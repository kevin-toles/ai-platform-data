{
  "metadata": {
    "title": "Architecture Patterns with Python",
    "author": "Bob Gregory & Harry Percival",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 497,
    "conversion_date": "2025-12-19T18:20:58.097962",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "Architecture Patterns with Python.pdf",
    "extraction_method": "Unstructured"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Domain Modeling",
      "start_page": 46,
      "end_page": 73,
      "detection_method": "regex_chapter_title",
      "content": "Figure 1-1. A placeholder illustration of our domain model\n\nWhat Is a Domain Model?\n\nIn the introduction, we used the term business logic layer to describe the central layer of a three-layered architecture. For the rest of the book, we’re going to use the term domain model instead. This is a term from the DDD community that does a better job of capturing our intended meaning (see the next sidebar for more on DDD).\n\nThe domain is a fancy way of saying the problem you’re trying to solve. Your authors currently work for an online retailer of furniture. Depending on which system you’re talking about, the domain might be\n\npurchasing and procurement, or product design, or logistics and delivery. Most programmers spend their days trying to improve or automate business processes; the domain is the set of activities that those processes support.\n\nA model is a map of a process or phenomenon that captures a useful property. Humans are exceptionally good at producing models of things in their heads. For example, when someone throws a ball toward you, you’re able to predict its movement almost unconsciously, because you have a model of the way objects move in space. Your model isn’t perfect by any means. Humans have terrible intuitions about how objects behave at near-light speeds or in a vacuum because\n\nour model was never designed to cover those cases. That doesn’t mean the model is wrong, but it does mean that some predictions fall outside of its domain.\n\nThe domain model is the mental map that business owners have of their businesses. All business people have these mental maps—they’re how humans think about complex processes.\n\nYou can tell when they’re navigating these maps because they use business speak. Jargon arises naturally among people who are collaborating on complex systems.\n\nImagine that you, our unfortunate reader, were suddenly transported light years away from Earth aboard an alien spaceship with your friends and family and had to figure out, from first principles, how to navigate home.\n\nIn your first few days, you might just push buttons randomly, but soon you’d learn which buttons did what, so that you could give one another instructions. “Press the red button near the flashing doohickey and then throw that big lever over by the radar gizmo,” you might say.\n\nWithin a couple of weeks, you’d become more precise as you adopted words to describe the ship’s functions: “Increase oxygen levels in cargo bay three” or “turn on the little thrusters.” After a few months, you’d have adopted language for entire complex processes: “Start landing sequence” or “prepare for warp.” This process would happen\n\nquite naturally, without any formal effort to build a shared glossary.\n\nTHIS IS NOT A DDD BOOK. YOU SHOULD READ A DDD BOOK.\n\n1\n\nDomain-driven design, or DDD, popularized the concept of domain modeling, and it’s been a hugely successful movement in transforming the way people design software by focusing on the core business domain. Many of the architecture patterns that we cover in this book—including Entity, Aggregate, Value Object (see Chapter 7), and Repository (in the next chapter)—come from the DDD tradition.\n\nIn a nutshell, DDD says that the most important thing about software is that it provides a useful model of a problem. If we get that model right, our software delivers value and makes new things possible.\n\nIf we get the model wrong, it becomes an obstacle to be worked around. In this book, we can show the basics of building a domain model, and building an architecture around it that leaves the model as free as possible from external constraints, so that it’s easy to evolve and change.\n\nBut there’s a lot more to DDD and to the processes, tools, and techniques for developing a domain model. We hope to give you a taste of it, though, and cannot encourage you enough to go on and read a proper DDD book:\n\nThe original “blue book,” Domain-Driven Design by Eric Evans (Addison-Wesley Professional)\n\nThe “red book,” Implementing Domain-Driven Design by Vaughn Vernon (Addison- Wesley Professional)\n\nSo it is in the mundane world of business. The terminology used by business stakeholders represents a distilled understanding of the domain model, where complex ideas and processes are boiled down to a single word or phrase.\n\nWhen we hear our business stakeholders using unfamiliar words, or using terms in a specific way, we should listen to understand the deeper meaning and encode their hard-won experience into our software.\n\nWe’re going to use a real-world domain model throughout this book, specifically a model from our current employment. MADE.com is a\n\nsuccessful furniture retailer. We source our furniture from manufacturers all over the world and sell it across Europe.\n\nWhen you buy a sofa or a coffee table, we have to figure out how best to get your goods from Poland or China or Vietnam and into your living room.\n\nAt a high level, we have separate systems that are responsible for buying stock, selling stock to customers, and shipping goods to customers. A system in the middle needs to coordinate the process by allocating stock to a customer’s orders; see Figure 1-2.\n\nFigure 1-2. Context diagram for the allocation service\n\nFor the purposes of this book, we’re imagining that the business\n\ndecides to implement an exciting new way of allocating stock. Until now, the business has been presenting stock and lead times based on\n\nwhat is physically available in the warehouse. If and when the warehouse runs out, a product is listed as “out of stock” until the next\n\nshipment arrives from the manufacturer.\n\nHere’s the innovation: if we have a system that can keep track of all our shipments and when they’re due to arrive, we can treat the goods\n\non those ships as real stock and part of our inventory, just with slightly\n\nlonger lead times. Fewer goods will appear to be out of stock, we’ll sell more, and the business can save money by keeping lower\n\ninventory in the domestic warehouse.\n\nBut allocating orders is no longer a trivial matter of decrementing a single quantity in the warehouse system. We need a more complex\n\nallocation mechanism. Time for some domain modeling.\n\nExploring the Domain Language\n\nUnderstanding the domain model takes time, and patience, and Post-it\n\nnotes. We have an initial conversation with our business experts and agree on a glossary and some rules for the first minimal version of the\n\ndomain model. Wherever possible, we ask for concrete examples to illustrate each rule.\n\nWe make sure to express those rules in the business jargon (the ubiquitous language in DDD terminology). We choose memorable\n\nidentifiers for our objects so that the examples are easier to talk about.\n\n“Some Notes on Allocation” shows some notes we might have taken while having a conversation with our domain experts about allocation.\n\nSOME NOTES ON ALLOCATION\n\nA product is identified by a SKU, pronounced “skew,” which is short for stock-keeping unit. Customers place orders. An order is identified by an order reference and comprises multiple order lines, where each line has a SKU and a quantity. For example:\n\n10 units of RED-CHAIR\n\n1 unit of TASTELESS-LAMP\n\nThe purchasing department orders small batches of stock. A batch of stock has a unique ID called a reference, a SKU, and a quantity.\n\nWe need to allocate order lines to batches. When we’ve allocated an order line to a batch, we will send stock from that specific batch to the customer’s delivery address. When we allocate x units of stock to a batch, the available quantity is reduced by x. For example:\n\nWe have a batch of 20 SMALL-TABLE, and we allocate an order line for 2 SMALL-TABLE.\n\nThe batch should have 18 SMALL-TABLE remaining.\n\nWe can’t allocate to a batch if the available quantity is less than the quantity of the order line. For example:\n\nWe have a batch of 1 BLUE-CUSHION, and an order line for 2 BLUE-CUSHION.\n\nWe should not be able to allocate the line to the batch.\n\nWe can’t allocate the same line twice. For example:\n\nWe have a batch of 10 BLUE-VASE, and we allocate an order line for 2 BLUE-VASE.\n\nIf we allocate the order line again to the same batch, the batch should still have an available quantity of 8.\n\nBatches have an ETA if they are currently shipping, or they may be in warehouse stock. We allocate to warehouse stock in preference to shipment batches. We allocate to shipment batches in order of which has the earliest ETA.\n\nUnit Testing Domain Models\n\nWe’re not going to show you how TDD works in this book, but we\n\nwant to show you how we would construct a model from this business conversation.\n\nEXERCISE FOR THE READER\n\nWhy not have a go at solving this problem yourself? Write a few unit tests to see if you can capture the essence of these business rules in nice, clean code.\n\nYou’ll find some placeholder unit tests on GitHub, but you could just start from scratch, or combine/rewrite them however you like.\n\nHere’s what one of our first tests might look like:\n\nA first test for allocation (test_batches.py)\n\ndef test_allocating_to_a_batch_reduces_the_available_quantity(): batch = Batch(\"batch-001\", \"SMALL-TABLE\", qty=20, eta=date.today()) line = OrderLine('order-ref', \"SMALL-TABLE\", 2)\n\nbatch.allocate(line)\n\nassert batch.available_quantity == 18\n\nThe name of our unit test describes the behavior that we want to see from the system, and the names of the classes and variables that we use\n\nare taken from the business jargon. We could show this code to our nontechnical coworkers, and they would agree that this correctly\n\ndescribes the behavior of the system.\n\nAnd here is a domain model that meets our requirements:\n\nFirst cut of a domain model for batches (model.py)\n\n@dataclass(frozen=True) class OrderLine: orderid: str sku: str qty: int\n\nclass Batch: def __init__( self, ref: str, sku: str, qty: int, eta: Optional[date] ): self.reference = ref self.sku = sku self.eta = eta self.available_quantity = qty\n\ndef allocate(self, line: OrderLine): self.available_quantity -= line.qty\n\nOrderLine is an immutable dataclass with no behavior.\n\n2\n\nWe’re not showing imports in most code listings, in an attempt to keep them clean. We’re hoping you can guess that this came via from dataclasses import dataclass; likewise, typing.Optional and datetime.date. If you want to double- check anything, you can see the full working code for each chapter in its branch (e.g., chapter_01_domain_model).\n\nType hints are still a matter of controversy in the Python world. For domain models, they can sometimes help to clarify or document what the expected arguments are, and people with IDEs are often grateful for them. You may decide the price paid in terms of readability is too high.\n\nOur implementation here is trivial: a Batch just wraps an integer available_quantity, and we decrement that value on allocation.\n\nWe’ve written quite a lot of code just to subtract one number from another, but we think that modeling our domain precisely will pay off.\n\nLet’s write some new failing tests:\n\nTesting logic for what we can allocate (test_batches.py)\n\ndef make_batch_and_line(sku, batch_qty, line_qty): return ( Batch(\"batch-001\", sku, batch_qty, eta=date.today()), OrderLine(\"order-123\", sku, line_qty) )\n\ndef test_can_allocate_if_available_greater_than_required(): large_batch, small_line = make_batch_and_line(\"ELEGANT-LAMP\", 20, 2) assert large_batch.can_allocate(small_line)\n\ndef test_cannot_allocate_if_available_smaller_than_required(): small_batch, large_line = make_batch_and_line(\"ELEGANT-LAMP\", 2, 20) assert small_batch.can_allocate(large_line) is False\n\ndef test_can_allocate_if_available_equal_to_required(): batch, line = make_batch_and_line(\"ELEGANT-LAMP\", 2, 2) assert batch.can_allocate(line)\n\ndef test_cannot_allocate_if_skus_do_not_match(): batch = Batch(\"batch-001\", \"UNCOMFORTABLE-CHAIR\", 100, eta=None) different_sku_line = OrderLine(\"order-123\", \"EXPENSIVE-TOASTER\", 10) assert batch.can_allocate(different_sku_line) is False\n\nThere’s nothing too unexpected here. We’ve refactored our test suite so that we don’t keep repeating the same lines of code to create a batch\n\nand a line for the same SKU; and we’ve written four simple tests for a new method can_allocate. Again, notice that the names we use\n\n3\n\nmirror the language of our domain experts, and the examples we\n\nagreed upon are directly written into code.\n\nWe can implement this straightforwardly, too, by writing the can_allocate method of Batch:\n\nA new method in the model (model.py)\n\ndef can_allocate(self, line: OrderLine) -> bool: return self.sku == line.sku and self.available_quantity >= line.qty\n\nSo far, we can manage the implementation by just incrementing and decrementing Batch.available_quantity, but as we get into deallocate() tests, we’ll be forced into a more intelligent solution:\n\nThis test is going to require a smarter model (test_batches.py)\n\ndef test_can_only_deallocate_allocated_lines(): batch, unallocated_line = make_batch_and_line(\"DECORATIVE-TRINKET\", 20, 2) batch.deallocate(unallocated_line) assert batch.available_quantity == 20\n\nIn this test, we’re asserting that deallocating a line from a batch has no effect unless the batch previously allocated the line. For this to work, our Batch needs to understand which lines have been allocated. Let’s look at the implementation:\n\nThe domain model now tracks allocations (model.py)\n\nclass Batch: def __init__( self, ref: str, sku: str, qty: int, eta: Optional[date] ): self.reference = ref\n\nself.sku = sku self.eta = eta self._purchased_quantity = qty self._allocations = set() # type: Set[OrderLine]\n\ndef allocate(self, line: OrderLine): if self.can_allocate(line): self._allocations.add(line)\n\ndef deallocate(self, line: OrderLine): if line in self._allocations: self._allocations.remove(line)\n\n@property def allocated_quantity(self) -> int: return sum(line.qty for line in self._allocations)\n\n@property def available_quantity(self) -> int: return self._purchased_quantity - self.allocated_quantity\n\ndef can_allocate(self, line: OrderLine) -> bool: return self.sku == line.sku and self.available_quantity >= line.qty\n\nFigure 1-3 shows the model in UML.\n\nFigure 1-3. Our model in UML\n\nNow we’re getting somewhere! A batch now keeps track of a set of allocated OrderLine objects. When we allocate, if we have enough\n\navailable quantity, we just add to the set. Our available_quantity is now a calculated property: purchased quantity minus allocated\n\nquantity.\n\nYes, there’s plenty more we could do. It’s a little disconcerting that both allocate() and deallocate() can fail silently, but we have the basics.\n\nIncidentally, using a set for ._allocations makes it simple for us to handle the last test, because items in a set are unique:\n\nLast batch test! (test_batches.py)\n\ndef test_allocation_is_idempotent(): batch, line = make_batch_and_line(\"ANGULAR-DESK\", 20, 2) batch.allocate(line) batch.allocate(line) assert batch.available_quantity == 18\n\nAt the moment, it’s probably a valid criticism to say that the domain model is too trivial to bother with DDD (or even object orientation!). In real life, any number of business rules and edge cases crop up: customers can ask for delivery on specific future dates, which means\n\nwe might not want to allocate them to the earliest batch. Some SKUs aren’t in batches, but ordered on demand directly from suppliers, so they have different logic. Depending on the customer’s location, we can allocate to only a subset of warehouses and shipments that are in\n\ntheir region—except for some SKUs we’re happy to deliver from a warehouse in a different region if we’re out of stock in the home region. And so on. A real business in the real world knows how to pile on complexity faster than we can show on the page!\n\nBut taking this simple domain model as a placeholder for something more complex, we’re going to extend our simple domain model in the rest of the book and plug it into the real world of APIs and databases\n\nand spreadsheets. We’ll see how sticking rigidly to our principles of encapsulation and careful layering will help us to avoid a ball of mud.\n\nMORE TYPES FOR MORE TYPE HINTS\n\nIf you really want to go to town with type hints, you could go so far as wrapping primitive types by using typing.NewType:\n\nJust taking it way too far, Bob\n\nfrom dataclasses import dataclass from typing import NewType\n\nQuantity = NewType(\"Quantity\", int) Sku = NewType(\"Sku\", str) Reference = NewType(\"Reference\", str) ...\n\nclass Batch: def __init__(self, ref: Reference, sku: Sku, qty: Quantity): self.sku = sku self.reference = ref self._purchased_quantity = qty\n\nThat would allow our type checker to make sure that we don’t pass a Sku where a Reference is expected, for example.\n\n4 Whether you think this is wonderful or appalling is a matter of debate.\n\nDataclasses Are Great for Value Objects\n\nWe’ve used line liberally in the previous code listings, but what is a line? In our business language, an order has multiple line items, where each line has a SKU and a quantity. We can imagine that a simple\n\nYAML file containing order information might look like this:\n\nOrder info as YAML\n\nOrder_reference: 12345 Lines: - sku: RED-CHAIR qty: 25 - sku: BLU-CHAIR qty: 25 - sku: GRN-CHAIR qty: 25\n\nNotice that while an order has a reference that uniquely identifies it, a line does not. (Even if we add the order reference to the OrderLine class, it’s not something that uniquely identifies the line itself.)\n\nWhenever we have a business concept that has data but no identity, we often choose to represent it using the Value Object pattern. A value object is any domain object that is uniquely identified by the data it holds; we usually make them immutable:\n\nOrderLine is a value object\n\n@dataclass(frozen=True) class OrderLine: orderid: OrderReference sku: ProductReference qty: Quantity\n\nOne of the nice things that dataclasses (or namedtuples) give us is\n\nvalue equality, which is the fancy way of saying, “Two lines with the same orderid, sku, and qty are equal.”\n\nMore examples of value objects\n\nfrom dataclasses import dataclass from typing import NamedTuple from collections import namedtuple\n\n@dataclass(frozen=True) class Name: first_name: str surname: str\n\nclass Money(NamedTuple): currency: str value: int\n\nLine = namedtuple('Line', ['sku', 'qty'])\n\ndef test_equality(): assert Money('gbp', 10) == Money('gbp', 10) assert Name('Harry', 'Percival') != Name('Bob', 'Gregory') assert Line('RED-CHAIR', 5) == Line('RED-CHAIR', 5)\n\nThese value objects match our real-world intuition about how their values work. It doesn’t matter which £10 note we’re talking about, because they all have the same value. Likewise, two names are equal\n\nif both the first and last names match; and two lines are equivalent if they have the same customer order, product code, and quantity. We can still have complex behavior on a value object, though. In fact, it’s common to support operations on values; for example, mathematical\n\noperators:\n\nMath with value objects\n\nfiver = Money('gbp', 5) tenner = Money('gbp', 10)\n\ndef can_add_money_values_for_the_same_currency(): assert fiver + fiver == tenner\n\ndef can_subtract_money_values(): assert tenner - fiver == fiver\n\ndef adding_different_currencies_fails(): with pytest.raises(ValueError): Money('usd', 10) + Money('gbp', 10)\n\ndef can_multiply_money_by_a_number(): assert fiver * 5 == Money('gbp', 25)\n\ndef multiplying_two_money_values_is_an_error(): with pytest.raises(TypeError): tenner * fiver\n\nValue Objects and Entities\n\nAn order line is uniquely identified by its order ID, SKU, and quantity; if we change one of those values, we now have a new line. That’s the definition of a value object: any object that is identified only by its\n\ndata and doesn’t have a long-lived identity. What about a batch, though? That is identified by a reference.\n\nWe use the term entity to describe a domain object that has long-lived identity. On the previous page, we introduced a Name class as a value object. If we take the name Harry Percival and change one letter, we have the new Name object Barry Percival.\n\nIt should be clear that Harry Percival is not equal to Barry Percival:\n\nA name itself cannot change…\n\ndef test_name_equality(): assert Name(\"Harry\", \"Percival\") != Name(\"Barry\", \"Percival\")\n\nBut what about Harry as a person? People do change their names, and their marital status, and even their gender, but we continue to recognize\n\nthem as the same individual. That’s because humans, unlike names, have a persistent identity:\n\nBut a person can!\n\nclass Person:\n\ndef __init__(self, name: Name): self.name = name\n\ndef test_barry_is_harry(): harry = Person(Name(\"Harry\", \"Percival\")) barry = harry\n\nbarry.name = Name(\"Barry\", \"Percival\")\n\nassert harry is barry and barry is harry\n\nEntities, unlike values, have identity equality. We can change their values, and they are still recognizably the same thing. Batches, in our example, are entities. We can allocate lines to a batch, or change the\n\ndate that we expect it to arrive, and it will still be the same entity.\n\nWe usually make this explicit in code by implementing equality operators on entities:\n\nImplementing equality operators (model.py)\n\nclass Batch: ...\n\ndef __eq__(self, other): if not isinstance(other, Batch): return False return other.reference == self.reference\n\ndef __hash__(self): return hash(self.reference)\n\nPython’s __eq__ magic method defines the behavior of the class for 5 the == operator.\n\nFor both entity and value objects, it’s also worth thinking through how __hash__ will work. It’s the magic method Python uses to control the behavior of objects when you add them to sets or use them as dict keys; you can find more info in the Python docs.\n\nFor value objects, the hash should be based on all the value attributes,\n\nand we should ensure that the objects are immutable. We get this for free by specifying @frozen=True on the dataclass.\n\nFor entities, the simplest option is to say that the hash is None, meaning that the object is not hashable and cannot, for example, be used in a\n\nset. If for some reason you decide you really do want to use set or dict operations with entities, the hash should be based on the attribute(s), such as .reference, that defines the entity’s unique identity over time. You should also try to somehow make that attribute read-only.\n\nWARNING\n\nThis is tricky territory; you shouldn’t modify __hash__ without also modifying __eq__. If you’re not sure what you’re doing, further reading is suggested. “Python Hashes and Equality” by our tech reviewer Hynek Schlawack is a good place to start.\n\nNot Everything Has to Be an Object: A Domain Service Function\n\nWe’ve made a model to represent batches, but what we actually need to do is allocate order lines against a specific set of batches that\n\nrepresent all our stock.\n\nSometimes, it just isn’t a thing.\n\n—Eric Evans, Domain-Driven Design\n\nEvans discusses the idea of Domain Service operations that don’t have a natural home in an entity or value object. A thing that allocates an\n\n6\n\norder line, given a set of batches, sounds a lot like a function, and we can take advantage of the fact that Python is a multiparadigm language and just make it a function.\n\nLet’s see how we might test-drive such a function:\n\nTesting our domain service (test_allocate.py)\n\ndef test_prefers_current_stock_batches_to_shipments(): in_stock_batch = Batch(\"in-stock-batch\", \"RETRO-CLOCK\", 100, eta=None) shipment_batch = Batch(\"shipment-batch\", \"RETRO-CLOCK\", 100, eta=tomorrow) line = OrderLine(\"oref\", \"RETRO-CLOCK\", 10)\n\nallocate(line, [in_stock_batch, shipment_batch])\n\nassert in_stock_batch.available_quantity == 90 assert shipment_batch.available_quantity == 100\n\ndef test_prefers_earlier_batches(): earliest = Batch(\"speedy-batch\", \"MINIMALIST-SPOON\", 100, eta=today) medium = Batch(\"normal-batch\", \"MINIMALIST-SPOON\", 100, eta=tomorrow) latest = Batch(\"slow-batch\", \"MINIMALIST-SPOON\", 100, eta=later)\n\nline = OrderLine(\"order1\", \"MINIMALIST-SPOON\", 10)\n\nallocate(line, [medium, earliest, latest])\n\nassert earliest.available_quantity == 90 assert medium.available_quantity == 100 assert latest.available_quantity == 100\n\ndef test_returns_allocated_batch_ref(): in_stock_batch = Batch(\"in-stock-batch-ref\", \"HIGHBROW-POSTER\", 100, eta=None) shipment_batch = Batch(\"shipment-batch-ref\", \"HIGHBROW-POSTER\", 100, eta=tomorrow) line = OrderLine(\"oref\", \"HIGHBROW-POSTER\", 10) allocation = allocate(line, [in_stock_batch, shipment_batch]) assert allocation == in_stock_batch.reference\n\nAnd our service might look like this:\n\nA standalone function for our domain service (model.py)\n\ndef allocate(line: OrderLine, batches: List[Batch]) -> str: batch = next( b for b in sorted(batches) if b.can_allocate(line) ) batch.allocate(line) return batch.reference\n\nPython’s Magic Methods Let Us Use Our Models with Idiomatic Python\n\nYou may or may not like the use of next() in the preceding code, but we’re pretty sure you’ll agree that being able to use sorted() on our list of batches is nice, idiomatic Python.\n\nTo make it work, we implement __gt__ on our domain model:\n\nMagic methods can express domain semantics (model.py)\n\nclass Batch: ...\n\ndef __gt__(self, other): if self.eta is None: return False if other.eta is None: return True return self.eta > other.eta\n\nThat’s lovely.\n\nExceptions Can Express Domain Concepts Too\n\nWe have one final concept to cover: exceptions can be used to express domain concepts too. In our conversations with domain experts, we’ve learned about the possibility that an order cannot be allocated because we are out of stock, and we can capture that by using a domain\n\nexception:\n\nTesting out-of-stock exception (test_allocate.py)\n\ndef test_raises_out_of_stock_exception_if_cannot_allocate(): batch = Batch('batch1', 'SMALL-FORK', 10, eta=today) allocate(OrderLine('order1', 'SMALL-FORK', 10), [batch])\n\nwith pytest.raises(OutOfStock, match='SMALL-FORK'): allocate(OrderLine('order2', 'SMALL-FORK', 1), [batch])\n\nDOMAIN MODELING RECAP\n\nDomain modeling\n\nThis is the part of your code that is closest to the business, the most likely to change, and the place where you deliver the most value to the business. Make it easy to understand and modify.\n\nDistinguish entities from value objects\n\nA value object is defined by its attributes. It’s usually best implemented as an immutable type. If you change an attribute on a Value Object, it represents a different object. In contrast, an entity has attributes that may vary over time and it will still be the same entity. It’s important to define what does uniquely identify an entity (usually some sort of name or reference field).\n\nNot everything has to be an object\n\nPython is a multiparadigm language, so let the “verbs” in your code be functions. For every FooManager, BarBuilder, or BazFactory, there’s often a more expressive and readable manage_foo(), build_bar(), or get_baz() waiting to happen.\n\nThis is the time to apply your best OO design principles\n\nRevisit the SOLID principles and all the other good heuristics like “has a versus is-a,” “prefer composition over inheritance,” and so on.\n\nYou’ll also want to think about consistency boundaries and aggregates\n\nBut that’s a topic for Chapter 7.\n\nWe won’t bore you too much with the implementation, but the main thing to note is that we take care in naming our exceptions in the ubiquitous language, just as we do our entities, value objects, and services:\n\nRaising a domain exception (model.py)\n\nclass OutOfStock(Exception): pass\n\ndef allocate(line: OrderLine, batches: List[Batch]) -> str: try: batch = next( ...\n\nexcept StopIteration: raise OutOfStock(f'Out of stock for sku {line.sku}')\n\nFigure 1-4 is a visual representation of where we’ve ended up.\n\nFigure 1-4. Our domain model at the end of the chapter\n\nThat’ll probably do for now! We have a domain service that we can\n\nuse for our first use case. But first we’ll need a database…\n\n1 DDD did not originate domain modeling. Eric Evans refers to the 2002 book Object\n\nDesign by Rebecca Wirfs-Brock and Alan McKean (Addison-Wesley Professional), which introduced responsibility-driven design, of which DDD is a special case dealing with the domain. But even that is too late, and OO enthusiasts will tell you to look further back to Ivar Jacobson and Grady Booch; the term has been around since the mid-1980s.\n\n2 In previous Python versions, we might have used a namedtuple. You could also check out\n\nHynek Schlawack’s excellent attrs.\n\n3 Or perhaps you think there’s not enough code? What about some sort of check that the SKU in the OrderLine matches Batch.sku? We saved some thoughts on validation for Appendix E.\n\n4 It is appalling. Please, please don’t do this. —Harry\n\n5 The __eq__ method is pronounced “dunder-EQ.” By some, at least.\n\n6 Domain services are not the same thing as the services from the service layer, although\n\nthey are often closely related. A domain service represents a business concept or process, whereas a service-layer service represents a use case for your application. Often the service layer will call a domain service.\n\nChapter 2. Repository Pattern\n\nIt’s time to make good on our promise to use the dependency inversion principle as a way of decoupling our core logic from infrastructural concerns.\n\nWe’ll introduce the Repository pattern, a simplifying abstraction over\n\ndata storage, allowing us to decouple our model layer from the data\n\nlayer. We’ll present a concrete example of how this simplifying\n\nabstraction makes our system more testable by hiding the complexities of the database.\n\nFigure 2-1 shows a little preview of what we’re going to build: a Repository object that sits between our domain model and the database.\n\nFigure 2-1. Before and after the Repository pattern\n\nTIP\n\nThe code for this chapter is in the chapter_02_repository branch on GitHub.\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_02_repository # or to code along, checkout the previous chapter: git checkout chapter_01_domain_model\n\nPersisting Our Domain Model\n\nIn Chapter 1 we built a simple domain model that can allocate orders to batches of stock. It’s easy for us to write tests against this code because there aren’t any dependencies or infrastructure to set up. If we needed to run a database or an API and create test data, our tests would be harder to write and maintain.\n\nSadly, at some point we’ll need to put our perfect little model in the hands of users and contend with the real world of spreadsheets and web browsers and race conditions. For the next few chapters we’re going to look at how we can connect our idealized domain model to external state.\n\nWe expect to be working in an agile manner, so our priority is to get to a minimum viable product as quickly as possible. In our case, that’s going to be a web API. In a real project, you might dive straight in\n\nwith some end-to-end tests and start plugging in a web framework, test-driving things outside-in.\n\nBut we know that, no matter what, we’re going to need some form of persistent storage, and this is a textbook, so we can allow ourselves a tiny bit more bottom-up development and start to think about storage and databases.\n\nSome Pseudocode: What Are We Going to Need?\n\nWhen we build our first API endpoint, we know we’re going to have some code that looks more or less like the following.\n\nWhat our first API endpoint will look like\n\n@flask.route.gubbins def allocate_endpoint(): # extract order line from request line = OrderLine(request.params, ...) # load all batches from the DB batches = ... # call our domain service allocate(line, batches) # then save the allocation back to the database somehow return 201\n\nNOTE\n\nWe’ve used Flask because it’s lightweight, but you don’t need to be a Flask user to understand this book. In fact, we’ll show you how to make your choice of framework a minor detail.\n\nWe’ll need a way to retrieve batch info from the database and instantiate our domain model objects from it, and we’ll also need a",
      "page_number": 46
    },
    {
      "number": 2,
      "title": "Repository Pattern",
      "start_page": 74,
      "end_page": 102,
      "detection_method": "regex_chapter_title",
      "content": "way of saving them back to the database.\n\nWhat? Oh, “gubbins” is a British word for “stuff.” You can just ignore that. It’s pseudocode, OK?\n\nApplying the DIP to Data Access\n\nAs mentioned in the introduction, a layered architecture is a common approach to structuring a system that has a UI, some logic, and a database (see Figure 2-2).\n\nFigure 2-2. Layered architecture\n\nDjango’s Model-View-Template structure is closely related, as is Model-View-Controller (MVC). In any case, the aim is to keep the layers separate (which is a good thing), and to have each layer depend only on the one below it.\n\nBut we want our domain model to have no dependencies whatsoever. We don’t want infrastructure concerns bleeding over into our domain model and slowing our unit tests or our ability to make changes.\n\nInstead, as discussed in the introduction, we’ll think of our model as being on the “inside,” and dependencies flowing inward to it; this is what people sometimes call onion architecture (see Figure 2-3).\n\n1\n\nFigure 2-3. Onion architecture\n\nIS THIS PORTS AND ADAPTERS?\n\nIf you’ve been reading about architectural patterns, you may be asking yourself questions like this:\n\nIs this ports and adapters? Or is it hexagonal architecture? Is that the same as onion architecture? What about the clean architecture? What’s a port, and what’s an adapter? Why do you people have so many words for the same thing?\n\nAlthough some people like to nitpick over the differences, all these are pretty much names for the same thing, and they all boil down to the dependency inversion principle: high-level modules (the 2 domain) should not depend on low-level ones (the infrastructure).\n\nWe’ll get into some of the nitty-gritty around “depending on abstractions,” and whether there is a Pythonic equivalent of interfaces, later in the book. See also “What Is a Port and What Is an Adapter, in Python?”.\n\nReminder: Our Model\n\nLet’s remind ourselves of our domain model (see Figure 2-4): an allocation is the concept of linking an OrderLine to a Batch. We’re storing the allocations as a collection on our Batch object.\n\nFigure 2-4. Our model\n\nLet’s see how we might translate this to a relational database.\n\nThe “Normal” ORM Way: Model Depends on ORM\n\nThese days, it’s unlikely that your team members are hand-rolling their own SQL queries. Instead, you’re almost certainly using some kind of\n\nframework to generate SQL for you based on your model objects.\n\nThese frameworks are called object-relational mappers (ORMs) because they exist to bridge the conceptual gap between the world of\n\nobjects and domain modeling and the world of databases and relational algebra.\n\nThe most important thing an ORM gives us is persistence ignorance:\n\nthe idea that our fancy domain model doesn’t need to know anything\n\nabout how data is loaded or persisted. This helps keep our domain 3 clean of direct dependencies on particular database technologies.\n\nBut if you follow the typical SQLAlchemy tutorial, you’ll end up with\n\nsomething like this:\n\nSQLAlchemy “declarative” syntax, model depends on ORM (orm.py)\n\nfrom sqlalchemy import Column, ForeignKey, Integer, String from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import relationship\n\nBase = declarative_base()\n\nclass Order(Base): id = Column(Integer, primary_key=True)\n\nclass OrderLine(Base): id = Column(Integer, primary_key=True) sku = Column(String(250)) qty = Integer(String(250)) order_id = Column(Integer, ForeignKey('order.id')) order = relationship(Order)\n\nclass Allocation(Base): ...\n\nYou don’t need to understand SQLAlchemy to see that our pristine model is now full of dependencies on the ORM and is starting to look\n\nugly as hell besides. Can we really say this model is ignorant of the database? How can it be separate from storage concerns when our\n\nmodel properties are directly coupled to database columns?\n\nDJANGO’S ORM IS ESSENTIALLY THE SAME, BUT MORE RESTRICTIVE\n\nIf you’re more used to Django, the preceding “declarative” SQLAlchemy snippet translates to something like this:\n\nDjango ORM example\n\nclass Order(models.Model): pass\n\nclass OrderLine(models.Model): sku = models.CharField(max_length=255) qty = models.IntegerField() order = models.ForeignKey(Order)\n\nclass Allocation(models.Model): ...\n\nThe point is the same—our model classes inherit directly from ORM classes, so our model depends on the ORM. We want it to be the other way around.\n\nDjango doesn’t provide an equivalent for SQLAlchemy’s classical mapper, but see Appendix D for examples of how to apply dependency inversion and the Repository pattern to Django.\n\nInverting the Dependency: ORM Depends on Model\n\nWell, thankfully, that’s not the only way to use SQLAlchemy. The\n\nalternative is to define your schema separately, and to define an explicit mapper for how to convert between the schema and our\n\ndomain model, what SQLAlchemy calls a classical mapping:\n\nExplicit ORM mapping with SQLAlchemy Table objects (orm.py)\n\nfrom sqlalchemy.orm import mapper, relationship\n\nimport model\n\nmetadata = MetaData()\n\norder_lines = Table( 'order_lines', metadata, Column('id', Integer, primary_key=True, autoincrement=True), Column('sku', String(255)), Column('qty', Integer, nullable=False), Column('orderid', String(255)), )\n\n...\n\ndef start_mappers(): lines_mapper = mapper(model.OrderLine, order_lines)\n\nThe ORM imports (or “depends on” or “knows about”) the domain model, and not the other way around.\n\nWe define our database tables and columns by using SQLAlchemy’s abstractions.\n\n4\n\nWhen we call the mapper function, SQLAlchemy does its magic to bind our domain model classes to the various tables we’ve defined.\n\nThe end result will be that, if we call start_mappers, we will be able to easily load and save domain model instances from and to the\n\ndatabase. But if we never call that function, our domain model classes stay blissfully unaware of the database.\n\nThis gives us all the benefits of SQLAlchemy, including the ability to use alembic for migrations, and the ability to transparently query using our domain classes, as we’ll see.\n\nWhen you’re first trying to build your ORM config, it can be useful to write tests for it, as in the following example:\n\nTesting the ORM directly (throwaway tests) (test_orm.py)\n\ndef test_orderline_mapper_can_load_lines(session): session.execute( 'INSERT INTO order_lines (orderid, sku, qty) VALUES ' '(\"order1\", \"RED-CHAIR\", 12),' '(\"order1\", \"RED-TABLE\", 13),' '(\"order2\", \"BLUE-LIPSTICK\", 14)' ) expected = [ model.OrderLine(\"order1\", \"RED-CHAIR\", 12), model.OrderLine(\"order1\", \"RED-TABLE\", 13), model.OrderLine(\"order2\", \"BLUE-LIPSTICK\", 14), ] assert session.query(model.OrderLine).all() == expected\n\ndef test_orderline_mapper_can_save_lines(session): new_line = model.OrderLine(\"order1\", \"DECORATIVE-WIDGET\", 12) session.add(new_line) session.commit()\n\nrows = list(session.execute('SELECT orderid, sku, qty FROM \"order_lines\"')) assert rows == [(\"order1\", \"DECORATIVE-WIDGET\", 12)]\n\nIf you haven’t used pytest, the session argument to this test needs explaining. You don’t need to worry about the details of pytest or its fixtures for the purposes of this book, but the short explanation is that you can define common dependencies for your tests as “fixtures,” and pytest will inject them to the tests that need them by looking at their function arguments. In this case, it’s a SQLAlchemy database session.\n\nYou probably wouldn’t keep these tests around—as you’ll see shortly,\n\nonce you’ve taken the step of inverting the dependency of ORM and domain model, it’s only a small additional step to implement another\n\nabstraction called the Repository pattern, which will be easier to write\n\ntests against and will provide a simple interface for faking out later in\n\ntests.\n\nBut we’ve already achieved our objective of inverting the traditional dependency: the domain model stays “pure” and free from\n\ninfrastructure concerns. We could throw away SQLAlchemy and use a different ORM, or a totally different persistence system, and the\n\ndomain model doesn’t need to change at all.\n\nDepending on what you’re doing in your domain model, and especially if you stray far from the OO paradigm, you may find it increasingly\n\nhard to get the ORM to produce the exact behavior you need, and you may need to modify your domain model. As so often happens with\n\n5\n\narchitectural decisions, you’ll need to consider a trade-off. As the Zen\n\nof Python says, “Practicality beats purity!”\n\nAt this point, though, our API endpoint might look something like the following, and we could get it to work just fine:\n\nUsing SQLAlchemy directly in our API endpoint\n\n@flask.route.gubbins def allocate_endpoint(): session = start_session()\n\n# extract order line from request line = OrderLine( request.json['orderid'], request.json['sku'], request.json['qty'], )\n\n# load all batches from the DB\n\nbatches = session.query(Batch).all()\n\n# call our domain service allocate(line, batches)\n\n# save the allocation back to the database session.commit()\n\nreturn 201\n\nIntroducing the Repository Pattern\n\nThe Repository pattern is an abstraction over persistent storage. It\n\nhides the boring details of data access by pretending that all of our data is in memory.\n\nIf we had infinite memory in our laptops, we’d have no need for clumsy databases. Instead, we could just use our objects whenever we liked. What would that look like?\n\nYou have to get your data from somewhere\n\nimport all_my_data\n\ndef create_a_batch(): batch = Batch(...) all_my_data.batches.add(batch)\n\ndef modify_a_batch(batch_id, new_quantity): batch = all_my_data.batches.get(batch_id) batch.change_initial_quantity(new_quantity)\n\nEven though our objects are in memory, we need to put them somewhere so we can find them again. Our in-memory data would let\n\nus add new objects, just like a list or a set. Because the objects are in\n\nmemory, we never need to call a .save() method; we just fetch the object we care about and modify it in memory.\n\nThe Repository in the Abstract\n\nThe simplest repository has just two methods: add() to put a new item in the repository, and get() to return a previously added item. We stick rigidly to using these methods for data access in our domain and\n\n6\n\nour service layer. This self-imposed simplicity stops us from coupling our domain model to the database.\n\nHere’s what an abstract base class (ABC) for our repository would\n\nlook like:\n\nThe simplest possible repository (repository.py)\n\nclass AbstractRepository(abc.ABC):\n\n@abc.abstractmethod def add(self, batch: model.Batch): raise NotImplementedError\n\n@abc.abstractmethod def get(self, reference) -> model.Batch: raise NotImplementedError\n\nPython tip: @abc.abstractmethod is one of the only things that makes ABCs actually “work” in Python. Python will refuse to let you instantiate a class that does not implement all the abstractmethods defined in its parent class.\n\n7\n\nraise NotImplementedError is nice, but it’s neither necessary nor sufficient. In fact, your abstract methods can have real behavior that subclasses can call out to, if you really want.\n\nABSTRACT BASE CLASSES, DUCK TYPING, AND PROTOCOLS\n\nWe’re using abstract base classes in this book for didactic reasons: we hope they help explain what the interface of the repository abstraction is.\n\nIn real life, we’ve sometimes found ourselves deleting ABCs from our production code, because Python makes it too easy to ignore them, and they end up unmaintained and, at worst, misleading. In practice we often just rely on Python’s duck typing to enable abstractions. To a Pythonista, a repository is any object that has add(thing) and get(id) methods.\n\nAn alternative to look into is PEP 544 protocols. These give you typing without the possibility of inheritance, which “prefer composition over inheritance” fans will particularly like.\n\nWhat Is the Trade-Off?\n\nYou know they say economists know the price of everything and the value of nothing? Well, programmers know the benefits of everything and the trade-offs of nothing.\n\n—Rich Hickey\n\nWhenever we introduce an architectural pattern in this book, we’ll always ask, “What do we get for this? And what does it cost us?”\n\nUsually, at the very least, we’ll be introducing an extra layer of abstraction, and although we may hope it will reduce complexity overall, it does add complexity locally, and it has a cost in terms of the\n\nraw numbers of moving parts and ongoing maintenance.\n\nThe Repository pattern is probably one of the easiest choices in the book, though, if you’re already heading down the DDD and\n\ndependency inversion route. As far as our code is concerned, we’re really just swapping the SQLAlchemy abstraction (session.query(Batch)) for a different one (batches_repo.get) that we designed.\n\nWe will have to write a few lines of code in our repository class each time we add a new domain object that we want to retrieve, but in\n\nreturn we get a simple abstraction over our storage layer, which we control. The Repository pattern would make it easy to make fundamental changes to the way we store things (see Appendix C), and as we’ll see, it is easy to fake out for unit tests.\n\nIn addition, the Repository pattern is so common in the DDD world that, if you do collaborate with programmers who have come to Python from the Java and C# worlds, they’re likely to recognize it. Figure 2-5\n\nillustrates the pattern.\n\nFigure 2-5. Repository pattern\n\nAs always, we start with a test. This would probably be classified as an integration test, since we’re checking that our code (the repository)\n\nis correctly integrated with the database; hence, the tests tend to mix raw SQL with calls and assertions on our own code.\n\nTIP\n\nUnlike the ORM tests from earlier, these tests are good candidates for staying part of your codebase longer term, particularly if any parts of your domain model mean the object-relational map is nontrivial.\n\nRepository test for saving an object (test_repository.py)\n\ndef test_repository_can_save_a_batch(session): batch = model.Batch(\"batch1\", \"RUSTY-SOAPDISH\", 100, eta=None)\n\nrepo = repository.SqlAlchemyRepository(session) repo.add(batch) session.commit()\n\nrows = list(session.execute( 'SELECT reference, sku, _purchased_quantity, eta FROM \"batches\"' )) assert rows == [(\"batch1\", \"RUSTY-SOAPDISH\", 100, None)]\n\nrepo.add() is the method under test here.\n\nWe keep the .commit() outside of the repository and make it the responsibility of the caller. There are pros and cons for this; some of our reasons will become clearer when we get to Chapter 6.\n\nWe use the raw SQL to verify that the right data has been saved.\n\nThe next test involves retrieving batches and allocations, so it’s more\n\ncomplex:\n\nRepository test for retrieving a complex object (test_repository.py)\n\ndef insert_order_line(session): session.execute( 'INSERT INTO order_lines (orderid, sku, qty)' ' VALUES (\"order1\", \"GENERIC-SOFA\", 12)' ) [[orderline_id]] = session.execute( 'SELECT id FROM order_lines WHERE orderid=:orderid AND sku=:sku', dict(orderid=\"order1\", sku=\"GENERIC-SOFA\") ) return orderline_id\n\ndef insert_batch(session, batch_id): ...\n\ndef test_repository_can_retrieve_a_batch_with_allocations(session): orderline_id = insert_order_line(session) batch1_id = insert_batch(session, \"batch1\") insert_batch(session, \"batch2\") insert_allocation(session, orderline_id, batch1_id)\n\nrepo = repository.SqlAlchemyRepository(session) retrieved = repo.get(\"batch1\")\n\nexpected = model.Batch(\"batch1\", \"GENERIC-SOFA\", 100, eta=None) assert retrieved == expected # Batch.__eq__ only compares reference assert retrieved.sku == expected.sku assert retrieved._purchased_quantity == expected._purchased_quantity assert retrieved._allocations == { model.OrderLine(\"order1\", \"GENERIC-SOFA\", 12), }\n\nThis tests the read side, so the raw SQL is preparing data to be read by the repo.get().\n\nWe’ll spare you the details of insert_batch and insert_allocation; the point is to create a couple of batches, and, for the batch we’re interested in, to have one existing order line allocated to it.\n\nAnd that’s what we verify here. The first assert == checks that the types match, and that the reference is the same (because, as you remember, Batch is an entity, and we have a custom eq for it).\n\nSo we also explicitly check on its major attributes, including ._allocations, which is a Python set of OrderLine value objects.\n\nWhether or not you painstakingly write tests for every model is a judgment call. Once you have one class tested for create/modify/save,\n\nyou might be happy to go on and do the others with a minimal round- trip test, or even nothing at all, if they all follow a similar pattern. In our case, the ORM config that sets up the ._allocations set is a little complex, so it merited a specific test.\n\nYou end up with something like this:\n\nA typical repository (repository.py)\n\nclass SqlAlchemyRepository(AbstractRepository):\n\ndef __init__(self, session): self.session = session\n\ndef add(self, batch): self.session.add(batch)\n\ndef get(self, reference): return self.session.query(model.Batch).filter_by(reference=reference).one()\n\ndef list(self): return self.session.query(model.Batch).all()\n\nAnd now our Flask endpoint might look something like the following:\n\nUsing our repository directly in our API endpoint\n\n@flask.route.gubbins def allocate_endpoint(): batches = SqlAlchemyRepository.list() lines = [ OrderLine(l['orderid'], l['sku'], l['qty']) for l in request.params... ] allocate(lines, batches)\n\nsession.commit() return 201\n\nEXERCISE FOR THE READER\n\nWe bumped into a friend at a DDD conference the other day who said, “I haven’t used an ORM in 10 years.” The Repository pattern and an ORM both act as abstractions in front of raw SQL, so using one behind the other isn’t really necessary. Why not have a go at implementing our repository without using the ORM? You’ll find the code on GitHub.\n\nWe’ve left the repository tests, but figuring out what SQL to write is up to you. Perhaps it’ll be harder than you think; perhaps it’ll be easier. But the nice thing is, the rest of your application just doesn’t care.\n\nBuilding a Fake Repository for Tests Is Now Trivial!\n\nHere’s one of the biggest benefits of the Repository pattern:\n\nA simple fake repository using a set (repository.py)\n\nclass FakeRepository(AbstractRepository):\n\ndef __init__(self, batches): self._batches = set(batches)\n\ndef add(self, batch): self._batches.add(batch)\n\ndef get(self, reference): return next(b for b in self._batches if b.reference == reference)\n\ndef list(self): return list(self._batches)\n\nBecause it’s a simple wrapper around a set, all the methods are one- liners.\n\nUsing a fake repo in tests is really easy, and we have a simple abstraction that’s easy to use and reason about:\n\nExample usage of fake repository (test_api.py)\n\nfake_repo = FakeRepository([batch1, batch2, batch3])\n\nYou’ll see this fake in action in the next chapter.\n\nTIP\n\nBuilding fakes for your abstractions is an excellent way to get design feedback: if it’s hard to fake, the abstraction is probably too complicated.\n\nWhat Is a Port and What Is an Adapter, in Python?\n\nWe don’t want to dwell on the terminology too much here because the main thing we want to focus on is dependency inversion, and the\n\nspecifics of the technique you use don’t matter too much. Also, we’re aware that different people use slightly different definitions.\n\nPorts and adapters came out of the OO world, and the definition we\n\nhold onto is that the port is the interface between our application and whatever it is we wish to abstract away, and the adapter is the implementation behind that interface or abstraction.\n\nNow Python doesn’t have interfaces per se, so although it’s usually easy to identify an adapter, defining the port can be harder. If you’re\n\nusing an abstract base class, that’s the port. If not, the port is just the\n\nduck type that your adapters conform to and that your core application expects—the function and method names in use, and their argument names and types.\n\nConcretely, in this chapter, AbstractRepository is the port, and SqlAlchemyRepository and FakeRepository are the adapters.\n\nWrap-Up\n\nBearing the Rich Hickey quote in mind, in each chapter we summarize the costs and benefits of each architectural pattern we introduce. We want to be clear that we’re not saying every single application needs\n\nto be built this way; only sometimes does the complexity of the app and domain make it worth investing the time and effort in adding these extra layers of indirection.\n\nWith that in mind, Table 2-1 shows some of the pros and cons of the Repository pattern and our persistence-ignorant model.\n\nTable 2-1. Repository pattern and persistence ignorance: the trade-offs\n\nPros\n\nCons\n\nPros\n\nWe have a simple interface between persistent storage and our domain model.\n\nIt’s easy to make a fake version of the repository for unit testing, or to swap out different storage solutions, because we’ve fully decoupled the model from infrastructure concerns.\n\nWriting the domain model before thinking about persistence helps us focus on the business problem at hand. If we ever want to radically change our approach, we can do that in our model, without needing to worry about foreign keys or migrations until later.\n\nOur database schema is really simple because we have complete control over how we map our objects to tables.\n\nCons\n\nAn ORM already buys you some decoupling. Changing foreign keys might be hard, but it should be pretty easy to swap between MySQL and Postgres if you ever need to.\n\nMaintaining ORM mappings by hand requires extra work and extra code.\n\nAny extra layer of indirection always increases maintenance costs and adds a “WTF factor” for Python programmers who’ve never seen the Repository pattern before.\n\nFigure 2-6 shows the basic thesis: yes, for simple cases, a decoupled domain model is harder work than a simple ORM/ActiveRecord pattern.\n\n8\n\nTIP\n\nIf your app is just a simple CRUD (create-read-update-delete) wrapper around a database, then you don’t need a domain model or a repository.\n\nBut the more complex the domain, the more an investment in freeing yourself from infrastructure concerns will pay off in terms of the ease of making changes.\n\nFigure 2-6. Domain model trade-offs as a diagram\n\nOur example code isn’t complex enough to give more than a hint of what the right-hand side of the graph looks like, but the hints are there. Imagine, for example, if we decide one day that we want to change allocations to live on the OrderLine instead of on the Batch object: if we were using Django, say, we’d have to define and think through the\n\ndatabase migration before we could run any tests. As it is, because our model is just plain old Python objects, we can change a set() to being a new attribute, without needing to think about the database until later.\n\nREPOSITORY PATTERN RECAP\n\nApply dependency inversion to your ORM\n\nOur domain model should be free of infrastructure concerns, so your ORM should import your model, and not the other way around.\n\nThe Repository pattern is a simple abstraction around permanent storage\n\nThe repository gives you the illusion of a collection of in-memory objects. It makes it easy to create a FakeRepository for testing and to swap fundamental details of your infrastructure without disrupting your core application. See Appendix C for an example.\n\nYou’ll be wondering, how do we instantiate these repositories, fake or real? What will our Flask app actually look like? You’ll find out in the\n\nnext exciting installment, the Service Layer pattern.\n\nBut first, a brief digression.\n\n1 I suppose we mean “no stateful dependencies.” Depending on a helper library is fine;\n\ndepending on an ORM or a web framework is not.\n\n2 Mark Seemann has an excellent blog post on the topic.\n\n3 In this sense, using an ORM is already an example of the DIP. Instead of depending on hardcoded SQL, we depend on an abstraction, the ORM. But that’s not enough for us— not in this book!\n\n4 Even in projects where we don’t use an ORM, we often use SQLAlchemy alongside\n\nAlembic to declaratively create schemas in Python and to manage migrations, connections, and sessions.\n\n5 Shout-out to the amazingly helpful SQLAlchemy maintainers, and to Mike Bayer in\n\nparticular.\n\n6 You may be thinking, “What about list or delete or update?” However, in an ideal\n\nworld, we modify our model objects one at a time, and delete is usually handled as a soft- delete—i.e., batch.cancel(). Finally, update is taken care of by the Unit of Work pattern, as you’ll see in Chapter 6.\n\n7 To really reap the benefits of ABCs (such as they may be), be running helpers like\n\npylint and mypy.\n\n8 Diagram inspired by a post called “Global Complexity, Local Simplicity” by Rob Vens.\n\nChapter 3. A Brief Interlude: On Coupling and Abstractions\n\nAllow us a brief digression on the subject of abstractions, dear reader. We’ve talked about abstractions quite a lot. The Repository pattern is an abstraction over permanent storage, for example. But what makes a\n\ngood abstraction? What do we want from abstractions? And how do they relate to testing?\n\nTIP\n\nThe code for this chapter is in the chapter_03_abstractions branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git git checkout chapter_03_abstractions\n\nA key theme in this book, hidden among the fancy patterns, is that we can use simple abstractions to hide messy details. When we’re writing\n\n1\n\ncode for fun, or in a kata, we get to play with ideas freely, hammering things out and refactoring aggressively. In a large-scale system, though, we become constrained by the decisions made elsewhere in the system.\n\nWhen we’re unable to change component A for fear of breaking component B, we say that the components have become coupled. Locally, coupling is a good thing: it’s a sign that our code is working together, each component supporting the others, all of them fitting in\n\nplace like the gears of a watch. In jargon, we say this works when there is high cohesion between the coupled elements.\n\nGlobally, coupling is a nuisance: it increases the risk and the cost of changing our code, sometimes to the point where we feel unable to make any changes at all. This is the problem with the Ball of Mud pattern: as the application grows, if we’re unable to prevent coupling\n\nbetween elements that have no cohesion, that coupling increases superlinearly until we are no longer able to effectively change our systems.\n\nWe can reduce the degree of coupling within a system (Figure 3-1) by abstracting away the details (Figure 3-2).\n\nFigure 3-1. Lots of coupling\n\nFigure 3-2. Less coupling\n\nIn both diagrams, we have a pair of subsystems, with one dependent on the other. In Figure 3-1, there is a high degree of coupling between the\n\ntwo; the number of arrows indicates lots of kinds of dependencies between the two. If we need to change system B, there’s a good chance that the change will ripple through to system A.\n\nIn Figure 3-2, though, we have reduced the degree of coupling by inserting a new, simpler abstraction. Because it is simpler, system A has fewer kinds of dependencies on the abstraction. The abstraction\n\nserves to protect us from change by hiding away the complex details of whatever system B does—we can change the arrows on the right without changing the ones on the left.\n\nAbstracting State Aids Testability\n\nLet’s see an example. Imagine we want to write code for synchronizing two file directories, which we’ll call the source and the destination:\n\nIf a file exists in the source but not in the destination, copy the file over.\n\nIf a file exists in the source, but it has a different name than in the destination, rename the destination file to match.\n\nIf a file exists in the destination but not in the source, remove it.\n\nOur first and third requirements are simple enough: we can just compare two lists of paths. Our second is trickier, though. To detect\n\nrenames, we’ll have to inspect the content of files. For this, we can use a hashing function like MD5 or SHA-1. The code to generate a SHA-1 hash from a file is simple enough:\n\nHashing a file (sync.py)\n\nBLOCKSIZE = 65536\n\ndef hash_file(path): hasher = hashlib.sha1() with path.open(\"rb\") as file: buf = file.read(BLOCKSIZE) while buf: hasher.update(buf) buf = file.read(BLOCKSIZE) return hasher.hexdigest()\n\nNow we need to write the bit that makes decisions about what to do— the business logic, if you will.\n\nWhen we have to tackle a problem from first principles, we usually try to write a simple implementation and then refactor toward better design. We’ll use this approach throughout the book, because it’s how we write code in the real world: start with a solution to the smallest part of the problem, and then iteratively make the solution richer and better designed.\n\nOur first hackish approach looks something like this:\n\nBasic sync algorithm (sync.py)\n\nimport hashlib import os import shutil from pathlib import Path\n\ndef sync(source, dest): # Walk the source folder and build a dict of filenames and their hashes source_hashes = {} for folder, _, files in os.walk(source): for fn in files: source_hashes[hash_file(Path(folder) / fn)] = fn",
      "page_number": 74
    },
    {
      "number": 3,
      "title": "A Brief Interlude: On Coupling and Abstractions",
      "start_page": 103,
      "end_page": 121,
      "detection_method": "regex_chapter_title",
      "content": "seen = set() # Keep track of the files we've found in the target\n\n# Walk the target folder and get the filenames and hashes for folder, _, files in os.walk(dest): for fn in files: dest_path = Path(folder) / fn dest_hash = hash_file(dest_path) seen.add(dest_hash)\n\n# if there's a file in target that's not in source, delete it if dest_hash not in source_hashes: dest_path.remove()\n\n# if there's a file in target that has a different path in source, # move it to the correct path elif dest_hash in source_hashes and fn != source_hashes[dest_hash]: shutil.move(dest_path, Path(folder) / source_hashes[dest_hash])\n\n# for every file that appears in source but not target, copy the file to # the target for src_hash, fn in source_hashes.items(): if src_hash not in seen: shutil.copy(Path(source) / fn, Path(dest) / fn)\n\nFantastic! We have some code and it looks OK, but before we run it on our hard drive, maybe we should test it. How do we go about testing this sort of thing?\n\nSome end-to-end tests (test_sync.py)\n\ndef test_when_a_file_exists_in_the_source_but_not_the_destination(): try: source = tempfile.mkdtemp() dest = tempfile.mkdtemp()\n\ncontent = \"I am a very useful file\" (Path(source) / 'my-file').write_text(content)\n\nsync(source, dest)\n\nexpected_path = Path(dest) / 'my-file' assert expected_path.exists() assert expected_path.read_text() == content\n\nfinally: shutil.rmtree(source) shutil.rmtree(dest)\n\ndef test_when_a_file_has_been_renamed_in_the_source(): try: source = tempfile.mkdtemp() dest = tempfile.mkdtemp()\n\ncontent = \"I am a file that was renamed\" source_path = Path(source) / 'source-filename' old_dest_path = Path(dest) / 'dest-filename' expected_dest_path = Path(dest) / 'source-filename' source_path.write_text(content) old_dest_path.write_text(content)\n\nsync(source, dest)\n\nassert old_dest_path.exists() is False assert expected_dest_path.read_text() == content\n\nfinally: shutil.rmtree(source) shutil.rmtree(dest)\n\nWowsers, that’s a lot of setup for two simple cases! The problem is that our domain logic, “figure out the difference between two directories,” is tightly coupled to the I/O code. We can’t run our difference algorithm without calling the pathlib, shutil, and hashlib modules.\n\nAnd the trouble is, even with our current requirements, we haven’t\n\nwritten enough tests: the current implementation has several bugs (the shutil.move() is wrong, for example). Getting decent coverage and revealing these bugs means writing more tests, but if they’re all as unwieldy as the preceding ones, that’s going to get real painful real quickly.\n\nOn top of that, our code isn’t very extensible. Imagine trying to implement a --dry-run flag that gets our code to just print out what it’s going to do, rather than actually do it. Or what if we wanted to\n\nsync to a remote server, or to cloud storage?\n\nOur high-level code is coupled to low-level details, and it’s making life hard. As the scenarios we consider get more complex, our tests\n\nwill get more unwieldy. We can definitely refactor these tests (some of the cleanup could go into pytest fixtures, for example) but as long as\n\nwe’re doing filesystem operations, they’re going to stay slow and be hard to read and write.\n\nChoosing the Right Abstraction(s)\n\nWhat could we do to rewrite our code to make it more testable?\n\nFirst, we need to think about what our code needs from the filesystem. Reading through the code, we can see that three distinct things are\n\nhappening. We can think of these as three distinct responsibilities that the code has:\n\n1. We interrogate the filesystem by using os.walk and determine hashes for a series of paths. This is similar in both the source and the destination cases.\n\n2. We decide whether a file is new, renamed, or redundant.\n\n3. We copy, move, or delete files to match the source.\n\nRemember that we want to find simplifying abstractions for each of these responsibilities. That will let us hide the messy details so we can\n\nfocus on the interesting logic.\n\n2\n\nNOTE\n\nIn this chapter, we’re refactoring some gnarly code into a more testable structure by identifying the separate tasks that need to be done and giving each task to a clearly defined actor, along similar lines to the duckduckgo example.\n\nFor steps 1 and 2, we’ve already intuitively started using an abstraction, a dictionary of hashes to paths. You may already have\n\nbeen thinking, “Why not build up a dictionary for the destination folder as well as the source, and then we just compare two dicts?” That\n\nseems like a nice way to abstract the current state of the filesystem:\n\nsource_files = {'hash1': 'path1', 'hash2': 'path2'} dest_files = {'hash1': 'path1', 'hash2': 'pathX'}\n\nWhat about moving from step 2 to step 3? How can we abstract out the actual move/copy/delete filesystem interaction?\n\nWe’ll apply a trick here that we’ll employ on a grand scale later in the\n\nbook. We’re going to separate what we want to do from how to do it.\n\nWe’re going to make our program output a list of commands that look like this:\n\n(\"COPY\", \"sourcepath\", \"destpath\"), (\"MOVE\", \"old\", \"new\"),\n\nNow we could write tests that just use two filesystem dicts as inputs,\n\nand we would expect lists of tuples of strings representing actions as outputs.\n\nInstead of saying, “Given this actual filesystem, when I run my\n\nfunction, check what actions have happened,” we say, “Given this abstraction of a filesystem, what abstraction of filesystem actions\n\nwill happen?”\n\nSimplified inputs and outputs in our tests (test_sync.py)\n\ndef test_when_a_file_exists_in_the_source_but_not_the_destination(): src_hashes = {'hash1': 'fn1'} dst_hashes = {} expected_actions = [('COPY', '/src/fn1', '/dst/fn1')] ...\n\ndef test_when_a_file_has_been_renamed_in_the_source(): src_hashes = {'hash1': 'fn1'} dst_hashes = {'hash1': 'fn2'} expected_actions == [('MOVE', '/dst/fn2', '/dst/fn1')] ...\n\nImplementing Our Chosen Abstractions\n\nThat’s all very well, but how do we actually write those new tests, and how do we change our implementation to make it all work?\n\nOur goal is to isolate the clever part of our system, and to be able to\n\ntest it thoroughly without needing to set up a real filesystem. We’ll create a “core” of code that has no dependencies on external state and\n\nthen see how it responds when we give it input from the outside world (this kind of approach was characterized by Gary Bernhardt as\n\nFunctional Core, Imperative Shell, or FCIS).\n\nLet’s start off by splitting the code to separate the stateful parts from the logic.\n\nAnd our top-level function will contain almost no logic at all; it’s just\n\nan imperative series of steps: gather inputs, call our logic, apply outputs:\n\nSplit our code into three (sync.py)\n\ndef sync(source, dest): # imperative shell step 1, gather inputs source_hashes = read_paths_and_hashes(source) dest_hashes = read_paths_and_hashes(dest)\n\n# step 2: call functional core actions = determine_actions(source_hashes, dest_hashes, source, dest)\n\n# imperative shell step 3, apply outputs for action, *paths in actions: if action == 'copy': shutil.copyfile(*paths) if action == 'move': shutil.move(*paths) if action == 'delete': os.remove(paths[0])\n\nHere’s the first function we factor out, read_paths_and_hashes(), which isolates the I/O part of our application.\n\nHere is where carve out the functional core, the business logic.\n\nThe code to build up the dictionary of paths and hashes is now trivially easy to write:\n\nA function that just does I/O (sync.py)\n\ndef read_paths_and_hashes(root): hashes = {} for folder, _, files in os.walk(root): for fn in files: hashes[hash_file(Path(folder) / fn)] = fn return hashes\n\nThe determine_actions() function will be the core of our business logic, which says, “Given these two sets of hashes and filenames, what\n\nshould we copy/move/delete?”. It takes simple data structures and returns simple data structures:\n\nA function that just does business logic (sync.py)\n\ndef determine_actions(src_hashes, dst_hashes, src_folder, dst_folder): for sha, filename in src_hashes.items(): if sha not in dst_hashes: sourcepath = Path(src_folder) / filename destpath = Path(dst_folder) / filename yield 'copy', sourcepath, destpath\n\nelif dst_hashes[sha] != filename: olddestpath = Path(dst_folder) / dst_hashes[sha] newdestpath = Path(dst_folder) / filename yield 'move', olddestpath, newdestpath\n\nfor sha, filename in dst_hashes.items(): if sha not in src_hashes: yield 'delete', dst_folder / filename\n\nOur tests now act directly on the determine_actions() function:\n\nNicer-looking tests (test_sync.py)\n\ndef test_when_a_file_exists_in_the_source_but_not_the_destination(): src_hashes = {'hash1': 'fn1'} dst_hashes = {} actions = determine_actions(src_hashes, dst_hashes, Path('/src'), Path('/dst')) assert list(actions) == [('copy', Path('/src/fn1'), Path('/dst/fn1'))] ...\n\ndef test_when_a_file_has_been_renamed_in_the_source(): src_hashes = {'hash1': 'fn1'} dst_hashes = {'hash1': 'fn2'} actions = determine_actions(src_hashes, dst_hashes, Path('/src'), Path('/dst')) assert list(actions) == [('move', Path('/dst/fn2'), Path('/dst/fn1'))]\n\nBecause we’ve disentangled the logic of our program—the code for\n\nidentifying changes—from the low-level details of I/O, we can easily test the core of our code.\n\nWith this approach, we’ve switched from testing our main entrypoint function, sync(), to testing a lower-level function, determine_actions(). You might decide that’s fine because sync() is now so simple. Or you might decide to keep some integration/acceptance tests to test that sync(). But there’s another option, which is to modify the sync() function so it can be unit tested\n\nand end-to-end tested; it’s an approach Bob calls edge-to-edge\n\ntesting.\n\nTesting Edge to Edge with Fakes and Dependency Injection\n\nWhen we start writing a new system, we often focus on the core logic\n\nfirst, driving it with direct unit tests. At some point, though, we want to test bigger chunks of the system together.\n\nWe could return to our end-to-end tests, but those are still as tricky to\n\nwrite and maintain as before. Instead, we often write tests that invoke a whole system together but fake the I/O, sort of edge to edge:\n\nExplicit dependencies (sync.py)\n\ndef sync(reader, filesystem, source_root, dest_root):\n\nsource_hashes = reader(source_root) dest_hashes = reader(dest_root)\n\nfor sha, filename in src_hashes.items(): if sha not in dest_hashes: sourcepath = source_root / filename destpath = dest_root / filename filesystem.copy(destpath, sourcepath)\n\nelif dest_hashes[sha] != filename: olddestpath = dest_root / dest_hashes[sha] newdestpath = dest_root / filename filesystem.move(olddestpath, newdestpath)\n\nfor sha, filename in dst_hashes.items(): if sha not in source_hashes: filesystem.delete(dest_root/filename)\n\nOur top-level function now exposes two new dependencies, a reader and a filesystem.\n\nWe invoke the reader to produce our files dict.\n\nWe invoke the filesystem to apply the changes we detect.\n\nTIP\n\nAlthough we’re using dependency injection, there is no need to define an abstract base class or any kind of explicit interface. In this book, we often show ABCs because we hope they help you understand what the abstraction is, but they’re not necessary. Python’s dynamic nature means we can always rely on duck typing.\n\nTests using DI\n\nclass FakeFileSystem(list):\n\ndef copy(self, src, dest): self.append(('COPY', src, dest))\n\ndef move(self, src, dest): self.append(('MOVE', src, dest))\n\ndef delete(self, dest): self.append(('DELETE', src, dest))\n\ndef test_when_a_file_exists_in_the_source_but_not_the_destination(): source = {\"sha1\": \"my-file\" } dest = {} filesystem = FakeFileSystem()\n\nreader = {\"/source\": source, \"/dest\": dest} synchronise_dirs(reader.pop, filesystem, \"/source\", \"/dest\")\n\nassert filesystem == [(\"COPY\", \"/source/my-file\", \"/dest/my-file\")]\n\ndef test_when_a_file_has_been_renamed_in_the_source(): source = {\"sha1\": \"renamed-file\" } dest = {\"sha1\": \"original-file\" } filesystem = FakeFileSystem()\n\nreader = {\"/source\": source, \"/dest\": dest} synchronise_dirs(reader.pop, filesystem, \"/source\", \"/dest\")\n\nassert filesystem == [(\"MOVE\", \"/dest/original-file\", \"/dest/renamed-file\")]\n\nBob loves using lists to build simple test doubles, even though his coworkers get mad. It means we can write tests like assert foo not in database.\n\nEach method in our FakeFileSystem just appends something to the list so we can inspect it later. This is an example of a spy object.\n\nThe advantage of this approach is that our tests act on the exact same function that’s used by our production code. The disadvantage is that\n\nwe have to make our stateful components explicit and pass them around. David Heinemeier Hansson, the creator of Ruby on Rails, famously described this as “test-induced design damage.”\n\nIn either case, we can now work on fixing all the bugs in our implementation; enumerating tests for all the edge cases is now much easier.\n\nWhy Not Just Patch It Out?\n\nAt this point you may be scratching your head and thinking, “Why don’t you just use mock.patch and save yourself the effort?\"”\n\nWe avoid using mocks in this book and in our production code too. We’re not going to enter into a Holy War, but our instinct is that mocking frameworks, particularly monkeypatching, are a code smell.\n\nInstead, we like to clearly identify the responsibilities in our codebase, and to separate those responsibilities into small, focused objects that are easy to replace with a test double.\n\nNOTE\n\nYou can see an example in Chapter 8, where we mock.patch() out an email- sending module, but eventually we replace that with an explicit bit of dependency injection in Chapter 13.\n\nWe have three closely related reasons for our preference:\n\nPatching out the dependency you’re using makes it possible to unit test the code, but it does nothing to improve the design. Using mock.patch won’t let your code work with a --dry- run flag, nor will it help you run against an FTP server. For that, you’ll need to introduce abstractions.\n\nTests that use mocks tend to be more coupled to the implementation details of the codebase. That’s because mock tests verify the interactions between things: did we call shutil.copy with the right arguments? This coupling between code and test tends to make tests more brittle, in our experience.\n\nOveruse of mocks leads to complicated test suites that fail to explain the code.\n\nNOTE\n\nDesigning for testability really means designing for extensibility. We trade off a little more complexity for a cleaner design that admits novel use cases.\n\nMOCKS VERSUS FAKES; CLASSIC-STYLE VERSUS LONDON- SCHOOL TDD\n\nHere’s a short and somewhat simplistic definition of the difference between mocks and fakes:\n\nMocks are used to verify how something gets used; they have methods like assert_called_once_with(). They’re associated with London-school TDD.\n\nFakes are working implementations of the thing they’re replacing, but they’re designed for use only in tests. They wouldn’t work “in real life”; our in-memory repository is a good example. But you can use them to make assertions about the end state of a system rather than the behaviors along the way, so they’re associated with classic-style TDD.\n\nWe’re slightly conflating mocks with spies and fakes with stubs here, and you can read the long, correct answer in Martin Fowler’s classic essay on the subject called “Mocks Aren’t Stubs”.\n\nIt also probably doesn’t help that the MagicMock objects provided by unittest.mock aren’t, strictly speaking, mocks; they’re spies, if anything. But they’re also often used as stubs or dummies. There, we promise we’re done with the test double terminology nitpicks now.\n\nWhat about London-school versus classic-style TDD? You can read more about those two in Martin Fowler’s article that we just cited, as well as on the Software Engineering Stack Exchange site, but in this book we’re pretty firmly in the classicist camp. We like to build our tests around state both in setup and in assertions, and we like to work at the highest level of abstraction 3 possible rather than doing checks on the behavior of intermediary collaborators.\n\nRead more on this in “On Deciding What Kind of Tests to Write”.\n\nWe view TDD as a design practice first and a testing practice second. The tests act as a record of our design choices and serve to explain the\n\nsystem to us when we return to the code after a long absence.\n\nTests that use too many mocks get overwhelmed with setup code that hides the story we care about.\n\nSteve Freeman has a great example of overmocked tests in his talk\n\n“Test-Driven Development”. You should also check out this PyCon talk, “Mocking and Patching Pitfalls”, by our esteemed tech reviewer, Ed Jung, which also addresses mocking and its alternatives. And while we’re recommending talks, don’t miss Brandon Rhodes talking about\n\n“Hoisting Your I/O”, which really nicely covers the issues we’re talking about, using another simple example.\n\nTIP\n\nIn this chapter, we’ve spent a lot of time replacing end-to-end tests with unit tests. That doesn’t mean we think you should never use E2E tests! In this book we’re showing techniques to get you to a decent test pyramid with as many unit tests as possible, and with the minimum number of E2E tests you need to feel confident. Read on to “Recap: Rules of Thumb for Different Types of Test” for more details.\n\nSO WHICH DO WE USE IN THIS BOOK? FUNCTIONAL OR OBJECT-ORIENTED COMPOSITION?\n\nBoth. Our domain model is entirely free of dependencies and side effects, so that’s our functional core. The service layer that we build around it (in Chapter 4) allows us to drive the system edge to edge, and we use dependency injection to provide those services with stateful components, so we can still unit test them.\n\nSee Chapter 13 for more exploration of making our dependency injection more explicit and centralized.\n\nWrap-Up\n\nWe’ll see this idea come up again and again in the book: we can make our systems easier to test and maintain by simplifying the interface\n\nbetween our business logic and messy I/O. Finding the right\n\nabstraction is tricky, but here are a few heuristics and questions to ask yourself:\n\nCan I choose a familiar Python data structure to represent the state of the messy system and then try to imagine a single function that can return that state?\n\nWhere can I draw a line between my systems, where can I carve out a seam to stick that abstraction in?\n\nWhat is a sensible way of dividing things into components with different responsibilities? What implicit concepts can I make explicit?\n\nWhat are the dependencies, and what is the core business logic?\n\nPractice makes less imperfect! And now back to our regular programming…\n\n1 A code kata is a small, contained programming challenge often used to practice TDD.\n\nSee “Kata—The Only Way to Learn TDD” by Peter Provost.\n\n2 If you’re used to thinking in terms of interfaces, that’s what we’re trying to define here.\n\n3 Which is not to say that we think the London school people are wrong. Some insanely\n\nsmart people work that way. It’s just not what we’re used to.\n\nChapter 4. Our First Use Case: Flask API and Service Layer\n\nBack to our allocations project! Figure 4-1 shows the point we reached at the end of Chapter 2, which covered the Repository pattern.\n\nFigure 4-1. Before: we drive our app by talking to repositories and the domain model\n\nIn this chapter, we discuss the differences between orchestration logic, business logic, and interfacing code, and we introduce the Service Layer pattern to take care of orchestrating our workflows and defining the use cases of our system.\n\nWe’ll also discuss testing: by combining the Service Layer with our repository abstraction over the database, we’re able to write fast tests, not just of our domain model but of the entire workflow for a use case.\n\nFigure 4-2 shows what we’re aiming for: we’re going to add a Flask API that will talk to the service layer, which will serve as the entrypoint to our domain model. Because our service layer depends on the AbstractRepository, we can unit test it by using FakeRepository but run our production code using SqlAlchemyRepository.\n\nFigure 4-2. The service layer will become the main way into our app\n\nIn our diagrams, we are using the convention that new components are highlighted with bold text/lines (and yellow/orange color, if you’re reading a digital version).\n\nTIP\n\nThe code for this chapter is in the chapter_04_service_layer branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_04_service_layer # or to code along, checkout Chapter 2: git checkout chapter_02_repository\n\nConnecting Our Application to the Real World\n\nLike any good agile team, we’re hustling to try to get an MVP out and\n\nin front of the users to start gathering feedback. We have the core of our domain model and the domain service we need to allocate orders, and we have the repository interface for permanent storage.\n\nLet’s plug all the moving parts together as quickly as we can and then refactor toward a cleaner architecture. Here’s our plan:\n\n1. Use Flask to put an API endpoint in front of our allocate domain service. Wire up the database session and our repository. Test it with an end-to-end test and some quick- and-dirty SQL to prepare test data.\n\n2. Refactor out a service layer that can serve as an abstraction to capture the use case and that will sit between Flask and our domain model. Build some service-layer tests and show how they can use FakeRepository.\n\n3. Experiment with different types of parameters for our service layer functions; show that using primitive data types allows the service layer’s clients (our tests and our Flask API) to be decoupled from the model layer.\n\nA First End-to-End Test\n\nNo one is interested in getting into a long terminology debate about\n\nwhat counts as an end-to-end (E2E) test versus a functional test versus an acceptance test versus an integration test versus a unit test. Different projects need different combinations of tests, and we’ve seen perfectly successful projects just split things into “fast tests” and “slow tests.”\n\nFor now, we want to write one or maybe two tests that are going to exercise a “real” API endpoint (using HTTP) and talk to a real database. Let’s call them end-to-end tests because it’s one of the most self-explanatory names.\n\nThe following shows a first cut:\n\nA first API test (test_api.py)\n\n@pytest.mark.usefixtures('restart_api') def test_api_returns_allocation(add_stock): sku, othersku = random_sku(), random_sku('other') earlybatch = random_batchref(1) laterbatch = random_batchref(2) otherbatch = random_batchref(3)",
      "page_number": 103
    },
    {
      "number": 4,
      "title": "Our First Use Case: Flask API and Service Layer",
      "start_page": 122,
      "end_page": 149,
      "detection_method": "regex_chapter_title",
      "content": "add_stock([ (laterbatch, sku, 100, '2011-01-02'), (earlybatch, sku, 100, '2011-01-01'), (otherbatch, othersku, 100, None), ]) data = {'orderid': random_orderid(), 'sku': sku, 'qty': 3} url = config.get_api_url() r = requests.post(f'{url}/allocate', json=data) assert r.status_code == 201 assert r.json()['batchref'] == earlybatch\n\nrandom_sku(), random_batchref(), and so on are little helper functions that generate randomized characters by using the uuid module. Because we’re running against an actual database now, this is one way to prevent various tests and runs from interfering with each other.\n\nadd_stock is a helper fixture that just hides away the details of manually inserting rows into the database using SQL. We’ll show a nicer way of doing this later in the chapter.\n\nconfig.py is a module in which we keep configuration information.\n\nEveryone solves these problems in different ways, but you’re going to\n\nneed some way of spinning up Flask, possibly in a container, and of talking to a Postgres database. If you want to see how we did it, check\n\nout Appendix B.\n\nThe Straightforward Implementation\n\nImplementing things in the most obvious way, you might get something\n\nlike this:\n\nFirst cut of Flask app (flask_app.py)\n\nfrom flask import Flask, jsonify, request from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker\n\nimport config import model import orm import repository\n\norm.start_mappers() get_session = sessionmaker(bind=create_engine(config.get_postgres_uri())) app = Flask(__name__)\n\n@app.route(\"/allocate\", methods=['POST']) def allocate_endpoint(): session = get_session() batches = repository.SqlAlchemyRepository(session).list() line = model.OrderLine( request.json['orderid'], request.json['sku'], request.json['qty'], )\n\nbatchref = model.allocate(line, batches)\n\nreturn jsonify({'batchref': batchref}), 201\n\nSo far, so good. No need for too much more of your “architecture astronaut” nonsense, Bob and Harry, you may be thinking.\n\nBut hang on a minute—there’s no commit. We’re not actually saving\n\nour allocation to the database. Now we need a second test, either one that will inspect the database state after (not very black-boxy), or\n\nmaybe one that checks that we can’t allocate a second line if a first should have already depleted the batch:\n\nTest allocations are persisted (test_api.py)\n\n@pytest.mark.usefixtures('restart_api') def test_allocations_are_persisted(add_stock): sku = random_sku() batch1, batch2 = random_batchref(1), random_batchref(2) order1, order2 = random_orderid(1), random_orderid(2) add_stock([ (batch1, sku, 10, '2011-01-01'), (batch2, sku, 10, '2011-01-02'), ]) line1 = {'orderid': order1, 'sku': sku, 'qty': 10} line2 = {'orderid': order2, 'sku': sku, 'qty': 10} url = config.get_api_url()\n\n# first order uses up all stock in batch 1 r = requests.post(f'{url}/allocate', json=line1) assert r.status_code == 201 assert r.json()['batchref'] == batch1\n\n# second order should go to batch 2 r = requests.post(f'{url}/allocate', json=line2) assert r.status_code == 201 assert r.json()['batchref'] == batch2\n\nNot quite so lovely, but that will force us to add the commit.\n\nError Conditions That Require Database Checks\n\nIf we keep going like this, though, things are going to get uglier and\n\nuglier.\n\nSuppose we want to add a bit of error handling. What if the domain raises an error, for a SKU that’s out of stock? Or what about a SKU\n\nthat doesn’t even exist? That’s not something the domain even knows\n\nabout, nor should it. It’s more of a sanity check that we should\n\nimplement at the database layer, before we even invoke the domain\n\nservice.\n\nNow we’re looking at two more end-to-end tests:\n\nYet more tests at the E2E layer (test_api.py)\n\n@pytest.mark.usefixtures('restart_api') def test_400_message_for_out_of_stock(add_stock): sku, smalL_batch, large_order = random_sku(), random_batchref(), random_orderid() add_stock([ (smalL_batch, sku, 10, '2011-01-01'), ]) data = {'orderid': large_order, 'sku': sku, 'qty': 20} url = config.get_api_url() r = requests.post(f'{url}/allocate', json=data) assert r.status_code == 400 assert r.json()['message'] == f'Out of stock for sku {sku}'\n\n@pytest.mark.usefixtures('restart_api') def test_400_message_for_invalid_sku(): unknown_sku, orderid = random_sku(), random_orderid() data = {'orderid': orderid, 'sku': unknown_sku, 'qty': 20} url = config.get_api_url() r = requests.post(f'{url}/allocate', json=data) assert r.status_code == 400 assert r.json()['message'] == f'Invalid sku {unknown_sku}'\n\nIn the first test, we’re trying to allocate more units than we have in stock.\n\nIn the second, the SKU just doesn’t exist (because we never called add_stock), so it’s invalid as far as our app is concerned.\n\nAnd sure, we could implement it in the Flask app too:\n\nFlask app starting to get crufty (flask_app.py)\n\ndef is_valid_sku(sku, batches): return sku in {b.sku for b in batches}\n\n@app.route(\"/allocate\", methods=['POST']) def allocate_endpoint(): session = get_session() batches = repository.SqlAlchemyRepository(session).list() line = model.OrderLine( request.json['orderid'], request.json['sku'], request.json['qty'], )\n\nif not is_valid_sku(line.sku, batches): return jsonify({'message': f'Invalid sku {line.sku}'}), 400\n\ntry: batchref = model.allocate(line, batches) except model.OutOfStock as e: return jsonify({'message': str(e)}), 400\n\nsession.commit() return jsonify({'batchref': batchref}), 201\n\nBut our Flask app is starting to look a bit unwieldy. And our number of\n\nE2E tests is starting to get out of control, and soon we’ll end up with an inverted test pyramid (or “ice-cream cone model,” as Bob likes to\n\ncall it).\n\nIntroducing a Service Layer, and Using FakeRepository to Unit Test It\n\nIf we look at what our Flask app is doing, there’s quite a lot of what\n\nwe might call orchestration—fetching stuff out of our repository,\n\nvalidating our input against database state, handling errors, and committing in the happy path. Most of these things don’t have anything\n\nto do with having a web API endpoint (you’d need them if you were building a CLI, for example; see Appendix C), and they’re not really\n\nthings that need to be tested by end-to-end tests.\n\nIt often makes sense to split out a service layer, sometimes called an\n\norchestration layer or a use-case layer.\n\nDo you remember the FakeRepository that we prepared in Chapter 3?\n\nOur fake repository, an in-memory collection of batches (test_services.py)\n\nclass FakeRepository(repository.AbstractRepository):\n\ndef __init__(self, batches): self._batches = set(batches)\n\ndef add(self, batch): self._batches.add(batch)\n\ndef get(self, reference): return next(b for b in self._batches if b.reference == reference)\n\ndef list(self): return list(self._batches)\n\nHere’s where it will come in useful; it lets us test our service layer\n\nwith nice, fast unit tests:\n\nUnit testing with fakes at the service layer (test_services.py)\n\ndef test_returns_allocation(): line = model.OrderLine(\"o1\", \"COMPLICATED-LAMP\", 10) batch = model.Batch(\"b1\", \"COMPLICATED-LAMP\", 100, eta=None) repo = FakeRepository([batch])\n\nresult = services.allocate(line, repo, FakeSession()) assert result == \"b1\"\n\ndef test_error_for_invalid_sku(): line = model.OrderLine(\"o1\", \"NONEXISTENTSKU\", 10) batch = model.Batch(\"b1\", \"AREALSKU\", 100, eta=None) repo = FakeRepository([batch])\n\nwith pytest.raises(services.InvalidSku, match=\"Invalid sku NONEXISTENTSKU\"): services.allocate(line, repo, FakeSession())\n\nFakeRepository holds the Batch objects that will be used by our test.\n\nOur services module (services.py) will define an allocate() service-layer function. It will sit between our allocate_endpoint() function in the API layer and the allocate() domain service function from our domain model.\n\nWe also need a FakeSession to fake out the database session, as shown in the following code snippet.\n\nA fake database session (test_services.py)\n\nclass FakeSession(): committed = False\n\ndef commit(self): self.committed = True\n\nThis fake session is only a temporary solution. We’ll get rid of it and make things even nicer soon, in Chapter 6. But in the meantime the fake\n\n1\n\n.commit() lets us migrate a third test from the E2E layer:\n\nA second test at the service layer (test_services.py)\n\ndef test_commits(): line = model.OrderLine('o1', 'OMINOUS-MIRROR', 10) batch = model.Batch('b1', 'OMINOUS-MIRROR', 100, eta=None) repo = FakeRepository([batch]) session = FakeSession()\n\nservices.allocate(line, repo, session) assert session.committed is True\n\nA Typical Service Function\n\nWe’ll write a service function that looks something like this:\n\nBasic allocation service (services.py)\n\nclass InvalidSku(Exception): pass\n\ndef is_valid_sku(sku, batches): return sku in {b.sku for b in batches}\n\ndef allocate(line: OrderLine, repo: AbstractRepository, session) -> str: batches = repo.list() if not is_valid_sku(line.sku, batches): raise InvalidSku(f'Invalid sku {line.sku}') batchref = model.allocate(line, batches) session.commit() return batchref\n\nTypical service-layer functions have similar steps:\n\nWe fetch some objects from the repository.\n\nWe make some checks or assertions about the request against the current state of the world.\n\nWe call a domain service.\n\nIf all is well, we save/update any state we’ve changed.\n\nThat last step is a little unsatisfactory at the moment, as our service layer is tightly coupled to our database layer. We’ll improve that in Chapter 6 with the Unit of Work pattern.\n\nDEPEND ON ABSTRACTIONS\n\nNotice one more thing about our service-layer function:\n\ndef allocate(line: OrderLine, repo: AbstractRepository, session) -> str:\n\nIt depends on a repository. We’ve chosen to make the dependency explicit, and we’ve used the type hint to say that we depend on AbstractRepository. This means it’ll work both when the tests give it a FakeRepository and when the Flask app gives it a SqlAlchemyRepository.\n\nIf you remember “The Dependency Inversion Principle”, this is what we mean when we say we should “depend on abstractions.” Our high-level module, the service layer, depends on the repository abstraction. And the details of the implementation for our specific choice of persistent storage also depend on that same abstraction. See Figures 4-3 and 4-4.\n\nSee also in Appendix C a worked example of swapping out the details of which persistent storage system to use while leaving the abstractions intact.\n\nBut the essentials of the service layer are there, and our Flask app now\n\nlooks a lot cleaner:\n\nFlask app delegating to service layer (flask_app.py)\n\n@app.route(\"/allocate\", methods=['POST']) def allocate_endpoint(): session = get_session() repo = repository.SqlAlchemyRepository(session)\n\nline = model.OrderLine( request.json['orderid'], request.json['sku'], request.json['qty'], ) try: batchref = services.allocate(line, repo, session) except (model.OutOfStock, services.InvalidSku) as e: return jsonify({'message': str(e)}), 400\n\nreturn jsonify({'batchref': batchref}), 201\n\nWe instantiate a database session and some repository objects.\n\nWe extract the user’s commands from the web request and pass them to a domain service.\n\nWe return some JSON responses with the appropriate status codes.\n\nThe responsibilities of the Flask app are just standard web stuff: per- request session management, parsing information out of POST parameters, response status codes, and JSON. All the orchestration logic is in the use case/service layer, and the domain logic stays in the\n\ndomain.\n\nFinally, we can confidently strip down our E2E tests to just two, one for the happy path and one for the unhappy path:\n\nE2E tests only happy and unhappy paths (test_api.py)\n\n@pytest.mark.usefixtures('restart_api') def test_happy_path_returns_201_and_allocated_batch(add_stock): sku, othersku = random_sku(), random_sku('other') earlybatch = random_batchref(1) laterbatch = random_batchref(2) otherbatch = random_batchref(3)\n\nadd_stock([ (laterbatch, sku, 100, '2011-01-02'), (earlybatch, sku, 100, '2011-01-01'), (otherbatch, othersku, 100, None), ]) data = {'orderid': random_orderid(), 'sku': sku, 'qty': 3} url = config.get_api_url() r = requests.post(f'{url}/allocate', json=data) assert r.status_code == 201 assert r.json()['batchref'] == earlybatch\n\n@pytest.mark.usefixtures('restart_api') def test_unhappy_path_returns_400_and_error_message(): unknown_sku, orderid = random_sku(), random_orderid() data = {'orderid': orderid, 'sku': unknown_sku, 'qty': 20} url = config.get_api_url() r = requests.post(f'{url}/allocate', json=data) assert r.status_code == 400 assert r.json()['message'] == f'Invalid sku {unknown_sku}'\n\nWe’ve successfully split our tests into two broad categories: tests\n\nabout web stuff, which we implement end to end; and tests about orchestration stuff, which we can test against the service layer in memory.\n\nEXERCISE FOR THE READER\n\nNow that we have an allocate service, why not build out a service for deallocate? We’ve added an E2E test and a few stub service-layer tests for you to get started on GitHub.\n\nIf that’s not enough, continue into the E2E tests and flask_app.py, and refactor the Flask adapter to be more RESTful. Notice how doing so doesn’t require any change to our service layer or domain layer!\n\nTIP\n\nIf you decide you want to build a read-only endpoint for retrieving allocation info, just do “the simplest thing that can possibly work,” which is repo.get() right in the Flask handler. We’ll talk more about reads versus writes in Chapter 12.\n\nWhy Is Everything Called a Service?\n\nSome of you are probably scratching your heads at this point trying to figure out exactly what the difference is between a domain service and\n\na service layer.\n\nWe’re sorry—we didn’t choose the names, or we’d have much cooler and friendlier ways to talk about this stuff.\n\nWe’re using two things called a service in this chapter. The first is an application service (our service layer). Its job is to handle requests from the outside world and to orchestrate an operation. What we mean\n\nis that the service layer drives the application by following a bunch of simple steps:\n\nGet some data from the database\n\nUpdate the domain model\n\nPersist any changes\n\nThis is the kind of boring work that has to happen for every operation in your system, and keeping it separate from business logic helps to keep things tidy.\n\nThe second type of service is a domain service. This is the name for a piece of logic that belongs in the domain model but doesn’t sit naturally inside a stateful entity or value object. For example, if you\n\nwere building a shopping cart application, you might choose to build taxation rules as a domain service. Calculating tax is a separate job from updating the cart, and it’s an important part of the model, but it doesn’t seem right to have a persisted entity for the job. Instead a stateless TaxCalculator class or a calculate_tax function can do the job.\n\nPutting Things in Folders to See Where It All Belongs\n\nAs our application gets bigger, we’ll need to keep tidying our directory structure. The layout of our project gives us useful hints\n\nabout what kinds of object we’ll find in each file.\n\nHere’s one way we could organize things:\n\nSome subfolders\n\n. ├── config.py ├── domain │ ├── __init__.py │ └── model.py\n\n├── service_layer │ ├── __init__.py │ └── services.py ├── adapters │ ├── __init__.py │ ├── orm.py │ └── repository.py ├── entrypoints │ ├── __init__.py │ └── flask_app.py └── tests ├── __init__.py ├── conftest.py ├── unit │ ├── test_allocate.py │ ├── test_batches.py │ └── test_services.py ├── integration │ ├── test_orm.py │ └── test_repository.py └── e2e └── test_api.py\n\nLet’s have a folder for our domain model. Currently that’s just one file, but for a more complex application, you might have one file per class; you might have helper parent classes for Entity, ValueObject, and Aggregate, and you might add an exceptions.py for domain-layer exceptions and, as you’ll see in Part II, commands.py and events.py.\n\nWe’ll distinguish the service layer. Currently that’s just one file called services.py for our service-layer functions. You could add service-layer exceptions here, and as you’ll see in Chapter 5, we’ll add unit_of_work.py.\n\nAdapters is a nod to the ports and adapters terminology. This will fill up with any other abstractions around external I/O (e.g., a redis_client.py). Strictly speaking, you would call these secondary adapters or driven adapters, or sometimes inward-facing adapters.\n\nEntrypoints are the places we drive our application from. In the official ports and adapters terminology, these are adapters too, and are referred to as primary, driving, or outward-facing adapters.\n\nWhat about ports? As you may remember, they are the abstract interfaces that the adapters implement. We tend to keep them in the same file as the adapters that implement them.\n\nWrap-Up\n\nAdding the service layer has really bought us quite a lot:\n\nOur Flask API endpoints become very thin and easy to write: their only responsibility is doing “web stuff,” such as parsing JSON and producing the right HTTP codes for happy or unhappy cases.\n\nWe’ve defined a clear API for our domain, a set of use cases or entrypoints that can be used by any adapter without needing to know anything about our domain model classes—whether that’s an API, a CLI (see Appendix C), or the tests! They’re an adapter for our domain too.\n\nWe can write tests in “high gear” by using the service layer, leaving us free to refactor the domain model in any way we see fit. As long as we can still deliver the same use cases, we can experiment with new designs without needing to rewrite a load of tests.\n\nAnd our test pyramid is looking good—the bulk of our tests are fast unit tests, with just the bare minimum of E2E and integration tests.\n\nThe DIP in Action\n\nFigure 4-3 shows the dependencies of our service layer: the domain model and AbstractRepository (the port, in ports and adapters terminology).\n\nWhen we run the tests, Figure 4-4 shows how we implement the abstract dependencies by using FakeRepository (the adapter).\n\nAnd when we actually run our app, we swap in the “real” dependency shown in Figure 4-5.\n\nFigure 4-3. Abstract dependencies of the service layer\n\nFigure 4-4. Tests provide an implementation of the abstract dependency\n\nFigure 4-5. Dependencies at runtime\n\nWonderful.\n\nLet’s pause for Table 4-1, in which we consider the pros and cons of having a service layer at all.\n\nTable 4-1. Service layer: the trade-offs\n\nPros\n\nCons\n\nPros\n\nWe have a single place to capture all the use cases for our application.\n\nWe’ve placed our clever domain logic behind an API, which leaves us free to refactor.\n\nWe have cleanly separated “stuff that talks HTTP” from “stuff that talks allocation.”\n\nWhen combined with the Repository pattern and FakeRep ository, we have a nice way of writing tests at a higher level than the domain layer; we can test more of our workflow without needing to use integration tests (read on to Chapter 5 for more elaboration on this).\n\nCons\n\nIf your app is purely a web app, your controllers/view functions can be the single place to capture all the use cases.\n\nIt’s yet another layer of abstraction.\n\nPutting too much logic into the service layer can lead to the Anemic Domain anti-pattern. It’s better to introduce this layer after you spot orchestration logic creeping into your controllers.\n\nYou can get a lot of the benefits that come from having rich domain models by simply pushing logic out of your controllers and down to the model layer, without needing to add an extra layer in between (aka “fat models, thin controllers”).\n\nBut there are still some bits of awkwardness to tidy up:\n\nThe service layer is still tightly coupled to the domain, because its API is expressed in terms of OrderLine objects. In Chapter 5, we’ll fix that and talk about the way that the service layer enables more productive TDD.\n\nThe service layer is tightly coupled to a session object. In Chapter 6, we’ll introduce one more pattern that works closely with the Repository and Service Layer patterns, the Unit of Work pattern, and everything will be absolutely lovely. You’ll see!\n\n1 Service-layer services and domain services do have confusingly similar names. We\n\ntackle this topic later in “Why Is Everything Called a Service?”.\n\nChapter 5. TDD in High Gear and Low Gear\n\nWe’ve introduced the service layer to capture some of the additional orchestration responsibilities we need from a working application. The service layer helps us clearly define our use cases and the\n\nworkflow for each: what we need to get from our repositories, what\n\npre-checks and current state validation we should do, and what we save at the end.\n\nBut currently, many of our unit tests operate at a lower level, acting\n\ndirectly on the model. In this chapter we’ll discuss the trade-offs involved in moving those tests up to the service-layer level, and some\n\nmore general testing guidelines.\n\nHARRY SAYS: SEEING A TEST PYRAMID IN ACTION WAS A LIGHT- BULB MOMENT\n\nHere are a few words from Harry directly:\n\nI was initially skeptical of all Bob’s architectural patterns, but seeing an actual test pyramid made me a convert.\n\nOnce you implement domain modeling and the service layer, you really actually can get to a stage where unit tests outnumber integration and end-to-end tests by an order of magnitude. Having worked in places where the E2E test build would take hours (“wait ‘til tomorrow,” essentially), I can’t tell you what a difference it makes to be able to run all your tests in minutes or seconds.\n\nRead on for some guidelines on how to decide what kinds of tests to write and at which level. The high gear versus low gear way of thinking really changed my testing life.\n\nHow Is Our Test Pyramid Looking?\n\nLet’s see what this move to using a service layer, with its own service- layer tests, does to our test pyramid:\n\nCounting types of tests\n\n$ grep -c test_ test_*.py tests/unit/test_allocate.py:4 tests/unit/test_batches.py:8 tests/unit/test_services.py:3\n\ntests/integration/test_orm.py:6 tests/integration/test_repository.py:2\n\ntests/e2e/test_api.py:2\n\nNot bad! We have 15 unit tests, 8 integration tests, and just 2 end-to- end tests. That’s already a healthy-looking test pyramid.\n\nShould Domain Layer Tests Move to the Service Layer?\n\nLet’s see what happens if we take this a step further. Since we can test our software against the service layer, we don’t really need tests for the domain model anymore. Instead, we could rewrite all of the domain-level tests from Chapter 1 in terms of the service layer:\n\nRewriting a domain test at the service layer (tests/unit/test_services.py)\n\n# domain-layer test: def test_prefers_current_stock_batches_to_shipments(): in_stock_batch = Batch(\"in-stock-batch\", \"RETRO-CLOCK\", 100, eta=None) shipment_batch = Batch(\"shipment-batch\", \"RETRO-CLOCK\", 100, eta=tomorrow)\n\nline = OrderLine(\"oref\", \"RETRO-CLOCK\", 10)\n\nallocate(line, [in_stock_batch, shipment_batch])\n\nassert in_stock_batch.available_quantity == 90 assert shipment_batch.available_quantity == 100\n\n# service-layer test: def test_prefers_warehouse_batches_to_shipments(): in_stock_batch = Batch(\"in-stock-batch\", \"RETRO-CLOCK\", 100, eta=None) shipment_batch = Batch(\"shipment-batch\", \"RETRO-CLOCK\", 100, eta=tomorrow) repo = FakeRepository([in_stock_batch, shipment_batch]) session = FakeSession()\n\nline = OrderLine('oref', \"RETRO-CLOCK\", 10)\n\nservices.allocate(line, repo, session)\n\nassert in_stock_batch.available_quantity == 90 assert shipment_batch.available_quantity == 100\n\nWhy would we want to do that?\n\nTests are supposed to help us change our system fearlessly, but often we see teams writing too many tests against their domain model. This causes problems when they come to change their codebase and find that they need to update tens or even hundreds of unit tests.\n\nThis makes sense if you stop to think about the purpose of automated tests. We use tests to enforce that a property of the system doesn’t change while we’re working. We use tests to check that the API\n\ncontinues to return 200, that the database session continues to commit, and that orders are still being allocated.\n\nIf we accidentally change one of those behaviors, our tests will break. The flip side, though, is that if we want to change the design of our\n\ncode, any tests relying directly on that code will also fail.\n\nAs we get further into the book, you’ll see how the service layer forms an API for our system that we can drive in multiple ways. Testing against this API reduces the amount of code that we need to change when we refactor our domain model. If we restrict ourselves to testing only against the service layer, we won’t have any tests that directly interact with “private” methods or attributes on our model objects, which leaves us freer to refactor them.\n\nTIP\n\nEvery line of code that we put in a test is like a blob of glue, holding the system in a particular shape. The more low-level tests we have, the harder it will be to change things.\n\nOn Deciding What Kind of Tests to Write\n\nYou might be asking yourself, “Should I rewrite all my unit tests, then? Is it wrong to write tests against the domain model?” To answer those questions, it’s important to understand the trade-off between coupling and design feedback (see Figure 5-1).\n\nFigure 5-1. The test spectrum\n\nExtreme programming (XP) exhorts us to “listen to the code.” When we’re writing tests, we might find that the code is hard to use or notice a code smell. This is a trigger for us to refactor, and to reconsider our design.\n\nWe only get that feedback, though, when we’re working closely with the target code. A test for the HTTP API tells us nothing about the fine- grained design of our objects, because it sits at a much higher level of abstraction.\n\nOn the other hand, we can rewrite our entire application and, so long as we don’t change the URLs or request formats, our HTTP tests will continue to pass. This gives us confidence that large-scale changes, like changing the database schema, haven’t broken our code.\n\nAt the other end of the spectrum, the tests we wrote in Chapter 1 helped us to flesh out our understanding of the objects we need. The tests guided us to a design that makes sense and reads in the domain language. When our tests read in the domain language, we feel\n\ncomfortable that our code matches our intuition about the problem we’re trying to solve.\n\nBecause the tests are written in the domain language, they act as living documentation for our model. A new team member can read these tests to quickly understand how the system works and how the core concepts interrelate.\n\nWe often “sketch” new behaviors by writing tests at this level to see how the code might look. When we want to improve the design of the code, though, we will need to replace or delete these tests, because they are tightly coupled to a particular implementation.\n\nHigh and Low Gear\n\nMost of the time, when we are adding a new feature or fixing a bug, we don’t need to make extensive changes to the domain model. In these cases, we prefer to write tests against services because of the lower coupling and higher coverage.\n\nFor example, when writing an add_stock function or a cancel_order feature, we can work more quickly and with less coupling by writing tests against the service layer.\n\nWhen starting a new project or when hitting a particularly gnarly problem, we will drop back down to writing tests against the domain model so we get better feedback and executable documentation of our intent.\n\nThe metaphor we use is that of shifting gears. When starting a journey,\n\nthe bicycle needs to be in a low gear so that it can overcome inertia. Once we’re off and running, we can go faster and more efficiently by changing into a high gear; but if we suddenly encounter a steep hill or are forced to slow down by a hazard, we again drop down to a low gear until we can pick up speed again.\n\nFully Decoupling the Service-Layer Tests from the Domain\n\nWe still have direct dependencies on the domain in our service-layer tests, because we use domain objects to set up our test data and to\n\ninvoke our service-layer functions.\n\nTo have a service layer that’s fully decoupled from the domain, we need to rewrite its API to work in terms of primitives.\n\nOur service layer currently takes an OrderLine domain object:\n\nBefore: allocate takes a domain object (service_layer/services.py)\n\ndef allocate(line: OrderLine, repo: AbstractRepository, session) -> str:\n\nHow would it look if its parameters were all primitive types?\n\nAfter: allocate takes strings and ints (service_layer/services.py)\n\ndef allocate( orderid: str, sku: str, qty: int, repo: AbstractRepository, session ) -> str:",
      "page_number": 122
    },
    {
      "number": 5,
      "title": "TDD in High Gear and Low Gear",
      "start_page": 150,
      "end_page": 163,
      "detection_method": "regex_chapter_title",
      "content": "We rewrite the tests in those terms as well:\n\nTests now use primitives in function call (tests/unit/test_services.py)\n\ndef test_returns_allocation(): batch = model.Batch(\"batch1\", \"COMPLICATED-LAMP\", 100, eta=None) repo = FakeRepository([batch])\n\nresult = services.allocate(\"o1\", \"COMPLICATED-LAMP\", 10, repo, FakeSession()) assert result == \"batch1\"\n\nBut our tests still depend on the domain, because we still manually instantiate Batch objects. So, if one day we decide to massively refactor how our Batch model works, we’ll have to change a bunch of tests.\n\nMitigation: Keep All Domain Dependencies in Fixture Functions\n\nWe could at least abstract that out to a helper function or a fixture in\n\nour tests. Here’s one way you could do that, adding a factory function on FakeRepository:\n\nFactory functions for fixtures are one possibility\n\n(tests/unit/test_services.py)\n\nclass FakeRepository(set):\n\n@staticmethod def for_batch(ref, sku, qty, eta=None): return FakeRepository([ model.Batch(ref, sku, qty, eta), ])\n\n...\n\ndef test_returns_allocation(): repo = FakeRepository.for_batch(\"batch1\", \"COMPLICATED-LAMP\", 100, eta=None) result = services.allocate(\"o1\", \"COMPLICATED-LAMP\", 10, repo, FakeSession()) assert result == \"batch1\"\n\nAt least that would move all of our tests’ dependencies on the domain into one place.\n\nAdding a Missing Service\n\nWe could go one step further, though. If we had a service to add stock, we could use that and make our service-layer tests fully expressed in\n\nterms of the service layer’s official use cases, removing all dependencies on the domain:\n\nTest for new add_batch service (tests/unit/test_services.py)\n\ndef test_add_batch(): repo, session = FakeRepository([]), FakeSession() services.add_batch(\"b1\", \"CRUNCHY-ARMCHAIR\", 100, None, repo, session) assert repo.get(\"b1\") is not None assert session.committed\n\nTIP\n\nIn general, if you find yourself needing to do domain-layer stuff directly in your service-layer tests, it may be an indication that your service layer is incomplete.\n\nAnd the implementation is just two lines:\n\nA new service for add_batch (service_layer/services.py)\n\ndef add_batch( ref: str, sku: str, qty: int, eta: Optional[date], repo: AbstractRepository, session, ): repo.add(model.Batch(ref, sku, qty, eta)) session.commit()\n\ndef allocate( orderid: str, sku: str, qty: int, repo: AbstractRepository, session ) -> str: ...\n\nNOTE\n\nShould you write a new service just because it would help remove dependencies from your tests? Probably not. But in this case, we almost definitely would need an add_batch service one day anyway.\n\nThat now allows us to rewrite all of our service-layer tests purely in\n\nterms of the services themselves, using only primitives, and without any dependencies on the model:\n\nServices tests now use only services (tests/unit/test_services.py)\n\ndef test_allocate_returns_allocation(): repo, session = FakeRepository([]), FakeSession() services.add_batch(\"batch1\", \"COMPLICATED-LAMP\", 100, None, repo, session) result = services.allocate(\"o1\", \"COMPLICATED-LAMP\", 10, repo, session) assert result == \"batch1\"\n\ndef test_allocate_errors_for_invalid_sku():\n\nrepo, session = FakeRepository([]), FakeSession() services.add_batch(\"b1\", \"AREALSKU\", 100, None, repo, session)\n\nwith pytest.raises(services.InvalidSku, match=\"Invalid sku NONEXISTENTSKU\"): services.allocate(\"o1\", \"NONEXISTENTSKU\", 10, repo, FakeSession())\n\nThis is a really nice place to be in. Our service-layer tests depend on\n\nonly the service layer itself, leaving us completely free to refactor the model as we see fit.\n\nCarrying the Improvement Through to the E2E Tests\n\nIn the same way that adding add_batch helped decouple our service- layer tests from the model, adding an API endpoint to add a batch would remove the need for the ugly add_stock fixture, and our E2E tests could be free of those hardcoded SQL queries and the direct\n\ndependency on the database.\n\nThanks to our service function, adding the endpoint is easy, with just a little JSON wrangling and a single function call required:\n\nAPI for adding a batch (entrypoints/flask_app.py)\n\n@app.route(\"/add_batch\", methods=['POST']) def add_batch(): session = get_session() repo = repository.SqlAlchemyRepository(session) eta = request.json['eta'] if eta is not None: eta = datetime.fromisoformat(eta).date() services.add_batch( request.json['ref'], request.json['sku'], request.json['qty'], eta,\n\nrepo, session ) return 'OK', 201\n\nNOTE\n\nAre you thinking to yourself, POST to /add_batch? That’s not very RESTful! You’re quite right. We’re being happily sloppy, but if you’d like to make it all more RESTy, maybe a POST to /batches, then knock yourself out! Because Flask is a thin adapter, it’ll be easy. See the next sidebar.\n\nAnd our hardcoded SQL queries from conftest.py get replaced with\n\nsome API calls, meaning the API tests have no dependencies other than the API, which is also nice:\n\nAPI tests can now add their own batches (tests/e2e/test_api.py)\n\ndef post_to_add_batch(ref, sku, qty, eta): url = config.get_api_url() r = requests.post( f'{url}/add_batch', json={'ref': ref, 'sku': sku, 'qty': qty, 'eta': eta} ) assert r.status_code == 201\n\n@pytest.mark.usefixtures('postgres_db') @pytest.mark.usefixtures('restart_api') def test_happy_path_returns_201_and_allocated_batch(): sku, othersku = random_sku(), random_sku('other') earlybatch = random_batchref(1) laterbatch = random_batchref(2) otherbatch = random_batchref(3) post_to_add_batch(laterbatch, sku, 100, '2011-01-02') post_to_add_batch(earlybatch, sku, 100, '2011-01-01')\n\npost_to_add_batch(otherbatch, othersku, 100, None) data = {'orderid': random_orderid(), 'sku': sku, 'qty': 3} url = config.get_api_url() r = requests.post(f'{url}/allocate', json=data) assert r.status_code == 201 assert r.json()['batchref'] == earlybatch\n\nWrap-Up\n\nOnce you have a service layer in place, you really can move the majority of your test coverage to unit tests and develop a healthy test\n\npyramid.\n\nRECAP: RULES OF THUMB FOR DIFFERENT TYPES OF TEST\n\nAim for one end-to-end test per feature\n\nThis might be written against an HTTP API, for example. The objective is to demonstrate that the feature works, and that all the moving parts are glued together correctly.\n\nWrite the bulk of your tests against the service layer\n\nThese edge-to-edge tests offer a good trade-off between coverage, runtime, and efficiency. Each test tends to cover one code path of a feature and use fakes for I/O. This is the place to 1 exhaustively cover all the edge cases and the ins and outs of your business logic.\n\nMaintain a small core of tests written against your domain model\n\nThese tests have highly focused coverage and are more brittle, but they have the highest feedback. Don’t be afraid to delete these tests if the functionality is later covered by tests at the service layer.\n\nError handling counts as a feature\n\nIdeally, your application will be structured such that all errors that bubble up to your entrypoints (e.g., Flask) are handled in the same way. This means you need to test only the happy path for each feature, and to reserve one end-to-end test for all unhappy paths (and many unhappy path unit tests, of course).\n\nA few things will help along the way:\n\nExpress your service layer in terms of primitives rather than domain objects.\n\nIn an ideal world, you’ll have all the services you need to be able to test entirely against the service layer, rather than hacking state via repositories or the database. This pays off in your end-to-end tests as well.\n\nOnto the next chapter!\n\n1 A valid concern about writing tests at a higher level is that it can lead to combinatorial\n\nexplosion for more complex use cases. In these cases, dropping down to lower-level unit tests of the various collaborating domain objects can be useful. But see also Chapter 8 and “Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus”.\n\nChapter 6. Unit of Work Pattern\n\nIn this chapter we’ll introduce the final piece of the puzzle that ties together the Repository and Service Layer patterns: the Unit of Work pattern.\n\nIf the Repository pattern is our abstraction over the idea of persistent\n\nstorage, the Unit of Work (UoW) pattern is our abstraction over the idea of atomic operations. It will allow us to finally and fully decouple our service layer from the data layer.\n\nFigure 6-1 shows that, currently, a lot of communication occurs across the layers of our infrastructure: the API talks directly to the database\n\nlayer to start a session, it talks to the repository layer to initialize SQLAlchemyRepository, and it talks to the service layer to ask it to allocate.\n\nTIP\n\nThe code for this chapter is in the chapter_06_uow branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_06_uow # or to code along, checkout Chapter 4: git checkout chapter_04_service_layer\n\nFigure 6-1. Without UoW: API talks directly to three layers\n\nFigure 6-2 shows our target state. The Flask API now does only two things: it initializes a unit of work, and it invokes a service. The service collaborates with the UoW (we like to think of the UoW as being part of the service layer), but neither the service function itself nor Flask now needs to talk directly to the database.\n\nAnd we’ll do it all using a lovely piece of Python syntax, a context manager.\n\nFigure 6-2. With UoW: UoW now manages database state\n\nThe Unit of Work Collaborates with the Repository\n\nLet’s see the unit of work (or UoW, which we pronounce “you-wow”) in action. Here’s how the service layer will look when we’re finished:\n\nPreview of unit of work in action (src/allocation/service_layer/services.py)\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(orderid, sku, qty) with uow: batches = uow.batches.list() ... batchref = model.allocate(line, batches) uow.commit()\n\nWe’ll start a UoW as a context manager.\n\nuow.batches is the batches repo, so the UoW provides us access to our permanent storage.\n\nWhen we’re done, we commit or roll back our work, using the UoW.\n\nThe UoW acts as a single entrypoint to our persistent storage, and it keeps track of what objects were loaded and of the latest state.\n\n1\n\nThis gives us three useful things:\n\nA stable snapshot of the database to work with, so the objects we use aren’t changing halfway through an operation\n\nA way to persist all of our changes at once, so if something goes wrong, we don’t end up in an inconsistent state\n\nA simple API to our persistence concerns and a handy place to get a repository\n\nTest-Driving a UoW with Integration Tests\n\nHere are our integration tests for the UOW:\n\nA basic “round-trip” test for a UoW (tests/integration/test_uow.py)\n\ndef test_uow_can_retrieve_a_batch_and_allocate_to_it(session_factory): session = session_factory() insert_batch(session, 'batch1', 'HIPSTER-WORKBENCH', 100, None) session.commit()\n\nuow = unit_of_work.SqlAlchemyUnitOfWork(session_factory) with uow: batch = uow.batches.get(reference='batch1') line = model.OrderLine('o1', 'HIPSTER-WORKBENCH', 10) batch.allocate(line) uow.commit()\n\nbatchref = get_allocated_batch_ref(session, 'o1', 'HIPSTER-WORKBENCH') assert batchref == 'batch1'\n\nWe initialize the UoW by using our custom session factory and get back a uow object to use in our with block.\n\nThe UoW gives us access to the batches repository via uow.batches.\n\nWe call commit() on it when we’re done.\n\nFor the curious, the insert_batch and get_allocated_batch_ref helpers look like this:\n\nHelpers for doing SQL stuff (tests/integration/test_uow.py)\n\ndef insert_batch(session, ref, sku, qty, eta): session.execute( 'INSERT INTO batches (reference, sku, _purchased_quantity, eta)' ' VALUES (:ref, :sku, :qty, :eta)', dict(ref=ref, sku=sku, qty=qty, eta=eta) )\n\ndef get_allocated_batch_ref(session, orderid, sku): [[orderlineid]] = session.execute( 'SELECT id FROM order_lines WHERE orderid=:orderid AND sku=:sku', dict(orderid=orderid, sku=sku) ) [[batchref]] = session.execute( 'SELECT b.reference FROM allocations JOIN batches AS b ON batch_id = b.id' ' WHERE orderline_id=:orderlineid', dict(orderlineid=orderlineid) ) return batchref\n\nUnit of Work and Its Context Manager\n\nIn our tests we’ve implicitly defined an interface for what a UoW\n\nneeds to do. Let’s make that explicit by using an abstract base class:\n\nAbstract UoW context manager (src/allocation/service_layer/unit_of_work.py)\n\nclass AbstractUnitOfWork(abc.ABC): batches: repository.AbstractRepository\n\ndef __exit__(self, *args): self.rollback()\n\n@abc.abstractmethod def commit(self): raise NotImplementedError\n\n@abc.abstractmethod def rollback(self): raise NotImplementedError\n\nThe UoW provides an attribute called .batches, which will give us access to the batches repository.\n\nIf you’ve never seen a context manager, __enter__ and __exit__ are the two magic methods that execute when we enter the with block and when we exit it, respectively. They’re our setup and teardown phases.\n\nWe’ll call this method to explicitly commit our work when we’re ready.\n\nIf we don’t commit, or if we exit the context manager by raising an error, we do a rollback. (The rollback has no effect if commit() has been called. Read on for more discussion of this.)\n\nThe Real Unit of Work Uses SQLAlchemy Sessions\n\nThe main thing that our concrete implementation adds is the database\n\nsession:\n\nThe real SQLAlchemy UoW (src/allocation/service_layer/unit_of_work.py)\n\nDEFAULT_SESSION_FACTORY = sessionmaker(bind=create_engine( config.get_postgres_uri(), ))\n\nclass SqlAlchemyUnitOfWork(AbstractUnitOfWork):\n\ndef __init__(self, session_factory=DEFAULT_SESSION_FACTORY): self.session_factory = session_factory\n\ndef __enter__(self): self.session = self.session_factory() # type: Session self.batches = repository.SqlAlchemyRepository(self.session) return super().__enter__()\n\ndef __exit__(self, *args): super().__exit__(*args) self.session.close()\n\ndef commit(self): self.session.commit()\n\ndef rollback(self): self.session.rollback()\n\nThe module defines a default session factory that will connect to Postgres, but we allow that to be overridden in our integration tests so that we can use SQLite instead.\n\nThe __enter__ method is responsible for starting a database session and instantiating a real repository that can use that session.\n\nWe close the session on exit.\n\nFinally, we provide concrete commit() and rollback() methods that use our database session.\n\nFake Unit of Work for Testing\n\nHere’s how we use a fake UoW in our service-layer tests:",
      "page_number": 150
    },
    {
      "number": 6,
      "title": "Unit of Work Pattern",
      "start_page": 164,
      "end_page": 184,
      "detection_method": "regex_chapter_title",
      "content": "Fake UoW (tests/unit/test_services.py)\n\nclass FakeUnitOfWork(unit_of_work.AbstractUnitOfWork):\n\ndef __init__(self): self.batches = FakeRepository([]) self.committed = False\n\ndef commit(self): self.committed = True\n\ndef rollback(self): pass\n\ndef test_add_batch(): uow = FakeUnitOfWork() services.add_batch(\"b1\", \"CRUNCHY-ARMCHAIR\", 100, None, uow) assert uow.batches.get(\"b1\") is not None assert uow.committed\n\ndef test_allocate_returns_allocation(): uow = FakeUnitOfWork() services.add_batch(\"batch1\", \"COMPLICATED-LAMP\", 100, None, uow) result = services.allocate(\"o1\", \"COMPLICATED-LAMP\", 10, uow) assert result == \"batch1\" ...\n\nFakeUnitOfWork and FakeRepository are tightly coupled, just like the real UnitofWork and Repository classes. That’s fine because we recognize that the objects are collaborators.\n\nNotice the similarity with the fake commit() function from FakeSession (which we can now get rid of). But it’s a substantial improvement because we’re now faking out code that we wrote rather than third-party code. Some people say, “Don’t mock what you don’t own”.\n\nIn our tests, we can instantiate a UoW and pass it to our service layer, rather than passing a repository and a session. This is considerably less cumbersome.\n\nDON’T MOCK WHAT YOU DON’T OWN\n\nWhy do we feel more comfortable mocking the UoW than the session? Both of our fakes achieve the same thing: they give us a way to swap out our persistence layer so we can run tests in memory instead of needing to talk to a real database. The difference is in the resulting design.\n\nIf we cared only about writing tests that run quickly, we could create mocks that replace SQLAlchemy and use those throughout our codebase. The problem is that Session is a complex object that exposes lots of persistence-related functionality. It’s easy to use Session to make arbitrary queries against the database, but that quickly leads to data access code being sprinkled all over the codebase. To avoid that, we want to limit access to our persistence layer so each component has exactly what it needs and nothing more.\n\nBy coupling to the Session interface, you’re choosing to couple to all the complexity of SQLAlchemy. Instead, we want to choose a simpler abstraction and use that to clearly separate responsibilities. Our UoW is much simpler than a session, and we feel comfortable with the service layer being able to start and stop units of work.\n\n“Don’t mock what you don’t own” is a rule of thumb that forces us to build these simple abstractions over messy subsystems. This has the same performance benefit as mocking the SQLAlchemy session but encourages us to think carefully about our designs.\n\nUsing the UoW in the Service Layer\n\nHere’s what our new service layer looks like:\n\nService layer using UoW (src/allocation/service_layer/services.py)\n\ndef add_batch( ref: str, sku: str, qty: int, eta: Optional[date], uow: unit_of_work.AbstractUnitOfWork ): with uow: uow.batches.add(model.Batch(ref, sku, qty, eta)) uow.commit()\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(orderid, sku, qty) with uow: batches = uow.batches.list() if not is_valid_sku(line.sku, batches): raise InvalidSku(f'Invalid sku {line.sku}') batchref = model.allocate(line, batches) uow.commit() return batchref\n\nOur service layer now has only the one dependency, once again on an abstract UoW.\n\nExplicit Tests for Commit/Rollback Behavior\n\nTo convince ourselves that the commit/rollback behavior works, we\n\nwrote a couple of tests:\n\nIntegration tests for rollback behavior (tests/integration/test_uow.py)\n\ndef test_rolls_back_uncommitted_work_by_default(session_factory): uow = unit_of_work.SqlAlchemyUnitOfWork(session_factory) with uow: insert_batch(uow.session, 'batch1', 'MEDIUM-PLINTH', 100, None)\n\nnew_session = session_factory() rows = list(new_session.execute('SELECT * FROM \"batches\"')) assert rows == []\n\ndef test_rolls_back_on_error(session_factory): class MyException(Exception): pass\n\nuow = unit_of_work.SqlAlchemyUnitOfWork(session_factory) with pytest.raises(MyException): with uow: insert_batch(uow.session, 'batch1', 'LARGE-FORK', 100, None) raise MyException()\n\nnew_session = session_factory() rows = list(new_session.execute('SELECT * FROM \"batches\"')) assert rows == []\n\nTIP\n\nWe haven’t shown it here, but it can be worth testing some of the more “obscure” database behavior, like transactions, against the “real” database—that is, the same engine. For now, we’re getting away with using SQLite instead of Postgres, but in Chapter 7, we’ll switch some of the tests to using the real database. It’s convenient that our UoW class makes that easy!\n\nExplicit Versus Implicit Commits\n\nNow we briefly digress on different ways of implementing the UoW pattern.\n\nWe could imagine a slightly different version of the UoW that commits by default and rolls back only if it spots an exception:\n\nA UoW with implicit commit… (src/allocation/unit_of_work.py)\n\nclass AbstractUnitOfWork(abc.ABC):\n\ndef __enter__(self): return self\n\ndef __exit__(self, exn_type, exn_value, traceback): if exn_type is None: self.commit() else: self.rollback()\n\nShould we have an implicit commit in the happy path?\n\nAnd roll back only on exception?\n\nIt would allow us to save a line of code and to remove the explicit commit from our client code:\n\n...would save us a line of code (src/allocation/service_layer/services.py)\n\ndef add_batch(ref: str, sku: str, qty: int, eta: Optional[date], uow): with uow: uow.batches.add(model.Batch(ref, sku, qty, eta)) # uow.commit()\n\nThis is a judgment call, but we tend to prefer requiring the explicit commit so that we have to choose when to flush state.\n\nAlthough we use an extra line of code, this makes the software safe by default. The default behavior is to not change anything. In turn, that makes our code easier to reason about because there’s only one code path that leads to changes in the system: total success and an explicit\n\ncommit. Any other code path, any exception, any early exit from the UoW’s scope leads to a safe state.\n\nSimilarly, we prefer to roll back by default because it’s easier to understand; this rolls back to the last commit, so either the user did one, or we blow their changes away. Harsh but simple.\n\nExamples: Using UoW to Group Multiple Operations into an Atomic Unit\n\nHere are a few examples showing the Unit of Work pattern in use. You can see how it leads to simple reasoning about what blocks of code happen together.\n\nExample 1: Reallocate\n\nSuppose we want to be able to deallocate and then reallocate orders:\n\nReallocate service function\n\ndef reallocate(line: OrderLine, uow: AbstractUnitOfWork) -> str: with uow: batch = uow.batches.get(sku=line.sku) if batch is None: raise InvalidSku(f'Invalid sku {line.sku}') batch.deallocate(line) allocate(line) uow.commit()\n\nIf deallocate() fails, we don’t want to call allocate(), obviously.\n\nIf allocate() fails, we probably don’t want to actually commit the deallocate() either.\n\nExample 2: Change Batch Quantity\n\nOur shipping company gives us a call to say that one of the container doors opened, and half our sofas have fallen into the Indian Ocean. Oops!\n\nChange quantity\n\ndef change_batch_quantity(batchref: str, new_qty: int, uow: AbstractUnitOfWork): with uow: batch = uow.batches.get(reference=batchref) batch.change_purchased_quantity(new_qty) while batch.available_quantity < 0: line = batch.deallocate_one() uow.commit()\n\nHere we may need to deallocate any number of lines. If we get a failure at any stage, we probably want to commit none of the changes.\n\nTidying Up the Integration Tests\n\nWe now have three sets of tests, all essentially pointing at the database: test_orm.py, test_repository.py, and test_uow.py. Should\n\nwe throw any away?\n\n└── tests ├── conftest.py ├── e2e │ └── test_api.py ├── integration │ ├── test_orm.py │ ├── test_repository.py │ └── test_uow.py ├── pytest.ini └── unit ├── test_allocate.py ├── test_batches.py └── test_services.py\n\nYou should always feel free to throw away tests if you think they’re not going to add value longer term. We’d say that test_orm.py was\n\nprimarily a tool to help us learn SQLAlchemy, so we won’t need that long term, especially if the main things it’s doing are covered in test_repository.py. That last test, you might keep around, but we could certainly see an argument for just keeping everything at the highest\n\npossible level of abstraction (just as we did for the unit tests).\n\nEXERCISE FOR THE READER\n\nFor this chapter, probably the best thing to try is to implement a UoW from scratch. The code, as always, is on GitHub. You could either follow the model we have quite closely, or perhaps experiment with separating the UoW (whose responsibilities are commit(), rollback(), and providing the .batches repository) from the context manager, whose job is to initialize things, and then do the commit or rollback on exit. If you feel like going all-functional rather than messing about with all these classes, you could use @contextmanager from contextlib.\n\nWe’ve stripped out both the actual UoW and the fakes, as well as paring back the abstract UoW. Why not send us a link to your repo if you come up with something you’re particularly proud of?\n\nTIP\n\nThis is another example of the lesson from Chapter 5: as we build better abstractions, we can move our tests to run against them, which leaves us free to change the underlying details.\n\nWrap-Up\n\nHopefully we’ve convinced you that the Unit of Work pattern is useful,\n\nand that the context manager is a really nice Pythonic way of visually grouping code into blocks that we want to happen atomically.\n\nThis pattern is so useful, in fact, that SQLAlchemy already uses a UoW in the shape of the Session object. The Session object in SQLAlchemy is the way that your application loads data from the database.\n\nEvery time you load a new entity from the database, the session begins to track changes to the entity, and when the session is flushed, all your changes are persisted together. Why do we go to the effort of\n\nabstracting away the SQLAlchemy session if it already implements the pattern we want?\n\nTable 6-1 discusses some of the trade-offs.\n\nTable 6-1. Unit of Work pattern: the trade-offs\n\nPros\n\nCons\n\nWe have a nice abstraction over the concept of atomic operations, and the context manager makes it easy to see, visually, what blocks of code are grouped together atomically.\n\nYour ORM probably already has some perfectly good abstractions around atomicity. SQLAlchemy even has context managers. You can go a long way just passing a session around.\n\nWe have explicit control over when a transaction starts and finishes, and our application fails in a way that is safe by default. We never have to worry that an operation is partially committed.\n\nWe’ve made it look easy, but you have to think quite carefully about things like rollbacks, multithreading, and nested transactions. Perhaps just sticking to what Django or Flask-SQLAlchemy gives you will keep your life simpler.\n\nIt’s a nice place to put all your repositories so client code can access them.\n\nAs you’ll see in later chapters, atomicity isn’t only about transactions; it can help us work with events and the message bus.\n\nFor one thing, the Session API is rich and supports operations that we don’t want or need in our domain. Our UnitOfWork simplifies the session to its essential core: it can be started, committed, or thrown away.\n\nFor another, we’re using the UnitOfWork to access our Repository objects. This is a neat bit of developer usability that we couldn’t do with a plain SQLAlchemy Session.\n\nUNIT OF WORK PATTERN RECAP\n\nThe Unit of Work pattern is an abstraction around data integrity\n\nIt helps to enforce the consistency of our domain model, and improves performance, by letting us perform a single flush operation at the end of an operation.\n\nIt works closely with the Repository and Service Layer patterns\n\nThe Unit of Work pattern completes our abstractions over data access by representing atomic updates. Each of our service-layer use cases runs in a single unit of work that succeeds or fails as a block.\n\nThis is a lovely case for a context manager\n\nContext managers are an idiomatic way of defining scope in Python. We can use a context manager to automatically roll back our work at the end of a request, which means the system is safe by default.\n\nSQLAlchemy already implements this pattern\n\nWe introduce an even simpler abstraction over the SQLAlchemy Session object in order to “narrow” the interface between the ORM and our code. This helps to keep us loosely coupled.\n\nLastly, we’re motivated again by the dependency inversion principle: our service layer depends on a thin abstraction, and we attach a concrete implementation at the outside edge of the system. This lines up nicely with SQLAlchemy’s own recommendations:\n\nKeep the life cycle of the session (and usually the transaction) separate and external. The most comprehensive approach, recommended for more substantial applications, will try to keep the details of session, transaction, and exception management as far as possible from the details of the program doing its work.\n\n—SQLALchemy “Session Basics” Documentation\n\n1 You may have come across the use of the word collaborators to describe objects that\n\nwork together to achieve a goal. The unit of work and the repository are a great example of collaborators in the object-modeling sense. In responsibility-driven design, clusters of objects that collaborate in their roles are called object neighborhoods, which is, in our professional opinion, totally adorable.\n\nChapter 7. Aggregates and Consistency Boundaries\n\nIn this chapter, we’d like to revisit our domain model to talk about invariants and constraints, and see how our domain objects can maintain their own internal consistency, both conceptually and in\n\npersistent storage. We’ll discuss the concept of a consistency\n\nboundary and show how making it explicit can help us to build high- performance software without compromising maintainability.\n\nFigure 7-1 shows a preview of where we’re headed: we’ll introduce a new model object called Product to wrap multiple batches, and we’ll make the old allocate() domain service available as a method on Product instead.\n\nWhy? Let’s find out.\n\nFigure 7-1. Adding the Product aggregate\n\nTIP\n\nThe code for this chapter is in the appendix_csvs branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout appendix_csvs # or to code along, checkout the previous chapter: git checkout chapter_06_uow\n\nWhy Not Just Run Everything in a Spreadsheet?\n\nWhat’s the point of a domain model, anyway? What’s the fundamental\n\nproblem we’re trying to address?\n\nCouldn’t we just run everything in a spreadsheet? Many of our users\n\nwould be delighted by that. Business users like spreadsheets because they’re simple, familiar, and yet enormously powerful.\n\nIn fact, an enormous number of business processes do operate by manually sending spreadsheets back and forth over email. This “CSV over SMTP” architecture has low initial complexity but tends not to scale very well because it’s difficult to apply logic and maintain consistency.\n\nWho is allowed to view this particular field? Who’s allowed to update it? What happens when we try to order –350 chairs, or 10,000,000 tables? Can an employee have a negative salary?\n\nThese are the constraints of a system. Much of the domain logic we write exists to enforce these constraints in order to maintain the invariants of the system. The invariants are the things that have to be true whenever we finish an operation.\n\nInvariants, Constraints, and Consistency\n\nThe two words are somewhat interchangeable, but a constraint is a rule that restricts the possible states our model can get into, while an invariant is defined a little more precisely as a condition that is always true.\n\nIf we were writing a hotel-booking system, we might have the constraint that double bookings are not allowed. This supports the invariant that a room cannot have more than one booking for the same night.\n\nOf course, sometimes we might need to temporarily bend the rules. Perhaps we need to shuffle the rooms around because of a VIP booking. While we’re moving bookings around in memory, we might be double booked, but our domain model should ensure that, when\n\nwe’re finished, we end up in a final consistent state, where the invariants are met. If we can’t find a way to accommodate all our guests, we should raise an error and refuse to complete the operation.\n\nLet’s look at a couple of concrete examples from our business requirements; we’ll start with this one:\n\nAn order line can be allocated to only one batch at a time. —The business\n\nThis is a business rule that imposes an invariant. The invariant is that an order line is allocated to either zero or one batch, but never more than one. We need to make sure that our code never accidentally calls Batch.allocate() on two different batches for the same line, and currently, there’s nothing there to explicitly stop us from doing that.\n\nInvariants, Concurrency, and Locks\n\nLet’s look at another one of our business rules:\n\nWe can’t allocate to a batch if the available quantity is less than the quantity of the order line.\n\n—The business\n\nHere the constraint is that we can’t allocate more stock than is available to a batch, so we never oversell stock by allocating two customers to the same physical cushion, for example. Every time we update the state of the system, our code needs to ensure that we don’t break the invariant, which is that the available quantity must be greater than or equal to zero.\n\nIn a single-threaded, single-user application, it’s relatively easy for us to maintain this invariant. We can just allocate stock one line at a time, and raise an error if there’s no stock available.\n\nThis gets much harder when we introduce the idea of concurrency. Suddenly we might be allocating stock for multiple order lines\n\nsimultaneously. We might even be allocating order lines at the same time as processing changes to the batches themselves.\n\nWe usually solve this problem by applying locks to our database tables. This prevents two operations from happening simultaneously on the same row or same table.\n\nAs we start to think about scaling up our app, we realize that our model of allocating lines against all available batches may not scale. If we process tens of thousands of orders per hour, and hundreds of thousands of order lines, we can’t hold a lock over the whole batches table for every single one—we’ll get deadlocks or performance problems at the very least.\n\nWhat Is an Aggregate?\n\nOK, so if we can’t lock the whole database every time we want to allocate an order line, what should we do instead? We want to protect the invariants of our system but allow for the greatest degree of concurrency. Maintaining our invariants inevitably means preventing concurrent writes; if multiple users can allocate DEADLY-SPOON at the same time, we run the risk of overallocating.\n\nOn the other hand, there’s no reason we can’t allocate DEADLY-SPOON at the same time as FLIMSY-DESK. It’s safe to allocate two products at the same time because there’s no invariant that covers them both. We don’t need them to be consistent with each other.\n\nThe Aggregate pattern is a design pattern from the DDD community\n\nthat helps us to resolve this tension. An aggregate is just a domain object that contains other domain objects and lets us treat the whole collection as a single unit.\n\nThe only way to modify the objects inside the aggregate is to load the whole thing, and to call methods on the aggregate itself.\n\nAs a model gets more complex and grows more entity and value objects, referencing each other in a tangled graph, it can be hard to\n\nkeep track of who can modify what. Especially when we have collections in the model as we do (our batches are a collection), it’s a\n\ngood idea to nominate some entities to be the single entrypoint for modifying their related objects. It makes the system conceptually\n\nsimpler and easy to reason about if you nominate some objects to be in\n\ncharge of consistency for the others.\n\nFor example, if we’re building a shopping site, the Cart might make a\n\ngood aggregate: it’s a collection of items that we can treat as a single\n\nunit. Importantly, we want to load the entire basket as a single blob from our data store. We don’t want two requests to modify the basket\n\nat the same time, or we run the risk of weird concurrency errors. Instead, we want each change to the basket to run in a single database\n\ntransaction.\n\nWe don’t want to modify multiple baskets in a transaction, because there’s no use case for changing the baskets of several customers at the\n\nsame time. Each basket is a single consistency boundary responsible for maintaining its own invariants.\n\nAn AGGREGATE is a cluster of associated objects that we treat as a unit for the purpose of data changes.\n\n—Eric Evans, Domain-Driven Design blue book\n\nPer Evans, our aggregate has a root entity (the Cart) that encapsulates\n\naccess to items. Each item has its own identity, but other parts of the system will always refer to the Cart only as an indivisible whole.\n\nTIP\n\nJust as we sometimes use _leading_underscores to mark methods or functions as “private,” you can think of aggregates as being the “public” classes of our model, and the rest of the entities and value objects as “private.”\n\nChoosing an Aggregate\n\nWhat aggregate should we use for our system? The choice is somewhat arbitrary, but it’s important. The aggregate will be the boundary where\n\nwe make sure every operation ends in a consistent state. This helps us to reason about our software and prevent weird race issues. We want\n\nto draw a boundary around a small number of objects—the smaller, the better, for performance—that have to be consistent with one another,\n\nand we need to give this boundary a good name.\n\nThe object we’re manipulating under the covers is Batch. What do we call a collection of batches? How should we divide all the batches in\n\nthe system into discrete islands of consistency?\n\nWe could use Shipment as our boundary. Each shipment contains several batches, and they all travel to our warehouse at the same time.\n\nOr perhaps we could use Warehouse as our boundary: each warehouse contains many batches, and counting all the stock at the same time could make sense.\n\nNeither of these concepts really satisfies us, though. We should be able to allocate DEADLY-SPOONs and FLIMSY-DESKs at the same time, even if they’re in the same warehouse or the same shipment. These concepts\n\nhave the wrong granularity.\n\nWhen we allocate an order line, we’re interested only in batches that have the same SKU as the order line. Some sort of concept like GlobalSkuStock could work: a collection of all the batches for a given SKU.\n\nIt’s an unwieldy name, though, so after some bikeshedding via SkuStock, Stock, ProductStock, and so on, we decided to simply call it Product—after all, that was the first concept we came across in our exploration of the domain language back in Chapter 1.\n\nSo the plan is this: when we want to allocate an order line, instead of Figure 7-2, where we look up all the Batch objects in the world and pass them to the allocate() domain service…",
      "page_number": 164
    },
    {
      "number": 7,
      "title": "Aggregates and Consistency Boundaries",
      "start_page": 185,
      "end_page": 222,
      "detection_method": "regex_chapter_title",
      "content": "Figure 7-2. Before: allocate against all batches using the domain service\n\n…we’ll move to the world of Figure 7-3, in which there is a new Product object for the particular SKU of our order line, and it will be in charge of all the batches for that SKU, and we can call a .allocate() method on that instead.\n\nFigure 7-3. After: ask Product to allocate against its batches\n\nLet’s see how that looks in code form:\n\nOur chosen aggregate, Product (src/allocation/domain/model.py)\n\nclass Product:\n\ndef __init__(self, sku: str, batches: List[Batch]): self.sku = sku self.batches = batches\n\ndef allocate(self, line: OrderLine) -> str: try: batch = next( b for b in sorted(self.batches) if b.can_allocate(line) ) batch.allocate(line) return batch.reference except StopIteration: raise OutOfStock(f'Out of stock for sku {line.sku}')\n\nProduct’s main identifier is the sku.\n\nOur Product class holds a reference to a collection of batches for that SKU.\n\nFinally, we can move the allocate() domain service to be a method on the Product aggregate.\n\nNOTE\n\nThis Product might not look like what you’d expect a Product model to look like. No price, no description, no dimensions. Our allocation service doesn’t care about any of those things. This is the power of bounded contexts; the concept of a product in one app can be very different from another. See the following sidebar for more discussion.\n\nAGGREGATES, BOUNDED CONTEXTS, AND MICROSERVICES\n\nOne of the most important contributions from Evans and the DDD community is the concept of bounded contexts.\n\nIn essence, this was a reaction against attempts to capture entire businesses into a single model. The word customer means different things to people in sales, customer service, logistics, support, and so on. Attributes needed in one context are irrelevant in another; more perniciously, concepts with the same name can have entirely different meanings in different contexts. Rather than trying to build a single model (or class, or database) to capture all the use cases, it’s better to have several models, draw boundaries around each context, and handle the translation between different contexts explicitly.\n\nThis concept translates very well to the world of microservices, where each microservice is free to have its own concept of “customer” and its own rules for translating that to and from other microservices it integrates with.\n\nIn our example, the allocation service has Product(sku, batches), whereas the ecommerce will have Product(sku, description, price, image_url, dimensions, etc...). As a rule of thumb, your domain models should include only the data that they need for performing calculations.\n\nWhether or not you have a microservices architecture, a key consideration in choosing your aggregates is also choosing the bounded context that they will operate in. By restricting the context, you can keep your number of aggregates low and their size manageable.\n\nOnce again, we find ourselves forced to say that we can’t give this issue the treatment it deserves here, and we can only encourage you to read up on it elsewhere. The Fowler link at the start of this sidebar is a good starting point, and either (or indeed, any) DDD book will have a chapter or more on bounded contexts.\n\nOne Aggregate = One Repository\n\nOnce you define certain entities to be aggregates, we need to apply the\n\nrule that they are the only entities that are publicly accessible to the outside world. In other words, the only repositories we are allowed should be repositories that return aggregates.\n\nNOTE\n\nThe rule that repositories should only return aggregates is the main place where we enforce the convention that aggregates are the only way into our domain model. Be wary of breaking it!\n\nIn our case, we’ll switch from BatchRepository to ProductRepository:\n\nOur new UoW and repository (unit_of_work.py and repository.py)\n\nclass AbstractUnitOfWork(abc.ABC): products: repository.AbstractProductRepository\n\n...\n\nclass AbstractProductRepository(abc.ABC):\n\n@abc.abstractmethod def add(self, product): ...\n\n@abc.abstractmethod def get(self, sku) -> model.Product: ...\n\nThe ORM layer will need some tweaks so that the right batches automatically get loaded and associated with Product objects. The nice thing is, the Repository pattern means we don’t have to worry about that yet. We can just use our FakeRepository and then feed through the new model into our service layer to see how it looks with Product as its main entrypoint:\n\nService layer (src/allocation/service_layer/services.py)\n\ndef add_batch( ref: str, sku: str, qty: int, eta: Optional[date], uow: unit_of_work.AbstractUnitOfWork ): with uow: product = uow.products.get(sku=sku) if product is None: product = model.Product(sku, batches=[]) uow.products.add(product) product.batches.append(model.Batch(ref, sku, qty, eta)) uow.commit()\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(orderid, sku, qty) with uow: product = uow.products.get(sku=line.sku) if product is None: raise InvalidSku(f'Invalid sku {line.sku}') batchref = product.allocate(line) uow.commit() return batchref\n\nWhat About Performance?\n\nWe’ve mentioned a few times that we’re modeling with aggregates because we want to have high-performance software, but here we are loading all the batches when we only need one. You might expect that to be inefficient, but there are a few reasons why we’re comfortable\n\nhere.\n\nFirst, we’re purposefully modeling our data so that we can make a single query to the database to read, and a single update to persist our\n\nchanges. This tends to perform much better than systems that issue lots of ad hoc queries. In systems that don’t model this way, we often find that transactions slowly get longer and more complex as the software\n\nevolves.\n\nSecond, our data structures are minimal and comprise a few strings and integers per row. We can easily load tens or even hundreds of\n\nbatches in a few milliseconds.\n\nThird, we expect to have only 20 or so batches of each product at a time. Once a batch is used up, we can discount it from our\n\ncalculations. This means that the amount of data we’re fetching shouldn’t get out of control over time.\n\nIf we did expect to have thousands of active batches for a product,\n\nwe’d have a couple of options. For one, we could use lazy-loading for the batches in a product. From the perspective of our code, nothing would change, but in the background, SQLAlchemy would page through data for us. This would lead to more requests, each fetching a\n\nsmaller number of rows. Because we need to find only a single batch with enough capacity for our order, this might work pretty well.\n\nEXERCISE FOR THE READER\n\nYou’ve just seen the main top layers of the code, so this shouldn’t be too hard, but we’d like you to implement the Product aggregate starting from Batch, just as we did.\n\nOf course, you could cheat and copy/paste from the previous listings, but even if you do that, you’ll still have to solve a few challenges on your own, like adding the model to the ORM and making sure all the moving parts can talk to each other, which we hope will be instructive.\n\nYou’ll find the code on GitHub. We’ve put in a “cheating” implementation in the delegates to the existing allocate() function, so you should be able to evolve that toward the real thing.\n\nWe’ve marked a couple of tests with @pytest.skip(). After you’ve read the rest of this chapter, come back to these tests to have a go at implementing version numbers. Bonus points if you can get SQLAlchemy to do them for you by magic!\n\nIf all else failed, we’d just look for a different aggregate. Maybe we could split up batches by region or by warehouse. Maybe we could\n\nredesign our data access strategy around the shipment concept. The Aggregate pattern is designed to help manage some technical constraints around consistency and performance. There isn’t one correct aggregate, and we should feel comfortable changing our minds\n\nif we find our boundaries are causing performance woes.\n\nOptimistic Concurrency with Version Numbers\n\nWe have our new aggregate, so we’ve solved the conceptual problem\n\nof choosing an object to be in charge of consistency boundaries. Let’s now spend a little time talking about how to enforce data integrity at the database level.\n\nNOTE\n\nThis section has a lot of implementation details; for example, some of it is Postgres-specific. But more generally, we’re showing one way of managing concurrency issues, but it is just one approach. Real requirements in this area vary a lot from project to project. You shouldn’t expect to be able to copy and paste code from here into production.\n\nWe don’t want to hold a lock over the entire batches table, but how will we implement holding a lock over just the rows for a particular SKU?\n\nOne answer is to have a single attribute on the Product model that acts as a marker for the whole state change being complete and to use\n\nit as the single resource that concurrent workers can fight over. If two transactions read the state of the world for batches at the same time, and both want to update the allocations tables, we force both to also try to update the version_number in the products table, in such a way that only one of them can win and the world stays consistent.\n\nFigure 7-4 illustrates two concurrent transactions doing their read operations at the same time, so they see a Product with, for example, version=3. They both call Product.allocate() in order to modify a state. But we set up our database integrity rules such that only one of them is allowed to commit the new Product with version=4, and the other update is rejected.\n\nTIP\n\nVersion numbers are just one way to implement optimistic locking. You could achieve the same thing by setting the Postgres transaction isolation level to SERIALIZABLE, but that often comes at a severe performance cost. Version numbers also make implicit concepts explicit.\n\nFigure 7-4. Sequence diagram: two transactions attempting a concurrent update on Product\n\nOPTIMISTIC CONCURRENCY CONTROL AND RETRIES\n\nWhat we’ve implemented here is called optimistic concurrency control because our default assumption is that everything will be fine when two users want to make changes to the database. We think it’s unlikely that they will conflict with each other, so we let them go ahead and just make sure we have a way to notice if there is a problem.\n\nPessimistic concurrency control works under the assumption that two users are going to cause conflicts, and we want to prevent conflicts in all cases, so we lock everything just to be safe. In our example, that would mean locking the whole batches table, or using SELECT FOR UPDATE— we’re pretending that we’ve ruled those out for performance reasons, but in real life you’d want to do some evaluations and measurements of your own.\n\nWith pessimistic locking, you don’t need to think about handling failures because the database will prevent them for you (although you do need to think about deadlocks). With optimistic locking, you need to explicitly handle the possibility of failures in the (hopefully unlikely) case of a clash.\n\nThe usual way to handle a failure is to retry the failed operation from the beginning. Imagine we have two customers, Harry and Bob, and each submits an order for SHINY-TABLE. Both threads load the product at version 1 and allocate stock. The database prevents the concurrent update, and Bob’s order fails with an error. When we retry the operation, Bob’s order loads the product at version 2 and tries to allocate again. If there is enough stock left, all is well; otherwise, he’ll receive OutOfStock. Most operations can be retried this way in the case of a concurrency problem.\n\nRead more on retries in “Recovering from Errors Synchronously” and “Footguns”.\n\nImplementation Options for Version Numbers\n\nThere are essentially three options for implementing version numbers:\n\n1. version_number lives in the domain; we add it to the Product constructor, and Product.allocate() is responsible for incrementing it.\n\n2. The service layer could do it! The version number isn’t strictly a domain concern, so instead our service layer could assume that the current version number is attached to Product by the repository, and the service layer will increment it before it does the commit().\n\n3. Since it’s arguably an infrastructure concern, the UoW and repository could do it by magic. The repository has access to version numbers for any products it retrieves, and when the UoW does a commit, it can increment the version number for any products it knows about, assuming them to have changed.\n\nOption 3 isn’t ideal, because there’s no real way of doing it without\n\nhaving to assume that all products have changed, so we’ll be incrementing version numbers when we don’t have to.\n\n1\n\nOption 2 involves mixing the responsibility for mutating state between\n\nthe service layer and the domain layer, so it’s a little messy as well.\n\nSo in the end, even though version numbers don’t have to be a domain concern, you might decide the cleanest trade-off is to put them in the\n\ndomain:\n\nOur chosen aggregate, Product (src/allocation/domain/model.py)\n\nclass Product:\n\ndef __init__(self, sku: str, batches: List[Batch], version_number: int = 0):\n\nself.sku = sku self.batches = batches self.version_number = version_number\n\ndef allocate(self, line: OrderLine) -> str: try: batch = next( b for b in sorted(self.batches) if b.can_allocate(line) ) batch.allocate(line) self.version_number += 1 return batch.reference\n\nexcept StopIteration: raise OutOfStock(f'Out of stock for sku {line.sku}')\n\nThere it is!\n\nTIP\n\nIf you’re scratching your head at this version number business, it might help to remember that the number isn’t important. What’s important is that the Product database row is modified whenever we make a change to the Product aggregate. The version number is a simple, human-comprehensible way to model a thing that changes on every write, but it could equally be a random UUID every time.\n\nTesting for Our Data Integrity Rules\n\nNow to make sure we can get the behavior we want: if we have two concurrent attempts to do allocation against the same Product, one of them should fail, because they can’t both update the version number.\n\nFirst, let’s simulate a “slow” transaction using a function that does allocation and then does an explicit sleep:\n\n2\n\ntime.sleep can reproduce concurrency behavior (tests/integration/test_uow.py)\n\ndef try_to_allocate(orderid, sku, exceptions): line = model.OrderLine(orderid, sku, 10) try: with unit_of_work.SqlAlchemyUnitOfWork() as uow: product = uow.products.get(sku=sku) product.allocate(line) time.sleep(0.2)\n\nuow.commit() except Exception as e: print(traceback.format_exc()) exceptions.append(e)\n\nThen we have our test invoke this slow allocation twice, concurrently, using threads:\n\nAn integration test for concurrency behavior\n\n(tests/integration/test_uow.py)\n\ndef test_concurrent_updates_to_version_are_not_allowed(postgres_session_factory): sku, batch = random_sku(), random_batchref() session = postgres_session_factory() insert_batch(session, batch, sku, 100, eta=None, product_version=1) session.commit()\n\norder1, order2 = random_orderid(1), random_orderid(2) exceptions = [] # type: List[Exception] try_to_allocate_order1 = lambda: try_to_allocate(order1, sku, exceptions) try_to_allocate_order2 = lambda: try_to_allocate(order2, sku, exceptions) thread1 = threading.Thread(target=try_to_allocate_order1) thread2 = threading.Thread(target=try_to_allocate_order2) thread1.start() thread2.start() thread1.join() thread2.join()\n\n[[version]] = session.execute( \"SELECT version_number FROM products WHERE sku=:sku\", dict(sku=sku), ) assert version == 2 [exception] = exceptions assert 'could not serialize access due to concurrent update' in str(exception)\n\norders = list(session.execute( \"SELECT orderid FROM allocations\" \" JOIN batches ON allocations.batch_id = batches.id\" \" JOIN order_lines ON allocations.orderline_id = order_lines.id\" \" WHERE order_lines.sku=:sku\", dict(sku=sku), )) assert len(orders) == 1 with unit_of_work.SqlAlchemyUnitOfWork() as uow: uow.session.execute('select 1')\n\nWe start two threads that will reliably produce the concurrency behavior we want: read1, read2, write1, write2.\n\nWe assert that the version number has been incremented only once.\n\nWe can also check on the specific exception if we like.\n\nAnd we double-check that only one allocation has gotten through.\n\nEnforcing Concurrency Rules by Using Database Transaction Isolation Levels\n\nTo get the test to pass as it is, we can set the transaction isolation level\n\non our session:\n\nSet isolation level for session (src/allocation/service_layer/unit_of_work.py)\n\nDEFAULT_SESSION_FACTORY = sessionmaker(bind=create_engine( config.get_postgres_uri(), isolation_level=\"REPEATABLE READ\", ))\n\nTIP\n\nTransaction isolation levels are tricky stuff, so it’s worth spending time understanding the Postgres documentation.\n\n3\n\nPessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nThere are multiple ways to approach this, but we’ll show one. SELECT FOR UPDATE produces different behavior; two concurrent transactions will not be allowed to do a read on the same rows at the same time:\n\nSELECT FOR UPDATE is a way of picking a row or rows to use as a lock (although those rows don’t have to be the ones you update). If two transactions both try to SELECT FOR UPDATE a row at the same time, one will win, and the other will wait until the lock is released. So this is an example of pessimistic concurrency control.\n\nHere’s how you can use the SQLAlchemy DSL to specify FOR UPDATE at query time:\n\nSQLAlchemy with_for_update (src/allocation/adapters/repository.py)\n\ndef get(self, sku): return self.session.query(model.Product) \\ .filter_by(sku=sku) \\ .with_for_update() \\ .first()\n\nThis will have the effect of changing the concurrency pattern from\n\nread1, read2, write1, write2(fail)\n\nto\n\nread1, write1, read2, write2(succeed)\n\nSome people refer to this as the “read-modify-write” failure mode. Read “PostgreSQL Anti-Patterns: Read-Modify-Write Cycles” for a good overview.\n\nWe don’t really have time to discuss all the trade-offs between REPEATABLE READ and SELECT FOR UPDATE, or optimistic versus pessimistic locking in general. But if you have a test like the one we’ve shown, you can specify the behavior you want and see how it changes. You can also use the test as a basis for performing some performance experiments.\n\nWrap-Up\n\nSpecific choices around concurrency control vary a lot based on\n\nbusiness circumstances and storage technology choices, but we’d like to bring this chapter back to the conceptual idea of an aggregate: we explicitly model an object as being the main entrypoint to some subset of our model, and as being in charge of enforcing the invariants and business rules that apply across all of those objects.\n\nChoosing the right aggregate is key, and it’s a decision you may revisit over time. You can read more about it in multiple DDD books. We also\n\nrecommend these three online papers on effective aggregate design by Vaughn Vernon (the “red book” author).\n\nTable 7-1 has some thoughts on the trade-offs of implementing the Aggregate pattern.\n\nTable 7-1. Aggregates: the trade-offs\n\nPros\n\nPython might not have “official” public and private methods, but we do have the underscores convention, because it’s often useful to try to indicate what’s for “internal” use and what’s for “outside code” to use. Choosing aggregates is just the next level up: it lets you decide which of your domain model classes are the public ones, and which aren’t.\n\nModeling our operations around explicit consistency boundaries helps us avoid performance problems with our ORM.\n\nPutting the aggregate in sole charge of state changes to its subsidiary models makes the system easier to reason about, and makes it easier to control invariants.\n\nCons\n\nYet another new concept for new developers to take on. Explaining entities versus value objects was already a mental load; now there’s a third type of domain model object?\n\nSticking rigidly to the rule that we modify only one aggregate at a time is a big mental shift.\n\nDealing with eventual consistency between aggregates can be complex.\n\nAGGREGATES AND CONSISTENCY BOUNDARIES RECAP\n\nAggregates are your entrypoints into the domain model\n\nBy restricting the number of ways that things can be changed, we make the system easier to reason about.\n\nAggregates are in charge of a consistency boundary\n\nAn aggregate’s job is to be able to manage our business rules about invariants as they apply to a group of related objects. It’s the aggregate’s job to check that the objects within its remit are consistent with each other and with our rules, and to reject changes that would break the rules.\n\nAggregates and concurrency issues go together\n\nWhen thinking about implementing these consistency checks, we end up thinking about transactions and locks. Choosing the right aggregate is about performance as well as conceptual organization of your domain.\n\nPart I Recap\n\nDo you remember Figure 7-5, the diagram we showed at the beginning of Part I to preview where we were heading?\n\nFigure 7-5. A component diagram for our app at the end of Part I\n\nSo that’s where we are at the end of Part I. What have we achieved? We’ve seen how to build a domain model that’s exercised by a set of high-level unit tests. Our tests are living documentation: they describe the behavior of our system—the rules upon which we agreed with our business stakeholders—in nice readable code. When our business requirements change, we have confidence that our tests will help us to prove the new functionality, and when new developers join the project, they can read our tests to understand how things work.\n\nWe’ve decoupled the infrastructural parts of our system, like the database and API handlers, so that we can plug them into the outside of our application. This helps us to keep our codebase well organized and stops us from building a big ball of mud.\n\nBy applying the dependency inversion principle, and by using ports- and-adapters-inspired patterns like Repository and Unit of Work,\n\nwe’ve made it possible to do TDD in both high gear and low gear and to maintain a healthy test pyramid. We can test our system edge to edge, and the need for integration and end-to-end tests is kept to a minimum.\n\nLastly, we’ve talked about the idea of consistency boundaries. We don’t want to lock our entire system whenever we make a change, so we have to choose which parts are consistent with one another.\n\nFor a small system, this is everything you need to go and play with the ideas of domain-driven design. You now have the tools to build\n\ndatabase-agnostic domain models that represent the shared language of your business experts. Hurrah!\n\nNOTE\n\nAt the risk of laboring the point—we’ve been at pains to point out that each pattern comes at a cost. Each layer of indirection has a price in terms of complexity and duplication in our code and will be confusing to programmers who’ve never seen these patterns before. If your app is essentially a simple CRUD wrapper around a database and isn’t likely to be anything more than that in the foreseeable future, you don’t need these patterns. Go ahead and use Django, and save yourself a lot of bother.\n\nIn Part II, we’ll zoom out and talk about a bigger topic: if aggregates are our boundary, and we can update only one at a time, how do we model processes that cross consistency boundaries?\n\n1 Perhaps we could get some ORM/SQLAlchemy magic to tell us when an object is dirty, but how would that work in the generic case—for example, for a CsvRepository?\n\n2 time.sleep() works well in our use case, but it’s not the most reliable or efficient way to reproduce concurrency bugs. Consider using semaphores or similar synchronization primitives shared between your threads to get better guarantees of behavior.\n\n3 If you’re not using Postgres, you’ll need to read different documentation. Annoyingly, different databases all have quite different definitions. Oracle’s SERIALIZABLE is equivalent to Postgres’s REPEATABLE READ, for example.\n\nPart II. Event-Driven Architecture\n\nI’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea.\n\nThe big idea is “messaging.\"…The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.\n\n—Alan Kay\n\nIt’s all very well being able to write one domain model to manage a\n\nsingle bit of business process, but what happens when we need to write many models? In the real world, our applications sit within an\n\norganization and need to exchange information with other parts of the system. You may remember our context diagram shown in Figure II-1.\n\nFaced with this requirement, many teams reach for microservices integrated via HTTP APIs. But if they’re not careful, they’ll end up\n\nproducing the most chaotic mess of all: the distributed big ball of mud.\n\nIn Part II, we’ll show how the techniques from Part I can be extended to distributed systems. We’ll zoom out to look at how we can compose a system from many small components that interact through asynchronous message passing.\n\nWe’ll see how our Service Layer and Unit of Work patterns allow us to reconfigure our app to run as an asynchronous message processor, and how event-driven systems help us to decouple aggregates and applications from one another.\n\nFigure II-1. But exactly how will all these systems talk to each other?\n\nWe’ll look at the following patterns and techniques:\n\nDomain Events\n\nTrigger workflows that cross consistency boundaries.\n\nMessage Bus\n\nProvide a unified way of invoking use cases from any endpoint.\n\nCQRS\n\nSeparating reads and writes avoids awkward compromises in an event-driven architecture and enables performance and scalability improvements.\n\nPlus, we’ll add a dependency injection framework. This has nothing to do with event-driven architecture per se, but it tidies up an awful lot of loose ends.\n\nChapter 8. Events and the Message Bus\n\nSo far we’ve spent a lot of time and energy on a simple problem that we could easily have solved with Django. You might be asking if the increased testability and expressiveness are really worth all the effort.\n\nIn practice, though, we find that it’s not the obvious features that make\n\na mess of our codebases: it’s the goop around the edge. It’s reporting, and permissions, and workflows that touch a zillion objects.\n\nOur example will be a typical notification requirement: when we can’t allocate an order because we’re out of stock, we should alert the buying team. They’ll go and fix the problem by buying more stock, and\n\nall will be well.\n\nFor a first version, our product owner says we can just send the alert\n\nby email.\n\nLet’s see how our architecture holds up when we need to plug in some\n\nof the mundane stuff that makes up so much of our systems.\n\nWe’ll start by doing the simplest, most expeditious thing, and talk about why it’s exactly this kind of decision that leads us to the Big Ball of Mud.\n\nThen we’ll show how to use the Domain Events pattern to separate side effects from our use cases, and how to use a simple Message Bus pattern for triggering behavior based on those events. We’ll show a few options for creating those events and how to pass them to the\n\nmessage bus, and finally we’ll show how the Unit of Work pattern can be modified to connect the two together elegantly, as previewed in Figure 8-1.\n\nFigure 8-1. Events flowing through the system\n\nTIP\n\nThe code for this chapter is in the chapter_08_events_and_message_bus branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_08_events_and_message_bus # or to code along, checkout the previous chapter: git checkout chapter_07_aggregate\n\nAvoiding Making a Mess\n\nSo. Email alerts when we run out of stock. When we have new requirements like ones that really have nothing to do with the core domain, it’s all too easy to start dumping these things into our web controllers.\n\nFirst, Let’s Avoid Making a Mess of Our Web Controllers\n\nAs a one-off hack, this might be OK:\n\nJust whack it in the endpoint—what could go wrong? (src/allocation/entrypoints/flask_app.py)\n\n@app.route(\"/allocate\", methods=['POST']) def allocate_endpoint(): line = model.OrderLine( request.json['orderid'], request.json['sku'],\n\nrequest.json['qty'], ) try: uow = unit_of_work.SqlAlchemyUnitOfWork() batchref = services.allocate(line, uow) except (model.OutOfStock, services.InvalidSku) as e: send_mail( 'out of stock', 'stock_admin@made.com', f'{line.orderid} - {line.sku}' ) return jsonify({'message': str(e)}), 400\n\nreturn jsonify({'batchref': batchref}), 201\n\n…but it’s easy to see how we can quickly end up in a mess by patching things up like this. Sending email isn’t the job of our HTTP layer, and we’d like to be able to unit test this new feature.\n\nAnd Let’s Not Make a Mess of Our Model Either\n\nAssuming we don’t want to put this code into our web controllers, because we want them to be as thin as possible, we may look at putting it right at the source, in the model:\n\nEmail-sending code in our model isn’t lovely either (src/allocation/domain/model.py)\n\ndef allocate(self, line: OrderLine) -> str: try: batch = next( b for b in sorted(self.batches) if b.can_allocate(line) ) #... except StopIteration:\n\nemail.send_mail('stock@made.com', f'Out of stock for {line.sku}') raise OutOfStock(f'Out of stock for sku {line.sku}')\n\nBut that’s even worse! We don’t want our model to have any dependencies on infrastructure concerns like email.send_mail.\n\nThis email-sending thing is unwelcome goop messing up the nice clean flow of our system. What we’d like is to keep our domain model focused on the rule “You can’t allocate more stuff than is actually available.”\n\nThe domain model’s job is to know that we’re out of stock, but the responsibility of sending an alert belongs elsewhere. We should be able to turn this feature on or off, or to switch to SMS notifications instead, without needing to change the rules of our domain model.\n\nOr the Service Layer!\n\nThe requirement “Try to allocate some stock, and send an email if it fails” is an example of workflow orchestration: it’s a set of steps that the system has to follow to achieve a goal.\n\nWe’ve written a service layer to manage orchestration for us, but even here the feature feels out of place:\n\nAnd in the service layer, it’s out of place (src/allocation/service_layer/services.py)\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str:\n\nline = OrderLine(orderid, sku, qty) with uow: product = uow.products.get(sku=line.sku) if product is None: raise InvalidSku(f'Invalid sku {line.sku}') try: batchref = product.allocate(line) uow.commit() return batchref except model.OutOfStock: email.send_mail('stock@made.com', f'Out of stock for {line.sku}') raise\n\nCatching an exception and reraising it? It could be worse, but it’s\n\ndefinitely making us unhappy. Why is it so hard to find a suitable home for this code?\n\nSingle Responsibility Principle\n\nReally, this is a violation of the single responsibility principle (SRP). Our use case is allocation. Our endpoint, service function, and domain methods are all called allocate, not allocate_and_send_mail_if_out_of_stock.\n\n1\n\nTIP\n\nRule of thumb: if you can’t describe what your function does without using words like “then” or “and,” you might be violating the SRP.\n\nOne formulation of the SRP is that each class should have only a single\n\nreason to change. When we switch from email to SMS, we shouldn’t\n\nhave to update our allocate() function, because that’s clearly a separate responsibility.\n\nTo solve the problem, we’re going to split the orchestration into\n\nseparate steps so that the different concerns don’t get tangled up. The\n\ndomain model’s job is to know that we’re out of stock, but the responsibility of sending an alert belongs elsewhere. We should be\n\nable to turn this feature on or off, or to switch to SMS notifications instead, without needing to change the rules of our domain model.\n\nWe’d also like to keep the service layer free of implementation details.\n\nWe want to apply the dependency inversion principle to notifications so that our service layer depends on an abstraction, in the same way as\n\nwe avoid depending on the database by using a unit of work.\n\nAll Aboard the Message Bus!\n\nThe patterns we’re going to introduce here are Domain Events and the\n\nMessage Bus. We can implement them in a few ways, so we’ll show a couple before settling on the one we like most.\n\nThe Model Records Events\n\nFirst, rather than being concerned about emails, our model will be in charge of recording events—facts about things that have happened.\n\nWe’ll use a message bus to respond to events and invoke a new operation.\n\nEvents Are Simple Dataclasses\n\n2\n\nAn event is a kind of value object. Events don’t have any behavior, because they’re pure data structures. We always name events in the\n\nlanguage of the domain, and we think of them as part of our domain model.\n\nWe could store them in model.py, but we may as well keep them in\n\ntheir own file (this might be a good time to consider refactoring out a directory called domain so that we have domain/model.py and\n\ndomain/events.py):\n\nEvent classes (src/allocation/domain/events.py)\n\nfrom dataclasses import dataclass\n\nclass Event: pass\n\n@dataclass class OutOfStock(Event): sku: str\n\nOnce we have a number of events, we’ll find it useful to have a parent class that can store common attributes. It’s also useful for type hints in our message bus, as you’ll see shortly.\n\ndataclasses are great for domain events too.\n\nThe Model Raises Events\n\nWhen our domain model records a fact that happened, we say it raises\n\nan event.\n\nHere’s what it will look like from the outside; if we ask Product to allocate but it can’t, it should raise an event:\n\nTest our aggregate to raise events (tests/unit/test_product.py)\n\ndef test_records_out_of_stock_event_if_cannot_allocate(): batch = Batch('batch1', 'SMALL-FORK', 10, eta=today) product = Product(sku=\"SMALL-FORK\", batches=[batch]) product.allocate(OrderLine('order1', 'SMALL-FORK', 10))\n\nallocation = product.allocate(OrderLine('order2', 'SMALL-FORK', 1)) assert product.events[-1] == events.OutOfStock(sku=\"SMALL-FORK\") assert allocation is None\n\nOur aggregate will expose a new attribute called .events that will contain a list of facts about what has happened, in the form of Event objects.\n\nHere’s what the model looks like on the inside:\n\nThe model raises a domain event (src/allocation/domain/model.py)\n\nclass Product:\n\ndef __init__(self, sku: str, batches: List[Batch], version_number: int = 0): self.sku = sku self.batches = batches self.version_number = version_number self.events = [] # type: List[events.Event]\n\ndef allocate(self, line: OrderLine) -> str: try: #... except StopIteration: self.events.append(events.OutOfStock(line.sku)) # raise OutOfStock(f'Out of stock for sku {line.sku}') return None\n\nHere’s our new .events attribute in use.\n\nRather than invoking some email-sending code directly, we record those events at the place they occur, using only the language of the\n\ndomain.\n\nWe’re also going to stop raising an exception for the out-of-stock case. The event will do the job the exception was doing.\n\nNOTE\n\nWe’re actually addressing a code smell we had until now, which is that we were using exceptions for control flow. In general, if you’re implementing domain events, don’t raise exceptions to describe the same domain concept. As you’ll see later when we handle events in the Unit of Work pattern, it’s confusing to have to reason about events and exceptions together.\n\nThe Message Bus Maps Events to Handlers\n\nA message bus basically says, “When I see this event, I should invoke the following handler function.” In other words, it’s a simple publish-\n\nsubscribe system. Handlers are subscribed to receive events, which we publish to the bus. It sounds harder than it is, and we usually\n\nimplement it with a dict:\n\nSimple message bus (src/allocation/service_layer/messagebus.py)\n\ndef handle(event: events.Event): for handler in HANDLERS[type(event)]: handler(event)\n\ndef send_out_of_stock_notification(event: events.OutOfStock): email.send_mail( 'stock@made.com', f'Out of stock for {event.sku}', )\n\nHANDLERS = { events.OutOfStock: [send_out_of_stock_notification],\n\n} # type: Dict[Type[events.Event], List[Callable]]\n\nNOTE\n\nNote that the message bus as implemented doesn’t give us concurrency because only one handler will run at a time. Our objective isn’t to support parallel threads but to separate tasks conceptually, and to keep each UoW as small as possible. This helps us to understand the codebase because the “recipe” for how to run each use case is written in a single place. See the following sidebar.\n\nIS THIS LIKE CELERY?\n\nCelery is a popular tool in the Python world for deferring self-contained chunks of work to an asynchronous task queue. The message bus we’re presenting here is very different, so the short answer to the above question is no; our message bus has more in common with a Node.js app, a UI event loop, or an actor framework.\n\nIf you do have a requirement for moving work off the main thread, you can still use our event- based metaphors, but we suggest you use external events for that. There’s more discussion in Table 11-1, but essentially, if you implement a way of persisting events to a centralized store, you can subscribe other containers or other microservices to them. Then that same concept of using events to separate responsibilities across units of work within a single process/service can be extended across multiple processes—which may be different containers within the same service, or totally different microservices.\n\nIf you follow us in this approach, your API for distributing tasks is your event classes—or a JSON representation of them. This allows you a lot of flexibility in who you distribute tasks to; they need not necessarily be Python services. Celery’s API for distributing tasks is essentially “function name plus arguments,” which is more restrictive, and Python-only.\n\nOption 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus",
      "page_number": 185
    },
    {
      "number": 8,
      "title": "Events and the Message Bus",
      "start_page": 223,
      "end_page": 246,
      "detection_method": "regex_chapter_title",
      "content": "Our domain model raises events, and our message bus will call the\n\nright handlers whenever an event happens. Now all we need is to connect the two. We need something to catch events from the model\n\nand pass them to the message bus—the publishing step.\n\nThe simplest way to do this is by adding some code into our service layer:\n\nThe service layer with an explicit message bus\n\n(src/allocation/service_layer/services.py)\n\nfrom . import messagebus ...\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(orderid, sku, qty) with uow: product = uow.products.get(sku=line.sku) if product is None: raise InvalidSku(f'Invalid sku {line.sku}') try: batchref = product.allocate(line) uow.commit() return batchref finally: messagebus.handle(product.events)\n\nWe keep the try/finally from our ugly earlier implementation (we haven’t gotten rid of all exceptions yet, just OutOfStock).\n\nBut now, instead of depending directly on an email infrastructure, the service layer is just in charge of passing events from the model up to the message bus.\n\nThat already avoids some of the ugliness that we had in our naive\n\nimplementation, and we have several systems that work like this one, in which the service layer explicitly collects events from aggregates and passes them to the message bus.\n\nOption 2: The Service Layer Raises Its Own Events\n\nAnother variant on this that we’ve used is to have the service layer in charge of creating and raising events directly, rather than having them raised by the domain model:\n\nService layer calls messagebus.handle directly (src/allocation/service_layer/services.py)\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(orderid, sku, qty) with uow: product = uow.products.get(sku=line.sku) if product is None: raise InvalidSku(f'Invalid sku {line.sku}') batchref = product.allocate(line) uow.commit()\n\nif batchref is None: messagebus.handle(events.OutOfStock(line.sku)) return batchref\n\nAs before, we commit even if we fail to allocate because the code is simpler this way and it’s easier to reason about: we always\n\ncommit unless something goes wrong. Committing when we haven’t changed anything is safe and keeps the code uncluttered.\n\nAgain, we have applications in production that implement the pattern in this way. What works for you will depend on the particular trade-\n\noffs you face, but we’d like to show you what we think is the most elegant solution, in which we put the unit of work in charge of collecting and raising events.\n\nOption 3: The UoW Publishes Events to the Message Bus\n\nThe UoW already has a try/finally, and it knows about all the aggregates currently in play because it provides access to the repository. So it’s a good place to spot events and pass them to the message bus:\n\nThe UoW meets the message bus (src/allocation/service_layer/unit_of_work.py)\n\nclass AbstractUnitOfWork(abc.ABC): ...\n\ndef commit(self): self._commit() self.publish_events()\n\ndef publish_events(self): for product in self.products.seen: while product.events: event = product.events.pop(0) messagebus.handle(event)\n\n@abc.abstractmethod\n\ndef _commit(self): raise NotImplementedError\n\n...\n\nclass SqlAlchemyUnitOfWork(AbstractUnitOfWork): ...\n\ndef _commit(self): self.session.commit()\n\nWe’ll change our commit method to require a private ._commit() method from subclasses.\n\nAfter committing, we run through all the objects that our repository has seen and pass their events to the message bus.\n\nThat relies on the repository keeping track of aggregates that have been loaded using a new attribute, .seen, as you’ll see in the next listing.\n\nNOTE\n\nAre you wondering what happens if one of the handlers fails? We’ll discuss error handling in detail in Chapter 10.\n\nRepository tracks aggregates that pass through it (src/allocation/adapters/repository.py)\n\nclass AbstractRepository(abc.ABC):\n\ndef __init__(self): self.seen = set() # type: Set[model.Product]\n\ndef add(self, product: model.Product): self._add(product)\n\nself.seen.add(product)\n\ndef get(self, sku) -> model.Product: product = self._get(sku) if product: self.seen.add(product) return product\n\n@abc.abstractmethod def _add(self, product: model.Product): raise NotImplementedError\n\n@abc.abstractmethod def _get(self, sku) -> model.Product: raise NotImplementedError\n\nclass SqlAlchemyRepository(AbstractRepository):\n\ndef __init__(self, session): super().__init__() self.session = session\n\ndef _add(self, product): self.session.add(product)\n\ndef _get(self, sku): return self.session.query(model.Product).filter_by(sku=sku).first()\n\nFor the UoW to be able to publish new events, it needs to be able to ask the repository for which Product objects have been used during this session. We use a set called .seen to store them. That means our implementations need to call super().__init__().\n\nThe parent add() method adds things to .seen, and now requires subclasses to implement ._add().\n\nSimilarly, .get() delegates to a ._get() function, to be implemented by subclasses, in order to capture objects seen.\n\nNOTE\n\nThe use of ._underscorey() methods and subclassing is definitely not the only way you could implement these patterns. Have a go at the Exercise for the Reader in this chapter and experiment with some alternatives.\n\nAfter the UoW and repository collaborate in this way to automatically keep track of live objects and process their events, the service layer can be totally free of event-handling concerns:\n\nService layer is clean again (src/allocation/service_layer/services.py)\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(orderid, sku, qty) with uow: product = uow.products.get(sku=line.sku) if product is None: raise InvalidSku(f'Invalid sku {line.sku}') batchref = product.allocate(line) uow.commit() return batchref\n\nWe do also have to remember to change the fakes in the service layer and make them call super() in the right places, and to implement underscorey methods, but the changes are minimal:\n\nService-layer fakes need tweaking (tests/unit/test_services.py)\n\nclass FakeRepository(repository.AbstractRepository):\n\ndef __init__(self, products): super().__init__() self._products = set(products)\n\ndef _add(self, product): self._products.add(product)\n\ndef _get(self, sku): return next((p for p in self._products if p.sku == sku), None)\n\n...\n\nclass FakeUnitOfWork(unit_of_work.AbstractUnitOfWork): ...\n\ndef _commit(self): self.committed = True\n\nEXERCISE FOR THE READER\n\nAre you finding all those ._add() and ._commit() methods “super-gross,” in the words of our beloved tech reviewer Hynek? Does it “make you want to beat Harry around the head with a plushie snake”? Hey, our code listings are only meant to be examples, not the perfect solution! Why not go see if you can do better?\n\nOne composition over inheritance way to go would be to implement a wrapper class:\n\nA wrapper adds functionality and then delegates (src/adapters/repository.py)\n\nclass TrackingRepository: seen: Set[model.Product]\n\ndef __init__(self, repo: AbstractRepository): self.seen = set() # type: Set[model.Product] self._repo = repo\n\ndef add(self, product: model.Product): self._repo.add(product) self.seen.add(product)\n\ndef get(self, sku) -> model.Product: product = self._repo.get(sku) if product: self.seen.add(product) return product\n\nBy wrapping the repository, we can call the actual .add() and .get() methods, avoiding weird underscorey methods.\n\nSee if you can apply a similar pattern to our UoW class in order to get rid of those Java-y _commit() methods too. You can find the code on GitHub.\n\nSwitching all the ABCs to typing.Protocol is a good way to force yourself to avoid using inheritance. Let us know if you come up with something nice!\n\nYou might be starting to worry that maintaining these fakes is going to be a maintenance burden. There’s no doubt that it is work, but in our experience it’s not a lot of work. Once your project is up and running,\n\nthe interface for your repository and UoW abstractions really don’t change much. And if you’re using ABCs, they’ll help remind you when things get out of sync.\n\nWrap-Up\n\nDomain events give us a way to handle workflows in our system. We often find, listening to our domain experts, that they express requirements in a causal or temporal way—for example, “When we try to allocate stock but there’s none available, then we should send an\n\nemail to the buying team.”\n\nThe magic words “When X, then Y” often tell us about an event that we can make concrete in our system. Treating events as first-class\n\nthings in our model helps us make our code more testable and observable, and it helps isolate concerns.\n\nAnd Table 8-1 shows the trade-offs as we see them.\n\nTable 8-1. Domain events: the trade-offs\n\nPros\n\nCons\n\nA message bus gives us a nice way to separate responsibilities when we have to take multiple actions in response to a request.\n\nEvent handlers are nicely decoupled from the “core” application logic, making it easy to change their implementation later.\n\nDomain events are a great way to model the real world, and we can use them as part of our business language when modeling with stakeholders.\n\nThe message bus is an additional thing to wrap your head around; the implementation in which the unit of work raises events for us is neat but also magic. It’s not obvious when we call commit that we’re also going to go and send email to people.\n\nWhat’s more, that hidden event- handling code executes synchronously, meaning your service-layer function doesn’t finish until all the handlers for any events are finished. That could cause unexpected performance problems in your web endpoints (adding asynchronous processing is possible but makes things even more confusing).\n\nMore generally, event-driven workflows can be confusing because after things are split across a chain of multiple handlers, there is no single place in the system where you can understand how a request will be fulfilled.\n\nPros\n\nCons\n\nYou also open yourself up to the possibility of circular dependencies between your event handlers, and infinite loops.\n\nEvents are useful for more than just sending email, though. In Chapter 7\n\nwe spent a lot of time convincing you that you should define aggregates, or boundaries where we guarantee consistency. People often ask, “What should I do if I need to change multiple aggregates as\n\npart of a request?” Now we have the tools we need to answer that question.\n\nIf we have two things that can be transactionally isolated (e.g., an\n\norder and a product), then we can make them eventually consistent by using events. When an order is canceled, we should find the products that were allocated to it and remove the allocations.\n\nDOMAIN EVENTS AND THE MESSAGE BUS RECAP\n\nEvents can help with the single responsibility principle\n\nCode gets tangled up when we mix multiple concerns in one place. Events can help us to keep things tidy by separating primary use cases from secondary ones. We also use events for communicating between aggregates so that we don’t need to run long-running transactions that lock against multiple tables.\n\nA message bus routes messages to handlers\n\nYou can think of a message bus as a dict that maps from events to their consumers. It doesn’t “know” anything about the meaning of events; it’s just a piece of dumb infrastructure for getting messages around the system.\n\nOption 1: Service layer raises events and passes them to message bus\n\nThe simplest way to start using events in your system is to raise them from handlers by calling bus.handle(some_new_event) after you commit your unit of work.\n\nOption 2: Domain model raises events, service layer passes them to message bus\n\nThe logic about when to raise an event really should live with the model, so we can improve our system’s design and testability by raising events from the domain model. It’s easy for our handlers to collect events off the model objects after commit and pass them to the bus.\n\nOption 3: UoW collects events from aggregates and passes them to message bus\n\nAdding bus.handle(aggregate.events) to every handler is annoying, so we can tidy up by making our unit of work responsible for raising events that were raised by loaded objects. This is the most complex design and might rely on ORM magic, but it’s clean and easy to use once it’s set up.\n\nIn Chapter 9, we’ll look at this idea in more detail as we build a more complex workflow with our new message bus.\n\n1 This principle is the S in SOLID.\n\n2 Our tech reviewer Ed Jung likes to say that the move from imperative to event-based\n\nflow control changes what used to be orchestration into choreography.\n\nChapter 9. Going to Town on the Message Bus\n\nIn this chapter, we’ll start to make events more fundamental to the internal structure of our application. We’ll move from the current state in Figure 9-1, where events are an optional side effect…\n\nFigure 9-1. Before: the message bus is an optional add-on\n\n…to the situation in Figure 9-2, where everything goes via the message bus, and our app has been transformed fundamentally into a message processor.\n\nFigure 9-2. The message bus is now the main entrypoint to the service layer\n\nTIP\n\nThe code for this chapter is in the chapter_09_all_messagebus branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_09_all_messagebus # or to code along, checkout the previous chapter: git checkout chapter_08_events_and_message_bus\n\nA New Requirement Leads Us to a New Architecture\n\nRich Hickey talks about situated software, meaning software that runs for extended periods of time, managing a real-world process. Examples include warehouse-management systems, logistics schedulers, and payroll systems.\n\nThis software is tricky to write because unexpected things happen all the time in the real world of physical objects and unreliable humans. For example:\n\nDuring a stock-take, we discover that three SPRINGY- MATTRESSes have been water damaged by a leaky roof.\n\nA consignment of RELIABLE-FORKs is missing the required documentation and is held in customs for several weeks. Three RELIABLE-FORKs subsequently fail safety testing and are destroyed.\n\nA global shortage of sequins means we’re unable to manufacture our next batch of SPARKLY-BOOKCASE.\n\nIn these types of situations, we learn about the need to change batch quantities when they’re already in the system. Perhaps someone made a mistake on the number in the manifest, or perhaps some sofas fell off a truck. Following a conversation with the business, we model the situation as in Figure 9-3.\n\n1\n\nFigure 9-3. Batch quantity changed means deallocate and reallocate\n\nAn event we’ll call BatchQuantityChanged should lead us to change the quantity on the batch, yes, but also to apply a business rule: if the new quantity drops to less than the total already allocated, we need to deallocate those orders from that batch. Then each one will require a new allocation, which we can capture as an event called AllocationRequired.\n\nPerhaps you’re already anticipating that our internal message bus and events can help implement this requirement. We could define a service called change_batch_quantity that knows how to adjust batch quantities and also how to deallocate any excess order lines, and then each deallocation can emit an AllocationRequired event that can be forwarded to the existing allocate service, in separate transactions.\n\nOnce again, our message bus helps us to enforce the single\n\nresponsibility principle, and it allows us to make choices about transactions and data integrity.\n\nImagining an Architecture Change: Everything Will Be an Event Handler\n\nBut before we jump in, think about where we’re headed. There are two kinds of flows through our system:\n\nAPI calls that are handled by a service-layer function\n\nInternal events (which might be raised as a side effect of a service-layer function) and their handlers (which in turn call service-layer functions)\n\nWouldn’t it be easier if everything was an event handler? If we rethink\n\nour API calls as capturing events, the service-layer functions can be event handlers too, and we no longer need to make a distinction\n\nbetween internal and external event handlers:\n\nservices.allocate() could be the handler for an AllocationRequired event and could emit Allocated events as its output.\n\nservices.add_batch() could be the handler for a BatchCreated event.\n\n2\n\nOur new requirement will fit the same pattern:\n\nAn event called BatchQuantityChanged can invoke a handler called change_batch_quantity().\n\nAnd the new AllocationRequired events that it may raise can be passed on to services.allocate() too, so there is no conceptual difference between a brand-new allocation coming from the API and a reallocation that’s internally triggered by a deallocation.\n\nAll sound like a bit much? Let’s work toward it all gradually. We’ll\n\nfollow the Preparatory Refactoring workflow, aka “Make the change easy; then make the easy change”:\n\n1. We refactor our service layer into event handlers. We can get used to the idea of events being the way we describe inputs to the system. In particular, the existing services.allocate() function will become the handler for an event called AllocationRequired.\n\n2. We build an end-to-end test that puts\n\nBatchQuantityChanged events into the system and looks for Allocated events coming out.\n\n3. Our implementation will conceptually be very simple: a new handler for BatchQuantityChanged events, whose implementation will emit AllocationRequired events, which in turn will be handled by the exact same handler for allocations that the API uses.\n\nAlong the way, we’ll make a small tweak to the message bus and UoW,\n\nmoving the responsibility for putting new events on the message bus\n\ninto the message bus itself.\n\nRefactoring Service Functions to Message Handlers\n\nWe start by defining the two events that capture our current API inputs —AllocationRequired and BatchCreated:\n\nBatchCreated and AllocationRequired events (src/allocation/domain/events.py)\n\n@dataclass class BatchCreated(Event): ref: str sku: str qty: int eta: Optional[date] = None\n\n...\n\n@dataclass class AllocationRequired(Event): orderid: str sku: str qty: int\n\nThen we rename services.py to handlers.py; we add the existing message handler for send_out_of_stock_notification; and most importantly, we change all the handlers so that they have the same\n\ninputs, an event and a UoW:\n\nHandlers and services are the same thing (src/allocation/service_layer/handlers.py)\n\ndef add_batch( event: events.BatchCreated, uow: unit_of_work.AbstractUnitOfWork ): with uow: product = uow.products.get(sku=event.sku) ...\n\ndef allocate( event: events.AllocationRequired, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(event.orderid, event.sku, event.qty) ...\n\ndef send_out_of_stock_notification( event: events.OutOfStock, uow: unit_of_work.AbstractUnitOfWork, ): email.send( 'stock@made.com', f'Out of stock for {event.sku}', )\n\nThe change might be clearer as a diff:\n\nChanging from services to handlers\n\n(src/allocation/service_layer/handlers.py)\n\ndef add_batch( - ref: str, sku: str, qty: int, eta: Optional[date], - uow: unit_of_work.AbstractUnitOfWork + event: events.BatchCreated, uow: unit_of_work.AbstractUnitOfWork ): with uow: - product = uow.products.get(sku=sku) + product = uow.products.get(sku=event.sku) ...\n\ndef allocate( - orderid: str, sku: str, qty: int, - uow: unit_of_work.AbstractUnitOfWork + event: events.AllocationRequired, uow: unit_of_work.AbstractUnitOfWork ) -> str: - line = OrderLine(orderid, sku, qty) + line = OrderLine(event.orderid, event.sku, event.qty) ...\n\n+\n\n+def send_out_of_stock_notification( + event: events.OutOfStock, uow: unit_of_work.AbstractUnitOfWork, +): + email.send( ...\n\nAlong the way, we’ve made our service-layer’s API more structured\n\nand more consistent. It was a scattering of primitives, and now it uses well-defined objects (see the following sidebar).\n\nFROM DOMAIN OBJECTS, VIA PRIMITIVE OBSESSION, TO EVENTS AS AN INTERFACE\n\nSome of you may remember “Fully Decoupling the Service-Layer Tests from the Domain”, in which we changed our service-layer API from being in terms of domain objects to primitives. And now we’re moving back, but to different objects? What gives?\n\nIn OO circles, people talk about primitive obsession as an anti-pattern: avoid primitives in public APIs, and instead wrap them with custom value classes, they would say. In the Python world, a lot of people would be quite skeptical of that as a rule of thumb. When mindlessly applied, it’s certainly a recipe for unnecessary complexity. So that’s not what we’re doing per se.\n\nThe move from domain objects to primitives bought us a nice bit of decoupling: our client code was no longer coupled directly to the domain, so the service layer could present an API that stays the same even if we decide to make changes to our model, and vice versa.\n\nSo have we gone backward? Well, our core domain model objects are still free to vary, but instead we’ve coupled the external world to our event classes. They’re part of the domain too, but the hope is that they vary less often, so they’re a sensible artifact to couple on.\n\nAnd what have we bought ourselves? Now, when invoking a use case in our application, we no longer need to remember a particular combination of primitives, but just a single event class that represents the input to our application. That’s conceptually quite nice. On top of that, as you’ll see in Appendix E, those event classes can be a nice place to do some input validation.\n\nThe Message Bus Now Collects Events from the UoW\n\nOur event handlers now need a UoW. In addition, as our message bus\n\nbecomes more central to our application, it makes sense to put it\n\nexplicitly in charge of collecting and processing new events. There\n\nwas a bit of a circular dependency between the UoW and message bus until now, so this will make it one-way:\n\nHandle takes a UoW and manages a queue\n\n(src/allocation/service_layer/messagebus.py)\n\ndef handle(event: events.Event, uow: unit_of_work.AbstractUnitOfWork): queue = [event] while queue: event = queue.pop(0) for handler in HANDLERS[type(event)]: handler(event, uow=uow) queue.extend(uow.collect_new_events())\n\nThe message bus now gets passed the UoW each time it starts up.\n\nWhen we begin handling our first event, we start a queue.\n\nWe pop events from the front of the queue and invoke their handlers (the HANDLERS dict hasn’t changed; it still maps event types to handler functions).\n\nThe message bus passes the UoW down to each handler.\n\nAfter each handler finishes, we collect any new events that have been generated and add them to the queue.\n\nIn unit_of_work.py, publish_events() becomes a less active method, collect_new_events():\n\nUoW no longer puts events directly on the bus\n\n(src/allocation/service_layer/unit_of_work.py)\n\nfrom . import messagebus -\n\nclass AbstractUnitOfWork(abc.ABC): @@ -23,13 +21,11 @@ class AbstractUnitOfWork(abc.ABC):\n\ndef commit(self): self._commit() - self.publish_events()\n\ndef publish_events(self): + def collect_new_events(self): for product in self.products.seen: while product.events: - event = product.events.pop(0) - messagebus.handle(event) + yield product.events.pop(0)\n\nThe unit_of_work module now no longer depends on messagebus.\n\nWe no longer publish_events automatically on commit. The message bus is keeping track of the event queue instead.\n\nAnd the UoW no longer actively puts events on the message bus; it just makes them available.\n\nOur Tests Are All Written in Terms of Events Too\n\nOur tests now operate by creating events and putting them on the message bus, rather than invoking service-layer functions directly:\n\nHandler tests use events (tests/unit/test_handlers.py)\n\nclass TestAddBatch:\n\ndef test_for_new_product(self): uow = FakeUnitOfWork() - services.add_batch(\"b1\", \"CRUNCHY-ARMCHAIR\", 100, None, uow) + messagebus.handle( + events.BatchCreated(\"b1\", \"CRUNCHY-ARMCHAIR\", 100, None), uow + ) assert uow.products.get(\"CRUNCHY-ARMCHAIR\") is not None\n\nassert uow.committed\n\n...\n\nclass TestAllocate:\n\ndef test_returns_allocation(self): uow = FakeUnitOfWork() - services.add_batch(\"batch1\", \"COMPLICATED-LAMP\", 100, None, uow) - result = services.allocate(\"o1\", \"COMPLICATED-LAMP\", 10, uow) + messagebus.handle( + events.BatchCreated(\"batch1\", \"COMPLICATED-LAMP\", 100, None), uow + ) + result = messagebus.handle( + events.AllocationRequired(\"o1\", \"COMPLICATED-LAMP\", 10), uow + ) assert result == \"batch1\"\n\nA Temporary Ugly Hack: The Message Bus Has to Return Results\n\nOur API and our service layer currently want to know the allocated batch reference when they invoke our allocate() handler. This means we need to put in a temporary hack on our message bus to let it return events:\n\nMessage bus returns results (src/allocation/service_layer/messagebus.py)\n\ndef handle(event: events.Event, uow: unit_of_work.AbstractUnitOfWork): + results = [] queue = [event] while queue: event = queue.pop(0) for handler in HANDLERS[type(event)]: - handler(event, uow=uow) + results.append(handler(event, uow=uow)) queue.extend(uow.collect_new_events()) + return results",
      "page_number": 223
    },
    {
      "number": 9,
      "title": "Going to Town on the Message Bus",
      "start_page": 247,
      "end_page": 275,
      "detection_method": "regex_chapter_title",
      "content": "It’s because we’re mixing the read and write responsibilities in our system. We’ll come back to fix this wart in Chapter 12.\n\nModifying Our API to Work with Events\n\nFlask changing to message bus as a diff (src/allocation/entrypoints/flask_app.py)\n\n@app.route(\"/allocate\", methods=['POST']) def allocate_endpoint(): try: - batchref = services.allocate( - request.json['orderid'], - request.json['sku'], - request.json['qty'], - unit_of_work.SqlAlchemyUnitOfWork(), + event = events.AllocationRequired( + request.json['orderid'], request.json['sku'], request.json['qty'], ) + results = messagebus.handle(event, unit_of_work.SqlAlchemyUnitOfWork())\n\n+ batchref = results.pop(0) except InvalidSku as e:\n\nInstead of calling the service layer with a bunch of primitives extracted from the request JSON…\n\nWe instantiate an event.\n\nThen we pass it to the message bus.\n\nAnd we should be back to a fully functional application, but one that’s now fully event-driven:\n\nWhat used to be service-layer functions are now event handlers.\n\nThat makes them the same as the functions we invoke for handling internal events raised by our domain model.\n\nWe use events as our data structure for capturing inputs to the system, as well as for handing off of internal work packages.\n\nThe entire app is now best described as a message processor, or an event processor if you prefer. We’ll talk about the distinction in the next chapter.\n\nImplementing Our New Requirement\n\nWe’re done with our refactoring phase. Let’s see if we really have “made the change easy.” Let’s implement our new requirement, shown\n\nin Figure 9-4: we’ll receive as our inputs some new BatchQuantityChanged events and pass them to a handler, which in turn might emit some AllocationRequired events, and those in turn will go back to our existing handler for reallocation.\n\nFigure 9-4. Sequence diagram for reallocation flow\n\nWARNING\n\nWhen you split things out like this across two units of work, you now have two database transactions, so you are opening yourself up to integrity issues: something could happen that means the first transaction completes but the second one does not. You’ll need to think about whether this is acceptable, and whether you need to notice when it happens and do something about it. See “Footguns” for more discussion.\n\nOur New Event\n\nThe event that tells us a batch quantity has changed is simple; it just needs a batch reference and a new quantity:\n\nNew event (src/allocation/domain/events.py)\n\n@dataclass class BatchQuantityChanged(Event): ref: str qty: int\n\nTest-Driving a New Handler\n\nFollowing the lessons learned in Chapter 4, we can operate in “high gear” and write our unit tests at the highest possible level of abstraction, in terms of events. Here’s what they might look like:\n\nHandler tests for change_batch_quantity (tests/unit/test_handlers.py)\n\nclass TestChangeBatchQuantity:\n\ndef test_changes_available_quantity(self): uow = FakeUnitOfWork() messagebus.handle( events.BatchCreated(\"batch1\", \"ADORABLE-SETTEE\", 100, None), uow ) [batch] = uow.products.get(sku=\"ADORABLE-SETTEE\").batches assert batch.available_quantity == 100\n\nmessagebus.handle(events.BatchQuantityChanged(\"batch1\", 50), uow)\n\nassert batch.available_quantity == 50\n\ndef test_reallocates_if_necessary(self): uow = FakeUnitOfWork() event_history = [ events.BatchCreated(\"batch1\", \"INDIFFERENT-TABLE\", 50, None), events.BatchCreated(\"batch2\", \"INDIFFERENT-TABLE\", 50, date.today()), events.AllocationRequired(\"order1\", \"INDIFFERENT-TABLE\", 20), events.AllocationRequired(\"order2\", \"INDIFFERENT-TABLE\", 20), ] for e in event_history: messagebus.handle(e, uow) [batch1, batch2] = uow.products.get(sku=\"INDIFFERENT-TABLE\").batches assert batch1.available_quantity == 10 assert batch2.available_quantity == 50\n\nmessagebus.handle(events.BatchQuantityChanged(\"batch1\", 25), uow)\n\n# order1 or order2 will be deallocated, so we'll have 25 - 20 assert batch1.available_quantity == 5 # and 20 will be reallocated to the next batch assert batch2.available_quantity == 30\n\nThe simple case would be trivially easy to implement; we just modify a quantity.\n\nBut if we try to change the quantity to less than has been allocated, we’ll need to deallocate at least one order, and we expect to reallocate it to a new batch.\n\nImplementation\n\nOur new handler is very simple:\n\nHandler delegates to model layer\n\n(src/allocation/service_layer/handlers.py)\n\ndef change_batch_quantity( event: events.BatchQuantityChanged, uow: unit_of_work.AbstractUnitOfWork ): with uow: product = uow.products.get_by_batchref(batchref=event.ref) product.change_batch_quantity(ref=event.ref, qty=event.qty) uow.commit()\n\nWe realize we’ll need a new query type on our repository:\n\nA new query type on our repository (src/allocation/adapters/repository.py)\n\nclass AbstractRepository(abc.ABC): ...\n\ndef get(self, sku) -> model.Product: ...\n\ndef get_by_batchref(self, batchref) -> model.Product: product = self._get_by_batchref(batchref) if product: self.seen.add(product) return product\n\n@abc.abstractmethod\n\ndef _add(self, product: model.Product): raise NotImplementedError\n\n@abc.abstractmethod def _get(self, sku) -> model.Product: raise NotImplementedError\n\n@abc.abstractmethod def _get_by_batchref(self, batchref) -> model.Product: raise NotImplementedError ...\n\nclass SqlAlchemyRepository(AbstractRepository): ...\n\ndef _get(self, sku): return self.session.query(model.Product).filter_by(sku=sku).first()\n\ndef _get_by_batchref(self, batchref): return self.session.query(model.Product).join(model.Batch).filter( orm.batches.c.reference == batchref, ).first()\n\nAnd on our FakeRepository too:\n\nUpdating the fake repo too (tests/unit/test_handlers.py)\n\nclass FakeRepository(repository.AbstractRepository): ...\n\ndef _get(self, sku): return next((p for p in self._products if p.sku == sku), None)\n\ndef _get_by_batchref(self, batchref): return next(( p for p in self._products for b in p.batches if b.reference == batchref ), None)\n\nNOTE\n\nWe’re adding a query to our repository to make this use case easier to implement. So long as our query is returning a single aggregate, we’re not bending any rules. If you find yourself writing complex queries on your repositories, you might want to consider a different design. Methods like get_most_popular_products or find_products_by_order_id in particular would definitely trigger our spidey sense. Chapter 11 and the epilogue have some tips on managing complex queries.\n\nA New Method on the Domain Model\n\nWe add the new method to the model, which does the quantity change and deallocation(s) inline and publishes a new event. We also modify\n\nthe existing allocate function to publish an event:\n\nOur model evolves to capture the new requirement (src/allocation/domain/model.py)\n\nclass Product: ...\n\ndef change_batch_quantity(self, ref: str, qty: int): batch = next(b for b in self.batches if b.reference == ref) batch._purchased_quantity = qty while batch.available_quantity < 0: line = batch.deallocate_one() self.events.append( events.AllocationRequired(line.orderid, line.sku, line.qty) ) ...\n\nclass Batch: ...\n\ndef deallocate_one(self) -> OrderLine: return self._allocations.pop()\n\nWe wire up our new handler:\n\nThe message bus grows (src/allocation/service_layer/messagebus.py)\n\nHANDLERS = { events.BatchCreated: [handlers.add_batch], events.BatchQuantityChanged: [handlers.change_batch_quantity], events.AllocationRequired: [handlers.allocate], events.OutOfStock: [handlers.send_out_of_stock_notification],\n\n} # type: Dict[Type[events.Event], List[Callable]]\n\nAnd our new requirement is fully implemented.\n\nOptionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nOur main test for the reallocation workflow is edge-to-edge (see the example code in “Test-Driving a New Handler”). It uses the real message bus, and it tests the whole flow, where the BatchQuantityChanged event handler triggers deallocation, and emits new AllocationRequired events, which in turn are handled by their own handlers. One test covers a chain of multiple events and handlers.\n\nDepending on the complexity of your chain of events, you may decide that you want to test some handlers in isolation from one another. You can do this using a “fake” message bus.\n\nIn our case, we actually intervene by modifying the publish_events() method on FakeUnitOfWork and decoupling it from the real message bus, instead making it record what events it\n\nsees:\n\nFake message bus implemented in UoW (tests/unit/test_handlers.py)\n\nclass FakeUnitOfWorkWithFakeMessageBus(FakeUnitOfWork):\n\ndef __init__(self): super().__init__() self.events_published = [] # type: List[events.Event]\n\ndef publish_events(self): for product in self.products.seen: while product.events: self.events_published.append(product.events.pop(0))\n\nNow when we invoke messagebus.handle() using the FakeUnitOfWorkWithFakeMessageBus, it runs only the handler for that event. So we can write a more isolated unit test: instead of checking all the side effects, we just check that BatchQuantityChanged leads to AllocationRequired if the quantity drops below the total already allocated:\n\nTesting reallocation in isolation (tests/unit/test_handlers.py)\n\ndef test_reallocates_if_necessary_isolated(): uow = FakeUnitOfWorkWithFakeMessageBus()\n\n# test setup as before event_history = [ events.BatchCreated(\"batch1\", \"INDIFFERENT-TABLE\", 50, None), events.BatchCreated(\"batch2\", \"INDIFFERENT-TABLE\", 50, date.today()), events.AllocationRequired(\"order1\", \"INDIFFERENT-TABLE\", 20),\n\nevents.AllocationRequired(\"order2\", \"INDIFFERENT-TABLE\", 20), ] for e in event_history: messagebus.handle(e, uow) [batch1, batch2] = uow.products.get(sku=\"INDIFFERENT-TABLE\").batches assert batch1.available_quantity == 10 assert batch2.available_quantity == 50\n\nmessagebus.handle(events.BatchQuantityChanged(\"batch1\", 25), uow)\n\n# assert on new events emitted rather than downstream side-effects [reallocation_event] = uow.events_published assert isinstance(reallocation_event, events.AllocationRequired) assert reallocation_event.orderid in {'order1', 'order2'} assert reallocation_event.sku == 'INDIFFERENT-TABLE'\n\nWhether you want to do this or not depends on the complexity of your chain of events. We say, start out with edge-to-edge testing, and resort to this only if necessary.\n\nEXERCISE FOR THE READER\n\nA great way to force yourself to really understand some code is to refactor it. In the discussion of testing handlers in isolation, we used something called FakeUnitOfWorkWithFakeMessageBus, which is unnecessarily complicated and violates the SRP.\n\n3\n\nIf we change the message bus to being a class, then building a FakeMessageBus is more straightforward:\n\nAn abstract message bus and its real and fake versions\n\nclass AbstractMessageBus: HANDLERS: Dict[Type[events.Event], List[Callable]]\n\ndef handle(self, event: events.Event): for handler in self.HANDLERS[type(event)]: handler(event)\n\nclass MessageBus(AbstractMessageBus): HANDLERS = { events.OutOfStock: [send_out_of_stock_notification],\n\n}\n\nclass FakeMessageBus(messagebus.AbstractMessageBus): def __init__(self): self.events_published = [] # type: List[events.Event] self.handlers = { events.OutOfStock: [lambda e: self.events_published.append(e)] }\n\nSo jump into the code on GitHub and see if you can get a class-based version working, and then write a version of test_reallocates_if_necessary_isolated() from earlier.\n\nWe use a class-based message bus in Chapter 13, if you need more inspiration.\n\nWrap-Up\n\nLet’s look back at what we’ve achieved, and think about why we did it.\n\nWhat Have We Achieved?\n\nEvents are simple dataclasses that define the data structures for inputs and internal messages within our system. This is quite powerful from a DDD standpoint, since events often translate really well into business language (look up event storming if you haven’t already).\n\nHandlers are the way we react to events. They can call down to our model or call out to external services. We can define multiple handlers for a single event if we want to. Handlers can also raise other events. This allows us to be very granular about what a handler does and really stick to the SRP.\n\nWhy Have We Achieved?\n\nOur ongoing objective with these architectural patterns is to try to have the complexity of our application grow more slowly than its size. When we go all in on the message bus, as always we pay a price in terms of architectural complexity (see Table 9-1), but we buy\n\nourselves a pattern that can handle almost arbitrarily complex requirements without needing any further conceptual or architectural change to the way we do things.\n\nHere we’ve added quite a complicated use case (change quantity, deallocate, start new transaction, reallocate, publish external notification), but architecturally, there’s been no cost in terms of\n\ncomplexity. We’ve added new events, new handlers, and a new external adapter (for email), all of which are existing categories of things in our architecture that we understand and know how to reason about, and that are easy to explain to newcomers. Our moving parts\n\neach have one job, they’re connected to each other in well-defined ways, and there are no unexpected side effects.\n\nTable 9-1. Whole app is a message bus: the trade-offs\n\nPros\n\nCons\n\nHandlers and services are the same thing, so that’s simpler.\n\nA message bus is still a slightly unpredictable way of doing things from a web point of view. You don’t know in advance when things are going to end.\n\nWe have a nice data structure for inputs to the system.\n\nThere will be duplication of fields and structure between model objects and events, which will have a maintenance cost. Adding a field to one usually means adding a field to at least one of the others.\n\nNow, you may be wondering, where are those BatchQuantityChanged events going to come from? The answer is revealed in a couple chapters’ time. But first, let’s talk about events versus commands.\n\n1 Event-based modeling is so popular that a practice called event storming has been developed for facilitating event-based requirements gathering and domain model\n\nelaboration.\n\n2 If you’ve done a bit of reading about event-driven architectures, you may be thinking, “Some of these events sound more like commands!” Bear with us! We’re trying to introduce one concept at a time. In the next chapter, we’ll introduce the distinction between commands and events.\n\n3 The “simple” implementation in this chapter essentially uses the messagebus.py module\n\nitself to implement the Singleton Pattern.\n\nChapter 10. Commands and Command Handler\n\nIn the previous chapter, we talked about using events as a way of representing the inputs to our system, and we turned our application into a message-processing machine.\n\nTo achieve that, we converted all our use-case functions to event\n\nhandlers. When the API receives a POST to create a new batch, it builds a new BatchCreated event and handles it as if it were an internal event. This might feel counterintuitive. After all, the batch hasn’t been created yet; that’s why we called the API. We’re going to fix that conceptual wart by introducing commands and showing how\n\nthey can be handled by the same message bus but with slightly different rules.\n\nTIP\n\nThe code for this chapter is in the chapter_10_commands branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_10_commands # or to code along, checkout the previous chapter: git checkout chapter_09_all_messagebus\n\nCommands and Events\n\nLike events, commands are a type of message—instructions sent by one part of a system to another. We usually represent commands with dumb data structures and can handle them in much the same way as events.\n\nThe differences between commands and events, though, are important.\n\nCommands are sent by one actor to another specific actor with the expectation that a particular thing will happen as a result. When we post a form to an API handler, we are sending a command. We name\n\ncommands with imperative mood verb phrases like “allocate stock” or “delay shipment.”\n\nCommands capture intent. They express our wish for the system to do something. As a result, when they fail, the sender needs to receive error information.\n\nEvents are broadcast by an actor to all interested listeners. When we publish BatchQuantityChanged, we don’t know who’s going to pick it up. We name events with past-tense verb phrases like “order\n\nallocated to stock” or “shipment delayed.”\n\nWe often use events to spread the knowledge about successful\n\ncommands.\n\nEvents capture facts about things that happened in the past. Since we\n\ndon’t know who’s handling an event, senders should not care whether the receivers succeeded or failed. Table 10-1 recaps the differences.\n\nTable 10-1. Events versus commands\n\nEvent\n\nCommand\n\nNamed\n\nPast tense\n\nImperative mood\n\nError handling\n\nFail independently\n\nFail noisily\n\nSent to\n\nAll listeners\n\nOne recipient\n\nWhat kinds of commands do we have in our system right now?\n\nPulling out some commands (src/allocation/domain/commands.py)\n\nclass Command: pass\n\n@dataclass class Allocate(Command): orderid: str sku: str qty: int\n\n@dataclass class CreateBatch(Command): ref: str sku: str qty: int eta: Optional[date] = None\n\n@dataclass class ChangeBatchQuantity(Command): ref: str qty: int\n\ncommands.Allocate will replace events.AllocationRequired.\n\ncommands.CreateBatch will replace events.BatchCreated.\n\ncommands.ChangeBatchQuantity will replace events.BatchQuantityChanged.\n\nDifferences in Exception Handling\n\nJust changing the names and verbs is all very well, but that won’t change the behavior of our system. We want to treat events and commands similarly, but not exactly the same. Let’s see how our\n\nmessage bus changes:\n\nDispatch events and commands differently (src/allocation/service_layer/messagebus.py)\n\nMessage = Union[commands.Command, events.Event]\n\ndef handle(message: Message, uow: unit_of_work.AbstractUnitOfWork): results = [] queue = [message] while queue: message = queue.pop(0) if isinstance(message, events.Event): handle_event(message, queue, uow) elif isinstance(message, commands.Command): cmd_result = handle_command(message, queue, uow) results.append(cmd_result) else: raise Exception(f'{message} was not an Event or Command') return results\n\nIt still has a main handle() entrypoint that takes a message, which may be a command or an event.\n\nWe dispatch events and commands to two different helper functions, shown next.\n\nHere’s how we handle events:\n\nEvents cannot interrupt the flow (src/allocation/service_layer/messagebus.py)\n\ndef handle_event( event: events.Event, queue: List[Message], uow: unit_of_work.AbstractUnitOfWork ): for handler in EVENT_HANDLERS[type(event)]: try: logger.debug('handling event %s with handler %s', event, handler) handler(event, uow=uow) queue.extend(uow.collect_new_events()) except Exception: logger.exception('Exception handling event %s', event) continue\n\nEvents go to a dispatcher that can delegate to multiple handlers per event.\n\nIt catches and logs errors but doesn’t let them interrupt message processing.\n\nAnd here’s how we do commands:\n\nCommands reraise exceptions (src/allocation/service_layer/messagebus.py)\n\ndef handle_command( command: commands.Command, queue: List[Message],\n\nuow: unit_of_work.AbstractUnitOfWork ): logger.debug('handling command %s', command) try: handler = COMMAND_HANDLERS[type(command)] result = handler(command, uow=uow) queue.extend(uow.collect_new_events()) return result except Exception: logger.exception('Exception handling command %s', command) raise\n\nThe command dispatcher expects just one handler per command.\n\nIf any errors are raised, they fail fast and will bubble up.\n\nreturn result is only temporary; as mentioned in “A Temporary Ugly Hack: The Message Bus Has to Return Results”, it’s a temporary hack to allow the message bus to return the batch reference for the API to use. We’ll fix this in Chapter 12.\n\nWe also change the single HANDLERS dict into different ones for commands and events. Commands can have only one handler, according to our convention:\n\nNew handlers dicts (src/allocation/service_layer/messagebus.py)\n\nEVENT_HANDLERS = { events.OutOfStock: [handlers.send_out_of_stock_notification], } # type: Dict[Type[events.Event], List[Callable]]\n\nCOMMAND_HANDLERS = { commands.Allocate: handlers.allocate, commands.CreateBatch: handlers.add_batch, commands.ChangeBatchQuantity: handlers.change_batch_quantity, } # type: Dict[Type[commands.Command], Callable]\n\nDiscussion: Events, Commands, and Error Handling\n\nMany developers get uncomfortable at this point and ask, “What happens when an event fails to process? How am I supposed to make sure the system is in a consistent state?” If we manage to process half of the events during messagebus.handle before an out-of-memory error kills our process, how do we mitigate problems caused by the lost messages?\n\nLet’s start with the worst case: we fail to handle an event, and the\n\nsystem is left in an inconsistent state. What kind of error would cause this? Often in our systems we can end up in an inconsistent state when\n\nonly half an operation is completed.\n\nFor example, we could allocate three units of DESIRABLE_BEANBAG to a customer’s order but somehow fail to reduce the amount of remaining\n\nstock. This would cause an inconsistent state: the three units of stock are both allocated and available, depending on how you look at it.\n\nLater, we might allocate those same beanbags to another customer, causing a headache for customer support.\n\nIn our allocation service, though, we’ve already taken steps to prevent\n\nthat happening. We’ve carefully identified aggregates that act as consistency boundaries, and we’ve introduced a UoW that manages the\n\natomic success or failure of an update to an aggregate.\n\nFor example, when we allocate stock to an order, our consistency boundary is the Product aggregate. This means that we can’t\n\naccidentally overallocate: either a particular order line is allocated to\n\nthe product, or it is not—there’s no room for inconsistent states.\n\nBy definition, we don’t require two aggregates to be immediately consistent, so if we fail to process an event and update only a single\n\naggregate, our system can still be made eventually consistent. We shouldn’t violate any constraints of the system.\n\nWith this example in mind, we can better understand the reason for\n\nsplitting messages into commands and events. When a user wants to make the system do something, we represent their request as a\n\ncommand. That command should modify a single aggregate and either succeed or fail in totality. Any other bookkeeping, cleanup, and\n\nnotification we need to do can happen via an event. We don’t require the event handlers to succeed in order for the command to be\n\nsuccessful.\n\nLet’s look at another example (from a different, imaginary projet) to see why not.\n\nImagine we are building an ecommerce website that sells expensive\n\nluxury goods. Our marketing department wants to reward customers for repeat visits. We will flag customers as VIPs after they make their\n\nthird purchase, and this will entitle them to priority treatment and\n\nspecial offers. Our acceptance criteria for this story reads as follows:\n\nGiven a customer with two orders in their history, When the customer places a third order, Then they should be flagged as a VIP.\n\nWhen a customer first becomes a VIP Then we should send them an email to congratulate them\n\nUsing the techniques we’ve already discussed in this book, we decide that we want to build a new History aggregate that records orders and can raise domain events when rules are met. We will structure the code\n\nlike this:\n\nVIP customer (example code for a different project)\n\nclass History: # Aggregate\n\ndef __init__(self, customer_id: int): self.orders = set() # Set[HistoryEntry] self.customer_id = customer_id\n\ndef record_order(self, order_id: str, order_amount: int): entry = HistoryEntry(order_id, order_amount)\n\nif entry in self.orders: return\n\nself.orders.add(entry)\n\nif len(self.orders) == 3: self.events.append( CustomerBecameVIP(self.customer_id) )\n\ndef create_order_from_basket(uow, cmd: CreateOrder): with uow: order = Order.from_basket(cmd.customer_id, cmd.basket_items) uow.orders.add(order) uow.commit() # raises OrderCreated\n\ndef update_customer_history(uow, event: OrderCreated): with uow: history = uow.order_history.get(event.customer_id) history.record_order(event.order_id, event.order_amount) uow.commit() # raises CustomerBecameVIP\n\ndef congratulate_vip_customer(uow, event: CustomerBecameVip): with uow: customer = uow.customers.get(event.customer_id) email.send( customer.email_address, f'Congratulations {customer.first_name}!' )\n\nThe History aggregate captures the rules indicating when a customer becomes a VIP. This puts us in a good place to handle changes when the rules become more complex in the future.\n\nOur first handler creates an order for the customer and raises a domain event OrderCreated.\n\nOur second handler updates the History object to record that an order was created.\n\nFinally, we send an email to the customer when they become a VIP.\n\nUsing this code, we can gain some intuition about error handling in an event-driven system.\n\nIn our current implementation, we raise events about an aggregate after\n\nwe persist our state to the database. What if we raised those events before we persisted, and committed all our changes at the same time?\n\nThat way, we could be sure that all the work was complete. Wouldn’t that be safer?\n\nWhat happens, though, if the email server is slightly overloaded? If all\n\nthe work has to complete at the same time, a busy email server can stop us from taking money for orders.\n\nWhat happens if there is a bug in the implementation of the History aggregate? Should we fail to take your money just because we can’t recognize you as a VIP?\n\nBy separating out these concerns, we have made it possible for things\n\nto fail in isolation, which improves the overall reliability of the system. The only part of this code that has to complete is the command\n\nhandler that creates an order. This is the only part that a customer cares about, and it’s the part that our business stakeholders should prioritize.\n\nNotice how we’ve deliberately aligned our transactional boundaries to\n\nthe start and end of the business processes. The names that we use in the code match the jargon used by our business stakeholders, and the\n\nhandlers we’ve written match the steps of our natural language\n\nacceptance criteria. This concordance of names and structure helps us to reason about our systems as they grow larger and more complex.\n\nRecovering from Errors Synchronously\n\nHopefully we’ve convinced you that it’s OK for events to fail independently from the commands that raised them. What should we\n\ndo, then, to make sure we can recover from errors when they inevitably occur?\n\nThe first thing we need is to know when an error has occurred, and for\n\nthat we usually rely on logs.\n\nLet’s look again at the handle_event method from our message bus:\n\nCurrent handle function (src/allocation/service_layer/messagebus.py)\n\ndef handle_event( event: events.Event, queue: List[Message], uow: unit_of_work.AbstractUnitOfWork ): for handler in EVENT_HANDLERS[type(event)]: try: logger.debug('handling event %s with handler %s', event, handler) handler(event, uow=uow) queue.extend(uow.collect_new_events()) except Exception: logger.exception('Exception handling event %s', event) continue\n\nWhen we handle a message in our system, the first thing we do is write\n\na log line to record what we’re about to do. For our CustomerBecameVIP use case, the logs might read as follows:\n\nHandling event CustomerBecameVIP(customer_id=12345) with handler <function congratulate_vip_customer at 0x10ebc9a60>\n\nBecause we’ve chosen to use dataclasses for our message types, we get a neatly printed summary of the incoming data that we can copy and\n\npaste into a Python shell to re-create the object.\n\nWhen an error occurs, we can use the logged data to either reproduce\n\nthe problem in a unit test or replay the message into the system.\n\nManual replay works well for cases where we need to fix a bug before\n\nwe can re-process an event, but our systems will always experience\n\nsome background level of transient failure. This includes things like\n\nnetwork hiccups, table deadlocks, and brief downtime caused by\n\ndeployments.\n\nFor most of those cases, we can recover elegantly by trying again. As the proverb says, “If at first you don’t succeed, retry the operation with\n\nan exponentially increasing back-off period.”\n\nHandle with retry (src/allocation/service_layer/messagebus.py)\n\nfrom tenacity import Retrying, RetryError, stop_after_attempt, wait_exponential\n\n...\n\ndef handle_event( event: events.Event, queue: List[Message], uow: unit_of_work.AbstractUnitOfWork ):\n\nfor handler in EVENT_HANDLERS[type(event)]: try: for attempt in Retrying( stop=stop_after_attempt(3), wait=wait_exponential() ):\n\nwith attempt: logger.debug('handling event %s with handler %s', event, handler) handler(event, uow=uow) queue.extend(uow.collect_new_events()) except RetryError as retry_failure: logger.error( 'Failed to handle event %s times, giving up!, retry_failure.last_attempt.attempt_number ) continue\n\nTenacity is a Python library that implements common patterns for retrying.\n\nHere we configure our message bus to retry operations up to three times, with an exponentially increasing wait between attempts.\n\nRetrying operations that might fail is probably the single best way to improve the resilience of our software. Again, the Unit of Work and Command Handler patterns mean that each attempt starts from a consistent state and won’t leave things half-finished.\n\nWARNING\n\nAt some point, regardless of tenacity, we’ll have to give up trying to process the message. Building reliable systems with distributed messages is hard, and we have to skim over some tricky bits. There are pointers to more reference materials in the epilogue.\n\nWrap-Up\n\nIn this book we decided to introduce the concept of events before the concept of commands, but other guides often do it the other way\n\naround. Making explicit the requests that our system can respond to by giving them a name and their own data structure is quite a fundamental thing to do. You’ll sometimes see people use the name Command Handler pattern to describe what we’re doing with Events,\n\nCommands, and Message Bus.\n\nTable 10-2 discusses some of the things you should think about before you jump on board.\n\nTable 10-2. Splitting commands and events: the trade-offs\n\nPros\n\nCons\n\nTreating commands and events differently helps us understand which things have to succeed and which things we can tidy up later.\n\nThe semantic differences between commands and events can be subtle. Expect bikeshedding arguments over the differences.\n\nCreateBatch is definitely a less confusing name than Batc hCreated. We are being explicit about the intent of our users, and explicit is better than implicit, right?\n\nWe’re expressly inviting failure. We know that sometimes things will break, and we’re choosing to handle that by making the failures smaller and more isolated. This can make the system harder to reason about and requires better monitoring.\n\nIn Chapter 11 we’ll talk about using events as an integration pattern.",
      "page_number": 247
    },
    {
      "number": 10,
      "title": "Commands and Command Handler",
      "start_page": 276,
      "end_page": 290,
      "detection_method": "regex_chapter_title",
      "content": "Chapter 11. Event-Driven Architecture: Using Events to Integrate Microservices\n\nIn the preceding chapter, we never actually spoke about how we would receive the “batch quantity changed” events, or indeed, how we might notify the outside world about reallocations.\n\nWe have a microservice with a web API, but what about other ways of talking to other systems? How will we know if, say, a shipment is\n\ndelayed or the quantity is amended? How will we tell the warehouse system that an order has been allocated and needs to be sent to a\n\ncustomer?\n\nIn this chapter, we’d like to show how the events metaphor can be\n\nextended to encompass the way that we handle incoming and outgoing messages from the system. Internally, the core of our application is\n\nnow a message processor. Let’s follow through on that so it becomes a message processor externally as well. As shown in Figure 11-1, our\n\napplication will receive events from external sources via an external message bus (we’ll use Redis pub/sub queues as an example) and publish its outputs, in the form of events, back there as well.\n\nFigure 11-1. Our application is a message processor\n\nTIP\n\nThe code for this chapter is in the chapter_11_external_events branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_11_external_events # or to code along, checkout the previous chapter: git checkout chapter_10_commands\n\nDistributed Ball of Mud, and Thinking in Nouns\n\nBefore we get into that, let’s talk about the alternatives. We regularly talk to engineers who are trying to build out a microservices architecture. Often they are migrating from an existing application, and\n\ntheir first instinct is to split their system into nouns.\n\nWhat nouns have we introduced so far in our system? Well, we have batches of stock, orders, products, and customers. So a naive attempt\n\nat breaking up the system might have looked like Figure 11-2 (notice that we’ve named our system after a noun, Batches, instead of Allocation).\n\nFigure 11-2. Context diagram with noun-based services\n\nEach “thing” in our system has an associated service, which exposes an HTTP API.\n\nLet’s work through an example happy-path flow in Figure 11-3: our users visit a website and can choose from products that are in stock. When they add an item to their basket, we will reserve some stock for them. When an order is complete, we confirm the reservation, which causes us to send dispatch instructions to the warehouse. Let’s also\n\nsay, if this is the customer’s third order, we want to update the customer record to flag them as a VIP.\n\nFigure 11-3. Command flow 1\n\nWe can think of each of these steps as a command in our system: ReserveStock, ConfirmReservation, DispatchGoods, MakeCustomerVIP, and so forth.\n\nThis style of architecture, where we create a microservice per database table and treat our HTTP APIs as CRUD interfaces to anemic models, is the most common initial way for people to approach service-oriented design.\n\nThis works fine for systems that are very simple, but it can quickly degrade into a distributed ball of mud.\n\nTo see why, let’s consider another case. Sometimes, when stock arrives at the warehouse, we discover that items have been water damaged during transit. We can’t sell water-damaged sofas, so we have to throw them away and request more stock from our partners. We also need to update our stock model, and that might mean we need to reallocate a customer’s order.\n\nWhere does this logic go?\n\nWell, the Warehouse system knows that the stock has been damaged, so maybe it should own this process, as shown in Figure 11-4.\n\nFigure 11-4. Command flow 2\n\nThis sort of works too, but now our dependency graph is a mess. To\n\nallocate stock, the Orders service drives the Batches system, which drives Warehouse; but in order to handle problems at the warehouse, our Warehouse system drives Batches, which drives Orders.\n\nMultiply this by all the other workflows we need to provide, and you can see how services quickly get tangled up.\n\nError Handling in Distributed Systems\n\n“Things break” is a universal law of software engineering. What\n\nhappens in our system when one of our requests fails? Let’s say that a network error happens right after we take a user’s order for three MISBEGOTTEN-RUG, as shown in Figure 11-5.\n\nWe have two options here: we can place the order anyway and leave it unallocated, or we can refuse to take the order because the allocation\n\ncan’t be guaranteed. The failure state of our batches service has bubbled up and is affecting the reliability of our order service.\n\nWhen two things have to be changed together, we say that they are\n\ncoupled. We can think of this failure cascade as a kind of temporal coupling: every part of the system has to work at the same time for any\n\npart of it to work. As the system gets bigger, there is an exponentially increasing probability that some part is degraded.\n\nFigure 11-5. Command flow with error\n\nCONNASCENCE\n\nWe’re using the term coupling here, but there’s another way to describe the relationships between our systems. Connascence is a term used by some authors to describe the different types of coupling.\n\nConnascence isn’t bad, but some types of connascence are stronger than others. We want to have strong connascence locally, as when two classes are closely related, but weak connascence at a distance.\n\nIn our first example of a distributed ball of mud, we see Connascence of Execution: multiple components need to know the correct order of work for an operation to be successful.\n\nWhen thinking about error conditions here, we’re talking about Connascence of Timing: multiple things have to happen, one after another, for the operation to work.\n\nWhen we replace our RPC-style system with events, we replace both of these types of connascence with a weaker type. That’s Connascence of Name: multiple components need to agree only on the name of an event and the names of fields it carries.\n\nWe can never completely avoid coupling, except by having our software not talk to any other software. What we want is to avoid inappropriate coupling. Connascence provides a mental model for understanding the strength and type of coupling inherent in different architectural styles. Read all about it at connascence.io.\n\nThe Alternative: Temporal Decoupling Using Asynchronous Messaging\n\nHow do we get appropriate coupling? We’ve already seen part of the answer, which is that we should think in terms of verbs, not nouns. Our\n\ndomain model is about modeling a business process. It’s not a static data model about a thing; it’s a model of a verb.\n\nSo instead of thinking about a system for orders and a system for\n\nbatches, we think about a system for ordering and a system for allocating, and so on.\n\nWhen we separate things this way, it’s a little easier to see which\n\nsystem should be responsible for what. When thinking about ordering, really we want to make sure that when we place an order, the order is\n\nplaced. Everything else can happen later, so long as it happens.\n\nNOTE\n\nIf this sounds familiar, it should! Segregating responsibilities is the same process we went through when designing our aggregates and commands.\n\nLike aggregates, microservices should be consistency boundaries.\n\nBetween two services, we can accept eventual consistency, and that means we don’t need to rely on synchronous calls. Each service\n\naccepts commands from the outside world and raises events to record the result. Other services can listen to those events to trigger the next\n\nsteps in the workflow.\n\nTo avoid the Distributed Ball of Mud anti-pattern, instead of\n\ntemporally coupled HTTP API calls, we want to use asynchronous messaging to integrate our systems. We want our BatchQuantityChanged messages to come in as external messages from upstream systems, and we want our system to publish Allocated events for downstream systems to listen to.\n\nWhy is this better? First, because things can fail independently, it’s\n\neasier to handle degraded behavior: we can still take orders if the allocation system is having a bad day.\n\nSecond, we’re reducing the strength of coupling between our systems.\n\nIf we need to change the order of operations or to introduce new steps in the process, we can do that locally.\n\nUsing a Redis Pub/Sub Channel for Integration\n\nLet’s see how it will all work concretely. We’ll need some way of getting events out of one system and into another, like our message bus,\n\nbut for services. This piece of infrastructure is often called a message broker. The role of a message broker is to take messages from\n\npublishers and deliver them to subscribers.\n\nAt MADE.com, we use Event Store; Kafka or RabbitMQ are valid alternatives. A lightweight solution based on Redis pub/sub channels\n\ncan also work just fine, and because Redis is much more generally\n\nfamiliar to people, we thought we’d use it for this book.\n\nNOTE\n\nWe’re glossing over the complexity involved in choosing the right messaging platform. Concerns like message ordering, failure handling, and idempotency all need to be thought through. For a few pointers, see “Footguns”.\n\nOur new flow will look like Figure 11-6: Redis provides the BatchQuantityChanged event that kicks off the whole process, and our Allocated event is published back out to Redis again at the end.\n\nFigure 11-6. Sequence diagram for reallocation flow\n\nTest-Driving It All Using an End-to-End Test\n\nHere’s how we might start with an end-to-end test. We can use our\n\nexisting API to create batches, and then we’ll test both inbound and outbound messages:\n\nAn end-to-end test for our pub/sub model\n\n(tests/e2e/test_external_events.py)\n\ndef test_change_batch_quantity_leading_to_reallocation(): # start with two batches and an order allocated to one of them orderid, sku = random_orderid(), random_sku() earlier_batch, later_batch = random_batchref('old'), random_batchref('newer') api_client.post_to_add_batch(earlier_batch, sku, qty=10, eta='2011-01-02')\n\napi_client.post_to_add_batch(later_batch, sku, qty=10, eta='2011-01-02') response = api_client.post_to_allocate(orderid, sku, 10) assert response.json()['batchref'] == earlier_batch\n\nsubscription = redis_client.subscribe_to('line_allocated')\n\n# change quantity on allocated batch so it's less than our order redis_client.publish_message('change_batch_quantity', { 'batchref': earlier_batch, 'qty': 5 })\n\n# wait until we see a message saying the order has been reallocated messages = [] for attempt in Retrying(stop=stop_after_delay(3), reraise=True): with attempt: message = subscription.get_message(timeout=1) if message:\n\nmessages.append(message) print(messages) data = json.loads(messages[-1]['data']) assert data['orderid'] == orderid assert data['batchref'] == later_batch\n\nYou can read the story of what’s going on in this test from the comments: we want to send an event into the system that causes an order line to be reallocated, and we see that reallocation come out as an event in Redis too.\n\napi_client is a little helper that we refactored out to share between our two test types; it wraps our calls to requests.post.\n\nredis_client is another little test helper, the details of which don’t really matter; its job is to be able to send and receive messages from various Redis channels. We’ll use a channel called change_batch_quantity to send in our request to change the quantity for a batch, and we’ll listen to another channel called line_allocated to look out for the expected reallocation.\n\nBecause of the asynchronous nature of the system under test, we need to use the tenacity library again to add a retry loop—first, because it may take some time for our new line_allocated message to arrive, but also because it won’t be the only message on that channel.\n\nRedis Is Another Thin Adapter Around Our Message Bus\n\nOur Redis pub/sub listener (we call it an event consumer) is very much like Flask: it translates from the outside world to our events:\n\nSimple Redis message listener (src/allocation/entrypoints/redis_eventconsumer.py)\n\nr = redis.Redis(**config.get_redis_host_and_port())\n\ndef main(): orm.start_mappers() pubsub = r.pubsub(ignore_subscribe_messages=True) pubsub.subscribe('change_batch_quantity')\n\nfor m in pubsub.listen(): handle_change_batch_quantity(m)\n\ndef handle_change_batch_quantity(m): logging.debug('handling %s', m) data = json.loads(m['data']) cmd = commands.ChangeBatchQuantity(ref=data['batchref'], qty=data['qty'])\n\nmessagebus.handle(cmd, uow=unit_of_work.SqlAlchemyUnitOfWork())\n\nmain() subscribes us to the change_batch_quantity channel on load.\n\nOur main job as an entrypoint to the system is to deserialize JSON, convert it to a Command, and pass it to the service layer—much as the Flask adapter does.\n\nWe also build a new downstream adapter to do the opposite job— converting domain events to public events:\n\nSimple Redis message publisher (src/allocation/adapters/redis_eventpublisher.py)\n\nr = redis.Redis(**config.get_redis_host_and_port())\n\ndef publish(channel, event: events.Event): logging.debug('publishing: channel=%s, event=%s', channel, event) r.publish(channel, json.dumps(asdict(event)))\n\nWe take a hardcoded channel here, but you could also store a mapping between event classes/names and the appropriate channel, allowing one or more message types to go to different channels.\n\nOur New Outgoing Event\n\nHere’s what the Allocated event will look like:\n\nNew event (src/allocation/domain/events.py)\n\n@dataclass class Allocated(Event): orderid: str sku: str qty: int batchref: str\n\nIt captures everything we need to know about an allocation: the details of the order line, and which batch it was allocated to.\n\nWe add it into our model’s allocate() method (having added a test first, naturally):\n\nProduct.allocate() emits new event to record what happened (src/allocation/domain/model.py)\n\nclass Product: ... def allocate(self, line: OrderLine) -> str: ...\n\nbatch.allocate(line) self.version_number += 1 self.events.append(events.Allocated( orderid=line.orderid, sku=line.sku, qty=line.qty,\n\nbatchref=batch.reference, )) return batch.reference\n\nThe handler for ChangeBatchQuantity already exists, so all we need to add is a handler that publishes the outgoing event:\n\nThe message bus grows (src/allocation/service_layer/messagebus.py)\n\nHANDLERS = { events.Allocated: [handlers.publish_allocated_event], events.OutOfStock: [handlers.send_out_of_stock_notification], } # type: Dict[Type[events.Event], List[Callable]]\n\nPublishing the event uses our helper function from the Redis wrapper:\n\nPublish to Redis (src/allocation/service_layer/handlers.py)\n\ndef publish_allocated_event( event: events.Allocated, uow: unit_of_work.AbstractUnitOfWork, ): redis_eventpublisher.publish('line_allocated', event)\n\nInternal Versus External Events\n\nIt’s a good idea to keep the distinction between internal and external\n\nevents clear. Some events may come from the outside, and some events may get upgraded and published externally, but not all of them will. This is particularly important if you get into event sourcing (very much a topic for another book, though).",
      "page_number": 276
    },
    {
      "number": 11,
      "title": "Event-Driven Architecture: Using Events to Integrate Microservices",
      "start_page": 291,
      "end_page": 309,
      "detection_method": "regex_chapter_title",
      "content": "TIP\n\nOutbound events are one of the places it’s important to apply validation. See Appendix E for some validation philosophy and examples.\n\nEXERCISE FOR THE READER\n\nA nice simple one for this chapter: make it so that the main allocate() use case can also be invoked by an event on a Redis channel, as well as (or instead of) via the API.\n\nYou will likely want to add a new E2E test and feed through some changes into redis_eventconsumer.py.\n\nWrap-Up\n\nEvents can come from the outside, but they can also be published externally—our publish handler converts an event to a message on a Redis channel. We use events to talk to the outside world. This kind of temporal decoupling buys us a lot of flexibility in our application integrations, but as always, it comes at a cost.\n\nEvent notification is nice because it implies a low level of coupling, and is pretty simple to set up. It can become problematic, however, if there really is a logical flow that runs over various event notifications...It can be hard to see such a flow as it’s not explicit in any program text....This can make it hard to debug and modify.\n\n—Martin Fowler, “What do you mean by ‘Event- Driven’”\n\nTable 11-1 shows some trade-offs to think about.\n\nTable 11-1. Event-based microservices integration: the trade-offs\n\nPros\n\nCons\n\nAvoids the distributed big ball of mud.\n\nThe overall flows of information are harder to see.\n\nServices are decoupled: it’s easier to change individual services and add new ones.\n\nEventual consistency is a new concept to deal with.\n\nMessage reliability and choices around at-least-once versus at- most-once delivery need thinking through.\n\nMore generally, if you’re moving from a model of synchronous messaging to an async one, you also open up a whole host of problems\n\nhaving to do with message reliability and eventual consistency. Read on to “Footguns”.\n\nChapter 12. Command-Query Responsibility Segregation (CQRS)\n\nIn this chapter, we’re going to start with a fairly uncontroversial insight: reads (queries) and writes (commands) are different, so they should be treated differently (or have their responsibilities segregated,\n\nif you will). Then we’re going to push that insight as far as we can.\n\nIf you’re anything like Harry, this will all seem extreme at first, but\n\nhopefully we can make the argument that it’s not totally unreasonable.\n\nFigure 12-1 shows where we might end up.\n\nTIP\n\nThe code for this chapter is in the chapter_12_cqrs branch on GitHub.\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_12_cqrs # or to code along, checkout the previous chapter: git checkout chapter_11_external_events\n\nFirst, though, why bother?\n\nFigure 12-1. Separating reads from writes\n\nDomain Models Are for Writing\n\nWe’ve spent a lot of time in this book talking about how to build\n\nsoftware that enforces the rules of our domain. These rules, or constraints, will be different for every application, and they make up the interesting core of our systems.\n\nIn this book, we’ve set explicit constraints like “You can’t allocate more stock than is available,” as well as implicit constraints like “Each order line is allocated to a single batch.”\n\nWe wrote down these rules as unit tests at the beginning of the book:\n\nOur basic domain tests (tests/unit/test_batches.py)\n\ndef test_allocating_to_a_batch_reduces_the_available_quantity(): batch = Batch(\"batch-001\", \"SMALL-TABLE\", qty=20, eta=date.today()) line = OrderLine('order-ref', \"SMALL-TABLE\", 2)\n\nbatch.allocate(line)\n\nassert batch.available_quantity == 18\n\n...\n\ndef test_cannot_allocate_if_available_smaller_than_required(): small_batch, large_line = make_batch_and_line(\"ELEGANT-LAMP\", 2, 20) assert small_batch.can_allocate(large_line) is False\n\nTo apply these rules properly, we needed to ensure that operations were consistent, and so we introduced patterns like Unit of Work and Aggregate that help us commit small chunks of work.\n\nTo communicate changes between those small chunks, we introduced the Domain Events pattern so we can write rules like “When stock is damaged or lost, adjust the available quantity on the batch, and reallocate orders if necessary.”\n\nAll of this complexity exists so we can enforce rules when we change the state of our system. We’ve built a flexible set of tools for writing data.\n\nWhat about reads, though?\n\nMost Users Aren’t Going to Buy Your Furniture\n\nAt MADE.com, we have a system very like the allocation service. In a busy day, we might process one hundred orders in an hour, and we have a big gnarly system for allocating stock to those orders.\n\nIn that same busy day, though, we might have one hundred product views per second. Each time somebody visits a product page, or a product listing page, we need to figure out whether the product is still in stock and how long it will take us to deliver it.\n\nThe domain is the same—we’re concerned with batches of stock, and their arrival date, and the amount that’s still available—but the access pattern is very different. For example, our customers won’t notice if the query is a few seconds out of date, but if our allocate service is inconsistent, we’ll make a mess of their orders. We can take advantage\n\nof this difference by making our reads eventually consistent in order to make them perform better.\n\nIS READ CONSISTENCY TRULY ATTAINABLE?\n\nThis idea of trading consistency against performance makes a lot of developers nervous at first, so let’s talk quickly about that.\n\nLet’s imagine that our “Get Available Stock” query is 30 seconds out of date when Bob visits the page for ASYMMETRICAL-DRESSER. Meanwhile, though, Harry has already bought the last item. When we try to allocate Bob’s order, we’ll get a failure, and we’ll need to either cancel his order or buy more stock and delay his delivery.\n\nPeople who’ve worked only with relational data stores get really nervous about this problem, but it’s worth considering two other scenarios to gain some perspective.\n\nFirst, let’s imagine that Bob and Harry both visit the page at the same time. Harry goes off to make coffee, and by the time he returns, Bob has already bought the last dresser. When Harry places his order, we send it to the allocation service, and because there’s not enough stock, we have to refund his payment or buy more stock and delay his delivery.\n\nAs soon as we render the product page, the data is already stale. This insight is key to understanding why reads can be safely inconsistent: we’ll always need to check the current state of our system when we come to allocate, because all distributed systems are inconsistent. As soon as you have a web server and two customers, you have the potential for stale data.\n\nOK, let’s assume we solve that problem somehow: we magically build a totally consistent web application where nobody ever sees stale data. This time Harry gets to the page first and buys his dresser.\n\nUnfortunately for him, when the warehouse staff tries to dispatch his furniture, it falls off the forklift and smashes into a zillion pieces. Now what?\n\nThe only options are to either call Harry and refund his order or buy more stock and delay delivery.\n\nNo matter what we do, we’re always going to find that our software systems are inconsistent with reality, and so we’ll always need business processes to cope with these edge cases. It’s OK to trade performance for consistency on the read side, because stale data is essentially unavoidable.\n\nWe can think of these requirements as forming two halves of a system: the read side and the write side, shown in Table 12-1.\n\nFor the write side, our fancy domain architectural patterns help us to evolve our system over time, but the complexity we’ve built so far doesn’t buy anything for reading data. The service layer, the unit of work, and the clever domain model are just bloat.\n\nTable 12-1. Read versus write\n\nRead side\n\nWrite side\n\nBehavior\n\nSimple read\n\nComplex business logic\n\nCacheability\n\nHighly cacheable\n\nUncacheable\n\nConsistency\n\nCan be stale\n\nMust be transactionally consistent\n\nPost/Redirect/Get and CQS\n\nIf you do web development, you’re probably familiar with the Post/Redirect/Get pattern. In this technique, a web endpoint accepts an HTTP POST and responds with a redirect to see the result. For\n\nexample, we might accept a POST to /batches to create a new batch and redirect the user to /batches/123 to see their newly created batch.\n\nThis approach fixes the problems that arise when users refresh the results page in their browser or try to bookmark a results page. In the case of a refresh, it can lead to our users double-submitting data and thus buying two sofas when they needed only one. In the case of a bookmark, our hapless customers will end up with a broken page when they try to GET a POST endpoint.\n\nBoth these problems happen because we’re returning data in response\n\nto a write operation. Post/Redirect/Get sidesteps the issue by separating the read and write phases of our operation.\n\nThis technique is a simple example of command-query separation (CQS). In CQS we follow one simple rule: functions should either modify state or answer questions, but never both. This makes software easier to reason about: we should always be able to ask, “Are the lights on?” without flicking the light switch.\n\nNOTE\n\nWhen building APIs, we can apply the same design technique by returning a 201 Created, or a 202 Accepted, with a Location header containing the URI of our new resources. What’s important here isn’t the status code we use but the logical separation of work into a write phase and a query phase.\n\nAs you’ll see, we can use the CQS principle to make our systems faster and more scalable, but first, let’s fix the CQS violation in our existing code. Ages ago, we introduced an allocate endpoint that takes an order and calls our service layer to allocate some stock. At\n\nthe end of the call, we return a 200 OK and the batch ID. That’s led to some ugly design flaws so that we can get the data we need. Let’s\n\nchange it to return a simple OK message and instead provide a new read-only endpoint to retrieve allocation state:\n\nAPI test does a GET after the POST (tests/e2e/test_api.py)\n\n@pytest.mark.usefixtures('postgres_db') @pytest.mark.usefixtures('restart_api')\n\ndef test_happy_path_returns_202_and_batch_is_allocated(): orderid = random_orderid() sku, othersku = random_sku(), random_sku('other') earlybatch = random_batchref(1) laterbatch = random_batchref(2) otherbatch = random_batchref(3) api_client.post_to_add_batch(laterbatch, sku, 100, '2011-01-02') api_client.post_to_add_batch(earlybatch, sku, 100, '2011-01-01') api_client.post_to_add_batch(otherbatch, othersku, 100, None)\n\nr = api_client.post_to_allocate(orderid, sku, qty=3) assert r.status_code == 202\n\nr = api_client.get_allocation(orderid) assert r.ok assert r.json() == [ {'sku': sku, 'batchref': earlybatch}, ]\n\n@pytest.mark.usefixtures('postgres_db') @pytest.mark.usefixtures('restart_api') def test_unhappy_path_returns_400_and_error_message(): unknown_sku, orderid = random_sku(), random_orderid() r = api_client.post_to_allocate( orderid, unknown_sku, qty=20, expect_success=False, ) assert r.status_code == 400 assert r.json()['message'] == f'Invalid sku {unknown_sku}'\n\nr = api_client.get_allocation(orderid) assert r.status_code == 404\n\nOK, what might the Flask app look like?\n\nEndpoint for viewing allocations (src/allocation/entrypoints/flask_app.py)\n\nfrom allocation import views ...\n\n@app.route(\"/allocations/<orderid>\", methods=['GET']) def allocations_view_endpoint(orderid): uow = unit_of_work.SqlAlchemyUnitOfWork() result = views.allocations(orderid, uow) if not result: return 'not found', 404 return jsonify(result), 200\n\nAll right, a views.py, fair enough; we can keep read-only stuff in there, and it’ll be a real views.py, not like Django’s, something that knows how to build read-only views of our data…\n\nHold On to Your Lunch, Folks\n\nHmm, so we can probably just add a list method to our existing repository object:\n\nViews do…raw SQL? (src/allocation/views.py)\n\nfrom allocation.service_layer import unit_of_work\n\ndef allocations(orderid: str, uow: unit_of_work.SqlAlchemyUnitOfWork): with uow: results = list(uow.session.execute( 'SELECT ol.sku, b.reference' ' FROM allocations AS a' ' JOIN batches AS b ON a.batch_id = b.id' ' JOIN order_lines AS ol ON a.orderline_id = ol.id' ' WHERE ol.orderid = :orderid', dict(orderid=orderid) )) return [{'sku': sku, 'batchref': batchref} for sku, batchref in results]\n\nExcuse me? Raw SQL?\n\nIf you’re anything like Harry encountering this pattern for the first time,\n\nyou’ll be wondering what on earth Bob has been smoking. We’re hand- rolling our own SQL now, and converting database rows directly to\n\ndicts? After all the effort we put into building a nice domain model? And what about the Repository pattern? Isn’t that meant to be our\n\nabstraction around the database? Why don’t we reuse that?\n\nWell, let’s explore that seemingly simpler alternative first, and see what it looks like in practice.\n\nWe’ll still keep our view in a separate views.py module; enforcing a\n\nclear distinction between reads and writes in your application is still a good idea. We apply command-query separation, and it’s easy to see\n\nwhich code modifies state (the event handlers) and which code just retrieves read-only state (the views).\n\nTIP\n\nSplitting out your read-only views from your state-modifying command and event handlers is probably a good idea, even if you don’t want to go to full-blown CQRS.\n\nTesting CQRS Views\n\nBefore we get into exploring various options, let’s talk about testing. Whichever approaches you decide to go for, you’re probably going to\n\nneed at least one integration test. Something like this:\n\nAn integration test for a view (tests/integration/test_views.py)\n\ndef test_allocations_view(sqlite_session_factory): uow = unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory) messagebus.handle(commands.CreateBatch('sku1batch', 'sku1', 50, None), uow)\n\nmessagebus.handle(commands.CreateBatch('sku2batch', 'sku2', 50, today), uow) messagebus.handle(commands.Allocate('order1', 'sku1', 20), uow) messagebus.handle(commands.Allocate('order1', 'sku2', 20), uow) # add a spurious batch and order to make sure we're getting the right ones messagebus.handle(commands.CreateBatch('sku1batch-later', 'sku1', 50, today), uow) messagebus.handle(commands.Allocate('otherorder', 'sku1', 30), uow) messagebus.handle(commands.Allocate('otherorder', 'sku2', 10), uow)\n\nassert views.allocations('order1', uow) == [ {'sku': 'sku1', 'batchref': 'sku1batch'}, {'sku': 'sku2', 'batchref': 'sku2batch'}, ]\n\nWe do the setup for the integration test by using the public entrypoint to our application, the message bus. That keeps our tests decoupled from any implementation/infrastructure details about how things get stored.\n\n“Obvious” Alternative 1: Using the Existing Repository\n\nHow about adding a helper method to our products repository?\n\nA simple view that uses the repository (src/allocation/views.py)\n\nfrom allocation import unit_of_work\n\ndef allocations(orderid: str, uow: unit_of_work.AbstractUnitOfWork): with uow: products = uow.products.for_order(orderid=orderid) batches = [b for p in products for b in p.batches]\n\nreturn [ {'sku': b.sku, 'batchref': b.reference} for b in batches if orderid in b.orderids ]\n\nOur repository returns Product objects, and we need to find all the products for the SKUs in a given order, so we’ll build a new helper method called .for_order() on the repository.\n\nNow we have products but we actually want batch references, so we get all the possible batches with a list comprehension.\n\nWe filter again to get just the batches for our specific order. That, in turn, relies on our Batch objects being able to tell us which order IDs it has allocated.\n\nWe implement that last using a .orderid property:\n\nAn arguably unnecessary property on our model\n\n(src/allocation/domain/model.py)\n\nclass Batch: ...\n\n@property def orderids(self): return {l.orderid for l in self._allocations}\n\nYou can start to see that reusing our existing repository and domain\n\nmodel classes is not as straightforward as you might have assumed. We’ve had to add new helper methods to both, and we’re doing a\n\nbunch of looping and filtering in Python, which is work that would be done much more efficiently by the database.\n\nSo yes, on the plus side we’re reusing our existing abstractions, but on\n\nthe downside, it all feels quite clunky.\n\nYour Domain Model Is Not Optimized for Read Operations\n\nWhat we’re seeing here are the effects of having a domain model that\n\nis designed primarily for write operations, while our requirements for reads are often conceptually quite different.\n\nThis is the chin-stroking-architect’s justification for CQRS. As we’ve\n\nsaid before, a domain model is not a data model—we’re trying to capture the way the business works: workflow, rules around state\n\nchanges, messages exchanged; concerns about how the system reacts to external events and user input. Most of this stuff is totally irrelevant\n\nfor read-only operations.\n\nTIP\n\nThis justification for CQRS is related to the justification for the Domain Model pattern. If you’re building a simple CRUD app, reads and writes are going to be closely related, so you don’t need a domain model or CQRS. But the more complex your domain, the more likely you are to need both.\n\nTo make a facile point, your domain classes will have multiple methods for modifying state, and you won’t need any of them for read-\n\nonly operations.\n\nAs the complexity of your domain model grows, you will find yourself\n\nmaking more and more choices about how to structure that model, which make it more and more awkward to use for read operations.\n\n“Obvious” Alternative 2: Using the ORM\n\nYou may be thinking, OK, if our repository is clunky, and working with Products is clunky, then I can at least use my ORM and work with Batches. That’s what it’s for!\n\nA simple view that uses the ORM (src/allocation/views.py)\n\nfrom allocation import unit_of_work, model\n\ndef allocations(orderid: str, uow: unit_of_work.AbstractUnitOfWork): with uow: batches = uow.session.query(model.Batch).join( model.OrderLine, model.Batch._allocations ).filter( model.OrderLine.orderid == orderid ) return [ {'sku': b.sku, 'batchref': b.batchref} for b in batches ]\n\nBut is that actually any easier to write or understand than the raw SQL version from the code example in “Hold On to Your Lunch, Folks”? It may not look too bad up there, but we can tell you it took several attempts, and plenty of digging through the SQLAlchemy docs. SQL is\n\njust SQL.\n\nBut the ORM can also expose us to performance problems.\n\nSELECT N+1 and Other Performance Considerations\n\nThe so-called SELECT N+1 problem is a common performance problem with ORMs: when retrieving a list of objects, your ORM will\n\noften perform an initial query to, say, get all the IDs of the objects it needs, and then issue individual queries for each object to retrieve their attributes. This is especially likely if there are any foreign-key relationships on your objects.\n\nNOTE\n\nIn all fairness, we should say that SQLAlchemy is quite good at avoiding the SELECT N+1 problem. It doesn’t display it in the preceding example, and you can request eager loading explicitly to avoid it when dealing with joined objects.\n\nBeyond SELECT N+1, you may have other reasons for wanting to decouple the way you persist state changes from the way that you retrieve current state. A set of fully normalized relational tables is a\n\ngood way to make sure that write operations never cause data corruption. But retrieving data using lots of joins can be slow. It’s common in such cases to add some denormalized views, build read replicas, or even add caching layers.\n\nTime to Completely Jump the Shark\n\nOn that note: have we convinced you that our raw SQL version isn’t so weird as it first seemed? Perhaps we were exaggerating for effect? Just you wait.\n\nSo, reasonable or not, that hardcoded SQL query is pretty ugly, right? What if we made it nicer…\n\nA much nicer query (src/allocation/views.py)\n\ndef allocations(orderid: str, uow: unit_of_work.SqlAlchemyUnitOfWork): with uow: results = list(uow.session.execute( 'SELECT sku, batchref FROM allocations_view WHERE orderid = :orderid', dict(orderid=orderid) )) ...\n\n…by keeping a totally separate, denormalized data store for our view model?\n\nHee hee hee, no foreign keys, just strings, YOLO (src/allocation/adapters/orm.py)\n\nallocations_view = Table( 'allocations_view', metadata, Column('orderid', String(255)), Column('sku', String(255)), Column('batchref', String(255)), )\n\nOK, nicer-looking SQL queries wouldn’t be a justification for anything\n\nreally, but building a denormalized copy of your data that’s optimized for read operations isn’t uncommon, once you’ve reached the limits of what you can do with indexes.\n\nEven with well-tuned indexes, a relational database uses a lot of CPU to perform joins. The fastest queries will always be SELECT * from\n\nmytable WHERE key = :value.\n\nMore than raw speed, though, this approach buys us scale. When we’re\n\nwriting data to a relational database, we need to make sure that we get a lock over the rows we’re changing so we don’t run into consistency problems.\n\nIf multiple clients are changing data at the same time, we’ll have weird race conditions. When we’re reading data, though, there’s no limit to the number of clients that can concurrently execute. For this reason, read-only stores can be horizontally scaled out.\n\nTIP\n\nBecause read replicas can be inconsistent, there’s no limit to how many we can have. If you’re struggling to scale a system with a complex data store, ask whether you could build a simpler read model.\n\nKeeping the read model up to date is the challenge! Database views (materialized or otherwise) and triggers are a common solution, but that limits you to your database. We’d like to show you how to reuse\n\nour event-driven architecture instead.\n\nUpdating a Read Model Table Using an Event Handler\n\nWe add a second handler to the Allocated event:\n\nAllocated event gets a new handler\n\n(src/allocation/service_layer/messagebus.py)\n\nEVENT_HANDLERS = { events.Allocated: [ handlers.publish_allocated_event, handlers.add_allocation_to_read_model ],\n\nHere’s what our update-view-model code looks like:\n\nUpdate on allocation (src/allocation/service_layer/handlers.py)\n\ndef add_allocation_to_read_model( event: events.Allocated, uow: unit_of_work.SqlAlchemyUnitOfWork, ): with uow: uow.session.execute( 'INSERT INTO allocations_view (orderid, sku, batchref)' ' VALUES (:orderid, :sku, :batchref)', dict(orderid=event.orderid, sku=event.sku, batchref=event.batchref) ) uow.commit()\n\nBelieve it or not, that will pretty much work! And it will work against the exact same integration tests as the rest of our options.\n\nOK, you’ll also need to handle Deallocated:\n\nA second listener for read model updates\n\nevents.Deallocated: [ handlers.remove_allocation_from_read_model, handlers.reallocate ],\n\n...",
      "page_number": 291
    },
    {
      "number": 12,
      "title": "Command-Query Responsibility Segregation (CQRS)",
      "start_page": 310,
      "end_page": 334,
      "detection_method": "regex_chapter_title",
      "content": "def remove_allocation_from_read_model( event: events.Deallocated, uow: unit_of_work.SqlAlchemyUnitOfWork, ): with uow: uow.session.execute( 'DELETE FROM allocations_view ' ' WHERE orderid = :orderid AND sku = :sku',\n\nFigure 12-2 shows the flow across the two requests.\n\nFigure 12-2. Sequence diagram for read model\n\nIn Figure 12-2, you can see two transactions in the POST/write\n\noperation, one to update the write model and one to update the read model, which the GET/read operation can use.\n\nREBUILDING FROM SCRATCH\n\n“What happens when it breaks?” should be the first question we ask as engineers.\n\nHow do we deal with a view model that hasn’t been updated because of a bug or temporary outage? Well, this is just another case where events and commands can fail independently.\n\nIf we never updated the view model, and the ASYMMETRICAL-DRESSER was forever in stock, that would be annoying for customers, but the allocate service would still fail, and we’d take action to fix the problem.\n\nRebuilding a view model is easy, though. Since we’re using a service layer to update our view model, we can write a tool that does the following:\n\nQueries the current state of the write side to work out what’s currently allocated\n\nCalls the add_allocate_to_read_model handler for each allocated item\n\nWe can use this technique to create entirely new read models from historical data.\n\nChanging Our Read Model Implementation Is Easy\n\nLet’s see the flexibility that our event-driven model buys us in action, by seeing what happens if we ever decide we want to implement a\n\nread model by using a totally separate storage engine, Redis.\n\nJust watch:\n\nHandlers update a Redis read model (src/allocation/service_layer/handlers.py)\n\ndef add_allocation_to_read_model(event: events.Allocated, _): redis_eventpublisher.update_readmodel(event.orderid, event.sku, event.batchref)\n\ndef remove_allocation_from_read_model(event: events.Deallocated, _): redis_eventpublisher.update_readmodel(event.orderid, event.sku, None)\n\nThe helpers in our Redis module are one-liners:\n\nRedis read model read and update (src/allocation/adapters/redis_eventpublisher.py)\n\ndef update_readmodel(orderid, sku, batchref): r.hset(orderid, sku, batchref)\n\ndef get_readmodel(orderid): return r.hgetall(orderid)\n\n(Maybe the name redis_eventpublisher.py is a misnomer now, but you get the idea.)\n\nAnd the view itself changes very slightly to adapt to its new backend:\n\nView adapted to Redis (src/allocation/views.py)\n\ndef allocations(orderid): batches = redis_eventpublisher.get_readmodel(orderid) return [ {'batchref': b.decode(), 'sku': s.decode()} for s, b in batches.items() ]\n\nAnd the exact same integration tests that we had before still pass,\n\nbecause they are written at a level of abstraction that’s decoupled from\n\nthe implementation: setup puts messages on the message bus, and the\n\nassertions are against our view.\n\nTIP\n\nEvent handlers are a great way to manage updates to a read model, if you decide you need one. They also make it easy to change the implementation of that read model at a later date.\n\nEXERCISE FOR THE READER\n\nImplement another view, this time to show the allocation for a single order line.\n\nHere the trade-offs between using hardcoded SQL versus going via a repository should be much more blurry. Try a few versions (maybe including going to Redis), and see which you prefer.\n\nWrap-Up\n\nTable 12-2 proposes some pros and cons for each of our options.\n\nAs it happens, the allocation service at MADE.com does use “full- blown” CQRS, with a read model stored in Redis, and even a second\n\nlayer of cache provided by Varnish. But its use cases are quite a bit different from what we’ve shown here. For the kind of allocation service we’re building, it seems unlikely that you’d need to use a separate read model and event handlers for updating it.\n\nBut as your domain model becomes richer and more complex, a simplified read model become ever more compelling.\n\nTable 12-2. Trade-offs of various view model options\n\nOption\n\nPros\n\nCons\n\nJust use repositories\n\nSimple, consistent approach.\n\nExpect performance issues with complex query patterns.\n\nUse custom queries with your ORM\n\nAllows reuse of DB configuration and model definitions.\n\nAdds another query language with its own quirks and syntax.\n\nUse hand- rolled SQL\n\nOffers fine control over performance with a standard query syntax.\n\nChanges to DB schema have to be made to your hand-rolled queries and your ORM definitions. Highly normalized schemas may still have performance limitations.\n\nCreate separate read stores with events\n\nRead-only copies are easy to scale out. Views can be constructed when data changes so that queries are as simple as possible.\n\nComplex technique. Harry will be forever suspicious of your tastes and motives.\n\nOften, your read operations will be acting on the same conceptual objects as your write model, so using the ORM, adding some read methods to your repositories, and using domain model classes for your read operations is just fine.\n\nIn our book example, the read operations act on quite different conceptual entities to our domain model. The allocation service thinks in terms of Batches for a single SKU, but users care about allocations for a whole order, with multiple SKUs, so using the ORM ends up being a little awkward. We’d be quite tempted to go with the raw-SQL\n\nview we showed right at the beginning of the chapter.\n\nOn that note, let’s sally forth into our final chapter.\n\nChapter 13. Dependency Injection (and Bootstrapping)\n\nDependency injection (DI) is regarded with suspicion in the Python world. And we’ve managed just fine without it so far in the example code for this book!\n\nIn this chapter, we’ll explore some of the pain points in our code that\n\nlead us to consider using DI, and we’ll present some options for how to do it, leaving it to you to pick which you think is most Pythonic.\n\nWe’ll also add a new component to our architecture called bootstrap.py; it will be in charge of dependency injection, as well as some other initialization stuff that we often need. We’ll explain why\n\nthis sort of thing is called a composition root in OO languages, and why bootstrap script is just fine for our purposes.\n\nFigure 13-1 shows what our app looks like without a bootstrapper: the entrypoints do a lot of initialization and passing around of our main\n\ndependency, the UoW.\n\nTIP\n\nIf you haven’t already, it’s worth reading Chapter 3 before continuing with this chapter, particularly the discussion of functional versus object-oriented dependency management.\n\nFigure 13-1. Without bootstrap: entrypoints do a lot\n\nTIP\n\nThe code for this chapter is in the chapter_13_dependency_injection branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_13_dependency_injection # or to code along, checkout the previous chapter: git checkout chapter_12_cqrs\n\nFigure 13-2 shows our bootstrapper taking over those responsibilities.\n\nFigure 13-2. Bootstrap takes care of all that in one place\n\nImplicit Versus Explicit Dependencies\n\nDepending on your particular brain type, you may have a slight feeling\n\nof unease at the back of your mind at this point. Let’s bring it out into the open. We’ve shown you two ways of managing dependencies and testing them.\n\nFor our database dependency, we’ve built a careful framework of explicit dependencies and easy options for overriding them in tests. Our main handler functions declare an explicit dependency on the UoW:\n\nOur handlers have an explicit dependency on the UoW (src/allocation/service_layer/handlers.py)\n\ndef allocate( cmd: commands.Allocate, uow: unit_of_work.AbstractUnitOfWork ):\n\nAnd that makes it easy to swap in a fake UoW in our service-layer tests:\n\nService-layer tests against a fake UoW: (tests/unit/test_services.py)\n\nuow = FakeUnitOfWork() messagebus.handle([...], uow)\n\nThe UoW itself declares an explicit dependency on the session factory:\n\nThe UoW depends on a session factory (src/allocation/service_layer/unit_of_work.py)\n\nclass SqlAlchemyUnitOfWork(AbstractUnitOfWork):\n\ndef __init__(self, session_factory=DEFAULT_SESSION_FACTORY): self.session_factory = session_factory ...\n\nWe take advantage of it in our integration tests to be able to sometimes use SQLite instead of Postgres:\n\nIntegration tests against a different DB (tests/integration/test_uow.py)\n\ndef test_rolls_back_uncommitted_work_by_default(sqlite_session_factory): uow = unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory)\n\nIntegration tests swap out the default Postgres session_factory for a SQLite one.\n\nAren’t Explicit Dependencies Totally Weird and Java-y?\n\nIf you’re used to the way things normally happen in Python, you’ll be thinking all this is a bit weird. The standard way to do things is to declare our dependency implicitly by simply importing it, and then if we ever need to change it for tests, we can monkeypatch, as is Right and True in dynamic languages:\n\nEmail sending as a normal import-based dependency (src/allocation/service_layer/handlers.py)\n\nfrom allocation.adapters import email, redis_eventpublisher ...\n\ndef send_out_of_stock_notification( event: events.OutOfStock, uow: unit_of_work.AbstractUnitOfWork, ): email.send( 'stock@made.com', f'Out of stock for {event.sku}', )\n\nHardcoded import\n\nCalls specific email sender directly\n\nWhy pollute our application code with unnecessary arguments just for the sake of our tests? mock.patch makes monkeypatching nice and easy:\n\nmock dot patch, thank you Michael Foord (tests/unit/test_handlers.py)\n\nwith mock.patch(\"allocation.adapters.email.send\") as mock_send_mail: ...\n\nThe trouble is that we’ve made it look easy because our toy example doesn’t send real email (email.send_mail just does a print), but in real life, you’d end up having to call mock.patch for every single test that might cause an out-of-stock notification. If you’ve worked on\n\ncodebases with lots of mocks used to prevent unwanted side effects,\n\nyou’ll know how annoying that mocky boilerplate gets.\n\nAnd you’ll know that mocks tightly couple us to the implementation. By choosing to monkeypatch email.send_mail, we are tied to doing\n\nimport email, and if we ever want to do from email import send_mail, a trivial refactor, we’d have to change all our mocks.\n\nSo it’s a trade-off. Yes, declaring explicit dependencies is\n\nunnecessary, strictly speaking, and using them would make our application code marginally more complex. But in return, we’d get\n\ntests that are easier to write and manage.\n\nOn top of that, declaring an explicit dependency is an example of the dependency inversion principle—rather than having an (implicit)\n\ndependency on a specific detail, we have an (explicit) dependency on an abstraction:\n\nExplicit is better than implicit.\n\n—The Zen of Python\n\nThe explicit dependency is more abstract\n\n(src/allocation/service_layer/handlers.py)\n\ndef send_out_of_stock_notification( event: events.OutOfStock, send_mail: Callable, ): send_mail( 'stock@made.com', f'Out of stock for {event.sku}', )\n\nBut if we do change to declaring all these dependencies explicitly, who will inject them, and how? So far, we’ve really been dealing with only passing the UoW around: our tests use FakeUnitOfWork, while Flask and Redis eventconsumer entrypoints use the real UoW, and the\n\nmessage bus passes them onto our command handlers. If we add real and fake email classes, who will create them and pass them on?\n\nThat’s extra (duplicated) cruft for Flask, Redis, and our tests.\n\nMoreover, putting all the responsibility for passing dependencies to the right handler onto the message bus feels like a violation of the SRP.\n\nInstead, we’ll reach for a pattern called Composition Root (a\n\n1\n\nbootstrap script to you and me), and we’ll do a bit of “manual DI” (dependency injection without a framework). See Figure 13-3.\n\n2\n\nFigure 13-3. Bootstrapper between entrypoints and message bus\n\nPreparing Handlers: Manual DI with Closures and Partials\n\nOne way to turn a function with dependencies into one that’s ready to\n\nbe called later with those dependencies already injected is to use closures or partial functions to compose the function with its\n\ndependencies:\n\nExamples of DI using closures or partial functions\n\n# existing allocate function, with abstract uow dependency def allocate( cmd: commands.Allocate, uow: unit_of_work.AbstractUnitOfWork ): line = OrderLine(cmd.orderid, cmd.sku, cmd.qty) with uow: ...\n\n# bootstrap script prepares actual UoW\n\ndef bootstrap(..): uow = unit_of_work.SqlAlchemyUnitOfWork()\n\n# prepare a version of the allocate fn with UoW dependency captured in a closure allocate_composed = lambda cmd: allocate(cmd, uow)\n\n# or, equivalently (this gets you a nicer stack trace) def allocate_composed(cmd): return allocate(cmd, uow)\n\n# alternatively with a partial import functools allocate_composed = functools.partial(allocate, uow=uow)\n\n# later at runtime, we can call the partial function, and it will have\n\n# the UoW already bound allocate_composed(cmd)\n\nThe difference between closures (lambdas or named functions) and functools.partial is that the former use late binding of variables, which can be a source of confusion if any of the dependencies are mutable.\n\nHere’s the same pattern again for the send_out_of_stock_notification() handler, which has different dependencies:\n\nAnother closure and partial functions example\n\ndef send_out_of_stock_notification( event: events.OutOfStock, send_mail: Callable, ): send_mail( 'stock@made.com', ...\n\n# prepare a version of the send_out_of_stock_notification with dependencies sosn_composed = lambda event: send_out_of_stock_notification(event, email.send_mail)\n\n... # later, at runtime: sosn_composed(event) # will have email.send_mail already injected in\n\nAn Alternative Using Classes\n\nClosures and partial functions will feel familiar to people who’ve done a bit of functional programming. Here’s an alternative using\n\nclasses, which may appeal to others. It requires rewriting all our handler functions as classes, though:\n\nDI using classes\n\n# we replace the old `def allocate(cmd, uow)` with:\n\nclass AllocateHandler:\n\ndef __init__(self, uow: unit_of_work.AbstractUnitOfWork): self.uow = uow\n\ndef __call__(self, cmd: commands.Allocate): line = OrderLine(cmd.orderid, cmd.sku, cmd.qty) with self.uow: # rest of handler method as before ...\n\n# bootstrap script prepares actual UoW uow = unit_of_work.SqlAlchemyUnitOfWork()\n\n# then prepares a version of the allocate fn with dependencies already injected allocate = AllocateHandler(uow)\n\n... # later at runtime, we can call the handler instance, and it will have # the UoW already injected allocate(cmd)\n\nThe class is designed to produce a callable function, so it has a call method.\n\nBut we use the init to declare the dependencies it requires. This sort of thing will feel familiar if you’ve ever made class-based descriptors, or a class-based context manager that takes arguments.\n\nUse whichever you and your team feel more comfortable with.\n\nA Bootstrap Script\n\nWe want our bootstrap script to do the following:\n\n1. Declare default dependencies but allow us to override them\n\n2. Do the “init” stuff that we need to get our app started\n\n3. Inject all the dependencies into our handlers\n\n4. Give us back the core object for our app, the message bus\n\nHere’s a first cut:\n\nA bootstrap function (src/allocation/bootstrap.py)\n\ndef bootstrap( start_orm: bool = True, uow: unit_of_work.AbstractUnitOfWork = unit_of_work.SqlAlchemyUnitOfWork(),\n\nsend_mail: Callable = email.send, publish: Callable = redis_eventpublisher.publish, ) -> messagebus.MessageBus:\n\nif start_orm: orm.start_mappers()\n\ndependencies = {'uow': uow, 'send_mail': send_mail, 'publish': publish} injected_event_handlers = { event_type: [ inject_dependencies(handler, dependencies) for handler in event_handlers ] for event_type, event_handlers in handlers.EVENT_HANDLERS.items() } injected_command_handlers = { command_type: inject_dependencies(handler, dependencies) for command_type, handler in handlers.COMMAND_HANDLERS.items() }\n\nreturn messagebus.MessageBus( uow=uow, event_handlers=injected_event_handlers,\n\ncommand_handlers=injected_command_handlers, )\n\norm.start_mappers() is our example of initialization work that needs to be done once at the beginning of an app. We also see things like setting up the logging module.\n\nWe can use the argument defaults to define what the normal/production defaults are. It’s nice to have them in a single place, but sometimes dependencies have some side effects at construction time, in which case you might prefer to default them to None instead.\n\nWe build up our injected versions of the handler mappings by using a function called inject_dependencies(), which we’ll show next.\n\nWe return a configured message bus ready for use.\n\nHere’s how we inject dependencies into a handler function by inspecting it:\n\nDI by inspecting function signatures (src/allocation/bootstrap.py)\n\ndef inject_dependencies(handler, dependencies): params = inspect.signature(handler).parameters deps = { name: dependency for name, dependency in dependencies.items() if name in params } return lambda message: handler(message, **deps)\n\nWe inspect our command/event handler’s arguments.\n\nWe match them by name to our dependencies.\n\nWe inject them as kwargs to produce a partial.\n\nEVEN-MORE-MANUAL DI WITH LESS MAGIC\n\nIf you’re finding the preceding inspect code a little harder to grok, this even simpler version may appeal to you.\n\nHarry wrote the code for inject_dependencies() as a first cut of how to do “manual” dependency injection, and when he saw it, Bob accused him of overengineering and writing his own DI framework.\n\nIt honestly didn’t even occur to Harry that you could do it any more plainly, but you can, like this:\n\nManually creating partial functions inline (src/allocation/bootstrap.py)\n\ninjected_event_handlers = { events.Allocated: [ lambda e: handlers.publish_allocated_event(e, publish), lambda e: handlers.add_allocation_to_read_model(e, uow), ], events.Deallocated: [ lambda e: handlers.remove_allocation_from_read_model(e, uow), lambda e: handlers.reallocate(e, uow), ], events.OutOfStock: [ lambda e: handlers.send_out_of_stock_notification(e, send_mail) ] } injected_command_handlers = { commands.Allocate: lambda c: handlers.allocate(c, uow), commands.CreateBatch: \\ lambda c: handlers.add_batch(c, uow), commands.ChangeBatchQuantity: \\ lambda c: handlers.change_batch_quantity(c, uow), }\n\nHarry says he couldn’t even imagine writing out that many lines of code and having to look up that many function arguments manually. This is a perfectly viable solution, though, since it’s only one line of code or so per handler you add, and thus not a massive maintenance burden even if you have dozens of handlers.\n\nOur app is structured in such a way that we always want to do dependency injection in only one place, the handler functions, so this super-manual solution and Harry’s inspect()-based one will both work fine.\n\nIf you find yourself wanting to do DI in more things and at different times, or if you ever get into dependency chains (in which your dependencies have their own dependencies, and so on), you may get some mileage out of a “real” DI framework.\n\nAt MADE, we’ve used Inject in a few places, and it’s fine, although it makes Pylint unhappy. You might also check out Punq, as written by Bob himself, or the DRY-Python crew’s dependencies.\n\nMessage Bus Is Given Handlers at Runtime\n\nOur message bus will no longer be static; it needs to have the already-\n\ninjected handlers given to it. So we turn it from being a module into a configurable class:\n\nMessageBus as a class (src/allocation/service_layer/messagebus.py)\n\nclass MessageBus:\n\ndef __init__( self, uow: unit_of_work.AbstractUnitOfWork, event_handlers: Dict[Type[events.Event], List[Callable]], command_handlers: Dict[Type[commands.Command], Callable], ): self.uow = uow self.event_handlers = event_handlers self.command_handlers = command_handlers\n\ndef handle(self, message: Message): self.queue = [message] while self.queue: message = self.queue.pop(0) if isinstance(message, events.Event): self.handle_event(message) elif isinstance(message, commands.Command): self.handle_command(message) else: raise Exception(f'{message} was not an Event or Command')\n\nThe message bus becomes a class…\n\n…which is given its already-dependency-injected handlers.\n\nThe main handle() function is substantially the same, with just a few attributes and methods moved onto self.\n\nUsing self.queue like this is not thread-safe, which might be a problem if you’re using threads, because the bus instance is global in the Flask app context as we’ve written it. Just something to watch out for.\n\nWhat else changes in the bus?\n\nEvent and command handler logic stays the same (src/allocation/service_layer/messagebus.py)\n\ndef handle_event(self, event: events.Event): for handler in self.event_handlers[type(event)]: try: logger.debug('handling event %s with handler %s', event, handler) handler(event) self.queue.extend(self.uow.collect_new_events()) except Exception: logger.exception('Exception handling event %s', event) continue\n\ndef handle_command(self, command: commands.Command): logger.debug('handling command %s', command) try: handler = self.command_handlers[type(command)] handler(command) self.queue.extend(self.uow.collect_new_events()) except Exception: logger.exception('Exception handling command %s', command) raise\n\nhandle_event and handle_command are substantially the same, but instead of indexing into a static EVENT_HANDLERS or\n\nCOMMAND_HANDLERS dict, they use the versions on self.\n\nInstead of passing a UoW into the handler, we expect the handlers to already have all their dependencies, so all they need is a single argument, the specific event or command.\n\nUsing Bootstrap in Our Entrypoints\n\nIn our application’s entrypoints, we now just call bootstrap.bootstrap() and get a message bus that’s ready to go, rather than configuring a UoW and the rest of it:\n\nFlask calls bootstrap (src/allocation/entrypoints/flask_app.py)\n\nfrom allocation import views +from allocation import bootstrap, views\n\napp = Flask(__name__) -orm.start_mappers() +bus = bootstrap.bootstrap()\n\n@app.route(\"/add_batch\", methods=['POST']) @@ -19,8 +16,7 @@ def add_batch(): cmd = commands.CreateBatch( request.json['ref'], request.json['sku'], request.json['qty'], eta, ) - uow = unit_of_work.SqlAlchemyUnitOfWork() - messagebus.handle(cmd, uow) + bus.handle(cmd) return 'OK', 201\n\nWe no longer need to call start_orm(); the bootstrap script’s initialization stages will do that.\n\nWe no longer need to explicitly build a particular type of UoW; the bootstrap script defaults take care of it.\n\nAnd our message bus is now a specific instance rather than the global module.\n\n3\n\nInitializing DI in Our Tests\n\nIn tests, we can use bootstrap.bootstrap() with overridden defaults to get a custom message bus. Here’s an example in an integration test:\n\nOverriding bootstrap defaults (tests/integration/test_views.py)\n\n@pytest.fixture def sqlite_bus(sqlite_session_factory): bus = bootstrap.bootstrap( start_orm=True, uow=unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory), send_mail=lambda *args: None, publish=lambda *args: None, ) yield bus clear_mappers()\n\ndef test_allocations_view(sqlite_bus): sqlite_bus.handle(commands.CreateBatch('sku1batch', 'sku1', 50, None)) sqlite_bus.handle(commands.CreateBatch('sku2batch', 'sku2', 50, date.today())) ... assert views.allocations('order1', sqlite_bus.uow) == [ {'sku': 'sku1', 'batchref': 'sku1batch'}, {'sku': 'sku2', 'batchref': 'sku2batch'}, ]\n\nWe do still want to start the ORM…\n\n…because we’re going to use a real UoW, albeit with an in- memory database.\n\nBut we don’t need to send email or publish, so we make those noops.\n\nIn our unit tests, in contrast, we can reuse our FakeUnitOfWork:\n\nBootstrap in unit test (tests/unit/test_handlers.py)\n\ndef bootstrap_test_app(): return bootstrap.bootstrap( start_orm=False, uow=FakeUnitOfWork(), send_mail=lambda *args: None, publish=lambda *args: None, )\n\nNo need to start the ORM…\n\n…because the fake UoW doesn’t use one.\n\nWe want to fake out our email and Redis adapters too.\n\nSo that gets rid of a little duplication, and we’ve moved a bunch of\n\nsetup and sensible defaults into a single place.\n\nEXERCISE FOR THE READER 1\n\nChange all the handlers to being classes as per the DI using classes example, and amend the bootstrapper’s DI code as appropriate. This will let you know whether you prefer the functional approach or the class-based approach when it comes to your own projects.\n\nBuilding an Adapter “Properly”: A Worked Example",
      "page_number": 310
    },
    {
      "number": 13,
      "title": "Dependency Injection (and Bootstrapping)",
      "start_page": 335,
      "end_page": 497,
      "detection_method": "regex_chapter_title",
      "content": "To really get a feel for how it all works, let’s work through an example\n\nof how you might “properly” build an adapter and do dependency injection for it.\n\nAt the moment, we have two types of dependencies:\n\nTwo types of dependencies (src/allocation/service_layer/messagebus.py)\n\nuow: unit_of_work.AbstractUnitOfWork, send_mail: Callable, publish: Callable,\n\nThe UoW has an abstract base class. This is the heavyweight option for declaring and managing your external dependency. We’d use this for the case when the dependency is relatively complex.\n\nOur email sender and pub/sub publisher are defined as functions. This works just fine for simple dependencies.\n\nHere are some of the things we find ourselves injecting at work:\n\nAn S3 filesystem client\n\nA key/value store client\n\nA requests session object\n\nMost of these will have more-complex APIs that you can’t capture as a\n\nsingle function: read and write, GET and POST, and so on.\n\nEven though it’s simple, let’s use send_mail as an example to talk through how you might define a more complex dependency.\n\nDefine the Abstract and Concrete Implementations\n\nWe’ll imagine a more generic notifications API. Could be email, could be SMS, could be Slack posts one day.\n\nAn ABC and a concrete implementation\n\n(src/allocation/adapters/notifications.py)\n\nclass AbstractNotifications(abc.ABC):\n\n@abc.abstractmethod def send(self, destination, message): raise NotImplementedError\n\n...\n\nclass EmailNotifications(AbstractNotifications):\n\ndef __init__(self, smtp_host=DEFAULT_HOST, port=DEFAULT_PORT): self.server = smtplib.SMTP(smtp_host, port=port) self.server.noop()\n\ndef send(self, destination, message): msg = f'Subject: allocation service notification\\n{message}' self.server.sendmail( from_addr='allocations@example.com', to_addrs=[destination], msg=msg )\n\nWe change the dependency in the bootstrap script:\n\nNotifications in message bus (src/allocation/bootstrap.py)\n\ndef bootstrap( start_orm: bool = True, uow: unit_of_work.AbstractUnitOfWork = unit_of_work.SqlAlchemyUnitOfWork(), - send_mail: Callable = email.send,\n\n+ notifications: AbstractNotifications = EmailNotifications(), publish: Callable = redis_eventpublisher.publish, ) -> messagebus.MessageBus:\n\nMake a Fake Version for Your Tests\n\nWe work through and define a fake version for unit testing:\n\nFake notifications (tests/unit/test_handlers.py)\n\nclass FakeNotifications(notifications.AbstractNotifications):\n\ndef __init__(self): self.sent = defaultdict(list) # type: Dict[str, List[str]]\n\ndef send(self, destination, message): self.sent[destination].append(message) ...\n\nAnd we use it in our tests:\n\nTests change slightly (tests/unit/test_handlers.py)\n\ndef test_sends_email_on_out_of_stock_error(self): fake_notifs = FakeNotifications() bus = bootstrap.bootstrap( start_orm=False, uow=FakeUnitOfWork(), notifications=fake_notifs, publish=lambda *args: None, ) bus.handle(commands.CreateBatch(\"b1\", \"POPULAR-CURTAINS\", 9, None)) bus.handle(commands.Allocate(\"o1\", \"POPULAR-CURTAINS\", 10)) assert fake_notifs.sent['stock@made.com'] == [ f\"Out of stock for POPULAR-CURTAINS\", ]\n\nFigure Out How to Integration Test the Real Thing\n\nNow we test the real thing, usually with an end-to-end or integration test. We’ve used MailHog as a real-ish email server for our Docker\n\ndev environment:\n\nDocker-compose config with real fake email server (docker- compose.yml)\n\nversion: \"3\"\n\nservices:\n\nredis_pubsub: build: context: . dockerfile: Dockerfile image: allocation-image ...\n\napi: image: allocation-image ...\n\npostgres: image: postgres:9.6 ...\n\nredis: image: redis:alpine ...\n\nmailhog: image: mailhog/mailhog ports: - \"11025:1025\" - \"18025:8025\"\n\nIn our integration tests, we use the real EmailNotifications class, talking to the MailHog server in the Docker cluster:\n\nIntegration test for email (tests/integration/test_email.py)\n\n@pytest.fixture def bus(sqlite_session_factory): bus = bootstrap.bootstrap( start_orm=True, uow=unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory), notifications=notifications.EmailNotifications(), publish=lambda *args: None, ) yield bus clear_mappers()\n\ndef get_email_from_mailhog(sku): host, port = map(config.get_email_host_and_port().get, ['host', 'http_port']) all_emails = requests.get(f'http://{host}:{port}/api/v2/messages').json() return next(m for m in all_emails['items'] if sku in str(m))\n\ndef test_out_of_stock_email(bus): sku = random_sku() bus.handle(commands.CreateBatch('batch1', sku, 9, None)) bus.handle(commands.Allocate('order1', sku, 10)) email = get_email_from_mailhog(sku) assert email['Raw']['From'] == 'allocations@example.com' assert email['Raw']['To'] == ['stock@made.com'] assert f'Out of stock for {sku}' in email['Raw']['Data']\n\nWe use our bootstrapper to build a message bus that talks to the real notifications class.\n\nWe figure out how to fetch emails from our “real” email server.\n\nWe use the bus to do our test setup.\n\nAgainst all the odds, this actually worked, pretty much at the first go!\n\nAnd that’s it really.\n\nEXERCISE FOR THE READER 2\n\nYou could do two things for practice regarding adapters:\n\n1. Try swapping out our notifications from email to SMS notifications using Twilio, for example, or Slack notifications. Can you find a good equivalent to MailHog for integration testing?\n\n2. In a similar way to what we did moving from send_mail to a Notifications class, try refactoring our redis_eventpublisher that is currently just a Callable to some sort of more formal adapter/base class/protocol.\n\nWrap-Up\n\nOnce you have more than one adapter, you’ll start to feel a lot of pain from passing dependencies around manually, unless you do some kind of dependency injection.\n\nSetting up dependency injection is just one of many typical setup/initialization activities that you need to do just once when\n\nstarting your app. Putting this all together into a bootstrap script is often a good idea.\n\nThe bootstrap script is also good as a place to provide sensible default configuration for your adapters, and as a single place to override those adapters with fakes for your tests.\n\nA dependency injection framework can be useful if you find yourself needing to do DI at multiple levels—if you have chained dependencies\n\nof components that all need DI, for example.\n\nThis chapter also presented a worked example of changing an implicit/simple dependency into a “proper” adapter, factoring out an ABC, defining its real and fake implementations, and thinking through integration testing.\n\nDI AND BOOTSTRAP RECAP\n\nIn summary:\n\n1. Define your API using an ABC.\n\n2. Implement the real thing.\n\n3. Build a fake and use it for unit/service-layer/handler tests.\n\n4. Find a less fake version you can put into your Docker environment.\n\n5. Test the less fake “real” thing.\n\n6. Profit!\n\nThese were the last patterns we wanted to cover, which brings us to the end of Part II. In the epilogue, we’ll try to give you some pointers\n\nfor applying these techniques in the Real World\n\nTM .\n\n1 Because Python is not a “pure” OO language, Python developers aren’t necessarily used to the concept of needing to compose a set of objects into a working application. We just pick our entrypoint and run code from top to bottom.\n\n2 Mark Seemann calls this Pure DI or sometimes Vanilla DI.\n\n3 However, it’s still a global in the flask_app module scope, if that makes sense. This may cause problems if you ever find yourself wanting to test your Flask app in-process by\n\nusing the Flask Test Client instead of using Docker as we do. It’s worth researching Flask app factories if you get into this.\n\nEpilogue\n\nWhat Now?\n\nPhew! We’ve covered a lot of ground in this book, and for most of our audience all of these ideas are new. With that in mind, we can’t hope to make you experts in these techniques. All we can really do is show you the broad-brush ideas, and just enough code for you to go ahead\n\nand write something from scratch.\n\nThe code we’ve shown in this book isn’t battle-hardened production\n\ncode: it’s a set of Lego blocks that you can play with to make your first house, spaceship, and skyscraper.\n\nThat leaves us with two big tasks. We want to talk about how to start applying these ideas for real in an existing system, and we need to\n\nwarn you about some of the things we had to skip. We’ve given you a whole new arsenal of ways to shoot yourself in the foot, so we should\n\ndiscuss some basic firearms safety.\n\nHow Do I Get There from Here?\n\nChances are that a lot of you are thinking something like this:\n\n“OK Bob and Harry, that’s all well and good, and if I ever get hired to work on a green-field new service, I know what to do. But in the meantime, I’m here with my big ball of Django mud, and I don’t see\n\nany way to get to your nice, clean, perfect, untainted, simplistic model. Not from here.”\n\nWe hear you. Once you’ve already built a big ball of mud, it’s hard to know how to start improving things. Really, we need to tackle things step by step.\n\nFirst things first: what problem are you trying to solve? Is the software too hard to change? Is the performance unacceptable? Have you got weird, inexplicable bugs?\n\nHaving a clear goal in mind will help you to prioritize the work that needs to be done and, importantly, communicate the reasons for doing\n\nit to the rest of the team. Businesses tend to have pragmatic approaches to technical debt and refactoring, so long as engineers can make a reasoned argument for fixing things.\n\nTIP\n\nMaking complex changes to a system is often an easier sell if you link it to feature work. Perhaps you’re launching a new product or opening your service to new markets? This is the right time to spend engineering resources on fixing the foundations. With a six-month project to deliver, it’s easier to make the argument for three weeks of cleanup work. Bob refers to this as architecture tax.\n\nSeparating Entangled Responsibilities\n\nAt the beginning of the book, we said that the main characteristic of a big ball of mud is homogeneity: every part of the system looks the\n\nsame, because we haven’t been clear about the responsibilities of each component. To fix that, we’ll need to start separating out responsibilities and introducing clear boundaries. One of the first things we can do is to start building a service layer (Figure E-1).\n\nFigure E-1. Domain of a collaboration system\n\nThis was the system in which Bob first learned how to break apart a\n\nball of mud, and it was a doozy. There was logic everywhere—in the web pages, in manager objects, in helpers, in fat service classes that we’d written to abstract the managers and helpers, and in hairy command objects that we’d written to break apart the services.\n\nIf you’re working in a system that’s reached this point, the situation can feel hopeless, but it’s never too late to start weeding an overgrown garden. Eventually, we hired an architect who knew what he was doing, and he helped us get things back under control.\n\nStart by working out the use cases of your system. If you have a user interface, what actions does it perform? If you have a backend processing component, maybe each cron job or Celery job is a single use case. Each of your use cases needs to have an imperative name: Apply Billing Charges, Clean Abandoned Accounts, or Raise Purchase Order, for example.\n\nIn our case, most of our use cases were part of the manager classes and had names like Create Workspace or Delete Document Version. Each use case was invoked from a web frontend.\n\nWe aim to create a single function or class for each of these supported operations that deals with orchestrating the work to be done. Each use case should do the following:\n\nStart its own database transaction if needed\n\nFetch any required data\n\nCheck any preconditions (see the Ensure pattern in Appendix E)\n\nUpdate the domain model\n\nPersist any changes\n\nEach use case should succeed or fail as an atomic unit. You might need to call one use case from another. That’s OK; just make a note of it, and try to avoid long-running database transactions.\n\nNOTE\n\nOne of the biggest problems we had was that manager methods called other manager methods, and data access could happen from the model objects themselves. It was hard to understand what each operation did without going on a treasure hunt across the codebase. Pulling all the logic into a single method, and using a UoW to control our transactions, made the system easier to reason about.\n\nCASE STUDY: LAYERING AN OVERGROWN SYSTEM\n\nMany years ago, Bob worked for a software company that had outsourced the first version of its application, an online collaboration platform for sharing and working on files.\n\nWhen the company brought development in-house, it passed through several generations of developers’ hands, and each wave of new developers added more complexity to the code’s structure.\n\nAt its heart, the system was an ASP.NET Web Forms application, built with an NHibernate ORM. Users would upload documents into workspaces, where they could invite other workspace members to review, comment on, or modify their work.\n\nMost of the complexity of the application was in the permissions model because each document was contained in a folder, and folders allowed read, write, and edit permissions, much like a Linux filesystem.\n\nAdditionally, each workspace belonged to an account, and the account had quotas attached to it via a billing package.\n\nAs a result, every read or write operation against a document had to load an enormous number of objects from the database in order to test permissions and quotas. Creating a new workspace involved hundreds of database queries as we set up the permissions structure, invited users, and set up sample content.\n\nSome of the code for operations was in web handlers that ran when a user clicked a button or submitted a form; some of it was in manager objects that held code for orchestrating work; and some of it was in the domain model. Model objects would make database calls or copy files on disk, and the test coverage was abysmal.\n\nTo fix the problem, we first introduced a service layer so that all of the code for creating a document or workspace was in one place and could be understood. This involved pulling data access code out of the domain model and into command handlers. Likewise, we pulled orchestration code out of the managers and the web handlers and pushed it into handlers.\n\nThe resulting command handlers were long and messy, but we’d made a start at introducing order to the chaos.\n\nTIP\n\nIt’s fine if you have duplication in the use-case functions. We’re not trying to write perfect code; we’re just trying to extract some meaningful layers. It’s better to duplicate some code in a few places than to have use-case functions calling one another in a long chain.\n\nThis is a good opportunity to pull any data-access or orchestration\n\ncode out of the domain model and into the use cases. We should also try to pull I/O concerns (e.g., sending email, writing files) out of the domain model and up into the use-case functions. We apply the techniques from Chapter 3 on abstractions to keep our handlers unit testable even when they’re performing I/O.\n\nThese use-case functions will mostly be about logging, data access, and error handling. Once you’ve done this step, you’ll have a grasp of what your program actually does, and a way to make sure each\n\noperation has a clearly defined start and finish. We’ll have taken a step toward building a pure domain model.\n\nRead Working Effectively with Legacy Code by Michael C. Feathers\n\n(Prentice Hall) for guidance on getting legacy code under test and\n\nstarting separating responsibilities.\n\nIdentifying Aggregates and Bounded Contexts\n\nPart of the problem with the codebase in our case study was that the object graph was highly connected. Each account had many\n\nworkspaces, and each workspace had many members, all of whom had\n\ntheir own accounts. Each workspace contained many documents, which had many versions.\n\nYou can’t express the full horror of the thing in a class diagram. For\n\none thing, there wasn’t really a single account related to a user. Instead, there was a bizarre rule requiring you to enumerate all of the\n\naccounts associated to the user via the workspaces and take the one\n\nwith the earliest creation date.\n\nEvery object in the system was part of an inheritance hierarchy that included SecureObject and Version. This inheritance hierarchy was mirrored directly in the database schema, so that every query had to join across 10 different tables and look at a discriminator column just\n\nto tell what kind of objects you were working with.\n\nThe codebase made it easy to “dot” your way through these objects like so:\n\nuser.account.workspaces[0].documents.versions[1].owner.account.settings[0];\n\nBuilding a system this way with Django ORM or SQLAlchemy is easy but is to be avoided. Although it’s convenient, it makes it very hard to\n\nreason about performance because each property might trigger a lookup to the database.\n\nTIP\n\nAggregates are a consistency boundary. In general, each use case should update a single aggregate at a time. One handler fetches one aggregate from a repository, modifies its state, and raises any events that happen as a result. If you need data from another part of the system, it’s totally fine to use a read model, but avoid updating multiple aggregates in a single transaction. When we choose to separate code into different aggregates, we’re explicitly choosing to make them eventually consistent with one another.\n\nA bunch of operations required us to loop over objects this way—for example:\n\n# Lock a user's workspaces for nonpayment\n\ndef lock_account(user): for workspace in user.account.workspaces: workspace.archive()\n\nOr even recurse over collections of folders and documents:\n\ndef lock_documents_in_folder(folder):\n\nfor doc in folder.documents: doc.archive()\n\nfor child in folder.children: lock_documents_in_folder(child)\n\nThese operations killed performance, but fixing them meant giving up our single object graph. Instead, we began to identify aggregates and to\n\nbreak the direct links between objects.\n\nNOTE\n\nWe talked about the infamous SELECT N+1 problem in Chapter 12, and how we might choose to use different techniques when reading data for queries versus reading data for commands.\n\nMostly we did this by replacing direct references with identifiers.\n\nBefore aggregates:\n\nAfter modeling with aggregates:\n\nTIP\n\nBidirectional links are often a sign that your aggregates aren’t right. In our original code, a Document knew about its containing Folder, and the Folder had a collection of Documents. This makes it easy to traverse the object graph but stops us from thinking properly about the consistency boundaries we need. We break apart aggregates by using references instead. In the new model, a Document had reference to its parent_folder but had no way to directly access the Folder.\n\nIf we needed to read data, we avoided writing complex loops and\n\ntransforms and tried to replace them with straight SQL. For example,\n\none of our screens was a tree view of folders and documents.\n\nThis screen was incredibly heavy on the database, because it relied on nested for loops that triggered a lazy-loaded ORM.\n\nTIP\n\nWe use this same technique in Chapter 11, where we replace a nested loop over ORM objects with a simple SQL query. It’s the first step in a CQRS approach.\n\nAfter a lot of head-scratching, we replaced the ORM code with a big, ugly stored procedure. The code looked horrible, but it was much faster and helped to break the links between Folder and Document.\n\nWhen we needed to write data, we changed a single aggregate at a time, and we introduced a message bus to handle events. For example,\n\nin the new model, when we locked an account, we could first query for all the affected workspaces via SELECT id FROM workspace WHERE account_id = ?.\n\nWe could then raise a new command for each workspace:\n\nfor workspace_id in workspaces: bus.handle(LockWorkspace(workspace_id))\n\nAn Event-Driven Approach to Go to Microservices via Strangler Pattern\n\nThe Strangler Fig pattern involves creating a new system around the\n\nedges of an old system, while keeping it running. Bits of old functionality are gradually intercepted and replaced, until the old\n\nsystem is left doing nothing at all and can be switched off.\n\nWhen building the availability service, we used a technique called\n\nevent interception to move functionality from one place to another. This is a three-step process:\n\n1. Raise events to represent the changes happening in a system you want to replace.\n\n2. Build a second system that consumes those events and uses them to build its own domain model.\n\n3. Replace the older system with the new.\n\nWe used event interception to move from Figure E-2…\n\nFigure E-2. Before: strong, bidirectional coupling based on XML-RPC\n\nto Figure E-3.\n\nFigure E-3. After: loose coupling with asynchronous events (you can find a high- resolution version of this diagram at cosmicpython.com)\n\nPractically, this was a several month-long project. Our first step was to write a domain model that could represent batches, shipments, and products. We used TDD to build a toy system that could answer a\n\nsingle question: “If I want N units of HAZARDOUS_RUG, how long will they take to be delivered?”\n\nTIP\n\nWhen deploying an event-driven system, start with a “walking skeleton.” Deploying a system that just logs its input forces us to tackle all the infrastructural questions and start working in production.\n\nCASE STUDY: CARVING OUT A MICROSERVICE TO REPLACE A DOMAIN\n\nMADE.com started out with two monoliths: one for the frontend ecommerce application, and one for the backend fulfillment system.\n\nThe two systems communicated through XML-RPC. Periodically, the backend system would wake up and query the frontend system to find out about new orders. When it had imported all the new orders, it would send RPC commands to update the stock levels.\n\nOver time this synchronization process became slower and slower until, one Christmas, it took longer than 24 hours to import a single day’s orders. Bob was hired to break the system into a set of event-driven services.\n\nFirst, we identified that the slowest part of the process was calculating and synchronizing the available stock. What we needed was a system that could listen to external events and keep a running total of how much stock was available.\n\nWe exposed that information via an API, so that the user’s browser could ask how much stock was available for each product and how long it would take to deliver to their address.\n\nWhenever a product ran out of stock completely, we would raise a new event that the ecommerce platform could use to take a product off sale. Because we didn’t know how much load we would need to handle, we wrote the system with a CQRS pattern. Whenever the amount of stock changed, we would update a Redis database with a cached view model. Our Flask API queried these view models instead of running the complex domain model.\n\nAs a result, we could answer the question “How much stock is available?” in 2 to 3 milliseconds, and now the API frequently handles hundreds of requests a second for sustained periods.\n\nIf this all sounds a little familiar, well, now you know where our example app came from!\n\nOnce we had a working domain model, we switched to building out some infrastructural pieces. Our first production deployment was a tiny system that could receive a batch_created event and log its JSON representation. This is the “Hello World” of event-driven\n\narchitecture. It forced us to deploy a message bus, hook up a producer and consumer, build a deployment pipeline, and write a simple message handler.\n\nGiven a deployment pipeline, the infrastructure we needed, and a basic domain model, we were off. A couple months later, we were in production and serving real customers.\n\nConvincing Your Stakeholders to Try Something New\n\nIf you’re thinking about carving a new system out of a big ball of mud, you’re probably suffering problems with reliability, performance,\n\nmaintainability, or all three simultaneously. Deep, intractable problems call for drastic measures!\n\nWe recommend domain modeling as a first step. In many overgrown\n\nsystems, the engineers, product owners, and customers no longer speak the same language. Business stakeholders speak about the system in abstract, process-focused terms, while developers are forced to speak about the system as it physically exists in its wild and chaotic state.\n\nCASE STUDY: THE USER MODEL\n\nWe mentioned earlier that the account and user model in our first system were bound together by a “bizarre rule.” This is a perfect example of how engineering and business stakeholders can drift apart.\n\nIn this system, accounts parented workspaces, and users were members of workspaces. Workspaces were the fundamental unit for applying permissions and quotas. If a user joined a workspace and didn’t already have an account, we would associate them with the account that owned that workspace.\n\nThis was messy and ad hoc, but it worked fine until the day a product owner asked for a new feature:\n\nWhen a user joins a company, we want to add them to some default workspaces for the company, like the HR workspace or the Company Announcements workspace.\n\nWe had to explain to them that there was no such thing as a company, and there was no sense in which a user joined an account. Moreover, a “company” might have many accounts owned by different users, and a new user might be invited to any one of them.\n\nYears of adding hacks and work-arounds to a broken model caught up with us, and we had to rewrite the entire user management function as a brand-new system.\n\nFiguring out how to model your domain is a complex task that’s the subject of many decent books in its own right. We like to use interactive techniques like event storming and CRC modeling, because humans are good at collaborating through play. Event modeling is\n\nanother technique that brings engineers and product owners together to understand a system in terms of commands, queries, and events.\n\nTIP\n\nCheck out www.eventmodeling.org and www.eventstorming.org for some great guides to visual modeling of systems with events.\n\nThe goal is to be able to talk about the system by using the same\n\nubiquitous language, so that you can agree on where the complexity\n\nlies.\n\nWe’ve found a lot of value in treating domain problems as TDD kata. For example, the first code we wrote for the availability service was the batch and order line model. You can treat this as a lunchtime\n\nworkshop, or as a spike at the beginning of a project. Once you can demonstrate the value of modeling, it’s easier to make the argument for structuring the project to optimize for modeling.\n\nCASE STUDY: DAVID SEDDON ON TAKING SMALL STEPS\n\nHi, I’m David, one of the tech reviewers on this book. I’ve worked on several complex Django monoliths, and so I’ve known the pain that Bob and Harry have made all sorts of grand promises about soothing.\n\nWhen I was first exposed to the patterns described here, I was rather excited. I had successfully used some of the techniques already on smaller projects, but here was a blueprint for much larger, database-backed systems like the one I work on in my day job. So I started trying to figure out how I could implement that blueprint at my current organization.\n\nI chose to tackle a problem area of the codebase that had always bothered me. I began by implementing it as a use case. But I found myself running into unexpected questions. There were things that I hadn’t considered while reading that now made it difficult to see what to do. Was it a problem if my use case interacted with two different aggregates? Could one use case call another? And how was it going to exist within a system that followed different architectural principles without resulting in a horrible mess?\n\nWhat happened to that oh-so-promising blueprint? Did I actually understand the ideas well enough to put them into practice? Was it even suitable for my application? Even if it was, would any of my colleagues agree to such a major change? Were these just nice ideas for me to fantasize about while I got on with real life?\n\nIt took me a while to realize that I could start small. I didn’t need to be a purist or to get it right the first time: I could experiment, finding what worked for me.\n\nAnd so that’s what I’ve done. I’ve been able to apply some of the ideas in a few places. I’ve built new features whose business logic can be tested without the database or mocks. And as a team, we’ve introduced a service layer to help define the jobs the system does.\n\nIf you start trying to apply these patterns in your work, you may go through similar feelings to begin with. When the nice theory of a book meets the reality of your codebase, it can be demoralizing.\n\nMy advice is to focus on a specific problem and ask yourself how you can put the relevant ideas to use, perhaps in an initially limited and imperfect fashion. You may discover, as I did, that the first problem you pick might be a bit too difficult; if so, move on to something else. Don’t try to boil the ocean, and don’t be too afraid of making mistakes. It will be a learning experience, and you can be confident that you’re moving roughly in a direction that others have found useful.\n\nSo, if you’re feeling the pain too, give these ideas a try. Don’t feel you need permission to rearchitect everything. Just look for somewhere small to start. And above all, do it to solve a specific problem. If you’re successful in solving it, you’ll know you got something right—and others will too.\n\nQuestions Our Tech Reviewers Asked That We Couldn’t Work into Prose\n\nHere are some questions we heard during drafting that we couldn’t find a good place to address elsewhere in the book:\n\nDo I need to do all of this at once? Can I just do a bit at a time?\n\nNo, you can absolutely adopt these techniques bit by bit. If you have an existing system, we recommend building a service layer to try to keep orchestration in one place. Once you have that, it’s much easier to push logic into the model and push edge concerns like validation or error handling to the entrypoints.\n\nIt’s worth having a service layer even if you still have a big, messy Django ORM because it’s a way to start understanding the boundaries of operations.\n\nExtracting use cases will break a lot of my existing code; it’s too tangled\n\nJust copy and paste. It’s OK to cause more duplication in the short term. Think of this as a multistep process. Your code is in a bad state now, so copy and paste it to a new place and then make that new code clean and tidy.\n\nOnce you’ve done that, you can replace uses of the old code with calls to your new code and finally delete the mess. Fixing large codebases is a messy and painful process. Don’t expect things to get instantly better, and don’t worry if some bits of your application stay messy.\n\nDo I need to do CQRS? That sounds weird. Can’t I just use repositories?\n\nOf course you can! The techniques we’re presenting in this book are intended to make your life easier. They’re not some kind of\n\nascetic discipline with which to punish yourself.\n\nIn our first case-study system, we had a lot of View Builder objects that used repositories to fetch data and then performed some transformations to return dumb read models. The advantage is that when you hit a performance problem, it’s easy to rewrite a view builder to use custom queries or raw SQL.\n\nHow should use cases interact across a larger system? Is it a problem for one to call another?\n\nThis might be an interim step. Again, in the first case study, we had handlers that would need to invoke other handlers. This gets really messy, though, and it’s much better to move to using a message bus to separate these concerns.\n\nGenerally, your system will have a single message bus implementation and a bunch of subdomains that center on a particular aggregate or set of aggregates. When your use case has finished, it can raise an event, and a handler elsewhere can run.\n\nIs it a code smell for a use case to use multiple repositories/aggregates, and if so, why?\n\nAn aggregate is a consistency boundary, so if your use case needs to update two aggregates atomically (within the same transaction), then your consistency boundary is wrong, strictly speaking. Ideally you should think about moving to a new aggregate that wraps up all the things you want to change at the same time.\n\nIf you’re actually updating only one aggregate and using the other(s) for read-only access, then that’s fine, although you could consider building a read/view model to get you that data instead— it makes things cleaner if each use case has only one aggregate.\n\nIf you do need to modify two aggregates, but the two operations don’t have to be in the same transaction/UoW, then consider splitting the work out into two different handlers and using a\n\ndomain event to carry information between the two. You can read more in these papers on aggregate design by Vaughn Vernon.\n\nWhat if I have a read-only but business-logic-heavy system?\n\nView models can have complex logic in them. In this book, we’ve encouraged you to separate your read and write models because they have different consistency and throughput requirements. Mostly, we can use simpler logic for reads, but that’s not always true. In particular, permissions and authorization models can add a lot of complexity to our read side.\n\nWe’ve written systems in which the view models needed extensive unit tests. In those systems, we split a view builder from a view fetcher, as in Figure E-4.\n\nFigure E-4. A view builder and view fetcher (you can find a high-resolution version of this diagram at cosmicpython.com)\n\n+ This makes it easy to test the view builder by giving it mocked data (e.g., a list of dicts). “Fancy CQRS” with event handlers is really a way of running our complex view logic whenever we write so that we\n\ncan avoid running it when we read.\n\nDo I need to build microservices to do this stuff?\n\nEgads, no! These techniques predate microservices by a decade or so. Aggregates, domain events, and dependency inversion are ways to control complexity in large systems. It just so happens that when you’ve built a set of use cases and a model for a business process,\n\nmoving it to its own service is relatively easy, but that’s not a requirement.\n\nI’m using Django. Can I still do this?\n\nWe have an entire appendix just for you: Appendix D!\n\nFootguns\n\nOK, so we’ve given you a whole bunch of new toys to play with. Here’s the fine print. Harry and Bob do not recommend that you copy and paste our code into a production system and rebuild your automated trading platform on Redis pub/sub. For reasons of brevity\n\nand simplicity, we’ve hand-waved a lot of tricky subjects. Here’s a list of things we think you should know before trying this for real.\n\nReliable messaging is hard\n\nRedis pub/sub is not reliable and shouldn’t be used as a general- purpose messaging tool. We picked it because it’s familiar and easy to run. At MADE, we run Event Store as our messaging tool, but we’ve had experience with RabbitMQ and Amazon EventBridge.\n\nTyler Treat has some excellent blog posts on his site bravenewgeek.com; you should read at least read “You Cannot Have Exactly-Once Delivery” and “What You Want Is What You Don’t: Understanding Trade-Offs in Distributed Messaging”.\n\nWe explicitly choose small, focused transactions that can fail independently\n\nIn Chapter 8, we update our process so that deallocating an order line and reallocating the line happen in two separate units of work. You will need monitoring to know when these transactions\n\nfail, and tooling to replay events. Some of this is made easier by using a transaction log as your message broker (e.g., Kafka or EventStore). You might also look at the Outbox pattern.\n\nWe don’t discuss idempotency\n\nWe haven’t given any real thought to what happens when handlers are retried. In practice you will want to make handlers idempotent so that calling them repeatedly with the same message will not make repeated changes to state. This is a key technique for building reliability, because it enables us to safely retry events when they fail.\n\nThere’s a lot of good material on idempotent message handling, try\n\nstarting with “How to Ensure Idempotency in an Eventual Consistent DDD/CQRS Application” and “(Un)Reliability in Messaging”.\n\nYour events will need to change their schema over time\n\nYou’ll need to find some way of documenting your events and sharing schema with consumers. We like using JSON schema and markdown because it’s simple but there is other prior art. Greg Young wrote an entire book on managing event-driven systems over time: Versioning in an Event Sourced System (Leanpub).\n\nMore Required Reading\n\nA few more books we’d like to recommend to help you on your way:\n\nClean Architectures in Python by Leonardo Giordani (Leanpub), which came out in 2019, is one of the few previous books on application architecture in Python.\n\nEnterprise Integration Patterns by Gregor Hohpe and Bobby Woolf (Addison-Wesley Professional) is a pretty good start\n\nfor messaging patterns.\n\nMonolith to Microservices by Sam Newman (O’Reilly), and Newman’s first book, Building Microservices (O’Reilly). The Strangler Fig pattern is mentioned as a favorite, along with many others. These are good to check out if you’re thinking of moving to microservices, and they’re also good on integration patterns and the considerations of async messaging-based integration.\n\nWrap-Up\n\nPhew! That’s a lot of warnings and reading suggestions; we hope we haven’t scared you off completely. Our goal with this book is to give you just enough knowledge and intuition for you to start building some of this for yourself. We would love to hear how you get on and what\n\nproblems you’re facing with the techniques in your own systems, so why not get in touch with us over at www.cosmicpython.com?\n\nAppendix A. Summary Diagram and Table\n\nHere’s what our architecture looks like by the end of the book:\n\nTable A-1 recaps each pattern and what it does.\n\nTable A-1. The components of our architecture and what they all do\n\nLayer\n\nCompo nent\n\nDescription\n\nDomain\n\nEntity\n\nA domain object whose attributes may change but that has a recognizable identity over time.\n\nDefines the business logic.\n\nValue object\n\nAn immutable domain object whose attributes entirely define it. It is fungible with other identical objects.\n\nAggregat e\n\nCluster of associated objects that we treat as a unit for the purpose of data changes. Defines and enforces a consistency boundary.\n\nEvent\n\nRepresents something that happened.\n\nComman d\n\nRepresents a job the system should perform.\n\nService Layer\n\nHandler\n\nReceives a command or an event and performs what needs to happen.\n\nDefines the jobs the system should perform and orchestrates different components.\n\nUnit of work\n\nMessage bus (internal)\n\nAbstraction around data integrity. Each unit of work represents an atomic update. Makes repositories available. Tracks new events on retrieved aggregates.\n\nHandles commands and events by routing them to the appropriate handler.\n\nAdapters (Secondary)\n\nRepositor y\n\nAbstraction around persistent storage. Each aggregate has its own repository.\n\nConcrete implementations of an interface that goes\n\nLayer\n\nfrom our system to the outside world (I/O).\n\nEntrypoints (Primary adapters)\n\nTranslate external inputs into calls into the service layer.\n\nN/A\n\nCompo nent\n\nEvent publisher\n\nWeb\n\nEvent consumer\n\nExternal message bus (message broker)\n\nDescription\n\nPushes events onto the external message bus.\n\nReceives web requests and translates them into commands, passing them to the internal message bus.\n\nReads events from the external message bus and translates them into commands, passing them to the internal message bus.\n\nA piece of infrastructure that different services use to intercommunicate, via events.\n\nAppendix B. A Template Project Structure\n\nAround Chapter 4, we moved from just having everything in one folder to a more structured tree, and we thought it might be of interest to outline the moving parts.\n\nTIP\n\nThe code for this appendix is in the appendix_project_structure branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout appendix_project_structure\n\nThe basic folder structure looks like this:\n\nProject tree\n\n. ├── Dockerfile ├── Makefile ├── README.md ├── docker-compose.yml ├── license.txt ├── mypy.ini ├── requirements.txt ├── src │ ├── allocation │ │ ├── __init__.py │ │ ├── adapters │ │ │ ├── __init__.py\n\n│ │ │ ├── orm.py │ │ │ └── repository.py │ │ ├── config.py │ │ ├── domain │ │ │ ├── __init__.py │ │ │ └── model.py │ │ ├── entrypoints │ │ │ ├── __init__.py │ │ │ └── flask_app.py │ │ └── service_layer │ │ ├── __init__.py │ │ └── services.py │ └── setup.py └── tests ├── conftest.py ├── e2e │ └── test_api.py ├── integration │ ├── test_orm.py │ └── test_repository.py ├── pytest.ini └── unit ├── test_allocate.py ├── test_batches.py └── test_services.py\n\nOur docker-compose.yml and our Dockerfile are the main bits of configuration for the containers that run our app, and they can also run the tests (for CI). A more complex project might have several Dockerfiles, although we’ve found that minimizing the number of images is usually a good idea.\n\n1\n\nA Makefile provides the entrypoint for all the typical commands a developer (or a CI server) might want to run during their normal workflow: make build, make test, and so on. This is optional. You could just use docker-compose and pytest directly, but if nothing else, it’s nice to have all the “common commands” in a list somewhere, and unlike documentation, a Makefile is code so it has less tendency to become out of date.\n\n2\n\nAll the source code for our app, including the domain model, the Flask app, and infrastructure code, lives in a Python package\n\n3\n\ninside src, which we install using pip install -e and the setup.py file. This makes imports easy. Currently, the structure within this module is totally flat, but for a more complex project, you’d expect to grow a folder hierarchy that includes domain_model/, infrastructure/, services/, and api/.\n\nTests live in their own folder. Subfolders distinguish different test types and allow you to run them separately. We can keep shared fixtures (conftest.py) in the main tests folder and nest more specific ones if we wish. This is also the place to keep pytest.ini.\n\nTIP\n\nThe pytest docs are really good on test layout and importability.\n\nLet’s look at a few of these files and concepts in more detail.\n\nEnv Vars, 12-Factor, and Config, Inside and Outside Containers\n\nThe basic problem we’re trying to solve here is that we need different config settings for the following:\n\nRunning code or tests directly from your own dev machine, perhaps talking to mapped ports from Docker containers\n\nRunning on the containers themselves, with “real” ports and hostnames\n\nDifferent container environments (dev, staging, prod, and so on)\n\nConfiguration through environment variables as suggested by the 12- factor manifesto will solve this problem, but concretely, how do we implement it in our code and our containers?\n\nConfig.py\n\nWhenever our application code needs access to some config, it’s going to get it from a file called config.py. Here are a couple of examples from our app:\n\nSample config functions (src/allocation/config.py)\n\nimport os\n\ndef get_postgres_uri(): host = os.environ.get('DB_HOST', 'localhost') port = 54321 if host == 'localhost' else 5432 password = os.environ.get('DB_PASSWORD', 'abc123') user, db_name = 'allocation', 'allocation' return f\"postgresql://{user}:{password}@{host}:{port}/{db_name}\"\n\ndef get_api_url(): host = os.environ.get('API_HOST', 'localhost') port = 5005 if host == 'localhost' else 80 return f\"http://{host}:{port}\"\n\nWe use functions for getting the current config, rather than constants available at import time, because that allows client code to modify os.environ if it needs to.\n\nconfig.py also defines some default settings, designed to work when running the code from the developer’s local machine.4\n\nAn elegant Python package called environ-config is worth looking at if you get tired of hand-rolling your own environment-based config functions.\n\nTIP\n\nDon’t let this config module become a dumping ground that is full of things only vaguely related to config and that is then imported all over the place. Keep things immutable and modify them only via environment variables. If you decide to use a bootstrap script, you can make it the only place (other than tests) that config is imported to.\n\nDocker-Compose and Containers Config\n\nWe use a lightweight Docker container orchestration tool called docker-compose. It’s main configuration is via a YAML file (sigh):\n\ndocker-compose config file (docker-compose.yml)\n\nversion: \"3\" services:\n\napp: build: context: . dockerfile: Dockerfile depends_on: - postgres environment: - DB_HOST=postgres - DB_PASSWORD=abc123 - API_HOST=app - PYTHONDONTWRITEBYTECODE=1 volumes:\n\n5\n\n./src:/src - ./tests:/tests ports: - \"5005:80\"\n\npostgres: image: postgres:9.6 environment: - POSTGRES_USER=allocation - POSTGRES_PASSWORD=abc123 ports: - \"54321:5432\"\n\nIn the docker-compose file, we define the different services (containers) that we need for our app. Usually one main image contains all our code, and we can use it to run our API, our tests, or any other service that needs access to the domain model.\n\nYou’ll probably have other infrastructure services, including a database. In production you might not use containers for this; you might have a cloud provider instead, but docker-compose gives us a way of producing a similar service for dev or CI.\n\nThe environment stanza lets you set the environment variables for your containers, the hostnames and ports as seen from inside the Docker cluster. If you have enough containers that information starts to be duplicated in these sections, you can use environment_file instead. We usually call ours container.env.\n\nInside a cluster, docker-compose sets up networking such that containers are available to each other via hostnames named after their service name.\n\nPro tip: if you’re mounting volumes to share source folders between your local dev machine and the container, the PYTHONDONTWRITEBYTECODE environment variable tells Python to not write .pyc files, and that will save you from having millions of\n\nroot-owned files sprinkled all over your local filesystem, being all annoying to delete and causing weird Python compiler errors besides.\n\nMounting our source and test code as volumes means we don’t need to rebuild our containers every time we make a code change.\n\nThe ports section allows us to expose the ports from inside the 6 containers to the outside world —these correspond to the default ports we set in config.py.\n\nNOTE\n\nInside Docker, other containers are available through hostnames named after their service name. Outside Docker, they are available on localhost, at the port defined in the ports section.\n\nInstalling Your Source as a Package\n\nAll our application code (everything except tests, really) lives inside\n\nan src folder:\n\nThe src folder\n\n├── src │ ├── allocation │ │ ├── config.py │ │ └── ... │ └── setup.py\n\nSubfolders define top-level module names. You can have multiple if you like.\n\nAnd setup.py is the file you need to make it pip-installable, shown next.\n\npip-installable modules in three lines (src/setup.py)\n\nfrom setuptools import setup\n\nsetup( name='allocation', version='0.1', packages=['allocation'], )\n\nThat’s all you need. packages= specifies the names of subfolders that you want to install as top-level modules. The name entry is just cosmetic, but it’s required. For a package that’s never actually going to hit PyPI, it’ll do fine.\n\n7\n\nDockerfile\n\nDockerfiles are going to be very project-specific, but here are a few key stages you’ll expect to see:\n\nOur Dockerfile (Dockerfile)\n\nFROM python:3.8-alpine\n\nRUN apk add --no-cache --virtual .build-deps gcc postgresql-dev musl-dev python3-dev RUN apk add libpq\n\nCOPY requirements.txt /tmp/ RUN pip install -r /tmp/requirements.txt\n\nRUN apk del --no-cache .build-deps\n\nRUN mkdir -p /src COPY src/ /src/ RUN pip install -e /src COPY tests/ /tests/\n\nWORKDIR /src ENV FLASK_APP=allocation/entrypoints/flask_app.py FLASK_DEBUG=1 PYTHONUNBUFFERED=1 CMD flask run --host=0.0.0.0 --port=80\n\nInstalling system-level dependencies\n\nInstalling our Python dependencies (you may want to split out your dev from prod dependencies; we haven’t here, for simplicity)\n\nCopying and installing our source\n\nOptionally configuring a default startup command (you’ll probably override this a lot from the command line)\n\nTIP\n\nOne thing to note is that we install things in the order of how frequently they are likely to change. This allows us to maximize Docker build cache reuse. I can’t tell you how much pain and frustration underlies this lesson. For this and many more Python Dockerfile improvement tips, check out “Production-Ready Docker Packaging”.\n\nTests\n\nOur tests are kept alongside everything else, as shown here:\n\nTests folder tree\n\n└── tests ├── conftest.py ├── e2e │ └── test_api.py ├── integration │ ├── test_orm.py │ └── test_repository.py ├── pytest.ini └── unit ├── test_allocate.py ├── test_batches.py └── test_services.py\n\nNothing particularly clever here, just some separation of different test types that you’re likely to want to run separately, and some files for\n\ncommon fixtures, config, and so on.\n\nThere’s no src folder or setup.py in the test folders because we usually haven’t needed to make tests pip-installable, but if you have\n\ndifficulties with import paths, you might find it helps.\n\nWrap-Up\n\nThese are our basic building blocks:\n\nSource code in an src folder, pip-installable using setup.py\n\nSome Docker config for spinning up a local cluster that mirrors production as far as possible\n\nConfiguration via environment variables, centralized in a Python file called config.py, with defaults allowing things to run outside containers\n\nA Makefile for useful command-line, um, commands\n\nWe doubt that anyone will end up with exactly the same solutions we\n\ndid, but we hope you find some inspiration here.\n\n1 Splitting out images for production and testing is sometimes a good idea, but we’ve\n\ntended to find that going further and trying to split out different images for different types of application code (e.g., Web API versus pub/sub client) usually ends up being more trouble than it’s worth; the cost in terms of complexity and longer rebuild/CI times is too high. YMMV.\n\n2 A pure-Python alternative to Makefiles is Invoke, worth checking out if everyone on your\n\nteam knows Python (or at least knows it better than Bash!).\n\n3 “Testing and Packaging” by Hynek Schlawack provides more information on src folders.\n\n4 This gives us a local development setup that “just works” (as much as possible). You\n\nmay prefer to fail hard on missing environment variables instead, particularly if any of the defaults would be insecure in production.\n\n5 Harry is a bit YAML-weary. It’s everywhere, and yet he can never remember the\n\nsyntax or how it’s supposed to indent.\n\n6 On a CI server, you may not be able to expose arbitrary ports reliably, but it’s only a\n\nconvenience for local dev. You can find ways of making these port mappings optional (e.g., with docker-compose.override.yml).\n\n7 For more setup.py tips, see this article on packaging by Hynek.\n\nAppendix C. Swapping Out the Infrastructure: Do Everything with CSVs\n\nThis appendix is intended as a little illustration of the benefits of the Repository, Unit of Work, and Service Layer patterns. It’s intended to follow from Chapter 6.\n\nJust as we finish building out our Flask API and getting it ready for release, the business comes to us apologetically, saying they’re not\n\nready to use our API and asking if we could build a thing that reads just batches and orders from a couple of CSVs and outputs a third CSV\n\nwith allocations.\n\nOrdinarily this is the kind of thing that might have a team cursing and\n\nspitting and making notes for their memoirs. But not us! Oh no, we’ve ensured that our infrastructure concerns are nicely decoupled from our\n\ndomain model and service layer. Switching to CSVs will be a simple matter of writing a couple of new Repository and UnitOfWork classes, and then we’ll be able to reuse all of our logic from the\n\ndomain layer and the service layer.\n\nHere’s an E2E test to show you how the CSVs flow in and out:\n\nA first CSV test (tests/e2e/test_csv.py)\n\ndef test_cli_app_reads_csvs_with_batches_and_orders_and_outputs_allocations( make_csv ): sku1, sku2 = random_ref('s1'), random_ref('s2') batch1, batch2, batch3 = random_ref('b1'), random_ref('b2'), random_ref('b3') order_ref = random_ref('o') make_csv('batches.csv', [ ['ref', 'sku', 'qty', 'eta'], [batch1, sku1, 100, ''], [batch2, sku2, 100, '2011-01-01'], [batch3, sku2, 100, '2011-01-02'], ]) orders_csv = make_csv('orders.csv', [ ['orderid', 'sku', 'qty'], [order_ref, sku1, 3], [order_ref, sku2, 12], ])\n\nrun_cli_script(orders_csv.parent)\n\nexpected_output_csv = orders_csv.parent / 'allocations.csv' with open(expected_output_csv) as f: rows = list(csv.reader(f)) assert rows == [ ['orderid', 'sku', 'qty', 'batchref'], [order_ref, sku1, '3', batch1], [order_ref, sku2, '12', batch2], ]\n\nDiving in and implementing without thinking about repositories and all that jazz, you might start with something like this:\n\nA first cut of our CSV reader/writer (src/bin/allocate-from-csv)\n\n#!/usr/bin/env python import csv import sys from datetime import datetime\n\nfrom pathlib import Path\n\nfrom allocation import model\n\ndef load_batches(batches_path): batches = [] with batches_path.open() as inf: reader = csv.DictReader(inf) for row in reader: if row['eta']: eta = datetime.strptime(row['eta'], '%Y-%m-%d').date() else: eta = None batches.append(model.Batch( ref=row['ref'], sku=row['sku'], qty=int(row['qty']), eta=eta )) return batches\n\ndef main(folder): batches_path = Path(folder) / 'batches.csv' orders_path = Path(folder) / 'orders.csv' allocations_path = Path(folder) / 'allocations.csv'\n\nbatches = load_batches(batches_path)\n\nwith orders_path.open() as inf, allocations_path.open('w') as outf: reader = csv.DictReader(inf) writer = csv.writer(outf) writer.writerow(['orderid', 'sku', 'batchref']) for row in reader: orderid, sku = row['orderid'], row['sku'] qty = int(row['qty']) line = model.OrderLine(orderid, sku, qty) batchref = model.allocate(line, batches) writer.writerow([line.orderid, line.sku, batchref])\n\nif __name__ == '__main__': main(sys.argv[1])\n\nIt’s not looking too bad! And we’re reusing our domain model objects and our domain service.\n\nBut it’s not going to work. Existing allocations need to also be part of our permanent CSV storage. We can write a second test to force us to improve things:\n\nAnd another one, with existing allocations (tests/e2e/test_csv.py)\n\ndef test_cli_app_also_reads_existing_allocations_and_can_append_to_them( make_csv ): sku = random_ref('s') batch1, batch2 = random_ref('b1'), random_ref('b2') old_order, new_order = random_ref('o1'), random_ref('o2') make_csv('batches.csv', [ ['ref', 'sku', 'qty', 'eta'], [batch1, sku, 10, '2011-01-01'], [batch2, sku, 10, '2011-01-02'], ]) make_csv('allocations.csv', [ ['orderid', 'sku', 'qty', 'batchref'], [old_order, sku, 10, batch1], ]) orders_csv = make_csv('orders.csv', [ ['orderid', 'sku', 'qty'], [new_order, sku, 7], ])\n\nrun_cli_script(orders_csv.parent)\n\nexpected_output_csv = orders_csv.parent / 'allocations.csv' with open(expected_output_csv) as f:\n\nrows = list(csv.reader(f)) assert rows == [ ['orderid', 'sku', 'qty', 'batchref'], [old_order, sku, '10', batch1], [new_order, sku, '7', batch2], ]\n\nAnd we could keep hacking about and adding extra lines to that load_batches function, and some sort of way of tracking and saving new allocations—but we already have a model for doing that! It’s called our Repository and Unit of Work patterns.\n\nAll we need to do (“all we need to do”) is reimplement those same abstractions, but with CSVs underlying them instead of a database. And as you’ll see, it really is relatively straightforward.\n\nImplementing a Repository and Unit of Work for CSVs\n\nHere’s what a CSV-based repository could look like. It abstracts away all the logic for reading CSVs from disk, including the fact that it has to read two different CSVs (one for batches and one for allocations), and it gives us just the familiar .list() API, which provides the illusion of an in-memory collection of domain objects:\n\nA repository that uses CSV as its storage mechanism (src/allocation/service_layer/csv_uow.py)\n\nclass CsvRepository(repository.AbstractRepository):\n\ndef __init__(self, folder): self._batches_path = Path(folder) / 'batches.csv'\n\nself._allocations_path = Path(folder) / 'allocations.csv' self._batches = {} # type: Dict[str, model.Batch] self._load()\n\ndef get(self, reference): return self._batches.get(reference)\n\ndef add(self, batch): self._batches[batch.reference] = batch\n\ndef _load(self): with self._batches_path.open() as f: reader = csv.DictReader(f) for row in reader: ref, sku = row['ref'], row['sku'] qty = int(row['qty']) if row['eta']: eta = datetime.strptime(row['eta'], '%Y-%m-%d').date() else: eta = None self._batches[ref] = model.Batch( ref=ref, sku=sku, qty=qty, eta=eta ) if self._allocations_path.exists() is False: return with self._allocations_path.open() as f: reader = csv.DictReader(f) for row in reader: batchref, orderid, sku = row['batchref'], row['orderid'], row['sku'] qty = int(row['qty']) line = model.OrderLine(orderid, sku, qty) batch = self._batches[batchref] batch._allocations.add(line)\n\ndef list(self): return list(self._batches.values())\n\nAnd here’s what a UoW for CSVs would look like:\n\nA UoW for CSVs: commit = csv.writer\n\n(src/allocation/service_layer/csv_uow.py)\n\nclass CsvUnitOfWork(unit_of_work.AbstractUnitOfWork):\n\ndef __init__(self, folder): self.batches = CsvRepository(folder)\n\ndef commit(self): with self.batches._allocations_path.open('w') as f: writer = csv.writer(f) writer.writerow(['orderid', 'sku', 'qty', 'batchref']) for batch in self.batches.list(): for line in batch._allocations: writer.writerow( [line.orderid, line.sku, line.qty, batch.reference] )\n\ndef rollback(self): pass\n\nAnd once we have that, our CLI app for reading and writing batches\n\nand allocations to CSV is pared down to what it should be—a bit of code for reading order lines, and a bit of code that invokes our\n\nexisting service layer:\n\nAllocation with CSVs in nine lines (src/bin/allocate-from-csv)\n\ndef main(folder): orders_path = Path(folder) / 'orders.csv' uow = csv_uow.CsvUnitOfWork(folder) with orders_path.open() as f: reader = csv.DictReader(f) for row in reader: orderid, sku = row['orderid'], row['sku'] qty = int(row['qty']) services.allocate(orderid, sku, qty, uow)\n\nTa-da! Now are y’all impressed or what?\n\nMuch love,\n\nBob and Harry\n\nAppendix D. Repository and Unit of Work Patterns with Django\n\nSuppose you wanted to use Django instead of SQLAlchemy and Flask. How might things look? The first thing is to choose where to install it. We put it in a separate package next to our main allocation code:\n\n├── src │ ├── allocation │ │ ├── __init__.py │ │ ├── adapters │ │ │ ├── __init__.py ... │ ├── djangoproject │ │ ├── alloc │ │ │ ├── __init__.py │ │ │ ├── apps.py │ │ │ ├── migrations │ │ │ │ ├── 0001_initial.py │ │ │ │ └── __init__.py │ │ │ ├── models.py │ │ │ └── views.py │ │ ├── django_project │ │ │ ├── __init__.py │ │ │ ├── settings.py │ │ │ ├── urls.py │ │ │ └── wsgi.py │ │ └── manage.py │ └── setup.py └── tests ├── conftest.py ├── e2e │ └── test_api.py ├── integration\n\n│ ├── test_repository.py ...\n\nTIP\n\nThe code for this appendix is in the appendix_django branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout appendix_django\n\nRepository Pattern with Django\n\nWe used a plug-in called pytest-django to help with test database management.\n\nRewriting the first repository test was a minimal change—just rewriting some raw SQL with a call to the Django ORM/QuerySet language:\n\nFirst repository test adapted (tests/integration/test_repository.py)\n\nfrom djangoproject.alloc import models as django_models\n\n@pytest.mark.django_db def test_repository_can_save_a_batch(): batch = model.Batch(\"batch1\", \"RUSTY-SOAPDISH\", 100, eta=date(2011, 12, 25))\n\nrepo = repository.DjangoRepository() repo.add(batch)\n\n[saved_batch] = django_models.Batch.objects.all() assert saved_batch.reference == batch.reference assert saved_batch.sku == batch.sku\n\nassert saved_batch.qty == batch._purchased_quantity assert saved_batch.eta == batch.eta\n\nThe second test is a bit more involved since it has allocations, but it is still made up of familiar-looking Django code:\n\nSecond repository test is more involved (tests/integration/test_repository.py)\n\n@pytest.mark.django_db def test_repository_can_retrieve_a_batch_with_allocations(): sku = \"PONY-STATUE\" d_line = django_models.OrderLine.objects.create(orderid=\"order1\", sku=sku, qty=12) d_b1 = django_models.Batch.objects.create( reference=\"batch1\", sku=sku, qty=100, eta=None ) d_b2 = django_models.Batch.objects.create( reference=\"batch2\", sku=sku, qty=100, eta=None ) django_models.Allocation.objects.create(line=d_line, batch=d_batch1)\n\nrepo = repository.DjangoRepository() retrieved = repo.get(\"batch1\")\n\nexpected = model.Batch(\"batch1\", sku, 100, eta=None) assert retrieved == expected # Batch.__eq__ only compares reference assert retrieved.sku == expected.sku assert retrieved._purchased_quantity == expected._purchased_quantity assert retrieved._allocations == { model.OrderLine(\"order1\", sku, 12), }\n\nHere’s how the actual repository ends up looking:\n\nA Django repository (src/allocation/adapters/repository.py)\n\nclass DjangoRepository(AbstractRepository):\n\ndef add(self, batch): super().add(batch) self.update(batch)\n\ndef update(self, batch): django_models.Batch.update_from_domain(batch)\n\ndef _get(self, reference): return django_models.Batch.objects.filter( reference=reference ).first().to_domain()\n\ndef list(self): return [b.to_domain() for b in django_models.Batch.objects.all()]\n\nYou can see that the implementation relies on the Django models having some custom methods for translating to and from our domain model.\n\n1\n\nCustom Methods on Django ORM Classes to Translate to/from Our Domain Model\n\nThose custom methods look something like this:\n\nDjango ORM with custom methods for domain model conversion (src/djangoproject/alloc/models.py)\n\nfrom django.db import models from allocation.domain import model as domain_model\n\nclass Batch(models.Model): reference = models.CharField(max_length=255) sku = models.CharField(max_length=255) qty = models.IntegerField() eta = models.DateField(blank=True, null=True)\n\n@staticmethod def update_from_domain(batch: domain_model.Batch):\n\ntry: b = Batch.objects.get(reference=batch.reference) except Batch.DoesNotExist: b = Batch(reference=batch.reference) b.sku = batch.sku b.qty = batch._purchased_quantity b.eta = batch.eta b.save() b.allocation_set.set( Allocation.from_domain(l, b) for l in batch._allocations )\n\ndef to_domain(self) -> domain_model.Batch: b = domain_model.Batch( ref=self.reference, sku=self.sku, qty=self.qty, eta=self.eta ) b._allocations = set( a.line.to_domain() for a in self.allocation_set.all() ) return b\n\nclass OrderLine(models.Model): #...\n\nFor value objects, objects.get_or_create can work, but for entities, you probably need an explicit try-get/except to handle the upsert.\n\n2\n\nWe’ve shown the most complex example here. If you do decide to do this, be aware that there will be boilerplate! Thankfully it’s not very complex boilerplate.\n\nRelationships also need some careful, custom handling.\n\nNOTE\n\nAs in Chapter 2, we use dependency inversion. The ORM (Django) depends on the model and not the other way around.\n\nUnit of Work Pattern with Django\n\nThe tests don’t change too much:\n\nAdapted UoW tests (tests/integration/test_uow.py)\n\ndef insert_batch(ref, sku, qty, eta): django_models.Batch.objects.create(reference=ref, sku=sku, qty=qty, eta=eta)\n\ndef get_allocated_batch_ref(orderid, sku): return django_models.Allocation.objects.get( line__orderid=orderid, line__sku=sku ).batch.reference\n\n@pytest.mark.django_db(transaction=True) def test_uow_can_retrieve_a_batch_and_allocate_to_it(): insert_batch('batch1', 'HIPSTER-WORKBENCH', 100, None)\n\nuow = unit_of_work.DjangoUnitOfWork() with uow: batch = uow.batches.get(reference='batch1') line = model.OrderLine('o1', 'HIPSTER-WORKBENCH', 10) batch.allocate(line) uow.commit()\n\nbatchref = get_allocated_batch_ref('o1', 'HIPSTER-WORKBENCH') assert batchref == 'batch1'\n\n@pytest.mark.django_db(transaction=True)\n\ndef test_rolls_back_uncommitted_work_by_default(): ...\n\n@pytest.mark.django_db(transaction=True) def test_rolls_back_on_error(): ...\n\nBecause we had little helper functions in these tests, the actual main bodies of the tests are pretty much the same as they were with SQLAlchemy.\n\nThe pytest-django mark.django_db(transaction=True) is required to test our custom transaction/rollback behaviors.\n\nAnd the implementation is quite simple, although it took me a few tries to find which invocation of Django’s transaction magic would work:\n\nUoW adapted for Django\n\n(src/allocation/service_layer/unit_of_work.py)\n\nclass DjangoUnitOfWork(AbstractUnitOfWork):\n\ndef __enter__(self): self.batches = repository.DjangoRepository() transaction.set_autocommit(False) return super().__enter__()\n\ndef __exit__(self, *args): super().__exit__(*args) transaction.set_autocommit(True)\n\ndef commit(self): for batch in self.batches.seen: self.batches.update(batch) transaction.commit()\n\ndef rollback(self): transaction.rollback()\n\nset_autocommit(False) was the best way to tell Django to stop automatically committing each ORM operation immediately, and to begin a transaction.\n\nThen we use the explicit rollback and commits.\n\nOne difficulty: because, unlike with SQLAlchemy, we’re not instrumenting the domain model instances themselves, the commit() command needs to explicitly go through all the objects that have been touched by every repository and manually update them back to the ORM.\n\nAPI: Django Views Are Adapters\n\nThe Django views.py file ends up being almost identical to the old\n\nflask_app.py, because our architecture means it’s a very thin wrapper around our service layer (which didn’t change at all, by the way):\n\nFlask app → Django views (src/djangoproject/alloc/views.py)\n\nos.environ['DJANGO_SETTINGS_MODULE'] = 'djangoproject.django_project.settings' django.setup()\n\n@csrf_exempt def add_batch(request): data = json.loads(request.body) eta = data['eta'] if eta is not None: eta = datetime.fromisoformat(eta).date() services.add_batch( data['ref'], data['sku'], data['qty'], eta, unit_of_work.DjangoUnitOfWork(), ) return HttpResponse('OK', status=201)\n\n@csrf_exempt\n\ndef allocate(request): data = json.loads(request.body) try: batchref = services.allocate( data['orderid'], data['sku'], data['qty'], unit_of_work.DjangoUnitOfWork(), ) except (model.OutOfStock, services.InvalidSku) as e: return JsonResponse({'message': str(e)}, status=400)\n\nreturn JsonResponse({'batchref': batchref}, status=201)\n\nWhy Was This All So Hard?\n\nOK, it works, but it does feel like more effort than Flask/SQLAlchemy.\n\nWhy is that?\n\nThe main reason at a low level is because Django’s ORM doesn’t work in the same way. We don’t have an equivalent of the SQLAlchemy classical mapper, so our ActiveRecord and our domain model can’t be the same object. Instead we have to build a manual\n\ntranslation layer behind the repository. That’s more work (although once it’s done, the ongoing maintenance burden shouldn’t be too high).\n\nBecause Django is so tightly coupled to the database, you have to use helpers like pytest-django and think carefully about test databases, right from the very first line of code, in a way that we didn’t have to when we started out with our pure domain model.\n\nBut at a higher level, the entire reason that Django is so great is that\n\nit’s designed around the sweet spot of making it easy to build CRUD apps with minimal boilerplate. But the entire thrust of our book is\n\nabout what to do when your app is no longer a simple CRUD app.\n\nAt that point, Django starts hindering more than it helps. Things like the Django admin, which are so awesome when you start out, become\n\nactively dangerous if the whole point of your app is to build a complex set of rules and modeling around the workflow of state changes. The\n\nDjango admin bypasses all of that.\n\nWhat to Do If You Already Have Django\n\nSo what should you do if you want to apply some of the patterns in this\n\nbook to a Django app? We’d say the following:\n\nThe Repository and Unit of Work patterns are going to be quite a lot of work. The main thing they will buy you in the short term is faster unit tests, so evaluate whether that benefit feels worth it in your case. In the longer term, they decouple your app from Django and the database, so if you anticipate wanting to migrate away from either of those, Repository and UoW are a good idea.\n\nThe Service Layer pattern might be of interest if you’re seeing a lot of duplication in your views.py. It can be a good way of thinking about your use cases separately from your web endpoints.\n\nYou can still theoretically do DDD and domain modeling with Django models, tightly coupled as they are to the database; you may be slowed by migrations, but it shouldn’t be fatal. So\n\nas long as your app is not too complex and your tests not too slow, you may be able to get something out of the fat models approach: push as much logic down to your models as possible, and apply patterns like Entity, Value Object, and Aggregate. However, see the following caveat.\n\nWith that said, word in the Django community is that people find that the fat models approach runs into scalability problems of its own,\n\nparticularly around managing interdependencies between apps. In\n\nthose cases, there’s a lot to be said for extracting out a business logic or domain layer to sit between your views and forms and your\n\nmodels.py, which you can then keep as minimal as possible.\n\nSteps Along the Way\n\nSuppose you’re working on a Django project that you’re not sure is\n\ngoing to get complex enough to warrant the patterns we recommend, but you still want to put a few steps in place to make your life easier,\n\nboth in the medium term and if you want to migrate to some of our patterns later. Consider the following:\n\nOne piece of advice we’ve heard is to put a logic.py into every Django app from day one. This gives you a place to put business logic, and to keep your forms, views, and models free of business logic. It can become a stepping-stone for moving to a fully decoupled domain model and/or service layer later.\n\nA business-logic layer might start out working with Django model objects and only later become fully decoupled from the framework and work on plain Python data structures.\n\nFor the read side, you can get some of the benefits of CQRS by putting reads into one place, avoiding ORM calls sprinkled all over the place.\n\nWhen separating out modules for reads and modules for domain logic, it may be worth decoupling yourself from the Django apps hierarchy. Business concerns will cut across them.\n\nNOTE\n\nWe’d like to give a shout-out to David Seddon and Ashia Zawaduk for talking through some of the ideas in this appendix. They did their best to stop us from saying anything really stupid about a topic we don’t really have enough personal experience of, but they may have failed.\n\nFor more thoughts and actual lived experience dealing with existing\n\napplications, refer to the epilogue.\n\n1 The DRY-Python project people have built a tool called mappers that looks like it might\n\nhelp minimize boilerplate for this sort of thing.\n\n2 @mr-bo-jangles suggested you might be able to use update_or_create, but that’s\n\nbeyond our Django-fu.\n\nAppendix E. Validation\n\nWhenever we’re teaching and talking about these techniques, one question that comes up over and over is “Where should I do validation? Does that belong with my business logic in the domain model, or is that an infrastructural concern?”\n\nAs with any architectural question, the answer is: it depends!\n\nThe most important consideration is that we want to keep our code\n\nwell separated so that each part of the system is simple. We don’t want to clutter our code with irrelevant detail.\n\nWhat Is Validation, Anyway?\n\nWhen people use the word validation, they usually mean a process whereby they test the inputs of an operation to make sure that they\n\nmatch certain criteria. Inputs that match the criteria are considered valid, and inputs that don’t are invalid.\n\nIf the input is invalid, the operation can’t continue but should exit with some kind of error. In other words, validation is about creating preconditions. We find it useful to separate our preconditions into\n\nthree subtypes: syntax, semantics, and pragmatics.\n\nValidating Syntax\n\nIn linguistics, the syntax of a language is the set of rules that govern the structure of grammatical sentences. For example, in English, the sentence “Allocate three units of TASTELESS-LAMP to order twenty- seven” is grammatically sound, while the phrase “hat hat hat hat hat hat wibble” is not. We can describe grammatically correct sentences as well formed.\n\nHow does this map to our application? Here are some examples of syntactic rules:\n\nAn Allocate command must have an order ID, a SKU, and a quantity.\n\nA quantity is a positive integer.\n\nA SKU is a string.\n\nThese are rules about the shape and structure of incoming data. An Allocate command without a SKU or an order ID isn’t a valid message. It’s the equivalent of the phrase “Allocate three to.”\n\nWe tend to validate these rules at the edge of the system. Our rule of thumb is that a message handler should always receive only a message that is well-formed and contains all required information.\n\nOne option is to put your validation logic on the message type itself:\n\nValidation on the message class (src/allocation/commands.py)\n\nfrom schema import And, Schema, Use\n\n@dataclass\n\nclass Allocate(Command):\n\n_schema = Schema({ 'orderid': int, sku: str, qty: And(Use(int), lambda n: n > 0) }, ignore_extra_keys=True)\n\norderid: str sku: str qty: int\n\n@classmethod def from_json(cls, data): data = json.loads(data) return cls(**_schema.validate(data))\n\nThe schema library lets us describe the structure and validation of our messages in a nice declarative way.\n\nThe from_json method reads a string as JSON and turns it into our message type.\n\nThis can get repetitive, though, since we need to specify our fields\n\ntwice, so we might want to introduce a helper library that can unify the validation and declaration of our message types:\n\nA command factory with schema (src/allocation/commands.py)\n\ndef command(name, **fields): schema = Schema(And(Use(json.loads), fields), ignore_extra_keys=True) cls = make_dataclass(name, fields.keys()) cls.from_json = lambda s: cls(**schema.validate(s)) return cls\n\ndef greater_than_zero(x): return x > 0\n\nquantity = And(Use(int), greater_than_zero)\n\nAllocate = command( orderid=int, sku=str, qty=quantity )\n\nAddStock = command( sku=str, qty=quantity\n\nThe command function takes a message name, plus kwargs for the fields of the message payload, where the name of the kwarg is the name of the field and the value is the parser.\n\nWe use the make_dataclass function from the dataclass module to dynamically create our message type.\n\nWe patch the from_json method onto our dynamic dataclass.\n\nWe can create reusable parsers for quantity, SKU, and so on to keep things DRY.\n\nDeclaring a message type becomes a one-liner.\n\nThis comes at the expense of losing the types on your dataclass, so bear that trade-off in mind.\n\nPostel’s Law and the Tolerant Reader Pattern\n\nPostel’s law, or the robustness principle, tells us, “Be liberal in what you accept, and conservative in what you emit.” We think this applies particularly well in the context of integration with our other systems. The idea here is that we should be strict whenever we’re sending\n\nmessages to other systems, but as lenient as possible when we’re receiving messages from others.\n\nFor example, our system could validate the format of a SKU. We’ve been using made-up SKUs like UNFORGIVING-CUSHION and MISBEGOTTEN-POUFFE. These follow a simple pattern: two words, separated by dashes, where the second word is the type of product and the first word is an adjective.\n\nDevelopers love to validate this kind of thing in their messages, and reject anything that looks like an invalid SKU. This causes horrible problems down the line when some anarchist releases a product named COMFY-CHAISE-LONGUE or when a snafu at the supplier results in a shipment of CHEAP-CARPET-2.\n\nReally, as the allocation system, it’s none of our business what the format of a SKU might be. All we need is an identifier, so we can simply describe it as a string. This means that the procurement system can change the format whenever they like, and we won’t care.\n\nThis same principle applies to order numbers, customer phone numbers, and much more. For the most part, we can ignore the internal structure of strings.\n\nSimilarly, developers love to validate incoming messages with tools like JSON Schema, or to build libraries that validate incoming messages and share them among systems. This likewise fails the robustness test.\n\nLet’s imagine, for example, that the procurement system adds new fields to the ChangeBatchQuantity message that record the reason for the change and the email of the user responsible for the change.\n\nSince these fields don’t matter to the allocation service, we should simply ignore them. We can do that in the schema library by passing the keyword arg ignore_extra_keys=True.\n\nThis pattern, whereby we extract only the fields we care about and do minimal validation of them, is the Tolerant Reader pattern.\n\nTIP\n\nValidate as little as possible. Read only the fields you need, and don’t overspecify their contents. This will help your system stay robust when other systems change over time. Resist the temptation to share message definitions between systems: instead, make it easy to define the data you depend on. For more info, see Martin Fowler’s article on the Tolerant Reader pattern.\n\nIS POSTEL ALWAYS RIGHT?\n\nMentioning Postel can be quite triggering to some people. They will tell you that Postel is the precise reason that everything on the internet is broken and we can’t have nice things. Ask Hynek about SSLv3 one day.\n\nWe like the Tolerant Reader approach in the particular context of event-based integration between services that we control, because it allows for independent evolution of those services.\n\nIf you’re in charge of an API that’s open to the public on the big bad internet, there might be good reasons to be more conservative about what inputs you allow.\n\nValidating at the Edge\n\nEarlier, we said that we want to avoid cluttering our code with\n\nirrelevant details. In particular, we don’t want to code defensively inside our domain model. Instead, we want to make sure that requests are known to be valid before our domain model or use-case handlers see them. This helps our code stay clean and maintainable over the long term. We sometimes refer to this as validating at the edge of the system.\n\nIn addition to keeping your code clean and free of endless checks and asserts, bear in mind that invalid data wandering through your system\n\nis a time bomb; the deeper it gets, the more damage it can do, and the fewer tools you have to respond to it.\n\nBack in Chapter 8, we said that the message bus was a great place to\n\nput cross-cutting concerns, and validation is a perfect example of that.\n\nHere’s how we might change our bus to perform validation for us:\n\nValidation\n\nclass MessageBus:\n\ndef handle_message(self, name: str, body: str): try: message_type = next(mt for mt in EVENT_HANDLERS if mt.__name__ == name) message = message_type.from_json(body) self.handle([message]) except StopIteration: raise KeyError(f\"Unknown message name {name}\") except ValidationError as e: logging.error( f'invalid message of type {name}\\n' f'{body}\\n' f'{e}'\n\n) raise e\n\nHere’s how we might use that method from our Flask API endpoint:\n\nAPI bubbles up validation errors (src/allocation/flask_app.py)\n\n@app.route(\"/change_quantity\", methods=['POST']) def change_batch_quantity(): try: bus.handle_message('ChangeBatchQuantity', request.body) except ValidationError as e: return bad_request(e) except exceptions.InvalidSku as e: return jsonify({'message': str(e)}), 400\n\ndef bad_request(e: ValidationError): return e.code, 400\n\nAnd here’s how we might plug it in to our asynchronous message processor:\n\nValidation errors when handling Redis messages\n\n(src/allocation/redis_pubsub.py)\n\ndef handle_change_batch_quantity(m, bus: messagebus.MessageBus): try: bus.handle_message('ChangeBatchQuantity', m) except ValidationError: print('Skipping invalid message') except exceptions.InvalidSku as e: print(f'Unable to change stock for missing sku {e}')\n\nNotice that our entrypoints are solely concerned with how to get a\n\nmessage from the outside world and how to report success or failure. Our message bus takes care of validating our requests and routing them\n\nto the correct handler, and our handlers are exclusively focused on the logic of our use case.\n\nTIP\n\nWhen you receive an invalid message, there’s usually little you can do but log the error and continue. At MADE we use metrics to count the number of messages a system receives, and how many of those are successfully processed, skipped, or invalid. Our monitoring tools will alert us if we see spikes in the numbers of bad messages.\n\nValidating Semantics\n\nWhile syntax is concerned with the structure of messages, semantics is the study of meaning in messages. The sentence “Undo no dogs from\n\nellipsis four” is syntactically valid and has the same structure as the sentence “Allocate one teapot to order five,\"” but it is meaningless.\n\nWe can read this JSON blob as an Allocate command but can’t successfully execute it, because it’s nonsense:\n\nA meaningless message\n\n{ \"orderid\": \"superman\", \"sku\": \"zygote\", \"qty\": -1 }\n\nWe tend to validate semantic concerns at the message-handler layer with a kind of contract-based programming:\n\nPreconditions (src/allocation/ensure.py)\n\n\"\"\" This module contains preconditions that we apply to our handlers. \"\"\"\n\nclass MessageUnprocessable(Exception):\n\ndef __init__(self, message): self.message = message\n\nclass ProductNotFound(MessageUnprocessable): \"\"\"\" This exception is raised when we try to perform an action on a product that doesn't exist in our database. \"\"\"\"\n\ndef __init__(self, message): super().__init__(message) self.sku = message.sku\n\ndef product_exists(event, uow): product = uow.products.get(event.sku) if product is None: raise ProductNotFound(event)\n\nWe use a common base class for errors that mean a message is invalid.\n\nUsing a specific error type for this problem makes it easier to report on and handle the error. For example, it’s easy to map ProductNotFound to a 404 in Flask.\n\nproduct_exists is a precondition. If the condition is False, we raise an error.\n\nThis keeps the main flow of our logic in the service layer clean and declarative:\n\nEnsure calls in services (src/allocation/services.py)\n\n# services.py\n\nfrom allocation import ensure\n\ndef allocate(event, uow): line = mode.OrderLine(event.orderid, event.sku, event.qty) with uow: ensure.product_exists(uow, event)\n\nproduct = uow.products.get(line.sku) product.allocate(line) uow.commit()\n\nWe can extend this technique to make sure that we apply messages\n\nidempotently. For example, we want to make sure that we don’t insert a batch of stock more than once.\n\nIf we get asked to create a batch that already exists, we’ll log a\n\nwarning and continue to the next message:\n\nRaise SkipMessage exception for ignorable events (src/allocation/services.py)\n\nclass SkipMessage (Exception): \"\"\"\" This exception is raised when a message can't be processed, but there's no incorrect behavior. For example, we might receive the same message multiple times, or we might receive a message that is now out of date. \"\"\"\"\n\ndef __init__(self, reason): self.reason = reason\n\ndef batch_is_new(self, event, uow): batch = uow.batches.get(event.batchid)\n\nif batch is not None: raise SkipMessage(f\"Batch with id {event.batchid} already exists\")\n\nIntroducing a SkipMessage exception lets us handle these cases in a generic way in our message bus:\n\nThe bus now knows how to skip (src/allocation/messagebus.py)\n\nclass MessageBus:\n\ndef handle_message(self, message): try: ... except SkipMessage as e: logging.warn(f\"Skipping message {message.id} because {e.reason}\")\n\nThere are a couple of pitfalls to be aware of here. First, we need to be\n\nsure that we’re using the same UoW that we use for the main logic of our use case. Otherwise, we open ourselves to irritating concurrency\n\nbugs.\n\nSecond, we should try to avoid putting all our business logic into these precondition checks. As a rule of thumb, if a rule can be tested inside\n\nour domain model, then it should be tested in the domain model.\n\nValidating Pragmatics\n\nPragmatics is the study of how we understand language in context.\n\nAfter we have parsed a message and grasped its meaning, we still need to process it in context. For example, if you get a comment on a\n\npull request saying, “I think this is very brave,” it may mean that the reviewer admires your courage—unless they’re British, in which case,\n\nthey’re trying to tell you that what you’re doing is insanely risky, and\n\nonly a fool would attempt it. Context is everything.\n\nVALIDATION RECAP\n\nValidation means different things to different people\n\nWhen talking about validation, make sure you’re clear about what you’re validating. We find it useful to think about syntax, semantics, and pragmatics: the structure of messages, the meaningfulness of messages, and the business logic governing our response to messages.\n\nValidate at the edge when possible\n\nValidating required fields and the permissible ranges of numbers is boring, and we want to keep it out of our nice clean codebase. Handlers should always receive only valid messages.\n\nOnly validate what you require\n\nUse the Tolerant Reader pattern: read only the fields your application needs and don’t overspecify their internal structure. Treating fields as opaque strings buys you a lot of flexibility.\n\nSpend time writing helpers for validation\n\nHaving a nice declarative way to validate incoming messages and apply preconditions to your handlers will make your codebase much cleaner. It’s worth investing time to make boring code easy to maintain.\n\nLocate each of the three types of validation in the right place\n\nValidating syntax can happen on message classes, validating semantics can happen in the service layer or on the message bus, and validating pragmatics belongs in the domain model.\n\nTIP\n\nOnce you’ve validated the syntax and semantics of your commands at the edges of your system, the domain is the place for the rest of your validation. Validation of pragmatics is often a core part of your business rules.\n\nIn software terms, the pragmatics of an operation are usually managed\n\nby the domain model. When we receive a message like “allocate three million units of SCARCE-CLOCK to order 76543,” the message is syntactically valid and semantically valid, but we’re unable to comply because we don’t have the stock available.\n\nIndex\n\nSYMBOLS\n\n@abc.abstractmethod, The Repository in the Abstract\n\nA\n\nabstract base classes (ABCs)\n\nABC for the repository, The Repository in the Abstract\n\ndefining for notifications, Define the Abstract and Concrete Implementations\n\nswitching to typing.Protocol, Option 3: The UoW Publishes Events to the Message Bus\n\nusing duck typing and protocols instead of, The Repository in the Abstract\n\nusing for ports, What Is a Port and What Is an Adapter, in Python?\n\nabstract methods, The Repository in the Abstract\n\nabstractions, A Brief Interlude: On Coupling and Abstractions-Wrap- Up\n\nabstracting state to aid testability, Abstracting State Aids Testability-Abstracting State Aids Testability\n\nAbstractRepository, service function depending on, A Typical Service Function\n\nAbstractUnitOfWork, Unit of Work and Its Context Manager\n\nchoosing right abstraction, Choosing the Right Abstraction(s)- Implementing Our Chosen Abstractions\n\nexplicit dependencies are more abstract, Aren’t Explicit Dependencies Totally Weird and Java-y?\n\nimplementing chosen abstraction, Implementing Our Chosen Abstractions-Wrap-Up\n\nedge-to-edge testing with fakes and dependency injection, Testing Edge to Edge with Fakes and Dependency Injection- Testing Edge to Edge with Fakes and Dependency Injection\n\nnot using mock.patch for testing, Why Not Just Patch It Out?\n\nsimplifying interface between business logic and I/O, Wrap-Up\n\nusing to reduce coupling, A Brief Interlude: On Coupling and Abstractions\n\nadapters\n\nbuilding adapter and doing dependency injection for it, Building an Adapter “Properly”: A Worked Example-Wrap-Up\n\ndefining abstract and concrete implementations, Define the Abstract and Concrete Implementations\n\ndefined, What Is a Port and What Is an Adapter, in Python?\n\nDjango views, API: Django Views Are Adapters\n\nexercise for the reader, Figure Out How to Integration Test the Real Thing\n\nports-and-adapters inspired patterns, Part I Recap\n\nputting into folder, Putting Things in Folders to See Where It All Belongs\n\nAggregate pattern, What Is an Aggregate?\n\naggregates\n\nabout, What Is an Aggregate?\n\nacting as consistency boundaries, Discussion: Events, Commands, and Error Handling\n\nand consistency boundaries recap, Wrap-Up\n\nchanging multiple aggregates in a request, Wrap-Up\n\nchoosing an aggregrate, Choosing an Aggregate-Choosing an Aggregate\n\nexercise for the reader, What About Performance?\n\nHistory aggregate recording orders and raising domain events, Discussion: Events, Commands, and Error Handling\n\nidentifying aggregates and bounded contexts, Identifying Aggregates and Bounded Contexts-An Event-Driven Approach to Go to Microservices via Strangler Pattern\n\none aggregrate = one repository, One Aggregate = One Repository\n\noptimistic concurrency with version numbers, Optimistic Concurrency with Version Numbers-Implementation Options for Version Numbers\n\nperformance and, What About Performance?\n\nProduct aggregate, Aggregates and Consistency Boundaries\n\npros and cons or trade-offs, Wrap-Up\n\nquery on repository returning single aggregate, Implementation\n\nraising events about, Discussion: Events, Commands, and Error Handling\n\nrepository keeping track of aggregates passing through it, Option 3: The UoW Publishes Events to the Message Bus\n\ntesting for data integrity rules, Testing for Our Data Integrity Rules-Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\ntesting Product object to raise events, The Model Raises Events\n\nUoW collecting events from and passing them to message bus, Wrap-Up\n\nallocate service\n\nallocating against all batches with, Choosing an Aggregate\n\nmoving to be a method on Product aggregate, Choosing an Aggregate\n\nAllocated event, Our New Outgoing Event\n\nAllocationRequired event, Refactoring Service Functions to Message Handlers\n\npassing to services.allocate, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nAnemic Domain anti-pattern, The DIP in Action\n\nAPIs\n\nadding API for adding a batch, Carrying the Improvement Through to the E2E Tests\n\nDjango views as adapters, API: Django Views Are Adapters\n\nend-to-end test of allocate API, A First End-to-End Test\n\nmodifying API to work with events, A Temporary Ugly Hack: The Message Bus Has to Return Results\n\nusing repository directly in API endpoint, What Is the Trade-Off?\n\nwithout Unit of Work pattern, talking directly to three layers, Unit of Work Pattern\n\napplication services, Why Is Everything Called a Service?\n\narchitecture, summary diagram and table, Summary Diagram and Table-Summary Diagram and Table\n\nasynchronous messaging, temporal decoupling with, The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\natomic operations, Unit of Work Pattern\n\nUnit of Work as abstraction over, Wrap-Up\n\nusing Unit of Work to group operations into atomic unit, Examples: Using UoW to Group Multiple Operations into an Atomic Unit-Example 2: Change Batch Quantity\n\nB\n\nBall of Mud pattern, A Brief Interlude: On Coupling and Abstractions\n\ndistributed ball of mud and thinking in nouns, Distributed Ball of Mud, and Thinking in Nouns-Distributed Ball of Mud, and Thinking in Nouns\n\nseparating responsibilities, Separating Entangled Responsibilities\n\nBatchCreated event, Refactoring Service Functions to Message Handlers\n\nservices.add_batch as handler for, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nbatches\n\nallocating against all batches using domain service, Choosing an Aggregate\n\nasking Product to allocate against, Choosing an Aggregate\n\nbatch quantities changed means deallocate and reallocate, A New Requirement Leads Us to a New Architecture\n\ncollection of, Choosing an Aggregate\n\nBatchQuantityChanged event\n\nimplementing, Our New Event\n\ninvoking handler change_batch_quantity, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nBernhardt, Gary, Implementing Our Chosen Abstractions\n\nbootstrapping, Dependency Injection (and Bootstrapping)\n\nbootstrapping script, capabilities of, A Bootstrap Script\n\nchanging notifications dependency in bootstrap script, Define the Abstract and Concrete Implementations\n\ndependency injection and bootstrap recap, Wrap-Up\n\ndependency injection with, Aren’t Explicit Dependencies Totally Weird and Java-y?\n\ninitializing dependency injection in tests, Initializing DI in Our Tests\n\nusing in entrypoints, Using Bootstrap in Our Entrypoints\n\nusing to build message bus that talks to real notification class, Figure Out How to Integration Test the Real Thing\n\nbounded contexts, Choosing an Aggregate\n\nidentifying aggregates and, Identifying Aggregates and Bounded Contexts-An Event-Driven Approach to Go to Microservices via Strangler Pattern\n\nproduct concept and, Choosing an Aggregate\n\nbusiness logic\n\nabstractions simplifying interface with messy I/O, Wrap-Up\n\nseparating from state in code, Implementing Our Chosen Abstractions\n\nbusiness logic layer, What Is a Domain Model?\n\nbusiness rules\n\ninvariants, concurrency, and locks, Invariants, Concurrency, and Locks\n\ninvariants, constraints, and consistency, Invariants, Constraints, and Consistency\n\nC\n\nCelery tool, The Message Bus Maps Events to Handlers\n\nchange_batch_quantity\n\nhandler tests for, Test-Driving a New Handler\n\nimplementation, handler delegating to model layer, Implementation\n\nchoreography, Single Responsibility Principle\n\nclasses, dependency injection using, An Alternative Using Classes\n\nclassical mapping, Inverting the Dependency: ORM Depends on Model\n\nclosures\n\ndependency injection using, Preparing Handlers: Manual DI with Closures and Partials\n\ndifference from partial functions, Preparing Handlers: Manual DI with Closures and Partials\n\ncohesion, high, between coupled elements, A Brief Interlude: On Coupling and Abstractions\n\ncollaborators, The Unit of Work Collaborates with the Repository\n\ncollections, What Is an Aggregate?\n\nCommand Handler pattern, Wrap-Up\n\ncommand-query responsibility segregation (CQRS), Command-Query Responsibility Segregation (CQRS)-Wrap-Up\n\nbuilding read-only views into our data, Hold On to Your Lunch, Folks\n\nchanging read model implementation to use Redis, Changing Our Read Model Implementation Is Easy\n\ndenormalized copy of your data optimized for read operations, Time to Completely Jump the Shark\n\ndomain model not optimized for read operations, Your Domain Model Is Not Optimized for Read Operations\n\ndomain models for writing, Domain Models Are for Writing\n\nfull-blown CQRS versus simpler options, Wrap-Up\n\nPost/Redirect/Get pattern and CQS, Post/Redirect/Get and CQS\n\nread side and write side, Most Users Aren’t Going to Buy Your Furniture\n\nreads, Most Users Aren’t Going to Buy Your Furniture\n\nconsistency of, Most Users Aren’t Going to Buy Your Furniture\n\nrebuilding view model from scratch, Updating a Read Model Table Using an Event Handler\n\nSELECT N+1 and other performance problems, SELECT N+1 and Other Performance Considerations\n\nsimple view using existing repository, “Obvious” Alternative 1: Using the Existing Repository\n\ntesting views, Testing CQRS Views\n\ntrade-offs for view model options, Wrap-Up\n\nupdating read model table using event handler, Time to Completely Jump the Shark\n\nview that uses the ORM, “Obvious” Alternative 2: Using the ORM\n\ncommands, Commands and Command Handler-Wrap-Up\n\ncommand flow to reserve stock, confirm reservation, dispatch goods, and make customer VIP, Distributed Ball of Mud, and Thinking in Nouns\n\ncommand flow when warehouse knows stock is damaged, Distributed Ball of Mud, and Thinking in Nouns\n\ncommand flow with error, Error Handling in Distributed Systems\n\ncommand handler logic in message bus, Message Bus Is Given Handlers at Runtime\n\nevents versus, Commands and Events-Commands and Events\n\nevents, commands, and error handling, Discussion: Events, Commands, and Error Handling-Discussion: Events, Commands, and Error Handling\n\nrecovering from errors synchronously, Recovering from Errors Synchronously\n\nexception handling, Differences in Exception Handling\n\nhandlers for, Differences in Exception Handling\n\nin our system now, Commands and Events\n\nprogram output as list of commands, Choosing the Right Abstraction(s)\n\nsplitting commands and events, trade-offs, Wrap-Up\n\ncommits\n\ncommit method, The Real Unit of Work Uses SQLAlchemy Sessions\n\nexplicit tests for, Explicit Tests for Commit/Rollback Behavior\n\nexplicit versus implicit, Explicit Versus Implicit Commits\n\ncomponent diagram at end of Part One, Part I Recap\n\ncomposition over inheritance in TrackingRepository wrapper class, Option 3: The UoW Publishes Events to the Message Bus\n\ncomposition root, Dependency Injection (and Bootstrapping), Aren’t Explicit Dependencies Totally Weird and Java-y?\n\nconcurrency, Invariants, Concurrency, and Locks\n\naggregates and concurrency issues, Wrap-Up\n\nallowing for greatest degree of, What Is an Aggregate?\n\nenforcing rules using database transactions, Enforcing Concurrency Rules by Using Database Transaction Isolation Levels\n\nintegration test for, Testing for Our Data Integrity Rules\n\nnot provided by message bus implementation, The Message Bus Maps Events to Handlers\n\noptimistic concurrency with version numbers, Optimistic Concurrency with Version Numbers-Implementation Options for Version Numbers\n\npessimistic concurrency example, SELECT FOR UPDATE, Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nreproducing behavior with time.sleep function, Testing for Our Data Integrity Rules\n\nconnascence, Error Handling in Distributed Systems\n\nconsistency, Invariants, Constraints, and Consistency\n\nattainment of read consistency, Most Users Aren’t Going to Buy Your Furniture\n\neventually consistent reads, Most Users Aren’t Going to Buy Your Furniture\n\nconsistency boundaries, Aggregates and Consistency Boundaries, What Is an Aggregate?\n\naggregates acting as, Discussion: Events, Commands, and Error Handling\n\nmicroservices as, The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\nrecap, Wrap-Up\n\nconstraints, Invariants, Constraints, and Consistency\n\ncontext manager, Unit of Work Pattern\n\nstarting Unit of Work as, The Unit of Work Collaborates with the Repository\n\nUnit of Work and, Unit of Work and Its Context Manager-Fake Unit of Work for Testing\n\ncontrol flow, using exceptions for, The Model Raises Events\n\ncoupling, A Brief Interlude: On Coupling and Abstractions\n\navoiding inappropriate coupling, Error Handling in Distributed Systems\n\ndisadvantages of, A Brief Interlude: On Coupling and Abstractions\n\ndomain logic coupled with I/O, Abstracting State Aids Testability\n\nfailure cascade as temporal coupling, Error Handling in Distributed Systems\n\nin tests that use mocks, Why Not Just Patch It Out?\n\nreducing by abstracting away details, A Brief Interlude: On Coupling and Abstractions\n\nseparating what you want to do from how to do it, Choosing the Right Abstraction(s)\n\ntemporal decoupling using asynchronous messaging, The Alternative: Temporal Decoupling Using Asynchronous\n\nMessaging\n\ntrade-off between design feedback and, On Deciding What Kind of Tests to Write\n\nCQRS (see command-query responsibility segregation)\n\nCQS (command-query separation), Post/Redirect/Get and CQS\n\nCRUD wrapper around a database, Part I Recap\n\nCSV over SMTP architecture, Why Not Just Run Everything in a Spreadsheet?\n\nCSVs, doing everything with, Swapping Out the Infrastructure: Do Everything with CSVs-Implementing a Repository and Unit of Work for CSVs\n\nD\n\ndata access, applying dependency inversion principle to, Applying the DIP to Data Access\n\ndata integrity\n\nissues arising from splitting operation across two UoWs, Implementing Our New Requirement\n\ntesting for, Testing for Our Data Integrity Rules-Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\ndata storage, Repository pattern and, Repository Pattern\n\ndatabases\n\nSQLAlchemy adding session for Unit of Work, The Real Unit of Work Uses SQLAlchemy Sessions\n\ntesting allocations persisted to database, The Straightforward Implementation\n\ntesting transactions against real database, Explicit Tests for Commit/Rollback Behavior\n\nUnit of Work pattern managing state for, Unit of Work Pattern\n\ndataclasses\n\nevents, Events Are Simple Dataclasses\n\nuse for message types, Recovering from Errors Synchronously\n\nuse for value objects, Dataclasses Are Great for Value Objects\n\ndeallocate service, building (exerise), A Typical Service Function\n\ndependencies\n\nabstract dependencies of service layer, The DIP in Action\n\ntesting, The DIP in Action\n\ncircular dependencies between event handlers, Wrap-Up\n\ndepending on abstractions, A Typical Service Function\n\nedge-to-edge testing with dependency injection, Testing Edge to Edge with Fakes and Dependency Injection-Testing Edge to Edge with Fakes and Dependency Injection\n\nkeeping all domain dependencies in fixture functions, Mitigation: Keep All Domain Dependencies in Fixture Functions\n\nnone in domain model, Applying the DIP to Data Access\n\nreal service layer dependencies at runtime, The DIP in Action\n\nservice layer dependency on abstract UoW, Using the UoW in the Service Layer\n\nUoW no longer dependent on message bus, The Message Bus Now Collects Events from the UoW\n\ndependency chains, A Bootstrap Script\n\ndependency injection, Dependency Injection (and Bootstrapping)-An Alternative Using Classes\n\nby inspecting function signatures, A Bootstrap Script\n\nexplicit dependencies are better than implicit dependencies, Aren’t Explicit Dependencies Totally Weird and Java-y?\n\nimplicit versus explicit dependencies, Implicit Versus Explicit Dependencies\n\nmanual creation of partial functions inline, A Bootstrap Script\n\nmanual DI with closures or partial functions, Preparing Handlers: Manual DI with Closures and Partials\n\nrecap of DI and bootstrap, Wrap-Up\n\nusing classes, An Alternative Using Classes\n\nusing DI framework, A Bootstrap Script\n\ndependency inversion principle, Applying the DIP to Data Access, Wrap-Up\n\ndeclaring explicit dependency as example of, Aren’t Explicit Dependencies Totally Weird and Java-y?\n\nORM depends on the data model, Inverting the Dependency: ORM Depends on Model\n\ndictionaries\n\ndictionary of hashes to paths, Implementing Our Chosen Abstractions\n\nfor filesystem operations, Choosing the Right Abstraction(s)\n\nHANDLERS dicts for commands and events, Differences in Exception Handling\n\ndirectory structure, putting project into folders, Putting Things in Folders to See Where It All Belongs\n\nDistributed Ball of Mud anti-pattern\n\nand thinking in nouns, Distributed Ball of Mud, and Thinking in Nouns-Distributed Ball of Mud, and Thinking in Nouns\n\navoiding, The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\nDjango, Repository and Unit of Work Patterns with Django-Steps Along the Way\n\napplying patterns to Django app, What to Do If You Already Have Django\n\nsteps along the way, Steps Along the Way\n\ninstalling, Repository and Unit of Work Patterns with Django\n\nORM example, The “Normal” ORM Way: Model Depends on ORM\n\nRepository pattern with, Repository Pattern with Django-Custom Methods on Django ORM Classes to Translate to/from Our Domain Model\n\nUnit of Work pattern with, Unit of Work Pattern with Django-Unit of Work Pattern with Django\n\nusing, difficulty of, Why Was This All So Hard?\n\nviews are adapters, API: Django Views Are Adapters\n\nDocker dev environment with real fake email server, Figure Out How to Integration Test the Real Thing\n\ndomain driven design (DDD), Domain Modeling, What Is a Domain Model?\n\n(see also domain model; domain modeling)\n\nAggregate pattern, What Is an Aggregate?\n\nbounded contexts, Choosing an Aggregate\n\nchoosing the right aggregate, references on, Wrap-Up\n\ndomain, defined, What Is a Domain Model?\n\nRepository pattern and, What Is the Trade-Off?\n\nDomain Events pattern, Events and the Message Bus\n\ndomain exceptions, Exceptions Can Express Domain Concepts Too\n\ndomain language, Exploring the Domain Language\n\ndomain layer\n\nfully decoupling service layer from, Fully Decoupling the Service-Layer Tests from the Domain-Adding a Missing Service\n\ntests moving to service layer, Should Domain Layer Tests Move to the Service Layer?\n\nreasons for, Should Domain Layer Tests Move to the Service Layer?\n\ndomain model, Reminder: Our Model-Introducing the Repository Pattern\n\ndeciding whether to write tests against, On Deciding What Kind of Tests to Write\n\nDjango custom ORM methods for conversion, Custom Methods on Django ORM Classes to Translate to/from Our Domain Model\n\nemail sending code in, avoiding, And Let’s Not Make a Mess of Our Model Either\n\nevents from, passing to message bus in service layer, Option 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus\n\nfolder for, Putting Things in Folders to See Where It All Belongs\n\ngetting benefits of rich model, The DIP in Action\n\ninvariants, constraints, and consistency, Invariants, Constraints, and Consistency\n\nmaintaining small core of tests written against, Wrap-Up\n\nnew method on, change_batch_quantity, A New Method on the Domain Model\n\nnot optimized for read operations, Your Domain Model Is Not Optimized for Read Operations\n\npersisting, Persisting Our Domain Model\n\nraising events, The Model Raises Events\n\nraising events and service layer passing them to message bus, Wrap-Up\n\ntrade-offs as a diagram, Wrap-Up\n\ntranslating to relational database\n\nnormal ORM way, model depends on ORM, The “Normal” ORM Way: Model Depends on ORM\n\nORM depends on the model, Inverting the Dependency: ORM Depends on Model\n\nusing spreadsheets instead of, Why Not Just Run Everything in a Spreadsheet?\n\nwriting data, Domain Models Are for Writing\n\nwriting tests against, High and Low Gear\n\ndomain modeling, Domain Modeling-Exceptions Can Express Domain Concepts Too\n\ndomain language, Exploring the Domain Language\n\nfunctions for domain services, Not Everything Has to Be an Object: A Domain Service Function-Exceptions Can Express Domain Concepts Too\n\nunit testing domain models, Unit Testing Domain Models-Value Objects and Entities\n\ndataclasses for value objects, Dataclasses Are Great for Value Objects\n\nvalue objects and entities, Value Objects and Entities\n\ndomain services, Not Everything Has to Be an Object: A Domain Service Function, Why Is Everything Called a Service?\n\nfunction for, Not Everything Has to Be an Object: A Domain Service Function\n\ndriven adapters, Putting Things in Folders to See Where It All Belongs\n\nduck typing, The Repository in the Abstract\n\nfor ports, What Is a Port and What Is an Adapter, in Python?\n\nE\n\nE2E tests (see end-to-end tests)\n\neager loading, SELECT N+1 and Other Performance Considerations\n\nedge-to-edge testing, Implementing Our Chosen Abstractions-Testing Edge to Edge with Fakes and Dependency Injection\n\nEffective Aggregate Design (Vernon), Wrap-Up\n\nemail alerts, sending when out of stock, Avoiding Making a Mess-Or the Service Layer!\n\nend-to-end tests\n\naiming for one test per feature, Wrap-Up\n\ndecoupling of service layer from domain, carrying through to, Carrying the Improvement Through to the E2E Tests\n\nof allocate API, A First End-to-End Test\n\nreplacement with unit tests, Why Not Just Patch It Out?\n\n__enter__ and __exit__ magic methods, Unit of Work and Its Context Manager, The Real Unit of Work Uses SQLAlchemy Sessions\n\nentities\n\ndefined, Value Objects and Entities\n\nidentity equality, Value Objects and Entities\n\nvalue objects versus, Exceptions Can Express Domain Concepts Too\n\nentrypoints, Putting Things in Folders to See Where It All Belongs\n\n__eq__magic method, Value Objects and Entities\n\nequality operators, implementing on entities, Value Objects and Entities\n\nerror handling\n\ncounting as a feature, Wrap-Up\n\nevents, commands, and, Discussion: Events, Commands, and Error Handling-Discussion: Events, Commands, and Error Handling\n\nin distributed systems, Error Handling in Distributed Systems- The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\nerrors, recovering from synchronously, Recovering from Errors Synchronously\n\nEvans, Eric, What Is an Aggregate?\n\nevent handlers\n\nimagined architecture in which everything is an event handler, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nin message bus, Message Bus Is Given Handlers at Runtime\n\nmanaging updates to read model, Changing Our Read Model Implementation Is Easy\n\nupdating read model table using, Time to Completely Jump the Shark\n\nevent storming, A New Requirement Leads Us to a New Architecture\n\nevent-driven architecture\n\ngoing to microservices via Strangler pattern, An Event-Driven Approach to Go to Microservices via Strangler Pattern-An Event-Driven Approach to Go to Microservices via Strangler Pattern\n\nusing events to integrate microservices, Event-Driven Architecture: Using Events to Integrate Microservices-Wrap-Up\n\nevents\n\nchanging schema over time, Footguns\n\ncommands versus, Commands and Events-Differences in Exception Handling\n\nevents, commands, and error handling, Discussion: Events, Commands, and Error Handling-Discussion: Events, Commands, and Error Handling\n\ninternal versus external, Internal Versus External Events\n\nsplitting command and events, trade-offs, Wrap-Up\n\nevents and the message bus, Events and the Message Bus-Wrap-Up\n\ndomain events and message bus recap, Wrap-Up\n\ndomain model raising events, The Model Raises Events\n\nevents as simple dataclasses, Events Are Simple Dataclasses\n\nevents flowing through the system, Events and the Message Bus\n\nmessage bus mapping events to handlers, The Message Bus Maps Events to Handlers\n\npros and cons or trade-offs, Wrap-Up\n\nrecording events, The Model Records Events\n\nsending email alerts when out of stock, Avoiding Making a Mess- Or the Service Layer!\n\navoiding messing up domain model, And Let’s Not Make a Mess of Our Model Either\n\navoiding messing up web controllers, First, Let’s Avoid Making a Mess of Our Web Controllers\n\nout of place in the service layer, Or the Service Layer!\n\nviolating the single responsibility principle, Single Responsibility Principle\n\nservice layer raising its own events, Option 2: The Service Layer Raises Its Own Events\n\nservice layer with explicit message bus, Option 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus\n\ntransforming our app into message processor, Going to Town on the Message Bus-Why Have We Achieved?\n\nimagined architecture, everything will be an event handler, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nimplementing the new requirement, Implementing Our New Requirement-Test-Driving a New Handler\n\nmodifying API to work with events, A Temporary Ugly Hack: The Message Bus Has to Return Results\n\nnew requirement and new architecture, A New Requirement Leads Us to a New Architecture\n\nrefactoring service functions to message handlers, Refactoring Service Functions to Message Handlers\n\ntemporary hack, message bus returning results, A Temporary Ugly Hack: The Message Bus Has to Return Results\n\ntest driving new handler, Test-Driving a New Handler\n\ntests writtern to in terms of events, Our Tests Are All Written in Terms of Events Too\n\nunit testing event handlers with fake message bus, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nwhole app as message bus, trade-offs, Why Have We Achieved?\n\nUoW publishes events to message bus, Option 3: The UoW Publishes Events to the Message Bus\n\neventually consistent reads, Most Users Aren’t Going to Buy Your Furniture\n\nexception handling, differences for events and commands, Differences in Exception Handling\n\nexceptions\n\nexpressing domain concepts, Exceptions Can Express Domain Concepts Too\n\nusing for control flow, The Model Raises Events\n\nexternal events, The Message Bus Maps Events to Handlers, Event- Driven Architecture: Using Events to Integrate Microservices-Wrap- Up\n\nextreme programming (XP), exhortation to listen to the code, On Deciding What Kind of Tests to Write\n\nF\n\nfaking\n\nFakeNotifications for unit testing, Make a Fake Version for Your Tests\n\nFakeRepository, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\nadding fixture function on, Mitigation: Keep All Domain Dependencies in Fixture Functions\n\nnew query type on, Implementation\n\nusing to unit test the service layer, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\nfakes versus mocks, Why Not Just Patch It Out?\n\nFakeSession, using to unit test the service layer, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\nFakeUnitOfWork for service layer testing, Fake Unit of Work for Testing\n\nfaking I/O in edge-to-edge test, Testing Edge to Edge with Fakes and Dependency Injection\n\ntweaking fakes in service layer to call super and implement underscorey methods, Option 3: The UoW Publishes Events to the Message Bus\n\nfilesystems\n\nwriting code to synchronize source and target directories, Abstracting State Aids Testability-Abstracting State Aids Testability\n\nchoosing right abstraction, Choosing the Right Abstraction(s)-Implementing Our Chosen Abstractions\n\nimplementing chosen abstraction, Implementing Our Chosen Abstractions-Wrap-Up\n\nfixture functions, keeping all domain dependencies in, Mitigation: Keep All Domain Dependencies in Fixture Functions\n\nFlask framework, Some Pseudocode: What Are We Going to Need?\n\nAPI endpoint, What Is the Trade-Off?\n\ncalling bootstrap in entrypoints, Using Bootstrap in Our Entrypoints\n\nendpoint for viewing allocations, Post/Redirect/Get and CQS\n\nFlask API and service layer, Our First Use Case: Flask API and Service Layer-The DIP in Action\n\napp delegating to service layer, A Typical Service Function\n\nconnecting the app to real world, Connecting Our Application to the Real World\n\ndifferent types of services, Why Is Everything Called a Service?\n\nend-to-end tests for happy and unhappy paths, A Typical Service Function\n\nerror conditions requiring database checks, Error Conditions That Require Database Checks\n\nfirst API end-to-end test, A First End-to-End Test-A First End-to-End Test\n\nfirst cut of the app, The Straightforward Implementation-The Straightforward Implementation\n\nintroducing service layer and fake repo to unit test it, Introducing a Service Layer, and Using FakeRepository to Unit Test It-A Typical Service Function\n\nputting project into folders, Putting Things in Folders to See Where It All Belongs\n\nservice layer benefits, Wrap-Up\n\nservice layer dependencies, The DIP in Action\n\nservice layer pros and cons, The DIP in Action\n\ntypical service layer function, A Typical Service Function\n\nputting API endpoint in front of allocate domain service, Connecting Our Application to the Real World\n\nFowler, Martin, Why Not Just Patch It Out?, Wrap-Up\n\nFreeman, Steve, Why Not Just Patch It Out?\n\nFunctional Core, Imperative Shell (FCIS), Implementing Our Chosen Abstractions\n\nfunctions, Exceptions Can Express Domain Concepts Too\n\nfor domain services, Not Everything Has to Be an Object: A Domain Service Function\n\nservice layer, A Typical Service Function\n\nG\n\n\"Global Complexity, Local Simplicity\" post, Wrap-Up\n\n__gt__ magic method, Python’s Magic Methods Let Us Use Our Models with Idiomatic Python\n\nH\n\nhandlers\n\nevent and command handlers in message bus, Message Bus Is Given Handlers at Runtime\n\nnew HANDLERS dicts for commands and events, Differences in Exception Handling\n\n__hash__ magic method, Value Objects and Entities\n\nhashing a file, Abstracting State Aids Testability\n\ndictionary of hashes to paths, Choosing the Right Abstraction(s)\n\nhoisting I/O, Why Not Just Patch It Out?\n\nI\n\nI/O\n\ndisentangling details from program logic, Implementing Our Chosen Abstractions\n\ndomain logic tightly coupled to, Abstracting State Aids Testability\n\nsimplifying interface with business logic using abstractions, Wrap-Up\n\nidempotent message handling, Footguns\n\nidentity equality (entities), Value Objects and Entities\n\nimplicit versus explicit commits, Explicit Versus Implicit Commits\n\nimporting dependenies, Aren’t Explicit Dependencies Totally Weird and Java-y?\n\ninheritance, avoiding use of with wrapper class, Option 3: The UoW Publishes Events to the Message Bus\n\nintegration tests\n\nfor concurrency behavior, Testing for Our Data Integrity Rules\n\ntest-driving Unit of Work with, Test-Driving a UoW with Integration Tests\n\ninterfaces, Python and, What Is a Port and What Is an Adapter, in Python?\n\ninvariants\n\ninvariants, concurrency, and locks, Invariants, Concurrency, and Locks\n\ninvariants, constraints, and consistency, Invariants, Constraints, and Consistency\n\nprotecting while allowing concurrency, What Is an Aggregate?\n\ninward-facing adapters, Putting Things in Folders to See Where It All Belongs\n\nisolation levels (transaction), Enforcing Concurrency Rules by Using Database Transaction Isolation Levels\n\nJ\n\nJung, Ed, Why Not Just Patch It Out?\n\nK\n\nkatas, A Brief Interlude: On Coupling and Abstractions\n\nL\n\nlayered architecture, Applying the DIP to Data Access\n\ncase study, layering an overgrown system, Separating Entangled Responsibilities\n\nlocks on database tables, Invariants, Concurrency, and Locks\n\noptimistic locking, Optimistic Concurrency with Version Numbers, Optimistic Concurrency with Version Numbers\n\npessimistic locking, Optimistic Concurrency with Version Numbers\n\nLondon-school versus classic-style TDD, Why Not Just Patch It Out?\n\nM\n\nmagic methods\n\nallowing use of domain model with idiomatic Python, Python’s Magic Methods Let Us Use Our Models with Idiomatic Python\n\n__enter__ and __exit__, Unit of Work and Its Context Manager\n\n__eq__, Value Objects and Entities\n\n__hash__, Value Objects and Entities\n\nMagicMock objects, Why Not Just Patch It Out?\n\nmappers, Inverting the Dependency: ORM Depends on Model\n\nmessage brokers, Using a Redis Pub/Sub Channel for Integration\n\nmessage bus\n\nabstract message bus and its real and fake versions, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nbefore, message buse as optional add-on, Going to Town on the Message Bus\n\nCelery and, The Message Bus Maps Events to Handlers\n\nclass given handlers at runtime, Message Bus Is Given Handlers at Runtime\n\ndispatching events and commands differently, Differences in Exception Handling\n\nevent and command handler logic staying the same, Message Bus Is Given Handlers at Runtime\n\ngetting custom with overridden bootstrap defaults, Initializing DI in Our Tests\n\nhandler publishing outgoing event, Our New Outgoing Event\n\nhandle_event method, Recovering from Errors Synchronously\n\nhandle_event with retries, Recovering from Errors Synchronously\n\nmapping events to handlers, The Message Bus Maps Events to Handlers\n\nnow collecting events from UoW, The Message Bus Now Collects Events from the UoW\n\nnow the main entrypoint to service layer, Going to Town on the Message Bus\n\npros and cons or trade-offs, Wrap-Up\n\nrecap, Wrap-Up\n\nRedis pub/sub listener as thin adapter around, Redis Is Another Thin Adapter Around Our Message Bus\n\nreturning results in temporary hack, A Temporary Ugly Hack: The Message Bus Has to Return Results\n\nservice layer raising events and calling messagebus.handle, Option 2: The Service Layer Raises Its Own Events\n\nservice layer with explicit message bus, Option 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus\n\nUnit of Work publishing events to, Option 3: The UoW Publishes Events to the Message Bus\n\nunit testing event handlers with fake message bus, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nwhole app as, trade-offs, Why Have We Achieved?\n\nwiring up new event handlers to, A New Method on the Domain Model\n\nMessage Bus pattern, Events and the Message Bus\n\nmessaging\n\nasynchronous, temporal decoupling with, The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\nidempotent message handling, Footguns\n\nreliable messaging is hard, Footguns\n\nusing Redis pub/sub channel for microservices integration, Using a Redis Pub/Sub Channel for Integration\n\nmicroservices\n\nbounded contexts and, Choosing an Aggregate\n\nevent-based integration, Event-Driven Architecture: Using Events to Integrate Microservices-Wrap-Up\n\ndistributed Ball of Mud and thinking in nouns, Distributed Ball of Mud, and Thinking in Nouns-Distributed Ball of Mud, and Thinking in Nouns\n\nerror handling in distributed systems, Error Handling in Distributed Systems-The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\ntemporal decoupling using asynchronous messaging, The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\ntesting with end-to-end test, Test-Driving It All Using an End-to-End Test-Internal Versus External Events\n\ntrade-offs, Wrap-Up\n\nusing Redis pub/sub channel for ntegration, Using a Redis Pub/Sub Channel for Integration\n\nevent-driven approach, using Strangler pattern, An Event-Driven Approach to Go to Microservices via Strangler Pattern-An Event-Driven Approach to Go to Microservices via Strangler Pattern\n\nminimum viable product, Persisting Our Domain Model\n\nmock.patch method, Why Not Just Patch It Out?, Aren’t Explicit Dependencies Totally Weird and Java-y?\n\nmocking\n\navoiding use of mock.patch, Why Not Just Patch It Out?\n\ndon't mock what you don't own, Fake Unit of Work for Testing\n\nmocks versus fakes, Why Not Just Patch It Out?\n\novermocked tests, pitfalls of, Why Not Just Patch It Out?\n\n\"Mocks Aren't Stubs\" (Fowler), Why Not Just Patch It Out?\n\nmodel (domain), What Is a Domain Model?\n\nN\n\nnamed tuples, Dataclasses Are Great for Value Objects\n\n(see also dataclasses)\n\nnouns, splitting system into, Distributed Ball of Mud, and Thinking in Nouns-Distributed Ball of Mud, and Thinking in Nouns\n\nO\n\nobject neighborhoods, The Unit of Work Collaborates with the Repository\n\nobject-oriented composition, Why Not Just Patch It Out?\n\nobject-oriented design principles, Exceptions Can Express Domain Concepts Too\n\nobject-relational mappers (ORMs), The “Normal” ORM Way: Model Depends on ORM\n\nassociating right batches with Product objects, One Aggregate = One Repository\n\nDjango ORM example, The “Normal” ORM Way: Model Depends on ORM\n\nDjango, custom methods to translate to/from domain model, Custom Methods on Django ORM Classes to Translate to/from Our Domain Model\n\nORM depends on the data model, Inverting the Dependency: ORM Depends on Model\n\ntesting the ORM, Inverting the Dependency: ORM Depends on Model\n\norm.start_mappers function, A Bootstrap Script\n\nRepository pattern and, What Is the Trade-Off?\n\nSELECT N+1 performance problem, SELECT N+1 and Other Performance Considerations\n\nsimple view using the ORM, “Obvious” Alternative 2: Using the ORM\n\nSQLAlchemy, model depends on ORM, The “Normal” ORM Way: Model Depends on ORM\n\nonion architecture, Applying the DIP to Data Access\n\noptimistic concurrency with version numbers, Optimistic Concurrency with Version Numbers-Implementation Options for Version Numbers\n\norchestration, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\nchanging to choreography, Single Responsibility Principle\n\nusing application service, Why Is Everything Called a Service?\n\norchestration layer (see service layer)\n\nOutbox pattern, Footguns\n\nP\n\npartial functions\n\ndependency injection with, Preparing Handlers: Manual DI with Closures and Partials\n\ndifference from closures, Preparing Handlers: Manual DI with Closures and Partials\n\nmanually creating inline, A Bootstrap Script\n\npatterns, deciding whether you need to use them, Part I Recap\n\nPEP 544 protocols, The Repository in the Abstract\n\nperformance\n\nconsistency boundaries and, Aggregates and Consistency Boundaries, Wrap-Up\n\nimpact of using aggregates, Choosing an Aggregate, What About Performance?\n\npersistence ignorance, The “Normal” ORM Way: Model Depends on ORM\n\ntrade-offs, Wrap-Up\n\npessimistic concurrency, Optimistic Concurrency with Version Numbers\n\nexample, SELECT FOR UPDATE, Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nports\n\ndefined, What Is a Port and What Is an Adapter, in Python?\n\nports-and-adapters inspired patterns, Part I Recap\n\nputting in folder with adapters, Putting Things in Folders to See Where It All Belongs\n\nPost/Redirect/Get pattern, Post/Redirect/Get and CQS\n\ncommand-query separation (CQS), Post/Redirect/Get and CQS\n\nPostgreSQL\n\nAnti-Patterns: Read-Modify-Write Cycles, Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\ndocumentation for transaction isolation levels, Enforcing Concurrency Rules by Using Database Transaction Isolation\n\nLevels\n\nmanaging concurrency issues, Optimistic Concurrency with Version Numbers\n\nSERIALIZABLE transaction isolation level, Optimistic Concurrency with Version Numbers\n\npreparatory refactoring workflow, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nprimitives\n\nmoving from domain objects to, in service layer, Refactoring Service Functions to Message Handlers\n\nprimitive obsession, Refactoring Service Functions to Message Handlers\n\nProduct object, Aggregates and Consistency Boundaries\n\nacting as consistency boundary, Discussion: Events, Commands, and Error Handling\n\nasking Product to allocate against its batches, Choosing an Aggregate\n\ncode for, Choosing an Aggregate\n\nservice layer using, One Aggregate = One Repository\n\ntwo transactions attempting concurrent update on, Optimistic Concurrency with Version Numbers\n\nversion numbers implemented on, Implementation Options for Version Numbers\n\nProductRepository object, One Aggregate = One Repository\n\nprojects\n\norganizing into folders, Putting Things in Folders to See Where It All Belongs\n\ntemplate project structure, A Template Project Structure-Wrap- Up\n\nprotocols, abstract base classes, duck typing, and, The Repository in the Abstract\n\npublish-subscribe system\n\nmessage bus as\n\nhandlers subscribed to receive events, The Message Bus Maps Events to Handlers\n\npublishing step, Option 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus\n\nusing Redis pub/sub channel for microservices integration, Using a Redis Pub/Sub Channel for Integration\n\nPyCon talk on Mocking Pitfalls, Why Not Just Patch It Out?\n\npytest\n\n@pytest.skip, What About Performance?\n\nfixtures, Abstracting State Aids Testability\n\npytest-django plug-in, Repository Pattern with Django, Why Was This All So Hard?\n\nsession argument, Inverting the Dependency: ORM Depends on Model\n\nQ\n\nqueries, Command-Query Responsibility Segregation (CQRS)\n\n(see also command-query responsibility segregation)\n\nquestions from tech reviewers, Questions Our Tech Reviewers Asked That We Couldn’t Work into Prose-Footguns\n\nR\n\nread-modify-write failure mode, Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nreallocate service function, Example 1: Reallocate\n\nreallocation\n\nsequence diagram for flow, Implementing Our New Requirement\n\ntesting in isolation using fake message bus, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nRedis pub/sub channel, using for microservices integration, Using a Redis Pub/Sub Channel for Integration\n\ntesting pub/sub model, Test-Driving It All Using an End-to-End Test\n\npublishing outgoing event, Our New Outgoing Event\n\nRedis as thin adapter around message bus, Redis Is Another Thin Adapter Around Our Message Bus\n\nRedis, changing read model implementation to use, Changing Our Read Model Implementation Is Easy\n\nrepositories\n\nadding list method to existing repository object, Hold On to Your Lunch, Folks\n\nCSV-based repository, Implementing a Repository and Unit of Work for CSVs\n\nnew query type on our repository, Implementation\n\none aggregrate = one repository, One Aggregate = One Repository\n\nrepository keeping track of aggregates passing through it, Option 3: The UoW Publishes Events to the Message Bus\n\nservice layer function depending on abstract repository, A Typical Service Function\n\nsimple view using existing repository, “Obvious” Alternative 1: Using the Existing Repository\n\nTrackerRepository wrapper class, Option 3: The UoW Publishes Events to the Message Bus\n\nUnit of Work collaborating with, The Unit of Work Collaborates with the Repository\n\nRepository pattern, Repository Pattern, Introducing the Repository Pattern-Wrap-Up\n\nand persistence ignorance, trade-offs, Wrap-Up\n\nbuilding fake repository for tests, Building a Fake Repository for Tests Is Now Trivial!\n\nORMs and, What Is the Trade-Off?\n\nrecap of important points, Wrap-Up\n\nsimplest possible repository, The Repository in the Abstract\n\ntesting the repository with retrieving a complex object, What Is the Trade-Off?\n\ntesting the repository with saving an object, What Is the Trade- Off?\n\ntrade-offs, What Is the Trade-Off?\n\ntypical repository, What Is the Trade-Off?\n\nusing repository directly in API endpoint, What Is the Trade-Off?\n\nwith Django, Repository Pattern with Django-Custom Methods on Django ORM Classes to Translate to/from Our Domain Model\n\nresources, additional required reading, More Required Reading\n\nresponsibilities of code, Choosing the Right Abstraction(s)\n\nseparating responsibilities, Separating Entangled Responsibilities\n\ncase study, layering overgrown system, Separating Entangled Responsibilities\n\nretries\n\nmessage bus handle_event with, Recovering from Errors Synchronously\n\noptimistic concurrency control and, Optimistic Concurrency with Version Numbers\n\nTenacity library for, Recovering from Errors Synchronously\n\nRhodes, Brandon, Why Not Just Patch It Out?\n\nrollbacks, Unit of Work and Its Context Manager\n\nexplicit tests for, Explicit Tests for Commit/Rollback Behavior\n\nrollback method, The Real Unit of Work Uses SQLAlchemy Sessions\n\nS\n\nseams, Wrap-Up\n\nsecondary adapters, Putting Things in Folders to See Where It All Belongs\n\nSeemann, Mark, blog post, Applying the DIP to Data Access\n\nSELECT * FROM WHERE queries, Time to Completely Jump the Shark\n\nSELECT FOR UPDATE statement, Optimistic Concurrency with Version Numbers\n\npessimistic concurrency control example with, Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nSELECT N+1, SELECT N+1 and Other Performance Considerations\n\nservice functions\n\nmaking them event handlers, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nrefactoring to message handlers, Refactoring Service Functions to Message Handlers\n\nservice layer, Our First Use Case: Flask API and Service Layer-The DIP in Action\n\nbenefits of, Wrap-Up\n\nbenefits to test-driven development, Wrap-Up\n\nconnecting our application to real world, Connecting Our Application to the Real World\n\ndependencies of, The DIP in Action\n\nreal dependencies at runtime, The DIP in Action\n\ntesting, The DIP in Action\n\ndifference between domain service and, Why Is Everything Called a Service?\n\ndomain layer tests moving to, Should Domain Layer Tests Move to the Service Layer?\n\nreasons for, Should Domain Layer Tests Move to the Service Layer?\n\nend-to-end test of allocate API, testing happy and unhappy paths, A Typical Service Function\n\nerror conditions requiring database checks in Flask app, Error Conditions That Require Database Checks\n\nfirst cut of Flask app, The Straightforward Implementation-The Straightforward Implementation\n\nFlask app delegating to, A Typical Service Function\n\nfrom domain objects to primitives to events as interface, Refactoring Service Functions to Message Handlers\n\nfully decoupling from the domain, Fully Decoupling the Service- Layer Tests from the Domain-Adding a Missing Service\n\nintroducing and using FakeRepository to unit test it, Introducing a Service Layer, and Using FakeRepository to Unit Test It-Why Is Everything Called a Service?\n\nmessage bus as main entrypoint, Going to Town on the Message Bus\n\npros and cons or trade-offs, The DIP in Action\n\nputting project in folders, Putting Things in Folders to See Where It All Belongs\n\nraising events and passing them to message bus, Wrap-Up\n\nraising its own events, Option 2: The Service Layer Raises Its Own Events\n\nsending email alerts when out of stock, avoiding, Or the Service Layer!\n\ntaking events from model and putting them on message bus, Option 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus\n\ntotally free of event handling concerns, Option 3: The UoW Publishes Events to the Message Bus\n\ntweaking fakes in to call super and implement underscorey methods, Option 3: The UoW Publishes Events to the Message Bus\n\ntypical service function, A Typical Service Function\n\nusing Product objects, One Aggregate = One Repository\n\nusing Unit of Work in, Using the UoW in the Service Layer\n\nusing, test pyramid and, How Is Our Test Pyramid Looking?\n\nwriting bulk of tests against, Wrap-Up\n\nwriting tests against, High and Low Gear\n\nservice-layer services vs. domain services, Not Everything Has to Be an Object: A Domain Service Function\n\nservices\n\napplication service and domain service, Why Is Everything Called a Service?\n\nservice layer tests only using services, Adding a Missing Service\n\nSession object, Wrap-Up\n\nset, fake repository as wrapper around, Building a Fake Repository for Tests Is Now Trivial!\n\nsimplifying abstractions, Choosing the Right Abstraction(s)\n\nsingle responsibility principle (SRP), Single Responsibility Principle\n\nSingleton pattern, messagebus.py implementing, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nsituated software, A New Requirement Leads Us to a New Architecture\n\nSoftware Engineering Stack Exchange site, Why Not Just Patch It Out?\n\nspreadsheets, using instead of domain model, Why Not Just Run Everything in a Spreadsheet?\n\nspy objects, Testing Edge to Edge with Fakes and Dependency Injection\n\nSQL\n\ngenerating for domain model objects, The “Normal” ORM Way: Model Depends on ORM\n\nhelpers for Unit of Work, Test-Driving a UoW with Integration Tests\n\nORM and Repository pattern as abstractions in front of, What Is the Trade-Off?\n\nraw SQL in views, Hold On to Your Lunch, Folks\n\nrepository test for retrieving complex object, What Is the Trade- Off?\n\nrepository test for saving an object, What Is the Trade-Off?\n\nSQLAlchemy\n\ndatabase session for Unit of Work, The Real Unit of Work Uses SQLAlchemy Sessions\n\nnot mocking, Fake Unit of Work for Testing\n\ndeclarative syntax, model depends on ORM, The “Normal” ORM Way: Model Depends on ORM\n\nexplicit ORM mapping with SQLAlchemy Table objects, Inverting the Dependency: ORM Depends on Model\n\nSELECT N+1 problem and, SELECT N+1 and Other Performance Considerations\n\nSession object, Wrap-Up\n\nusing directly in API endpoint, Inverting the Dependency: ORM Depends on Model\n\nusing DSL to specify FOR UPDATE, Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nstakeholders, convincing to try something new, Convincing Your Stakeholders to Try Something New-Questions Our Tech Reviewers Asked That We Couldn’t Work into Prose\n\nstate\n\nabstracting to aid testability, Abstracting State Aids Testability- Abstracting State Aids Testability\n\nsplitting off from logic in the program, Implementing Our Chosen Abstractions\n\nstorage, Repository Pattern\n\n(see also repositories; Repository pattern)\n\npermanent, UoW providing entrypoint to, The Unit of Work Collaborates with the Repository\n\nStrangler pattern, going to microservices via, An Event-Driven Approach to Go to Microservices via Strangler Pattern-An Event- Driven Approach to Go to Microservices via Strangler Pattern\n\nstubbing, mocks and stubs, Why Not Just Patch It Out?\n\nsuper function, Option 3: The UoW Publishes Events to the Message Bus\n\ntweaking fakes in service layer to call, Option 3: The UoW Publishes Events to the Message Bus\n\nsynchronous execution of event-handling code, Wrap-Up\n\nT\n\ntemporal coupling, Error Handling in Distributed Systems\n\ntemporal decoupling using asynchronous messaging, The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\nTenacity library, Recovering from Errors Synchronously\n\ntest doubles\n\nmocks versus fakes, Why Not Just Patch It Out?\n\nmocks versus stubs, Why Not Just Patch It Out?\n\nusing lists to build, Testing Edge to Edge with Fakes and Dependency Injection\n\n\"Test-Driven Development: That's Not What We Meant\", Why Not Just Patch It Out?\n\ntest-driven development (TDD), TDD in High Gear and Low Gear- Wrap-Up\n\nbenefits of service layer to, Wrap-Up\n\nclassic versus London-school, Why Not Just Patch It Out?\n\ndeciding what kinds of tests to write, On Deciding What Kind of Tests to Write\n\ndomain layer tests moving to service layer, Should Domain Layer Tests Move to the Service Layer?\n\nfully decoupling service layer from the domain, Fully Decoupling the Service-Layer Tests from the Domain-Adding a Missing Service\n\nadding missing service, Adding a Missing Service\n\ncarrying improvement through to E2E tests, Carrying the Improvement Through to the E2E Tests\n\nkeeping all domain dependencies in fixture functions, Mitigation: Keep All Domain Dependencies in Fixture Functions\n\nhigh and low gear, High and Low Gear\n\ntest pyramid with service layer added, How Is Our Test Pyramid Looking?\n\ntest pyramid, examining, TDD in High Gear and Low Gear\n\ntypes of tests, rules of thumb for, Wrap-Up\n\nunit tests operating at lower level, acting directly on model, TDD in High Gear and Low Gear\n\ntesting\n\nabstracting state to aid testability, Abstracting State Aids Testability-Abstracting State Aids Testability\n\nafter implementing chosen abstraction, Implementing Our Chosen Abstractions-Wrap-Up\n\navoiding use of mock.patch, Why Not Just Patch It Out?- Wrap-Up\n\nedge-to-edge testing with fakes and dependency injection, Testing Edge to Edge with Fakes and Dependency Injection- Testing Edge to Edge with Fakes and Dependency Injection\n\nend-to-end test of pub/sub model, Test-Driving It All Using an End-to-End Test\n\nfake database session at service layer, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\nfake UoW for service layer testing, Fake Unit of Work for Testing\n\nfor data integrity rules, Testing for Our Data Integrity Rules- Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nintegration test for CQRS view, Testing CQRS Views\n\nintegration test for overriding bootstrap defaults, Initializing DI in Our Tests\n\nintegration tests for rollback behavior, Explicit Tests for Commit/Rollback Behavior\n\ntests folder tree, Tests\n\ntests written in terms of events, Our Tests Are All Written in Terms of Events Too\n\nhandler tests for change_batch_quantity, Test-Driving a New Handler\n\nunit testing event handlers with fake message bus, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nUnit of Work with integration tests, Test-Driving a UoW with Integration Tests\n\ntidying up tests, Tidying Up the Integration Tests\n\nunit test for bootstrap, Initializing DI in Our Tests\n\nunit testing with fakes at service layer, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\ntime.sleep function, Testing for Our Data Integrity Rules\n\nreproducing concurrency behavior with, Testing for Our Data Integrity Rules\n\ntransactions\n\nconcurrent, attempting update on Product, Optimistic Concurrency with Version Numbers\n\nsimulating a slow transaction, Testing for Our Data Integrity Rules\n\nUnit of Work and, Wrap-Up\n\nusing to enforce concurrency rules, Enforcing Concurrency Rules by Using Database Transaction Isolation Levels\n\ntype hints, Unit Testing Domain Models, Unit Testing Domain Models\n\nU\n\nunderscorey methods\n\navoiding by implementing TrackingRepository wrapper class, Option 3: The UoW Publishes Events to the Message Bus\n\ntweaking fakes in service layer to implement, Option 3: The UoW Publishes Events to the Message Bus\n\nUnit of Work pattern, The Repository in the Abstract, Unit of Work Pattern-Wrap-Up\n\nand its context manager, Unit of Work and Its Context Manager\n\nfake UoW for testing, Fake Unit of Work for Testing\n\nreal UoW using SQLAlchemy session, The Real Unit of Work Uses SQLAlchemy Sessions\n\nbenefits of using, Wrap-Up\n\ncollaboration with repository, The Unit of Work Collaborates with the Repository\n\nexplicit tests for commit/rollback behavior, Explicit Tests for Commit/Rollback Behavior\n\nexplicit versus implicit commits, Explicit Versus Implicit Commits\n\nfake message bus implemented in UoW, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\ngetting rid of underscorey methods in UoW class, Option 3: The UoW Publishes Events to the Message Bus\n\nmanaging database state, Unit of Work Pattern\n\nmessage bus now collecting events from UoW, The Message Bus Now Collects Events from the UoW\n\nmodifying to connect domain events and message bus, Events and the Message Bus\n\npros and cons or trade-offs, Wrap-Up\n\nrecap of important points, Wrap-Up\n\nsplitting operations across two UoWs, Implementing Our New Requirement\n\ntest driving with integration tests, Test-Driving a UoW with Integration Tests\n\ntidying up integration tests, Tidying Up the Integration Tests\n\nUoW and product repository, One Aggregate = One Repository\n\nUoW collecting events from aggregates and passing them to message bus, Wrap-Up\n\nUoW for CSVs, Implementing a Repository and Unit of Work for CSVs\n\nUoW managing success or failure of aggregate update, Discussion: Events, Commands, and Error Handling\n\nUoW publishing events to message bus, Option 3: The UoW Publishes Events to the Message Bus\n\nusing UoW in service layer, Using the UoW in the Service Layer\n\nusing UoW to group multiple operations into atomic unit, Examples: Using UoW to Group Multiple Operations into an Atomic Unit-Example 2: Change Batch Quantity\n\nchanging batch quantity example, Example 2: Change Batch Quantity\n\nreallocate function example, Example 1: Reallocate\n\nwith Django, Unit of Work Pattern with Django-Unit of Work Pattern with Django\n\nwithout, API talking directly to three layers, Unit of Work Pattern\n\nunit testing, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\n(see also test-driven development; testing)\n\nof domain models, Unit Testing Domain Models-Value Objects and Entities\n\nunit tests replacing end-to-end tests, Why Not Just Patch It Out?\n\nunittest.mock function, Why Not Just Patch It Out?\n\nUoW (see Unit of Work pattern)\n\nuse-case layer (see service layer)\n\nV\n\nvalidation, Validation-Validating Pragmatics\n\nvalue objects\n\ndefined, Dataclasses Are Great for Value Objects\n\nand entities, Value Objects and Entities\n\nentities versus, Exceptions Can Express Domain Concepts Too\n\nmath with, Dataclasses Are Great for Value Objects\n\nusing dataclasses for, Dataclasses Are Great for Value Objects\n\nVens, Rob, Wrap-Up\n\nVernon, Vaughn, Wrap-Up\n\nversion numbers\n\nimplementation options for, Implementation Options for Version Numbers\n\nin the products table, implementing optimistic locking, Optimistic Concurrency with Version Numbers\n\nviews\n\nDjango views as adapters, API: Django Views Are Adapters\n\nkeeping totally separate, denormalized datastore for view model, Time to Completely Jump the Shark\n\nread-only, Post/Redirect/Get and CQS\n\nrebuilding view model from scratch, Updating a Read Model Table Using an Event Handler\n\nsimple view that uses the ORM, “Obvious” Alternative 2: Using the ORM\n\nsimple view that uses the repository, “Obvious” Alternative 1: Using the Existing Repository\n\ntesting CQRS views, Testing CQRS Views\n\ntrade-offs for view model options, Wrap-Up\n\nupdating read model table using event handler, Time to Completely Jump the Shark\n\nW\n\nweb controllers, sending email alerts via, avoiding, Avoiding Making a Mess\n\nAbout the Authors\n\nHarry Percival spent a few years being deeply unhappy as a management consultant. Soon he rediscovered his true geek nature and was lucky enough to fall in with a bunch of XP fanatics, working on\n\npioneering the sadly defunct Resolver One spreadsheet. He worked at PythonAnywhere LLP, spreading the gospel of TDD worldwide at talks, workshops, and conferences. He is now with MADE.com.\n\nBob Gregory is a UK-based software architect with MADE.com. He has been building event-driven systems with domain-driven design for\n\nmore than a decade.\n\nColophon\n\nThe animal on the cover of Architecture Patterns with Python is a Burmese python (Python bivitattus). As you might expect, the Burmese python is native to Southeast Asia. Today it lives in jungles and\n\nmarshes in South Asia, Myanmar, China, and Indonesia; it’s also invasive in Florida’s Everglades.\n\nBurmese pythons are one of the world’s largest species of snakes. These nocturnal, carnivorous constrictors can grow to 23 feet and 200 pounds. Females are larger than males. They can lay up to a hundred\n\neggs in one clutch. In the wild, Burmese pythons live an average of 20 to 25 years.\n\nThe markings on a Burmese python begin with an arrow-shaped spot of light brown on top of the head and continue along the body in\n\nrectangles that stand out against its otherwise tan scales. Before they reach their full size, which takes two to three years, Burmese pythons\n\nlive in trees hunting small mammals and birds. They also swim for long stretches of time—going up to 30 minutes without air.\n\nBecause of habitat destruction, the Burmese python has a conservation\n\nstatus of Vulnerable. Many of the animals on O’Reilly’s covers are\n\nendangered; all of them are important to the world.\n\nThe color illustration is by Jose Marzan, based on a black-and-white\n\nengraving from Encyclopedie D’Histoire Naturelle. The cover fonts are URW Typewriter and Guardian Sans. The text font is Adobe\n\nMinion Pro; the heading font is Adobe Myriad Condensed; and the code font is Dalton Maag’s Ubuntu Mono.",
      "page_number": 335
    }
  ],
  "pages": [
    {
      "page_number": 2,
      "content": "1. Preface\n\na. Managing Complexity, Solving Business\n\nProblems\n\nb. Why Python?\n\nc. TDD, DDD, and Event-Driven Architecture\n\nd. Who Should Read This Book\n\ne. A Brief Overview of What You’ll Learn\n\ni. Part I, Building an Architecture to\n\nSupport Domain Modeling\n\nii. Part II, Event-Driven Architecture\n\niii. Addtional Content\n\nf. Example Code and Coding Along\n\ng. License\n\nh. Conventions Used in This Book\n\ni. O’Reilly Online Learning\n\nj. How to Contact O’Reilly\n\nk. Acknowledgments\n\n2. Introduction\n\na. Why Do Our Designs Go Wrong?\n\nb. Encapsulation and Abstractions\n\nc. Layering\n\nd. The Dependency Inversion Principle",
      "content_length": 617,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 3,
      "content": "e. A Place for All Our Business Logic: The\n\nDomain Model\n\n3. I. Building an Architecture to Support Domain Modeling\n\n4. 1. Domain Modeling\n\na. What Is a Domain Model?\n\nb. Exploring the Domain Language\n\nc. Unit Testing Domain Models\n\ni. Dataclasses Are Great for Value\n\nObjects\n\nii. Value Objects and Entities\n\nd. Not Everything Has to Be an Object: A Domain\n\nService Function\n\ni. Python’s Magic Methods Let Us Use Our Models with Idiomatic Python\n\nii. Exceptions Can Express Domain\n\nConcepts Too\n\n5. 2. Repository Pattern\n\na. Persisting Our Domain Model\n\nb. Some Pseudocode: What Are We Going to\n\nNeed?\n\nc. Applying the DIP to Data Access\n\nd. Reminder: Our Model\n\ni. The “Normal” ORM Way: Model\n\nDepends on ORM",
      "content_length": 710,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 4,
      "content": "ii. Inverting the Dependency: ORM\n\nDepends on Model\n\ne. Introducing the Repository Pattern\n\ni. The Repository in the Abstract\n\nii. What Is the Trade-Off?\n\nf. Building a Fake Repository for Tests Is Now\n\nTrivial!\n\ng. What Is a Port and What Is an Adapter, in\n\nPython?\n\nh. Wrap-Up\n\n6. 3. A Brief Interlude: On Coupling and Abstractions\n\na. Abstracting State Aids Testability\n\nb. Choosing the Right Abstraction(s)\n\nc. Implementing Our Chosen Abstractions\n\ni. Testing Edge to Edge with Fakes and\n\nDependency Injection\n\nii. Why Not Just Patch It Out?\n\nd. Wrap-Up\n\n7. 4. Our First Use Case: Flask API and Service Layer\n\na. Connecting Our Application to the Real World\n\nb. A First End-to-End Test\n\nc. The Straightforward Implementation\n\nd. Error Conditions That Require Database\n\nChecks",
      "content_length": 779,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 5,
      "content": "e. Introducing a Service Layer, and Using\n\nFakeRepository to Unit Test It\n\ni. A Typical Service Function\n\nf. Why Is Everything Called a Service?\n\ng. Putting Things in Folders to See Where It All\n\nBelongs\n\nh. Wrap-Up\n\ni. The DIP in Action\n\n8. 5. TDD in High Gear and Low Gear\n\na. How Is Our Test Pyramid Looking?\n\nb. Should Domain Layer Tests Move to the\n\nService Layer?\n\nc. On Deciding What Kind of Tests to Write\n\nd. High and Low Gear\n\ne. Fully Decoupling the Service-Layer Tests from\n\nthe Domain\n\ni. Mitigation: Keep All Domain\n\nDependencies in Fixture Functions\n\nii. Adding a Missing Service\n\nf. Carrying the Improvement Through to the E2E\n\nTests\n\ng. Wrap-Up\n\n9. 6. Unit of Work Pattern\n\na. The Unit of Work Collaborates with the\n\nRepository",
      "content_length": 744,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 6,
      "content": "b. Test-Driving a UoW with Integration Tests\n\nc. Unit of Work and Its Context Manager\n\ni. The Real Unit of Work Uses\n\nSQLAlchemy Sessions\n\nii. Fake Unit of Work for Testing\n\nd. Using the UoW in the Service Layer\n\ne. Explicit Tests for Commit/Rollback Behavior\n\nf. Explicit Versus Implicit Commits\n\ng. Examples: Using UoW to Group Multiple\n\nOperations into an Atomic Unit\n\ni. Example 1: Reallocate\n\nii. Example 2: Change Batch Quantity\n\nh. Tidying Up the Integration Tests\n\ni. Wrap-Up\n\n10. 7. Aggregates and Consistency Boundaries\n\na. Why Not Just Run Everything in a\n\nSpreadsheet?\n\nb. Invariants, Constraints, and Consistency\n\ni. Invariants, Concurrency, and Locks\n\nc. What Is an Aggregate?\n\nd. Choosing an Aggregate\n\ne. One Aggregate = One Repository\n\nf. What About Performance?",
      "content_length": 779,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 7,
      "content": "g. Optimistic Concurrency with Version Numbers\n\ni. Implementation Options for Version\n\nNumbers\n\nh. Testing for Our Data Integrity Rules\n\ni. Enforcing Concurrency Rules by Using Database Transaction Isolation Levels\n\nii. Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\ni. Wrap-Up\n\nj. Part I Recap\n\n11. II. Event-Driven Architecture\n\n12. 8. Events and the Message Bus\n\na. Avoiding Making a Mess\n\ni. First, Let’s Avoid Making a Mess of\n\nOur Web Controllers\n\nii. And Let’s Not Make a Mess of Our\n\nModel Either\n\niii. Or the Service Layer!\n\nb. Single Responsibility Principle\n\nc. All Aboard the Message Bus!\n\ni. The Model Records Events\n\nii. Events Are Simple Dataclasses\n\niii. The Model Raises Events",
      "content_length": 707,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 8,
      "content": "iv. The Message Bus Maps Events to\n\nHandlers\n\nd. Option 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus\n\ne. Option 2: The Service Layer Raises Its Own\n\nEvents\n\nf. Option 3: The UoW Publishes Events to the\n\nMessage Bus\n\ng. Wrap-Up\n\n13. 9. Going to Town on the Message Bus\n\na. A New Requirement Leads Us to a New\n\nArchitecture\n\ni. Imagining an Architecture Change:\n\nEverything Will Be an Event Handler\n\nb. Refactoring Service Functions to Message\n\nHandlers\n\ni. The Message Bus Now Collects Events\n\nfrom the UoW\n\nii. Our Tests Are All Written in Terms of\n\nEvents Too\n\niii. A Temporary Ugly Hack: The Message\n\nBus Has to Return Results\n\niv. Modifying Our API to Work with\n\nEvents\n\nc. Implementing Our New Requirement\n\ni. Our New Event",
      "content_length": 764,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 9,
      "content": "d. Test-Driving a New Handler\n\ni. Implementation\n\nii. A New Method on the Domain Model\n\ne. Optionally: Unit Testing Event Handlers in\n\nIsolation with a Fake Message Bus\n\nf. Wrap-Up\n\ni. What Have We Achieved?\n\nii. Why Have We Achieved?\n\n14. 10. Commands and Command Handler\n\na. Commands and Events\n\nb. Differences in Exception Handling\n\nc. Discussion: Events, Commands, and Error\n\nHandling\n\nd. Recovering from Errors Synchronously\n\ne. Wrap-Up\n\n15. 11. Event-Driven Architecture: Using Events to Integrate Microservices\n\na. Distributed Ball of Mud, and Thinking in\n\nNouns\n\nb. Error Handling in Distributed Systems\n\nc. The Alternative: Temporal Decoupling Using\n\nAsynchronous Messaging\n\nd. Using a Redis Pub/Sub Channel for\n\nIntegration",
      "content_length": 733,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 10,
      "content": "e. Test-Driving It All Using an End-to-End Test\n\ni. Redis Is Another Thin Adapter Around\n\nOur Message Bus\n\nii. Our New Outgoing Event\n\nf. Internal Versus External Events\n\ng. Wrap-Up\n\n16. 12. Command-Query Responsibility Segregation (CQRS)\n\na. Domain Models Are for Writing\n\nb. Most Users Aren’t Going to Buy Your\n\nFurniture\n\nc. Post/Redirect/Get and CQS\n\nd. Hold On to Your Lunch, Folks\n\ne. Testing CQRS Views\n\nf. “Obvious” Alternative 1: Using the Existing\n\nRepository\n\ng. Your Domain Model Is Not Optimized for\n\nRead Operations\n\nh. “Obvious” Alternative 2: Using the ORM\n\ni. SELECT N+1 and Other Performance\n\nConsiderations\n\nj. Time to Completely Jump the Shark\n\ni. Updating a Read Model Table Using an\n\nEvent Handler",
      "content_length": 719,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 11,
      "content": "k. Changing Our Read Model Implementation Is\n\nEasy\n\nl. Wrap-Up\n\n17. 13. Dependency Injection (and Bootstrapping)\n\na. Implicit Versus Explicit Dependencies\n\nb. Aren’t Explicit Dependencies Totally Weird\n\nand Java-y?\n\nc. Preparing Handlers: Manual DI with Closures\n\nand Partials\n\nd. An Alternative Using Classes\n\ne. A Bootstrap Script\n\nf. Message Bus Is Given Handlers at Runtime\n\ng. Using Bootstrap in Our Entrypoints\n\nh. Initializing DI in Our Tests\n\ni. Building an Adapter “Properly”: A Worked\n\nExample\n\ni. Define the Abstract and Concrete\n\nImplementations\n\nii. Make a Fake Version for Your Tests\n\niii. Figure Out How to Integration Test the\n\nReal Thing\n\nj. Wrap-Up\n\n18. Epilogue\n\na. What Now?",
      "content_length": 694,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 12,
      "content": "b. How Do I Get There from Here?\n\nc. Separating Entangled Responsibilities\n\nd. Identifying Aggregates and Bounded Contexts\n\ne. An Event-Driven Approach to Go to Microservices via Strangler Pattern\n\nf. Convincing Your Stakeholders to Try\n\nSomething New\n\ng. Questions Our Tech Reviewers Asked That We\n\nCouldn’t Work into Prose\n\nh. Footguns\n\ni. More Required Reading\n\nj. Wrap-Up\n\n19. A. Summary Diagram and Table\n\n20. B. A Template Project Structure\n\na. Env Vars, 12-Factor, and Config, Inside and\n\nOutside Containers\n\nb. Config.py\n\nc. Docker-Compose and Containers Config\n\nd. Installing Your Source as a Package\n\ne. Dockerfile\n\nf. Tests\n\ng. Wrap-Up\n\n21. C. Swapping Out the Infrastructure: Do Everything with CSVs",
      "content_length": 711,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 13,
      "content": "a. Implementing a Repository and Unit of Work\n\nfor CSVs\n\n22. D. Repository and Unit of Work Patterns with Django\n\na. Repository Pattern with Django\n\ni. Custom Methods on Django ORM Classes to Translate to/from Our Domain Model\n\nb. Unit of Work Pattern with Django\n\nc. API: Django Views Are Adapters\n\nd. Why Was This All So Hard?\n\ne. What to Do If You Already Have Django\n\nf. Steps Along the Way\n\n23. E. Validation\n\na. What Is Validation, Anyway?\n\nb. Validating Syntax\n\nc. Postel’s Law and the Tolerant Reader Pattern\n\nd. Validating at the Edge\n\ne. Validating Semantics\n\nf. Validating Pragmatics\n\n24. Index",
      "content_length": 605,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 14,
      "content": "Architecture Patterns with Python\n\nEnabling Test-Driven Development, Domain- Driven Design, and Event-Driven Microservices\n\nHarry Percival and Bob Gregory",
      "content_length": 154,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 15,
      "content": "Architecture Patterns with Python\n\nby Harry Percival and Bob Gregory\n\nCopyright © 2020 Harry Percival and Bob Gregory. All rights reserved.\n\nPrinted in the United States of America.\n\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North,\n\nSebastopol, CA 95472.\n\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles\n\n(http://oreilly.com). For more information, contact our corporate/institutional sales department: 800-998-9938 or\n\ncorporate@oreilly.com.\n\nAcquisitions Editor: Ryan Shaw\n\nDevelopment Editor: Corbin Collins\n\nProduction Editor: Katherine Tozer\n\nCopyeditor: Sharon Wilkey\n\nProofreader: Arthur Johnson\n\nIndexer: Ellen Troutman-Zaig\n\nInterior Designer: David Futato",
      "content_length": 771,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 16,
      "content": "Cover Designer: Karen Montgomery\n\nIllustrator: Rebecca Demarest\n\nMarch 2020: First Edition\n\nRevision History for the First Edition\n\n2020-03-05: First Release\n\nSee http://oreilly.com/catalog/errata.csp?isbn=9781492052203 for release details.\n\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Architecture Patterns with Python, the cover image, and related trade\n\ndress are trademarks of O’Reilly Media, Inc.\n\nThe views expressed in this work are those of the authors and do not\n\nrepresent the publisher’s views. While the publisher and the authors have used good faith efforts to ensure that the information and\n\ninstructions contained in this work are accurate, the publisher and the authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work. Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.\n\n978-1-492-05220-3",
      "content_length": 1229,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 17,
      "content": "[LSI]",
      "content_length": 5,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 18,
      "content": "Preface\n\nYou may be wondering who we are and why we wrote this book.\n\nAt the end of Harry’s last book, Test-Driven Development with Python (O’Reilly), he found himself asking a bunch of questions about architecture, such as, What’s the best way of structuring your\n\napplication so that it’s easy to test? More specifically, so that your\n\ncore business logic is covered by unit tests, and so that you minimize\n\nthe number of integration and end-to-end tests you need? He made vague references to “Hexagonal Architecture” and “Ports and Adapters” and “Functional Core, Imperative Shell,” but if he was\n\nhonest, he’d have to admit that these weren’t things he really understood or had done in practice.\n\nAnd then he was lucky enough to run into Bob, who has the answers to all these questions.\n\nBob ended up a software architect because nobody else on his team was doing it. He turned out to be pretty bad at it, but he was lucky\n\nenough to run into Ian Cooper, who taught him new ways of writing and thinking about code.\n\nManaging Complexity, Solving Business Problems",
      "content_length": 1066,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 19,
      "content": "We both work for MADE.com, a European ecommerce company that sells furniture online; there, we apply the techniques in this book to build distributed systems that model real-world business problems. Our example domain is the first system Bob built for MADE, and this\n\nbook is an attempt to write down all the stuff we have to teach new programmers when they join one of our teams.\n\nMADE.com operates a global supply chain of freight partners and manufacturers. To keep costs low, we try to optimize the delivery of stock to our warehouses so that we don’t have unsold goods lying around the place.\n\nIdeally, the sofa that you want to buy will arrive in port on the very day that you decide to buy it, and we’ll ship it straight to your house\n\nwithout ever storing it. Getting the timing right is a tricky balancing act when goods take three months to arrive by container ship. Along the way, things get broken or water damaged, storms cause unexpected\n\ndelays, logistics partners mishandle goods, paperwork goes missing, customers change their minds and amend their orders, and so on.\n\nWe solve those problems by building intelligent software representing the kinds of operations taking place in the real world so that we can automate as much of the business as possible.\n\nWhy Python?\n\nIf you’re reading this book, we probably don’t need to convince you that Python is great, so the real question is “Why does the Python community need a book like this?” The answer is about Python’s",
      "content_length": 1483,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 20,
      "content": "popularity and maturity: although Python is probably the world’s fastest-growing programming language and is nearing the top of the absolute popularity tables, it’s only just starting to take on the kinds of problems that the C# and Java world has been working on for years.\n\nStartups become real businesses; web apps and scripted automations are becoming (whisper it) enterprise software.\n\nIn the Python world, we often quote the Zen of Python: “There should be one—and preferably only one—obvious way to do it.” Unfortunately, as project size grows, the most obvious way of doing things isn’t always the way that helps you manage complexity and evolving requirements.\n\n1\n\nNone of the techniques and patterns we discuss in this book are new, but they are mostly new to the Python world. And this book isn’t a replacement for the classics in the field such as Eric Evans’s Domain- Driven Design or Martin Fowler’s Patterns of Enterprise Application Architecture (both published by Addison-Wesley Professional)—which we often refer to and encourage you to go and\n\nread.\n\nBut all the classic code examples in the literature do tend to be written\n\nin Java or C++/#, and if you’re a Python person and haven’t used either of those languages in a long time (or indeed ever), those code listings can be quite…trying. There’s a reason the latest edition of that other classic text, Fowler’s Refactoring (Addison-Wesley Professional), is in JavaScript.",
      "content_length": 1443,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 21,
      "content": "TDD, DDD, and Event-Driven Architecture\n\nIn order of notoriety, we know of three tools for managing complexity:\n\n1. Test-driven development (TDD) helps us to build code that is correct and enables us to refactor or add new features, without fear of regression. But it can be hard to get the best out of our tests: How do we make sure that they run as fast as possible? That we get as much coverage and feedback from fast, dependency-free unit tests and have the minimum number of slower, flaky end-to-end tests?\n\n2. Domain-driven design (DDD) asks us to focus our efforts on building a good model of the business domain, but how do we make sure that our models aren’t encumbered with infrastructure concerns and don’t become hard to change?\n\n3. Loosely coupled (micro)services integrated via messages (sometimes called reactive microservices) are a well- established answer to managing complexity across multiple applications or business domains. But it’s not always obvious how to make them fit with the established tools of the Python world—Flask, Django, Celery, and so on.\n\nNOTE\n\nDon’t be put off if you’re not working with (or interested in) microservices. The vast majority of the patterns we discuss, including much of the event-driven architecture material, is absolutely applicable in a monolithic architecture.\n\nOur aim with this book is to introduce several classic architectural patterns and show how they support TDD, DDD, and event-driven services. We hope it will serve as a reference for implementing them",
      "content_length": 1521,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 22,
      "content": "in a Pythonic way, and that people can use it as a first step toward further research in this field.\n\nWho Should Read This Book\n\nHere are a few things we assume about you, dear reader:\n\nYou’ve been close to some reasonably complex Python applications.\n\nYou’ve seen some of the pain that comes with trying to manage that complexity.\n\nYou don’t necessarily know anything about DDD or any of the classic application architecture patterns.\n\nWe structure our explorations of architectural patterns around an example app, building it up chapter by chapter. We use TDD at work, so we tend to show listings of tests first, followed by implementation. If you’re not used to working test-first, it may feel a little strange at the beginning, but we hope you’ll soon get used to seeing code “being used” (i.e., from the outside) before you see how it’s built on the inside.\n\nWe use some specific Python frameworks and technologies, including Flask, SQLAlchemy, and pytest, as well as Docker and Redis. If you’re already familiar with them, that won’t hurt, but we don’t think\n\nit’s required. One of our main aims with this book is to build an architecture for which specific technology choices become minor implementation details.",
      "content_length": 1219,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 23,
      "content": "A Brief Overview of What You’ll Learn\n\nThe book is divided into two parts; here’s a look at the topics we’ll cover and the chapters they live in.",
      "content_length": 145,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 24,
      "content": "Part I, Building an Architecture to Support Domain Modeling\n\nDomain modeling and DDD (Chapters 1 and 7)\n\nAt some level, everyone has learned the lesson that complex business problems need to be reflected in code, in the form of a model of the domain. But why does it always seem to be so hard to do without getting tangled up with infrastructure concerns, our web frameworks, or whatever else? In the first chapter we give a broad overview of domain modeling and DDD, and we show how to get started with a model that has no external dependencies, and fast unit tests. Later we return to DDD patterns to discuss how to choose the right aggregate, and how this choice relates to questions of data integrity.\n\nRepository, Service Layer, and Unit of Work patterns (Chapters 2, 4, and 5)\n\nIn these three chapters we present three closely related and mutually reinforcing patterns that support our ambition to keep the model free of extraneous dependencies. We build a layer of abstraction around persistent storage, and we build a service layer to define the entrypoints to our system and capture the primary use cases. We show how this layer makes it easy to build thin entrypoints to our system, whether it’s a Flask API or a CLI.\n\nSome thoughts on testing and abstractions (Chapters 3 and 6)\n\nAfter presenting the first abstraction (the Repository pattern), we take the opportunity for a general discussion of how to choose abstractions, and what their role is in choosing how our software is coupled together. After we introduce the Service Layer pattern, we talk a bit about achieving a test pyramid and writing unit tests at the highest possible level of abstraction.",
      "content_length": 1668,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 25,
      "content": "Part II, Event-Driven Architecture\n\nEvent-driven architecture (Chapters 8–11)\n\nWe introduce three more mutually reinforcing patterns: the Domain Events, Message Bus, and Handler patterns. Domain events are a vehicle for capturing the idea that some interactions with a system are triggers for others. We use a message bus to allow actions to trigger events and call appropriate handlers. We move on to discuss how events can be used as a pattern for integration between services in a microservices architecture. Finally, we distinguish between commands and events. Our application is now fundamentally a message-processing system.\n\nCommand-query responsibility segregation (Chapter 12)\n\nWe present an example of command-query responsibility segregation, with and without events.\n\nDependency injection (Chapter 13)\n\nWe tidy up our explicit and implicit dependencies and implement a simple dependency injection framework.\n\nAddtional Content\n\nHow do I get there from here? (Epilogue)\n\nImplementing architectural patterns always looks easy when you show a simple example, starting from scratch, but many of you will probably be wondering how to apply these principles to existing software. We’ll provide a few pointers in the epilogue and some links to further reading.\n\nExample Code and Coding Along",
      "content_length": 1296,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 26,
      "content": "You’re reading a book, but you’ll probably agree with us when we say that the best way to learn about code is to code. We learned most of\n\nwhat we know from pairing with people, writing code with them, and learning by doing, and we’d like to re-create that experience as much\n\nas possible for you in this book.\n\nAs a result, we’ve structured the book around a single example project (although we do sometimes throw in other examples). We’ll build up\n\nthis project as the chapters progress, as if you’ve paired with us and we’re explaining what we’re doing and why at each step.\n\nBut to really get to grips with these patterns, you need to mess about\n\nwith the code and get a feel for how it works. You’ll find all the code on GitHub; each chapter has its own branch. You can find a list of the\n\nbranches on GitHub as well.\n\nHere are three ways you might code along with the book:\n\nStart your own repo and try to build up the app as we do, following the examples from listings in the book, and occasionally looking to our repo for hints. A word of warning, however: if you’ve read Harry’s previous book and coded along with that, you’ll find that this book requires you to figure out more on your own; you may need to lean pretty heavily on the working versions on GitHub.\n\nTry to apply each pattern, chapter by chapter, to your own (preferably small/toy) project, and see if you can make it work for your use case. This is high risk/high reward (and high effort besides!). It may take quite some work to get things working for the specifics of your project, but on the other hand, you’re likely to learn the most.",
      "content_length": 1613,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 27,
      "content": "For less effort, in each chapter we outline an “Exercise for the Reader,” and point you to a GitHub location where you can download some partially finished code for the chapter with a few missing parts to write yourself.\n\nParticularly if you’re intending to apply some of these patterns in your\n\nown projects, working through a simple example is a great way to safely practice.\n\nTIP\n\nAt the very least, do a git checkout of the code from our repo as you read each chapter. Being able to jump in and see the code in the context of an actual working app will help answer a lot of questions as you go, and makes everything more real. You’ll find instructions for how to do that at the beginning of each chapter.\n\nLicense\n\nThe code (and the online version of the book) is licensed under a\n\nCreative Commons CC BY-NC-ND license, which means you are free to copy and share it with anyone you like, for non-commercial\n\npurposes, as long as you give attribution. If you want to re-use any of\n\nthe content from this book and you have any worries about the license, contact O’Reilly at permissions@oreilly.com.\n\nThe print edition is licensed differently; please see the copyright page.\n\nConventions Used in This Book",
      "content_length": 1206,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 28,
      "content": "The following typographical conventions are used in this book:\n\nItalic\n\nIndicates new terms, URLs, email addresses, filenames, and file extensions.\n\nConstant width\n\nUsed for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.\n\nConstant width bold\n\nShows commands or other text that should be typed literally by the user.\n\nConstant width italic\n\nShows text that should be replaced with user-supplied values or by values determined by context.\n\nTIP\n\nThis element signifies a tip or suggestion.\n\nNOTE\n\nThis element signifies a general note.",
      "content_length": 669,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 29,
      "content": "WARNING\n\nThis element indicates a warning or caution.\n\nO’Reilly Online Learning\n\nNOTE\n\nFor more than 40 years, O’Reilly Media has provided technology and business training, knowledge, and insight to help companies succeed.\n\nOur unique network of experts and innovators share their knowledge and expertise through books, articles, conferences, and our online\n\nlearning platform. O’Reilly’s online learning platform gives you on- demand access to live training courses, in-depth learning paths,\n\ninteractive coding environments, and a vast collection of text and video from O’Reilly and 200+ other publishers. For more information,\n\nplease visit http://oreilly.com.\n\nHow to Contact O’Reilly\n\nPlease address comments and questions concerning this book to the\n\npublisher:\n\nO’Reilly Media, Inc.\n\n1005 Gravenstein Highway North",
      "content_length": 821,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 30,
      "content": "Sebastopol, CA 95472\n\n800-998-9938 (in the United States or Canada)\n\n707-829-0515 (international or local)\n\n707-829-0104 (fax)\n\nWe have a web page for this book, where we list errata, examples, and any additional information. You can access this page at\n\nhttps://oreil.ly/architecture-patterns-python.\n\nEmail bookquestions@oreilly.com to comment or ask technical\n\nquestions about this book.\n\nFor more information about our books, courses, conferences, and\n\nnews, see our website at http://www.oreilly.com.\n\nFind us on Facebook: http://facebook.com/oreilly\n\nFollow us on Twitter: http://twitter.com/oreillymedia\n\nWatch us on YouTube: http://www.youtube.com/oreillymedia\n\nAcknowledgments\n\nTo our tech reviewers, David Seddon, Ed Jung, and Hynek Schlawack: we absolutely do not deserve you. You are all incredibly dedicated,\n\nconscientious, and rigorous. Each one of you is immensely smart, and your different points of view were both useful and complementary to each other. Thank you from the bottom of our hearts.",
      "content_length": 1012,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 31,
      "content": "Gigantic thanks also to our Early Release readers for their comments\n\nand suggestions: Ian Cooper, Abdullah Ariff, Jonathan Meier, Gil Gonçalves, Matthieu Choplin, Ben Judson, James Gregory, Łukasz Lechowicz, Clinton Roy, Vitorino Araújo, Susan Goodbody, Josh Harwood, Daniel Butler, Liu Haibin, Jimmy Davies, Ignacio Vergara\n\nKausel, Gaia Canestrani, Renne Rocha, pedroabi, Ashia Zawaduk, Jostein Leira, Brandon Rhodes, and many more; our apologies if we missed you on this list.\n\nSuper-mega-thanks to our editor Corbin Collins for his gentle chivvying, and for being a tireless advocate of the reader. Similarly- superlative thanks to the production staff, Katherine Tozer, Sharon\n\nWilkey, Ellen Troutman-Zaig, and Rebecca Demarest, for your dedication, professionalism, and attention to detail. This book is immeasurably improved thanks to you.\n\nAny errors remaining in the book are our own, naturally.\n\n1 python -c \"import this\"",
      "content_length": 932,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 32,
      "content": "Introduction\n\nWhy Do Our Designs Go Wrong?\n\nWhat comes to mind when you hear the word chaos? Perhaps you think of a noisy stock exchange, or your kitchen in the morning—everything confused and jumbled. When you think of the word order, perhaps you\n\nthink of an empty room, serene and calm. For scientists, though, chaos\n\nis characterized by homogeneity (sameness), and order by complexity (difference).\n\nFor example, a well-tended garden is a highly ordered system.\n\nGardeners define boundaries with paths and fences, and they mark out flower beds or vegetable patches. Over time, the garden evolves,\n\ngrowing richer and thicker; but without deliberate effort, the garden will run wild. Weeds and grasses will choke out other plants, covering\n\nover the paths, until eventually every part looks the same again—wild and unmanaged.\n\nSoftware systems, too, tend toward chaos. When we first start building a new system, we have grand ideas that our code will be clean and well ordered, but over time we find that it gathers cruft and edge cases\n\nand ends up a confusing morass of manager classes and util modules. We find that our sensibly layered architecture has collapsed into itself like an oversoggy trifle. Chaotic software systems are characterized by a sameness of function: API handlers that have domain knowledge and send email and perform logging; “business logic” classes that perform",
      "content_length": 1391,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 33,
      "content": "no calculations but do perform I/O; and everything coupled to everything else so that changing any part of the system becomes fraught with danger. This is so common that software engineers have their own term for chaos: the Big Ball of Mud anti-pattern (Figure P-1).\n\nFigure P-1. A real-life dependency diagram (source: “Enterprise Dependency: Big Ball of Yarn” by Alex Papadimoulis)",
      "content_length": 383,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 34,
      "content": "TIP\n\nA big ball of mud is the natural state of software in the same way that wilderness is the natural state of your garden. It takes energy and direction to prevent the collapse.\n\nFortunately, the techniques to avoid creating a big ball of mud aren’t complex.\n\nEncapsulation and Abstractions\n\nEncapsulation and abstraction are tools that we all instinctively reach for as programmers, even if we don’t all use these exact words. Allow us to dwell on them for a moment, since they are a recurring background theme of the book.\n\nThe term encapsulation covers two closely related ideas: simplifying behavior and hiding data. In this discussion, we’re using the first\n\nsense. We encapsulate behavior by identifying a task that needs to be done in our code and giving that task to a well-defined object or function. We call that object or function an abstraction.\n\nTake a look at the following two snippets of Python code:\n\nDo a search with urllib\n\nimport json from urllib.request import urlopen from urllib.parse import urlencode\n\nparams = dict(q='Sausages', format='json')",
      "content_length": 1070,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 35,
      "content": "handle = urlopen('http://api.duckduckgo.com' + '?' + urlencode(params)) raw_text = handle.read().decode('utf8') parsed = json.loads(raw_text)\n\nresults = parsed['RelatedTopics'] for r in results: if 'Text' in r: print(r['FirstURL'] + ' - ' + r['Text'])\n\nDo a search with requests\n\nimport requests\n\nparams = dict(q='Sausages', format='json') parsed = requests.get('http://api.duckduckgo.com/', params=params).json()\n\nresults = parsed['RelatedTopics'] for r in results: if 'Text' in r: print(r['FirstURL'] + ' - ' + r['Text'])\n\nBoth code listings do the same thing: they submit form-encoded values to a URL in order to use a search engine API. But the second is simpler to read and understand because it operates at a higher level of\n\nabstraction.\n\nWe can take this one step further still by identifying and naming the\n\ntask we want the code to perform for us and using an even higher-level abstraction to make it explicit:\n\nDo a search with the duckduckgo module\n\nimport duckduckgo for r in duckduckgo.query('Sausages').results: print(r.url + ' - ' + r.text)",
      "content_length": 1056,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 36,
      "content": "Encapsulating behavior by using abstractions is a powerful tool for making code more expressive, more testable, and easier to maintain.\n\nNOTE\n\nIn the literature of the object-oriented (OO) world, one of the classic characterizations of this approach is called responsibility-driven design; it uses the words roles and responsibilities rather than tasks. The main point is to think about code in terms of behavior, rather than in terms of data or algorithms.\n\n1\n\nABSTRACTIONS AND ABCS\n\nIn a traditional OO language like Java or C#, you might use an abstract base class (ABC) or an interface to define an abstraction. In Python you can (and we sometimes do) use ABCs, but you can also happily rely on duck typing.\n\nThe abstraction can just mean “the public API of the thing you’re using”—a function name plus some arguments, for example.\n\nMost of the patterns in this book involve choosing an abstraction, so you’ll see plenty of examples in each chapter. In addition, Chapter 3 specifically discusses some general heuristics for choosing abstractions.\n\nLayering\n\nEncapsulation and abstraction help us by hiding details and protecting the consistency of our data, but we also need to pay attention to the interactions between our objects and functions. When one function, module, or object uses another, we say that the one depends on the other. These dependencies form a kind of network or graph.",
      "content_length": 1395,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 37,
      "content": "In a big ball of mud, the dependencies are out of control (as you saw in Figure P-1). Changing one node of the graph becomes difficult because it has the potential to affect many other parts of the system. Layered architectures are one way of tackling this problem. In a layered architecture, we divide our code into discrete categories or roles, and we introduce rules about which categories of code can call each other.\n\nOne of the most common examples is the three-layered architecture shown in Figure P-2.\n\nFigure P-2. Layered architecture\n\nLayered architecture is perhaps the most common pattern for building business software. In this model we have user-interface components,",
      "content_length": 681,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 38,
      "content": "which could be a web page, an API, or a command line; these user-\n\ninterface components communicate with a business logic layer that contains our business rules and our workflows; and finally, we have a database layer that’s responsible for storing and retrieving data.\n\nFor the rest of this book, we’re going to be systematically turning this model inside out by obeying one simple principle.\n\nThe Dependency Inversion Principle\n\nYou might be familiar with the dependency inversion principle (DIP)\n\nalready, because it’s the D in SOLID.\n\n2\n\nUnfortunately, we can’t illustrate the DIP by using three tiny code listings as we did for encapsulation. However, the whole of Part I is\n\nessentially a worked example of implementing the DIP throughout an application, so you’ll get your fill of concrete examples.\n\nIn the meantime, we can talk about DIP’s formal definition:\n\n1. High-level modules should not depend on low-level modules. Both should depend on abstractions.\n\n2. Abstractions should not depend on details. Instead, details should depend on abstractions.\n\nBut what does this mean? Let’s take it bit by bit.\n\nHigh-level modules are the code that your organization really cares about. Perhaps you work for a pharmaceutical company, and your high-\n\nlevel modules deal with patients and trials. Perhaps you work for a",
      "content_length": 1320,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 39,
      "content": "bank, and your high-level modules manage trades and exchanges. The\n\nhigh-level modules of a software system are the functions, classes, and packages that deal with our real-world concepts.\n\nBy contrast, low-level modules are the code that your organization\n\ndoesn’t care about. It’s unlikely that your HR department gets excited about filesystems or network sockets. It’s not often that you discuss\n\nSMTP, HTTP, or AMQP with your finance team. For our nontechnical stakeholders, these low-level concepts aren’t interesting or relevant.\n\nAll they care about is whether the high-level concepts work correctly. If payroll runs on time, your business is unlikely to care whether that’s\n\na cron job or a transient function running on Kubernetes.\n\nDepends on doesn’t mean imports or calls, necessarily, but rather a more general idea that one module knows about or needs another\n\nmodule.\n\nAnd we’ve mentioned abstractions already: they’re simplified interfaces that encapsulate behavior, in the way that our duckduckgo\n\nmodule encapsulated a search engine’s API.\n\nAll problems in computer science can be solved by adding another level of indirection.\n\n—David Wheeler\n\nSo the first part of the DIP says that our business code shouldn’t\n\ndepend on technical details; instead, both should use abstractions.\n\nWhy? Broadly, because we want to be able to change them independently of each other. High-level modules should be easy to",
      "content_length": 1420,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 40,
      "content": "change in response to business needs. Low-level modules (details) are often, in practice, harder to change: think about refactoring to change a\n\nfunction name versus defining, testing, and deploying a database migration to change a column name. We don’t want business logic\n\nchanges to slow down because they are closely coupled to low-level infrastructure details. But, similarly, it is important to be able to\n\nchange your infrastructure details when you need to (think about sharding a database, for example), without needing to make changes to\n\nyour business layer. Adding an abstraction between them (the famous extra layer of indirection) allows the two to change (more)\n\nindependently of each other.\n\nThe second part is even more mysterious. “Abstractions should not depend on details” seems clear enough, but “Details should depend on\n\nabstractions” is hard to imagine. How can we have an abstraction that doesn’t depend on the details it’s abstracting? By the time we get to\n\nChapter 4, we’ll have a concrete example that should make this all a\n\nbit clearer.\n\nA Place for All Our Business Logic: The Domain Model\n\nBut before we can turn our three-layered architecture inside out, we need to talk more about that middle layer: the high-level modules or\n\nbusiness logic. One of the most common reasons that our designs go\n\nwrong is that business logic becomes spread throughout the layers of our application, making it hard to identify, understand, and change.",
      "content_length": 1467,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 41,
      "content": "Chapter 1 shows how to build a business layer with a Domain Model\n\npattern. The rest of the patterns in Part I show how we can keep the domain model easy to change and free of low-level concerns by\n\nchoosing the right abstractions and continuously applying the DIP.\n\n1 If you’ve come across class-responsibility-collaborator (CRC) cards, they’re driving at the same thing: thinking about responsibilities helps you decide how to split things up.\n\n2 SOLID is an acronym for Robert C. Martin’s five principles of object-oriented design: single responsibility, open for extension but closed for modification, Liskov substitution, interface segregation, and dependency inversion. See “S.O.L.I.D: The First 5 Principles of Object-Oriented Design” by Samuel Oloruntoba.",
      "content_length": 763,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 42,
      "content": "Part I. Building an Architecture to Support Domain Modeling\n\nMost developers have never seen a domain model, only a data model.\n\n—Cyrille Martraire, DDD EU 2017\n\nMost developers we talk to about architecture have a nagging sense\n\nthat things could be better. They are often trying to rescue a system that has gone wrong somehow, and are trying to put some structure back\n\ninto a ball of mud. They know that their business logic shouldn’t be spread all over the place, but they have no idea how to fix it.\n\nWe’ve found that many developers, when asked to design a new system, will immediately start to build a database schema, with the\n\nobject model treated as an afterthought. This is where it all starts to go wrong. Instead, behavior should come first and drive our storage requirements. After all, our customers don’t care about the data model. They care about what the system does; otherwise they’d just use a\n\nspreadsheet.\n\nThe first part of the book looks at how to build a rich object model\n\nthrough TDD (in Chapter 1), and then we’ll show how to keep that",
      "content_length": 1063,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 43,
      "content": "model decoupled from technical concerns. We show how to build persistence-ignorant code and how to create stable APIs around our domain so that we can refactor aggressively.\n\nTo do that, we present four key design patterns:\n\nThe Repository pattern, an abstraction over the idea of persistent storage\n\nThe Service Layer pattern to clearly define where our use cases begin and end\n\nThe Unit of Work pattern to provide atomic operations\n\nThe Aggregate pattern to enforce the integrity of our data\n\nIf you’d like a picture of where we’re going, take a look at Figure I-1, but don’t worry if none of it makes sense yet! We introduce each box in\n\nthe figure, one by one, throughout this part of the book.",
      "content_length": 698,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 44,
      "content": "Figure I-1. A component diagram for our app at the end of Part I\n\nWe also take a little time out to talk about coupling and abstractions, illustrating it with a simple example that shows how and why we\n\nchoose our abstractions.\n\nThree appendices are further explorations of the content from Part I:\n\nAppendix B is a write-up of the infrastructure for our example code: how we build and run the Docker images, where we",
      "content_length": 417,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 45,
      "content": "manage configuration info, and how we run different types of tests.\n\nAppendix C is a “proof is in the pudding” kind of content, showing how easy it is to swap out our entire infrastructure— the Flask API, the ORM, and Postgres—for a totally different I/O model involving a CLI and CSVs.\n\nFinally, Appendix D may be of interest if you’re wondering how these patterns might look if using Django instead of Flask and SQLAlchemy.",
      "content_length": 425,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 46,
      "content": "Chapter 1. Domain Modeling\n\nThis chapter looks into how we can model business processes with code, in a way that’s highly compatible with TDD. We’ll discuss why domain modeling matters, and we’ll look at a few key patterns for modeling domains: Entity, Value Object, and Domain Service.\n\nFigure 1-1 is a simple visual placeholder for our Domain Model\n\npattern. We’ll fill in some details in this chapter, and as we move on to\n\nother chapters, we’ll build things around the domain model, but you should always be able to find these little shapes at the core.",
      "content_length": 557,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 48,
      "content": "Figure 1-1. A placeholder illustration of our domain model\n\nWhat Is a Domain Model?\n\nIn the introduction, we used the term business logic layer to describe the central layer of a three-layered architecture. For the rest of the book, we’re going to use the term domain model instead. This is a term from the DDD community that does a better job of capturing our intended meaning (see the next sidebar for more on DDD).\n\nThe domain is a fancy way of saying the problem you’re trying to solve. Your authors currently work for an online retailer of furniture. Depending on which system you’re talking about, the domain might be\n\npurchasing and procurement, or product design, or logistics and delivery. Most programmers spend their days trying to improve or automate business processes; the domain is the set of activities that those processes support.\n\nA model is a map of a process or phenomenon that captures a useful property. Humans are exceptionally good at producing models of things in their heads. For example, when someone throws a ball toward you, you’re able to predict its movement almost unconsciously, because you have a model of the way objects move in space. Your model isn’t perfect by any means. Humans have terrible intuitions about how objects behave at near-light speeds or in a vacuum because\n\nour model was never designed to cover those cases. That doesn’t mean the model is wrong, but it does mean that some predictions fall outside of its domain.",
      "content_length": 1468,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 49,
      "content": "The domain model is the mental map that business owners have of their businesses. All business people have these mental maps—they’re how humans think about complex processes.\n\nYou can tell when they’re navigating these maps because they use business speak. Jargon arises naturally among people who are collaborating on complex systems.\n\nImagine that you, our unfortunate reader, were suddenly transported light years away from Earth aboard an alien spaceship with your friends and family and had to figure out, from first principles, how to navigate home.\n\nIn your first few days, you might just push buttons randomly, but soon you’d learn which buttons did what, so that you could give one another instructions. “Press the red button near the flashing doohickey and then throw that big lever over by the radar gizmo,” you might say.\n\nWithin a couple of weeks, you’d become more precise as you adopted words to describe the ship’s functions: “Increase oxygen levels in cargo bay three” or “turn on the little thrusters.” After a few months, you’d have adopted language for entire complex processes: “Start landing sequence” or “prepare for warp.” This process would happen\n\nquite naturally, without any formal effort to build a shared glossary.",
      "content_length": 1244,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 50,
      "content": "THIS IS NOT A DDD BOOK. YOU SHOULD READ A DDD BOOK.\n\n1\n\nDomain-driven design, or DDD, popularized the concept of domain modeling, and it’s been a hugely successful movement in transforming the way people design software by focusing on the core business domain. Many of the architecture patterns that we cover in this book—including Entity, Aggregate, Value Object (see Chapter 7), and Repository (in the next chapter)—come from the DDD tradition.\n\nIn a nutshell, DDD says that the most important thing about software is that it provides a useful model of a problem. If we get that model right, our software delivers value and makes new things possible.\n\nIf we get the model wrong, it becomes an obstacle to be worked around. In this book, we can show the basics of building a domain model, and building an architecture around it that leaves the model as free as possible from external constraints, so that it’s easy to evolve and change.\n\nBut there’s a lot more to DDD and to the processes, tools, and techniques for developing a domain model. We hope to give you a taste of it, though, and cannot encourage you enough to go on and read a proper DDD book:\n\nThe original “blue book,” Domain-Driven Design by Eric Evans (Addison-Wesley Professional)\n\nThe “red book,” Implementing Domain-Driven Design by Vaughn Vernon (Addison- Wesley Professional)\n\nSo it is in the mundane world of business. The terminology used by business stakeholders represents a distilled understanding of the domain model, where complex ideas and processes are boiled down to a single word or phrase.\n\nWhen we hear our business stakeholders using unfamiliar words, or using terms in a specific way, we should listen to understand the deeper meaning and encode their hard-won experience into our software.\n\nWe’re going to use a real-world domain model throughout this book, specifically a model from our current employment. MADE.com is a",
      "content_length": 1908,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 51,
      "content": "successful furniture retailer. We source our furniture from manufacturers all over the world and sell it across Europe.\n\nWhen you buy a sofa or a coffee table, we have to figure out how best to get your goods from Poland or China or Vietnam and into your living room.\n\nAt a high level, we have separate systems that are responsible for buying stock, selling stock to customers, and shipping goods to customers. A system in the middle needs to coordinate the process by allocating stock to a customer’s orders; see Figure 1-2.",
      "content_length": 525,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 53,
      "content": "Figure 1-2. Context diagram for the allocation service\n\nFor the purposes of this book, we’re imagining that the business\n\ndecides to implement an exciting new way of allocating stock. Until now, the business has been presenting stock and lead times based on\n\nwhat is physically available in the warehouse. If and when the warehouse runs out, a product is listed as “out of stock” until the next\n\nshipment arrives from the manufacturer.\n\nHere’s the innovation: if we have a system that can keep track of all our shipments and when they’re due to arrive, we can treat the goods\n\non those ships as real stock and part of our inventory, just with slightly\n\nlonger lead times. Fewer goods will appear to be out of stock, we’ll sell more, and the business can save money by keeping lower\n\ninventory in the domestic warehouse.\n\nBut allocating orders is no longer a trivial matter of decrementing a single quantity in the warehouse system. We need a more complex\n\nallocation mechanism. Time for some domain modeling.\n\nExploring the Domain Language\n\nUnderstanding the domain model takes time, and patience, and Post-it\n\nnotes. We have an initial conversation with our business experts and agree on a glossary and some rules for the first minimal version of the\n\ndomain model. Wherever possible, we ask for concrete examples to illustrate each rule.",
      "content_length": 1339,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 54,
      "content": "We make sure to express those rules in the business jargon (the ubiquitous language in DDD terminology). We choose memorable\n\nidentifiers for our objects so that the examples are easier to talk about.\n\n“Some Notes on Allocation” shows some notes we might have taken while having a conversation with our domain experts about allocation.\n\nSOME NOTES ON ALLOCATION\n\nA product is identified by a SKU, pronounced “skew,” which is short for stock-keeping unit. Customers place orders. An order is identified by an order reference and comprises multiple order lines, where each line has a SKU and a quantity. For example:\n\n10 units of RED-CHAIR\n\n1 unit of TASTELESS-LAMP\n\nThe purchasing department orders small batches of stock. A batch of stock has a unique ID called a reference, a SKU, and a quantity.\n\nWe need to allocate order lines to batches. When we’ve allocated an order line to a batch, we will send stock from that specific batch to the customer’s delivery address. When we allocate x units of stock to a batch, the available quantity is reduced by x. For example:\n\nWe have a batch of 20 SMALL-TABLE, and we allocate an order line for 2 SMALL-TABLE.\n\nThe batch should have 18 SMALL-TABLE remaining.\n\nWe can’t allocate to a batch if the available quantity is less than the quantity of the order line. For example:\n\nWe have a batch of 1 BLUE-CUSHION, and an order line for 2 BLUE-CUSHION.\n\nWe should not be able to allocate the line to the batch.\n\nWe can’t allocate the same line twice. For example:\n\nWe have a batch of 10 BLUE-VASE, and we allocate an order line for 2 BLUE-VASE.\n\nIf we allocate the order line again to the same batch, the batch should still have an available quantity of 8.\n\nBatches have an ETA if they are currently shipping, or they may be in warehouse stock. We allocate to warehouse stock in preference to shipment batches. We allocate to shipment batches in order of which has the earliest ETA.",
      "content_length": 1920,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 55,
      "content": "Unit Testing Domain Models\n\nWe’re not going to show you how TDD works in this book, but we\n\nwant to show you how we would construct a model from this business conversation.\n\nEXERCISE FOR THE READER\n\nWhy not have a go at solving this problem yourself? Write a few unit tests to see if you can capture the essence of these business rules in nice, clean code.\n\nYou’ll find some placeholder unit tests on GitHub, but you could just start from scratch, or combine/rewrite them however you like.\n\nHere’s what one of our first tests might look like:\n\nA first test for allocation (test_batches.py)\n\ndef test_allocating_to_a_batch_reduces_the_available_quantity(): batch = Batch(\"batch-001\", \"SMALL-TABLE\", qty=20, eta=date.today()) line = OrderLine('order-ref', \"SMALL-TABLE\", 2)\n\nbatch.allocate(line)\n\nassert batch.available_quantity == 18\n\nThe name of our unit test describes the behavior that we want to see from the system, and the names of the classes and variables that we use\n\nare taken from the business jargon. We could show this code to our nontechnical coworkers, and they would agree that this correctly\n\ndescribes the behavior of the system.\n\nAnd here is a domain model that meets our requirements:",
      "content_length": 1203,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 56,
      "content": "First cut of a domain model for batches (model.py)\n\n@dataclass(frozen=True) class OrderLine: orderid: str sku: str qty: int\n\nclass Batch: def __init__( self, ref: str, sku: str, qty: int, eta: Optional[date] ): self.reference = ref self.sku = sku self.eta = eta self.available_quantity = qty\n\ndef allocate(self, line: OrderLine): self.available_quantity -= line.qty\n\nOrderLine is an immutable dataclass with no behavior.\n\n2\n\nWe’re not showing imports in most code listings, in an attempt to keep them clean. We’re hoping you can guess that this came via from dataclasses import dataclass; likewise, typing.Optional and datetime.date. If you want to double- check anything, you can see the full working code for each chapter in its branch (e.g., chapter_01_domain_model).\n\nType hints are still a matter of controversy in the Python world. For domain models, they can sometimes help to clarify or document what the expected arguments are, and people with IDEs are often grateful for them. You may decide the price paid in terms of readability is too high.\n\nOur implementation here is trivial: a Batch just wraps an integer available_quantity, and we decrement that value on allocation.",
      "content_length": 1183,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 57,
      "content": "We’ve written quite a lot of code just to subtract one number from another, but we think that modeling our domain precisely will pay off.\n\nLet’s write some new failing tests:\n\nTesting logic for what we can allocate (test_batches.py)\n\ndef make_batch_and_line(sku, batch_qty, line_qty): return ( Batch(\"batch-001\", sku, batch_qty, eta=date.today()), OrderLine(\"order-123\", sku, line_qty) )\n\ndef test_can_allocate_if_available_greater_than_required(): large_batch, small_line = make_batch_and_line(\"ELEGANT-LAMP\", 20, 2) assert large_batch.can_allocate(small_line)\n\ndef test_cannot_allocate_if_available_smaller_than_required(): small_batch, large_line = make_batch_and_line(\"ELEGANT-LAMP\", 2, 20) assert small_batch.can_allocate(large_line) is False\n\ndef test_can_allocate_if_available_equal_to_required(): batch, line = make_batch_and_line(\"ELEGANT-LAMP\", 2, 2) assert batch.can_allocate(line)\n\ndef test_cannot_allocate_if_skus_do_not_match(): batch = Batch(\"batch-001\", \"UNCOMFORTABLE-CHAIR\", 100, eta=None) different_sku_line = OrderLine(\"order-123\", \"EXPENSIVE-TOASTER\", 10) assert batch.can_allocate(different_sku_line) is False\n\nThere’s nothing too unexpected here. We’ve refactored our test suite so that we don’t keep repeating the same lines of code to create a batch\n\nand a line for the same SKU; and we’ve written four simple tests for a new method can_allocate. Again, notice that the names we use\n\n3",
      "content_length": 1410,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 58,
      "content": "mirror the language of our domain experts, and the examples we\n\nagreed upon are directly written into code.\n\nWe can implement this straightforwardly, too, by writing the can_allocate method of Batch:\n\nA new method in the model (model.py)\n\ndef can_allocate(self, line: OrderLine) -> bool: return self.sku == line.sku and self.available_quantity >= line.qty\n\nSo far, we can manage the implementation by just incrementing and decrementing Batch.available_quantity, but as we get into deallocate() tests, we’ll be forced into a more intelligent solution:\n\nThis test is going to require a smarter model (test_batches.py)\n\ndef test_can_only_deallocate_allocated_lines(): batch, unallocated_line = make_batch_and_line(\"DECORATIVE-TRINKET\", 20, 2) batch.deallocate(unallocated_line) assert batch.available_quantity == 20\n\nIn this test, we’re asserting that deallocating a line from a batch has no effect unless the batch previously allocated the line. For this to work, our Batch needs to understand which lines have been allocated. Let’s look at the implementation:\n\nThe domain model now tracks allocations (model.py)\n\nclass Batch: def __init__( self, ref: str, sku: str, qty: int, eta: Optional[date] ): self.reference = ref",
      "content_length": 1218,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 59,
      "content": "self.sku = sku self.eta = eta self._purchased_quantity = qty self._allocations = set() # type: Set[OrderLine]\n\ndef allocate(self, line: OrderLine): if self.can_allocate(line): self._allocations.add(line)\n\ndef deallocate(self, line: OrderLine): if line in self._allocations: self._allocations.remove(line)\n\n@property def allocated_quantity(self) -> int: return sum(line.qty for line in self._allocations)\n\n@property def available_quantity(self) -> int: return self._purchased_quantity - self.allocated_quantity\n\ndef can_allocate(self, line: OrderLine) -> bool: return self.sku == line.sku and self.available_quantity >= line.qty\n\nFigure 1-3 shows the model in UML.\n\nFigure 1-3. Our model in UML\n\nNow we’re getting somewhere! A batch now keeps track of a set of allocated OrderLine objects. When we allocate, if we have enough",
      "content_length": 824,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 60,
      "content": "available quantity, we just add to the set. Our available_quantity is now a calculated property: purchased quantity minus allocated\n\nquantity.\n\nYes, there’s plenty more we could do. It’s a little disconcerting that both allocate() and deallocate() can fail silently, but we have the basics.\n\nIncidentally, using a set for ._allocations makes it simple for us to handle the last test, because items in a set are unique:\n\nLast batch test! (test_batches.py)\n\ndef test_allocation_is_idempotent(): batch, line = make_batch_and_line(\"ANGULAR-DESK\", 20, 2) batch.allocate(line) batch.allocate(line) assert batch.available_quantity == 18\n\nAt the moment, it’s probably a valid criticism to say that the domain model is too trivial to bother with DDD (or even object orientation!). In real life, any number of business rules and edge cases crop up: customers can ask for delivery on specific future dates, which means\n\nwe might not want to allocate them to the earliest batch. Some SKUs aren’t in batches, but ordered on demand directly from suppliers, so they have different logic. Depending on the customer’s location, we can allocate to only a subset of warehouses and shipments that are in\n\ntheir region—except for some SKUs we’re happy to deliver from a warehouse in a different region if we’re out of stock in the home region. And so on. A real business in the real world knows how to pile on complexity faster than we can show on the page!",
      "content_length": 1436,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 61,
      "content": "But taking this simple domain model as a placeholder for something more complex, we’re going to extend our simple domain model in the rest of the book and plug it into the real world of APIs and databases\n\nand spreadsheets. We’ll see how sticking rigidly to our principles of encapsulation and careful layering will help us to avoid a ball of mud.\n\nMORE TYPES FOR MORE TYPE HINTS\n\nIf you really want to go to town with type hints, you could go so far as wrapping primitive types by using typing.NewType:\n\nJust taking it way too far, Bob\n\nfrom dataclasses import dataclass from typing import NewType\n\nQuantity = NewType(\"Quantity\", int) Sku = NewType(\"Sku\", str) Reference = NewType(\"Reference\", str) ...\n\nclass Batch: def __init__(self, ref: Reference, sku: Sku, qty: Quantity): self.sku = sku self.reference = ref self._purchased_quantity = qty\n\nThat would allow our type checker to make sure that we don’t pass a Sku where a Reference is expected, for example.\n\n4 Whether you think this is wonderful or appalling is a matter of debate.\n\nDataclasses Are Great for Value Objects\n\nWe’ve used line liberally in the previous code listings, but what is a line? In our business language, an order has multiple line items, where each line has a SKU and a quantity. We can imagine that a simple\n\nYAML file containing order information might look like this:\n\nOrder info as YAML",
      "content_length": 1369,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 62,
      "content": "Order_reference: 12345 Lines: - sku: RED-CHAIR qty: 25 - sku: BLU-CHAIR qty: 25 - sku: GRN-CHAIR qty: 25\n\nNotice that while an order has a reference that uniquely identifies it, a line does not. (Even if we add the order reference to the OrderLine class, it’s not something that uniquely identifies the line itself.)\n\nWhenever we have a business concept that has data but no identity, we often choose to represent it using the Value Object pattern. A value object is any domain object that is uniquely identified by the data it holds; we usually make them immutable:\n\nOrderLine is a value object\n\n@dataclass(frozen=True) class OrderLine: orderid: OrderReference sku: ProductReference qty: Quantity\n\nOne of the nice things that dataclasses (or namedtuples) give us is\n\nvalue equality, which is the fancy way of saying, “Two lines with the same orderid, sku, and qty are equal.”\n\nMore examples of value objects\n\nfrom dataclasses import dataclass from typing import NamedTuple from collections import namedtuple",
      "content_length": 1008,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 63,
      "content": "@dataclass(frozen=True) class Name: first_name: str surname: str\n\nclass Money(NamedTuple): currency: str value: int\n\nLine = namedtuple('Line', ['sku', 'qty'])\n\ndef test_equality(): assert Money('gbp', 10) == Money('gbp', 10) assert Name('Harry', 'Percival') != Name('Bob', 'Gregory') assert Line('RED-CHAIR', 5) == Line('RED-CHAIR', 5)\n\nThese value objects match our real-world intuition about how their values work. It doesn’t matter which £10 note we’re talking about, because they all have the same value. Likewise, two names are equal\n\nif both the first and last names match; and two lines are equivalent if they have the same customer order, product code, and quantity. We can still have complex behavior on a value object, though. In fact, it’s common to support operations on values; for example, mathematical\n\noperators:\n\nMath with value objects\n\nfiver = Money('gbp', 5) tenner = Money('gbp', 10)\n\ndef can_add_money_values_for_the_same_currency(): assert fiver + fiver == tenner\n\ndef can_subtract_money_values(): assert tenner - fiver == fiver",
      "content_length": 1051,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 64,
      "content": "def adding_different_currencies_fails(): with pytest.raises(ValueError): Money('usd', 10) + Money('gbp', 10)\n\ndef can_multiply_money_by_a_number(): assert fiver * 5 == Money('gbp', 25)\n\ndef multiplying_two_money_values_is_an_error(): with pytest.raises(TypeError): tenner * fiver\n\nValue Objects and Entities\n\nAn order line is uniquely identified by its order ID, SKU, and quantity; if we change one of those values, we now have a new line. That’s the definition of a value object: any object that is identified only by its\n\ndata and doesn’t have a long-lived identity. What about a batch, though? That is identified by a reference.\n\nWe use the term entity to describe a domain object that has long-lived identity. On the previous page, we introduced a Name class as a value object. If we take the name Harry Percival and change one letter, we have the new Name object Barry Percival.\n\nIt should be clear that Harry Percival is not equal to Barry Percival:\n\nA name itself cannot change…\n\ndef test_name_equality(): assert Name(\"Harry\", \"Percival\") != Name(\"Barry\", \"Percival\")\n\nBut what about Harry as a person? People do change their names, and their marital status, and even their gender, but we continue to recognize",
      "content_length": 1217,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 65,
      "content": "them as the same individual. That’s because humans, unlike names, have a persistent identity:\n\nBut a person can!\n\nclass Person:\n\ndef __init__(self, name: Name): self.name = name\n\ndef test_barry_is_harry(): harry = Person(Name(\"Harry\", \"Percival\")) barry = harry\n\nbarry.name = Name(\"Barry\", \"Percival\")\n\nassert harry is barry and barry is harry\n\nEntities, unlike values, have identity equality. We can change their values, and they are still recognizably the same thing. Batches, in our example, are entities. We can allocate lines to a batch, or change the\n\ndate that we expect it to arrive, and it will still be the same entity.\n\nWe usually make this explicit in code by implementing equality operators on entities:\n\nImplementing equality operators (model.py)\n\nclass Batch: ...\n\ndef __eq__(self, other): if not isinstance(other, Batch): return False return other.reference == self.reference",
      "content_length": 891,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 66,
      "content": "def __hash__(self): return hash(self.reference)\n\nPython’s __eq__ magic method defines the behavior of the class for 5 the == operator.\n\nFor both entity and value objects, it’s also worth thinking through how __hash__ will work. It’s the magic method Python uses to control the behavior of objects when you add them to sets or use them as dict keys; you can find more info in the Python docs.\n\nFor value objects, the hash should be based on all the value attributes,\n\nand we should ensure that the objects are immutable. We get this for free by specifying @frozen=True on the dataclass.\n\nFor entities, the simplest option is to say that the hash is None, meaning that the object is not hashable and cannot, for example, be used in a\n\nset. If for some reason you decide you really do want to use set or dict operations with entities, the hash should be based on the attribute(s), such as .reference, that defines the entity’s unique identity over time. You should also try to somehow make that attribute read-only.\n\nWARNING\n\nThis is tricky territory; you shouldn’t modify __hash__ without also modifying __eq__. If you’re not sure what you’re doing, further reading is suggested. “Python Hashes and Equality” by our tech reviewer Hynek Schlawack is a good place to start.",
      "content_length": 1269,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 67,
      "content": "Not Everything Has to Be an Object: A Domain Service Function\n\nWe’ve made a model to represent batches, but what we actually need to do is allocate order lines against a specific set of batches that\n\nrepresent all our stock.\n\nSometimes, it just isn’t a thing.\n\n—Eric Evans, Domain-Driven Design\n\nEvans discusses the idea of Domain Service operations that don’t have a natural home in an entity or value object. A thing that allocates an\n\n6\n\norder line, given a set of batches, sounds a lot like a function, and we can take advantage of the fact that Python is a multiparadigm language and just make it a function.\n\nLet’s see how we might test-drive such a function:\n\nTesting our domain service (test_allocate.py)\n\ndef test_prefers_current_stock_batches_to_shipments(): in_stock_batch = Batch(\"in-stock-batch\", \"RETRO-CLOCK\", 100, eta=None) shipment_batch = Batch(\"shipment-batch\", \"RETRO-CLOCK\", 100, eta=tomorrow) line = OrderLine(\"oref\", \"RETRO-CLOCK\", 10)\n\nallocate(line, [in_stock_batch, shipment_batch])\n\nassert in_stock_batch.available_quantity == 90 assert shipment_batch.available_quantity == 100\n\ndef test_prefers_earlier_batches(): earliest = Batch(\"speedy-batch\", \"MINIMALIST-SPOON\", 100, eta=today) medium = Batch(\"normal-batch\", \"MINIMALIST-SPOON\", 100, eta=tomorrow) latest = Batch(\"slow-batch\", \"MINIMALIST-SPOON\", 100, eta=later)",
      "content_length": 1345,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 68,
      "content": "line = OrderLine(\"order1\", \"MINIMALIST-SPOON\", 10)\n\nallocate(line, [medium, earliest, latest])\n\nassert earliest.available_quantity == 90 assert medium.available_quantity == 100 assert latest.available_quantity == 100\n\ndef test_returns_allocated_batch_ref(): in_stock_batch = Batch(\"in-stock-batch-ref\", \"HIGHBROW-POSTER\", 100, eta=None) shipment_batch = Batch(\"shipment-batch-ref\", \"HIGHBROW-POSTER\", 100, eta=tomorrow) line = OrderLine(\"oref\", \"HIGHBROW-POSTER\", 10) allocation = allocate(line, [in_stock_batch, shipment_batch]) assert allocation == in_stock_batch.reference\n\nAnd our service might look like this:\n\nA standalone function for our domain service (model.py)\n\ndef allocate(line: OrderLine, batches: List[Batch]) -> str: batch = next( b for b in sorted(batches) if b.can_allocate(line) ) batch.allocate(line) return batch.reference\n\nPython’s Magic Methods Let Us Use Our Models with Idiomatic Python\n\nYou may or may not like the use of next() in the preceding code, but we’re pretty sure you’ll agree that being able to use sorted() on our list of batches is nice, idiomatic Python.\n\nTo make it work, we implement __gt__ on our domain model:",
      "content_length": 1153,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 69,
      "content": "Magic methods can express domain semantics (model.py)\n\nclass Batch: ...\n\ndef __gt__(self, other): if self.eta is None: return False if other.eta is None: return True return self.eta > other.eta\n\nThat’s lovely.\n\nExceptions Can Express Domain Concepts Too\n\nWe have one final concept to cover: exceptions can be used to express domain concepts too. In our conversations with domain experts, we’ve learned about the possibility that an order cannot be allocated because we are out of stock, and we can capture that by using a domain\n\nexception:\n\nTesting out-of-stock exception (test_allocate.py)\n\ndef test_raises_out_of_stock_exception_if_cannot_allocate(): batch = Batch('batch1', 'SMALL-FORK', 10, eta=today) allocate(OrderLine('order1', 'SMALL-FORK', 10), [batch])\n\nwith pytest.raises(OutOfStock, match='SMALL-FORK'): allocate(OrderLine('order2', 'SMALL-FORK', 1), [batch])",
      "content_length": 872,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 70,
      "content": "DOMAIN MODELING RECAP\n\nDomain modeling\n\nThis is the part of your code that is closest to the business, the most likely to change, and the place where you deliver the most value to the business. Make it easy to understand and modify.\n\nDistinguish entities from value objects\n\nA value object is defined by its attributes. It’s usually best implemented as an immutable type. If you change an attribute on a Value Object, it represents a different object. In contrast, an entity has attributes that may vary over time and it will still be the same entity. It’s important to define what does uniquely identify an entity (usually some sort of name or reference field).\n\nNot everything has to be an object\n\nPython is a multiparadigm language, so let the “verbs” in your code be functions. For every FooManager, BarBuilder, or BazFactory, there’s often a more expressive and readable manage_foo(), build_bar(), or get_baz() waiting to happen.\n\nThis is the time to apply your best OO design principles\n\nRevisit the SOLID principles and all the other good heuristics like “has a versus is-a,” “prefer composition over inheritance,” and so on.\n\nYou’ll also want to think about consistency boundaries and aggregates\n\nBut that’s a topic for Chapter 7.\n\nWe won’t bore you too much with the implementation, but the main thing to note is that we take care in naming our exceptions in the ubiquitous language, just as we do our entities, value objects, and services:\n\nRaising a domain exception (model.py)\n\nclass OutOfStock(Exception): pass\n\ndef allocate(line: OrderLine, batches: List[Batch]) -> str: try: batch = next( ...",
      "content_length": 1607,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 71,
      "content": "except StopIteration: raise OutOfStock(f'Out of stock for sku {line.sku}')\n\nFigure 1-4 is a visual representation of where we’ve ended up.",
      "content_length": 138,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 73,
      "content": "Figure 1-4. Our domain model at the end of the chapter\n\nThat’ll probably do for now! We have a domain service that we can\n\nuse for our first use case. But first we’ll need a database…\n\n1 DDD did not originate domain modeling. Eric Evans refers to the 2002 book Object\n\nDesign by Rebecca Wirfs-Brock and Alan McKean (Addison-Wesley Professional), which introduced responsibility-driven design, of which DDD is a special case dealing with the domain. But even that is too late, and OO enthusiasts will tell you to look further back to Ivar Jacobson and Grady Booch; the term has been around since the mid-1980s.\n\n2 In previous Python versions, we might have used a namedtuple. You could also check out\n\nHynek Schlawack’s excellent attrs.\n\n3 Or perhaps you think there’s not enough code? What about some sort of check that the SKU in the OrderLine matches Batch.sku? We saved some thoughts on validation for Appendix E.\n\n4 It is appalling. Please, please don’t do this. —Harry\n\n5 The __eq__ method is pronounced “dunder-EQ.” By some, at least.\n\n6 Domain services are not the same thing as the services from the service layer, although\n\nthey are often closely related. A domain service represents a business concept or process, whereas a service-layer service represents a use case for your application. Often the service layer will call a domain service.",
      "content_length": 1351,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 74,
      "content": "Chapter 2. Repository Pattern\n\nIt’s time to make good on our promise to use the dependency inversion principle as a way of decoupling our core logic from infrastructural concerns.\n\nWe’ll introduce the Repository pattern, a simplifying abstraction over\n\ndata storage, allowing us to decouple our model layer from the data\n\nlayer. We’ll present a concrete example of how this simplifying\n\nabstraction makes our system more testable by hiding the complexities of the database.\n\nFigure 2-1 shows a little preview of what we’re going to build: a Repository object that sits between our domain model and the database.",
      "content_length": 611,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 75,
      "content": "Figure 2-1. Before and after the Repository pattern",
      "content_length": 51,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 76,
      "content": "TIP\n\nThe code for this chapter is in the chapter_02_repository branch on GitHub.\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_02_repository # or to code along, checkout the previous chapter: git checkout chapter_01_domain_model\n\nPersisting Our Domain Model\n\nIn Chapter 1 we built a simple domain model that can allocate orders to batches of stock. It’s easy for us to write tests against this code because there aren’t any dependencies or infrastructure to set up. If we needed to run a database or an API and create test data, our tests would be harder to write and maintain.\n\nSadly, at some point we’ll need to put our perfect little model in the hands of users and contend with the real world of spreadsheets and web browsers and race conditions. For the next few chapters we’re going to look at how we can connect our idealized domain model to external state.\n\nWe expect to be working in an agile manner, so our priority is to get to a minimum viable product as quickly as possible. In our case, that’s going to be a web API. In a real project, you might dive straight in\n\nwith some end-to-end tests and start plugging in a web framework, test-driving things outside-in.",
      "content_length": 1210,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 77,
      "content": "But we know that, no matter what, we’re going to need some form of persistent storage, and this is a textbook, so we can allow ourselves a tiny bit more bottom-up development and start to think about storage and databases.\n\nSome Pseudocode: What Are We Going to Need?\n\nWhen we build our first API endpoint, we know we’re going to have some code that looks more or less like the following.\n\nWhat our first API endpoint will look like\n\n@flask.route.gubbins def allocate_endpoint(): # extract order line from request line = OrderLine(request.params, ...) # load all batches from the DB batches = ... # call our domain service allocate(line, batches) # then save the allocation back to the database somehow return 201\n\nNOTE\n\nWe’ve used Flask because it’s lightweight, but you don’t need to be a Flask user to understand this book. In fact, we’ll show you how to make your choice of framework a minor detail.\n\nWe’ll need a way to retrieve batch info from the database and instantiate our domain model objects from it, and we’ll also need a",
      "content_length": 1034,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 78,
      "content": "way of saving them back to the database.\n\nWhat? Oh, “gubbins” is a British word for “stuff.” You can just ignore that. It’s pseudocode, OK?\n\nApplying the DIP to Data Access\n\nAs mentioned in the introduction, a layered architecture is a common approach to structuring a system that has a UI, some logic, and a database (see Figure 2-2).\n\nFigure 2-2. Layered architecture",
      "content_length": 369,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 79,
      "content": "Django’s Model-View-Template structure is closely related, as is Model-View-Controller (MVC). In any case, the aim is to keep the layers separate (which is a good thing), and to have each layer depend only on the one below it.\n\nBut we want our domain model to have no dependencies whatsoever. We don’t want infrastructure concerns bleeding over into our domain model and slowing our unit tests or our ability to make changes.\n\nInstead, as discussed in the introduction, we’ll think of our model as being on the “inside,” and dependencies flowing inward to it; this is what people sometimes call onion architecture (see Figure 2-3).\n\n1",
      "content_length": 634,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 80,
      "content": "Figure 2-3. Onion architecture\n\nIS THIS PORTS AND ADAPTERS?\n\nIf you’ve been reading about architectural patterns, you may be asking yourself questions like this:\n\nIs this ports and adapters? Or is it hexagonal architecture? Is that the same as onion architecture? What about the clean architecture? What’s a port, and what’s an adapter? Why do you people have so many words for the same thing?\n\nAlthough some people like to nitpick over the differences, all these are pretty much names for the same thing, and they all boil down to the dependency inversion principle: high-level modules (the 2 domain) should not depend on low-level ones (the infrastructure).\n\nWe’ll get into some of the nitty-gritty around “depending on abstractions,” and whether there is a Pythonic equivalent of interfaces, later in the book. See also “What Is a Port and What Is an Adapter, in Python?”.",
      "content_length": 875,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 81,
      "content": "Reminder: Our Model\n\nLet’s remind ourselves of our domain model (see Figure 2-4): an allocation is the concept of linking an OrderLine to a Batch. We’re storing the allocations as a collection on our Batch object.\n\nFigure 2-4. Our model\n\nLet’s see how we might translate this to a relational database.\n\nThe “Normal” ORM Way: Model Depends on ORM\n\nThese days, it’s unlikely that your team members are hand-rolling their own SQL queries. Instead, you’re almost certainly using some kind of\n\nframework to generate SQL for you based on your model objects.\n\nThese frameworks are called object-relational mappers (ORMs) because they exist to bridge the conceptual gap between the world of\n\nobjects and domain modeling and the world of databases and relational algebra.\n\nThe most important thing an ORM gives us is persistence ignorance:\n\nthe idea that our fancy domain model doesn’t need to know anything",
      "content_length": 898,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 82,
      "content": "about how data is loaded or persisted. This helps keep our domain 3 clean of direct dependencies on particular database technologies.\n\nBut if you follow the typical SQLAlchemy tutorial, you’ll end up with\n\nsomething like this:\n\nSQLAlchemy “declarative” syntax, model depends on ORM (orm.py)\n\nfrom sqlalchemy import Column, ForeignKey, Integer, String from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import relationship\n\nBase = declarative_base()\n\nclass Order(Base): id = Column(Integer, primary_key=True)\n\nclass OrderLine(Base): id = Column(Integer, primary_key=True) sku = Column(String(250)) qty = Integer(String(250)) order_id = Column(Integer, ForeignKey('order.id')) order = relationship(Order)\n\nclass Allocation(Base): ...\n\nYou don’t need to understand SQLAlchemy to see that our pristine model is now full of dependencies on the ORM and is starting to look\n\nugly as hell besides. Can we really say this model is ignorant of the database? How can it be separate from storage concerns when our\n\nmodel properties are directly coupled to database columns?",
      "content_length": 1086,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 83,
      "content": "DJANGO’S ORM IS ESSENTIALLY THE SAME, BUT MORE RESTRICTIVE\n\nIf you’re more used to Django, the preceding “declarative” SQLAlchemy snippet translates to something like this:\n\nDjango ORM example\n\nclass Order(models.Model): pass\n\nclass OrderLine(models.Model): sku = models.CharField(max_length=255) qty = models.IntegerField() order = models.ForeignKey(Order)\n\nclass Allocation(models.Model): ...\n\nThe point is the same—our model classes inherit directly from ORM classes, so our model depends on the ORM. We want it to be the other way around.\n\nDjango doesn’t provide an equivalent for SQLAlchemy’s classical mapper, but see Appendix D for examples of how to apply dependency inversion and the Repository pattern to Django.\n\nInverting the Dependency: ORM Depends on Model\n\nWell, thankfully, that’s not the only way to use SQLAlchemy. The\n\nalternative is to define your schema separately, and to define an explicit mapper for how to convert between the schema and our\n\ndomain model, what SQLAlchemy calls a classical mapping:\n\nExplicit ORM mapping with SQLAlchemy Table objects (orm.py)\n\nfrom sqlalchemy.orm import mapper, relationship\n\nimport model\n\nmetadata = MetaData()",
      "content_length": 1170,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 84,
      "content": "order_lines = Table( 'order_lines', metadata, Column('id', Integer, primary_key=True, autoincrement=True), Column('sku', String(255)), Column('qty', Integer, nullable=False), Column('orderid', String(255)), )\n\n...\n\ndef start_mappers(): lines_mapper = mapper(model.OrderLine, order_lines)\n\nThe ORM imports (or “depends on” or “knows about”) the domain model, and not the other way around.\n\nWe define our database tables and columns by using SQLAlchemy’s abstractions.\n\n4\n\nWhen we call the mapper function, SQLAlchemy does its magic to bind our domain model classes to the various tables we’ve defined.\n\nThe end result will be that, if we call start_mappers, we will be able to easily load and save domain model instances from and to the\n\ndatabase. But if we never call that function, our domain model classes stay blissfully unaware of the database.\n\nThis gives us all the benefits of SQLAlchemy, including the ability to use alembic for migrations, and the ability to transparently query using our domain classes, as we’ll see.\n\nWhen you’re first trying to build your ORM config, it can be useful to write tests for it, as in the following example:",
      "content_length": 1148,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 85,
      "content": "Testing the ORM directly (throwaway tests) (test_orm.py)\n\ndef test_orderline_mapper_can_load_lines(session): session.execute( 'INSERT INTO order_lines (orderid, sku, qty) VALUES ' '(\"order1\", \"RED-CHAIR\", 12),' '(\"order1\", \"RED-TABLE\", 13),' '(\"order2\", \"BLUE-LIPSTICK\", 14)' ) expected = [ model.OrderLine(\"order1\", \"RED-CHAIR\", 12), model.OrderLine(\"order1\", \"RED-TABLE\", 13), model.OrderLine(\"order2\", \"BLUE-LIPSTICK\", 14), ] assert session.query(model.OrderLine).all() == expected\n\ndef test_orderline_mapper_can_save_lines(session): new_line = model.OrderLine(\"order1\", \"DECORATIVE-WIDGET\", 12) session.add(new_line) session.commit()\n\nrows = list(session.execute('SELECT orderid, sku, qty FROM \"order_lines\"')) assert rows == [(\"order1\", \"DECORATIVE-WIDGET\", 12)]\n\nIf you haven’t used pytest, the session argument to this test needs explaining. You don’t need to worry about the details of pytest or its fixtures for the purposes of this book, but the short explanation is that you can define common dependencies for your tests as “fixtures,” and pytest will inject them to the tests that need them by looking at their function arguments. In this case, it’s a SQLAlchemy database session.\n\nYou probably wouldn’t keep these tests around—as you’ll see shortly,\n\nonce you’ve taken the step of inverting the dependency of ORM and domain model, it’s only a small additional step to implement another\n\nabstraction called the Repository pattern, which will be easier to write",
      "content_length": 1472,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 86,
      "content": "tests against and will provide a simple interface for faking out later in\n\ntests.\n\nBut we’ve already achieved our objective of inverting the traditional dependency: the domain model stays “pure” and free from\n\ninfrastructure concerns. We could throw away SQLAlchemy and use a different ORM, or a totally different persistence system, and the\n\ndomain model doesn’t need to change at all.\n\nDepending on what you’re doing in your domain model, and especially if you stray far from the OO paradigm, you may find it increasingly\n\nhard to get the ORM to produce the exact behavior you need, and you may need to modify your domain model. As so often happens with\n\n5\n\narchitectural decisions, you’ll need to consider a trade-off. As the Zen\n\nof Python says, “Practicality beats purity!”\n\nAt this point, though, our API endpoint might look something like the following, and we could get it to work just fine:\n\nUsing SQLAlchemy directly in our API endpoint\n\n@flask.route.gubbins def allocate_endpoint(): session = start_session()\n\n# extract order line from request line = OrderLine( request.json['orderid'], request.json['sku'], request.json['qty'], )\n\n# load all batches from the DB",
      "content_length": 1173,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 87,
      "content": "batches = session.query(Batch).all()\n\n# call our domain service allocate(line, batches)\n\n# save the allocation back to the database session.commit()\n\nreturn 201\n\nIntroducing the Repository Pattern\n\nThe Repository pattern is an abstraction over persistent storage. It\n\nhides the boring details of data access by pretending that all of our data is in memory.\n\nIf we had infinite memory in our laptops, we’d have no need for clumsy databases. Instead, we could just use our objects whenever we liked. What would that look like?\n\nYou have to get your data from somewhere\n\nimport all_my_data\n\ndef create_a_batch(): batch = Batch(...) all_my_data.batches.add(batch)\n\ndef modify_a_batch(batch_id, new_quantity): batch = all_my_data.batches.get(batch_id) batch.change_initial_quantity(new_quantity)\n\nEven though our objects are in memory, we need to put them somewhere so we can find them again. Our in-memory data would let\n\nus add new objects, just like a list or a set. Because the objects are in",
      "content_length": 991,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 88,
      "content": "memory, we never need to call a .save() method; we just fetch the object we care about and modify it in memory.\n\nThe Repository in the Abstract\n\nThe simplest repository has just two methods: add() to put a new item in the repository, and get() to return a previously added item. We stick rigidly to using these methods for data access in our domain and\n\n6\n\nour service layer. This self-imposed simplicity stops us from coupling our domain model to the database.\n\nHere’s what an abstract base class (ABC) for our repository would\n\nlook like:\n\nThe simplest possible repository (repository.py)\n\nclass AbstractRepository(abc.ABC):\n\n@abc.abstractmethod def add(self, batch: model.Batch): raise NotImplementedError\n\n@abc.abstractmethod def get(self, reference) -> model.Batch: raise NotImplementedError\n\nPython tip: @abc.abstractmethod is one of the only things that makes ABCs actually “work” in Python. Python will refuse to let you instantiate a class that does not implement all the abstractmethods defined in its parent class.\n\n7\n\nraise NotImplementedError is nice, but it’s neither necessary nor sufficient. In fact, your abstract methods can have real behavior that subclasses can call out to, if you really want.",
      "content_length": 1214,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 89,
      "content": "ABSTRACT BASE CLASSES, DUCK TYPING, AND PROTOCOLS\n\nWe’re using abstract base classes in this book for didactic reasons: we hope they help explain what the interface of the repository abstraction is.\n\nIn real life, we’ve sometimes found ourselves deleting ABCs from our production code, because Python makes it too easy to ignore them, and they end up unmaintained and, at worst, misleading. In practice we often just rely on Python’s duck typing to enable abstractions. To a Pythonista, a repository is any object that has add(thing) and get(id) methods.\n\nAn alternative to look into is PEP 544 protocols. These give you typing without the possibility of inheritance, which “prefer composition over inheritance” fans will particularly like.\n\nWhat Is the Trade-Off?\n\nYou know they say economists know the price of everything and the value of nothing? Well, programmers know the benefits of everything and the trade-offs of nothing.\n\n—Rich Hickey\n\nWhenever we introduce an architectural pattern in this book, we’ll always ask, “What do we get for this? And what does it cost us?”\n\nUsually, at the very least, we’ll be introducing an extra layer of abstraction, and although we may hope it will reduce complexity overall, it does add complexity locally, and it has a cost in terms of the\n\nraw numbers of moving parts and ongoing maintenance.\n\nThe Repository pattern is probably one of the easiest choices in the book, though, if you’re already heading down the DDD and\n\ndependency inversion route. As far as our code is concerned, we’re really just swapping the SQLAlchemy abstraction (session.query(Batch)) for a different one (batches_repo.get) that we designed.",
      "content_length": 1661,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 90,
      "content": "We will have to write a few lines of code in our repository class each time we add a new domain object that we want to retrieve, but in\n\nreturn we get a simple abstraction over our storage layer, which we control. The Repository pattern would make it easy to make fundamental changes to the way we store things (see Appendix C), and as we’ll see, it is easy to fake out for unit tests.\n\nIn addition, the Repository pattern is so common in the DDD world that, if you do collaborate with programmers who have come to Python from the Java and C# worlds, they’re likely to recognize it. Figure 2-5\n\nillustrates the pattern.\n\nFigure 2-5. Repository pattern\n\nAs always, we start with a test. This would probably be classified as an integration test, since we’re checking that our code (the repository)\n\nis correctly integrated with the database; hence, the tests tend to mix raw SQL with calls and assertions on our own code.\n\nTIP\n\nUnlike the ORM tests from earlier, these tests are good candidates for staying part of your codebase longer term, particularly if any parts of your domain model mean the object-relational map is nontrivial.",
      "content_length": 1132,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 91,
      "content": "Repository test for saving an object (test_repository.py)\n\ndef test_repository_can_save_a_batch(session): batch = model.Batch(\"batch1\", \"RUSTY-SOAPDISH\", 100, eta=None)\n\nrepo = repository.SqlAlchemyRepository(session) repo.add(batch) session.commit()\n\nrows = list(session.execute( 'SELECT reference, sku, _purchased_quantity, eta FROM \"batches\"' )) assert rows == [(\"batch1\", \"RUSTY-SOAPDISH\", 100, None)]\n\nrepo.add() is the method under test here.\n\nWe keep the .commit() outside of the repository and make it the responsibility of the caller. There are pros and cons for this; some of our reasons will become clearer when we get to Chapter 6.\n\nWe use the raw SQL to verify that the right data has been saved.\n\nThe next test involves retrieving batches and allocations, so it’s more\n\ncomplex:\n\nRepository test for retrieving a complex object (test_repository.py)\n\ndef insert_order_line(session): session.execute( 'INSERT INTO order_lines (orderid, sku, qty)' ' VALUES (\"order1\", \"GENERIC-SOFA\", 12)' ) [[orderline_id]] = session.execute( 'SELECT id FROM order_lines WHERE orderid=:orderid AND sku=:sku', dict(orderid=\"order1\", sku=\"GENERIC-SOFA\") ) return orderline_id",
      "content_length": 1168,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 92,
      "content": "def insert_batch(session, batch_id): ...\n\ndef test_repository_can_retrieve_a_batch_with_allocations(session): orderline_id = insert_order_line(session) batch1_id = insert_batch(session, \"batch1\") insert_batch(session, \"batch2\") insert_allocation(session, orderline_id, batch1_id)\n\nrepo = repository.SqlAlchemyRepository(session) retrieved = repo.get(\"batch1\")\n\nexpected = model.Batch(\"batch1\", \"GENERIC-SOFA\", 100, eta=None) assert retrieved == expected # Batch.__eq__ only compares reference assert retrieved.sku == expected.sku assert retrieved._purchased_quantity == expected._purchased_quantity assert retrieved._allocations == { model.OrderLine(\"order1\", \"GENERIC-SOFA\", 12), }\n\nThis tests the read side, so the raw SQL is preparing data to be read by the repo.get().\n\nWe’ll spare you the details of insert_batch and insert_allocation; the point is to create a couple of batches, and, for the batch we’re interested in, to have one existing order line allocated to it.\n\nAnd that’s what we verify here. The first assert == checks that the types match, and that the reference is the same (because, as you remember, Batch is an entity, and we have a custom eq for it).\n\nSo we also explicitly check on its major attributes, including ._allocations, which is a Python set of OrderLine value objects.\n\nWhether or not you painstakingly write tests for every model is a judgment call. Once you have one class tested for create/modify/save,",
      "content_length": 1436,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 93,
      "content": "you might be happy to go on and do the others with a minimal round- trip test, or even nothing at all, if they all follow a similar pattern. In our case, the ORM config that sets up the ._allocations set is a little complex, so it merited a specific test.\n\nYou end up with something like this:\n\nA typical repository (repository.py)\n\nclass SqlAlchemyRepository(AbstractRepository):\n\ndef __init__(self, session): self.session = session\n\ndef add(self, batch): self.session.add(batch)\n\ndef get(self, reference): return self.session.query(model.Batch).filter_by(reference=reference).one()\n\ndef list(self): return self.session.query(model.Batch).all()\n\nAnd now our Flask endpoint might look something like the following:\n\nUsing our repository directly in our API endpoint\n\n@flask.route.gubbins def allocate_endpoint(): batches = SqlAlchemyRepository.list() lines = [ OrderLine(l['orderid'], l['sku'], l['qty']) for l in request.params... ] allocate(lines, batches)",
      "content_length": 958,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 94,
      "content": "session.commit() return 201\n\nEXERCISE FOR THE READER\n\nWe bumped into a friend at a DDD conference the other day who said, “I haven’t used an ORM in 10 years.” The Repository pattern and an ORM both act as abstractions in front of raw SQL, so using one behind the other isn’t really necessary. Why not have a go at implementing our repository without using the ORM? You’ll find the code on GitHub.\n\nWe’ve left the repository tests, but figuring out what SQL to write is up to you. Perhaps it’ll be harder than you think; perhaps it’ll be easier. But the nice thing is, the rest of your application just doesn’t care.\n\nBuilding a Fake Repository for Tests Is Now Trivial!\n\nHere’s one of the biggest benefits of the Repository pattern:\n\nA simple fake repository using a set (repository.py)\n\nclass FakeRepository(AbstractRepository):\n\ndef __init__(self, batches): self._batches = set(batches)\n\ndef add(self, batch): self._batches.add(batch)\n\ndef get(self, reference): return next(b for b in self._batches if b.reference == reference)\n\ndef list(self): return list(self._batches)\n\nBecause it’s a simple wrapper around a set, all the methods are one- liners.",
      "content_length": 1151,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 95,
      "content": "Using a fake repo in tests is really easy, and we have a simple abstraction that’s easy to use and reason about:\n\nExample usage of fake repository (test_api.py)\n\nfake_repo = FakeRepository([batch1, batch2, batch3])\n\nYou’ll see this fake in action in the next chapter.\n\nTIP\n\nBuilding fakes for your abstractions is an excellent way to get design feedback: if it’s hard to fake, the abstraction is probably too complicated.\n\nWhat Is a Port and What Is an Adapter, in Python?\n\nWe don’t want to dwell on the terminology too much here because the main thing we want to focus on is dependency inversion, and the\n\nspecifics of the technique you use don’t matter too much. Also, we’re aware that different people use slightly different definitions.\n\nPorts and adapters came out of the OO world, and the definition we\n\nhold onto is that the port is the interface between our application and whatever it is we wish to abstract away, and the adapter is the implementation behind that interface or abstraction.\n\nNow Python doesn’t have interfaces per se, so although it’s usually easy to identify an adapter, defining the port can be harder. If you’re",
      "content_length": 1139,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 96,
      "content": "using an abstract base class, that’s the port. If not, the port is just the\n\nduck type that your adapters conform to and that your core application expects—the function and method names in use, and their argument names and types.\n\nConcretely, in this chapter, AbstractRepository is the port, and SqlAlchemyRepository and FakeRepository are the adapters.\n\nWrap-Up\n\nBearing the Rich Hickey quote in mind, in each chapter we summarize the costs and benefits of each architectural pattern we introduce. We want to be clear that we’re not saying every single application needs\n\nto be built this way; only sometimes does the complexity of the app and domain make it worth investing the time and effort in adding these extra layers of indirection.\n\nWith that in mind, Table 2-1 shows some of the pros and cons of the Repository pattern and our persistence-ignorant model.",
      "content_length": 864,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 97,
      "content": "Table 2-1. Repository pattern and persistence ignorance: the trade-offs\n\nPros\n\nCons",
      "content_length": 83,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 98,
      "content": "Pros\n\nWe have a simple interface between persistent storage and our domain model.\n\nIt’s easy to make a fake version of the repository for unit testing, or to swap out different storage solutions, because we’ve fully decoupled the model from infrastructure concerns.\n\nWriting the domain model before thinking about persistence helps us focus on the business problem at hand. If we ever want to radically change our approach, we can do that in our model, without needing to worry about foreign keys or migrations until later.\n\nOur database schema is really simple because we have complete control over how we map our objects to tables.\n\nCons\n\nAn ORM already buys you some decoupling. Changing foreign keys might be hard, but it should be pretty easy to swap between MySQL and Postgres if you ever need to.\n\nMaintaining ORM mappings by hand requires extra work and extra code.\n\nAny extra layer of indirection always increases maintenance costs and adds a “WTF factor” for Python programmers who’ve never seen the Repository pattern before.",
      "content_length": 1036,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 99,
      "content": "Figure 2-6 shows the basic thesis: yes, for simple cases, a decoupled domain model is harder work than a simple ORM/ActiveRecord pattern.\n\n8\n\nTIP\n\nIf your app is just a simple CRUD (create-read-update-delete) wrapper around a database, then you don’t need a domain model or a repository.\n\nBut the more complex the domain, the more an investment in freeing yourself from infrastructure concerns will pay off in terms of the ease of making changes.",
      "content_length": 446,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 100,
      "content": "Figure 2-6. Domain model trade-offs as a diagram\n\nOur example code isn’t complex enough to give more than a hint of what the right-hand side of the graph looks like, but the hints are there. Imagine, for example, if we decide one day that we want to change allocations to live on the OrderLine instead of on the Batch object: if we were using Django, say, we’d have to define and think through the\n\ndatabase migration before we could run any tests. As it is, because our model is just plain old Python objects, we can change a set() to being a new attribute, without needing to think about the database until later.",
      "content_length": 615,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 101,
      "content": "REPOSITORY PATTERN RECAP\n\nApply dependency inversion to your ORM\n\nOur domain model should be free of infrastructure concerns, so your ORM should import your model, and not the other way around.\n\nThe Repository pattern is a simple abstraction around permanent storage\n\nThe repository gives you the illusion of a collection of in-memory objects. It makes it easy to create a FakeRepository for testing and to swap fundamental details of your infrastructure without disrupting your core application. See Appendix C for an example.\n\nYou’ll be wondering, how do we instantiate these repositories, fake or real? What will our Flask app actually look like? You’ll find out in the\n\nnext exciting installment, the Service Layer pattern.\n\nBut first, a brief digression.\n\n1 I suppose we mean “no stateful dependencies.” Depending on a helper library is fine;\n\ndepending on an ORM or a web framework is not.\n\n2 Mark Seemann has an excellent blog post on the topic.\n\n3 In this sense, using an ORM is already an example of the DIP. Instead of depending on hardcoded SQL, we depend on an abstraction, the ORM. But that’s not enough for us— not in this book!\n\n4 Even in projects where we don’t use an ORM, we often use SQLAlchemy alongside\n\nAlembic to declaratively create schemas in Python and to manage migrations, connections, and sessions.\n\n5 Shout-out to the amazingly helpful SQLAlchemy maintainers, and to Mike Bayer in\n\nparticular.\n\n6 You may be thinking, “What about list or delete or update?” However, in an ideal\n\nworld, we modify our model objects one at a time, and delete is usually handled as a soft- delete—i.e., batch.cancel(). Finally, update is taken care of by the Unit of Work pattern, as you’ll see in Chapter 6.",
      "content_length": 1718,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 102,
      "content": "7 To really reap the benefits of ABCs (such as they may be), be running helpers like\n\npylint and mypy.\n\n8 Diagram inspired by a post called “Global Complexity, Local Simplicity” by Rob Vens.",
      "content_length": 190,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 103,
      "content": "Chapter 3. A Brief Interlude: On Coupling and Abstractions\n\nAllow us a brief digression on the subject of abstractions, dear reader. We’ve talked about abstractions quite a lot. The Repository pattern is an abstraction over permanent storage, for example. But what makes a\n\ngood abstraction? What do we want from abstractions? And how do they relate to testing?\n\nTIP\n\nThe code for this chapter is in the chapter_03_abstractions branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git git checkout chapter_03_abstractions\n\nA key theme in this book, hidden among the fancy patterns, is that we can use simple abstractions to hide messy details. When we’re writing\n\n1\n\ncode for fun, or in a kata, we get to play with ideas freely, hammering things out and refactoring aggressively. In a large-scale system, though, we become constrained by the decisions made elsewhere in the system.",
      "content_length": 894,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 104,
      "content": "When we’re unable to change component A for fear of breaking component B, we say that the components have become coupled. Locally, coupling is a good thing: it’s a sign that our code is working together, each component supporting the others, all of them fitting in\n\nplace like the gears of a watch. In jargon, we say this works when there is high cohesion between the coupled elements.\n\nGlobally, coupling is a nuisance: it increases the risk and the cost of changing our code, sometimes to the point where we feel unable to make any changes at all. This is the problem with the Ball of Mud pattern: as the application grows, if we’re unable to prevent coupling\n\nbetween elements that have no cohesion, that coupling increases superlinearly until we are no longer able to effectively change our systems.\n\nWe can reduce the degree of coupling within a system (Figure 3-1) by abstracting away the details (Figure 3-2).\n\nFigure 3-1. Lots of coupling\n\nFigure 3-2. Less coupling\n\nIn both diagrams, we have a pair of subsystems, with one dependent on the other. In Figure 3-1, there is a high degree of coupling between the",
      "content_length": 1117,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 105,
      "content": "two; the number of arrows indicates lots of kinds of dependencies between the two. If we need to change system B, there’s a good chance that the change will ripple through to system A.\n\nIn Figure 3-2, though, we have reduced the degree of coupling by inserting a new, simpler abstraction. Because it is simpler, system A has fewer kinds of dependencies on the abstraction. The abstraction\n\nserves to protect us from change by hiding away the complex details of whatever system B does—we can change the arrows on the right without changing the ones on the left.\n\nAbstracting State Aids Testability\n\nLet’s see an example. Imagine we want to write code for synchronizing two file directories, which we’ll call the source and the destination:\n\nIf a file exists in the source but not in the destination, copy the file over.\n\nIf a file exists in the source, but it has a different name than in the destination, rename the destination file to match.\n\nIf a file exists in the destination but not in the source, remove it.\n\nOur first and third requirements are simple enough: we can just compare two lists of paths. Our second is trickier, though. To detect\n\nrenames, we’ll have to inspect the content of files. For this, we can use a hashing function like MD5 or SHA-1. The code to generate a SHA-1 hash from a file is simple enough:\n\nHashing a file (sync.py)",
      "content_length": 1351,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 106,
      "content": "BLOCKSIZE = 65536\n\ndef hash_file(path): hasher = hashlib.sha1() with path.open(\"rb\") as file: buf = file.read(BLOCKSIZE) while buf: hasher.update(buf) buf = file.read(BLOCKSIZE) return hasher.hexdigest()\n\nNow we need to write the bit that makes decisions about what to do— the business logic, if you will.\n\nWhen we have to tackle a problem from first principles, we usually try to write a simple implementation and then refactor toward better design. We’ll use this approach throughout the book, because it’s how we write code in the real world: start with a solution to the smallest part of the problem, and then iteratively make the solution richer and better designed.\n\nOur first hackish approach looks something like this:\n\nBasic sync algorithm (sync.py)\n\nimport hashlib import os import shutil from pathlib import Path\n\ndef sync(source, dest): # Walk the source folder and build a dict of filenames and their hashes source_hashes = {} for folder, _, files in os.walk(source): for fn in files: source_hashes[hash_file(Path(folder) / fn)] = fn",
      "content_length": 1046,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 107,
      "content": "seen = set() # Keep track of the files we've found in the target\n\n# Walk the target folder and get the filenames and hashes for folder, _, files in os.walk(dest): for fn in files: dest_path = Path(folder) / fn dest_hash = hash_file(dest_path) seen.add(dest_hash)\n\n# if there's a file in target that's not in source, delete it if dest_hash not in source_hashes: dest_path.remove()\n\n# if there's a file in target that has a different path in source, # move it to the correct path elif dest_hash in source_hashes and fn != source_hashes[dest_hash]: shutil.move(dest_path, Path(folder) / source_hashes[dest_hash])\n\n# for every file that appears in source but not target, copy the file to # the target for src_hash, fn in source_hashes.items(): if src_hash not in seen: shutil.copy(Path(source) / fn, Path(dest) / fn)\n\nFantastic! We have some code and it looks OK, but before we run it on our hard drive, maybe we should test it. How do we go about testing this sort of thing?\n\nSome end-to-end tests (test_sync.py)\n\ndef test_when_a_file_exists_in_the_source_but_not_the_destination(): try: source = tempfile.mkdtemp() dest = tempfile.mkdtemp()\n\ncontent = \"I am a very useful file\" (Path(source) / 'my-file').write_text(content)\n\nsync(source, dest)",
      "content_length": 1242,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 108,
      "content": "expected_path = Path(dest) / 'my-file' assert expected_path.exists() assert expected_path.read_text() == content\n\nfinally: shutil.rmtree(source) shutil.rmtree(dest)\n\ndef test_when_a_file_has_been_renamed_in_the_source(): try: source = tempfile.mkdtemp() dest = tempfile.mkdtemp()\n\ncontent = \"I am a file that was renamed\" source_path = Path(source) / 'source-filename' old_dest_path = Path(dest) / 'dest-filename' expected_dest_path = Path(dest) / 'source-filename' source_path.write_text(content) old_dest_path.write_text(content)\n\nsync(source, dest)\n\nassert old_dest_path.exists() is False assert expected_dest_path.read_text() == content\n\nfinally: shutil.rmtree(source) shutil.rmtree(dest)\n\nWowsers, that’s a lot of setup for two simple cases! The problem is that our domain logic, “figure out the difference between two directories,” is tightly coupled to the I/O code. We can’t run our difference algorithm without calling the pathlib, shutil, and hashlib modules.",
      "content_length": 969,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 109,
      "content": "And the trouble is, even with our current requirements, we haven’t\n\nwritten enough tests: the current implementation has several bugs (the shutil.move() is wrong, for example). Getting decent coverage and revealing these bugs means writing more tests, but if they’re all as unwieldy as the preceding ones, that’s going to get real painful real quickly.\n\nOn top of that, our code isn’t very extensible. Imagine trying to implement a --dry-run flag that gets our code to just print out what it’s going to do, rather than actually do it. Or what if we wanted to\n\nsync to a remote server, or to cloud storage?\n\nOur high-level code is coupled to low-level details, and it’s making life hard. As the scenarios we consider get more complex, our tests\n\nwill get more unwieldy. We can definitely refactor these tests (some of the cleanup could go into pytest fixtures, for example) but as long as\n\nwe’re doing filesystem operations, they’re going to stay slow and be hard to read and write.\n\nChoosing the Right Abstraction(s)\n\nWhat could we do to rewrite our code to make it more testable?\n\nFirst, we need to think about what our code needs from the filesystem. Reading through the code, we can see that three distinct things are\n\nhappening. We can think of these as three distinct responsibilities that the code has:",
      "content_length": 1308,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 110,
      "content": "1. We interrogate the filesystem by using os.walk and determine hashes for a series of paths. This is similar in both the source and the destination cases.\n\n2. We decide whether a file is new, renamed, or redundant.\n\n3. We copy, move, or delete files to match the source.\n\nRemember that we want to find simplifying abstractions for each of these responsibilities. That will let us hide the messy details so we can\n\nfocus on the interesting logic.\n\n2\n\nNOTE\n\nIn this chapter, we’re refactoring some gnarly code into a more testable structure by identifying the separate tasks that need to be done and giving each task to a clearly defined actor, along similar lines to the duckduckgo example.\n\nFor steps 1 and 2, we’ve already intuitively started using an abstraction, a dictionary of hashes to paths. You may already have\n\nbeen thinking, “Why not build up a dictionary for the destination folder as well as the source, and then we just compare two dicts?” That\n\nseems like a nice way to abstract the current state of the filesystem:\n\nsource_files = {'hash1': 'path1', 'hash2': 'path2'} dest_files = {'hash1': 'path1', 'hash2': 'pathX'}\n\nWhat about moving from step 2 to step 3? How can we abstract out the actual move/copy/delete filesystem interaction?\n\nWe’ll apply a trick here that we’ll employ on a grand scale later in the\n\nbook. We’re going to separate what we want to do from how to do it.",
      "content_length": 1395,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 111,
      "content": "We’re going to make our program output a list of commands that look like this:\n\n(\"COPY\", \"sourcepath\", \"destpath\"), (\"MOVE\", \"old\", \"new\"),\n\nNow we could write tests that just use two filesystem dicts as inputs,\n\nand we would expect lists of tuples of strings representing actions as outputs.\n\nInstead of saying, “Given this actual filesystem, when I run my\n\nfunction, check what actions have happened,” we say, “Given this abstraction of a filesystem, what abstraction of filesystem actions\n\nwill happen?”\n\nSimplified inputs and outputs in our tests (test_sync.py)\n\ndef test_when_a_file_exists_in_the_source_but_not_the_destination(): src_hashes = {'hash1': 'fn1'} dst_hashes = {} expected_actions = [('COPY', '/src/fn1', '/dst/fn1')] ...\n\ndef test_when_a_file_has_been_renamed_in_the_source(): src_hashes = {'hash1': 'fn1'} dst_hashes = {'hash1': 'fn2'} expected_actions == [('MOVE', '/dst/fn2', '/dst/fn1')] ...\n\nImplementing Our Chosen Abstractions\n\nThat’s all very well, but how do we actually write those new tests, and how do we change our implementation to make it all work?",
      "content_length": 1082,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 112,
      "content": "Our goal is to isolate the clever part of our system, and to be able to\n\ntest it thoroughly without needing to set up a real filesystem. We’ll create a “core” of code that has no dependencies on external state and\n\nthen see how it responds when we give it input from the outside world (this kind of approach was characterized by Gary Bernhardt as\n\nFunctional Core, Imperative Shell, or FCIS).\n\nLet’s start off by splitting the code to separate the stateful parts from the logic.\n\nAnd our top-level function will contain almost no logic at all; it’s just\n\nan imperative series of steps: gather inputs, call our logic, apply outputs:\n\nSplit our code into three (sync.py)\n\ndef sync(source, dest): # imperative shell step 1, gather inputs source_hashes = read_paths_and_hashes(source) dest_hashes = read_paths_and_hashes(dest)\n\n# step 2: call functional core actions = determine_actions(source_hashes, dest_hashes, source, dest)\n\n# imperative shell step 3, apply outputs for action, *paths in actions: if action == 'copy': shutil.copyfile(*paths) if action == 'move': shutil.move(*paths) if action == 'delete': os.remove(paths[0])",
      "content_length": 1126,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 113,
      "content": "Here’s the first function we factor out, read_paths_and_hashes(), which isolates the I/O part of our application.\n\nHere is where carve out the functional core, the business logic.\n\nThe code to build up the dictionary of paths and hashes is now trivially easy to write:\n\nA function that just does I/O (sync.py)\n\ndef read_paths_and_hashes(root): hashes = {} for folder, _, files in os.walk(root): for fn in files: hashes[hash_file(Path(folder) / fn)] = fn return hashes\n\nThe determine_actions() function will be the core of our business logic, which says, “Given these two sets of hashes and filenames, what\n\nshould we copy/move/delete?”. It takes simple data structures and returns simple data structures:\n\nA function that just does business logic (sync.py)\n\ndef determine_actions(src_hashes, dst_hashes, src_folder, dst_folder): for sha, filename in src_hashes.items(): if sha not in dst_hashes: sourcepath = Path(src_folder) / filename destpath = Path(dst_folder) / filename yield 'copy', sourcepath, destpath\n\nelif dst_hashes[sha] != filename: olddestpath = Path(dst_folder) / dst_hashes[sha] newdestpath = Path(dst_folder) / filename yield 'move', olddestpath, newdestpath",
      "content_length": 1175,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 114,
      "content": "for sha, filename in dst_hashes.items(): if sha not in src_hashes: yield 'delete', dst_folder / filename\n\nOur tests now act directly on the determine_actions() function:\n\nNicer-looking tests (test_sync.py)\n\ndef test_when_a_file_exists_in_the_source_but_not_the_destination(): src_hashes = {'hash1': 'fn1'} dst_hashes = {} actions = determine_actions(src_hashes, dst_hashes, Path('/src'), Path('/dst')) assert list(actions) == [('copy', Path('/src/fn1'), Path('/dst/fn1'))] ...\n\ndef test_when_a_file_has_been_renamed_in_the_source(): src_hashes = {'hash1': 'fn1'} dst_hashes = {'hash1': 'fn2'} actions = determine_actions(src_hashes, dst_hashes, Path('/src'), Path('/dst')) assert list(actions) == [('move', Path('/dst/fn2'), Path('/dst/fn1'))]\n\nBecause we’ve disentangled the logic of our program—the code for\n\nidentifying changes—from the low-level details of I/O, we can easily test the core of our code.\n\nWith this approach, we’ve switched from testing our main entrypoint function, sync(), to testing a lower-level function, determine_actions(). You might decide that’s fine because sync() is now so simple. Or you might decide to keep some integration/acceptance tests to test that sync(). But there’s another option, which is to modify the sync() function so it can be unit tested",
      "content_length": 1286,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 115,
      "content": "and end-to-end tested; it’s an approach Bob calls edge-to-edge\n\ntesting.\n\nTesting Edge to Edge with Fakes and Dependency Injection\n\nWhen we start writing a new system, we often focus on the core logic\n\nfirst, driving it with direct unit tests. At some point, though, we want to test bigger chunks of the system together.\n\nWe could return to our end-to-end tests, but those are still as tricky to\n\nwrite and maintain as before. Instead, we often write tests that invoke a whole system together but fake the I/O, sort of edge to edge:\n\nExplicit dependencies (sync.py)\n\ndef sync(reader, filesystem, source_root, dest_root):\n\nsource_hashes = reader(source_root) dest_hashes = reader(dest_root)\n\nfor sha, filename in src_hashes.items(): if sha not in dest_hashes: sourcepath = source_root / filename destpath = dest_root / filename filesystem.copy(destpath, sourcepath)\n\nelif dest_hashes[sha] != filename: olddestpath = dest_root / dest_hashes[sha] newdestpath = dest_root / filename filesystem.move(olddestpath, newdestpath)\n\nfor sha, filename in dst_hashes.items(): if sha not in source_hashes: filesystem.delete(dest_root/filename)",
      "content_length": 1129,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 116,
      "content": "Our top-level function now exposes two new dependencies, a reader and a filesystem.\n\nWe invoke the reader to produce our files dict.\n\nWe invoke the filesystem to apply the changes we detect.\n\nTIP\n\nAlthough we’re using dependency injection, there is no need to define an abstract base class or any kind of explicit interface. In this book, we often show ABCs because we hope they help you understand what the abstraction is, but they’re not necessary. Python’s dynamic nature means we can always rely on duck typing.\n\nTests using DI\n\nclass FakeFileSystem(list):\n\ndef copy(self, src, dest): self.append(('COPY', src, dest))\n\ndef move(self, src, dest): self.append(('MOVE', src, dest))\n\ndef delete(self, dest): self.append(('DELETE', src, dest))\n\ndef test_when_a_file_exists_in_the_source_but_not_the_destination(): source = {\"sha1\": \"my-file\" } dest = {} filesystem = FakeFileSystem()\n\nreader = {\"/source\": source, \"/dest\": dest} synchronise_dirs(reader.pop, filesystem, \"/source\", \"/dest\")",
      "content_length": 988,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 117,
      "content": "assert filesystem == [(\"COPY\", \"/source/my-file\", \"/dest/my-file\")]\n\ndef test_when_a_file_has_been_renamed_in_the_source(): source = {\"sha1\": \"renamed-file\" } dest = {\"sha1\": \"original-file\" } filesystem = FakeFileSystem()\n\nreader = {\"/source\": source, \"/dest\": dest} synchronise_dirs(reader.pop, filesystem, \"/source\", \"/dest\")\n\nassert filesystem == [(\"MOVE\", \"/dest/original-file\", \"/dest/renamed-file\")]\n\nBob loves using lists to build simple test doubles, even though his coworkers get mad. It means we can write tests like assert foo not in database.\n\nEach method in our FakeFileSystem just appends something to the list so we can inspect it later. This is an example of a spy object.\n\nThe advantage of this approach is that our tests act on the exact same function that’s used by our production code. The disadvantage is that\n\nwe have to make our stateful components explicit and pass them around. David Heinemeier Hansson, the creator of Ruby on Rails, famously described this as “test-induced design damage.”\n\nIn either case, we can now work on fixing all the bugs in our implementation; enumerating tests for all the edge cases is now much easier.\n\nWhy Not Just Patch It Out?\n\nAt this point you may be scratching your head and thinking, “Why don’t you just use mock.patch and save yourself the effort?\"”",
      "content_length": 1312,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 118,
      "content": "We avoid using mocks in this book and in our production code too. We’re not going to enter into a Holy War, but our instinct is that mocking frameworks, particularly monkeypatching, are a code smell.\n\nInstead, we like to clearly identify the responsibilities in our codebase, and to separate those responsibilities into small, focused objects that are easy to replace with a test double.\n\nNOTE\n\nYou can see an example in Chapter 8, where we mock.patch() out an email- sending module, but eventually we replace that with an explicit bit of dependency injection in Chapter 13.\n\nWe have three closely related reasons for our preference:\n\nPatching out the dependency you’re using makes it possible to unit test the code, but it does nothing to improve the design. Using mock.patch won’t let your code work with a --dry- run flag, nor will it help you run against an FTP server. For that, you’ll need to introduce abstractions.\n\nTests that use mocks tend to be more coupled to the implementation details of the codebase. That’s because mock tests verify the interactions between things: did we call shutil.copy with the right arguments? This coupling between code and test tends to make tests more brittle, in our experience.\n\nOveruse of mocks leads to complicated test suites that fail to explain the code.",
      "content_length": 1302,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 119,
      "content": "NOTE\n\nDesigning for testability really means designing for extensibility. We trade off a little more complexity for a cleaner design that admits novel use cases.\n\nMOCKS VERSUS FAKES; CLASSIC-STYLE VERSUS LONDON- SCHOOL TDD\n\nHere’s a short and somewhat simplistic definition of the difference between mocks and fakes:\n\nMocks are used to verify how something gets used; they have methods like assert_called_once_with(). They’re associated with London-school TDD.\n\nFakes are working implementations of the thing they’re replacing, but they’re designed for use only in tests. They wouldn’t work “in real life”; our in-memory repository is a good example. But you can use them to make assertions about the end state of a system rather than the behaviors along the way, so they’re associated with classic-style TDD.\n\nWe’re slightly conflating mocks with spies and fakes with stubs here, and you can read the long, correct answer in Martin Fowler’s classic essay on the subject called “Mocks Aren’t Stubs”.\n\nIt also probably doesn’t help that the MagicMock objects provided by unittest.mock aren’t, strictly speaking, mocks; they’re spies, if anything. But they’re also often used as stubs or dummies. There, we promise we’re done with the test double terminology nitpicks now.\n\nWhat about London-school versus classic-style TDD? You can read more about those two in Martin Fowler’s article that we just cited, as well as on the Software Engineering Stack Exchange site, but in this book we’re pretty firmly in the classicist camp. We like to build our tests around state both in setup and in assertions, and we like to work at the highest level of abstraction 3 possible rather than doing checks on the behavior of intermediary collaborators.\n\nRead more on this in “On Deciding What Kind of Tests to Write”.\n\nWe view TDD as a design practice first and a testing practice second. The tests act as a record of our design choices and serve to explain the\n\nsystem to us when we return to the code after a long absence.\n\nTests that use too many mocks get overwhelmed with setup code that hides the story we care about.",
      "content_length": 2107,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 120,
      "content": "Steve Freeman has a great example of overmocked tests in his talk\n\n“Test-Driven Development”. You should also check out this PyCon talk, “Mocking and Patching Pitfalls”, by our esteemed tech reviewer, Ed Jung, which also addresses mocking and its alternatives. And while we’re recommending talks, don’t miss Brandon Rhodes talking about\n\n“Hoisting Your I/O”, which really nicely covers the issues we’re talking about, using another simple example.\n\nTIP\n\nIn this chapter, we’ve spent a lot of time replacing end-to-end tests with unit tests. That doesn’t mean we think you should never use E2E tests! In this book we’re showing techniques to get you to a decent test pyramid with as many unit tests as possible, and with the minimum number of E2E tests you need to feel confident. Read on to “Recap: Rules of Thumb for Different Types of Test” for more details.\n\nSO WHICH DO WE USE IN THIS BOOK? FUNCTIONAL OR OBJECT-ORIENTED COMPOSITION?\n\nBoth. Our domain model is entirely free of dependencies and side effects, so that’s our functional core. The service layer that we build around it (in Chapter 4) allows us to drive the system edge to edge, and we use dependency injection to provide those services with stateful components, so we can still unit test them.\n\nSee Chapter 13 for more exploration of making our dependency injection more explicit and centralized.\n\nWrap-Up\n\nWe’ll see this idea come up again and again in the book: we can make our systems easier to test and maintain by simplifying the interface",
      "content_length": 1511,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 121,
      "content": "between our business logic and messy I/O. Finding the right\n\nabstraction is tricky, but here are a few heuristics and questions to ask yourself:\n\nCan I choose a familiar Python data structure to represent the state of the messy system and then try to imagine a single function that can return that state?\n\nWhere can I draw a line between my systems, where can I carve out a seam to stick that abstraction in?\n\nWhat is a sensible way of dividing things into components with different responsibilities? What implicit concepts can I make explicit?\n\nWhat are the dependencies, and what is the core business logic?\n\nPractice makes less imperfect! And now back to our regular programming…\n\n1 A code kata is a small, contained programming challenge often used to practice TDD.\n\nSee “Kata—The Only Way to Learn TDD” by Peter Provost.\n\n2 If you’re used to thinking in terms of interfaces, that’s what we’re trying to define here.\n\n3 Which is not to say that we think the London school people are wrong. Some insanely\n\nsmart people work that way. It’s just not what we’re used to.",
      "content_length": 1070,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 122,
      "content": "Chapter 4. Our First Use Case: Flask API and Service Layer\n\nBack to our allocations project! Figure 4-1 shows the point we reached at the end of Chapter 2, which covered the Repository pattern.",
      "content_length": 193,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 124,
      "content": "Figure 4-1. Before: we drive our app by talking to repositories and the domain model\n\nIn this chapter, we discuss the differences between orchestration logic, business logic, and interfacing code, and we introduce the Service Layer pattern to take care of orchestrating our workflows and defining the use cases of our system.\n\nWe’ll also discuss testing: by combining the Service Layer with our repository abstraction over the database, we’re able to write fast tests, not just of our domain model but of the entire workflow for a use case.\n\nFigure 4-2 shows what we’re aiming for: we’re going to add a Flask API that will talk to the service layer, which will serve as the entrypoint to our domain model. Because our service layer depends on the AbstractRepository, we can unit test it by using FakeRepository but run our production code using SqlAlchemyRepository.",
      "content_length": 866,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 126,
      "content": "Figure 4-2. The service layer will become the main way into our app\n\nIn our diagrams, we are using the convention that new components are highlighted with bold text/lines (and yellow/orange color, if you’re reading a digital version).\n\nTIP\n\nThe code for this chapter is in the chapter_04_service_layer branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_04_service_layer # or to code along, checkout Chapter 2: git checkout chapter_02_repository\n\nConnecting Our Application to the Real World\n\nLike any good agile team, we’re hustling to try to get an MVP out and\n\nin front of the users to start gathering feedback. We have the core of our domain model and the domain service we need to allocate orders, and we have the repository interface for permanent storage.\n\nLet’s plug all the moving parts together as quickly as we can and then refactor toward a cleaner architecture. Here’s our plan:\n\n1. Use Flask to put an API endpoint in front of our allocate domain service. Wire up the database session and our repository. Test it with an end-to-end test and some quick- and-dirty SQL to prepare test data.",
      "content_length": 1149,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 127,
      "content": "2. Refactor out a service layer that can serve as an abstraction to capture the use case and that will sit between Flask and our domain model. Build some service-layer tests and show how they can use FakeRepository.\n\n3. Experiment with different types of parameters for our service layer functions; show that using primitive data types allows the service layer’s clients (our tests and our Flask API) to be decoupled from the model layer.\n\nA First End-to-End Test\n\nNo one is interested in getting into a long terminology debate about\n\nwhat counts as an end-to-end (E2E) test versus a functional test versus an acceptance test versus an integration test versus a unit test. Different projects need different combinations of tests, and we’ve seen perfectly successful projects just split things into “fast tests” and “slow tests.”\n\nFor now, we want to write one or maybe two tests that are going to exercise a “real” API endpoint (using HTTP) and talk to a real database. Let’s call them end-to-end tests because it’s one of the most self-explanatory names.\n\nThe following shows a first cut:\n\nA first API test (test_api.py)\n\n@pytest.mark.usefixtures('restart_api') def test_api_returns_allocation(add_stock): sku, othersku = random_sku(), random_sku('other') earlybatch = random_batchref(1) laterbatch = random_batchref(2) otherbatch = random_batchref(3)",
      "content_length": 1352,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 128,
      "content": "add_stock([ (laterbatch, sku, 100, '2011-01-02'), (earlybatch, sku, 100, '2011-01-01'), (otherbatch, othersku, 100, None), ]) data = {'orderid': random_orderid(), 'sku': sku, 'qty': 3} url = config.get_api_url() r = requests.post(f'{url}/allocate', json=data) assert r.status_code == 201 assert r.json()['batchref'] == earlybatch\n\nrandom_sku(), random_batchref(), and so on are little helper functions that generate randomized characters by using the uuid module. Because we’re running against an actual database now, this is one way to prevent various tests and runs from interfering with each other.\n\nadd_stock is a helper fixture that just hides away the details of manually inserting rows into the database using SQL. We’ll show a nicer way of doing this later in the chapter.\n\nconfig.py is a module in which we keep configuration information.\n\nEveryone solves these problems in different ways, but you’re going to\n\nneed some way of spinning up Flask, possibly in a container, and of talking to a Postgres database. If you want to see how we did it, check\n\nout Appendix B.\n\nThe Straightforward Implementation\n\nImplementing things in the most obvious way, you might get something\n\nlike this:\n\nFirst cut of Flask app (flask_app.py)",
      "content_length": 1233,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 129,
      "content": "from flask import Flask, jsonify, request from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker\n\nimport config import model import orm import repository\n\norm.start_mappers() get_session = sessionmaker(bind=create_engine(config.get_postgres_uri())) app = Flask(__name__)\n\n@app.route(\"/allocate\", methods=['POST']) def allocate_endpoint(): session = get_session() batches = repository.SqlAlchemyRepository(session).list() line = model.OrderLine( request.json['orderid'], request.json['sku'], request.json['qty'], )\n\nbatchref = model.allocate(line, batches)\n\nreturn jsonify({'batchref': batchref}), 201\n\nSo far, so good. No need for too much more of your “architecture astronaut” nonsense, Bob and Harry, you may be thinking.\n\nBut hang on a minute—there’s no commit. We’re not actually saving\n\nour allocation to the database. Now we need a second test, either one that will inspect the database state after (not very black-boxy), or\n\nmaybe one that checks that we can’t allocate a second line if a first should have already depleted the batch:\n\nTest allocations are persisted (test_api.py)",
      "content_length": 1109,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 130,
      "content": "@pytest.mark.usefixtures('restart_api') def test_allocations_are_persisted(add_stock): sku = random_sku() batch1, batch2 = random_batchref(1), random_batchref(2) order1, order2 = random_orderid(1), random_orderid(2) add_stock([ (batch1, sku, 10, '2011-01-01'), (batch2, sku, 10, '2011-01-02'), ]) line1 = {'orderid': order1, 'sku': sku, 'qty': 10} line2 = {'orderid': order2, 'sku': sku, 'qty': 10} url = config.get_api_url()\n\n# first order uses up all stock in batch 1 r = requests.post(f'{url}/allocate', json=line1) assert r.status_code == 201 assert r.json()['batchref'] == batch1\n\n# second order should go to batch 2 r = requests.post(f'{url}/allocate', json=line2) assert r.status_code == 201 assert r.json()['batchref'] == batch2\n\nNot quite so lovely, but that will force us to add the commit.\n\nError Conditions That Require Database Checks\n\nIf we keep going like this, though, things are going to get uglier and\n\nuglier.\n\nSuppose we want to add a bit of error handling. What if the domain raises an error, for a SKU that’s out of stock? Or what about a SKU\n\nthat doesn’t even exist? That’s not something the domain even knows\n\nabout, nor should it. It’s more of a sanity check that we should",
      "content_length": 1199,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 131,
      "content": "implement at the database layer, before we even invoke the domain\n\nservice.\n\nNow we’re looking at two more end-to-end tests:\n\nYet more tests at the E2E layer (test_api.py)\n\n@pytest.mark.usefixtures('restart_api') def test_400_message_for_out_of_stock(add_stock): sku, smalL_batch, large_order = random_sku(), random_batchref(), random_orderid() add_stock([ (smalL_batch, sku, 10, '2011-01-01'), ]) data = {'orderid': large_order, 'sku': sku, 'qty': 20} url = config.get_api_url() r = requests.post(f'{url}/allocate', json=data) assert r.status_code == 400 assert r.json()['message'] == f'Out of stock for sku {sku}'\n\n@pytest.mark.usefixtures('restart_api') def test_400_message_for_invalid_sku(): unknown_sku, orderid = random_sku(), random_orderid() data = {'orderid': orderid, 'sku': unknown_sku, 'qty': 20} url = config.get_api_url() r = requests.post(f'{url}/allocate', json=data) assert r.status_code == 400 assert r.json()['message'] == f'Invalid sku {unknown_sku}'\n\nIn the first test, we’re trying to allocate more units than we have in stock.\n\nIn the second, the SKU just doesn’t exist (because we never called add_stock), so it’s invalid as far as our app is concerned.\n\nAnd sure, we could implement it in the Flask app too:",
      "content_length": 1233,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 132,
      "content": "Flask app starting to get crufty (flask_app.py)\n\ndef is_valid_sku(sku, batches): return sku in {b.sku for b in batches}\n\n@app.route(\"/allocate\", methods=['POST']) def allocate_endpoint(): session = get_session() batches = repository.SqlAlchemyRepository(session).list() line = model.OrderLine( request.json['orderid'], request.json['sku'], request.json['qty'], )\n\nif not is_valid_sku(line.sku, batches): return jsonify({'message': f'Invalid sku {line.sku}'}), 400\n\ntry: batchref = model.allocate(line, batches) except model.OutOfStock as e: return jsonify({'message': str(e)}), 400\n\nsession.commit() return jsonify({'batchref': batchref}), 201\n\nBut our Flask app is starting to look a bit unwieldy. And our number of\n\nE2E tests is starting to get out of control, and soon we’ll end up with an inverted test pyramid (or “ice-cream cone model,” as Bob likes to\n\ncall it).\n\nIntroducing a Service Layer, and Using FakeRepository to Unit Test It\n\nIf we look at what our Flask app is doing, there’s quite a lot of what\n\nwe might call orchestration—fetching stuff out of our repository,",
      "content_length": 1079,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 133,
      "content": "validating our input against database state, handling errors, and committing in the happy path. Most of these things don’t have anything\n\nto do with having a web API endpoint (you’d need them if you were building a CLI, for example; see Appendix C), and they’re not really\n\nthings that need to be tested by end-to-end tests.\n\nIt often makes sense to split out a service layer, sometimes called an\n\norchestration layer or a use-case layer.\n\nDo you remember the FakeRepository that we prepared in Chapter 3?\n\nOur fake repository, an in-memory collection of batches (test_services.py)\n\nclass FakeRepository(repository.AbstractRepository):\n\ndef __init__(self, batches): self._batches = set(batches)\n\ndef add(self, batch): self._batches.add(batch)\n\ndef get(self, reference): return next(b for b in self._batches if b.reference == reference)\n\ndef list(self): return list(self._batches)\n\nHere’s where it will come in useful; it lets us test our service layer\n\nwith nice, fast unit tests:\n\nUnit testing with fakes at the service layer (test_services.py)",
      "content_length": 1045,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 134,
      "content": "def test_returns_allocation(): line = model.OrderLine(\"o1\", \"COMPLICATED-LAMP\", 10) batch = model.Batch(\"b1\", \"COMPLICATED-LAMP\", 100, eta=None) repo = FakeRepository([batch])\n\nresult = services.allocate(line, repo, FakeSession()) assert result == \"b1\"\n\ndef test_error_for_invalid_sku(): line = model.OrderLine(\"o1\", \"NONEXISTENTSKU\", 10) batch = model.Batch(\"b1\", \"AREALSKU\", 100, eta=None) repo = FakeRepository([batch])\n\nwith pytest.raises(services.InvalidSku, match=\"Invalid sku NONEXISTENTSKU\"): services.allocate(line, repo, FakeSession())\n\nFakeRepository holds the Batch objects that will be used by our test.\n\nOur services module (services.py) will define an allocate() service-layer function. It will sit between our allocate_endpoint() function in the API layer and the allocate() domain service function from our domain model.\n\nWe also need a FakeSession to fake out the database session, as shown in the following code snippet.\n\nA fake database session (test_services.py)\n\nclass FakeSession(): committed = False\n\ndef commit(self): self.committed = True\n\nThis fake session is only a temporary solution. We’ll get rid of it and make things even nicer soon, in Chapter 6. But in the meantime the fake\n\n1",
      "content_length": 1212,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 135,
      "content": ".commit() lets us migrate a third test from the E2E layer:\n\nA second test at the service layer (test_services.py)\n\ndef test_commits(): line = model.OrderLine('o1', 'OMINOUS-MIRROR', 10) batch = model.Batch('b1', 'OMINOUS-MIRROR', 100, eta=None) repo = FakeRepository([batch]) session = FakeSession()\n\nservices.allocate(line, repo, session) assert session.committed is True\n\nA Typical Service Function\n\nWe’ll write a service function that looks something like this:\n\nBasic allocation service (services.py)\n\nclass InvalidSku(Exception): pass\n\ndef is_valid_sku(sku, batches): return sku in {b.sku for b in batches}\n\ndef allocate(line: OrderLine, repo: AbstractRepository, session) -> str: batches = repo.list() if not is_valid_sku(line.sku, batches): raise InvalidSku(f'Invalid sku {line.sku}') batchref = model.allocate(line, batches) session.commit() return batchref\n\nTypical service-layer functions have similar steps:\n\nWe fetch some objects from the repository.",
      "content_length": 962,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 136,
      "content": "We make some checks or assertions about the request against the current state of the world.\n\nWe call a domain service.\n\nIf all is well, we save/update any state we’ve changed.\n\nThat last step is a little unsatisfactory at the moment, as our service layer is tightly coupled to our database layer. We’ll improve that in Chapter 6 with the Unit of Work pattern.\n\nDEPEND ON ABSTRACTIONS\n\nNotice one more thing about our service-layer function:\n\ndef allocate(line: OrderLine, repo: AbstractRepository, session) -> str:\n\nIt depends on a repository. We’ve chosen to make the dependency explicit, and we’ve used the type hint to say that we depend on AbstractRepository. This means it’ll work both when the tests give it a FakeRepository and when the Flask app gives it a SqlAlchemyRepository.\n\nIf you remember “The Dependency Inversion Principle”, this is what we mean when we say we should “depend on abstractions.” Our high-level module, the service layer, depends on the repository abstraction. And the details of the implementation for our specific choice of persistent storage also depend on that same abstraction. See Figures 4-3 and 4-4.\n\nSee also in Appendix C a worked example of swapping out the details of which persistent storage system to use while leaving the abstractions intact.\n\nBut the essentials of the service layer are there, and our Flask app now\n\nlooks a lot cleaner:\n\nFlask app delegating to service layer (flask_app.py)\n\n@app.route(\"/allocate\", methods=['POST']) def allocate_endpoint(): session = get_session() repo = repository.SqlAlchemyRepository(session)",
      "content_length": 1578,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 137,
      "content": "line = model.OrderLine( request.json['orderid'], request.json['sku'], request.json['qty'], ) try: batchref = services.allocate(line, repo, session) except (model.OutOfStock, services.InvalidSku) as e: return jsonify({'message': str(e)}), 400\n\nreturn jsonify({'batchref': batchref}), 201\n\nWe instantiate a database session and some repository objects.\n\nWe extract the user’s commands from the web request and pass them to a domain service.\n\nWe return some JSON responses with the appropriate status codes.\n\nThe responsibilities of the Flask app are just standard web stuff: per- request session management, parsing information out of POST parameters, response status codes, and JSON. All the orchestration logic is in the use case/service layer, and the domain logic stays in the\n\ndomain.\n\nFinally, we can confidently strip down our E2E tests to just two, one for the happy path and one for the unhappy path:\n\nE2E tests only happy and unhappy paths (test_api.py)\n\n@pytest.mark.usefixtures('restart_api') def test_happy_path_returns_201_and_allocated_batch(add_stock): sku, othersku = random_sku(), random_sku('other') earlybatch = random_batchref(1) laterbatch = random_batchref(2) otherbatch = random_batchref(3)",
      "content_length": 1212,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 138,
      "content": "add_stock([ (laterbatch, sku, 100, '2011-01-02'), (earlybatch, sku, 100, '2011-01-01'), (otherbatch, othersku, 100, None), ]) data = {'orderid': random_orderid(), 'sku': sku, 'qty': 3} url = config.get_api_url() r = requests.post(f'{url}/allocate', json=data) assert r.status_code == 201 assert r.json()['batchref'] == earlybatch\n\n@pytest.mark.usefixtures('restart_api') def test_unhappy_path_returns_400_and_error_message(): unknown_sku, orderid = random_sku(), random_orderid() data = {'orderid': orderid, 'sku': unknown_sku, 'qty': 20} url = config.get_api_url() r = requests.post(f'{url}/allocate', json=data) assert r.status_code == 400 assert r.json()['message'] == f'Invalid sku {unknown_sku}'\n\nWe’ve successfully split our tests into two broad categories: tests\n\nabout web stuff, which we implement end to end; and tests about orchestration stuff, which we can test against the service layer in memory.",
      "content_length": 910,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 139,
      "content": "EXERCISE FOR THE READER\n\nNow that we have an allocate service, why not build out a service for deallocate? We’ve added an E2E test and a few stub service-layer tests for you to get started on GitHub.\n\nIf that’s not enough, continue into the E2E tests and flask_app.py, and refactor the Flask adapter to be more RESTful. Notice how doing so doesn’t require any change to our service layer or domain layer!\n\nTIP\n\nIf you decide you want to build a read-only endpoint for retrieving allocation info, just do “the simplest thing that can possibly work,” which is repo.get() right in the Flask handler. We’ll talk more about reads versus writes in Chapter 12.\n\nWhy Is Everything Called a Service?\n\nSome of you are probably scratching your heads at this point trying to figure out exactly what the difference is between a domain service and\n\na service layer.\n\nWe’re sorry—we didn’t choose the names, or we’d have much cooler and friendlier ways to talk about this stuff.\n\nWe’re using two things called a service in this chapter. The first is an application service (our service layer). Its job is to handle requests from the outside world and to orchestrate an operation. What we mean\n\nis that the service layer drives the application by following a bunch of simple steps:\n\nGet some data from the database\n\nUpdate the domain model",
      "content_length": 1323,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 140,
      "content": "Persist any changes\n\nThis is the kind of boring work that has to happen for every operation in your system, and keeping it separate from business logic helps to keep things tidy.\n\nThe second type of service is a domain service. This is the name for a piece of logic that belongs in the domain model but doesn’t sit naturally inside a stateful entity or value object. For example, if you\n\nwere building a shopping cart application, you might choose to build taxation rules as a domain service. Calculating tax is a separate job from updating the cart, and it’s an important part of the model, but it doesn’t seem right to have a persisted entity for the job. Instead a stateless TaxCalculator class or a calculate_tax function can do the job.\n\nPutting Things in Folders to See Where It All Belongs\n\nAs our application gets bigger, we’ll need to keep tidying our directory structure. The layout of our project gives us useful hints\n\nabout what kinds of object we’ll find in each file.\n\nHere’s one way we could organize things:\n\nSome subfolders\n\n. ├── config.py ├── domain │ ├── __init__.py │ └── model.py",
      "content_length": 1102,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 141,
      "content": "├── service_layer │ ├── __init__.py │ └── services.py ├── adapters │ ├── __init__.py │ ├── orm.py │ └── repository.py ├── entrypoints │ ├── __init__.py │ └── flask_app.py └── tests ├── __init__.py ├── conftest.py ├── unit │ ├── test_allocate.py │ ├── test_batches.py │ └── test_services.py ├── integration │ ├── test_orm.py │ └── test_repository.py └── e2e └── test_api.py\n\nLet’s have a folder for our domain model. Currently that’s just one file, but for a more complex application, you might have one file per class; you might have helper parent classes for Entity, ValueObject, and Aggregate, and you might add an exceptions.py for domain-layer exceptions and, as you’ll see in Part II, commands.py and events.py.\n\nWe’ll distinguish the service layer. Currently that’s just one file called services.py for our service-layer functions. You could add service-layer exceptions here, and as you’ll see in Chapter 5, we’ll add unit_of_work.py.\n\nAdapters is a nod to the ports and adapters terminology. This will fill up with any other abstractions around external I/O (e.g., a redis_client.py). Strictly speaking, you would call these secondary adapters or driven adapters, or sometimes inward-facing adapters.",
      "content_length": 1208,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 142,
      "content": "Entrypoints are the places we drive our application from. In the official ports and adapters terminology, these are adapters too, and are referred to as primary, driving, or outward-facing adapters.\n\nWhat about ports? As you may remember, they are the abstract interfaces that the adapters implement. We tend to keep them in the same file as the adapters that implement them.\n\nWrap-Up\n\nAdding the service layer has really bought us quite a lot:\n\nOur Flask API endpoints become very thin and easy to write: their only responsibility is doing “web stuff,” such as parsing JSON and producing the right HTTP codes for happy or unhappy cases.\n\nWe’ve defined a clear API for our domain, a set of use cases or entrypoints that can be used by any adapter without needing to know anything about our domain model classes—whether that’s an API, a CLI (see Appendix C), or the tests! They’re an adapter for our domain too.\n\nWe can write tests in “high gear” by using the service layer, leaving us free to refactor the domain model in any way we see fit. As long as we can still deliver the same use cases, we can experiment with new designs without needing to rewrite a load of tests.\n\nAnd our test pyramid is looking good—the bulk of our tests are fast unit tests, with just the bare minimum of E2E and integration tests.\n\nThe DIP in Action",
      "content_length": 1329,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 143,
      "content": "Figure 4-3 shows the dependencies of our service layer: the domain model and AbstractRepository (the port, in ports and adapters terminology).\n\nWhen we run the tests, Figure 4-4 shows how we implement the abstract dependencies by using FakeRepository (the adapter).\n\nAnd when we actually run our app, we swap in the “real” dependency shown in Figure 4-5.\n\nFigure 4-3. Abstract dependencies of the service layer",
      "content_length": 410,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 144,
      "content": "Figure 4-4. Tests provide an implementation of the abstract dependency",
      "content_length": 70,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 146,
      "content": "Figure 4-5. Dependencies at runtime\n\nWonderful.\n\nLet’s pause for Table 4-1, in which we consider the pros and cons of having a service layer at all.",
      "content_length": 148,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 147,
      "content": "Table 4-1. Service layer: the trade-offs\n\nPros\n\nCons",
      "content_length": 52,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 148,
      "content": "Pros\n\nWe have a single place to capture all the use cases for our application.\n\nWe’ve placed our clever domain logic behind an API, which leaves us free to refactor.\n\nWe have cleanly separated “stuff that talks HTTP” from “stuff that talks allocation.”\n\nWhen combined with the Repository pattern and FakeRep ository, we have a nice way of writing tests at a higher level than the domain layer; we can test more of our workflow without needing to use integration tests (read on to Chapter 5 for more elaboration on this).\n\nCons\n\nIf your app is purely a web app, your controllers/view functions can be the single place to capture all the use cases.\n\nIt’s yet another layer of abstraction.\n\nPutting too much logic into the service layer can lead to the Anemic Domain anti-pattern. It’s better to introduce this layer after you spot orchestration logic creeping into your controllers.\n\nYou can get a lot of the benefits that come from having rich domain models by simply pushing logic out of your controllers and down to the model layer, without needing to add an extra layer in between (aka “fat models, thin controllers”).",
      "content_length": 1120,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 149,
      "content": "But there are still some bits of awkwardness to tidy up:\n\nThe service layer is still tightly coupled to the domain, because its API is expressed in terms of OrderLine objects. In Chapter 5, we’ll fix that and talk about the way that the service layer enables more productive TDD.\n\nThe service layer is tightly coupled to a session object. In Chapter 6, we’ll introduce one more pattern that works closely with the Repository and Service Layer patterns, the Unit of Work pattern, and everything will be absolutely lovely. You’ll see!\n\n1 Service-layer services and domain services do have confusingly similar names. We\n\ntackle this topic later in “Why Is Everything Called a Service?”.",
      "content_length": 683,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 150,
      "content": "Chapter 5. TDD in High Gear and Low Gear\n\nWe’ve introduced the service layer to capture some of the additional orchestration responsibilities we need from a working application. The service layer helps us clearly define our use cases and the\n\nworkflow for each: what we need to get from our repositories, what\n\npre-checks and current state validation we should do, and what we save at the end.\n\nBut currently, many of our unit tests operate at a lower level, acting\n\ndirectly on the model. In this chapter we’ll discuss the trade-offs involved in moving those tests up to the service-layer level, and some\n\nmore general testing guidelines.\n\nHARRY SAYS: SEEING A TEST PYRAMID IN ACTION WAS A LIGHT- BULB MOMENT\n\nHere are a few words from Harry directly:\n\nI was initially skeptical of all Bob’s architectural patterns, but seeing an actual test pyramid made me a convert.\n\nOnce you implement domain modeling and the service layer, you really actually can get to a stage where unit tests outnumber integration and end-to-end tests by an order of magnitude. Having worked in places where the E2E test build would take hours (“wait ‘til tomorrow,” essentially), I can’t tell you what a difference it makes to be able to run all your tests in minutes or seconds.\n\nRead on for some guidelines on how to decide what kinds of tests to write and at which level. The high gear versus low gear way of thinking really changed my testing life.",
      "content_length": 1429,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 151,
      "content": "How Is Our Test Pyramid Looking?\n\nLet’s see what this move to using a service layer, with its own service- layer tests, does to our test pyramid:\n\nCounting types of tests\n\n$ grep -c test_ test_*.py tests/unit/test_allocate.py:4 tests/unit/test_batches.py:8 tests/unit/test_services.py:3\n\ntests/integration/test_orm.py:6 tests/integration/test_repository.py:2\n\ntests/e2e/test_api.py:2\n\nNot bad! We have 15 unit tests, 8 integration tests, and just 2 end-to- end tests. That’s already a healthy-looking test pyramid.\n\nShould Domain Layer Tests Move to the Service Layer?\n\nLet’s see what happens if we take this a step further. Since we can test our software against the service layer, we don’t really need tests for the domain model anymore. Instead, we could rewrite all of the domain-level tests from Chapter 1 in terms of the service layer:\n\nRewriting a domain test at the service layer (tests/unit/test_services.py)\n\n# domain-layer test: def test_prefers_current_stock_batches_to_shipments(): in_stock_batch = Batch(\"in-stock-batch\", \"RETRO-CLOCK\", 100, eta=None) shipment_batch = Batch(\"shipment-batch\", \"RETRO-CLOCK\", 100, eta=tomorrow)",
      "content_length": 1140,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 152,
      "content": "line = OrderLine(\"oref\", \"RETRO-CLOCK\", 10)\n\nallocate(line, [in_stock_batch, shipment_batch])\n\nassert in_stock_batch.available_quantity == 90 assert shipment_batch.available_quantity == 100\n\n# service-layer test: def test_prefers_warehouse_batches_to_shipments(): in_stock_batch = Batch(\"in-stock-batch\", \"RETRO-CLOCK\", 100, eta=None) shipment_batch = Batch(\"shipment-batch\", \"RETRO-CLOCK\", 100, eta=tomorrow) repo = FakeRepository([in_stock_batch, shipment_batch]) session = FakeSession()\n\nline = OrderLine('oref', \"RETRO-CLOCK\", 10)\n\nservices.allocate(line, repo, session)\n\nassert in_stock_batch.available_quantity == 90 assert shipment_batch.available_quantity == 100\n\nWhy would we want to do that?\n\nTests are supposed to help us change our system fearlessly, but often we see teams writing too many tests against their domain model. This causes problems when they come to change their codebase and find that they need to update tens or even hundreds of unit tests.\n\nThis makes sense if you stop to think about the purpose of automated tests. We use tests to enforce that a property of the system doesn’t change while we’re working. We use tests to check that the API\n\ncontinues to return 200, that the database session continues to commit, and that orders are still being allocated.\n\nIf we accidentally change one of those behaviors, our tests will break. The flip side, though, is that if we want to change the design of our",
      "content_length": 1429,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 153,
      "content": "code, any tests relying directly on that code will also fail.\n\nAs we get further into the book, you’ll see how the service layer forms an API for our system that we can drive in multiple ways. Testing against this API reduces the amount of code that we need to change when we refactor our domain model. If we restrict ourselves to testing only against the service layer, we won’t have any tests that directly interact with “private” methods or attributes on our model objects, which leaves us freer to refactor them.\n\nTIP\n\nEvery line of code that we put in a test is like a blob of glue, holding the system in a particular shape. The more low-level tests we have, the harder it will be to change things.\n\nOn Deciding What Kind of Tests to Write\n\nYou might be asking yourself, “Should I rewrite all my unit tests, then? Is it wrong to write tests against the domain model?” To answer those questions, it’s important to understand the trade-off between coupling and design feedback (see Figure 5-1).",
      "content_length": 997,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 154,
      "content": "Figure 5-1. The test spectrum\n\nExtreme programming (XP) exhorts us to “listen to the code.” When we’re writing tests, we might find that the code is hard to use or notice a code smell. This is a trigger for us to refactor, and to reconsider our design.\n\nWe only get that feedback, though, when we’re working closely with the target code. A test for the HTTP API tells us nothing about the fine- grained design of our objects, because it sits at a much higher level of abstraction.\n\nOn the other hand, we can rewrite our entire application and, so long as we don’t change the URLs or request formats, our HTTP tests will continue to pass. This gives us confidence that large-scale changes, like changing the database schema, haven’t broken our code.\n\nAt the other end of the spectrum, the tests we wrote in Chapter 1 helped us to flesh out our understanding of the objects we need. The tests guided us to a design that makes sense and reads in the domain language. When our tests read in the domain language, we feel",
      "content_length": 1015,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 155,
      "content": "comfortable that our code matches our intuition about the problem we’re trying to solve.\n\nBecause the tests are written in the domain language, they act as living documentation for our model. A new team member can read these tests to quickly understand how the system works and how the core concepts interrelate.\n\nWe often “sketch” new behaviors by writing tests at this level to see how the code might look. When we want to improve the design of the code, though, we will need to replace or delete these tests, because they are tightly coupled to a particular implementation.\n\nHigh and Low Gear\n\nMost of the time, when we are adding a new feature or fixing a bug, we don’t need to make extensive changes to the domain model. In these cases, we prefer to write tests against services because of the lower coupling and higher coverage.\n\nFor example, when writing an add_stock function or a cancel_order feature, we can work more quickly and with less coupling by writing tests against the service layer.\n\nWhen starting a new project or when hitting a particularly gnarly problem, we will drop back down to writing tests against the domain model so we get better feedback and executable documentation of our intent.",
      "content_length": 1213,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 156,
      "content": "The metaphor we use is that of shifting gears. When starting a journey,\n\nthe bicycle needs to be in a low gear so that it can overcome inertia. Once we’re off and running, we can go faster and more efficiently by changing into a high gear; but if we suddenly encounter a steep hill or are forced to slow down by a hazard, we again drop down to a low gear until we can pick up speed again.\n\nFully Decoupling the Service-Layer Tests from the Domain\n\nWe still have direct dependencies on the domain in our service-layer tests, because we use domain objects to set up our test data and to\n\ninvoke our service-layer functions.\n\nTo have a service layer that’s fully decoupled from the domain, we need to rewrite its API to work in terms of primitives.\n\nOur service layer currently takes an OrderLine domain object:\n\nBefore: allocate takes a domain object (service_layer/services.py)\n\ndef allocate(line: OrderLine, repo: AbstractRepository, session) -> str:\n\nHow would it look if its parameters were all primitive types?\n\nAfter: allocate takes strings and ints (service_layer/services.py)\n\ndef allocate( orderid: str, sku: str, qty: int, repo: AbstractRepository, session ) -> str:",
      "content_length": 1174,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 157,
      "content": "We rewrite the tests in those terms as well:\n\nTests now use primitives in function call (tests/unit/test_services.py)\n\ndef test_returns_allocation(): batch = model.Batch(\"batch1\", \"COMPLICATED-LAMP\", 100, eta=None) repo = FakeRepository([batch])\n\nresult = services.allocate(\"o1\", \"COMPLICATED-LAMP\", 10, repo, FakeSession()) assert result == \"batch1\"\n\nBut our tests still depend on the domain, because we still manually instantiate Batch objects. So, if one day we decide to massively refactor how our Batch model works, we’ll have to change a bunch of tests.\n\nMitigation: Keep All Domain Dependencies in Fixture Functions\n\nWe could at least abstract that out to a helper function or a fixture in\n\nour tests. Here’s one way you could do that, adding a factory function on FakeRepository:\n\nFactory functions for fixtures are one possibility\n\n(tests/unit/test_services.py)\n\nclass FakeRepository(set):\n\n@staticmethod def for_batch(ref, sku, qty, eta=None): return FakeRepository([ model.Batch(ref, sku, qty, eta), ])",
      "content_length": 1013,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 158,
      "content": "...\n\ndef test_returns_allocation(): repo = FakeRepository.for_batch(\"batch1\", \"COMPLICATED-LAMP\", 100, eta=None) result = services.allocate(\"o1\", \"COMPLICATED-LAMP\", 10, repo, FakeSession()) assert result == \"batch1\"\n\nAt least that would move all of our tests’ dependencies on the domain into one place.\n\nAdding a Missing Service\n\nWe could go one step further, though. If we had a service to add stock, we could use that and make our service-layer tests fully expressed in\n\nterms of the service layer’s official use cases, removing all dependencies on the domain:\n\nTest for new add_batch service (tests/unit/test_services.py)\n\ndef test_add_batch(): repo, session = FakeRepository([]), FakeSession() services.add_batch(\"b1\", \"CRUNCHY-ARMCHAIR\", 100, None, repo, session) assert repo.get(\"b1\") is not None assert session.committed\n\nTIP\n\nIn general, if you find yourself needing to do domain-layer stuff directly in your service-layer tests, it may be an indication that your service layer is incomplete.\n\nAnd the implementation is just two lines:",
      "content_length": 1044,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 159,
      "content": "A new service for add_batch (service_layer/services.py)\n\ndef add_batch( ref: str, sku: str, qty: int, eta: Optional[date], repo: AbstractRepository, session, ): repo.add(model.Batch(ref, sku, qty, eta)) session.commit()\n\ndef allocate( orderid: str, sku: str, qty: int, repo: AbstractRepository, session ) -> str: ...\n\nNOTE\n\nShould you write a new service just because it would help remove dependencies from your tests? Probably not. But in this case, we almost definitely would need an add_batch service one day anyway.\n\nThat now allows us to rewrite all of our service-layer tests purely in\n\nterms of the services themselves, using only primitives, and without any dependencies on the model:\n\nServices tests now use only services (tests/unit/test_services.py)\n\ndef test_allocate_returns_allocation(): repo, session = FakeRepository([]), FakeSession() services.add_batch(\"batch1\", \"COMPLICATED-LAMP\", 100, None, repo, session) result = services.allocate(\"o1\", \"COMPLICATED-LAMP\", 10, repo, session) assert result == \"batch1\"\n\ndef test_allocate_errors_for_invalid_sku():",
      "content_length": 1069,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 160,
      "content": "repo, session = FakeRepository([]), FakeSession() services.add_batch(\"b1\", \"AREALSKU\", 100, None, repo, session)\n\nwith pytest.raises(services.InvalidSku, match=\"Invalid sku NONEXISTENTSKU\"): services.allocate(\"o1\", \"NONEXISTENTSKU\", 10, repo, FakeSession())\n\nThis is a really nice place to be in. Our service-layer tests depend on\n\nonly the service layer itself, leaving us completely free to refactor the model as we see fit.\n\nCarrying the Improvement Through to the E2E Tests\n\nIn the same way that adding add_batch helped decouple our service- layer tests from the model, adding an API endpoint to add a batch would remove the need for the ugly add_stock fixture, and our E2E tests could be free of those hardcoded SQL queries and the direct\n\ndependency on the database.\n\nThanks to our service function, adding the endpoint is easy, with just a little JSON wrangling and a single function call required:\n\nAPI for adding a batch (entrypoints/flask_app.py)\n\n@app.route(\"/add_batch\", methods=['POST']) def add_batch(): session = get_session() repo = repository.SqlAlchemyRepository(session) eta = request.json['eta'] if eta is not None: eta = datetime.fromisoformat(eta).date() services.add_batch( request.json['ref'], request.json['sku'], request.json['qty'], eta,",
      "content_length": 1264,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 161,
      "content": "repo, session ) return 'OK', 201\n\nNOTE\n\nAre you thinking to yourself, POST to /add_batch? That’s not very RESTful! You’re quite right. We’re being happily sloppy, but if you’d like to make it all more RESTy, maybe a POST to /batches, then knock yourself out! Because Flask is a thin adapter, it’ll be easy. See the next sidebar.\n\nAnd our hardcoded SQL queries from conftest.py get replaced with\n\nsome API calls, meaning the API tests have no dependencies other than the API, which is also nice:\n\nAPI tests can now add their own batches (tests/e2e/test_api.py)\n\ndef post_to_add_batch(ref, sku, qty, eta): url = config.get_api_url() r = requests.post( f'{url}/add_batch', json={'ref': ref, 'sku': sku, 'qty': qty, 'eta': eta} ) assert r.status_code == 201\n\n@pytest.mark.usefixtures('postgres_db') @pytest.mark.usefixtures('restart_api') def test_happy_path_returns_201_and_allocated_batch(): sku, othersku = random_sku(), random_sku('other') earlybatch = random_batchref(1) laterbatch = random_batchref(2) otherbatch = random_batchref(3) post_to_add_batch(laterbatch, sku, 100, '2011-01-02') post_to_add_batch(earlybatch, sku, 100, '2011-01-01')",
      "content_length": 1143,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 162,
      "content": "post_to_add_batch(otherbatch, othersku, 100, None) data = {'orderid': random_orderid(), 'sku': sku, 'qty': 3} url = config.get_api_url() r = requests.post(f'{url}/allocate', json=data) assert r.status_code == 201 assert r.json()['batchref'] == earlybatch\n\nWrap-Up\n\nOnce you have a service layer in place, you really can move the majority of your test coverage to unit tests and develop a healthy test\n\npyramid.\n\nRECAP: RULES OF THUMB FOR DIFFERENT TYPES OF TEST\n\nAim for one end-to-end test per feature\n\nThis might be written against an HTTP API, for example. The objective is to demonstrate that the feature works, and that all the moving parts are glued together correctly.\n\nWrite the bulk of your tests against the service layer\n\nThese edge-to-edge tests offer a good trade-off between coverage, runtime, and efficiency. Each test tends to cover one code path of a feature and use fakes for I/O. This is the place to 1 exhaustively cover all the edge cases and the ins and outs of your business logic.\n\nMaintain a small core of tests written against your domain model\n\nThese tests have highly focused coverage and are more brittle, but they have the highest feedback. Don’t be afraid to delete these tests if the functionality is later covered by tests at the service layer.\n\nError handling counts as a feature\n\nIdeally, your application will be structured such that all errors that bubble up to your entrypoints (e.g., Flask) are handled in the same way. This means you need to test only the happy path for each feature, and to reserve one end-to-end test for all unhappy paths (and many unhappy path unit tests, of course).\n\nA few things will help along the way:",
      "content_length": 1667,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 163,
      "content": "Express your service layer in terms of primitives rather than domain objects.\n\nIn an ideal world, you’ll have all the services you need to be able to test entirely against the service layer, rather than hacking state via repositories or the database. This pays off in your end-to-end tests as well.\n\nOnto the next chapter!\n\n1 A valid concern about writing tests at a higher level is that it can lead to combinatorial\n\nexplosion for more complex use cases. In these cases, dropping down to lower-level unit tests of the various collaborating domain objects can be useful. But see also Chapter 8 and “Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus”.",
      "content_length": 677,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 164,
      "content": "Chapter 6. Unit of Work Pattern\n\nIn this chapter we’ll introduce the final piece of the puzzle that ties together the Repository and Service Layer patterns: the Unit of Work pattern.\n\nIf the Repository pattern is our abstraction over the idea of persistent\n\nstorage, the Unit of Work (UoW) pattern is our abstraction over the idea of atomic operations. It will allow us to finally and fully decouple our service layer from the data layer.\n\nFigure 6-1 shows that, currently, a lot of communication occurs across the layers of our infrastructure: the API talks directly to the database\n\nlayer to start a session, it talks to the repository layer to initialize SQLAlchemyRepository, and it talks to the service layer to ask it to allocate.\n\nTIP\n\nThe code for this chapter is in the chapter_06_uow branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_06_uow # or to code along, checkout Chapter 4: git checkout chapter_04_service_layer",
      "content_length": 977,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 166,
      "content": "Figure 6-1. Without UoW: API talks directly to three layers\n\nFigure 6-2 shows our target state. The Flask API now does only two things: it initializes a unit of work, and it invokes a service. The service collaborates with the UoW (we like to think of the UoW as being part of the service layer), but neither the service function itself nor Flask now needs to talk directly to the database.\n\nAnd we’ll do it all using a lovely piece of Python syntax, a context manager.",
      "content_length": 469,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 168,
      "content": "Figure 6-2. With UoW: UoW now manages database state\n\nThe Unit of Work Collaborates with the Repository\n\nLet’s see the unit of work (or UoW, which we pronounce “you-wow”) in action. Here’s how the service layer will look when we’re finished:\n\nPreview of unit of work in action (src/allocation/service_layer/services.py)\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(orderid, sku, qty) with uow: batches = uow.batches.list() ... batchref = model.allocate(line, batches) uow.commit()\n\nWe’ll start a UoW as a context manager.\n\nuow.batches is the batches repo, so the UoW provides us access to our permanent storage.\n\nWhen we’re done, we commit or roll back our work, using the UoW.\n\nThe UoW acts as a single entrypoint to our persistent storage, and it keeps track of what objects were loaded and of the latest state.\n\n1\n\nThis gives us three useful things:",
      "content_length": 920,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 169,
      "content": "A stable snapshot of the database to work with, so the objects we use aren’t changing halfway through an operation\n\nA way to persist all of our changes at once, so if something goes wrong, we don’t end up in an inconsistent state\n\nA simple API to our persistence concerns and a handy place to get a repository\n\nTest-Driving a UoW with Integration Tests\n\nHere are our integration tests for the UOW:\n\nA basic “round-trip” test for a UoW (tests/integration/test_uow.py)\n\ndef test_uow_can_retrieve_a_batch_and_allocate_to_it(session_factory): session = session_factory() insert_batch(session, 'batch1', 'HIPSTER-WORKBENCH', 100, None) session.commit()\n\nuow = unit_of_work.SqlAlchemyUnitOfWork(session_factory) with uow: batch = uow.batches.get(reference='batch1') line = model.OrderLine('o1', 'HIPSTER-WORKBENCH', 10) batch.allocate(line) uow.commit()\n\nbatchref = get_allocated_batch_ref(session, 'o1', 'HIPSTER-WORKBENCH') assert batchref == 'batch1'\n\nWe initialize the UoW by using our custom session factory and get back a uow object to use in our with block.\n\nThe UoW gives us access to the batches repository via uow.batches.\n\nWe call commit() on it when we’re done.",
      "content_length": 1167,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 170,
      "content": "For the curious, the insert_batch and get_allocated_batch_ref helpers look like this:\n\nHelpers for doing SQL stuff (tests/integration/test_uow.py)\n\ndef insert_batch(session, ref, sku, qty, eta): session.execute( 'INSERT INTO batches (reference, sku, _purchased_quantity, eta)' ' VALUES (:ref, :sku, :qty, :eta)', dict(ref=ref, sku=sku, qty=qty, eta=eta) )\n\ndef get_allocated_batch_ref(session, orderid, sku): [[orderlineid]] = session.execute( 'SELECT id FROM order_lines WHERE orderid=:orderid AND sku=:sku', dict(orderid=orderid, sku=sku) ) [[batchref]] = session.execute( 'SELECT b.reference FROM allocations JOIN batches AS b ON batch_id = b.id' ' WHERE orderline_id=:orderlineid', dict(orderlineid=orderlineid) ) return batchref\n\nUnit of Work and Its Context Manager\n\nIn our tests we’ve implicitly defined an interface for what a UoW\n\nneeds to do. Let’s make that explicit by using an abstract base class:\n\nAbstract UoW context manager (src/allocation/service_layer/unit_of_work.py)\n\nclass AbstractUnitOfWork(abc.ABC): batches: repository.AbstractRepository",
      "content_length": 1062,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 171,
      "content": "def __exit__(self, *args): self.rollback()\n\n@abc.abstractmethod def commit(self): raise NotImplementedError\n\n@abc.abstractmethod def rollback(self): raise NotImplementedError\n\nThe UoW provides an attribute called .batches, which will give us access to the batches repository.\n\nIf you’ve never seen a context manager, __enter__ and __exit__ are the two magic methods that execute when we enter the with block and when we exit it, respectively. They’re our setup and teardown phases.\n\nWe’ll call this method to explicitly commit our work when we’re ready.\n\nIf we don’t commit, or if we exit the context manager by raising an error, we do a rollback. (The rollback has no effect if commit() has been called. Read on for more discussion of this.)\n\nThe Real Unit of Work Uses SQLAlchemy Sessions\n\nThe main thing that our concrete implementation adds is the database\n\nsession:\n\nThe real SQLAlchemy UoW (src/allocation/service_layer/unit_of_work.py)",
      "content_length": 942,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 172,
      "content": "DEFAULT_SESSION_FACTORY = sessionmaker(bind=create_engine( config.get_postgres_uri(), ))\n\nclass SqlAlchemyUnitOfWork(AbstractUnitOfWork):\n\ndef __init__(self, session_factory=DEFAULT_SESSION_FACTORY): self.session_factory = session_factory\n\ndef __enter__(self): self.session = self.session_factory() # type: Session self.batches = repository.SqlAlchemyRepository(self.session) return super().__enter__()\n\ndef __exit__(self, *args): super().__exit__(*args) self.session.close()\n\ndef commit(self): self.session.commit()\n\ndef rollback(self): self.session.rollback()\n\nThe module defines a default session factory that will connect to Postgres, but we allow that to be overridden in our integration tests so that we can use SQLite instead.\n\nThe __enter__ method is responsible for starting a database session and instantiating a real repository that can use that session.\n\nWe close the session on exit.\n\nFinally, we provide concrete commit() and rollback() methods that use our database session.\n\nFake Unit of Work for Testing\n\nHere’s how we use a fake UoW in our service-layer tests:",
      "content_length": 1078,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 173,
      "content": "Fake UoW (tests/unit/test_services.py)\n\nclass FakeUnitOfWork(unit_of_work.AbstractUnitOfWork):\n\ndef __init__(self): self.batches = FakeRepository([]) self.committed = False\n\ndef commit(self): self.committed = True\n\ndef rollback(self): pass\n\ndef test_add_batch(): uow = FakeUnitOfWork() services.add_batch(\"b1\", \"CRUNCHY-ARMCHAIR\", 100, None, uow) assert uow.batches.get(\"b1\") is not None assert uow.committed\n\ndef test_allocate_returns_allocation(): uow = FakeUnitOfWork() services.add_batch(\"batch1\", \"COMPLICATED-LAMP\", 100, None, uow) result = services.allocate(\"o1\", \"COMPLICATED-LAMP\", 10, uow) assert result == \"batch1\" ...\n\nFakeUnitOfWork and FakeRepository are tightly coupled, just like the real UnitofWork and Repository classes. That’s fine because we recognize that the objects are collaborators.\n\nNotice the similarity with the fake commit() function from FakeSession (which we can now get rid of). But it’s a substantial improvement because we’re now faking out code that we wrote rather than third-party code. Some people say, “Don’t mock what you don’t own”.",
      "content_length": 1074,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 174,
      "content": "In our tests, we can instantiate a UoW and pass it to our service layer, rather than passing a repository and a session. This is considerably less cumbersome.\n\nDON’T MOCK WHAT YOU DON’T OWN\n\nWhy do we feel more comfortable mocking the UoW than the session? Both of our fakes achieve the same thing: they give us a way to swap out our persistence layer so we can run tests in memory instead of needing to talk to a real database. The difference is in the resulting design.\n\nIf we cared only about writing tests that run quickly, we could create mocks that replace SQLAlchemy and use those throughout our codebase. The problem is that Session is a complex object that exposes lots of persistence-related functionality. It’s easy to use Session to make arbitrary queries against the database, but that quickly leads to data access code being sprinkled all over the codebase. To avoid that, we want to limit access to our persistence layer so each component has exactly what it needs and nothing more.\n\nBy coupling to the Session interface, you’re choosing to couple to all the complexity of SQLAlchemy. Instead, we want to choose a simpler abstraction and use that to clearly separate responsibilities. Our UoW is much simpler than a session, and we feel comfortable with the service layer being able to start and stop units of work.\n\n“Don’t mock what you don’t own” is a rule of thumb that forces us to build these simple abstractions over messy subsystems. This has the same performance benefit as mocking the SQLAlchemy session but encourages us to think carefully about our designs.\n\nUsing the UoW in the Service Layer\n\nHere’s what our new service layer looks like:\n\nService layer using UoW (src/allocation/service_layer/services.py)\n\ndef add_batch( ref: str, sku: str, qty: int, eta: Optional[date], uow: unit_of_work.AbstractUnitOfWork ): with uow: uow.batches.add(model.Batch(ref, sku, qty, eta)) uow.commit()",
      "content_length": 1913,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 175,
      "content": "def allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(orderid, sku, qty) with uow: batches = uow.batches.list() if not is_valid_sku(line.sku, batches): raise InvalidSku(f'Invalid sku {line.sku}') batchref = model.allocate(line, batches) uow.commit() return batchref\n\nOur service layer now has only the one dependency, once again on an abstract UoW.\n\nExplicit Tests for Commit/Rollback Behavior\n\nTo convince ourselves that the commit/rollback behavior works, we\n\nwrote a couple of tests:\n\nIntegration tests for rollback behavior (tests/integration/test_uow.py)\n\ndef test_rolls_back_uncommitted_work_by_default(session_factory): uow = unit_of_work.SqlAlchemyUnitOfWork(session_factory) with uow: insert_batch(uow.session, 'batch1', 'MEDIUM-PLINTH', 100, None)\n\nnew_session = session_factory() rows = list(new_session.execute('SELECT * FROM \"batches\"')) assert rows == []",
      "content_length": 926,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 176,
      "content": "def test_rolls_back_on_error(session_factory): class MyException(Exception): pass\n\nuow = unit_of_work.SqlAlchemyUnitOfWork(session_factory) with pytest.raises(MyException): with uow: insert_batch(uow.session, 'batch1', 'LARGE-FORK', 100, None) raise MyException()\n\nnew_session = session_factory() rows = list(new_session.execute('SELECT * FROM \"batches\"')) assert rows == []\n\nTIP\n\nWe haven’t shown it here, but it can be worth testing some of the more “obscure” database behavior, like transactions, against the “real” database—that is, the same engine. For now, we’re getting away with using SQLite instead of Postgres, but in Chapter 7, we’ll switch some of the tests to using the real database. It’s convenient that our UoW class makes that easy!\n\nExplicit Versus Implicit Commits\n\nNow we briefly digress on different ways of implementing the UoW pattern.\n\nWe could imagine a slightly different version of the UoW that commits by default and rolls back only if it spots an exception:\n\nA UoW with implicit commit… (src/allocation/unit_of_work.py)\n\nclass AbstractUnitOfWork(abc.ABC):",
      "content_length": 1084,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 177,
      "content": "def __enter__(self): return self\n\ndef __exit__(self, exn_type, exn_value, traceback): if exn_type is None: self.commit() else: self.rollback()\n\nShould we have an implicit commit in the happy path?\n\nAnd roll back only on exception?\n\nIt would allow us to save a line of code and to remove the explicit commit from our client code:\n\n...would save us a line of code (src/allocation/service_layer/services.py)\n\ndef add_batch(ref: str, sku: str, qty: int, eta: Optional[date], uow): with uow: uow.batches.add(model.Batch(ref, sku, qty, eta)) # uow.commit()\n\nThis is a judgment call, but we tend to prefer requiring the explicit commit so that we have to choose when to flush state.\n\nAlthough we use an extra line of code, this makes the software safe by default. The default behavior is to not change anything. In turn, that makes our code easier to reason about because there’s only one code path that leads to changes in the system: total success and an explicit\n\ncommit. Any other code path, any exception, any early exit from the UoW’s scope leads to a safe state.",
      "content_length": 1062,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 178,
      "content": "Similarly, we prefer to roll back by default because it’s easier to understand; this rolls back to the last commit, so either the user did one, or we blow their changes away. Harsh but simple.\n\nExamples: Using UoW to Group Multiple Operations into an Atomic Unit\n\nHere are a few examples showing the Unit of Work pattern in use. You can see how it leads to simple reasoning about what blocks of code happen together.\n\nExample 1: Reallocate\n\nSuppose we want to be able to deallocate and then reallocate orders:\n\nReallocate service function\n\ndef reallocate(line: OrderLine, uow: AbstractUnitOfWork) -> str: with uow: batch = uow.batches.get(sku=line.sku) if batch is None: raise InvalidSku(f'Invalid sku {line.sku}') batch.deallocate(line) allocate(line) uow.commit()\n\nIf deallocate() fails, we don’t want to call allocate(), obviously.\n\nIf allocate() fails, we probably don’t want to actually commit the deallocate() either.\n\nExample 2: Change Batch Quantity",
      "content_length": 957,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 179,
      "content": "Our shipping company gives us a call to say that one of the container doors opened, and half our sofas have fallen into the Indian Ocean. Oops!\n\nChange quantity\n\ndef change_batch_quantity(batchref: str, new_qty: int, uow: AbstractUnitOfWork): with uow: batch = uow.batches.get(reference=batchref) batch.change_purchased_quantity(new_qty) while batch.available_quantity < 0: line = batch.deallocate_one() uow.commit()\n\nHere we may need to deallocate any number of lines. If we get a failure at any stage, we probably want to commit none of the changes.\n\nTidying Up the Integration Tests\n\nWe now have three sets of tests, all essentially pointing at the database: test_orm.py, test_repository.py, and test_uow.py. Should\n\nwe throw any away?\n\n└── tests ├── conftest.py ├── e2e │ └── test_api.py ├── integration │ ├── test_orm.py │ ├── test_repository.py │ └── test_uow.py ├── pytest.ini └── unit ├── test_allocate.py ├── test_batches.py └── test_services.py",
      "content_length": 954,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 180,
      "content": "You should always feel free to throw away tests if you think they’re not going to add value longer term. We’d say that test_orm.py was\n\nprimarily a tool to help us learn SQLAlchemy, so we won’t need that long term, especially if the main things it’s doing are covered in test_repository.py. That last test, you might keep around, but we could certainly see an argument for just keeping everything at the highest\n\npossible level of abstraction (just as we did for the unit tests).\n\nEXERCISE FOR THE READER\n\nFor this chapter, probably the best thing to try is to implement a UoW from scratch. The code, as always, is on GitHub. You could either follow the model we have quite closely, or perhaps experiment with separating the UoW (whose responsibilities are commit(), rollback(), and providing the .batches repository) from the context manager, whose job is to initialize things, and then do the commit or rollback on exit. If you feel like going all-functional rather than messing about with all these classes, you could use @contextmanager from contextlib.\n\nWe’ve stripped out both the actual UoW and the fakes, as well as paring back the abstract UoW. Why not send us a link to your repo if you come up with something you’re particularly proud of?\n\nTIP\n\nThis is another example of the lesson from Chapter 5: as we build better abstractions, we can move our tests to run against them, which leaves us free to change the underlying details.\n\nWrap-Up\n\nHopefully we’ve convinced you that the Unit of Work pattern is useful,\n\nand that the context manager is a really nice Pythonic way of visually grouping code into blocks that we want to happen atomically.",
      "content_length": 1654,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 181,
      "content": "This pattern is so useful, in fact, that SQLAlchemy already uses a UoW in the shape of the Session object. The Session object in SQLAlchemy is the way that your application loads data from the database.\n\nEvery time you load a new entity from the database, the session begins to track changes to the entity, and when the session is flushed, all your changes are persisted together. Why do we go to the effort of\n\nabstracting away the SQLAlchemy session if it already implements the pattern we want?\n\nTable 6-1 discusses some of the trade-offs.",
      "content_length": 542,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 182,
      "content": "Table 6-1. Unit of Work pattern: the trade-offs\n\nPros\n\nCons\n\nWe have a nice abstraction over the concept of atomic operations, and the context manager makes it easy to see, visually, what blocks of code are grouped together atomically.\n\nYour ORM probably already has some perfectly good abstractions around atomicity. SQLAlchemy even has context managers. You can go a long way just passing a session around.\n\nWe have explicit control over when a transaction starts and finishes, and our application fails in a way that is safe by default. We never have to worry that an operation is partially committed.\n\nWe’ve made it look easy, but you have to think quite carefully about things like rollbacks, multithreading, and nested transactions. Perhaps just sticking to what Django or Flask-SQLAlchemy gives you will keep your life simpler.\n\nIt’s a nice place to put all your repositories so client code can access them.\n\nAs you’ll see in later chapters, atomicity isn’t only about transactions; it can help us work with events and the message bus.",
      "content_length": 1042,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 183,
      "content": "For one thing, the Session API is rich and supports operations that we don’t want or need in our domain. Our UnitOfWork simplifies the session to its essential core: it can be started, committed, or thrown away.\n\nFor another, we’re using the UnitOfWork to access our Repository objects. This is a neat bit of developer usability that we couldn’t do with a plain SQLAlchemy Session.\n\nUNIT OF WORK PATTERN RECAP\n\nThe Unit of Work pattern is an abstraction around data integrity\n\nIt helps to enforce the consistency of our domain model, and improves performance, by letting us perform a single flush operation at the end of an operation.\n\nIt works closely with the Repository and Service Layer patterns\n\nThe Unit of Work pattern completes our abstractions over data access by representing atomic updates. Each of our service-layer use cases runs in a single unit of work that succeeds or fails as a block.\n\nThis is a lovely case for a context manager\n\nContext managers are an idiomatic way of defining scope in Python. We can use a context manager to automatically roll back our work at the end of a request, which means the system is safe by default.\n\nSQLAlchemy already implements this pattern\n\nWe introduce an even simpler abstraction over the SQLAlchemy Session object in order to “narrow” the interface between the ORM and our code. This helps to keep us loosely coupled.\n\nLastly, we’re motivated again by the dependency inversion principle: our service layer depends on a thin abstraction, and we attach a concrete implementation at the outside edge of the system. This lines up nicely with SQLAlchemy’s own recommendations:",
      "content_length": 1627,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 184,
      "content": "Keep the life cycle of the session (and usually the transaction) separate and external. The most comprehensive approach, recommended for more substantial applications, will try to keep the details of session, transaction, and exception management as far as possible from the details of the program doing its work.\n\n—SQLALchemy “Session Basics” Documentation\n\n1 You may have come across the use of the word collaborators to describe objects that\n\nwork together to achieve a goal. The unit of work and the repository are a great example of collaborators in the object-modeling sense. In responsibility-driven design, clusters of objects that collaborate in their roles are called object neighborhoods, which is, in our professional opinion, totally adorable.",
      "content_length": 756,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 185,
      "content": "Chapter 7. Aggregates and Consistency Boundaries\n\nIn this chapter, we’d like to revisit our domain model to talk about invariants and constraints, and see how our domain objects can maintain their own internal consistency, both conceptually and in\n\npersistent storage. We’ll discuss the concept of a consistency\n\nboundary and show how making it explicit can help us to build high- performance software without compromising maintainability.\n\nFigure 7-1 shows a preview of where we’re headed: we’ll introduce a new model object called Product to wrap multiple batches, and we’ll make the old allocate() domain service available as a method on Product instead.",
      "content_length": 657,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 186,
      "content": "Why? Let’s find out.\n\nFigure 7-1. Adding the Product aggregate",
      "content_length": 62,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 187,
      "content": "TIP\n\nThe code for this chapter is in the appendix_csvs branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout appendix_csvs # or to code along, checkout the previous chapter: git checkout chapter_06_uow\n\nWhy Not Just Run Everything in a Spreadsheet?\n\nWhat’s the point of a domain model, anyway? What’s the fundamental\n\nproblem we’re trying to address?\n\nCouldn’t we just run everything in a spreadsheet? Many of our users\n\nwould be delighted by that. Business users like spreadsheets because they’re simple, familiar, and yet enormously powerful.\n\nIn fact, an enormous number of business processes do operate by manually sending spreadsheets back and forth over email. This “CSV over SMTP” architecture has low initial complexity but tends not to scale very well because it’s difficult to apply logic and maintain consistency.\n\nWho is allowed to view this particular field? Who’s allowed to update it? What happens when we try to order –350 chairs, or 10,000,000 tables? Can an employee have a negative salary?",
      "content_length": 1045,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 188,
      "content": "These are the constraints of a system. Much of the domain logic we write exists to enforce these constraints in order to maintain the invariants of the system. The invariants are the things that have to be true whenever we finish an operation.\n\nInvariants, Constraints, and Consistency\n\nThe two words are somewhat interchangeable, but a constraint is a rule that restricts the possible states our model can get into, while an invariant is defined a little more precisely as a condition that is always true.\n\nIf we were writing a hotel-booking system, we might have the constraint that double bookings are not allowed. This supports the invariant that a room cannot have more than one booking for the same night.\n\nOf course, sometimes we might need to temporarily bend the rules. Perhaps we need to shuffle the rooms around because of a VIP booking. While we’re moving bookings around in memory, we might be double booked, but our domain model should ensure that, when\n\nwe’re finished, we end up in a final consistent state, where the invariants are met. If we can’t find a way to accommodate all our guests, we should raise an error and refuse to complete the operation.\n\nLet’s look at a couple of concrete examples from our business requirements; we’ll start with this one:",
      "content_length": 1274,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 189,
      "content": "An order line can be allocated to only one batch at a time. —The business\n\nThis is a business rule that imposes an invariant. The invariant is that an order line is allocated to either zero or one batch, but never more than one. We need to make sure that our code never accidentally calls Batch.allocate() on two different batches for the same line, and currently, there’s nothing there to explicitly stop us from doing that.\n\nInvariants, Concurrency, and Locks\n\nLet’s look at another one of our business rules:\n\nWe can’t allocate to a batch if the available quantity is less than the quantity of the order line.\n\n—The business\n\nHere the constraint is that we can’t allocate more stock than is available to a batch, so we never oversell stock by allocating two customers to the same physical cushion, for example. Every time we update the state of the system, our code needs to ensure that we don’t break the invariant, which is that the available quantity must be greater than or equal to zero.\n\nIn a single-threaded, single-user application, it’s relatively easy for us to maintain this invariant. We can just allocate stock one line at a time, and raise an error if there’s no stock available.\n\nThis gets much harder when we introduce the idea of concurrency. Suddenly we might be allocating stock for multiple order lines",
      "content_length": 1325,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 190,
      "content": "simultaneously. We might even be allocating order lines at the same time as processing changes to the batches themselves.\n\nWe usually solve this problem by applying locks to our database tables. This prevents two operations from happening simultaneously on the same row or same table.\n\nAs we start to think about scaling up our app, we realize that our model of allocating lines against all available batches may not scale. If we process tens of thousands of orders per hour, and hundreds of thousands of order lines, we can’t hold a lock over the whole batches table for every single one—we’ll get deadlocks or performance problems at the very least.\n\nWhat Is an Aggregate?\n\nOK, so if we can’t lock the whole database every time we want to allocate an order line, what should we do instead? We want to protect the invariants of our system but allow for the greatest degree of concurrency. Maintaining our invariants inevitably means preventing concurrent writes; if multiple users can allocate DEADLY-SPOON at the same time, we run the risk of overallocating.\n\nOn the other hand, there’s no reason we can’t allocate DEADLY-SPOON at the same time as FLIMSY-DESK. It’s safe to allocate two products at the same time because there’s no invariant that covers them both. We don’t need them to be consistent with each other.",
      "content_length": 1319,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 191,
      "content": "The Aggregate pattern is a design pattern from the DDD community\n\nthat helps us to resolve this tension. An aggregate is just a domain object that contains other domain objects and lets us treat the whole collection as a single unit.\n\nThe only way to modify the objects inside the aggregate is to load the whole thing, and to call methods on the aggregate itself.\n\nAs a model gets more complex and grows more entity and value objects, referencing each other in a tangled graph, it can be hard to\n\nkeep track of who can modify what. Especially when we have collections in the model as we do (our batches are a collection), it’s a\n\ngood idea to nominate some entities to be the single entrypoint for modifying their related objects. It makes the system conceptually\n\nsimpler and easy to reason about if you nominate some objects to be in\n\ncharge of consistency for the others.\n\nFor example, if we’re building a shopping site, the Cart might make a\n\ngood aggregate: it’s a collection of items that we can treat as a single\n\nunit. Importantly, we want to load the entire basket as a single blob from our data store. We don’t want two requests to modify the basket\n\nat the same time, or we run the risk of weird concurrency errors. Instead, we want each change to the basket to run in a single database\n\ntransaction.\n\nWe don’t want to modify multiple baskets in a transaction, because there’s no use case for changing the baskets of several customers at the\n\nsame time. Each basket is a single consistency boundary responsible for maintaining its own invariants.",
      "content_length": 1557,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 192,
      "content": "An AGGREGATE is a cluster of associated objects that we treat as a unit for the purpose of data changes.\n\n—Eric Evans, Domain-Driven Design blue book\n\nPer Evans, our aggregate has a root entity (the Cart) that encapsulates\n\naccess to items. Each item has its own identity, but other parts of the system will always refer to the Cart only as an indivisible whole.\n\nTIP\n\nJust as we sometimes use _leading_underscores to mark methods or functions as “private,” you can think of aggregates as being the “public” classes of our model, and the rest of the entities and value objects as “private.”\n\nChoosing an Aggregate\n\nWhat aggregate should we use for our system? The choice is somewhat arbitrary, but it’s important. The aggregate will be the boundary where\n\nwe make sure every operation ends in a consistent state. This helps us to reason about our software and prevent weird race issues. We want\n\nto draw a boundary around a small number of objects—the smaller, the better, for performance—that have to be consistent with one another,\n\nand we need to give this boundary a good name.\n\nThe object we’re manipulating under the covers is Batch. What do we call a collection of batches? How should we divide all the batches in\n\nthe system into discrete islands of consistency?\n\nWe could use Shipment as our boundary. Each shipment contains several batches, and they all travel to our warehouse at the same time.",
      "content_length": 1405,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 193,
      "content": "Or perhaps we could use Warehouse as our boundary: each warehouse contains many batches, and counting all the stock at the same time could make sense.\n\nNeither of these concepts really satisfies us, though. We should be able to allocate DEADLY-SPOONs and FLIMSY-DESKs at the same time, even if they’re in the same warehouse or the same shipment. These concepts\n\nhave the wrong granularity.\n\nWhen we allocate an order line, we’re interested only in batches that have the same SKU as the order line. Some sort of concept like GlobalSkuStock could work: a collection of all the batches for a given SKU.\n\nIt’s an unwieldy name, though, so after some bikeshedding via SkuStock, Stock, ProductStock, and so on, we decided to simply call it Product—after all, that was the first concept we came across in our exploration of the domain language back in Chapter 1.\n\nSo the plan is this: when we want to allocate an order line, instead of Figure 7-2, where we look up all the Batch objects in the world and pass them to the allocate() domain service…",
      "content_length": 1040,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 194,
      "content": "Figure 7-2. Before: allocate against all batches using the domain service\n\n…we’ll move to the world of Figure 7-3, in which there is a new Product object for the particular SKU of our order line, and it will be in charge of all the batches for that SKU, and we can call a .allocate() method on that instead.",
      "content_length": 307,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 195,
      "content": "Figure 7-3. After: ask Product to allocate against its batches",
      "content_length": 62,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 196,
      "content": "Let’s see how that looks in code form:\n\nOur chosen aggregate, Product (src/allocation/domain/model.py)\n\nclass Product:\n\ndef __init__(self, sku: str, batches: List[Batch]): self.sku = sku self.batches = batches\n\ndef allocate(self, line: OrderLine) -> str: try: batch = next( b for b in sorted(self.batches) if b.can_allocate(line) ) batch.allocate(line) return batch.reference except StopIteration: raise OutOfStock(f'Out of stock for sku {line.sku}')\n\nProduct’s main identifier is the sku.\n\nOur Product class holds a reference to a collection of batches for that SKU.\n\nFinally, we can move the allocate() domain service to be a method on the Product aggregate.\n\nNOTE\n\nThis Product might not look like what you’d expect a Product model to look like. No price, no description, no dimensions. Our allocation service doesn’t care about any of those things. This is the power of bounded contexts; the concept of a product in one app can be very different from another. See the following sidebar for more discussion.",
      "content_length": 1010,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 197,
      "content": "AGGREGATES, BOUNDED CONTEXTS, AND MICROSERVICES\n\nOne of the most important contributions from Evans and the DDD community is the concept of bounded contexts.\n\nIn essence, this was a reaction against attempts to capture entire businesses into a single model. The word customer means different things to people in sales, customer service, logistics, support, and so on. Attributes needed in one context are irrelevant in another; more perniciously, concepts with the same name can have entirely different meanings in different contexts. Rather than trying to build a single model (or class, or database) to capture all the use cases, it’s better to have several models, draw boundaries around each context, and handle the translation between different contexts explicitly.\n\nThis concept translates very well to the world of microservices, where each microservice is free to have its own concept of “customer” and its own rules for translating that to and from other microservices it integrates with.\n\nIn our example, the allocation service has Product(sku, batches), whereas the ecommerce will have Product(sku, description, price, image_url, dimensions, etc...). As a rule of thumb, your domain models should include only the data that they need for performing calculations.\n\nWhether or not you have a microservices architecture, a key consideration in choosing your aggregates is also choosing the bounded context that they will operate in. By restricting the context, you can keep your number of aggregates low and their size manageable.\n\nOnce again, we find ourselves forced to say that we can’t give this issue the treatment it deserves here, and we can only encourage you to read up on it elsewhere. The Fowler link at the start of this sidebar is a good starting point, and either (or indeed, any) DDD book will have a chapter or more on bounded contexts.\n\nOne Aggregate = One Repository\n\nOnce you define certain entities to be aggregates, we need to apply the\n\nrule that they are the only entities that are publicly accessible to the outside world. In other words, the only repositories we are allowed should be repositories that return aggregates.",
      "content_length": 2154,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 198,
      "content": "NOTE\n\nThe rule that repositories should only return aggregates is the main place where we enforce the convention that aggregates are the only way into our domain model. Be wary of breaking it!\n\nIn our case, we’ll switch from BatchRepository to ProductRepository:\n\nOur new UoW and repository (unit_of_work.py and repository.py)\n\nclass AbstractUnitOfWork(abc.ABC): products: repository.AbstractProductRepository\n\n...\n\nclass AbstractProductRepository(abc.ABC):\n\n@abc.abstractmethod def add(self, product): ...\n\n@abc.abstractmethod def get(self, sku) -> model.Product: ...\n\nThe ORM layer will need some tweaks so that the right batches automatically get loaded and associated with Product objects. The nice thing is, the Repository pattern means we don’t have to worry about that yet. We can just use our FakeRepository and then feed through the new model into our service layer to see how it looks with Product as its main entrypoint:\n\nService layer (src/allocation/service_layer/services.py)",
      "content_length": 989,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 199,
      "content": "def add_batch( ref: str, sku: str, qty: int, eta: Optional[date], uow: unit_of_work.AbstractUnitOfWork ): with uow: product = uow.products.get(sku=sku) if product is None: product = model.Product(sku, batches=[]) uow.products.add(product) product.batches.append(model.Batch(ref, sku, qty, eta)) uow.commit()\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(orderid, sku, qty) with uow: product = uow.products.get(sku=line.sku) if product is None: raise InvalidSku(f'Invalid sku {line.sku}') batchref = product.allocate(line) uow.commit() return batchref\n\nWhat About Performance?\n\nWe’ve mentioned a few times that we’re modeling with aggregates because we want to have high-performance software, but here we are loading all the batches when we only need one. You might expect that to be inefficient, but there are a few reasons why we’re comfortable\n\nhere.\n\nFirst, we’re purposefully modeling our data so that we can make a single query to the database to read, and a single update to persist our",
      "content_length": 1059,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 200,
      "content": "changes. This tends to perform much better than systems that issue lots of ad hoc queries. In systems that don’t model this way, we often find that transactions slowly get longer and more complex as the software\n\nevolves.\n\nSecond, our data structures are minimal and comprise a few strings and integers per row. We can easily load tens or even hundreds of\n\nbatches in a few milliseconds.\n\nThird, we expect to have only 20 or so batches of each product at a time. Once a batch is used up, we can discount it from our\n\ncalculations. This means that the amount of data we’re fetching shouldn’t get out of control over time.\n\nIf we did expect to have thousands of active batches for a product,\n\nwe’d have a couple of options. For one, we could use lazy-loading for the batches in a product. From the perspective of our code, nothing would change, but in the background, SQLAlchemy would page through data for us. This would lead to more requests, each fetching a\n\nsmaller number of rows. Because we need to find only a single batch with enough capacity for our order, this might work pretty well.",
      "content_length": 1092,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 201,
      "content": "EXERCISE FOR THE READER\n\nYou’ve just seen the main top layers of the code, so this shouldn’t be too hard, but we’d like you to implement the Product aggregate starting from Batch, just as we did.\n\nOf course, you could cheat and copy/paste from the previous listings, but even if you do that, you’ll still have to solve a few challenges on your own, like adding the model to the ORM and making sure all the moving parts can talk to each other, which we hope will be instructive.\n\nYou’ll find the code on GitHub. We’ve put in a “cheating” implementation in the delegates to the existing allocate() function, so you should be able to evolve that toward the real thing.\n\nWe’ve marked a couple of tests with @pytest.skip(). After you’ve read the rest of this chapter, come back to these tests to have a go at implementing version numbers. Bonus points if you can get SQLAlchemy to do them for you by magic!\n\nIf all else failed, we’d just look for a different aggregate. Maybe we could split up batches by region or by warehouse. Maybe we could\n\nredesign our data access strategy around the shipment concept. The Aggregate pattern is designed to help manage some technical constraints around consistency and performance. There isn’t one correct aggregate, and we should feel comfortable changing our minds\n\nif we find our boundaries are causing performance woes.\n\nOptimistic Concurrency with Version Numbers\n\nWe have our new aggregate, so we’ve solved the conceptual problem\n\nof choosing an object to be in charge of consistency boundaries. Let’s now spend a little time talking about how to enforce data integrity at the database level.",
      "content_length": 1631,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 202,
      "content": "NOTE\n\nThis section has a lot of implementation details; for example, some of it is Postgres-specific. But more generally, we’re showing one way of managing concurrency issues, but it is just one approach. Real requirements in this area vary a lot from project to project. You shouldn’t expect to be able to copy and paste code from here into production.\n\nWe don’t want to hold a lock over the entire batches table, but how will we implement holding a lock over just the rows for a particular SKU?\n\nOne answer is to have a single attribute on the Product model that acts as a marker for the whole state change being complete and to use\n\nit as the single resource that concurrent workers can fight over. If two transactions read the state of the world for batches at the same time, and both want to update the allocations tables, we force both to also try to update the version_number in the products table, in such a way that only one of them can win and the world stays consistent.\n\nFigure 7-4 illustrates two concurrent transactions doing their read operations at the same time, so they see a Product with, for example, version=3. They both call Product.allocate() in order to modify a state. But we set up our database integrity rules such that only one of them is allowed to commit the new Product with version=4, and the other update is rejected.",
      "content_length": 1350,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 203,
      "content": "TIP\n\nVersion numbers are just one way to implement optimistic locking. You could achieve the same thing by setting the Postgres transaction isolation level to SERIALIZABLE, but that often comes at a severe performance cost. Version numbers also make implicit concepts explicit.",
      "content_length": 277,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 204,
      "content": "Figure 7-4. Sequence diagram: two transactions attempting a concurrent update on Product",
      "content_length": 88,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 205,
      "content": "OPTIMISTIC CONCURRENCY CONTROL AND RETRIES\n\nWhat we’ve implemented here is called optimistic concurrency control because our default assumption is that everything will be fine when two users want to make changes to the database. We think it’s unlikely that they will conflict with each other, so we let them go ahead and just make sure we have a way to notice if there is a problem.\n\nPessimistic concurrency control works under the assumption that two users are going to cause conflicts, and we want to prevent conflicts in all cases, so we lock everything just to be safe. In our example, that would mean locking the whole batches table, or using SELECT FOR UPDATE— we’re pretending that we’ve ruled those out for performance reasons, but in real life you’d want to do some evaluations and measurements of your own.\n\nWith pessimistic locking, you don’t need to think about handling failures because the database will prevent them for you (although you do need to think about deadlocks). With optimistic locking, you need to explicitly handle the possibility of failures in the (hopefully unlikely) case of a clash.\n\nThe usual way to handle a failure is to retry the failed operation from the beginning. Imagine we have two customers, Harry and Bob, and each submits an order for SHINY-TABLE. Both threads load the product at version 1 and allocate stock. The database prevents the concurrent update, and Bob’s order fails with an error. When we retry the operation, Bob’s order loads the product at version 2 and tries to allocate again. If there is enough stock left, all is well; otherwise, he’ll receive OutOfStock. Most operations can be retried this way in the case of a concurrency problem.\n\nRead more on retries in “Recovering from Errors Synchronously” and “Footguns”.\n\nImplementation Options for Version Numbers\n\nThere are essentially three options for implementing version numbers:\n\n1. version_number lives in the domain; we add it to the Product constructor, and Product.allocate() is responsible for incrementing it.\n\n2. The service layer could do it! The version number isn’t strictly a domain concern, so instead our service layer could assume that the current version number is attached to Product by the repository, and the service layer will increment it before it does the commit().",
      "content_length": 2301,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 206,
      "content": "3. Since it’s arguably an infrastructure concern, the UoW and repository could do it by magic. The repository has access to version numbers for any products it retrieves, and when the UoW does a commit, it can increment the version number for any products it knows about, assuming them to have changed.\n\nOption 3 isn’t ideal, because there’s no real way of doing it without\n\nhaving to assume that all products have changed, so we’ll be incrementing version numbers when we don’t have to.\n\n1\n\nOption 2 involves mixing the responsibility for mutating state between\n\nthe service layer and the domain layer, so it’s a little messy as well.\n\nSo in the end, even though version numbers don’t have to be a domain concern, you might decide the cleanest trade-off is to put them in the\n\ndomain:\n\nOur chosen aggregate, Product (src/allocation/domain/model.py)\n\nclass Product:\n\ndef __init__(self, sku: str, batches: List[Batch], version_number: int = 0):\n\nself.sku = sku self.batches = batches self.version_number = version_number\n\ndef allocate(self, line: OrderLine) -> str: try: batch = next( b for b in sorted(self.batches) if b.can_allocate(line) ) batch.allocate(line) self.version_number += 1 return batch.reference",
      "content_length": 1210,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 207,
      "content": "except StopIteration: raise OutOfStock(f'Out of stock for sku {line.sku}')\n\nThere it is!\n\nTIP\n\nIf you’re scratching your head at this version number business, it might help to remember that the number isn’t important. What’s important is that the Product database row is modified whenever we make a change to the Product aggregate. The version number is a simple, human-comprehensible way to model a thing that changes on every write, but it could equally be a random UUID every time.\n\nTesting for Our Data Integrity Rules\n\nNow to make sure we can get the behavior we want: if we have two concurrent attempts to do allocation against the same Product, one of them should fail, because they can’t both update the version number.\n\nFirst, let’s simulate a “slow” transaction using a function that does allocation and then does an explicit sleep:\n\n2\n\ntime.sleep can reproduce concurrency behavior (tests/integration/test_uow.py)\n\ndef try_to_allocate(orderid, sku, exceptions): line = model.OrderLine(orderid, sku, 10) try: with unit_of_work.SqlAlchemyUnitOfWork() as uow: product = uow.products.get(sku=sku) product.allocate(line) time.sleep(0.2)",
      "content_length": 1142,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 208,
      "content": "uow.commit() except Exception as e: print(traceback.format_exc()) exceptions.append(e)\n\nThen we have our test invoke this slow allocation twice, concurrently, using threads:\n\nAn integration test for concurrency behavior\n\n(tests/integration/test_uow.py)\n\ndef test_concurrent_updates_to_version_are_not_allowed(postgres_session_factory): sku, batch = random_sku(), random_batchref() session = postgres_session_factory() insert_batch(session, batch, sku, 100, eta=None, product_version=1) session.commit()\n\norder1, order2 = random_orderid(1), random_orderid(2) exceptions = [] # type: List[Exception] try_to_allocate_order1 = lambda: try_to_allocate(order1, sku, exceptions) try_to_allocate_order2 = lambda: try_to_allocate(order2, sku, exceptions) thread1 = threading.Thread(target=try_to_allocate_order1) thread2 = threading.Thread(target=try_to_allocate_order2) thread1.start() thread2.start() thread1.join() thread2.join()\n\n[[version]] = session.execute( \"SELECT version_number FROM products WHERE sku=:sku\", dict(sku=sku), ) assert version == 2 [exception] = exceptions assert 'could not serialize access due to concurrent update' in str(exception)",
      "content_length": 1150,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 209,
      "content": "orders = list(session.execute( \"SELECT orderid FROM allocations\" \" JOIN batches ON allocations.batch_id = batches.id\" \" JOIN order_lines ON allocations.orderline_id = order_lines.id\" \" WHERE order_lines.sku=:sku\", dict(sku=sku), )) assert len(orders) == 1 with unit_of_work.SqlAlchemyUnitOfWork() as uow: uow.session.execute('select 1')\n\nWe start two threads that will reliably produce the concurrency behavior we want: read1, read2, write1, write2.\n\nWe assert that the version number has been incremented only once.\n\nWe can also check on the specific exception if we like.\n\nAnd we double-check that only one allocation has gotten through.\n\nEnforcing Concurrency Rules by Using Database Transaction Isolation Levels\n\nTo get the test to pass as it is, we can set the transaction isolation level\n\non our session:\n\nSet isolation level for session (src/allocation/service_layer/unit_of_work.py)\n\nDEFAULT_SESSION_FACTORY = sessionmaker(bind=create_engine( config.get_postgres_uri(), isolation_level=\"REPEATABLE READ\", ))",
      "content_length": 1015,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 210,
      "content": "TIP\n\nTransaction isolation levels are tricky stuff, so it’s worth spending time understanding the Postgres documentation.\n\n3\n\nPessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nThere are multiple ways to approach this, but we’ll show one. SELECT FOR UPDATE produces different behavior; two concurrent transactions will not be allowed to do a read on the same rows at the same time:\n\nSELECT FOR UPDATE is a way of picking a row or rows to use as a lock (although those rows don’t have to be the ones you update). If two transactions both try to SELECT FOR UPDATE a row at the same time, one will win, and the other will wait until the lock is released. So this is an example of pessimistic concurrency control.\n\nHere’s how you can use the SQLAlchemy DSL to specify FOR UPDATE at query time:\n\nSQLAlchemy with_for_update (src/allocation/adapters/repository.py)\n\ndef get(self, sku): return self.session.query(model.Product) \\ .filter_by(sku=sku) \\ .with_for_update() \\ .first()\n\nThis will have the effect of changing the concurrency pattern from",
      "content_length": 1050,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 211,
      "content": "read1, read2, write1, write2(fail)\n\nto\n\nread1, write1, read2, write2(succeed)\n\nSome people refer to this as the “read-modify-write” failure mode. Read “PostgreSQL Anti-Patterns: Read-Modify-Write Cycles” for a good overview.\n\nWe don’t really have time to discuss all the trade-offs between REPEATABLE READ and SELECT FOR UPDATE, or optimistic versus pessimistic locking in general. But if you have a test like the one we’ve shown, you can specify the behavior you want and see how it changes. You can also use the test as a basis for performing some performance experiments.\n\nWrap-Up\n\nSpecific choices around concurrency control vary a lot based on\n\nbusiness circumstances and storage technology choices, but we’d like to bring this chapter back to the conceptual idea of an aggregate: we explicitly model an object as being the main entrypoint to some subset of our model, and as being in charge of enforcing the invariants and business rules that apply across all of those objects.\n\nChoosing the right aggregate is key, and it’s a decision you may revisit over time. You can read more about it in multiple DDD books. We also\n\nrecommend these three online papers on effective aggregate design by Vaughn Vernon (the “red book” author).",
      "content_length": 1235,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 212,
      "content": "Table 7-1 has some thoughts on the trade-offs of implementing the Aggregate pattern.",
      "content_length": 84,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 213,
      "content": "Table 7-1. Aggregates: the trade-offs\n\nPros\n\nPython might not have “official” public and private methods, but we do have the underscores convention, because it’s often useful to try to indicate what’s for “internal” use and what’s for “outside code” to use. Choosing aggregates is just the next level up: it lets you decide which of your domain model classes are the public ones, and which aren’t.\n\nModeling our operations around explicit consistency boundaries helps us avoid performance problems with our ORM.\n\nPutting the aggregate in sole charge of state changes to its subsidiary models makes the system easier to reason about, and makes it easier to control invariants.\n\nCons\n\nYet another new concept for new developers to take on. Explaining entities versus value objects was already a mental load; now there’s a third type of domain model object?\n\nSticking rigidly to the rule that we modify only one aggregate at a time is a big mental shift.\n\nDealing with eventual consistency between aggregates can be complex.",
      "content_length": 1021,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 214,
      "content": "AGGREGATES AND CONSISTENCY BOUNDARIES RECAP\n\nAggregates are your entrypoints into the domain model\n\nBy restricting the number of ways that things can be changed, we make the system easier to reason about.\n\nAggregates are in charge of a consistency boundary\n\nAn aggregate’s job is to be able to manage our business rules about invariants as they apply to a group of related objects. It’s the aggregate’s job to check that the objects within its remit are consistent with each other and with our rules, and to reject changes that would break the rules.\n\nAggregates and concurrency issues go together\n\nWhen thinking about implementing these consistency checks, we end up thinking about transactions and locks. Choosing the right aggregate is about performance as well as conceptual organization of your domain.",
      "content_length": 807,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 215,
      "content": "Part I Recap\n\nDo you remember Figure 7-5, the diagram we showed at the beginning of Part I to preview where we were heading?",
      "content_length": 124,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 217,
      "content": "Figure 7-5. A component diagram for our app at the end of Part I\n\nSo that’s where we are at the end of Part I. What have we achieved? We’ve seen how to build a domain model that’s exercised by a set of high-level unit tests. Our tests are living documentation: they describe the behavior of our system—the rules upon which we agreed with our business stakeholders—in nice readable code. When our business requirements change, we have confidence that our tests will help us to prove the new functionality, and when new developers join the project, they can read our tests to understand how things work.\n\nWe’ve decoupled the infrastructural parts of our system, like the database and API handlers, so that we can plug them into the outside of our application. This helps us to keep our codebase well organized and stops us from building a big ball of mud.\n\nBy applying the dependency inversion principle, and by using ports- and-adapters-inspired patterns like Repository and Unit of Work,\n\nwe’ve made it possible to do TDD in both high gear and low gear and to maintain a healthy test pyramid. We can test our system edge to edge, and the need for integration and end-to-end tests is kept to a minimum.\n\nLastly, we’ve talked about the idea of consistency boundaries. We don’t want to lock our entire system whenever we make a change, so we have to choose which parts are consistent with one another.\n\nFor a small system, this is everything you need to go and play with the ideas of domain-driven design. You now have the tools to build",
      "content_length": 1534,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 218,
      "content": "database-agnostic domain models that represent the shared language of your business experts. Hurrah!\n\nNOTE\n\nAt the risk of laboring the point—we’ve been at pains to point out that each pattern comes at a cost. Each layer of indirection has a price in terms of complexity and duplication in our code and will be confusing to programmers who’ve never seen these patterns before. If your app is essentially a simple CRUD wrapper around a database and isn’t likely to be anything more than that in the foreseeable future, you don’t need these patterns. Go ahead and use Django, and save yourself a lot of bother.\n\nIn Part II, we’ll zoom out and talk about a bigger topic: if aggregates are our boundary, and we can update only one at a time, how do we model processes that cross consistency boundaries?\n\n1 Perhaps we could get some ORM/SQLAlchemy magic to tell us when an object is dirty, but how would that work in the generic case—for example, for a CsvRepository?\n\n2 time.sleep() works well in our use case, but it’s not the most reliable or efficient way to reproduce concurrency bugs. Consider using semaphores or similar synchronization primitives shared between your threads to get better guarantees of behavior.\n\n3 If you’re not using Postgres, you’ll need to read different documentation. Annoyingly, different databases all have quite different definitions. Oracle’s SERIALIZABLE is equivalent to Postgres’s REPEATABLE READ, for example.",
      "content_length": 1443,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 219,
      "content": "Part II. Event-Driven Architecture\n\nI’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea.\n\nThe big idea is “messaging.\"…The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.\n\n—Alan Kay\n\nIt’s all very well being able to write one domain model to manage a\n\nsingle bit of business process, but what happens when we need to write many models? In the real world, our applications sit within an\n\norganization and need to exchange information with other parts of the system. You may remember our context diagram shown in Figure II-1.\n\nFaced with this requirement, many teams reach for microservices integrated via HTTP APIs. But if they’re not careful, they’ll end up\n\nproducing the most chaotic mess of all: the distributed big ball of mud.\n\nIn Part II, we’ll show how the techniques from Part I can be extended to distributed systems. We’ll zoom out to look at how we can compose a system from many small components that interact through asynchronous message passing.",
      "content_length": 1142,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 220,
      "content": "We’ll see how our Service Layer and Unit of Work patterns allow us to reconfigure our app to run as an asynchronous message processor, and how event-driven systems help us to decouple aggregates and applications from one another.",
      "content_length": 229,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 222,
      "content": "Figure II-1. But exactly how will all these systems talk to each other?\n\nWe’ll look at the following patterns and techniques:\n\nDomain Events\n\nTrigger workflows that cross consistency boundaries.\n\nMessage Bus\n\nProvide a unified way of invoking use cases from any endpoint.\n\nCQRS\n\nSeparating reads and writes avoids awkward compromises in an event-driven architecture and enables performance and scalability improvements.\n\nPlus, we’ll add a dependency injection framework. This has nothing to do with event-driven architecture per se, but it tidies up an awful lot of loose ends.",
      "content_length": 577,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 223,
      "content": "Chapter 8. Events and the Message Bus\n\nSo far we’ve spent a lot of time and energy on a simple problem that we could easily have solved with Django. You might be asking if the increased testability and expressiveness are really worth all the effort.\n\nIn practice, though, we find that it’s not the obvious features that make\n\na mess of our codebases: it’s the goop around the edge. It’s reporting, and permissions, and workflows that touch a zillion objects.\n\nOur example will be a typical notification requirement: when we can’t allocate an order because we’re out of stock, we should alert the buying team. They’ll go and fix the problem by buying more stock, and\n\nall will be well.\n\nFor a first version, our product owner says we can just send the alert\n\nby email.\n\nLet’s see how our architecture holds up when we need to plug in some\n\nof the mundane stuff that makes up so much of our systems.\n\nWe’ll start by doing the simplest, most expeditious thing, and talk about why it’s exactly this kind of decision that leads us to the Big Ball of Mud.",
      "content_length": 1049,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 224,
      "content": "Then we’ll show how to use the Domain Events pattern to separate side effects from our use cases, and how to use a simple Message Bus pattern for triggering behavior based on those events. We’ll show a few options for creating those events and how to pass them to the\n\nmessage bus, and finally we’ll show how the Unit of Work pattern can be modified to connect the two together elegantly, as previewed in Figure 8-1.",
      "content_length": 416,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 226,
      "content": "Figure 8-1. Events flowing through the system\n\nTIP\n\nThe code for this chapter is in the chapter_08_events_and_message_bus branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_08_events_and_message_bus # or to code along, checkout the previous chapter: git checkout chapter_07_aggregate\n\nAvoiding Making a Mess\n\nSo. Email alerts when we run out of stock. When we have new requirements like ones that really have nothing to do with the core domain, it’s all too easy to start dumping these things into our web controllers.\n\nFirst, Let’s Avoid Making a Mess of Our Web Controllers\n\nAs a one-off hack, this might be OK:\n\nJust whack it in the endpoint—what could go wrong? (src/allocation/entrypoints/flask_app.py)\n\n@app.route(\"/allocate\", methods=['POST']) def allocate_endpoint(): line = model.OrderLine( request.json['orderid'], request.json['sku'],",
      "content_length": 893,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 227,
      "content": "request.json['qty'], ) try: uow = unit_of_work.SqlAlchemyUnitOfWork() batchref = services.allocate(line, uow) except (model.OutOfStock, services.InvalidSku) as e: send_mail( 'out of stock', 'stock_admin@made.com', f'{line.orderid} - {line.sku}' ) return jsonify({'message': str(e)}), 400\n\nreturn jsonify({'batchref': batchref}), 201\n\n…but it’s easy to see how we can quickly end up in a mess by patching things up like this. Sending email isn’t the job of our HTTP layer, and we’d like to be able to unit test this new feature.\n\nAnd Let’s Not Make a Mess of Our Model Either\n\nAssuming we don’t want to put this code into our web controllers, because we want them to be as thin as possible, we may look at putting it right at the source, in the model:\n\nEmail-sending code in our model isn’t lovely either (src/allocation/domain/model.py)\n\ndef allocate(self, line: OrderLine) -> str: try: batch = next( b for b in sorted(self.batches) if b.can_allocate(line) ) #... except StopIteration:",
      "content_length": 985,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 228,
      "content": "email.send_mail('stock@made.com', f'Out of stock for {line.sku}') raise OutOfStock(f'Out of stock for sku {line.sku}')\n\nBut that’s even worse! We don’t want our model to have any dependencies on infrastructure concerns like email.send_mail.\n\nThis email-sending thing is unwelcome goop messing up the nice clean flow of our system. What we’d like is to keep our domain model focused on the rule “You can’t allocate more stuff than is actually available.”\n\nThe domain model’s job is to know that we’re out of stock, but the responsibility of sending an alert belongs elsewhere. We should be able to turn this feature on or off, or to switch to SMS notifications instead, without needing to change the rules of our domain model.\n\nOr the Service Layer!\n\nThe requirement “Try to allocate some stock, and send an email if it fails” is an example of workflow orchestration: it’s a set of steps that the system has to follow to achieve a goal.\n\nWe’ve written a service layer to manage orchestration for us, but even here the feature feels out of place:\n\nAnd in the service layer, it’s out of place (src/allocation/service_layer/services.py)\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str:",
      "content_length": 1228,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 229,
      "content": "line = OrderLine(orderid, sku, qty) with uow: product = uow.products.get(sku=line.sku) if product is None: raise InvalidSku(f'Invalid sku {line.sku}') try: batchref = product.allocate(line) uow.commit() return batchref except model.OutOfStock: email.send_mail('stock@made.com', f'Out of stock for {line.sku}') raise\n\nCatching an exception and reraising it? It could be worse, but it’s\n\ndefinitely making us unhappy. Why is it so hard to find a suitable home for this code?\n\nSingle Responsibility Principle\n\nReally, this is a violation of the single responsibility principle (SRP). Our use case is allocation. Our endpoint, service function, and domain methods are all called allocate, not allocate_and_send_mail_if_out_of_stock.\n\n1\n\nTIP\n\nRule of thumb: if you can’t describe what your function does without using words like “then” or “and,” you might be violating the SRP.\n\nOne formulation of the SRP is that each class should have only a single\n\nreason to change. When we switch from email to SMS, we shouldn’t",
      "content_length": 1011,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 230,
      "content": "have to update our allocate() function, because that’s clearly a separate responsibility.\n\nTo solve the problem, we’re going to split the orchestration into\n\nseparate steps so that the different concerns don’t get tangled up. The\n\ndomain model’s job is to know that we’re out of stock, but the responsibility of sending an alert belongs elsewhere. We should be\n\nable to turn this feature on or off, or to switch to SMS notifications instead, without needing to change the rules of our domain model.\n\nWe’d also like to keep the service layer free of implementation details.\n\nWe want to apply the dependency inversion principle to notifications so that our service layer depends on an abstraction, in the same way as\n\nwe avoid depending on the database by using a unit of work.\n\nAll Aboard the Message Bus!\n\nThe patterns we’re going to introduce here are Domain Events and the\n\nMessage Bus. We can implement them in a few ways, so we’ll show a couple before settling on the one we like most.\n\nThe Model Records Events\n\nFirst, rather than being concerned about emails, our model will be in charge of recording events—facts about things that have happened.\n\nWe’ll use a message bus to respond to events and invoke a new operation.\n\nEvents Are Simple Dataclasses\n\n2",
      "content_length": 1260,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 231,
      "content": "An event is a kind of value object. Events don’t have any behavior, because they’re pure data structures. We always name events in the\n\nlanguage of the domain, and we think of them as part of our domain model.\n\nWe could store them in model.py, but we may as well keep them in\n\ntheir own file (this might be a good time to consider refactoring out a directory called domain so that we have domain/model.py and\n\ndomain/events.py):\n\nEvent classes (src/allocation/domain/events.py)\n\nfrom dataclasses import dataclass\n\nclass Event: pass\n\n@dataclass class OutOfStock(Event): sku: str\n\nOnce we have a number of events, we’ll find it useful to have a parent class that can store common attributes. It’s also useful for type hints in our message bus, as you’ll see shortly.\n\ndataclasses are great for domain events too.\n\nThe Model Raises Events\n\nWhen our domain model records a fact that happened, we say it raises\n\nan event.\n\nHere’s what it will look like from the outside; if we ask Product to allocate but it can’t, it should raise an event:",
      "content_length": 1035,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 232,
      "content": "Test our aggregate to raise events (tests/unit/test_product.py)\n\ndef test_records_out_of_stock_event_if_cannot_allocate(): batch = Batch('batch1', 'SMALL-FORK', 10, eta=today) product = Product(sku=\"SMALL-FORK\", batches=[batch]) product.allocate(OrderLine('order1', 'SMALL-FORK', 10))\n\nallocation = product.allocate(OrderLine('order2', 'SMALL-FORK', 1)) assert product.events[-1] == events.OutOfStock(sku=\"SMALL-FORK\") assert allocation is None\n\nOur aggregate will expose a new attribute called .events that will contain a list of facts about what has happened, in the form of Event objects.\n\nHere’s what the model looks like on the inside:\n\nThe model raises a domain event (src/allocation/domain/model.py)\n\nclass Product:\n\ndef __init__(self, sku: str, batches: List[Batch], version_number: int = 0): self.sku = sku self.batches = batches self.version_number = version_number self.events = [] # type: List[events.Event]\n\ndef allocate(self, line: OrderLine) -> str: try: #... except StopIteration: self.events.append(events.OutOfStock(line.sku)) # raise OutOfStock(f'Out of stock for sku {line.sku}') return None\n\nHere’s our new .events attribute in use.\n\nRather than invoking some email-sending code directly, we record those events at the place they occur, using only the language of the",
      "content_length": 1288,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 233,
      "content": "domain.\n\nWe’re also going to stop raising an exception for the out-of-stock case. The event will do the job the exception was doing.\n\nNOTE\n\nWe’re actually addressing a code smell we had until now, which is that we were using exceptions for control flow. In general, if you’re implementing domain events, don’t raise exceptions to describe the same domain concept. As you’ll see later when we handle events in the Unit of Work pattern, it’s confusing to have to reason about events and exceptions together.\n\nThe Message Bus Maps Events to Handlers\n\nA message bus basically says, “When I see this event, I should invoke the following handler function.” In other words, it’s a simple publish-\n\nsubscribe system. Handlers are subscribed to receive events, which we publish to the bus. It sounds harder than it is, and we usually\n\nimplement it with a dict:\n\nSimple message bus (src/allocation/service_layer/messagebus.py)\n\ndef handle(event: events.Event): for handler in HANDLERS[type(event)]: handler(event)\n\ndef send_out_of_stock_notification(event: events.OutOfStock): email.send_mail( 'stock@made.com', f'Out of stock for {event.sku}', )",
      "content_length": 1136,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 234,
      "content": "HANDLERS = { events.OutOfStock: [send_out_of_stock_notification],\n\n} # type: Dict[Type[events.Event], List[Callable]]\n\nNOTE\n\nNote that the message bus as implemented doesn’t give us concurrency because only one handler will run at a time. Our objective isn’t to support parallel threads but to separate tasks conceptually, and to keep each UoW as small as possible. This helps us to understand the codebase because the “recipe” for how to run each use case is written in a single place. See the following sidebar.\n\nIS THIS LIKE CELERY?\n\nCelery is a popular tool in the Python world for deferring self-contained chunks of work to an asynchronous task queue. The message bus we’re presenting here is very different, so the short answer to the above question is no; our message bus has more in common with a Node.js app, a UI event loop, or an actor framework.\n\nIf you do have a requirement for moving work off the main thread, you can still use our event- based metaphors, but we suggest you use external events for that. There’s more discussion in Table 11-1, but essentially, if you implement a way of persisting events to a centralized store, you can subscribe other containers or other microservices to them. Then that same concept of using events to separate responsibilities across units of work within a single process/service can be extended across multiple processes—which may be different containers within the same service, or totally different microservices.\n\nIf you follow us in this approach, your API for distributing tasks is your event classes—or a JSON representation of them. This allows you a lot of flexibility in who you distribute tasks to; they need not necessarily be Python services. Celery’s API for distributing tasks is essentially “function name plus arguments,” which is more restrictive, and Python-only.\n\nOption 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus",
      "content_length": 1924,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 235,
      "content": "Our domain model raises events, and our message bus will call the\n\nright handlers whenever an event happens. Now all we need is to connect the two. We need something to catch events from the model\n\nand pass them to the message bus—the publishing step.\n\nThe simplest way to do this is by adding some code into our service layer:\n\nThe service layer with an explicit message bus\n\n(src/allocation/service_layer/services.py)\n\nfrom . import messagebus ...\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(orderid, sku, qty) with uow: product = uow.products.get(sku=line.sku) if product is None: raise InvalidSku(f'Invalid sku {line.sku}') try: batchref = product.allocate(line) uow.commit() return batchref finally: messagebus.handle(product.events)\n\nWe keep the try/finally from our ugly earlier implementation (we haven’t gotten rid of all exceptions yet, just OutOfStock).\n\nBut now, instead of depending directly on an email infrastructure, the service layer is just in charge of passing events from the model up to the message bus.",
      "content_length": 1093,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 236,
      "content": "That already avoids some of the ugliness that we had in our naive\n\nimplementation, and we have several systems that work like this one, in which the service layer explicitly collects events from aggregates and passes them to the message bus.\n\nOption 2: The Service Layer Raises Its Own Events\n\nAnother variant on this that we’ve used is to have the service layer in charge of creating and raising events directly, rather than having them raised by the domain model:\n\nService layer calls messagebus.handle directly (src/allocation/service_layer/services.py)\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(orderid, sku, qty) with uow: product = uow.products.get(sku=line.sku) if product is None: raise InvalidSku(f'Invalid sku {line.sku}') batchref = product.allocate(line) uow.commit()\n\nif batchref is None: messagebus.handle(events.OutOfStock(line.sku)) return batchref\n\nAs before, we commit even if we fail to allocate because the code is simpler this way and it’s easier to reason about: we always",
      "content_length": 1065,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 237,
      "content": "commit unless something goes wrong. Committing when we haven’t changed anything is safe and keeps the code uncluttered.\n\nAgain, we have applications in production that implement the pattern in this way. What works for you will depend on the particular trade-\n\noffs you face, but we’d like to show you what we think is the most elegant solution, in which we put the unit of work in charge of collecting and raising events.\n\nOption 3: The UoW Publishes Events to the Message Bus\n\nThe UoW already has a try/finally, and it knows about all the aggregates currently in play because it provides access to the repository. So it’s a good place to spot events and pass them to the message bus:\n\nThe UoW meets the message bus (src/allocation/service_layer/unit_of_work.py)\n\nclass AbstractUnitOfWork(abc.ABC): ...\n\ndef commit(self): self._commit() self.publish_events()\n\ndef publish_events(self): for product in self.products.seen: while product.events: event = product.events.pop(0) messagebus.handle(event)\n\n@abc.abstractmethod",
      "content_length": 1018,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 238,
      "content": "def _commit(self): raise NotImplementedError\n\n...\n\nclass SqlAlchemyUnitOfWork(AbstractUnitOfWork): ...\n\ndef _commit(self): self.session.commit()\n\nWe’ll change our commit method to require a private ._commit() method from subclasses.\n\nAfter committing, we run through all the objects that our repository has seen and pass their events to the message bus.\n\nThat relies on the repository keeping track of aggregates that have been loaded using a new attribute, .seen, as you’ll see in the next listing.\n\nNOTE\n\nAre you wondering what happens if one of the handlers fails? We’ll discuss error handling in detail in Chapter 10.\n\nRepository tracks aggregates that pass through it (src/allocation/adapters/repository.py)\n\nclass AbstractRepository(abc.ABC):\n\ndef __init__(self): self.seen = set() # type: Set[model.Product]\n\ndef add(self, product: model.Product): self._add(product)",
      "content_length": 873,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 239,
      "content": "self.seen.add(product)\n\ndef get(self, sku) -> model.Product: product = self._get(sku) if product: self.seen.add(product) return product\n\n@abc.abstractmethod def _add(self, product: model.Product): raise NotImplementedError\n\n@abc.abstractmethod def _get(self, sku) -> model.Product: raise NotImplementedError\n\nclass SqlAlchemyRepository(AbstractRepository):\n\ndef __init__(self, session): super().__init__() self.session = session\n\ndef _add(self, product): self.session.add(product)\n\ndef _get(self, sku): return self.session.query(model.Product).filter_by(sku=sku).first()\n\nFor the UoW to be able to publish new events, it needs to be able to ask the repository for which Product objects have been used during this session. We use a set called .seen to store them. That means our implementations need to call super().__init__().\n\nThe parent add() method adds things to .seen, and now requires subclasses to implement ._add().\n\nSimilarly, .get() delegates to a ._get() function, to be implemented by subclasses, in order to capture objects seen.",
      "content_length": 1042,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 240,
      "content": "NOTE\n\nThe use of ._underscorey() methods and subclassing is definitely not the only way you could implement these patterns. Have a go at the Exercise for the Reader in this chapter and experiment with some alternatives.\n\nAfter the UoW and repository collaborate in this way to automatically keep track of live objects and process their events, the service layer can be totally free of event-handling concerns:\n\nService layer is clean again (src/allocation/service_layer/services.py)\n\ndef allocate( orderid: str, sku: str, qty: int, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(orderid, sku, qty) with uow: product = uow.products.get(sku=line.sku) if product is None: raise InvalidSku(f'Invalid sku {line.sku}') batchref = product.allocate(line) uow.commit() return batchref\n\nWe do also have to remember to change the fakes in the service layer and make them call super() in the right places, and to implement underscorey methods, but the changes are minimal:\n\nService-layer fakes need tweaking (tests/unit/test_services.py)",
      "content_length": 1042,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 241,
      "content": "class FakeRepository(repository.AbstractRepository):\n\ndef __init__(self, products): super().__init__() self._products = set(products)\n\ndef _add(self, product): self._products.add(product)\n\ndef _get(self, sku): return next((p for p in self._products if p.sku == sku), None)\n\n...\n\nclass FakeUnitOfWork(unit_of_work.AbstractUnitOfWork): ...\n\ndef _commit(self): self.committed = True",
      "content_length": 379,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 242,
      "content": "EXERCISE FOR THE READER\n\nAre you finding all those ._add() and ._commit() methods “super-gross,” in the words of our beloved tech reviewer Hynek? Does it “make you want to beat Harry around the head with a plushie snake”? Hey, our code listings are only meant to be examples, not the perfect solution! Why not go see if you can do better?\n\nOne composition over inheritance way to go would be to implement a wrapper class:\n\nA wrapper adds functionality and then delegates (src/adapters/repository.py)\n\nclass TrackingRepository: seen: Set[model.Product]\n\ndef __init__(self, repo: AbstractRepository): self.seen = set() # type: Set[model.Product] self._repo = repo\n\ndef add(self, product: model.Product): self._repo.add(product) self.seen.add(product)\n\ndef get(self, sku) -> model.Product: product = self._repo.get(sku) if product: self.seen.add(product) return product\n\nBy wrapping the repository, we can call the actual .add() and .get() methods, avoiding weird underscorey methods.\n\nSee if you can apply a similar pattern to our UoW class in order to get rid of those Java-y _commit() methods too. You can find the code on GitHub.\n\nSwitching all the ABCs to typing.Protocol is a good way to force yourself to avoid using inheritance. Let us know if you come up with something nice!\n\nYou might be starting to worry that maintaining these fakes is going to be a maintenance burden. There’s no doubt that it is work, but in our experience it’s not a lot of work. Once your project is up and running,\n\nthe interface for your repository and UoW abstractions really don’t change much. And if you’re using ABCs, they’ll help remind you when things get out of sync.",
      "content_length": 1657,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 243,
      "content": "Wrap-Up\n\nDomain events give us a way to handle workflows in our system. We often find, listening to our domain experts, that they express requirements in a causal or temporal way—for example, “When we try to allocate stock but there’s none available, then we should send an\n\nemail to the buying team.”\n\nThe magic words “When X, then Y” often tell us about an event that we can make concrete in our system. Treating events as first-class\n\nthings in our model helps us make our code more testable and observable, and it helps isolate concerns.\n\nAnd Table 8-1 shows the trade-offs as we see them.",
      "content_length": 593,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 244,
      "content": "Table 8-1. Domain events: the trade-offs\n\nPros\n\nCons\n\nA message bus gives us a nice way to separate responsibilities when we have to take multiple actions in response to a request.\n\nEvent handlers are nicely decoupled from the “core” application logic, making it easy to change their implementation later.\n\nDomain events are a great way to model the real world, and we can use them as part of our business language when modeling with stakeholders.\n\nThe message bus is an additional thing to wrap your head around; the implementation in which the unit of work raises events for us is neat but also magic. It’s not obvious when we call commit that we’re also going to go and send email to people.\n\nWhat’s more, that hidden event- handling code executes synchronously, meaning your service-layer function doesn’t finish until all the handlers for any events are finished. That could cause unexpected performance problems in your web endpoints (adding asynchronous processing is possible but makes things even more confusing).\n\nMore generally, event-driven workflows can be confusing because after things are split across a chain of multiple handlers, there is no single place in the system where you can understand how a request will be fulfilled.",
      "content_length": 1244,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 245,
      "content": "Pros\n\nCons\n\nYou also open yourself up to the possibility of circular dependencies between your event handlers, and infinite loops.\n\nEvents are useful for more than just sending email, though. In Chapter 7\n\nwe spent a lot of time convincing you that you should define aggregates, or boundaries where we guarantee consistency. People often ask, “What should I do if I need to change multiple aggregates as\n\npart of a request?” Now we have the tools we need to answer that question.\n\nIf we have two things that can be transactionally isolated (e.g., an\n\norder and a product), then we can make them eventually consistent by using events. When an order is canceled, we should find the products that were allocated to it and remove the allocations.",
      "content_length": 742,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 246,
      "content": "DOMAIN EVENTS AND THE MESSAGE BUS RECAP\n\nEvents can help with the single responsibility principle\n\nCode gets tangled up when we mix multiple concerns in one place. Events can help us to keep things tidy by separating primary use cases from secondary ones. We also use events for communicating between aggregates so that we don’t need to run long-running transactions that lock against multiple tables.\n\nA message bus routes messages to handlers\n\nYou can think of a message bus as a dict that maps from events to their consumers. It doesn’t “know” anything about the meaning of events; it’s just a piece of dumb infrastructure for getting messages around the system.\n\nOption 1: Service layer raises events and passes them to message bus\n\nThe simplest way to start using events in your system is to raise them from handlers by calling bus.handle(some_new_event) after you commit your unit of work.\n\nOption 2: Domain model raises events, service layer passes them to message bus\n\nThe logic about when to raise an event really should live with the model, so we can improve our system’s design and testability by raising events from the domain model. It’s easy for our handlers to collect events off the model objects after commit and pass them to the bus.\n\nOption 3: UoW collects events from aggregates and passes them to message bus\n\nAdding bus.handle(aggregate.events) to every handler is annoying, so we can tidy up by making our unit of work responsible for raising events that were raised by loaded objects. This is the most complex design and might rely on ORM magic, but it’s clean and easy to use once it’s set up.\n\nIn Chapter 9, we’ll look at this idea in more detail as we build a more complex workflow with our new message bus.\n\n1 This principle is the S in SOLID.\n\n2 Our tech reviewer Ed Jung likes to say that the move from imperative to event-based\n\nflow control changes what used to be orchestration into choreography.",
      "content_length": 1929,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 247,
      "content": "Chapter 9. Going to Town on the Message Bus\n\nIn this chapter, we’ll start to make events more fundamental to the internal structure of our application. We’ll move from the current state in Figure 9-1, where events are an optional side effect…",
      "content_length": 242,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 249,
      "content": "Figure 9-1. Before: the message bus is an optional add-on\n\n…to the situation in Figure 9-2, where everything goes via the message bus, and our app has been transformed fundamentally into a message processor.",
      "content_length": 207,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 251,
      "content": "Figure 9-2. The message bus is now the main entrypoint to the service layer\n\nTIP\n\nThe code for this chapter is in the chapter_09_all_messagebus branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_09_all_messagebus # or to code along, checkout the previous chapter: git checkout chapter_08_events_and_message_bus\n\nA New Requirement Leads Us to a New Architecture\n\nRich Hickey talks about situated software, meaning software that runs for extended periods of time, managing a real-world process. Examples include warehouse-management systems, logistics schedulers, and payroll systems.\n\nThis software is tricky to write because unexpected things happen all the time in the real world of physical objects and unreliable humans. For example:\n\nDuring a stock-take, we discover that three SPRINGY- MATTRESSes have been water damaged by a leaky roof.\n\nA consignment of RELIABLE-FORKs is missing the required documentation and is held in customs for several weeks. Three RELIABLE-FORKs subsequently fail safety testing and are destroyed.",
      "content_length": 1076,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 252,
      "content": "A global shortage of sequins means we’re unable to manufacture our next batch of SPARKLY-BOOKCASE.\n\nIn these types of situations, we learn about the need to change batch quantities when they’re already in the system. Perhaps someone made a mistake on the number in the manifest, or perhaps some sofas fell off a truck. Following a conversation with the business, we model the situation as in Figure 9-3.\n\n1\n\nFigure 9-3. Batch quantity changed means deallocate and reallocate\n\nAn event we’ll call BatchQuantityChanged should lead us to change the quantity on the batch, yes, but also to apply a business rule: if the new quantity drops to less than the total already allocated, we need to deallocate those orders from that batch. Then each one will require a new allocation, which we can capture as an event called AllocationRequired.\n\nPerhaps you’re already anticipating that our internal message bus and events can help implement this requirement. We could define a service called change_batch_quantity that knows how to adjust batch quantities and also how to deallocate any excess order lines, and then each deallocation can emit an AllocationRequired event that can be forwarded to the existing allocate service, in separate transactions.",
      "content_length": 1242,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 253,
      "content": "Once again, our message bus helps us to enforce the single\n\nresponsibility principle, and it allows us to make choices about transactions and data integrity.\n\nImagining an Architecture Change: Everything Will Be an Event Handler\n\nBut before we jump in, think about where we’re headed. There are two kinds of flows through our system:\n\nAPI calls that are handled by a service-layer function\n\nInternal events (which might be raised as a side effect of a service-layer function) and their handlers (which in turn call service-layer functions)\n\nWouldn’t it be easier if everything was an event handler? If we rethink\n\nour API calls as capturing events, the service-layer functions can be event handlers too, and we no longer need to make a distinction\n\nbetween internal and external event handlers:\n\nservices.allocate() could be the handler for an AllocationRequired event and could emit Allocated events as its output.\n\nservices.add_batch() could be the handler for a BatchCreated event.\n\n2\n\nOur new requirement will fit the same pattern:\n\nAn event called BatchQuantityChanged can invoke a handler called change_batch_quantity().",
      "content_length": 1126,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 254,
      "content": "And the new AllocationRequired events that it may raise can be passed on to services.allocate() too, so there is no conceptual difference between a brand-new allocation coming from the API and a reallocation that’s internally triggered by a deallocation.\n\nAll sound like a bit much? Let’s work toward it all gradually. We’ll\n\nfollow the Preparatory Refactoring workflow, aka “Make the change easy; then make the easy change”:\n\n1. We refactor our service layer into event handlers. We can get used to the idea of events being the way we describe inputs to the system. In particular, the existing services.allocate() function will become the handler for an event called AllocationRequired.\n\n2. We build an end-to-end test that puts\n\nBatchQuantityChanged events into the system and looks for Allocated events coming out.\n\n3. Our implementation will conceptually be very simple: a new handler for BatchQuantityChanged events, whose implementation will emit AllocationRequired events, which in turn will be handled by the exact same handler for allocations that the API uses.\n\nAlong the way, we’ll make a small tweak to the message bus and UoW,\n\nmoving the responsibility for putting new events on the message bus\n\ninto the message bus itself.\n\nRefactoring Service Functions to Message Handlers",
      "content_length": 1289,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 255,
      "content": "We start by defining the two events that capture our current API inputs —AllocationRequired and BatchCreated:\n\nBatchCreated and AllocationRequired events (src/allocation/domain/events.py)\n\n@dataclass class BatchCreated(Event): ref: str sku: str qty: int eta: Optional[date] = None\n\n...\n\n@dataclass class AllocationRequired(Event): orderid: str sku: str qty: int\n\nThen we rename services.py to handlers.py; we add the existing message handler for send_out_of_stock_notification; and most importantly, we change all the handlers so that they have the same\n\ninputs, an event and a UoW:\n\nHandlers and services are the same thing (src/allocation/service_layer/handlers.py)\n\ndef add_batch( event: events.BatchCreated, uow: unit_of_work.AbstractUnitOfWork ): with uow: product = uow.products.get(sku=event.sku) ...",
      "content_length": 807,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 256,
      "content": "def allocate( event: events.AllocationRequired, uow: unit_of_work.AbstractUnitOfWork ) -> str: line = OrderLine(event.orderid, event.sku, event.qty) ...\n\ndef send_out_of_stock_notification( event: events.OutOfStock, uow: unit_of_work.AbstractUnitOfWork, ): email.send( 'stock@made.com', f'Out of stock for {event.sku}', )\n\nThe change might be clearer as a diff:\n\nChanging from services to handlers\n\n(src/allocation/service_layer/handlers.py)\n\ndef add_batch( - ref: str, sku: str, qty: int, eta: Optional[date], - uow: unit_of_work.AbstractUnitOfWork + event: events.BatchCreated, uow: unit_of_work.AbstractUnitOfWork ): with uow: - product = uow.products.get(sku=sku) + product = uow.products.get(sku=event.sku) ...\n\ndef allocate( - orderid: str, sku: str, qty: int, - uow: unit_of_work.AbstractUnitOfWork + event: events.AllocationRequired, uow: unit_of_work.AbstractUnitOfWork ) -> str: - line = OrderLine(orderid, sku, qty) + line = OrderLine(event.orderid, event.sku, event.qty) ...\n\n+",
      "content_length": 989,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 257,
      "content": "+def send_out_of_stock_notification( + event: events.OutOfStock, uow: unit_of_work.AbstractUnitOfWork, +): + email.send( ...\n\nAlong the way, we’ve made our service-layer’s API more structured\n\nand more consistent. It was a scattering of primitives, and now it uses well-defined objects (see the following sidebar).\n\nFROM DOMAIN OBJECTS, VIA PRIMITIVE OBSESSION, TO EVENTS AS AN INTERFACE\n\nSome of you may remember “Fully Decoupling the Service-Layer Tests from the Domain”, in which we changed our service-layer API from being in terms of domain objects to primitives. And now we’re moving back, but to different objects? What gives?\n\nIn OO circles, people talk about primitive obsession as an anti-pattern: avoid primitives in public APIs, and instead wrap them with custom value classes, they would say. In the Python world, a lot of people would be quite skeptical of that as a rule of thumb. When mindlessly applied, it’s certainly a recipe for unnecessary complexity. So that’s not what we’re doing per se.\n\nThe move from domain objects to primitives bought us a nice bit of decoupling: our client code was no longer coupled directly to the domain, so the service layer could present an API that stays the same even if we decide to make changes to our model, and vice versa.\n\nSo have we gone backward? Well, our core domain model objects are still free to vary, but instead we’ve coupled the external world to our event classes. They’re part of the domain too, but the hope is that they vary less often, so they’re a sensible artifact to couple on.\n\nAnd what have we bought ourselves? Now, when invoking a use case in our application, we no longer need to remember a particular combination of primitives, but just a single event class that represents the input to our application. That’s conceptually quite nice. On top of that, as you’ll see in Appendix E, those event classes can be a nice place to do some input validation.\n\nThe Message Bus Now Collects Events from the UoW\n\nOur event handlers now need a UoW. In addition, as our message bus\n\nbecomes more central to our application, it makes sense to put it\n\nexplicitly in charge of collecting and processing new events. There",
      "content_length": 2185,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 258,
      "content": "was a bit of a circular dependency between the UoW and message bus until now, so this will make it one-way:\n\nHandle takes a UoW and manages a queue\n\n(src/allocation/service_layer/messagebus.py)\n\ndef handle(event: events.Event, uow: unit_of_work.AbstractUnitOfWork): queue = [event] while queue: event = queue.pop(0) for handler in HANDLERS[type(event)]: handler(event, uow=uow) queue.extend(uow.collect_new_events())\n\nThe message bus now gets passed the UoW each time it starts up.\n\nWhen we begin handling our first event, we start a queue.\n\nWe pop events from the front of the queue and invoke their handlers (the HANDLERS dict hasn’t changed; it still maps event types to handler functions).\n\nThe message bus passes the UoW down to each handler.\n\nAfter each handler finishes, we collect any new events that have been generated and add them to the queue.\n\nIn unit_of_work.py, publish_events() becomes a less active method, collect_new_events():\n\nUoW no longer puts events directly on the bus\n\n(src/allocation/service_layer/unit_of_work.py)\n\nfrom . import messagebus -",
      "content_length": 1068,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 259,
      "content": "class AbstractUnitOfWork(abc.ABC): @@ -23,13 +21,11 @@ class AbstractUnitOfWork(abc.ABC):\n\ndef commit(self): self._commit() - self.publish_events()\n\ndef publish_events(self): + def collect_new_events(self): for product in self.products.seen: while product.events: - event = product.events.pop(0) - messagebus.handle(event) + yield product.events.pop(0)\n\nThe unit_of_work module now no longer depends on messagebus.\n\nWe no longer publish_events automatically on commit. The message bus is keeping track of the event queue instead.\n\nAnd the UoW no longer actively puts events on the message bus; it just makes them available.\n\nOur Tests Are All Written in Terms of Events Too\n\nOur tests now operate by creating events and putting them on the message bus, rather than invoking service-layer functions directly:\n\nHandler tests use events (tests/unit/test_handlers.py)\n\nclass TestAddBatch:\n\ndef test_for_new_product(self): uow = FakeUnitOfWork() - services.add_batch(\"b1\", \"CRUNCHY-ARMCHAIR\", 100, None, uow) + messagebus.handle( + events.BatchCreated(\"b1\", \"CRUNCHY-ARMCHAIR\", 100, None), uow + ) assert uow.products.get(\"CRUNCHY-ARMCHAIR\") is not None",
      "content_length": 1148,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 260,
      "content": "assert uow.committed\n\n...\n\nclass TestAllocate:\n\ndef test_returns_allocation(self): uow = FakeUnitOfWork() - services.add_batch(\"batch1\", \"COMPLICATED-LAMP\", 100, None, uow) - result = services.allocate(\"o1\", \"COMPLICATED-LAMP\", 10, uow) + messagebus.handle( + events.BatchCreated(\"batch1\", \"COMPLICATED-LAMP\", 100, None), uow + ) + result = messagebus.handle( + events.AllocationRequired(\"o1\", \"COMPLICATED-LAMP\", 10), uow + ) assert result == \"batch1\"\n\nA Temporary Ugly Hack: The Message Bus Has to Return Results\n\nOur API and our service layer currently want to know the allocated batch reference when they invoke our allocate() handler. This means we need to put in a temporary hack on our message bus to let it return events:\n\nMessage bus returns results (src/allocation/service_layer/messagebus.py)\n\ndef handle(event: events.Event, uow: unit_of_work.AbstractUnitOfWork): + results = [] queue = [event] while queue: event = queue.pop(0) for handler in HANDLERS[type(event)]: - handler(event, uow=uow) + results.append(handler(event, uow=uow)) queue.extend(uow.collect_new_events()) + return results",
      "content_length": 1102,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 261,
      "content": "It’s because we’re mixing the read and write responsibilities in our system. We’ll come back to fix this wart in Chapter 12.\n\nModifying Our API to Work with Events\n\nFlask changing to message bus as a diff (src/allocation/entrypoints/flask_app.py)\n\n@app.route(\"/allocate\", methods=['POST']) def allocate_endpoint(): try: - batchref = services.allocate( - request.json['orderid'], - request.json['sku'], - request.json['qty'], - unit_of_work.SqlAlchemyUnitOfWork(), + event = events.AllocationRequired( + request.json['orderid'], request.json['sku'], request.json['qty'], ) + results = messagebus.handle(event, unit_of_work.SqlAlchemyUnitOfWork())\n\n+ batchref = results.pop(0) except InvalidSku as e:\n\nInstead of calling the service layer with a bunch of primitives extracted from the request JSON…\n\nWe instantiate an event.\n\nThen we pass it to the message bus.\n\nAnd we should be back to a fully functional application, but one that’s now fully event-driven:\n\nWhat used to be service-layer functions are now event handlers.\n\nThat makes them the same as the functions we invoke for handling internal events raised by our domain model.",
      "content_length": 1131,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 262,
      "content": "We use events as our data structure for capturing inputs to the system, as well as for handing off of internal work packages.\n\nThe entire app is now best described as a message processor, or an event processor if you prefer. We’ll talk about the distinction in the next chapter.\n\nImplementing Our New Requirement\n\nWe’re done with our refactoring phase. Let’s see if we really have “made the change easy.” Let’s implement our new requirement, shown\n\nin Figure 9-4: we’ll receive as our inputs some new BatchQuantityChanged events and pass them to a handler, which in turn might emit some AllocationRequired events, and those in turn will go back to our existing handler for reallocation.",
      "content_length": 686,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 264,
      "content": "Figure 9-4. Sequence diagram for reallocation flow\n\nWARNING\n\nWhen you split things out like this across two units of work, you now have two database transactions, so you are opening yourself up to integrity issues: something could happen that means the first transaction completes but the second one does not. You’ll need to think about whether this is acceptable, and whether you need to notice when it happens and do something about it. See “Footguns” for more discussion.\n\nOur New Event\n\nThe event that tells us a batch quantity has changed is simple; it just needs a batch reference and a new quantity:\n\nNew event (src/allocation/domain/events.py)\n\n@dataclass class BatchQuantityChanged(Event): ref: str qty: int\n\nTest-Driving a New Handler\n\nFollowing the lessons learned in Chapter 4, we can operate in “high gear” and write our unit tests at the highest possible level of abstraction, in terms of events. Here’s what they might look like:\n\nHandler tests for change_batch_quantity (tests/unit/test_handlers.py)",
      "content_length": 1015,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 265,
      "content": "class TestChangeBatchQuantity:\n\ndef test_changes_available_quantity(self): uow = FakeUnitOfWork() messagebus.handle( events.BatchCreated(\"batch1\", \"ADORABLE-SETTEE\", 100, None), uow ) [batch] = uow.products.get(sku=\"ADORABLE-SETTEE\").batches assert batch.available_quantity == 100\n\nmessagebus.handle(events.BatchQuantityChanged(\"batch1\", 50), uow)\n\nassert batch.available_quantity == 50\n\ndef test_reallocates_if_necessary(self): uow = FakeUnitOfWork() event_history = [ events.BatchCreated(\"batch1\", \"INDIFFERENT-TABLE\", 50, None), events.BatchCreated(\"batch2\", \"INDIFFERENT-TABLE\", 50, date.today()), events.AllocationRequired(\"order1\", \"INDIFFERENT-TABLE\", 20), events.AllocationRequired(\"order2\", \"INDIFFERENT-TABLE\", 20), ] for e in event_history: messagebus.handle(e, uow) [batch1, batch2] = uow.products.get(sku=\"INDIFFERENT-TABLE\").batches assert batch1.available_quantity == 10 assert batch2.available_quantity == 50\n\nmessagebus.handle(events.BatchQuantityChanged(\"batch1\", 25), uow)\n\n# order1 or order2 will be deallocated, so we'll have 25 - 20 assert batch1.available_quantity == 5 # and 20 will be reallocated to the next batch assert batch2.available_quantity == 30\n\nThe simple case would be trivially easy to implement; we just modify a quantity.",
      "content_length": 1260,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 266,
      "content": "But if we try to change the quantity to less than has been allocated, we’ll need to deallocate at least one order, and we expect to reallocate it to a new batch.\n\nImplementation\n\nOur new handler is very simple:\n\nHandler delegates to model layer\n\n(src/allocation/service_layer/handlers.py)\n\ndef change_batch_quantity( event: events.BatchQuantityChanged, uow: unit_of_work.AbstractUnitOfWork ): with uow: product = uow.products.get_by_batchref(batchref=event.ref) product.change_batch_quantity(ref=event.ref, qty=event.qty) uow.commit()\n\nWe realize we’ll need a new query type on our repository:\n\nA new query type on our repository (src/allocation/adapters/repository.py)\n\nclass AbstractRepository(abc.ABC): ...\n\ndef get(self, sku) -> model.Product: ...\n\ndef get_by_batchref(self, batchref) -> model.Product: product = self._get_by_batchref(batchref) if product: self.seen.add(product) return product\n\n@abc.abstractmethod",
      "content_length": 919,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 267,
      "content": "def _add(self, product: model.Product): raise NotImplementedError\n\n@abc.abstractmethod def _get(self, sku) -> model.Product: raise NotImplementedError\n\n@abc.abstractmethod def _get_by_batchref(self, batchref) -> model.Product: raise NotImplementedError ...\n\nclass SqlAlchemyRepository(AbstractRepository): ...\n\ndef _get(self, sku): return self.session.query(model.Product).filter_by(sku=sku).first()\n\ndef _get_by_batchref(self, batchref): return self.session.query(model.Product).join(model.Batch).filter( orm.batches.c.reference == batchref, ).first()\n\nAnd on our FakeRepository too:\n\nUpdating the fake repo too (tests/unit/test_handlers.py)\n\nclass FakeRepository(repository.AbstractRepository): ...\n\ndef _get(self, sku): return next((p for p in self._products if p.sku == sku), None)\n\ndef _get_by_batchref(self, batchref): return next(( p for p in self._products for b in p.batches if b.reference == batchref ), None)",
      "content_length": 919,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 268,
      "content": "NOTE\n\nWe’re adding a query to our repository to make this use case easier to implement. So long as our query is returning a single aggregate, we’re not bending any rules. If you find yourself writing complex queries on your repositories, you might want to consider a different design. Methods like get_most_popular_products or find_products_by_order_id in particular would definitely trigger our spidey sense. Chapter 11 and the epilogue have some tips on managing complex queries.\n\nA New Method on the Domain Model\n\nWe add the new method to the model, which does the quantity change and deallocation(s) inline and publishes a new event. We also modify\n\nthe existing allocate function to publish an event:\n\nOur model evolves to capture the new requirement (src/allocation/domain/model.py)\n\nclass Product: ...\n\ndef change_batch_quantity(self, ref: str, qty: int): batch = next(b for b in self.batches if b.reference == ref) batch._purchased_quantity = qty while batch.available_quantity < 0: line = batch.deallocate_one() self.events.append( events.AllocationRequired(line.orderid, line.sku, line.qty) ) ...\n\nclass Batch: ...\n\ndef deallocate_one(self) -> OrderLine: return self._allocations.pop()",
      "content_length": 1195,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 269,
      "content": "We wire up our new handler:\n\nThe message bus grows (src/allocation/service_layer/messagebus.py)\n\nHANDLERS = { events.BatchCreated: [handlers.add_batch], events.BatchQuantityChanged: [handlers.change_batch_quantity], events.AllocationRequired: [handlers.allocate], events.OutOfStock: [handlers.send_out_of_stock_notification],\n\n} # type: Dict[Type[events.Event], List[Callable]]\n\nAnd our new requirement is fully implemented.\n\nOptionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nOur main test for the reallocation workflow is edge-to-edge (see the example code in “Test-Driving a New Handler”). It uses the real message bus, and it tests the whole flow, where the BatchQuantityChanged event handler triggers deallocation, and emits new AllocationRequired events, which in turn are handled by their own handlers. One test covers a chain of multiple events and handlers.\n\nDepending on the complexity of your chain of events, you may decide that you want to test some handlers in isolation from one another. You can do this using a “fake” message bus.",
      "content_length": 1073,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 270,
      "content": "In our case, we actually intervene by modifying the publish_events() method on FakeUnitOfWork and decoupling it from the real message bus, instead making it record what events it\n\nsees:\n\nFake message bus implemented in UoW (tests/unit/test_handlers.py)\n\nclass FakeUnitOfWorkWithFakeMessageBus(FakeUnitOfWork):\n\ndef __init__(self): super().__init__() self.events_published = [] # type: List[events.Event]\n\ndef publish_events(self): for product in self.products.seen: while product.events: self.events_published.append(product.events.pop(0))\n\nNow when we invoke messagebus.handle() using the FakeUnitOfWorkWithFakeMessageBus, it runs only the handler for that event. So we can write a more isolated unit test: instead of checking all the side effects, we just check that BatchQuantityChanged leads to AllocationRequired if the quantity drops below the total already allocated:\n\nTesting reallocation in isolation (tests/unit/test_handlers.py)\n\ndef test_reallocates_if_necessary_isolated(): uow = FakeUnitOfWorkWithFakeMessageBus()\n\n# test setup as before event_history = [ events.BatchCreated(\"batch1\", \"INDIFFERENT-TABLE\", 50, None), events.BatchCreated(\"batch2\", \"INDIFFERENT-TABLE\", 50, date.today()), events.AllocationRequired(\"order1\", \"INDIFFERENT-TABLE\", 20),",
      "content_length": 1263,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 271,
      "content": "events.AllocationRequired(\"order2\", \"INDIFFERENT-TABLE\", 20), ] for e in event_history: messagebus.handle(e, uow) [batch1, batch2] = uow.products.get(sku=\"INDIFFERENT-TABLE\").batches assert batch1.available_quantity == 10 assert batch2.available_quantity == 50\n\nmessagebus.handle(events.BatchQuantityChanged(\"batch1\", 25), uow)\n\n# assert on new events emitted rather than downstream side-effects [reallocation_event] = uow.events_published assert isinstance(reallocation_event, events.AllocationRequired) assert reallocation_event.orderid in {'order1', 'order2'} assert reallocation_event.sku == 'INDIFFERENT-TABLE'\n\nWhether you want to do this or not depends on the complexity of your chain of events. We say, start out with edge-to-edge testing, and resort to this only if necessary.",
      "content_length": 785,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 272,
      "content": "EXERCISE FOR THE READER\n\nA great way to force yourself to really understand some code is to refactor it. In the discussion of testing handlers in isolation, we used something called FakeUnitOfWorkWithFakeMessageBus, which is unnecessarily complicated and violates the SRP.\n\n3\n\nIf we change the message bus to being a class, then building a FakeMessageBus is more straightforward:\n\nAn abstract message bus and its real and fake versions\n\nclass AbstractMessageBus: HANDLERS: Dict[Type[events.Event], List[Callable]]\n\ndef handle(self, event: events.Event): for handler in self.HANDLERS[type(event)]: handler(event)\n\nclass MessageBus(AbstractMessageBus): HANDLERS = { events.OutOfStock: [send_out_of_stock_notification],\n\n}\n\nclass FakeMessageBus(messagebus.AbstractMessageBus): def __init__(self): self.events_published = [] # type: List[events.Event] self.handlers = { events.OutOfStock: [lambda e: self.events_published.append(e)] }\n\nSo jump into the code on GitHub and see if you can get a class-based version working, and then write a version of test_reallocates_if_necessary_isolated() from earlier.\n\nWe use a class-based message bus in Chapter 13, if you need more inspiration.\n\nWrap-Up\n\nLet’s look back at what we’ve achieved, and think about why we did it.\n\nWhat Have We Achieved?",
      "content_length": 1284,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 273,
      "content": "Events are simple dataclasses that define the data structures for inputs and internal messages within our system. This is quite powerful from a DDD standpoint, since events often translate really well into business language (look up event storming if you haven’t already).\n\nHandlers are the way we react to events. They can call down to our model or call out to external services. We can define multiple handlers for a single event if we want to. Handlers can also raise other events. This allows us to be very granular about what a handler does and really stick to the SRP.\n\nWhy Have We Achieved?\n\nOur ongoing objective with these architectural patterns is to try to have the complexity of our application grow more slowly than its size. When we go all in on the message bus, as always we pay a price in terms of architectural complexity (see Table 9-1), but we buy\n\nourselves a pattern that can handle almost arbitrarily complex requirements without needing any further conceptual or architectural change to the way we do things.\n\nHere we’ve added quite a complicated use case (change quantity, deallocate, start new transaction, reallocate, publish external notification), but architecturally, there’s been no cost in terms of\n\ncomplexity. We’ve added new events, new handlers, and a new external adapter (for email), all of which are existing categories of things in our architecture that we understand and know how to reason about, and that are easy to explain to newcomers. Our moving parts",
      "content_length": 1496,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 274,
      "content": "each have one job, they’re connected to each other in well-defined ways, and there are no unexpected side effects.\n\nTable 9-1. Whole app is a message bus: the trade-offs\n\nPros\n\nCons\n\nHandlers and services are the same thing, so that’s simpler.\n\nA message bus is still a slightly unpredictable way of doing things from a web point of view. You don’t know in advance when things are going to end.\n\nWe have a nice data structure for inputs to the system.\n\nThere will be duplication of fields and structure between model objects and events, which will have a maintenance cost. Adding a field to one usually means adding a field to at least one of the others.\n\nNow, you may be wondering, where are those BatchQuantityChanged events going to come from? The answer is revealed in a couple chapters’ time. But first, let’s talk about events versus commands.\n\n1 Event-based modeling is so popular that a practice called event storming has been developed for facilitating event-based requirements gathering and domain model",
      "content_length": 1013,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 275,
      "content": "elaboration.\n\n2 If you’ve done a bit of reading about event-driven architectures, you may be thinking, “Some of these events sound more like commands!” Bear with us! We’re trying to introduce one concept at a time. In the next chapter, we’ll introduce the distinction between commands and events.\n\n3 The “simple” implementation in this chapter essentially uses the messagebus.py module\n\nitself to implement the Singleton Pattern.",
      "content_length": 429,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 276,
      "content": "Chapter 10. Commands and Command Handler\n\nIn the previous chapter, we talked about using events as a way of representing the inputs to our system, and we turned our application into a message-processing machine.\n\nTo achieve that, we converted all our use-case functions to event\n\nhandlers. When the API receives a POST to create a new batch, it builds a new BatchCreated event and handles it as if it were an internal event. This might feel counterintuitive. After all, the batch hasn’t been created yet; that’s why we called the API. We’re going to fix that conceptual wart by introducing commands and showing how\n\nthey can be handled by the same message bus but with slightly different rules.\n\nTIP\n\nThe code for this chapter is in the chapter_10_commands branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_10_commands # or to code along, checkout the previous chapter: git checkout chapter_09_all_messagebus\n\nCommands and Events",
      "content_length": 978,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 277,
      "content": "Like events, commands are a type of message—instructions sent by one part of a system to another. We usually represent commands with dumb data structures and can handle them in much the same way as events.\n\nThe differences between commands and events, though, are important.\n\nCommands are sent by one actor to another specific actor with the expectation that a particular thing will happen as a result. When we post a form to an API handler, we are sending a command. We name\n\ncommands with imperative mood verb phrases like “allocate stock” or “delay shipment.”\n\nCommands capture intent. They express our wish for the system to do something. As a result, when they fail, the sender needs to receive error information.\n\nEvents are broadcast by an actor to all interested listeners. When we publish BatchQuantityChanged, we don’t know who’s going to pick it up. We name events with past-tense verb phrases like “order\n\nallocated to stock” or “shipment delayed.”\n\nWe often use events to spread the knowledge about successful\n\ncommands.\n\nEvents capture facts about things that happened in the past. Since we\n\ndon’t know who’s handling an event, senders should not care whether the receivers succeeded or failed. Table 10-1 recaps the differences.",
      "content_length": 1243,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 278,
      "content": "Table 10-1. Events versus commands\n\nEvent\n\nCommand\n\nNamed\n\nPast tense\n\nImperative mood\n\nError handling\n\nFail independently\n\nFail noisily\n\nSent to\n\nAll listeners\n\nOne recipient\n\nWhat kinds of commands do we have in our system right now?\n\nPulling out some commands (src/allocation/domain/commands.py)\n\nclass Command: pass\n\n@dataclass class Allocate(Command): orderid: str sku: str qty: int\n\n@dataclass class CreateBatch(Command): ref: str sku: str qty: int eta: Optional[date] = None\n\n@dataclass class ChangeBatchQuantity(Command): ref: str qty: int\n\ncommands.Allocate will replace events.AllocationRequired.",
      "content_length": 606,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 279,
      "content": "commands.CreateBatch will replace events.BatchCreated.\n\ncommands.ChangeBatchQuantity will replace events.BatchQuantityChanged.\n\nDifferences in Exception Handling\n\nJust changing the names and verbs is all very well, but that won’t change the behavior of our system. We want to treat events and commands similarly, but not exactly the same. Let’s see how our\n\nmessage bus changes:\n\nDispatch events and commands differently (src/allocation/service_layer/messagebus.py)\n\nMessage = Union[commands.Command, events.Event]\n\ndef handle(message: Message, uow: unit_of_work.AbstractUnitOfWork): results = [] queue = [message] while queue: message = queue.pop(0) if isinstance(message, events.Event): handle_event(message, queue, uow) elif isinstance(message, commands.Command): cmd_result = handle_command(message, queue, uow) results.append(cmd_result) else: raise Exception(f'{message} was not an Event or Command') return results\n\nIt still has a main handle() entrypoint that takes a message, which may be a command or an event.",
      "content_length": 1020,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 280,
      "content": "We dispatch events and commands to two different helper functions, shown next.\n\nHere’s how we handle events:\n\nEvents cannot interrupt the flow (src/allocation/service_layer/messagebus.py)\n\ndef handle_event( event: events.Event, queue: List[Message], uow: unit_of_work.AbstractUnitOfWork ): for handler in EVENT_HANDLERS[type(event)]: try: logger.debug('handling event %s with handler %s', event, handler) handler(event, uow=uow) queue.extend(uow.collect_new_events()) except Exception: logger.exception('Exception handling event %s', event) continue\n\nEvents go to a dispatcher that can delegate to multiple handlers per event.\n\nIt catches and logs errors but doesn’t let them interrupt message processing.\n\nAnd here’s how we do commands:\n\nCommands reraise exceptions (src/allocation/service_layer/messagebus.py)\n\ndef handle_command( command: commands.Command, queue: List[Message],",
      "content_length": 881,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 281,
      "content": "uow: unit_of_work.AbstractUnitOfWork ): logger.debug('handling command %s', command) try: handler = COMMAND_HANDLERS[type(command)] result = handler(command, uow=uow) queue.extend(uow.collect_new_events()) return result except Exception: logger.exception('Exception handling command %s', command) raise\n\nThe command dispatcher expects just one handler per command.\n\nIf any errors are raised, they fail fast and will bubble up.\n\nreturn result is only temporary; as mentioned in “A Temporary Ugly Hack: The Message Bus Has to Return Results”, it’s a temporary hack to allow the message bus to return the batch reference for the API to use. We’ll fix this in Chapter 12.\n\nWe also change the single HANDLERS dict into different ones for commands and events. Commands can have only one handler, according to our convention:\n\nNew handlers dicts (src/allocation/service_layer/messagebus.py)\n\nEVENT_HANDLERS = { events.OutOfStock: [handlers.send_out_of_stock_notification], } # type: Dict[Type[events.Event], List[Callable]]\n\nCOMMAND_HANDLERS = { commands.Allocate: handlers.allocate, commands.CreateBatch: handlers.add_batch, commands.ChangeBatchQuantity: handlers.change_batch_quantity, } # type: Dict[Type[commands.Command], Callable]",
      "content_length": 1229,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 282,
      "content": "Discussion: Events, Commands, and Error Handling\n\nMany developers get uncomfortable at this point and ask, “What happens when an event fails to process? How am I supposed to make sure the system is in a consistent state?” If we manage to process half of the events during messagebus.handle before an out-of-memory error kills our process, how do we mitigate problems caused by the lost messages?\n\nLet’s start with the worst case: we fail to handle an event, and the\n\nsystem is left in an inconsistent state. What kind of error would cause this? Often in our systems we can end up in an inconsistent state when\n\nonly half an operation is completed.\n\nFor example, we could allocate three units of DESIRABLE_BEANBAG to a customer’s order but somehow fail to reduce the amount of remaining\n\nstock. This would cause an inconsistent state: the three units of stock are both allocated and available, depending on how you look at it.\n\nLater, we might allocate those same beanbags to another customer, causing a headache for customer support.\n\nIn our allocation service, though, we’ve already taken steps to prevent\n\nthat happening. We’ve carefully identified aggregates that act as consistency boundaries, and we’ve introduced a UoW that manages the\n\natomic success or failure of an update to an aggregate.\n\nFor example, when we allocate stock to an order, our consistency boundary is the Product aggregate. This means that we can’t",
      "content_length": 1424,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 283,
      "content": "accidentally overallocate: either a particular order line is allocated to\n\nthe product, or it is not—there’s no room for inconsistent states.\n\nBy definition, we don’t require two aggregates to be immediately consistent, so if we fail to process an event and update only a single\n\naggregate, our system can still be made eventually consistent. We shouldn’t violate any constraints of the system.\n\nWith this example in mind, we can better understand the reason for\n\nsplitting messages into commands and events. When a user wants to make the system do something, we represent their request as a\n\ncommand. That command should modify a single aggregate and either succeed or fail in totality. Any other bookkeeping, cleanup, and\n\nnotification we need to do can happen via an event. We don’t require the event handlers to succeed in order for the command to be\n\nsuccessful.\n\nLet’s look at another example (from a different, imaginary projet) to see why not.\n\nImagine we are building an ecommerce website that sells expensive\n\nluxury goods. Our marketing department wants to reward customers for repeat visits. We will flag customers as VIPs after they make their\n\nthird purchase, and this will entitle them to priority treatment and\n\nspecial offers. Our acceptance criteria for this story reads as follows:\n\nGiven a customer with two orders in their history, When the customer places a third order, Then they should be flagged as a VIP.\n\nWhen a customer first becomes a VIP Then we should send them an email to congratulate them",
      "content_length": 1522,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 284,
      "content": "Using the techniques we’ve already discussed in this book, we decide that we want to build a new History aggregate that records orders and can raise domain events when rules are met. We will structure the code\n\nlike this:\n\nVIP customer (example code for a different project)\n\nclass History: # Aggregate\n\ndef __init__(self, customer_id: int): self.orders = set() # Set[HistoryEntry] self.customer_id = customer_id\n\ndef record_order(self, order_id: str, order_amount: int): entry = HistoryEntry(order_id, order_amount)\n\nif entry in self.orders: return\n\nself.orders.add(entry)\n\nif len(self.orders) == 3: self.events.append( CustomerBecameVIP(self.customer_id) )\n\ndef create_order_from_basket(uow, cmd: CreateOrder): with uow: order = Order.from_basket(cmd.customer_id, cmd.basket_items) uow.orders.add(order) uow.commit() # raises OrderCreated\n\ndef update_customer_history(uow, event: OrderCreated): with uow: history = uow.order_history.get(event.customer_id) history.record_order(event.order_id, event.order_amount) uow.commit() # raises CustomerBecameVIP",
      "content_length": 1054,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 285,
      "content": "def congratulate_vip_customer(uow, event: CustomerBecameVip): with uow: customer = uow.customers.get(event.customer_id) email.send( customer.email_address, f'Congratulations {customer.first_name}!' )\n\nThe History aggregate captures the rules indicating when a customer becomes a VIP. This puts us in a good place to handle changes when the rules become more complex in the future.\n\nOur first handler creates an order for the customer and raises a domain event OrderCreated.\n\nOur second handler updates the History object to record that an order was created.\n\nFinally, we send an email to the customer when they become a VIP.\n\nUsing this code, we can gain some intuition about error handling in an event-driven system.\n\nIn our current implementation, we raise events about an aggregate after\n\nwe persist our state to the database. What if we raised those events before we persisted, and committed all our changes at the same time?\n\nThat way, we could be sure that all the work was complete. Wouldn’t that be safer?\n\nWhat happens, though, if the email server is slightly overloaded? If all\n\nthe work has to complete at the same time, a busy email server can stop us from taking money for orders.",
      "content_length": 1193,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 286,
      "content": "What happens if there is a bug in the implementation of the History aggregate? Should we fail to take your money just because we can’t recognize you as a VIP?\n\nBy separating out these concerns, we have made it possible for things\n\nto fail in isolation, which improves the overall reliability of the system. The only part of this code that has to complete is the command\n\nhandler that creates an order. This is the only part that a customer cares about, and it’s the part that our business stakeholders should prioritize.\n\nNotice how we’ve deliberately aligned our transactional boundaries to\n\nthe start and end of the business processes. The names that we use in the code match the jargon used by our business stakeholders, and the\n\nhandlers we’ve written match the steps of our natural language\n\nacceptance criteria. This concordance of names and structure helps us to reason about our systems as they grow larger and more complex.\n\nRecovering from Errors Synchronously\n\nHopefully we’ve convinced you that it’s OK for events to fail independently from the commands that raised them. What should we\n\ndo, then, to make sure we can recover from errors when they inevitably occur?\n\nThe first thing we need is to know when an error has occurred, and for\n\nthat we usually rely on logs.\n\nLet’s look again at the handle_event method from our message bus:",
      "content_length": 1347,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 287,
      "content": "Current handle function (src/allocation/service_layer/messagebus.py)\n\ndef handle_event( event: events.Event, queue: List[Message], uow: unit_of_work.AbstractUnitOfWork ): for handler in EVENT_HANDLERS[type(event)]: try: logger.debug('handling event %s with handler %s', event, handler) handler(event, uow=uow) queue.extend(uow.collect_new_events()) except Exception: logger.exception('Exception handling event %s', event) continue\n\nWhen we handle a message in our system, the first thing we do is write\n\na log line to record what we’re about to do. For our CustomerBecameVIP use case, the logs might read as follows:\n\nHandling event CustomerBecameVIP(customer_id=12345) with handler <function congratulate_vip_customer at 0x10ebc9a60>\n\nBecause we’ve chosen to use dataclasses for our message types, we get a neatly printed summary of the incoming data that we can copy and\n\npaste into a Python shell to re-create the object.\n\nWhen an error occurs, we can use the logged data to either reproduce\n\nthe problem in a unit test or replay the message into the system.\n\nManual replay works well for cases where we need to fix a bug before\n\nwe can re-process an event, but our systems will always experience\n\nsome background level of transient failure. This includes things like",
      "content_length": 1270,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 288,
      "content": "network hiccups, table deadlocks, and brief downtime caused by\n\ndeployments.\n\nFor most of those cases, we can recover elegantly by trying again. As the proverb says, “If at first you don’t succeed, retry the operation with\n\nan exponentially increasing back-off period.”\n\nHandle with retry (src/allocation/service_layer/messagebus.py)\n\nfrom tenacity import Retrying, RetryError, stop_after_attempt, wait_exponential\n\n...\n\ndef handle_event( event: events.Event, queue: List[Message], uow: unit_of_work.AbstractUnitOfWork ):\n\nfor handler in EVENT_HANDLERS[type(event)]: try: for attempt in Retrying( stop=stop_after_attempt(3), wait=wait_exponential() ):\n\nwith attempt: logger.debug('handling event %s with handler %s', event, handler) handler(event, uow=uow) queue.extend(uow.collect_new_events()) except RetryError as retry_failure: logger.error( 'Failed to handle event %s times, giving up!, retry_failure.last_attempt.attempt_number ) continue",
      "content_length": 944,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 289,
      "content": "Tenacity is a Python library that implements common patterns for retrying.\n\nHere we configure our message bus to retry operations up to three times, with an exponentially increasing wait between attempts.\n\nRetrying operations that might fail is probably the single best way to improve the resilience of our software. Again, the Unit of Work and Command Handler patterns mean that each attempt starts from a consistent state and won’t leave things half-finished.\n\nWARNING\n\nAt some point, regardless of tenacity, we’ll have to give up trying to process the message. Building reliable systems with distributed messages is hard, and we have to skim over some tricky bits. There are pointers to more reference materials in the epilogue.\n\nWrap-Up\n\nIn this book we decided to introduce the concept of events before the concept of commands, but other guides often do it the other way\n\naround. Making explicit the requests that our system can respond to by giving them a name and their own data structure is quite a fundamental thing to do. You’ll sometimes see people use the name Command Handler pattern to describe what we’re doing with Events,\n\nCommands, and Message Bus.\n\nTable 10-2 discusses some of the things you should think about before you jump on board.",
      "content_length": 1256,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 290,
      "content": "Table 10-2. Splitting commands and events: the trade-offs\n\nPros\n\nCons\n\nTreating commands and events differently helps us understand which things have to succeed and which things we can tidy up later.\n\nThe semantic differences between commands and events can be subtle. Expect bikeshedding arguments over the differences.\n\nCreateBatch is definitely a less confusing name than Batc hCreated. We are being explicit about the intent of our users, and explicit is better than implicit, right?\n\nWe’re expressly inviting failure. We know that sometimes things will break, and we’re choosing to handle that by making the failures smaller and more isolated. This can make the system harder to reason about and requires better monitoring.\n\nIn Chapter 11 we’ll talk about using events as an integration pattern.",
      "content_length": 800,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 291,
      "content": "Chapter 11. Event-Driven Architecture: Using Events to Integrate Microservices\n\nIn the preceding chapter, we never actually spoke about how we would receive the “batch quantity changed” events, or indeed, how we might notify the outside world about reallocations.\n\nWe have a microservice with a web API, but what about other ways of talking to other systems? How will we know if, say, a shipment is\n\ndelayed or the quantity is amended? How will we tell the warehouse system that an order has been allocated and needs to be sent to a\n\ncustomer?\n\nIn this chapter, we’d like to show how the events metaphor can be\n\nextended to encompass the way that we handle incoming and outgoing messages from the system. Internally, the core of our application is\n\nnow a message processor. Let’s follow through on that so it becomes a message processor externally as well. As shown in Figure 11-1, our\n\napplication will receive events from external sources via an external message bus (we’ll use Redis pub/sub queues as an example) and publish its outputs, in the form of events, back there as well.",
      "content_length": 1083,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 293,
      "content": "Figure 11-1. Our application is a message processor\n\nTIP\n\nThe code for this chapter is in the chapter_11_external_events branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_11_external_events # or to code along, checkout the previous chapter: git checkout chapter_10_commands\n\nDistributed Ball of Mud, and Thinking in Nouns\n\nBefore we get into that, let’s talk about the alternatives. We regularly talk to engineers who are trying to build out a microservices architecture. Often they are migrating from an existing application, and\n\ntheir first instinct is to split their system into nouns.\n\nWhat nouns have we introduced so far in our system? Well, we have batches of stock, orders, products, and customers. So a naive attempt\n\nat breaking up the system might have looked like Figure 11-2 (notice that we’ve named our system after a noun, Batches, instead of Allocation).",
      "content_length": 920,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 294,
      "content": "Figure 11-2. Context diagram with noun-based services\n\nEach “thing” in our system has an associated service, which exposes an HTTP API.\n\nLet’s work through an example happy-path flow in Figure 11-3: our users visit a website and can choose from products that are in stock. When they add an item to their basket, we will reserve some stock for them. When an order is complete, we confirm the reservation, which causes us to send dispatch instructions to the warehouse. Let’s also",
      "content_length": 478,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 295,
      "content": "say, if this is the customer’s third order, we want to update the customer record to flag them as a VIP.\n\nFigure 11-3. Command flow 1\n\nWe can think of each of these steps as a command in our system: ReserveStock, ConfirmReservation, DispatchGoods, MakeCustomerVIP, and so forth.\n\nThis style of architecture, where we create a microservice per database table and treat our HTTP APIs as CRUD interfaces to anemic models, is the most common initial way for people to approach service-oriented design.\n\nThis works fine for systems that are very simple, but it can quickly degrade into a distributed ball of mud.",
      "content_length": 607,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 296,
      "content": "To see why, let’s consider another case. Sometimes, when stock arrives at the warehouse, we discover that items have been water damaged during transit. We can’t sell water-damaged sofas, so we have to throw them away and request more stock from our partners. We also need to update our stock model, and that might mean we need to reallocate a customer’s order.\n\nWhere does this logic go?\n\nWell, the Warehouse system knows that the stock has been damaged, so maybe it should own this process, as shown in Figure 11-4.\n\nFigure 11-4. Command flow 2",
      "content_length": 545,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 297,
      "content": "This sort of works too, but now our dependency graph is a mess. To\n\nallocate stock, the Orders service drives the Batches system, which drives Warehouse; but in order to handle problems at the warehouse, our Warehouse system drives Batches, which drives Orders.\n\nMultiply this by all the other workflows we need to provide, and you can see how services quickly get tangled up.\n\nError Handling in Distributed Systems\n\n“Things break” is a universal law of software engineering. What\n\nhappens in our system when one of our requests fails? Let’s say that a network error happens right after we take a user’s order for three MISBEGOTTEN-RUG, as shown in Figure 11-5.\n\nWe have two options here: we can place the order anyway and leave it unallocated, or we can refuse to take the order because the allocation\n\ncan’t be guaranteed. The failure state of our batches service has bubbled up and is affecting the reliability of our order service.\n\nWhen two things have to be changed together, we say that they are\n\ncoupled. We can think of this failure cascade as a kind of temporal coupling: every part of the system has to work at the same time for any\n\npart of it to work. As the system gets bigger, there is an exponentially increasing probability that some part is degraded.",
      "content_length": 1268,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 298,
      "content": "Figure 11-5. Command flow with error\n\nCONNASCENCE\n\nWe’re using the term coupling here, but there’s another way to describe the relationships between our systems. Connascence is a term used by some authors to describe the different types of coupling.\n\nConnascence isn’t bad, but some types of connascence are stronger than others. We want to have strong connascence locally, as when two classes are closely related, but weak connascence at a distance.\n\nIn our first example of a distributed ball of mud, we see Connascence of Execution: multiple components need to know the correct order of work for an operation to be successful.\n\nWhen thinking about error conditions here, we’re talking about Connascence of Timing: multiple things have to happen, one after another, for the operation to work.\n\nWhen we replace our RPC-style system with events, we replace both of these types of connascence with a weaker type. That’s Connascence of Name: multiple components need to agree only on the name of an event and the names of fields it carries.\n\nWe can never completely avoid coupling, except by having our software not talk to any other software. What we want is to avoid inappropriate coupling. Connascence provides a mental model for understanding the strength and type of coupling inherent in different architectural styles. Read all about it at connascence.io.",
      "content_length": 1359,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 299,
      "content": "The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\nHow do we get appropriate coupling? We’ve already seen part of the answer, which is that we should think in terms of verbs, not nouns. Our\n\ndomain model is about modeling a business process. It’s not a static data model about a thing; it’s a model of a verb.\n\nSo instead of thinking about a system for orders and a system for\n\nbatches, we think about a system for ordering and a system for allocating, and so on.\n\nWhen we separate things this way, it’s a little easier to see which\n\nsystem should be responsible for what. When thinking about ordering, really we want to make sure that when we place an order, the order is\n\nplaced. Everything else can happen later, so long as it happens.\n\nNOTE\n\nIf this sounds familiar, it should! Segregating responsibilities is the same process we went through when designing our aggregates and commands.\n\nLike aggregates, microservices should be consistency boundaries.\n\nBetween two services, we can accept eventual consistency, and that means we don’t need to rely on synchronous calls. Each service\n\naccepts commands from the outside world and raises events to record the result. Other services can listen to those events to trigger the next\n\nsteps in the workflow.",
      "content_length": 1270,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 300,
      "content": "To avoid the Distributed Ball of Mud anti-pattern, instead of\n\ntemporally coupled HTTP API calls, we want to use asynchronous messaging to integrate our systems. We want our BatchQuantityChanged messages to come in as external messages from upstream systems, and we want our system to publish Allocated events for downstream systems to listen to.\n\nWhy is this better? First, because things can fail independently, it’s\n\neasier to handle degraded behavior: we can still take orders if the allocation system is having a bad day.\n\nSecond, we’re reducing the strength of coupling between our systems.\n\nIf we need to change the order of operations or to introduce new steps in the process, we can do that locally.\n\nUsing a Redis Pub/Sub Channel for Integration\n\nLet’s see how it will all work concretely. We’ll need some way of getting events out of one system and into another, like our message bus,\n\nbut for services. This piece of infrastructure is often called a message broker. The role of a message broker is to take messages from\n\npublishers and deliver them to subscribers.\n\nAt MADE.com, we use Event Store; Kafka or RabbitMQ are valid alternatives. A lightweight solution based on Redis pub/sub channels\n\ncan also work just fine, and because Redis is much more generally\n\nfamiliar to people, we thought we’d use it for this book.",
      "content_length": 1333,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 301,
      "content": "NOTE\n\nWe’re glossing over the complexity involved in choosing the right messaging platform. Concerns like message ordering, failure handling, and idempotency all need to be thought through. For a few pointers, see “Footguns”.\n\nOur new flow will look like Figure 11-6: Redis provides the BatchQuantityChanged event that kicks off the whole process, and our Allocated event is published back out to Redis again at the end.",
      "content_length": 420,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 303,
      "content": "Figure 11-6. Sequence diagram for reallocation flow\n\nTest-Driving It All Using an End-to-End Test\n\nHere’s how we might start with an end-to-end test. We can use our\n\nexisting API to create batches, and then we’ll test both inbound and outbound messages:\n\nAn end-to-end test for our pub/sub model\n\n(tests/e2e/test_external_events.py)\n\ndef test_change_batch_quantity_leading_to_reallocation(): # start with two batches and an order allocated to one of them orderid, sku = random_orderid(), random_sku() earlier_batch, later_batch = random_batchref('old'), random_batchref('newer') api_client.post_to_add_batch(earlier_batch, sku, qty=10, eta='2011-01-02')\n\napi_client.post_to_add_batch(later_batch, sku, qty=10, eta='2011-01-02') response = api_client.post_to_allocate(orderid, sku, 10) assert response.json()['batchref'] == earlier_batch\n\nsubscription = redis_client.subscribe_to('line_allocated')\n\n# change quantity on allocated batch so it's less than our order redis_client.publish_message('change_batch_quantity', { 'batchref': earlier_batch, 'qty': 5 })\n\n# wait until we see a message saying the order has been reallocated messages = [] for attempt in Retrying(stop=stop_after_delay(3), reraise=True): with attempt: message = subscription.get_message(timeout=1) if message:",
      "content_length": 1277,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 304,
      "content": "messages.append(message) print(messages) data = json.loads(messages[-1]['data']) assert data['orderid'] == orderid assert data['batchref'] == later_batch\n\nYou can read the story of what’s going on in this test from the comments: we want to send an event into the system that causes an order line to be reallocated, and we see that reallocation come out as an event in Redis too.\n\napi_client is a little helper that we refactored out to share between our two test types; it wraps our calls to requests.post.\n\nredis_client is another little test helper, the details of which don’t really matter; its job is to be able to send and receive messages from various Redis channels. We’ll use a channel called change_batch_quantity to send in our request to change the quantity for a batch, and we’ll listen to another channel called line_allocated to look out for the expected reallocation.\n\nBecause of the asynchronous nature of the system under test, we need to use the tenacity library again to add a retry loop—first, because it may take some time for our new line_allocated message to arrive, but also because it won’t be the only message on that channel.\n\nRedis Is Another Thin Adapter Around Our Message Bus\n\nOur Redis pub/sub listener (we call it an event consumer) is very much like Flask: it translates from the outside world to our events:\n\nSimple Redis message listener (src/allocation/entrypoints/redis_eventconsumer.py)",
      "content_length": 1425,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 305,
      "content": "r = redis.Redis(**config.get_redis_host_and_port())\n\ndef main(): orm.start_mappers() pubsub = r.pubsub(ignore_subscribe_messages=True) pubsub.subscribe('change_batch_quantity')\n\nfor m in pubsub.listen(): handle_change_batch_quantity(m)\n\ndef handle_change_batch_quantity(m): logging.debug('handling %s', m) data = json.loads(m['data']) cmd = commands.ChangeBatchQuantity(ref=data['batchref'], qty=data['qty'])\n\nmessagebus.handle(cmd, uow=unit_of_work.SqlAlchemyUnitOfWork())\n\nmain() subscribes us to the change_batch_quantity channel on load.\n\nOur main job as an entrypoint to the system is to deserialize JSON, convert it to a Command, and pass it to the service layer—much as the Flask adapter does.\n\nWe also build a new downstream adapter to do the opposite job— converting domain events to public events:\n\nSimple Redis message publisher (src/allocation/adapters/redis_eventpublisher.py)\n\nr = redis.Redis(**config.get_redis_host_and_port())\n\ndef publish(channel, event: events.Event): logging.debug('publishing: channel=%s, event=%s', channel, event) r.publish(channel, json.dumps(asdict(event)))",
      "content_length": 1098,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 306,
      "content": "We take a hardcoded channel here, but you could also store a mapping between event classes/names and the appropriate channel, allowing one or more message types to go to different channels.\n\nOur New Outgoing Event\n\nHere’s what the Allocated event will look like:\n\nNew event (src/allocation/domain/events.py)\n\n@dataclass class Allocated(Event): orderid: str sku: str qty: int batchref: str\n\nIt captures everything we need to know about an allocation: the details of the order line, and which batch it was allocated to.\n\nWe add it into our model’s allocate() method (having added a test first, naturally):\n\nProduct.allocate() emits new event to record what happened (src/allocation/domain/model.py)\n\nclass Product: ... def allocate(self, line: OrderLine) -> str: ...\n\nbatch.allocate(line) self.version_number += 1 self.events.append(events.Allocated( orderid=line.orderid, sku=line.sku, qty=line.qty,",
      "content_length": 898,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 307,
      "content": "batchref=batch.reference, )) return batch.reference\n\nThe handler for ChangeBatchQuantity already exists, so all we need to add is a handler that publishes the outgoing event:\n\nThe message bus grows (src/allocation/service_layer/messagebus.py)\n\nHANDLERS = { events.Allocated: [handlers.publish_allocated_event], events.OutOfStock: [handlers.send_out_of_stock_notification], } # type: Dict[Type[events.Event], List[Callable]]\n\nPublishing the event uses our helper function from the Redis wrapper:\n\nPublish to Redis (src/allocation/service_layer/handlers.py)\n\ndef publish_allocated_event( event: events.Allocated, uow: unit_of_work.AbstractUnitOfWork, ): redis_eventpublisher.publish('line_allocated', event)\n\nInternal Versus External Events\n\nIt’s a good idea to keep the distinction between internal and external\n\nevents clear. Some events may come from the outside, and some events may get upgraded and published externally, but not all of them will. This is particularly important if you get into event sourcing (very much a topic for another book, though).",
      "content_length": 1057,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 308,
      "content": "TIP\n\nOutbound events are one of the places it’s important to apply validation. See Appendix E for some validation philosophy and examples.\n\nEXERCISE FOR THE READER\n\nA nice simple one for this chapter: make it so that the main allocate() use case can also be invoked by an event on a Redis channel, as well as (or instead of) via the API.\n\nYou will likely want to add a new E2E test and feed through some changes into redis_eventconsumer.py.\n\nWrap-Up\n\nEvents can come from the outside, but they can also be published externally—our publish handler converts an event to a message on a Redis channel. We use events to talk to the outside world. This kind of temporal decoupling buys us a lot of flexibility in our application integrations, but as always, it comes at a cost.\n\nEvent notification is nice because it implies a low level of coupling, and is pretty simple to set up. It can become problematic, however, if there really is a logical flow that runs over various event notifications...It can be hard to see such a flow as it’s not explicit in any program text....This can make it hard to debug and modify.\n\n—Martin Fowler, “What do you mean by ‘Event- Driven’”\n\nTable 11-1 shows some trade-offs to think about.",
      "content_length": 1216,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 309,
      "content": "Table 11-1. Event-based microservices integration: the trade-offs\n\nPros\n\nCons\n\nAvoids the distributed big ball of mud.\n\nThe overall flows of information are harder to see.\n\nServices are decoupled: it’s easier to change individual services and add new ones.\n\nEventual consistency is a new concept to deal with.\n\nMessage reliability and choices around at-least-once versus at- most-once delivery need thinking through.\n\nMore generally, if you’re moving from a model of synchronous messaging to an async one, you also open up a whole host of problems\n\nhaving to do with message reliability and eventual consistency. Read on to “Footguns”.",
      "content_length": 635,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 310,
      "content": "Chapter 12. Command-Query Responsibility Segregation (CQRS)\n\nIn this chapter, we’re going to start with a fairly uncontroversial insight: reads (queries) and writes (commands) are different, so they should be treated differently (or have their responsibilities segregated,\n\nif you will). Then we’re going to push that insight as far as we can.\n\nIf you’re anything like Harry, this will all seem extreme at first, but\n\nhopefully we can make the argument that it’s not totally unreasonable.\n\nFigure 12-1 shows where we might end up.\n\nTIP\n\nThe code for this chapter is in the chapter_12_cqrs branch on GitHub.\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_12_cqrs # or to code along, checkout the previous chapter: git checkout chapter_11_external_events\n\nFirst, though, why bother?",
      "content_length": 814,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 312,
      "content": "Figure 12-1. Separating reads from writes\n\nDomain Models Are for Writing\n\nWe’ve spent a lot of time in this book talking about how to build\n\nsoftware that enforces the rules of our domain. These rules, or constraints, will be different for every application, and they make up the interesting core of our systems.\n\nIn this book, we’ve set explicit constraints like “You can’t allocate more stock than is available,” as well as implicit constraints like “Each order line is allocated to a single batch.”\n\nWe wrote down these rules as unit tests at the beginning of the book:\n\nOur basic domain tests (tests/unit/test_batches.py)\n\ndef test_allocating_to_a_batch_reduces_the_available_quantity(): batch = Batch(\"batch-001\", \"SMALL-TABLE\", qty=20, eta=date.today()) line = OrderLine('order-ref', \"SMALL-TABLE\", 2)\n\nbatch.allocate(line)\n\nassert batch.available_quantity == 18\n\n...\n\ndef test_cannot_allocate_if_available_smaller_than_required(): small_batch, large_line = make_batch_and_line(\"ELEGANT-LAMP\", 2, 20) assert small_batch.can_allocate(large_line) is False\n\nTo apply these rules properly, we needed to ensure that operations were consistent, and so we introduced patterns like Unit of Work and Aggregate that help us commit small chunks of work.",
      "content_length": 1248,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 313,
      "content": "To communicate changes between those small chunks, we introduced the Domain Events pattern so we can write rules like “When stock is damaged or lost, adjust the available quantity on the batch, and reallocate orders if necessary.”\n\nAll of this complexity exists so we can enforce rules when we change the state of our system. We’ve built a flexible set of tools for writing data.\n\nWhat about reads, though?\n\nMost Users Aren’t Going to Buy Your Furniture\n\nAt MADE.com, we have a system very like the allocation service. In a busy day, we might process one hundred orders in an hour, and we have a big gnarly system for allocating stock to those orders.\n\nIn that same busy day, though, we might have one hundred product views per second. Each time somebody visits a product page, or a product listing page, we need to figure out whether the product is still in stock and how long it will take us to deliver it.\n\nThe domain is the same—we’re concerned with batches of stock, and their arrival date, and the amount that’s still available—but the access pattern is very different. For example, our customers won’t notice if the query is a few seconds out of date, but if our allocate service is inconsistent, we’ll make a mess of their orders. We can take advantage",
      "content_length": 1260,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 314,
      "content": "of this difference by making our reads eventually consistent in order to make them perform better.\n\nIS READ CONSISTENCY TRULY ATTAINABLE?\n\nThis idea of trading consistency against performance makes a lot of developers nervous at first, so let’s talk quickly about that.\n\nLet’s imagine that our “Get Available Stock” query is 30 seconds out of date when Bob visits the page for ASYMMETRICAL-DRESSER. Meanwhile, though, Harry has already bought the last item. When we try to allocate Bob’s order, we’ll get a failure, and we’ll need to either cancel his order or buy more stock and delay his delivery.\n\nPeople who’ve worked only with relational data stores get really nervous about this problem, but it’s worth considering two other scenarios to gain some perspective.\n\nFirst, let’s imagine that Bob and Harry both visit the page at the same time. Harry goes off to make coffee, and by the time he returns, Bob has already bought the last dresser. When Harry places his order, we send it to the allocation service, and because there’s not enough stock, we have to refund his payment or buy more stock and delay his delivery.\n\nAs soon as we render the product page, the data is already stale. This insight is key to understanding why reads can be safely inconsistent: we’ll always need to check the current state of our system when we come to allocate, because all distributed systems are inconsistent. As soon as you have a web server and two customers, you have the potential for stale data.\n\nOK, let’s assume we solve that problem somehow: we magically build a totally consistent web application where nobody ever sees stale data. This time Harry gets to the page first and buys his dresser.\n\nUnfortunately for him, when the warehouse staff tries to dispatch his furniture, it falls off the forklift and smashes into a zillion pieces. Now what?\n\nThe only options are to either call Harry and refund his order or buy more stock and delay delivery.\n\nNo matter what we do, we’re always going to find that our software systems are inconsistent with reality, and so we’ll always need business processes to cope with these edge cases. It’s OK to trade performance for consistency on the read side, because stale data is essentially unavoidable.\n\nWe can think of these requirements as forming two halves of a system: the read side and the write side, shown in Table 12-1.",
      "content_length": 2364,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 315,
      "content": "For the write side, our fancy domain architectural patterns help us to evolve our system over time, but the complexity we’ve built so far doesn’t buy anything for reading data. The service layer, the unit of work, and the clever domain model are just bloat.\n\nTable 12-1. Read versus write\n\nRead side\n\nWrite side\n\nBehavior\n\nSimple read\n\nComplex business logic\n\nCacheability\n\nHighly cacheable\n\nUncacheable\n\nConsistency\n\nCan be stale\n\nMust be transactionally consistent\n\nPost/Redirect/Get and CQS\n\nIf you do web development, you’re probably familiar with the Post/Redirect/Get pattern. In this technique, a web endpoint accepts an HTTP POST and responds with a redirect to see the result. For\n\nexample, we might accept a POST to /batches to create a new batch and redirect the user to /batches/123 to see their newly created batch.\n\nThis approach fixes the problems that arise when users refresh the results page in their browser or try to bookmark a results page. In the case of a refresh, it can lead to our users double-submitting data and thus buying two sofas when they needed only one. In the case of a bookmark, our hapless customers will end up with a broken page when they try to GET a POST endpoint.",
      "content_length": 1206,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 316,
      "content": "Both these problems happen because we’re returning data in response\n\nto a write operation. Post/Redirect/Get sidesteps the issue by separating the read and write phases of our operation.\n\nThis technique is a simple example of command-query separation (CQS). In CQS we follow one simple rule: functions should either modify state or answer questions, but never both. This makes software easier to reason about: we should always be able to ask, “Are the lights on?” without flicking the light switch.\n\nNOTE\n\nWhen building APIs, we can apply the same design technique by returning a 201 Created, or a 202 Accepted, with a Location header containing the URI of our new resources. What’s important here isn’t the status code we use but the logical separation of work into a write phase and a query phase.\n\nAs you’ll see, we can use the CQS principle to make our systems faster and more scalable, but first, let’s fix the CQS violation in our existing code. Ages ago, we introduced an allocate endpoint that takes an order and calls our service layer to allocate some stock. At\n\nthe end of the call, we return a 200 OK and the batch ID. That’s led to some ugly design flaws so that we can get the data we need. Let’s\n\nchange it to return a simple OK message and instead provide a new read-only endpoint to retrieve allocation state:\n\nAPI test does a GET after the POST (tests/e2e/test_api.py)\n\n@pytest.mark.usefixtures('postgres_db') @pytest.mark.usefixtures('restart_api')",
      "content_length": 1467,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 317,
      "content": "def test_happy_path_returns_202_and_batch_is_allocated(): orderid = random_orderid() sku, othersku = random_sku(), random_sku('other') earlybatch = random_batchref(1) laterbatch = random_batchref(2) otherbatch = random_batchref(3) api_client.post_to_add_batch(laterbatch, sku, 100, '2011-01-02') api_client.post_to_add_batch(earlybatch, sku, 100, '2011-01-01') api_client.post_to_add_batch(otherbatch, othersku, 100, None)\n\nr = api_client.post_to_allocate(orderid, sku, qty=3) assert r.status_code == 202\n\nr = api_client.get_allocation(orderid) assert r.ok assert r.json() == [ {'sku': sku, 'batchref': earlybatch}, ]\n\n@pytest.mark.usefixtures('postgres_db') @pytest.mark.usefixtures('restart_api') def test_unhappy_path_returns_400_and_error_message(): unknown_sku, orderid = random_sku(), random_orderid() r = api_client.post_to_allocate( orderid, unknown_sku, qty=20, expect_success=False, ) assert r.status_code == 400 assert r.json()['message'] == f'Invalid sku {unknown_sku}'\n\nr = api_client.get_allocation(orderid) assert r.status_code == 404\n\nOK, what might the Flask app look like?\n\nEndpoint for viewing allocations (src/allocation/entrypoints/flask_app.py)\n\nfrom allocation import views ...",
      "content_length": 1200,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 318,
      "content": "@app.route(\"/allocations/<orderid>\", methods=['GET']) def allocations_view_endpoint(orderid): uow = unit_of_work.SqlAlchemyUnitOfWork() result = views.allocations(orderid, uow) if not result: return 'not found', 404 return jsonify(result), 200\n\nAll right, a views.py, fair enough; we can keep read-only stuff in there, and it’ll be a real views.py, not like Django’s, something that knows how to build read-only views of our data…\n\nHold On to Your Lunch, Folks\n\nHmm, so we can probably just add a list method to our existing repository object:\n\nViews do…raw SQL? (src/allocation/views.py)\n\nfrom allocation.service_layer import unit_of_work\n\ndef allocations(orderid: str, uow: unit_of_work.SqlAlchemyUnitOfWork): with uow: results = list(uow.session.execute( 'SELECT ol.sku, b.reference' ' FROM allocations AS a' ' JOIN batches AS b ON a.batch_id = b.id' ' JOIN order_lines AS ol ON a.orderline_id = ol.id' ' WHERE ol.orderid = :orderid', dict(orderid=orderid) )) return [{'sku': sku, 'batchref': batchref} for sku, batchref in results]\n\nExcuse me? Raw SQL?",
      "content_length": 1056,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 319,
      "content": "If you’re anything like Harry encountering this pattern for the first time,\n\nyou’ll be wondering what on earth Bob has been smoking. We’re hand- rolling our own SQL now, and converting database rows directly to\n\ndicts? After all the effort we put into building a nice domain model? And what about the Repository pattern? Isn’t that meant to be our\n\nabstraction around the database? Why don’t we reuse that?\n\nWell, let’s explore that seemingly simpler alternative first, and see what it looks like in practice.\n\nWe’ll still keep our view in a separate views.py module; enforcing a\n\nclear distinction between reads and writes in your application is still a good idea. We apply command-query separation, and it’s easy to see\n\nwhich code modifies state (the event handlers) and which code just retrieves read-only state (the views).\n\nTIP\n\nSplitting out your read-only views from your state-modifying command and event handlers is probably a good idea, even if you don’t want to go to full-blown CQRS.\n\nTesting CQRS Views\n\nBefore we get into exploring various options, let’s talk about testing. Whichever approaches you decide to go for, you’re probably going to\n\nneed at least one integration test. Something like this:\n\nAn integration test for a view (tests/integration/test_views.py)",
      "content_length": 1281,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 320,
      "content": "def test_allocations_view(sqlite_session_factory): uow = unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory) messagebus.handle(commands.CreateBatch('sku1batch', 'sku1', 50, None), uow)\n\nmessagebus.handle(commands.CreateBatch('sku2batch', 'sku2', 50, today), uow) messagebus.handle(commands.Allocate('order1', 'sku1', 20), uow) messagebus.handle(commands.Allocate('order1', 'sku2', 20), uow) # add a spurious batch and order to make sure we're getting the right ones messagebus.handle(commands.CreateBatch('sku1batch-later', 'sku1', 50, today), uow) messagebus.handle(commands.Allocate('otherorder', 'sku1', 30), uow) messagebus.handle(commands.Allocate('otherorder', 'sku2', 10), uow)\n\nassert views.allocations('order1', uow) == [ {'sku': 'sku1', 'batchref': 'sku1batch'}, {'sku': 'sku2', 'batchref': 'sku2batch'}, ]\n\nWe do the setup for the integration test by using the public entrypoint to our application, the message bus. That keeps our tests decoupled from any implementation/infrastructure details about how things get stored.\n\n“Obvious” Alternative 1: Using the Existing Repository\n\nHow about adding a helper method to our products repository?\n\nA simple view that uses the repository (src/allocation/views.py)\n\nfrom allocation import unit_of_work\n\ndef allocations(orderid: str, uow: unit_of_work.AbstractUnitOfWork): with uow: products = uow.products.for_order(orderid=orderid) batches = [b for p in products for b in p.batches]",
      "content_length": 1442,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 321,
      "content": "return [ {'sku': b.sku, 'batchref': b.reference} for b in batches if orderid in b.orderids ]\n\nOur repository returns Product objects, and we need to find all the products for the SKUs in a given order, so we’ll build a new helper method called .for_order() on the repository.\n\nNow we have products but we actually want batch references, so we get all the possible batches with a list comprehension.\n\nWe filter again to get just the batches for our specific order. That, in turn, relies on our Batch objects being able to tell us which order IDs it has allocated.\n\nWe implement that last using a .orderid property:\n\nAn arguably unnecessary property on our model\n\n(src/allocation/domain/model.py)\n\nclass Batch: ...\n\n@property def orderids(self): return {l.orderid for l in self._allocations}\n\nYou can start to see that reusing our existing repository and domain\n\nmodel classes is not as straightforward as you might have assumed. We’ve had to add new helper methods to both, and we’re doing a\n\nbunch of looping and filtering in Python, which is work that would be done much more efficiently by the database.",
      "content_length": 1105,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 322,
      "content": "So yes, on the plus side we’re reusing our existing abstractions, but on\n\nthe downside, it all feels quite clunky.\n\nYour Domain Model Is Not Optimized for Read Operations\n\nWhat we’re seeing here are the effects of having a domain model that\n\nis designed primarily for write operations, while our requirements for reads are often conceptually quite different.\n\nThis is the chin-stroking-architect’s justification for CQRS. As we’ve\n\nsaid before, a domain model is not a data model—we’re trying to capture the way the business works: workflow, rules around state\n\nchanges, messages exchanged; concerns about how the system reacts to external events and user input. Most of this stuff is totally irrelevant\n\nfor read-only operations.\n\nTIP\n\nThis justification for CQRS is related to the justification for the Domain Model pattern. If you’re building a simple CRUD app, reads and writes are going to be closely related, so you don’t need a domain model or CQRS. But the more complex your domain, the more likely you are to need both.\n\nTo make a facile point, your domain classes will have multiple methods for modifying state, and you won’t need any of them for read-\n\nonly operations.",
      "content_length": 1180,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 323,
      "content": "As the complexity of your domain model grows, you will find yourself\n\nmaking more and more choices about how to structure that model, which make it more and more awkward to use for read operations.\n\n“Obvious” Alternative 2: Using the ORM\n\nYou may be thinking, OK, if our repository is clunky, and working with Products is clunky, then I can at least use my ORM and work with Batches. That’s what it’s for!\n\nA simple view that uses the ORM (src/allocation/views.py)\n\nfrom allocation import unit_of_work, model\n\ndef allocations(orderid: str, uow: unit_of_work.AbstractUnitOfWork): with uow: batches = uow.session.query(model.Batch).join( model.OrderLine, model.Batch._allocations ).filter( model.OrderLine.orderid == orderid ) return [ {'sku': b.sku, 'batchref': b.batchref} for b in batches ]\n\nBut is that actually any easier to write or understand than the raw SQL version from the code example in “Hold On to Your Lunch, Folks”? It may not look too bad up there, but we can tell you it took several attempts, and plenty of digging through the SQLAlchemy docs. SQL is\n\njust SQL.\n\nBut the ORM can also expose us to performance problems.",
      "content_length": 1135,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 324,
      "content": "SELECT N+1 and Other Performance Considerations\n\nThe so-called SELECT N+1 problem is a common performance problem with ORMs: when retrieving a list of objects, your ORM will\n\noften perform an initial query to, say, get all the IDs of the objects it needs, and then issue individual queries for each object to retrieve their attributes. This is especially likely if there are any foreign-key relationships on your objects.\n\nNOTE\n\nIn all fairness, we should say that SQLAlchemy is quite good at avoiding the SELECT N+1 problem. It doesn’t display it in the preceding example, and you can request eager loading explicitly to avoid it when dealing with joined objects.\n\nBeyond SELECT N+1, you may have other reasons for wanting to decouple the way you persist state changes from the way that you retrieve current state. A set of fully normalized relational tables is a\n\ngood way to make sure that write operations never cause data corruption. But retrieving data using lots of joins can be slow. It’s common in such cases to add some denormalized views, build read replicas, or even add caching layers.\n\nTime to Completely Jump the Shark\n\nOn that note: have we convinced you that our raw SQL version isn’t so weird as it first seemed? Perhaps we were exaggerating for effect? Just you wait.",
      "content_length": 1286,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 325,
      "content": "So, reasonable or not, that hardcoded SQL query is pretty ugly, right? What if we made it nicer…\n\nA much nicer query (src/allocation/views.py)\n\ndef allocations(orderid: str, uow: unit_of_work.SqlAlchemyUnitOfWork): with uow: results = list(uow.session.execute( 'SELECT sku, batchref FROM allocations_view WHERE orderid = :orderid', dict(orderid=orderid) )) ...\n\n…by keeping a totally separate, denormalized data store for our view model?\n\nHee hee hee, no foreign keys, just strings, YOLO (src/allocation/adapters/orm.py)\n\nallocations_view = Table( 'allocations_view', metadata, Column('orderid', String(255)), Column('sku', String(255)), Column('batchref', String(255)), )\n\nOK, nicer-looking SQL queries wouldn’t be a justification for anything\n\nreally, but building a denormalized copy of your data that’s optimized for read operations isn’t uncommon, once you’ve reached the limits of what you can do with indexes.\n\nEven with well-tuned indexes, a relational database uses a lot of CPU to perform joins. The fastest queries will always be SELECT * from",
      "content_length": 1054,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 326,
      "content": "mytable WHERE key = :value.\n\nMore than raw speed, though, this approach buys us scale. When we’re\n\nwriting data to a relational database, we need to make sure that we get a lock over the rows we’re changing so we don’t run into consistency problems.\n\nIf multiple clients are changing data at the same time, we’ll have weird race conditions. When we’re reading data, though, there’s no limit to the number of clients that can concurrently execute. For this reason, read-only stores can be horizontally scaled out.\n\nTIP\n\nBecause read replicas can be inconsistent, there’s no limit to how many we can have. If you’re struggling to scale a system with a complex data store, ask whether you could build a simpler read model.\n\nKeeping the read model up to date is the challenge! Database views (materialized or otherwise) and triggers are a common solution, but that limits you to your database. We’d like to show you how to reuse\n\nour event-driven architecture instead.\n\nUpdating a Read Model Table Using an Event Handler\n\nWe add a second handler to the Allocated event:",
      "content_length": 1065,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 327,
      "content": "Allocated event gets a new handler\n\n(src/allocation/service_layer/messagebus.py)\n\nEVENT_HANDLERS = { events.Allocated: [ handlers.publish_allocated_event, handlers.add_allocation_to_read_model ],\n\nHere’s what our update-view-model code looks like:\n\nUpdate on allocation (src/allocation/service_layer/handlers.py)\n\ndef add_allocation_to_read_model( event: events.Allocated, uow: unit_of_work.SqlAlchemyUnitOfWork, ): with uow: uow.session.execute( 'INSERT INTO allocations_view (orderid, sku, batchref)' ' VALUES (:orderid, :sku, :batchref)', dict(orderid=event.orderid, sku=event.sku, batchref=event.batchref) ) uow.commit()\n\nBelieve it or not, that will pretty much work! And it will work against the exact same integration tests as the rest of our options.\n\nOK, you’ll also need to handle Deallocated:\n\nA second listener for read model updates\n\nevents.Deallocated: [ handlers.remove_allocation_from_read_model, handlers.reallocate ],\n\n...",
      "content_length": 940,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 328,
      "content": "def remove_allocation_from_read_model( event: events.Deallocated, uow: unit_of_work.SqlAlchemyUnitOfWork, ): with uow: uow.session.execute( 'DELETE FROM allocations_view ' ' WHERE orderid = :orderid AND sku = :sku',\n\nFigure 12-2 shows the flow across the two requests.",
      "content_length": 268,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 330,
      "content": "Figure 12-2. Sequence diagram for read model\n\nIn Figure 12-2, you can see two transactions in the POST/write\n\noperation, one to update the write model and one to update the read model, which the GET/read operation can use.\n\nREBUILDING FROM SCRATCH\n\n“What happens when it breaks?” should be the first question we ask as engineers.\n\nHow do we deal with a view model that hasn’t been updated because of a bug or temporary outage? Well, this is just another case where events and commands can fail independently.\n\nIf we never updated the view model, and the ASYMMETRICAL-DRESSER was forever in stock, that would be annoying for customers, but the allocate service would still fail, and we’d take action to fix the problem.\n\nRebuilding a view model is easy, though. Since we’re using a service layer to update our view model, we can write a tool that does the following:\n\nQueries the current state of the write side to work out what’s currently allocated\n\nCalls the add_allocate_to_read_model handler for each allocated item\n\nWe can use this technique to create entirely new read models from historical data.\n\nChanging Our Read Model Implementation Is Easy\n\nLet’s see the flexibility that our event-driven model buys us in action, by seeing what happens if we ever decide we want to implement a\n\nread model by using a totally separate storage engine, Redis.\n\nJust watch:\n\nHandlers update a Redis read model (src/allocation/service_layer/handlers.py)",
      "content_length": 1444,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 331,
      "content": "def add_allocation_to_read_model(event: events.Allocated, _): redis_eventpublisher.update_readmodel(event.orderid, event.sku, event.batchref)\n\ndef remove_allocation_from_read_model(event: events.Deallocated, _): redis_eventpublisher.update_readmodel(event.orderid, event.sku, None)\n\nThe helpers in our Redis module are one-liners:\n\nRedis read model read and update (src/allocation/adapters/redis_eventpublisher.py)\n\ndef update_readmodel(orderid, sku, batchref): r.hset(orderid, sku, batchref)\n\ndef get_readmodel(orderid): return r.hgetall(orderid)\n\n(Maybe the name redis_eventpublisher.py is a misnomer now, but you get the idea.)\n\nAnd the view itself changes very slightly to adapt to its new backend:\n\nView adapted to Redis (src/allocation/views.py)\n\ndef allocations(orderid): batches = redis_eventpublisher.get_readmodel(orderid) return [ {'batchref': b.decode(), 'sku': s.decode()} for s, b in batches.items() ]\n\nAnd the exact same integration tests that we had before still pass,\n\nbecause they are written at a level of abstraction that’s decoupled from",
      "content_length": 1058,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 332,
      "content": "the implementation: setup puts messages on the message bus, and the\n\nassertions are against our view.\n\nTIP\n\nEvent handlers are a great way to manage updates to a read model, if you decide you need one. They also make it easy to change the implementation of that read model at a later date.\n\nEXERCISE FOR THE READER\n\nImplement another view, this time to show the allocation for a single order line.\n\nHere the trade-offs between using hardcoded SQL versus going via a repository should be much more blurry. Try a few versions (maybe including going to Redis), and see which you prefer.\n\nWrap-Up\n\nTable 12-2 proposes some pros and cons for each of our options.\n\nAs it happens, the allocation service at MADE.com does use “full- blown” CQRS, with a read model stored in Redis, and even a second\n\nlayer of cache provided by Varnish. But its use cases are quite a bit different from what we’ve shown here. For the kind of allocation service we’re building, it seems unlikely that you’d need to use a separate read model and event handlers for updating it.\n\nBut as your domain model becomes richer and more complex, a simplified read model become ever more compelling.",
      "content_length": 1161,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 333,
      "content": "Table 12-2. Trade-offs of various view model options\n\nOption\n\nPros\n\nCons\n\nJust use repositories\n\nSimple, consistent approach.\n\nExpect performance issues with complex query patterns.\n\nUse custom queries with your ORM\n\nAllows reuse of DB configuration and model definitions.\n\nAdds another query language with its own quirks and syntax.\n\nUse hand- rolled SQL\n\nOffers fine control over performance with a standard query syntax.\n\nChanges to DB schema have to be made to your hand-rolled queries and your ORM definitions. Highly normalized schemas may still have performance limitations.\n\nCreate separate read stores with events\n\nRead-only copies are easy to scale out. Views can be constructed when data changes so that queries are as simple as possible.\n\nComplex technique. Harry will be forever suspicious of your tastes and motives.\n\nOften, your read operations will be acting on the same conceptual objects as your write model, so using the ORM, adding some read methods to your repositories, and using domain model classes for your read operations is just fine.\n\nIn our book example, the read operations act on quite different conceptual entities to our domain model. The allocation service thinks in terms of Batches for a single SKU, but users care about allocations for a whole order, with multiple SKUs, so using the ORM ends up being a little awkward. We’d be quite tempted to go with the raw-SQL\n\nview we showed right at the beginning of the chapter.",
      "content_length": 1456,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 334,
      "content": "On that note, let’s sally forth into our final chapter.",
      "content_length": 55,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 335,
      "content": "Chapter 13. Dependency Injection (and Bootstrapping)\n\nDependency injection (DI) is regarded with suspicion in the Python world. And we’ve managed just fine without it so far in the example code for this book!\n\nIn this chapter, we’ll explore some of the pain points in our code that\n\nlead us to consider using DI, and we’ll present some options for how to do it, leaving it to you to pick which you think is most Pythonic.\n\nWe’ll also add a new component to our architecture called bootstrap.py; it will be in charge of dependency injection, as well as some other initialization stuff that we often need. We’ll explain why\n\nthis sort of thing is called a composition root in OO languages, and why bootstrap script is just fine for our purposes.\n\nFigure 13-1 shows what our app looks like without a bootstrapper: the entrypoints do a lot of initialization and passing around of our main\n\ndependency, the UoW.\n\nTIP\n\nIf you haven’t already, it’s worth reading Chapter 3 before continuing with this chapter, particularly the discussion of functional versus object-oriented dependency management.",
      "content_length": 1090,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 337,
      "content": "Figure 13-1. Without bootstrap: entrypoints do a lot\n\nTIP\n\nThe code for this chapter is in the chapter_13_dependency_injection branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout chapter_13_dependency_injection # or to code along, checkout the previous chapter: git checkout chapter_12_cqrs\n\nFigure 13-2 shows our bootstrapper taking over those responsibilities.",
      "content_length": 401,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 339,
      "content": "Figure 13-2. Bootstrap takes care of all that in one place\n\nImplicit Versus Explicit Dependencies\n\nDepending on your particular brain type, you may have a slight feeling\n\nof unease at the back of your mind at this point. Let’s bring it out into the open. We’ve shown you two ways of managing dependencies and testing them.\n\nFor our database dependency, we’ve built a careful framework of explicit dependencies and easy options for overriding them in tests. Our main handler functions declare an explicit dependency on the UoW:\n\nOur handlers have an explicit dependency on the UoW (src/allocation/service_layer/handlers.py)\n\ndef allocate( cmd: commands.Allocate, uow: unit_of_work.AbstractUnitOfWork ):\n\nAnd that makes it easy to swap in a fake UoW in our service-layer tests:\n\nService-layer tests against a fake UoW: (tests/unit/test_services.py)\n\nuow = FakeUnitOfWork() messagebus.handle([...], uow)\n\nThe UoW itself declares an explicit dependency on the session factory:",
      "content_length": 972,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 340,
      "content": "The UoW depends on a session factory (src/allocation/service_layer/unit_of_work.py)\n\nclass SqlAlchemyUnitOfWork(AbstractUnitOfWork):\n\ndef __init__(self, session_factory=DEFAULT_SESSION_FACTORY): self.session_factory = session_factory ...\n\nWe take advantage of it in our integration tests to be able to sometimes use SQLite instead of Postgres:\n\nIntegration tests against a different DB (tests/integration/test_uow.py)\n\ndef test_rolls_back_uncommitted_work_by_default(sqlite_session_factory): uow = unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory)\n\nIntegration tests swap out the default Postgres session_factory for a SQLite one.\n\nAren’t Explicit Dependencies Totally Weird and Java-y?\n\nIf you’re used to the way things normally happen in Python, you’ll be thinking all this is a bit weird. The standard way to do things is to declare our dependency implicitly by simply importing it, and then if we ever need to change it for tests, we can monkeypatch, as is Right and True in dynamic languages:\n\nEmail sending as a normal import-based dependency (src/allocation/service_layer/handlers.py)",
      "content_length": 1099,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 341,
      "content": "from allocation.adapters import email, redis_eventpublisher ...\n\ndef send_out_of_stock_notification( event: events.OutOfStock, uow: unit_of_work.AbstractUnitOfWork, ): email.send( 'stock@made.com', f'Out of stock for {event.sku}', )\n\nHardcoded import\n\nCalls specific email sender directly\n\nWhy pollute our application code with unnecessary arguments just for the sake of our tests? mock.patch makes monkeypatching nice and easy:\n\nmock dot patch, thank you Michael Foord (tests/unit/test_handlers.py)\n\nwith mock.patch(\"allocation.adapters.email.send\") as mock_send_mail: ...\n\nThe trouble is that we’ve made it look easy because our toy example doesn’t send real email (email.send_mail just does a print), but in real life, you’d end up having to call mock.patch for every single test that might cause an out-of-stock notification. If you’ve worked on\n\ncodebases with lots of mocks used to prevent unwanted side effects,\n\nyou’ll know how annoying that mocky boilerplate gets.\n\nAnd you’ll know that mocks tightly couple us to the implementation. By choosing to monkeypatch email.send_mail, we are tied to doing",
      "content_length": 1107,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 342,
      "content": "import email, and if we ever want to do from email import send_mail, a trivial refactor, we’d have to change all our mocks.\n\nSo it’s a trade-off. Yes, declaring explicit dependencies is\n\nunnecessary, strictly speaking, and using them would make our application code marginally more complex. But in return, we’d get\n\ntests that are easier to write and manage.\n\nOn top of that, declaring an explicit dependency is an example of the dependency inversion principle—rather than having an (implicit)\n\ndependency on a specific detail, we have an (explicit) dependency on an abstraction:\n\nExplicit is better than implicit.\n\n—The Zen of Python\n\nThe explicit dependency is more abstract\n\n(src/allocation/service_layer/handlers.py)\n\ndef send_out_of_stock_notification( event: events.OutOfStock, send_mail: Callable, ): send_mail( 'stock@made.com', f'Out of stock for {event.sku}', )\n\nBut if we do change to declaring all these dependencies explicitly, who will inject them, and how? So far, we’ve really been dealing with only passing the UoW around: our tests use FakeUnitOfWork, while Flask and Redis eventconsumer entrypoints use the real UoW, and the",
      "content_length": 1143,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 343,
      "content": "message bus passes them onto our command handlers. If we add real and fake email classes, who will create them and pass them on?\n\nThat’s extra (duplicated) cruft for Flask, Redis, and our tests.\n\nMoreover, putting all the responsibility for passing dependencies to the right handler onto the message bus feels like a violation of the SRP.\n\nInstead, we’ll reach for a pattern called Composition Root (a\n\n1\n\nbootstrap script to you and me), and we’ll do a bit of “manual DI” (dependency injection without a framework). See Figure 13-3.\n\n2",
      "content_length": 536,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 345,
      "content": "Figure 13-3. Bootstrapper between entrypoints and message bus\n\nPreparing Handlers: Manual DI with Closures and Partials\n\nOne way to turn a function with dependencies into one that’s ready to\n\nbe called later with those dependencies already injected is to use closures or partial functions to compose the function with its\n\ndependencies:\n\nExamples of DI using closures or partial functions\n\n# existing allocate function, with abstract uow dependency def allocate( cmd: commands.Allocate, uow: unit_of_work.AbstractUnitOfWork ): line = OrderLine(cmd.orderid, cmd.sku, cmd.qty) with uow: ...\n\n# bootstrap script prepares actual UoW\n\ndef bootstrap(..): uow = unit_of_work.SqlAlchemyUnitOfWork()\n\n# prepare a version of the allocate fn with UoW dependency captured in a closure allocate_composed = lambda cmd: allocate(cmd, uow)\n\n# or, equivalently (this gets you a nicer stack trace) def allocate_composed(cmd): return allocate(cmd, uow)\n\n# alternatively with a partial import functools allocate_composed = functools.partial(allocate, uow=uow)\n\n# later at runtime, we can call the partial function, and it will have",
      "content_length": 1111,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 346,
      "content": "# the UoW already bound allocate_composed(cmd)\n\nThe difference between closures (lambdas or named functions) and functools.partial is that the former use late binding of variables, which can be a source of confusion if any of the dependencies are mutable.\n\nHere’s the same pattern again for the send_out_of_stock_notification() handler, which has different dependencies:\n\nAnother closure and partial functions example\n\ndef send_out_of_stock_notification( event: events.OutOfStock, send_mail: Callable, ): send_mail( 'stock@made.com', ...\n\n# prepare a version of the send_out_of_stock_notification with dependencies sosn_composed = lambda event: send_out_of_stock_notification(event, email.send_mail)\n\n... # later, at runtime: sosn_composed(event) # will have email.send_mail already injected in\n\nAn Alternative Using Classes\n\nClosures and partial functions will feel familiar to people who’ve done a bit of functional programming. Here’s an alternative using\n\nclasses, which may appeal to others. It requires rewriting all our handler functions as classes, though:",
      "content_length": 1064,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 347,
      "content": "DI using classes\n\n# we replace the old `def allocate(cmd, uow)` with:\n\nclass AllocateHandler:\n\ndef __init__(self, uow: unit_of_work.AbstractUnitOfWork): self.uow = uow\n\ndef __call__(self, cmd: commands.Allocate): line = OrderLine(cmd.orderid, cmd.sku, cmd.qty) with self.uow: # rest of handler method as before ...\n\n# bootstrap script prepares actual UoW uow = unit_of_work.SqlAlchemyUnitOfWork()\n\n# then prepares a version of the allocate fn with dependencies already injected allocate = AllocateHandler(uow)\n\n... # later at runtime, we can call the handler instance, and it will have # the UoW already injected allocate(cmd)\n\nThe class is designed to produce a callable function, so it has a call method.\n\nBut we use the init to declare the dependencies it requires. This sort of thing will feel familiar if you’ve ever made class-based descriptors, or a class-based context manager that takes arguments.\n\nUse whichever you and your team feel more comfortable with.\n\nA Bootstrap Script\n\nWe want our bootstrap script to do the following:",
      "content_length": 1038,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 348,
      "content": "1. Declare default dependencies but allow us to override them\n\n2. Do the “init” stuff that we need to get our app started\n\n3. Inject all the dependencies into our handlers\n\n4. Give us back the core object for our app, the message bus\n\nHere’s a first cut:\n\nA bootstrap function (src/allocation/bootstrap.py)\n\ndef bootstrap( start_orm: bool = True, uow: unit_of_work.AbstractUnitOfWork = unit_of_work.SqlAlchemyUnitOfWork(),\n\nsend_mail: Callable = email.send, publish: Callable = redis_eventpublisher.publish, ) -> messagebus.MessageBus:\n\nif start_orm: orm.start_mappers()\n\ndependencies = {'uow': uow, 'send_mail': send_mail, 'publish': publish} injected_event_handlers = { event_type: [ inject_dependencies(handler, dependencies) for handler in event_handlers ] for event_type, event_handlers in handlers.EVENT_HANDLERS.items() } injected_command_handlers = { command_type: inject_dependencies(handler, dependencies) for command_type, handler in handlers.COMMAND_HANDLERS.items() }\n\nreturn messagebus.MessageBus( uow=uow, event_handlers=injected_event_handlers,",
      "content_length": 1060,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 349,
      "content": "command_handlers=injected_command_handlers, )\n\norm.start_mappers() is our example of initialization work that needs to be done once at the beginning of an app. We also see things like setting up the logging module.\n\nWe can use the argument defaults to define what the normal/production defaults are. It’s nice to have them in a single place, but sometimes dependencies have some side effects at construction time, in which case you might prefer to default them to None instead.\n\nWe build up our injected versions of the handler mappings by using a function called inject_dependencies(), which we’ll show next.\n\nWe return a configured message bus ready for use.\n\nHere’s how we inject dependencies into a handler function by inspecting it:\n\nDI by inspecting function signatures (src/allocation/bootstrap.py)\n\ndef inject_dependencies(handler, dependencies): params = inspect.signature(handler).parameters deps = { name: dependency for name, dependency in dependencies.items() if name in params } return lambda message: handler(message, **deps)\n\nWe inspect our command/event handler’s arguments.\n\nWe match them by name to our dependencies.",
      "content_length": 1135,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 350,
      "content": "We inject them as kwargs to produce a partial.",
      "content_length": 46,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 351,
      "content": "EVEN-MORE-MANUAL DI WITH LESS MAGIC\n\nIf you’re finding the preceding inspect code a little harder to grok, this even simpler version may appeal to you.\n\nHarry wrote the code for inject_dependencies() as a first cut of how to do “manual” dependency injection, and when he saw it, Bob accused him of overengineering and writing his own DI framework.\n\nIt honestly didn’t even occur to Harry that you could do it any more plainly, but you can, like this:\n\nManually creating partial functions inline (src/allocation/bootstrap.py)\n\ninjected_event_handlers = { events.Allocated: [ lambda e: handlers.publish_allocated_event(e, publish), lambda e: handlers.add_allocation_to_read_model(e, uow), ], events.Deallocated: [ lambda e: handlers.remove_allocation_from_read_model(e, uow), lambda e: handlers.reallocate(e, uow), ], events.OutOfStock: [ lambda e: handlers.send_out_of_stock_notification(e, send_mail) ] } injected_command_handlers = { commands.Allocate: lambda c: handlers.allocate(c, uow), commands.CreateBatch: \\ lambda c: handlers.add_batch(c, uow), commands.ChangeBatchQuantity: \\ lambda c: handlers.change_batch_quantity(c, uow), }\n\nHarry says he couldn’t even imagine writing out that many lines of code and having to look up that many function arguments manually. This is a perfectly viable solution, though, since it’s only one line of code or so per handler you add, and thus not a massive maintenance burden even if you have dozens of handlers.\n\nOur app is structured in such a way that we always want to do dependency injection in only one place, the handler functions, so this super-manual solution and Harry’s inspect()-based one will both work fine.\n\nIf you find yourself wanting to do DI in more things and at different times, or if you ever get into dependency chains (in which your dependencies have their own dependencies, and so on), you may get some mileage out of a “real” DI framework.\n\nAt MADE, we’ve used Inject in a few places, and it’s fine, although it makes Pylint unhappy. You might also check out Punq, as written by Bob himself, or the DRY-Python crew’s dependencies.",
      "content_length": 2098,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 352,
      "content": "Message Bus Is Given Handlers at Runtime\n\nOur message bus will no longer be static; it needs to have the already-\n\ninjected handlers given to it. So we turn it from being a module into a configurable class:\n\nMessageBus as a class (src/allocation/service_layer/messagebus.py)\n\nclass MessageBus:\n\ndef __init__( self, uow: unit_of_work.AbstractUnitOfWork, event_handlers: Dict[Type[events.Event], List[Callable]], command_handlers: Dict[Type[commands.Command], Callable], ): self.uow = uow self.event_handlers = event_handlers self.command_handlers = command_handlers\n\ndef handle(self, message: Message): self.queue = [message] while self.queue: message = self.queue.pop(0) if isinstance(message, events.Event): self.handle_event(message) elif isinstance(message, commands.Command): self.handle_command(message) else: raise Exception(f'{message} was not an Event or Command')\n\nThe message bus becomes a class…\n\n…which is given its already-dependency-injected handlers.",
      "content_length": 965,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 353,
      "content": "The main handle() function is substantially the same, with just a few attributes and methods moved onto self.\n\nUsing self.queue like this is not thread-safe, which might be a problem if you’re using threads, because the bus instance is global in the Flask app context as we’ve written it. Just something to watch out for.\n\nWhat else changes in the bus?\n\nEvent and command handler logic stays the same (src/allocation/service_layer/messagebus.py)\n\ndef handle_event(self, event: events.Event): for handler in self.event_handlers[type(event)]: try: logger.debug('handling event %s with handler %s', event, handler) handler(event) self.queue.extend(self.uow.collect_new_events()) except Exception: logger.exception('Exception handling event %s', event) continue\n\ndef handle_command(self, command: commands.Command): logger.debug('handling command %s', command) try: handler = self.command_handlers[type(command)] handler(command) self.queue.extend(self.uow.collect_new_events()) except Exception: logger.exception('Exception handling command %s', command) raise\n\nhandle_event and handle_command are substantially the same, but instead of indexing into a static EVENT_HANDLERS or",
      "content_length": 1174,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 354,
      "content": "COMMAND_HANDLERS dict, they use the versions on self.\n\nInstead of passing a UoW into the handler, we expect the handlers to already have all their dependencies, so all they need is a single argument, the specific event or command.\n\nUsing Bootstrap in Our Entrypoints\n\nIn our application’s entrypoints, we now just call bootstrap.bootstrap() and get a message bus that’s ready to go, rather than configuring a UoW and the rest of it:\n\nFlask calls bootstrap (src/allocation/entrypoints/flask_app.py)\n\nfrom allocation import views +from allocation import bootstrap, views\n\napp = Flask(__name__) -orm.start_mappers() +bus = bootstrap.bootstrap()\n\n@app.route(\"/add_batch\", methods=['POST']) @@ -19,8 +16,7 @@ def add_batch(): cmd = commands.CreateBatch( request.json['ref'], request.json['sku'], request.json['qty'], eta, ) - uow = unit_of_work.SqlAlchemyUnitOfWork() - messagebus.handle(cmd, uow) + bus.handle(cmd) return 'OK', 201\n\nWe no longer need to call start_orm(); the bootstrap script’s initialization stages will do that.\n\nWe no longer need to explicitly build a particular type of UoW; the bootstrap script defaults take care of it.",
      "content_length": 1138,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 355,
      "content": "And our message bus is now a specific instance rather than the global module.\n\n3\n\nInitializing DI in Our Tests\n\nIn tests, we can use bootstrap.bootstrap() with overridden defaults to get a custom message bus. Here’s an example in an integration test:\n\nOverriding bootstrap defaults (tests/integration/test_views.py)\n\n@pytest.fixture def sqlite_bus(sqlite_session_factory): bus = bootstrap.bootstrap( start_orm=True, uow=unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory), send_mail=lambda *args: None, publish=lambda *args: None, ) yield bus clear_mappers()\n\ndef test_allocations_view(sqlite_bus): sqlite_bus.handle(commands.CreateBatch('sku1batch', 'sku1', 50, None)) sqlite_bus.handle(commands.CreateBatch('sku2batch', 'sku2', 50, date.today())) ... assert views.allocations('order1', sqlite_bus.uow) == [ {'sku': 'sku1', 'batchref': 'sku1batch'}, {'sku': 'sku2', 'batchref': 'sku2batch'}, ]\n\nWe do still want to start the ORM…\n\n…because we’re going to use a real UoW, albeit with an in- memory database.",
      "content_length": 1013,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 356,
      "content": "But we don’t need to send email or publish, so we make those noops.\n\nIn our unit tests, in contrast, we can reuse our FakeUnitOfWork:\n\nBootstrap in unit test (tests/unit/test_handlers.py)\n\ndef bootstrap_test_app(): return bootstrap.bootstrap( start_orm=False, uow=FakeUnitOfWork(), send_mail=lambda *args: None, publish=lambda *args: None, )\n\nNo need to start the ORM…\n\n…because the fake UoW doesn’t use one.\n\nWe want to fake out our email and Redis adapters too.\n\nSo that gets rid of a little duplication, and we’ve moved a bunch of\n\nsetup and sensible defaults into a single place.\n\nEXERCISE FOR THE READER 1\n\nChange all the handlers to being classes as per the DI using classes example, and amend the bootstrapper’s DI code as appropriate. This will let you know whether you prefer the functional approach or the class-based approach when it comes to your own projects.\n\nBuilding an Adapter “Properly”: A Worked Example",
      "content_length": 922,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 357,
      "content": "To really get a feel for how it all works, let’s work through an example\n\nof how you might “properly” build an adapter and do dependency injection for it.\n\nAt the moment, we have two types of dependencies:\n\nTwo types of dependencies (src/allocation/service_layer/messagebus.py)\n\nuow: unit_of_work.AbstractUnitOfWork, send_mail: Callable, publish: Callable,\n\nThe UoW has an abstract base class. This is the heavyweight option for declaring and managing your external dependency. We’d use this for the case when the dependency is relatively complex.\n\nOur email sender and pub/sub publisher are defined as functions. This works just fine for simple dependencies.\n\nHere are some of the things we find ourselves injecting at work:\n\nAn S3 filesystem client\n\nA key/value store client\n\nA requests session object\n\nMost of these will have more-complex APIs that you can’t capture as a\n\nsingle function: read and write, GET and POST, and so on.\n\nEven though it’s simple, let’s use send_mail as an example to talk through how you might define a more complex dependency.",
      "content_length": 1057,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 358,
      "content": "Define the Abstract and Concrete Implementations\n\nWe’ll imagine a more generic notifications API. Could be email, could be SMS, could be Slack posts one day.\n\nAn ABC and a concrete implementation\n\n(src/allocation/adapters/notifications.py)\n\nclass AbstractNotifications(abc.ABC):\n\n@abc.abstractmethod def send(self, destination, message): raise NotImplementedError\n\n...\n\nclass EmailNotifications(AbstractNotifications):\n\ndef __init__(self, smtp_host=DEFAULT_HOST, port=DEFAULT_PORT): self.server = smtplib.SMTP(smtp_host, port=port) self.server.noop()\n\ndef send(self, destination, message): msg = f'Subject: allocation service notification\\n{message}' self.server.sendmail( from_addr='allocations@example.com', to_addrs=[destination], msg=msg )\n\nWe change the dependency in the bootstrap script:\n\nNotifications in message bus (src/allocation/bootstrap.py)\n\ndef bootstrap( start_orm: bool = True, uow: unit_of_work.AbstractUnitOfWork = unit_of_work.SqlAlchemyUnitOfWork(), - send_mail: Callable = email.send,",
      "content_length": 1006,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 359,
      "content": "+ notifications: AbstractNotifications = EmailNotifications(), publish: Callable = redis_eventpublisher.publish, ) -> messagebus.MessageBus:\n\nMake a Fake Version for Your Tests\n\nWe work through and define a fake version for unit testing:\n\nFake notifications (tests/unit/test_handlers.py)\n\nclass FakeNotifications(notifications.AbstractNotifications):\n\ndef __init__(self): self.sent = defaultdict(list) # type: Dict[str, List[str]]\n\ndef send(self, destination, message): self.sent[destination].append(message) ...\n\nAnd we use it in our tests:\n\nTests change slightly (tests/unit/test_handlers.py)\n\ndef test_sends_email_on_out_of_stock_error(self): fake_notifs = FakeNotifications() bus = bootstrap.bootstrap( start_orm=False, uow=FakeUnitOfWork(), notifications=fake_notifs, publish=lambda *args: None, ) bus.handle(commands.CreateBatch(\"b1\", \"POPULAR-CURTAINS\", 9, None)) bus.handle(commands.Allocate(\"o1\", \"POPULAR-CURTAINS\", 10)) assert fake_notifs.sent['stock@made.com'] == [ f\"Out of stock for POPULAR-CURTAINS\", ]",
      "content_length": 1017,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 360,
      "content": "Figure Out How to Integration Test the Real Thing\n\nNow we test the real thing, usually with an end-to-end or integration test. We’ve used MailHog as a real-ish email server for our Docker\n\ndev environment:\n\nDocker-compose config with real fake email server (docker- compose.yml)\n\nversion: \"3\"\n\nservices:\n\nredis_pubsub: build: context: . dockerfile: Dockerfile image: allocation-image ...\n\napi: image: allocation-image ...\n\npostgres: image: postgres:9.6 ...\n\nredis: image: redis:alpine ...\n\nmailhog: image: mailhog/mailhog ports: - \"11025:1025\" - \"18025:8025\"",
      "content_length": 558,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 361,
      "content": "In our integration tests, we use the real EmailNotifications class, talking to the MailHog server in the Docker cluster:\n\nIntegration test for email (tests/integration/test_email.py)\n\n@pytest.fixture def bus(sqlite_session_factory): bus = bootstrap.bootstrap( start_orm=True, uow=unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory), notifications=notifications.EmailNotifications(), publish=lambda *args: None, ) yield bus clear_mappers()\n\ndef get_email_from_mailhog(sku): host, port = map(config.get_email_host_and_port().get, ['host', 'http_port']) all_emails = requests.get(f'http://{host}:{port}/api/v2/messages').json() return next(m for m in all_emails['items'] if sku in str(m))\n\ndef test_out_of_stock_email(bus): sku = random_sku() bus.handle(commands.CreateBatch('batch1', sku, 9, None)) bus.handle(commands.Allocate('order1', sku, 10)) email = get_email_from_mailhog(sku) assert email['Raw']['From'] == 'allocations@example.com' assert email['Raw']['To'] == ['stock@made.com'] assert f'Out of stock for {sku}' in email['Raw']['Data']\n\nWe use our bootstrapper to build a message bus that talks to the real notifications class.\n\nWe figure out how to fetch emails from our “real” email server.",
      "content_length": 1206,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 362,
      "content": "We use the bus to do our test setup.\n\nAgainst all the odds, this actually worked, pretty much at the first go!\n\nAnd that’s it really.\n\nEXERCISE FOR THE READER 2\n\nYou could do two things for practice regarding adapters:\n\n1. Try swapping out our notifications from email to SMS notifications using Twilio, for example, or Slack notifications. Can you find a good equivalent to MailHog for integration testing?\n\n2. In a similar way to what we did moving from send_mail to a Notifications class, try refactoring our redis_eventpublisher that is currently just a Callable to some sort of more formal adapter/base class/protocol.\n\nWrap-Up\n\nOnce you have more than one adapter, you’ll start to feel a lot of pain from passing dependencies around manually, unless you do some kind of dependency injection.\n\nSetting up dependency injection is just one of many typical setup/initialization activities that you need to do just once when\n\nstarting your app. Putting this all together into a bootstrap script is often a good idea.\n\nThe bootstrap script is also good as a place to provide sensible default configuration for your adapters, and as a single place to override those adapters with fakes for your tests.",
      "content_length": 1200,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 363,
      "content": "A dependency injection framework can be useful if you find yourself needing to do DI at multiple levels—if you have chained dependencies\n\nof components that all need DI, for example.\n\nThis chapter also presented a worked example of changing an implicit/simple dependency into a “proper” adapter, factoring out an ABC, defining its real and fake implementations, and thinking through integration testing.\n\nDI AND BOOTSTRAP RECAP\n\nIn summary:\n\n1. Define your API using an ABC.\n\n2. Implement the real thing.\n\n3. Build a fake and use it for unit/service-layer/handler tests.\n\n4. Find a less fake version you can put into your Docker environment.\n\n5. Test the less fake “real” thing.\n\n6. Profit!\n\nThese were the last patterns we wanted to cover, which brings us to the end of Part II. In the epilogue, we’ll try to give you some pointers\n\nfor applying these techniques in the Real World\n\nTM .\n\n1 Because Python is not a “pure” OO language, Python developers aren’t necessarily used to the concept of needing to compose a set of objects into a working application. We just pick our entrypoint and run code from top to bottom.\n\n2 Mark Seemann calls this Pure DI or sometimes Vanilla DI.\n\n3 However, it’s still a global in the flask_app module scope, if that makes sense. This may cause problems if you ever find yourself wanting to test your Flask app in-process by",
      "content_length": 1358,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 364,
      "content": "using the Flask Test Client instead of using Docker as we do. It’s worth researching Flask app factories if you get into this.",
      "content_length": 126,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 365,
      "content": "Epilogue\n\nWhat Now?\n\nPhew! We’ve covered a lot of ground in this book, and for most of our audience all of these ideas are new. With that in mind, we can’t hope to make you experts in these techniques. All we can really do is show you the broad-brush ideas, and just enough code for you to go ahead\n\nand write something from scratch.\n\nThe code we’ve shown in this book isn’t battle-hardened production\n\ncode: it’s a set of Lego blocks that you can play with to make your first house, spaceship, and skyscraper.\n\nThat leaves us with two big tasks. We want to talk about how to start applying these ideas for real in an existing system, and we need to\n\nwarn you about some of the things we had to skip. We’ve given you a whole new arsenal of ways to shoot yourself in the foot, so we should\n\ndiscuss some basic firearms safety.\n\nHow Do I Get There from Here?\n\nChances are that a lot of you are thinking something like this:\n\n“OK Bob and Harry, that’s all well and good, and if I ever get hired to work on a green-field new service, I know what to do. But in the meantime, I’m here with my big ball of Django mud, and I don’t see",
      "content_length": 1126,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 366,
      "content": "any way to get to your nice, clean, perfect, untainted, simplistic model. Not from here.”\n\nWe hear you. Once you’ve already built a big ball of mud, it’s hard to know how to start improving things. Really, we need to tackle things step by step.\n\nFirst things first: what problem are you trying to solve? Is the software too hard to change? Is the performance unacceptable? Have you got weird, inexplicable bugs?\n\nHaving a clear goal in mind will help you to prioritize the work that needs to be done and, importantly, communicate the reasons for doing\n\nit to the rest of the team. Businesses tend to have pragmatic approaches to technical debt and refactoring, so long as engineers can make a reasoned argument for fixing things.\n\nTIP\n\nMaking complex changes to a system is often an easier sell if you link it to feature work. Perhaps you’re launching a new product or opening your service to new markets? This is the right time to spend engineering resources on fixing the foundations. With a six-month project to deliver, it’s easier to make the argument for three weeks of cleanup work. Bob refers to this as architecture tax.\n\nSeparating Entangled Responsibilities\n\nAt the beginning of the book, we said that the main characteristic of a big ball of mud is homogeneity: every part of the system looks the",
      "content_length": 1308,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 367,
      "content": "same, because we haven’t been clear about the responsibilities of each component. To fix that, we’ll need to start separating out responsibilities and introducing clear boundaries. One of the first things we can do is to start building a service layer (Figure E-1).\n\nFigure E-1. Domain of a collaboration system\n\nThis was the system in which Bob first learned how to break apart a\n\nball of mud, and it was a doozy. There was logic everywhere—in the web pages, in manager objects, in helpers, in fat service classes that we’d written to abstract the managers and helpers, and in hairy command objects that we’d written to break apart the services.\n\nIf you’re working in a system that’s reached this point, the situation can feel hopeless, but it’s never too late to start weeding an overgrown garden. Eventually, we hired an architect who knew what he was doing, and he helped us get things back under control.",
      "content_length": 909,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 368,
      "content": "Start by working out the use cases of your system. If you have a user interface, what actions does it perform? If you have a backend processing component, maybe each cron job or Celery job is a single use case. Each of your use cases needs to have an imperative name: Apply Billing Charges, Clean Abandoned Accounts, or Raise Purchase Order, for example.\n\nIn our case, most of our use cases were part of the manager classes and had names like Create Workspace or Delete Document Version. Each use case was invoked from a web frontend.\n\nWe aim to create a single function or class for each of these supported operations that deals with orchestrating the work to be done. Each use case should do the following:\n\nStart its own database transaction if needed\n\nFetch any required data\n\nCheck any preconditions (see the Ensure pattern in Appendix E)\n\nUpdate the domain model\n\nPersist any changes\n\nEach use case should succeed or fail as an atomic unit. You might need to call one use case from another. That’s OK; just make a note of it, and try to avoid long-running database transactions.",
      "content_length": 1084,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 369,
      "content": "NOTE\n\nOne of the biggest problems we had was that manager methods called other manager methods, and data access could happen from the model objects themselves. It was hard to understand what each operation did without going on a treasure hunt across the codebase. Pulling all the logic into a single method, and using a UoW to control our transactions, made the system easier to reason about.",
      "content_length": 392,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 370,
      "content": "CASE STUDY: LAYERING AN OVERGROWN SYSTEM\n\nMany years ago, Bob worked for a software company that had outsourced the first version of its application, an online collaboration platform for sharing and working on files.\n\nWhen the company brought development in-house, it passed through several generations of developers’ hands, and each wave of new developers added more complexity to the code’s structure.\n\nAt its heart, the system was an ASP.NET Web Forms application, built with an NHibernate ORM. Users would upload documents into workspaces, where they could invite other workspace members to review, comment on, or modify their work.\n\nMost of the complexity of the application was in the permissions model because each document was contained in a folder, and folders allowed read, write, and edit permissions, much like a Linux filesystem.\n\nAdditionally, each workspace belonged to an account, and the account had quotas attached to it via a billing package.\n\nAs a result, every read or write operation against a document had to load an enormous number of objects from the database in order to test permissions and quotas. Creating a new workspace involved hundreds of database queries as we set up the permissions structure, invited users, and set up sample content.\n\nSome of the code for operations was in web handlers that ran when a user clicked a button or submitted a form; some of it was in manager objects that held code for orchestrating work; and some of it was in the domain model. Model objects would make database calls or copy files on disk, and the test coverage was abysmal.\n\nTo fix the problem, we first introduced a service layer so that all of the code for creating a document or workspace was in one place and could be understood. This involved pulling data access code out of the domain model and into command handlers. Likewise, we pulled orchestration code out of the managers and the web handlers and pushed it into handlers.\n\nThe resulting command handlers were long and messy, but we’d made a start at introducing order to the chaos.\n\nTIP\n\nIt’s fine if you have duplication in the use-case functions. We’re not trying to write perfect code; we’re just trying to extract some meaningful layers. It’s better to duplicate some code in a few places than to have use-case functions calling one another in a long chain.",
      "content_length": 2342,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 371,
      "content": "This is a good opportunity to pull any data-access or orchestration\n\ncode out of the domain model and into the use cases. We should also try to pull I/O concerns (e.g., sending email, writing files) out of the domain model and up into the use-case functions. We apply the techniques from Chapter 3 on abstractions to keep our handlers unit testable even when they’re performing I/O.\n\nThese use-case functions will mostly be about logging, data access, and error handling. Once you’ve done this step, you’ll have a grasp of what your program actually does, and a way to make sure each\n\noperation has a clearly defined start and finish. We’ll have taken a step toward building a pure domain model.\n\nRead Working Effectively with Legacy Code by Michael C. Feathers\n\n(Prentice Hall) for guidance on getting legacy code under test and\n\nstarting separating responsibilities.\n\nIdentifying Aggregates and Bounded Contexts\n\nPart of the problem with the codebase in our case study was that the object graph was highly connected. Each account had many\n\nworkspaces, and each workspace had many members, all of whom had\n\ntheir own accounts. Each workspace contained many documents, which had many versions.\n\nYou can’t express the full horror of the thing in a class diagram. For\n\none thing, there wasn’t really a single account related to a user. Instead, there was a bizarre rule requiring you to enumerate all of the",
      "content_length": 1405,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 372,
      "content": "accounts associated to the user via the workspaces and take the one\n\nwith the earliest creation date.\n\nEvery object in the system was part of an inheritance hierarchy that included SecureObject and Version. This inheritance hierarchy was mirrored directly in the database schema, so that every query had to join across 10 different tables and look at a discriminator column just\n\nto tell what kind of objects you were working with.\n\nThe codebase made it easy to “dot” your way through these objects like so:\n\nuser.account.workspaces[0].documents.versions[1].owner.account.settings[0];\n\nBuilding a system this way with Django ORM or SQLAlchemy is easy but is to be avoided. Although it’s convenient, it makes it very hard to\n\nreason about performance because each property might trigger a lookup to the database.\n\nTIP\n\nAggregates are a consistency boundary. In general, each use case should update a single aggregate at a time. One handler fetches one aggregate from a repository, modifies its state, and raises any events that happen as a result. If you need data from another part of the system, it’s totally fine to use a read model, but avoid updating multiple aggregates in a single transaction. When we choose to separate code into different aggregates, we’re explicitly choosing to make them eventually consistent with one another.",
      "content_length": 1337,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 373,
      "content": "A bunch of operations required us to loop over objects this way—for example:\n\n# Lock a user's workspaces for nonpayment\n\ndef lock_account(user): for workspace in user.account.workspaces: workspace.archive()\n\nOr even recurse over collections of folders and documents:\n\ndef lock_documents_in_folder(folder):\n\nfor doc in folder.documents: doc.archive()\n\nfor child in folder.children: lock_documents_in_folder(child)\n\nThese operations killed performance, but fixing them meant giving up our single object graph. Instead, we began to identify aggregates and to\n\nbreak the direct links between objects.\n\nNOTE\n\nWe talked about the infamous SELECT N+1 problem in Chapter 12, and how we might choose to use different techniques when reading data for queries versus reading data for commands.\n\nMostly we did this by replacing direct references with identifiers.\n\nBefore aggregates:",
      "content_length": 871,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 374,
      "content": "After modeling with aggregates:",
      "content_length": 31,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 375,
      "content": "TIP\n\nBidirectional links are often a sign that your aggregates aren’t right. In our original code, a Document knew about its containing Folder, and the Folder had a collection of Documents. This makes it easy to traverse the object graph but stops us from thinking properly about the consistency boundaries we need. We break apart aggregates by using references instead. In the new model, a Document had reference to its parent_folder but had no way to directly access the Folder.\n\nIf we needed to read data, we avoided writing complex loops and\n\ntransforms and tried to replace them with straight SQL. For example,\n\none of our screens was a tree view of folders and documents.\n\nThis screen was incredibly heavy on the database, because it relied on nested for loops that triggered a lazy-loaded ORM.",
      "content_length": 800,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 376,
      "content": "TIP\n\nWe use this same technique in Chapter 11, where we replace a nested loop over ORM objects with a simple SQL query. It’s the first step in a CQRS approach.\n\nAfter a lot of head-scratching, we replaced the ORM code with a big, ugly stored procedure. The code looked horrible, but it was much faster and helped to break the links between Folder and Document.\n\nWhen we needed to write data, we changed a single aggregate at a time, and we introduced a message bus to handle events. For example,\n\nin the new model, when we locked an account, we could first query for all the affected workspaces via SELECT id FROM workspace WHERE account_id = ?.\n\nWe could then raise a new command for each workspace:\n\nfor workspace_id in workspaces: bus.handle(LockWorkspace(workspace_id))\n\nAn Event-Driven Approach to Go to Microservices via Strangler Pattern\n\nThe Strangler Fig pattern involves creating a new system around the\n\nedges of an old system, while keeping it running. Bits of old functionality are gradually intercepted and replaced, until the old\n\nsystem is left doing nothing at all and can be switched off.",
      "content_length": 1106,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 377,
      "content": "When building the availability service, we used a technique called\n\nevent interception to move functionality from one place to another. This is a three-step process:\n\n1. Raise events to represent the changes happening in a system you want to replace.\n\n2. Build a second system that consumes those events and uses them to build its own domain model.\n\n3. Replace the older system with the new.\n\nWe used event interception to move from Figure E-2…\n\nFigure E-2. Before: strong, bidirectional coupling based on XML-RPC\n\nto Figure E-3.",
      "content_length": 529,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 378,
      "content": "Figure E-3. After: loose coupling with asynchronous events (you can find a high- resolution version of this diagram at cosmicpython.com)\n\nPractically, this was a several month-long project. Our first step was to write a domain model that could represent batches, shipments, and products. We used TDD to build a toy system that could answer a\n\nsingle question: “If I want N units of HAZARDOUS_RUG, how long will they take to be delivered?”\n\nTIP\n\nWhen deploying an event-driven system, start with a “walking skeleton.” Deploying a system that just logs its input forces us to tackle all the infrastructural questions and start working in production.",
      "content_length": 647,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 379,
      "content": "CASE STUDY: CARVING OUT A MICROSERVICE TO REPLACE A DOMAIN\n\nMADE.com started out with two monoliths: one for the frontend ecommerce application, and one for the backend fulfillment system.\n\nThe two systems communicated through XML-RPC. Periodically, the backend system would wake up and query the frontend system to find out about new orders. When it had imported all the new orders, it would send RPC commands to update the stock levels.\n\nOver time this synchronization process became slower and slower until, one Christmas, it took longer than 24 hours to import a single day’s orders. Bob was hired to break the system into a set of event-driven services.\n\nFirst, we identified that the slowest part of the process was calculating and synchronizing the available stock. What we needed was a system that could listen to external events and keep a running total of how much stock was available.\n\nWe exposed that information via an API, so that the user’s browser could ask how much stock was available for each product and how long it would take to deliver to their address.\n\nWhenever a product ran out of stock completely, we would raise a new event that the ecommerce platform could use to take a product off sale. Because we didn’t know how much load we would need to handle, we wrote the system with a CQRS pattern. Whenever the amount of stock changed, we would update a Redis database with a cached view model. Our Flask API queried these view models instead of running the complex domain model.\n\nAs a result, we could answer the question “How much stock is available?” in 2 to 3 milliseconds, and now the API frequently handles hundreds of requests a second for sustained periods.\n\nIf this all sounds a little familiar, well, now you know where our example app came from!\n\nOnce we had a working domain model, we switched to building out some infrastructural pieces. Our first production deployment was a tiny system that could receive a batch_created event and log its JSON representation. This is the “Hello World” of event-driven\n\narchitecture. It forced us to deploy a message bus, hook up a producer and consumer, build a deployment pipeline, and write a simple message handler.",
      "content_length": 2190,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 380,
      "content": "Given a deployment pipeline, the infrastructure we needed, and a basic domain model, we were off. A couple months later, we were in production and serving real customers.\n\nConvincing Your Stakeholders to Try Something New\n\nIf you’re thinking about carving a new system out of a big ball of mud, you’re probably suffering problems with reliability, performance,\n\nmaintainability, or all three simultaneously. Deep, intractable problems call for drastic measures!\n\nWe recommend domain modeling as a first step. In many overgrown\n\nsystems, the engineers, product owners, and customers no longer speak the same language. Business stakeholders speak about the system in abstract, process-focused terms, while developers are forced to speak about the system as it physically exists in its wild and chaotic state.",
      "content_length": 806,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 381,
      "content": "CASE STUDY: THE USER MODEL\n\nWe mentioned earlier that the account and user model in our first system were bound together by a “bizarre rule.” This is a perfect example of how engineering and business stakeholders can drift apart.\n\nIn this system, accounts parented workspaces, and users were members of workspaces. Workspaces were the fundamental unit for applying permissions and quotas. If a user joined a workspace and didn’t already have an account, we would associate them with the account that owned that workspace.\n\nThis was messy and ad hoc, but it worked fine until the day a product owner asked for a new feature:\n\nWhen a user joins a company, we want to add them to some default workspaces for the company, like the HR workspace or the Company Announcements workspace.\n\nWe had to explain to them that there was no such thing as a company, and there was no sense in which a user joined an account. Moreover, a “company” might have many accounts owned by different users, and a new user might be invited to any one of them.\n\nYears of adding hacks and work-arounds to a broken model caught up with us, and we had to rewrite the entire user management function as a brand-new system.\n\nFiguring out how to model your domain is a complex task that’s the subject of many decent books in its own right. We like to use interactive techniques like event storming and CRC modeling, because humans are good at collaborating through play. Event modeling is\n\nanother technique that brings engineers and product owners together to understand a system in terms of commands, queries, and events.\n\nTIP\n\nCheck out www.eventmodeling.org and www.eventstorming.org for some great guides to visual modeling of systems with events.\n\nThe goal is to be able to talk about the system by using the same\n\nubiquitous language, so that you can agree on where the complexity",
      "content_length": 1853,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 382,
      "content": "lies.\n\nWe’ve found a lot of value in treating domain problems as TDD kata. For example, the first code we wrote for the availability service was the batch and order line model. You can treat this as a lunchtime\n\nworkshop, or as a spike at the beginning of a project. Once you can demonstrate the value of modeling, it’s easier to make the argument for structuring the project to optimize for modeling.",
      "content_length": 401,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 383,
      "content": "CASE STUDY: DAVID SEDDON ON TAKING SMALL STEPS\n\nHi, I’m David, one of the tech reviewers on this book. I’ve worked on several complex Django monoliths, and so I’ve known the pain that Bob and Harry have made all sorts of grand promises about soothing.\n\nWhen I was first exposed to the patterns described here, I was rather excited. I had successfully used some of the techniques already on smaller projects, but here was a blueprint for much larger, database-backed systems like the one I work on in my day job. So I started trying to figure out how I could implement that blueprint at my current organization.\n\nI chose to tackle a problem area of the codebase that had always bothered me. I began by implementing it as a use case. But I found myself running into unexpected questions. There were things that I hadn’t considered while reading that now made it difficult to see what to do. Was it a problem if my use case interacted with two different aggregates? Could one use case call another? And how was it going to exist within a system that followed different architectural principles without resulting in a horrible mess?\n\nWhat happened to that oh-so-promising blueprint? Did I actually understand the ideas well enough to put them into practice? Was it even suitable for my application? Even if it was, would any of my colleagues agree to such a major change? Were these just nice ideas for me to fantasize about while I got on with real life?\n\nIt took me a while to realize that I could start small. I didn’t need to be a purist or to get it right the first time: I could experiment, finding what worked for me.\n\nAnd so that’s what I’ve done. I’ve been able to apply some of the ideas in a few places. I’ve built new features whose business logic can be tested without the database or mocks. And as a team, we’ve introduced a service layer to help define the jobs the system does.\n\nIf you start trying to apply these patterns in your work, you may go through similar feelings to begin with. When the nice theory of a book meets the reality of your codebase, it can be demoralizing.\n\nMy advice is to focus on a specific problem and ask yourself how you can put the relevant ideas to use, perhaps in an initially limited and imperfect fashion. You may discover, as I did, that the first problem you pick might be a bit too difficult; if so, move on to something else. Don’t try to boil the ocean, and don’t be too afraid of making mistakes. It will be a learning experience, and you can be confident that you’re moving roughly in a direction that others have found useful.\n\nSo, if you’re feeling the pain too, give these ideas a try. Don’t feel you need permission to rearchitect everything. Just look for somewhere small to start. And above all, do it to solve a specific problem. If you’re successful in solving it, you’ll know you got something right—and others will too.",
      "content_length": 2881,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 384,
      "content": "Questions Our Tech Reviewers Asked That We Couldn’t Work into Prose\n\nHere are some questions we heard during drafting that we couldn’t find a good place to address elsewhere in the book:\n\nDo I need to do all of this at once? Can I just do a bit at a time?\n\nNo, you can absolutely adopt these techniques bit by bit. If you have an existing system, we recommend building a service layer to try to keep orchestration in one place. Once you have that, it’s much easier to push logic into the model and push edge concerns like validation or error handling to the entrypoints.\n\nIt’s worth having a service layer even if you still have a big, messy Django ORM because it’s a way to start understanding the boundaries of operations.\n\nExtracting use cases will break a lot of my existing code; it’s too tangled\n\nJust copy and paste. It’s OK to cause more duplication in the short term. Think of this as a multistep process. Your code is in a bad state now, so copy and paste it to a new place and then make that new code clean and tidy.\n\nOnce you’ve done that, you can replace uses of the old code with calls to your new code and finally delete the mess. Fixing large codebases is a messy and painful process. Don’t expect things to get instantly better, and don’t worry if some bits of your application stay messy.\n\nDo I need to do CQRS? That sounds weird. Can’t I just use repositories?\n\nOf course you can! The techniques we’re presenting in this book are intended to make your life easier. They’re not some kind of",
      "content_length": 1508,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 385,
      "content": "ascetic discipline with which to punish yourself.\n\nIn our first case-study system, we had a lot of View Builder objects that used repositories to fetch data and then performed some transformations to return dumb read models. The advantage is that when you hit a performance problem, it’s easy to rewrite a view builder to use custom queries or raw SQL.\n\nHow should use cases interact across a larger system? Is it a problem for one to call another?\n\nThis might be an interim step. Again, in the first case study, we had handlers that would need to invoke other handlers. This gets really messy, though, and it’s much better to move to using a message bus to separate these concerns.\n\nGenerally, your system will have a single message bus implementation and a bunch of subdomains that center on a particular aggregate or set of aggregates. When your use case has finished, it can raise an event, and a handler elsewhere can run.\n\nIs it a code smell for a use case to use multiple repositories/aggregates, and if so, why?\n\nAn aggregate is a consistency boundary, so if your use case needs to update two aggregates atomically (within the same transaction), then your consistency boundary is wrong, strictly speaking. Ideally you should think about moving to a new aggregate that wraps up all the things you want to change at the same time.\n\nIf you’re actually updating only one aggregate and using the other(s) for read-only access, then that’s fine, although you could consider building a read/view model to get you that data instead— it makes things cleaner if each use case has only one aggregate.\n\nIf you do need to modify two aggregates, but the two operations don’t have to be in the same transaction/UoW, then consider splitting the work out into two different handlers and using a",
      "content_length": 1785,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 386,
      "content": "domain event to carry information between the two. You can read more in these papers on aggregate design by Vaughn Vernon.\n\nWhat if I have a read-only but business-logic-heavy system?\n\nView models can have complex logic in them. In this book, we’ve encouraged you to separate your read and write models because they have different consistency and throughput requirements. Mostly, we can use simpler logic for reads, but that’s not always true. In particular, permissions and authorization models can add a lot of complexity to our read side.\n\nWe’ve written systems in which the view models needed extensive unit tests. In those systems, we split a view builder from a view fetcher, as in Figure E-4.",
      "content_length": 699,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 387,
      "content": "Figure E-4. A view builder and view fetcher (you can find a high-resolution version of this diagram at cosmicpython.com)\n\n+ This makes it easy to test the view builder by giving it mocked data (e.g., a list of dicts). “Fancy CQRS” with event handlers is really a way of running our complex view logic whenever we write so that we\n\ncan avoid running it when we read.\n\nDo I need to build microservices to do this stuff?\n\nEgads, no! These techniques predate microservices by a decade or so. Aggregates, domain events, and dependency inversion are ways to control complexity in large systems. It just so happens that when you’ve built a set of use cases and a model for a business process,",
      "content_length": 685,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 388,
      "content": "moving it to its own service is relatively easy, but that’s not a requirement.\n\nI’m using Django. Can I still do this?\n\nWe have an entire appendix just for you: Appendix D!\n\nFootguns\n\nOK, so we’ve given you a whole bunch of new toys to play with. Here’s the fine print. Harry and Bob do not recommend that you copy and paste our code into a production system and rebuild your automated trading platform on Redis pub/sub. For reasons of brevity\n\nand simplicity, we’ve hand-waved a lot of tricky subjects. Here’s a list of things we think you should know before trying this for real.\n\nReliable messaging is hard\n\nRedis pub/sub is not reliable and shouldn’t be used as a general- purpose messaging tool. We picked it because it’s familiar and easy to run. At MADE, we run Event Store as our messaging tool, but we’ve had experience with RabbitMQ and Amazon EventBridge.\n\nTyler Treat has some excellent blog posts on his site bravenewgeek.com; you should read at least read “You Cannot Have Exactly-Once Delivery” and “What You Want Is What You Don’t: Understanding Trade-Offs in Distributed Messaging”.\n\nWe explicitly choose small, focused transactions that can fail independently\n\nIn Chapter 8, we update our process so that deallocating an order line and reallocating the line happen in two separate units of work. You will need monitoring to know when these transactions",
      "content_length": 1370,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 389,
      "content": "fail, and tooling to replay events. Some of this is made easier by using a transaction log as your message broker (e.g., Kafka or EventStore). You might also look at the Outbox pattern.\n\nWe don’t discuss idempotency\n\nWe haven’t given any real thought to what happens when handlers are retried. In practice you will want to make handlers idempotent so that calling them repeatedly with the same message will not make repeated changes to state. This is a key technique for building reliability, because it enables us to safely retry events when they fail.\n\nThere’s a lot of good material on idempotent message handling, try\n\nstarting with “How to Ensure Idempotency in an Eventual Consistent DDD/CQRS Application” and “(Un)Reliability in Messaging”.\n\nYour events will need to change their schema over time\n\nYou’ll need to find some way of documenting your events and sharing schema with consumers. We like using JSON schema and markdown because it’s simple but there is other prior art. Greg Young wrote an entire book on managing event-driven systems over time: Versioning in an Event Sourced System (Leanpub).\n\nMore Required Reading\n\nA few more books we’d like to recommend to help you on your way:\n\nClean Architectures in Python by Leonardo Giordani (Leanpub), which came out in 2019, is one of the few previous books on application architecture in Python.\n\nEnterprise Integration Patterns by Gregor Hohpe and Bobby Woolf (Addison-Wesley Professional) is a pretty good start",
      "content_length": 1475,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 390,
      "content": "for messaging patterns.\n\nMonolith to Microservices by Sam Newman (O’Reilly), and Newman’s first book, Building Microservices (O’Reilly). The Strangler Fig pattern is mentioned as a favorite, along with many others. These are good to check out if you’re thinking of moving to microservices, and they’re also good on integration patterns and the considerations of async messaging-based integration.\n\nWrap-Up\n\nPhew! That’s a lot of warnings and reading suggestions; we hope we haven’t scared you off completely. Our goal with this book is to give you just enough knowledge and intuition for you to start building some of this for yourself. We would love to hear how you get on and what\n\nproblems you’re facing with the techniques in your own systems, so why not get in touch with us over at www.cosmicpython.com?",
      "content_length": 809,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 391,
      "content": "Appendix A. Summary Diagram and Table\n\nHere’s what our architecture looks like by the end of the book:",
      "content_length": 102,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 393,
      "content": "Table A-1 recaps each pattern and what it does.",
      "content_length": 47,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 394,
      "content": "Table A-1. The components of our architecture and what they all do\n\nLayer\n\nCompo nent\n\nDescription\n\nDomain\n\nEntity\n\nA domain object whose attributes may change but that has a recognizable identity over time.\n\nDefines the business logic.\n\nValue object\n\nAn immutable domain object whose attributes entirely define it. It is fungible with other identical objects.\n\nAggregat e\n\nCluster of associated objects that we treat as a unit for the purpose of data changes. Defines and enforces a consistency boundary.\n\nEvent\n\nRepresents something that happened.\n\nComman d\n\nRepresents a job the system should perform.\n\nService Layer\n\nHandler\n\nReceives a command or an event and performs what needs to happen.\n\nDefines the jobs the system should perform and orchestrates different components.\n\nUnit of work\n\nMessage bus (internal)\n\nAbstraction around data integrity. Each unit of work represents an atomic update. Makes repositories available. Tracks new events on retrieved aggregates.\n\nHandles commands and events by routing them to the appropriate handler.\n\nAdapters (Secondary)\n\nRepositor y\n\nAbstraction around persistent storage. Each aggregate has its own repository.\n\nConcrete implementations of an interface that goes",
      "content_length": 1211,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 395,
      "content": "Layer\n\nfrom our system to the outside world (I/O).\n\nEntrypoints (Primary adapters)\n\nTranslate external inputs into calls into the service layer.\n\nN/A\n\nCompo nent\n\nEvent publisher\n\nWeb\n\nEvent consumer\n\nExternal message bus (message broker)\n\nDescription\n\nPushes events onto the external message bus.\n\nReceives web requests and translates them into commands, passing them to the internal message bus.\n\nReads events from the external message bus and translates them into commands, passing them to the internal message bus.\n\nA piece of infrastructure that different services use to intercommunicate, via events.",
      "content_length": 606,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 396,
      "content": "Appendix B. A Template Project Structure\n\nAround Chapter 4, we moved from just having everything in one folder to a more structured tree, and we thought it might be of interest to outline the moving parts.\n\nTIP\n\nThe code for this appendix is in the appendix_project_structure branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout appendix_project_structure\n\nThe basic folder structure looks like this:\n\nProject tree\n\n. ├── Dockerfile ├── Makefile ├── README.md ├── docker-compose.yml ├── license.txt ├── mypy.ini ├── requirements.txt ├── src │ ├── allocation │ │ ├── __init__.py │ │ ├── adapters │ │ │ ├── __init__.py",
      "content_length": 654,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 397,
      "content": "│ │ │ ├── orm.py │ │ │ └── repository.py │ │ ├── config.py │ │ ├── domain │ │ │ ├── __init__.py │ │ │ └── model.py │ │ ├── entrypoints │ │ │ ├── __init__.py │ │ │ └── flask_app.py │ │ └── service_layer │ │ ├── __init__.py │ │ └── services.py │ └── setup.py └── tests ├── conftest.py ├── e2e │ └── test_api.py ├── integration │ ├── test_orm.py │ └── test_repository.py ├── pytest.ini └── unit ├── test_allocate.py ├── test_batches.py └── test_services.py\n\nOur docker-compose.yml and our Dockerfile are the main bits of configuration for the containers that run our app, and they can also run the tests (for CI). A more complex project might have several Dockerfiles, although we’ve found that minimizing the number of images is usually a good idea.\n\n1\n\nA Makefile provides the entrypoint for all the typical commands a developer (or a CI server) might want to run during their normal workflow: make build, make test, and so on. This is optional. You could just use docker-compose and pytest directly, but if nothing else, it’s nice to have all the “common commands” in a list somewhere, and unlike documentation, a Makefile is code so it has less tendency to become out of date.\n\n2\n\nAll the source code for our app, including the domain model, the Flask app, and infrastructure code, lives in a Python package",
      "content_length": 1308,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 398,
      "content": "3\n\ninside src, which we install using pip install -e and the setup.py file. This makes imports easy. Currently, the structure within this module is totally flat, but for a more complex project, you’d expect to grow a folder hierarchy that includes domain_model/, infrastructure/, services/, and api/.\n\nTests live in their own folder. Subfolders distinguish different test types and allow you to run them separately. We can keep shared fixtures (conftest.py) in the main tests folder and nest more specific ones if we wish. This is also the place to keep pytest.ini.\n\nTIP\n\nThe pytest docs are really good on test layout and importability.\n\nLet’s look at a few of these files and concepts in more detail.\n\nEnv Vars, 12-Factor, and Config, Inside and Outside Containers\n\nThe basic problem we’re trying to solve here is that we need different config settings for the following:\n\nRunning code or tests directly from your own dev machine, perhaps talking to mapped ports from Docker containers\n\nRunning on the containers themselves, with “real” ports and hostnames\n\nDifferent container environments (dev, staging, prod, and so on)",
      "content_length": 1124,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 399,
      "content": "Configuration through environment variables as suggested by the 12- factor manifesto will solve this problem, but concretely, how do we implement it in our code and our containers?\n\nConfig.py\n\nWhenever our application code needs access to some config, it’s going to get it from a file called config.py. Here are a couple of examples from our app:\n\nSample config functions (src/allocation/config.py)\n\nimport os\n\ndef get_postgres_uri(): host = os.environ.get('DB_HOST', 'localhost') port = 54321 if host == 'localhost' else 5432 password = os.environ.get('DB_PASSWORD', 'abc123') user, db_name = 'allocation', 'allocation' return f\"postgresql://{user}:{password}@{host}:{port}/{db_name}\"\n\ndef get_api_url(): host = os.environ.get('API_HOST', 'localhost') port = 5005 if host == 'localhost' else 80 return f\"http://{host}:{port}\"\n\nWe use functions for getting the current config, rather than constants available at import time, because that allows client code to modify os.environ if it needs to.\n\nconfig.py also defines some default settings, designed to work when running the code from the developer’s local machine.4",
      "content_length": 1116,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 400,
      "content": "An elegant Python package called environ-config is worth looking at if you get tired of hand-rolling your own environment-based config functions.\n\nTIP\n\nDon’t let this config module become a dumping ground that is full of things only vaguely related to config and that is then imported all over the place. Keep things immutable and modify them only via environment variables. If you decide to use a bootstrap script, you can make it the only place (other than tests) that config is imported to.\n\nDocker-Compose and Containers Config\n\nWe use a lightweight Docker container orchestration tool called docker-compose. It’s main configuration is via a YAML file (sigh):\n\ndocker-compose config file (docker-compose.yml)\n\nversion: \"3\" services:\n\napp: build: context: . dockerfile: Dockerfile depends_on: - postgres environment: - DB_HOST=postgres - DB_PASSWORD=abc123 - API_HOST=app - PYTHONDONTWRITEBYTECODE=1 volumes:\n\n5",
      "content_length": 914,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 401,
      "content": "./src:/src - ./tests:/tests ports: - \"5005:80\"\n\npostgres: image: postgres:9.6 environment: - POSTGRES_USER=allocation - POSTGRES_PASSWORD=abc123 ports: - \"54321:5432\"\n\nIn the docker-compose file, we define the different services (containers) that we need for our app. Usually one main image contains all our code, and we can use it to run our API, our tests, or any other service that needs access to the domain model.\n\nYou’ll probably have other infrastructure services, including a database. In production you might not use containers for this; you might have a cloud provider instead, but docker-compose gives us a way of producing a similar service for dev or CI.\n\nThe environment stanza lets you set the environment variables for your containers, the hostnames and ports as seen from inside the Docker cluster. If you have enough containers that information starts to be duplicated in these sections, you can use environment_file instead. We usually call ours container.env.\n\nInside a cluster, docker-compose sets up networking such that containers are available to each other via hostnames named after their service name.\n\nPro tip: if you’re mounting volumes to share source folders between your local dev machine and the container, the PYTHONDONTWRITEBYTECODE environment variable tells Python to not write .pyc files, and that will save you from having millions of",
      "content_length": 1372,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 402,
      "content": "root-owned files sprinkled all over your local filesystem, being all annoying to delete and causing weird Python compiler errors besides.\n\nMounting our source and test code as volumes means we don’t need to rebuild our containers every time we make a code change.\n\nThe ports section allows us to expose the ports from inside the 6 containers to the outside world —these correspond to the default ports we set in config.py.\n\nNOTE\n\nInside Docker, other containers are available through hostnames named after their service name. Outside Docker, they are available on localhost, at the port defined in the ports section.\n\nInstalling Your Source as a Package\n\nAll our application code (everything except tests, really) lives inside\n\nan src folder:\n\nThe src folder\n\n├── src │ ├── allocation │ │ ├── config.py │ │ └── ... │ └── setup.py\n\nSubfolders define top-level module names. You can have multiple if you like.",
      "content_length": 907,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 403,
      "content": "And setup.py is the file you need to make it pip-installable, shown next.\n\npip-installable modules in three lines (src/setup.py)\n\nfrom setuptools import setup\n\nsetup( name='allocation', version='0.1', packages=['allocation'], )\n\nThat’s all you need. packages= specifies the names of subfolders that you want to install as top-level modules. The name entry is just cosmetic, but it’s required. For a package that’s never actually going to hit PyPI, it’ll do fine.\n\n7\n\nDockerfile\n\nDockerfiles are going to be very project-specific, but here are a few key stages you’ll expect to see:\n\nOur Dockerfile (Dockerfile)\n\nFROM python:3.8-alpine\n\nRUN apk add --no-cache --virtual .build-deps gcc postgresql-dev musl-dev python3-dev RUN apk add libpq\n\nCOPY requirements.txt /tmp/ RUN pip install -r /tmp/requirements.txt\n\nRUN apk del --no-cache .build-deps",
      "content_length": 844,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 404,
      "content": "RUN mkdir -p /src COPY src/ /src/ RUN pip install -e /src COPY tests/ /tests/\n\nWORKDIR /src ENV FLASK_APP=allocation/entrypoints/flask_app.py FLASK_DEBUG=1 PYTHONUNBUFFERED=1 CMD flask run --host=0.0.0.0 --port=80\n\nInstalling system-level dependencies\n\nInstalling our Python dependencies (you may want to split out your dev from prod dependencies; we haven’t here, for simplicity)\n\nCopying and installing our source\n\nOptionally configuring a default startup command (you’ll probably override this a lot from the command line)\n\nTIP\n\nOne thing to note is that we install things in the order of how frequently they are likely to change. This allows us to maximize Docker build cache reuse. I can’t tell you how much pain and frustration underlies this lesson. For this and many more Python Dockerfile improvement tips, check out “Production-Ready Docker Packaging”.\n\nTests\n\nOur tests are kept alongside everything else, as shown here:\n\nTests folder tree",
      "content_length": 950,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 405,
      "content": "└── tests ├── conftest.py ├── e2e │ └── test_api.py ├── integration │ ├── test_orm.py │ └── test_repository.py ├── pytest.ini └── unit ├── test_allocate.py ├── test_batches.py └── test_services.py\n\nNothing particularly clever here, just some separation of different test types that you’re likely to want to run separately, and some files for\n\ncommon fixtures, config, and so on.\n\nThere’s no src folder or setup.py in the test folders because we usually haven’t needed to make tests pip-installable, but if you have\n\ndifficulties with import paths, you might find it helps.\n\nWrap-Up\n\nThese are our basic building blocks:\n\nSource code in an src folder, pip-installable using setup.py\n\nSome Docker config for spinning up a local cluster that mirrors production as far as possible\n\nConfiguration via environment variables, centralized in a Python file called config.py, with defaults allowing things to run outside containers\n\nA Makefile for useful command-line, um, commands",
      "content_length": 971,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 406,
      "content": "We doubt that anyone will end up with exactly the same solutions we\n\ndid, but we hope you find some inspiration here.\n\n1 Splitting out images for production and testing is sometimes a good idea, but we’ve\n\ntended to find that going further and trying to split out different images for different types of application code (e.g., Web API versus pub/sub client) usually ends up being more trouble than it’s worth; the cost in terms of complexity and longer rebuild/CI times is too high. YMMV.\n\n2 A pure-Python alternative to Makefiles is Invoke, worth checking out if everyone on your\n\nteam knows Python (or at least knows it better than Bash!).\n\n3 “Testing and Packaging” by Hynek Schlawack provides more information on src folders.\n\n4 This gives us a local development setup that “just works” (as much as possible). You\n\nmay prefer to fail hard on missing environment variables instead, particularly if any of the defaults would be insecure in production.\n\n5 Harry is a bit YAML-weary. It’s everywhere, and yet he can never remember the\n\nsyntax or how it’s supposed to indent.\n\n6 On a CI server, you may not be able to expose arbitrary ports reliably, but it’s only a\n\nconvenience for local dev. You can find ways of making these port mappings optional (e.g., with docker-compose.override.yml).\n\n7 For more setup.py tips, see this article on packaging by Hynek.",
      "content_length": 1360,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 407,
      "content": "Appendix C. Swapping Out the Infrastructure: Do Everything with CSVs\n\nThis appendix is intended as a little illustration of the benefits of the Repository, Unit of Work, and Service Layer patterns. It’s intended to follow from Chapter 6.\n\nJust as we finish building out our Flask API and getting it ready for release, the business comes to us apologetically, saying they’re not\n\nready to use our API and asking if we could build a thing that reads just batches and orders from a couple of CSVs and outputs a third CSV\n\nwith allocations.\n\nOrdinarily this is the kind of thing that might have a team cursing and\n\nspitting and making notes for their memoirs. But not us! Oh no, we’ve ensured that our infrastructure concerns are nicely decoupled from our\n\ndomain model and service layer. Switching to CSVs will be a simple matter of writing a couple of new Repository and UnitOfWork classes, and then we’ll be able to reuse all of our logic from the\n\ndomain layer and the service layer.\n\nHere’s an E2E test to show you how the CSVs flow in and out:\n\nA first CSV test (tests/e2e/test_csv.py)",
      "content_length": 1087,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 408,
      "content": "def test_cli_app_reads_csvs_with_batches_and_orders_and_outputs_allocations( make_csv ): sku1, sku2 = random_ref('s1'), random_ref('s2') batch1, batch2, batch3 = random_ref('b1'), random_ref('b2'), random_ref('b3') order_ref = random_ref('o') make_csv('batches.csv', [ ['ref', 'sku', 'qty', 'eta'], [batch1, sku1, 100, ''], [batch2, sku2, 100, '2011-01-01'], [batch3, sku2, 100, '2011-01-02'], ]) orders_csv = make_csv('orders.csv', [ ['orderid', 'sku', 'qty'], [order_ref, sku1, 3], [order_ref, sku2, 12], ])\n\nrun_cli_script(orders_csv.parent)\n\nexpected_output_csv = orders_csv.parent / 'allocations.csv' with open(expected_output_csv) as f: rows = list(csv.reader(f)) assert rows == [ ['orderid', 'sku', 'qty', 'batchref'], [order_ref, sku1, '3', batch1], [order_ref, sku2, '12', batch2], ]\n\nDiving in and implementing without thinking about repositories and all that jazz, you might start with something like this:\n\nA first cut of our CSV reader/writer (src/bin/allocate-from-csv)\n\n#!/usr/bin/env python import csv import sys from datetime import datetime",
      "content_length": 1058,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 409,
      "content": "from pathlib import Path\n\nfrom allocation import model\n\ndef load_batches(batches_path): batches = [] with batches_path.open() as inf: reader = csv.DictReader(inf) for row in reader: if row['eta']: eta = datetime.strptime(row['eta'], '%Y-%m-%d').date() else: eta = None batches.append(model.Batch( ref=row['ref'], sku=row['sku'], qty=int(row['qty']), eta=eta )) return batches\n\ndef main(folder): batches_path = Path(folder) / 'batches.csv' orders_path = Path(folder) / 'orders.csv' allocations_path = Path(folder) / 'allocations.csv'\n\nbatches = load_batches(batches_path)\n\nwith orders_path.open() as inf, allocations_path.open('w') as outf: reader = csv.DictReader(inf) writer = csv.writer(outf) writer.writerow(['orderid', 'sku', 'batchref']) for row in reader: orderid, sku = row['orderid'], row['sku'] qty = int(row['qty']) line = model.OrderLine(orderid, sku, qty) batchref = model.allocate(line, batches) writer.writerow([line.orderid, line.sku, batchref])",
      "content_length": 960,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 410,
      "content": "if __name__ == '__main__': main(sys.argv[1])\n\nIt’s not looking too bad! And we’re reusing our domain model objects and our domain service.\n\nBut it’s not going to work. Existing allocations need to also be part of our permanent CSV storage. We can write a second test to force us to improve things:\n\nAnd another one, with existing allocations (tests/e2e/test_csv.py)\n\ndef test_cli_app_also_reads_existing_allocations_and_can_append_to_them( make_csv ): sku = random_ref('s') batch1, batch2 = random_ref('b1'), random_ref('b2') old_order, new_order = random_ref('o1'), random_ref('o2') make_csv('batches.csv', [ ['ref', 'sku', 'qty', 'eta'], [batch1, sku, 10, '2011-01-01'], [batch2, sku, 10, '2011-01-02'], ]) make_csv('allocations.csv', [ ['orderid', 'sku', 'qty', 'batchref'], [old_order, sku, 10, batch1], ]) orders_csv = make_csv('orders.csv', [ ['orderid', 'sku', 'qty'], [new_order, sku, 7], ])\n\nrun_cli_script(orders_csv.parent)\n\nexpected_output_csv = orders_csv.parent / 'allocations.csv' with open(expected_output_csv) as f:",
      "content_length": 1032,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 411,
      "content": "rows = list(csv.reader(f)) assert rows == [ ['orderid', 'sku', 'qty', 'batchref'], [old_order, sku, '10', batch1], [new_order, sku, '7', batch2], ]\n\nAnd we could keep hacking about and adding extra lines to that load_batches function, and some sort of way of tracking and saving new allocations—but we already have a model for doing that! It’s called our Repository and Unit of Work patterns.\n\nAll we need to do (“all we need to do”) is reimplement those same abstractions, but with CSVs underlying them instead of a database. And as you’ll see, it really is relatively straightforward.\n\nImplementing a Repository and Unit of Work for CSVs\n\nHere’s what a CSV-based repository could look like. It abstracts away all the logic for reading CSVs from disk, including the fact that it has to read two different CSVs (one for batches and one for allocations), and it gives us just the familiar .list() API, which provides the illusion of an in-memory collection of domain objects:\n\nA repository that uses CSV as its storage mechanism (src/allocation/service_layer/csv_uow.py)\n\nclass CsvRepository(repository.AbstractRepository):\n\ndef __init__(self, folder): self._batches_path = Path(folder) / 'batches.csv'",
      "content_length": 1201,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 412,
      "content": "self._allocations_path = Path(folder) / 'allocations.csv' self._batches = {} # type: Dict[str, model.Batch] self._load()\n\ndef get(self, reference): return self._batches.get(reference)\n\ndef add(self, batch): self._batches[batch.reference] = batch\n\ndef _load(self): with self._batches_path.open() as f: reader = csv.DictReader(f) for row in reader: ref, sku = row['ref'], row['sku'] qty = int(row['qty']) if row['eta']: eta = datetime.strptime(row['eta'], '%Y-%m-%d').date() else: eta = None self._batches[ref] = model.Batch( ref=ref, sku=sku, qty=qty, eta=eta ) if self._allocations_path.exists() is False: return with self._allocations_path.open() as f: reader = csv.DictReader(f) for row in reader: batchref, orderid, sku = row['batchref'], row['orderid'], row['sku'] qty = int(row['qty']) line = model.OrderLine(orderid, sku, qty) batch = self._batches[batchref] batch._allocations.add(line)\n\ndef list(self): return list(self._batches.values())\n\nAnd here’s what a UoW for CSVs would look like:",
      "content_length": 995,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 413,
      "content": "A UoW for CSVs: commit = csv.writer\n\n(src/allocation/service_layer/csv_uow.py)\n\nclass CsvUnitOfWork(unit_of_work.AbstractUnitOfWork):\n\ndef __init__(self, folder): self.batches = CsvRepository(folder)\n\ndef commit(self): with self.batches._allocations_path.open('w') as f: writer = csv.writer(f) writer.writerow(['orderid', 'sku', 'qty', 'batchref']) for batch in self.batches.list(): for line in batch._allocations: writer.writerow( [line.orderid, line.sku, line.qty, batch.reference] )\n\ndef rollback(self): pass\n\nAnd once we have that, our CLI app for reading and writing batches\n\nand allocations to CSV is pared down to what it should be—a bit of code for reading order lines, and a bit of code that invokes our\n\nexisting service layer:\n\nAllocation with CSVs in nine lines (src/bin/allocate-from-csv)\n\ndef main(folder): orders_path = Path(folder) / 'orders.csv' uow = csv_uow.CsvUnitOfWork(folder) with orders_path.open() as f: reader = csv.DictReader(f) for row in reader: orderid, sku = row['orderid'], row['sku'] qty = int(row['qty']) services.allocate(orderid, sku, qty, uow)",
      "content_length": 1080,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 414,
      "content": "Ta-da! Now are y’all impressed or what?\n\nMuch love,\n\nBob and Harry",
      "content_length": 66,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 415,
      "content": "Appendix D. Repository and Unit of Work Patterns with Django\n\nSuppose you wanted to use Django instead of SQLAlchemy and Flask. How might things look? The first thing is to choose where to install it. We put it in a separate package next to our main allocation code:\n\n├── src │ ├── allocation │ │ ├── __init__.py │ │ ├── adapters │ │ │ ├── __init__.py ... │ ├── djangoproject │ │ ├── alloc │ │ │ ├── __init__.py │ │ │ ├── apps.py │ │ │ ├── migrations │ │ │ │ ├── 0001_initial.py │ │ │ │ └── __init__.py │ │ │ ├── models.py │ │ │ └── views.py │ │ ├── django_project │ │ │ ├── __init__.py │ │ │ ├── settings.py │ │ │ ├── urls.py │ │ │ └── wsgi.py │ │ └── manage.py │ └── setup.py └── tests ├── conftest.py ├── e2e │ └── test_api.py ├── integration",
      "content_length": 745,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 416,
      "content": "│ ├── test_repository.py ...\n\nTIP\n\nThe code for this appendix is in the appendix_django branch on GitHub:\n\ngit clone https://github.com/cosmicpython/code.git cd code git checkout appendix_django\n\nRepository Pattern with Django\n\nWe used a plug-in called pytest-django to help with test database management.\n\nRewriting the first repository test was a minimal change—just rewriting some raw SQL with a call to the Django ORM/QuerySet language:\n\nFirst repository test adapted (tests/integration/test_repository.py)\n\nfrom djangoproject.alloc import models as django_models\n\n@pytest.mark.django_db def test_repository_can_save_a_batch(): batch = model.Batch(\"batch1\", \"RUSTY-SOAPDISH\", 100, eta=date(2011, 12, 25))\n\nrepo = repository.DjangoRepository() repo.add(batch)\n\n[saved_batch] = django_models.Batch.objects.all() assert saved_batch.reference == batch.reference assert saved_batch.sku == batch.sku",
      "content_length": 897,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 417,
      "content": "assert saved_batch.qty == batch._purchased_quantity assert saved_batch.eta == batch.eta\n\nThe second test is a bit more involved since it has allocations, but it is still made up of familiar-looking Django code:\n\nSecond repository test is more involved (tests/integration/test_repository.py)\n\n@pytest.mark.django_db def test_repository_can_retrieve_a_batch_with_allocations(): sku = \"PONY-STATUE\" d_line = django_models.OrderLine.objects.create(orderid=\"order1\", sku=sku, qty=12) d_b1 = django_models.Batch.objects.create( reference=\"batch1\", sku=sku, qty=100, eta=None ) d_b2 = django_models.Batch.objects.create( reference=\"batch2\", sku=sku, qty=100, eta=None ) django_models.Allocation.objects.create(line=d_line, batch=d_batch1)\n\nrepo = repository.DjangoRepository() retrieved = repo.get(\"batch1\")\n\nexpected = model.Batch(\"batch1\", sku, 100, eta=None) assert retrieved == expected # Batch.__eq__ only compares reference assert retrieved.sku == expected.sku assert retrieved._purchased_quantity == expected._purchased_quantity assert retrieved._allocations == { model.OrderLine(\"order1\", sku, 12), }\n\nHere’s how the actual repository ends up looking:\n\nA Django repository (src/allocation/adapters/repository.py)\n\nclass DjangoRepository(AbstractRepository):",
      "content_length": 1258,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 418,
      "content": "def add(self, batch): super().add(batch) self.update(batch)\n\ndef update(self, batch): django_models.Batch.update_from_domain(batch)\n\ndef _get(self, reference): return django_models.Batch.objects.filter( reference=reference ).first().to_domain()\n\ndef list(self): return [b.to_domain() for b in django_models.Batch.objects.all()]\n\nYou can see that the implementation relies on the Django models having some custom methods for translating to and from our domain model.\n\n1\n\nCustom Methods on Django ORM Classes to Translate to/from Our Domain Model\n\nThose custom methods look something like this:\n\nDjango ORM with custom methods for domain model conversion (src/djangoproject/alloc/models.py)\n\nfrom django.db import models from allocation.domain import model as domain_model\n\nclass Batch(models.Model): reference = models.CharField(max_length=255) sku = models.CharField(max_length=255) qty = models.IntegerField() eta = models.DateField(blank=True, null=True)\n\n@staticmethod def update_from_domain(batch: domain_model.Batch):",
      "content_length": 1022,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 419,
      "content": "try: b = Batch.objects.get(reference=batch.reference) except Batch.DoesNotExist: b = Batch(reference=batch.reference) b.sku = batch.sku b.qty = batch._purchased_quantity b.eta = batch.eta b.save() b.allocation_set.set( Allocation.from_domain(l, b) for l in batch._allocations )\n\ndef to_domain(self) -> domain_model.Batch: b = domain_model.Batch( ref=self.reference, sku=self.sku, qty=self.qty, eta=self.eta ) b._allocations = set( a.line.to_domain() for a in self.allocation_set.all() ) return b\n\nclass OrderLine(models.Model): #...\n\nFor value objects, objects.get_or_create can work, but for entities, you probably need an explicit try-get/except to handle the upsert.\n\n2\n\nWe’ve shown the most complex example here. If you do decide to do this, be aware that there will be boilerplate! Thankfully it’s not very complex boilerplate.\n\nRelationships also need some careful, custom handling.",
      "content_length": 888,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 420,
      "content": "NOTE\n\nAs in Chapter 2, we use dependency inversion. The ORM (Django) depends on the model and not the other way around.\n\nUnit of Work Pattern with Django\n\nThe tests don’t change too much:\n\nAdapted UoW tests (tests/integration/test_uow.py)\n\ndef insert_batch(ref, sku, qty, eta): django_models.Batch.objects.create(reference=ref, sku=sku, qty=qty, eta=eta)\n\ndef get_allocated_batch_ref(orderid, sku): return django_models.Allocation.objects.get( line__orderid=orderid, line__sku=sku ).batch.reference\n\n@pytest.mark.django_db(transaction=True) def test_uow_can_retrieve_a_batch_and_allocate_to_it(): insert_batch('batch1', 'HIPSTER-WORKBENCH', 100, None)\n\nuow = unit_of_work.DjangoUnitOfWork() with uow: batch = uow.batches.get(reference='batch1') line = model.OrderLine('o1', 'HIPSTER-WORKBENCH', 10) batch.allocate(line) uow.commit()\n\nbatchref = get_allocated_batch_ref('o1', 'HIPSTER-WORKBENCH') assert batchref == 'batch1'\n\n@pytest.mark.django_db(transaction=True)",
      "content_length": 965,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 421,
      "content": "def test_rolls_back_uncommitted_work_by_default(): ...\n\n@pytest.mark.django_db(transaction=True) def test_rolls_back_on_error(): ...\n\nBecause we had little helper functions in these tests, the actual main bodies of the tests are pretty much the same as they were with SQLAlchemy.\n\nThe pytest-django mark.django_db(transaction=True) is required to test our custom transaction/rollback behaviors.\n\nAnd the implementation is quite simple, although it took me a few tries to find which invocation of Django’s transaction magic would work:\n\nUoW adapted for Django\n\n(src/allocation/service_layer/unit_of_work.py)\n\nclass DjangoUnitOfWork(AbstractUnitOfWork):\n\ndef __enter__(self): self.batches = repository.DjangoRepository() transaction.set_autocommit(False) return super().__enter__()\n\ndef __exit__(self, *args): super().__exit__(*args) transaction.set_autocommit(True)\n\ndef commit(self): for batch in self.batches.seen: self.batches.update(batch) transaction.commit()\n\ndef rollback(self): transaction.rollback()",
      "content_length": 1007,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 422,
      "content": "set_autocommit(False) was the best way to tell Django to stop automatically committing each ORM operation immediately, and to begin a transaction.\n\nThen we use the explicit rollback and commits.\n\nOne difficulty: because, unlike with SQLAlchemy, we’re not instrumenting the domain model instances themselves, the commit() command needs to explicitly go through all the objects that have been touched by every repository and manually update them back to the ORM.\n\nAPI: Django Views Are Adapters\n\nThe Django views.py file ends up being almost identical to the old\n\nflask_app.py, because our architecture means it’s a very thin wrapper around our service layer (which didn’t change at all, by the way):\n\nFlask app → Django views (src/djangoproject/alloc/views.py)\n\nos.environ['DJANGO_SETTINGS_MODULE'] = 'djangoproject.django_project.settings' django.setup()\n\n@csrf_exempt def add_batch(request): data = json.loads(request.body) eta = data['eta'] if eta is not None: eta = datetime.fromisoformat(eta).date() services.add_batch( data['ref'], data['sku'], data['qty'], eta, unit_of_work.DjangoUnitOfWork(), ) return HttpResponse('OK', status=201)\n\n@csrf_exempt",
      "content_length": 1154,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 423,
      "content": "def allocate(request): data = json.loads(request.body) try: batchref = services.allocate( data['orderid'], data['sku'], data['qty'], unit_of_work.DjangoUnitOfWork(), ) except (model.OutOfStock, services.InvalidSku) as e: return JsonResponse({'message': str(e)}, status=400)\n\nreturn JsonResponse({'batchref': batchref}, status=201)\n\nWhy Was This All So Hard?\n\nOK, it works, but it does feel like more effort than Flask/SQLAlchemy.\n\nWhy is that?\n\nThe main reason at a low level is because Django’s ORM doesn’t work in the same way. We don’t have an equivalent of the SQLAlchemy classical mapper, so our ActiveRecord and our domain model can’t be the same object. Instead we have to build a manual\n\ntranslation layer behind the repository. That’s more work (although once it’s done, the ongoing maintenance burden shouldn’t be too high).\n\nBecause Django is so tightly coupled to the database, you have to use helpers like pytest-django and think carefully about test databases, right from the very first line of code, in a way that we didn’t have to when we started out with our pure domain model.",
      "content_length": 1094,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 424,
      "content": "But at a higher level, the entire reason that Django is so great is that\n\nit’s designed around the sweet spot of making it easy to build CRUD apps with minimal boilerplate. But the entire thrust of our book is\n\nabout what to do when your app is no longer a simple CRUD app.\n\nAt that point, Django starts hindering more than it helps. Things like the Django admin, which are so awesome when you start out, become\n\nactively dangerous if the whole point of your app is to build a complex set of rules and modeling around the workflow of state changes. The\n\nDjango admin bypasses all of that.\n\nWhat to Do If You Already Have Django\n\nSo what should you do if you want to apply some of the patterns in this\n\nbook to a Django app? We’d say the following:\n\nThe Repository and Unit of Work patterns are going to be quite a lot of work. The main thing they will buy you in the short term is faster unit tests, so evaluate whether that benefit feels worth it in your case. In the longer term, they decouple your app from Django and the database, so if you anticipate wanting to migrate away from either of those, Repository and UoW are a good idea.\n\nThe Service Layer pattern might be of interest if you’re seeing a lot of duplication in your views.py. It can be a good way of thinking about your use cases separately from your web endpoints.\n\nYou can still theoretically do DDD and domain modeling with Django models, tightly coupled as they are to the database; you may be slowed by migrations, but it shouldn’t be fatal. So",
      "content_length": 1515,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 425,
      "content": "as long as your app is not too complex and your tests not too slow, you may be able to get something out of the fat models approach: push as much logic down to your models as possible, and apply patterns like Entity, Value Object, and Aggregate. However, see the following caveat.\n\nWith that said, word in the Django community is that people find that the fat models approach runs into scalability problems of its own,\n\nparticularly around managing interdependencies between apps. In\n\nthose cases, there’s a lot to be said for extracting out a business logic or domain layer to sit between your views and forms and your\n\nmodels.py, which you can then keep as minimal as possible.\n\nSteps Along the Way\n\nSuppose you’re working on a Django project that you’re not sure is\n\ngoing to get complex enough to warrant the patterns we recommend, but you still want to put a few steps in place to make your life easier,\n\nboth in the medium term and if you want to migrate to some of our patterns later. Consider the following:\n\nOne piece of advice we’ve heard is to put a logic.py into every Django app from day one. This gives you a place to put business logic, and to keep your forms, views, and models free of business logic. It can become a stepping-stone for moving to a fully decoupled domain model and/or service layer later.\n\nA business-logic layer might start out working with Django model objects and only later become fully decoupled from the framework and work on plain Python data structures.",
      "content_length": 1494,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 426,
      "content": "For the read side, you can get some of the benefits of CQRS by putting reads into one place, avoiding ORM calls sprinkled all over the place.\n\nWhen separating out modules for reads and modules for domain logic, it may be worth decoupling yourself from the Django apps hierarchy. Business concerns will cut across them.\n\nNOTE\n\nWe’d like to give a shout-out to David Seddon and Ashia Zawaduk for talking through some of the ideas in this appendix. They did their best to stop us from saying anything really stupid about a topic we don’t really have enough personal experience of, but they may have failed.\n\nFor more thoughts and actual lived experience dealing with existing\n\napplications, refer to the epilogue.\n\n1 The DRY-Python project people have built a tool called mappers that looks like it might\n\nhelp minimize boilerplate for this sort of thing.\n\n2 @mr-bo-jangles suggested you might be able to use update_or_create, but that’s\n\nbeyond our Django-fu.",
      "content_length": 957,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 427,
      "content": "Appendix E. Validation\n\nWhenever we’re teaching and talking about these techniques, one question that comes up over and over is “Where should I do validation? Does that belong with my business logic in the domain model, or is that an infrastructural concern?”\n\nAs with any architectural question, the answer is: it depends!\n\nThe most important consideration is that we want to keep our code\n\nwell separated so that each part of the system is simple. We don’t want to clutter our code with irrelevant detail.\n\nWhat Is Validation, Anyway?\n\nWhen people use the word validation, they usually mean a process whereby they test the inputs of an operation to make sure that they\n\nmatch certain criteria. Inputs that match the criteria are considered valid, and inputs that don’t are invalid.\n\nIf the input is invalid, the operation can’t continue but should exit with some kind of error. In other words, validation is about creating preconditions. We find it useful to separate our preconditions into\n\nthree subtypes: syntax, semantics, and pragmatics.\n\nValidating Syntax",
      "content_length": 1063,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 428,
      "content": "In linguistics, the syntax of a language is the set of rules that govern the structure of grammatical sentences. For example, in English, the sentence “Allocate three units of TASTELESS-LAMP to order twenty- seven” is grammatically sound, while the phrase “hat hat hat hat hat hat wibble” is not. We can describe grammatically correct sentences as well formed.\n\nHow does this map to our application? Here are some examples of syntactic rules:\n\nAn Allocate command must have an order ID, a SKU, and a quantity.\n\nA quantity is a positive integer.\n\nA SKU is a string.\n\nThese are rules about the shape and structure of incoming data. An Allocate command without a SKU or an order ID isn’t a valid message. It’s the equivalent of the phrase “Allocate three to.”\n\nWe tend to validate these rules at the edge of the system. Our rule of thumb is that a message handler should always receive only a message that is well-formed and contains all required information.\n\nOne option is to put your validation logic on the message type itself:\n\nValidation on the message class (src/allocation/commands.py)\n\nfrom schema import And, Schema, Use\n\n@dataclass",
      "content_length": 1139,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 429,
      "content": "class Allocate(Command):\n\n_schema = Schema({ 'orderid': int, sku: str, qty: And(Use(int), lambda n: n > 0) }, ignore_extra_keys=True)\n\norderid: str sku: str qty: int\n\n@classmethod def from_json(cls, data): data = json.loads(data) return cls(**_schema.validate(data))\n\nThe schema library lets us describe the structure and validation of our messages in a nice declarative way.\n\nThe from_json method reads a string as JSON and turns it into our message type.\n\nThis can get repetitive, though, since we need to specify our fields\n\ntwice, so we might want to introduce a helper library that can unify the validation and declaration of our message types:\n\nA command factory with schema (src/allocation/commands.py)\n\ndef command(name, **fields): schema = Schema(And(Use(json.loads), fields), ignore_extra_keys=True) cls = make_dataclass(name, fields.keys()) cls.from_json = lambda s: cls(**schema.validate(s)) return cls\n\ndef greater_than_zero(x): return x > 0",
      "content_length": 954,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 430,
      "content": "quantity = And(Use(int), greater_than_zero)\n\nAllocate = command( orderid=int, sku=str, qty=quantity )\n\nAddStock = command( sku=str, qty=quantity\n\nThe command function takes a message name, plus kwargs for the fields of the message payload, where the name of the kwarg is the name of the field and the value is the parser.\n\nWe use the make_dataclass function from the dataclass module to dynamically create our message type.\n\nWe patch the from_json method onto our dynamic dataclass.\n\nWe can create reusable parsers for quantity, SKU, and so on to keep things DRY.\n\nDeclaring a message type becomes a one-liner.\n\nThis comes at the expense of losing the types on your dataclass, so bear that trade-off in mind.\n\nPostel’s Law and the Tolerant Reader Pattern\n\nPostel’s law, or the robustness principle, tells us, “Be liberal in what you accept, and conservative in what you emit.” We think this applies particularly well in the context of integration with our other systems. The idea here is that we should be strict whenever we’re sending",
      "content_length": 1035,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 431,
      "content": "messages to other systems, but as lenient as possible when we’re receiving messages from others.\n\nFor example, our system could validate the format of a SKU. We’ve been using made-up SKUs like UNFORGIVING-CUSHION and MISBEGOTTEN-POUFFE. These follow a simple pattern: two words, separated by dashes, where the second word is the type of product and the first word is an adjective.\n\nDevelopers love to validate this kind of thing in their messages, and reject anything that looks like an invalid SKU. This causes horrible problems down the line when some anarchist releases a product named COMFY-CHAISE-LONGUE or when a snafu at the supplier results in a shipment of CHEAP-CARPET-2.\n\nReally, as the allocation system, it’s none of our business what the format of a SKU might be. All we need is an identifier, so we can simply describe it as a string. This means that the procurement system can change the format whenever they like, and we won’t care.\n\nThis same principle applies to order numbers, customer phone numbers, and much more. For the most part, we can ignore the internal structure of strings.\n\nSimilarly, developers love to validate incoming messages with tools like JSON Schema, or to build libraries that validate incoming messages and share them among systems. This likewise fails the robustness test.",
      "content_length": 1315,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 432,
      "content": "Let’s imagine, for example, that the procurement system adds new fields to the ChangeBatchQuantity message that record the reason for the change and the email of the user responsible for the change.\n\nSince these fields don’t matter to the allocation service, we should simply ignore them. We can do that in the schema library by passing the keyword arg ignore_extra_keys=True.\n\nThis pattern, whereby we extract only the fields we care about and do minimal validation of them, is the Tolerant Reader pattern.\n\nTIP\n\nValidate as little as possible. Read only the fields you need, and don’t overspecify their contents. This will help your system stay robust when other systems change over time. Resist the temptation to share message definitions between systems: instead, make it easy to define the data you depend on. For more info, see Martin Fowler’s article on the Tolerant Reader pattern.\n\nIS POSTEL ALWAYS RIGHT?\n\nMentioning Postel can be quite triggering to some people. They will tell you that Postel is the precise reason that everything on the internet is broken and we can’t have nice things. Ask Hynek about SSLv3 one day.\n\nWe like the Tolerant Reader approach in the particular context of event-based integration between services that we control, because it allows for independent evolution of those services.\n\nIf you’re in charge of an API that’s open to the public on the big bad internet, there might be good reasons to be more conservative about what inputs you allow.\n\nValidating at the Edge",
      "content_length": 1505,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 433,
      "content": "Earlier, we said that we want to avoid cluttering our code with\n\nirrelevant details. In particular, we don’t want to code defensively inside our domain model. Instead, we want to make sure that requests are known to be valid before our domain model or use-case handlers see them. This helps our code stay clean and maintainable over the long term. We sometimes refer to this as validating at the edge of the system.\n\nIn addition to keeping your code clean and free of endless checks and asserts, bear in mind that invalid data wandering through your system\n\nis a time bomb; the deeper it gets, the more damage it can do, and the fewer tools you have to respond to it.\n\nBack in Chapter 8, we said that the message bus was a great place to\n\nput cross-cutting concerns, and validation is a perfect example of that.\n\nHere’s how we might change our bus to perform validation for us:\n\nValidation\n\nclass MessageBus:\n\ndef handle_message(self, name: str, body: str): try: message_type = next(mt for mt in EVENT_HANDLERS if mt.__name__ == name) message = message_type.from_json(body) self.handle([message]) except StopIteration: raise KeyError(f\"Unknown message name {name}\") except ValidationError as e: logging.error( f'invalid message of type {name}\\n' f'{body}\\n' f'{e}'",
      "content_length": 1264,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 434,
      "content": ") raise e\n\nHere’s how we might use that method from our Flask API endpoint:\n\nAPI bubbles up validation errors (src/allocation/flask_app.py)\n\n@app.route(\"/change_quantity\", methods=['POST']) def change_batch_quantity(): try: bus.handle_message('ChangeBatchQuantity', request.body) except ValidationError as e: return bad_request(e) except exceptions.InvalidSku as e: return jsonify({'message': str(e)}), 400\n\ndef bad_request(e: ValidationError): return e.code, 400\n\nAnd here’s how we might plug it in to our asynchronous message processor:\n\nValidation errors when handling Redis messages\n\n(src/allocation/redis_pubsub.py)\n\ndef handle_change_batch_quantity(m, bus: messagebus.MessageBus): try: bus.handle_message('ChangeBatchQuantity', m) except ValidationError: print('Skipping invalid message') except exceptions.InvalidSku as e: print(f'Unable to change stock for missing sku {e}')\n\nNotice that our entrypoints are solely concerned with how to get a\n\nmessage from the outside world and how to report success or failure. Our message bus takes care of validating our requests and routing them",
      "content_length": 1091,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 435,
      "content": "to the correct handler, and our handlers are exclusively focused on the logic of our use case.\n\nTIP\n\nWhen you receive an invalid message, there’s usually little you can do but log the error and continue. At MADE we use metrics to count the number of messages a system receives, and how many of those are successfully processed, skipped, or invalid. Our monitoring tools will alert us if we see spikes in the numbers of bad messages.\n\nValidating Semantics\n\nWhile syntax is concerned with the structure of messages, semantics is the study of meaning in messages. The sentence “Undo no dogs from\n\nellipsis four” is syntactically valid and has the same structure as the sentence “Allocate one teapot to order five,\"” but it is meaningless.\n\nWe can read this JSON blob as an Allocate command but can’t successfully execute it, because it’s nonsense:\n\nA meaningless message\n\n{ \"orderid\": \"superman\", \"sku\": \"zygote\", \"qty\": -1 }\n\nWe tend to validate semantic concerns at the message-handler layer with a kind of contract-based programming:",
      "content_length": 1033,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 436,
      "content": "Preconditions (src/allocation/ensure.py)\n\n\"\"\" This module contains preconditions that we apply to our handlers. \"\"\"\n\nclass MessageUnprocessable(Exception):\n\ndef __init__(self, message): self.message = message\n\nclass ProductNotFound(MessageUnprocessable): \"\"\"\" This exception is raised when we try to perform an action on a product that doesn't exist in our database. \"\"\"\"\n\ndef __init__(self, message): super().__init__(message) self.sku = message.sku\n\ndef product_exists(event, uow): product = uow.products.get(event.sku) if product is None: raise ProductNotFound(event)\n\nWe use a common base class for errors that mean a message is invalid.\n\nUsing a specific error type for this problem makes it easier to report on and handle the error. For example, it’s easy to map ProductNotFound to a 404 in Flask.\n\nproduct_exists is a precondition. If the condition is False, we raise an error.\n\nThis keeps the main flow of our logic in the service layer clean and declarative:",
      "content_length": 967,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 437,
      "content": "Ensure calls in services (src/allocation/services.py)\n\n# services.py\n\nfrom allocation import ensure\n\ndef allocate(event, uow): line = mode.OrderLine(event.orderid, event.sku, event.qty) with uow: ensure.product_exists(uow, event)\n\nproduct = uow.products.get(line.sku) product.allocate(line) uow.commit()\n\nWe can extend this technique to make sure that we apply messages\n\nidempotently. For example, we want to make sure that we don’t insert a batch of stock more than once.\n\nIf we get asked to create a batch that already exists, we’ll log a\n\nwarning and continue to the next message:\n\nRaise SkipMessage exception for ignorable events (src/allocation/services.py)\n\nclass SkipMessage (Exception): \"\"\"\" This exception is raised when a message can't be processed, but there's no incorrect behavior. For example, we might receive the same message multiple times, or we might receive a message that is now out of date. \"\"\"\"\n\ndef __init__(self, reason): self.reason = reason\n\ndef batch_is_new(self, event, uow): batch = uow.batches.get(event.batchid)",
      "content_length": 1043,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 438,
      "content": "if batch is not None: raise SkipMessage(f\"Batch with id {event.batchid} already exists\")\n\nIntroducing a SkipMessage exception lets us handle these cases in a generic way in our message bus:\n\nThe bus now knows how to skip (src/allocation/messagebus.py)\n\nclass MessageBus:\n\ndef handle_message(self, message): try: ... except SkipMessage as e: logging.warn(f\"Skipping message {message.id} because {e.reason}\")\n\nThere are a couple of pitfalls to be aware of here. First, we need to be\n\nsure that we’re using the same UoW that we use for the main logic of our use case. Otherwise, we open ourselves to irritating concurrency\n\nbugs.\n\nSecond, we should try to avoid putting all our business logic into these precondition checks. As a rule of thumb, if a rule can be tested inside\n\nour domain model, then it should be tested in the domain model.\n\nValidating Pragmatics\n\nPragmatics is the study of how we understand language in context.\n\nAfter we have parsed a message and grasped its meaning, we still need to process it in context. For example, if you get a comment on a\n\npull request saying, “I think this is very brave,” it may mean that the reviewer admires your courage—unless they’re British, in which case,",
      "content_length": 1205,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 439,
      "content": "they’re trying to tell you that what you’re doing is insanely risky, and\n\nonly a fool would attempt it. Context is everything.\n\nVALIDATION RECAP\n\nValidation means different things to different people\n\nWhen talking about validation, make sure you’re clear about what you’re validating. We find it useful to think about syntax, semantics, and pragmatics: the structure of messages, the meaningfulness of messages, and the business logic governing our response to messages.\n\nValidate at the edge when possible\n\nValidating required fields and the permissible ranges of numbers is boring, and we want to keep it out of our nice clean codebase. Handlers should always receive only valid messages.\n\nOnly validate what you require\n\nUse the Tolerant Reader pattern: read only the fields your application needs and don’t overspecify their internal structure. Treating fields as opaque strings buys you a lot of flexibility.\n\nSpend time writing helpers for validation\n\nHaving a nice declarative way to validate incoming messages and apply preconditions to your handlers will make your codebase much cleaner. It’s worth investing time to make boring code easy to maintain.\n\nLocate each of the three types of validation in the right place\n\nValidating syntax can happen on message classes, validating semantics can happen in the service layer or on the message bus, and validating pragmatics belongs in the domain model.\n\nTIP\n\nOnce you’ve validated the syntax and semantics of your commands at the edges of your system, the domain is the place for the rest of your validation. Validation of pragmatics is often a core part of your business rules.",
      "content_length": 1632,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 440,
      "content": "In software terms, the pragmatics of an operation are usually managed\n\nby the domain model. When we receive a message like “allocate three million units of SCARCE-CLOCK to order 76543,” the message is syntactically valid and semantically valid, but we’re unable to comply because we don’t have the stock available.",
      "content_length": 314,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 441,
      "content": "Index\n\nSYMBOLS\n\n@abc.abstractmethod, The Repository in the Abstract\n\nA\n\nabstract base classes (ABCs)\n\nABC for the repository, The Repository in the Abstract\n\ndefining for notifications, Define the Abstract and Concrete Implementations\n\nswitching to typing.Protocol, Option 3: The UoW Publishes Events to the Message Bus\n\nusing duck typing and protocols instead of, The Repository in the Abstract\n\nusing for ports, What Is a Port and What Is an Adapter, in Python?\n\nabstract methods, The Repository in the Abstract\n\nabstractions, A Brief Interlude: On Coupling and Abstractions-Wrap- Up\n\nabstracting state to aid testability, Abstracting State Aids Testability-Abstracting State Aids Testability\n\nAbstractRepository, service function depending on, A Typical Service Function\n\nAbstractUnitOfWork, Unit of Work and Its Context Manager",
      "content_length": 831,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 442,
      "content": "choosing right abstraction, Choosing the Right Abstraction(s)- Implementing Our Chosen Abstractions\n\nexplicit dependencies are more abstract, Aren’t Explicit Dependencies Totally Weird and Java-y?\n\nimplementing chosen abstraction, Implementing Our Chosen Abstractions-Wrap-Up\n\nedge-to-edge testing with fakes and dependency injection, Testing Edge to Edge with Fakes and Dependency Injection- Testing Edge to Edge with Fakes and Dependency Injection\n\nnot using mock.patch for testing, Why Not Just Patch It Out?\n\nsimplifying interface between business logic and I/O, Wrap-Up\n\nusing to reduce coupling, A Brief Interlude: On Coupling and Abstractions\n\nadapters\n\nbuilding adapter and doing dependency injection for it, Building an Adapter “Properly”: A Worked Example-Wrap-Up\n\ndefining abstract and concrete implementations, Define the Abstract and Concrete Implementations\n\ndefined, What Is a Port and What Is an Adapter, in Python?\n\nDjango views, API: Django Views Are Adapters\n\nexercise for the reader, Figure Out How to Integration Test the Real Thing\n\nports-and-adapters inspired patterns, Part I Recap\n\nputting into folder, Putting Things in Folders to See Where It All Belongs",
      "content_length": 1181,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 443,
      "content": "Aggregate pattern, What Is an Aggregate?\n\naggregates\n\nabout, What Is an Aggregate?\n\nacting as consistency boundaries, Discussion: Events, Commands, and Error Handling\n\nand consistency boundaries recap, Wrap-Up\n\nchanging multiple aggregates in a request, Wrap-Up\n\nchoosing an aggregrate, Choosing an Aggregate-Choosing an Aggregate\n\nexercise for the reader, What About Performance?\n\nHistory aggregate recording orders and raising domain events, Discussion: Events, Commands, and Error Handling\n\nidentifying aggregates and bounded contexts, Identifying Aggregates and Bounded Contexts-An Event-Driven Approach to Go to Microservices via Strangler Pattern\n\none aggregrate = one repository, One Aggregate = One Repository\n\noptimistic concurrency with version numbers, Optimistic Concurrency with Version Numbers-Implementation Options for Version Numbers\n\nperformance and, What About Performance?\n\nProduct aggregate, Aggregates and Consistency Boundaries\n\npros and cons or trade-offs, Wrap-Up\n\nquery on repository returning single aggregate, Implementation",
      "content_length": 1052,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 444,
      "content": "raising events about, Discussion: Events, Commands, and Error Handling\n\nrepository keeping track of aggregates passing through it, Option 3: The UoW Publishes Events to the Message Bus\n\ntesting for data integrity rules, Testing for Our Data Integrity Rules-Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\ntesting Product object to raise events, The Model Raises Events\n\nUoW collecting events from and passing them to message bus, Wrap-Up\n\nallocate service\n\nallocating against all batches with, Choosing an Aggregate\n\nmoving to be a method on Product aggregate, Choosing an Aggregate\n\nAllocated event, Our New Outgoing Event\n\nAllocationRequired event, Refactoring Service Functions to Message Handlers\n\npassing to services.allocate, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nAnemic Domain anti-pattern, The DIP in Action\n\nAPIs\n\nadding API for adding a batch, Carrying the Improvement Through to the E2E Tests\n\nDjango views as adapters, API: Django Views Are Adapters\n\nend-to-end test of allocate API, A First End-to-End Test",
      "content_length": 1064,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 445,
      "content": "modifying API to work with events, A Temporary Ugly Hack: The Message Bus Has to Return Results\n\nusing repository directly in API endpoint, What Is the Trade-Off?\n\nwithout Unit of Work pattern, talking directly to three layers, Unit of Work Pattern\n\napplication services, Why Is Everything Called a Service?\n\narchitecture, summary diagram and table, Summary Diagram and Table-Summary Diagram and Table\n\nasynchronous messaging, temporal decoupling with, The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\natomic operations, Unit of Work Pattern\n\nUnit of Work as abstraction over, Wrap-Up\n\nusing Unit of Work to group operations into atomic unit, Examples: Using UoW to Group Multiple Operations into an Atomic Unit-Example 2: Change Batch Quantity\n\nB\n\nBall of Mud pattern, A Brief Interlude: On Coupling and Abstractions\n\ndistributed ball of mud and thinking in nouns, Distributed Ball of Mud, and Thinking in Nouns-Distributed Ball of Mud, and Thinking in Nouns\n\nseparating responsibilities, Separating Entangled Responsibilities\n\nBatchCreated event, Refactoring Service Functions to Message Handlers\n\nservices.add_batch as handler for, Imagining an Architecture Change: Everything Will Be an Event Handler",
      "content_length": 1222,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 446,
      "content": "batches\n\nallocating against all batches using domain service, Choosing an Aggregate\n\nasking Product to allocate against, Choosing an Aggregate\n\nbatch quantities changed means deallocate and reallocate, A New Requirement Leads Us to a New Architecture\n\ncollection of, Choosing an Aggregate\n\nBatchQuantityChanged event\n\nimplementing, Our New Event\n\ninvoking handler change_batch_quantity, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nBernhardt, Gary, Implementing Our Chosen Abstractions\n\nbootstrapping, Dependency Injection (and Bootstrapping)\n\nbootstrapping script, capabilities of, A Bootstrap Script\n\nchanging notifications dependency in bootstrap script, Define the Abstract and Concrete Implementations\n\ndependency injection and bootstrap recap, Wrap-Up\n\ndependency injection with, Aren’t Explicit Dependencies Totally Weird and Java-y?\n\ninitializing dependency injection in tests, Initializing DI in Our Tests\n\nusing in entrypoints, Using Bootstrap in Our Entrypoints\n\nusing to build message bus that talks to real notification class, Figure Out How to Integration Test the Real Thing",
      "content_length": 1115,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 447,
      "content": "bounded contexts, Choosing an Aggregate\n\nidentifying aggregates and, Identifying Aggregates and Bounded Contexts-An Event-Driven Approach to Go to Microservices via Strangler Pattern\n\nproduct concept and, Choosing an Aggregate\n\nbusiness logic\n\nabstractions simplifying interface with messy I/O, Wrap-Up\n\nseparating from state in code, Implementing Our Chosen Abstractions\n\nbusiness logic layer, What Is a Domain Model?\n\nbusiness rules\n\ninvariants, concurrency, and locks, Invariants, Concurrency, and Locks\n\ninvariants, constraints, and consistency, Invariants, Constraints, and Consistency\n\nC\n\nCelery tool, The Message Bus Maps Events to Handlers\n\nchange_batch_quantity\n\nhandler tests for, Test-Driving a New Handler\n\nimplementation, handler delegating to model layer, Implementation\n\nchoreography, Single Responsibility Principle\n\nclasses, dependency injection using, An Alternative Using Classes",
      "content_length": 898,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 448,
      "content": "classical mapping, Inverting the Dependency: ORM Depends on Model\n\nclosures\n\ndependency injection using, Preparing Handlers: Manual DI with Closures and Partials\n\ndifference from partial functions, Preparing Handlers: Manual DI with Closures and Partials\n\ncohesion, high, between coupled elements, A Brief Interlude: On Coupling and Abstractions\n\ncollaborators, The Unit of Work Collaborates with the Repository\n\ncollections, What Is an Aggregate?\n\nCommand Handler pattern, Wrap-Up\n\ncommand-query responsibility segregation (CQRS), Command-Query Responsibility Segregation (CQRS)-Wrap-Up\n\nbuilding read-only views into our data, Hold On to Your Lunch, Folks\n\nchanging read model implementation to use Redis, Changing Our Read Model Implementation Is Easy\n\ndenormalized copy of your data optimized for read operations, Time to Completely Jump the Shark\n\ndomain model not optimized for read operations, Your Domain Model Is Not Optimized for Read Operations\n\ndomain models for writing, Domain Models Are for Writing\n\nfull-blown CQRS versus simpler options, Wrap-Up\n\nPost/Redirect/Get pattern and CQS, Post/Redirect/Get and CQS",
      "content_length": 1124,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 449,
      "content": "read side and write side, Most Users Aren’t Going to Buy Your Furniture\n\nreads, Most Users Aren’t Going to Buy Your Furniture\n\nconsistency of, Most Users Aren’t Going to Buy Your Furniture\n\nrebuilding view model from scratch, Updating a Read Model Table Using an Event Handler\n\nSELECT N+1 and other performance problems, SELECT N+1 and Other Performance Considerations\n\nsimple view using existing repository, “Obvious” Alternative 1: Using the Existing Repository\n\ntesting views, Testing CQRS Views\n\ntrade-offs for view model options, Wrap-Up\n\nupdating read model table using event handler, Time to Completely Jump the Shark\n\nview that uses the ORM, “Obvious” Alternative 2: Using the ORM\n\ncommands, Commands and Command Handler-Wrap-Up\n\ncommand flow to reserve stock, confirm reservation, dispatch goods, and make customer VIP, Distributed Ball of Mud, and Thinking in Nouns\n\ncommand flow when warehouse knows stock is damaged, Distributed Ball of Mud, and Thinking in Nouns\n\ncommand flow with error, Error Handling in Distributed Systems\n\ncommand handler logic in message bus, Message Bus Is Given Handlers at Runtime",
      "content_length": 1119,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 450,
      "content": "events versus, Commands and Events-Commands and Events\n\nevents, commands, and error handling, Discussion: Events, Commands, and Error Handling-Discussion: Events, Commands, and Error Handling\n\nrecovering from errors synchronously, Recovering from Errors Synchronously\n\nexception handling, Differences in Exception Handling\n\nhandlers for, Differences in Exception Handling\n\nin our system now, Commands and Events\n\nprogram output as list of commands, Choosing the Right Abstraction(s)\n\nsplitting commands and events, trade-offs, Wrap-Up\n\ncommits\n\ncommit method, The Real Unit of Work Uses SQLAlchemy Sessions\n\nexplicit tests for, Explicit Tests for Commit/Rollback Behavior\n\nexplicit versus implicit, Explicit Versus Implicit Commits\n\ncomponent diagram at end of Part One, Part I Recap\n\ncomposition over inheritance in TrackingRepository wrapper class, Option 3: The UoW Publishes Events to the Message Bus\n\ncomposition root, Dependency Injection (and Bootstrapping), Aren’t Explicit Dependencies Totally Weird and Java-y?\n\nconcurrency, Invariants, Concurrency, and Locks\n\naggregates and concurrency issues, Wrap-Up",
      "content_length": 1113,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 451,
      "content": "allowing for greatest degree of, What Is an Aggregate?\n\nenforcing rules using database transactions, Enforcing Concurrency Rules by Using Database Transaction Isolation Levels\n\nintegration test for, Testing for Our Data Integrity Rules\n\nnot provided by message bus implementation, The Message Bus Maps Events to Handlers\n\noptimistic concurrency with version numbers, Optimistic Concurrency with Version Numbers-Implementation Options for Version Numbers\n\npessimistic concurrency example, SELECT FOR UPDATE, Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nreproducing behavior with time.sleep function, Testing for Our Data Integrity Rules\n\nconnascence, Error Handling in Distributed Systems\n\nconsistency, Invariants, Constraints, and Consistency\n\nattainment of read consistency, Most Users Aren’t Going to Buy Your Furniture\n\neventually consistent reads, Most Users Aren’t Going to Buy Your Furniture\n\nconsistency boundaries, Aggregates and Consistency Boundaries, What Is an Aggregate?\n\naggregates acting as, Discussion: Events, Commands, and Error Handling",
      "content_length": 1070,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 452,
      "content": "microservices as, The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\nrecap, Wrap-Up\n\nconstraints, Invariants, Constraints, and Consistency\n\ncontext manager, Unit of Work Pattern\n\nstarting Unit of Work as, The Unit of Work Collaborates with the Repository\n\nUnit of Work and, Unit of Work and Its Context Manager-Fake Unit of Work for Testing\n\ncontrol flow, using exceptions for, The Model Raises Events\n\ncoupling, A Brief Interlude: On Coupling and Abstractions\n\navoiding inappropriate coupling, Error Handling in Distributed Systems\n\ndisadvantages of, A Brief Interlude: On Coupling and Abstractions\n\ndomain logic coupled with I/O, Abstracting State Aids Testability\n\nfailure cascade as temporal coupling, Error Handling in Distributed Systems\n\nin tests that use mocks, Why Not Just Patch It Out?\n\nreducing by abstracting away details, A Brief Interlude: On Coupling and Abstractions\n\nseparating what you want to do from how to do it, Choosing the Right Abstraction(s)\n\ntemporal decoupling using asynchronous messaging, The Alternative: Temporal Decoupling Using Asynchronous",
      "content_length": 1091,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 453,
      "content": "Messaging\n\ntrade-off between design feedback and, On Deciding What Kind of Tests to Write\n\nCQRS (see command-query responsibility segregation)\n\nCQS (command-query separation), Post/Redirect/Get and CQS\n\nCRUD wrapper around a database, Part I Recap\n\nCSV over SMTP architecture, Why Not Just Run Everything in a Spreadsheet?\n\nCSVs, doing everything with, Swapping Out the Infrastructure: Do Everything with CSVs-Implementing a Repository and Unit of Work for CSVs\n\nD\n\ndata access, applying dependency inversion principle to, Applying the DIP to Data Access\n\ndata integrity\n\nissues arising from splitting operation across two UoWs, Implementing Our New Requirement\n\ntesting for, Testing for Our Data Integrity Rules-Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\ndata storage, Repository pattern and, Repository Pattern\n\ndatabases\n\nSQLAlchemy adding session for Unit of Work, The Real Unit of Work Uses SQLAlchemy Sessions\n\ntesting allocations persisted to database, The Straightforward Implementation",
      "content_length": 1011,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 454,
      "content": "testing transactions against real database, Explicit Tests for Commit/Rollback Behavior\n\nUnit of Work pattern managing state for, Unit of Work Pattern\n\ndataclasses\n\nevents, Events Are Simple Dataclasses\n\nuse for message types, Recovering from Errors Synchronously\n\nuse for value objects, Dataclasses Are Great for Value Objects\n\ndeallocate service, building (exerise), A Typical Service Function\n\ndependencies\n\nabstract dependencies of service layer, The DIP in Action\n\ntesting, The DIP in Action\n\ncircular dependencies between event handlers, Wrap-Up\n\ndepending on abstractions, A Typical Service Function\n\nedge-to-edge testing with dependency injection, Testing Edge to Edge with Fakes and Dependency Injection-Testing Edge to Edge with Fakes and Dependency Injection\n\nkeeping all domain dependencies in fixture functions, Mitigation: Keep All Domain Dependencies in Fixture Functions\n\nnone in domain model, Applying the DIP to Data Access\n\nreal service layer dependencies at runtime, The DIP in Action\n\nservice layer dependency on abstract UoW, Using the UoW in the Service Layer\n\nUoW no longer dependent on message bus, The Message Bus Now Collects Events from the UoW",
      "content_length": 1172,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 455,
      "content": "dependency chains, A Bootstrap Script\n\ndependency injection, Dependency Injection (and Bootstrapping)-An Alternative Using Classes\n\nby inspecting function signatures, A Bootstrap Script\n\nexplicit dependencies are better than implicit dependencies, Aren’t Explicit Dependencies Totally Weird and Java-y?\n\nimplicit versus explicit dependencies, Implicit Versus Explicit Dependencies\n\nmanual creation of partial functions inline, A Bootstrap Script\n\nmanual DI with closures or partial functions, Preparing Handlers: Manual DI with Closures and Partials\n\nrecap of DI and bootstrap, Wrap-Up\n\nusing classes, An Alternative Using Classes\n\nusing DI framework, A Bootstrap Script\n\ndependency inversion principle, Applying the DIP to Data Access, Wrap-Up\n\ndeclaring explicit dependency as example of, Aren’t Explicit Dependencies Totally Weird and Java-y?\n\nORM depends on the data model, Inverting the Dependency: ORM Depends on Model\n\ndictionaries\n\ndictionary of hashes to paths, Implementing Our Chosen Abstractions\n\nfor filesystem operations, Choosing the Right Abstraction(s)",
      "content_length": 1069,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 456,
      "content": "HANDLERS dicts for commands and events, Differences in Exception Handling\n\ndirectory structure, putting project into folders, Putting Things in Folders to See Where It All Belongs\n\nDistributed Ball of Mud anti-pattern\n\nand thinking in nouns, Distributed Ball of Mud, and Thinking in Nouns-Distributed Ball of Mud, and Thinking in Nouns\n\navoiding, The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\nDjango, Repository and Unit of Work Patterns with Django-Steps Along the Way\n\napplying patterns to Django app, What to Do If You Already Have Django\n\nsteps along the way, Steps Along the Way\n\ninstalling, Repository and Unit of Work Patterns with Django\n\nORM example, The “Normal” ORM Way: Model Depends on ORM\n\nRepository pattern with, Repository Pattern with Django-Custom Methods on Django ORM Classes to Translate to/from Our Domain Model\n\nUnit of Work pattern with, Unit of Work Pattern with Django-Unit of Work Pattern with Django\n\nusing, difficulty of, Why Was This All So Hard?\n\nviews are adapters, API: Django Views Are Adapters\n\nDocker dev environment with real fake email server, Figure Out How to Integration Test the Real Thing",
      "content_length": 1153,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 457,
      "content": "domain driven design (DDD), Domain Modeling, What Is a Domain Model?\n\n(see also domain model; domain modeling)\n\nAggregate pattern, What Is an Aggregate?\n\nbounded contexts, Choosing an Aggregate\n\nchoosing the right aggregate, references on, Wrap-Up\n\ndomain, defined, What Is a Domain Model?\n\nRepository pattern and, What Is the Trade-Off?\n\nDomain Events pattern, Events and the Message Bus\n\ndomain exceptions, Exceptions Can Express Domain Concepts Too\n\ndomain language, Exploring the Domain Language\n\ndomain layer\n\nfully decoupling service layer from, Fully Decoupling the Service-Layer Tests from the Domain-Adding a Missing Service\n\ntests moving to service layer, Should Domain Layer Tests Move to the Service Layer?\n\nreasons for, Should Domain Layer Tests Move to the Service Layer?\n\ndomain model, Reminder: Our Model-Introducing the Repository Pattern\n\ndeciding whether to write tests against, On Deciding What Kind of Tests to Write\n\nDjango custom ORM methods for conversion, Custom Methods on Django ORM Classes to Translate to/from Our Domain Model",
      "content_length": 1055,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 458,
      "content": "email sending code in, avoiding, And Let’s Not Make a Mess of Our Model Either\n\nevents from, passing to message bus in service layer, Option 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus\n\nfolder for, Putting Things in Folders to See Where It All Belongs\n\ngetting benefits of rich model, The DIP in Action\n\ninvariants, constraints, and consistency, Invariants, Constraints, and Consistency\n\nmaintaining small core of tests written against, Wrap-Up\n\nnew method on, change_batch_quantity, A New Method on the Domain Model\n\nnot optimized for read operations, Your Domain Model Is Not Optimized for Read Operations\n\npersisting, Persisting Our Domain Model\n\nraising events, The Model Raises Events\n\nraising events and service layer passing them to message bus, Wrap-Up\n\ntrade-offs as a diagram, Wrap-Up\n\ntranslating to relational database\n\nnormal ORM way, model depends on ORM, The “Normal” ORM Way: Model Depends on ORM\n\nORM depends on the model, Inverting the Dependency: ORM Depends on Model",
      "content_length": 1024,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 459,
      "content": "using spreadsheets instead of, Why Not Just Run Everything in a Spreadsheet?\n\nwriting data, Domain Models Are for Writing\n\nwriting tests against, High and Low Gear\n\ndomain modeling, Domain Modeling-Exceptions Can Express Domain Concepts Too\n\ndomain language, Exploring the Domain Language\n\nfunctions for domain services, Not Everything Has to Be an Object: A Domain Service Function-Exceptions Can Express Domain Concepts Too\n\nunit testing domain models, Unit Testing Domain Models-Value Objects and Entities\n\ndataclasses for value objects, Dataclasses Are Great for Value Objects\n\nvalue objects and entities, Value Objects and Entities\n\ndomain services, Not Everything Has to Be an Object: A Domain Service Function, Why Is Everything Called a Service?\n\nfunction for, Not Everything Has to Be an Object: A Domain Service Function\n\ndriven adapters, Putting Things in Folders to See Where It All Belongs\n\nduck typing, The Repository in the Abstract\n\nfor ports, What Is a Port and What Is an Adapter, in Python?\n\nE\n\nE2E tests (see end-to-end tests)",
      "content_length": 1046,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 460,
      "content": "eager loading, SELECT N+1 and Other Performance Considerations\n\nedge-to-edge testing, Implementing Our Chosen Abstractions-Testing Edge to Edge with Fakes and Dependency Injection\n\nEffective Aggregate Design (Vernon), Wrap-Up\n\nemail alerts, sending when out of stock, Avoiding Making a Mess-Or the Service Layer!\n\nend-to-end tests\n\naiming for one test per feature, Wrap-Up\n\ndecoupling of service layer from domain, carrying through to, Carrying the Improvement Through to the E2E Tests\n\nof allocate API, A First End-to-End Test\n\nreplacement with unit tests, Why Not Just Patch It Out?\n\n__enter__ and __exit__ magic methods, Unit of Work and Its Context Manager, The Real Unit of Work Uses SQLAlchemy Sessions\n\nentities\n\ndefined, Value Objects and Entities\n\nidentity equality, Value Objects and Entities\n\nvalue objects versus, Exceptions Can Express Domain Concepts Too\n\nentrypoints, Putting Things in Folders to See Where It All Belongs\n\n__eq__magic method, Value Objects and Entities\n\nequality operators, implementing on entities, Value Objects and Entities\n\nerror handling",
      "content_length": 1074,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 461,
      "content": "counting as a feature, Wrap-Up\n\nevents, commands, and, Discussion: Events, Commands, and Error Handling-Discussion: Events, Commands, and Error Handling\n\nin distributed systems, Error Handling in Distributed Systems- The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\nerrors, recovering from synchronously, Recovering from Errors Synchronously\n\nEvans, Eric, What Is an Aggregate?\n\nevent handlers\n\nimagined architecture in which everything is an event handler, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nin message bus, Message Bus Is Given Handlers at Runtime\n\nmanaging updates to read model, Changing Our Read Model Implementation Is Easy\n\nupdating read model table using, Time to Completely Jump the Shark\n\nevent storming, A New Requirement Leads Us to a New Architecture\n\nevent-driven architecture\n\ngoing to microservices via Strangler pattern, An Event-Driven Approach to Go to Microservices via Strangler Pattern-An Event-Driven Approach to Go to Microservices via Strangler Pattern",
      "content_length": 1031,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 462,
      "content": "using events to integrate microservices, Event-Driven Architecture: Using Events to Integrate Microservices-Wrap-Up\n\nevents\n\nchanging schema over time, Footguns\n\ncommands versus, Commands and Events-Differences in Exception Handling\n\nevents, commands, and error handling, Discussion: Events, Commands, and Error Handling-Discussion: Events, Commands, and Error Handling\n\ninternal versus external, Internal Versus External Events\n\nsplitting command and events, trade-offs, Wrap-Up\n\nevents and the message bus, Events and the Message Bus-Wrap-Up\n\ndomain events and message bus recap, Wrap-Up\n\ndomain model raising events, The Model Raises Events\n\nevents as simple dataclasses, Events Are Simple Dataclasses\n\nevents flowing through the system, Events and the Message Bus\n\nmessage bus mapping events to handlers, The Message Bus Maps Events to Handlers\n\npros and cons or trade-offs, Wrap-Up\n\nrecording events, The Model Records Events\n\nsending email alerts when out of stock, Avoiding Making a Mess- Or the Service Layer!\n\navoiding messing up domain model, And Let’s Not Make a Mess of Our Model Either",
      "content_length": 1098,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 463,
      "content": "avoiding messing up web controllers, First, Let’s Avoid Making a Mess of Our Web Controllers\n\nout of place in the service layer, Or the Service Layer!\n\nviolating the single responsibility principle, Single Responsibility Principle\n\nservice layer raising its own events, Option 2: The Service Layer Raises Its Own Events\n\nservice layer with explicit message bus, Option 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus\n\ntransforming our app into message processor, Going to Town on the Message Bus-Why Have We Achieved?\n\nimagined architecture, everything will be an event handler, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nimplementing the new requirement, Implementing Our New Requirement-Test-Driving a New Handler\n\nmodifying API to work with events, A Temporary Ugly Hack: The Message Bus Has to Return Results\n\nnew requirement and new architecture, A New Requirement Leads Us to a New Architecture\n\nrefactoring service functions to message handlers, Refactoring Service Functions to Message Handlers\n\ntemporary hack, message bus returning results, A Temporary Ugly Hack: The Message Bus Has to Return Results\n\ntest driving new handler, Test-Driving a New Handler",
      "content_length": 1227,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 464,
      "content": "tests writtern to in terms of events, Our Tests Are All Written in Terms of Events Too\n\nunit testing event handlers with fake message bus, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nwhole app as message bus, trade-offs, Why Have We Achieved?\n\nUoW publishes events to message bus, Option 3: The UoW Publishes Events to the Message Bus\n\neventually consistent reads, Most Users Aren’t Going to Buy Your Furniture\n\nexception handling, differences for events and commands, Differences in Exception Handling\n\nexceptions\n\nexpressing domain concepts, Exceptions Can Express Domain Concepts Too\n\nusing for control flow, The Model Raises Events\n\nexternal events, The Message Bus Maps Events to Handlers, Event- Driven Architecture: Using Events to Integrate Microservices-Wrap- Up\n\nextreme programming (XP), exhortation to listen to the code, On Deciding What Kind of Tests to Write\n\nF\n\nfaking\n\nFakeNotifications for unit testing, Make a Fake Version for Your Tests",
      "content_length": 990,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 465,
      "content": "FakeRepository, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\nadding fixture function on, Mitigation: Keep All Domain Dependencies in Fixture Functions\n\nnew query type on, Implementation\n\nusing to unit test the service layer, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\nfakes versus mocks, Why Not Just Patch It Out?\n\nFakeSession, using to unit test the service layer, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\nFakeUnitOfWork for service layer testing, Fake Unit of Work for Testing\n\nfaking I/O in edge-to-edge test, Testing Edge to Edge with Fakes and Dependency Injection\n\ntweaking fakes in service layer to call super and implement underscorey methods, Option 3: The UoW Publishes Events to the Message Bus\n\nfilesystems\n\nwriting code to synchronize source and target directories, Abstracting State Aids Testability-Abstracting State Aids Testability\n\nchoosing right abstraction, Choosing the Right Abstraction(s)-Implementing Our Chosen Abstractions\n\nimplementing chosen abstraction, Implementing Our Chosen Abstractions-Wrap-Up",
      "content_length": 1112,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 466,
      "content": "fixture functions, keeping all domain dependencies in, Mitigation: Keep All Domain Dependencies in Fixture Functions\n\nFlask framework, Some Pseudocode: What Are We Going to Need?\n\nAPI endpoint, What Is the Trade-Off?\n\ncalling bootstrap in entrypoints, Using Bootstrap in Our Entrypoints\n\nendpoint for viewing allocations, Post/Redirect/Get and CQS\n\nFlask API and service layer, Our First Use Case: Flask API and Service Layer-The DIP in Action\n\napp delegating to service layer, A Typical Service Function\n\nconnecting the app to real world, Connecting Our Application to the Real World\n\ndifferent types of services, Why Is Everything Called a Service?\n\nend-to-end tests for happy and unhappy paths, A Typical Service Function\n\nerror conditions requiring database checks, Error Conditions That Require Database Checks\n\nfirst API end-to-end test, A First End-to-End Test-A First End-to-End Test\n\nfirst cut of the app, The Straightforward Implementation-The Straightforward Implementation\n\nintroducing service layer and fake repo to unit test it, Introducing a Service Layer, and Using FakeRepository to Unit Test It-A Typical Service Function",
      "content_length": 1139,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 467,
      "content": "putting project into folders, Putting Things in Folders to See Where It All Belongs\n\nservice layer benefits, Wrap-Up\n\nservice layer dependencies, The DIP in Action\n\nservice layer pros and cons, The DIP in Action\n\ntypical service layer function, A Typical Service Function\n\nputting API endpoint in front of allocate domain service, Connecting Our Application to the Real World\n\nFowler, Martin, Why Not Just Patch It Out?, Wrap-Up\n\nFreeman, Steve, Why Not Just Patch It Out?\n\nFunctional Core, Imperative Shell (FCIS), Implementing Our Chosen Abstractions\n\nfunctions, Exceptions Can Express Domain Concepts Too\n\nfor domain services, Not Everything Has to Be an Object: A Domain Service Function\n\nservice layer, A Typical Service Function\n\nG\n\n\"Global Complexity, Local Simplicity\" post, Wrap-Up\n\n__gt__ magic method, Python’s Magic Methods Let Us Use Our Models with Idiomatic Python\n\nH\n\nhandlers",
      "content_length": 892,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 468,
      "content": "event and command handlers in message bus, Message Bus Is Given Handlers at Runtime\n\nnew HANDLERS dicts for commands and events, Differences in Exception Handling\n\n__hash__ magic method, Value Objects and Entities\n\nhashing a file, Abstracting State Aids Testability\n\ndictionary of hashes to paths, Choosing the Right Abstraction(s)\n\nhoisting I/O, Why Not Just Patch It Out?\n\nI\n\nI/O\n\ndisentangling details from program logic, Implementing Our Chosen Abstractions\n\ndomain logic tightly coupled to, Abstracting State Aids Testability\n\nsimplifying interface with business logic using abstractions, Wrap-Up\n\nidempotent message handling, Footguns\n\nidentity equality (entities), Value Objects and Entities\n\nimplicit versus explicit commits, Explicit Versus Implicit Commits\n\nimporting dependenies, Aren’t Explicit Dependencies Totally Weird and Java-y?\n\ninheritance, avoiding use of with wrapper class, Option 3: The UoW Publishes Events to the Message Bus\n\nintegration tests",
      "content_length": 968,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 469,
      "content": "for concurrency behavior, Testing for Our Data Integrity Rules\n\ntest-driving Unit of Work with, Test-Driving a UoW with Integration Tests\n\ninterfaces, Python and, What Is a Port and What Is an Adapter, in Python?\n\ninvariants\n\ninvariants, concurrency, and locks, Invariants, Concurrency, and Locks\n\ninvariants, constraints, and consistency, Invariants, Constraints, and Consistency\n\nprotecting while allowing concurrency, What Is an Aggregate?\n\ninward-facing adapters, Putting Things in Folders to See Where It All Belongs\n\nisolation levels (transaction), Enforcing Concurrency Rules by Using Database Transaction Isolation Levels\n\nJ\n\nJung, Ed, Why Not Just Patch It Out?\n\nK\n\nkatas, A Brief Interlude: On Coupling and Abstractions\n\nL\n\nlayered architecture, Applying the DIP to Data Access\n\ncase study, layering an overgrown system, Separating Entangled Responsibilities",
      "content_length": 868,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 470,
      "content": "locks on database tables, Invariants, Concurrency, and Locks\n\noptimistic locking, Optimistic Concurrency with Version Numbers, Optimistic Concurrency with Version Numbers\n\npessimistic locking, Optimistic Concurrency with Version Numbers\n\nLondon-school versus classic-style TDD, Why Not Just Patch It Out?\n\nM\n\nmagic methods\n\nallowing use of domain model with idiomatic Python, Python’s Magic Methods Let Us Use Our Models with Idiomatic Python\n\n__enter__ and __exit__, Unit of Work and Its Context Manager\n\n__eq__, Value Objects and Entities\n\n__hash__, Value Objects and Entities\n\nMagicMock objects, Why Not Just Patch It Out?\n\nmappers, Inverting the Dependency: ORM Depends on Model\n\nmessage brokers, Using a Redis Pub/Sub Channel for Integration\n\nmessage bus\n\nabstract message bus and its real and fake versions, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nbefore, message buse as optional add-on, Going to Town on the Message Bus\n\nCelery and, The Message Bus Maps Events to Handlers",
      "content_length": 1018,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 471,
      "content": "class given handlers at runtime, Message Bus Is Given Handlers at Runtime\n\ndispatching events and commands differently, Differences in Exception Handling\n\nevent and command handler logic staying the same, Message Bus Is Given Handlers at Runtime\n\ngetting custom with overridden bootstrap defaults, Initializing DI in Our Tests\n\nhandler publishing outgoing event, Our New Outgoing Event\n\nhandle_event method, Recovering from Errors Synchronously\n\nhandle_event with retries, Recovering from Errors Synchronously\n\nmapping events to handlers, The Message Bus Maps Events to Handlers\n\nnow collecting events from UoW, The Message Bus Now Collects Events from the UoW\n\nnow the main entrypoint to service layer, Going to Town on the Message Bus\n\npros and cons or trade-offs, Wrap-Up\n\nrecap, Wrap-Up\n\nRedis pub/sub listener as thin adapter around, Redis Is Another Thin Adapter Around Our Message Bus\n\nreturning results in temporary hack, A Temporary Ugly Hack: The Message Bus Has to Return Results\n\nservice layer raising events and calling messagebus.handle, Option 2: The Service Layer Raises Its Own Events",
      "content_length": 1101,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 472,
      "content": "service layer with explicit message bus, Option 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus\n\nUnit of Work publishing events to, Option 3: The UoW Publishes Events to the Message Bus\n\nunit testing event handlers with fake message bus, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nwhole app as, trade-offs, Why Have We Achieved?\n\nwiring up new event handlers to, A New Method on the Domain Model\n\nMessage Bus pattern, Events and the Message Bus\n\nmessaging\n\nasynchronous, temporal decoupling with, The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\nidempotent message handling, Footguns\n\nreliable messaging is hard, Footguns\n\nusing Redis pub/sub channel for microservices integration, Using a Redis Pub/Sub Channel for Integration\n\nmicroservices\n\nbounded contexts and, Choosing an Aggregate\n\nevent-based integration, Event-Driven Architecture: Using Events to Integrate Microservices-Wrap-Up\n\ndistributed Ball of Mud and thinking in nouns, Distributed Ball of Mud, and Thinking in Nouns-Distributed Ball of Mud, and Thinking in Nouns",
      "content_length": 1117,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 473,
      "content": "error handling in distributed systems, Error Handling in Distributed Systems-The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\ntemporal decoupling using asynchronous messaging, The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\ntesting with end-to-end test, Test-Driving It All Using an End-to-End Test-Internal Versus External Events\n\ntrade-offs, Wrap-Up\n\nusing Redis pub/sub channel for ntegration, Using a Redis Pub/Sub Channel for Integration\n\nevent-driven approach, using Strangler pattern, An Event-Driven Approach to Go to Microservices via Strangler Pattern-An Event-Driven Approach to Go to Microservices via Strangler Pattern\n\nminimum viable product, Persisting Our Domain Model\n\nmock.patch method, Why Not Just Patch It Out?, Aren’t Explicit Dependencies Totally Weird and Java-y?\n\nmocking\n\navoiding use of mock.patch, Why Not Just Patch It Out?\n\ndon't mock what you don't own, Fake Unit of Work for Testing\n\nmocks versus fakes, Why Not Just Patch It Out?\n\novermocked tests, pitfalls of, Why Not Just Patch It Out?\n\n\"Mocks Aren't Stubs\" (Fowler), Why Not Just Patch It Out?\n\nmodel (domain), What Is a Domain Model?",
      "content_length": 1158,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 474,
      "content": "N\n\nnamed tuples, Dataclasses Are Great for Value Objects\n\n(see also dataclasses)\n\nnouns, splitting system into, Distributed Ball of Mud, and Thinking in Nouns-Distributed Ball of Mud, and Thinking in Nouns\n\nO\n\nobject neighborhoods, The Unit of Work Collaborates with the Repository\n\nobject-oriented composition, Why Not Just Patch It Out?\n\nobject-oriented design principles, Exceptions Can Express Domain Concepts Too\n\nobject-relational mappers (ORMs), The “Normal” ORM Way: Model Depends on ORM\n\nassociating right batches with Product objects, One Aggregate = One Repository\n\nDjango ORM example, The “Normal” ORM Way: Model Depends on ORM\n\nDjango, custom methods to translate to/from domain model, Custom Methods on Django ORM Classes to Translate to/from Our Domain Model\n\nORM depends on the data model, Inverting the Dependency: ORM Depends on Model\n\ntesting the ORM, Inverting the Dependency: ORM Depends on Model\n\norm.start_mappers function, A Bootstrap Script",
      "content_length": 965,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 475,
      "content": "Repository pattern and, What Is the Trade-Off?\n\nSELECT N+1 performance problem, SELECT N+1 and Other Performance Considerations\n\nsimple view using the ORM, “Obvious” Alternative 2: Using the ORM\n\nSQLAlchemy, model depends on ORM, The “Normal” ORM Way: Model Depends on ORM\n\nonion architecture, Applying the DIP to Data Access\n\noptimistic concurrency with version numbers, Optimistic Concurrency with Version Numbers-Implementation Options for Version Numbers\n\norchestration, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\nchanging to choreography, Single Responsibility Principle\n\nusing application service, Why Is Everything Called a Service?\n\norchestration layer (see service layer)\n\nOutbox pattern, Footguns\n\nP\n\npartial functions\n\ndependency injection with, Preparing Handlers: Manual DI with Closures and Partials\n\ndifference from closures, Preparing Handlers: Manual DI with Closures and Partials\n\nmanually creating inline, A Bootstrap Script\n\npatterns, deciding whether you need to use them, Part I Recap",
      "content_length": 1034,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 476,
      "content": "PEP 544 protocols, The Repository in the Abstract\n\nperformance\n\nconsistency boundaries and, Aggregates and Consistency Boundaries, Wrap-Up\n\nimpact of using aggregates, Choosing an Aggregate, What About Performance?\n\npersistence ignorance, The “Normal” ORM Way: Model Depends on ORM\n\ntrade-offs, Wrap-Up\n\npessimistic concurrency, Optimistic Concurrency with Version Numbers\n\nexample, SELECT FOR UPDATE, Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nports\n\ndefined, What Is a Port and What Is an Adapter, in Python?\n\nports-and-adapters inspired patterns, Part I Recap\n\nputting in folder with adapters, Putting Things in Folders to See Where It All Belongs\n\nPost/Redirect/Get pattern, Post/Redirect/Get and CQS\n\ncommand-query separation (CQS), Post/Redirect/Get and CQS\n\nPostgreSQL\n\nAnti-Patterns: Read-Modify-Write Cycles, Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\ndocumentation for transaction isolation levels, Enforcing Concurrency Rules by Using Database Transaction Isolation",
      "content_length": 1010,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 477,
      "content": "Levels\n\nmanaging concurrency issues, Optimistic Concurrency with Version Numbers\n\nSERIALIZABLE transaction isolation level, Optimistic Concurrency with Version Numbers\n\npreparatory refactoring workflow, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nprimitives\n\nmoving from domain objects to, in service layer, Refactoring Service Functions to Message Handlers\n\nprimitive obsession, Refactoring Service Functions to Message Handlers\n\nProduct object, Aggregates and Consistency Boundaries\n\nacting as consistency boundary, Discussion: Events, Commands, and Error Handling\n\nasking Product to allocate against its batches, Choosing an Aggregate\n\ncode for, Choosing an Aggregate\n\nservice layer using, One Aggregate = One Repository\n\ntwo transactions attempting concurrent update on, Optimistic Concurrency with Version Numbers\n\nversion numbers implemented on, Implementation Options for Version Numbers\n\nProductRepository object, One Aggregate = One Repository\n\nprojects",
      "content_length": 989,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 478,
      "content": "organizing into folders, Putting Things in Folders to See Where It All Belongs\n\ntemplate project structure, A Template Project Structure-Wrap- Up\n\nprotocols, abstract base classes, duck typing, and, The Repository in the Abstract\n\npublish-subscribe system\n\nmessage bus as\n\nhandlers subscribed to receive events, The Message Bus Maps Events to Handlers\n\npublishing step, Option 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus\n\nusing Redis pub/sub channel for microservices integration, Using a Redis Pub/Sub Channel for Integration\n\nPyCon talk on Mocking Pitfalls, Why Not Just Patch It Out?\n\npytest\n\n@pytest.skip, What About Performance?\n\nfixtures, Abstracting State Aids Testability\n\npytest-django plug-in, Repository Pattern with Django, Why Was This All So Hard?\n\nsession argument, Inverting the Dependency: ORM Depends on Model\n\nQ\n\nqueries, Command-Query Responsibility Segregation (CQRS)",
      "content_length": 926,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 479,
      "content": "(see also command-query responsibility segregation)\n\nquestions from tech reviewers, Questions Our Tech Reviewers Asked That We Couldn’t Work into Prose-Footguns\n\nR\n\nread-modify-write failure mode, Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nreallocate service function, Example 1: Reallocate\n\nreallocation\n\nsequence diagram for flow, Implementing Our New Requirement\n\ntesting in isolation using fake message bus, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nRedis pub/sub channel, using for microservices integration, Using a Redis Pub/Sub Channel for Integration\n\ntesting pub/sub model, Test-Driving It All Using an End-to-End Test\n\npublishing outgoing event, Our New Outgoing Event\n\nRedis as thin adapter around message bus, Redis Is Another Thin Adapter Around Our Message Bus\n\nRedis, changing read model implementation to use, Changing Our Read Model Implementation Is Easy\n\nrepositories\n\nadding list method to existing repository object, Hold On to Your Lunch, Folks\n\nCSV-based repository, Implementing a Repository and Unit of Work for CSVs",
      "content_length": 1095,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 480,
      "content": "new query type on our repository, Implementation\n\none aggregrate = one repository, One Aggregate = One Repository\n\nrepository keeping track of aggregates passing through it, Option 3: The UoW Publishes Events to the Message Bus\n\nservice layer function depending on abstract repository, A Typical Service Function\n\nsimple view using existing repository, “Obvious” Alternative 1: Using the Existing Repository\n\nTrackerRepository wrapper class, Option 3: The UoW Publishes Events to the Message Bus\n\nUnit of Work collaborating with, The Unit of Work Collaborates with the Repository\n\nRepository pattern, Repository Pattern, Introducing the Repository Pattern-Wrap-Up\n\nand persistence ignorance, trade-offs, Wrap-Up\n\nbuilding fake repository for tests, Building a Fake Repository for Tests Is Now Trivial!\n\nORMs and, What Is the Trade-Off?\n\nrecap of important points, Wrap-Up\n\nsimplest possible repository, The Repository in the Abstract\n\ntesting the repository with retrieving a complex object, What Is the Trade-Off?\n\ntesting the repository with saving an object, What Is the Trade- Off?",
      "content_length": 1085,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 481,
      "content": "trade-offs, What Is the Trade-Off?\n\ntypical repository, What Is the Trade-Off?\n\nusing repository directly in API endpoint, What Is the Trade-Off?\n\nwith Django, Repository Pattern with Django-Custom Methods on Django ORM Classes to Translate to/from Our Domain Model\n\nresources, additional required reading, More Required Reading\n\nresponsibilities of code, Choosing the Right Abstraction(s)\n\nseparating responsibilities, Separating Entangled Responsibilities\n\ncase study, layering overgrown system, Separating Entangled Responsibilities\n\nretries\n\nmessage bus handle_event with, Recovering from Errors Synchronously\n\noptimistic concurrency control and, Optimistic Concurrency with Version Numbers\n\nTenacity library for, Recovering from Errors Synchronously\n\nRhodes, Brandon, Why Not Just Patch It Out?\n\nrollbacks, Unit of Work and Its Context Manager\n\nexplicit tests for, Explicit Tests for Commit/Rollback Behavior\n\nrollback method, The Real Unit of Work Uses SQLAlchemy Sessions\n\nS\n\nseams, Wrap-Up",
      "content_length": 997,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 482,
      "content": "secondary adapters, Putting Things in Folders to See Where It All Belongs\n\nSeemann, Mark, blog post, Applying the DIP to Data Access\n\nSELECT * FROM WHERE queries, Time to Completely Jump the Shark\n\nSELECT FOR UPDATE statement, Optimistic Concurrency with Version Numbers\n\npessimistic concurrency control example with, Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nSELECT N+1, SELECT N+1 and Other Performance Considerations\n\nservice functions\n\nmaking them event handlers, Imagining an Architecture Change: Everything Will Be an Event Handler\n\nrefactoring to message handlers, Refactoring Service Functions to Message Handlers\n\nservice layer, Our First Use Case: Flask API and Service Layer-The DIP in Action\n\nbenefits of, Wrap-Up\n\nbenefits to test-driven development, Wrap-Up\n\nconnecting our application to real world, Connecting Our Application to the Real World\n\ndependencies of, The DIP in Action\n\nreal dependencies at runtime, The DIP in Action\n\ntesting, The DIP in Action",
      "content_length": 990,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 483,
      "content": "difference between domain service and, Why Is Everything Called a Service?\n\ndomain layer tests moving to, Should Domain Layer Tests Move to the Service Layer?\n\nreasons for, Should Domain Layer Tests Move to the Service Layer?\n\nend-to-end test of allocate API, testing happy and unhappy paths, A Typical Service Function\n\nerror conditions requiring database checks in Flask app, Error Conditions That Require Database Checks\n\nfirst cut of Flask app, The Straightforward Implementation-The Straightforward Implementation\n\nFlask app delegating to, A Typical Service Function\n\nfrom domain objects to primitives to events as interface, Refactoring Service Functions to Message Handlers\n\nfully decoupling from the domain, Fully Decoupling the Service- Layer Tests from the Domain-Adding a Missing Service\n\nintroducing and using FakeRepository to unit test it, Introducing a Service Layer, and Using FakeRepository to Unit Test It-Why Is Everything Called a Service?\n\nmessage bus as main entrypoint, Going to Town on the Message Bus\n\npros and cons or trade-offs, The DIP in Action\n\nputting project in folders, Putting Things in Folders to See Where It All Belongs\n\nraising events and passing them to message bus, Wrap-Up",
      "content_length": 1213,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 484,
      "content": "raising its own events, Option 2: The Service Layer Raises Its Own Events\n\nsending email alerts when out of stock, avoiding, Or the Service Layer!\n\ntaking events from model and putting them on message bus, Option 1: The Service Layer Takes Events from the Model and Puts Them on the Message Bus\n\ntotally free of event handling concerns, Option 3: The UoW Publishes Events to the Message Bus\n\ntweaking fakes in to call super and implement underscorey methods, Option 3: The UoW Publishes Events to the Message Bus\n\ntypical service function, A Typical Service Function\n\nusing Product objects, One Aggregate = One Repository\n\nusing Unit of Work in, Using the UoW in the Service Layer\n\nusing, test pyramid and, How Is Our Test Pyramid Looking?\n\nwriting bulk of tests against, Wrap-Up\n\nwriting tests against, High and Low Gear\n\nservice-layer services vs. domain services, Not Everything Has to Be an Object: A Domain Service Function\n\nservices\n\napplication service and domain service, Why Is Everything Called a Service?\n\nservice layer tests only using services, Adding a Missing Service\n\nSession object, Wrap-Up",
      "content_length": 1107,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 485,
      "content": "set, fake repository as wrapper around, Building a Fake Repository for Tests Is Now Trivial!\n\nsimplifying abstractions, Choosing the Right Abstraction(s)\n\nsingle responsibility principle (SRP), Single Responsibility Principle\n\nSingleton pattern, messagebus.py implementing, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\nsituated software, A New Requirement Leads Us to a New Architecture\n\nSoftware Engineering Stack Exchange site, Why Not Just Patch It Out?\n\nspreadsheets, using instead of domain model, Why Not Just Run Everything in a Spreadsheet?\n\nspy objects, Testing Edge to Edge with Fakes and Dependency Injection\n\nSQL\n\ngenerating for domain model objects, The “Normal” ORM Way: Model Depends on ORM\n\nhelpers for Unit of Work, Test-Driving a UoW with Integration Tests\n\nORM and Repository pattern as abstractions in front of, What Is the Trade-Off?\n\nraw SQL in views, Hold On to Your Lunch, Folks\n\nrepository test for retrieving complex object, What Is the Trade- Off?\n\nrepository test for saving an object, What Is the Trade-Off?\n\nSQLAlchemy",
      "content_length": 1081,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 486,
      "content": "database session for Unit of Work, The Real Unit of Work Uses SQLAlchemy Sessions\n\nnot mocking, Fake Unit of Work for Testing\n\ndeclarative syntax, model depends on ORM, The “Normal” ORM Way: Model Depends on ORM\n\nexplicit ORM mapping with SQLAlchemy Table objects, Inverting the Dependency: ORM Depends on Model\n\nSELECT N+1 problem and, SELECT N+1 and Other Performance Considerations\n\nSession object, Wrap-Up\n\nusing directly in API endpoint, Inverting the Dependency: ORM Depends on Model\n\nusing DSL to specify FOR UPDATE, Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nstakeholders, convincing to try something new, Convincing Your Stakeholders to Try Something New-Questions Our Tech Reviewers Asked That We Couldn’t Work into Prose\n\nstate\n\nabstracting to aid testability, Abstracting State Aids Testability- Abstracting State Aids Testability\n\nsplitting off from logic in the program, Implementing Our Chosen Abstractions\n\nstorage, Repository Pattern\n\n(see also repositories; Repository pattern)\n\npermanent, UoW providing entrypoint to, The Unit of Work Collaborates with the Repository",
      "content_length": 1103,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 487,
      "content": "Strangler pattern, going to microservices via, An Event-Driven Approach to Go to Microservices via Strangler Pattern-An Event- Driven Approach to Go to Microservices via Strangler Pattern\n\nstubbing, mocks and stubs, Why Not Just Patch It Out?\n\nsuper function, Option 3: The UoW Publishes Events to the Message Bus\n\ntweaking fakes in service layer to call, Option 3: The UoW Publishes Events to the Message Bus\n\nsynchronous execution of event-handling code, Wrap-Up\n\nT\n\ntemporal coupling, Error Handling in Distributed Systems\n\ntemporal decoupling using asynchronous messaging, The Alternative: Temporal Decoupling Using Asynchronous Messaging\n\nTenacity library, Recovering from Errors Synchronously\n\ntest doubles\n\nmocks versus fakes, Why Not Just Patch It Out?\n\nmocks versus stubs, Why Not Just Patch It Out?\n\nusing lists to build, Testing Edge to Edge with Fakes and Dependency Injection\n\n\"Test-Driven Development: That's Not What We Meant\", Why Not Just Patch It Out?\n\ntest-driven development (TDD), TDD in High Gear and Low Gear- Wrap-Up\n\nbenefits of service layer to, Wrap-Up",
      "content_length": 1079,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 488,
      "content": "classic versus London-school, Why Not Just Patch It Out?\n\ndeciding what kinds of tests to write, On Deciding What Kind of Tests to Write\n\ndomain layer tests moving to service layer, Should Domain Layer Tests Move to the Service Layer?\n\nfully decoupling service layer from the domain, Fully Decoupling the Service-Layer Tests from the Domain-Adding a Missing Service\n\nadding missing service, Adding a Missing Service\n\ncarrying improvement through to E2E tests, Carrying the Improvement Through to the E2E Tests\n\nkeeping all domain dependencies in fixture functions, Mitigation: Keep All Domain Dependencies in Fixture Functions\n\nhigh and low gear, High and Low Gear\n\ntest pyramid with service layer added, How Is Our Test Pyramid Looking?\n\ntest pyramid, examining, TDD in High Gear and Low Gear\n\ntypes of tests, rules of thumb for, Wrap-Up\n\nunit tests operating at lower level, acting directly on model, TDD in High Gear and Low Gear\n\ntesting\n\nabstracting state to aid testability, Abstracting State Aids Testability-Abstracting State Aids Testability\n\nafter implementing chosen abstraction, Implementing Our Chosen Abstractions-Wrap-Up",
      "content_length": 1135,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 489,
      "content": "avoiding use of mock.patch, Why Not Just Patch It Out?- Wrap-Up\n\nedge-to-edge testing with fakes and dependency injection, Testing Edge to Edge with Fakes and Dependency Injection- Testing Edge to Edge with Fakes and Dependency Injection\n\nend-to-end test of pub/sub model, Test-Driving It All Using an End-to-End Test\n\nfake database session at service layer, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\nfake UoW for service layer testing, Fake Unit of Work for Testing\n\nfor data integrity rules, Testing for Our Data Integrity Rules- Pessimistic Concurrency Control Example: SELECT FOR UPDATE\n\nintegration test for CQRS view, Testing CQRS Views\n\nintegration test for overriding bootstrap defaults, Initializing DI in Our Tests\n\nintegration tests for rollback behavior, Explicit Tests for Commit/Rollback Behavior\n\ntests folder tree, Tests\n\ntests written in terms of events, Our Tests Are All Written in Terms of Events Too\n\nhandler tests for change_batch_quantity, Test-Driving a New Handler\n\nunit testing event handlers with fake message bus, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus",
      "content_length": 1147,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 490,
      "content": "Unit of Work with integration tests, Test-Driving a UoW with Integration Tests\n\ntidying up tests, Tidying Up the Integration Tests\n\nunit test for bootstrap, Initializing DI in Our Tests\n\nunit testing with fakes at service layer, Introducing a Service Layer, and Using FakeRepository to Unit Test It\n\ntime.sleep function, Testing for Our Data Integrity Rules\n\nreproducing concurrency behavior with, Testing for Our Data Integrity Rules\n\ntransactions\n\nconcurrent, attempting update on Product, Optimistic Concurrency with Version Numbers\n\nsimulating a slow transaction, Testing for Our Data Integrity Rules\n\nUnit of Work and, Wrap-Up\n\nusing to enforce concurrency rules, Enforcing Concurrency Rules by Using Database Transaction Isolation Levels\n\ntype hints, Unit Testing Domain Models, Unit Testing Domain Models\n\nU\n\nunderscorey methods\n\navoiding by implementing TrackingRepository wrapper class, Option 3: The UoW Publishes Events to the Message Bus\n\ntweaking fakes in service layer to implement, Option 3: The UoW Publishes Events to the Message Bus",
      "content_length": 1050,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 491,
      "content": "Unit of Work pattern, The Repository in the Abstract, Unit of Work Pattern-Wrap-Up\n\nand its context manager, Unit of Work and Its Context Manager\n\nfake UoW for testing, Fake Unit of Work for Testing\n\nreal UoW using SQLAlchemy session, The Real Unit of Work Uses SQLAlchemy Sessions\n\nbenefits of using, Wrap-Up\n\ncollaboration with repository, The Unit of Work Collaborates with the Repository\n\nexplicit tests for commit/rollback behavior, Explicit Tests for Commit/Rollback Behavior\n\nexplicit versus implicit commits, Explicit Versus Implicit Commits\n\nfake message bus implemented in UoW, Optionally: Unit Testing Event Handlers in Isolation with a Fake Message Bus\n\ngetting rid of underscorey methods in UoW class, Option 3: The UoW Publishes Events to the Message Bus\n\nmanaging database state, Unit of Work Pattern\n\nmessage bus now collecting events from UoW, The Message Bus Now Collects Events from the UoW\n\nmodifying to connect domain events and message bus, Events and the Message Bus\n\npros and cons or trade-offs, Wrap-Up\n\nrecap of important points, Wrap-Up",
      "content_length": 1063,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 492,
      "content": "splitting operations across two UoWs, Implementing Our New Requirement\n\ntest driving with integration tests, Test-Driving a UoW with Integration Tests\n\ntidying up integration tests, Tidying Up the Integration Tests\n\nUoW and product repository, One Aggregate = One Repository\n\nUoW collecting events from aggregates and passing them to message bus, Wrap-Up\n\nUoW for CSVs, Implementing a Repository and Unit of Work for CSVs\n\nUoW managing success or failure of aggregate update, Discussion: Events, Commands, and Error Handling\n\nUoW publishing events to message bus, Option 3: The UoW Publishes Events to the Message Bus\n\nusing UoW in service layer, Using the UoW in the Service Layer\n\nusing UoW to group multiple operations into atomic unit, Examples: Using UoW to Group Multiple Operations into an Atomic Unit-Example 2: Change Batch Quantity\n\nchanging batch quantity example, Example 2: Change Batch Quantity\n\nreallocate function example, Example 1: Reallocate\n\nwith Django, Unit of Work Pattern with Django-Unit of Work Pattern with Django\n\nwithout, API talking directly to three layers, Unit of Work Pattern\n\nunit testing, Introducing a Service Layer, and Using FakeRepository to Unit Test It",
      "content_length": 1194,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 493,
      "content": "(see also test-driven development; testing)\n\nof domain models, Unit Testing Domain Models-Value Objects and Entities\n\nunit tests replacing end-to-end tests, Why Not Just Patch It Out?\n\nunittest.mock function, Why Not Just Patch It Out?\n\nUoW (see Unit of Work pattern)\n\nuse-case layer (see service layer)\n\nV\n\nvalidation, Validation-Validating Pragmatics\n\nvalue objects\n\ndefined, Dataclasses Are Great for Value Objects\n\nand entities, Value Objects and Entities\n\nentities versus, Exceptions Can Express Domain Concepts Too\n\nmath with, Dataclasses Are Great for Value Objects\n\nusing dataclasses for, Dataclasses Are Great for Value Objects\n\nVens, Rob, Wrap-Up\n\nVernon, Vaughn, Wrap-Up\n\nversion numbers\n\nimplementation options for, Implementation Options for Version Numbers\n\nin the products table, implementing optimistic locking, Optimistic Concurrency with Version Numbers\n\nviews",
      "content_length": 878,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 494,
      "content": "Django views as adapters, API: Django Views Are Adapters\n\nkeeping totally separate, denormalized datastore for view model, Time to Completely Jump the Shark\n\nread-only, Post/Redirect/Get and CQS\n\nrebuilding view model from scratch, Updating a Read Model Table Using an Event Handler\n\nsimple view that uses the ORM, “Obvious” Alternative 2: Using the ORM\n\nsimple view that uses the repository, “Obvious” Alternative 1: Using the Existing Repository\n\ntesting CQRS views, Testing CQRS Views\n\ntrade-offs for view model options, Wrap-Up\n\nupdating read model table using event handler, Time to Completely Jump the Shark\n\nW\n\nweb controllers, sending email alerts via, avoiding, Avoiding Making a Mess",
      "content_length": 693,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 495,
      "content": "About the Authors\n\nHarry Percival spent a few years being deeply unhappy as a management consultant. Soon he rediscovered his true geek nature and was lucky enough to fall in with a bunch of XP fanatics, working on\n\npioneering the sadly defunct Resolver One spreadsheet. He worked at PythonAnywhere LLP, spreading the gospel of TDD worldwide at talks, workshops, and conferences. He is now with MADE.com.\n\nBob Gregory is a UK-based software architect with MADE.com. He has been building event-driven systems with domain-driven design for\n\nmore than a decade.",
      "content_length": 558,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 496,
      "content": "Colophon\n\nThe animal on the cover of Architecture Patterns with Python is a Burmese python (Python bivitattus). As you might expect, the Burmese python is native to Southeast Asia. Today it lives in jungles and\n\nmarshes in South Asia, Myanmar, China, and Indonesia; it’s also invasive in Florida’s Everglades.\n\nBurmese pythons are one of the world’s largest species of snakes. These nocturnal, carnivorous constrictors can grow to 23 feet and 200 pounds. Females are larger than males. They can lay up to a hundred\n\neggs in one clutch. In the wild, Burmese pythons live an average of 20 to 25 years.\n\nThe markings on a Burmese python begin with an arrow-shaped spot of light brown on top of the head and continue along the body in\n\nrectangles that stand out against its otherwise tan scales. Before they reach their full size, which takes two to three years, Burmese pythons\n\nlive in trees hunting small mammals and birds. They also swim for long stretches of time—going up to 30 minutes without air.\n\nBecause of habitat destruction, the Burmese python has a conservation\n\nstatus of Vulnerable. Many of the animals on O’Reilly’s covers are\n\nendangered; all of them are important to the world.\n\nThe color illustration is by Jose Marzan, based on a black-and-white\n\nengraving from Encyclopedie D’Histoire Naturelle. The cover fonts are URW Typewriter and Guardian Sans. The text font is Adobe",
      "content_length": 1390,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 497,
      "content": "Minion Pro; the heading font is Adobe Myriad Condensed; and the code font is Dalton Maag’s Ubuntu Mono.",
      "content_length": 103,
      "extraction_method": "Unstructured"
    }
  ]
}