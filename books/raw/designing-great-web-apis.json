{
  "metadata": {
    "title": "designing-great-web-apis",
    "author": "James Higginbotham",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 45,
    "conversion_date": "2025-12-19T18:44:48.050175",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "designing-great-web-apis.pdf",
    "extraction_method": "Unstructured"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-9)",
      "start_page": 1,
      "end_page": 9,
      "detection_method": "topic_boundary",
      "content": "Designing Great Web APIs\n\nCreating Business Value Through Developer Experience\n\nJames Higginbotham\n\nShort. Smart. Seriously useful.\n\nFree ebooks and reports from O’Reilly at oreil.ly/webdev\n\n“When you strive to comprehend your code, you create better work and become better at what you do. The code isn’t just your job anymore, it’s your craft. This is why I love Up & Going.” —JENN LUKAS, Frontend consultant\n\nKYLE SIMPSON\n\nUpgrading to PHP 7\n\nThe Little Book of HTML/CSS Coding Guidelines\n\nUP &I GOING\n\nDavey Shafik\n\nJens Oliver Meiert Foreword by Lindsey Simon\n\nStatic Site Generators\n\nModern Tools for Static Website Development\n\nBrian Rinaldi\n\nWe’ve compiled the best insights from subject matter experts for you in one place, so you can dive deep into what’s happening in web development.\n\n©2016 O’Reilly Media, Inc. The O’Reilly logo is a registered trademark of O’Reilly Media, Inc. D1814\n\nDesigning Great Web APIs Creating Business Value Through Developer Experience\n\nJames Higginbotham\n\nDesigning Great Web APIs by James Higginbotham\n\nCopyright © 2015 O’Reilly Media, Inc. All rights reserved.\n\nPrinted in the United States of America.\n\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\n\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (http://safaribooksonline.com). For more sales department: 800-998-9938 or corporate@oreilly.com.\n\ninformation,\n\ncontact our\n\ncorporate/institutional\n\nEditor: Allyson MacDonald Production Editor: Melanie Yarbrough Copyeditor: Amanda Kersey Proofreader: Melanie Yarbrough\n\nInterior Designer: David Futato Cover Designer: Randy Comer Illustrator: Rebecca Demarest\n\nJuly 2015:\n\nFirst Edition\n\nRevision History for the First Edition 2015-07-21: First Release\n\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Designing Great Web APIs, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.\n\nWhile the publisher and the author have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the author disclaim all responsibility for errors or omissions, including without limi‐ tation responsibility for damages resulting from the use of or reliance on this work. Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsi‐ bility to ensure that your use thereof complies with such licenses and/or rights.\n\n978-1-491-92459-4\n\n[LSI]\n\nTable of Contents\n\nThe Business of APIs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 What Are APIs? 1 The Rise of the API Economy 2 Business Advantages of Web APIs 4 Web API Development versus Traditional Software 6\n\nGuidelines for Designing a Great API. . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n23 The Design-First API Process. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . User Interface Wireframes to Drive API Design 24 API Modeling 24 Next Step: Detailed API Design 28\n\nAPI Design Details. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 An HTTP Primer 29 Building Your Resource Ontology 33 Defining URLs Through Relationships 33 Mapping Resource Lifecycles to HTTP Verbs 35 Mapping Response Codes 36 Validating Design Through Documentation and Prototyping 37 Putting It All Together 38\n\n7\n\niii\n\nThe Business of APIs\n\nWeb APIs are everywhere. Just browse any technology news website and you are likely to read something about the latest product launching an open API. Companies are making huge investments in providing APIs to internal developers, partner organizations, and public developers. APIs that were once used to solve integration problems have now become the backbone for an organization’s digi‐ tal strategy.\n\nWhat Are APIs? An API, or application programming interface, is the specification of how one piece of software can interact with another. It is best thought of as a contract between software and the developers using it.\n\nAs an example, if you provide a display message to the confirm dia‐ log API inside a browser, then the browser will display the message inside of a pop-up dialog and offer OK/Cancel buttons to proceed when the user presses OK, or cancel if the user presses Cancel:\n\nif (window.confirm(\"Do you really want to leave?\")) { window.open(\"done.html\", \"Thanks for visiting!\"); }\n\nUsing the preceding window.confirm() API results in a browser confirmation dialog:\n\n1\n\nTraditionally, APIs have always been part of software development. Operating systems such as Microsoft Windows and Mac OS or mobile platforms such as iOS and Android offer APIs that allow developers to build software on top of their platform. Developers depend upon these APIs to exist, operate as expected, and not break their contract without sufficient notice.\n\nAs software has moved from a focus on desktop and web to mobile computing, there has been an increased demand for web APIs. These modern web APIs aren’t just built to integrate systems within an organization. Instead, they allow businesses to share business capabilities and data, build community, and foster innovation. This has led to the rise of the API economy.\n\nThe Rise of the API Economy The API economy is a term that was coined to describe the growth of revenue and brand engagement as a result of offering public APIs for developers. Let’s examine the reasons that gave rise to the API economy.\n\nReason #1 – Higher Demand Historically, APIs were used to integrate different software systems or even different organizations. Web APIs are now in high demand due to three key factors: the modern browser, mobile devices, and the Internet of Things.\n\nYears ago, modern browsers were limited to displaying content and limited scripting capabilities using JavaScript. Modern browsers have moved beyond this, allowing rich web applications to be built using a combination of HTML, CSS, and modern JavaScript frame‐ works. As a result, we no longer require servers to generate com‐ plete web pages. Instead, JavaScript frameworks request data from\n\n2\n\n|\n\nThe Business of APIs\n\none or more web APIs, dynamically changing what the user sees and the actions they can perform.\n\nIn addition to modern browsers, there has been explosive growth in mobile devices such as phones and tablets. These devices have access to the Internet from most locations and offer GPS location and app- store distribution. Applications no longer have to be web pages in a browser. Instead, they can use APIs to access data and business logic to get things done.\n\nFinally, the Internet of Things (IoT) is moving the world of devices, previously requiring human intervention, into autonomous replace‐ ments that combine the physical world with the world of software. As a result, APIs enable IoT devices to broadcast their telemetry data and receive commands from other systems. IoT is an emerging domain that will greatly benefit from integrating and providing APIs.\n\nReason #2 – Simplicity Historically, enterprises adopted technologies such as SOAP or XML-RPC to integrate applications internally and between partner organizations. These technologies often required additional stand‐ ards and specifications on top of transport protocols such as HTTP. However, these technologies are meant for systems integration where rigid specifications are most important.\n\nModern web APIs abandon the need for these complex standards, instead choosing a simpler solution. They encourage the use of HTTP, the protocol that powers the Web, as the foundation for APIs. The HTTP specification was designed to support a robust set of request verbs (i.e., what you want to do) and response codes (i.e., the result of the request). The philosophy for web APIs is to avoid additional standards and specifications, instead choosing to use the HTTP standard to define how web APIs operate.\n\nBy choosing HTTP as the only standard, any application or device can consume a web API using built-in programming libraries. No longer are expensive software solutions and complicated standards required. This means easy integration for any device: mobile phones, browsers, or even cars with mobile network access can con‐ sume web APIs.\n\nThe Rise of the API Economy\n\n|\n\n3\n\nReason #3 –Lower Cost By choosing HTTP for our APIs, companies can avoid allocating large budgets of time and money to learn, build, and maintain com‐ plex software-technology stacks. Instead, built-in and open source programming libraries can be used to create and consume a variety of web APIs.\n\nWith the introduction of cloud computing, any business or individ‐ ual developer can provision a complete data center on a credit card. No longer do you have to purchase tens of thousands of dollars of equipment, wait for it to be shipped to a data center, physically install it, and configure it for use. Now anyone can provision a server from one of multiple cloud vendors—often in less than 60 seconds—and at a fraction of the cost of purchasing and maintain‐ ing a physical server.\n\nReason #4 – New Business Models installed, on-premise solutions to As software moved from Software-as-a-Service (SaaS) products, web APIs became more pop‐ ular for accessing data and automating integration. Eventually, com‐ panies offering SaaS products realized that their APIs were just as valuable as the product itself. They could even be productized inde‐ pendently from the core SaaS offering.\n\nAs the API economy emerged, new API business models were iden‐ tified, including free, developer pays, developer gets paid, indirect, and internal. The free or developer pays subscription models are the most common, although the other models are used with specific strategies in mind.\n\nAs a result of the API economy, businesses must market APIs to developers directly to gain traction and generate revenue. This places heavier emphasis on great API design to gain developer acceptance, whether the API will be open to the public or only used internally.\n\nBusiness Advantages of Web APIs Today, companies are using web APIs to transform their businesses as well. Netflix uses APIs to enable streaming across more than 200 different devices. Over half of eBay’s listings are posted using its API. Best Buy has used APIs to transform itself in the face of online\n\n4\n\n|\n\nThe Business of APIs",
      "page_number": 1
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 10-18)",
      "start_page": 10,
      "end_page": 18,
      "detection_method": "topic_boundary",
      "content": "retail competitors. Walgreens has wrapped every corner store with an API to enable local photo printing and other services, all pow‐ ered by developers.\n\nBusinesses are using Web APIs to increase revenue, improve innova‐ tion, and reduce their time-to-market through two strategies: con‐ suming APIs from others and exposing their own APIs for internal and external developers.\n\nConsuming APIs from Others APIs allow businesses to leverage the hard work of other developers. Rather than building every feature in-house, teams can leverage third-party APIs to add new functionality and focus on the aspects of the solution that are unique. For some solutions, this may result in building an application entirely from third-party APIs, with little or no custom development.\n\nWhen selecting a third-party API for integration, it is important to consider the API provider’s strengths and weaknesses. An API pro‐ vider needs to have a business model that indicates longevity, to pre‐ vent the API from being shut down in the future. It should also have a documented process for upgrading and versioning APIs to prevent breaking your existing applications. Finally, it should invest in great documentation to help your developers, while offering support pro‐ cesses when your developers are experiencing difficulties. If care is not taken when selecting an API provider, the result can be worse than building the feature in-house.\n\nExposing APIs to Other Developers While many organizations are resistant to building and exposing APIs to partner or public developers, there are several advantages for doing so:\n\nAPIs allow your customers to innovate without depending on your team. This allows them to customize your solution as they wish, a requirement that is often necessary for mid and large- size organizations.\n\nAPIs often result in additional revenue streams by productizing your business capabilities as a service. For product companies, this may be a necessary step to closing sales (or accelerating the close).\n\nBusiness Advantages of Web APIs\n\n|\n\n5\n\nAPIs create partner networks, allowing third-parties to sell your software by offering API-based integration to your solution.\n\nBuilding web APIs are often considered an integration problem best left to the technology team. However, web APIs are more than just a technology solution: they reach to the heart of the business. Every‐ thing an API offers (and doesn’t offer) speaks volumes about what an organization most cares about. This means that organizations need to view web APIs as a business asset, not just a technology sol‐ ution. An organization’s API provides a view into what the business truly values; the quality of its API design provides a view into how the business truly values developers.\n\nWeb API Development versus Traditional Software Unlike past trends that market to business leaders, APIs market directly to developers. And developers demand more than just a marketing website that lists the features in bullet points. They demand an intuitive, easy-to-use API that can quickly be integrated into their next project.\n\nThis requirement, called “developer experience,” is transforming the way that APIs are designed. Organizations can no longer bolt on an API as an afterthought and force developers to use it. Instead, entire markets are emerging where APIs compete for the attention of developers.\n\nThis means that an API that solves developer problems and comes with a great design will have a greater chance of winning their atten‐ tion. Your web API design is a competitive advantage.\n\nWith all of this in mind, the remainder of this book provides insights into designing a great API that results in creating value for your business.\n\n6\n\n|\n\nThe Business of APIs\n\nGuidelines for Designing a Great API\n\nIf you have been involved with any kind of software product, you have probably heard of the term user experience, or UX. This is the discipline of meeting the exact needs of the user, from their interac‐ tions with the product, company, and its services.\n\nDeveloper experience (DX) is just as important for APIs as UX is for great applications. The developer experience focuses on the various aspects of engagement with developers for your API product. This extends beyond the features of the API. It also includes all aspects of the API product, from first glance to day-to-day usage and support.\n\nAs we seek to understand how to design a great API, it is important to remember that DX is important for both internal and external developers. Internal developers benefit from great DX because they are able to create business value faster, especially for newer develop‐ ers that just joined the organization. External developers benefit by integrating your well-designed API quickly, hopefully faster than any competitor can offer (or building it in-house).\n\nAs you begin to produce APIs for internal or external developers, you will be faced with a variety of decisions about your API. This can range from how you manage it as a product, to its design and documentation. The following seven guidelines will help your orga‐ nization incorporate a great developer experience for the internal and external developers that will use your API.\n\n7\n\n#1 - Treat Your API as a Product Many APIs start as a bolt-on solution to an existing application in an effort to solve a short-term problem, such as building a mobile application. However, APIs designed from the ground-up as a sepa‐ rate product enable the development of not just one type of applica‐ tion, but any number of applications that span a variety of devices and situations: third-party software, internal applications, desktop apps, mobile devices, and the emerging world of IoT. This means that APIs extend beyond a simple technology solution: they can have a positive (or negative) impact across the entire business, including:\n\n1. Internal innovation\n\n2. Marketing channels\n\n3. Business development\n\n4. Lead generation\n\n5. User acquisition\n\n6. Upsell opportunity\n\n7. Device and mobile support\n\n8. Increased customer retention\n\nAs a result, APIs need to be treated as a product, even if it is an internal product used only by the organization itself. This means investing in the API as you would any other product, including:\n\n1. Clear communication of your API strategy and business model(s) to all lines of business to ensure everyone is focused on achieving the same business goals\n\n2. Implementing an API governance program to encourage API consistency through design standards and product management\n\n3. Managing the entire API software development life cycle (SDLC), from requirements to delivery, deployment, and cus‐ tomer support\n\n4. Monitoring API usage and key metrics and performance indica‐ tors (KPIs)\n\n8\n\n| Guidelines for Designing a Great API\n\n5. Evangelizing the API to internal and external developers through online resources, hackathons, internal/external confer‐ ences, and partner programs\n\nTaking these steps will ensure that not only will your API design remain well-designed and consistent, but also that your API will have longevity as you continue to support the needs of both internal and external developers.\n\n#2 – Take an Outside-In Design Approach Web APIs have a tendency to reflect two things: organizational structure and database structure. Neither will produce a great API design, and both of these situations can be prevented. Taking an outside-in approach to API design means looking at your API from the viewpoint of an external developer that doesn’t have access to your code, your database design, or your organizational structure.\n\nOrganizational structure leaks\n\nWhen an organizational structure leaks into the API, it announces to developers that the API isn’t a product; it is the output of a spe‐ cific team within the organization. The result is inconsistent design and duplication or gaps in functionality.\n\nOrganizational structure creeps into an API for two reasons: 1) APIs are designed in isolation from other teams, or 2) APIs are designed around internal systems rather than external needs.\n\nTo avoid this, consider establishing an API governance board that encourages consistency across teams. A governance board isn’t meant to be an oppressive committee that stalls innovation. Rather, they represent the best interests of developers, your APIs, and your business. Great governance boards often act as internal consultants for your APIs to make them successful.\n\nDatabase structure leaks\n\nDatabase structure creeps in through the use of tools and frame‐ works that promise rapid API development at the expense of a thoughtful API design. They externalize the data through generated APIs but make one huge assumption that becomes the enemy of great API design: external developers want to use your API like you access your database.\n\nGuidelines for Designing a Great API\n\n|\n\n9\n\nDevelopers using your API don’t care how you store your data as long as it is stored correctly and reliably. Taking an outside-in design approach will prevent the database design from creeping in by encouraging you to see your API as external developers will see it.\n\nWhen taking an outside-in approach to API design, focus on how the API will be used, rather than how it is built. This means looking for ways to make your API useful for web clients, where connectiv‐ ity and CPU capabilities are abundant as well as mobile devices, where connectivity and battery enforce a variety of limitations.\n\n#3 – Write Great Documentation The first essential trait of a great API is great documentation. It is important to remember that developers won’t have access to your source code. Therefore, they won’t be able to see how things work inside your API. They will depend on your API’s documentation to understand how to use it, when to use it, and what will happen as a result.\n\nGreat documentation requires careful attention to format, complete‐ ness, and discoverability. Let’s look at each of these documentation concerns in more detail.\n\nFormat\n\nHow you decide to distribute your documentation will heavily impact the audience. Many companies employ technical writers who use tools that produce beautiful, typeset documentation in PDF for‐ mat. The documentation looks professional and amazing.\n\nHowever, there is a big downside to PDF-based documentation: the PDF goes stale once it is downloaded. As new versions of the PDF are released, older versions remain on their hard drive for reference. This means that they won’t have the benefit of the latest examples, clarifications, and new features.\n\nInstead, APIs need to have documentation that is always current for the reader. HTML-based documentation provides an always upda‐ ted, easily accessible solution. It should be hosted on your website and easily accessed by developers to ensure the documentation is available at any time.\n\n10\n\n| Guidelines for Designing a Great API\n\nCompleteness\n\nAt least one time in your life you have encountered bad documenta‐ tion. It may have been the assembly instructions for do-it-yourself furniture. Perhaps it was an owner’s manual for a new device or soft‐ ware product. The experience of poor documentation can waste your time, leave you frustrated, or perhaps even cause you to replace it with something better.\n\nAPI documentation can provide the same experience if it is left incomplete or unclear. Developers may continue to use the API in the short term, but they will likely look to replace your API at first chance.\n\nIt is important to remember that a public web API is a contract with every developer that will use it. Whether you target internal devel‐ opers, developers within a partner organization, or public develop‐ ers in general, you are making a contract with each individual devel‐ oper.\n\nTherefore, the documentation you provide to developers will pro‐ vide the bulk of their developer experience. It will be the first thing that they experience when trying to understand your API, and the first place they go when they are stuck.\n\nThe challenge with API documentation is that it must serve a variety of situations. This may include the developer looking at your API for the first time or the expert developer looking to use a newly released feature. This means that complete documentation takes into account the following scenarios:\n\nDevelopers, product managers, and business users that are con‐ sidering your API but haven’t committed to it yet\n\nThe developer integrating your API for the first time\n\nThe expert developer who has been using your API for some time and wants to explore previously hidden features or options\n\nSupport staff trying to troubleshoot how your API works and why an application is failing\n\nNewly hired developers in your organization seeing the API (and the business) details for the first time\n\nToo often, documentation lacks focus around one or more of these areas. This is particularly the case when using documentation writ‐\n\nGuidelines for Designing a Great API\n\n|\n\n11\n\nten inline with the code itself. Tools exist that allow API docs to be built from inline comments and are sometimes used to expedite the documentation process. However, the result is documentation that is only focused on what that specific code does, not how to use it suc‐ cessfully. Complete documentation must consider all of the five sce‐ narios previously listed.\n\nInteractive\n\nFinally, great documentation should be interactive. As mentioned, API documentation delivered in HTML format can be hosted on a website and kept up-to-date. But another added benefit is that we can use the browser to actually interact with our API.\n\nFigure 2-1 is an example of interactive documentation using Swag‐ ger.\n\nFigure 2-1. API documentation using Swagger, which offers a Try It Out feature\n\nInteractive API documentation allows anyone, including developers, quality assurance staff, product managers, and support staff to make API calls into a live running server from within the documentation itself. This is possible because our web APIs use the HTTP standard and therefore don’t require special libraries or software to make them work. Imagine allowing developers and QA staff explore your API before they ever write a line of code or an automated test! That is power of interactive documentation.\n\n#4 – Have an Intuitive, Consistent Design An intuitive API is one that makes it easy for a developer to know what to do to use it effectively. By lowering the learning curve of your API, you will ensure that developers experience successes early\n\n12\n\n| Guidelines for Designing a Great API\n\nand often. This results in greater API adoption, longer retention (even in the face of competitors), and developer autonomy resulting in reduced support costs.\n\nFollow these general guidelines to make your API more intuitive:\n\nMake data available easily, rather than hidden or hard to find.\n\nRequire only the information necessary to accomplish the desired task.\n\nOffer both low-level ways of getting things done, as well as higher-level ways of accomplishing common workflows with fewer calls.\n\nUse hypermedia links to inform API clients the available actions at any given point, based on the current state of the data and the permissions of the API client.\n\nOffer only one way to accomplish a task.\n\nFor APIs, consistency is important for a great developer experience because it creates predictability. As developers start to become familiar with your API, they will come to expect the same familiarity as they explore it further. This consistency encompasses a number of areas, including naming, resource URLs, payload formats, and error messaging. Let’s examine each one further.\n\nConsistent naming\n\nAs developers approach your API, the first thing they will notice is the naming conventions that you use. This includes the names of the domain concepts referenced, many of which become the resources used in the URLs of your API. Therefore, naming is critical to the understanding and usage of your API. The following are some tips for incorporating consistent naming:\n\nAvoid abbreviations, as they can be difficult to read and often create confusion as some names may be unclear or inconsis‐ tently abbreviated.\n\nBe consistent with resource names to avoid confusion.\n\nRefrain from referencing internal systems, as this results in requiring insider knowledge to use or comprehend your API.\n\nGuidelines for Designing a Great API\n\n|\n\n13",
      "page_number": 10
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 19-26)",
      "start_page": 19,
      "end_page": 26,
      "detection_method": "topic_boundary",
      "content": "Consistent resource URLs\n\nAs you design your API, you will need to map out the various URLs that will represent your resources. It is highly recommended that you develop a resource ontology to ensure that URLs are consis‐ tently designed into the API.\n\nIf you are unfamiliar, ontology is a technique used in information science for the naming and typing of entities and their relationships. API ontologies define the structure of your API, from the top-level resources to the nested resources under them.\n\nFigure 2-2 is an example of a URL ontology for an ecommerce web‐ site.\n\nFigure 2-2. An example resource ontology for an eCommerce API\n\nWhen designing your resource ontology, apply the following techni‐ ques to create a more consistent API:\n\nUse plural resource names when offering a collection of resour‐ ces and a singular resource name for a single resource (e.g., /users for a collection of user resources, /user for a single user resource).\n\nUse nested resources to indicate relationships between resour‐ ces.\n\n14\n\n| Guidelines for Designing a Great API\n\nAvoid one-off URLs (e.g., /users/current rather than the more appropriate /user).\n\nWe will cover this topic in more detail in Chapter 4.\n\nConsistent payload formats\n\nFinally, the payload format should be consistent to allow API con‐ sumers to easily construct request payloads and parse response pay‐ loads. Most developers prefer to write helper code to handle this logic. If an API is inconsistent in its approach, developers will have to write one-off code to handle the differences. Follow these patterns for more consistent API payloads:\n\nReuse field names across payloads when possible for better pre‐ dictability (e.g., use firstName and lastName or use fullName, but don’t interchange them).\n\nAvoid abbreviations in field names.\n\nKeep consistent casing rules, usually camelCase or snake_case (e.g., firstName or first_name, but not both).\n\nSelect a single payload format or standard when handling pay‐ loads, including resource representations and search result col‐ lections.\n\nEnsure all error message formats are consistent across the API. This is especially important when an API is built by multiple developers who may otherwise handle error messaging differ‐ ently.\n\nBeyond data: Supporting API-based workflows\n\nAPIs often require more than just data. While data is important, developers seek out APIs to solve a problem. If they wanted to store data, they would push it into a database directly, unless you have data that no one else can provide. They are looking to your API to do something that they don’t want to build themselves. This may be solving difficult problems, building support for collaboration, or providing data analysis.\n\nGreat APIs need to look beyond data access endpoints. While these kinds of endpoints are essential to any API, adding workflow into your API helps developers get things done quickly and with fewer lines of code.\n\nGuidelines for Designing a Great API\n\n|\n\n15\n\nAs an example, Twilio only supported conference calls by putting each caller on mute and then managing each caller using the low- level access APIs. The company realized that customers required an affordance to support conference calls at a higher level. The result is that providers were able to remove a lot of hard work from API developers by building in a higher-level conference call API that did the heavy lifting for them.\n\nAs an API provider, it is important to look for usage patterns of how your API may be used across a variety of different types of develop‐ ers. Then begin to build in higher-level APIs that support these workflows, saving them effort and time.\n\nA Note About Hypermedia APIs Hypermedia APIs are a breed of web APIs that inform clients about what actions are possible after a given request. This may take the form of next steps within a workflow, related API resources, and other functional areas of the API. This mimics how we use the Web: we go to a homepage, click the login link, enter our credentials, then navigate to various areas of the application.\n\nUsing hypermedia enables our clients to be more flexible and reduces the amount of business logic we have to code into them. Instead, they look for the existence of specific links within a response payload and offer (or hide) specific actions based on the server’s determination of what is and isn’t allowed. If the business logic needs to change in a workflow, the server simply adds or removes the appropriate hypermedia links that are used to guide the client’s behavior.\n\nSome REST purists believe that hypermedia is a requirement for an API to be labeled REST. While this isn’t strictly the case, hyperme‐ dia often provides additional value to an API by making API con‐ sumption easier and more flexible. However, it isn’t necessarily required to deliver a useful and functionally complete API.\n\n#5 – Design for Security at the Start Teams can become so focused on the features that they forget to integrate security into their API design. Nearly every API will need to provide access to internal business systems, sensitive and per‐ sonal information (PII), and/or public data that co-exists with inter‐\n\n16\n\n| Guidelines for Designing a Great API\n\nnal/private data. Some APIs may provide limited data for free or for specific roles, while others may restrict access to any and all data. Therefore, every API must consider security from the design phase rather than as an afterthought, when it is often too late to make API changes without significant impact. The following are security con‐ siderations that need to be made during API design.\n\nAuthentication\n\nAuthentication is the process of verifying the identity of a particular API consumer. For websites that are built for humans, this is often a form that asks for a username and password. For APIs, there are a number of options available:\n\nPassword-based authentication\n\nWith password-based authentication, a username and password is sent on each request. While this may be secured through the use of transport-level security (TLS), software integrations to APIs may stop working if a user resets her password for any rea‐ son.\n\nAPI-key based authentication\n\nInstead of sharing a username and password, APIs can require the use of an API key that is provided by the service. This key identifies the API client and is not directly tied to a user’s pass‐ word. The API key may be embedded within the URL as part of the request body or in the request header. API keys may be shared with other applications, but revoking access to the API key will cause all applications sharing the key to stop working.\n\nDelegation-based authentication\n\nFor scenarios when third-party applications may want to con‐ nect to an API on someone else’s behalf (e.g., a third-party Twit‐ ter or Facebook client), delegation-based authentication is often the best approach. OAuth is the most popular standard, since it is somewhat like a “protocol of protocols” that allows discon‐ necting the authentication provider that provides API tokens from the API provider. API tokens are granted and revoked as desired by the user, allowing third-party applications to make API calls on their behalf (i.e., delegated access)\n\nGuidelines for Designing a Great API\n\n|\n\n17\n\nAuthorization\n\nOnce you have identified yourself through the authentication mech‐ anism, the API must still authorize access to the appropriate data and functional access rules for the system. This may be a direct result of your user account permissions within the API, or the per‐ missions granted through the use of a delegation-based authentica‐ tion mechanism such as OAuth. Each API endpoint’s authorization requirements should be considered during the API design process to ensure that data and access to critical systems are secured properly while the core functionality of the API is maintained.\n\nData leakage\n\nEven with the proper authentication and authorization mechanism, your API design can still have security leaks. While this can happen for a variety of reasons, the most common is that APIs are designed for internal consumption only and are eventually promoted to part‐ ner or public developers. Sensitive data once thought as accessible only by internal systems is now made available to developers outside of the organization.\n\nAs an example, the Tinder API experienced a security breach through data leakage. While its mobile applications did not surface an individual’s exact location, the API did return specific locations within the response payload. This means that any developer had access to an individual’s location, since the data was not removed or scrubbed properly for external consumption. Instead, internal knowledge of another Tinder user’s location was both stored within their backend systems and then made available directly via its API, exposing these users to potential harm.\n\nTo prevent data leakage, design your APIs as if you were releasing the API to the public. This includes adding proper authorization for API consumers to grant or revoke access to specific data fields and functional areas of the API as appropriate.\n\nAlways use TLS\n\nWhile some API endpoints may be providing data that isn’t sensi‐ tive, it is generally best to use TLS to secure all data in motion. This will help protect authentication credentials, as well as prevent eaves‐ dropping when transmitting sensitive data between the API client and server.\n\n18\n\n| Guidelines for Designing a Great API\n\nDesigning with security is important\n\nAs you likely realize by now, if security is an afterthought in your API design, everything from the API documentation to assumptions in implementation may need to be revisited. In addition, improper design of your API by ignoring security implications can result in the sharing of sensitive data and perhaps even exposing unnecessary risk to users.\n\n#6 – Share Great Code Examples Documentation is a very important element of the developer experi‐ ence. However, code examples provide the important guidance nec‐ essary for developers to be able to apply the documentation in prac‐ tice.\n\nCode examples come in a variety of forms, from just a few lines that demonstrate how a specific API works, to more complex examples that show how to assemble multiple API calls into a complete work‐ flow.\n\nSo, how do you choose what kind of examples to include? First, you need to understand the developer journey and the various mile‐ stones developers go through as they learn your API.\n\nMilestone 1: First success\n\nInitially, the developer needs to overcome any doubts that the API will solve his needs. This often starts with code examples that allow her to explore the API beyond the interactive documentation.\n\nIt is important to remember that during this phase, the developer just wants to see something work. This is often known as TTFHW, “Time to first Hello World” and is a key metric for determining API complexity. The longer it takes to get a developer to her first “win”, the more likely the developer will leave your API and find a better solution. If there are no alternatives for your API, the developer will build his own solution.\n\nProducts such as Twilio have made it their goal to onboard develop‐ ers in less than five minutes. While this takes considerable focus and investment, your goal should be to find the shortest possible route, then keep working to shorten the time as your API matures.\n\nTo achieve a low TTFHW, provide concise examples that remove all need for boilerplate code. Look at the following example:\n\nGuidelines for Designing a Great API\n\n|\n\n19\n\nrequire \"stripe\" Stripe.api_key = \"sk_test_BQokikJOvBiI2HlWgH4olfQ2\"\n\nStripe::Token.create( :card => { :number => \"4242424242424242\", :exp_month => 6, :exp_year => 2016, :cvc => \"314\" }, )\n\nNotice in this example that there is little code to write. Simply fill-in your API key and the credit card credentials to try it out.\n\nBad example code requires that you write code to use the example. This requires you to learn more about the API before you can try it out. Never require developers to write code to complete an example when first trying out your API.\n\nMilestone 2: Workflow support\n\nAfter the developers have had some time to acquaint themselves with your API using your easy-to-use examples, the next step is to begin to demonstrate the API based on how they will want to use it.\n\nWorkflow examples focus more on achieving specific goals than applying coding best practices. This means that you want to convey clarity over code performance, clear intent over code quality. Use copious inline comments to explain why each step is necessary. Be willing to include hard-coded values for easier reading. Choose vari‐ able and method names that make it easy to read. Focus more on behavior than handling errors at this point.\n\nIt is important to note that while these examples will be more com‐ plex than those found from the first milestone, they shouldn’t exceed the height of the screen. The examples need to be short enough to explain the concepts but not too long that they require considerable time to understand. It is often best to demonstrate sce‐ narios that are easily understood and likely map to your customer needs.\n\nMilestone 3: Production-ready integration\n\nOnce the developer has followed your simple examples and then tried some workflows, the final step is to help her understand how to integrate your API into her production environment. This\n\n20\n\n| Guidelines for Designing a Great API\n\nincludes how to catch errors to help developers properly trouble‐ shoot their integration code. It also includes demonstrating how to catch and recover from bad data provided by end users. Finally, if you are enforcing rate limiting, then show not only how to obtain the current rate limits for their account, but also provide tips for reducing the number of API calls required.\n\n#7 – Provide Helper Libraries Web APIs have a huge advantage: they are built on the hard work of the authors of the HTTP specification. This means that any devel‐ oper can pick up their favorite programming language, select an HTTP client library, and make API calls. They don’t need anything else to make it happen.\n\nHelper libraries allow developers to make API calls using a special library built for their specific programming language. As an exam‐ ple, a Ruby helper library can be provided to allow developers to consume your API directly, without having to write the code neces‐ sary to handle the lower-level HTTP logic required for web APIs.\n\nWhile API providers are not required to release helper libraries, they often accelerate developer success. This is especially the case for mobile developers, who are accustomed to working with helper libraries rather than raw HTTP. Many API providers that wish to reach mobile developers choose to produce a helper library for iOS and a helper for Android.\n\nFor APIs that will likely be used outside of a mobile platform, you may opt to provide helper libraries for Java, JavaScript, Python, Ruby, Go, PHP, and .NET. What languages you choose depend upon your intended audience. For example, if your target audience is enterprise developers, then Java and .NET should be priority. For web developers, you may choose to focus on Python, PHP, Java‐ Script, Ruby, and Go. Whatever you do, don’t assume that your team’s preferred language platform is what your customers will be using. Do the research to be sure you have prioritized your focus.\n\nIt is important to note that each helper library should be docu‐ mented fully and follow each language’s programming idioms. This will prevent a library written in Ruby from looking like it was built for a Java developer. This may require hiring outside expertise to consult on how the library should work, or perhaps even build it for your organization.\n\nGuidelines for Designing a Great API\n\n|\n\n21",
      "page_number": 19
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 27-35)",
      "start_page": 27,
      "end_page": 35,
      "detection_method": "topic_boundary",
      "content": "The Design-First API Process\n\nTraditional software development is often focused on internal devel‐ opment teams that have access to the source code that makes the software function. Or, at the very least, they have access to the inter‐ nal developers and data administrators to ask questions.\n\nWeb APIs, however, are more social in nature. They require collabo‐ ration between the developers consuming the API and the develop‐ ers that built the API. They only have the API design and documen‐ tation to guide them. Developers consuming an API do not have access to the source code, database diagrams, or an internal knowl‐ edge base on why the API operates a certain, quirky way. They can‐ not copy-and-paste the source code for an API and make the changes they need to get their job done.\n\nThis means that our goals for our API design need to reflect simplic‐ ity and clarity and to anticipate the needs of developers and the end users who will indirectly consume the API from a web or mobile application. This is a difficult challenge for any team, no matter how experienced they may be with the particular software or business domain. Therefore, heavy emphasis should be placed on the API design process, including how your team translates product require‐ ments.\n\nThis chapter provides a process and some guidelines for API model‐ ing and design that your team may wish to incorporate into their process. Feel free to adjust as necessary to support your specific organizational requirements.\n\n23\n\nUser Interface Wireframes to Drive API Design In the case of an API that is being developed in tandem with a mobile or web interface, wireframing the user interface will help drive a top-down view of how the API will be used. The wireframes won’t define every required feature of the API, but they will focus on the key goals of end users: what they will do and how they will do it. This will have a large impact on the API, as often the user interface requires more complex interactions that the API will need to sup‐ port.\n\nWhile many APIs start with simple data-access functionality, the user interface will expose the gaps in your APIs as they need to per‐ form more complex tasks. It will also expose the number of API calls that will be required to accomplish a given task. This is especially important with regard to mobile applications, where every HTTP call to an API occurs over an unreliable cellular network.\n\nAs we will discuss later, a simple wireframe or static mockup of the screens can help validate your API design. Be sure to schedule time into your project plan to design any web and mobile screens, pref‐ erably in time to help validate your API design.\n\nAPI Modeling Just as a beautiful web design begins from a wireframe, a great API design begins with modeling. The goal of API modeling is to trans‐ late the product requirements into the beginnings of a high-level API design. API modeling ensures that both developers and end users have their goals met.\n\nThe API modeling process is comprised of five steps:\n\n1. Identify the participants, or actors, who will interact with your API.\n\n2. Identify the activities that participants wish to achieve.\n\n3. Separate the activities into steps that the participants will per‐ form.\n\n4. Create a list of API methods from the steps, grouped into com‐ mon resource groups.\n\n24\n\n|\n\nThe Design-First API Process\n\n5. Validate the API by using requirements artifacts to test the com‐ pleteness of the API.\n\nThe process is designed to be iterative, allowing you to return to a previous step if you discover that something is missing or needs to be adjusted. Let’s look at how to perform each step.\n\nStep 1: Identify the Participants The first step is to identify the participants, sometimes called actors, who will interact with the API. Unlike a user interface, an API design must factor in both humans and non-humans who may interact with your API. Some examples include:\n\nSystem administrators (i.e., your company’s administrators)\n\nAccount administrators (i.e., your customer’s administrators)\n\nUsers of the system, including their various roles (e.g., users, managers, and moderators)\n\nInternal or external software\n\nOther Internet-connected devices\n\nFor each participant, you will capture their name and perhaps a short description of what they do (see Table 3-1).\n\nTable 3-1. Some example participants for our project management API\n\nParticipant\n\nDescription\n\nProject manager\n\nThe person in charge of the project\n\nProject member\n\nSomeone assigned to the project and tasks\n\nSystem administrator\n\nManages global settings\n\nBy considering the different types of participants, it will help you consider your API design from a variety of intended uses.\n\nStep 2: Identify the Activities Activities are the outcomes that your participants will expect your API to provide. These activities focus on the job to be done, not how\n\nAPI Modeling\n\n|\n\n25\n\nto do it. We will capture the steps required to accomplish the activi‐ ties in our next modeling process.\n\nAlthough your API may focus on only one activity, most APIs must support more than one activity to deliver value to developers. If you find yourself with only one activity, try asking what each participant is trying to achieve. Most likely, you will find more than one activity will be required of your API once you evaluate the activities for each of your participants identified in step 1.\n\nFor each activity, capture a short name, description, and the partici‐ pant(s) that will be involved in the activity (see Table 3-2).\n\nTable 3-2. Some example activities for our project-management API\n\nActivity name\n\nDescription\n\nParticipant(s)\n\nManage project\n\nCreate, update, and archive a project\n\nProject manager\n\nView project details\n\nView project tasks and overall status\n\nProject manager, project member\n\nManage project tasks\n\nCreate, update, and archive tasks for a project\n\nProject manager, Project member\n\nStep 3: Separate the Activities into Steps Once you have a list of activities, it is time to break them into steps. Each step may involve one or more participants but must be exe‐ cuted by a single participant at a time.\n\nYou may find that you may be missing some details about how an activity should be performed. This is an indicator that you should involve one or more subject matter experts (SMEs) who can provide greater insight and details into how the system should work. These experts may be business analysts, customers, and/or quality- assurance teams familiar with the requirements.\n\nFor each activity step, capture the activity name, a short name for the step, a description, and a list of participants who may perform the step. Table 3-3 is an example of documenting the activity steps for the “manage project tasks” activity in the previous modeling step.\n\n26\n\n|\n\nThe Design-First API Process\n\nTable 3-3. “Manage project tasks” activity step example for our project management API\n\nActivity\n\nActivity step name Description\n\nParticipant(s)\n\nManage project tasks\n\nAdd task to project\n\nAdds a task to an existing project\n\nProject manager, project member\n\nManage project tasks\n\nArchive project task\n\nArchives a task in an exist- ing project\n\nProject manager, project member\n\nManage project tasks\n\nMark project task as complete\n\nMarks a task in an existing project as complete\n\nProject manager, project member\n\nYou may notice that you see recurring patterns or steps across activi‐ ties. That is expected and may provide insight into possible API design and/or code reuse.\n\nStep 4: Identify the Resources and Candidate APIs Once you have the activities and steps identified, you will begin to see specific business entities emerge. These are your resource candi‐ dates that may become actual API resources. Others may appear to be resources but may instead be activities that will be performed outside of the API itself and therefore won’t become actual API resources. Since this is the modeling phase, that is perfectly fine. Our API design process will help filter out these unnecessary items.\n\nBecause this is the modeling and not the design phase, we do not want to focus on the HTTP specifics. Instead, focus on the high- level API only. The details of how you will implement the API, including the specific URLs, HTTP verbs, and response codes will emerge as we move into the full API design process. Table 3-4 is an example of how to document the project tasks API that we have identified as a result of our API design model.\n\nTable 3-4. “Project tasks API”: Project-management API example\n\nMethod\n\nParticipant(s) authorized for API\n\nAdd task to project\n\nProject manager, project member\n\nArchive project task\n\nProject manager, project member\n\nAPI Modeling\n\n|\n\n27\n\nMethod\n\nParticipant(s) authorized for API\n\nMark project task as complete\n\nProject manager, project member\n\nStep 5: Validate the API Model Once you have an API model defined, you can use the model to vali‐ date that it meets the requirements of internal developers, partner or public developers, and the end user. There are three techniques that can help validate your API model:\n\nThe API walkthrough\n\nIf you have mobile or web mockups, walk through each screen to determine which API will be used to satisfy the data being displayed or functionality being performed. Revisit any areas that you may have missed to ensure that you have a complete API model.\n\nUse-case validation\n\nUsing existing use cases, step through each one to identify any gaps in your API. This is especially useful if user interface mockups haven’t been completed yet, or if some of the API will not have a user interface associated with it. This is often the case for APIs designed for machine-to-machine integration rather than end-user functionality.\n\nBusiness-process diagrams\n\nFor APIs that will be supporting business-workflow processes, first diagram the workflow(s). For each step in the workflow, map your API model to each step to ensure that you can accom‐ plish all necessary aspects of the workflow.\n\nAs you validate your APIs, look for methods that are missing. You may also want to make notes about APIs that have dependencies on other APIs or that may experience heavy usage. While not necessary, this may guide some of your decisions as you move into the design and development phases.\n\nNext Step: Detailed API Design With the API model complete, we now have a sketch of what our API will look like. The next step is to detail the design by applying HTTP and REST principles. We will cover this in the next chapter.\n\n28\n\n|\n\nThe Design-First API Process\n\nAPI Design Details\n\nWhile API modeling is focused on mapping requirements to the API, the API design process maps the API model to HTTP, the lan‐ guage of the Web.\n\nTransitioning from the model to design phase will require a variety of decisions. Some of these decisions will become obvious, while others may require some careful thought and planning. The more decisions you leave until the development phase, the more likely your API design will be compromised due to your delivery schedule.\n\nRather than making these decisions quickly during the development phase, we encourage you to spend sufficient time with the API design process to ensure that your API design is complete. This will help you focus on building a great web API and avoiding too many changes after your API has been released.\n\nAn HTTP Primer As we move from the API design model to the details of how the web API will be realized using HTTP, it is important to review how HTTP works. If you are familiar with HTTP, feel free to skip this section.\n\nHTTP Is Request/Response HTTP is a request/response protocol. The HTTP client contacts a server and sends a request. The server processes the request and returns a response indicating a success or failure. It is important to note that HTTP is stateless, which means that every request must\n\n29\n\nprovide all of the details necessary to process the request on the server.\n\nUniform Resource Locators (URLs) Uniform resource locators, or URLs, provide a address of where to locate a resource, such as a web page, image, or data, from an API. A URL is divided into the following parts:\n\nScheme\n\nHow we want to connect, (e.g., HTTP [unsecure] or HTTPS [secure]).\n\nHostname\n\nThe server to contact (e.g., api.example.com).\n\nPort number\n\nA number ranging from 0 to 65535 that identifies the process on the server where the request is to go (e.g., 443 [optional, defaults to 80 for HTTP and 443 for HTTPS]).\n\nPath\n\nThe path to the resource being requested (e.g., /projects [default is /, which indicates the homepage]).\n\nQuery string\n\nContains data to be passed to the server. Starts with a question mark and contains name/value (e.g., foo=bar) pairs, using an ampersand as a separator between (e.g., ?page=1&per_page=10).\n\nHTTP Verbs HTTP request verbs indicate the type of action being requested from the URL. For APIs, they are often one of the following:\n\nGET\n\nRetrieve a collection or individual resource.\n\nPOST\n\nCreate a new resource or request custom action.\n\nPUT\n\nUpdate an existing resource or collection.\n\nDELETE\n\nDelete an existing resource or collection.\n\n30\n\n| API Design Details\n\nThere are more HTTP request verbs in the HTTP specification. This list contains the majority of HTTP verbs useful for a modern web API.\n\nHTTP Requests A client request is composed of the following parts:\n\nRequest verb\n\nInforms the server about the type of request being made (e.g., retrieve, create, update, delete, etc.)\n\nURL\n\nThe universal address of the information being requested\n\nRequest header\n\nInformation about the client and what is being requested in name:value format\n\nRequest body\n\nThe request details (may be empty)\n\nThe following is an example HTTP request with no request body:\n\nGET http://www.oreilly.com/ HTTP/1.0 Proxy-Connection: Keep-Alive User-Agent: Mozilla/5.0 [en] (X11; I; Linux 2.2.3 i686) Host: oreilly.com Accept: image/gif, image/x-xbitmap, image/jpeg, */* Accept-Encoding: gzip Accept-Language: en Accept-Charset: iso-8859-1, *, utf-8\n\nThe following are examples of API requests:\n\nGET /accounts\n\nRetrieves all accounts in the accounts resource collection\n\nGET /accounts/{id}\n\nRetrieves a specific account by the given ID\n\nPOST /accounts\n\nCreates a new acccount\n\nPUT /accounts/{id}\n\nUpdates an account by the given ID\n\nAn HTTP Primer\n\n|\n\n31",
      "page_number": 27
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 36-43)",
      "start_page": 36,
      "end_page": 43,
      "detection_method": "topic_boundary",
      "content": "DELETE /accounts/{id}\n\nDeletes an account by the given ID\n\nHTTP Responses A server response is composed of the following parts:\n\nServer response code\n\nA number indicating if the request was successful or not\n\nResponse header\n\nInformation about what happened in name:value format\n\nResponse body\n\nContains the response payload, often HTML, XML, JSON, or an image (may be empty)\n\nThe following code is an example HTTP request with an HTML response body:\n\nHTTP/1.1 200 OK Date: Tue, 26 May 2015 06:57:43 GMT Content-Location: http://oreilly.com/index.html Etag: \"07db14afa76be1:1074\" Last-Modified: Sun, 24 May 2015 01:27:41 GMT Content-Type: text/html Server: Apache\n\n<html>...</html>\n\nResponse codes are grouped into families, with the 2xx response codes indicating success, 4xx response codes indicating that the cli‐ ent failed to format the request properly, and 5xx response codes indicating a server error. The following are the most common server response codes used for web APIs:\n\n200 OK\n\nThe request has succeeded.\n\n201 Created\n\nThe request has been fulfilled and resulted in a new resource being created.\n\n202 Accepted\n\nThe request has been accepted for processing, but the process‐ ing has not been completed.\n\n32\n\n| API Design Details\n\n204 No Content\n\nThe server has fulfilled the request but does not need to return a body. This is common for delete operations.\n\n400 Bad Request\n\nThe request could not be understood by the server due to mal‐ formed syntax.\n\n401 Unauthorized\n\nThe request requires user authentication.\n\n403 Forbidden\n\nThe server understood the request, but is refusing to fulfill it.\n\n404 Not Found\n\nThe server has not found anything matching the requested URI.\n\n500 Internal Server Error\n\nThe server encountered an unexpected condition which preven‐ ted it from fulfilling the request.\n\nBuilding Your Resource Ontology An ontology is simply a classification of concepts. An API ontology captures the set of resources you will be offering, and their relation‐ ships to other resources. It is generally realized through your API’s URL structure.\n\nIf you modeled your API already, you likely have a list of candidate resources that will be part of it. If not, take some time and model your API to help you identify your resources. To build your ontol‐ ogy, begin by creating a list of the resources, placing them at the top of the URL structure (e.g., /projects and /tasks).\n\nDefining URLs Through Relationships Next, you will need to determine if your resources all belong at the top level, or if some of them should be nested under parent resour‐ ces. To do this, we first need to understand the relationships between each of the resources.\n\nRelationships between resources can be categorized into three types: independent, dependent, and associative. Those familiar with data‐ base design will recognize these relationship types and will quickly understand them. For those not familiar, the following list contains\n\nBuilding Your Resource Ontology\n\n|\n\n33\n\na description of each of the three types, with further information in Table 4-1:\n\nIndependent\n\nIndependent resources can exist stand alone without the other’s existence, but may reference each other. The URLs for both resources often exist at the top level.\n\nDependent\n\nDependent resources cannot exist without the existence of the parent resource. The URL for the dependent resource exists as a nested resource of its parent.\n\nAssociative\n\nAssociative resources have a relationship that contains or requires additional properties to describe it. Associative resour‐ ces may be nested under one parent or may be placed as a top- level resource and treated as an independent resource.\n\nTable 4-1. Examples of resource relationships\n\nRelation Type\n\nResources\n\nMeaning\n\nIndependent\n\n/projects, /tasks\n\nTasks can exist with or without a project\n\nDependent\n\n/projects, /projects/{id}/ tasks\n\nTasks must belong to a project instance\n\nAssociative\n\n/users, /projects, /projects/ {id}/collaborators\n\nUsers assigned to a project become col- laborators\n\nIn our project-management API example, we have to make a critical decision: whether tasks exist outside of a project or not. If they can, then both resources are independent and therefore both exist at the top level of the URL structure (e.g., /projects and /tasks). However, if tasks must belong to a project, then tasks are dependent on a project and must exist as a nested resource under the specific project instance (e.g., /projects/{id}/tasks).\n\nUnderstanding and applying resource relationships is critical to a great API design. Weigh your resource URL designs carefully and understand the impact of your decisions.\n\n34\n\n| API Design Details\n\nMapping Resource Lifecycles to HTTP Verbs Once you determine your resource URL structure, you can then map your resource lifecycles to the necessary HTTP verb or verbs. We have four core HTTP verbs that we will focus on, though a few others exist when you need them for uncommon situations.\n\nYour API model will provide insight into the lifecycle requirements of your resources. Review your model and notice the verbs you used for each resource. Some resources may require all verbs in our life‐ cycle: search, create, read, update, and delete. However, other resources may not require update or delete actions. Other resources may be read-only. Therefore, the requirements identified during the modeling phase will inform your API design.\n\nAs you model your API, you will notice a common pattern between the verbs you choose and the eventual resource lifecycle they require. Table 4-2 is a common mapping between verbs used in modeling and the verbs in HTTP.\n\nTable 4-2. Common modeling actions to HTTP verb mappings\n\nModeling Actions\n\nTypical HTTP Verb\n\n“List”, “Search”, “Match”, “View All”\n\nGET collection\n\n“Show”, “Retrieve”, “View”\n\nGET resource instance\n\n“Create”, “Add”\n\nPOST create a new resource\n\n“Replace”\n\nPUT update a resource collection\n\n“Update”\n\nPUT update a resource instance\n\n“Delete All”, “Remove All”, “Clear”, “Reset” DELETE delete a resource collection\n\n“Delete”, “Remove”\n\nDELETE delete a resource instance\n\n<other verbs>\n\nPOST custom action on a resource instance\n\nWhile you may use different verbs during modeling, they will likely map to one of the common HTTP verbs. If they don’t, you may need to revisit the concept and see if it can be broken down into a\n\nMapping Resource Lifecycles to HTTP Verbs\n\n|\n\n35\n\nresource with a specific lifecycle. Otherwise, you may need to con‐ sider a custom POST action on a particular resource instance (e.g., POST /projects/{id}/approve).\n\nMapping Response Codes For each API endpoint you identified in the previous step, you will need to consider what response code(s) to return. While we hope that most responses will indicate a success, sometimes the client will fail to provide all of the correct details necessary to fulfill a request.\n\nIt is important to map both success and error codes in the design phase, as it will be part of our documentation delivered to develop‐ ers consuming our API. It will also inform your team in the com‐ plexity of each API endpoint prior to development, to help with the estimation process (see Table 4-3).\n\nTable 4-3. Common HTTP verb to response-code mappings\n\nType\n\nCondition\n\nCommon response code Verb(s)\n\nSuccess Request was successful\n\n200 OK\n\nAll verbs\n\nSuccess Resource created successfully\n\n201 Created\n\nPOST\n\nSuccess Request was successful, but not\n\n202 Accepted\n\nPOST\n\ncomplete yet\n\nSuccess Resource deleted successfully\n\n204 No Content\n\nDELETE\n\nError\n\nNot authentication credentials pro- vided\n\n401 Unauthorized\n\nAll verbs\n\nError\n\nUser not authorized or server for- bids requested action\n\n403 Forbidden\n\nAll verbs\n\nError\n\nResource not found\n\n404 Not Found\n\nGET, PUT, DELETE\n\nError\n\nFilter parameters provided were not valid\n\n400 Bad Request\n\nGET, POST, PUT\n\n36\n\n| API Design Details\n\nValidating Design Through Documentation and Prototyping As your API design starts to emerge, you should start the API docu‐ mentation process. At this stage, you may not have all of the details of what your resource representations will look like—that is expected.\n\nBy documenting your API design early, it will encourage the team to focus on documentation throughout the development process. It will also encourage validation through feedback from internal or external developers by sharing your API design with them early rather than waiting until launch.\n\nYou can begin to document the high-level design using one of your favorite API definition formats, such as Swagger, RAML, Blueprint, or IO Docs. Each of these formats can convert your API design into beautiful interactive docs, one of our key characteristics of a great API design. As your resource structures begin to take shape, you can capture those additional details, along with examples to complete your documentation.\n\nIn addition to documentation, prototyping is another effective way to validate your API design. Prototypes come in two common forms: a static prototype and a working prototype.\n\nA static prototype is just a method of returning resource representa‐ tions in one or more formats, such as XML or JSON. The static pro‐ totype is either stored on the local filesystem or served via a web server.\n\nStatic prototypes allow developers to begin to integrate the search (i.e., GET collection) and read (i.e., GET a resource instance) por‐ tions of the lifecycle. However, the filesystem or web server cannot process POST, PUT, or DELETE requests, so static prototypes are limited. To get beyond this limitation, a working prototype is required.\n\nWorking prototypes offer more functionality than static prototypes, allowing any or all functionality to be delivered. The focus of a working prototype is to simplify more complex interactions, such as third-party integrations or connecting to existing SOAP-based serv‐ ices or legacy systems.\n\nValidating Design Through Documentation and Prototyping\n\n|\n\n37\n\nWorking prototypes are not meant to be production-ready imple‐ mentations, so they can take shortcuts or flatten complex data struc‐ tures for ease of implementation. You can use the programming lan‐ guage and framework you plan to use for the production implemen‐ tation or select something simple that provides the minimal func‐ tionality required.\n\nPutting It All Together APIs can offer several advantages for businesses, including faster innovation and increased revenue. Every member of the organiza‐ tion, including executives, product managers, and developers, must be willing to see APIs as an investment that will create business value.\n\nA significant portion of your investment must be in the design of the API to provide a great developer experience. Only then will you pro‐ duce APIs that developers will love.\n\n38\n\n| API Design Details\n\nAbout the Author\n\nJames Higginbotham is a seasoned API consultant with experience in architecting, building, and deploying APIs. He is also a speaker and trainer. As an API consultant, he enjoys helping businesses bal‐ ance great API design and product needs. As a trainer, he enjoys equipping cross-functional teams to integrate their talents toward building first-class APIs for their product or enterprise systems.\n\nAcknowledgments\n\nI would first like to thank D. Keith Casey, Jr., whose generosity knows no bounds.\n\nI would also like to thank Mike Amundsen for his feedback on an early draft of this book.\n\nAnd finally, my sincere thanks to the many people that have directly and indirectly influenced this book through lively discussions, both online and offline.",
      "page_number": 36
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 44-45)",
      "start_page": 44,
      "end_page": 45,
      "detection_method": "topic_boundary",
      "content": "",
      "page_number": 44
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "content": "Designing Great Web APIs\n\nCreating Business Value Through Developer Experience\n\nJames Higginbotham",
      "content_length": 98,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 2,
      "content": "Short. Smart. Seriously useful.\n\nFree ebooks and reports from O’Reilly at oreil.ly/webdev\n\n“When you strive to comprehend your code, you create better work and become better at what you do. The code isn’t just your job anymore, it’s your craft. This is why I love Up & Going.” —JENN LUKAS, Frontend consultant\n\nKYLE SIMPSON\n\nUpgrading to PHP 7\n\nThe Little Book of HTML/CSS Coding Guidelines\n\nUP &I GOING\n\nDavey Shafik\n\nJens Oliver Meiert Foreword by Lindsey Simon\n\nStatic Site Generators\n\nModern Tools for Static Website Development\n\nBrian Rinaldi\n\nWe’ve compiled the best insights from subject matter experts for you in one place, so you can dive deep into what’s happening in web development.\n\n©2016 O’Reilly Media, Inc. The O’Reilly logo is a registered trademark of O’Reilly Media, Inc. D1814",
      "content_length": 796,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 3,
      "content": "Designing Great Web APIs Creating Business Value Through Developer Experience\n\nJames Higginbotham",
      "content_length": 97,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 4,
      "content": "Designing Great Web APIs by James Higginbotham\n\nCopyright © 2015 O’Reilly Media, Inc. All rights reserved.\n\nPrinted in the United States of America.\n\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\n\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (http://safaribooksonline.com). For more sales department: 800-998-9938 or corporate@oreilly.com.\n\ninformation,\n\ncontact our\n\ncorporate/institutional\n\nEditor: Allyson MacDonald Production Editor: Melanie Yarbrough Copyeditor: Amanda Kersey Proofreader: Melanie Yarbrough\n\nInterior Designer: David Futato Cover Designer: Randy Comer Illustrator: Rebecca Demarest\n\nJuly 2015:\n\nFirst Edition\n\nRevision History for the First Edition 2015-07-21: First Release\n\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Designing Great Web APIs, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.\n\nWhile the publisher and the author have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the author disclaim all responsibility for errors or omissions, including without limi‐ tation responsibility for damages resulting from the use of or reliance on this work. Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsi‐ bility to ensure that your use thereof complies with such licenses and/or rights.\n\n978-1-491-92459-4\n\n[LSI]",
      "content_length": 1714,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 5,
      "content": "Table of Contents\n\nThe Business of APIs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 What Are APIs? 1 The Rise of the API Economy 2 Business Advantages of Web APIs 4 Web API Development versus Traditional Software 6\n\nGuidelines for Designing a Great API. . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n23 The Design-First API Process. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . User Interface Wireframes to Drive API Design 24 API Modeling 24 Next Step: Detailed API Design 28\n\nAPI Design Details. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 An HTTP Primer 29 Building Your Resource Ontology 33 Defining URLs Through Relationships 33 Mapping Resource Lifecycles to HTTP Verbs 35 Mapping Response Codes 36 Validating Design Through Documentation and Prototyping 37 Putting It All Together 38\n\n7\n\niii",
      "content_length": 904,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 7,
      "content": "The Business of APIs\n\nWeb APIs are everywhere. Just browse any technology news website and you are likely to read something about the latest product launching an open API. Companies are making huge investments in providing APIs to internal developers, partner organizations, and public developers. APIs that were once used to solve integration problems have now become the backbone for an organization’s digi‐ tal strategy.\n\nWhat Are APIs? An API, or application programming interface, is the specification of how one piece of software can interact with another. It is best thought of as a contract between software and the developers using it.\n\nAs an example, if you provide a display message to the confirm dia‐ log API inside a browser, then the browser will display the message inside of a pop-up dialog and offer OK/Cancel buttons to proceed when the user presses OK, or cancel if the user presses Cancel:\n\nif (window.confirm(\"Do you really want to leave?\")) { window.open(\"done.html\", \"Thanks for visiting!\"); }\n\nUsing the preceding window.confirm() API results in a browser confirmation dialog:\n\n1",
      "content_length": 1104,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 8,
      "content": "Traditionally, APIs have always been part of software development. Operating systems such as Microsoft Windows and Mac OS or mobile platforms such as iOS and Android offer APIs that allow developers to build software on top of their platform. Developers depend upon these APIs to exist, operate as expected, and not break their contract without sufficient notice.\n\nAs software has moved from a focus on desktop and web to mobile computing, there has been an increased demand for web APIs. These modern web APIs aren’t just built to integrate systems within an organization. Instead, they allow businesses to share business capabilities and data, build community, and foster innovation. This has led to the rise of the API economy.\n\nThe Rise of the API Economy The API economy is a term that was coined to describe the growth of revenue and brand engagement as a result of offering public APIs for developers. Let’s examine the reasons that gave rise to the API economy.\n\nReason #1 – Higher Demand Historically, APIs were used to integrate different software systems or even different organizations. Web APIs are now in high demand due to three key factors: the modern browser, mobile devices, and the Internet of Things.\n\nYears ago, modern browsers were limited to displaying content and limited scripting capabilities using JavaScript. Modern browsers have moved beyond this, allowing rich web applications to be built using a combination of HTML, CSS, and modern JavaScript frame‐ works. As a result, we no longer require servers to generate com‐ plete web pages. Instead, JavaScript frameworks request data from\n\n2\n\n|\n\nThe Business of APIs",
      "content_length": 1642,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 9,
      "content": "one or more web APIs, dynamically changing what the user sees and the actions they can perform.\n\nIn addition to modern browsers, there has been explosive growth in mobile devices such as phones and tablets. These devices have access to the Internet from most locations and offer GPS location and app- store distribution. Applications no longer have to be web pages in a browser. Instead, they can use APIs to access data and business logic to get things done.\n\nFinally, the Internet of Things (IoT) is moving the world of devices, previously requiring human intervention, into autonomous replace‐ ments that combine the physical world with the world of software. As a result, APIs enable IoT devices to broadcast their telemetry data and receive commands from other systems. IoT is an emerging domain that will greatly benefit from integrating and providing APIs.\n\nReason #2 – Simplicity Historically, enterprises adopted technologies such as SOAP or XML-RPC to integrate applications internally and between partner organizations. These technologies often required additional stand‐ ards and specifications on top of transport protocols such as HTTP. However, these technologies are meant for systems integration where rigid specifications are most important.\n\nModern web APIs abandon the need for these complex standards, instead choosing a simpler solution. They encourage the use of HTTP, the protocol that powers the Web, as the foundation for APIs. The HTTP specification was designed to support a robust set of request verbs (i.e., what you want to do) and response codes (i.e., the result of the request). The philosophy for web APIs is to avoid additional standards and specifications, instead choosing to use the HTTP standard to define how web APIs operate.\n\nBy choosing HTTP as the only standard, any application or device can consume a web API using built-in programming libraries. No longer are expensive software solutions and complicated standards required. This means easy integration for any device: mobile phones, browsers, or even cars with mobile network access can con‐ sume web APIs.\n\nThe Rise of the API Economy\n\n|\n\n3",
      "content_length": 2140,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 10,
      "content": "Reason #3 –Lower Cost By choosing HTTP for our APIs, companies can avoid allocating large budgets of time and money to learn, build, and maintain com‐ plex software-technology stacks. Instead, built-in and open source programming libraries can be used to create and consume a variety of web APIs.\n\nWith the introduction of cloud computing, any business or individ‐ ual developer can provision a complete data center on a credit card. No longer do you have to purchase tens of thousands of dollars of equipment, wait for it to be shipped to a data center, physically install it, and configure it for use. Now anyone can provision a server from one of multiple cloud vendors—often in less than 60 seconds—and at a fraction of the cost of purchasing and maintain‐ ing a physical server.\n\nReason #4 – New Business Models installed, on-premise solutions to As software moved from Software-as-a-Service (SaaS) products, web APIs became more pop‐ ular for accessing data and automating integration. Eventually, com‐ panies offering SaaS products realized that their APIs were just as valuable as the product itself. They could even be productized inde‐ pendently from the core SaaS offering.\n\nAs the API economy emerged, new API business models were iden‐ tified, including free, developer pays, developer gets paid, indirect, and internal. The free or developer pays subscription models are the most common, although the other models are used with specific strategies in mind.\n\nAs a result of the API economy, businesses must market APIs to developers directly to gain traction and generate revenue. This places heavier emphasis on great API design to gain developer acceptance, whether the API will be open to the public or only used internally.\n\nBusiness Advantages of Web APIs Today, companies are using web APIs to transform their businesses as well. Netflix uses APIs to enable streaming across more than 200 different devices. Over half of eBay’s listings are posted using its API. Best Buy has used APIs to transform itself in the face of online\n\n4\n\n|\n\nThe Business of APIs",
      "content_length": 2074,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 11,
      "content": "retail competitors. Walgreens has wrapped every corner store with an API to enable local photo printing and other services, all pow‐ ered by developers.\n\nBusinesses are using Web APIs to increase revenue, improve innova‐ tion, and reduce their time-to-market through two strategies: con‐ suming APIs from others and exposing their own APIs for internal and external developers.\n\nConsuming APIs from Others APIs allow businesses to leverage the hard work of other developers. Rather than building every feature in-house, teams can leverage third-party APIs to add new functionality and focus on the aspects of the solution that are unique. For some solutions, this may result in building an application entirely from third-party APIs, with little or no custom development.\n\nWhen selecting a third-party API for integration, it is important to consider the API provider’s strengths and weaknesses. An API pro‐ vider needs to have a business model that indicates longevity, to pre‐ vent the API from being shut down in the future. It should also have a documented process for upgrading and versioning APIs to prevent breaking your existing applications. Finally, it should invest in great documentation to help your developers, while offering support pro‐ cesses when your developers are experiencing difficulties. If care is not taken when selecting an API provider, the result can be worse than building the feature in-house.\n\nExposing APIs to Other Developers While many organizations are resistant to building and exposing APIs to partner or public developers, there are several advantages for doing so:\n\nAPIs allow your customers to innovate without depending on your team. This allows them to customize your solution as they wish, a requirement that is often necessary for mid and large- size organizations.\n\nAPIs often result in additional revenue streams by productizing your business capabilities as a service. For product companies, this may be a necessary step to closing sales (or accelerating the close).\n\nBusiness Advantages of Web APIs\n\n|\n\n5",
      "content_length": 2053,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 12,
      "content": "APIs create partner networks, allowing third-parties to sell your software by offering API-based integration to your solution.\n\nBuilding web APIs are often considered an integration problem best left to the technology team. However, web APIs are more than just a technology solution: they reach to the heart of the business. Every‐ thing an API offers (and doesn’t offer) speaks volumes about what an organization most cares about. This means that organizations need to view web APIs as a business asset, not just a technology sol‐ ution. An organization’s API provides a view into what the business truly values; the quality of its API design provides a view into how the business truly values developers.\n\nWeb API Development versus Traditional Software Unlike past trends that market to business leaders, APIs market directly to developers. And developers demand more than just a marketing website that lists the features in bullet points. They demand an intuitive, easy-to-use API that can quickly be integrated into their next project.\n\nThis requirement, called “developer experience,” is transforming the way that APIs are designed. Organizations can no longer bolt on an API as an afterthought and force developers to use it. Instead, entire markets are emerging where APIs compete for the attention of developers.\n\nThis means that an API that solves developer problems and comes with a great design will have a greater chance of winning their atten‐ tion. Your web API design is a competitive advantage.\n\nWith all of this in mind, the remainder of this book provides insights into designing a great API that results in creating value for your business.\n\n6\n\n|\n\nThe Business of APIs",
      "content_length": 1688,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 13,
      "content": "Guidelines for Designing a Great API\n\nIf you have been involved with any kind of software product, you have probably heard of the term user experience, or UX. This is the discipline of meeting the exact needs of the user, from their interac‐ tions with the product, company, and its services.\n\nDeveloper experience (DX) is just as important for APIs as UX is for great applications. The developer experience focuses on the various aspects of engagement with developers for your API product. This extends beyond the features of the API. It also includes all aspects of the API product, from first glance to day-to-day usage and support.\n\nAs we seek to understand how to design a great API, it is important to remember that DX is important for both internal and external developers. Internal developers benefit from great DX because they are able to create business value faster, especially for newer develop‐ ers that just joined the organization. External developers benefit by integrating your well-designed API quickly, hopefully faster than any competitor can offer (or building it in-house).\n\nAs you begin to produce APIs for internal or external developers, you will be faced with a variety of decisions about your API. This can range from how you manage it as a product, to its design and documentation. The following seven guidelines will help your orga‐ nization incorporate a great developer experience for the internal and external developers that will use your API.\n\n7",
      "content_length": 1479,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 14,
      "content": "#1 - Treat Your API as a Product Many APIs start as a bolt-on solution to an existing application in an effort to solve a short-term problem, such as building a mobile application. However, APIs designed from the ground-up as a sepa‐ rate product enable the development of not just one type of applica‐ tion, but any number of applications that span a variety of devices and situations: third-party software, internal applications, desktop apps, mobile devices, and the emerging world of IoT. This means that APIs extend beyond a simple technology solution: they can have a positive (or negative) impact across the entire business, including:\n\n1. Internal innovation\n\n2. Marketing channels\n\n3. Business development\n\n4. Lead generation\n\n5. User acquisition\n\n6. Upsell opportunity\n\n7. Device and mobile support\n\n8. Increased customer retention\n\nAs a result, APIs need to be treated as a product, even if it is an internal product used only by the organization itself. This means investing in the API as you would any other product, including:\n\n1. Clear communication of your API strategy and business model(s) to all lines of business to ensure everyone is focused on achieving the same business goals\n\n2. Implementing an API governance program to encourage API consistency through design standards and product management\n\n3. Managing the entire API software development life cycle (SDLC), from requirements to delivery, deployment, and cus‐ tomer support\n\n4. Monitoring API usage and key metrics and performance indica‐ tors (KPIs)\n\n8\n\n| Guidelines for Designing a Great API",
      "content_length": 1573,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 15,
      "content": "5. Evangelizing the API to internal and external developers through online resources, hackathons, internal/external confer‐ ences, and partner programs\n\nTaking these steps will ensure that not only will your API design remain well-designed and consistent, but also that your API will have longevity as you continue to support the needs of both internal and external developers.\n\n#2 – Take an Outside-In Design Approach Web APIs have a tendency to reflect two things: organizational structure and database structure. Neither will produce a great API design, and both of these situations can be prevented. Taking an outside-in approach to API design means looking at your API from the viewpoint of an external developer that doesn’t have access to your code, your database design, or your organizational structure.\n\nOrganizational structure leaks\n\nWhen an organizational structure leaks into the API, it announces to developers that the API isn’t a product; it is the output of a spe‐ cific team within the organization. The result is inconsistent design and duplication or gaps in functionality.\n\nOrganizational structure creeps into an API for two reasons: 1) APIs are designed in isolation from other teams, or 2) APIs are designed around internal systems rather than external needs.\n\nTo avoid this, consider establishing an API governance board that encourages consistency across teams. A governance board isn’t meant to be an oppressive committee that stalls innovation. Rather, they represent the best interests of developers, your APIs, and your business. Great governance boards often act as internal consultants for your APIs to make them successful.\n\nDatabase structure leaks\n\nDatabase structure creeps in through the use of tools and frame‐ works that promise rapid API development at the expense of a thoughtful API design. They externalize the data through generated APIs but make one huge assumption that becomes the enemy of great API design: external developers want to use your API like you access your database.\n\nGuidelines for Designing a Great API\n\n|\n\n9",
      "content_length": 2071,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 16,
      "content": "Developers using your API don’t care how you store your data as long as it is stored correctly and reliably. Taking an outside-in design approach will prevent the database design from creeping in by encouraging you to see your API as external developers will see it.\n\nWhen taking an outside-in approach to API design, focus on how the API will be used, rather than how it is built. This means looking for ways to make your API useful for web clients, where connectiv‐ ity and CPU capabilities are abundant as well as mobile devices, where connectivity and battery enforce a variety of limitations.\n\n#3 – Write Great Documentation The first essential trait of a great API is great documentation. It is important to remember that developers won’t have access to your source code. Therefore, they won’t be able to see how things work inside your API. They will depend on your API’s documentation to understand how to use it, when to use it, and what will happen as a result.\n\nGreat documentation requires careful attention to format, complete‐ ness, and discoverability. Let’s look at each of these documentation concerns in more detail.\n\nFormat\n\nHow you decide to distribute your documentation will heavily impact the audience. Many companies employ technical writers who use tools that produce beautiful, typeset documentation in PDF for‐ mat. The documentation looks professional and amazing.\n\nHowever, there is a big downside to PDF-based documentation: the PDF goes stale once it is downloaded. As new versions of the PDF are released, older versions remain on their hard drive for reference. This means that they won’t have the benefit of the latest examples, clarifications, and new features.\n\nInstead, APIs need to have documentation that is always current for the reader. HTML-based documentation provides an always upda‐ ted, easily accessible solution. It should be hosted on your website and easily accessed by developers to ensure the documentation is available at any time.\n\n10\n\n| Guidelines for Designing a Great API",
      "content_length": 2028,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 17,
      "content": "Completeness\n\nAt least one time in your life you have encountered bad documenta‐ tion. It may have been the assembly instructions for do-it-yourself furniture. Perhaps it was an owner’s manual for a new device or soft‐ ware product. The experience of poor documentation can waste your time, leave you frustrated, or perhaps even cause you to replace it with something better.\n\nAPI documentation can provide the same experience if it is left incomplete or unclear. Developers may continue to use the API in the short term, but they will likely look to replace your API at first chance.\n\nIt is important to remember that a public web API is a contract with every developer that will use it. Whether you target internal devel‐ opers, developers within a partner organization, or public develop‐ ers in general, you are making a contract with each individual devel‐ oper.\n\nTherefore, the documentation you provide to developers will pro‐ vide the bulk of their developer experience. It will be the first thing that they experience when trying to understand your API, and the first place they go when they are stuck.\n\nThe challenge with API documentation is that it must serve a variety of situations. This may include the developer looking at your API for the first time or the expert developer looking to use a newly released feature. This means that complete documentation takes into account the following scenarios:\n\nDevelopers, product managers, and business users that are con‐ sidering your API but haven’t committed to it yet\n\nThe developer integrating your API for the first time\n\nThe expert developer who has been using your API for some time and wants to explore previously hidden features or options\n\nSupport staff trying to troubleshoot how your API works and why an application is failing\n\nNewly hired developers in your organization seeing the API (and the business) details for the first time\n\nToo often, documentation lacks focus around one or more of these areas. This is particularly the case when using documentation writ‐\n\nGuidelines for Designing a Great API\n\n|\n\n11",
      "content_length": 2082,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 18,
      "content": "ten inline with the code itself. Tools exist that allow API docs to be built from inline comments and are sometimes used to expedite the documentation process. However, the result is documentation that is only focused on what that specific code does, not how to use it suc‐ cessfully. Complete documentation must consider all of the five sce‐ narios previously listed.\n\nInteractive\n\nFinally, great documentation should be interactive. As mentioned, API documentation delivered in HTML format can be hosted on a website and kept up-to-date. But another added benefit is that we can use the browser to actually interact with our API.\n\nFigure 2-1 is an example of interactive documentation using Swag‐ ger.\n\nFigure 2-1. API documentation using Swagger, which offers a Try It Out feature\n\nInteractive API documentation allows anyone, including developers, quality assurance staff, product managers, and support staff to make API calls into a live running server from within the documentation itself. This is possible because our web APIs use the HTTP standard and therefore don’t require special libraries or software to make them work. Imagine allowing developers and QA staff explore your API before they ever write a line of code or an automated test! That is power of interactive documentation.\n\n#4 – Have an Intuitive, Consistent Design An intuitive API is one that makes it easy for a developer to know what to do to use it effectively. By lowering the learning curve of your API, you will ensure that developers experience successes early\n\n12\n\n| Guidelines for Designing a Great API",
      "content_length": 1585,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 19,
      "content": "and often. This results in greater API adoption, longer retention (even in the face of competitors), and developer autonomy resulting in reduced support costs.\n\nFollow these general guidelines to make your API more intuitive:\n\nMake data available easily, rather than hidden or hard to find.\n\nRequire only the information necessary to accomplish the desired task.\n\nOffer both low-level ways of getting things done, as well as higher-level ways of accomplishing common workflows with fewer calls.\n\nUse hypermedia links to inform API clients the available actions at any given point, based on the current state of the data and the permissions of the API client.\n\nOffer only one way to accomplish a task.\n\nFor APIs, consistency is important for a great developer experience because it creates predictability. As developers start to become familiar with your API, they will come to expect the same familiarity as they explore it further. This consistency encompasses a number of areas, including naming, resource URLs, payload formats, and error messaging. Let’s examine each one further.\n\nConsistent naming\n\nAs developers approach your API, the first thing they will notice is the naming conventions that you use. This includes the names of the domain concepts referenced, many of which become the resources used in the URLs of your API. Therefore, naming is critical to the understanding and usage of your API. The following are some tips for incorporating consistent naming:\n\nAvoid abbreviations, as they can be difficult to read and often create confusion as some names may be unclear or inconsis‐ tently abbreviated.\n\nBe consistent with resource names to avoid confusion.\n\nRefrain from referencing internal systems, as this results in requiring insider knowledge to use or comprehend your API.\n\nGuidelines for Designing a Great API\n\n|\n\n13",
      "content_length": 1838,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 20,
      "content": "Consistent resource URLs\n\nAs you design your API, you will need to map out the various URLs that will represent your resources. It is highly recommended that you develop a resource ontology to ensure that URLs are consis‐ tently designed into the API.\n\nIf you are unfamiliar, ontology is a technique used in information science for the naming and typing of entities and their relationships. API ontologies define the structure of your API, from the top-level resources to the nested resources under them.\n\nFigure 2-2 is an example of a URL ontology for an ecommerce web‐ site.\n\nFigure 2-2. An example resource ontology for an eCommerce API\n\nWhen designing your resource ontology, apply the following techni‐ ques to create a more consistent API:\n\nUse plural resource names when offering a collection of resour‐ ces and a singular resource name for a single resource (e.g., /users for a collection of user resources, /user for a single user resource).\n\nUse nested resources to indicate relationships between resour‐ ces.\n\n14\n\n| Guidelines for Designing a Great API",
      "content_length": 1063,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 21,
      "content": "Avoid one-off URLs (e.g., /users/current rather than the more appropriate /user).\n\nWe will cover this topic in more detail in Chapter 4.\n\nConsistent payload formats\n\nFinally, the payload format should be consistent to allow API con‐ sumers to easily construct request payloads and parse response pay‐ loads. Most developers prefer to write helper code to handle this logic. If an API is inconsistent in its approach, developers will have to write one-off code to handle the differences. Follow these patterns for more consistent API payloads:\n\nReuse field names across payloads when possible for better pre‐ dictability (e.g., use firstName and lastName or use fullName, but don’t interchange them).\n\nAvoid abbreviations in field names.\n\nKeep consistent casing rules, usually camelCase or snake_case (e.g., firstName or first_name, but not both).\n\nSelect a single payload format or standard when handling pay‐ loads, including resource representations and search result col‐ lections.\n\nEnsure all error message formats are consistent across the API. This is especially important when an API is built by multiple developers who may otherwise handle error messaging differ‐ ently.\n\nBeyond data: Supporting API-based workflows\n\nAPIs often require more than just data. While data is important, developers seek out APIs to solve a problem. If they wanted to store data, they would push it into a database directly, unless you have data that no one else can provide. They are looking to your API to do something that they don’t want to build themselves. This may be solving difficult problems, building support for collaboration, or providing data analysis.\n\nGreat APIs need to look beyond data access endpoints. While these kinds of endpoints are essential to any API, adding workflow into your API helps developers get things done quickly and with fewer lines of code.\n\nGuidelines for Designing a Great API\n\n|\n\n15",
      "content_length": 1909,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 22,
      "content": "As an example, Twilio only supported conference calls by putting each caller on mute and then managing each caller using the low- level access APIs. The company realized that customers required an affordance to support conference calls at a higher level. The result is that providers were able to remove a lot of hard work from API developers by building in a higher-level conference call API that did the heavy lifting for them.\n\nAs an API provider, it is important to look for usage patterns of how your API may be used across a variety of different types of develop‐ ers. Then begin to build in higher-level APIs that support these workflows, saving them effort and time.\n\nA Note About Hypermedia APIs Hypermedia APIs are a breed of web APIs that inform clients about what actions are possible after a given request. This may take the form of next steps within a workflow, related API resources, and other functional areas of the API. This mimics how we use the Web: we go to a homepage, click the login link, enter our credentials, then navigate to various areas of the application.\n\nUsing hypermedia enables our clients to be more flexible and reduces the amount of business logic we have to code into them. Instead, they look for the existence of specific links within a response payload and offer (or hide) specific actions based on the server’s determination of what is and isn’t allowed. If the business logic needs to change in a workflow, the server simply adds or removes the appropriate hypermedia links that are used to guide the client’s behavior.\n\nSome REST purists believe that hypermedia is a requirement for an API to be labeled REST. While this isn’t strictly the case, hyperme‐ dia often provides additional value to an API by making API con‐ sumption easier and more flexible. However, it isn’t necessarily required to deliver a useful and functionally complete API.\n\n#5 – Design for Security at the Start Teams can become so focused on the features that they forget to integrate security into their API design. Nearly every API will need to provide access to internal business systems, sensitive and per‐ sonal information (PII), and/or public data that co-exists with inter‐\n\n16\n\n| Guidelines for Designing a Great API",
      "content_length": 2242,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 23,
      "content": "nal/private data. Some APIs may provide limited data for free or for specific roles, while others may restrict access to any and all data. Therefore, every API must consider security from the design phase rather than as an afterthought, when it is often too late to make API changes without significant impact. The following are security con‐ siderations that need to be made during API design.\n\nAuthentication\n\nAuthentication is the process of verifying the identity of a particular API consumer. For websites that are built for humans, this is often a form that asks for a username and password. For APIs, there are a number of options available:\n\nPassword-based authentication\n\nWith password-based authentication, a username and password is sent on each request. While this may be secured through the use of transport-level security (TLS), software integrations to APIs may stop working if a user resets her password for any rea‐ son.\n\nAPI-key based authentication\n\nInstead of sharing a username and password, APIs can require the use of an API key that is provided by the service. This key identifies the API client and is not directly tied to a user’s pass‐ word. The API key may be embedded within the URL as part of the request body or in the request header. API keys may be shared with other applications, but revoking access to the API key will cause all applications sharing the key to stop working.\n\nDelegation-based authentication\n\nFor scenarios when third-party applications may want to con‐ nect to an API on someone else’s behalf (e.g., a third-party Twit‐ ter or Facebook client), delegation-based authentication is often the best approach. OAuth is the most popular standard, since it is somewhat like a “protocol of protocols” that allows discon‐ necting the authentication provider that provides API tokens from the API provider. API tokens are granted and revoked as desired by the user, allowing third-party applications to make API calls on their behalf (i.e., delegated access)\n\nGuidelines for Designing a Great API\n\n|\n\n17",
      "content_length": 2045,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 24,
      "content": "Authorization\n\nOnce you have identified yourself through the authentication mech‐ anism, the API must still authorize access to the appropriate data and functional access rules for the system. This may be a direct result of your user account permissions within the API, or the per‐ missions granted through the use of a delegation-based authentica‐ tion mechanism such as OAuth. Each API endpoint’s authorization requirements should be considered during the API design process to ensure that data and access to critical systems are secured properly while the core functionality of the API is maintained.\n\nData leakage\n\nEven with the proper authentication and authorization mechanism, your API design can still have security leaks. While this can happen for a variety of reasons, the most common is that APIs are designed for internal consumption only and are eventually promoted to part‐ ner or public developers. Sensitive data once thought as accessible only by internal systems is now made available to developers outside of the organization.\n\nAs an example, the Tinder API experienced a security breach through data leakage. While its mobile applications did not surface an individual’s exact location, the API did return specific locations within the response payload. This means that any developer had access to an individual’s location, since the data was not removed or scrubbed properly for external consumption. Instead, internal knowledge of another Tinder user’s location was both stored within their backend systems and then made available directly via its API, exposing these users to potential harm.\n\nTo prevent data leakage, design your APIs as if you were releasing the API to the public. This includes adding proper authorization for API consumers to grant or revoke access to specific data fields and functional areas of the API as appropriate.\n\nAlways use TLS\n\nWhile some API endpoints may be providing data that isn’t sensi‐ tive, it is generally best to use TLS to secure all data in motion. This will help protect authentication credentials, as well as prevent eaves‐ dropping when transmitting sensitive data between the API client and server.\n\n18\n\n| Guidelines for Designing a Great API",
      "content_length": 2211,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 25,
      "content": "Designing with security is important\n\nAs you likely realize by now, if security is an afterthought in your API design, everything from the API documentation to assumptions in implementation may need to be revisited. In addition, improper design of your API by ignoring security implications can result in the sharing of sensitive data and perhaps even exposing unnecessary risk to users.\n\n#6 – Share Great Code Examples Documentation is a very important element of the developer experi‐ ence. However, code examples provide the important guidance nec‐ essary for developers to be able to apply the documentation in prac‐ tice.\n\nCode examples come in a variety of forms, from just a few lines that demonstrate how a specific API works, to more complex examples that show how to assemble multiple API calls into a complete work‐ flow.\n\nSo, how do you choose what kind of examples to include? First, you need to understand the developer journey and the various mile‐ stones developers go through as they learn your API.\n\nMilestone 1: First success\n\nInitially, the developer needs to overcome any doubts that the API will solve his needs. This often starts with code examples that allow her to explore the API beyond the interactive documentation.\n\nIt is important to remember that during this phase, the developer just wants to see something work. This is often known as TTFHW, “Time to first Hello World” and is a key metric for determining API complexity. The longer it takes to get a developer to her first “win”, the more likely the developer will leave your API and find a better solution. If there are no alternatives for your API, the developer will build his own solution.\n\nProducts such as Twilio have made it their goal to onboard develop‐ ers in less than five minutes. While this takes considerable focus and investment, your goal should be to find the shortest possible route, then keep working to shorten the time as your API matures.\n\nTo achieve a low TTFHW, provide concise examples that remove all need for boilerplate code. Look at the following example:\n\nGuidelines for Designing a Great API\n\n|\n\n19",
      "content_length": 2114,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 26,
      "content": "require \"stripe\" Stripe.api_key = \"sk_test_BQokikJOvBiI2HlWgH4olfQ2\"\n\nStripe::Token.create( :card => { :number => \"4242424242424242\", :exp_month => 6, :exp_year => 2016, :cvc => \"314\" }, )\n\nNotice in this example that there is little code to write. Simply fill-in your API key and the credit card credentials to try it out.\n\nBad example code requires that you write code to use the example. This requires you to learn more about the API before you can try it out. Never require developers to write code to complete an example when first trying out your API.\n\nMilestone 2: Workflow support\n\nAfter the developers have had some time to acquaint themselves with your API using your easy-to-use examples, the next step is to begin to demonstrate the API based on how they will want to use it.\n\nWorkflow examples focus more on achieving specific goals than applying coding best practices. This means that you want to convey clarity over code performance, clear intent over code quality. Use copious inline comments to explain why each step is necessary. Be willing to include hard-coded values for easier reading. Choose vari‐ able and method names that make it easy to read. Focus more on behavior than handling errors at this point.\n\nIt is important to note that while these examples will be more com‐ plex than those found from the first milestone, they shouldn’t exceed the height of the screen. The examples need to be short enough to explain the concepts but not too long that they require considerable time to understand. It is often best to demonstrate sce‐ narios that are easily understood and likely map to your customer needs.\n\nMilestone 3: Production-ready integration\n\nOnce the developer has followed your simple examples and then tried some workflows, the final step is to help her understand how to integrate your API into her production environment. This\n\n20\n\n| Guidelines for Designing a Great API",
      "content_length": 1909,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 27,
      "content": "includes how to catch errors to help developers properly trouble‐ shoot their integration code. It also includes demonstrating how to catch and recover from bad data provided by end users. Finally, if you are enforcing rate limiting, then show not only how to obtain the current rate limits for their account, but also provide tips for reducing the number of API calls required.\n\n#7 – Provide Helper Libraries Web APIs have a huge advantage: they are built on the hard work of the authors of the HTTP specification. This means that any devel‐ oper can pick up their favorite programming language, select an HTTP client library, and make API calls. They don’t need anything else to make it happen.\n\nHelper libraries allow developers to make API calls using a special library built for their specific programming language. As an exam‐ ple, a Ruby helper library can be provided to allow developers to consume your API directly, without having to write the code neces‐ sary to handle the lower-level HTTP logic required for web APIs.\n\nWhile API providers are not required to release helper libraries, they often accelerate developer success. This is especially the case for mobile developers, who are accustomed to working with helper libraries rather than raw HTTP. Many API providers that wish to reach mobile developers choose to produce a helper library for iOS and a helper for Android.\n\nFor APIs that will likely be used outside of a mobile platform, you may opt to provide helper libraries for Java, JavaScript, Python, Ruby, Go, PHP, and .NET. What languages you choose depend upon your intended audience. For example, if your target audience is enterprise developers, then Java and .NET should be priority. For web developers, you may choose to focus on Python, PHP, Java‐ Script, Ruby, and Go. Whatever you do, don’t assume that your team’s preferred language platform is what your customers will be using. Do the research to be sure you have prioritized your focus.\n\nIt is important to note that each helper library should be docu‐ mented fully and follow each language’s programming idioms. This will prevent a library written in Ruby from looking like it was built for a Java developer. This may require hiring outside expertise to consult on how the library should work, or perhaps even build it for your organization.\n\nGuidelines for Designing a Great API\n\n|\n\n21",
      "content_length": 2374,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 29,
      "content": "The Design-First API Process\n\nTraditional software development is often focused on internal devel‐ opment teams that have access to the source code that makes the software function. Or, at the very least, they have access to the inter‐ nal developers and data administrators to ask questions.\n\nWeb APIs, however, are more social in nature. They require collabo‐ ration between the developers consuming the API and the develop‐ ers that built the API. They only have the API design and documen‐ tation to guide them. Developers consuming an API do not have access to the source code, database diagrams, or an internal knowl‐ edge base on why the API operates a certain, quirky way. They can‐ not copy-and-paste the source code for an API and make the changes they need to get their job done.\n\nThis means that our goals for our API design need to reflect simplic‐ ity and clarity and to anticipate the needs of developers and the end users who will indirectly consume the API from a web or mobile application. This is a difficult challenge for any team, no matter how experienced they may be with the particular software or business domain. Therefore, heavy emphasis should be placed on the API design process, including how your team translates product require‐ ments.\n\nThis chapter provides a process and some guidelines for API model‐ ing and design that your team may wish to incorporate into their process. Feel free to adjust as necessary to support your specific organizational requirements.\n\n23",
      "content_length": 1500,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 30,
      "content": "User Interface Wireframes to Drive API Design In the case of an API that is being developed in tandem with a mobile or web interface, wireframing the user interface will help drive a top-down view of how the API will be used. The wireframes won’t define every required feature of the API, but they will focus on the key goals of end users: what they will do and how they will do it. This will have a large impact on the API, as often the user interface requires more complex interactions that the API will need to sup‐ port.\n\nWhile many APIs start with simple data-access functionality, the user interface will expose the gaps in your APIs as they need to per‐ form more complex tasks. It will also expose the number of API calls that will be required to accomplish a given task. This is especially important with regard to mobile applications, where every HTTP call to an API occurs over an unreliable cellular network.\n\nAs we will discuss later, a simple wireframe or static mockup of the screens can help validate your API design. Be sure to schedule time into your project plan to design any web and mobile screens, pref‐ erably in time to help validate your API design.\n\nAPI Modeling Just as a beautiful web design begins from a wireframe, a great API design begins with modeling. The goal of API modeling is to trans‐ late the product requirements into the beginnings of a high-level API design. API modeling ensures that both developers and end users have their goals met.\n\nThe API modeling process is comprised of five steps:\n\n1. Identify the participants, or actors, who will interact with your API.\n\n2. Identify the activities that participants wish to achieve.\n\n3. Separate the activities into steps that the participants will per‐ form.\n\n4. Create a list of API methods from the steps, grouped into com‐ mon resource groups.\n\n24\n\n|\n\nThe Design-First API Process",
      "content_length": 1873,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 31,
      "content": "5. Validate the API by using requirements artifacts to test the com‐ pleteness of the API.\n\nThe process is designed to be iterative, allowing you to return to a previous step if you discover that something is missing or needs to be adjusted. Let’s look at how to perform each step.\n\nStep 1: Identify the Participants The first step is to identify the participants, sometimes called actors, who will interact with the API. Unlike a user interface, an API design must factor in both humans and non-humans who may interact with your API. Some examples include:\n\nSystem administrators (i.e., your company’s administrators)\n\nAccount administrators (i.e., your customer’s administrators)\n\nUsers of the system, including their various roles (e.g., users, managers, and moderators)\n\nInternal or external software\n\nOther Internet-connected devices\n\nFor each participant, you will capture their name and perhaps a short description of what they do (see Table 3-1).\n\nTable 3-1. Some example participants for our project management API\n\nParticipant\n\nDescription\n\nProject manager\n\nThe person in charge of the project\n\nProject member\n\nSomeone assigned to the project and tasks\n\nSystem administrator\n\nManages global settings\n\nBy considering the different types of participants, it will help you consider your API design from a variety of intended uses.\n\nStep 2: Identify the Activities Activities are the outcomes that your participants will expect your API to provide. These activities focus on the job to be done, not how\n\nAPI Modeling\n\n|\n\n25",
      "content_length": 1529,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 32,
      "content": "to do it. We will capture the steps required to accomplish the activi‐ ties in our next modeling process.\n\nAlthough your API may focus on only one activity, most APIs must support more than one activity to deliver value to developers. If you find yourself with only one activity, try asking what each participant is trying to achieve. Most likely, you will find more than one activity will be required of your API once you evaluate the activities for each of your participants identified in step 1.\n\nFor each activity, capture a short name, description, and the partici‐ pant(s) that will be involved in the activity (see Table 3-2).\n\nTable 3-2. Some example activities for our project-management API\n\nActivity name\n\nDescription\n\nParticipant(s)\n\nManage project\n\nCreate, update, and archive a project\n\nProject manager\n\nView project details\n\nView project tasks and overall status\n\nProject manager, project member\n\nManage project tasks\n\nCreate, update, and archive tasks for a project\n\nProject manager, Project member\n\nStep 3: Separate the Activities into Steps Once you have a list of activities, it is time to break them into steps. Each step may involve one or more participants but must be exe‐ cuted by a single participant at a time.\n\nYou may find that you may be missing some details about how an activity should be performed. This is an indicator that you should involve one or more subject matter experts (SMEs) who can provide greater insight and details into how the system should work. These experts may be business analysts, customers, and/or quality- assurance teams familiar with the requirements.\n\nFor each activity step, capture the activity name, a short name for the step, a description, and a list of participants who may perform the step. Table 3-3 is an example of documenting the activity steps for the “manage project tasks” activity in the previous modeling step.\n\n26\n\n|\n\nThe Design-First API Process",
      "content_length": 1922,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 33,
      "content": "Table 3-3. “Manage project tasks” activity step example for our project management API\n\nActivity\n\nActivity step name Description\n\nParticipant(s)\n\nManage project tasks\n\nAdd task to project\n\nAdds a task to an existing project\n\nProject manager, project member\n\nManage project tasks\n\nArchive project task\n\nArchives a task in an exist- ing project\n\nProject manager, project member\n\nManage project tasks\n\nMark project task as complete\n\nMarks a task in an existing project as complete\n\nProject manager, project member\n\nYou may notice that you see recurring patterns or steps across activi‐ ties. That is expected and may provide insight into possible API design and/or code reuse.\n\nStep 4: Identify the Resources and Candidate APIs Once you have the activities and steps identified, you will begin to see specific business entities emerge. These are your resource candi‐ dates that may become actual API resources. Others may appear to be resources but may instead be activities that will be performed outside of the API itself and therefore won’t become actual API resources. Since this is the modeling phase, that is perfectly fine. Our API design process will help filter out these unnecessary items.\n\nBecause this is the modeling and not the design phase, we do not want to focus on the HTTP specifics. Instead, focus on the high- level API only. The details of how you will implement the API, including the specific URLs, HTTP verbs, and response codes will emerge as we move into the full API design process. Table 3-4 is an example of how to document the project tasks API that we have identified as a result of our API design model.\n\nTable 3-4. “Project tasks API”: Project-management API example\n\nMethod\n\nParticipant(s) authorized for API\n\nAdd task to project\n\nProject manager, project member\n\nArchive project task\n\nProject manager, project member\n\nAPI Modeling\n\n|\n\n27",
      "content_length": 1870,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 34,
      "content": "Method\n\nParticipant(s) authorized for API\n\nMark project task as complete\n\nProject manager, project member\n\nStep 5: Validate the API Model Once you have an API model defined, you can use the model to vali‐ date that it meets the requirements of internal developers, partner or public developers, and the end user. There are three techniques that can help validate your API model:\n\nThe API walkthrough\n\nIf you have mobile or web mockups, walk through each screen to determine which API will be used to satisfy the data being displayed or functionality being performed. Revisit any areas that you may have missed to ensure that you have a complete API model.\n\nUse-case validation\n\nUsing existing use cases, step through each one to identify any gaps in your API. This is especially useful if user interface mockups haven’t been completed yet, or if some of the API will not have a user interface associated with it. This is often the case for APIs designed for machine-to-machine integration rather than end-user functionality.\n\nBusiness-process diagrams\n\nFor APIs that will be supporting business-workflow processes, first diagram the workflow(s). For each step in the workflow, map your API model to each step to ensure that you can accom‐ plish all necessary aspects of the workflow.\n\nAs you validate your APIs, look for methods that are missing. You may also want to make notes about APIs that have dependencies on other APIs or that may experience heavy usage. While not necessary, this may guide some of your decisions as you move into the design and development phases.\n\nNext Step: Detailed API Design With the API model complete, we now have a sketch of what our API will look like. The next step is to detail the design by applying HTTP and REST principles. We will cover this in the next chapter.\n\n28\n\n|\n\nThe Design-First API Process",
      "content_length": 1840,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 35,
      "content": "API Design Details\n\nWhile API modeling is focused on mapping requirements to the API, the API design process maps the API model to HTTP, the lan‐ guage of the Web.\n\nTransitioning from the model to design phase will require a variety of decisions. Some of these decisions will become obvious, while others may require some careful thought and planning. The more decisions you leave until the development phase, the more likely your API design will be compromised due to your delivery schedule.\n\nRather than making these decisions quickly during the development phase, we encourage you to spend sufficient time with the API design process to ensure that your API design is complete. This will help you focus on building a great web API and avoiding too many changes after your API has been released.\n\nAn HTTP Primer As we move from the API design model to the details of how the web API will be realized using HTTP, it is important to review how HTTP works. If you are familiar with HTTP, feel free to skip this section.\n\nHTTP Is Request/Response HTTP is a request/response protocol. The HTTP client contacts a server and sends a request. The server processes the request and returns a response indicating a success or failure. It is important to note that HTTP is stateless, which means that every request must\n\n29",
      "content_length": 1313,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 36,
      "content": "provide all of the details necessary to process the request on the server.\n\nUniform Resource Locators (URLs) Uniform resource locators, or URLs, provide a address of where to locate a resource, such as a web page, image, or data, from an API. A URL is divided into the following parts:\n\nScheme\n\nHow we want to connect, (e.g., HTTP [unsecure] or HTTPS [secure]).\n\nHostname\n\nThe server to contact (e.g., api.example.com).\n\nPort number\n\nA number ranging from 0 to 65535 that identifies the process on the server where the request is to go (e.g., 443 [optional, defaults to 80 for HTTP and 443 for HTTPS]).\n\nPath\n\nThe path to the resource being requested (e.g., /projects [default is /, which indicates the homepage]).\n\nQuery string\n\nContains data to be passed to the server. Starts with a question mark and contains name/value (e.g., foo=bar) pairs, using an ampersand as a separator between (e.g., ?page=1&per_page=10).\n\nHTTP Verbs HTTP request verbs indicate the type of action being requested from the URL. For APIs, they are often one of the following:\n\nGET\n\nRetrieve a collection or individual resource.\n\nPOST\n\nCreate a new resource or request custom action.\n\nPUT\n\nUpdate an existing resource or collection.\n\nDELETE\n\nDelete an existing resource or collection.\n\n30\n\n| API Design Details",
      "content_length": 1287,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 37,
      "content": "There are more HTTP request verbs in the HTTP specification. This list contains the majority of HTTP verbs useful for a modern web API.\n\nHTTP Requests A client request is composed of the following parts:\n\nRequest verb\n\nInforms the server about the type of request being made (e.g., retrieve, create, update, delete, etc.)\n\nURL\n\nThe universal address of the information being requested\n\nRequest header\n\nInformation about the client and what is being requested in name:value format\n\nRequest body\n\nThe request details (may be empty)\n\nThe following is an example HTTP request with no request body:\n\nGET http://www.oreilly.com/ HTTP/1.0 Proxy-Connection: Keep-Alive User-Agent: Mozilla/5.0 [en] (X11; I; Linux 2.2.3 i686) Host: oreilly.com Accept: image/gif, image/x-xbitmap, image/jpeg, */* Accept-Encoding: gzip Accept-Language: en Accept-Charset: iso-8859-1, *, utf-8\n\nThe following are examples of API requests:\n\nGET /accounts\n\nRetrieves all accounts in the accounts resource collection\n\nGET /accounts/{id}\n\nRetrieves a specific account by the given ID\n\nPOST /accounts\n\nCreates a new acccount\n\nPUT /accounts/{id}\n\nUpdates an account by the given ID\n\nAn HTTP Primer\n\n|\n\n31",
      "content_length": 1170,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 38,
      "content": "DELETE /accounts/{id}\n\nDeletes an account by the given ID\n\nHTTP Responses A server response is composed of the following parts:\n\nServer response code\n\nA number indicating if the request was successful or not\n\nResponse header\n\nInformation about what happened in name:value format\n\nResponse body\n\nContains the response payload, often HTML, XML, JSON, or an image (may be empty)\n\nThe following code is an example HTTP request with an HTML response body:\n\nHTTP/1.1 200 OK Date: Tue, 26 May 2015 06:57:43 GMT Content-Location: http://oreilly.com/index.html Etag: \"07db14afa76be1:1074\" Last-Modified: Sun, 24 May 2015 01:27:41 GMT Content-Type: text/html Server: Apache\n\n<html>...</html>\n\nResponse codes are grouped into families, with the 2xx response codes indicating success, 4xx response codes indicating that the cli‐ ent failed to format the request properly, and 5xx response codes indicating a server error. The following are the most common server response codes used for web APIs:\n\n200 OK\n\nThe request has succeeded.\n\n201 Created\n\nThe request has been fulfilled and resulted in a new resource being created.\n\n202 Accepted\n\nThe request has been accepted for processing, but the process‐ ing has not been completed.\n\n32\n\n| API Design Details",
      "content_length": 1243,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 39,
      "content": "204 No Content\n\nThe server has fulfilled the request but does not need to return a body. This is common for delete operations.\n\n400 Bad Request\n\nThe request could not be understood by the server due to mal‐ formed syntax.\n\n401 Unauthorized\n\nThe request requires user authentication.\n\n403 Forbidden\n\nThe server understood the request, but is refusing to fulfill it.\n\n404 Not Found\n\nThe server has not found anything matching the requested URI.\n\n500 Internal Server Error\n\nThe server encountered an unexpected condition which preven‐ ted it from fulfilling the request.\n\nBuilding Your Resource Ontology An ontology is simply a classification of concepts. An API ontology captures the set of resources you will be offering, and their relation‐ ships to other resources. It is generally realized through your API’s URL structure.\n\nIf you modeled your API already, you likely have a list of candidate resources that will be part of it. If not, take some time and model your API to help you identify your resources. To build your ontol‐ ogy, begin by creating a list of the resources, placing them at the top of the URL structure (e.g., /projects and /tasks).\n\nDefining URLs Through Relationships Next, you will need to determine if your resources all belong at the top level, or if some of them should be nested under parent resour‐ ces. To do this, we first need to understand the relationships between each of the resources.\n\nRelationships between resources can be categorized into three types: independent, dependent, and associative. Those familiar with data‐ base design will recognize these relationship types and will quickly understand them. For those not familiar, the following list contains\n\nBuilding Your Resource Ontology\n\n|\n\n33",
      "content_length": 1736,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 40,
      "content": "a description of each of the three types, with further information in Table 4-1:\n\nIndependent\n\nIndependent resources can exist stand alone without the other’s existence, but may reference each other. The URLs for both resources often exist at the top level.\n\nDependent\n\nDependent resources cannot exist without the existence of the parent resource. The URL for the dependent resource exists as a nested resource of its parent.\n\nAssociative\n\nAssociative resources have a relationship that contains or requires additional properties to describe it. Associative resour‐ ces may be nested under one parent or may be placed as a top- level resource and treated as an independent resource.\n\nTable 4-1. Examples of resource relationships\n\nRelation Type\n\nResources\n\nMeaning\n\nIndependent\n\n/projects, /tasks\n\nTasks can exist with or without a project\n\nDependent\n\n/projects, /projects/{id}/ tasks\n\nTasks must belong to a project instance\n\nAssociative\n\n/users, /projects, /projects/ {id}/collaborators\n\nUsers assigned to a project become col- laborators\n\nIn our project-management API example, we have to make a critical decision: whether tasks exist outside of a project or not. If they can, then both resources are independent and therefore both exist at the top level of the URL structure (e.g., /projects and /tasks). However, if tasks must belong to a project, then tasks are dependent on a project and must exist as a nested resource under the specific project instance (e.g., /projects/{id}/tasks).\n\nUnderstanding and applying resource relationships is critical to a great API design. Weigh your resource URL designs carefully and understand the impact of your decisions.\n\n34\n\n| API Design Details",
      "content_length": 1692,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 41,
      "content": "Mapping Resource Lifecycles to HTTP Verbs Once you determine your resource URL structure, you can then map your resource lifecycles to the necessary HTTP verb or verbs. We have four core HTTP verbs that we will focus on, though a few others exist when you need them for uncommon situations.\n\nYour API model will provide insight into the lifecycle requirements of your resources. Review your model and notice the verbs you used for each resource. Some resources may require all verbs in our life‐ cycle: search, create, read, update, and delete. However, other resources may not require update or delete actions. Other resources may be read-only. Therefore, the requirements identified during the modeling phase will inform your API design.\n\nAs you model your API, you will notice a common pattern between the verbs you choose and the eventual resource lifecycle they require. Table 4-2 is a common mapping between verbs used in modeling and the verbs in HTTP.\n\nTable 4-2. Common modeling actions to HTTP verb mappings\n\nModeling Actions\n\nTypical HTTP Verb\n\n“List”, “Search”, “Match”, “View All”\n\nGET collection\n\n“Show”, “Retrieve”, “View”\n\nGET resource instance\n\n“Create”, “Add”\n\nPOST create a new resource\n\n“Replace”\n\nPUT update a resource collection\n\n“Update”\n\nPUT update a resource instance\n\n“Delete All”, “Remove All”, “Clear”, “Reset” DELETE delete a resource collection\n\n“Delete”, “Remove”\n\nDELETE delete a resource instance\n\n<other verbs>\n\nPOST custom action on a resource instance\n\nWhile you may use different verbs during modeling, they will likely map to one of the common HTTP verbs. If they don’t, you may need to revisit the concept and see if it can be broken down into a\n\nMapping Resource Lifecycles to HTTP Verbs\n\n|\n\n35",
      "content_length": 1734,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 42,
      "content": "resource with a specific lifecycle. Otherwise, you may need to con‐ sider a custom POST action on a particular resource instance (e.g., POST /projects/{id}/approve).\n\nMapping Response Codes For each API endpoint you identified in the previous step, you will need to consider what response code(s) to return. While we hope that most responses will indicate a success, sometimes the client will fail to provide all of the correct details necessary to fulfill a request.\n\nIt is important to map both success and error codes in the design phase, as it will be part of our documentation delivered to develop‐ ers consuming our API. It will also inform your team in the com‐ plexity of each API endpoint prior to development, to help with the estimation process (see Table 4-3).\n\nTable 4-3. Common HTTP verb to response-code mappings\n\nType\n\nCondition\n\nCommon response code Verb(s)\n\nSuccess Request was successful\n\n200 OK\n\nAll verbs\n\nSuccess Resource created successfully\n\n201 Created\n\nPOST\n\nSuccess Request was successful, but not\n\n202 Accepted\n\nPOST\n\ncomplete yet\n\nSuccess Resource deleted successfully\n\n204 No Content\n\nDELETE\n\nError\n\nNot authentication credentials pro- vided\n\n401 Unauthorized\n\nAll verbs\n\nError\n\nUser not authorized or server for- bids requested action\n\n403 Forbidden\n\nAll verbs\n\nError\n\nResource not found\n\n404 Not Found\n\nGET, PUT, DELETE\n\nError\n\nFilter parameters provided were not valid\n\n400 Bad Request\n\nGET, POST, PUT\n\n36\n\n| API Design Details",
      "content_length": 1460,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 43,
      "content": "Validating Design Through Documentation and Prototyping As your API design starts to emerge, you should start the API docu‐ mentation process. At this stage, you may not have all of the details of what your resource representations will look like—that is expected.\n\nBy documenting your API design early, it will encourage the team to focus on documentation throughout the development process. It will also encourage validation through feedback from internal or external developers by sharing your API design with them early rather than waiting until launch.\n\nYou can begin to document the high-level design using one of your favorite API definition formats, such as Swagger, RAML, Blueprint, or IO Docs. Each of these formats can convert your API design into beautiful interactive docs, one of our key characteristics of a great API design. As your resource structures begin to take shape, you can capture those additional details, along with examples to complete your documentation.\n\nIn addition to documentation, prototyping is another effective way to validate your API design. Prototypes come in two common forms: a static prototype and a working prototype.\n\nA static prototype is just a method of returning resource representa‐ tions in one or more formats, such as XML or JSON. The static pro‐ totype is either stored on the local filesystem or served via a web server.\n\nStatic prototypes allow developers to begin to integrate the search (i.e., GET collection) and read (i.e., GET a resource instance) por‐ tions of the lifecycle. However, the filesystem or web server cannot process POST, PUT, or DELETE requests, so static prototypes are limited. To get beyond this limitation, a working prototype is required.\n\nWorking prototypes offer more functionality than static prototypes, allowing any or all functionality to be delivered. The focus of a working prototype is to simplify more complex interactions, such as third-party integrations or connecting to existing SOAP-based serv‐ ices or legacy systems.\n\nValidating Design Through Documentation and Prototyping\n\n|\n\n37",
      "content_length": 2078,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 44,
      "content": "Working prototypes are not meant to be production-ready imple‐ mentations, so they can take shortcuts or flatten complex data struc‐ tures for ease of implementation. You can use the programming lan‐ guage and framework you plan to use for the production implemen‐ tation or select something simple that provides the minimal func‐ tionality required.\n\nPutting It All Together APIs can offer several advantages for businesses, including faster innovation and increased revenue. Every member of the organiza‐ tion, including executives, product managers, and developers, must be willing to see APIs as an investment that will create business value.\n\nA significant portion of your investment must be in the design of the API to provide a great developer experience. Only then will you pro‐ duce APIs that developers will love.\n\n38\n\n| API Design Details",
      "content_length": 849,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 45,
      "content": "About the Author\n\nJames Higginbotham is a seasoned API consultant with experience in architecting, building, and deploying APIs. He is also a speaker and trainer. As an API consultant, he enjoys helping businesses bal‐ ance great API design and product needs. As a trainer, he enjoys equipping cross-functional teams to integrate their talents toward building first-class APIs for their product or enterprise systems.\n\nAcknowledgments\n\nI would first like to thank D. Keith Casey, Jr., whose generosity knows no bounds.\n\nI would also like to thank Mike Amundsen for his feedback on an early draft of this book.\n\nAnd finally, my sincere thanks to the many people that have directly and indirectly influenced this book through lively discussions, both online and offline.",
      "content_length": 768,
      "extraction_method": "Unstructured"
    }
  ]
}