{
  "metadata": {
    "title": "Hands-on Test-Driven Development Using Ruby",
    "author": "Unknown Author",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 237,
    "conversion_date": "2025-12-25T18:14:13.640026",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "Hands-on Test-Driven Development Using Ruby.pdf",
    "extraction_method": "Unstructured"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 2-9)",
      "start_page": 2,
      "end_page": 9,
      "detection_method": "topic_boundary",
      "content": "Greg Donald\n\nHands-on Test-Driven Development Using Ruby, Ruby on Rails, and RSpec\n\nGreg Donald Clarksville, TN, USA\n\nISBN-13 (pbk): 978-1-4842-9747-6 https://doi.org/10.1007/978-1-4842-9748-3\n\nISBN-13 (electronic): 978-1-4842-9748-3\n\nCopyright © 2024 by Greg Donald This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microﬁlms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed. Trademarked names, logos, and images may appear in this book. Rather than use a trademark symbol with every occurrence of a trademarked name, logo, or image we use the names, logos, and images only in an editorial fashion and to the beneﬁt of the trademark owner, with no intention of infringement of the trademark. The use in this publication of trade names, trademarks, service marks, and similar terms, even if they are not identiﬁed as such, is not to be taken as an expression of opinion as to whether or not they are subject to proprietary rights. While the advice and information in this book are believed to be true and accurate at the date of publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or omissions that may be made. The publisher makes no warranty, express or implied, with respect to the material contained herein.\n\nManaging Director, Apress Media LLC: Welmoed Spahr Acquisitions Editor: Melissa Duffy Development Editor: James Markham Coordinating Editor: Gryfﬁn Winkler\n\nCover designed by eStudioCalamar\n\nCover image by Pexels@Pixabay.com\n\nDistributed to the book trade worldwide by Apress Media, LLC, 1 New York Plaza, New York, NY 10004, U.S.A. Phone 1-800-SPRINGER, fax (201) 348-4505, e-mail orders-ny@springer-sbm.com, or visit www.springeronline.com. Apress Media, LLC is a California LLC and the sole member (owner) is Springer Science + Business Media Finance Inc (SSBM Finance Inc). SSBM Finance Inc is a Delaware corporation. For information on translations, please e-mail booktranslations@springernature.com; for reprint, paperback, or audio rights, please e-mail bookpermissions@springernature.com. Apress titles may be purchased in bulk for academic, corporate, or promotional use. eBook versions and licenses are also available for most titles. For more information, reference our Print and eBook Bulk Sales web page at http://www.apress.com/ bulk-sales. Any source code or other supplementary material referenced by the author in this book is available to readers on GitHub (https:// github.com/Apress). For more detailed information, please visit https://www.apress.com/gp/services/source-code.\n\nPaper in this product is recyclable\n\nThis book is dedicated to my wife and best friend, Sunni. She has been a constant source of support and encouragement during the writing of this book.\n\nContents\n\n1\n\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . What Are We Building? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Our Database . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Why Another TDD Book? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . My Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . How to Read This Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\nWhy You Should Trust Me\n\nAudience and Prerequisites\n\n2 What Is Test-Driven Development?\n\n7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Problems with Late Test Writing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 No Code Design 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Passing by Accident . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 Code Spikes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 The Red-Green-Refactor Development Cycle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 Red Phase. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 Green Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 Refactor Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 Wash, Rinse, and Repeat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 Code Design. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 No Broken Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 Maintaining Focus. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Acceptance Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Code Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n\nAdvantages of Building Software Using TDD\n\n3 Getting Started with Ruby . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 Installing Homebrew . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 Installing rbenv . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 Installing Ruby . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n\n4 Getting Started with Ruby on Rails . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 Installing Bundler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 Installing Ruby on Rails. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 Installing PostgreSQL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 Installing Node.js . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n\n1 1 2 3 3 4 5 5\n\nvii\n\nviii\n\n5\n\n6\n\n7\n\n8\n\n9\n\nCreating a New Ruby on Rails Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n\nRunning Rails Locally\n\nSetting Up RSpec and FactoryBot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 Installing RSpec . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 Installing FactoryBot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 The User Factory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 How to Run Specs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 User Model Validations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 The Page Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 RSpec’s “subject” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 FactoryBot “build” vs. “create” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 The Page slug. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 Page Factory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 Final Thoughts on Model Validations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 User Spec Cleanup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 Advice on Writing Too Many Specs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n\nAdding Initial Models The User Model\n\nCreating Pages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 Shared Partial Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 More View Specs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 Homepage Layout. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 CSS Framework. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 Layout Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 Sidebar Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77\n\nBuild Homepage Contents View Specs\n\nSidebar Contents. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 Search As a Service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 Implementing a Search Service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 Searching by Term . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 Adding a Search Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86 Displaying Search Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88 Pages Archive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91 Creating a List of Months and Years . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 Archive List View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 Archive Integration Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n\nSearching for Pages\n\nContents\n\nContents\n\n10 Page Tags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 Adding Page Tags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 Creating the Tag Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 Creating the Page Tag Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107 Jumping Over Relationships . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 Tagging Pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 After Save Callbacks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 Display Tags on Pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114 Handling Missing Tags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119 Refactor Duplicate Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122\n\n11\n\nImages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 Active Storage for Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 Getting Started with Active Storage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 Adding an Image Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124 Serving Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127 Adding an Image Controller. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132\n\n12 User Authentication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133 Improving Our User Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133 Password Hashing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133 Adding Fields to Our User Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134 Add a Hashing Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136 Authenticating a User . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137 Improving Authentication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139 Password Conﬁrmation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144 Skipping Password Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148\n\n13 Administration\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149 Adding Active Admin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149 Adding the Gem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149 Testing Active Admin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150 Logging In . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150 Admin Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 Managing Pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158 Overriding Active Admin Form Field Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161 Factoring Out Duplicate Login Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164 Previewing a Page . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166 Managing Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 Viewing Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 Uploading New Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172 Editing Images. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176 Deleting Images. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180 Admin Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182\n\nManaging Users\n\nAdding New Users\n\nix\n\nx\n\nDeleting Users . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186\n\n14 Odds and Ends\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187 Build a Sitemap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187 Pagination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192 Fixing Specs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198 Styling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199 CSS in Rails . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199 Styling Our Public Pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199 Styling Our Admin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203 Wrapping Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205 Stimulus and Turbo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209\n\nCode Highlighting\n\n15 Bonus: Deploy to Production . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211 Why This Non-cloud Approach? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211 Acquiring a Production Linux Server . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211 Getting Production Ready . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212 Installing Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212 Installing Ruby . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213 Installing Phusion Passenger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213 Conﬁguring PostgreSQL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215 Storing Code on GitHub . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 Installing Capistrano. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 Conﬁguring Capistrano. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 Deploying Our Rails Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219 Conﬁguring Our Apache Virtual Host . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223 Logging In . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225\n\nIndex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227\n\nContents\n\nAbout the Author\n\nGreg Donald has been a professional software engineer since 1996 and has worked with Ruby on Rails since 2006. Prior to that, he worked on many Perl and PHP projects, ﬁnding the applications messy and hard to maintain. He became a test driven development enthusiasts after having seen the results of software written in various forms, and determining no style was more successful than TDD. He decided to write this book to promote TDD and share his positive experiences using it.\n\nxi",
      "page_number": 2
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 10-22)",
      "start_page": 10,
      "end_page": 22,
      "detection_method": "topic_boundary",
      "content": "About the Technical Reviewer\n\nEldon isa senior technologist, creator, and United States Marine Corps veteran. He’s the author of two software development books. His career has allowed him to work across a wide variety of technologies and domains. His career has taken him from working in successful startups in roles ranging from senior developer to chief architect to working as a principal technologist for a global software consulting ﬁrm, helping enterprises and companies rescue software projects and/or evolve their software delivery capabilities.\n\nThese days, he works as a technical fellow with a mission of raising the bar of software development globally for a technology company providing tools, AI, and research to advance the rule of law.\n\nCurrently, he lives in Florida where he enjoys scuba diving and creating video content.\n\nxiii\n\nIntroduction\n\nHello, and welcome! I’m very excited to share with you my book about test-driven software development. I’ve been a software engineer for over 25 years, and I’ve seen the results of software written using many different styles and techniques. It wasn’t so long ago that we didn’t even write tests for our software. At some point, some very smart people realized that writing tests for our software was actually a good idea. Our tests would provide us with conﬁdence that our software worked as expected and even more importantly keep us from getting phone calls in the middle of the night to ﬁx things that would break in production.\n\nNot long after we started writing tests, some other very smart people realized that writing our tests ﬁrst would give us an opportunity to think about what we were going to write before we would write it. It would give us a target to aim at, in effect. This was the birth of test-driven development (TDD). TDD is a style of software development where we write our tests ﬁrst, see that they are failing as expected, and only then do we pursue writing the code to make those tests pass.\n\nThis is the central idea of my book. We will think about what we want to do, then we will capture that idea with a properly failing test. We will then write the code to make the test pass. We will then refactor our code to make it better, or prettier, or less repetitive, and then we will write another test. We will repeat this process over and over until we have a fully functional web application.\n\nLet’s get started!\n\nWhat Are We Building?\n\nAs you pick up this book and look inside at the ﬁrst few pages, you may be wondering, what exactly are we going to build? I’m so glad you asked! We will build a fully functional blog ! A “blog,” short for “weblog” or “web log,” is a web application that allows its administrator (you) to post articles to the Web. Instead of downloading premade blog software, for example, WordPress,1 we’re going to build our own blog software from scratch.\n\nWe’ll be using the Ruby2 programming language and the Ruby on Rails3 web framework to build everything. These are the best tools for the job, in my opinion. Ruby is a very expressive and powerful programming language, and Ruby on Rails is a very powerful web framework.\n\n1https://wordpress.org/ 2https://ruby-lang.org/ 3https://rubyonrails.org/\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_1\n\n1\n\n1\n\n2\n\n1 Introduction\n\nFigure 1-1 Blog database diagram\n\nWe’ll use the test-driven development (TDD) style of software design and engineering, which means we’ll write failing tests ﬁrst and only then write our implementation code to get our failing tests passing.\n\nWe’ll use the RSpec4 testing framework to write our tests. RSpec describes itself as a tool for performing “behavior-driven development” and is in fact the best tool available for testing Ruby code. If you’ve never used RSpec before, don’t worry; in this book, I’ll cover more than enough to get you started and productive.\n\nOur blog will be a simple web application overall, but will be complex enough to demonstrate the test-driven development style of software development. Our blog will allow us to create and update pages as well as search them by keyword and tag them for easy categorization.\n\nLet’s take a look at our database design next.\n\nOur Database\n\nWe will use the PostgreSQL5 relational database management system (RDBMS) to store our blog’s data. When it comes to free and open source databases, PostgreSQL is best in its class.\n\nAt the end of the book, our database design will look similar to the diagram in Figure 1-1.\n\n4https://rspec.info/ 5https://postgresql.org/\n\nWhy Another TDD Book?\n\nWe’ll go into much more detail about our database design in later chapters, but I want to give you an initial idea of what we’ll be building early on. We will have database tables for users, pages, tags, and images. Our image table is not connected to any of the other previously mentioned tables. Our tag table is connected to our page table through our page_tags join table. Each of our pages will belong to a single user. With this design, we can have more than one user, and each user can be an author of many pages.\n\nWe will build up our database design as we go, adding new tables and columns as we need them,\n\nas that’s the nature of practicing proper test-driven development.\n\nWhy Another TDD Book?\n\nThe main goal of this book is to provide a practical, hands-on introduction to the test-driven style of software design and engineering.\n\nMany books on the topic of test-driven development have been written before this one. Some of them are actually very good, but none of them were written in the practical, hands-on style of this book. In fact, very few books are written in this style.\n\nThis book covers the building of an entire web application, from start to ﬁnish. Our focus application, a blog, is the most practical thing I could think to build, given my audience of software engineering readers. Every software engineer has their own online blog, right? A blog is simple enough that it can be covered in a single book, but complex enough that it can be used to demonstrate my favorite parts of RSpec while building a Ruby on Rails web application.\n\nMost other TDD books are written in a small-problem sort of writing style. They cover single topics, one at a time, barely more than a reference guide. They do not cover the entire process of building a software application from start to ﬁnish, using TDD. As a result, they are, in my opinion, less practical and much less useful for actually learning practical TDD.\n\nMy Motivation\n\nAbout ﬁve years ago, I joined a team of software engineers who were busy working on a very important (people’s lives were at stake) large-scale web application. They were several months into it at the time, and there were deadlines. The application was being written in Ruby on Rails, and the team was using TDD to build it. They were practicing Extreme Programming (XP),6 as described by Kent Beck,7 pretty much to the letter. I had heard of TDD and XP before, but had never actually practiced them. I had never even pair-programmed8 an entire day prior to joining the team. I was eager to learn, and little did I know at the time that I was working with some of the best software engineers I had ever met.\n\nThese girls and guys were amazingly agile. They refactored their code constantly. They were always looking for ways to reduce code complexity and improve their processes. They were constantly learning new things, and they were always teaching each other new things. They were very passionate about their craft and passionate about leveling up their team even more so.\n\nI soon realized I was in over my head. I was a n00b to the team, to TDD, and to XP. They did not\n\nseem to care about any of that.\n\n6www.extremeprogramming.org/ 7http://wiki.c2.com/?KentBeck 8http://wiki.c2.com/?PairProgramming\n\n3\n\n4\n\n1 Introduction\n\nThey were very patient with me, and they were completely willing to teach me everything they knew. They taught me how to practice proper TDD and XP. They taught me how to write failing tests ﬁrst and how to write code that is easy to test. They taught me how to write tests that supplied courage for when I would later perform fearless refactoring.\n\nOver the next couple of years, I became a much better software engineer. The ﬁrst major change I noticed in myself was how I had stopped worrying about code I had recently pushed into production. I was no longer thinking about code breaking in production during my off hours or how these sorts of breakages were often followed by an emergency phone call to hurry to ﬁx things. I had stopped worrying about code breaking because I knew my code was completely covered with well-written tests and very unlikely to break.\n\nAnother change I noticed in myself was that I was writing cleaner code. I was writing code that was easier to later understand. I was only writing the code that was necessary to get my tests into a passing state. I got into a pattern of knowing that once my tests pass, my implementation work was done. Moving on to refactor any ugliness or code duplication is my only next step before writing my next failing test.\n\nI’m telling you all of this because I want you to understand how I’ve come to learn and respect test-driven development. I learned it by doing it, for many years, with a team of experts. I know that developing software using TDD produces better software than not using TDD to develop software. I know this because I have seen the ﬁnal results with my own eyes.\n\nWhy You Should Trust Me\n\nI’ve been a computer programmer for a long time. If we’re counting uncompensated work, then I’ve been programming since 1984, when I wrote my ﬁrst bits of BASIC9 code on my grandpa’s TI- 99/4A,10 saving my work to a cassette tape. I went on to write more advanced programs and games in BASIC at my junior high school, where we had Apple IIe11 computers in our computer lab. A few years later, in high school, we had IBM PC clones12 in our computer lab, and it was at this time I learned to program in Turbo Pascal.13\n\nI joined the US Navy in 1990 and didn’t have much contact with computers for the next few years. When I got out in 1995, I discovered the World Wide Web was a thing, and I became instantly hooked on my newly found favorite hobby, building web pages. I taught myself HTML and enough Perl14 to be dangerous, and by late 1996, I had landed my ﬁrst paid programming job as a web developer working on Perl-based shopping cart software.\n\nSo if we’re counting compensated work, I’ve been a self-taught professional software engineer since late 1996. I’ve written code in almost every major programming language and on many different operating systems and platforms. My focus has been on web development for the most part, but I also have signiﬁcant experience working on mobile applications and games, in native code, for both Android and iOS. I was an early publisher on Google’s Android platform, having the ﬁrst published Blackjack game there.\n\n9http://hopl.info/showlanguage.prx?exp=176 10www.ti994.com/ 11www.old-computers.com/museum/computer.asp?st=1&c=83 12www.ibm.com/ibm/history/exhibits/pc/pc_1.html 13http://progopedia.com/implementation/turbo-pascal/ 14www.perl.org/\n\nHow to Read This Book\n\nIn 2005–2006, I started working with Ruby on Rails. I had some experience with Ruby before that, automating processes on Linux, but didn’t get into Ruby seriously until I started working with Rails. Rails was my ﬁrst experience using the model-view-controller15 (MVC) design pattern, and it was a revelation to me. Prior to that, I had worked on many Perl and PHP16 projects, and I had always thought they were messy and hard to maintain, and there was certainly never anything like a test-suite present.\n\nI tell you all this to instill a bit of trust. I’ve seen software written many different ways, and I’ve seen the results of those pursuits. I’ve never seen software written using TDD that was not better than software written without TDD.\n\nAudience and Prerequisites\n\nI’ve seen many programmers, both beginners and those who have been programming for years, who can’t begin to imagine writing failing tests ﬁrst and only then writing the code to make those tests pass. This book will be useful in teaching you how to do that, providing conﬁdence and courage.\n\nThis book is written for beginner to intermediate Ruby programmers who are interested in learning to use TDD with RSpec to test and build web applications using Ruby on Rails. It is assumed that you have some experience with Ruby and Ruby on Rails and that you have read the Getting Started with Rails17 guide that’s available for Rails, or something similar.\n\nHow to Read This Book\n\nThis book should be read in a linear fashion, from beginning to end. The chapters are numbered and should be read in that order. This is not a reference guide and does not provide complete coverage of any particular topic. Those kinds of reference books already exist for many of the topics discussed in this book, and duplicating their authors’ efforts would not provide much value.\n\nThis is a work-along book. Every effort has been made to make this book self-contained, so that you can read it from cover to cover and not need to refer to any other resources. Nevertheless, I’ve been quite liberal in my use of footnote references to other resources, so please do visit them for additional information on unfamiliar topics.\n\n15http://wiki.c2.com/?ModelViewControllerHistory 16www.php.net/ 17https://guides.rubyonrails.org/getting_started.html\n\n5\n\nWhat Is Test-Driven Development?\n\nTest-driven development is a powerful software development technique where the test (or spec) is written before the implementation code. Initially, the test will fail because the implementation code does not exist yet. This situation with a failing test is expected and is known to drive out minimal implementation code changes or additions to get the failing test into a passing state. It may sound complicated at ﬁrst, but with a thorough demonstration of the beneﬁts, followed by a bit of practice, you’ll begin to prefer doing things this way.\n\nBut what happens when we don’t do test-driven development? What happens when we write our\n\ntests after the implementation code? I’m so glad you asked!\n\nProblems with Late Test Writing\n\nIn this section, we will explore some of the problems with writing tests after the implementation code has already been written.\n\nNo Code Design\n\nWhen we write our tests after the implementation code, we’re typically not thinking too much about the design of our code. We’re mostly just writing tests to make sure our code works. This is a very different, and less thoughtful, mindset than when we’re writing tests before the implementation code. When we write our tests before the implementation code, we’re thinking about the design of our code, how we want our code to behave and be used. We’re hopefully also thinking about how we want our code to be extended in the future, probably by us.\n\nPassing by Accident\n\nWhen we write our tests after the implementation code, we will inevitably write tests that pass by accident. This is because we’re not taking the time to see the tests fail ﬁrst.\n\nWe should never trust tests that we did not see fail ﬁrst.\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_2\n\n2\n\n7\n\n8\n\n2 What Is Test-Driven Development?\n\nThe one exception is that you may work on a team where you will not actually see every single newly written test fail before it’s made to pass. Obviously, we don’t want to delete our team members’ tests and hard work. But we should always have a high degree of skepticism about our own tests and pursue seeing them fail appropriately.\n\nThis advice of trusting tests based on individual experience with seeing them fail also comes with a bit of counter advice: don’t ever be afraid to delete a test that cannot be made to fail by temporarily reversing or commenting implementation code. Delete unfailable tests as soon as possible. Your continuous integration1 server will thank you.\n\nCode Spikes\n\nSometimes, we may need to explore our ideas, with code, a bit before we know what our desired behavior will be. Often, we write this sort of code knowing up front we will eventually throw it away. This act of writing throwaway code is known as code spiking and almost certainly also accompanies the deliberate act of not writing any tests beforehand. This situation should be rare, and we should always be thinking about how we can write tests that will fail when we’re done with exploring our ideas.\n\nPractically speaking, anytime I’m done with spiking some bits of code, I will comment the code out and then proceed with writing failing tests. I then uncomment my spiked code, a bit at a time usually, to get my tests passing. This is a very useful technique for safely exploring ideas with code and for junior TDD practitioners who have a hard time with test writing.\n\nWe’ve now explored some of the problems with writing tests after the implementation code. Let’s\n\nnow explore the beneﬁts of writing tests before the implementation code.\n\nThe Red-Green-Refactor Development Cycle\n\nTest-driven development can be thought of as a three-phase development cycle as shown in Figure 2-1.\n\n1. Red 2. Green 3. Refactor\n\nLet’s step through each phase and discuss it in more detail, with simple but practical code\n\nexamples.\n\nRed Phase\n\nIn the red phase of the TDD cycle, an initially failing test is written. Most often, this will just be a single test. It should be a minimal concept or idea designed to drive out a desired behavior.\n\n1http://wiki.c2.com/?ContinuousIntegration\n\nThe Red-Green-Refactor Development Cycle\n\nFigure 2-1 The red-green-refactor development cycle\n\nImagine we want a method that adds two numbers and returns a result. An example failing test\n\nmight be\n\nit 'equals 4' do\n\nresult = add(2, 2) expect(result).to eq(4)\n\nend\n\nThis test will fail because there is a call to an add method that currently does not exist. This is a very useful test because it will focus our attention on our implementation code changes.\n\nNotice how most of the test is written in a way that it ﬂows like a couple of English sentences.\n\nThis is RSpec’s developer-friendly DSL in action; our tests are easy to read and understand.\n\nGreen Phase\n\nNext, we add our implementation code changes to turn the red failing test into a green passing test.\n\nThe ﬁrst error we get is the missing method error. We could add an empty method to satisfy the\n\nerror:\n\ndef add end\n\nAfter adding that, our test will still fail, but it will fail with a different error. It will complain about the argument signature being wrong. We can ﬁx that error with adding the desired arguments to the method signature:\n\ndef add(x, y) end\n\n9\n\n10\n\n2 What Is Test-Driven Development?\n\nFinally, we get to the end where the empty method returns nil instead of the value of the arguments being added together. We can ﬁx that by implementing the arguments being added together and returned:\n\ndef add(x, y)\n\nx + y\n\nend\n\nIt depends on the situation and your own experience level with the codebase for how ﬁne-grained you choose to have your red-green-refactor loop operate. I think stepping through it like this is a good way to get started with TDD, but I certainly don’t always do it this way. I sometimes even ﬁnd myself writing more than one test at a time and then implementing the code to make them all eventually pass.\n\nRefactor Phase\n\nAfter the green phase, we reach the refactor phase. In this simple example, there’s not much that can be refactored, but that’s a very short-term problem for anything larger than a small hello-world sort of program. Imagine if you decided to rename the add method’s x and y arguments to something else; perhaps you decide a and b would be more appropriate. The updated add method might then look like this:\n\ndef add(a, b)\n\na + b\n\nend\n\nThis sort of refactoring is considered safe since there is a test that will inform us if we break the implementation code. When we run the test again, it should still pass, letting us know our refactor was successful.\n\nAny sort of refactoring done outside of proper test coverage is dangerous. Software engineers who practice test-driven development always prefer implementation code changes be done under test, even if that means backﬁlling missing test coverage ﬁrst.\n\nThis section gave you a small taste of what you’re in store for with the rest of the book.\n\nWash, Rinse, and Repeat\n\nThe instructions from the back of the shampoo bottle “wash, rinse, and repeat” imply an endless cycle of performing the same tasks again and again (or just twice depending on how literal you take the meaning of the word “repeat”). In TDD, this is exactly what we do. At the end of our refactor phase,\n\nAdvantages of Building Software Using TDD\n\nwe’re ready to repeat the cycle and begin with a new failing test. A repetitious red, green, refactor loop informs us sooner rather than later when we’ve accidentally gone down a wrong path.\n\nAdvantages of Building Software Using TDD\n\nIn the next section, we will discuss the beneﬁts of practicing test-driven development. These beneﬁts are not just for the individual software engineer but also for the entire software engineering team.\n\nCode Design\n\nTest-driven development encourages us to think through our code design before implementing the code.\n\nEvery experienced software engineer has at some point in their career worked on a poorly designed application codebase. Often, these codebases have little or no test coverage, making refactoring and improving them very dangerous. Even the smallest change over here could cause some unexpected breakage over there. Surprisingly, broken code in production is no fun at all!\n\nTDD gives us the power to make small incremental changes to our code design without the danger of unknowingly breaking things. Sure, sometimes our changes do break things; that’s to be expected. But with adequate test coverage, these breakages will alert us as soon as possible, so we can make informed decisions about the direction of our evolving code design. We may choose to stop and undo our latest change, or we may choose to push on and repair our test failures. Either way, it causes us to consider everything more carefully before we proceed.\n\nNo Broken Windows\n\nBroken Window Theory refers to urban decay. A single unﬁxed broken window in a neighborhood leads to a second broken window and so on until the entire community is in complete disrepair. This way of thinking about urban decay easily lends itself to how we think about software engineering. The idea of a broken window in software engineering can manifest itself in different ways. The ﬁrst way that comes to my mind is when a bug appears in the codebase and (hopefully) causes a test to begin to fail, and then for whatever reason no one immediately pursues ﬁxing it. The longer the unﬁxed bug lives on, the more risk there is for data corruption, user dissatisfaction, lesser revenues, or security issues.\n\nAnother type of broken window is a sort of generic term we software engineers refer to as technical debt, the unpaid time we still owe to the codebase that we didn’t pay when it was initially due. This can be anything like outdated software dependencies or duplicate lines of code that need to be factored out into a shared code module.\n\nThe longer these broken windows accumulate on top of each other, the more effort required to ﬁx\n\nthem when we do eventually get around to it.\n\n“I’ll ﬁx it, no need to remind me every 8 months!” The most important phase of TDD is the green phase. We never proceed with new development without getting our tests back to a fully passing state. A “green” codebase tells us all known software bugs are ﬁxed and any recently updated software dependencies are working as expected.\n\nGood software engineers ﬁx their broken windows as soon as possible!\n\n11\n\n12\n\n2 What Is Test-Driven Development?\n\nMaintaining Focus\n\nTDD keeps you focused on the problem, and just the problem.\n\nThere’s a software principle and acronym YAGNI2 that means you aren’t gonna need it. TDD- focused software engineers believe, when given a user story with well-written acceptance criteria, it is the job of the software engineers to do no more and no less than exactly what the story requests be done.\n\nThere is real danger in adding things not explicitly requested in the user story. Another engineer could already be adding the thing you are thinking to add while working on their current story. Or there could be a follow-on story where the new behavior is described there. We just don’t know what tomorrow’s user stories will bring, and with ﬁnite resources, it’s better to not guess.\n\nAcceptance Testing\n\nTDD lends itself naturally to automatically validated code. If your tests closely match the given acceptance criteria, then your implementation code will usually result in the desirable feature changes and behavior.\n\nA very nice side effect of using TDD is that it tells you exactly when you are done working on a user story. If all the new acceptance criteria tests are passing and there are no more refactorings in sight, then it’s usually time to deliver the story. So ship it!\n\nCode Quality\n\nTDD helps software engineers maintain high code quality. Implementation code is typically leaner and more precise than code written outside of TDD. Code refactorings occur more often when tests exist, helping to reduce the danger of change. We software engineers feel more empowered to pursue code cleanups and refactorings when we know the risk of breaking anything is lower.\n\nThese ways of thinking about software engineering play out across software engineering teams too. An individual team member is much more likely to care about code quality if other engineers are seen caring too.\n\nSummary\n\nThis chapter discussed the philosophy and beneﬁts of practicing test-driven development. You may not yet be convinced that TDD is the right way to go; I certainly wasn’t convinced early on. It just takes time to reprogram your brain to think to write the tests ﬁrst, especially if you’ve been writing software for a while already. Don’t give up; the struggle is worth the reward!\n\n2www.techtarget.com/whatis/deﬁnition/You-arent-gonna-need-it\n\nGetting Started with Ruby\n\nIn this chapter, we’ll install tools we can use to manage our installed Ruby versions. We will issue commands to our local operating system via the command-line interface1 (CLI) using a shell interpreter, which depending on your operating system is likely to be bash or zsh. On macOS, we can use the Terminal application to issue these commands, and similar programs are available on other operating systems:\n\n1. Homebrew 2. rbenv 3. Ruby\n\nInstalling Homebrew\n\nOn macOS, I use Homebrew2 to install most of my local software development stack. There’s a shell command on the Homebrew homepage I use to install it:\n\nURL=https://raw.githubusercontent.com/Homebrew/\\ install/HEAD/install.sh bash -c \"$(curl -fsSL $URL)\"\n\nIf trusting this way of installing Homebrew via direct URL execution makes you nervous, you can install Homebrew manually too:\n\nhttps://docs.brew.sh/Installation\n\n1www.codecademy.com/article/command-line-interface 2https://brew.sh\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_3\n\n3\n\n13",
      "page_number": 10
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 23-31)",
      "start_page": 23,
      "end_page": 31,
      "detection_method": "topic_boundary",
      "content": "14\n\n3 Getting Started with Ruby\n\nHomebrew also works on Linux and Windows Subsystem for Linux. If you’re working under those\n\nenvironments, you can ﬁnd more information here:\n\nhttps://docs.brew.sh/Homebrew-on-Linux\n\nInstalling rbenv\n\nAs previously mentioned, we will use rbenv3 to manage our Ruby installations. Using rbenv allows us to easily switch between different versions of Ruby with just a few keystrokes. This provides us with ﬂexibility to use different versions of Ruby for different projects and to easily upgrade to newer versions of Ruby when they are released.\n\nWe can install rbenv with the following brew command:\n\nbrew install rbenv\n\nAfter installation, rbenv then requires initialization in our command SHELL.4 We will place this initialization in our .bashrc or .zshrc ﬁle depending on which SHELL we are using. This will allow us to use rbenv commands in our shell and have it automatically conﬁgured anytime we start a new shell.\n\nzsh users will add this to the end of “.zshrc” and then source it:\n\necho 'eval \"$(rbenv init - zsh)\"' >> ~/.zshrc\n\n. ~/.zshrc\n\nbash users will perform a similar command and then source it:\n\necho 'eval \"$(rbenv init - bash)\"' >> ~/.bashrc\n\n. ~/.bashrc\n\nIf you’re not sure which SHELL you’re using, you can ﬁnd out by issuing the command echo\n\n$SHELL.\n\nInstalling Ruby\n\nInstalling Ruby will require we ﬁrst install some dependencies. Our Ruby compilation will fail or may not function correctly if we are missing these dependencies. We can install them from Homebrew using the brew command again:\n\n3https://github.com/rbenv/rbenv 4https://datacarpentry.org/shell-genomics/01-introduction/\n\nInstalling Ruby\n\nbrew install openssl readline\n\nNow that we have our dependencies installed, we can use “rbenv” to install the latest version of Ruby:\n\nrbenv install 3.2.2\n\nThis command may take several minutes or longer to complete depending on our system specs.\n\nPlease note, the latest version will probably be different by the time you’re reading this book. You can ﬁnd the current latest version by running the rbenv list command with grep and sort, like this:\n\nrbenv install -L | grep -E '^\\d' | sort -V\n\nUsing grep with the proper regular expression removes all the more exotic implementations of Ruby from the list: jruby, rbx, and others. In this book, we’re going to use the original MRI5 (Matz’s Ruby Interpreter) version of Ruby, created by Yukihiro Matsumoto6 and friends.\n\nAfter rbenv installs your chosen version of Ruby, you can set that version to be your global\n\nversion:\n\nrbenv global 3.2.2\n\nNow we can run the which command and see that ruby and the Ruby gem command are both installed via rbenv shims:\n\nwhich ruby /Users/gd/.rbenv/shims/ruby\n\nwhich gem /Users/gd/.rbenv/shims/gem\n\nIf these which commands do not work for you right away, you may need to restart your terminal or shell application.\n\nrbenv shims are used to provide us the ability to easily switch between Ruby versions. If you\n\nwould like to pursue a deeper understanding of rbenv shims, more information is available.7\n\n5www.ruby-lang.org 6https://dbpedia.org/page/Yukihiro_Matsumoto 7https://github.com/rbenv/rbenv#understanding-shims\n\n15\n\n16\n\n3 Getting Started with Ruby\n\nLet’s now check that ruby is actually executable and is the version we installed:\n\nruby -v ruby 3.2.2 (2023-03-30 revision e51014f9c0)\n\nSuccess!\n\nIt’s also worth mentioning that there are other ways to accomplish what we’ve done here. For example, instead of using rbenv we could have instead used rvm.8 On macOS, instead of Homebrew we could have used MacPorts.9 My point is that if you already have a preference for other tooling to manage your Ruby installations, then feel free to use them.\n\nSummary\n\nIn this chapter, we installed Homebrew, rbenv, and Ruby. We learned to use the brew command to install software on our local machine. We also learned how to use rbenv to manage our Ruby versions. In the future, we can easily switch to a new version of Ruby with a single command. We can also now have any number of Ruby projects using different versions of Ruby.\n\n8https://rvm.io/ 9www.macports.org/\n\nGetting Started with Ruby on Rails\n\nIn the previous chapter, we installed the Ruby language itself. In this chapter, we will install the Ruby on Rails1 framework and some additional tools Ruby software engineers use for Ruby on Rails application development:\n\n1. Bundler 2. Ruby on Rails 3. PostgreSQL\n\nInstalling Bundler\n\nBundler2 is a package manager that manages the dependencies of a Ruby application. Our project will use Bundler to manage the dependencies of our Ruby on Rails application speciﬁcally. Bundler is a Ruby gem, so we will use the Ruby gem3 command to install it:\n\ngem install bundler\n\nThis should produce output similar to the following:\n\nSuccessfully installed bundler-2.4.10 Parsing documentation for bundler-2.4.10 Done installing documentation for bundler after 0 seconds 1 gem installed\n\nBy the time you read this, the latest version of Bundler may be different, so feel free to use the latest version of Bundler available.\n\n1https://rubyonrails.org/ 2https://bundler.io/ 3https://guides.rubygems.org/rubygems-basics/\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_4\n\n4\n\n17\n\n18\n\n4 Getting Started with Ruby on Rails\n\nInstalling Ruby on Rails\n\nRuby on Rails is a web application framework written in the Ruby programming language. It’s designed to make programming web applications faster and easier by making opinionated decisions about what every web developer needs in their web development software stack. Ruby on Rails enables us to write less code while accomplishing more than any other language and framework, given similar effort.\n\nAs a framework, Ruby on Rails consists of several individual Ruby gems, but we only need to install a single gem to pull everything in at once. Let’s use the Ruby gem command to install the “rails ” gem:\n\ngem install rails\n\nThis command will generate a lot of output and should include something similar to the following:\n\nSuccessfully installed rails-7.0.4.3 Parsing documentation for rails-7.0.4.3 Done installing documentation for rails after 0 seconds 1 gem installed\n\nBy the time you read this, the latest version of Rails may be different, so feel free to use the latest available version.\n\nInstalling PostgreSQL\n\nPostgreSQL4 is a very popular relational database management system (RDBMS) used by a lot of Ruby on Rails applications and other web applications in general. We will use PostgreSQL to store the data for our Ruby on Rails application.\n\nAs you may have guessed, PostgreSQL is available to install from Homebrew, so we will use the\n\nbrew command to install it:\n\nbrew install postgresql@14\n\nAgain, by the time you read this, the latest version of PostgreSQL may be different, so feel free to use the latest version of PostgreSQL available. The PostgreSQL developers put a lot of effort into maintaining backwards compatibility, so there’s usually no need to worry about using the latest version of PostgreSQL.\n\n4www.postgresql.org/\n\nInstalling Node.js\n\nAfter installing PostgreSQL, we need to start the PostgreSQL server:\n\nbrew services start postgresql@14\n\nAs a sanity check, we should use the PostgreSQL psql command to connect to the PostgreSQL server and run a simple SQL query:\n\npsql -d postgres -c \"SELECT version()\"\n\nThis should yield a result containing the version of PostgreSQL we just installed. If it does not work, and you get an error message about psql not being found, you may need to add the directory where the psql program was installed to your PATH environment variable. You can do this by adding the following line to your . ∼/.zshrc (or . ∼/.bashrc ) ﬁle:\n\nexport PATH=\"/opt/homebrew/bin:$PATH\"\n\nThis will prepend the directory path /opt/homebrew/bin to your existing $PATH and then re-export the new value to your shell environment. After making the change, run the following command to source and re-apply the contents of your . ∼/.zshrc ﬁle:\n\n. ~/.zshrc\n\nIf /opt/homebrew/bin is not the location where psql was installed, you will need to change the path to the location where psql was actually installed. It may, for example, be installed in /usr/local/bin or some other location like /opt/homebrew/Cellar/postgresql/ 14.x/bin.\n\nInstalling Node.js\n\nNode.js5 is a JavaScript runtime environment that we need for our Ruby on Rails application development. We won’t be using Node directly, but Rails commands, like the rails new command, will use Node.js to compile JavaScript assets for our application as we develop.\n\nNode.js is available to install from Homebrew, so we will use the brew command to install it:\n\nbrew install node\n\n5https://nodejs.org/\n\n19\n\n20\n\n4 Getting Started with Ruby on Rails\n\nAfter the install completes, we can see that Node.js is installed by running the following commands:\n\nwhich node node --version npm --version npx --version\n\nIf these commands do not complete with successful output, you may need to add the directory where the node, npm, and npx programs were installed to your PATH environment variable, as we did with the psql program earlier.\n\nNow that we have Node.js installed, we can use it to install some Javascript packages Rails will need for our Ruby on Rails application development and very importantly when we run the rails new command shortly. We will use the npm command to install the esbuild, nodemon , and sass packages:\n\nnpm install -g esbuild nodemon sass\n\nNow we are ready to create our new Ruby on Rails application.\n\nCreating a New Ruby on Rails Application\n\nIn this book, we will create a Ruby on Rails application in the form of a blog. We will use the Ruby on Rails rails new6 command to create our new Ruby on Rails application. Before proceeding, let’s discuss our rails new command-line options we will use to conﬁgure our new Ruby on Rails application creation.\n\nWe are going to use RSpec for testing, so for now we will use the -skip-test option to tell Ruby on Rails to skip creating its own test directory and related ﬁles. There’s currently no command-line option to add RSpec (which is preposterous), so we will add RSpec manually later.\n\nWe will use the --database=postgresql option to tell Ruby on Rails to conﬁgure our app for use with PostgreSQL as the database for our application. This option will cause a Gemﬁle entry to be added for the pg gem and will preconﬁgure our config/database.yml ﬁle for use with PostgreSQL.\n\nJavaScript support has evolved a lot in recent years, and Ruby on Rails has a new way of handling JavaScript dependencies called importmap.7 We will use that along with esbuild8 for our JavaScript bundler.\n\nFinally, we will use Bootstrap9 for our CSS framework. Bootstrap is a very popular CSS framework that provides lots of convenient CSS classes to make building web applications easier for both web and mobile apps.\n\n6https://guides.rubyonrails.org/command_line.html#rails-new 7https://github.com/rails/importmap-rails 8https://esbuild.github.io/ 9https://getbootstrap.com\n\nCreating a New Ruby on Rails Application\n\nBefore you blast me with an email about how Bootstrap is the old way and how Tailwind is the new hotness, I know. I’m going to use Bootstrap for this book because it’s what I know best and it’s what I like.\n\nAnother consideration is in what directory do we run the rails new command? The simple answer is that it doesn’t matter much. The rails new command we’re going to use makes a directory and puts everything inside it. You can then move this directory around to where you want it to live, now or in the future.\n\nI personally like to store my Rails-speciﬁc code in my\n\n. ∼/workspace/rails directory, so I\n\nwill run the rails new command after I change into that directory, like this:\n\ncd ~/workspace/rails\n\nBe sure to use whatever directory you prefer for your Rails code.\n\nrails new \\\n\n--skip-test \\ --database=postgresql \\ --javascript=esbuild \\ --css=bootstrap \\ blog\n\nRunning the rails new command will take some time to complete. When it’s done, you will have a new directory called blog containing the ﬁles for our new Ruby on Rails blog application.\n\nChange directory into the blog directory:\n\ncd blog\n\nWe can now start our local Rails server using Bundler’s bundle exec command. This command will run Rails in the context of our application’s Gemﬁle, which will ensure that we are using the correct version of Ruby and Rails and all of the other gems we need for our application.\n\nbundle exec rails server\n\nWe should see output similar to the following:\n\n=> Booting Puma => Rails 7.0.4.3 application starting in development => Run `bin/rails server --help` for more startup options Puma starting in single mode... * Puma version: 5.6.5 (ruby 3.2.2-p53) (\"Birdie's Version\")\n\n21\n\n22\n\n4 Getting Started with Ruby on Rails\n\nFigure 4-1 The Ruby on Rails error page\n\nMin threads: 5 * Max threads: 5 * Environment: development * * Listening on http://127.0.0.1:3000 * Listening on http://[::1]:3000 Use Ctrl-C to stop PID: 11869\n\nIf we visit the Rails welcome page at http://127.0.0.1:3000 in our web browser, we should see an error page like the one in Figure 4-1. This is because we haven’t created the database named blog_development that is deﬁned in our config/database.yml ﬁle yet. We can ﬁx the error by creating the database using the rails db:create command:\n\nbundle exec rails db:create\n\nRunning this command will produce the following output:\n\nCreated database 'blog_development' Created database 'blog_test'\n\nAs seen in the output, we actually get two databases, a development database and a test database. The development database is used for development, and the test database is used strictly for running tests that we will begin writing shortly.\n\nNow if we visit the Rails welcome page at http://127.0.0.1:3000 in our web browser, we should\n\nsee the Rails welcome page as referenced in Figure 4-2.",
      "page_number": 23
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 32-39)",
      "start_page": 32,
      "end_page": 39,
      "detection_method": "topic_boundary",
      "content": "Creating a New Ruby on Rails Application\n\nFigure 4-2 The Ruby on Rails welcome page\n\nRunning Rails Locally\n\nAs mentioned previously, we can run our Ruby on Rails application locally using the rails server command along with the bundle exec preﬁx. That’s ﬁne for developing Ruby code, but our Rails application will also contain CSS and JavaScript code. There are many different ways to handle CSS and JavaScript in a modern Ruby on Rails application, in both development and production environments.\n\nTo ease the burden of managing Ruby, CSS, and JavaScript in our local development environment, the rails new command we ran earlier automatically created a Procfile.dev ﬁle in our application’s root directory. This ﬁle contains process deﬁnitions we need to run our Rails application in our local development.\n\nIf we have a look at the Procfile.dev ﬁle, we will see the following contents:\n\nweb: unset PORT && env RUBY_DEBUG_OPEN=true bin/rails server js: yarn build --watch css: yarn watch:css\n\nAs is often the case with other ﬁles generated by the rails new command, this ﬁle tends to evolve over time and may appear slightly different in the future. For now, we can see there are three lines, and each line represents a process that will be run when we do something with this ﬁle, but how do we run it?\n\n23\n\n24\n\n4 Getting Started with Ruby on Rails\n\nFigure 4-3 Running Rails using foreman\n\nWe need to use the foreman10 command to run the processes deﬁned in our Procfile.dev ﬁle. The foreman command can be acquired by installing the foreman gem using the command:\n\ngem install foreman\n\nBefore we can actually run foreman we need to install yarn, a tool that will be used to automate compiling our Javascript and CSS ﬁles for us. There are many ways to install yarn. I install it from Homebrew using the command:\n\nbrew install yarn\n\nOnce we have foreman and yarn installed, we can run foreman using the command:\n\nforeman start -f Procfile.dev\n\nThis will start the web, js, and css processes deﬁned in our Procfile.dev ﬁle. The output will look similar to Figure 4-3. The web process is the Rails server we started earlier. The js process is a process that will watch for changes to our JavaScript ﬁles and rebuild them as needed. The css process is a process that will watch for changes to our CSS ﬁles and rebuild them as needed. This will save us a lot of time when developing our Ruby on Rails application.\n\n10https://github.com/ddollar/foreman\n\nSummary\n\nWe’re almost ready to begin writing our Ruby on Rails blog application in earnest. If you are planning on following along with the rest of the book, you would be wise to commit your code to a version control system at this point.\n\nSummary\n\nIn this chapter, we installed the Ruby on Rails framework, along with Bundler and PostgreSQL. We created a new Ruby on Rails application using the rails new command. We also learned how to run our Ruby on Rails app in our local development environment using the foreman command. Next, we will add RSpec and FactoryBot to our Ruby on Rails application to facilitate writing our ﬁrst tests.\n\n25\n\nSetting Up RSpec and FactoryBot\n\nRSpec1 is a testing framework for Ruby. RSpec is available to us as a domain-speciﬁc language2 (DSL) written in Ruby and used to test Ruby code. RSpec tests the behavior of Ruby code and considers itself to be a “behavior-driven development” (BDD) framework. RSpec is most widely used for testing Rails applications, but can be used to test any Ruby code.\n\nRuby on Rails by default comes with the testing framework Test::Unit. In the previous chapter when we used the rails new command to create our Rails blog application, we added the --skip-test option to disable Test::Unit. Like most Rails developers, we will use RSpec instead of Test::Unit.\n\nInstalling RSpec\n\nRSpec is a gem, so we can add it to our Rails blog application by adding it to our Gemfile and running the bundle command. We want RSpec to be available in both the Rails development and test environments, so we will add it to both the :development and :test groups in our Gemﬁle. The Gemﬁle addition should then look like this:\n\ngroup :development, :test do\n\ngem 'rspec-rails'\n\nend\n\nLet’s save our Gemﬁle changes and run the bundle command:\n\nbundle\n\nRunning the bundle command or more verbosely the bundle install command will install the rspec-rails gem and all of its dependencies. The bundle command will also update the Gemfile.lock which is used to lock our gems and their dependent gems to speciﬁc versions. This\n\n1https://rspec.info 2www.jetbrains.com/mps/concepts/domain-speciﬁc-languages/\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_5\n\n5\n\n27\n\n28\n\n5 Setting Up RSpec and FactoryBot\n\nis important because it ensures we are using the gem versions we mean to in all of our potential Rails environments.\n\nRSpec has now been added to our blog application, but we need one more step to get it working.\n\nWe need to run the rails generate rspec:install command:\n\nbundle exec rails generate rspec:install\n\nWe should see the following output:\n\ncreate .rspec create spec create spec/spec_helper.rb create spec/rails_helper.rb\n\nWe can now verify that RSpec is installed and conﬁgured by running the rspec command:\n\nbundle exec rspec\n\nWe should see the following output:\n\nNo examples found.\n\nFinished in 0.0002 seconds (files took 0.0351 seconds to load) 0 examples, 0 failures\n\nThis output tells us that RSpec is installed and properly conﬁgured within our Rails application. We have no tests yet, so RSpec lets us know that it found “no examples” to run. In RSpec lingo, an example is actually a test, or a spec. We will soon be adding our ﬁrst RSpec example, so let’s move on for now.\n\nInstalling FactoryBot\n\nFactoryBot3 is a Ruby gem that provides a framework and domain-speciﬁc language (DSL) for deﬁning and using factories. A FactoryBot factory is a blueprint for creating instances of Ruby classes, or in our use case, Rails ActiveRecord objects. FactoryBot is most widely used for testing Rails applications, but can also be used to test any sort of Ruby code.\n\nBut do we really need FactoryBot? Can’t we just create our test data using Rails and ActiveRecord\n\nobjects directly?\n\n3https://github.com/thoughtbot/factory_bot\n\nInstalling FactoryBot\n\nWe could indeed create all of our test data for our blog application using only Rails ActiveRecord objects. For example, we could create a new user object using User.new, and then we could create a new page object using Page.new(user:) that belongs to that user. But this is tedious and error prone, especially if we need to create similar test data many times over or if we need test data with particular traits.\n\nFactoryBot provides more concise and ﬂexible ways to create test data. We can deﬁne reusable traits that we can then mix and match to reliably create exactly the test data that we need. We can also choose to only build (not create) test data, without actually saving it to our database. This is very useful when we want to test ﬁeld validation errors, for example.\n\nFactoryBot is of course packaged as a Ruby gem, and there is a Rails-speciﬁc version called factory_bot_rails that we can use. Let’s add it to our application by adding the following line to our Gemfile and running the bundle command:\n\ngem 'factory_bot_rails'\n\nWe want FactoryBot to be available in all Rails environments, so we will add it outside of any group blocks in our Gemﬁle.\n\nAnytime we add a gem to our Gemﬁle, we need to then run the bundle command to install the new gem and its dependencies. We’ve done it a few times already, so to save space we won’t show the output anymore.\n\nWe need to integrate FactoryBot into our Rails application. So let’s add it to our spec/spec_\n\nhelper.rb ﬁle. Near the top, add the following line:\n\nrequire 'factory_bot_rails'\n\nThen, just inside our RSpec.configure block, let’s add the following:\n\nconfig.include FactoryBot::Syntax::Methods\n\nThese additions to our RSpec conﬁguration will allow us to use all of the FactoryBot methods in our specs. For example, instead of using the fully qualiﬁed “FactoryBot” namespace to call the FactoryBot.create method, we can instead just use the create method directly. This will make our specs cleaner and save us some keystrokes as well.\n\nAnother FactoryBot integration we want to take advantage of is the ability for Rails code generators to create factories for our models. To enable this, we need to add the following near the top of our config/application.rb ﬁle:\n\nrequire 'factory_bot_rails'\n\n29\n\n30\n\n5 Setting Up RSpec and FactoryBot\n\nFurther down, inside the same ﬁle, let’s add this bit of extra conﬁguration inside our Application class:\n\nconfig.generators do |g|\n\ng.test_framework :rspec, fixture: true g.fixture_replacement :factory_bot, dir: 'spec/factories'\n\nend\n\nThis will conﬁgure the Rails model generator to use FactoryBot to create factory ﬁle stubs whenever we generate a new model. We Ruby developers (especially the author) love saving keystrokes whenever possible. Maybe not as much as Perl developers, but still.\n\nTo further facilitate our spec writing, let’s install another gem called shoulda-matchers.4 This gem provides a collection of RSpec-compatible one-liners and helpers that will aid us in testing common Rails functionality.\n\nLet’s modify our Gemfile to add the following line inside the :test group:\n\ngroup :test do\n\ngem 'shoulda-matchers'\n\nend\n\nThen let’s run the bundle command to install the new gem.\n\nTo integrate the shoulda-matchers gem into RSpec and Rails, we need to add the following\n\nconﬁguration into our spec/rails_helper.rb ﬁle; anywhere near the bottom is ﬁne:\n\nShoulda::Matchers.configure do |config|\n\nconfig.integrate do |with|\n\nwith.test_framework :rspec with.library :rails\n\nend\n\nend\n\nDebugging\n\nWhile writing our RSpec tests and Rails application code, we will inevitably encounter errors and other confusing situations where we may not understand exactly what is happening. When we do, we will need to be able to debug our code. We will need to be able to dig deeper into the code’s execution and see what is happening at each step. We will need to be able to inspect the variable values and follow different code paths.\n\n4https://github.com/thoughtbot/shoulda-matchers\n\nInstalling FactoryBot\n\nThe easiest way to debug Ruby code is to use binding.irb. This is built into Ruby and allows us to drop into an irb session at any point in our code execution. An example call to binding.irb may look something like this:\n\n# debug.rb\n\ndef add(a, b) binding.irb a + b\n\nend\n\nputs add(1, 2)\n\nIn our ﬁle debug.rb, we deﬁne a method called add that takes two variables and adds them together, returning the result. We then call our method and use puts to print the result. We can run this code by executing it with the ruby command:\n\nruby debug.rb\n\nWhen our code executes, it will stop at the binding.irb line and drop us into an irb session. It will look something like this:\n\nFrom: debug.rb @ line 3 :\n\n1: 2: def add(a, b) binding.irb a + b\n\n=> 3: 4: 5: end 6: 7: puts add(1, 2) 8:\n\nirb(main):001:0>\n\nWe can then inspect our variables and execute any Ruby code we want. When we are done, we can exit the irb session by pressing ctrl-d or by typing the more verbose exit command:\n\nirb(main):001:0> a\n\n=> 1 irb(main):002:0> b => 2 irb(main):003:0> a + b => 3 irb(main):004:0> 3\n\n31",
      "page_number": 32
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 40-49)",
      "start_page": 40,
      "end_page": 49,
      "detection_method": "topic_boundary",
      "content": "32\n\n5 Setting Up RSpec and FactoryBot\n\nThis is a simple example, but binding.irb can be very useful when debugging more complex code too.\n\nThere are other more advanced debugging tools available for Ruby; two that I encounter regularly are pry and byebug. Give them a try and see which one(s) you like best. Over time, I’ve come to prefer binding.irb because I don’t have to install or conﬁgure anything extra to use it.\n\nSummary\n\nIn this chapter, we installed and conﬁgured RSpec and FactoryBot, two of the most important tools we will use going forward to create our Rails application’s test suite. We will write our tests using RSpec and shoulda-matchers, and we will use FactoryBot to create consistent test data for our tests. We also ran through a simple example showing how to use binding.irb to debug our code, just in case we get stuck and need to dig in deeper to ﬁgure something out.\n\nAdding Initial Models\n\nIn this chapter, we will add our ﬁrst two Rails ActiveRecord models into our blog application. We will start with simple User and Page models and proceed to grow them, adding more functionality as we go along.\n\nRuby on Rails is overﬂowing with code generators. Rails code generators create lots of code for us when we run them. We can use the rails generate command, for example, to quickly generate a fully namespaced model or a controller with actions and views stubbed and ready for additional development. And since we already have RSpec and FactoryBot installed, we will get appropriately named stub ﬁles for those as well. Rails code generators can be huge time savers.\n\nThe User Model\n\nIn our blog app, a Page model will represent a blog post, and a User model will represent the person who wrote the blog post. This will allow multiple users to write blog posts if we need that scenario. We will begin by generating the User model using the rails generate command:\n\nbundle exec rails generate model \\\n\nUser \\ name:string:uniq \\ email:string:uniq\n\nThis will generate a model as well as a database migration, a factory, and a model spec. The output will look like this:\n\ninvoke active_record create create invoke create invoke create\n\ndb/migrate/20221030192603_create_users.rb app/models/user.rb rspec\n\nspec/models/user_spec.rb factory_bot\n\nspec/factories/users.rb\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_6\n\n6\n\n33\n\n34\n\n6 Adding Initial Models\n\nThe generated migration ﬁle will look like this:\n\nclass CreateUsers < ActiveRecord::Migration[7.0]\n\ndef change\n\ncreate_table :users do |t|\n\nt.string :name t.string :email t.timestamps\n\nend add_index :users, :name, unique: true add_index :users, :email, unique: true\n\nend\n\nend\n\nWe’re adding the uniq option to the name and email ﬁelds to make sure no two users can have the same name or the same email address. This is a common requirement for user accounts, and since we can easily enforce it directly in our database, we should. This will protect us from any other code that creates or modiﬁes user records outside of our Rails app.\n\nIn front of our unique database constraints, we will use Rails model validations.1 This will prevent us from showing actual Postgres errors in our web browser. When we try to create a new record with a duplicate name or email address, we will show a nicely formatted error message instead of the entire page being broken.\n\nLet’s run our new migrations to create our new database tables:\n\nbundle exec rails db:{migrate,test:prepare}\n\nThis will actually run two commands: ﬁrst db:migrate and then after that db:test:prepare will be run. The ﬁrst will run our migration against our development database, and the second will prepare our test database for use, making sure it matches our development database.\n\nMost of the time after I migrate my database, I run psql to connect to my database and check the schema. This is a good way to make sure the migration did what I expected. Let’s do that now. We can connect to our development database with the following Rails command:\n\nbundle exec rails db\n\nSince we’re using PostgreSQL, this command will connect us to our blog_development database using PostgreSQL’s psql program. If you’re on an underpowered machine, this may take longer than\n\n1https://guides.rubyonrails.org/active_record_validations.html\n\nThe User Model\n\nyou’d like to start up, as it loads the entire Rails codebase. If it’s too much to bear, you can always run psql directly as shown in the previous chapter:\n\npsql blog_development\n\nOnce we’re connected to our database, we can run the \\d command to see a list of all the tables in our database:\n\nblog_development=# \\d\n\nList of relations\n\nSchema |\n\nName\n\n| Type | Owner\n\n--------+----------------------+-------+----------\n\npublic | ar_internal_metadata | table | gd | table | gd public | pages | table | gd public | schema_migrations public | users | table | gd (4 rows)\n\nAs we can see, our pages and users tables have been created. We can further examine the schema of a given table by running the \\d command followed by the table name:\n\nblog_development=# \\d users\n\nHave a look and make sure the users and pages tables match our migrations.\n\nThe User Factory\n\nNext, let’s improve our new user factory in spec/factories/users.rb. Right now, it looks like this:\n\nFactoryBot.define do factory :user do\n\nname { \"MyString\" } email { \"MyString\" }\n\nend\n\nend\n\n35\n\n36\n\n6 Adding Initial Models\n\nGiven our unique constraints on our name and email ﬁelds, this will fail on the second usage when it tries to create a user record with the same name and email as the ﬁrst usage. Let’s ﬁx that by adding a FactoryBot sequence to the name and email ﬁelds:\n\nFactoryBot.define do factory :user do\n\nsequence(:name) { |n| \"First#{n} Last#{n}\" } sequence(:email) { |n| \"user#{n}@example.com\" }\n\nend\n\nend\n\nThis will cause the factory to generate name values like “First1 Last1” and “First2 Last2” and email values like “user1@example.com” and “user2@example.com.” The sequence method takes a ﬁeld name and a block that will be called each time a new record is created. The block will be passed a sequential number that will be used to generate unique values.\n\nSome software engineers consider sequentially numbering ﬁeld values to be a sort of anti-pattern, but I think it’s a useful option. When we encounter a scenario where we need higher-quality values, we should deﬁnitely take the time to create them by hand. For most cases where we just need non-random unique values, a sequential numbering tool is a good way to accomplish that.\n\nNow we’re ready to add ﬁeld validation specs for our name and email ﬁelds to our User model.\n\nRight now, our User model spec located in spec/models/user_spec.rb looks like this:\n\nrequire 'rails_helper'\n\nRSpec.describe User, type: :model do\n\npending \"add some examples to (or delete) #{__FILE__}\"\n\nend\n\nLet’s remove the pending entry and replace it with a spec to make sure our factory is working as expected:\n\nrequire 'rails_helper'\n\nRSpec.describe User, type: :model do\n\nlet(:user) { build(:user) }\n\nit 'has a valid factory' do expect(user).to be_valid\n\nend\n\nend\n\nThis is a very simple spec, but it’s a good start. We are using the build method from FactoryBot to create a new User instance. build just creates the instance in memory and doesn’t write any data to our database, so it’s very fast. We create the User instance using RSpec’s let syntax. let is lazily evaluated and, as we’ll see later, can come in very handy for making our spec ﬁles clean and easy to understand.\n\nThe User Model\n\nEvery factory we create should be this easy to instantiate, and adding a spec ensures we don’t accidentally break it later. Our spec just checks if our user instance is valid using RSpec’s be_* syntax. Our expect statement, as you may have guessed, is expecting our user instance to “be valid.” If it is not valid, then our spec will fail, and we will know that our factory became broken somehow. It’s equivalent to this more verbose version:\n\nexpect(user.valid?).to eq(true)\n\nRSpec’s be_* syntax is very powerful and can be used to test anything that responds to a boolean query. For example, we can test if a string is empty, like this:\n\nexpect('').to be_empty\n\nOr we can verify something is actually a hash or not:\n\nexpect({a: 1}).to be_a(Hash)\n\nHow to Run Specs\n\nWe software engineers have different preferences for how we like to run our specs. I like to run my specs in a terminal, so I can see the output and any errors in a large window, with the least amount of scrolling. I may also run my specs inside my code editor from time to time, but this is usually a scenario involving existing specs that I want to quickly verify that I have not broken.\n\nLet’s use the rspec command to run our new User model spec:\n\nbundle exec rspec spec/models/user_spec.rb\n\nThe output will look like this:\n\n.\n\nFinished in 0.04421 seconds (files took 0.78106 seconds to load) 1 example, 0 failures\n\nThere are two indicators here that our ﬁrst spec passed. The ﬁrst is the period (.) on the ﬁrst line. If our spec had failed, we would have got an F instead of a period. The second indicator is the 1 example, 0 failures.\n\n37\n\n38\n\n6 Adding Initial Models\n\nUser Model Validations\n\nto our User model spec ﬁle. the the validate_uniqueness_of shoulda-matchers. Let’s\n\nNow We need validate_presence_of and add these to our spec ﬁle just below the previous spec:\n\nthat we can run specs,\n\nlet’s add ﬁeld validation specs\n\nto ﬁrst\n\ntest\n\nthat our name ﬁeld\n\nis present and unique. We can do\n\nthis with\n\ndescribe 'validations' do\n\nit { is_expected.to validate_presence_of(:name) } it { is_expected.to validate_uniqueness_of(:name) }\n\nend\n\nI tend to put all my shoulda-matchers and validations near the top of my spec ﬁle, but you can organize your specs however you like. You could add these new specs to the top or to the bottom of your own ﬁle; RSpec does not care about the order when it runs your specs.\n\nWhen we run our spec, we will get two expected failure messages:\n\n1) User validations is expected to validate that :name cannot be empty/falsy\n\nFailure/Error: it { is_expected.to validate_presence_of(:name) }\n\nExpected User to validate that :name cannot be empty/falsy, but this could not be proved.\n\nAfter setting :name to ‹\"\"›, the matcher expected the User to be invalid, but it was valid instead.\n\n2) User validations is expected to validate that :name is case-sensitively unique\n\nFailure/Error:\n\nit { is_expected.to validate_uniqueness_of(:name) }\n\nExpected User to validate that :name is case-sensitively unique, but this could not be proved.\n\nAfter taking the given User, whose :name is ‹\"First2 Last2\"›, and saving it as the existing record, then making a new User and setting its :name to ‹\"First2 Last2\"› as well, the matcher expected the new User to be invalid, but it was valid instead.\n\nWe are using RSpec’s describe block syntax to group our specs into logical units. First, we have a validations group, then inside we begin to use RSpec with shoulda-matchers to test individual ﬁelds. To get these two specs to pass, we need to add our missing name ﬁeld validations to our User\n\nmodel. We can do this by adding the following to our User model:\n\nclass User < ApplicationRecord\n\nvalidates :name,\n\npresence: true,\n\nThe User Model\n\nuniqueness: true\n\nend\n\nThis gets our name specs to pass. We can now add specs to test that our email ﬁeld is also present and unique:\n\nit { is_expected.to validate_presence_of(:email) } it { is_expected.to validate_uniqueness_of(:email) }\n\nWhen we re-run our spec, we get the following output:\n\n1) User validations is expected to validate that :email cannot be empty/falsy\n\nFailure/Error:\n\nit { is_expected.to validate_presence_of(:email) }\n\nExpected User to validate that :email cannot be empty/falsy, but this could not be proved.\n\nAfter setting :email to ‹\"\"›, the matcher expected the User to be invalid, but it was valid instead.\n\n2) User validations is expected to validate that :email is case-sensitively unique\n\nFailure/Error:\n\nit { is_expected.to validate_uniqueness_of(:email) }\n\nExpected User to validate that :email is case-sensitively unique, but this could not be proved.\n\nAfter taking the given User, whose :email is ‹\"user4@example.com\"›, and saving it as the existing record, then making a new User and setting its :email to ‹\"user4@example.com\"› as well, the matcher expected the new User to be invalid, but it was valid instead.\n\nTo get these two email specs to pass, we need to add the following to our User model:\n\nvalidates :email,\n\npresence: true, uniqueness: true\n\nThis gets our email specs to pass.\n\nWe can also add some sanity checks to ensure our email address data looks like actual email addresses. How far you take email address validation is up to you. I (used to?) have a Perl book that showed a regular expression to properly validate an email address, and it is more than an entire printed\n\n39\n\n40\n\n6 Adding Initial Models\n\npage in length. We’re not going to go that far here, but we can add some simple sanity checks to our describe validation block:\n\nit { is_expected.to_not allow_value('foo@').for(:email) } it { is_expected.to_not allow_value('@bar.com').for(:email) }\n\nWhen we re-run our spec, we get the expected failure messages:\n\n1) User validations is expected not to allow :email to be ‹\"foo@\"› Failure/Error:\n\nit { is_expected.to_not allow_value('foo@').for(:email) }\n\nAfter setting :email to ‹\"foo@\"›, the matcher expected the User to be invalid, but it was valid instead.\n\n2) User validations is expected not to allow :email to be ‹\"@bar.com\"› Failure/Error:\n\nit { is_expected.to_not allow_value('@bar.com').for(:email) }\n\nAfter setting :email to ‹\"@bar.com\"›, the matcher expected the User to be invalid, but it was valid instead.\n\nWe can get these two specs passing by adding a format validation to our User model email validation:\n\nvalidates :email,\n\npresence: true, uniqueness: true, format: { with: /\\A\\S+@\\S+\\z/ }\n\nThe content of our with: parameter is a regular expression that will validate the format of our email addresses. We use word boundary matchers \\A and \\z to ensure the email address does not begin or end with a whitespace character. We use \\S to match any number of non-whitespace characters, followed by matching the @ symbol. Last we make sure we have some non-whitespace characters after the @ symbol. This is a very simple regular expression, but it will catch a lot of common mistakes made when entering email addresses.\n\nThe Page Model\n\nLet’s leave our User model as is for now and move on to our Page model.\n\nThe Page Model\n\nLet’s work on our Page model next. We’ll use the rails generate command as before:\n\nbundle exec rails generate model \\\n\nPage \\ user:references \\ title:string:uniq \\ slug:string:uniq \\ summary:text \\ content:text \\ published:boolean:index\n\nThis will generate a Page model as well as a database migration , a factory , and a model spec . The output will look like this:\n\ninvoke active_record create create invoke create invoke create\n\ndb/migrate/20221030235303_create_pages.rb app/models/page.rb rspec\n\nspec/models/page_spec.rb factory_bot\n\nspec/factories/pages.rb\n\nThe generated Page migration ﬁle needs some work. There are a few things Rails does not currently support with command line–generated database migrations, adding an index to our created_at ﬁeld or setting ﬁelds to not be NOT NULL (null: false), for example. We’ll need to manually update our migration to look like this:\n\nclass CreatePages < ActiveRecord::Migration[7.0]\n\ndef change\n\ncreate_table :pages do |t|\n\nt.references :user, null: false, foreign_key: true t.string :title, null: false t.string :slug, null: false t.text :summary, null: false t.text :content, null: false t.boolean :published, null: false, default: false t.timestamps\n\nend add_index :pages, :title, unique: true add_index :pages, :slug, unique: true add_index :pages, :published add_index :pages, :created_at\n\n41",
      "page_number": 40
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 50-57)",
      "start_page": 50,
      "end_page": 57,
      "detection_method": "topic_boundary",
      "content": "42\n\n6 Adding Initial Models\n\nend\n\nend\n\nNow we can run our new migration to migrate our database:\n\nbundle exec rails db:{migrate,test:prepare}\n\nNext, let’s improve our new page factory in spec/factories/pages.rb. Currently, it’s using default values and looks like this:\n\nFactoryBot.define do factory :page do user { nil } title { 'MyString' } slug { 'my-string' } summary { 'MyText' } content { 'MyText' } published { false }\n\nend\n\nend\n\nLet’s ﬁrst add a spec to ensure the Page model instances we create with this factory are valid:\n\nrequire 'rails_helper'\n\nRSpec.describe Page, type: :model do\n\nlet(:page) { build(:page) }\n\nit 'has a valid factory' do expect(page).to be_valid\n\nend\n\nend\n\nWhen we run our spec/models/page_spec.rb specs, we see that our factory is not currently creating valid Page instances:\n\nF\n\nFailures:\n\n1) Page has a valid factory\n\nFailure/Error: expect(page).to be_valid\n\nexpected #<Page id: nil, user_id: nil, title: \"MyString\", slug: \"my-string\", summary: \"MyText\",\n\nThe Page Model\n\ncontent: \"MyText\", published: false, created_at: nil, updated_at: nil> to be valid, but got errors: User must exist\n\n# ./spec/models/page_spec.rb:7:in `block (2 levels) in <top (required)>'\n\nFinished in 0.05983 seconds (files took 1.08 seconds to load) 1 example, 1 failure\n\nFailed examples:\n\nrspec ./spec/models/page_spec.rb:6 # Page has a valid factory\n\nIt’s a big error message, with the important part being the line that says “User must exist.” We’re getting this particular error message because we gave our Page model a belongs_to :user association via our user:references command-line option. This means that every Page instance must have a user_id ﬁeld that references a valid User instance. We can ﬁx this by updating our Page factory to automatically create an associated User instance when we use it to create a new Page instance:\n\nuser { create(:user) }\n\nNow when we run our specs, we see that it passes.\n\nNext, let’s add more specs to our Page spec ﬁle. Let’s add specs to ensure the Page model is invalid when the title and content attributes are not present. We’ll also add a spec to ensure our title value is unique. We always want an associated user too, and we don’t want our database blowing up; we instead want Rails to catch the error before the database does. Let’s add the following Page model specs:\n\ndescribe 'validations' do\n\nit { is_expected.to belong_to(:user) } it { is_expected.to validate_presence_of(:title) } it { is_expected.to validate_uniqueness_of(:title) } it { is_expected.to validate_presence_of(:content) }\n\nend\n\nWhen we run our Page spec ﬁle, we see that we have a new failure:\n\n...F.\n\nFailures:\n\n1) Page validations is expected to validate that :title\n\n43\n\n44\n\n6 Adding Initial Models\n\nis case-sensitively unique\n\nFailure/Error: it { is_expected.to validate_uniqueness_of(:title) }\n\nShoulda::Matchers::ActiveRecord:: ValidateUniquenessOfMatcher::ExistingRecordInvalid: validate_uniqueness_of works by matching a new record against an existing record. If there is no existing record, it will create one using the record you provide.\n\nWhile doing this, the following error was raised:\n\nPG::NotNullViolation: ERROR: null value in column \"user_id\" of relation \"pages\" violates not-null constraint DETAIL: Failing row contains (1, null, null, null, null, null, f, 2022-11-02 00:27:42.12824, 2022-11-02 00:27:42.12824).\n\nThe best way to fix this is to provide the matcher with a record where any required attributes are filled in with valid values beforehand.\n\n# ./spec/models/page_spec.rb:14:in `block (3 levels) in <top (required)>' # ------------------ # --- Caused by: --- # PG::NotNullViolation: # # # # # # #\n\nERROR: null value in column \"user_id\" of relation \"pages\" violates not-null constraint DETAIL: Failing row contains (1, null, null, null, null, null, f, 2022-11-02 00:27:42.12824, 2022-11-02 00:27:42.12824). ./spec/models/page_spec.rb:14:in `block (3 levels) in <top (required)>'\n\nFinished in 0.1452 seconds (files took 0.87346 seconds to load) 5 examples, 1 failure\n\nFailed examples:\n\nrspec ./spec/models/page_spec.rb:14 # Page validations is expected to validate that :title is case-sensitively unique\n\nThis error message seems to be saying Postgres is preventing us from adding a new Page instance without a user_id ﬁeld, as previously discussed. But the weird part is it’s actually failing on the spec for requiring a unique title.\n\nWhat’s going on here? Is there some implied Page record being created?\n\nThe Page Model\n\nRSpec’s “subject”\n\nWhen we’re using RSpec, each individual spec ﬁle has a sort of “magic” variable called \"subject\". This variable is automatically set based on our spec ﬁle’s name and what type of spec it is. In our case, we’re testing our Page model, so our implied subject variable is set to a new Page instance.\n\nOur shoulda-matchers use RSpec’s implied subject variable to perform the validation. So when we’re testing the uniqueness of our title value in a shoulda-matcher, we’re actually testing the uniqueness of our title value on the implied subject.\n\nIn our case, RSpec is by default building a new instance of Page without a user_id ﬁeld. It just doesn’t know any better unless we tell it to do something different. We can ﬁx our spec failure by telling RSpec what we actually want for a subject in our spec ﬁle. One option is to do something like this:\n\ndescribe 'validations' do\n\nsubject { build(:page) } it { is_expected.to belong_to(:user) } it { is_expected.to validate_presence_of(:title) } it { is_expected.to validate_uniqueness_of(:title) } it { is_expected.to validate_presence_of(:content) }\n\nend\n\nSo just inside our one describe block, we’re telling RSpec to use our own custom subject instead of the implied one. This works, but it’s a bit of a pain to have to do this for every describe block.\n\nAnother option could be to reuse the page we’re already building at the top of our spec:\n\nsubject { page }\n\nThis is an improvement, but it’s still not great because it’s redundant.\n\nThe solution I prefer is to deﬁne my subject at the top of my spec ﬁle, so my attention is\n\nimmediately drawn to it whenever I open the ﬁle:\n\nsubject { build(:page) }\n\nNow when we’re reading our spec ﬁle, we can immediately see what our subject is for all of our specs. Let’s do a bit of cleanup and have our Page spec look like this:\n\nrequire 'rails_helper'\n\nRSpec.describe Page, type: :model do\n\nsubject { build(:page) }\n\ndescribe 'validations' do\n\n45\n\n46\n\n6 Adding Initial Models\n\nit { is_expected.to belong_to(:user) } it { is_expected.to be_valid } it { is_expected.to validate_presence_of(:title) } it { is_expected.to validate_uniqueness_of(:title) } it { is_expected.to validate_presence_of(:content) }\n\nend\n\nend\n\nThere’s not much harm in redeﬁning our subject in any subsequent describe block, as needed, but we should try to have a clean and simple default subject at the top of each spec ﬁle if possible. Now that our code is better organized and we have become experts on RSpec’s subject variable, let’s get our failing specs passing by adding our currently missing model validations to our Page model:\n\nclass Page < ApplicationRecord\n\nbelongs_to :user\n\nvalidates :title,\n\npresence: true, uniqueness: true\n\nvalidates :content,\n\npresence: true\n\nend\n\nNow our Page specs are passing.\n\nFactoryBot “build” vs. “create”\n\nThere is the cost of a database write if our FactoryBot build call is instead a call to create. We should keep that in mind and always consider using build unless we actually need to persist the record in our database. We can even default to using build and then call .save on our subject as needed. It’s a great way to make sure we’re only persisting records when we actually need to.\n\nWriting records to our database is often the slowest part of a spec. It’s best to avoid doing it\n\nwhenever possible.\n\nThe Page slug\n\nIn web development, we should try to use human-friendly URLs for a given resource. Instead of using the URL http://example.com/pages/1, or the even uglier http://example.com/pages?id=1, we should build our app to use beautiful URLs such as http://example.com/pages/ﬁrst-page.\n\nThe “ﬁrst-page” part, at the end of the URL, is called the slug. I honestly do not know why it’s\n\ncalled that, but I’ve heard it called that so many times, I now call it that too.\n\nIt would be unnecessary extra work to create the URL-friendly slug every time we make a page, and since we’re already making a title that is very similar, we should just use the title to\n\nThe Page Model\n\ngenerate the slug value for us. If we do it correctly, we can even maintain our slug uniqueness validation along the way.\n\nSo we want to provide a title with any sort of a value and then take that value and make it all lowercase, with no spaces, and using dashes as word delimiters. Let’s ﬁrst capture our idea in a new spec.\n\nLet’s provide a complicated title value and then make sure the slug ends up becoming what\n\nwe expect:\n\ndescribe '#slug' do\n\nlet(:page) { create(:page, title: '--Foo Bar! _ 87 --') }\n\nit 'is generated from the title' do\n\nexpect(page.slug).to eq('foo-bar-87')\n\nend\n\nend\n\nWhen we run this spec, we get the failure:\n\n1) Page#slug is generated from the title Failure/Error: expect(page.slug).to eq('foo-bar-87')\n\nexpected: \"foo-bar-87\" got: \"my-string\"\n\nThe \"my-string\" is still the default value for the slug ﬁeld in our factory. Let’s remove it, knowing that our subject uses the FactoryBot build method and that we need some sort of value for our shoulda-matcher to work. As expected, we get a different failure message:\n\nActiveRecord::NotNullViolation:\n\nPG::NotNullViolation: ERROR: null value in column \"slug\" of relation \"pages\" violates not-null constraint\n\nIt’s telling us that the slug ﬁeld is not allowed to be null, and remembering back to our database migration for our pages table, that’s correct behavior. We need to update our Page model to make our slug value for us, automatically.\n\nRails provides “callbacks” in the ActiveRecord class. A callback is a method that is called at a particular point in the life cycle of an ActiveRecord object. We can use a callback to generate our slug for us. We’ll use the before_validation callback to generate our slug just before we save the record to our database. There’s a before_save callback, but we want to generate our slug before Rails validates the record, so it would actually ﬁre too late for our particular use case, so we will user before_validation.\n\nclass Page < ApplicationRecord\n\n47\n\n48\n\n6 Adding Initial Models\n\n# previously added code omitted for brevity\n\nbefore_validation :make_slug\n\nprivate\n\ndef make_slug\n\nself.slug = title\n\n.downcase .gsub(/[_ ]/, '-') .gsub(/[^-a-z0-9+]/, '') .gsub(/-{2,}/, '-') .gsub(/^-/, '') .chomp('-')\n\nend\n\nend\n\nThat’s a lot of gsub calls, so let’s run through it all. First, we make the title lowercase by calling downcase. Then we replace all spaces and underscores with dashes, giving them special treatment early on since spaces and underscores are typical word delimiters. Then we remove any characters that are not dashes, lowercase letters, or numbers. Then we remove any duplicate dashes. Finally, we remove any dashes at the beginning and end of the string. That’s a lot of work to make a slug, but if you re-run our spec, you can see that it works and that our spec is now passing.\n\nPage Factory\n\nBefore we go much further, let’s polish our Page factory a bit. We can use FactoryBot sequences to generate different but predictable (not random) data for our Page data:\n\nFactoryBot.define do factory :page do\n\nuser { create(:user) } sequence(:title) { |n| \"Page Title #{n} \" } sequence(:slug) { |n| \"page-title-#{n} \" } sequence(:summary) { |n| \"<p>Page summary goes here #{n}</p>\" } sequence(:content) { |n| \"<p>Page content goes here #{n}</p>\" } created_at { Time.zone.now } published { false }\n\nend\n\nend\n\nRandom Test Data Some software engineers recommend using random data in their factories, for example, the Faker gem, but I strongly advise against doing that, especially if the randomly generated factory data is used in specs. Random test data causes random spec failures, which are often difﬁcult and time-consuming\n\nFinal Thoughts on Model Validations\n\nto debug. These random test failures will at some point become blockers for important things like Friday afternoon production deployments!\n\nThe ﬁrst thing I do when I work on a randomly failing spec is to begin to look for where some bits of random data are coming into the picture, on purpose or by accident. Sometimes, things you don’t think will ever be random end up becoming random when you least expect it. Consider Time.zone.now and how it works on your local development machine where you probably have a local time zone set versus how it will work in a CI environment where the time zone is probably set to UTC. Then imagine your test suite running late in the evening where it becomes “tomorrow” compared to your local machine that still thinks it’s “today.” To complicate debugging efforts further, imagine some of your team members are on the other side of the planet from you.\n\nI do not use the term “ﬂakey spec” when describing a randomly failing spec. That sort of terminology has an underlying meaning of “I don’t really know why this spec is failing and I’d rather imply it’s RSpec’s fault instead of spending the time to ﬁgure it out.” Instead, I advise using the words “randomly failing spec” which is encouragement to spend the time to ﬁgure out why it’s random.\n\nRemember, RSpec is not a fuzzing tool, it’s an acceptance testing framework. Acceptance testing means putting in known inputs and expecting to get back predictable outputs. Always steer clear of random data in your factories and specs.\n\nFinal Thoughts on Model Validations\n\nThis chapter was a whirlwind tour of Rails model validations. We covered a lot of small topics and saw how they ﬁt together in a practical hands-on way. We used tools that actual Ruby software engineers use every day. We leaned heavily on FactoryBot and will continue to do so throughout the book. Repeatability is important, especially when it comes to writing specs.\n\nBefore we close out the chapter, let’s take a moment for some cleanup.\n\nUser Spec Cleanup\n\nA few sections ago, we became RSpec subject experts, so let’s now clean up our User spec:\n\nrequire 'rails_helper'\n\nRSpec.describe User, type: :model do\n\nsubject { build(:user) }\n\ndescribe 'validations' do\n\nit { is_expected.to be_valid } it { is_expected.to validate_presence_of(:name) } it { is_expected.to validate_uniqueness_of(:name) } it { is_expected.to validate_presence_of(:email) } it { is_expected.to validate_uniqueness_of(:email) } it { is_expected.to allow_value('foo@bar.com').for(:email) } it { is_expected.to_not allow_value('@bar.com').for(:email) } it { is_expected.to_not allow_value('foo@').for(:email) }\n\nend\n\nend\n\n49",
      "page_number": 50
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 58-66)",
      "start_page": 58,
      "end_page": 66,
      "detection_method": "topic_boundary",
      "content": "50\n\n6 Adding Initial Models\n\nThat’s a lot cleaner and easier to read, and we’re getting a lot of value out of such a small amount of code.\n\nAdvice on Writing Too Many Specs\n\nIn our blog application, we won’t pursue writing every single spec that is automatically generated for us. These automatically generated spec ﬁles are mostly harmless to remain empty, and we will eventually delete them when we don’t want them hanging around anymore. I wanted to take a moment to explain why we won’t be ﬁlling in every spec ﬁle that is generated for us.\n\nIt’s not that writing every single spec we can is a horrible world-ending idea, it’s that we will be\n\nwriting enough specs to provide more than ample cover of any logic we might create.\n\nUndoubtedly, you will have, or will soon have, your own preferences for what specs you want to write for your own apps. My preferences have evolved, as my experience grew. The best way to grow this level of experience is to practice test-driven development. Having a failing test, failing exactly like you expect it to fail, is the best way to learn how to write the best code possible, to get that spec to pass.\n\nSummary\n\nIn this chapter, we learned about shoulda-matchers and Rails model validations and how to use them to ensure our data is valid before it gets saved to our database. I also gave some experienced advice on how using random data often causes random test failures. Next, we’re going to jump headﬁrst into Rails routes and controllers while creating our application’s homepage.\n\nCreating Pages\n\nIt may be surprising to make it all the way to this chapter without having written any HTML yet; we are creating a web application after all! We’ve been doing a lot of preparation, making sure we get off to a solid start. Rest assured, it’s now time to get down to business. In this chapter, we’ll create our homepage, which will be the ﬁrst page that users see when they visit our site.\n\nWe’ll start by writing a system spec for our homepage and learn about Capybara,1 a tool that\n\nfacilitates web browser testing from inside our system specs.\n\nSystem Specs\n\nA system spec is a spec that simulates a user interacting with our application directly. It will do things exactly as the user would, things such as visiting URLs, ﬁlling out forms, and clicking buttons and links.\n\nBut why would we use a system spec when we could instead use a controller spec or a request spec? The two test types both make HTTP requests after all. The biggest reason is JavaScript. Request specs are great for testing the behavior of our application at the HTTP request/response level, and controller specs are great for testing the behavior of our Rails application at the routing/controller level, but neither of these approaches will exercise our JavaScript.\n\nTesting Our Homepage\n\nLet’s start by writing a simple system spec for our homepage. It will require signiﬁcant effort to get it to pass, but that’s how TDD works! We’ll start with adding a new spec ﬁle into our spec/system directory. Let’s add this to a ﬁle named home_spec.rb:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Home' do\n\nit 'renders homepage' do\n\nvisit root_path\n\n1http://teamcapybara.github.io/capybara/\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_7\n\n7\n\n51\n\n52\n\n7 Creating Pages\n\nwithin 'header' do\n\nexpect(page).to have_link 'My Blog'\n\nend\n\nend\n\nend\n\nWhen we run our new system spec with the command:\n\nbundle exec rspec spec/system/home_spec.rb\n\nwe get a lot of output, with the important part of the error message near the end:\n\nGem::LoadError:\n\ncapybara is not part of the bundle. Add it to your Gemfile.\n\n# ./spec/system/home_spec.rb:3:in `<top (required)>'\n\nThere’s nothing better than an error message telling us exactly what we need to do to ﬁx it! Let’s add capybara to our Gemﬁle, in our :test group:\n\ngroup :test do\n\ngem 'capybara'\n\nend\n\nThen, as before, we need to run bundle to install our new gem. Some Ruby developers like to run bundle install instead of just bundle, but I prefer less typing anytime I’m given the choice. Now that we have capybara installed, let’s run our new system spec again. Our previous error\n\nmessage is gone, but we have a new one:\n\nGem::LoadError: selenium-webdriver is not part of the bundle. Add it to your Gemfile.\n\nWe are presented with another highly informative error message; we need the selenium- webdriver. But before we add it to our Gemﬁle, let’s consider a better option. There is a gem called webdrivers that will automatically install the latest version of selenium-webdriver for us, as well as other webdrivers for many different web browsers. Let’s add it to our Gemﬁle and run bundle:\n\ngroup :test do\n\ngem 'webdrivers'\n\nend\n\nSystem Specs\n\nKeep in mind there may be other gems in the :test group of our Gemﬁle. To save space, I’m not going to show them all every time we make a modiﬁcation.\n\nNow that we have webdrivers installed, let’s run our spec again. This time, we get a different\n\nerror message:\n\n1) Home renders homepage\n\nFailure/Error: visit root_path\n\nNameError:\n\nundefined local variable or method `root_path' for #<RSpec::ExampleGroups::Home \"renders homepage\" (./spec/system/home_spec.rb:4)>\n\n# ./spec/system/home_spec.rb:5:in `block (2 levels) in <top (required)>'\n\nThis error message may seem cryptic, but it just means that we’re missing a Rails route. In Rails, the root_path is the path for the root URL of our application. As this is a brand-new Rails application, our root_path simply has not been deﬁned yet. If we open up config/routes.rb, we can see the root method is still commented out:\n\n# root \"articles#index\"\n\nLet’s uncomment it and add a route for our homepage, so our routes ﬁle looks like this:\n\nRails.application.routes.draw do\n\nroot 'home#index'\n\nend\n\nThe argument we’re passing to the root method is the name of a controller and action we will use for our homepage, separated with a # symbol.\n\nWhen we call up the root URL of our application, Rails will look for a controller class named Home that contains an action named index. If it ﬁnds them, it will execute the action and do whatever it says to do. If it doesn’t ﬁnd them, it will throw an error, just like we’ll see if we now run our spec again (you may have to scroll up a bit to see this exact error message):\n\n1) Home renders homepage\n\nFailure/Error: raise MissingController.new(error.message, error.name)\n\nActionController::RoutingError:\n\nuninitialized constant HomeController\n\n53\n\n54\n\n7 Creating Pages\n\nOur practice of test-driven development is really paying off. It continues to guide us with making changes, only as needed, to get our spec to pass. At this point, we’re being guided to create our Home controller and index action. Let’s create them now using a Rails generator:\n\nbundle exec rails generate controller home index\n\nA Quick Confession\n\nI’m going to confess something here. I don’t type that full bundle exec command very often. I’ve been typing it out up until now because it’s the proper way to use bundler with a Rails application. The truth is I have an alias in my .zshrc ﬁle that looks like this:\n\nalias be='bundle exec'\n\nIn addition to my alias, Rails itself has an internal alias for the generate portion of the command, the letter g. So what I usually type out for that command is this:\n\nbe rails g controller home index\n\nThis gives me the same result as if I have typed out the longer command. The Rails g alias also works for other generators like model. From now on, we’ll use the shorter commands.\n\nAfter we run our generate command, we get our new controller and our new controller action, and\n\nsome other new ﬁles as well:\n\ncreate app/controllers/home_controller.rb\n\nroute get 'home/index'\n\ninvoke erb create create invoke rspec create create create invoke helper create invoke create\n\napp/views/home app/views/home/index.html.erb\n\nspec/requests/home_spec.rb spec/views/home spec/views/home/index.html.erb_spec.rb\n\napp/helpers/home_helper.rb rspec\n\nspec/helpers/home_helper_spec.rb\n\nSystem Specs\n\nWe can ignore most of these ﬁles for now, but one change that just occurred inside our config/routes.rb ﬁle is the addition of a new get route:\n\nget 'home/index'\n\nRails is being helpful, and normally we may very well want the new route addition, but since we already have a route for our root_path, we don’t actually need it. Let’s remove it.\n\nLet’s run our spec again. Our previous error appears to be ﬁxed, and we’re getting a new error\n\nmessage:\n\n1) Home renders homepage Failure/Error:\n\nwithin 'header' do\n\nexpect(page).to have_link 'My Blog'\n\nend\n\nCapybara::ElementNotFound:\n\nUnable to find css \"header\"\n\nIt looks like it’s ﬁnally time to write some HTML, but where do we write it?\n\nRails View Templates\n\nIn Rails, the ﬁles that contain our HTML that gets rendered to our browser are called “views ” or “view templates.” In our Rails application, we’re using the default template engine “ERB,” which stands for “Embedded Ruby.” ERB is a templating language that allows us to embed Ruby code directly inside our HTML code, using a special template syntax. This is very useful because it allows us to use Ruby to dynamically generate HTML. For example, we can use Ruby to generate HTML that is different for each user of our application.\n\nIn Rails, an example block of ERB template code might look like this:\n\n<% if user_signed_in? %>\n\n<p>Welcome back, <%= current_user.name %></p>\n\n<% else %>\n\n<p>Welcome to our site!</p>\n\n<% end %>\n\nThe ﬁrst line of this code is just a plain old Ruby if statement. The magic is that it is wrapped with ERB opening and closing brackets. This allows us to embed Ruby code directly in our HTML code. The if condition checks to see if the current user is signed in. If the user is signed in, the next line of code will be evaluated, and the result will be inserted into the HTML, welcoming them back to our website by name. Notice the different <%= starting bracket syntax; it contains an = symbol unlike the\n\n55\n\n56\n\n7 Creating Pages\n\nother brackets surrounding our if code. We use this version of the opening ERB bracket when we want to insert something into our HTML.\n\nFollowing the if is an else condition with contents that will be evaluated if the user is not signed\n\nin. The last line of code is a closing end statement that ends the if/else conditions.\n\nTo explain it another way, ERB is just Ruby code that gets evaluated and inserted into our HTML.\n\nOutside of an ERB template, the preceding code is equivalent to this:\n\nif user_signed_in?\n\nputs \"<p>Welcome back, #{current_user.name}</p>\"\n\nelse\n\nputs '<p>Welcome to our site!</p>'\n\nend\n\nIn this example, our <%= current_user.name %> example code is equivalent to our #{current_user.name} code; the evaluation delimiters are just different from regular Ruby code to ERB code.\n\nIt’s easy to get used to ERB syntax. It’s just Ruby code with some special syntax that allows it to work inside of and with HTML. I can promise you that most of your ERB template debugging time will be spent on missing = symbols however; at least this is the case for me.\n\nThere are other template engines available for Ruby and Rails. I’ve worked with HAML2 on several\n\nRails projects, and I’ve heard good things about Slim.3 Give them a try if you’re interested.\n\nBack to our failing spec. Our spec is failing because it can’t ﬁnd the <header> element in our template. We need to create that element, but where? I can think of three possible places to put our HTML code:\n\n1. app/views/home/index.html.erb 2. app/views/layouts/application.html.erb 3. In a new partial ﬁle that we share between our views\n\nAs you might have guessed, the third option is the best option. But why?\n\nOur blog header will need to appear on every public page of our application, so we should put it in a partial ﬁle that we can render it inside our app/views/layouts/application.html.erb ﬁle. If we put our code in the app/views/home/index.html.erb ﬁle, we would end up having duplicate code for every page of our application that needs a header. This is something we want to avoid since changing it would then require us to edit many ﬁles instead of just one.\n\nPutting our code in our app/views/layouts/application.html.erb ﬁle would not be horrible, but this ﬁle can become very large and difﬁcult to manage if we put too much code into it. It’s better to keep our layout ﬁles small and use partials to represent the logical sections of our layout.\n\n2https://haml.info/ 3https://slim-template.github.io/\n\nSystem Specs\n\nLet’s create a new directory named app/view/shared and add a new partial ﬁle called\n\n_header.html.erb in there:\n\n<header>\n\n<%= link_to 'My Blog', root_path %>\n\n</header>\n\nNotice how our header ﬁle’s ﬁlename starts with an underscore. This is a Rails convention that tells Rails this ﬁle is a partial ﬁle. We can render this partial ﬁle in other templates by using the ﬁlename without the underscore. For example, we can render this partial in our app/views/layouts/application.html.erb ﬁle using the following line of code:\n\n<%= render 'shared/header' %>\n\nRails looks in our app/views directory for templates by default, so we don’t need to specify that directory path in our render method call. We just need to specify the path to the partial ﬁle relative to our app/views directly, which in this case is shared/header.\n\nNow that we are Rails partial template experts, we can proceed with rendering our partial in our app/views/layouts/application.html.erb layout ﬁle by adding the following code just inside our opening <body> tag:\n\n<body>\n\n<%= render 'shared/header' %> <%= yield %>\n\n</body>\n\nThe render method is a Rails helper method that will render the partial ﬁle. The yield method is a special method that will render the contents of the current view template. These two concepts will become more clear as we continue to add more partial templates.\n\nLet’s run our spec again. This time, it passes! We’ve successfully rendered our header partial in\n\nour application layout.\n\n.\n\nFinished in 1.51 seconds (files took 1.11 seconds to load) 1 example, 0 failures\n\nConﬁguring Selenium\n\nWhen we run our new system spec, we can visibly see a browser window open and close as the spec runs. But what if it’s not the browser we wanted? What if we want to use “headless mode” sometimes but maybe not always? What if we’re on our CI server and we can only use headless mode?\n\n57\n\n58\n\n7 Creating Pages\n\nThe answers to these questions are all about conﬁguration. We can conﬁgure Capybara to use different drivers for different environments or different environment variables. We can also conﬁgure Capybara to use different headless modes for different drivers. It’s all about what we decide we need for our application.\n\nFor our blog application, we’re going to use Chrome as our Capybara-conﬁgured browser, and\n\nwe’ll conﬁgure a way to run our specs in headless mode whenever we want to.\n\nIn our spec/rails_helper.rb ﬁle, we can conﬁgure Capybara. We need to work inside the\n\nRSpec.configure block. Let’s add a new block of code there:\n\nconfig.before(:each, type: :system) do driver = :selenium_chrome_headless driver = :selenium_chrome if ENV['SHOW_CHROME'] driven_by(driver)\n\nend\n\nThis lets us run our spec in headless mode by default, but we can also run it with a visible Chrome browser by setting the SHOW_CHROME environment variable on our command line. Let’s run our spec again. This time, we will not see a browser window open:\n\nbe rspec spec/system/home_spec.rb\n\nAnd then if we use our new SHOW_CHROME environment variable, we will see a browser window open:\n\nSHOW_CHROME=1 be rspec spec/system/home_spec.rb\n\nI like this approach because it lets me run my specs in headless mode by default during local development, as well as on my CI server. But if I need to see the browser, for whatever reason, I can easily do that by temporarily setting the environment variable.\n\nDisplaying Page Summaries\n\nContinuing development of our blog application’s homepage, next we’re going to add a list of blog post summaries. We’ll start by writing a failing spec for this new functionality. Since we’re still working on our homepage, we can continue to use the same spec ﬁle. Let’s check for a new article element in our spec:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Home' do\n\nit 'renders homepage' do\n\ncreate(:page)",
      "page_number": 58
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 67-74)",
      "start_page": 67,
      "end_page": 74,
      "detection_method": "topic_boundary",
      "content": "Displaying Page Summaries\n\nvisit root_path\n\nwithin 'header' do\n\nexpect(page).to have_link 'My Blog'\n\nend\n\narticles = find_all('article') expect(articles.size).to eq(1)\n\nwithin articles.first do\n\nexpect(page).to have_css('h2', text: Page.last.title)\n\nend\n\nend\n\nend\n\nWe’re using Capybara’s find_all method to ﬁnd all of our <article> elements on the page. We’re then checking that there is only one article element. Next, we use Capybara’s within method to scope our expectations down to the ﬁrst article element and check that it has an h2 element with the text of the last Page record’s title attribute.\n\nUsing .last here is a very common pattern found in specs. It allows us to locate and reference the last record we added to our database without having to know the ID of that record. This is very helpful since the ID of the last record will change every time we re-run our spec. Our pages table’s ID column is an auto-incrementing integer generated from our database sequence, so the ID of the last record will always be changing to be one greater than the ID of the previous record.\n\nLet’s run our spec and see it fail:\n\n1) Home renders homepage\n\nFailure/Error: expect(articles.size).to eq(1)\n\nexpected: 1 got: 0\n\nIt seems like the ﬁx might be as simple as adding a new Page record to our database and displaying that on the page. But do we want to show all posts? What about the published attribute in our Page model? We’ve made no consideration for its usage yet.\n\nPublished vs. Unpublished Pages\n\nNot all Pages are equal. Some are ready to be published and some need more work and are not. We need the concept of an unpublished Page for several important reasons:\n\n1. We want to be able to continue working on a page as many times as required before considering it complete and ready for anyone to read.\n\n2. We don’t want to show incomplete or unﬁnished pages to search engines. 3. We want to be able to retire old pages and remove them from our blog.\n\n59\n\n60\n\n7 Creating Pages\n\nRecalling back to when we made our database migration for our pages table, we defaulted our published ﬁeld to false. We even took things a step further and had our Page factory also default our published ﬁeld to false. This means that when we create a new Page record, it will not be published by default, with no effort from us or from our code.\n\nAll that said, we still need a way to display only published pages. In Rails, we can use the scope4 method to deﬁne a named scope on our Page model that queries our database for published pages only. Let’s add a new model spec for our published scope idea:\n\ndescribe 'scopes' do\n\ndescribe '.published' do\n\nlet(:page1) { create(:page, :published) } let(:page2) { create(:page) }\n\nbefore do\n\n[page1, page2]\n\nend\n\nit 'returns only published pages' do\n\nexpect(Page.published).to eq([page1])\n\nend\n\nend\n\nend\n\nWe’re using the let method to deﬁne two Page records. Per our database default, our Pages are unpublished unless we explicitly say otherwise. In our spec, our page1 instance will be published, while our other page2 instance will be defaulting to unpublished.\n\nRSpec lets are lazily evaluated, so we use the before block to create both records in our database before our spec runs. We then add a describe block to deﬁne our .published scope and use the it block to check that it returns only the one published Page record.\n\nLet’s run our spec and see it fail:\n\n1) Page scopes .published returns published pages\n\nFailure/Error: let(:page1) { create(:page, :published) }\n\nKeyError:\n\nTrait not registered: \"published\"\n\nWe’re getting a KeyError because we haven’t deﬁned a published trait in our Page factory yet. Let’s add that now inside our factory block:\n\ntrait :published do\n\npublished { true }\n\nend\n\n4https://guides.rubyonrails.org/active_record_querying.html#scopes\n\nDisplaying Page Summaries\n\nLet’s run our spec again:\n\n1) Page scopes .published returns published pages Failure/Error: expect(Page.published).to eq([page1])\n\nNoMethodError:\n\nundefined method `published' for Page:Class\n\nNow we’re getting a NoMethodError because we haven’t deﬁned our .published scope yet in our Page model class. Let’s add that now:\n\nscope :published, -> { where(published: true ) }\n\nNow our new scope spec passes.\n\nRails scopes are a great way to encapsulate common database queries. We can use them anywhere\n\nin our code including inside our controller actions. Let’s now use our new .published scope.\n\nDisplaying Published Pages\n\nTo make our posts available to our view, we need to add an instance variable to our HomeController#index action. We’ll call it @posts and assign it to the result of calling our new .published scope:\n\ndef index\n\n@pages = Page.published\n\nend\n\nWe can now use our new instance variable in home/index.html.erb to display a list of our pages using the page titles:\n\n<% @pages.each do |page| %>\n\n<article>\n\n<h2><%= page.title %></h2>\n\n</article>\n\n<% end %>\n\nNow we just need to go back and update our homepage spec to create a published page; let’s add our new published trait to our create(:page) call:\n\ncreate(:page, :published)\n\nThat should do it. Let’s run our spec and see it pass.\n\n61\n\n62\n\n7 Creating Pages\n\nPage Summary Ordering\n\nWe’ve got our homepage displaying our published pages, but they’re not necessarily in the correct order. We want our most recent posts to be displayed ﬁrst, followed by older posts. We can use ActiveRecord’s order method to specify the order we want our posts to be displayed, but we want to add it as a scope so it’s cleaner and simpler to use. Let’s add a new Page model spec ﬁle spec/models/page_spec.rb to test our new model scope inside our describe ‘scopes’ block:\n\ndescribe '.ordered' do\n\nlet(:page1) { create(:page, created_at: 2.days.ago) } let(:page2) { create(:page, created_at: 1.day.ago) }\n\nbefore do\n\n[page1, page2]\n\nend\n\nit 'returns ordered pages' do\n\nexpect(Page.ordered).to eq([page2, page1])\n\nend\n\nend\n\nWe’re using let to deﬁne two Page records. One is created two days ago, and the other is created one day ago. RSpec lets are lazily evaluated, so we use the before block to create both records in our database. We’re creating our new Page records in the opposite order that we expect our scope to order results; this provides additional conﬁdence that our spec won’t pass by accident. Running our spec, we get the failure:\n\n1) Page scopes .ordered returns ordered pages Failure/Error: expect(Page.ordered).to eq([page2, page1])\n\nNoMethodError:\n\nundefined method `ordered' for Page:Class\n\nThe simplest thing we can do to make progress on our failing spec is to add an empty .ordered scope to our Page model:\n\nscope :ordered, -> {}\n\nRunning our spec again, we get a different failure:\n\n1) Page scopes .ordered returns ordered pages\n\nFailure/Error: expect(Page.ordered).to eq([page2, page1])\n\nexpected: [#<Page id: 642, user_id: 898, title: \"Charisma ...\n\ngot: #<ActiveRecord::Relation [#<Page id: 641, ...\n\nDisplaying Page Summaries\n\nWe can see just from looking at the ids in the failure message that our scope isn’t ordering our results correctly. We can ﬁx that by implementing the body of our .ordered scope:\n\nscope :ordered, -> { order(created_at: :desc) }\n\nRunning our spec again, we see it passes. We can now use our new .ordered scope in our HomeController#index action:\n\ndef index\n\n@pages = Page.published.ordered\n\nend\n\nHappy Paths and System Specs\n\nSystem specs are not cheap in terms of CPU and memory usage. They spawn some sort of a web client (usually a headless browser) and run our specs against it. As a result, system specs are slower and more resource intensive than any other kind of spec we can write. Being thoughtful software engineers, we do not want to exhaust our limited system resources by running unnecessary system specs.\n\nBut what makes a system spec unnecessary? In general, unnecessary system specs fall into a few categories:\n\n1. Redundant 2. Negative 3. Impossible\n\nFor example, we may have a spec that tests that a user can log in successfully. That’s a great reason for the system spec to exist. But we don’t then also need another system spec that tests that a user cannot log in successfully. We can trust that if we somehow break the ability for a user to log in, our original login system spec will fail, and we will realize our mistake. We call the former spec the “happy path” and the latter the “sad ” or “unhappy ” path.\n\nDo not confuse the unhappy path with feature logic. For example, we may have a feature where the user ﬁlls out a form and submits it. If the form is invalid, we want to display an error message to the user. That sounds like a feature requirement that we should deﬁnitely test. What we should not test is that the error message does not display when the form submission is valid.\n\nWe want to keep our system specs focused on the happy path and avoid testing anything that is not a feature requirement. We should also do our best to create the smallest possible system spec with the fewest database interactions possible. This will help us keep our system specs fast and efﬁcient.\n\nSometimes, we will ﬁnd that something we ﬁrst think to put in a system spec can instead be placed in a view spec or a request spec. This is deﬁnitely a “right tool for the job” scenario. It’s our job as software engineers to choose the right tool for the job. Let’s do our jobs!\n\n63\n\n64\n\n7 Creating Pages\n\nDisplaying a Single Page\n\nNext, we want to be able to display a single page. Let’s create a new system spec ﬁle named spec/system/page_spec.rb and add a new spec for our single page:\n\nCustom Routing\n\nrequire 'rails_helper'\n\nRSpec.describe 'Pages' do\n\nlet(:my_page) { create(:page, :published) }\n\nit 'renders page' do\n\nvisit page_path(slug: my_page.slug)\n\narticle = find('article')\n\nwithin article do\n\nexpect(page).to have_css('h2', text: my_page.title)\n\nend\n\nend\n\nend\n\nWe’re again using the FactoryBot create method to create a published page. We then use Capybara’s visit method to visit the page’s URL. Next, we use the find method to ﬁnd our article element on the page. After that, we use the within method to scope our expectations to only the article element and its contents. Finally, we use the have_css matcher to check that the article element contains an h2 element with the text of the page’s title.\n\nThis spec will give us plenty to do. Let’s work through the failures. Running our spec will give us\n\nour ﬁrst failure:\n\n1) Pages renders page\n\nFailure/Error: visit page_path(slug: my_page.slug)\n\nNoMethodError:\n\nundefined method `page_path' for #<RSpec::ExampleGroups::Pages \"renders page\" (./spec/system/page_spec.rb:6)>\n\nWe’re getting a NoMethodError because we don’t have a page_path route yet. Let’s modify our config/routes.rb ﬁle to add a route for our pages:\n\nget 'page/:slug',\n\nto: 'pages#show', slug: /[-a-z0-9+]*/, as: :page\n\nDisplaying Page Summaries\n\nThis is a custom route that aids us in creating our beautiful URLs we discussed before. The :slug value must match our regular expression /[-a-z0-9+]*/, and then when it does, our request is sent to our show action in our Pages controller. Re-running our spec shows us our next failure:\n\n1) Pages renders page\n\nFailure/Error: raise MissingController.new(error.message, error.name)\n\nActionController::RoutingError:\n\nuninitialized constant PagesController\n\nNot surprising, we have not created our PagesController yet. Let’s create it and add a #show action as well:\n\nbe rails g controller pages show\n\nThis moves us to our next spec failure:\n\n1) Pages renders page\n\nFailure/Error: article = find('article')\n\nCapybara::ElementNotFound:\n\nUnable to find css \"article\"\n\nHaving an empty #show action is not enough to make our spec pass. We need to query our database for the page we want to display and then set that result as an instance variable, for use in our view template. Let’s add a #find_by query to our #show action:\n\nclass PagesController < ApplicationController\n\ndef show\n\n@page = Page.published.find_by(slug: params[:slug])\n\nend\n\nend\n\nIn addition to our #find_by query, we need to also make sure that we only ﬁnd and return published pages. We can do that by chaining our #find_by query to our #published scope.\n\n65\n\n66\n\n7 Creating Pages\n\nThis will give us a @page instance variable that we can use in our view:\n\n<article>\n\n<h2><%= @page.title %></h2>\n\n</article>\n\nOur spec should now pass. Let’s run it and see:\n\nbe rspec spec/system/page_spec.rb\n\n.\n\nFinished in 1.16 seconds (files took 1.07 seconds to load) 1 example, 0 failures\n\nBroken Specs and Warnings\n\nWe used Rails code generators to generate our PagesController and our HomeController, and along the way matching request specs were also generated for us. If we run RSpec against our generated request specs, we will see that we have some failures. The ﬁrst one is in our spec/requests/home_spec.rb ﬁle:\n\n1) Homes GET /index returns http success Failure/Error: get \"/home/index\"\n\nActionController::RoutingError:\n\nNo route matches [GET] \"/home/index\"\n\nThe failure is because we’re never planning to have a /home/index route. We’re going to use the HomeController#index as the root (or homepage) of our application. We can ﬁx this spec failure by deleting the spec or by changing it to request our root path instead. Let’s do the latter:\n\nrequire 'rails_helper'\n\nRSpec.describe 'HomePage', type: :request do\n\ndescribe 'GET /index' do\n\nit 'returns http success' do\n\nget root_path expect(response).to be_successful\n\nend",
      "page_number": 67
    },
    {
      "number": 9,
      "title": "Segment 9 (pages 75-82)",
      "start_page": 75,
      "end_page": 82,
      "detection_method": "topic_boundary",
      "content": "Broken Specs and Warnings\n\nend\n\nend\n\nOur spec should now pass. Our next failure message points to our spec/requests/pages_ spec.rb spec:\n\n1) Pages GET /show returns http success Failure/Error: <h2><%= @page.title %></h2>\n\nActionView::Template::Error:\n\nundefined method `title' for nil:NilClass\n\nThis failure is happening because our PagesController#show action is querying our database for a page with a slug value of “show” that does not currently exist. We can ﬁx this by putting a known page instance into our database and then using its slug value in our request spec:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Pages', type: :request do\n\ndescribe 'GET /show' do\n\nlet(:page) { create(:page, :published) }\n\nit 'returns http success' do\n\nget page_path(slug: page.slug) expect(response).to be_successful\n\nend\n\nend\n\nend\n\nThis update gets our spec passing. If we now run RSpec against our entire test suite, we see that we now only have a few warnings:\n\nbe rspec\n\n# Not yet implemented # ./spec/helpers/home_helper_spec.rb:14\n\n# Not yet implemented # ./spec/helpers/pages_helper_spec.rb:14\n\n# Not yet implemented # ./spec/views/home/index.html.erb_spec.rb:4\n\n67\n\n68\n\n7 Creating Pages\n\n# Not yet implemented # ./spec/views/pages/show.html.erb_spec.rb:4\n\nWe will implement some of these specs in later chapters. For now, let’s make our test suite less noisy by just deleting them:\n\nrm spec/helpers/home_helper_spec.rb \\\n\nspec/helpers/pages_helper_spec.rb \\ spec/views/home/index.html.erb_spec.rb \\ spec/views/pages/show.html.erb_spec.rb\n\nWe can now run RSpec against our entire test suite and see that we have no failure messages or warnings.\n\nSummary\n\nWe now have a solid understanding of how to create a system spec and how to use Capybara to interact with our application like a user would when using a web browser. We also have a good understanding of how to create custom routes, controller actions, and how to use instance variables in view templates.\n\nNext, we’ll jump into view specs, an often overlooked but very important part of our testing suite\n\ncapabilities.\n\nBuild Homepage Contents\n\nIn the last chapter, we created our ﬁrst page, the home page, and our show page for displaying individual page objects. These were minimal efforts with just enough content for creating our ﬁrst two system specs. In this chapter, we will take things further and complete building out these pages using our remaining content ﬁelds.\n\nView Specs\n\nIf you recall, we used the HTML <article> tag to wrap our page content. This is a good choice as it has semantic value for accessibility and search engine optimization. It’s not hard to see how our homepage, which uses an article tag to list all of our page summaries, will be similar in structure to our article tag that shows a single page object on our show page. Hmm.\n\nIn fact, the only real difference between the two is that our homepage view will show our page summary ﬁeld, while our show page view will show our content ﬁeld. This similar structure is a good candidate for a shared partial template.\n\nShared Partial Template\n\nOur shared partial idea needs a spec, so let’s create a new ﬁle named _page.html.erb_spec.rb in our spec/views/shared directory and then add the following content:\n\nrequire 'rails_helper'\n\nRSpec.describe 'shared/_page.html.erb', type: :view do\n\nlet(:page) { build(:page) }\n\nit 'renders the page object' do\n\nassign(:page, page) render partial: 'shared/page',\n\nlocals: {\n\npage: page, content: '<p>content</p>'\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_8\n\n8\n\n69\n\n70\n\n8 Build Homepage Contents\n\n}\n\nexpect(rendered).to have_css('h2', text: page.title) expect(rendered).to have_css('p', text: page.created_at.to_fs) expect(rendered).to have_css('p', text: 'content')\n\nend\n\nend\n\nThe ﬁlename _page.html.erb_spec.rb may look a little strange, but it’s actually a convention for naming view specs for partial templates. The leading underscore indicates that this is a partial template spec, and the _spec.rb sufﬁx is used to indicate that this is a spec ﬁle.\n\nThe spec itself is fairly straightforward. We build a page object and assign it to a page instance variable, much like our Rails controller would. We use build because we do not need our variable to actually be persisted in our database for the purposes of our spec. We then render our partial template while passing in our local variables using locals. Finally, we make assertions about the rendered content.\n\nWhen we run our new spec, we get the failure message:\n\n1) shared/_page.html.erb renders the page object Failure/Error:\n\nrender partial: 'shared/page',\n\nlocals: {\n\npage: page, content: '<p>content</p>'\n\n}\n\nActionView::MissingTemplate:\n\nMissing partial shared/_page\n\nThe failure message makes perfect sense as we have not yet created our partial template. In the app/views/shared directory, let’s create an empty _page.html.erb ﬁle and then run our spec again. This time, we get a different failure message:\n\n1) shared/_page.html.erb renders the page object Failure/Error: expect(rendered).to have_css('h2', text: page.title)\n\nexpected to find css \"h2\" but there were no matches\n\nThis failure is also expected as we have not yet added any content to our partial template. Let’s add the following:\n\n<article>\n\n<h2><%= link_to page.title, page_path(slug: page.slug) %></h2> <p><%= page.created_at.to_fs %></p> <%= content.html_safe %>\n\n</article>\n\nView Specs\n\nThis gets our spec passing. We can now refactor our homepage and show page views to use this partial template.\n\nNotably, we use the html_safe method on our content variable to indicate that it is safe HTML content. This is important as we will likely want to later format our summary and content ﬁeld data with HTML formatting.\n\nIf we were to use the content variable without calling html_safe on it, our HTML would be rendered as literal text. This is a security feature of Rails to prevent cross-site scripting (XSS) attacks. We can see this undesirable HTML tag rendering in action by temporarily removing the html_safe call:\n\n<%= content %>\n\nOur <p>content</p> tag will now have any dangerous characters replaced with their corresponding HTML entities before being rendered:\n\n&lt;p&gt;content&lt;/p&gt;\n\nOur < and > characters have been replaced, making our HTML tags safe to render.\n\nSo you may now be wondering if using html_safe makes our app less secure. We trust ourselves to not attack our own application, so it’s likely we can trust that our own content will be safe. If we were to allow untrusted users to create pages, we would not want to use html_safe on it before rendering it, or we would put great effort into sanitizing the content before we did render it.\n\nGranted, a <p> tag is not very dangerous, but imagine if we allowed users to create pages with JavaScript <script> tags in them. We would not want to render that JavaScript without sanitizing it as it could be used to attack our site visitors.\n\nMore View Specs\n\nWe have our shared partial template, but we still need to update our “homepage ” and “show ” page views to use it. Let’s start with a homepage view spec ﬁle named index.html.erb_spec.rb in our spec/views/home directory:\n\nrequire 'rails_helper'\n\nRSpec.describe 'home/index', type: :view do\n\nlet(:page) { build(:page) }\n\nit 'renders the page object' do\n\nassign(:pages, [page]) render expect(rendered).to have_css('h2', text: page.title) expect(rendered).to have_css('p', text: page.created_at.to_fs) expect(rendered).to include(page.summary)\n\n71\n\n72\n\n8 Build Homepage Contents\n\nend\n\nend\n\nThis spec expects our home/index template to use our shared partial template to render a list of page objects, with emphasis on displaying our summary ﬁeld data. We start out with calling assign to assign an array of page objects to the pages variable just like our controller would, and then we render the view. We can simply call render since this is a non-partial template. RSpec knows the correct template to render because of our RSpec.describe ’home/index’ do block that contains our path. After the render executes, we make assertions about the rendered content.\n\nI will point out how our last expectation uses include to check for the presence of our summary ﬁeld data. This is a good choice as we do not want to make any direct assumptions about the actual HTML structure of our summary data. We just want to make sure that the summary data is present in the rendered content.\n\nWhen we run our spec, we get the failure:\n\n1) home/index renders the page object\n\nFailure/Error: expect(rendered).to have_css('p',\n\ntext: page.created_at.to_fs) expected to find css \"p\" but there were no matches\n\nNow we need to update our home/index template to use our shared partial:\n\n<% @pages.each do |page| %>\n\n<%= render partial: 'shared/page', locals: {\n\npage: page, content: page.summary\n\n} %>\n\n<% end %>\n\nNext, spec/views/pages directory:\n\nlet’s add our “show” view spec ﬁle named show.html.erb_spec.rb\n\nin our\n\nrequire 'rails_helper'\n\nRSpec.describe 'pages/show', type: :view do\n\nlet(:page) { build(:page) }\n\nit 'renders the page object' do\n\nassign(:page, page) render expect(rendered).to have_css('h2', text: page.title) expect(rendered).to have_css('p', text: page.created_at.to_fs) expect(rendered).to include(page.content)\n\nHomepage Layout\n\nend\n\nend\n\nThis spec expects our pages/show template to use our shared partial template to render a single page object, just as before, but now with emphasis on displaying our content ﬁeld data, rather than our summary data. We start out with calling assign to assign our page object to our page variable, just like our controller would, and then we render our view. We can again just call render since this is also a non-partial template. RSpec again knows the correct template to render because of our RSpec.describe ’pages/show’ do block that contains the path. After the render, we make assertions about the rendered content.\n\nWhen we run our spec, we get the failure message:\n\n1) pages/show renders the page object\n\nFailure/Error: expect(rendered).to have_css('p',\n\ntext: page.created_at.to_fs) expected to find css \"p\" but there were no matches\n\nNow we need to update our pages/show template to use our shared partial:\n\n<%= render partial: 'shared/page', locals: {\n\npage: @page, content: @page.content\n\n} %>\n\nThat’s it! We have now refactored our homepage and show page views to use our shared partial template. We have also added view specs to ensure that our partial template is rendering the correct data depending on the context it’s used in. Let’s re-run all of our specs again to make sure we have not accidentally broken anything:\n\nbe rspec\n\nWe should see all of our specs are passing.\n\nHomepage Layout\n\nUntil now, we’ve been using the default Rails application layout ﬁle application.html.erb located in our app/views/layouts directory. It was generated for us when we ﬁrst created our Rails application. Let’s improve on our layout by adding some structure to it. We will go with the familiar header, main, sidebar , and footer layout structure shown in Figure 8-1 that many websites use. The header, footer, and sidebar sections will contain more or less static content, while the main section will contain the more dynamic content that changes depending on the page we are viewing.\n\n73\n\n74\n\n8 Build Homepage Contents\n\nFigure 8-1 Blog page layout\n\nCSS Framework\n\nWe will use the CSS framework Bootstrap to bootstrap our layout and CSS styling. Bootstrap is a mature CSS framework that is well documented and has many great features. It works really well with mobile devices and has a large community of veteran users. We will use the latest Bootstrap version 5.\n\nThere are many ways to add Bootstrap to a Rails application. Since we are using Rails and have a Gemﬁle setup already, we will use the gem approach. Let’s add the following to our Gemfile in the upper section outside of any environment groups, so it’s available to all our environments:\n\ngem 'bootstrap'\n\nThen we need to run bundle to install the new gem:\n\nbundle\n\nLayout Template\n\nRight now, our layout <body> tag content looks this:\n\n<body>\n\n<%= render 'shared/header' %> <%= yield %>\n\n</body>",
      "page_number": 75
    },
    {
      "number": 10,
      "title": "Segment 10 (pages 83-97)",
      "start_page": 83,
      "end_page": 97,
      "detection_method": "topic_boundary",
      "content": "Homepage Layout\n\nCurrently, we’re rendering a shared header partial template and then yielding whatever content we get from a given controller action when visiting a particular URL route. Let’s add the main, sidebar , and footer sections to our layout and introduce additional partial templates to help keep things organized.\n\nLet’s begin this idea with a new view spec. Let’s ﬁrst create a new directory spec/views/ layouts and then add a new view spec ﬁle inside it named application.html.erb_ spec.rb:\n\nrequire 'rails_helper'\n\nRSpec.describe 'layouts/application', type: :view do\n\nit 'renders the layout' do\n\nallow(view).to receive(:render).and_call_original render\n\nexpect(view).to have_received(:render).with('shared/header') expect(view).to have_received(:render).with('shared/side_bar') expect(view).to have_received(:render).with('shared/footer')\n\nend\n\nend\n\nThis spec provides a lot of value for the few lines of code it contains. It ensures that our layout is rendering the correct partial templates. The line\n\nallow(view).to receive(:render).and_call_original\n\nis dual purpose. It allows us to add expectations about render calls our view makes, and with the and_call_original call, it allows the render calls to actually happen even though we are mocking all render calls inside our view. This spec isn’t so much about what HTML is rendered, but rather that the correct partial templates are successfully rendered in our layout ﬁle.\n\nWhen we run our spec, we get past the expected shared/header rendering since it already\n\nexists in our layout ﬁle, but then the next expectation fails with the error:\n\nFailures:\n\n1) layouts/application renders the layout\n\nFailure/Error: expect(view).to have_received(:render)\n\n.with('shared/side_bar')\n\nAt templates. Let’s do partial shared/_side_bar.html.erb indicate they are partial templates.\n\nthis point,\n\nit makes sense\n\nto create empty shared/side_bar and shared/footer leading underscores, to respectively,\n\nthat now. Remember\n\nto name\n\nthe ﬁles with\n\nand shared/_footer.html.erb,\n\n75\n\n76\n\n8 Build Homepage Contents\n\nWith our new empty partial templates in place, we can update our layout HTML to create our\n\nactual layout structure:\n\n<body>\n\n<div class=\"container-fluid\">\n\n<%= render 'shared/header' %>\n\n</div>\n\n<main class=\"container-fluid\">\n\n<div class=\"row\">\n\n<div class=\"col-md-9\">\n\n<%= yield %>\n\n</div> <div class=\"col-md-3\">\n\n<%= render 'shared/side_bar' %>\n\n</div>\n\n</div>\n\n</main>\n\n<%= render 'shared/footer' %>\n\n</body>\n\nIn our layout, we use the Bootstrap container-fluid style that will expand our content to ﬁll the entire width of the browser window. Next, we create a row and two col-md-9 and col-md-3 columns. The col-md-9 column will contain the yielded content from the controller action, while the col-md-3 column will contain the side_bar partial template. We also add a footer partial template to the bottom of our layout.\n\nLet’s run our view spec again and see that it passes. We can also visit our homepage in a web\n\nbrowser and see that our layout is rendering correctly.\n\nSidebar Layout\n\nLots of different types of content can appear in a blog sidebar. Some of the more common things I’ve seen are\n\nRecent posts • Recent comments • Archives • Categories • Tag clouds • Search • Social media links\n\nFrom this list of possible sidebar content, I’ve chosen to write about two of the most common ones: an archive and a search form. The archive will be a list of all the month/year combinations that have any page content. The search form will allow our visitors to search our pages by title or by content.\n\nLet’s capture the layout of our sidebar in a view spec. This new spec will be similar to our application layout spec; it will ensure we are rendering the correct partial templates we\n\nSummary\n\nmean to render. Let’s create a new spec ﬁle named _side_bar.html.erb_spec.rb in our spec/views/shared directory with the following content:\n\nrequire 'rails_helper'\n\nRSpec.describe 'shared/_side_bar', type: :view do\n\nit 'renders the side_bar' do\n\nallow(view).to receive(:render).and_call_original render\n\nexpect(view).to have_received(:render).with('shared/search_form') expect(view).to have_received(:render).with('shared/archives')\n\nend\n\nend\n\nRunning this spec, we get the following error:\n\nFailures:\n\n1) shared/_side_bar renders the side_bar\n\nFailure/Error: expect(view).to have_received(:render)\n\n.with('shared/search_form')\n\nFor now, let’s create empty ﬁles for our new partial template ﬁles:\n\n1. app/views/shared/_search_form.html.erb 2. app/views/shared/_archives.html.erb\n\nNow we can update our shared/_side_bar.html.erb partial template to render our new partials:\n\n<%= render 'shared/search_form' %> <%= render 'shared/archives' %>\n\nWith these changes in place, our side_bar view spec passes.\n\nSummary\n\nIn this chapter, we introduced a new layout ﬁle and partial templates to help keep our views organized. In the next chapter, we’ll build out our search form in earnest, as well as our archive listing.\n\n77\n\nSidebar Contents\n\nIn the previous chapter, we laid out placeholder templates for our overall application layout and our sidebar. In this chapter, we will build out a search service which will allow us to search our blog pages by keyword. We’ll also work up some clever SQL to establish our dynamically generated archive list.\n\nSearch As a Service\n\nWe’ll start this chapter by ﬁrst building a search service. Our search service will be a simple Ruby class that handles searching our page records and will live in between our Search controller and our Page model. We’re going to develop it as a service because it’s neither a model nor is it a controller. It will be called from our controller, but it will not be a controller, and similarly it will operate on our Page model while not being a model itself. All that said, it makes sense to develop it as a service.\n\nYou may ﬁnd other Ruby and Rails developers have strong opinions about when to make a thing into a service or not. I’ve found the best way for me to decide is to ask myself: Is this thing a model? Is this thing a controller? If neither is true, then it’s probably a service. If you’re coming over from the Java world, you may prefer to make a thing into a service even when it could exist just as easily as a worker or a builder/factory class, or something similar. Feel free to do whatever makes sense to you. I’m going to show you what I do.\n\nI also think it’s important to remember that when using Rails, some things we will build won’t always ﬁt comfortably into the model-view-controller (MVC) pattern. It’s up to us to decide how to handle these things when they come up. Rails doesn’t include a formal “service” pattern, but it does not mean we are prohibited from making and using services.\n\nImplementing a Search Service\n\nLet’s start by creating a new spec directory spec/services. This is where we’ll put our search service spec. Then, inside our new directory, let’s create a new spec ﬁle called page_search_spec.rb. Inside our new spec ﬁle, let’s add the following code:\n\nrequire 'rails_helper'\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_9\n\n9\n\n79\n\n80\n\n9 Sidebar Contents\n\nRSpec.describe PageSearch do\n\nsubject { PageSearch }\n\ndescribe '.search' do\n\nit 'nil params returns no pages' do\n\nexpect(subject.search(nil)).to eq([])\n\nend\n\nend\n\nend\n\nAs expected, we see our new spec fail when we run it:\n\nNameError:\n\nuninitialized constant PageSearch\n\nThe error message is telling us that we need to create a PageSearch constant of some sort, so let’s do that. Let’s ﬁrst create a new directory called app/services. Then, inside our new directory, let’s create a new ﬁle called page_search.rb. Inside our new ﬁle, let’s add the following code:\n\nmodule PageSearch end\n\nThis will create a new constant as a Ruby Module. But why did we choose a module instead of a class? The reason is that we’re not going to be creating any instances of our search service. We’re only going to call a single method on it, so it makes sense to make it as a Ruby module. If we were going to be creating actual instances of our search service, then we would have made it a Ruby Class.\n\nWhen we run our spec again, we see that creating our new module moves us to our next error\n\nmessage:\n\nNoMethodError:\n\nundefined method `search' for PageSearch:Module\n\nSpec failures are really good at telling us what we need to do next! Let’s add a search method to our PageSearch module:\n\ndef self.search(params) end\n\nSearch As a Service\n\nThe self keyword in Ruby has a number of different meanings depending on the context. In this context, it means that we’re deﬁning a method directly inside our PageSearch module namespace. This allows us to call it like this:\n\nPageSearch.search\n\n# Instead of like this: # PageSearch.new.search\n\nWhen we run our spec again, we see that creating our new method moves us to our next error message:\n\nFailure/Error: expect(subject.search).to eq([])\n\nexpected: []\n\ngot: nil\n\nAt this point, we can make our spec pass by simply returning an empty array:\n\nmodule PageSearch\n\ndef self.search(params)\n\n[]\n\nend\n\nend\n\nThe next thing we will do is get our search service to handle empty parameters. In Ruby, an empty parameter hash is not the same thing as the nil value we passed in our ﬁrst spec. Let’s add a new spec to our page_search_spec.rb ﬁle to capture this idea:\n\nit 'empty params returns no pages' do\n\nexpect(subject.search({})).to eq([])\n\nend\n\nThis spec automatically passes because we’re already returning an empty array by default. So now both of our invalid parameter specs are passing.\n\nThe next thing we will do is get our search service to handle valid parameters. Before we do that, we need to consider what we will do with the parameters our service receives. Ultimately, we’ll use the params to search our database for matching Page records, which sounds a lot like a Rails scope.\n\n81\n\n82\n\n9 Sidebar Contents\n\nSo instead of writing a spec around actual Page search results, let’s write specs to ensure we send only valid parameters to our Page scope:\n\nit 'an empty term is not sent to .by_term' do\n\nallow(Page).to receive(:by_term) PageSearch.search({ term: '' }) expect(Page).to_not have_received(:by_term)\n\nend\n\nit 'a nil term is not sent to .by_term' do\n\nallow(Page).to receive(:by_term) PageSearch.search({ term: nil }) expect(Page).to_not have_received(:by_term)\n\nend\n\nit 'a valid term is sent to .by_term' do\n\nallow(Page).to receive(:by_term) PageSearch.search({ term: 'foo' }) expect(Page).to have_received(:by_term).with('foo')\n\nend\n\nThe allow mocks our call to .by_term, and our expect veriﬁes that our by_term call was made or not. The have_received matcher veriﬁes that a method was called with the correct arguments. When we run our specs, we see they all fail because we haven’t deﬁned the .by_term scope yet:\n\nFailure/Error: allow(Page).to receive(:by_term)\n\n... does not implement: by_term\n\nWe can ﬁx this by stubbing an empty .by_term scope, which we will build out shortly, in our Page model:\n\nscope :by_term, ->(term) { [] }\n\nRunning our spec again, we see that it fails with a new error message:\n\nFailure/Error: expect(Page).to have_received(:by_term).with('foo')\n\n... expected: 1 time with arguments: (\"foo\") received: 0 times\n\nThe error message is telling us that we need to call the .by_term scope from our PageSearch service. But before we do that, we need to consider under what conditions we will call our new\n\nSearch As a Service\n\n.by_term scope. We only want to call it when we have a term parameter present, so let’s implement it that way:\n\ndef self.search(params)\n\nreturn [] unless params.present? && params[:term].present?\n\nPage.by_term(params[:term])\n\nend\n\nWe’re examining our params in two different ways here. The ﬁrst way is to check if params are present at all, and if they are not present, we return an empty array, which is similar to searching using Rails ActiveRecord and ﬁnding no results. The second way we examine our params is to check if the term key is present, and if so we call our .by_term scope. When we run our specs again, we can see that they now all pass.\n\nSearching by Term\n\nNow that we have our .by_term scope being called from inside our search service, we can start to implement the scope itself. We want to be able to search by any number or combination of terms. So let’s start by writing a spec that will allow us to search by a single term. Let’s add the following to our existing spec/models/page_spec.rb ﬁle:\n\ndescribe '.by_term' do\n\nlet(:page) { create(:page, content: 'foo') }\n\nbefore { page }\n\nit 'returns pages for the given term' do\n\nexpect(Page.by_term('foo')).to eq([page])\n\nend\n\nend\n\nOur spec fails to ﬁnd an array of Page instances and fails:\n\nFailure/Error: expect(Page.by_term('foo')).to eq([page1])\n\nexpected: [#<Page id: 47, user_id: 118, title: \"Decipio...>]\n\ngot: []\n\n83\n\n84\n\n9 Sidebar Contents\n\nLooks like it’s time to implement our stubbed .by_term scope. We’ll start by assuming that we’ll be searching for a single term. This will change later, but right now we’re doing TDD, and we’re only concerned with this one failing spec. So let’s make it pass with\n\nscope :by_term, ->(term) { where('content LIKE ?', \"%#{term}%\") }\n\nWhen we run our spec again, we see that it passes. Now we can move on to implementing the ability to search by multiple terms. Let’s add a new spec that will allow us to search by multiple terms:\n\ndescribe '.by_term' do\n\nlet(:page1) { create(:page, content: 'foo') } let(:page2) { create(:page, content: 'foo bar') } let(:page3) { create(:page, content: 'foo bar baz') }\n\nbefore do\n\n[page1, page2]\n\nend\n\nit 'returns pages for the given term' do\n\nexpected = [page1, page2, page3] expect(Page.by_term('foo')).to match_array(expected)\n\nend\n\nit 'returns pages for multiple terms' do\n\nexpected = [page3] expect(Page.by_term('foo baz')).to match_array(expected)\n\nend\n\nend\n\nOur ﬁrst spec still passes, but our second spec is failing because we’re not splitting up the term into individual words. Using the Rails console, we can see that the entire string is being searched for like a phrase using the .to_sql method:\n\nbe rails console\n\nirb(main):001:0> Page.by_term('foo baz').to_sql => \"SELECT \\\"pages\\\".* FROM \\\"pages\\\" WHERE (content LIKE '%foo baz%')\"\n\nWe want to split the phrase into individual words and then use the resulting array to form a dynamically generated SQL query. We also want to take care to not break our existing spec that\n\nSearching for Pages\n\nonly queries by one word. We also want to clean up the content of the term or phrase being passed in and only search for alphanumeric characters. Here is the solution I came up with:\n\nscope :by_term, ->(term) do term.gsub!(/[^-\\w ]/, '') terms = term.include?(' ') ? term.split : [term]\n\npages = Page terms.each do |t|\n\npages = pages.where('content ILIKE ?', \"%#{t}%\")\n\nend\n\npages\n\nend\n\nThere’s a lot going on there, so let’s break it down. First, we clean up the incoming term argument by removing any non-alphanumeric characters using gsub with the regular expression. The regular expression may look complicated at ﬁrst glance, but it’s really just a list of characters we want to keep in the term while removing all others.\n\nNext, we check to see if the term contains a space character, which indicates that it is a phrase. If it is a phrase, then we split it into individual terms; otherwise, we just put the single term into an array as a single element. This way, we end up with an array either way.\n\nWe then iterate over the array of term(s) and build up a query that will search for each term. We start with just assigning Page to pages, then we add on a where clause for each term. Rails will join all of our where clauses together with an SQL AND:\n\nirb(main):001:0> Page.by_term('Foo baz!').to_sql => \"SELECT \\\"pages\\\".* FROM \\\"pages\\\" WHERE (content ILIKE '%Foo%') AND (content ILIKE '%baz%')\"\n\nThis way, we can search for as many terms as we like, and the query will be built up correctly. If you plan to run this code in production, you might want to limit the array size to some maximum number of terms of course.\n\nFinally, we return the resulting query result. When we run our specs again, we see they are both\n\npassing. Now we’ll move on to implementing calling our search service from our controller.\n\nSearching for Pages\n\nIn the next section, we will add a search form to our sidebar. We will then implement a search controller and view template to display our search results.\n\n85\n\n86\n\n9 Sidebar Contents\n\nAdding a Search Form\n\nNow that we have our search service implemented, we can pursue adding it to our sidebar and begin using it. Since this next bit of functionality is going to involve a form submission, we’ll test this using a new system spec. In our spec/system directory, we’ll create a new ﬁle called search_spec.rb and add the following code:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Search' do describe 'Searching' do\n\nbefore do\n\ncreate(:page, :published, content: 'Page content')\n\nend\n\ncontext 'with no search term' do\n\nit 'returns no results' do\n\nvisit root_path\n\nwithin 'form' do\n\nfill_in 'term', with: '' click_button 'Search'\n\nend\n\nexpect(page).to have_current_path(search_path(term: '')) expect(page).to have_css('p', text: 'No results found')\n\nend\n\nend\n\nend\n\nend\n\nOur spec is fairly straightforward. We create a page with some content, then visit the root path and submit an empty search term. We check that our form is actually set up to perform a GET request when invoked, which will make the URL useful to examine, compared to a form POST. We then expect to see a message saying that no results were found.\n\nThere are a lot of missing pieces to get this spec working, and we’ll let the spec drive them all out.\n\nWhen we run this spec:\n\nbe rspec spec/system/search_spec.rb\n\nwe see that it fails with\n\n1) Search Searching with no search term returns no results Failure/Error:\n\nwithin 'form' do\n\nfill_in 'term', with: '' click_button 'Search'\n\nSearching for Pages\n\nend\n\nCapybara::ElementNotFound:\n\nUnable to find css \"form\"\n\nOur failure message tells us that our spec can’t ﬁnd a form on the page. Let’s add an actual search form to our _search_form.html.erb partial:\n\n<div>\n\n<%= form_for(:search, url: search_path, method: :get) do %>\n\n<div>\n\n<input type=\"search\" name=\"term\" /> <input type=\"submit\" value=\"Search\" />\n\n</div> <% end %>\n\n</div>\n\nNow when we run our spec, we get our next failure message:\n\n1) Search Searching with no search term returns no results Failure/Error: <%= form_for(:search, url: search_path, method: :get) do %>\n\nActionView::Template::Error:\n\nundefined local variable or method `search_path' for\n\n#<ActionView::Base:0x0000000000cbc0>\n\nOur spec doesn’t currently understand that we’re expecting the search_path variable to be a Rails route, which makes sense since we didn’t add it to our routes ﬁle yet. Let’s add a new route pointing to our search controller. In our config/routes.rb ﬁle, let’s add\n\nget '/search', to: 'search#index'\n\nThis addition to our routes ﬁle will direct a matching GET request to /search to an index action in our SearchController, which of course doesn’t exist yet. So as expected, when we run our spec, we get\n\n1) Search Searching with no search term returns no results Failure/Error: raise MissingController.new(error.message, error.name)\n\nActionController::RoutingError:\n\nuninitialized constant SearchController\n\n87\n\n88\n\n9 Sidebar Contents\n\nThe spec is telling us that we need to create a SearchController. Let’s do that now. In our app/controllers directory, let’s create a new ﬁle called search_controller.rb and add the following code:\n\nclass SearchController < ApplicationController\n\ndef index end\n\nend\n\nOur new search controller is very simple; it just has an empty index action that does nothing useful at the moment. It is the simplest thing we can do to try to move our failing spec along to the next error. When we run our spec again, we’re informed of our missing search index template:\n\n1) Search Searching with no search term returns no results Failure/Error: raise ActionController::MissingExactTemplate, message\n\nActionController::MissingExactTemplate:\n\nSearchController#index is missing a template for request formats:\n\ntext/html\n\nDisplaying Search Results\n\nLet’s add our missing template. Inside our app/views directory, let’s add a new directory named \"search\", and inside that directory, let’s create a new ﬁle named index.html.erb. Running our spec again, we get our next error message:\n\n1) Search Searching with no search term returns no results Failure/Error:\n\nexpect(page).to have_css('p', text: 'No results found') expected to find css \"p\" but there were no matches\n\nLooks like progress. We’re now getting a failure because we don’t have the No results found message on our page. Let’s add that to our new template:\n\n<p>No results found</p>\n\nWith that addition, we now have a passing search spec.\n\nSearching for Pages\n\nNext, we can add a new spec to test the search results display when we do enter an actual search\n\nterm. In our spec/system/search_spec.rb ﬁle, let’s add the following code:\n\ncontext 'with a search term' do\n\nit 'renders search results' do\n\nvisit root_path\n\nwithin 'form' do\n\nfill_in 'term', with: 'content' click_button 'Search'\n\nend\n\nexpect(page).to have_current_path(search_path(term: 'content'))\n\narticles = find_all('article') expect(articles.count).to eq(1)\n\nwithin articles.first do\n\nexpect(page).to have_css('h2', text: Page.last.title)\n\nend\n\nend\n\nend\n\nThis spec is very similar to our previous spec except this time we’re entering an actual search term. We’re then expecting to see the title of the page we created previously as the ﬁrst of an array of <article> tags we ﬁnd using find_all. When we run this spec, we get\n\n1) Search Searching with a search term renders search results Failure/Error: expect(articles.count).to eq(1)\n\nexpected: 1 got: 0\n\nGetting this spec working requires two things. First, we need to get some search results to display. Second, we need to make sure that our search results are actually being rendered inside of <article> tags. Let’s start with the ﬁrst problem. In our SearchController, we need to add some code to actually perform the search. We’ll use our PageSearch service to do the search. In our index action, let’s add\n\nclass SearchController < ApplicationController\n\ndef index\n\n@pages = PageSearch.search(params)\n\nend\n\nend\n\n89\n\n90\n\n9 Sidebar Contents\n\nThen, in our associated view template search/index.html.erb, we can update our code to iterate over our @pages instance variable and render each page inside an <article> tag using our _page.html.erb partial:\n\n<% if @pages.any? %>\n\n<% @pages.each do |page| %>\n\n<%= render partial: 'shared/page',\n\nlocals: {\n\npage: page, content: page.summary\n\n} %>\n\n<% end %>\n\n<% else %>\n\n<p>No results found</p>\n\n<% end %>\n\nThis gets our failing spec to pass. There’s nothing too fancy there; we call any? on our @pages variable to check if there are any pages in the collection. The rest is just collection iteration and partial rendering.\n\nIf you’ve been following along closely with the code in this chapter, you’ll notice that we just\n\nadded a block of code that is very similar to a block of code that we added before:\n\n<% @pages.each do |page| %>\n\n<%= render partial: 'shared/page',\n\nlocals: {\n\npage: page, content: page.summary\n\n} %>\n\n<% end %>\n\nThis same block of code is used in our home/index.html.erb ﬁle too. We should factor this code out to make our app more DRY (don’t repeat yourself). Let’s create a new partial called shared/_pages.html.erb and move the code from our home/index.html.erb action into this new partial. We will leave it mostly the same except we will turn the @page instance variable into a local template variable called Page:\n\n<% pages.each do |page| %>\n\n<%= render partial: 'shared/page',\n\nlocals: {\n\npage: page, content: page.summary\n\n} %>\n\n<% end %>",
      "page_number": 83
    },
    {
      "number": 11,
      "title": "Segment 11 (pages 98-108)",
      "start_page": 98,
      "end_page": 108,
      "detection_method": "topic_boundary",
      "content": "Pages Archive\n\nNow we can use this new partial in both our home/index.html.erb and search/index. html.erb templates. Let’s clean things up by updating our home/index.html.erb template to use our new partial:\n\n<%= render partial: 'shared/pages', locals: { pages: @pages } %>\n\nAnd then let’s update our search/index.html.erb template to do the same:\n\n<% if @pages.any? %>\n\n<%= render partial: 'shared/pages', locals: { pages: @pages } %>\n\n<% else %>\n\n<p>No results found</p>\n\n<% end %>\n\nWe performed this refactor to make our app more DRY. We’re not repeating ourselves anymore. We’re using a partial to render a collection of pages in a single template ﬁle instead of repeating the same code in multiple places.\n\nWe also performed this refactor “under test,” so it was low risk, but we do need to now re-run our\n\nspecs to make sure they still pass:\n\nbe rspec spec/system/search_spec.rb spec/system/home_spec.rb\n\nIt looks like we didn’t break anything:\n\n...\n\nFinished in 2.51 seconds (files took 1.09 seconds to load) 3 examples, 0 failures\n\nPages Archive\n\nNow that we’ve got a working search feature for our pages, we can next pursue adding our archived pages feature. We’ll add our new Archives section below our search form in our sidebar. This section will display a list of month and year links that have pages in them. When a user clicks a month and year link, they will be taken to a page that displays all of the pages that were created in that month and year.\n\nWe will tackle this feature in three steps:\n\n1. Create a list of months and years that have pages in them 2. Create a search scope to search pages by month and year 3. Add a link to each month and year combination in our sidebar\n\n91\n\n92\n\n9 Sidebar Contents\n\nCreating a List of Months and Years\n\nWe’ll start by creating a list of months and years that have pages in them. We can do this by adding a new method to our Page model called .month_year_list. This method will return an array of hashes that contain month and year key/value pairs. We’ll use these values to create search engine–friendly links in our sidebar. Let’s add the following spec to our page_spec.rb ﬁle:\n\ndescribe '.month_year_list' do\n\nlet(:result) { Page.month_year_list }\n\nbefore do\n\ncreate(:page, created_at: Date.new(2022, 8, 10))\n\nend\n\nit 'returns month and year' do\n\nexpect(result[0]['month_name']).to eq('August') expect(result[0]['month_number']).to eq('08') expect(result[0]['year']).to eq('2022')\n\nend\n\nend\n\nWe will need the month_number and year values to create our search engine–friendly URLs. We will use the month_name and year values for the HTML display values of our URLs. The somewhat redundant month_name and month_number values are personal preference; feel free to use whatever month and year formats you like.\n\nAs expected, our spec fails:\n\n1) Page.month_year_list returns month and year\n\nFailure/Error: let(:result) { Page.month_year_list }\n\nNoMethodError:\n\nundefined method `month_year_list' for Page:Class\n\nLet’s add the .month_year_list method to our Page model:\n\ndef self.month_year_list end\n\nThis progresses our spec failure to the next error:\n\n1) Page.month_year_list returns month and year\n\nFailure/Error: expect(result[0]['month_name']).to eq('August')\n\nNoMethodError:\n\nundefined method `[]' for nil:NilClass\n\nPages Archive\n\nThis error is telling us that our result variable is nil and that we’re trying to access the ﬁrst element of a nil array. We need to return an array of hashes from our .month_year_list method. To extract the month name from our created_at timestamp, we can use SQL and some Postgres functions:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT\n\nTO_CHAR(created_at, 'Month') AS month_name\n\nFROM pages\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nThis SQL query uses PostgreSQL’s TO_CHAR function to extract the month name from our created_at timestamp ﬁeld. When we run our spec again, we get a somewhat annoying new error:\n\n1) Page.month_year_list returns month and year\n\nFailure/Error: expect(result[0]['month_name']).to eq('August')\n\nexpected: \"August\"\n\ngot: \"August\n\n\"\n\nThis error is telling us that our month_name value has some extra whitespace at the end of it. We can ﬁx this by using the PostgreSQL TRIM function:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT\n\nTRIM(TO_CHAR(created_at, 'Month')) AS month_name\n\nFROM pages\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nNow our ﬁrst expect statement passes, and we get a new error message for our second expect statement:\n\n1) Page.month_year_list returns month and year\n\nFailure/Error: expect(result[0]['month_number']).to eq('08')\n\nexpected: \"08\"\n\ngot: nil\n\n93\n\n94\n\n9 Sidebar Contents\n\nSo let’s add the month_number value to our SQL query:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT\n\nTRIM(TO_CHAR(created_at, 'Month')) AS month_name, TO_CHAR(created_at, 'MM') AS month_number\n\nFROM pages\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nWhen we re-run our spec, we can see this update moves us to the failure for our third expect statement:\n\n1) Page.month_year_list returns month and year\n\nFailure/Error: expect(result[0]['year']).to eq('2022')\n\nexpected: \"2022\"\n\ngot: nil\n\nWe can ﬁx this by adding the year value to our SQL query:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT\n\nTRIM(TO_CHAR(created_at, 'Month')) AS month_name, TO_CHAR(created_at, 'MM') AS month_number, TO_CHAR(created_at, 'YYYY') AS year\n\nFROM pages\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nWith this addition, our entire spec passes. Next, we need to consider the scenario where we have multiple pages that were created in the same month and year. We don’t want to have duplicate month and year values in our list. We can enhance our spec to add a page with the same month and year and then check to see that our list only contains one entry for that month and year:\n\ndescribe '.month_year_list' do\n\nlet(:result) { Page.month_year_list }\n\nbefore do\n\ncreate(:page, created_at: Date.new(2022, 8, 10)) create(:page, created_at: Date.new(2022, 8, 11))\n\nend\n\nPages Archive\n\nit 'returns a list of results' do expect(result.count).to eq(1)\n\nend\n\nit 'returns month and year' do\n\nexpect(result[0]['month_name']).to eq('August') expect(result[0]['month_number']).to eq('08') expect(result[0]['year']).to eq('2022')\n\nend\n\nend\n\nWhen we run our spec, we get the exact expected failure:\n\n1) Page.month_year_list returns a list of results Failure/Error: expect(result.count).to eq(1)\n\nexpected: 1 got: 2\n\nTo get our spec passing, we can add a DISTINCT modiﬁer to our SQL query. This will modify our results so that we only have one distinct entry for each month and year combination:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT DISTINCT\n\nTRIM(TO_CHAR(created_at, 'Month')) AS month_name, TO_CHAR(created_at, 'MM') AS month_number, TO_CHAR(created_at, 'YYYY') AS year\n\nFROM pages\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nWith this addition, our spec passes. The last thing we need to do is sort our results by year and month. Let’s modify our spec, including our previous “returns a list of results” spec, to test this as well:\n\ndescribe '.month_year_list' do\n\nlet(:result) { Page.month_year_list }\n\nbefore do\n\ncreate(:page, created_at: Date.new(2022, 8, 10)) create(:page, created_at: Date.new(2022, 8, 11)) create(:page, created_at: Date.new(2021, 3, 13))\n\nend\n\n95\n\n96\n\n9 Sidebar Contents\n\nit 'returns a list of results' do expect(result.count).to eq(2)\n\nend\n\nit 'returns month and year' do\n\nexpect(result[0]['month_name']).to eq('August') expect(result[0]['month_number']).to eq('08') expect(result[0]['year']).to eq('2022')\n\nexpect(result[1]['month_name']).to eq('March') expect(result[1]['month_number']).to eq('03') expect(result[1]['year']).to eq('2021')\n\nend\n\nend\n\nThis adds an earlier month and year combination and some more expect statements to test the ordering of the results.\n\nWhen we run our spec, we get the expected ordering failure; it’s not sorted by year and month yet;\n\ninstead, we’re getting the “natural” ordering based on how the data was stored in our database:\n\n1) Page.month_year_list returns month and year\n\nFailure/Error: expect(result[0]['month_name']).to eq('August')\n\nexpected: \"August\"\n\ngot: \"March\"\n\nTo ﬁx this, we can add an ORDER BY clause to our SQL query:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT DISTINCT\n\nTRIM(TO_CHAR(created_at, 'Month')) AS month_name, TO_CHAR(created_at, 'MM') AS month_number, TO_CHAR(created_at, 'YYYY') AS year\n\nFROM pages ORDER BY year DESC, month_number DESC\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nWe order by both the year and month number so that we get the most recent year ﬁrst and then the most recent month next when we have more than one month in a given year. With this addition, our spec passes.\n\nPages Archive\n\nAn archive list entry implies there will be published pages present for that month and year. The last consideration for our Page.month_year_list method is that we should ﬁlter out any pages that are not yet published. Let’s update our spec to include an unpublished page:\n\ndescribe '.month_year_list' do\n\nlet(:result) { Page.month_year_list }\n\nbefore do\n\ncreate(:page, created_at: Date.new(2022, 7, 4)) create(:page, :published, created_at: Date.new(2022, 8, 10)) create(:page, :published, created_at: Date.new(2022, 8, 11)) create(:page, :published, created_at: Date.new(2021, 3, 13))\n\nend\n\nit 'returns a list of results' do expect(result.count).to eq(2)\n\nend\n\nit 'returns month and year' do\n\nexpect(result[0]['month_name']).to eq('August') expect(result[0]['month_number']).to eq('08') expect(result[0]['year']).to eq('2022')\n\nexpect(result[1]['month_name']).to eq('March') expect(result[1]['month_number']).to eq('03') expect(result[1]['year']).to eq('2021')\n\nend\n\nend\n\nWhen we run our spec, we get the expected failure:\n\n1) Page.month_year_list returns a list of results Failure/Error: expect(result.count).to eq(2)\n\nexpected: 2 got: 3\n\nTo get our spec passing, we can add a WHERE clause to our SQL query to ﬁlter out any pages that are not yet published:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT DISTINCT\n\nTRIM(TO_CHAR(created_at, 'Month')) AS month_name, TO_CHAR(created_at, 'MM') AS month_number, TO_CHAR(created_at, 'YYYY') AS year\n\nFROM pages WHERE published = true\n\n97\n\n98\n\n9 Sidebar Contents\n\nORDER BY year DESC, month_number DESC\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nThis gets our spec passing.\n\nIt’s been a fun journey to develop our archive year and month list. It’s completely covered with specs, and we have a Ruby method wrapping our SQL query that we can use to get the data we need. We can now use this method to draw our archive list in our view.\n\nArchive List View\n\nIn the previous section, we developed a method to get a year/month aggregate list of all the pages in our database. Now we will use this method to draw our archive list in our view and show search results for a given month and year.\n\nBefore jumping right into coding our archive list display into our sidebar, we need to consider how it should be wired up. We already have a PageSearch service class that handles searching for pages by keyword. We could probably add a new method to this class to handle searching for pages by month and year without too much additional effort. In fact, we already use our PageSearch service class in our SearchController, so treating archive searching like regular searching seems like a good idea. Let’s work toward that goal. A good next step will be to add a spec to our page_search_spec.rb to test the searching by month and year:\n\nit 'valid year and month are sent to .by_year_month' do\n\nallow(Page).to receive(:by_year_month) PageSearch.search({ year: 2022, month: 8 }) expect(Page).to have_received(:by_year_month).with(2022, 8)\n\nend\n\nWhen we run our spec, we get the expected failure:\n\n1) PageSearch.search valid year and month are sent to .by_year_month Failure/Error: allow(Page).to receive(:by_year_month)\n\nPage(id: integer, user_id: integer ...) does not implement: by_year_month\n\nWe need to add a new method to our Page model to handle searching by year and month:\n\nscope :by_year_month, ->(year, month) do\n\n[]\n\nend\n\nPages Archive\n\nWhen we run our spec again, we get the expected failure:\n\n1) PageSearch.search valid year and month are sent to .by_year_month Failure/Error: expect(Page).to have_received(:by_year_month) ... Page(id: integer, user_id: integer ...)\n\nexpected: 1 time with arguments: (2022, 8) received: 0 times\n\nWe can ﬁx this failure by improving our parameter handling in our PageSearch.search method:\n\ndef self.search(params)\n\nreturn [] unless params.present?\n\nPage.by_term(params[:term]) if params[:term].present?\n\nif params[:year].present? && params[:month].present? Page.by_year_month(params[:year], params[:month])\n\nend\n\nend\n\nThat gets our spec passing. We now know we’re sending the correct parameters to our Page.by_year_month method. When we have a term parameter, we call our Page.by_term method, and when we have year and month parameters, we instead call our Page.by_year_month method.\n\nNext, we need to build out our Page.by_year_month scope method to actually return the pages for a given year and month. We’ll start by adding a spec to our page_spec.rb to test the Page.by_year_month method:\n\ndescribe '.by_year_month' do\n\nlet(:page1) { create(:page, created_at: Date.new(2022, 8, 10)) } let(:page2) { create(:page, created_at: Date.new(2021, 4, 13)) }\n\nbefore do\n\n[page1, page2]\n\nend\n\nit 'returns pages for the given year and month' do\n\nexpect(Page.by_year_month(2021, 4)).to match_array([page2])\n\nend\n\nend\n\nWhen we run our spec, we get the expected failure:\n\n1) Page scopes .by_year_month returns pages for the given year ... Failure/Error: expect(Page.by_year_month(2021, 4)).to match ...\n\n99\n\n100\n\n9 Sidebar Contents\n\nexpected collection contained: [#<Page id: 694, user_id: ...\n\nactual collection contained: []\n\nTo get this passing, we need to query our database for pages that match the given year and month. We can do this with a parameterized SQL query:\n\nscope :by_year_month, ->(year, month) do\n\nsql = <<~SQL\n\nextract(year from created_at) = ? AND extract(month from created_at) = ?\n\nSQL where(sql, year, month)\n\nend\n\nOur spec passes with this change. We now have a tested and working Page.by_year_month method.\n\nLet’s now go back to our PageSearch.search method and clean it up a bit. We’re passing our incoming params off to the correct scopes, but we’re not currently ordering our results nor are we ﬁltering results by our published status. We can easily ﬁx these issues with a few minor changes:\n\ndef self.search(params)\n\nreturn [] unless params.present?\n\npages = if params[:year].present? && params[:month].present?\n\nPage.by_year_month(params[:year], params[:month])\n\nelsif params[:term].present?\n\nPage.by_term(params[:term])\n\nend\n\nreturn [] unless pages\n\npages.published.ordered\n\nend\n\nAfter that, let’s ensure our specs in page_search_spec.rb are still passing:\n\nbe rspec spec/services/page_search_spec.rb\n\nPages Archive\n\nAnd we get the expected results:\n\n......\n\nFinished in 0.02775 seconds (files took 1.03 seconds to load) 6 examples, 0 failures\n\nArchive Integration Testing\n\nWith all that, we’re now ready to wrap up this chapter with a high-level system spec to test the archive list and search results when we click a month and year link. We’ll start by adding a new spec to our spec/system directory called archive_spec.rb:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Archives' do describe 'Results page' do\n\nbefore do\n\ncreate(:page, :published, created_at: '2022-08-10')\n\nend\n\nit 'renders archives search results' do\n\nvisit root_path click_on 'August 2022'\n\narticles = find_all('article') expect(articles.count).to eq(1)\n\nwithin articles.first do\n\nexpect(page).to have_css('h2', text: Page.first.title)\n\nend\n\nend\n\nend\n\nend\n\nNext, we’ll create a published page with a known creation date which will in turn give us a known archive entry for our sidebar. Then we’ll visit our root path and click our known-to-be-present August 2022 link. We’ll then expect to have our one article element on the page.\n\n101",
      "page_number": 98
    },
    {
      "number": 12,
      "title": "Segment 12 (pages 109-116)",
      "start_page": 109,
      "end_page": 116,
      "detection_method": "topic_boundary",
      "content": "102\n\n9 Sidebar Contents\n\nWhen we run our spec, we get the expected failure:\n\n1) Archives Results page renders archives search results Failure/Error: click_on 'August 2022'\n\nCapybara::ElementNotFound:\n\nUnable to find link or button \"August 2022\"\n\nThis error makes sense since we haven’t yet built out our archive sidebar HTML. Let’s do that now. Inside our shared/archives partial, let’s call our new Page.by_year_month method and iterate over each item to build out our archive HTML links in our sidebar:\n\n<div>\n\n<h4>Archives</h4> <ul>\n\n<% Page.month_year_list.each do |item| %>\n\n<li>\n\n<%= link_to\n\n\"#{item['month_name'] } #{item['year']}\", \"/search/#{item['year']}/#{item['month_number']}\" %>\n\n</li> <% end %>\n\n</ul>\n\n</div>\n\nThis will give us a list of links for each month and year that we have pages for, but when we run our spec, we get the following error:\n\n1) Archives Results page renders archives search results Failure/Error: raise ActionController::RoutingError ...\n\nActionController::RoutingError:\n\nNo route matches [GET] \"/search/2022/08\"\n\nLooks like a missing route error. To ﬁx this failure, we need to add a route for our archive link to our config/routes.rb ﬁle:\n\nget 'search/:year/:month', to: 'search#index', year: /\\d{4}/, month: /\\d{2}/\n\nSummary\n\nWe use some simple regular expressions to ensure that the year and month are four and two digits, respectively. We do not need to add a controller action for this route since we’re already using the SearchController#index action for our search results. When we run our spec again, we see that it passes now.\n\nSummary\n\nIn this chapter, we dug into “Search as a Service” and built out our search form and our archive list in our sidebar. Our sidebar content will appear on every page and will help our site visitors ﬁnd the content they’re looking for more easily.\n\nWe also showed how to make custom Rails routes that will allow us to have beautiful URLs, instead of ugly ones containing query parameters. Search engines prefer these types of URLs, and they’re also easier for our users to remember and share.\n\n103\n\nPage Tags\n\n10\n\nIn our previous chapter, we built out features for our Page objects. We added a way to search for pages by keyword and a way to look up archives of pages. We did this through a “search service,” which aided in separating our controller logic from our model logic.\n\nIn this chapter, we’ll add other features to our pages. We’ll add the ability to create and tag pages\n\nto categorize them.\n\nAdding Page Tags\n\nFirst, we want to add the ability to add tags to our Page records. Tags are a way to categorize our pages. Instead of using a gem such as acts-as-taggable-on, we’re going to implement our own tagging system. This will give us a better understanding of how tagging systems work and how they can be implemented and customized.\n\nCreating the Tag Model\n\nLet’s use a Rails generator to create a Tag model:\n\nbe rails g model tag \\\n\nname:string:uniq \\ page_tags_count:integer:index\n\nThis will create several ﬁles for us:\n\ninvoke active_record create create invoke create\n\ndb/migrate/20230108193644_create_tags.rb app/models/tag.rb rspec\n\nspec/models/tag_spec.rb\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_10\n\n105\n\n106\n\n10 Page Tags\n\ninvoke create\n\nfactory_bot\n\nspec/factories/tags.rb\n\nWe’re using the uniq option to make sure that our tag names are unique; having duplicates serves no purpose. We’re also adding a page_tags_count column which will allow us to keep track of how many Page records are associated with a given tag. We’ll use this to determine if a tag can be deleted or not, and it also has the nice side effect of allowing us to sort tags by popularity and not having to count them each time we want to sort them.\n\nLet’s run our migrations:\n\nbe rails db:migrate be rails db:migrate RAILS_ENV=test\n\nLet’s ﬁrst update our Tag factory to use a sequence to generate a unique name for each tag:\n\nFactoryBot.define do factory :tag do\n\nsequence(:name) { |n| \"Name #{n} \" }\n\nend\n\nend\n\nNext, let’s update our generated tag_spec.rb ﬁle to add some validation tests:\n\nrequire 'rails_helper'\n\nRSpec.describe Tag, type: :model do\n\nsubject { build(:tag) }\n\nit { is_expected.to validate_presence_of(:name) } it { is_expected.to validate_uniqueness_of(:name) }\n\nend\n\nRunning our spec, we can see that it fails as expected:\n\n1) Tag is expected to validate that :name cannot be empty/falsy Failure/Error: it { is_expected.to validate_presence_of(:name) }\n\nExpected Tag to validate that :name cannot be empty/falsy, but this could not be proved.\n\nAdding Page Tags\n\nWe can ﬁx this failure by adding a :name validation to our Tag model:\n\nvalidates :name, presence: true\n\nRunning our spec again, we can see that it fails in a new way:\n\n1) Tag is expected to validate that :name is case-sensitively unique Failure/Error: it { is_expected.to validate_uniqueness_of(:name) }\n\nExpected Tag to validate that :name is case-sensitively unique, but this could not be proved.\n\nWe can ﬁx this failure by adding a :name uniqueness validation:\n\nvalidates :name, presence: true, uniqueness: true\n\nOur Tag spec should now pass.\n\nCreating the Page Tag Model\n\nNext, we need to create a “join model ” to allow us to associate a Tag to a Page. We’ll again use a Rails generator to create this model:\n\nbe rails g model page_tag \\\n\npage:references \\ tag:references\n\nBefore we run our CreatePageTags migration, we need to update it to add a unique index to our page_id and tag_id columns. This will make sure that we won’t ever have any duplicate PageTag records. Let’s add this line after the end of our create_table block:\n\nadd_index :page_tags, %i[page_id tag_id], unique: true\n\nWith that added, now let’s run our migration:\n\nbe rails db:migrate be rails db:migrate RAILS_ENV=test\n\n107\n\n108\n\n10 Page Tags\n\nNow that we have our page_tags table created in our database, let’s update our page_tags factory to be more useful:\n\nFactoryBot.define do\n\nfactory :page_tag do\n\npage { create(:page) } tag { create(:tag) }\n\nend\n\nend\n\nAfter that, we can next focus on our page_tag_spec.rb ﬁle. We’ll start by adding some validation tests:\n\nrequire 'rails_helper'\n\nRSpec.describe PageTag, type: :model do\n\nsubject { create(:page_tag) }\n\nit { is_expected.to belong_to(:page) } it { is_expected.to belong_to(:tag) }\n\nend\n\nRunning our spec, we can see that it passes. This is because we generated our PageTag model using :references for our Page and Tag columns. This automatically added our belongs_to associations for us.\n\nWe do need to add an extra bit of code to enable our page_tags_count column to be updated\n\nautomatically when we create or destroy PageTag records, but ﬁrst the spec:\n\nit { is_expected.to belong_to(:tag).counter_cache }\n\nThen, once we see it fail:\n\nFailures:\n\n1) PageTag is expected to belong to tag required: true\n\ncounter_cache => true Failure/Error: it { is_expected.to belong_to(:tag).counter_cache }\n\nExpected PageTag to have a belongs_to association called tag (tag should have counter_cache => true)\n\nAdding Page Tags\n\nWe can ﬁx this failure by adding the counter_cache option to our belongs_to:\n\nbelongs_to :tag, counter_cache: true\n\nLet’s now prevent our database from raising an error if we try to create a duplicate PageTag record. We can do this by adding a validation spec:\n\nit { is_expected\n\n.to validate_uniqueness_of(:tag_id) .scoped_to(:page_id) }\n\nThis one actually fails as we might have expected:\n\n1) PageTag is expected to validate that :tag_id is case-sensitively unique within the scope of :page_id\n\nFailure/Error: is_expected.to validate_uniqueness_of(:tag_id)\n\n.scoped_to(:page_id)\n\nExpected PageTag to validate that :tag_id is case-sensitively unique within the scope of :page_id, but this could not be proved.\n\nWe can ﬁx this by adding a validation to our PageTag model:\n\nvalidates :tag_id, uniqueness: { scope: :page_id }\n\nThat should do it for our PageTag model. It’s a pretty simple model, but it’s important to get it right as it’s the glue model that will allow us to associate Tag records to Page records.\n\nJumping Over Relationships\n\nOne of the most useful features in Rails is the ability to jump over relationships using a has_many :through association. This association allows us to create a has_many relationship on a model and then use that relationship to create another has_many relationship on a related model. In our case, we want to be able to jump from an instance of a Page to its related Tags, or from a Tag to its related Pages.\n\nIn other words, we want to be able to do things like this:\n\nPage.last.tags.each do |tag|\n\nputs tag.name\n\nend\n\n109\n\n110\n\n10 Page Tags\n\nor this:\n\nTag.last.pages.each do |page|\n\nputs page.title\n\nend\n\nWe basically want to be able to ignore our PageTag join model. Let’s add some new specs to our page_spec.rb ﬁle to test this behavior:\n\nit { is_expected.to have_many(:page_tags).dependent(:destroy) } it { is_expected.to have_many(:tags).through(:page_tags) }\n\nRunning our specs, we can see that they both fail:\n\n1) Page is expected to have many page_tags dependent => destroy Failure/Error: it { is_expected.to have_many(:page_tags) ... Expected Page to have a has_many association called page_tags (no association called page_tags)\n\n2) Page is expected to have many tags through page_tags Failure/Error: it { is_expected.to have_many(:tags) ...\n\nExpected Page to have a has_many association called tags (no association called tags)\n\nGetting these specs to pass is simple. We just need to add our has_many associations to our Page model:\n\nhas_many :page_tags, dependent: :destroy has_many :tags, through: :page_tags\n\nNow we can add similar specs to our tag_spec.rb ﬁle:\n\nit { is_expected.to have_many(:page_tags).dependent(:destroy) } it { is_expected.to have_many(:pages).through(:page_tags) }\n\nRunning our specs, we can see that they both fail:\n\n1) Tag is expected to have many page_tags dependent => destroy Failure/Error: it { is_expected.to have_many(:page_tags) ... Expected Tag to have a has_many association called page_tags",
      "page_number": 109
    },
    {
      "number": 13,
      "title": "Segment 13 (pages 117-125)",
      "start_page": 117,
      "end_page": 125,
      "detection_method": "topic_boundary",
      "content": "Tagging Pages\n\n(no association called page_tags)\n\n2) Tag is expected to have many pages through page_tags Failure/Error: it { is_expected.to have_many(:pages) ...\n\nExpected Tag to have a has_many association called pages (no association called pages)\n\nAgain, getting these sorts of specs to pass is easy. We just need to add our has_many associations to our Tag model:\n\nhas_many :page_tags, dependent: :destroy has_many :pages, through: :page_tags\n\nWe can now very easily jump across our relationships and ignore our PageTag join model.\n\nTagging Pages\n\nNow that we have our PageTag model and our has_many :through associations neatly deﬁned and tested, we can start working on our tagging feature itself. We want to be able to pass a comma- separated list of Tag names to our Page model and have it create the appropriate PageTag records for us. We need it to handle the case where a Tag already exists, as well as the case where it does not.\n\nAfter Save Callbacks\n\nWe’ll call our new comma-separated list of Tag names a “tags_string.” We can process it when we save an instance of a Page. Let’s capture this idea by adding a new spec to our page_spec.rb ﬁle:\n\ndescribe '#update_tags' do\n\nlet(:page) { create(:page, tags_string: 'foo, bar') }\n\ncontext 'when tags do not already exist' do\n\nit 'creates new tags' do\n\nexpect { page }.to change(Tag, :count).by(2) expect(page.tags.map(&:name)).to match_array(%w[foo bar])\n\nend\n\nend\n\nend\n\n111\n\n112\n\n10 Page Tags\n\nRunning our new spec, we can see that it fails:\n\n1) Page#update_tags when tags do not already exist creates new tags Failure: let(:page) { create(:page, tags_string: 'foo, bar') }\n\nNoMethodError:\n\nundefined method `tags_string=' for #<Page id: nil, user_id: ...\n\nThe failure message is telling us that we need to add a tags_string attribute to our Page model. We can do that by adding the following to our Page model:\n\nattr_accessor :tags_string\n\nAn attr_accessor is a special type of Ruby method that allows us to read and write to a named instance variable. In our case, we’re creating a new instance variable named tags_string that we can use to store a comma-separated list of Tag names, each of which we want to assign to our Page object. We don’t actually want to store our tags_string value in our database, but we do need it to be accessible inside our Page model for a period of time. We can use an attr_accessor to do exactly that.\n\nThis change moves us on to our next failure message:\n\n1) Page#update_tags when tags do not already exist creates new tags Failure/Error: expect { page }.to change(Tag, :count).by(2)\n\nexpected `Tag.count` to have changed by 2, but was changed by 0\n\nWe need to add a way for our Page model to handle the updating of new Tag records after we save an instance of a Page object. We can do that by using a Rails after_save callback:\n\nafter_save :update_tags\n\nprivate\n\ndef update_tags\n\nreturn if tags_string.blank?\n\ntags_string.split(',').each do |name|\n\nname = name\n\n.downcase .gsub(/[_ ]/, '-') .gsub(/[^-a-z0-9+]/, '') .gsub(/-{2,}/, '-') .gsub(/^-/, '') .chomp('-')\n\ntags << Tag.find_or_create_by(name:)\n\nTagging Pages\n\nend\n\nend\n\nEvery time we save a Page instance, our update_tags method will be called. It will return early if our tags_string is blank; otherwise, it will split our tags_string into an array of names and then iterate over the array. For each name, we clean it up, just like how we previously cleaned up our title ﬁeld to make our slug ﬁeld. We then ﬁnd or create a new Tag record with that name. Finally, we ﬁnd or create a PageTag record, connecting our Page to that Tag.\n\nBut what about the case where we remove a Tag from our tags_string? We need to also remove the corresponding PageTag record. We need to add a spec to our page_spec.rb ﬁle to make sure we always remove any tags not in our tags_string when our callback is called. Inside our existing “#update_tags” describe block, let’s add the following:\n\ncontext 'when tags are removed' do\n\nlet(:tag_names) { page.tags.map(&:name) }\n\nbefore { page }\n\nit 'removes tags' do\n\npage.update(tags_string: 'foo') expect(tag_names).to match_array(%w[foo])\n\nend\n\nend\n\nWe add a before block to our spec to make sure we have a persisted Page instance with the two known Tag records from our previous spec. Then we update our Page object with a new tags_string and expect one of the tags to be removed. Running this spec, we can see that it fails:\n\n1) Page#update_tags when tags are removed removes tags Failure/Error: expect(tag_names).to match_array(%w[foo])\n\nexpected collection contained: [\"foo\"] actual collection contained: the extra elements were:\n\n[\"bar\", \"foo\"] [\"bar\"]\n\nTo get this passing, we need to clear out all of our PageTag records via our has_many :tags association before we create new ones. Let’s update our update_tags method to do that:\n\ndef update_tags\n\nself.tags = [] return if tags_string.blank?\n\ntags_string.split(',').each do |name|\n\nname = name\n\n113\n\n114\n\n10 Page Tags\n\n.downcase .gsub(/[_ ]/, '-') .gsub(/[^-a-z0-9+]/, '') .gsub(/-{2,}/, '-') .gsub(/^-/, '') .chomp('-')\n\ntags << Tag.find_or_create_by(name:)\n\nend\n\nend\n\nAdmittedly, adding self.tags = [] is a quick and dirty solution. In the future, when our blog is massively popular and we have written millions of PageTag records into our database, and we need to optimize this code, we can cherry-pick exactly the records that we want to destroy by iterating through them and then only destroying those. But for now, this will work just ﬁne.\n\nDisplay Tags on Pages\n\nNow that we can create Tag records when we save a Page, we want to display them as Tag name links. When we click a link, we want to see a list of all the Page records that are associated with that particular Tag. So the ﬁrst thing to do is to create a helper method to display our Tag records as links. Let’s make a helper spec to capture this idea. In our spec/helpers directory, let’s create a new tags_helper_spec.rb ﬁle with the following contents:\n\nrequire 'rails_helper'\n\nRSpec.describe TagsHelper, type: :helper do\n\ndescribe '#tag_links' do\n\nlet(:page) { create(:page, tags_string: 'foo, bar') } let(:result) { helper.tag_links(page.tags) }\n\nit 'returns a list of tag links' do\n\nexpected = <<~HTML.squish\n\n<a href=\"/tags/bar\">bar (1)</a> <a href=\"/tags/foo\">foo (1)</a>\n\nHTML expect(result).to eq(expected)\n\nend\n\nend\n\nend\n\nThis spec will drive out a lot of the functionality we want. We’ll pass in a Tag collection and get back a list of links. We’ll also want to see the number of Page records associated with each Tag, and we’ll want to see the Tag names in alphabetical order.\n\nTagging Pages\n\nLet’s run our spec and see what happens:\n\nNameError:\n\nuninitialized constant TagsHelper\n\nThis is telling us that we need to create our TagsHelper module. So let’s do that. In our app/helpers directory, let’s create a new ﬁle called tags_helper.rb with the following contents:\n\nmodule TagsHelper end\n\nNow let’s run our spec again:\n\nNoMethodError: undefined method `tag_links'\n\nlet(:result) { helper.tag_links(page.tags) }\n\nOur next failure message is telling us that we need to add our tag_links method to our TagsHelper module. Let’s do that:\n\nmodule TagsHelper\n\ndef tag_links(tags) end\n\nend\n\nNow let’s run our spec again:\n\nFailure/Error: expect(result).to eq(expected)\n\nexpected: \"<a href=\\\"/tags/bar\\\">bar (1)</a> <a ... \"\n\ngot: nil\n\nWe’re getting closer. Our spec is now failing because we’re not returning the correct value, our new tag links. Let’s ﬁx that:\n\nmodule TagsHelper\n\ndef tag_links(tags) tags.map do |tag|\n\n115\n\n116\n\n10 Page Tags\n\nlink_to \"#{tag.name} (#{tag.page_tags_count})\",\n\ntag_path(tag.name)\n\nend.join(' ')\n\nend\n\nend\n\nWe iterate over our tags array and create a link for each one. Now our spec failure message is telling us that we have not yet deﬁned a tag_path route:\n\nNoMethodError:\n\nundefined method `tag_path'\n\nLet’s add our new route to our config/routes.rb ﬁle:\n\nget 'tags/:name', to: 'tags#show', name: /[-a-z0-9_+]*/, as: :tag\n\nNow let’s run our spec again:\n\n1) TagsHelper#tag_links returns a list of tag links Failure/Error: expect(result).to eq(expected)\n\nexpected: \"<a href=\\\"/tags/bar\\\">bar (1)</a> <a ... got: \"<a href=\\\"/tags/foo\\\">foo (1)</a> <a ...\n\nWe’re now getting links, but they are in the wrong order. We want them to be in alphabetical order. This is easy; we can add a scope to our Tag model to sort by name:\n\nscope :ordered, -> { order(:name) }\n\nThen we update our spec to use this new scope:\n\nlet(:result) { helper.tag_links(page.tags.ordered) }\n\nThis gets our spec to pass.\n\nI will pause here to mention that we could have made the choice to use a default_scope . Some software engineers (myself included) consider it to be potentially dangerous as it can be difﬁcult to override and can lead to unexpected behavior when doing complex table joins.\n\nTagging Pages\n\nWe can now proceed with using our new TagsHelper#tag_links method in our views. We’ll start by adding a new system spec to capture this usage. In our spec/system directory, we’ll create a new tag_spec.rb ﬁle with the following contents:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Tag', type: :system do\n\nlet(:page_1) { create(:page, :published, tags_string: 'foo, bar') } let(:page_2) { create(:page, :published, tags_string: 'bar') }\n\nbefore do\n\n[page_1, page_2]\n\nend\n\nit 'displays clickable tags on a page' do\n\nvisit root_path\n\nfind_link(href: '/tags/foo').click expect(page).to have_content(page_1.title) expect(page).to_not have_content(page_2.title)\n\nfind_link(href: '/tags/bar', match: :first).click expect(page).to have_content(page_1.title) expect(page).to have_content(page_2.title)\n\nend\n\nend\n\nWhen we run this spec, we’ll see that it fails:\n\n1) Tag displays clickable tags on a page\n\nFailure/Error: find_link(href: '/tags/foo').click\n\nCapybara::ElementNotFound:\n\nUnable to find link nil with href \"/tags/foo\"\n\nWe need to add a call to our new tag_links method in our _page.html.erb partial that will cause our tag links to appear at the bottom of each page or page summary. Let’s add that:\n\n<p><%= tag_links(page.tags).html_safe %></p>\n\nRunning our spec again, we can see a new failure message:\n\nActionController::RoutingError:\n\nuninitialized constant TagsController\n\n117\n\n118\n\n10 Page Tags\n\nWe could use a Rails generator here to create our missing TagsController, but it’s not a lot of effort to step through it manually. Let’s create our new tags_controller.rb ﬁle in our app/controllers directory:\n\nclass TagsController < ApplicationController end\n\nRunning our spec again, we can see a new failure message:\n\nAbstractController::ActionNotFound:\n\nThe action 'show' could not be found for TagsController\n\nLet’s do as the error message suggests and create a show action in our tags_controller.rb ﬁle:\n\nclass TagsController < ApplicationController\n\ndef show end\n\nend\n\nRunning our spec again, we can see a new failure message:\n\nActionController::MissingExactTemplate:\n\nTagsController#show is missing a template for request formats: text/html\n\nAgain, letting the failure message guide us, let’s create the directory app/views/tags and then create a new show.html.erb ﬁle inside it.\n\nOnce we’ve done that, we can run our spec again and see the next failure message:\n\n1) Tag displays clickable tags on a page\n\nFailure/Error: expect(page).to have_content(page_1.title)\n\nexpected to find text \"Page Title ...\"\n\nThis failure message occurs after we visit our root_path and click a tag. We can see that the show action is being called, but we’re not seeing any pages. This is because we haven’t yet implemented\n\nTagging Pages\n\nthe logic to ﬁnd the pages that have the tag we clicked. Let’s do that by adding the following to our show action in our tags_controller.rb ﬁle:\n\ndef show\n\ntag = Tag.find_by(name: params[:name]) @pages = tag.pages.published.ordered\n\nend\n\nWe also need to actually render our @pages in our show.html.erb ﬁle. We can do that by adding the following to our show.html.erb ﬁle, reusing our _pages.html.erb partial:\n\n<%= render partial: 'shared/pages', locals: { pages: @pages } %>\n\nWith those changes in place, we can run our spec again and see that it passes.\n\nHandling Missing Tags\n\nWe’ve now implemented the ability to click a tag and see the pages that have that tag. But what happens if we try to visit a tag that doesn’t exist? Let’s add a spec to capture this behavior. In the same system spec we’ve been working in, tag_spec.rb, we’ll add the following new spec:\n\ncontext 'when a tag does not exist' do it 'redirects to the root path' do\n\nvisit '/tags/does-not-exist' expect(page).to have_current_path(root_path)\n\nend\n\nend\n\nHonestly, this spec could just as easily exist as a request spec, but we’re going to keep it in our system spec for now since we already have a very similar tag spec. When we run this spec, we’ll see that it fails with the following error:\n\n1) Tag when a tag does not exist redirects to the root path Failure/Error: @pages = tag.pages.published.ordered\n\nNoMethodError:\n\nundefined method `pages' for nil:NilClass\n\n119",
      "page_number": 117
    },
    {
      "number": 14,
      "title": "Segment 14 (pages 126-139)",
      "start_page": 126,
      "end_page": 139,
      "detection_method": "topic_boundary",
      "content": "120\n\n10 Page Tags\n\nWe need to handle the case where the tag is not found. Let’s do that by adding a redirect to our root_path in our show action:\n\ndef show\n\ntag = Tag.find_by(name: params[:name]) redirect_to root_path and return unless tag\n\n@pages = tag.pages.published.ordered\n\nend\n\nWith that change in place, we can run our spec again and see that it passes. We redirect and return early to prevent the rest of the show action from being executed, if a tag is not found.\n\nRefactor Duplicate Code\n\nWe’ve made a lot of progress with page tagging, but along the way we’ve created some duplication in our code. Let’s clean that up. We currently have two places in our code where we are cleaning up a string using the same duplicated cleanup code:\n\n.downcase\n\n.gsub(/[_ ]/, '-') .gsub(/[^-a-z0-9+]/, '') .gsub(/-{2,}/, '-') .gsub(/^-/, '') .chomp('-')\n\nLet’s refactor this into a separate Ruby module and remove the duplication. In our spec/models\n\ndirectory, we’ll create a new name_cleanup_spec.rb ﬁle with the following contents:\n\nrequire 'rails_helper'\n\nRSpec.describe NameCleanup do\n\nlet(:name) { ' - -Foo Bar! _ 87 -- ' }\n\ndescribe '.clean' do\n\nit 'cleans a name' do\n\nexpect(NameCleanup.clean(name)).to eq('foo-bar-87')\n\nend\n\nend\n\nend\n\nTagging Pages\n\nRunning our new spec gives us an expected failure message:\n\nNameError:\n\nuninitialized constant NameCleanup\n\nLet’s create our NameCleanup module. In our app/models directory, let’s create a new ﬁle named name_cleanup.rb with the following contents:\n\nmodule NameCleanup end\n\nThis addition moves us to the next failure:\n\n1) NameCleanup.clean cleans a name\n\nFailure/Error: expect(NameCleanup.clean(name)).to eq('foo-bar-87')\n\nNoMethodError:\n\nundefined method `clean' for NameCleanup:Class\n\nWe can ﬁx this by adding our clean method to our NameCleanup module and using our cleanup code in it:\n\nmodule NameCleanup\n\ndef self.clean(name)\n\nname\n\n.downcase .gsub(/[_ ]/, '-') .gsub(/[^-a-z0-9+]/, '') .gsub(/-{2,}/, '-') .gsub(/^-/, '') .chomp('-')\n\nend\n\nend\n\nThis gets our spec to pass.\n\nNow we can go back to our Page model and use our new NameCleanup module to clean up our\n\nmake_slug method:\n\ndef make_slug\n\nreturn unless title\n\nself.slug = NameCleanup.clean(title)\n\nend\n\n121\n\n122\n\n10 Page Tags\n\nand then also our update_tags method:\n\ndef update_tags\n\nself.tags = [] return if tags_string.blank?\n\ntags_string.split(',').each do |name|\n\nname = NameCleanup.clean(name)\n\ntags << Tag.find_or_create_by(name:)\n\nend\n\nend\n\nAnother option to refactor this code might have been to create a local private method instead of our NameCleanup module. But testing it as a private method would have required us to test it through each of its callers, with lots of additional test setup, or by calling it indirectly using Ruby’s send method. I think the module approach is a much better option in this case.\n\nAfter this refactor, our Page model is looking much better. Let’s be sure to re-run our\n\npage_spec.rb spec to make sure we didn’t break anything.\n\nSummary\n\nIn this chapter, we’ve added the ability to tag pages and view pages by tag. We also refactored some of our code to remove duplication. In our next chapter, we’ll begin pursuing our image storage feature.\n\nImages\n\nIn this chapter, we will add the ability to store image ﬁles for display in our blog posts. We will leverage the Active Storage gem to provide much of the functionality while working within our own image controller to serve up the image data and to handle missing images.\n\nActive Storage for Images\n\nRails version 5.2 introduced a new feature called Active Storage that provides ﬁle storage function- ality. Active Storage allows us to upload ﬁles to our Rails application, storing the ﬁle binary data as well as metadata, making it the current best way to add images to our blog. I say “current best way” because there are many other ways to add images to our blog, but Active Storage is the easiest and most integrated way to do it, given we’re already using Rails.\n\nGetting Started with Active Storage\n\nActive Storage will need us to create three new tables in our database:\n\n1. active_storage_blobs 2. active_storage_variant_records 3. active_storage_attachments\n\nFortunately, we don’t need to know much about them with Rails having a generator command to create our database migrations for us:\n\nbe rails active_storage:install\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_11\n\n11\n\n123\n\n124\n\n11 Images\n\nLet’s run that command and then migrate our database:\n\nbe rails db:migrate be rails db:migrate RAILS_ENV=test\n\nNext, we need to inform Active Storage how we would like to store our ﬁles. We can do this by adding two conﬁgurations to our config/storage.yml ﬁle, one for our test environment and one for our development environment:\n\ntest:\n\nservice: Disk root: <%= Rails.root.join(\"tmp/storage\") %>\n\nlocal:\n\nservice: Disk root: <%= Rails.root.join(\"storage\") %>\n\nIt’s likely these conﬁgurations will already exist in your own Rails application code, but please do check to make sure.\n\nWe will cover adding a production environment conﬁguration for storage in a later chapter. For now, we’ll just need to conﬁgure our development and test environments, and we’ll use the Disk service for both.\n\nTwo more storage conﬁgurations that may also already exist in your own Rails application code\n\nare in the config/environments directory, the development.rb and the test.rb ﬁles.\n\nInside of development.rb, we need to ensure the following line is present:\n\nconfig.active_storage.service = :local\n\nAnd inside of test.rb, we need to similarly ensure a similar line exists:\n\nconfig.active_storage.service = :test\n\nThe point of these two lines is to tell Active Storage which service, from the services deﬁned in our storage.yml, to use for each environment.\n\nThat’s all we need to do to conﬁgure our Active Storage setup for local development and test usage.\n\nAdding an Image Model\n\nTo actually begin to use Active Storage, we need to create a Rails ActiveRecord model that will represent our image record. This model will be simple, having only a name ﬁeld. We’ll then use Active Storage to attach image data to this model.\n\nActive Storage for Images\n\nLet’s create our model with the following command:\n\nbe rails g model Image name:string\n\nThen we’ll migrate our database:\n\nbe rails db:migrate be rails db:migrate RAILS_ENV=test\n\nWe want to make sure instances of our Image always have a name present, so let’s add a validation spec to our spec/models/image_spec.rb ﬁle:\n\ndescribe 'validations' do\n\nit { should validate_presence_of(:name) }\n\nend\n\nThis spec will fail because we haven’t added the validation to our Image model yet:\n\n1) Image validations is expected to validate that :name cannot be empty/falsy Failure/Error: it { should validate_presence_of(:name) }\n\nExpected Image to validate that :name cannot be empty/falsy, but this could not be proved.\n\nLet’s add the validation to our model:\n\nvalidates :name, presence: true\n\nThis spec should now pass. Next, let’s make sure we have a valid Image factory to use in future specs we will write. Let’s add the following to our spec/models/image_spec.rb ﬁle:\n\ndescribe 'has a valid factory' do\n\nit { expect(build(:image)).to be_valid }\n\nend\n\nThe point of this sort of test is to ensure our Image factory, with no traits applied, is always working. I consider this a good habit to get into since RSpec’s subject does this implicitly, as well as other factory associations.\n\n125\n\n126\n\n11 Images\n\nRunning our spec, we can see that it passes. Now let’s update our Image factory to give it a name\n\nand attach image data:\n\nFactoryBot.define do factory :image do name { 'Name' }\n\nafter(:build) do |image|\n\nio = Rails.root.join('spec/factories/images/image.jpeg').open image.image.attach(io: io,\n\nfilename: 'image.jpeg', content_type: 'image/jpeg')\n\nend\n\nend\n\nend\n\nThe code image.image.attach means that we want our image model to have an image ﬁeld that we can attach data to. The io variable is a ﬁle handle to a ﬁle named image.jpeg.\n\nRunning our spec again, we can see that it now fails:\n\n1) Image has a valid factory\n\nFailure/Error: io = Rails.root.join('spec/factories/images/ ...\n\nErrno::ENOENT:\n\nNo such file or directory @ rb_sysopen - ... image.jpeg\n\nThis error message informs us that we need to provide an image.jpeg ﬁle. Let’s create a directory for our image ﬁles:\n\nmkdir spec/factories/images\n\nAnd then I’ll leave it up to you to ﬁnd an image ﬁle to use for this spec. Any old jpeg ﬁle will work; just be sure to name it “image.jpeg” and place it in the spec/factories/images directory that we just created.\n\nAssuming you’ve successfully provided an image ﬁle, we can now run our spec again, and it will\n\nfail with a different error:\n\n1) Image has a valid factory Failure/Error:\n\nimage.image.attach(io: io,\n\nfilename: 'image.jpeg', content_type: 'image/jpeg')\n\nNoMethodError:\n\nServing Images\n\nundefined method `image' for #<Image id: nil, name: \"Name\", created_at: nil, updated_at: nil>\n\nNow we can add the Active Storage attachment code to our model. We’ll do this by adding the following to our app/models/image.rb ﬁle:\n\nhas_one_attached :image\n\nhas_one_attached is an Active Storage helper method that will provide instances of our model with an :image ﬁeld to which we can attach image data. We could of course call our :image ﬁeld something else if we wanted to, perhaps :photo, but we’ll stick with :image.\n\nRunning our spec again, we can see that it now passes. We could add more validations to our Image model, but for now we’ll leave it as is. In particular, you might question why we do not have a validation for image data being present. For this, we’re trusting in the Active Storage gem to do the right thing and to have adequate test coverage in place within its own codebase.\n\nServing Images\n\nWe have our images stored in our database, and so we now need a way to serve them up to our site visitors. We’ll do this by creating a controller that will serve up image data from Active Storage.\n\nAdding an Image Controller\n\nA blog wouldn’t be complete without the ability to display images in the page content here and there. So we’ll need an ImagesController with a show action to serve up image data.\n\nAs you might expect, we’ll ﬁrst write a spec for it, a request spec to be exact. Inside our spec/requests directory, let’s add a new ﬁle called images_spec.rb and add the following to it:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Images' do it 'returns an image' do\n\ncreate(:image) get image_path(Image.last)\n\nexpect(response).to be_successful expect(response.content_type).to eq('image/jpeg')\n\nend\n\nend\n\nIn this spec, we create an image record using our new image factory and then make a GET request to our show action in our ImagesController. We then assert that the response is successful and\n\n127\n\n128\n\n11 Images\n\nthat the content type is image/jpeg. This spec will fail in various ways as we work through the implementation of our controller action. Let’s see what the ﬁrst failure message looks like:\n\nbe rspec spec/requests/images_spec.rb\n\nRSpec tells us that we have an undeﬁned method, a Rails route to be speciﬁc:\n\n1) Images returns an image\n\nFailure/Error: get image_path(Image.last)\n\nNoMethodError:\n\nundefined method `image_path' ...\n\nSo let’s add a route to our config/routes.rb ﬁle:\n\nresources :images, only: :show\n\nWe’re adding a standard REST “resources” route, but we only want to make the show action available. We can see what that gives us by running the rails routes command with the -g (grep) option to ﬁlter the output:\n\nbe rails routes -g images\n\nWe can see that Rails has created just the one show route for us:\n\nPrefix Verb URI Pattern image GET /images/:id(.:format) images#show\n\nController#Action\n\nRunning our spec again, we can see that we now have a different error:\n\n1) Images returns an image\n\nFailure/Error: get image_path(Image.last)\n\nActionController::RoutingError:\n\nuninitialized constant ImagesController\n\nServing Images\n\nLooks like it’s time to create our image controller. We could use the following command to create it, but we won’t because it will create a bunch of extra ﬁles that we don’t need:\n\n# be rails g controller images show\n\nInstead, let’s create the controller ﬁle manually. Let’s add a new ﬁle to our app/controllers directory called images_controller.rb and then add the following to it:\n\nclass ImagesController < ApplicationController end\n\nRunning our spec again, we can see that we now have a different error:\n\n1) Images returns an image\n\nFailure/Error: get image_path(Image.last)\n\nAbstractController::ActionNotFound:\n\nThe action 'show' could not be found for ImagesController\n\nRSpec is telling us that it’s now time to create a show action in our controller. Let’s do that:\n\nclass ImagesController < ApplicationController\n\ndef show end\n\nend\n\nRunning our spec again, we see that we now have a different error:\n\n1) Images returns an image\n\nFailure/Error: get image_path(Image.last)\n\nActionController::MissingExactTemplate:\n\nImagesController#show is missing a template for request formats: text/html\n\nRails wants us to add an HTML/ERB template for use with our show action, but what it doesn’t currently know is that we’re not going to render HTML; we’re instead going to serve up binary image data. Once we have our controller action implemented, Rails will no longer complain about\n\n129\n\n130\n\n11 Images\n\nthe missing template. Let’s add the following code to our show action, and then we will run through how it works:\n\ndef show\n\nimg = Image.find_by(id: params[:id]) image = img.image\n\ndata = image.download type = image.content_type ext = image.filename.to_s.split('.').last filename = \"image_#{img.id}.#{ext}\"\n\nsend_data data, type:, filename:, disposition: 'inline'\n\nend\n\nFirst, we get our img record from our database using the id parameter from our request params. We then get the Active Storage image attachment from the img record. Next, we assign our variables data, type, and filename for use with the Rails send_data method to return the image data to our controller action’s caller.\n\nThe real magic here is the image.download call. This is an Active Storage method that will download the image data from wherever it is stored, locally or remotely. It returns the downloaded binary image data to us, and we then pass that data to the Rails send_data method.\n\nThe filename is not required, but it’s a nice touch to give the image a friendly name that is probably more uniform than the original ﬁlename of the image that was uploaded. We’re also setting the disposition to inline so that the image will be displayed in the browser, rather than be automatically downloaded.\n\nLet’s run our spec again and see that it passes. There are other things we could do in our request spec, such as checking the headers, to make sure\n\nthe Content-Disposition is set to inline, for example:\n\nheaders = response.headers expect(headers['Content-Disposition']).to include('inline')\n\nimage_name = \"image_#{Image.last.id}.jpeg\" expect(headers['Content-Disposition']).to include(image_name)\n\nOr we could check for and handle a missing image ﬁle extension in the ﬁlename; it’s up to you whether you want to add these to your own specs or not.\n\nWe do however want to handle the situation where the “img” record is not found. It may have been deleted from our database, or the id parameter may have been incorrectly set by the caller. Let’s add a spec for handling that scenario:\n\nit 'returns a missing image if the image does not exist' do\n\nget image_path(0)\n\nexpect(response).to be_successful\n\nServing Images\n\nexpect(response.content_type).to eq('image/jpeg')\n\nend\n\nInstead of showing a broken image, we want to show a “missing” image. We can simulate that scenario by looking for an image with an id of 0. We can then check that the response is successful and the content type is image/jpeg, just like if the image was actually found.\n\nRunning our spec, we can see that it fails:\n\n1) Images returns a missing image if the image does not exist Failure/Error: image = img.image\n\nNoMethodError:\n\nundefined method `image' for nil:NilClass\n\nWe can now update our controller action code to handle our missing image scenario:\n\ndef show\n\nimg = Image.find_by(id: params[:id])\n\nif img\n\nimage = img.image\n\ndata = image.download type = image.content_type ext = image.filename.to_s.split('.').last filename = \"image_#{img.id}.#{ext}\"\n\nelse\n\nimage_path = Rails.public_path.join('missing.jpeg') image = image_path.open('rb')\n\ndata = image.read type = 'image/jpeg' filename = 'missing.jpeg'\n\nend\n\nsend_data data, type:, filename:, disposition: 'inline'\n\nend\n\nRunning this spec again, we can see that it’s still failing, but for a different reason:\n\n1) Images returns a missing image if the image does not exist Failure/Error: image = image_path.open('rb')\n\nErrno::ENOENT:\n\nNo such file or directory @ rb_sysopen - ... missing.jpeg\n\n131\n\n132\n\n11 Images\n\nLet’s add a missing.jpeg ﬁle to our public directory. I will again leave it up to you to provide whatever image you like for your missing.jpeg image ﬁle. Let’s re-run our spec and see that it now passes.\n\nSummary\n\nIn this chapter, we added the ability to upload images and retrieve them using Active Storage. We’ve also added the ability to handle missing images. We’ll add the ability to delete images in a later chapter, when we build out our admin pages. Next, we’re going to tackle user authentication.\n\nUser Authentication\n\n12\n\nEventually, our blog application will have an administration interface, and we will need to make sure that only an administrator user can access it. To this end, we will need to add the ability to authenticate to our user model. This chapter will cover how to do that.\n\nSome readers may begin wondering why we are not using a third-party authentication library such\n\nas Devise. The reasons are\n\nWe want to always keep our application as simple as possible, with as few dependencies as possible. As you will soon see, adding a user model with salted password authentication is not difﬁcult. It’s important for software engineers to understand at least the basics of how third-party libraries such as Devise work, so we can make informed decisions to use them or not, and to adequately assess risk when we do choose to use them. Can you trust the authors to ship security ﬁxes quickly when exploits become publicly known? basic authentication.\n\n(cid:129)\n\nImproving Our User Model\n\nWe created a User model in a previous chapter. We now need to add functionality to support authentication. In particular, we need to add a password “salt” ﬁeld and a password “hash” ﬁeld. Adding these two ﬁelds will enable us to store one-way hashed passwords, individually salted for each of our users.\n\nPassword Hashing\n\nPassword hashing is a technique that is used to safely store passwords in a database in a way that makes it difﬁcult to recover the original password. The idea is that the password is hashed using a one-way hash function, such as SHA-256. The hash function is a mathematical function that takes a string of characters and produces a different ﬁxed length string of characters representing the original\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_12\n\n133",
      "page_number": 126
    },
    {
      "number": 15,
      "title": "Segment 15 (pages 140-155)",
      "start_page": 140,
      "end_page": 155,
      "detection_method": "topic_boundary",
      "content": "134\n\n12 User Authentication\n\nvalue. The hash function is one-way in that it is easy to compute the hash of a string of characters, but it is difﬁcult to compute the original string of characters from the hash. The hash function is also deterministic, in that given the same string of characters the hash function will always produce the same hashed value.\n\nThe hash function combines a “salt” value with the user-provided password value to produce a password hash. The salt value is a random string of characters, but it is unique for each password. The salt value is stored in the database along with the password hash. The salt value is used to make it difﬁcult to precompute a table of password hashes. If the salt value was not used, an attacker could precompute a table of password hashes for a large number of common passwords and then compare the password hashes in our database to the precomputed table to determine the passwords. Using salt values makes this attack much more difﬁcult, especially for users who use weak passwords.\n\nNow that we have a basic understanding of password salting and hashing, let’s add our password\n\nﬁelds to our user model.\n\nAdding Fields to Our User Model\n\nLet’s generate a migration to add our password ﬁelds to our user model:\n\nbe rails g migration add_user_password_fields\n\nWe will add two new ﬁelds to our user model, a password_salt ﬁeld and a password_hash ﬁeld. Both ﬁelds will be strings. Let’s modify our new migration ﬁle to add the ﬁelds:\n\nclass AddUserPasswordFields < ActiveRecord::Migration\n\ndef change\n\nadd_column :users, :password_salt, :string add_column :users, :password_hash, :string\n\nend\n\nend\n\nNow let’s run the migration:\n\nbe rails db:migrate be rails db:migrate RAILS_ENV=test\n\nWe now have the ﬁelds we need to store password hashes in our User model. The next step is to add the ability to set a password for a user. We do not want to store the password in our database in plaintext, so we need to be able to control things explicitly. We need a temporary password ﬁeld that we can use to generate the value we will actually store in our database.\n\nImproving Our User Model\n\nInside our spec/models/user_spec.rb ﬁle, let’s capture this idea by adding the following\n\nnew spec:\n\ndescribe 'set a password' do\n\nlet(:user) { build(:user) }\n\nit 'sets a password' do\n\nuser.password = 'changeme' user.save!\n\nexpect(user.password_salt).to be_present expect(user.password_hash).to be_present\n\nend\n\nend\n\nThis spec fails because we have not yet added any sort of password attribute or method to our user model:\n\n1) User password= sets a password\n\nFailure/Error: user.password = 'changeme'\n\nNoMethodError:\n\nundefined method `password=' for #<User id: nil, name: ...\n\nThe failure message indicates that we don’t actually need an attribute; we instead need a password= method.\n\ndef password=(password)\n\nself.password_salt = 'salt' self.password_hash = \"#{password_salt}#{password}\"\n\nend\n\nThis gets our spec to pass, but it is not a very good implementation. We’re capturing the basic idea of salting a password, but nothing is actually being hashed. We can see what is actually happening by running our Rails console:\n\nbe rails c\n\n135\n\n136\n\n12 User Authentication\n\nWhen we create a new user, we can see that the password salt and password hash are being set, but not hashed:\n\nirb(main):001:0> user = User.new(\n\nemail: 'foo@bar.com', name: 'Name', password: 'changeme'\n\n) ... irb(main):002:0> user.password_salt => \"salt\" irb(main):003:0> user.password_hash => \"saltchangeme\"\n\nBeing software engineers, but probably not expert cryptographers, we need to add a hashing library to our application.\n\nAdd a Hashing Library\n\nWe will use the bcrypt gem to add password hashing to our application. The bcrypt gem is a Ruby wrapper around the OpenBSD bcrypt library. Let’s add the gem to our application:\n\nbundle add bcrypt\n\nNext, we need to require the bcrypt library in our User model:\n\nrequire 'bcrypt'\n\nThis will give us access to all of the bcrypt gem’s functionality. We can now modify our password= method to use bcrypt:\n\ndef password=(password)\n\nself.password_salt = BCrypt::Engine.generate_salt self.password_hash = BCrypt::Engine.hash_secret(\n\npassword, password_salt\n\n) end\n\nFirst, we generate a salt value using BCrypt::Engine.generate_salt . Then we use the salt value to generate a hash of the user-provided password string using BCrypt::Engine.hash_ secret. The salt and hash values are then stored in our user record, after our before_save callback is executed.\n\nImproving Our User Model\n\nLet’s re-run our spec and see that it still passes. And then let’s see what we’re actually storing in\n\nour database, now that we’re using bcrypt:\n\nbe rails c\n\nirb(main):001:0> User.destroy_all ... irb(main):002:0> user = User.new(\n\nemail: 'foo@bar.com', name: 'Name', password: 'changeme'\n\n) ... irb(main):003:0> user.password_salt => \"$2a$12$jOaFNA79pCgwWS0poghAlu\" irb(main):004:0> user.password_hash => \"$2a$12$jOaFNA79pCgwWS0poghAluIaInS7I98yvVEdi03apOaXSoE5b1uyy\"\n\nOur salt and password hashes are being stored in our database now. Next, we should perform some actual user validation to verify that our new hash values are being generated correctly and that we can successfully authenticate.\n\nAuthenticating a User\n\nLet’s add a new spec to verify that we can authenticate a user:\n\ndescribe '.authenticate' do\n\nlet(:user) { build(:user) } let(:password) { 'changeme' }\n\nbefore do\n\nuser.password = password user.save!\n\nend\n\nit 'can authenticate' do\n\nexpect(User.authenticate(user.email, password)).to eq(user)\n\nend\n\nend\n\nThe idea here is that a user can authenticate if they provide the correct email address and password. We will call an .authenticate class method to verify the user’s credentials against the values we have stored in our database.\n\n137\n\n138\n\n12 User Authentication\n\nRunning this spec, we will see it fail because we have not yet added our .authenticate class\n\nmethod to our User model:\n\n1) User.authenticate can authenticate\n\nFailure/Error: expect(User.authenticate(user.email, password)).to eq(user)\n\nNoMethodError:\n\nundefined method `authenticate' for User:Class\n\nIf we implement the .authenticate method:\n\ndef self.authenticate end\n\nwe can make some progress to our next failure message:\n\n1) User.authenticate can authenticate Failure/Error:\n\ndef self.authenticate end\n\nArgumentError:\n\nwrong number of arguments (given 2, expected 0)\n\nRSpec is telling us that we need to accept two arguments into our .authenticate method: the user’s email address and the password they are attempting to authenticate with. Let’s add those arguments:\n\ndef self.authenticate(email, password) end\n\nNow that we have a method that accepts two arguments, we get our next failure message:\n\n1) User.authenticate can authenticate\n\nFailure/Error: expect(User.authenticate(user.email, password)).to eq(user)\n\nexpected: #<User id: 40, name: \"First10 Last10\", email: ...\n\ngot: nil\n\nImproving Our User Model\n\nWe’re accepting the correct arguments, but we’re not actually doing anything with them. Let’s add some code to ﬁnd the user record by email address and then verify that the provided password matches our stored password hash:\n\ndef self.authenticate(email, password) user = User.find_by(email: email)\n\npassword_hash = BCrypt::Engine.hash_secret(\n\npassword, user.password_salt\n\n)\n\nif password_hash == user.password_hash\n\nuser\n\nend\n\nend\n\nWe’re again using one-way hashing to generate a hash of the user-provided password and our stored salt value. If our generated hash matches our stored hash, we know that the correct password has been provided, and so we return the user record. If the hashes do not match, we will reach the end of our method, and our return value would be nil since nothing was actually returned.\n\nOur spec should now pass, and this is a good start to our authentication, but we’re not done yet.\n\nThere are a few more things we should do to improve our implementation; we should\n\n1. Return nil if the user’s email address is unknown. 2. Handle email address case sensitivity. 3. Create wrapper methods for any BCrypt methods we’re using.\n\nImproving Authentication\n\nRight now, we’re assuming a user record will always be found when searching by email address, and then we go on to call User.password_salt and User.password_hash. Either of these two calls will raise an exception if the user record is nil. We should not assume a user will be found and instead return nil if the user’s email address is unknown in our database. Let’s add a spec to reproduce the issue:\n\nit 'unknown email fails authentication' do\n\nexpect(User.authenticate('foo@bar.com', password)).to be_nil\n\nend\n\nWhen we run this spec, we get the following error:\n\n1) User.authenticate unknown email fails authenticate Failure/Error: user.password_salt\n\n139\n\n140\n\n12 User Authentication\n\nNoMethodError:\n\nundefined method `password_salt' for nil:NilClass\n\nLet’s ﬁx this by returning nil early in our method if the user record is not found:\n\ndef self.authenticate(email, password) user = User.find_by(email: email) return nil if user.nil?\n\npassword_hash = BCrypt::Engine.hash_secret(\n\npassword, user.password_salt\n\n)\n\nif password_hash == user.password_hash\n\nuser\n\nend\n\nend\n\nThe next issue we have is that we’re not handling email address case sensitivity correctly. If a user signs up with an email address of foo@bar.com and then attempts to authenticate with an email address of Foo@Bar.com, we should still authenticate them. The easiest solution to this is to downcase the email address when we store it in our database and then downcase the email address again when we search for it in our find_by call. This way, we will only ever compare lowercased email addresses. Let’s add a spec to handle downcasing email addresses anytime we save a user record:\n\ndescribe 'email' do\n\ncontext 'on create' do\n\nlet(:user) { create(:user, email: 'Foo@baR.Com') }\n\nit 'is downcased' do\n\nexpect(user.email).to eq('foo@bar.com')\n\nend\n\nend\n\ncontext 'on update' do\n\nlet(:user) { create(:user, email: 'foo@bar.com') }\n\nbefore do\n\nuser.update(email: 'Foo@baR.Com')\n\nend\n\nit 'is downcased' do\n\nexpect(user.email).to eq('foo@bar.com')\n\nend\n\nImproving Our User Model\n\nend\n\nend\n\nWhen we run this spec, we get two failures:\n\n1) User email on create is downcased\n\nFailure/Error: expect(user.email).to eq('foo@bar.com')\n\nexpected: \"foo@bar.com\" got: \"Foo@baR.Com\"\n\n2) User email on update is downcased\n\nFailure/Error: expect(user.email).to eq('foo@bar.com')\n\nexpected: \"foo@bar.com\" got: \"Foo@baR.Com\"\n\nLet’s ﬁx these spec failures by adding a before_save callback into our User model:\n\nbefore_save :downcase_email\n\nprivate\n\ndef downcase_email\n\nself.email = email.downcase\n\nend\n\nThese changes will ensure that anytime we save a user record, on create or on update, our user’s email address will be downcased. Our two new specs should pass now, and we can return to improving our authentication method.\n\nInside our .authenticate method, we’re not handling email address case sensitivity yet. Let’s\n\nadd a spec to reproduce this issue:\n\nit 'mixed case email can authenticate' do\n\nexpect(User.authenticate(user.email.titleize, password)).to eq(user)\n\nend\n\nWe can use titleize as a simple way to uppercase the ﬁrst letter of the email address. This fails as expected:\n\n1) User.authenticate mixed case email can authenticate Failure/Error: expect(User.authenticate(user.email.titleize, password)).to eq(user)\n\n141\n\n142\n\n12 User Authentication\n\nexpected: #<User id: 80, name: \"First12 Last12\", email: ...\n\ngot: nil\n\nTo ﬁx this, we need to downcase the email address before we search for the user record:\n\ndef self.authenticate(email, password)\n\nuser = User.find_by(email: email.downcase) ...\n\nend\n\nRe-running our spec, we see that it now passes, but we just created a new issue. What if the email address is nil? We’ll get an exception when we try to call downcase on a nil value. Let’s add a spec to reproduce this issue:\n\nit 'nil email fails authentication' do\n\nexpect(User.authenticate(nil, password)).to be_nil\n\nend\n\nThis spec fails as expected:\n\n1) User.authenticate nil email fails authentication Failure/Error: user = User.find_by(email: email.downcase)\n\nNoMethodError:\n\nundefined method `downcase' for nil:NilClass\n\nWe can ﬁx this by adding a guard clause to our method to return nil early if the email address is\n\nnil:\n\ndef self.authenticate(email, password)\n\nreturn nil unless email.present?\n\nuser = User.find_by(email: email.downcase) ...\n\nend\n\nRe-running our spec, we see that it now passes.\n\nNext, let’s do some refactoring. We’re using the BCrypt gem to create our password salt and hash values, but what if in the future we decided to use a different gem or even a different algorithm? We\n\nImproving Our User Model\n\nwould have to change our code in multiple places. Let’s extract the logic for creating a password hash into a separate method:\n\ndef self.hash_password(password, salt)\n\nBCrypt::Engine.hash_secret(password, salt)\n\nend\n\nWe can then use this method in our password= method:\n\ndef password=(password)\n\nself.password_salt = BCrypt::Engine.generate_salt self.password_hash = User.hash_password(password, password_salt)\n\nend\n\nand also in our .authenticate method:\n\ndef self.authenticate(email, password)\n\nreturn nil unless email.present?\n\nuser = User.find_by(email: email.downcase) return nil if user.nil?\n\npassword_hash = hash_password(\n\npassword, user.password_salt\n\n)\n\nif password_hash == user.password_hash\n\nuser\n\nend\n\nend\n\nLet’s also create a wrapper method for BCrypt::Engine.generate_salt:\n\ndef self.generate_salt\n\nBCrypt::Engine.generate_salt\n\nend\n\nWe can then use this method in our password= method:\n\ndef password=(password)\n\nself.password_salt = User.generate_salt self.password_hash = User.hash_password(password, password_salt)\n\nend\n\n143\n\n144\n\n12 User Authentication\n\nWe’re still depending on the BCrypt gem, but we’ve isolated the code that depends on it so that if we decide to change gems or algorithms in the future we only have to change the code in one place, and our specs will likely continue to pass.\n\nAlways remember to re-run specs to make sure nothing regressed into a broken state when\n\nrefactoring code or when adding wrapper methods to isolate third-party APIs, as we just did.\n\nPassword Conﬁrmation\n\nSince our user password value is one-way hashed, it would be a good idea to conﬁrm it before saving it. We will never be able to look into our database to conﬁrm it after the save occurs, so we need to conﬁrm it before the save.\n\nLet’s add new shoulda-matcher specs to capture this conﬁrmation behavior:\n\nit { is_expected.to validate_presence_of(:password) } it { is_expected.to validate_confirmation_of(:password) }\n\nOur ﬁrst failing spec is for the presence of the password:\n\n1) User validations is expected to validate that :password cannot be empty/falsy Failure/Error: it { is_expected.to validate_presence_of(:password) }\n\nNoMethodError:\n\nundefined method `password' for #<User id: nil, name: ...\n\nWe don’t have an actual password attribute on our user model, and we don’t want one either. We only want to store the password hash and salt, never the plaintext version a user provides. So to ﬁx this, we need to add a virtual attribute to our user model:\n\nattr_accessor :password\n\nAnd we need to set it inside our password= method:\n\ndef password=(password) @password = password self.password_salt = User.generate_salt self.password_hash = User.hash_password(password, password_salt)\n\nend\n\nImproving Our User Model\n\nThese changes will move us to our next failure message:\n\n1) User validations is expected to validate that :password cannot be empty/falsy Failure/Error: it { is_expected.to validate_presence_of(:password) }\n\nExpected User to validate that :password cannot be empty/falsy, but this could not be proved.\n\nAfter setting :password to ‹nil›, the matcher expected the User to be invalid, but it was valid instead.\n\nIt appears our new password attribute is correctly deﬁned now, but we need to actually validate it for presence. We can do this by adding a validation to our user model:\n\nvalidates :password, presence: true\n\nThis change gets our new spec to pass but breaks many of our other specs. The problem is the subject deﬁned at the top of our User_spec.rb ﬁle:\n\nsubject { build(:user) }\n\nIf we look at our user factory deﬁnition in spec/factories/users.rb, we can see that it does not currently deﬁne a password attribute, which is an easy ﬁx:\n\npassword { 'changeme' }\n\nRe-running our spec ﬁle shows us progress. We’re now getting a new failure message for our password conﬁrmation spec:\n\n1) User validations is expected to validate that :password_confirmation matches :password Failure/Error: it { is_expected.to\n\nvalidate_confirmation_of(:password) }\n\nShoulda::Matchers::ActiveModel::AllowValueMatcher::Attribute ...\n\nThe matcher attempted to set :password_confirmation on the User to \"some value\", but that attribute does not exist.\n\n145\n\n146\n\n12 User Authentication\n\nTo ﬁx this, we need to update our user password validation to include conﬁrmation:\n\nvalidates :password, presence: true, confirmation: true\n\nThis change will enable another virtual attribute in our user model, password_confirmation, which is exactly what our spec is looking for. This causes us to also need to add a separate password conﬁrmation validation:\n\nvalidates :password_confirmation, presence: true\n\nAs before, this gets our new spec to pass but breaks some of our other specs. Our subject is again causing problems, and we again need to update our user factory deﬁnition, this time to include a password conﬁrmation attribute:\n\npassword_confirmation { password }\n\nWe’ll let FactoryBot reuse the password attribute we deﬁned earlier to set our new password_confirmation attribute. This will make it easier to change both values in the future if we need to.\n\nThis gets our spec to pass, but do we always want to require a password and password\n\nconﬁrmation?\n\nSkipping Password Validation\n\nRight now, we are requiring a password and a password conﬁrmation for every user record, both on create and on save. This is not always what we want. For example, if we’re only updating a user’s name, we don’t want to require the password and password conﬁrmation to also be present. We can even imagine a scenario where the user is not even present when another ﬁeld needs to be updated. First, let’s prove the problem actually exists with a spec, and then we’ll ﬁgure out how to ﬁx it:\n\ndescribe 'password' do\n\nbefore { subject.save! }\n\nit 'is not required when updating name' do\n\nuser = User.last expect(user.password).to be_nil\n\nuser.update(name: 'New Name') expect(user).to be_valid\n\nend\n\nend\n\nImproving Our User Model\n\nRunning this spec, we can see that the bug is real:\n\n1) User password is not required when updating name Failure/Error: expect(subject).to be_valid\n\nexpected #<User id: 462, name: \"New Name\", email: \"user16@example.com\", created_at: \"2023-01-22 21:10:55.920524000 +0000\", updated_at: \"2023-01-22 21:10:55.920524000 +0000\", password_salt: [FILTERED], password_hash: [FILTERED]> to be valid, but got errors: Password can't be blank, Password confirmation can't be blank\n\nWe can ﬁx this by making our password validations conditional. There are two conditions where we do want the password validation:\n\n1. When the user has not been saved to our database 2. When the user is updating their password\n\nWe can ﬁrst create a private helper method to check for these conditions:\n\nprivate\n\ndef password_required?\n\n!persisted? || password.present?\n\nend\n\nSo if the user record has not been persisted to our database, because the record is new, or the password is actually present, because the user is updating their password, then we want to execute our password and password conﬁrmation validations. We just need to update our validations to use this helper method to allow them to become conditional:\n\nvalidates :password,\n\npresence: true, confirmation: true, if: :password_required?\n\nvalidates :password_confirmation,\n\npresence: true, if: :password_required?\n\nThis change gets our new spec to pass.\n\n147\n\n148\n\n12 User Authentication\n\nSummary\n\nIn this chapter, we learned how to add a password authentication system to our User model. We learned how to use the bcrypt gem to hash and salt our passwords. We also learned how to use the shoulda-matchers gem to validate password and password conﬁrmation values. We also provided specs and ﬁxes around the password validations to ensure that we only require passwords when we should.\n\nNo Devises were harmed in the making of this chapter.\n\nAdministration\n\n13\n\nIn this chapter, we will develop an administrative interface for our blog’s application data. Everything we’ve built so far will be given the usual CRUD operations (Create, Read, Update, Delete) we’d expect to have available. We will save a lot of time by leveraging Active Admin to create these interfaces.\n\nAdding Active Admin\n\nActive Admin is a gem that provides a framework for creating administrative interfaces for Rails applications. It is a very powerful tool that can be implemented simply and quickly, but can also be customized to a great degree.\n\nAdding the Gem\n\nThe ﬁrst step is to add the gem to our project:\n\nbundle add activeadmin\n\nNext, we need to run the generator to install the necessary integration ﬁles:\n\nbe rails generate active_admin:install --skip-users --skip-comments\n\nWe will skip the user integration and instead use our own User model for our user authentication. We will also skip the additional Active Admin comments table as we will not be using admin comments in our blog application.\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_13\n\n149",
      "page_number": 140
    },
    {
      "number": 16,
      "title": "Segment 16 (pages 156-163)",
      "start_page": 156,
      "end_page": 163,
      "detection_method": "topic_boundary",
      "content": "150\n\n13 Administration\n\nFigure 13-1 Active Admin dashboard\n\nThat’s it for the setup. We can now start using Active Admin to create our administrative interfaces.\n\nLet’s start up Rails:\n\nbe rails s\n\nAnd see what we have so far. Visiting the admin URL shows us output like Figure 13-1:\n\nhttp://localhost:3000/admin\n\nIt’s not much at the moment, but we will build it out soon enough.\n\nTesting Active Admin\n\nActive Admin is recipe driven. We will use a DSL (domain-speciﬁc language) provided by Active Admin to tell it what we want it to do for us. As a rule, I don’t usually write specs for third-party gems that already have their own specs, but Active Admin is a special case. Our Active Admin interface code can be considered part of our application and should be tested as such. Our DSL code could very well contain bugs or could become broken by future changes in our models, for example, so we will write high-level system specs to protect us from our future selves.\n\nLogging In\n\nThe ﬁrst thing we should pursue is to prevent anonymous access to our admin interface. Right now, we can access it without logging in; it’s completely unprotected. Let’s begin with a system spec to\n\nLogging In\n\ntest that we can’t access the admin interface without logging in. In our spec/system directory, let’s create a new ﬁle called login_spec.rb and add the following code:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Login Page' do let(:user) { create(:user) }\n\nit 'Admin requires logging in' do\n\nvisit admin_root_path\n\nexpect(page).to have_css('h2', text: 'Sign in')\n\nfill_in 'Email', with: user.email fill_in 'Password', with: 'changeme' click_button 'Submit'\n\nexpect(page).to have_css('h2', text: 'Dashboard')\n\nclick_link 'Logout'\n\nexpect(page).to have_link 'My Blog'\n\nend\n\nend\n\nIn our spec, we try, as an anonymous user, to visit our admin dashboard page and then expect to be redirected away to our login page where we should be encouraged to log in. We then ﬁll in our login form, submit it, and expect to be redirected to our admin dashboard. Finally, we click the logout link and expect to be redirected back to our blog’s public homepage. It’s a very simple spec, but it will go a long way in helping us drive out our admin login/logout implementation code.\n\nWhen we run this spec, we see it fails with the following error:\n\n1) Login Page Admin requires logging in\n\nFailure/Error: expect(page).to have_css('h2', text: 'Sign in')\n\nexpected to find visible css \"h2\" with text \"Sign in\" but there were no matches.\n\nTo get past this particular error, we need to make several changes:\n\n1. Implement our login form 2. Add a Rails route to render our login form 3. Have Active Admin redirect anonymous users\n\n151\n\n152\n\n13 Administration\n\nFor the ﬁrst item, we will need to create a new view template to render our login form. In our app/views directory, let’s create a new directory called sessions and inside that directory create a new ﬁle called new.html.erb with the following content:\n\n<%= form_for(:login, url: login_path) do |f| %>\n\n<h2>Sign in</h2> <div>\n\n<%= f.label :email %> <%= f.email_field :email %>\n\n</div> <div>\n\n<%= f.label :password %> <%= f.password_field :password %>\n\n</div> <div>\n\n<button type=\"submit\">Submit</button>\n\n</div> <% end %>\n\nNext, we need to add our new route to our config/routes.rb ﬁle:\n\nget 'login', to: 'sessions#new'\n\nInstead of using the Rails resources method, we will use the get method to create a named route called login that maps to a controller named sessions with a method of new. This will enable the Rails login_path helper method for us. user\n\nour config/initializers/active_admin.rb ﬁle, we need to uncomment the following line:\n\nNext, we\n\nneed\n\nto\n\nenable\n\nauthentication\n\nin Active Admin.\n\nIn\n\nconfig.authentication_method = :authenticate_admin_user!\n\nIf you read the comment above this line:\n\n# This setting changes the method which Active Admin calls (within # the application controller) to return the currently logged in user.\n\nWe know from reading the comment that we need to create a new method in our application_ controller.rb ﬁle called authenticate_admin_user! that will be called by Active\n\nLogging In\n\nAdmin to authenticate our users. We can verify this is the next thing to pursue by running our spec again:\n\n1) Login Page Admin requires logging in\n\nFailure/Error: send(active_admin_namespace.authentication_method) if active_admin_namespace.authentication_method\n\nNoMethodError:\n\nundefined method `authenticate_admin_user!' for #<Admin::DashboardController:0x0000000000f4d8>\n\nLet’s add the following method to our application_controller.rb ﬁle:\n\ndef authenticate_admin_user!\n\nredirect_to login_path if session[:admin_user_id].nil?\n\n@current_admin_user = User.find_by(id: session[:admin_user_id])\n\nend\n\nThis method will redirect anonymous users to our login page. We consider a user to be anonymous if they do have a session variable name admin_user_id set. If they do have the session variable we’re looking for, then we query our database to try to locate their user account. Either way, we set the query result (nil or other) to an instance variable name @current_admin_user. We can now run our spec again and see that we’re getting a new failure message:\n\n1) ActionController::RoutingError:\n\nuninitialized constant SessionsController\n\nThis error is telling us that we need to create our sessions controller. Let’s do that now by creating a new ﬁle called sessions_controller.rb in our app/controllers directory and adding the following code:\n\nclass SessionsController < ApplicationController end\n\nRunning our spec again, we see that we’ve moved along to the next error message:\n\n1) Login Page Admin requires logging in\n\nFailure/Error: <%= form_for(:login, url: login_path) ...\n\nActionView::Template::Error:\n\nundefined local variable or method `sessions_path'\n\n153\n\n154\n\n13 Administration\n\nWhy is it not complaining about our lack of a new method in our sessions controller? Well, as it turns out, Rails will look for a view template with the same name as the controller method, and if it ﬁnds one, it will automatically render it. In our case, we do have a view template called new.html.erb in our app/view/sessions directory, so Rails will render that for us.\n\nSo what does the error message mean? By default, our form_for helper method is creating an HTML form tag for us that contains a method of post and an action of sessions_path. That particular Rails route does not currently exist in our application, so we need to add it. Let’s do that now by adding the following line to our config/routes.rb ﬁle:\n\npost 'login', to: 'sessions#create'\n\nThis will give us a second login route that maps to a create method in our sessions controller. We can verify this by running the Rails routes command:\n\nbe rails routes -g login\n\nThe output shows both new login routes, one for get and one for post:\n\nPrefix Verb URI Pattern\n\nController#Action\n\nlogin GET /login(.:format) sessions#new\n\nPOST /login(.:format) sessions#create\n\nRunning our spec again, we see that we’ve moved along to the next error message:\n\nAbstractController::ActionNotFound:\n\nThe action 'create' could not be found for SessionsController\n\nIn order to ﬁx this error, we need to add our create method to our sessions controller. Let’s do that now by adding the following code to our sessions_controller.rb ﬁle:\n\nclass SessionsController < ApplicationController\n\ndef create end\n\nend\n\nLogging In\n\nRunning our spec again, we see that we’ve moved along to the next error message:\n\n1) Login Page Admin requires logging in\n\nFailure/Error: expect(page).to have_css('h2', text: 'Dashboard')\n\nexpected to find css \"h2\" but there were no matches\n\nThis error is telling us that we’re submitting our login form successfully, but after that we’re not redirecting to the dashboard page. It’s time to implement the contents of our create method in our SessionsController:\n\ndef create\n\nuser = User.find_by(email: params[:login][:email]) if User.authenticate(user&.email, params[:login][:password])\n\nsession[:admin_user_id] = user.id redirect_to admin_root_path\n\nelse\n\nrender :new\n\nend\n\nend\n\nOur params hash will contain a top-level login key that contains another hash with our actual login form data. We can query our database using the email key of this inner hash to try to locate a matching user account. We then try to authenticate the user using our User.authenticate method that we added to our User model earlier, making sure to use the &. safety operator to avoid a nil error if the user account is not found. If the user is authenticated, we set the session variable admin_user_id and redirect to our admin dashboard page. If the user is not authenticated, we render the new view template again.\n\nRunning our spec again, we see that we’ve moved along to the next error message:\n\n1) Login Page Admin requires logging in Failure/Error: click_link 'Logout'\n\nCapybara::ElementNotFound:\n\nUnable to find link \"Logout\"\n\nIt looks like our login is ﬁnally working. Now we need to work on our logout functionality.\n\nThere are several steps we will work through to get our logout link working:\n\n1. Add a Rails route for our logout link 2. Add a destroy method in our sessions controller 3. Conﬁgure Active Admin to show our logout link\n\n155\n\n156\n\n13 Administration\n\nLet’s start by adding a Rails route for our logout link. We’ll add the following line to our config/routes.rb ﬁle:\n\nget 'logout', to: 'sessions#destroy'\n\nAgain, we’re using a named route. This gives us a logout path that maps to a destroy method in our sessions controller. We can verify this by running the Rails routes command:\n\nbe rails routes -g logout\n\nIt gives us the following output conﬁrming our new route:\n\nPrefix Verb URI Pattern logout GET /logout(.:format) sessions#destroy\n\nController#Action\n\nWe could have just as easily used a delete route instead of a get route if we wanted to. A delete route would be more RESTful, but we’re not actually making any sort of destructive changes to our database, so we’ll use a get route instead.\n\nNext, we need to add our destroy method in our SessionsController. Let’s do that now\n\nby adding the following code:\n\ndef destroy\n\nsession[:admin_user_id] = nil redirect_to root_path\n\nend\n\nThis method simply clears the admin_user_id session variable and redirects us to our homepage. Without the session variable, any future requests to our admin dashboard will be redirected to our login page.\n\nFinally, we need to conﬁgure Active Admin to actually show our logout link; it’s off by default. We need to uncomment and/or (re)conﬁgure the following variables in our active_admin.rb initializer ﬁle:\n\nconfig.current_user_method = :current_admin_user config.logout_link_path = :logout_path config.logout_link_method = :get\n\nThe logout_link_path and the logout_link_method need to match our previous work in our routes and sessions controller. We point them to our logout_path that uses the get method.\n\nLogging In\n\nThe current_user_method variable tells Active Admin which method to call on our ApplicationController to get the current user via our login session variable. We still need to add that, so let’s add this method to our ApplicationController:\n\ndef current_admin_user\n\n@current_admin_user ||= User.find_by(id: session[:admin_user_id])\n\nend\n\nWe memoize the result of our User.find_by database query so that we don’t query our database every time we call this method. Active Admin can and will call this method multiple times during a single HTTP request, so our ||= memoization adds some efﬁciency.\n\nRunning our spec again, we can see it’s ﬁnally passing. We’ve successfully implemented our login\n\nand logout functionality for our admin.\n\nAdmin Layout\n\nRight now, our login page is using our default application.html.erb layout ﬁle, so it includes our header and sidebar sections. It would be nice to have a separate layout ﬁle for our login page that does not include anything extra. In addition, it could also be laid out and styled differently. We can accomplish this by creating a new layout ﬁle and assigning it in our SessionController.\n\nLet’s ﬁrst add an expectation to make sure we’re rendering the correct layout ﬁle. We don’t really need an entire new spec for testing that one layout or another is being used, and we can easily look for the presence of a speciﬁc element on the page to make sure we’re using the one we mean to. Let’s add the following expectation just inside the beginning of our “Admin requires logging in” spec in our login_spec.rb system spec ﬁle:\n\nexpect(page).to have_css('h2', text: 'Admin')\n\nThis expectation will look for an h2 element with the text Admin just before we try to log in. This will fail because we’re not currently using the correct layout ﬁle:\n\n1) Login Page Admin requires logging in\n\nFailure/Error: expect(page).to have_css('h2', text: 'Admin')\n\nexpected to find css \"h2\" but there were no matches\n\nLet’s ﬁx that now by creating a new layout ﬁle called admin.html.erb in our app/views/ layouts directory. We’ll add the following content to our new layout ﬁle:\n\n<!DOCTYPE html> <html>\n\n<head>\n\n<title>Admin</title>\n\n157",
      "page_number": 156
    },
    {
      "number": 17,
      "title": "Segment 17 (pages 164-172)",
      "start_page": 164,
      "end_page": 172,
      "detection_method": "topic_boundary",
      "content": "158\n\n13 Administration\n\n<%= csrf_meta_tags %> <%= csp_meta_tag %> <%= stylesheet_link_tag \"application\", \"data-turbo-track\": \"reload\" %>\n\n</head> <body>\n\n<h2>Admin</h2> <%= yield %>\n\n</body>\n\n</html>\n\nNext, we need to inform our SessionsController that it should use our new layout ﬁle. We can do that by adding the following line to our SessionsController class near the top:\n\nclass SessionsController < ApplicationController\n\nlayout 'admin'\n\n...\n\nend\n\nThis gets our spec passing. We’re now using the correct layout ﬁle for our login page.\n\nManaging Pages\n\nNow that we have our Active Admin login and logout functionality working, we can begin adding data management interfaces. We’ll ﬁrst add Pages. Inside of our spec/system directory, we’ll create a new directory called admin, then inside of that new directory, we’ll create a new ﬁle called pages_spec.rb with the following content:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Pages' do\n\nlet(:user) { create(:user) }\n\ndescribe 'A new page' do it 'can be added' do\n\nvisit admin_root_path\n\nfill_in 'Email', with: user.email fill_in 'Password', with: 'changeme' click_button 'Submit'\n\nexpect(page).to have_css('h2', text: 'Dashboard')\n\nvisit new_admin_page_path\n\nselect User.last.name, from: 'User'\n\nManaging Pages\n\nfill_in 'Title', with: 'Page Title' fill_in 'Summary', with: 'Summary info' fill_in 'Content', with: 'Content goes here' fill_in 'Tags', with: 'foo, bar'\n\ncheck('Published')\n\nclick_button 'Create Page'\n\nwithin '.flashes' do\n\nexpected = 'Page was successfully created.' expect(page).to have_css('.flash_notice', text: expected)\n\nend\n\nwithin '#main_content' do\n\nexpect(page).to have_css('td', text: user.name) expect(page).to have_css('td', text: 'Page Title') expect(page).to have_css('td', text: 'Summary info') expect(page).to have_css('td', text: 'Content goes here') expect(page).to have_css('span.yes', text: 'YES') expect(page).to have_css('td', text: 'bar, foo')\n\nend\n\nend\n\nend\n\nend\n\nThis spec is a bit more complicated than our previous system specs. We’re going to log in, then we’re going to create a new page with some basic form ﬁeld values. We’ll then verify that the page was created by checking the HTML that is styled with the flashes CSS class and the HTML with the main_content id attribute sections of the show page that appears after a successful page creation.\n\nRunning our new system spec, we get the following error:\n\n1) Pages A new page can be added\n\nFailure/Error: visit new_admin_page_path\n\nNameError:\n\nundefined local variable or method `new_admin_page_path'\n\nWe can see that our spec is failing because it can’t ﬁnd a route for our new_admin_page_path. We need to add a route for this path but not in the usual way of modifying our routes.rb ﬁle. Active Admin adds routes for us if we use the ActiveAdmin.register method to register a new model. In our app/admin directory, let’s create a new ﬁle called pages.rb with the following content:\n\nActiveAdmin.register Page do end\n\n159\n\n160\n\n13 Administration\n\nThis gives us a new route for our new_admin_page_path and moves us along to our next spec failure message:\n\n1) Pages A new page can be added\n\nFailure/Error: fill_in 'Tags', with: 'foo, bar'\n\nCapybara::ElementNotFound:\n\nUnable to find field \"Tags\" that is not disabled\n\nThis error is telling us that Capybara can’t ﬁnd a form ﬁeld with the label of \"Tags\". We need to add a form ﬁeld for our tags_string attribute. Unfortunately, Active Admin doesn’t have an easy way to add a single form ﬁeld to the existing form ﬁelds that it generates for us automatically. We will need to override the entire default form that Active Admin generates for us.\n\nLet’s modify our admin/pages.rb ﬁle to add a custom form:\n\nform do |f|\n\nf.semantic_errors inputs do\n\nf.input :user f.input :title f.input :summary f.input :content f.input :tags_string, label: 'Tags' f.input :published\n\nend f.actions\n\nend\n\nThis gets our tags_string form ﬁeld to show up and also allows us to customize our form if we needed any other customizations. Now when we run our spec, we get the following error:\n\n1) Pages A new page can be added\n\nFailure/Error: raise ActiveModel::ForbiddenAttributesError ...\n\nActiveModel::ForbiddenAttributesError:\n\nActiveModel::ForbiddenAttributesError\n\nWe’re getting this error because we have not yet permitted valid parameters to be processed. This is similar to how we have to permit parameters in our non-admin Rails controllers. We need to add a permitted_params method call and add our Page parameter list:\n\npermit_params :user_id,\n\n:title, :summary, :content,\n\nManaging Pages\n\n:tags_string, :published\n\nThis allows our Active Admin to process the parameters that we’re passing in from our form. Now when we run our spec, we get the following error message:\n\n1) Pages A new page can be added\n\nFailure/Error: expect(page).to have_css('td', text: 'bar, foo')\n\nexpected to find css \"td\" within #<Capybara::Node::Element ...\n\nThe page we land on after a successful Page creation is the Active Admin equivalent of a Rails show page for our Page model. We can see that the tags_string attribute is not being displayed. We have a similar situation as before with our Active Admin generated form; we need to customize the show page output to display our tags_string attribute.\n\nOverriding Active Admin Form Field Values\n\nOur tags_string ﬁeld is not being populated with the existing tag values. We can run our spec using SHOW_CHROME=1 to conﬁrm. The missing values make sense because tags_string is an attr_accessor attribute on our Page model and not an actual ActiveRecord database column.\n\nWe can ﬁx this by providing the value ourselves. First, we need a helper method to convert our tags attribute into a comma-separated string. Let’s add a spec to capture this idea. In our spec/models/page_spec.rb ﬁle, let’s add the following spec:\n\ndescribe '#tags_string_for_form' do\n\nlet(:tag) { create(:tag, name: 'foo') } let(:tag2) { create(:tag, name: 'bar') } let(:page) { create(:page, :published) }\n\nbefore do\n\ncreate(:page_tag, page:, tag:) create(:page_tag, page:, tag: tag2)\n\nend\n\nit 'returns the tags in comma delimited format' do\n\nexpect(page.tags_string_for_form).to eq('bar, foo')\n\nend\n\nend\n\nWe then get our spec failure message:\n\n1) Page#tags_string_for_form returns the tags in comma delimited format Failure/Error: expect(page.tags_string_for_form).to eq('bar, foo')\n\n161\n\n162\n\n13 Administration\n\nNoMethodError:\n\nundefined method `tags_string_for_form' for #<Page id: ...\n\nOur failure message tells us we need to add a method to our Page model named tags_string_ for_form. Let’s modify our app/models/page.rb ﬁle to add it:\n\ndef tags_string_for_form end\n\nWhen we re-run our spec, we get a different failure message:\n\n1) Page#tags_string_for_form returns the tags in comma delimited format Failure/Error: expect(page.tags_string_for_form).to eq('bar, foo')\n\nexpected: \"bar, foo\"\n\ngot: nil\n\nLet’s modify our tags_string_for_form method to return the expected value:\n\ndef tags_string_for_form\n\ntags.ordered.map(&:name).join(', ')\n\nend\n\nWe “map over” our ordered tags attribute, calling the name method on each tag to get the name of the tag. This results in an array that we can then join together using a comma. This ﬁnal string is returned from our method.\n\nWhen we re-run our spec, we can see it’s now passing. Now we can modify our admin/pages.rb ﬁle to add a custom show page that uses our new tags_string_for_form method:\n\nshow do\n\nattributes_table do\n\nrow :user row :title row :slug row :summary row :content row('Tags') { |p| p.tags_string_for_form } row :published\n\nend\n\nend\n\nManaging Pages\n\nThis gets our tags appearing on the page and gets our spec passing. Next, let’s add a spec for our ability to edit a page:\n\ndescribe 'An existing page' do\n\nlet(:the_page) { create(:page, :published, user:) } let(:user2) { create(:user) }\n\nbefore do\n\nthe_page.tags << create(:tag, name: 'foo') the_page.tags << create(:tag, name: 'bar') user2\n\nend\n\nit 'can be edited' do\n\nvisit admin_root_path\n\nfill_in 'Email', with: user.email fill_in 'Password', with: 'changeme' click_button 'Submit'\n\nexpect(page).to have_css('h2', text: 'Dashboard')\n\nvisit admin_pages_path\n\nclick_link 'Edit'\n\nexpect(page).to have_select('page_user_id', selected: user.name) expect(page).to have_field('page_title', with: the_page.title) expect(page).to have_field('page_summary', with: the_page.summary) expect(page).to have_field('page_content', with: the_page.content) expect(page).to have_field('page_tags_string', with: 'bar, foo') expect(page).to have_unchecked_field('page_published')\n\nselect user2.name, from: 'User'\n\nfill_in 'Title', with: 'Page Title' fill_in 'Summary', with: 'Summary info' fill_in 'Content', with: 'Content goes here' fill_in 'Tags', with: 'foo, bar, baz'\n\ncheck('Published')\n\nclick_button('Update Page')\n\nwithin '.flashes' do\n\ntext = 'Page was successfully updated.' expect(page).to have_css('.flash_notice', text:)\n\nend\n\nwithin '#main_content' do\n\nexpect(page).to have_css('td', text: user2.name) expect(page).to have_css('td', text: 'Page Title') expect(page).to have_css('td', text: 'Summary info')\n\n163\n\n164\n\n13 Administration\n\nexpect(page).to have_css('td', text: 'Content goes here') expect(page).to have_css('span.yes', text: 'YES') expect(page).to have_css('td', text: 'bar, baz, foo')\n\nend\n\nend\n\nend\n\nWhen we run our new edit spec, we get the following error:\n\n1) Pages An existing page can be edited\n\nFailure/Error: expect(page).to have_field('page_tags_string',\n\nwith: 'bar, foo') expected to find visible field \"page_tags_string\" that is not disabled with value \"bar, foo\" but there were no matches.\n\nLet’s modify our admin/pages.rb ﬁle to use our tags_string_for_form method. We need to modify our form block to use the input_html attribute to set the value of our tags_string ﬁeld:\n\nf.input :tags_string, label: 'Tags',\n\ninput_html: { value: f.object.tags_string_for_form }\n\nWe can access our Page object using the f.object method, and then we can call our tags_string_for_form method on that to get the comma-separated value we want.\n\nThe rest of the spec is a lot like our previous spec for creating a new page. When we run it again,\n\nwe can see it is now passing, although we have created some code duplication along the way.\n\nFactoring Out Duplicate Login Code\n\nWe’re now logging in to our admin three times in two different spec ﬁles. It’s time to factor out a helper method to reduce code duplication. Let’s create a new directory in our spec directory named support, and inside our new directory, let’s create a new ﬁle called login.rb. Then let’s add a method to our new ﬁle to handle logging in:\n\ndef login_as(user)\n\nvisit admin_root_path\n\nexpect(page).to have_css('h2', text: 'Admin') expect(page).to have_css('h2', text: 'Sign in')\n\nfill_in 'Email', with: user.email fill_in 'Password', with: 'changeme' click_button 'Submit'\n\nManaging Pages\n\nexpect(page).to have_css('h2', text: 'Dashboard')\n\nend\n\nTo give RSpec access to our new login_as method, we need to add the following line to the bottom of our spec/rails_helper.rb ﬁle:\n\nrequire \"#{Rails.root}/spec/support/login\"\n\nThis will load our login.rb ﬁle whenever our spec suite is run.\n\nNow we can replace our three login calls with a single call to our new helper method. The ﬁrst one\n\nis in our system/login_spec.rb ﬁle:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Login Page' do let(:user) { create(:user) }\n\nit 'Admin requires logging in' do\n\nlogin_as(user)\n\nclick_link 'Logout'\n\nexpect(page).to have_link 'My Blog'\n\nend\n\nend\n\nThe other two are in our system/admin/pages_spec.rb ﬁle. Let’s do a similar replacement on them. In fact, in all of our admin pages, we are going to need to log in before doing much else, so let’s add our login_as call in a before block so it’s called before every spec runs:\n\nbefore do\n\nlogin_as(user)\n\nend\n\nOnce we’ve done that, let’s re-run our system specs and make sure they are all still passing:\n\nSHOW_CHROME=1 be rspec spec/system/**/*.rb\n\n165\n\n166\n\n13 Administration\n\nPreviewing a Page\n\nNext, we’re going to customize our Page admin, so we can visit a page directly from within our admin interface. We’ll do this by adding a custom link to our index page. We don’t yet have an index page spec, so let’s start there. Let’s add this new spec to our “An existing page” describe block in our system/admin/pages_spec.rb ﬁle:\n\nit 'can be visited' do\n\nvisit admin_pages_path\n\nwithin '.index_content' do\n\nexpect(page).to have_css('td', text: the_page.title) expect(page).to have_css('td', text: 'bar, foo') expect(page).to have_css('span.yes', text: 'YES')\n\nnew_window = window_opened_by do\n\nclick_link(\"/pages/#{the_page.slug}\")\n\nend\n\nwithin_window new_window do\n\nexpect(page).to have_css('h2', text: the_page.title)\n\nend\n\nend\n\nend\n\nTo start with, we visit our Page index page. Then we use the within method to limit our scope to the .index_content element. This is the element that contains our table of Page objects. We can then use the have_css matcher to check that our Page is listed in the table.\n\nNext, we use the window_opened_by method to open a new window when we click our Page link. We then use the within_window method to switch to that new window and check that it contains our Page title.\n\nLet’s run our spec and see what happens:\n\n1) Pages An existing page can be visited\n\nFailure/Error: expect(page).to have_css('td', text: 'bar, foo')\n\nRight away, we can see that we are going to need to fully customize our index page to show our tags. Let’s do that now by adding a new index block to our ActiveAdmin.register call in our admin/pages.rb ﬁle:\n\nindex do\n\ncolumn :title column('Tags') { |p| p.tags_string_for_form }\n\nend",
      "page_number": 164
    },
    {
      "number": 18,
      "title": "Segment 18 (pages 173-181)",
      "start_page": 173,
      "end_page": 181,
      "detection_method": "topic_boundary",
      "content": "Managing Pages\n\nThis change breaks our ability to click the “Edit” link, and that breaks a previously working spec, but we’ll get it ﬁxed up momentarily.\n\nThe spec failure we’re concerned with at the moment is the complaint about our published\n\ncolumn:\n\n1) Pages An existing page can be visited\n\nFailure/Error: expect(page).to have_css('span.yes', text: 'YES')\n\nexpected to find css \"span.yes\"\n\nLet’s ﬁx that by adding a new published column to our index block:\n\ncolumn :published\n\nOur next spec failure message complains about our link to visit our Page:\n\n) Pages An existing page can be visited\n\nFailure/Error: click_link(\"/pages/#{the_page.slug}\")\n\nCapybara::ElementNotFound:\n\nUnable to find link\n\nLet’s ﬁx that by adding a link to our non-admin show page. In our index block, we can add a new column with a block that returns a link to the public URL of our page:\n\ncolumn('Preview') do |p|\n\npath = \"/page/#{p.slug}\" link_to path, path, target: '_blank'\n\nend\n\nIf we now run our whole spec ﬁle, we can see that we’ve broken a previous spec. Our edit link is no longer working:\n\n1) Pages An existing page can be edited Failure/Error: click_link 'Edit'\n\nCapybara::ElementNotFound:\n\nUnable to find link \"Edit\"\n\n167\n\n168\n\n13 Administration\n\nWhen we customized the columns in our index block, we accidentally removed our default Edit link. Let’s add it back in, as well as the id column and our batch actions checkbox:\n\nindex do\n\nselectable_column id_column column :title column('Tags') { |p| p.tags_string_for_form } column :published column('Preview') do |p|\n\npath = \"/page/#{p.slug}\" link_to path, path, target: '_blank'\n\nend actions\n\nend\n\nOur Active Admin Page index is back to a fully working state, and all of our specs should be back to passing now.\n\nManaging Images\n\nThe next piece of functionality we’re going to add to our admin is the ability to manage our image uploads. We’ll want to be able to upload images, edit them, and delete them. We’ll also want to provide a thumbnail of an uploaded image as well as a valid HTML <image /> tag that we can easily use in our Page content.\n\nViewing Images\n\nLet’s start by adding a new spec that tests our ability to view images in our admin, in a new Images index page. In our system/admin directory, let’s add a new ﬁle called images_spec.rb with the following content:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Images' do\n\nlet(:user) { create(:user) } let(:img) { Image.last }\n\nbefore do\n\nlogin_as(user)\n\nend\n\ndescribe 'index' do\n\nbefore do\n\ncreate(:image)\n\nend\n\nManaging Images\n\nit 'renders images' do\n\nvisit admin_images_path\n\nwithin 'table.index_table' do\n\nwithin 'td.col-name' do\n\nexpect(page).to have_text(img.name)\n\nend\n\nwithin 'td.col-image' do xpath = <<~IMG.squish\n\n//img[@height='80' and\n\n@alt='#{img.name}' and @title='#{img.name}' and @src='/images/#{img.id}']\n\nIMG expect(page).to have_xpath(xpath)\n\nend\n\nwithin 'td.col-image_tag' do\n\ntext = <<~IMG.squish\n\n<img alt=\"#{img.name}\"\n\ntitle=\"#{img.name}\" src=\"/images/#{img.id}\" />\n\nIMG expect(page).to have_text(text)\n\nend\n\nend\n\nend\n\nend\n\nend\n\nWe’ll test that our admin images index has columns for the image name, a valid thumbnail image, and a valid HTML <image /> tag. We’ll also test that the image name is displayed as the alt and title attributes of the image in our thumbnail and in our <image /> tag.\n\nWe’re using within blocks to limit our scope to the exact td tags where we expect to ﬁnd things. We need to do it this way because our image name is present as a string in one form or another in all three of the columns we’re testing.\n\nWe are using Capybara’s has_xpath matcher to test that our thumbnail image is displayed on our page as properly rendered HTML. We then use Capybara’s has_text matcher to test that a non-rendered string representation of our <image /> tag is displayed on the page as well. This second version can be used to easily copy and paste the <image /> tag into our Page content later when we’re making new pages.\n\nLet’s run our spec and see what happens:\n\n1) Images index renders images\n\nFailure/Error: visit admin_images_path\n\n169\n\n170\n\n13 Administration\n\nNameError:\n\nundefined local variable or method `admin_images_path'\n\nAs before, the admin route we’re trying to access does not yet exist. We can get the route working by simply adding a new Active Admin ﬁle with a proper ActiveAdmin.register block for our Image model. Let’s do that now. In our app/admin directory, let’s add a new ﬁle called images.rb with the following content:\n\nActiveAdmin.register Image do end\n\nRe-running our spec, we can see that we’ve got our Admin Image routes now, and we have a new failure message:\n\n1) Images index renders images Failure/Error: ...\n\nCapybara::ElementNotFound:\n\nUnable to find css \"td.col-image\"\n\nThis error message is telling us that we’re not able to ﬁnd a td tag with the class col-image . Let’s ﬁx that by adding a custom index block to our ActiveAdmin.register block and a column for our image:\n\nindex do\n\ncolumn 'Image' do |i|\n\nimage_tag image_path(i),\n\nheight: 80, alt: i.name, title: i.name\n\nend\n\nend\n\nWe’re using the Rails image_tag helper and our image_path route to create a thumbnail image with a height of 80 pixels that we can use to preview our full-size image. We’re also using the image name ﬁeld to set the alt and title attributes of our image.\n\nLet’s run our spec again and see what happens:\n\n1) Images index renders images Failure/Error: ...\n\nManaging Images\n\nCapybara::ElementNotFound:\n\nUnable to find css \"td.col-name\"\n\nTo get this failure ﬁxed, we need to add a column for our image name. Let’s do that now:\n\nindex do\n\ncolumn :name column 'Image' do |i|\n\nimage_tag image_path(i),\n\nheight: 80, alt: i.name, title: i.name\n\nend\n\nend\n\nThis moves us to our next failure message:\n\n1) Images index renders images Failure/Error: ...\n\nCapybara::ElementNotFound:\n\nUnable to find css \"td.col-image_tag\"\n\nThis failure message is telling us that we’re not able to ﬁnd a td tag with a CSS class col-image_tag. This is our table column where we want to display our HTML <image /> tag. Let’s add a column; it will be similar to our thumbnail column except that we will display the <image /> tag itself, not a rendered HTML image:\n\ncolumn 'Image Tag' do |i|\n\n\"#{image_tag image_path(i), alt: i.name, title: i.name}\"\n\nend\n\nThis gets our spec passing.\n\nBecause we added a custom index block to our ActiveAdmin.register block, we’ve lost some of the default columns that Active Admin provides: selectable_column, id_column, and actions. Let’s add them back in:\n\nindex do\n\nselectable_column id_column column :name column 'Image' do |i|\n\n171\n\n172\n\n13 Administration\n\nimage_tag image_path(i),\n\nheight: 80, alt: i.name, title: i.name\n\nend column 'Image Tag' do |i|\n\n\"#{image_tag image_path(i), alt: i.name, title: i.name}\"\n\nend actions\n\nend\n\nWe created our spec using a factory for our image. We will also want to be able to upload new images via a regular HTML form.\n\nUploading New Images\n\nOur inclusion of Active Storage into our blog application takes care of the image ﬁle storage work for us; it will use whatever we deﬁned in our storage.yml ﬁle. We just need to add an image upload form to facilitate uploading the image from our local machine to our application.\n\nOur spec to capture our image upload functionality is\n\ndescribe 'new' do\n\nit 'uploads an image' do\n\nvisit new_admin_image_path\n\nfill_in 'Name', with: 'Name' file = Rails.root.join('spec/factories/images/image.jpeg') attach_file 'Image', file click_button 'Create Image'\n\nwithin '.flashes' do\n\nexpect(page).to have_css('.flash_notice',\n\ntext: 'Image was successfully created.')\n\nend\n\nwithin '.image table' do\n\nwithin 'tr.row-name td' do\n\nexpect(page).to have_text(img.name)\n\nend\n\nwithin 'tr.row-image td' do\n\nxpath = <<~IMG.squish\n\n//img[@height='80' and\n\n@alt='#{img.name}' and @title='#{img.name}' and @src='/images/#{img.id}']\n\nIMG expect(page).to have_xpath(xpath)\n\nend\n\nManaging Images\n\nwithin 'tr.row-image_tag td' do\n\ntext = <<~IMG.squish\n\n<img alt=\"#{img.name}\"\n\ntitle=\"#{img.name}\" src=\"/images/#{img.id}\" />\n\nIMG expect(page).to have_text(text)\n\nend\n\nend\n\nend\n\nend\n\nWe want to upload an image and also give it a friendly name for use with our HTML alt and title attributes. We use Capybara’s attach_file helper method to attach our image ﬁle to our form. This mimics navigating to the ﬁle on our local computer and selecting it for upload. We pass the attach_file method the ﬁle path to our image ﬁle using Rails’ .root method as the base of our path.\n\nAfter a successful upload, we expect to see a ﬂash message indicating that our image was successfully created. We also expect to see our image name, thumbnail image, and image tag in our table. These are similar to the expectations we have for our index spec, the major difference being that the CSS class names are mostly on the <tr> tags instead of the <td> tags.\n\nRunning our new spec, we get the following failure message:\n\n1) Images new uploads an image\n\nFailure/Error: attach_file 'Image', file\n\nCapybara::ElementNotFound:\n\nUnable to find file field \"Image\"\n\nOur failure message is telling us that Capybara is unable to ﬁnd an Image ﬁle ﬁeld on our form. Ap- parently, Active Admin doesn’t understand our has_one_attached association we added to our Image model. We can ﬁx this by adding a custom form block to our ActiveAdmin.register block and adding an f.input for our image ﬁeld:\n\nform do |f|\n\nf.inputs do\n\nf.input :name f.input :image\n\nend f.actions\n\nend\n\nAnd since we’re adding a custom form block that overrides Active Admin’s default form block, we need to add our name ﬁeld and the Active Admin actions method also.\n\n173\n\n174\n\n13 Administration\n\nWhen we run our spec again, we get a different failure message:\n\n1) Images new uploads an image\n\nFailure/Error: raise ActiveModel::ForbiddenAttributesError\n\nif !attributes.permitted?\n\nActiveModel::ForbiddenAttributesError:\n\nActiveModel::ForbiddenAttributesError\n\nThis failure message is telling us that we’re trying to pass attributes to our Image model that are not permitted. This is similar to how Rails handles strong parameters in a regular controller. We can ﬁx this by adding the Active Admin equivalent of allowing expected parameters to our ActiveAdmin.register block:\n\npermit_params :name, :image\n\nThis ﬁxes our permitted parameters failure message. We now get a different failure message:\n\n1) Images new uploads an image Failure/Error: ...\n\nCapybara::ElementNotFound:\n\nUnable to find css \"tr.row-image td\"\n\nIn Active Admin, after we successfully create a new record, we are redirected to the show page for that record. To get our spec passing, we need to add a custom show block to our ActiveAdmin.register block and customize the rows, just like how we customized the columns for our index block:\n\nshow do\n\nattributes_table do\n\nrow :name row 'Image' do |i|\n\nimage_tag image_path(i),\n\nheight: 80, alt: i.name, title: i.name\n\nend row 'Image Tag' do |i|\n\n\"#{image_tag image_path(i), alt: i.name, title: i.name}\"\n\nend\n\nend\n\nend\n\nManaging Images\n\nThis gets our spec passing. We can now upload images to our application, and we see an image thumbnail and image tags in our index and show pages. We also created some code duplication in our specs.\n\nFactor Out Our Image Matchers Let’s factor out our thumbnail image and image tag matchers into helper methods:\n\nprivate\n\ndef thumbnail_xpath(img)\n\n<<~IMG.squish\n\n//img[@height='80' and\n\n@alt='#{img.name}' and @title='#{img.name}' and @src='/images/#{img.id}']\n\nIMG\n\nend\n\ndef image_tag_string(img)\n\n<<~IMG.squish\n\n<img alt=\"#{img.name}\"\n\ntitle=\"#{img.name}\" src=\"/images/#{img.id}\" />\n\nIMG\n\nend\n\nThen we can replace the locations in our specs where we were using these matchers within our helper methods, ﬁrst in our index spec:\n\nwithin 'td.col-image' do\n\nexpect(page).to have_xpath(thumbnail_xpath(img))\n\nend\n\nwithin 'td.col-image_tag' do\n\nexpect(page).to have_text(image_tag_string(img))\n\nend\n\nAnd then also in our show spec:\n\nwithin 'tr.row-image td' do\n\nexpect(page).to have_xpath(thumbnail_xpath(img))\n\nend\n\nwithin 'tr.row-image_tag td' do\n\nexpect(page).to have_text(image_tag_string(img))\n\nend\n\n175",
      "page_number": 173
    },
    {
      "number": 19,
      "title": "Segment 19 (pages 182-189)",
      "start_page": 182,
      "end_page": 189,
      "detection_method": "topic_boundary",
      "content": "176\n\n13 Administration\n\nWe can undoubtedly factor things down further, but we risk making things harder to understand and more difﬁcult to work on in the future. There is a balance to be had between reducing code duplication and making things too abstract. You’ll ﬁnd that balance for yourself, or with your team, the more code you write.\n\nWe can now upload images into our application. We will obviously want to be able to modify our\n\nimages too.\n\nEditing Images\n\nAs far as our Active Admin code is concerned, modifying images is very similar to creating images. Our ActiveAdmin.register block will use our existing custom form and show blocks when adding new or editing existing image uploads.\n\nLet’s add a spec for editing an image:\n\ndescribe 'edit' do\n\nlet(:name) { 'New Name' }\n\nbefore do\n\ncreate(:image)\n\nend\n\nit 'updates an image' do\n\nvisit edit_admin_image_path(img)\n\nwithin 'form.image' do\n\nwithin '.inline-hints' do\n\nexpect(page).to have_xpath(thumbnail_xpath(img))\n\nend\n\nend\n\nfill_in 'Name', with: name file = Rails.root.join('spec/factories/images/image.jpeg') attach_file 'Image', file click_button 'Update Image'\n\nwithin '.flashes' do\n\nexpect(page).to have_css('.flash_notice',\n\ntext: 'Image was successfully updated.')\n\nend\n\nimg.reload\n\nwithin '.image table' do\n\nwithin 'tr.row-name td' do\n\nexpect(page).to have_text(name)\n\nend\n\nwithin 'tr.row-image td' do\n\nexpect(page).to have_xpath(thumbnail_xpath(img))\n\nend\n\nManaging Images\n\nwithin 'tr.row-image_tag td' do\n\nexpect(page).to have_text(image_tag_string(img))\n\nend\n\nend\n\nend\n\nend\n\nWe ﬁrst create an image record in our database using our image factory. We don’t need to assign the created image to a local variable because we can use the img from our let at the top of our ﬁle, where it gets the last image created.\n\nNext, we visit the edit page for our image. On the page, we expect to see a thumbnail of our image. This isn’t strictly necessary, but it’s a good sanity check to make sure we’re on the right page and that we’re about to modify the image that we mean to modify. We then ﬁll in the name ﬁeld with our new name. We’ve created this static name string in a let block so that we can use it in multiple places in our spec, and additionally if we change it later, then we only need to modify a single code location.\n\nWe then attach a new image ﬁle to our form. We again use the attach_file method. We click\n\nthe Update Image button and check for our success message.\n\nIf everything has gone as planned, we next need to reload our image record from our database. This is because Active Admin will have updated our image record in our database, but our local img variable will still be pointing to the old record, with the old name and image data. We then check that our show page has our new image name and that our image thumbnail and image tag are both correct.\n\nRunning this spec gives us a failure message:\n\n1) Images edit updates an image Failure/Error:\n\nwithin '.inline-hints' do\n\nexpect(page).to have_xpath(thumbnail_xpath(img))\n\nend\n\nCapybara::ElementNotFound:\n\nUnable to find css \".inline-hints\"\n\nThis is failing because we haven’t added any code to our form block to display the image thumbnail. Active Admin has the concept of a form ﬁeld hint which can be whatever we would like to display below our form ﬁeld. We just need to add a hint option to our f.input image ﬁeld:\n\nform do |f|\n\nhint = image_tag image_path(f.object),\n\nheight: 80, alt: f.object.name, title: f.object.name\n\ninputs do\n\nf.input :name f.input :image, as: :file, hint:\n\n177\n\n178\n\n13 Administration\n\nend f.actions\n\nend\n\nThis will display our image thumbnail below our image ﬁeld in our form. We can run our spec again and see that it passes. We can also see when we run our previous specs that we broke one of them:\n\n1) Images new uploads an image Failure/Error:\n\nhint = image_tag image_path(f.object),\n\nheight: 80, alt: f.object.name, title: f.object.name\n\nActionView::Template::Error:\n\nNo route matches {:action=>\"show\", :controller=>\"images\",\n\n:id=>nil}, missing required keys: [:id]\n\nWhat happened? Well, remember that when we render our Active Admin image upload form, it’s the same form ﬁelds for both our new and edit routes; the only differences are our <form> attributes. This means the hint we have created is trying to display a thumbnail of an image that doesn’t exist yet in our database and therefore does not yet have an id assigned. The evidence is in the error message, where we see the id parameter is set to nil:\n\nNo route matches {:action=>\"show\", :controller=>\"images\", :id=>nil}\n\nWe can ﬁx this by adding a conditional sufﬁx to our hint:\n\nhint = image_tag image_path(f.object),\n\nheight: 80, alt: f.object.name, title: f.object.name if f.object.persisted?\n\nSo now we can support both scenarios, when we have an image that already exists in our database and also when we are creating a new image. We have also created more code duplication. Time to refactor.\n\nFactor Out Duplicate Expectations Two of our specs now have the same show page expectations. We can factor them out into a shared method. We also have the option of using a shared example group, but for this small amount of code,\n\nManaging Images\n\nit’s probably not worth the complexity and additional indirection that it would introduce for our future selves. Let’s add a method to our spec:\n\nprivate\n\ndef validate_show_page(img) within '.image table' do\n\nwithin 'tr.row-name td' do\n\nexpect(page).to have_text(img.name)\n\nend\n\nwithin 'tr.row-image td' do\n\nexpect(page).to have_xpath(thumbnail_xpath(img))\n\nend\n\nwithin 'tr.row-image_tag td' do\n\nexpect(page).to have_text(image_tag_string(img))\n\nend\n\nend\n\nend\n\nWe can then replace our duplicate code in our new spec:\n\ndescribe 'new' do\n\nit 'uploads an image' do\n\n... within '.flashes' do\n\nexpect(page).to have_css('.flash_notice',\n\ntext: 'Image was successfully created.')\n\nend\n\nvalidate_show_page(img)\n\nend\n\nend\n\nAnd also in our edit spec:\n\ndescribe 'edit' do\n\nlet(:name) { 'New Name' }\n\nbefore do\n\ncreate(:image)\n\nend\n\nit 'updates an image' do\n\n... img.reload\n\n179\n\n180\n\n13 Administration\n\nvalidate_show_page(img)\n\nend\n\nend\n\nIf you like, you can also factor out our image ﬁle path into a small helper method:\n\nprivate\n\ndef file_path\n\nRails.root.join('spec/factories/images/image.jpeg')\n\nend\n\nDeleting Images\n\nI’ve found through experience supporting users that building ways to delete data into an application isn’t always a good idea. Just as soon as you provide this functionality, someone will use it accidentally, and then you’ll have to spend time restoring the deleted data from backups or creating it brand new again if you don’t yet have backups.\n\nYou are creating backups, right? However you work this out with your own data, in our case we’re going to embrace our Active Admin delete functionality, mostly because it’s a good learning experience. We’ll encounter the need to conﬁrm a destructive action with Capybara, so that will be fun.\n\nLet’s add a spec for deleting an image. The delete functionality and link is already built into Active Admin and is already present on our index page as well as our show page. We just need to add a spec to test it. I would imagine most image deletions will take place from the index page, so let’s add our spec there inside our existing describe ’index’ block:\n\nit 'deletes an image' do\n\nvisit admin_images_path\n\naccept_confirm do\n\nclick_link 'Delete'\n\nend\n\nwithin '.flashes' do\n\nexpect(page).to have_css('.flash_notice',\n\ntext: 'Image was successfully destroyed.')\n\nend\n\nend\n\nThe exciting thing here is the accept_confirm method. This is a Capybara helper method that wraps our click_link call and will accept the resulting conﬁrmation dialog that is displayed. We can run our spec and see that it passes and that we do get a success message.\n\nManaging Images\n\nFigure 13-2 Active Admin image ﬁlters\n\nAdmin Filters\n\nActive Admin provides ﬁlters to search our data on the index page for any type of record we register. This is great except that the default ﬁltering includes all of our ﬁelds, which is not always desirable. For example, right now, on our Images page we have the ﬁlters shown in Figure 13-2 available and turned on by default.\n\nWe can conﬁgure which ﬁelds are available for ﬁltering by adding filter entries. So if we wanted to get rid of the image attachment ﬁlter and the image blob ﬁlters, we could do this by adding only the ﬁlters that we do want to be present into our ActiveAdmin.register block:\n\nActiveAdmin.register Image do\n\nfilter :name filter :created_at filter :updated_at ...\n\nend\n\nIf we have a lot of default ﬁlters that we do want to keep and only a few that we want to remove, we can instead use the different Active Admin remove_filter syntax:\n\nActiveAdmin.register Image do\n\nremove_filter :image_blob, :image_attachment\n\n# other code not shown for brevity\n\nend\n\n181\n\n182\n\n13 Administration\n\nFigure 13-3 Fewer Active Admin image ﬁlters\n\nEither of these options will result in only the ﬁlters we want to be available on our index page to appear, as shown in Figure 13-3.\n\nLet’s also remove an unnecessary ﬁlter from our Pages admin page:\n\nremove_filter :page_tags\n\nWe would never ﬁlter pages by join table data, so this makes sense.\n\nOur Active Admin ﬁlter customizations are minimal, so we will not write any specs for them. It’s also highly unlikely we will remove the name, created_at , or updated_at ﬁelds from our image table anytime soon. Feel free to add specs for your own blog application ﬁlters if you like.\n\nManaging Users\n\nWe’ve now seen how to manage our Image and Page models with Active Admin. Now we’ll see how to manage our User model. The main functionality this addition provides is the ability to create users and then be able to update their passwords and email addresses. You may not ﬁnd this useful as a single administrator for a one-user blog application, but this will likely be the smallest Rails application you ever work on in your entire software engineering career, hopefully.\n\nAdding New Users\n\nLet’s add a spec for creating a new user. We’ll add this new spec into a new ﬁle called users_spec.rb located in our spec/system/admin directory:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Users' do\n\nlet(:user) { create(:user) }\n\nbefore do\n\nManaging Users\n\nlogin_as(user)\n\nend\n\ndescribe 'A new user' do it 'can be added' do\n\nvisit new_admin_user_path\n\nfill_in 'Name', with: 'Foo Bar' fill_in 'Email', with: 'foo@bar.com' fill_in 'user[password]', with: 'changeme' fill_in 'user[password_confirmation]', with: 'changeme'\n\nclick_button 'Create User'\n\nwithin '.flashes' do\n\ntext = 'User was successfully created.' expect(page).to have_css('.flash_notice', text:)\n\nend\n\nwithin '#main_content' do\n\nexpect(page).to have_css('td', text: 'Foo Bar') expect(page).to have_css('td', text: 'foo@bar.com')\n\nend\n\nend\n\nend\n\nend\n\nThere are no real surprises here. The only remarkable change from our previous Active Admin specs is that we cannot use fill_in with the HTML label of Password because given that we will also have a Password Conﬁrmation ﬁeld label on the form, the Password label is not unique. Instead, we have to use the HTML names of our ﬁelds, which are user[password] and user[password_confirmation].\n\nWhen we run this spec, we see that it fails:\n\n1) Users A new user can be added\n\nFailure/Error: visit new_admin_user_path\n\nNameError:\n\nundefined local variable or method `new_admin_user_path'\n\nThe failure message indicates that we need to add a route for our new user path. We can do that by creating a new ﬁle called users.rb in our app/admin directory:\n\nActiveAdmin.register User do end\n\n183",
      "page_number": 182
    },
    {
      "number": 20,
      "title": "Segment 20 (pages 190-198)",
      "start_page": 190,
      "end_page": 198,
      "detection_method": "topic_boundary",
      "content": "184\n\n13 Administration\n\nThis gets us our route and moves us on to our next failure:\n\n1) Users A new user can be added\n\nFailure/Error: fill_in 'user[password]', with: 'changeme'\n\nCapybara::ElementNotFound:\n\nUnable to find field \"user[password]\" that is not disabled\n\nThis may seem confusing at ﬁrst; we can set the password ﬁeld in our User model, and we already have specs that prove it. The problem is that Active Admin does not automatically include attributes, and recalling back to our User model, our password attribute is not an actual ﬁeld in our database, it is an attr_reader.\n\nWe can ﬁx this by overriding the default form method in our Active Admin User registration\n\nblock:\n\nActiveAdmin.register User do\n\nform do |f|\n\nf.semantic_errors inputs do\n\nf.input :name f.input :email f.input :password f.input :password_confirmation\n\nend f.actions\n\nend\n\nend\n\nRemember, if we override our form block, we have to add all the ﬁelds we want to be included in the form, so we’re adding our password and password_confirmation ﬁelds as well as our name and email ﬁelds. We can now run our spec again and see that we have a new failure:\n\n1) Users A new user can be added\n\nFailure/Error: raise ActiveModel::ForbiddenAttributesError if !attributes.permitted?\n\nActiveModel::ForbiddenAttributesError:\n\nActiveModel::ForbiddenAttributesError\n\nWe’ve seen this error message before. It means that we have not yet permitted our submitted form parameters. We can ﬁx this error by adding them:\n\npermit_params :name,\n\n:email,\n\nManaging Users\n\n:password, :password_confirmation\n\nThis gets our spec to pass. We can now add a spec for updating an existing user record:\n\ndescribe 'An existing user' do\n\nit 'can be updated' do\n\nvisit admin_users_path\n\nclick_link 'Edit'\n\nexpect(page).to have_field('user_name', with: user.name) expect(page).to have_field('user_email', with: user.email)\n\nfill_in 'Name', with: 'Bar Baz' fill_in 'Email', with: 'bar@baz.com' fill_in 'user[password]', with: 'change_me' fill_in 'user[password_confirmation]', with: 'change_me'\n\nclick_button('Update User')\n\nwithin '.flashes' do\n\ntext = 'User was successfully updated.' expect(page).to have_css('.flash_notice', text:)\n\nend\n\nwithin '#main_content' do\n\nexpect(page).to have_css('td', text: 'Bar Baz') expect(page).to have_css('td', text: 'bar@baz.com')\n\nend\n\nend\n\nend\n\nThis spec passes with no changes. We’re reusing the same form and parameters as we did for creating a new user, so we don’t need to make any changes to our Active Admin registration block. Normally, I would never trust a spec that I didn’t see fail at least once, but this spec is very simple, and it reuses the same patterns we’ve seen work in other specs, so I’m going to trust it.\n\nDeleting Users\n\nSince we can add and edit users, we should add a spec for deleting users too:\n\nit 'can be deleted' do\n\nvisit admin_users_path\n\naccept_confirm do\n\nclick_link 'Delete'\n\n185\n\n186\n\n13 Administration\n\nend\n\nwithin '.flashes' do\n\nexpect(page).to have_css('.flash_notice',\n\ntext: 'User was successfully destroyed.')\n\nend\n\nend\n\nThis spec also passes with no changes to our Active Admin registration block. Similar to before, this spec is again very simple, and it reuses the same patterns we’ve seen work in other specs, so I’m again going to trust it.\n\nRight now, our index and show pages are displaying all of our user attributes, including our password_salt and password_hash ﬁelds. Displaying these ﬁelds is not useful, so let’s remove them by overriding our index and show blocks with just the ﬁelds we do want to display:\n\nindex do\n\nselectable_column id_column column :name column :email actions\n\nend\n\nshow do\n\nattributes_table do\n\nrow :name row :email\n\nend\n\nend\n\nOur user ﬁlter block is also displaying all of our user attributes, so let’s remove the password_salt and password_hash ﬁelds from there too.\n\nremove_filter :password_salt, :password_hash\n\nSummary\n\nThis concludes our Active Admin chapter. I’ve shown enough of the basics to get you started with specs for your own Active Admin implementations. You probably want to add an Active Admin interface for managing page tags as well. I’m going to leave that as a TDD exercise for you to complete on your own.\n\nOdds and Ends\n\n14\n\nThis chapter will cover some additions and enhancements to our existing work:\n\n1. Build a sitemap 2. Add pagination for our blog entries 3. Add CSS styling 4. Add syntax highlighting for code blocks\n\nBuild a Sitemap\n\nA sitemap isn’t a hard requirement for a website, but it is a good idea to have one. A sitemap is a URL endpoint, usually living at /sitemap.xml, that is available through a GET request and that lists all of the other URL endpoints on the website. A sitemap helps search engines ﬁnd all of the pages in the website more easily compared to doing a full website crawl. For a large website, it can also help the search engine understand the hierarchical structure.\n\nLet’s add a sitemap to our blog application. To start with, we will add a request spec that will request the /sitemap.xml and verify that it is returning a valid XML response. Let’s add the following to our spec/requests/home_spec.rb ﬁle:\n\ndescribe 'GET /sitemap' do\n\nit 'returns http success' do\n\nget sitemap_path(format: :xml) expect(response).to be_successful\n\nend\n\nend\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_14\n\n187\n\n188\n\n14 Odds and Ends\n\nRunning this spec will result in a failure message because we don’t yet have a route for /sitemap.xml:\n\n1) Home Page GET /sitemap returns http success Failure/Error: get sitemap_path(format: :xml)\n\nNoMethodError:\n\nundefined method `sitemap_path'\n\nLet’s add a route for this URL in our config/routes.rb ﬁle:\n\nget 'sitemap', to: 'home#sitemap'\n\nRe-running our spec moves us to our next error message:\n\n1) Home Page GET /sitemap returns http success Failure/Error: get sitemap_path(format: :xml)\n\nAbstractController::ActionNotFound:\n\nThe action 'sitemap' could not be found for HomeController\n\nAs suggested by the error message, let’s add a sitemap action to our HomeController:\n\ndef sitemap end\n\nThis gets our new request spec to pass. Next, we should parse the XML response and verify that it contains our expected URLs. We can use Nokogiri to parse our XML response body and collect the URL paths into an array, then we can easily check the contents of the array for known URL paths.\n\nBefore we pursue this, we should consider the XML structure of our sitemap and what it should\n\nlook like. We can ﬁnd the standard XML structure for a sitemap published online at\n\nwww.sitemaps.org/protocol.html Notice the <url> and <loc> are required ﬁelds. There are other optional ﬁelds available, but we will stick with just the required ﬁelds for now. Our generated XML should look something like this:\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"> <url>\n\n<loc>http://www.example.com/</loc>\n\n</url> </urlset>\n\nBuild a Sitemap\n\nLet’s update our spec to parse the XML response and verify that it contains our expected URL paths:\n\ndescribe 'GET /sitemap' do\n\nlet(:tag) { create(:tag) } let!(:page) do\n\ncreate(\n\n:page, :published, tags: [tag], created_at: '2023-02-19'\n\n) end\n\nit 'returns http success' do\n\nget sitemap_path(format: :xml) expect(response).to be_successful\n\ndoc = Nokogiri::XML(response.body) urls = doc.css('loc').collect(&:text) paths = urls.map{ |url| URI.parse(url).path }\n\nexpect(paths).to include(page_path(slug: page.slug))\n\nend\n\nend\n\nWe’re using the Nokogiri::XML method to parse the XML response body of our request into a Nokogiri document object. We then use the doc’s css method to ﬁnd all of the <loc> elements and collect the URL (via the text ﬁeld) of each <loc> element into an array. We then map over the array of URLs and extract the path portion of each URL using URI.parse. Finally, we can check that the array of paths includes the path for our page object we created using our let!.\n\nWhen we run this spec, we get the following error message:\n\nFailures:\n\n1) Home Page GET /sitemap returns http success\n\nFailure/Error: expect(paths).to include(page_path ...\n\nexpected [] to include \"/page/page-title-1\"\n\nIt looks like our paths array is empty, which makes sense because we have not yet implemented an ERB template for our HomeController sitemap action. Let’s add an ERB template named sitemap.xml.erb in our app/views/home directory and add the following code to it:\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"> <% Page.published.ordered.each do |p| -%> <url>\n\n<loc><%= \"http://127.0.0.1:3000/page/#{p.slug}\" %></loc>\n\n189\n\n190\n\n14 Odds and Ends\n\n</url> <% end -%> </urlset>\n\nThis will generate sitemap XML that contains a <url> element for each published page in our database. We can now run our spec and see that it passes.\n\nWe probably do not want to hard-code the domain name and port number in our sitemap XML template. We should instead make it read from an environment variable and have a default value for when the environment variable is not set. Let’s add this to our sitemap action in our HomeController:\n\ndef sitemap\n\n@url = ENV['BASE_URL'] || 'http://localhost:3000'\n\nend\n\nThen we can update our ERB template to use our new @url instance variable:\n\n<% Page.published.ordered.each do |p| -%> <url>\n\n<loc><%= \"#{@url}/page/#{p.slug}\" %></loc>\n\n</url> <% end -%>\n\nRe-running our spec, we can see that it still passes. We of course need to make sure to set our new environment variable in our production environment, so don’t forget!\n\nLet’s now add another expectation for our Tag URLs:\n\nexpect(paths).to include(tag_path(name: tag.name))\n\nThis fails as expected:\n\nFailures:\n\n1) Home Page GET /sitemap returns http success\n\nFailure/Error: expect(paths).to include(tag_path(name: tag.name))\n\nexpected [\"/page/page-title-1\"] to include \"/tag/name-1\"\n\nBuild a Sitemap\n\nWe can ﬁx this error by adding a <url> element for each tag in our sitemap XML:\n\n<% Tag.all.each do |t| -%> <url>\n\n<loc><%= \"#{@url}/tag/#{t.name}\" %></loc>\n\n</url> <% end -%>\n\nThis gets our request spec back to passing.\n\nThe last thing we will add to our spec is an expectation for our sidebar archive links:\n\nexpect(paths).to include('/search/2023/02')\n\nThis fails as expected:\n\nFailures:\n\n1) Home Page GET /sitemap returns http success\n\nFailure/Error: expect(paths).to include('/search/2023/02')\n\nexpected [\"/page/page-title-1\", \"/tag/name-1\"] to include \"/search/2023/02\"\n\nWe can ﬁx this error by adding a <url> element for each archive link in our sitemap XML:\n\n<% Page.month_year_list.each do |i| %> <url>\n\n<loc>\n\n<%= \"#{@url}/search/#{i['year']}/#{i['month_number']}\" %>\n\n</loc>\n\n</url> <% end %>\n\nThis gets our request spec back to passing. We can now do a bit of cleanup by moving our local variables into let statements:\n\ndescribe 'GET /sitemap' do\n\nlet(:doc) { Nokogiri::XML(response.body) } let(:urls) { doc.css('loc').collect(&:text) } let(:paths) { urls.map{ |url| URI.parse(url).path } } let(:tag) { create(:tag) } let!(:page) do\n\ncreate(\n\n:page,\n\n191\n\n192\n\n14 Odds and Ends\n\n:published, tags: [tag], created_at: '2023-02-19'\n\n) end\n\nit 'returns http success' do\n\nget sitemap_path(format: :xml) expect(response).to be_successful\n\nexpect(paths).to include(page_path(slug: page.slug)) expect(paths).to include(tag_path(name: tag.name)) expect(paths).to include('/search/2023/02')\n\nend\n\nend\n\nWe should re-run our spec to make sure it still passes.\n\nPagination\n\nOnce we have more than a handful of pages, we will want to add pagination. Pagination will allow our homepage to load faster, and our back-end database will not have to load as many records all at once for a given request. This will also be true for our tag pages and our search results pages.\n\nInstead of inventing pagination from scratch, we will use the Kaminari gem. Kaminari is a pagination gem that is very easy to use and has a lot of options for customizing the look and feel of the pagination links.\n\nLet’s add the Kaminari gem to our Gemfile:\n\ngem 'kaminari', '~> 1.2.2'\n\nAnd then let’s run the bundle command to install it:\n\nbundle\n\nKaminari has a lot of options for customizing the look and feel of the pagination links. We can generate an initializer ﬁle for Kaminari, which contains all of the default options and values, by running the following command:\n\nbe rails g kaminari:config",
      "page_number": 190
    },
    {
      "number": 21,
      "title": "Segment 21 (pages 199-206)",
      "start_page": 199,
      "end_page": 206,
      "detection_method": "topic_boundary",
      "content": "Pagination\n\nWe can then update the generated initializer ﬁle kaminari_config.rb values to our liking:\n\n# config/initializers/kaminari_config.rb\n\nKaminari.configure do |config|\n\n# config.default_per_page = 25 # config.max_per_page = nil # config.window = 4 # config.outer_window = 0 # config.left = 0 # config.right = 0 # config.page_method_name = :page # config.param_name = :page # config.max_pages = nil # config.params_on_first_page = false\n\nend\n\nThe defaults are ﬁne for our purposes, so we will leave them as is for now.\n\nNow that we have Kaminari installed, we can add pagination to our blog application. Thinking through it, we will want pagination on any page that displays a list of Page objects, so let’s start with our homepage. We ﬁrst need a spec to test the pagination functionality. Let’s add the following to our spec/system/home_spec.rb ﬁle:\n\ndescribe 'pagination' do\n\ncontext 'with many pages' do\n\nit 'paginates' do\n\ncreate_list(:page, 26, :published)\n\nvisit root_path\n\narticles = find_all('article') expect(articles.size).to eq(25) expect(page).to have_link('Next')\n\nend\n\nend\n\nend\n\nWe begin this spec by calling FactoryBot’s create_list method to create 26 published Page objects. This number of Page objects is just enough to trigger pagination to render since we have the Kaminari default_per_page set to 25 items per page. We then visit the homepage and expect to see exactly 25 Page objects (instead of 26). We then expect to ﬁnd a “Next” link on the page. This will prove our pagination is being rendered on the homepage as expected.\n\n193\n\n194\n\n14 Odds and Ends\n\nWhen we run our spec, we get the following error:\n\n1) Home pagination with many pages paginates Failure/Error: expect(articles.size).to eq(25)\n\nexpected: 25 got: 26\n\nTo ﬁx this error, we need to add a .page call to our ActiveRecord query in our HomeController index method where we assign our @pages object. Let’s update it to look like this:\n\ndef index\n\n@pages = Page.published.ordered.page(params[:page])\n\nend\n\nWhen we re-run our spec, we get a new error message:\n\n1) Home pagination with many pages paginates Failure/Error: expect(page).to have_link('Next')\n\nexpected to find link \"Next\" but there were no matches\n\nTo ﬁx this error, we need to add the pagination links to our homepage. You may recall that our Page objects are rendered in our shared partial template called _pages.html.erb residing in our app/views/shared directory.\n\nLet’s modify our partial to add a call to Kaminari’s paginate method at the bottom of the page\n\nto render our pagination links:\n\n<% pages.each do |page| %>\n\n<%= render partial: 'shared/page',\n\nlocals: {\n\npage: page, content: page.summary\n\n} %>\n\n<% end %>\n\n<%= paginate pages %>\n\nThis gets our spec passing, and this is good, but we can do better.\n\nDo we really need 26 Page objects to test our pagination? If we think about it, we really only need a few Page objects to test pagination. We need a couple of Page objects to render on our ﬁrst page to exercise our render loop and then one more Page object to trigger pagination to render. Let’s update our spec to only create three Page objects:\n\nPagination\n\nit 'paginates' do\n\ncreate_list(:page, 3, :published)\n\nvisit root_path\n\narticles = find_all('article') expect(articles.size).to eq(2) expect(page).to have_link('Next')\n\nend\n\nThis fails with the following error:\n\n1) Home pagination with many pages paginates Failure/Error: expect(articles.size).to eq(2)\n\nexpected: 2 got: 3\n\nNow we need to adjust our Kaminari initializer conﬁguration to render only one Page object per page and only when we are running a spec. We can accomplish this by adding a conditional to our initializer ﬁle, to look at our Rails.env value and set our default_per_page to only 2 when we are in our test environment:\n\nconfig.default_per_page = Rails.env.test? ? 2 : 25\n\nThis gets our spec passing again. Our system spec for our tags also needs to be updated to use pagination. Let’s add a tag spec into our spec/system/tag_spec.rb ﬁle to test pagination:\n\ndescribe 'pagination' do\n\ncontext 'with many tagged pages' do\n\nit 'paginates' do\n\ntag = create(:tag) create_list(:page, 3, :published) Page.all.each { |page| page.tags << tag }\n\nvisit tag_path(name: tag.name)\n\narticles = find_all('article') expect(articles.size).to eq(2) expect(page).to have_link('Next')\n\nend\n\nend\n\nend\n\n195\n\n196\n\n14 Odds and Ends\n\nThis spec is very similar to the one we added to our homepage spec. We create a Tag object and then create three Page objects with our new tag assigned to each one. We then visit our tag show page and expect to see two Page objects and our “Next” link rendered.\n\nWhen we run our new spec, we get the error:\n\nFailure/Error: visit tag_path(name: tag.name)\n\nActionController::UrlGenerationError:\n\nNo route matches {:action=>\"show\", :controller=>\"tags\", ...\n\nThis error is telling us that we need to add a route. We need to add our Tag show action route. Let’s modify our config/routes.rb ﬁle to add this:\n\nget 'tag/:name', to: 'tags#show', name: /[-a-z0-9_+]*/, as: :tag\n\nThis update moves us to our next error. When we run our spec again, we get\n\n1) Tag displays clickable tags on a page Failure/Error: <%= paginate pages %>\n\nActionView::Template::Error:\n\nundefined method `total_pages'\n\nThis error message may seem a bit cryptic at ﬁrst, but we can assume the call to paginate is failing because we are not passing a Kaminari-like page object. We need to update our TagsController show method to call Kaminari’s page method when we are retrieving our Page objects. Let’s update our show method to look like this:\n\ndef show\n\ntag = Tag.find_by(name: params[:name]) redirect_to root_path and return unless tag\n\n@pages = tag.pages.published.ordered.page(params[:page])\n\nend\n\nThis gets our spec passing.\n\nThe last bit of pagination we need to add is with our search. Let’s add a spec to our\n\nspec/system/search_spec.rb ﬁle to test search results pagination:\n\ndescribe 'pagination' do\n\ncontext 'with many search result pages' do\n\nit 'paginates' do\n\nPagination\n\ncreate_list(:page, 3, :published, content: 'foo bar baz')\n\nvisit search_path(term: 'foo')\n\narticles = find_all('article') expect(articles.size).to eq(2) expect(page).to have_link('Next')\n\nend\n\nend\n\nend\n\nThis spec fails in the same way as our tag spec:\n\n1) Search Searching with a search term renders search results Failure/Error: <%= paginate pages %>\n\nActionView::Template::Error:\n\nundefined method `total_pages'\n\nThe update for this failure is not going to be in the same location as with our previous controller updates. For searching, we use our PageSearch service class, so the ﬁx will be in there instead of in our SearchController ﬁle. Let’s update our PageSearch class to add our page call:\n\ndef self.search(params)\n\nreturn [] unless params.present?\n\npages = if params[:year].present? && params[:month].present?\n\nPage.by_year_month(params[:year], params[:month])\n\nelsif params[:term].present?\n\nPage.by_term(params[:term])\n\nend\n\nreturn [] unless pages\n\npages.published.ordered.page(params[:page])\n\nend\n\nThis gets our spec passing. The reason we can’t put the ﬁx in the controller is because we sometimes return an empty array from our search method. An empty array does not respond to the page method, so we need to put the ﬁx where we are returning actual ActiveRecord Page objects.\n\nWe could change our two early returns to use Page.none instead of returning an empty array, then we could put our page call in our controller. This is a matter of personal preference, so feel free to pursue that option if you like.\n\n197\n\n198\n\n14 Odds and Ends\n\nFixing Specs\n\nIf we run our entire test suite now:\n\nbe rspec\n\nwe will see that our spec ﬁle index.html.erb_spec.rb located in our spec/views/home directory is failing:\n\n1) home/index renders the page object Failure/Error: <%= paginate pages %>\n\nActionView::Template::Error:\n\nundefined method `total_pages'\n\nThis is similar to our other pagination-related spec failures. We need to update our failing view spec to assign a properly paginated Page object, instead of an array. This will give us access to the total_pages method our view is trying, and failing, to call.\n\nLet’s update our spec to look like this:\n\nrequire 'rails_helper'\n\nRSpec.describe 'home/index', type: :view do\n\nlet!(:page) { create(:page) }\n\nit 'renders the page object' do assign(:pages, Page.page(1)) render expect(rendered).to have_css('h2', text: page.title) expect(rendered).to have_css('p', text: page.created_at.to_fs) expect(rendered).to include(page.summary)\n\nend\n\nend\n\nThe main change here is that we are now assigning a paginated Page object to our view instead of an array, but we also have to change our let to a let! that uses a create so that it is created before we perform our pagination .page call.\n\nIf we run our spec now, we will see that it is passing.\n\nStyling\n\nStyling\n\nWithout a doubt, we’ve paid very little attention to styling our application up to now. We now have a fully functioning application, so we can work to improve its appearance. As before, we are going to continue to use the Bootstrap CSS framework we installed previously.\n\nCSS in Rails\n\nWhen we generated our application using the rails new command, we passed in the option --css=bootstrap to choose Bootstrap as our CSS framework. This option caused our main application.scss ﬁle to be generated with the name application.boostrap.scss . I ﬁnd having this longer ﬁlename serves no real purpose, and I prefer to rename it back to just the default application.scss ﬁlename. Let’s do that now:\n\nmv app/assets/stylesheets/application.bootstrap.scss \\\n\napp/assets/stylesheets/application.scss\n\nRenaming our application.scss ﬁle requires we also update the name in our package.json ﬁle. You might use a sed command to do this:\n\nsed -i '' 's/\\.bootstrap//g' package.json\n\nOr just open our package.json ﬁle and change it manually.\n\nStyling Our Public Pages\n\nFirst, let’s add styling to our _header.html.erb ﬁle, located in our app/views/shared directory. Let’s add additional padding on the top and left side of our <header> container, using ps-1 and pt-1 to bring it down and to the right a bit. Right now, our link in our <h1> tag is underlined, so let’s remove that by adding the text-decoration-none class.\n\nOur updated ﬁle will look like this:\n\n<header class=\"ps-1 pt-1\">\n\n<h1>\n\n<%= link_to 'My Blog', root_path,\n\nclass: 'text-decoration-none' %>\n\n</h1> </header>\n\nNow our header looks like Figure 14-1.\n\n199\n\n200\n\n14 Odds and Ends\n\nFigure 14-1 Header CSS\n\nFigure 14-2 Page summary CSS\n\nNext, let’s add CSS styling to our _page.html.erb partial, located in our app/views/ shared directory. Let’s give our <article> tag the card class, which will give it a rounded gray border as shown in Figure 14-2, and the p-3 and mb-3 classes to give it a bit of inner padding and bottom margin. Our updated ﬁle will look like this:\n\n<article class=\"card p-3 mb-3\">\n\n<h2><%= link_to page.title, page_path(slug: page.slug) %></h2> <p><%= page.created_at.to_fs %></p> <%= content.html_safe %> <p><%= tag_links(page.tags).html_safe %></p>\n\n</article>\n\nWhen we search our blog entries and get no results, we are rendering a “No results found” message in our index.html.erb ﬁle, found in our app/views/search directory. It’s currently a bit tight against the left side of our page. Let’s add the ps-2 class to give it more padding on the left side, as shown in Figure 14-3.",
      "page_number": 199
    },
    {
      "number": 22,
      "title": "Segment 22 (pages 207-215)",
      "start_page": 207,
      "end_page": 215,
      "detection_method": "topic_boundary",
      "content": "Styling\n\nFigure 14-3 No search results CSS\n\nFigure 14-4 Search form CSS\n\n<% if @pages&.any? %>\n\n<%= render partial: 'shared/pages', locals: { pages: @pages } %>\n\n<% else %>\n\n<p class=\"ps-2\">No results found</p>\n\n<% end %>\n\nNow let’s turn our attention to the sidebar section of our blog. First, let’s add CSS styling to our _search_form.html.erb ﬁle, located in our app/views/shared directory. Let’s join our search term text ﬁeld and our search button together by adding the input-group class to our <div> container they live in. We also need to add the form-control class to our search term text ﬁeld itself. And then let’s also add the btn and btn-primary classes to our search button as shown in Figure 14-4. Our updated ﬁle will look like this:\n\n<div>\n\n<%= form_for(:search, url: search_path, method: :get) do %>\n\n<div class=\"input-group\">\n\n<input type=\"search\" name=\"term\" class=\"form-control\" /> <input type=\"submit\" value=\"Search\" class=\"btn btn-primary\" />\n\n</div> <% end %>\n\n</div>\n\nJust below our search form, we have our Archives section which lives in our _archives.html. erb ﬁle in our app/views/shared directory. Like we did with our blog entries’ <article> tag, let’s add the card class to give it the same rounded gray border. Let’s also add the p-3 class to give it some inner padding and the mt-3 class to give it some top margin, to push it down a bit from our search form.\n\nOur archive list is currently decorated with the default list dots that are by default rendered with a <ul> tag. Let’s remove those dots by adding the list-unstyled class to our <ul> tag. Let’s also add the pt-1 class to our <li> tags to give them a bit of top padding, to push them down from each other, as shown in Figure 14-5.\n\n201\n\n202\n\n14 Odds and Ends\n\nFigure 14-5 Archive list CSS\n\nOur updated ﬁle will look like this:\n\n<div class=\"card p-3 mt-3\">\n\n<h4>Archives</h4> <ul class=\"list-unstyled\"> <% Page.month_year_list.each do |item| %>\n\n<li class=\"pt-1\">\n\n<%= link_to \"#{item['month_name'] } #{item['year']}\",\n\n\"/search/#{item['year']}/#{item['month_number']}\" %>\n\n</li> <% end %> </ul>\n\n</div>\n\nThe next bit of styling we will do is to our pagination links. Given the popularity of Bootstrap, and the fact that we’re not creating the very ﬁrst blog application that ever needed pagination styling, it’s no surprise that there is already a Ruby gem to address our exact problem. The gem is called bootstrap5-kaminari-views, and it provides Bootstrap 5 styling for the kaminari pagination gem we’re using.\n\nLet’s add the gem to our Gemfile:\n\ngem 'bootstrap5-kaminari-views', '~> 0.0.1'\n\nAnd then run bundle to install the gem.\n\nTo apply the styling, we need to modify our _pages.html.erb ﬁle located in our app/views/shared directory. We only need to pass the theme parameter with a value of ‘bootstrap-5’. Our updated paginate call will look like this:\n\n<%= paginate pages, theme: 'bootstrap-5' %>\n\nThis makes our pagination links, as shown in Figure 14-6, look similar to the other Bootstrap styles we are already using.\n\nStyling\n\nFigure 14-6 Pagination CSS\n\nStyling Our Admin\n\nThe last bit of styling we will do is to style our Admin login page.\n\nFirst, let’s update our admin.html.erb layout ﬁle that is located in our app/views/ layouts directory. Our <h1> tag is too tight against the top and left sides of the page. Let’s add some extra margin:\n\n<h1 class=\"ms-2 mt-1\">Admin</h1>\n\nThe “ms” means “margin start” or left margin. The “mt” means “margin top” or top margin. The numeric sufﬁx is the amount of margin with higher numbers being more margin than lower numbers. Next, let’s work on improving our login form. Let’s open and modify our new.html.erb template ﬁle located in our app/views/sessions directory. We need to again add some left margin to our form; currently, it’s too close to the left side of the page. Let’s wrap our form in a <div> container and add the ms-2 class to it:\n\n<div class=\"ms-2\"> ... </div>\n\nTo get our form ﬁelds looking a bit nicer, let’s add the form-control class to each of them:\n\n<%= f.email_field :email, class: 'form-control' %>\n\nTo add some space between our form ﬁelds, let’s add the mt-3 class to each of our <div> containers that wrap our form ﬁelds:\n\n<div class=\"mt-3\"> ... </div>\n\n203\n\n204\n\n14 Odds and Ends\n\nFigure 14-7 Admin login CSS\n\nNext, let’s improve our submit <button> by adding \"btn btn-primary\" classes to it:\n\n<button type=\"submit\" class=\"btn btn-primary\">Submit</button>\n\nOur form ﬁelds are looking better, but now they span the entire width of the page. Let’s add a class to our <div> container to pull them in to about a fourth of the page. Bootstrap is based on a 12-column grid system, so 3 columns is a fourth of the page. Let’s add the col-3 class to our <div> container:\n\n<div class=\"col-3 ms-2\">\n\n... </div>\n\nAfter our updates, our ﬁnal new.html.erb ﬁle looks like this, and our login form looks like Figure 14-7:\n\n<div class=\"col-3 ms-2\">\n\n<%= form_for(:login, url: login_path) do |f| %>\n\n<h2>Sign in</h2> <div class=\"mt-3\">\n\n<%= f.label :email %> <%= f.email_field :email, class: 'form-control' %>\n\n</div> <div class=\"mt-3\">\n\n<%= f.label :password %> <%= f.password_field :password, class: 'form-control' %>\n\n</div>\n\nCode Highlighting\n\n<div class=\"mt-3\">\n\n<button type=\"submit\" class=\"btn btn-primary\">Submit</button>\n\n</div> <% end %>\n\n</div>\n\nWrapping Up\n\nThis wraps up styling our blog application. We’ve added standard Bootstrap 5 styling to our blog application, and admittedly we could add a lot more. Bootstrap has lots of styling options, and we’ve only barely scratched the surface.\n\nCode Highlighting\n\nTo close out this chapter, we’re going to add code highlighting to our blog application. I’m assuming that you are reading this book because you are or soon will be a software engineer and that you will want to write blog entries that include code that you want to make syntax highlighted. If that’s a wrong assumption, then you can skip this section.\n\nWe’re going rogue here and will not be using a Ruby gem to do this. Instead, we’re going to use a\n\nplain old JavaScript library called Prism:\n\nhttps://prismjs.com/\n\nPrism is a client-side syntax highlighting library that is very popular with software engineers and is used by many popular websites. It’s also very easy to use. We’re going to use the Prism library to highlight our <code> blocks in our blog entries.\n\nThe way it works is very simple. When we create a blog entry, and we include a <code> block in our HTML, we add a language-* CSS class to the <code> tag. For example, if we want to highlight a <code> block as Ruby code, we would add the language-ruby class to our <code> tag. After page load, Prism will look for classes it knows about and will highlight the <code> tag contents accordingly. Prism supports many different programming languages and has great support for Ruby.\n\nBefore we do anything else, let’s add a new system spec, so we’ll know when we have it working.\n\nIn our spec/system directory, let’s modify our existing page_spec.rb ﬁle to add this:\n\ndescribe 'syntax highlighting' do\n\nbefore do\n\ncontent = <<~RUBY.squish\n\n<pre>\n\n<code class=\"language-ruby\">\n\nputs 'hello world!'\n\n</code>\n\n</pre>\n\nRUBY\n\nmy_page.update(content:)\n\nend\n\n205\n\n206\n\n14 Odds and Ends\n\nit 'renders code blocks' do\n\nvisit page_path(slug: my_page.slug)\n\nwithin 'pre' do\n\nexpect(page).to have_text('puts')\n\nwithin 'code.language-ruby span.token.string' do\n\nexpect(page).to have_text('hello world!')\n\nend\n\nend\n\nend\n\nend\n\nWe’re updating our existing my_page variable from the let at the top of the spec ﬁle to have a <code> block in its content ﬁeld. Our <code> block contains a single line of Ruby code that outputs hello world!. We’re then visiting our page and checking to see if our <code> tag is present and has the language-ruby class assigned. This is expected, even without Prism, but then we’re checking to see if there is a <span> tag with CSS classes token and string that contains our string ‘hello world!’. We didn’t add anything to do with <span> tags in our <code> block; that’s what Prism does for us. So when we run our spec, and it begins to pass, we’ll know our Prism setup is working.\n\nRunning our spec, we see that it fails, as expected. We need to install Prism into our application\n\nand conﬁgure it.\n\nThe ﬁrst step is to visit the Prism website and download the JavaScript and CSS ﬁles. On this page,\n\nwe can pick which languages we want to support and then download the ﬁles:\n\nhttps://prismjs.com/download.html\n\nMake sure and choose Ruby as one of the languages to support, then scroll to the bottom of the page and click each of the two Download buttons to download the JavaScript and CSS ﬁles. Move the prism.css CSS ﬁle into our app/assets/stylesheets directory and move the prism.js JavaScript ﬁle into our app/javascript directory.\n\nNext, we need to load the prism.js JavaScript ﬁle into our application. Let’s add this to the\n\nbottom of our app/javascript/application.js ﬁle:\n\nimport './prism'\n\nOur prism.js ﬁle is a plain old JavaScript ﬁle living in the same directory as our application.js ﬁle, so we can just import it into our application using a local path of \"./\". Notice how the ﬁle extension is not included in the import statement; it’s optional and assumed to be .js.\n\nStimulus and Turbo\n\nIn our modern Rails application, we are by default using Stimulus and Turbo, mostly because we didn’t say we didn’t want to use them via the -skip-hotwire option when we created our application using the rails new command previously. But why am I writing about them?\n\nCode Highlighting\n\nGone are the days of simply adding a <script> tag to our HTML to load a plain old JavaScript ﬁle. The modern way, especially inside a Rails application, is to use Stimulus to create a “controller” that is loaded into our HTML using “data” tags. Stimulus then connects and runs our JavaScript code only when and where we need it to. It’s pretty fancy, especially if you’re old enough to have ever supported IE6. But I digress.\n\nTo execute our Prism code, we need to add a Stimulus controller to our application. Let’s create a new ﬁle in our app/javascript/controllers directory called prism_controller.js with this content:\n\nimport { Controller } from \"@hotwired/stimulus\"\n\nexport default class extends Controller {\n\nconnect() {\n\ndocument.addEventListener('turbo:load', function() {\n\nPrism.highlightAll();\n\n});\n\n}\n\n}\n\nThe point of this code is so that we call our Prism.highlightAll() method when the Turbo library has ﬁnished loading our page. Rails is using Turbo to load our pages, and it has a turbo:load event that we can listen for. When that event is ﬁred, we know our page has ﬁnished loading, and we can then safely call our Prism.highlightAll() function.\n\nBut notice how this code is not stand-alone, it’s wrapped inside a Stimulus controller connect\n\nmethod that is called when our Stimulus controller successfully connects to our HTML.\n\nThe next step is to add our new Stimulus controller to our list of all our Stimulus controllers. In our app/javascript/controllers directory, we need to modify our index.js ﬁle to add these two lines at the bottom:\n\nimport PrismController from \"./prism_controller\" application.register(\"prism\", PrismController)\n\nThis is very similar to adding a <script> tag to an HTML ﬁle, but instead of loading a JavaScript ﬁle, we’re loading a Stimulus controller. The ﬁrst line imports our prism_controller.js ﬁle, and the second line registers our controller with Stimulus and gives it the name prism.\n\nThe magic that connects our new Stimulus controller to our HTML is simply the proper naming of our Stimulus controller ﬁle and the presence of a data-controller attribute located somewhere in our HTML. We named our controller ﬁle prism_controller.js, and the part before the _controller.js is important for the next step.\n\nNext, we need to decide where in our HTML we want to connect our Stimulus controller. We could load it at the top of every page, but that’s a heavy-handed approach. We only want to load it on pages that have code blocks that need to be syntax highlighted, and we only want to execute it on\n\n207\n\n208\n\n14 Odds and Ends\n\nblocks of HTML that need to be highlighted. So let’s add our data-controller attribute to our _page.html.erb ﬁle, in our <article> tag:\n\n<article class=\"card p-3 mb-3\" data-controller=\"prism\">\n\n<h2><%= link_to page.title, page_path(slug: page.slug) %></h2> <p><%= page.created_at.to_fs %></p> <%= content.html_safe %> <p><%= tag_links(page.tags).html_safe %></p>\n\n</article>\n\nWith this modiﬁcation, we’re telling Stimulus to load our prism controller after our <article> tag is loaded. We’re also telling Stimulus to connect our Prism controller to this particular block of HTML and then, if that is successful, to execute our connect method.\n\nNow when we re-run our spec, it should pass. We’ve added the necessary JavaScript code in all the correct places, and we’ve added the required HTML data attribute to connect our Stimulus controller to our HTML. The last thing to do is to add our Prism CSS into our application. We already have our prism.css CSS ﬁle in place, we just need to load it. Let’s add this to the bottom of our application.scss ﬁle:\n\n@import './prism';\n\nThis is similar to adding a <link> tag into our HTML to load a CSS ﬁle. With this modiﬁcation, we now get colors and other styling, as shown in Figure 14-8, for our code blocks.\n\nFigure 14-8 Prism syntax highlighting\n\nSummary\n\nSummary\n\nIn this chapter, we wrapped up several odds and ends including building a sitemap, adding pagination for our page entries, and adding CSS styling and code syntax highlighting. We also learned a little about Stimulus and Turbo and how to integrate plain old JavaScript into our modern Rails application.\n\n209",
      "page_number": 207
    },
    {
      "number": 23,
      "title": "Segment 23 (pages 216-227)",
      "start_page": 216,
      "end_page": 227,
      "detection_method": "topic_boundary",
      "content": "Bonus: Deploy to Production\n\n15\n\nIn this “bonus” chapter, we will deploy our Rails blog application into production. You do not need to read this chapter to complete the book. This chapter is extra, for those who are interested in learning how to deploy a Rails application into production.\n\nWe will install and conﬁgure Capistrano,1 a remote server automation and deployment tool, and then command it to perform a repeatable production deployment. On our production server, we will run Debian Linux. We will install and conﬁgure Ruby and Phusion Passenger2 to work with an Apache web server. We will conﬁgure Apache to serve our Rails blog application using a VirtualHost conﬁguration. We will store our code on GitHub and move things across the Internet securely using SSH.\n\nWhy This Non-cloud Approach?\n\nThere is presently a push in “the industry” to move away from the cloud-hosting approach and return to deploying to bare metal. The cloud is expensive, and there is needless additional complexity in managing a cloud environment.\n\nThe cloud is great for scaling up and down, but if you don’t need to scale up and down, then you\n\nprobably don’t need the cloud.\n\nYou can discover more information about exiting the cloud here:\n\nhttps://duckduckgo.com/?q=dhh+exiting+the+cloud\n\nAcquiring a Production Linux Server\n\nIn our current age of modern computing, it is very simple and easy to acquire a production Linux server. We can rent a dedicated server from a hosting provider such as Rackspace, DreamHost, or Namecheap. The options are endless.\n\nHowever you choose to acquire a production Linux server, you will need to have root access to it. This means you will need to be able to log in to the server as the root user, or become the root user using su or sudo, after logging in with your regular unprivileged user account.\n\n1https://capistranorb.com/ 2www.phusionpassenger.com/\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_15\n\n211\n\n212\n\n15 Bonus: Deploy to Production\n\nFor the purposes of this book, I will assume that you have acquired a Linux server and that you have root access. I will also assume that you have a domain name that you can use to access your production server. You don’t have to have a domain name, but it’s a little easier to remember a domain name compared to an IP address.\n\nMy production server that I will reference while writing this chapter is an EC2 instance running on Amazon Web Services. I’ve acquired a t2.micro instance running Debian Linux version 11. I’m using AWS so I can minimize cost. I will delete my server instance after I’ve written this chapter.\n\nI’ve acquired a domain name from Namecheap, tdd-book.com, and I’ve conﬁgured it to point to my production server’s IP address. None of this will be working anymore by the time you read this book, just so you know.\n\nGetting Production Ready\n\nBefore we can deploy our Rails blog application to production, we need to install and conﬁgure things on our production server. Our Debian operating system will need to be conﬁgured to run Ruby and Phusion Passenger.\n\nInstalling Dependencies\n\nLet’s install all of our dependencies on our Debian server. We will need to become the root user for all of this to work:\n\nsudo su -\n\nThen let’s install the following packages using the apt command:\n\napt update\n\napt install -y apache2 \\\n\napache2-dev \\ build-essential \\ git \\ libcurl4-openssl-dev \\ libffi-dev \\ libpq-dev \\ libssl-dev \\ libreadline-dev \\ libyaml-dev \\ postgresql \\ wget \\ zlib1g-dev\n\nThese are all packages we will get from our Debian operating system repositories. They are not known for being the latest and greatest version; they are instead known for being stable and reliable. We will\n\nGetting Production Ready\n\nventure out into more cutting-edge versions of things with our latest version of Ruby and Phusion Passenger however.\n\nInstalling Ruby\n\nContinuing as the root user, let’s change into our /usr/src directory and download the latest 3.2.2 version of Ruby:\n\ncd /usr/src\n\nwget https://cache.ruby-lang.org/pub/ruby/3.2/ruby-3.2.2.tar.gz\n\nNext let’s extract the archive we downloaded using the tar command:\n\ntar xvf ruby-3.2.2.tar.gz\n\nNow let’s conﬁgure, build, and install our new Ruby:\n\ncd ruby-3.2.2\n\n./configure\n\nmake\n\nmake install\n\nAfter Ruby is installed, let’s use our new gem command to install the bundler and rack gems:\n\ngem install bundler rack\n\nInstalling Phusion Passenger\n\nNext, let’s download the latest 6.0.17 version of Phusion Passenger:\n\ncd /usr/src\n\nwget \\ https://github.com/phusion/passenger/releases/\\ download/release-6.0.17/passenger-6.0.17.tar.gz\n\n213\n\n214\n\n15 Bonus: Deploy to Production\n\nBe careful with the preceding wget command and URL. It’s a long URL and is wrapped for use in a shell environment using backslashes. If you copy and paste it into your terminal and it does not work, then you may need to remove the backslashes and paste it in as one long line. If you still have problem, you can instead download the archive ﬁle manually from the Phusion Passenger GitHub page:\n\nhttps://github.com/phusion/passenger/releases\n\nAssuming you downloaded the ﬁle without any issues, let’s now extract it using the tar command:\n\ntar xvf passenger-6.0.17.tar.gz\n\nNow that we’ve untarred our Phusion Passenger download, let’s install it:\n\ncd passenger-6.0.17\n\nbin/passenger-install-apache2-module\n\nYou will be prompted to answer a question about language support:\n\nWhich languages are you interested in?\n\nMake sure to select Ruby using your space bar, and then press Enter. Passenger takes a while to build and install. At the end it will prompt us to add a few lines to our Apache conﬁguration ﬁle. Let’s change into our Apache module directory and create a new ﬁle called passenger.load and put the following contents in it:\n\ncd /etc/apache2/mods-available\n\n# Create a new file called passenger.load with the contents: LoadModule \\\n\npassenger_module \\ /usr/src/passenger-6.0.17/buildout/apache2/mod_passenger.so\n\n<IfModule mod_passenger.c>\n\nPassengerRoot /usr/src/passenger-6.0.17 PassengerDefaultRuby /usr/local/bin/ruby\n\n</IfModule>\n\nThen enable our new passenger.load ﬁle using the a2enmod command:\n\na2enmod passenger\n\nGetting Production Ready\n\nNext, we need to disable the Apache mpm_event module using the a2dismod command; we’re not going to be using it and it’s on by default:\n\na2dismod mpm_event\n\nWe’re going to use the Apache mpm_prefork module instead. We need to enable it and some other Apache modules that we will also need for our Rails application:\n\na2enmod auth_digest \\\n\nheaders \\ mpm_prefork \\ proxy \\ proxy_http \\ rewrite \\ socache_shmcb \\ ssl\n\nNow we can restart our Apache web server and see that we have no errors from our Phusion Passenger install and our module updates:\n\nservice apache2 restart\n\nFinally, let’s modify our PATH to include the Passenger bin directory. Let’s add the following line\n\nto the end of our /etc/bash.bashrc ﬁle:\n\nexport PATH=\"/usr/src/passenger-6.0.17/bin:$PATH\"\n\nConﬁguring PostgreSQL\n\nWe installed PostgreSQL earlier, but we still need to conﬁgure it. Let’s change into our /etc/postgresql/13/main directory and make some additions to our postgresql.conf ﬁle:\n\nclient_min_messages = warning\n\nThis lets PostgreSQL listen on all network interfaces, and it also sets the minimum level of messages that PostgreSQL will log. We want logging but we don’t want to log everything, just warnings and errors. The log levels below “warning” are very noisy and not very useful.\n\n215\n\n216\n\n15 Bonus: Deploy to Production\n\nNext, let’s modify our pg_hba.conf ﬁle to allow us to connect to PostgreSQL locally. We’ll\n\nadd the following lines near the end of the ﬁle:\n\n# TYPE DATABASE USER ADDRESS METHOD all local\n\nall\n\ntrust\n\nThis lets us connect to PostgreSQL locally without a password. If you’re running a shared server with multiple applications using the same PostgreSQL database instance, then you should instead use the md5 option and set passwords for all your PostgreSQL users.\n\nNow we can restart our PostgreSQL service and see that we have no errors:\n\nservice postgresql restart\n\nAgain, as the root user, let’s now switch users and create a new PostgreSQL user named admin\n\nand give them ownership of a new database:\n\nsu - postgres\n\ncreateuser admin\n\ncreatedb blog -O admin\n\nNow that we have a PostgreSQL admin user and a blog database, let’s try them out using the psql command:\n\npsql -U admin -d blog\n\nWe should be able to successfully connect to our new blog database as our new admin user and see that we currently have no tables:\n\nblog=> \\dt Did not find any relations.\n\nInstalling Capistrano\n\nPostgreSQL is now conﬁgured. Our Rails app will be able to connect to our blog database using our admin user when we deploy it shortly.\n\nStoring Code on GitHub\n\nYou can store your code anywhere you like, but for this chapter, I will assume that you have a GitHub account and that you have stored your code from this book on GitHub. Hopefully, you’ve been following along and have already done this. If not, read on.\n\nIf you don’t have a GitHub account, you can create one for free at\n\nhttps://github.com\n\nJust to be clear, there is no particular reason why I’m using GitHub. It’s just a popular place to store code, it’s free, and I’m making the assumption that most of my readers will use it or will at least be familiar with it.\n\nIf you’re using something else, then it will probably just be a matter of different URLs when we\n\nconﬁgure our deployment.\n\nInstalling Capistrano\n\nCapistrano is a Ruby gem, so we can add it to our Rails blog application by modifying our Gemfile to add the following in our development group:\n\ngem \"capistrano-rails\", \"~> 1.6\" gem \"capistrano-passenger\", \"~> 0.2.1\"\n\nThese are the latest versions of those gems at the time of writing. You can probably use newer versions without any signiﬁcant changes. We’re using the capistrano-rails gem which will install the capistrano gem for us as a dependency. We’re also using the capistrano-passenger gem which will provide us with some Capistrano Rake tasks to help us more easily work with Phusion Passenger and Apache.\n\nNow let’s install these gems into our application by running the bundle command.\n\nConﬁguring Capistrano\n\nNow that we have our Capistrano gems installed, we need to integrate them into our Rails application. We can do this by running the cap install command:\n\nbe cap install\n\n217\n\n218\n\n15 Bonus: Deploy to Production\n\nThis command will add several new ﬁles to our Rails application:\n\nCapfile config/deploy.rb config/deploy/production.rb config/deploy/staging.rb\n\nWe can delete or ignore the staging.rb ﬁle; we’re not going to be using it. We will make modiﬁcations to the other three ﬁles. Let’s ﬁrst modify our Capfile ﬁle and uncomment the functionality we want to use:\n\nrequire \"capistrano/bundler\" require \"capistrano/rails/assets\" require \"capistrano/rails/migrations\" require \"capistrano/passenger\"\n\nWe need bundler support to install our application’s Ruby gems on our server. We need Rails asset support to compile our assets. We need Rails migration support to run our database migrations, and we need Passenger support to restart our application after we deploy it.\n\nNext, we need to conﬁgure our config/deploy.rb ﬁle. We’ll start by adding the following\n\nlines to the top of the ﬁle:\n\nset :application, 'blog' set :repo_url, 'git@github.com:gdonald/blog.git' set :branch, 'main'\n\nappend :linked_files, 'config/database.yml',\n\n'config/secrets.yml', 'config/storage.yml'\n\nappend :linked_dirs, 'storage',\n\n'log', 'tmp/pids', 'tmp/cache', 'tmp/sockets', 'public/system'\n\nset :passenger_restart_with_touch, true\n\nThere are a number of variables being conﬁgured, so let’s run through them. First, we set our application variable to the name of our application. It’s normally used in the name of our application’s directory on our server. Next, we deﬁne our repo_url variable to the URL of our GitHub repository, and we set our branch variable to the name of the branch we want to deploy. We’re using the main branch, but you can use whatever branch you like.\n\nDeploying Our Rails Application\n\nThe next two variables, linked_files and linked_dirs, are ﬁles and directories that are shared between each deployment we perform. They exist only once on our server and get relinked on each deployment.\n\nThe last conﬁguration ﬁle we will update is named for the environment we will deploy to, our config/deploy/production.rb ﬁle. We need to add the following lines to the top of the ﬁle:\n\nserver 'tdd-book.com', user: 'admin', roles: %w[app db web] set :deploy_to, '/rails/blog' set :rails_env, 'production'\n\nset :pty, true set :ssh_options, {\n\nforward_agent: true, auth_methods: ['publickey'], keys: ['~/aws.pem']\n\n}\n\nFirst is our server variable which deﬁnes the server we will deploy to. This is a fully qualiﬁed domain name, and the username is the user we will use to connect to the server. We’re using our default Debian admin user, but you should use the username of your user. The roles are default for our Rails application because our application code and database are both on the same server.\n\nNext, we set our deploy_to variable to the directory where we will deploy. This is a full path on our production server for which our user owns and has write access. Your deploy_to can be different, of course.\n\nNext, we set our rails_env variable to the environment we will deploy to. For our production\n\nRails application, this will be production.\n\nThe next two variables are used to conﬁgure our SSH connection to our server. We’re using Capistrano to issue commands over a pseudo terminal, so we need to set our pty variable to true. After that, we set our ssh_options variable to a hash of options. Inside there, we’re telling Capistrano to use the forward_agent option to simplify deploying to our remote server. This will allow a remote SSH agent to securely use our local SSH keys.\n\nLast, we’re telling Capistrano with our auth_methods option to use publickey authentica- tion, and then we deﬁne the local path to our public key ﬁle. This key was automatically added to the authorized_keys ﬁle in our . ∼/.ssh directory when creating the EC2 instance on AWS.\n\nDeploying Our Rails Application\n\nOn our production server, we need to create the directory we deﬁned in our deploy_to variable. We can create this directory and change its ownership with the following commands:\n\nmkdir -p /rails/blog\n\nchown -R admin:admin /rails\n\n219\n\n220\n\n15 Bonus: Deploy to Production\n\nNow we can begin to debug our deploy. There are several more steps to perform, but I want to work through each one of them as if we were doing test-driven development. Seeing these errors and ﬁxing them will help us understand what is happening and why.\n\nThe command we need to run is\n\ncap production deploy\n\nThe ﬁrst error we get is\n\n01 git@github.com: Permission denied (publickey). 01 01 fatal: Could not read from remote repository. 01 01 Please make sure you have the correct access rights 01 and the repository exists.\n\nWe’re getting this error because we have not yet put a copy of our public key from our production server into our GitHub account. We can do this by navigating to our GitHub account’s Settings page and then clicking SSH and GPG keys. We can then click the New SSH key button and paste in the contents of our . ∼/.ssh/id_rsa.pub ﬁle. We can then click the Add SSH key button.\n\nIf you ﬁnd you don’t have a . ∼/.ssh/id_rsa.pub ﬁle, you can create one with the following\n\ncommand:\n\nssh-keygen -t rsa\n\nThis will generate a new key pair and will place the public key contents you need for GitHub in the . ∼/.ssh/id_rsa.pub ﬁle.\n\nNow we can try to deploy again:\n\ncap production deploy\n\nThe next error we get is\n\n00:01 deploy:check:linked_files ERROR linked file /rails/blog/shared/config/database.yml does not exist on tdd-book.com\n\nDeploying Our Rails Application\n\nThis error is telling us that we need to create our Rails database.yml ﬁle on our production server in our /rails/blog/shared/conﬁg directory. The contents of this ﬁle should match our PostgreSQL user and database names we created earlier. The content of the ﬁle should look similar to this:\n\ndefault: &default\n\nadapter: postgresql encoding: unicode pool: <%= ENV.fetch(\"RAILS_MAX_THREADS\") { 5 } %> port: <%= ENV['DB_PORT'] || 5432 %>\n\nproduction:\n\n<<: *default database: blog username: admin\n\nRe-running our deploy command gives us our next error message:\n\n00:01 deploy:check:linked_files ERROR linked file /rails/blog/shared/config/secrets.yml does not exist on tdd-book.com\n\nRails needs to keep secrets, so it uses a secrets.yml ﬁle to store a secret key base value that is used to encrypt cookies and other sensitive information. We need to provide this ﬁle like we did with our database.yml ﬁle. The contents of our secrets.yml ﬁle should look similar to this:\n\nproduction:\n\nsecret_key_base: \"make_this_a_long_string_of_random_characters\"\n\nMake sure and replace the value of secret_key_base with a long string of random characters. You can generate a random string of characters with the following command:\n\nrake secret\n\nRe-running our deploy command gives us our next error message:\n\n00:01 deploy:check:linked_files ERROR linked file /rails/blog/shared/config/storage.yml does not exist on tdd-book.com\n\n221\n\n222\n\n15 Bonus: Deploy to Production\n\nOur Rails application uses Active Storage to manage our uploaded images. We need to provide a storage.yml ﬁle to conﬁgure Active Storage for production. The contents of our storage.yml ﬁle should look similar to this:\n\nlocal:\n\nservice: Disk root: <%= Rails.root.join(\"storage\") %>\n\nThis tells Active Storage to store our uploaded image ﬁles in the relative path of storage inside our /rails/blog/shared directory, which in effect means a full path of /rails/blog/shared/ storage. Considering that you need to keep this directory backed up, you may not like this, so feel free to change it to a more convenient path for your particular backup strategy.\n\nRe-running our deploy command gives us our next error message:\n\nbundle stdout: Your bundle only supports platforms [\"arm64-darwin-22\"] but your local platform is x86_64-linux. Add the current platform to the lockfile with `bundle lock --add-platform x86_64-linux` and try again.\n\nI wrote this book and all the Ruby and Rails code on an arm64 Macbook Pro, but we’re trying to deploy to an x86_64 Linux server. Bundler is understandably complaining that we have a platform mismatch in our Gemﬁle.lock ﬁle. We need to add our production platform to our Gemﬁle.lock ﬁle. We can do this by running the command the error message suggests:\n\nbundle lock --add-platform x86_64-linux\n\nAfter we run this command, we need to commit the changes and push them up to GitHub, or wherever you’re storing your code. We can then re-run our deploy command to get our next error message:\n\nExecJS::RuntimeUnavailable: Could not find a JavaScript runtime. See \\url{https://github.com/rails/execjs} for a list of available runtimes.\n\nThis error is telling us that we need to install a JavaScript runtime. We need a JavaScript runtime for the Rails asset pipeline to compile our CSS and JavaScript assets. We can remedy this error by installing Node.js.",
      "page_number": 216
    },
    {
      "number": 24,
      "title": "Segment 24 (pages 228-236)",
      "start_page": 228,
      "end_page": 236,
      "detection_method": "topic_boundary",
      "content": "Conﬁguring Our Apache Virtual Host\n\nThe version of Node.js available to use from the Debian repositories is too old and does not work with Rails Turbo, so we need to install a newer version from an alternate source. We can install it from nodesource.com.3 To do this, we need to run the following commands:\n\ncurl -fsSL https://deb.nodesource.com/setup_18.x | bash - &&\\ apt-get install -y nodejs\n\nThis will get us the latest stable version of Node.js. We can then re-run our deploy command to get our next error message:\n\nrake stdout: sh: 1: yarn: not found\n\nThis error message is telling us that we need to install the yarn package, a different package manager that we need to assist with compiling our Rails assets. We can do this by running the following commands:\n\nnpm install yarn -g\n\nThis command uses npm, the node package manager, to install the latest version of yarn. The -g option tells npm to install the yarn package globally, so it will be available to all users on our production system, not just the root user performing the install. We can then re-run our deploy command again, and this time we should get a successful deploy with no error messages.\n\nWhen we now visit our domain name on our production server (mine is at http://tdd-book.com), we do not yet see our Rails app running. We instead see the default Apache web server page. This is because we need to conﬁgure our Apache web server’s virtual host conﬁguration, to serve our Rails app using Phusion Passenger.\n\nConﬁguring Our Apache Virtual Host\n\nWe currently have the default Apache web server conﬁguration serving up content from the /var/www/html directory under a single virtual host entry. The conﬁguration ﬁle representing the virtual host is located in the /etc/apache2/sites-available directory and is named 000-default.conf. We need to modify it to serve up content from our /rails/blog/current/public directory instead.\n\nLet’s update the ﬁle to look like this:\n\n<VirtualHost *:80>\n\nServerAdmin admin@tdd-book.com SetEnv RAILS_ENV production\n\n3https://github.com/nodesource/distributions\n\n223\n\n224\n\n15 Bonus: Deploy to Production\n\nServerName tdd-book.com ServerAlias www.tdd-book.com DocumentRoot /rails/blog/current/public <Directory /rails/blog/current/public>\n\nRequire all granted Options -MultiViews\n\n</Directory> ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/tdd-book.com.log combined\n\n</VirtualHost>\n\nBe sure to update the Server* values to match your own domain name and email address.\n\nNotice that we’ve added the SetEnv RAILS_ENV line to tell our Rails app that we’re running in a production environment. This is important, because it will tell our Rails app to use our production database conﬁguration in our database.yml ﬁle, and not look for the default development database conﬁguration.\n\nThere’s also some magic here. Phusion Passenger knows our virtual host is now conﬁgured as a Rails app. When we make some future updates and redeploy our Rails app, Capybara can automatically let Passenger know it needs to hot-reload the new version of our code. We will have zero downtime on redeploys.\n\nUsing Passenger as an Apache web server module, we automatically get all the decades of effort that have gone into making Apache a stable, secure, and performant web server. We also get the ability to automatically serve up static assets from our public directory, which is a “really nice to have” feature in not having to conﬁgure another web server on another port or adding additional conﬁguration to our virtual host entry just to match incoming requests for them.\n\nAfter we make these virtual host changes, we need to restart our Apache web server:\n\nservice apache2 restart\n\nLogging In\n\nWe can now visit our domain name in our web browser and see our Rails app running, but we cannot yet log in to our admin to add any new page content. We do not currently have a user account in our production database. Let’s add one using our Rails console:\n\nRAILS_ENV=production bundle exec rails c\n\nSummary\n\nThis will open a Rails console into our production environment connected to our production database. We can now create a new user account using our user Factory:\n\nFactoryBot.create(:user,\n\nname: 'Greg Donald', email: 'gdonald@gmail.com', password: 'changeme', password_confirmation: 'changeme')\n\nNow we can log in to our admin using the email address and password we just created. We can then add some content to our blog.\n\nSummary\n\nIn this chapter, we learned how to deploy our Rails app to a production server. We set up a Debian Linux server from scratch, installed all the necessary packages and dependencies, and conﬁgured our Apache web server to run Phusion Passenger to serve our Rails app. We also learned how to use Capybara to automatically deploy our Rails app to our production server.\n\n225\n\nIndex\n\nA accept_confirm method, 180 Active Admin\n\nadding gem, 149–150 description, 149 testing, 150\n\nActive Admin ﬁlter customizations, 182 ActiveAdmin.register method, 159 Active Admin remove_filter syntax, 181 ActiveRecord object, 47 ActiveRecord’s order method, 62 Active storage, images\n\nadd image model, 125 config/storage.yml ﬁle, 124 has_one_attached, 127 Rails application, 123, 124 storage.yml, 124\n\nAuthentication enhancement\n\n.authenticate method, 141, 143. BCrypt::Engine.generate_salt:, 143 BCrypt gem, 142, 144 before_save callback, 141 downcase, 141 error, 139 failures, 141 foo@bar.com, 140 password hash, 143 password= method, 143 titleize, 141 User.password_hash, 139 User.password_salt, 139 user record, 140\n\nacts-as-taggable-on, 105 Adding page tags\n\ncreating page Tag model, 107–109 creating Tag model, 105–107 jump over relationships, 109–111\n\nadd method, 31 Admin ﬁlters, 181–182 admin/pages.rb ﬁle, 166 After save callbacks\n\nattr_accessor, 112 before block, 113 has_many :tags association, 113 Page object, 112 page_spec.rb ﬁle, 111 PageTag record, 113 self.tags . = [], 114 tags_string attribute, 111, 112 update_tags method, 113 Amazon Web Services (AWS), 212 Apache Virtual Host conﬁguration, 223–224 Apache web server, 211 app/controllers directory, 118, 153 apt command, 212 Archive integration test, 101–103 Archive list view, 98–101 authenticate_admin_user!, 152\n\nB BCrypt::Engine.generate_salt, 136 BCrypt::Engine.hash_secret, 136 before_save callback, 136 before_validation callback, 47 Behavior-driven development (BDD)\n\nframework, 27 binding.irb, 31, 32 Blog, 1, 2, 21 Blog database diagram, 2 blog_development database, 34 Bootstrap, 20\n\ncontainer-fluid style, 76 CSS framework, 74, 199, 202\n\nbootstrap5-kaminari-views, 202 Broken Window Theory, 11 Bundler, 17 Bundler’s bundle exec command, 21\n\nC Callback, 47 Capistrano, 217–219 Capybara, 52, 58\n\nattach_file helper method, 173 find_all method, 59\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3\n\n227\n\n228\n\nhas_text matcher, 169 has_xpath matcher, 169 visit method, 64 within method, 59\n\nclean method, 121 Code highlighting, 205–208 Code spikes, 8 Command-line interface1 (CLI), 13 config/environments directory, 124 content variable , 71 CSS\n\narchive list, 201–202 framework, 74 header, 199–200 and JavaScript ﬁles, 206 no search results, 200–201 page summary, 200 pagination, 202–203 in rails, 199 search form, 201\n\ncurrent_user_method, 157\n\nD Debian Linux, 211 Debian operating system\n\ninstalling dependencies, 212–213 installing Phusion Passenger, 213–215 installing Ruby, 213 PostgreSQL, 215–217 repositories, 212\n\ndebug.rb , 31 delete route, 156 Deleting images, 180–181 Deleting users\n\nActive Admin registration block, 186 password_salt, 186 user attributes, 186\n\ndescribe ’index’ block, 180 destroy method, 156 development.rb ﬁle, 124 Display tags on pages\n\nconfig/routes.rb ﬁle, 116 default_scope, 116 failure message, 118 _page.html.erb partial, 117 show.html.erb ﬁle, 118, 119 spec/system directory, 117 Tag collection, 114 tag_links method, 115, 117 tag_path route, 116 Tag records, 114 tags_controller.rb ﬁle, 118, 119 TagsHelper module, 115 tags_helper.rb ﬁle, 115 tags_helper_spec.rb ﬁle, 114 TagsHelper#tag_links method, 116\n\nDomain-speciﬁc language (DSL), 27 Don’t repeat yourself (DRY), 90, 91 DreamHost, 211\n\nE Editing images\n\nActiveAdmin.register block, 176 attach_file page, 177 edit page, 177 factor out duplicate expectations, 178–180 form block, 177 new and edit routes, 178 Embedded Ruby (ERB), 55, 56 Extreme Programming (XP), 3\n\nF FactoryBot\n\ndebugging, 30–32 DSL, 28 FactoryBot.create method, 29 factory_bot_rails , 29 Rails code generators, 29, 30 Rails environments, 29 RSpec, 29 Ruby gem, 29 shoulda-matchers , 30 test data, Rails and ActiveRecord\n\nobjects, 28, 29\n\ntest Rails applications, 28 FactoryBot create method, 64 FactoryBot.create method, 29 factory_bot_rails , 29 find method, 64 foreman command, 24, 25 form_for helper method, 154 form method, 184\n\nG gem command, 17, 18 Gemﬁle, 29 GitHub, 217, 220, 222\n\nH Handling missing tags request spec, 119 root_path, 120 tag_spec.rb, 119\n\nHash function, 134 Hashing library, 136–137 Homebrew, 13–14 HomeController#index action, 61, 63 Homepage Layout, 73 html_safe method, 71\n\nI Image Controller, serve image data\n\nContent-Disposition, 130 GET request, 127 HTML/ERB template, 129 image.download, 130 image/jpeg, 128\n\nIndex\n\nIndex\n\nimages_controller.rb, 129 images_spec.rb, 127 img record, 130 “missing” image, 131 missing.jpeg ﬁle, 132 Rails route, 128 show route, 128\n\nimage.image.attach code, 126 Image model, 125 Images management\n\nadmin ﬁlters, 181–182 deleting, 180–181 editing, 176–180 uploading, 172–176 viewing (see Viewing Images)\n\nImage tag matchers, 175 importmap , 20 index block, 167, 168 index_content element, 166\n\nJ Join model, 107 Jump over relationships\n\nhas_many relationship, 109–111 has_many:through\n\nassociation, 109\n\npage_spec.rb ﬁle, 110 tag_spec.rb ﬁle, 110\n\nL layout template, 74–76 let method, 60 Linux server, 211–212 Logging in\n\nactive_admin.rb initializer file, 156 admin layout, 157–158 admin_user_id session, 156 admin_user_id set, 153 ApplicationController, 157 application_controller.rb ﬁle, 152, 153 changes, 151 config/routes.rb ﬁle, 152, 154 create command, 155 error, 151 login_spec.rb ﬁle, 151 logout functionality, 155 new.html.erb ﬁle, 152 routes command, 154, 155 sessions_controller.rb set, 153–155 top-level login key, 155 user authentication, 152\n\nlogin_as method, 165 login_path helper method, 152 login.rb ﬁle, 164 login routes, 154 logout path, 156\n\nM Matz’s Ruby Interpreter (MRI), 15 Model-view-controller (MVC) .month_year_list method, 92, 93\n\nN Namecheap, 211, 212 NameCleanup module, 121 Node.js, 19–20, 222–223 nodesource.com, 223 NoMethodError, 61, 64 Non-cloud approach, 211\n\nO OpenBSD bcrypt library, 136 .ordered scope, 62, 63 Overriding Active Admin form ﬁeld values admin/pages.rb ﬁle, 161, 164 missing values, 161 Page model, 161 spec failure message, 161 spec/models/page_spec.rb\n\nfile, 161\n\ntags_string_for_form\n\nmethod, 161, 164\n\nP Page.by_term method, 99 Page.by_year_month method, 99, 100, 102 Page factory, 48 Page method, 60 Page model\n\nblog post, 33 factory, 42 FactoryBot “build” vs. “create,” 46 migration, 41, 42 .ordered scope , 62 Page factory, 48 Page slug, 46–48 Postgres, 44 rails generate command , 41 random test data, 48–49 RSpec’s “subject,” 45–46 specs, 43\n\nPage.month_year_list method, 97 Page.new(user:), 29 Pages archive, sidebar\n\narchive integration test, 101–103 archive list view, 98–101 create list of months and years, 92–98\n\nPageSearch.search method, 100 PageSearch service class, 98 Pages management error, 160 factoring out duplicate login code, 164–165 flashes CSS class, 159\n\n229\n\n230\n\nnew_admin_page_path, 159, 160 overriding Active Admin form ﬁeld values, 161–164 Page parameter list, 160 page preview, 166–168 pages_spec.rb ﬁle, 158 tags_string attribute, 160, 161\n\nPageTag model creation\n\ncounter_cache option, 109 CreatePageTags migration, 107 create_table block, 107 page_tags_count column, 108 page_tags factory, 108 page_tag_spec.rb file, 108 Rails generator, 107 :references, 108 validation spec, 109 PageTag records, 108 Pagination\n\nconfig/routes.rb ﬁle, 196 FactoryBot’s create_list method, 193 ﬁxing specs, 198 HomeController index method, 194 kaminari_config.rb, 193 Kaminari gem, 192–193 Page.none, 197 Page objects, 194–195 PageSearch service class, 197 spec/system/home_spec.rb\n\nfile, 193\n\nspec/system/search_spec.rb\n\nﬁle, 196–197\n\nspec/system/tag_spec.rb ﬁle, 195 TagsController, 196\n\npassword attribute, 135 Password conﬁrmation\n\nattribute, 146 FactoryBot, 146 failure message, 144 password attribute, 144, 145 password= method, 144 shoulda-matcher specs, 144 spec/factories/users.rb, 145 user password validation, 146 User_spec.rb ﬁle, 145 virtual attribute, 146\n\nPassword Conﬁrmation ﬁeld label, 183 password_hash ﬁeld, 134 Password hashing, 133–134 password= method, 135 password_salt ﬁeld, 134 permitted_params method, 160 Phusion Passenger, 213–215, 224 PostgreSQL, 2, 18–19, 34, 215–217, 221 PostgreSQL’s psql program, 34 PostgreSQL’s TO_CHAR function, 93 PostgreSQL TRIM function, 93 Prism, 205–208 Procfile.dev file, 23, 24 Published Pages, 61\n\n.published scope , 61 Published vs. unpublished pages, 59–61\n\nR Rackspace, 211 Rails application, 211\n\nActive Storage, 222 deploying, 219–223 logging in, 224–225\n\nrails generate command , 33 Rails model validations, 49, 50 rails new command, 20–23 Rails resources method, 152 Rails routes command, 154 rails server command , 23 Rails view templates, 55–57 Random test data, 48–49 rbenv, 14–16 Red-green-refactor development cycle, TDD\n\ngreen phase, 9–10 red phase, 8–9 refactor phase, 10 wash, rinse, and repeat, 10–11\n\nRefactor duplicate code cleanup code, 120 local private method, 122 make_slug method, 121 name_cleanup.rb module, 121 name_cleanup_spec.rb ﬁle, 120\n\nRelational database management system (RDBMS), 2, 18\n\nrender method, 57 Request specs, 51 root method, 53 RSpec\n\nbehavior-driven development, 2 bundle command , 27 DSL, Ruby, 27 Gemﬁle, 27 Rails blog application, 27, 28 Rails development, 27 run rails generate rspec:install\n\ncommand , 28 run rspec command , 27 shoulda-matchers, 38 test environments, 27 testing framework, Ruby, 27\n\nRSpec lets, 60, 62 RSpec’s “subject,” 45–46 Ruby\n\ninstallation, 14–16 MRI, 15 rbenv, 14\n\nRuby gem, 205–206 Ruby on Rails, 1, 5\n\ncode generators, 33 create new Ruby on Rails application Bootstrap, CSS framework, 20 Bundler’s bundle exec command, 21\n\nIndex\n\nIndex\n\ndatabase=postgresql option , 20\n\ndevelopment database, 22 error page, 22 JavaScript, 20 rails db:create command , 22 rails new command, 20, 21 RSpec, 20 test database, 22 welcome page, 23\n\ninstallation, 18 install Bundler, 17 Node.js installation, 19–20 PostgreSQL installation, 18–19 run Rails, foreman command, 24, 25 Test::Unit , 27\n\nS Salt value, 134 Search for page, sidebar\n\napp/views directory , 88 GET request, 86 SearchController , 88 search form, 86–88 _search_form.html.erb , 86 search_path variable, 87 search results display, 88–91 search_spec.rb , 86 spec/system directory, 86\n\nSearch service\n\n.by_term scope, 82, 83 empty parameter, 81 PageSearch, 80, 81 page_search_spec.rb , 79 Rails ActiveRecord, 83 Ruby class, 79 Ruby module, 80 search by term, 83–85 Search controller and\n\nPage model , 79\n\nspec/services , 79\n\nsend_data method, 130 SessionsController, 155 Shared partial template, 69–71 Shoulda-matchers, 30, 38, 45, 47, 50, 144 Sidebar layout, 76–77 Sitemap\n\nblog application, 187 config/routes.rb file, 188 ERB template, 189–190 let statements, 191–192 spec/requests/home_spec.rb\n\nfile, 187–188 Tag URLs, 190–191 URL endpoint, 187 XML response, 188–189 Skipping password validation\n\nbug, 147 conditional, 147\n\nprivate helper method, 147\n\n:slug value , 65 spec/helpers directory, 114 spec/models directory, 120 spec/models/image_spec.rb ﬁle, 125 spec/models/user_spec.rb ﬁle, 135 spec/system/admin directory, 182 spec/system directory, 158 SQL query, 93–95, 97, 98 SSH, 211 Stimulus and Turbo, 206–208 Styling\n\nadmin login, 203–205 CSS\n\narchive list, 201–202 header, 199–200 no search results, 200–201 page summary, 200 pagination, 202–203 in rails, 199 search form, 201\n\nfunctioning application, 199 public pages, 199–203 wraps up, 205\n\nsubject variable , 45 system/admin/pages_spec.rb\n\nﬁle, 165, 166\n\nsystem/login_spec.rb ﬁle, 165 System specs\n\narticle element , 59 bundle exec command , 54 capybara , 52 Capybara’s find_all method, 59 Capybara’s within method, 59 conﬁgure Selenium, 57–58 display single page, 64–66 error message, 52 get route , 55 happy path, 63 homepage, testing, 51–54 .last , 59 Rails, 57 Rails g alias also , 54 Rails, root_path , 52 Rails view templates, 55–57 render method, 57 Request specs, 51 root method, 53 simulates user interaction, 51 yield method, 57\n\nT Tag factory, 106 Tagging pages\n\nafter save callbacks, 111–114 display tags on pages, 114–119 handling missing tags, 119–120 refactor duplicate code, 120–122\n\nTag model creation\n\n231\n\n232\n\n:name uniqueness validation, 107 :name validation, 107 page_tags_count column, 106 Rails generator, 105 Tag factory updation, 106 tag_spec.rb ﬁle updation, 106 uniq option, 106 TagsController, 118 TagsHelper module, 115 TagsHelper#tag_links method, 117 tags_string_for_form method, 161, 164 Test-driven development (TDD), 1, 2220\n\nadvantages\n\nacceptance test, 12 code design, 11 code quality, 12 maintain focus, 12 no broken windows, 11 problems with late testwriting\n\ncode spikes, 8 no code design, 7 pass by accident, 7–8\n\nred-green-refactor development cycle\n\ngreen phase, 9–10 red phase, 8–9 refactor phase, 10 wash, rinse, and repeat, 10–11 software design and engineering, 2 writing style, 2 test.rb ﬁle, 124 Third-party authentication library, 133 .to_sql method, 84\n\nU Uploading images\n\nactions method, 173 factor out our image matchers, 175–176 functionality, 172 has_one_attached\n\nassociation, 173\n\nImage model, 174 Rails’ .root method, 173 storage.yml ﬁle, 172\n\nUser.authenticate method, 155 User authentication arguments, 138 .authenticate class method, 137, 138 failure message, 138 one-way hashing, 139 password hash, 139\n\nUser factory, 35–37 User model\n\nblog post, 33 migration, 34, 35 rails generate command, 33\n\nrun specs, 37 user factory, 35–37 validation, 38–41 User model enhancement adding ﬁelds, 134–136 adding hashing library, 136–137 authentication (see Authentication\n\nenhancement)\n\npassword conﬁrmation, 144–146 password hashing, 133–134 skipping password validation, 146–147 user authentication, 137–139\n\nUsers management\n\nadding new users, 182–185 deleting users, 185–186 Image and Page models, 182\n\nUser Spec Cleanup, 49 users.rb ﬁle, 183\n\nV Viewing Images\n\nActiveAdmin.register block, 170 alt and title attributes, 170 within blocks, 169 CSS class col-image_tag, 171 failure message, 171 images_spec.rb ﬁle, 168 “views” or “view” templates, 55 View Specs\n\nBlog page layout, 74 pcontent/p tag, 71 CSS framework, 74 home/index template , 72 homepage, 71 Homepage Layout, 73 html_safe , 71 HTML article tag, 69 layout template, 74–76 pages/show template , 73 <p>tag, 71 shared partial template, 69–71 “show” view spec ﬁle, 72, 73 sidebar layout, 76–77\n\nVirtualHost conﬁguration, 211\n\nW “weblog” or “web log”, 1 within_window method, 166 World Wide Web, 4\n\nY yarn package, 223 yield method, 57\n\nIndex",
      "page_number": 228
    },
    {
      "number": 25,
      "title": "Segment 25 (pages 237-237)",
      "start_page": 237,
      "end_page": 237,
      "detection_method": "topic_boundary",
      "content": "",
      "page_number": 237
    }
  ],
  "pages": [
    {
      "page_number": 2,
      "content": "Hands-on Test-Driven Development",
      "content_length": 32,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 3,
      "content": "Greg Donald\n\nHands-on Test-Driven Development Using Ruby, Ruby on Rails, and RSpec",
      "content_length": 82,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 4,
      "content": "Greg Donald Clarksville, TN, USA\n\nISBN-13 (pbk): 978-1-4842-9747-6 https://doi.org/10.1007/978-1-4842-9748-3\n\nISBN-13 (electronic): 978-1-4842-9748-3\n\nCopyright © 2024 by Greg Donald This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microﬁlms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed. Trademarked names, logos, and images may appear in this book. Rather than use a trademark symbol with every occurrence of a trademarked name, logo, or image we use the names, logos, and images only in an editorial fashion and to the beneﬁt of the trademark owner, with no intention of infringement of the trademark. The use in this publication of trade names, trademarks, service marks, and similar terms, even if they are not identiﬁed as such, is not to be taken as an expression of opinion as to whether or not they are subject to proprietary rights. While the advice and information in this book are believed to be true and accurate at the date of publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or omissions that may be made. The publisher makes no warranty, express or implied, with respect to the material contained herein.\n\nManaging Director, Apress Media LLC: Welmoed Spahr Acquisitions Editor: Melissa Duffy Development Editor: James Markham Coordinating Editor: Gryfﬁn Winkler\n\nCover designed by eStudioCalamar\n\nCover image by Pexels@Pixabay.com\n\nDistributed to the book trade worldwide by Apress Media, LLC, 1 New York Plaza, New York, NY 10004, U.S.A. Phone 1-800-SPRINGER, fax (201) 348-4505, e-mail orders-ny@springer-sbm.com, or visit www.springeronline.com. Apress Media, LLC is a California LLC and the sole member (owner) is Springer Science + Business Media Finance Inc (SSBM Finance Inc). SSBM Finance Inc is a Delaware corporation. For information on translations, please e-mail booktranslations@springernature.com; for reprint, paperback, or audio rights, please e-mail bookpermissions@springernature.com. Apress titles may be purchased in bulk for academic, corporate, or promotional use. eBook versions and licenses are also available for most titles. For more information, reference our Print and eBook Bulk Sales web page at http://www.apress.com/ bulk-sales. Any source code or other supplementary material referenced by the author in this book is available to readers on GitHub (https:// github.com/Apress). For more detailed information, please visit https://www.apress.com/gp/services/source-code.\n\nPaper in this product is recyclable",
      "content_length": 2879,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 5,
      "content": "This book is dedicated to my wife and best friend, Sunni. She has been a constant source of support and encouragement during the writing of this book.",
      "content_length": 150,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 6,
      "content": "Contents\n\n1\n\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . What Are We Building? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Our Database . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Why Another TDD Book? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . My Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . How to Read This Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\nWhy You Should Trust Me\n\nAudience and Prerequisites\n\n2 What Is Test-Driven Development?\n\n7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Problems with Late Test Writing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 No Code Design 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Passing by Accident . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 Code Spikes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 The Red-Green-Refactor Development Cycle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 Red Phase. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 Green Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 Refactor Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 Wash, Rinse, and Repeat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 Code Design. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 No Broken Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 Maintaining Focus. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Acceptance Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Code Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n\nAdvantages of Building Software Using TDD\n\n3 Getting Started with Ruby . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 Installing Homebrew . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 Installing rbenv . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 Installing Ruby . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n\n4 Getting Started with Ruby on Rails . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 Installing Bundler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 Installing Ruby on Rails. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 Installing PostgreSQL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 Installing Node.js . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n\n1 1 2 3 3 4 5 5\n\nvii",
      "content_length": 4745,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 7,
      "content": "viii\n\n5\n\n6\n\n7\n\n8\n\n9\n\nCreating a New Ruby on Rails Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n\nRunning Rails Locally\n\nSetting Up RSpec and FactoryBot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 Installing RSpec . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 Installing FactoryBot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 The User Factory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 How to Run Specs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 User Model Validations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 The Page Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 RSpec’s “subject” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 FactoryBot “build” vs. “create” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 The Page slug. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 Page Factory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 Final Thoughts on Model Validations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 User Spec Cleanup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 Advice on Writing Too Many Specs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n\nAdding Initial Models The User Model\n\nCreating Pages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 Shared Partial Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 More View Specs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 Homepage Layout. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 CSS Framework. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 Layout Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 Sidebar Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77\n\nBuild Homepage Contents View Specs\n\nSidebar Contents. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 Search As a Service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 Implementing a Search Service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 Searching by Term . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 Adding a Search Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86 Displaying Search Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88 Pages Archive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91 Creating a List of Months and Years . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 Archive List View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 Archive Integration Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n\nSearching for Pages\n\nContents",
      "content_length": 5998,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 8,
      "content": "Contents\n\n10 Page Tags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 Adding Page Tags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 Creating the Tag Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 Creating the Page Tag Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107 Jumping Over Relationships . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 Tagging Pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 After Save Callbacks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 Display Tags on Pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114 Handling Missing Tags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119 Refactor Duplicate Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122\n\n11\n\nImages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 Active Storage for Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 Getting Started with Active Storage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 Adding an Image Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124 Serving Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127 Adding an Image Controller. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132\n\n12 User Authentication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133 Improving Our User Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133 Password Hashing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133 Adding Fields to Our User Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134 Add a Hashing Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136 Authenticating a User . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137 Improving Authentication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139 Password Conﬁrmation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144 Skipping Password Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148\n\n13 Administration\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149 Adding Active Admin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149 Adding the Gem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149 Testing Active Admin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150 Logging In . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150 Admin Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 Managing Pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158 Overriding Active Admin Form Field Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161 Factoring Out Duplicate Login Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164 Previewing a Page . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166 Managing Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 Viewing Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 Uploading New Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172 Editing Images. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176 Deleting Images. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180 Admin Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182\n\nManaging Users\n\nAdding New Users\n\nix",
      "content_length": 6220,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 9,
      "content": "x\n\nDeleting Users . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186\n\n14 Odds and Ends\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187 Build a Sitemap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187 Pagination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192 Fixing Specs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198 Styling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199 CSS in Rails . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199 Styling Our Public Pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199 Styling Our Admin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203 Wrapping Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205 Stimulus and Turbo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209\n\nCode Highlighting\n\n15 Bonus: Deploy to Production . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211 Why This Non-cloud Approach? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211 Acquiring a Production Linux Server . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211 Getting Production Ready . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212 Installing Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212 Installing Ruby . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213 Installing Phusion Passenger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213 Conﬁguring PostgreSQL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215 Storing Code on GitHub . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 Installing Capistrano. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 Conﬁguring Capistrano. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 Deploying Our Rails Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219 Conﬁguring Our Apache Virtual Host . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223 Logging In . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225\n\nIndex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227\n\nContents",
      "content_length": 4165,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 10,
      "content": "About the Author\n\nGreg Donald has been a professional software engineer since 1996 and has worked with Ruby on Rails since 2006. Prior to that, he worked on many Perl and PHP projects, ﬁnding the applications messy and hard to maintain. He became a test driven development enthusiasts after having seen the results of software written in various forms, and determining no style was more successful than TDD. He decided to write this book to promote TDD and share his positive experiences using it.\n\nxi",
      "content_length": 501,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 11,
      "content": "About the Technical Reviewer\n\nEldon isa senior technologist, creator, and United States Marine Corps veteran. He’s the author of two software development books. His career has allowed him to work across a wide variety of technologies and domains. His career has taken him from working in successful startups in roles ranging from senior developer to chief architect to working as a principal technologist for a global software consulting ﬁrm, helping enterprises and companies rescue software projects and/or evolve their software delivery capabilities.\n\nThese days, he works as a technical fellow with a mission of raising the bar of software development globally for a technology company providing tools, AI, and research to advance the rule of law.\n\nCurrently, he lives in Florida where he enjoys scuba diving and creating video content.\n\nxiii",
      "content_length": 846,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 12,
      "content": "Introduction\n\nHello, and welcome! I’m very excited to share with you my book about test-driven software development. I’ve been a software engineer for over 25 years, and I’ve seen the results of software written using many different styles and techniques. It wasn’t so long ago that we didn’t even write tests for our software. At some point, some very smart people realized that writing tests for our software was actually a good idea. Our tests would provide us with conﬁdence that our software worked as expected and even more importantly keep us from getting phone calls in the middle of the night to ﬁx things that would break in production.\n\nNot long after we started writing tests, some other very smart people realized that writing our tests ﬁrst would give us an opportunity to think about what we were going to write before we would write it. It would give us a target to aim at, in effect. This was the birth of test-driven development (TDD). TDD is a style of software development where we write our tests ﬁrst, see that they are failing as expected, and only then do we pursue writing the code to make those tests pass.\n\nThis is the central idea of my book. We will think about what we want to do, then we will capture that idea with a properly failing test. We will then write the code to make the test pass. We will then refactor our code to make it better, or prettier, or less repetitive, and then we will write another test. We will repeat this process over and over until we have a fully functional web application.\n\nLet’s get started!\n\nWhat Are We Building?\n\nAs you pick up this book and look inside at the ﬁrst few pages, you may be wondering, what exactly are we going to build? I’m so glad you asked! We will build a fully functional blog ! A “blog,” short for “weblog” or “web log,” is a web application that allows its administrator (you) to post articles to the Web. Instead of downloading premade blog software, for example, WordPress,1 we’re going to build our own blog software from scratch.\n\nWe’ll be using the Ruby2 programming language and the Ruby on Rails3 web framework to build everything. These are the best tools for the job, in my opinion. Ruby is a very expressive and powerful programming language, and Ruby on Rails is a very powerful web framework.\n\n1https://wordpress.org/ 2https://ruby-lang.org/ 3https://rubyonrails.org/\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_1\n\n1\n\n1",
      "content_length": 2554,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 13,
      "content": "2\n\n1 Introduction\n\nFigure 1-1 Blog database diagram\n\nWe’ll use the test-driven development (TDD) style of software design and engineering, which means we’ll write failing tests ﬁrst and only then write our implementation code to get our failing tests passing.\n\nWe’ll use the RSpec4 testing framework to write our tests. RSpec describes itself as a tool for performing “behavior-driven development” and is in fact the best tool available for testing Ruby code. If you’ve never used RSpec before, don’t worry; in this book, I’ll cover more than enough to get you started and productive.\n\nOur blog will be a simple web application overall, but will be complex enough to demonstrate the test-driven development style of software development. Our blog will allow us to create and update pages as well as search them by keyword and tag them for easy categorization.\n\nLet’s take a look at our database design next.\n\nOur Database\n\nWe will use the PostgreSQL5 relational database management system (RDBMS) to store our blog’s data. When it comes to free and open source databases, PostgreSQL is best in its class.\n\nAt the end of the book, our database design will look similar to the diagram in Figure 1-1.\n\n4https://rspec.info/ 5https://postgresql.org/",
      "content_length": 1244,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 14,
      "content": "Why Another TDD Book?\n\nWe’ll go into much more detail about our database design in later chapters, but I want to give you an initial idea of what we’ll be building early on. We will have database tables for users, pages, tags, and images. Our image table is not connected to any of the other previously mentioned tables. Our tag table is connected to our page table through our page_tags join table. Each of our pages will belong to a single user. With this design, we can have more than one user, and each user can be an author of many pages.\n\nWe will build up our database design as we go, adding new tables and columns as we need them,\n\nas that’s the nature of practicing proper test-driven development.\n\nWhy Another TDD Book?\n\nThe main goal of this book is to provide a practical, hands-on introduction to the test-driven style of software design and engineering.\n\nMany books on the topic of test-driven development have been written before this one. Some of them are actually very good, but none of them were written in the practical, hands-on style of this book. In fact, very few books are written in this style.\n\nThis book covers the building of an entire web application, from start to ﬁnish. Our focus application, a blog, is the most practical thing I could think to build, given my audience of software engineering readers. Every software engineer has their own online blog, right? A blog is simple enough that it can be covered in a single book, but complex enough that it can be used to demonstrate my favorite parts of RSpec while building a Ruby on Rails web application.\n\nMost other TDD books are written in a small-problem sort of writing style. They cover single topics, one at a time, barely more than a reference guide. They do not cover the entire process of building a software application from start to ﬁnish, using TDD. As a result, they are, in my opinion, less practical and much less useful for actually learning practical TDD.\n\nMy Motivation\n\nAbout ﬁve years ago, I joined a team of software engineers who were busy working on a very important (people’s lives were at stake) large-scale web application. They were several months into it at the time, and there were deadlines. The application was being written in Ruby on Rails, and the team was using TDD to build it. They were practicing Extreme Programming (XP),6 as described by Kent Beck,7 pretty much to the letter. I had heard of TDD and XP before, but had never actually practiced them. I had never even pair-programmed8 an entire day prior to joining the team. I was eager to learn, and little did I know at the time that I was working with some of the best software engineers I had ever met.\n\nThese girls and guys were amazingly agile. They refactored their code constantly. They were always looking for ways to reduce code complexity and improve their processes. They were constantly learning new things, and they were always teaching each other new things. They were very passionate about their craft and passionate about leveling up their team even more so.\n\nI soon realized I was in over my head. I was a n00b to the team, to TDD, and to XP. They did not\n\nseem to care about any of that.\n\n6www.extremeprogramming.org/ 7http://wiki.c2.com/?KentBeck 8http://wiki.c2.com/?PairProgramming\n\n3",
      "content_length": 3279,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 15,
      "content": "4\n\n1 Introduction\n\nThey were very patient with me, and they were completely willing to teach me everything they knew. They taught me how to practice proper TDD and XP. They taught me how to write failing tests ﬁrst and how to write code that is easy to test. They taught me how to write tests that supplied courage for when I would later perform fearless refactoring.\n\nOver the next couple of years, I became a much better software engineer. The ﬁrst major change I noticed in myself was how I had stopped worrying about code I had recently pushed into production. I was no longer thinking about code breaking in production during my off hours or how these sorts of breakages were often followed by an emergency phone call to hurry to ﬁx things. I had stopped worrying about code breaking because I knew my code was completely covered with well-written tests and very unlikely to break.\n\nAnother change I noticed in myself was that I was writing cleaner code. I was writing code that was easier to later understand. I was only writing the code that was necessary to get my tests into a passing state. I got into a pattern of knowing that once my tests pass, my implementation work was done. Moving on to refactor any ugliness or code duplication is my only next step before writing my next failing test.\n\nI’m telling you all of this because I want you to understand how I’ve come to learn and respect test-driven development. I learned it by doing it, for many years, with a team of experts. I know that developing software using TDD produces better software than not using TDD to develop software. I know this because I have seen the ﬁnal results with my own eyes.\n\nWhy You Should Trust Me\n\nI’ve been a computer programmer for a long time. If we’re counting uncompensated work, then I’ve been programming since 1984, when I wrote my ﬁrst bits of BASIC9 code on my grandpa’s TI- 99/4A,10 saving my work to a cassette tape. I went on to write more advanced programs and games in BASIC at my junior high school, where we had Apple IIe11 computers in our computer lab. A few years later, in high school, we had IBM PC clones12 in our computer lab, and it was at this time I learned to program in Turbo Pascal.13\n\nI joined the US Navy in 1990 and didn’t have much contact with computers for the next few years. When I got out in 1995, I discovered the World Wide Web was a thing, and I became instantly hooked on my newly found favorite hobby, building web pages. I taught myself HTML and enough Perl14 to be dangerous, and by late 1996, I had landed my ﬁrst paid programming job as a web developer working on Perl-based shopping cart software.\n\nSo if we’re counting compensated work, I’ve been a self-taught professional software engineer since late 1996. I’ve written code in almost every major programming language and on many different operating systems and platforms. My focus has been on web development for the most part, but I also have signiﬁcant experience working on mobile applications and games, in native code, for both Android and iOS. I was an early publisher on Google’s Android platform, having the ﬁrst published Blackjack game there.\n\n9http://hopl.info/showlanguage.prx?exp=176 10www.ti994.com/ 11www.old-computers.com/museum/computer.asp?st=1&c=83 12www.ibm.com/ibm/history/exhibits/pc/pc_1.html 13http://progopedia.com/implementation/turbo-pascal/ 14www.perl.org/",
      "content_length": 3381,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 16,
      "content": "How to Read This Book\n\nIn 2005–2006, I started working with Ruby on Rails. I had some experience with Ruby before that, automating processes on Linux, but didn’t get into Ruby seriously until I started working with Rails. Rails was my ﬁrst experience using the model-view-controller15 (MVC) design pattern, and it was a revelation to me. Prior to that, I had worked on many Perl and PHP16 projects, and I had always thought they were messy and hard to maintain, and there was certainly never anything like a test-suite present.\n\nI tell you all this to instill a bit of trust. I’ve seen software written many different ways, and I’ve seen the results of those pursuits. I’ve never seen software written using TDD that was not better than software written without TDD.\n\nAudience and Prerequisites\n\nI’ve seen many programmers, both beginners and those who have been programming for years, who can’t begin to imagine writing failing tests ﬁrst and only then writing the code to make those tests pass. This book will be useful in teaching you how to do that, providing conﬁdence and courage.\n\nThis book is written for beginner to intermediate Ruby programmers who are interested in learning to use TDD with RSpec to test and build web applications using Ruby on Rails. It is assumed that you have some experience with Ruby and Ruby on Rails and that you have read the Getting Started with Rails17 guide that’s available for Rails, or something similar.\n\nHow to Read This Book\n\nThis book should be read in a linear fashion, from beginning to end. The chapters are numbered and should be read in that order. This is not a reference guide and does not provide complete coverage of any particular topic. Those kinds of reference books already exist for many of the topics discussed in this book, and duplicating their authors’ efforts would not provide much value.\n\nThis is a work-along book. Every effort has been made to make this book self-contained, so that you can read it from cover to cover and not need to refer to any other resources. Nevertheless, I’ve been quite liberal in my use of footnote references to other resources, so please do visit them for additional information on unfamiliar topics.\n\n15http://wiki.c2.com/?ModelViewControllerHistory 16www.php.net/ 17https://guides.rubyonrails.org/getting_started.html\n\n5",
      "content_length": 2320,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 17,
      "content": "What Is Test-Driven Development?\n\nTest-driven development is a powerful software development technique where the test (or spec) is written before the implementation code. Initially, the test will fail because the implementation code does not exist yet. This situation with a failing test is expected and is known to drive out minimal implementation code changes or additions to get the failing test into a passing state. It may sound complicated at ﬁrst, but with a thorough demonstration of the beneﬁts, followed by a bit of practice, you’ll begin to prefer doing things this way.\n\nBut what happens when we don’t do test-driven development? What happens when we write our\n\ntests after the implementation code? I’m so glad you asked!\n\nProblems with Late Test Writing\n\nIn this section, we will explore some of the problems with writing tests after the implementation code has already been written.\n\nNo Code Design\n\nWhen we write our tests after the implementation code, we’re typically not thinking too much about the design of our code. We’re mostly just writing tests to make sure our code works. This is a very different, and less thoughtful, mindset than when we’re writing tests before the implementation code. When we write our tests before the implementation code, we’re thinking about the design of our code, how we want our code to behave and be used. We’re hopefully also thinking about how we want our code to be extended in the future, probably by us.\n\nPassing by Accident\n\nWhen we write our tests after the implementation code, we will inevitably write tests that pass by accident. This is because we’re not taking the time to see the tests fail ﬁrst.\n\nWe should never trust tests that we did not see fail ﬁrst.\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_2\n\n2\n\n7",
      "content_length": 1911,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 18,
      "content": "8\n\n2 What Is Test-Driven Development?\n\nThe one exception is that you may work on a team where you will not actually see every single newly written test fail before it’s made to pass. Obviously, we don’t want to delete our team members’ tests and hard work. But we should always have a high degree of skepticism about our own tests and pursue seeing them fail appropriately.\n\nThis advice of trusting tests based on individual experience with seeing them fail also comes with a bit of counter advice: don’t ever be afraid to delete a test that cannot be made to fail by temporarily reversing or commenting implementation code. Delete unfailable tests as soon as possible. Your continuous integration1 server will thank you.\n\nCode Spikes\n\nSometimes, we may need to explore our ideas, with code, a bit before we know what our desired behavior will be. Often, we write this sort of code knowing up front we will eventually throw it away. This act of writing throwaway code is known as code spiking and almost certainly also accompanies the deliberate act of not writing any tests beforehand. This situation should be rare, and we should always be thinking about how we can write tests that will fail when we’re done with exploring our ideas.\n\nPractically speaking, anytime I’m done with spiking some bits of code, I will comment the code out and then proceed with writing failing tests. I then uncomment my spiked code, a bit at a time usually, to get my tests passing. This is a very useful technique for safely exploring ideas with code and for junior TDD practitioners who have a hard time with test writing.\n\nWe’ve now explored some of the problems with writing tests after the implementation code. Let’s\n\nnow explore the beneﬁts of writing tests before the implementation code.\n\nThe Red-Green-Refactor Development Cycle\n\nTest-driven development can be thought of as a three-phase development cycle as shown in Figure 2-1.\n\n1. Red 2. Green 3. Refactor\n\nLet’s step through each phase and discuss it in more detail, with simple but practical code\n\nexamples.\n\nRed Phase\n\nIn the red phase of the TDD cycle, an initially failing test is written. Most often, this will just be a single test. It should be a minimal concept or idea designed to drive out a desired behavior.\n\n1http://wiki.c2.com/?ContinuousIntegration",
      "content_length": 2309,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 19,
      "content": "The Red-Green-Refactor Development Cycle\n\nFigure 2-1 The red-green-refactor development cycle\n\nImagine we want a method that adds two numbers and returns a result. An example failing test\n\nmight be\n\nit 'equals 4' do\n\nresult = add(2, 2) expect(result).to eq(4)\n\nend\n\nThis test will fail because there is a call to an add method that currently does not exist. This is a very useful test because it will focus our attention on our implementation code changes.\n\nNotice how most of the test is written in a way that it ﬂows like a couple of English sentences.\n\nThis is RSpec’s developer-friendly DSL in action; our tests are easy to read and understand.\n\nGreen Phase\n\nNext, we add our implementation code changes to turn the red failing test into a green passing test.\n\nThe ﬁrst error we get is the missing method error. We could add an empty method to satisfy the\n\nerror:\n\ndef add end\n\nAfter adding that, our test will still fail, but it will fail with a different error. It will complain about the argument signature being wrong. We can ﬁx that error with adding the desired arguments to the method signature:\n\ndef add(x, y) end\n\n9",
      "content_length": 1128,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 20,
      "content": "10\n\n2 What Is Test-Driven Development?\n\nFinally, we get to the end where the empty method returns nil instead of the value of the arguments being added together. We can ﬁx that by implementing the arguments being added together and returned:\n\ndef add(x, y)\n\nx + y\n\nend\n\nIt depends on the situation and your own experience level with the codebase for how ﬁne-grained you choose to have your red-green-refactor loop operate. I think stepping through it like this is a good way to get started with TDD, but I certainly don’t always do it this way. I sometimes even ﬁnd myself writing more than one test at a time and then implementing the code to make them all eventually pass.\n\nRefactor Phase\n\nAfter the green phase, we reach the refactor phase. In this simple example, there’s not much that can be refactored, but that’s a very short-term problem for anything larger than a small hello-world sort of program. Imagine if you decided to rename the add method’s x and y arguments to something else; perhaps you decide a and b would be more appropriate. The updated add method might then look like this:\n\ndef add(a, b)\n\na + b\n\nend\n\nThis sort of refactoring is considered safe since there is a test that will inform us if we break the implementation code. When we run the test again, it should still pass, letting us know our refactor was successful.\n\nAny sort of refactoring done outside of proper test coverage is dangerous. Software engineers who practice test-driven development always prefer implementation code changes be done under test, even if that means backﬁlling missing test coverage ﬁrst.\n\nThis section gave you a small taste of what you’re in store for with the rest of the book.\n\nWash, Rinse, and Repeat\n\nThe instructions from the back of the shampoo bottle “wash, rinse, and repeat” imply an endless cycle of performing the same tasks again and again (or just twice depending on how literal you take the meaning of the word “repeat”). In TDD, this is exactly what we do. At the end of our refactor phase,",
      "content_length": 2015,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 21,
      "content": "Advantages of Building Software Using TDD\n\nwe’re ready to repeat the cycle and begin with a new failing test. A repetitious red, green, refactor loop informs us sooner rather than later when we’ve accidentally gone down a wrong path.\n\nAdvantages of Building Software Using TDD\n\nIn the next section, we will discuss the beneﬁts of practicing test-driven development. These beneﬁts are not just for the individual software engineer but also for the entire software engineering team.\n\nCode Design\n\nTest-driven development encourages us to think through our code design before implementing the code.\n\nEvery experienced software engineer has at some point in their career worked on a poorly designed application codebase. Often, these codebases have little or no test coverage, making refactoring and improving them very dangerous. Even the smallest change over here could cause some unexpected breakage over there. Surprisingly, broken code in production is no fun at all!\n\nTDD gives us the power to make small incremental changes to our code design without the danger of unknowingly breaking things. Sure, sometimes our changes do break things; that’s to be expected. But with adequate test coverage, these breakages will alert us as soon as possible, so we can make informed decisions about the direction of our evolving code design. We may choose to stop and undo our latest change, or we may choose to push on and repair our test failures. Either way, it causes us to consider everything more carefully before we proceed.\n\nNo Broken Windows\n\nBroken Window Theory refers to urban decay. A single unﬁxed broken window in a neighborhood leads to a second broken window and so on until the entire community is in complete disrepair. This way of thinking about urban decay easily lends itself to how we think about software engineering. The idea of a broken window in software engineering can manifest itself in different ways. The ﬁrst way that comes to my mind is when a bug appears in the codebase and (hopefully) causes a test to begin to fail, and then for whatever reason no one immediately pursues ﬁxing it. The longer the unﬁxed bug lives on, the more risk there is for data corruption, user dissatisfaction, lesser revenues, or security issues.\n\nAnother type of broken window is a sort of generic term we software engineers refer to as technical debt, the unpaid time we still owe to the codebase that we didn’t pay when it was initially due. This can be anything like outdated software dependencies or duplicate lines of code that need to be factored out into a shared code module.\n\nThe longer these broken windows accumulate on top of each other, the more effort required to ﬁx\n\nthem when we do eventually get around to it.\n\n“I’ll ﬁx it, no need to remind me every 8 months!” The most important phase of TDD is the green phase. We never proceed with new development without getting our tests back to a fully passing state. A “green” codebase tells us all known software bugs are ﬁxed and any recently updated software dependencies are working as expected.\n\nGood software engineers ﬁx their broken windows as soon as possible!\n\n11",
      "content_length": 3135,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 22,
      "content": "12\n\n2 What Is Test-Driven Development?\n\nMaintaining Focus\n\nTDD keeps you focused on the problem, and just the problem.\n\nThere’s a software principle and acronym YAGNI2 that means you aren’t gonna need it. TDD- focused software engineers believe, when given a user story with well-written acceptance criteria, it is the job of the software engineers to do no more and no less than exactly what the story requests be done.\n\nThere is real danger in adding things not explicitly requested in the user story. Another engineer could already be adding the thing you are thinking to add while working on their current story. Or there could be a follow-on story where the new behavior is described there. We just don’t know what tomorrow’s user stories will bring, and with ﬁnite resources, it’s better to not guess.\n\nAcceptance Testing\n\nTDD lends itself naturally to automatically validated code. If your tests closely match the given acceptance criteria, then your implementation code will usually result in the desirable feature changes and behavior.\n\nA very nice side effect of using TDD is that it tells you exactly when you are done working on a user story. If all the new acceptance criteria tests are passing and there are no more refactorings in sight, then it’s usually time to deliver the story. So ship it!\n\nCode Quality\n\nTDD helps software engineers maintain high code quality. Implementation code is typically leaner and more precise than code written outside of TDD. Code refactorings occur more often when tests exist, helping to reduce the danger of change. We software engineers feel more empowered to pursue code cleanups and refactorings when we know the risk of breaking anything is lower.\n\nThese ways of thinking about software engineering play out across software engineering teams too. An individual team member is much more likely to care about code quality if other engineers are seen caring too.\n\nSummary\n\nThis chapter discussed the philosophy and beneﬁts of practicing test-driven development. You may not yet be convinced that TDD is the right way to go; I certainly wasn’t convinced early on. It just takes time to reprogram your brain to think to write the tests ﬁrst, especially if you’ve been writing software for a while already. Don’t give up; the struggle is worth the reward!\n\n2www.techtarget.com/whatis/deﬁnition/You-arent-gonna-need-it",
      "content_length": 2365,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 23,
      "content": "Getting Started with Ruby\n\nIn this chapter, we’ll install tools we can use to manage our installed Ruby versions. We will issue commands to our local operating system via the command-line interface1 (CLI) using a shell interpreter, which depending on your operating system is likely to be bash or zsh. On macOS, we can use the Terminal application to issue these commands, and similar programs are available on other operating systems:\n\n1. Homebrew 2. rbenv 3. Ruby\n\nInstalling Homebrew\n\nOn macOS, I use Homebrew2 to install most of my local software development stack. There’s a shell command on the Homebrew homepage I use to install it:\n\nURL=https://raw.githubusercontent.com/Homebrew/\\ install/HEAD/install.sh bash -c \"$(curl -fsSL $URL)\"\n\nIf trusting this way of installing Homebrew via direct URL execution makes you nervous, you can install Homebrew manually too:\n\nhttps://docs.brew.sh/Installation\n\n1www.codecademy.com/article/command-line-interface 2https://brew.sh\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_3\n\n3\n\n13",
      "content_length": 1163,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 24,
      "content": "14\n\n3 Getting Started with Ruby\n\nHomebrew also works on Linux and Windows Subsystem for Linux. If you’re working under those\n\nenvironments, you can ﬁnd more information here:\n\nhttps://docs.brew.sh/Homebrew-on-Linux\n\nInstalling rbenv\n\nAs previously mentioned, we will use rbenv3 to manage our Ruby installations. Using rbenv allows us to easily switch between different versions of Ruby with just a few keystrokes. This provides us with ﬂexibility to use different versions of Ruby for different projects and to easily upgrade to newer versions of Ruby when they are released.\n\nWe can install rbenv with the following brew command:\n\nbrew install rbenv\n\nAfter installation, rbenv then requires initialization in our command SHELL.4 We will place this initialization in our .bashrc or .zshrc ﬁle depending on which SHELL we are using. This will allow us to use rbenv commands in our shell and have it automatically conﬁgured anytime we start a new shell.\n\nzsh users will add this to the end of “.zshrc” and then source it:\n\necho 'eval \"$(rbenv init - zsh)\"' >> ~/.zshrc\n\n. ~/.zshrc\n\nbash users will perform a similar command and then source it:\n\necho 'eval \"$(rbenv init - bash)\"' >> ~/.bashrc\n\n. ~/.bashrc\n\nIf you’re not sure which SHELL you’re using, you can ﬁnd out by issuing the command echo\n\n$SHELL.\n\nInstalling Ruby\n\nInstalling Ruby will require we ﬁrst install some dependencies. Our Ruby compilation will fail or may not function correctly if we are missing these dependencies. We can install them from Homebrew using the brew command again:\n\n3https://github.com/rbenv/rbenv 4https://datacarpentry.org/shell-genomics/01-introduction/",
      "content_length": 1639,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 25,
      "content": "Installing Ruby\n\nbrew install openssl readline\n\nNow that we have our dependencies installed, we can use “rbenv” to install the latest version of Ruby:\n\nrbenv install 3.2.2\n\nThis command may take several minutes or longer to complete depending on our system specs.\n\nPlease note, the latest version will probably be different by the time you’re reading this book. You can ﬁnd the current latest version by running the rbenv list command with grep and sort, like this:\n\nrbenv install -L | grep -E '^\\d' | sort -V\n\nUsing grep with the proper regular expression removes all the more exotic implementations of Ruby from the list: jruby, rbx, and others. In this book, we’re going to use the original MRI5 (Matz’s Ruby Interpreter) version of Ruby, created by Yukihiro Matsumoto6 and friends.\n\nAfter rbenv installs your chosen version of Ruby, you can set that version to be your global\n\nversion:\n\nrbenv global 3.2.2\n\nNow we can run the which command and see that ruby and the Ruby gem command are both installed via rbenv shims:\n\nwhich ruby /Users/gd/.rbenv/shims/ruby\n\nwhich gem /Users/gd/.rbenv/shims/gem\n\nIf these which commands do not work for you right away, you may need to restart your terminal or shell application.\n\nrbenv shims are used to provide us the ability to easily switch between Ruby versions. If you\n\nwould like to pursue a deeper understanding of rbenv shims, more information is available.7\n\n5www.ruby-lang.org 6https://dbpedia.org/page/Yukihiro_Matsumoto 7https://github.com/rbenv/rbenv#understanding-shims\n\n15",
      "content_length": 1526,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 26,
      "content": "16\n\n3 Getting Started with Ruby\n\nLet’s now check that ruby is actually executable and is the version we installed:\n\nruby -v ruby 3.2.2 (2023-03-30 revision e51014f9c0)\n\nSuccess!\n\nIt’s also worth mentioning that there are other ways to accomplish what we’ve done here. For example, instead of using rbenv we could have instead used rvm.8 On macOS, instead of Homebrew we could have used MacPorts.9 My point is that if you already have a preference for other tooling to manage your Ruby installations, then feel free to use them.\n\nSummary\n\nIn this chapter, we installed Homebrew, rbenv, and Ruby. We learned to use the brew command to install software on our local machine. We also learned how to use rbenv to manage our Ruby versions. In the future, we can easily switch to a new version of Ruby with a single command. We can also now have any number of Ruby projects using different versions of Ruby.\n\n8https://rvm.io/ 9www.macports.org/",
      "content_length": 937,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 27,
      "content": "Getting Started with Ruby on Rails\n\nIn the previous chapter, we installed the Ruby language itself. In this chapter, we will install the Ruby on Rails1 framework and some additional tools Ruby software engineers use for Ruby on Rails application development:\n\n1. Bundler 2. Ruby on Rails 3. PostgreSQL\n\nInstalling Bundler\n\nBundler2 is a package manager that manages the dependencies of a Ruby application. Our project will use Bundler to manage the dependencies of our Ruby on Rails application speciﬁcally. Bundler is a Ruby gem, so we will use the Ruby gem3 command to install it:\n\ngem install bundler\n\nThis should produce output similar to the following:\n\nSuccessfully installed bundler-2.4.10 Parsing documentation for bundler-2.4.10 Done installing documentation for bundler after 0 seconds 1 gem installed\n\nBy the time you read this, the latest version of Bundler may be different, so feel free to use the latest version of Bundler available.\n\n1https://rubyonrails.org/ 2https://bundler.io/ 3https://guides.rubygems.org/rubygems-basics/\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_4\n\n4\n\n17",
      "content_length": 1231,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 28,
      "content": "18\n\n4 Getting Started with Ruby on Rails\n\nInstalling Ruby on Rails\n\nRuby on Rails is a web application framework written in the Ruby programming language. It’s designed to make programming web applications faster and easier by making opinionated decisions about what every web developer needs in their web development software stack. Ruby on Rails enables us to write less code while accomplishing more than any other language and framework, given similar effort.\n\nAs a framework, Ruby on Rails consists of several individual Ruby gems, but we only need to install a single gem to pull everything in at once. Let’s use the Ruby gem command to install the “rails ” gem:\n\ngem install rails\n\nThis command will generate a lot of output and should include something similar to the following:\n\nSuccessfully installed rails-7.0.4.3 Parsing documentation for rails-7.0.4.3 Done installing documentation for rails after 0 seconds 1 gem installed\n\nBy the time you read this, the latest version of Rails may be different, so feel free to use the latest available version.\n\nInstalling PostgreSQL\n\nPostgreSQL4 is a very popular relational database management system (RDBMS) used by a lot of Ruby on Rails applications and other web applications in general. We will use PostgreSQL to store the data for our Ruby on Rails application.\n\nAs you may have guessed, PostgreSQL is available to install from Homebrew, so we will use the\n\nbrew command to install it:\n\nbrew install postgresql@14\n\nAgain, by the time you read this, the latest version of PostgreSQL may be different, so feel free to use the latest version of PostgreSQL available. The PostgreSQL developers put a lot of effort into maintaining backwards compatibility, so there’s usually no need to worry about using the latest version of PostgreSQL.\n\n4www.postgresql.org/",
      "content_length": 1813,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 29,
      "content": "Installing Node.js\n\nAfter installing PostgreSQL, we need to start the PostgreSQL server:\n\nbrew services start postgresql@14\n\nAs a sanity check, we should use the PostgreSQL psql command to connect to the PostgreSQL server and run a simple SQL query:\n\npsql -d postgres -c \"SELECT version()\"\n\nThis should yield a result containing the version of PostgreSQL we just installed. If it does not work, and you get an error message about psql not being found, you may need to add the directory where the psql program was installed to your PATH environment variable. You can do this by adding the following line to your . ∼/.zshrc (or . ∼/.bashrc ) ﬁle:\n\nexport PATH=\"/opt/homebrew/bin:$PATH\"\n\nThis will prepend the directory path /opt/homebrew/bin to your existing $PATH and then re-export the new value to your shell environment. After making the change, run the following command to source and re-apply the contents of your . ∼/.zshrc ﬁle:\n\n. ~/.zshrc\n\nIf /opt/homebrew/bin is not the location where psql was installed, you will need to change the path to the location where psql was actually installed. It may, for example, be installed in /usr/local/bin or some other location like /opt/homebrew/Cellar/postgresql/ 14.x/bin.\n\nInstalling Node.js\n\nNode.js5 is a JavaScript runtime environment that we need for our Ruby on Rails application development. We won’t be using Node directly, but Rails commands, like the rails new command, will use Node.js to compile JavaScript assets for our application as we develop.\n\nNode.js is available to install from Homebrew, so we will use the brew command to install it:\n\nbrew install node\n\n5https://nodejs.org/\n\n19",
      "content_length": 1648,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 30,
      "content": "20\n\n4 Getting Started with Ruby on Rails\n\nAfter the install completes, we can see that Node.js is installed by running the following commands:\n\nwhich node node --version npm --version npx --version\n\nIf these commands do not complete with successful output, you may need to add the directory where the node, npm, and npx programs were installed to your PATH environment variable, as we did with the psql program earlier.\n\nNow that we have Node.js installed, we can use it to install some Javascript packages Rails will need for our Ruby on Rails application development and very importantly when we run the rails new command shortly. We will use the npm command to install the esbuild, nodemon , and sass packages:\n\nnpm install -g esbuild nodemon sass\n\nNow we are ready to create our new Ruby on Rails application.\n\nCreating a New Ruby on Rails Application\n\nIn this book, we will create a Ruby on Rails application in the form of a blog. We will use the Ruby on Rails rails new6 command to create our new Ruby on Rails application. Before proceeding, let’s discuss our rails new command-line options we will use to conﬁgure our new Ruby on Rails application creation.\n\nWe are going to use RSpec for testing, so for now we will use the -skip-test option to tell Ruby on Rails to skip creating its own test directory and related ﬁles. There’s currently no command-line option to add RSpec (which is preposterous), so we will add RSpec manually later.\n\nWe will use the --database=postgresql option to tell Ruby on Rails to conﬁgure our app for use with PostgreSQL as the database for our application. This option will cause a Gemﬁle entry to be added for the pg gem and will preconﬁgure our config/database.yml ﬁle for use with PostgreSQL.\n\nJavaScript support has evolved a lot in recent years, and Ruby on Rails has a new way of handling JavaScript dependencies called importmap.7 We will use that along with esbuild8 for our JavaScript bundler.\n\nFinally, we will use Bootstrap9 for our CSS framework. Bootstrap is a very popular CSS framework that provides lots of convenient CSS classes to make building web applications easier for both web and mobile apps.\n\n6https://guides.rubyonrails.org/command_line.html#rails-new 7https://github.com/rails/importmap-rails 8https://esbuild.github.io/ 9https://getbootstrap.com",
      "content_length": 2313,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 31,
      "content": "Creating a New Ruby on Rails Application\n\nBefore you blast me with an email about how Bootstrap is the old way and how Tailwind is the new hotness, I know. I’m going to use Bootstrap for this book because it’s what I know best and it’s what I like.\n\nAnother consideration is in what directory do we run the rails new command? The simple answer is that it doesn’t matter much. The rails new command we’re going to use makes a directory and puts everything inside it. You can then move this directory around to where you want it to live, now or in the future.\n\nI personally like to store my Rails-speciﬁc code in my\n\n. ∼/workspace/rails directory, so I\n\nwill run the rails new command after I change into that directory, like this:\n\ncd ~/workspace/rails\n\nBe sure to use whatever directory you prefer for your Rails code.\n\nrails new \\\n\n--skip-test \\ --database=postgresql \\ --javascript=esbuild \\ --css=bootstrap \\ blog\n\nRunning the rails new command will take some time to complete. When it’s done, you will have a new directory called blog containing the ﬁles for our new Ruby on Rails blog application.\n\nChange directory into the blog directory:\n\ncd blog\n\nWe can now start our local Rails server using Bundler’s bundle exec command. This command will run Rails in the context of our application’s Gemﬁle, which will ensure that we are using the correct version of Ruby and Rails and all of the other gems we need for our application.\n\nbundle exec rails server\n\nWe should see output similar to the following:\n\n=> Booting Puma => Rails 7.0.4.3 application starting in development => Run `bin/rails server --help` for more startup options Puma starting in single mode... * Puma version: 5.6.5 (ruby 3.2.2-p53) (\"Birdie's Version\")\n\n21",
      "content_length": 1731,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 32,
      "content": "22\n\n4 Getting Started with Ruby on Rails\n\nFigure 4-1 The Ruby on Rails error page\n\nMin threads: 5 * Max threads: 5 * Environment: development * * Listening on http://127.0.0.1:3000 * Listening on http://[::1]:3000 Use Ctrl-C to stop PID: 11869\n\nIf we visit the Rails welcome page at http://127.0.0.1:3000 in our web browser, we should see an error page like the one in Figure 4-1. This is because we haven’t created the database named blog_development that is deﬁned in our config/database.yml ﬁle yet. We can ﬁx the error by creating the database using the rails db:create command:\n\nbundle exec rails db:create\n\nRunning this command will produce the following output:\n\nCreated database 'blog_development' Created database 'blog_test'\n\nAs seen in the output, we actually get two databases, a development database and a test database. The development database is used for development, and the test database is used strictly for running tests that we will begin writing shortly.\n\nNow if we visit the Rails welcome page at http://127.0.0.1:3000 in our web browser, we should\n\nsee the Rails welcome page as referenced in Figure 4-2.",
      "content_length": 1128,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 33,
      "content": "Creating a New Ruby on Rails Application\n\nFigure 4-2 The Ruby on Rails welcome page\n\nRunning Rails Locally\n\nAs mentioned previously, we can run our Ruby on Rails application locally using the rails server command along with the bundle exec preﬁx. That’s ﬁne for developing Ruby code, but our Rails application will also contain CSS and JavaScript code. There are many different ways to handle CSS and JavaScript in a modern Ruby on Rails application, in both development and production environments.\n\nTo ease the burden of managing Ruby, CSS, and JavaScript in our local development environment, the rails new command we ran earlier automatically created a Procfile.dev ﬁle in our application’s root directory. This ﬁle contains process deﬁnitions we need to run our Rails application in our local development.\n\nIf we have a look at the Procfile.dev ﬁle, we will see the following contents:\n\nweb: unset PORT && env RUBY_DEBUG_OPEN=true bin/rails server js: yarn build --watch css: yarn watch:css\n\nAs is often the case with other ﬁles generated by the rails new command, this ﬁle tends to evolve over time and may appear slightly different in the future. For now, we can see there are three lines, and each line represents a process that will be run when we do something with this ﬁle, but how do we run it?\n\n23",
      "content_length": 1310,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 34,
      "content": "24\n\n4 Getting Started with Ruby on Rails\n\nFigure 4-3 Running Rails using foreman\n\nWe need to use the foreman10 command to run the processes deﬁned in our Procfile.dev ﬁle. The foreman command can be acquired by installing the foreman gem using the command:\n\ngem install foreman\n\nBefore we can actually run foreman we need to install yarn, a tool that will be used to automate compiling our Javascript and CSS ﬁles for us. There are many ways to install yarn. I install it from Homebrew using the command:\n\nbrew install yarn\n\nOnce we have foreman and yarn installed, we can run foreman using the command:\n\nforeman start -f Procfile.dev\n\nThis will start the web, js, and css processes deﬁned in our Procfile.dev ﬁle. The output will look similar to Figure 4-3. The web process is the Rails server we started earlier. The js process is a process that will watch for changes to our JavaScript ﬁles and rebuild them as needed. The css process is a process that will watch for changes to our CSS ﬁles and rebuild them as needed. This will save us a lot of time when developing our Ruby on Rails application.\n\n10https://github.com/ddollar/foreman",
      "content_length": 1139,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 35,
      "content": "Summary\n\nWe’re almost ready to begin writing our Ruby on Rails blog application in earnest. If you are planning on following along with the rest of the book, you would be wise to commit your code to a version control system at this point.\n\nSummary\n\nIn this chapter, we installed the Ruby on Rails framework, along with Bundler and PostgreSQL. We created a new Ruby on Rails application using the rails new command. We also learned how to run our Ruby on Rails app in our local development environment using the foreman command. Next, we will add RSpec and FactoryBot to our Ruby on Rails application to facilitate writing our ﬁrst tests.\n\n25",
      "content_length": 641,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 36,
      "content": "Setting Up RSpec and FactoryBot\n\nRSpec1 is a testing framework for Ruby. RSpec is available to us as a domain-speciﬁc language2 (DSL) written in Ruby and used to test Ruby code. RSpec tests the behavior of Ruby code and considers itself to be a “behavior-driven development” (BDD) framework. RSpec is most widely used for testing Rails applications, but can be used to test any Ruby code.\n\nRuby on Rails by default comes with the testing framework Test::Unit. In the previous chapter when we used the rails new command to create our Rails blog application, we added the --skip-test option to disable Test::Unit. Like most Rails developers, we will use RSpec instead of Test::Unit.\n\nInstalling RSpec\n\nRSpec is a gem, so we can add it to our Rails blog application by adding it to our Gemfile and running the bundle command. We want RSpec to be available in both the Rails development and test environments, so we will add it to both the :development and :test groups in our Gemﬁle. The Gemﬁle addition should then look like this:\n\ngroup :development, :test do\n\ngem 'rspec-rails'\n\nend\n\nLet’s save our Gemﬁle changes and run the bundle command:\n\nbundle\n\nRunning the bundle command or more verbosely the bundle install command will install the rspec-rails gem and all of its dependencies. The bundle command will also update the Gemfile.lock which is used to lock our gems and their dependent gems to speciﬁc versions. This\n\n1https://rspec.info 2www.jetbrains.com/mps/concepts/domain-speciﬁc-languages/\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_5\n\n5\n\n27",
      "content_length": 1687,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 37,
      "content": "28\n\n5 Setting Up RSpec and FactoryBot\n\nis important because it ensures we are using the gem versions we mean to in all of our potential Rails environments.\n\nRSpec has now been added to our blog application, but we need one more step to get it working.\n\nWe need to run the rails generate rspec:install command:\n\nbundle exec rails generate rspec:install\n\nWe should see the following output:\n\ncreate .rspec create spec create spec/spec_helper.rb create spec/rails_helper.rb\n\nWe can now verify that RSpec is installed and conﬁgured by running the rspec command:\n\nbundle exec rspec\n\nWe should see the following output:\n\nNo examples found.\n\nFinished in 0.0002 seconds (files took 0.0351 seconds to load) 0 examples, 0 failures\n\nThis output tells us that RSpec is installed and properly conﬁgured within our Rails application. We have no tests yet, so RSpec lets us know that it found “no examples” to run. In RSpec lingo, an example is actually a test, or a spec. We will soon be adding our ﬁrst RSpec example, so let’s move on for now.\n\nInstalling FactoryBot\n\nFactoryBot3 is a Ruby gem that provides a framework and domain-speciﬁc language (DSL) for deﬁning and using factories. A FactoryBot factory is a blueprint for creating instances of Ruby classes, or in our use case, Rails ActiveRecord objects. FactoryBot is most widely used for testing Rails applications, but can also be used to test any sort of Ruby code.\n\nBut do we really need FactoryBot? Can’t we just create our test data using Rails and ActiveRecord\n\nobjects directly?\n\n3https://github.com/thoughtbot/factory_bot",
      "content_length": 1574,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 38,
      "content": "Installing FactoryBot\n\nWe could indeed create all of our test data for our blog application using only Rails ActiveRecord objects. For example, we could create a new user object using User.new, and then we could create a new page object using Page.new(user:) that belongs to that user. But this is tedious and error prone, especially if we need to create similar test data many times over or if we need test data with particular traits.\n\nFactoryBot provides more concise and ﬂexible ways to create test data. We can deﬁne reusable traits that we can then mix and match to reliably create exactly the test data that we need. We can also choose to only build (not create) test data, without actually saving it to our database. This is very useful when we want to test ﬁeld validation errors, for example.\n\nFactoryBot is of course packaged as a Ruby gem, and there is a Rails-speciﬁc version called factory_bot_rails that we can use. Let’s add it to our application by adding the following line to our Gemfile and running the bundle command:\n\ngem 'factory_bot_rails'\n\nWe want FactoryBot to be available in all Rails environments, so we will add it outside of any group blocks in our Gemﬁle.\n\nAnytime we add a gem to our Gemﬁle, we need to then run the bundle command to install the new gem and its dependencies. We’ve done it a few times already, so to save space we won’t show the output anymore.\n\nWe need to integrate FactoryBot into our Rails application. So let’s add it to our spec/spec_\n\nhelper.rb ﬁle. Near the top, add the following line:\n\nrequire 'factory_bot_rails'\n\nThen, just inside our RSpec.configure block, let’s add the following:\n\nconfig.include FactoryBot::Syntax::Methods\n\nThese additions to our RSpec conﬁguration will allow us to use all of the FactoryBot methods in our specs. For example, instead of using the fully qualiﬁed “FactoryBot” namespace to call the FactoryBot.create method, we can instead just use the create method directly. This will make our specs cleaner and save us some keystrokes as well.\n\nAnother FactoryBot integration we want to take advantage of is the ability for Rails code generators to create factories for our models. To enable this, we need to add the following near the top of our config/application.rb ﬁle:\n\nrequire 'factory_bot_rails'\n\n29",
      "content_length": 2290,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 39,
      "content": "30\n\n5 Setting Up RSpec and FactoryBot\n\nFurther down, inside the same ﬁle, let’s add this bit of extra conﬁguration inside our Application class:\n\nconfig.generators do |g|\n\ng.test_framework :rspec, fixture: true g.fixture_replacement :factory_bot, dir: 'spec/factories'\n\nend\n\nThis will conﬁgure the Rails model generator to use FactoryBot to create factory ﬁle stubs whenever we generate a new model. We Ruby developers (especially the author) love saving keystrokes whenever possible. Maybe not as much as Perl developers, but still.\n\nTo further facilitate our spec writing, let’s install another gem called shoulda-matchers.4 This gem provides a collection of RSpec-compatible one-liners and helpers that will aid us in testing common Rails functionality.\n\nLet’s modify our Gemfile to add the following line inside the :test group:\n\ngroup :test do\n\ngem 'shoulda-matchers'\n\nend\n\nThen let’s run the bundle command to install the new gem.\n\nTo integrate the shoulda-matchers gem into RSpec and Rails, we need to add the following\n\nconﬁguration into our spec/rails_helper.rb ﬁle; anywhere near the bottom is ﬁne:\n\nShoulda::Matchers.configure do |config|\n\nconfig.integrate do |with|\n\nwith.test_framework :rspec with.library :rails\n\nend\n\nend\n\nDebugging\n\nWhile writing our RSpec tests and Rails application code, we will inevitably encounter errors and other confusing situations where we may not understand exactly what is happening. When we do, we will need to be able to debug our code. We will need to be able to dig deeper into the code’s execution and see what is happening at each step. We will need to be able to inspect the variable values and follow different code paths.\n\n4https://github.com/thoughtbot/shoulda-matchers",
      "content_length": 1723,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 40,
      "content": "Installing FactoryBot\n\nThe easiest way to debug Ruby code is to use binding.irb. This is built into Ruby and allows us to drop into an irb session at any point in our code execution. An example call to binding.irb may look something like this:\n\n# debug.rb\n\ndef add(a, b) binding.irb a + b\n\nend\n\nputs add(1, 2)\n\nIn our ﬁle debug.rb, we deﬁne a method called add that takes two variables and adds them together, returning the result. We then call our method and use puts to print the result. We can run this code by executing it with the ruby command:\n\nruby debug.rb\n\nWhen our code executes, it will stop at the binding.irb line and drop us into an irb session. It will look something like this:\n\nFrom: debug.rb @ line 3 :\n\n1: 2: def add(a, b) binding.irb a + b\n\n=> 3: 4: 5: end 6: 7: puts add(1, 2) 8:\n\nirb(main):001:0>\n\nWe can then inspect our variables and execute any Ruby code we want. When we are done, we can exit the irb session by pressing ctrl-d or by typing the more verbose exit command:\n\nirb(main):001:0> a\n\n=> 1 irb(main):002:0> b => 2 irb(main):003:0> a + b => 3 irb(main):004:0> 3\n\n31",
      "content_length": 1098,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 41,
      "content": "32\n\n5 Setting Up RSpec and FactoryBot\n\nThis is a simple example, but binding.irb can be very useful when debugging more complex code too.\n\nThere are other more advanced debugging tools available for Ruby; two that I encounter regularly are pry and byebug. Give them a try and see which one(s) you like best. Over time, I’ve come to prefer binding.irb because I don’t have to install or conﬁgure anything extra to use it.\n\nSummary\n\nIn this chapter, we installed and conﬁgured RSpec and FactoryBot, two of the most important tools we will use going forward to create our Rails application’s test suite. We will write our tests using RSpec and shoulda-matchers, and we will use FactoryBot to create consistent test data for our tests. We also ran through a simple example showing how to use binding.irb to debug our code, just in case we get stuck and need to dig in deeper to ﬁgure something out.",
      "content_length": 894,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 42,
      "content": "Adding Initial Models\n\nIn this chapter, we will add our ﬁrst two Rails ActiveRecord models into our blog application. We will start with simple User and Page models and proceed to grow them, adding more functionality as we go along.\n\nRuby on Rails is overﬂowing with code generators. Rails code generators create lots of code for us when we run them. We can use the rails generate command, for example, to quickly generate a fully namespaced model or a controller with actions and views stubbed and ready for additional development. And since we already have RSpec and FactoryBot installed, we will get appropriately named stub ﬁles for those as well. Rails code generators can be huge time savers.\n\nThe User Model\n\nIn our blog app, a Page model will represent a blog post, and a User model will represent the person who wrote the blog post. This will allow multiple users to write blog posts if we need that scenario. We will begin by generating the User model using the rails generate command:\n\nbundle exec rails generate model \\\n\nUser \\ name:string:uniq \\ email:string:uniq\n\nThis will generate a model as well as a database migration, a factory, and a model spec. The output will look like this:\n\ninvoke active_record create create invoke create invoke create\n\ndb/migrate/20221030192603_create_users.rb app/models/user.rb rspec\n\nspec/models/user_spec.rb factory_bot\n\nspec/factories/users.rb\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_6\n\n6\n\n33",
      "content_length": 1582,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 43,
      "content": "34\n\n6 Adding Initial Models\n\nThe generated migration ﬁle will look like this:\n\nclass CreateUsers < ActiveRecord::Migration[7.0]\n\ndef change\n\ncreate_table :users do |t|\n\nt.string :name t.string :email t.timestamps\n\nend add_index :users, :name, unique: true add_index :users, :email, unique: true\n\nend\n\nend\n\nWe’re adding the uniq option to the name and email ﬁelds to make sure no two users can have the same name or the same email address. This is a common requirement for user accounts, and since we can easily enforce it directly in our database, we should. This will protect us from any other code that creates or modiﬁes user records outside of our Rails app.\n\nIn front of our unique database constraints, we will use Rails model validations.1 This will prevent us from showing actual Postgres errors in our web browser. When we try to create a new record with a duplicate name or email address, we will show a nicely formatted error message instead of the entire page being broken.\n\nLet’s run our new migrations to create our new database tables:\n\nbundle exec rails db:{migrate,test:prepare}\n\nThis will actually run two commands: ﬁrst db:migrate and then after that db:test:prepare will be run. The ﬁrst will run our migration against our development database, and the second will prepare our test database for use, making sure it matches our development database.\n\nMost of the time after I migrate my database, I run psql to connect to my database and check the schema. This is a good way to make sure the migration did what I expected. Let’s do that now. We can connect to our development database with the following Rails command:\n\nbundle exec rails db\n\nSince we’re using PostgreSQL, this command will connect us to our blog_development database using PostgreSQL’s psql program. If you’re on an underpowered machine, this may take longer than\n\n1https://guides.rubyonrails.org/active_record_validations.html",
      "content_length": 1913,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 44,
      "content": "The User Model\n\nyou’d like to start up, as it loads the entire Rails codebase. If it’s too much to bear, you can always run psql directly as shown in the previous chapter:\n\npsql blog_development\n\nOnce we’re connected to our database, we can run the \\d command to see a list of all the tables in our database:\n\nblog_development=# \\d\n\nList of relations\n\nSchema |\n\nName\n\n| Type | Owner\n\n--------+----------------------+-------+----------\n\npublic | ar_internal_metadata | table | gd | table | gd public | pages | table | gd public | schema_migrations public | users | table | gd (4 rows)\n\nAs we can see, our pages and users tables have been created. We can further examine the schema of a given table by running the \\d command followed by the table name:\n\nblog_development=# \\d users\n\nHave a look and make sure the users and pages tables match our migrations.\n\nThe User Factory\n\nNext, let’s improve our new user factory in spec/factories/users.rb. Right now, it looks like this:\n\nFactoryBot.define do factory :user do\n\nname { \"MyString\" } email { \"MyString\" }\n\nend\n\nend\n\n35",
      "content_length": 1069,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 45,
      "content": "36\n\n6 Adding Initial Models\n\nGiven our unique constraints on our name and email ﬁelds, this will fail on the second usage when it tries to create a user record with the same name and email as the ﬁrst usage. Let’s ﬁx that by adding a FactoryBot sequence to the name and email ﬁelds:\n\nFactoryBot.define do factory :user do\n\nsequence(:name) { |n| \"First#{n} Last#{n}\" } sequence(:email) { |n| \"user#{n}@example.com\" }\n\nend\n\nend\n\nThis will cause the factory to generate name values like “First1 Last1” and “First2 Last2” and email values like “user1@example.com” and “user2@example.com.” The sequence method takes a ﬁeld name and a block that will be called each time a new record is created. The block will be passed a sequential number that will be used to generate unique values.\n\nSome software engineers consider sequentially numbering ﬁeld values to be a sort of anti-pattern, but I think it’s a useful option. When we encounter a scenario where we need higher-quality values, we should deﬁnitely take the time to create them by hand. For most cases where we just need non-random unique values, a sequential numbering tool is a good way to accomplish that.\n\nNow we’re ready to add ﬁeld validation specs for our name and email ﬁelds to our User model.\n\nRight now, our User model spec located in spec/models/user_spec.rb looks like this:\n\nrequire 'rails_helper'\n\nRSpec.describe User, type: :model do\n\npending \"add some examples to (or delete) #{__FILE__}\"\n\nend\n\nLet’s remove the pending entry and replace it with a spec to make sure our factory is working as expected:\n\nrequire 'rails_helper'\n\nRSpec.describe User, type: :model do\n\nlet(:user) { build(:user) }\n\nit 'has a valid factory' do expect(user).to be_valid\n\nend\n\nend\n\nThis is a very simple spec, but it’s a good start. We are using the build method from FactoryBot to create a new User instance. build just creates the instance in memory and doesn’t write any data to our database, so it’s very fast. We create the User instance using RSpec’s let syntax. let is lazily evaluated and, as we’ll see later, can come in very handy for making our spec ﬁles clean and easy to understand.",
      "content_length": 2138,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 46,
      "content": "The User Model\n\nEvery factory we create should be this easy to instantiate, and adding a spec ensures we don’t accidentally break it later. Our spec just checks if our user instance is valid using RSpec’s be_* syntax. Our expect statement, as you may have guessed, is expecting our user instance to “be valid.” If it is not valid, then our spec will fail, and we will know that our factory became broken somehow. It’s equivalent to this more verbose version:\n\nexpect(user.valid?).to eq(true)\n\nRSpec’s be_* syntax is very powerful and can be used to test anything that responds to a boolean query. For example, we can test if a string is empty, like this:\n\nexpect('').to be_empty\n\nOr we can verify something is actually a hash or not:\n\nexpect({a: 1}).to be_a(Hash)\n\nHow to Run Specs\n\nWe software engineers have different preferences for how we like to run our specs. I like to run my specs in a terminal, so I can see the output and any errors in a large window, with the least amount of scrolling. I may also run my specs inside my code editor from time to time, but this is usually a scenario involving existing specs that I want to quickly verify that I have not broken.\n\nLet’s use the rspec command to run our new User model spec:\n\nbundle exec rspec spec/models/user_spec.rb\n\nThe output will look like this:\n\n.\n\nFinished in 0.04421 seconds (files took 0.78106 seconds to load) 1 example, 0 failures\n\nThere are two indicators here that our ﬁrst spec passed. The ﬁrst is the period (.) on the ﬁrst line. If our spec had failed, we would have got an F instead of a period. The second indicator is the 1 example, 0 failures.\n\n37",
      "content_length": 1627,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 47,
      "content": "38\n\n6 Adding Initial Models\n\nUser Model Validations\n\nto our User model spec ﬁle. the the validate_uniqueness_of shoulda-matchers. Let’s\n\nNow We need validate_presence_of and add these to our spec ﬁle just below the previous spec:\n\nthat we can run specs,\n\nlet’s add ﬁeld validation specs\n\nto ﬁrst\n\ntest\n\nthat our name ﬁeld\n\nis present and unique. We can do\n\nthis with\n\ndescribe 'validations' do\n\nit { is_expected.to validate_presence_of(:name) } it { is_expected.to validate_uniqueness_of(:name) }\n\nend\n\nI tend to put all my shoulda-matchers and validations near the top of my spec ﬁle, but you can organize your specs however you like. You could add these new specs to the top or to the bottom of your own ﬁle; RSpec does not care about the order when it runs your specs.\n\nWhen we run our spec, we will get two expected failure messages:\n\n1) User validations is expected to validate that :name cannot be empty/falsy\n\nFailure/Error: it { is_expected.to validate_presence_of(:name) }\n\nExpected User to validate that :name cannot be empty/falsy, but this could not be proved.\n\nAfter setting :name to ‹\"\"›, the matcher expected the User to be invalid, but it was valid instead.\n\n2) User validations is expected to validate that :name is case-sensitively unique\n\nFailure/Error:\n\nit { is_expected.to validate_uniqueness_of(:name) }\n\nExpected User to validate that :name is case-sensitively unique, but this could not be proved.\n\nAfter taking the given User, whose :name is ‹\"First2 Last2\"›, and saving it as the existing record, then making a new User and setting its :name to ‹\"First2 Last2\"› as well, the matcher expected the new User to be invalid, but it was valid instead.\n\nWe are using RSpec’s describe block syntax to group our specs into logical units. First, we have a validations group, then inside we begin to use RSpec with shoulda-matchers to test individual ﬁelds. To get these two specs to pass, we need to add our missing name ﬁeld validations to our User\n\nmodel. We can do this by adding the following to our User model:\n\nclass User < ApplicationRecord\n\nvalidates :name,\n\npresence: true,",
      "content_length": 2098,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 48,
      "content": "The User Model\n\nuniqueness: true\n\nend\n\nThis gets our name specs to pass. We can now add specs to test that our email ﬁeld is also present and unique:\n\nit { is_expected.to validate_presence_of(:email) } it { is_expected.to validate_uniqueness_of(:email) }\n\nWhen we re-run our spec, we get the following output:\n\n1) User validations is expected to validate that :email cannot be empty/falsy\n\nFailure/Error:\n\nit { is_expected.to validate_presence_of(:email) }\n\nExpected User to validate that :email cannot be empty/falsy, but this could not be proved.\n\nAfter setting :email to ‹\"\"›, the matcher expected the User to be invalid, but it was valid instead.\n\n2) User validations is expected to validate that :email is case-sensitively unique\n\nFailure/Error:\n\nit { is_expected.to validate_uniqueness_of(:email) }\n\nExpected User to validate that :email is case-sensitively unique, but this could not be proved.\n\nAfter taking the given User, whose :email is ‹\"user4@example.com\"›, and saving it as the existing record, then making a new User and setting its :email to ‹\"user4@example.com\"› as well, the matcher expected the new User to be invalid, but it was valid instead.\n\nTo get these two email specs to pass, we need to add the following to our User model:\n\nvalidates :email,\n\npresence: true, uniqueness: true\n\nThis gets our email specs to pass.\n\nWe can also add some sanity checks to ensure our email address data looks like actual email addresses. How far you take email address validation is up to you. I (used to?) have a Perl book that showed a regular expression to properly validate an email address, and it is more than an entire printed\n\n39",
      "content_length": 1643,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 49,
      "content": "40\n\n6 Adding Initial Models\n\npage in length. We’re not going to go that far here, but we can add some simple sanity checks to our describe validation block:\n\nit { is_expected.to_not allow_value('foo@').for(:email) } it { is_expected.to_not allow_value('@bar.com').for(:email) }\n\nWhen we re-run our spec, we get the expected failure messages:\n\n1) User validations is expected not to allow :email to be ‹\"foo@\"› Failure/Error:\n\nit { is_expected.to_not allow_value('foo@').for(:email) }\n\nAfter setting :email to ‹\"foo@\"›, the matcher expected the User to be invalid, but it was valid instead.\n\n2) User validations is expected not to allow :email to be ‹\"@bar.com\"› Failure/Error:\n\nit { is_expected.to_not allow_value('@bar.com').for(:email) }\n\nAfter setting :email to ‹\"@bar.com\"›, the matcher expected the User to be invalid, but it was valid instead.\n\nWe can get these two specs passing by adding a format validation to our User model email validation:\n\nvalidates :email,\n\npresence: true, uniqueness: true, format: { with: /\\A\\S+@\\S+\\z/ }\n\nThe content of our with: parameter is a regular expression that will validate the format of our email addresses. We use word boundary matchers \\A and \\z to ensure the email address does not begin or end with a whitespace character. We use \\S to match any number of non-whitespace characters, followed by matching the @ symbol. Last we make sure we have some non-whitespace characters after the @ symbol. This is a very simple regular expression, but it will catch a lot of common mistakes made when entering email addresses.",
      "content_length": 1563,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 50,
      "content": "The Page Model\n\nLet’s leave our User model as is for now and move on to our Page model.\n\nThe Page Model\n\nLet’s work on our Page model next. We’ll use the rails generate command as before:\n\nbundle exec rails generate model \\\n\nPage \\ user:references \\ title:string:uniq \\ slug:string:uniq \\ summary:text \\ content:text \\ published:boolean:index\n\nThis will generate a Page model as well as a database migration , a factory , and a model spec . The output will look like this:\n\ninvoke active_record create create invoke create invoke create\n\ndb/migrate/20221030235303_create_pages.rb app/models/page.rb rspec\n\nspec/models/page_spec.rb factory_bot\n\nspec/factories/pages.rb\n\nThe generated Page migration ﬁle needs some work. There are a few things Rails does not currently support with command line–generated database migrations, adding an index to our created_at ﬁeld or setting ﬁelds to not be NOT NULL (null: false), for example. We’ll need to manually update our migration to look like this:\n\nclass CreatePages < ActiveRecord::Migration[7.0]\n\ndef change\n\ncreate_table :pages do |t|\n\nt.references :user, null: false, foreign_key: true t.string :title, null: false t.string :slug, null: false t.text :summary, null: false t.text :content, null: false t.boolean :published, null: false, default: false t.timestamps\n\nend add_index :pages, :title, unique: true add_index :pages, :slug, unique: true add_index :pages, :published add_index :pages, :created_at\n\n41",
      "content_length": 1454,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 51,
      "content": "42\n\n6 Adding Initial Models\n\nend\n\nend\n\nNow we can run our new migration to migrate our database:\n\nbundle exec rails db:{migrate,test:prepare}\n\nNext, let’s improve our new page factory in spec/factories/pages.rb. Currently, it’s using default values and looks like this:\n\nFactoryBot.define do factory :page do user { nil } title { 'MyString' } slug { 'my-string' } summary { 'MyText' } content { 'MyText' } published { false }\n\nend\n\nend\n\nLet’s ﬁrst add a spec to ensure the Page model instances we create with this factory are valid:\n\nrequire 'rails_helper'\n\nRSpec.describe Page, type: :model do\n\nlet(:page) { build(:page) }\n\nit 'has a valid factory' do expect(page).to be_valid\n\nend\n\nend\n\nWhen we run our spec/models/page_spec.rb specs, we see that our factory is not currently creating valid Page instances:\n\nF\n\nFailures:\n\n1) Page has a valid factory\n\nFailure/Error: expect(page).to be_valid\n\nexpected #<Page id: nil, user_id: nil, title: \"MyString\", slug: \"my-string\", summary: \"MyText\",",
      "content_length": 989,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 52,
      "content": "The Page Model\n\ncontent: \"MyText\", published: false, created_at: nil, updated_at: nil> to be valid, but got errors: User must exist\n\n# ./spec/models/page_spec.rb:7:in `block (2 levels) in <top (required)>'\n\nFinished in 0.05983 seconds (files took 1.08 seconds to load) 1 example, 1 failure\n\nFailed examples:\n\nrspec ./spec/models/page_spec.rb:6 # Page has a valid factory\n\nIt’s a big error message, with the important part being the line that says “User must exist.” We’re getting this particular error message because we gave our Page model a belongs_to :user association via our user:references command-line option. This means that every Page instance must have a user_id ﬁeld that references a valid User instance. We can ﬁx this by updating our Page factory to automatically create an associated User instance when we use it to create a new Page instance:\n\nuser { create(:user) }\n\nNow when we run our specs, we see that it passes.\n\nNext, let’s add more specs to our Page spec ﬁle. Let’s add specs to ensure the Page model is invalid when the title and content attributes are not present. We’ll also add a spec to ensure our title value is unique. We always want an associated user too, and we don’t want our database blowing up; we instead want Rails to catch the error before the database does. Let’s add the following Page model specs:\n\ndescribe 'validations' do\n\nit { is_expected.to belong_to(:user) } it { is_expected.to validate_presence_of(:title) } it { is_expected.to validate_uniqueness_of(:title) } it { is_expected.to validate_presence_of(:content) }\n\nend\n\nWhen we run our Page spec ﬁle, we see that we have a new failure:\n\n...F.\n\nFailures:\n\n1) Page validations is expected to validate that :title\n\n43",
      "content_length": 1715,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 53,
      "content": "44\n\n6 Adding Initial Models\n\nis case-sensitively unique\n\nFailure/Error: it { is_expected.to validate_uniqueness_of(:title) }\n\nShoulda::Matchers::ActiveRecord:: ValidateUniquenessOfMatcher::ExistingRecordInvalid: validate_uniqueness_of works by matching a new record against an existing record. If there is no existing record, it will create one using the record you provide.\n\nWhile doing this, the following error was raised:\n\nPG::NotNullViolation: ERROR: null value in column \"user_id\" of relation \"pages\" violates not-null constraint DETAIL: Failing row contains (1, null, null, null, null, null, f, 2022-11-02 00:27:42.12824, 2022-11-02 00:27:42.12824).\n\nThe best way to fix this is to provide the matcher with a record where any required attributes are filled in with valid values beforehand.\n\n# ./spec/models/page_spec.rb:14:in `block (3 levels) in <top (required)>' # ------------------ # --- Caused by: --- # PG::NotNullViolation: # # # # # # #\n\nERROR: null value in column \"user_id\" of relation \"pages\" violates not-null constraint DETAIL: Failing row contains (1, null, null, null, null, null, f, 2022-11-02 00:27:42.12824, 2022-11-02 00:27:42.12824). ./spec/models/page_spec.rb:14:in `block (3 levels) in <top (required)>'\n\nFinished in 0.1452 seconds (files took 0.87346 seconds to load) 5 examples, 1 failure\n\nFailed examples:\n\nrspec ./spec/models/page_spec.rb:14 # Page validations is expected to validate that :title is case-sensitively unique\n\nThis error message seems to be saying Postgres is preventing us from adding a new Page instance without a user_id ﬁeld, as previously discussed. But the weird part is it’s actually failing on the spec for requiring a unique title.\n\nWhat’s going on here? Is there some implied Page record being created?",
      "content_length": 1760,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 54,
      "content": "The Page Model\n\nRSpec’s “subject”\n\nWhen we’re using RSpec, each individual spec ﬁle has a sort of “magic” variable called \"subject\". This variable is automatically set based on our spec ﬁle’s name and what type of spec it is. In our case, we’re testing our Page model, so our implied subject variable is set to a new Page instance.\n\nOur shoulda-matchers use RSpec’s implied subject variable to perform the validation. So when we’re testing the uniqueness of our title value in a shoulda-matcher, we’re actually testing the uniqueness of our title value on the implied subject.\n\nIn our case, RSpec is by default building a new instance of Page without a user_id ﬁeld. It just doesn’t know any better unless we tell it to do something different. We can ﬁx our spec failure by telling RSpec what we actually want for a subject in our spec ﬁle. One option is to do something like this:\n\ndescribe 'validations' do\n\nsubject { build(:page) } it { is_expected.to belong_to(:user) } it { is_expected.to validate_presence_of(:title) } it { is_expected.to validate_uniqueness_of(:title) } it { is_expected.to validate_presence_of(:content) }\n\nend\n\nSo just inside our one describe block, we’re telling RSpec to use our own custom subject instead of the implied one. This works, but it’s a bit of a pain to have to do this for every describe block.\n\nAnother option could be to reuse the page we’re already building at the top of our spec:\n\nsubject { page }\n\nThis is an improvement, but it’s still not great because it’s redundant.\n\nThe solution I prefer is to deﬁne my subject at the top of my spec ﬁle, so my attention is\n\nimmediately drawn to it whenever I open the ﬁle:\n\nsubject { build(:page) }\n\nNow when we’re reading our spec ﬁle, we can immediately see what our subject is for all of our specs. Let’s do a bit of cleanup and have our Page spec look like this:\n\nrequire 'rails_helper'\n\nRSpec.describe Page, type: :model do\n\nsubject { build(:page) }\n\ndescribe 'validations' do\n\n45",
      "content_length": 1972,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 55,
      "content": "46\n\n6 Adding Initial Models\n\nit { is_expected.to belong_to(:user) } it { is_expected.to be_valid } it { is_expected.to validate_presence_of(:title) } it { is_expected.to validate_uniqueness_of(:title) } it { is_expected.to validate_presence_of(:content) }\n\nend\n\nend\n\nThere’s not much harm in redeﬁning our subject in any subsequent describe block, as needed, but we should try to have a clean and simple default subject at the top of each spec ﬁle if possible. Now that our code is better organized and we have become experts on RSpec’s subject variable, let’s get our failing specs passing by adding our currently missing model validations to our Page model:\n\nclass Page < ApplicationRecord\n\nbelongs_to :user\n\nvalidates :title,\n\npresence: true, uniqueness: true\n\nvalidates :content,\n\npresence: true\n\nend\n\nNow our Page specs are passing.\n\nFactoryBot “build” vs. “create”\n\nThere is the cost of a database write if our FactoryBot build call is instead a call to create. We should keep that in mind and always consider using build unless we actually need to persist the record in our database. We can even default to using build and then call .save on our subject as needed. It’s a great way to make sure we’re only persisting records when we actually need to.\n\nWriting records to our database is often the slowest part of a spec. It’s best to avoid doing it\n\nwhenever possible.\n\nThe Page slug\n\nIn web development, we should try to use human-friendly URLs for a given resource. Instead of using the URL http://example.com/pages/1, or the even uglier http://example.com/pages?id=1, we should build our app to use beautiful URLs such as http://example.com/pages/ﬁrst-page.\n\nThe “ﬁrst-page” part, at the end of the URL, is called the slug. I honestly do not know why it’s\n\ncalled that, but I’ve heard it called that so many times, I now call it that too.\n\nIt would be unnecessary extra work to create the URL-friendly slug every time we make a page, and since we’re already making a title that is very similar, we should just use the title to",
      "content_length": 2036,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 56,
      "content": "The Page Model\n\ngenerate the slug value for us. If we do it correctly, we can even maintain our slug uniqueness validation along the way.\n\nSo we want to provide a title with any sort of a value and then take that value and make it all lowercase, with no spaces, and using dashes as word delimiters. Let’s ﬁrst capture our idea in a new spec.\n\nLet’s provide a complicated title value and then make sure the slug ends up becoming what\n\nwe expect:\n\ndescribe '#slug' do\n\nlet(:page) { create(:page, title: '--Foo Bar! _ 87 --') }\n\nit 'is generated from the title' do\n\nexpect(page.slug).to eq('foo-bar-87')\n\nend\n\nend\n\nWhen we run this spec, we get the failure:\n\n1) Page#slug is generated from the title Failure/Error: expect(page.slug).to eq('foo-bar-87')\n\nexpected: \"foo-bar-87\" got: \"my-string\"\n\nThe \"my-string\" is still the default value for the slug ﬁeld in our factory. Let’s remove it, knowing that our subject uses the FactoryBot build method and that we need some sort of value for our shoulda-matcher to work. As expected, we get a different failure message:\n\nActiveRecord::NotNullViolation:\n\nPG::NotNullViolation: ERROR: null value in column \"slug\" of relation \"pages\" violates not-null constraint\n\nIt’s telling us that the slug ﬁeld is not allowed to be null, and remembering back to our database migration for our pages table, that’s correct behavior. We need to update our Page model to make our slug value for us, automatically.\n\nRails provides “callbacks” in the ActiveRecord class. A callback is a method that is called at a particular point in the life cycle of an ActiveRecord object. We can use a callback to generate our slug for us. We’ll use the before_validation callback to generate our slug just before we save the record to our database. There’s a before_save callback, but we want to generate our slug before Rails validates the record, so it would actually ﬁre too late for our particular use case, so we will user before_validation.\n\nclass Page < ApplicationRecord\n\n47",
      "content_length": 1991,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 57,
      "content": "48\n\n6 Adding Initial Models\n\n# previously added code omitted for brevity\n\nbefore_validation :make_slug\n\nprivate\n\ndef make_slug\n\nself.slug = title\n\n.downcase .gsub(/[_ ]/, '-') .gsub(/[^-a-z0-9+]/, '') .gsub(/-{2,}/, '-') .gsub(/^-/, '') .chomp('-')\n\nend\n\nend\n\nThat’s a lot of gsub calls, so let’s run through it all. First, we make the title lowercase by calling downcase. Then we replace all spaces and underscores with dashes, giving them special treatment early on since spaces and underscores are typical word delimiters. Then we remove any characters that are not dashes, lowercase letters, or numbers. Then we remove any duplicate dashes. Finally, we remove any dashes at the beginning and end of the string. That’s a lot of work to make a slug, but if you re-run our spec, you can see that it works and that our spec is now passing.\n\nPage Factory\n\nBefore we go much further, let’s polish our Page factory a bit. We can use FactoryBot sequences to generate different but predictable (not random) data for our Page data:\n\nFactoryBot.define do factory :page do\n\nuser { create(:user) } sequence(:title) { |n| \"Page Title #{n} \" } sequence(:slug) { |n| \"page-title-#{n} \" } sequence(:summary) { |n| \"<p>Page summary goes here #{n}</p>\" } sequence(:content) { |n| \"<p>Page content goes here #{n}</p>\" } created_at { Time.zone.now } published { false }\n\nend\n\nend\n\nRandom Test Data Some software engineers recommend using random data in their factories, for example, the Faker gem, but I strongly advise against doing that, especially if the randomly generated factory data is used in specs. Random test data causes random spec failures, which are often difﬁcult and time-consuming",
      "content_length": 1680,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 58,
      "content": "Final Thoughts on Model Validations\n\nto debug. These random test failures will at some point become blockers for important things like Friday afternoon production deployments!\n\nThe ﬁrst thing I do when I work on a randomly failing spec is to begin to look for where some bits of random data are coming into the picture, on purpose or by accident. Sometimes, things you don’t think will ever be random end up becoming random when you least expect it. Consider Time.zone.now and how it works on your local development machine where you probably have a local time zone set versus how it will work in a CI environment where the time zone is probably set to UTC. Then imagine your test suite running late in the evening where it becomes “tomorrow” compared to your local machine that still thinks it’s “today.” To complicate debugging efforts further, imagine some of your team members are on the other side of the planet from you.\n\nI do not use the term “ﬂakey spec” when describing a randomly failing spec. That sort of terminology has an underlying meaning of “I don’t really know why this spec is failing and I’d rather imply it’s RSpec’s fault instead of spending the time to ﬁgure it out.” Instead, I advise using the words “randomly failing spec” which is encouragement to spend the time to ﬁgure out why it’s random.\n\nRemember, RSpec is not a fuzzing tool, it’s an acceptance testing framework. Acceptance testing means putting in known inputs and expecting to get back predictable outputs. Always steer clear of random data in your factories and specs.\n\nFinal Thoughts on Model Validations\n\nThis chapter was a whirlwind tour of Rails model validations. We covered a lot of small topics and saw how they ﬁt together in a practical hands-on way. We used tools that actual Ruby software engineers use every day. We leaned heavily on FactoryBot and will continue to do so throughout the book. Repeatability is important, especially when it comes to writing specs.\n\nBefore we close out the chapter, let’s take a moment for some cleanup.\n\nUser Spec Cleanup\n\nA few sections ago, we became RSpec subject experts, so let’s now clean up our User spec:\n\nrequire 'rails_helper'\n\nRSpec.describe User, type: :model do\n\nsubject { build(:user) }\n\ndescribe 'validations' do\n\nit { is_expected.to be_valid } it { is_expected.to validate_presence_of(:name) } it { is_expected.to validate_uniqueness_of(:name) } it { is_expected.to validate_presence_of(:email) } it { is_expected.to validate_uniqueness_of(:email) } it { is_expected.to allow_value('foo@bar.com').for(:email) } it { is_expected.to_not allow_value('@bar.com').for(:email) } it { is_expected.to_not allow_value('foo@').for(:email) }\n\nend\n\nend\n\n49",
      "content_length": 2693,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 59,
      "content": "50\n\n6 Adding Initial Models\n\nThat’s a lot cleaner and easier to read, and we’re getting a lot of value out of such a small amount of code.\n\nAdvice on Writing Too Many Specs\n\nIn our blog application, we won’t pursue writing every single spec that is automatically generated for us. These automatically generated spec ﬁles are mostly harmless to remain empty, and we will eventually delete them when we don’t want them hanging around anymore. I wanted to take a moment to explain why we won’t be ﬁlling in every spec ﬁle that is generated for us.\n\nIt’s not that writing every single spec we can is a horrible world-ending idea, it’s that we will be\n\nwriting enough specs to provide more than ample cover of any logic we might create.\n\nUndoubtedly, you will have, or will soon have, your own preferences for what specs you want to write for your own apps. My preferences have evolved, as my experience grew. The best way to grow this level of experience is to practice test-driven development. Having a failing test, failing exactly like you expect it to fail, is the best way to learn how to write the best code possible, to get that spec to pass.\n\nSummary\n\nIn this chapter, we learned about shoulda-matchers and Rails model validations and how to use them to ensure our data is valid before it gets saved to our database. I also gave some experienced advice on how using random data often causes random test failures. Next, we’re going to jump headﬁrst into Rails routes and controllers while creating our application’s homepage.",
      "content_length": 1528,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 60,
      "content": "Creating Pages\n\nIt may be surprising to make it all the way to this chapter without having written any HTML yet; we are creating a web application after all! We’ve been doing a lot of preparation, making sure we get off to a solid start. Rest assured, it’s now time to get down to business. In this chapter, we’ll create our homepage, which will be the ﬁrst page that users see when they visit our site.\n\nWe’ll start by writing a system spec for our homepage and learn about Capybara,1 a tool that\n\nfacilitates web browser testing from inside our system specs.\n\nSystem Specs\n\nA system spec is a spec that simulates a user interacting with our application directly. It will do things exactly as the user would, things such as visiting URLs, ﬁlling out forms, and clicking buttons and links.\n\nBut why would we use a system spec when we could instead use a controller spec or a request spec? The two test types both make HTTP requests after all. The biggest reason is JavaScript. Request specs are great for testing the behavior of our application at the HTTP request/response level, and controller specs are great for testing the behavior of our Rails application at the routing/controller level, but neither of these approaches will exercise our JavaScript.\n\nTesting Our Homepage\n\nLet’s start by writing a simple system spec for our homepage. It will require signiﬁcant effort to get it to pass, but that’s how TDD works! We’ll start with adding a new spec ﬁle into our spec/system directory. Let’s add this to a ﬁle named home_spec.rb:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Home' do\n\nit 'renders homepage' do\n\nvisit root_path\n\n1http://teamcapybara.github.io/capybara/\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_7\n\n7\n\n51",
      "content_length": 1859,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 61,
      "content": "52\n\n7 Creating Pages\n\nwithin 'header' do\n\nexpect(page).to have_link 'My Blog'\n\nend\n\nend\n\nend\n\nWhen we run our new system spec with the command:\n\nbundle exec rspec spec/system/home_spec.rb\n\nwe get a lot of output, with the important part of the error message near the end:\n\nGem::LoadError:\n\ncapybara is not part of the bundle. Add it to your Gemfile.\n\n# ./spec/system/home_spec.rb:3:in `<top (required)>'\n\nThere’s nothing better than an error message telling us exactly what we need to do to ﬁx it! Let’s add capybara to our Gemﬁle, in our :test group:\n\ngroup :test do\n\ngem 'capybara'\n\nend\n\nThen, as before, we need to run bundle to install our new gem. Some Ruby developers like to run bundle install instead of just bundle, but I prefer less typing anytime I’m given the choice. Now that we have capybara installed, let’s run our new system spec again. Our previous error\n\nmessage is gone, but we have a new one:\n\nGem::LoadError: selenium-webdriver is not part of the bundle. Add it to your Gemfile.\n\nWe are presented with another highly informative error message; we need the selenium- webdriver. But before we add it to our Gemﬁle, let’s consider a better option. There is a gem called webdrivers that will automatically install the latest version of selenium-webdriver for us, as well as other webdrivers for many different web browsers. Let’s add it to our Gemﬁle and run bundle:\n\ngroup :test do\n\ngem 'webdrivers'\n\nend",
      "content_length": 1423,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 62,
      "content": "System Specs\n\nKeep in mind there may be other gems in the :test group of our Gemﬁle. To save space, I’m not going to show them all every time we make a modiﬁcation.\n\nNow that we have webdrivers installed, let’s run our spec again. This time, we get a different\n\nerror message:\n\n1) Home renders homepage\n\nFailure/Error: visit root_path\n\nNameError:\n\nundefined local variable or method `root_path' for #<RSpec::ExampleGroups::Home \"renders homepage\" (./spec/system/home_spec.rb:4)>\n\n# ./spec/system/home_spec.rb:5:in `block (2 levels) in <top (required)>'\n\nThis error message may seem cryptic, but it just means that we’re missing a Rails route. In Rails, the root_path is the path for the root URL of our application. As this is a brand-new Rails application, our root_path simply has not been deﬁned yet. If we open up config/routes.rb, we can see the root method is still commented out:\n\n# root \"articles#index\"\n\nLet’s uncomment it and add a route for our homepage, so our routes ﬁle looks like this:\n\nRails.application.routes.draw do\n\nroot 'home#index'\n\nend\n\nThe argument we’re passing to the root method is the name of a controller and action we will use for our homepage, separated with a # symbol.\n\nWhen we call up the root URL of our application, Rails will look for a controller class named Home that contains an action named index. If it ﬁnds them, it will execute the action and do whatever it says to do. If it doesn’t ﬁnd them, it will throw an error, just like we’ll see if we now run our spec again (you may have to scroll up a bit to see this exact error message):\n\n1) Home renders homepage\n\nFailure/Error: raise MissingController.new(error.message, error.name)\n\nActionController::RoutingError:\n\nuninitialized constant HomeController\n\n53",
      "content_length": 1750,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 63,
      "content": "54\n\n7 Creating Pages\n\nOur practice of test-driven development is really paying off. It continues to guide us with making changes, only as needed, to get our spec to pass. At this point, we’re being guided to create our Home controller and index action. Let’s create them now using a Rails generator:\n\nbundle exec rails generate controller home index\n\nA Quick Confession\n\nI’m going to confess something here. I don’t type that full bundle exec command very often. I’ve been typing it out up until now because it’s the proper way to use bundler with a Rails application. The truth is I have an alias in my .zshrc ﬁle that looks like this:\n\nalias be='bundle exec'\n\nIn addition to my alias, Rails itself has an internal alias for the generate portion of the command, the letter g. So what I usually type out for that command is this:\n\nbe rails g controller home index\n\nThis gives me the same result as if I have typed out the longer command. The Rails g alias also works for other generators like model. From now on, we’ll use the shorter commands.\n\nAfter we run our generate command, we get our new controller and our new controller action, and\n\nsome other new ﬁles as well:\n\ncreate app/controllers/home_controller.rb\n\nroute get 'home/index'\n\ninvoke erb create create invoke rspec create create create invoke helper create invoke create\n\napp/views/home app/views/home/index.html.erb\n\nspec/requests/home_spec.rb spec/views/home spec/views/home/index.html.erb_spec.rb\n\napp/helpers/home_helper.rb rspec\n\nspec/helpers/home_helper_spec.rb",
      "content_length": 1530,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 64,
      "content": "System Specs\n\nWe can ignore most of these ﬁles for now, but one change that just occurred inside our config/routes.rb ﬁle is the addition of a new get route:\n\nget 'home/index'\n\nRails is being helpful, and normally we may very well want the new route addition, but since we already have a route for our root_path, we don’t actually need it. Let’s remove it.\n\nLet’s run our spec again. Our previous error appears to be ﬁxed, and we’re getting a new error\n\nmessage:\n\n1) Home renders homepage Failure/Error:\n\nwithin 'header' do\n\nexpect(page).to have_link 'My Blog'\n\nend\n\nCapybara::ElementNotFound:\n\nUnable to find css \"header\"\n\nIt looks like it’s ﬁnally time to write some HTML, but where do we write it?\n\nRails View Templates\n\nIn Rails, the ﬁles that contain our HTML that gets rendered to our browser are called “views ” or “view templates.” In our Rails application, we’re using the default template engine “ERB,” which stands for “Embedded Ruby.” ERB is a templating language that allows us to embed Ruby code directly inside our HTML code, using a special template syntax. This is very useful because it allows us to use Ruby to dynamically generate HTML. For example, we can use Ruby to generate HTML that is different for each user of our application.\n\nIn Rails, an example block of ERB template code might look like this:\n\n<% if user_signed_in? %>\n\n<p>Welcome back, <%= current_user.name %></p>\n\n<% else %>\n\n<p>Welcome to our site!</p>\n\n<% end %>\n\nThe ﬁrst line of this code is just a plain old Ruby if statement. The magic is that it is wrapped with ERB opening and closing brackets. This allows us to embed Ruby code directly in our HTML code. The if condition checks to see if the current user is signed in. If the user is signed in, the next line of code will be evaluated, and the result will be inserted into the HTML, welcoming them back to our website by name. Notice the different <%= starting bracket syntax; it contains an = symbol unlike the\n\n55",
      "content_length": 1961,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 65,
      "content": "56\n\n7 Creating Pages\n\nother brackets surrounding our if code. We use this version of the opening ERB bracket when we want to insert something into our HTML.\n\nFollowing the if is an else condition with contents that will be evaluated if the user is not signed\n\nin. The last line of code is a closing end statement that ends the if/else conditions.\n\nTo explain it another way, ERB is just Ruby code that gets evaluated and inserted into our HTML.\n\nOutside of an ERB template, the preceding code is equivalent to this:\n\nif user_signed_in?\n\nputs \"<p>Welcome back, #{current_user.name}</p>\"\n\nelse\n\nputs '<p>Welcome to our site!</p>'\n\nend\n\nIn this example, our <%= current_user.name %> example code is equivalent to our #{current_user.name} code; the evaluation delimiters are just different from regular Ruby code to ERB code.\n\nIt’s easy to get used to ERB syntax. It’s just Ruby code with some special syntax that allows it to work inside of and with HTML. I can promise you that most of your ERB template debugging time will be spent on missing = symbols however; at least this is the case for me.\n\nThere are other template engines available for Ruby and Rails. I’ve worked with HAML2 on several\n\nRails projects, and I’ve heard good things about Slim.3 Give them a try if you’re interested.\n\nBack to our failing spec. Our spec is failing because it can’t ﬁnd the <header> element in our template. We need to create that element, but where? I can think of three possible places to put our HTML code:\n\n1. app/views/home/index.html.erb 2. app/views/layouts/application.html.erb 3. In a new partial ﬁle that we share between our views\n\nAs you might have guessed, the third option is the best option. But why?\n\nOur blog header will need to appear on every public page of our application, so we should put it in a partial ﬁle that we can render it inside our app/views/layouts/application.html.erb ﬁle. If we put our code in the app/views/home/index.html.erb ﬁle, we would end up having duplicate code for every page of our application that needs a header. This is something we want to avoid since changing it would then require us to edit many ﬁles instead of just one.\n\nPutting our code in our app/views/layouts/application.html.erb ﬁle would not be horrible, but this ﬁle can become very large and difﬁcult to manage if we put too much code into it. It’s better to keep our layout ﬁles small and use partials to represent the logical sections of our layout.\n\n2https://haml.info/ 3https://slim-template.github.io/",
      "content_length": 2506,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 66,
      "content": "System Specs\n\nLet’s create a new directory named app/view/shared and add a new partial ﬁle called\n\n_header.html.erb in there:\n\n<header>\n\n<%= link_to 'My Blog', root_path %>\n\n</header>\n\nNotice how our header ﬁle’s ﬁlename starts with an underscore. This is a Rails convention that tells Rails this ﬁle is a partial ﬁle. We can render this partial ﬁle in other templates by using the ﬁlename without the underscore. For example, we can render this partial in our app/views/layouts/application.html.erb ﬁle using the following line of code:\n\n<%= render 'shared/header' %>\n\nRails looks in our app/views directory for templates by default, so we don’t need to specify that directory path in our render method call. We just need to specify the path to the partial ﬁle relative to our app/views directly, which in this case is shared/header.\n\nNow that we are Rails partial template experts, we can proceed with rendering our partial in our app/views/layouts/application.html.erb layout ﬁle by adding the following code just inside our opening <body> tag:\n\n<body>\n\n<%= render 'shared/header' %> <%= yield %>\n\n</body>\n\nThe render method is a Rails helper method that will render the partial ﬁle. The yield method is a special method that will render the contents of the current view template. These two concepts will become more clear as we continue to add more partial templates.\n\nLet’s run our spec again. This time, it passes! We’ve successfully rendered our header partial in\n\nour application layout.\n\n.\n\nFinished in 1.51 seconds (files took 1.11 seconds to load) 1 example, 0 failures\n\nConﬁguring Selenium\n\nWhen we run our new system spec, we can visibly see a browser window open and close as the spec runs. But what if it’s not the browser we wanted? What if we want to use “headless mode” sometimes but maybe not always? What if we’re on our CI server and we can only use headless mode?\n\n57",
      "content_length": 1889,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 67,
      "content": "58\n\n7 Creating Pages\n\nThe answers to these questions are all about conﬁguration. We can conﬁgure Capybara to use different drivers for different environments or different environment variables. We can also conﬁgure Capybara to use different headless modes for different drivers. It’s all about what we decide we need for our application.\n\nFor our blog application, we’re going to use Chrome as our Capybara-conﬁgured browser, and\n\nwe’ll conﬁgure a way to run our specs in headless mode whenever we want to.\n\nIn our spec/rails_helper.rb ﬁle, we can conﬁgure Capybara. We need to work inside the\n\nRSpec.configure block. Let’s add a new block of code there:\n\nconfig.before(:each, type: :system) do driver = :selenium_chrome_headless driver = :selenium_chrome if ENV['SHOW_CHROME'] driven_by(driver)\n\nend\n\nThis lets us run our spec in headless mode by default, but we can also run it with a visible Chrome browser by setting the SHOW_CHROME environment variable on our command line. Let’s run our spec again. This time, we will not see a browser window open:\n\nbe rspec spec/system/home_spec.rb\n\nAnd then if we use our new SHOW_CHROME environment variable, we will see a browser window open:\n\nSHOW_CHROME=1 be rspec spec/system/home_spec.rb\n\nI like this approach because it lets me run my specs in headless mode by default during local development, as well as on my CI server. But if I need to see the browser, for whatever reason, I can easily do that by temporarily setting the environment variable.\n\nDisplaying Page Summaries\n\nContinuing development of our blog application’s homepage, next we’re going to add a list of blog post summaries. We’ll start by writing a failing spec for this new functionality. Since we’re still working on our homepage, we can continue to use the same spec ﬁle. Let’s check for a new article element in our spec:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Home' do\n\nit 'renders homepage' do\n\ncreate(:page)",
      "content_length": 1931,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 68,
      "content": "Displaying Page Summaries\n\nvisit root_path\n\nwithin 'header' do\n\nexpect(page).to have_link 'My Blog'\n\nend\n\narticles = find_all('article') expect(articles.size).to eq(1)\n\nwithin articles.first do\n\nexpect(page).to have_css('h2', text: Page.last.title)\n\nend\n\nend\n\nend\n\nWe’re using Capybara’s find_all method to ﬁnd all of our <article> elements on the page. We’re then checking that there is only one article element. Next, we use Capybara’s within method to scope our expectations down to the ﬁrst article element and check that it has an h2 element with the text of the last Page record’s title attribute.\n\nUsing .last here is a very common pattern found in specs. It allows us to locate and reference the last record we added to our database without having to know the ID of that record. This is very helpful since the ID of the last record will change every time we re-run our spec. Our pages table’s ID column is an auto-incrementing integer generated from our database sequence, so the ID of the last record will always be changing to be one greater than the ID of the previous record.\n\nLet’s run our spec and see it fail:\n\n1) Home renders homepage\n\nFailure/Error: expect(articles.size).to eq(1)\n\nexpected: 1 got: 0\n\nIt seems like the ﬁx might be as simple as adding a new Page record to our database and displaying that on the page. But do we want to show all posts? What about the published attribute in our Page model? We’ve made no consideration for its usage yet.\n\nPublished vs. Unpublished Pages\n\nNot all Pages are equal. Some are ready to be published and some need more work and are not. We need the concept of an unpublished Page for several important reasons:\n\n1. We want to be able to continue working on a page as many times as required before considering it complete and ready for anyone to read.\n\n2. We don’t want to show incomplete or unﬁnished pages to search engines. 3. We want to be able to retire old pages and remove them from our blog.\n\n59",
      "content_length": 1963,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 69,
      "content": "60\n\n7 Creating Pages\n\nRecalling back to when we made our database migration for our pages table, we defaulted our published ﬁeld to false. We even took things a step further and had our Page factory also default our published ﬁeld to false. This means that when we create a new Page record, it will not be published by default, with no effort from us or from our code.\n\nAll that said, we still need a way to display only published pages. In Rails, we can use the scope4 method to deﬁne a named scope on our Page model that queries our database for published pages only. Let’s add a new model spec for our published scope idea:\n\ndescribe 'scopes' do\n\ndescribe '.published' do\n\nlet(:page1) { create(:page, :published) } let(:page2) { create(:page) }\n\nbefore do\n\n[page1, page2]\n\nend\n\nit 'returns only published pages' do\n\nexpect(Page.published).to eq([page1])\n\nend\n\nend\n\nend\n\nWe’re using the let method to deﬁne two Page records. Per our database default, our Pages are unpublished unless we explicitly say otherwise. In our spec, our page1 instance will be published, while our other page2 instance will be defaulting to unpublished.\n\nRSpec lets are lazily evaluated, so we use the before block to create both records in our database before our spec runs. We then add a describe block to deﬁne our .published scope and use the it block to check that it returns only the one published Page record.\n\nLet’s run our spec and see it fail:\n\n1) Page scopes .published returns published pages\n\nFailure/Error: let(:page1) { create(:page, :published) }\n\nKeyError:\n\nTrait not registered: \"published\"\n\nWe’re getting a KeyError because we haven’t deﬁned a published trait in our Page factory yet. Let’s add that now inside our factory block:\n\ntrait :published do\n\npublished { true }\n\nend\n\n4https://guides.rubyonrails.org/active_record_querying.html#scopes",
      "content_length": 1840,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 70,
      "content": "Displaying Page Summaries\n\nLet’s run our spec again:\n\n1) Page scopes .published returns published pages Failure/Error: expect(Page.published).to eq([page1])\n\nNoMethodError:\n\nundefined method `published' for Page:Class\n\nNow we’re getting a NoMethodError because we haven’t deﬁned our .published scope yet in our Page model class. Let’s add that now:\n\nscope :published, -> { where(published: true ) }\n\nNow our new scope spec passes.\n\nRails scopes are a great way to encapsulate common database queries. We can use them anywhere\n\nin our code including inside our controller actions. Let’s now use our new .published scope.\n\nDisplaying Published Pages\n\nTo make our posts available to our view, we need to add an instance variable to our HomeController#index action. We’ll call it @posts and assign it to the result of calling our new .published scope:\n\ndef index\n\n@pages = Page.published\n\nend\n\nWe can now use our new instance variable in home/index.html.erb to display a list of our pages using the page titles:\n\n<% @pages.each do |page| %>\n\n<article>\n\n<h2><%= page.title %></h2>\n\n</article>\n\n<% end %>\n\nNow we just need to go back and update our homepage spec to create a published page; let’s add our new published trait to our create(:page) call:\n\ncreate(:page, :published)\n\nThat should do it. Let’s run our spec and see it pass.\n\n61",
      "content_length": 1332,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 71,
      "content": "62\n\n7 Creating Pages\n\nPage Summary Ordering\n\nWe’ve got our homepage displaying our published pages, but they’re not necessarily in the correct order. We want our most recent posts to be displayed ﬁrst, followed by older posts. We can use ActiveRecord’s order method to specify the order we want our posts to be displayed, but we want to add it as a scope so it’s cleaner and simpler to use. Let’s add a new Page model spec ﬁle spec/models/page_spec.rb to test our new model scope inside our describe ‘scopes’ block:\n\ndescribe '.ordered' do\n\nlet(:page1) { create(:page, created_at: 2.days.ago) } let(:page2) { create(:page, created_at: 1.day.ago) }\n\nbefore do\n\n[page1, page2]\n\nend\n\nit 'returns ordered pages' do\n\nexpect(Page.ordered).to eq([page2, page1])\n\nend\n\nend\n\nWe’re using let to deﬁne two Page records. One is created two days ago, and the other is created one day ago. RSpec lets are lazily evaluated, so we use the before block to create both records in our database. We’re creating our new Page records in the opposite order that we expect our scope to order results; this provides additional conﬁdence that our spec won’t pass by accident. Running our spec, we get the failure:\n\n1) Page scopes .ordered returns ordered pages Failure/Error: expect(Page.ordered).to eq([page2, page1])\n\nNoMethodError:\n\nundefined method `ordered' for Page:Class\n\nThe simplest thing we can do to make progress on our failing spec is to add an empty .ordered scope to our Page model:\n\nscope :ordered, -> {}\n\nRunning our spec again, we get a different failure:\n\n1) Page scopes .ordered returns ordered pages\n\nFailure/Error: expect(Page.ordered).to eq([page2, page1])\n\nexpected: [#<Page id: 642, user_id: 898, title: \"Charisma ...\n\ngot: #<ActiveRecord::Relation [#<Page id: 641, ...",
      "content_length": 1768,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 72,
      "content": "Displaying Page Summaries\n\nWe can see just from looking at the ids in the failure message that our scope isn’t ordering our results correctly. We can ﬁx that by implementing the body of our .ordered scope:\n\nscope :ordered, -> { order(created_at: :desc) }\n\nRunning our spec again, we see it passes. We can now use our new .ordered scope in our HomeController#index action:\n\ndef index\n\n@pages = Page.published.ordered\n\nend\n\nHappy Paths and System Specs\n\nSystem specs are not cheap in terms of CPU and memory usage. They spawn some sort of a web client (usually a headless browser) and run our specs against it. As a result, system specs are slower and more resource intensive than any other kind of spec we can write. Being thoughtful software engineers, we do not want to exhaust our limited system resources by running unnecessary system specs.\n\nBut what makes a system spec unnecessary? In general, unnecessary system specs fall into a few categories:\n\n1. Redundant 2. Negative 3. Impossible\n\nFor example, we may have a spec that tests that a user can log in successfully. That’s a great reason for the system spec to exist. But we don’t then also need another system spec that tests that a user cannot log in successfully. We can trust that if we somehow break the ability for a user to log in, our original login system spec will fail, and we will realize our mistake. We call the former spec the “happy path” and the latter the “sad ” or “unhappy ” path.\n\nDo not confuse the unhappy path with feature logic. For example, we may have a feature where the user ﬁlls out a form and submits it. If the form is invalid, we want to display an error message to the user. That sounds like a feature requirement that we should deﬁnitely test. What we should not test is that the error message does not display when the form submission is valid.\n\nWe want to keep our system specs focused on the happy path and avoid testing anything that is not a feature requirement. We should also do our best to create the smallest possible system spec with the fewest database interactions possible. This will help us keep our system specs fast and efﬁcient.\n\nSometimes, we will ﬁnd that something we ﬁrst think to put in a system spec can instead be placed in a view spec or a request spec. This is deﬁnitely a “right tool for the job” scenario. It’s our job as software engineers to choose the right tool for the job. Let’s do our jobs!\n\n63",
      "content_length": 2422,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 73,
      "content": "64\n\n7 Creating Pages\n\nDisplaying a Single Page\n\nNext, we want to be able to display a single page. Let’s create a new system spec ﬁle named spec/system/page_spec.rb and add a new spec for our single page:\n\nCustom Routing\n\nrequire 'rails_helper'\n\nRSpec.describe 'Pages' do\n\nlet(:my_page) { create(:page, :published) }\n\nit 'renders page' do\n\nvisit page_path(slug: my_page.slug)\n\narticle = find('article')\n\nwithin article do\n\nexpect(page).to have_css('h2', text: my_page.title)\n\nend\n\nend\n\nend\n\nWe’re again using the FactoryBot create method to create a published page. We then use Capybara’s visit method to visit the page’s URL. Next, we use the find method to ﬁnd our article element on the page. After that, we use the within method to scope our expectations to only the article element and its contents. Finally, we use the have_css matcher to check that the article element contains an h2 element with the text of the page’s title.\n\nThis spec will give us plenty to do. Let’s work through the failures. Running our spec will give us\n\nour ﬁrst failure:\n\n1) Pages renders page\n\nFailure/Error: visit page_path(slug: my_page.slug)\n\nNoMethodError:\n\nundefined method `page_path' for #<RSpec::ExampleGroups::Pages \"renders page\" (./spec/system/page_spec.rb:6)>\n\nWe’re getting a NoMethodError because we don’t have a page_path route yet. Let’s modify our config/routes.rb ﬁle to add a route for our pages:\n\nget 'page/:slug',\n\nto: 'pages#show', slug: /[-a-z0-9+]*/, as: :page",
      "content_length": 1468,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 74,
      "content": "Displaying Page Summaries\n\nThis is a custom route that aids us in creating our beautiful URLs we discussed before. The :slug value must match our regular expression /[-a-z0-9+]*/, and then when it does, our request is sent to our show action in our Pages controller. Re-running our spec shows us our next failure:\n\n1) Pages renders page\n\nFailure/Error: raise MissingController.new(error.message, error.name)\n\nActionController::RoutingError:\n\nuninitialized constant PagesController\n\nNot surprising, we have not created our PagesController yet. Let’s create it and add a #show action as well:\n\nbe rails g controller pages show\n\nThis moves us to our next spec failure:\n\n1) Pages renders page\n\nFailure/Error: article = find('article')\n\nCapybara::ElementNotFound:\n\nUnable to find css \"article\"\n\nHaving an empty #show action is not enough to make our spec pass. We need to query our database for the page we want to display and then set that result as an instance variable, for use in our view template. Let’s add a #find_by query to our #show action:\n\nclass PagesController < ApplicationController\n\ndef show\n\n@page = Page.published.find_by(slug: params[:slug])\n\nend\n\nend\n\nIn addition to our #find_by query, we need to also make sure that we only ﬁnd and return published pages. We can do that by chaining our #find_by query to our #published scope.\n\n65",
      "content_length": 1347,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 75,
      "content": "66\n\n7 Creating Pages\n\nThis will give us a @page instance variable that we can use in our view:\n\n<article>\n\n<h2><%= @page.title %></h2>\n\n</article>\n\nOur spec should now pass. Let’s run it and see:\n\nbe rspec spec/system/page_spec.rb\n\n.\n\nFinished in 1.16 seconds (files took 1.07 seconds to load) 1 example, 0 failures\n\nBroken Specs and Warnings\n\nWe used Rails code generators to generate our PagesController and our HomeController, and along the way matching request specs were also generated for us. If we run RSpec against our generated request specs, we will see that we have some failures. The ﬁrst one is in our spec/requests/home_spec.rb ﬁle:\n\n1) Homes GET /index returns http success Failure/Error: get \"/home/index\"\n\nActionController::RoutingError:\n\nNo route matches [GET] \"/home/index\"\n\nThe failure is because we’re never planning to have a /home/index route. We’re going to use the HomeController#index as the root (or homepage) of our application. We can ﬁx this spec failure by deleting the spec or by changing it to request our root path instead. Let’s do the latter:\n\nrequire 'rails_helper'\n\nRSpec.describe 'HomePage', type: :request do\n\ndescribe 'GET /index' do\n\nit 'returns http success' do\n\nget root_path expect(response).to be_successful\n\nend",
      "content_length": 1258,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 76,
      "content": "Broken Specs and Warnings\n\nend\n\nend\n\nOur spec should now pass. Our next failure message points to our spec/requests/pages_ spec.rb spec:\n\n1) Pages GET /show returns http success Failure/Error: <h2><%= @page.title %></h2>\n\nActionView::Template::Error:\n\nundefined method `title' for nil:NilClass\n\nThis failure is happening because our PagesController#show action is querying our database for a page with a slug value of “show” that does not currently exist. We can ﬁx this by putting a known page instance into our database and then using its slug value in our request spec:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Pages', type: :request do\n\ndescribe 'GET /show' do\n\nlet(:page) { create(:page, :published) }\n\nit 'returns http success' do\n\nget page_path(slug: page.slug) expect(response).to be_successful\n\nend\n\nend\n\nend\n\nThis update gets our spec passing. If we now run RSpec against our entire test suite, we see that we now only have a few warnings:\n\nbe rspec\n\n# Not yet implemented # ./spec/helpers/home_helper_spec.rb:14\n\n# Not yet implemented # ./spec/helpers/pages_helper_spec.rb:14\n\n# Not yet implemented # ./spec/views/home/index.html.erb_spec.rb:4\n\n67",
      "content_length": 1158,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 77,
      "content": "68\n\n7 Creating Pages\n\n# Not yet implemented # ./spec/views/pages/show.html.erb_spec.rb:4\n\nWe will implement some of these specs in later chapters. For now, let’s make our test suite less noisy by just deleting them:\n\nrm spec/helpers/home_helper_spec.rb \\\n\nspec/helpers/pages_helper_spec.rb \\ spec/views/home/index.html.erb_spec.rb \\ spec/views/pages/show.html.erb_spec.rb\n\nWe can now run RSpec against our entire test suite and see that we have no failure messages or warnings.\n\nSummary\n\nWe now have a solid understanding of how to create a system spec and how to use Capybara to interact with our application like a user would when using a web browser. We also have a good understanding of how to create custom routes, controller actions, and how to use instance variables in view templates.\n\nNext, we’ll jump into view specs, an often overlooked but very important part of our testing suite\n\ncapabilities.",
      "content_length": 907,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 78,
      "content": "Build Homepage Contents\n\nIn the last chapter, we created our ﬁrst page, the home page, and our show page for displaying individual page objects. These were minimal efforts with just enough content for creating our ﬁrst two system specs. In this chapter, we will take things further and complete building out these pages using our remaining content ﬁelds.\n\nView Specs\n\nIf you recall, we used the HTML <article> tag to wrap our page content. This is a good choice as it has semantic value for accessibility and search engine optimization. It’s not hard to see how our homepage, which uses an article tag to list all of our page summaries, will be similar in structure to our article tag that shows a single page object on our show page. Hmm.\n\nIn fact, the only real difference between the two is that our homepage view will show our page summary ﬁeld, while our show page view will show our content ﬁeld. This similar structure is a good candidate for a shared partial template.\n\nShared Partial Template\n\nOur shared partial idea needs a spec, so let’s create a new ﬁle named _page.html.erb_spec.rb in our spec/views/shared directory and then add the following content:\n\nrequire 'rails_helper'\n\nRSpec.describe 'shared/_page.html.erb', type: :view do\n\nlet(:page) { build(:page) }\n\nit 'renders the page object' do\n\nassign(:page, page) render partial: 'shared/page',\n\nlocals: {\n\npage: page, content: '<p>content</p>'\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_8\n\n8\n\n69",
      "content_length": 1599,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 79,
      "content": "70\n\n8 Build Homepage Contents\n\n}\n\nexpect(rendered).to have_css('h2', text: page.title) expect(rendered).to have_css('p', text: page.created_at.to_fs) expect(rendered).to have_css('p', text: 'content')\n\nend\n\nend\n\nThe ﬁlename _page.html.erb_spec.rb may look a little strange, but it’s actually a convention for naming view specs for partial templates. The leading underscore indicates that this is a partial template spec, and the _spec.rb sufﬁx is used to indicate that this is a spec ﬁle.\n\nThe spec itself is fairly straightforward. We build a page object and assign it to a page instance variable, much like our Rails controller would. We use build because we do not need our variable to actually be persisted in our database for the purposes of our spec. We then render our partial template while passing in our local variables using locals. Finally, we make assertions about the rendered content.\n\nWhen we run our new spec, we get the failure message:\n\n1) shared/_page.html.erb renders the page object Failure/Error:\n\nrender partial: 'shared/page',\n\nlocals: {\n\npage: page, content: '<p>content</p>'\n\n}\n\nActionView::MissingTemplate:\n\nMissing partial shared/_page\n\nThe failure message makes perfect sense as we have not yet created our partial template. In the app/views/shared directory, let’s create an empty _page.html.erb ﬁle and then run our spec again. This time, we get a different failure message:\n\n1) shared/_page.html.erb renders the page object Failure/Error: expect(rendered).to have_css('h2', text: page.title)\n\nexpected to find css \"h2\" but there were no matches\n\nThis failure is also expected as we have not yet added any content to our partial template. Let’s add the following:\n\n<article>\n\n<h2><%= link_to page.title, page_path(slug: page.slug) %></h2> <p><%= page.created_at.to_fs %></p> <%= content.html_safe %>\n\n</article>",
      "content_length": 1843,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 80,
      "content": "View Specs\n\nThis gets our spec passing. We can now refactor our homepage and show page views to use this partial template.\n\nNotably, we use the html_safe method on our content variable to indicate that it is safe HTML content. This is important as we will likely want to later format our summary and content ﬁeld data with HTML formatting.\n\nIf we were to use the content variable without calling html_safe on it, our HTML would be rendered as literal text. This is a security feature of Rails to prevent cross-site scripting (XSS) attacks. We can see this undesirable HTML tag rendering in action by temporarily removing the html_safe call:\n\n<%= content %>\n\nOur <p>content</p> tag will now have any dangerous characters replaced with their corresponding HTML entities before being rendered:\n\n&lt;p&gt;content&lt;/p&gt;\n\nOur < and > characters have been replaced, making our HTML tags safe to render.\n\nSo you may now be wondering if using html_safe makes our app less secure. We trust ourselves to not attack our own application, so it’s likely we can trust that our own content will be safe. If we were to allow untrusted users to create pages, we would not want to use html_safe on it before rendering it, or we would put great effort into sanitizing the content before we did render it.\n\nGranted, a <p> tag is not very dangerous, but imagine if we allowed users to create pages with JavaScript <script> tags in them. We would not want to render that JavaScript without sanitizing it as it could be used to attack our site visitors.\n\nMore View Specs\n\nWe have our shared partial template, but we still need to update our “homepage ” and “show ” page views to use it. Let’s start with a homepage view spec ﬁle named index.html.erb_spec.rb in our spec/views/home directory:\n\nrequire 'rails_helper'\n\nRSpec.describe 'home/index', type: :view do\n\nlet(:page) { build(:page) }\n\nit 'renders the page object' do\n\nassign(:pages, [page]) render expect(rendered).to have_css('h2', text: page.title) expect(rendered).to have_css('p', text: page.created_at.to_fs) expect(rendered).to include(page.summary)\n\n71",
      "content_length": 2095,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 81,
      "content": "72\n\n8 Build Homepage Contents\n\nend\n\nend\n\nThis spec expects our home/index template to use our shared partial template to render a list of page objects, with emphasis on displaying our summary ﬁeld data. We start out with calling assign to assign an array of page objects to the pages variable just like our controller would, and then we render the view. We can simply call render since this is a non-partial template. RSpec knows the correct template to render because of our RSpec.describe ’home/index’ do block that contains our path. After the render executes, we make assertions about the rendered content.\n\nI will point out how our last expectation uses include to check for the presence of our summary ﬁeld data. This is a good choice as we do not want to make any direct assumptions about the actual HTML structure of our summary data. We just want to make sure that the summary data is present in the rendered content.\n\nWhen we run our spec, we get the failure:\n\n1) home/index renders the page object\n\nFailure/Error: expect(rendered).to have_css('p',\n\ntext: page.created_at.to_fs) expected to find css \"p\" but there were no matches\n\nNow we need to update our home/index template to use our shared partial:\n\n<% @pages.each do |page| %>\n\n<%= render partial: 'shared/page', locals: {\n\npage: page, content: page.summary\n\n} %>\n\n<% end %>\n\nNext, spec/views/pages directory:\n\nlet’s add our “show” view spec ﬁle named show.html.erb_spec.rb\n\nin our\n\nrequire 'rails_helper'\n\nRSpec.describe 'pages/show', type: :view do\n\nlet(:page) { build(:page) }\n\nit 'renders the page object' do\n\nassign(:page, page) render expect(rendered).to have_css('h2', text: page.title) expect(rendered).to have_css('p', text: page.created_at.to_fs) expect(rendered).to include(page.content)",
      "content_length": 1764,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 82,
      "content": "Homepage Layout\n\nend\n\nend\n\nThis spec expects our pages/show template to use our shared partial template to render a single page object, just as before, but now with emphasis on displaying our content ﬁeld data, rather than our summary data. We start out with calling assign to assign our page object to our page variable, just like our controller would, and then we render our view. We can again just call render since this is also a non-partial template. RSpec again knows the correct template to render because of our RSpec.describe ’pages/show’ do block that contains the path. After the render, we make assertions about the rendered content.\n\nWhen we run our spec, we get the failure message:\n\n1) pages/show renders the page object\n\nFailure/Error: expect(rendered).to have_css('p',\n\ntext: page.created_at.to_fs) expected to find css \"p\" but there were no matches\n\nNow we need to update our pages/show template to use our shared partial:\n\n<%= render partial: 'shared/page', locals: {\n\npage: @page, content: @page.content\n\n} %>\n\nThat’s it! We have now refactored our homepage and show page views to use our shared partial template. We have also added view specs to ensure that our partial template is rendering the correct data depending on the context it’s used in. Let’s re-run all of our specs again to make sure we have not accidentally broken anything:\n\nbe rspec\n\nWe should see all of our specs are passing.\n\nHomepage Layout\n\nUntil now, we’ve been using the default Rails application layout ﬁle application.html.erb located in our app/views/layouts directory. It was generated for us when we ﬁrst created our Rails application. Let’s improve on our layout by adding some structure to it. We will go with the familiar header, main, sidebar , and footer layout structure shown in Figure 8-1 that many websites use. The header, footer, and sidebar sections will contain more or less static content, while the main section will contain the more dynamic content that changes depending on the page we are viewing.\n\n73",
      "content_length": 2018,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 83,
      "content": "74\n\n8 Build Homepage Contents\n\nFigure 8-1 Blog page layout\n\nCSS Framework\n\nWe will use the CSS framework Bootstrap to bootstrap our layout and CSS styling. Bootstrap is a mature CSS framework that is well documented and has many great features. It works really well with mobile devices and has a large community of veteran users. We will use the latest Bootstrap version 5.\n\nThere are many ways to add Bootstrap to a Rails application. Since we are using Rails and have a Gemﬁle setup already, we will use the gem approach. Let’s add the following to our Gemfile in the upper section outside of any environment groups, so it’s available to all our environments:\n\ngem 'bootstrap'\n\nThen we need to run bundle to install the new gem:\n\nbundle\n\nLayout Template\n\nRight now, our layout <body> tag content looks this:\n\n<body>\n\n<%= render 'shared/header' %> <%= yield %>\n\n</body>",
      "content_length": 870,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 84,
      "content": "Homepage Layout\n\nCurrently, we’re rendering a shared header partial template and then yielding whatever content we get from a given controller action when visiting a particular URL route. Let’s add the main, sidebar , and footer sections to our layout and introduce additional partial templates to help keep things organized.\n\nLet’s begin this idea with a new view spec. Let’s ﬁrst create a new directory spec/views/ layouts and then add a new view spec ﬁle inside it named application.html.erb_ spec.rb:\n\nrequire 'rails_helper'\n\nRSpec.describe 'layouts/application', type: :view do\n\nit 'renders the layout' do\n\nallow(view).to receive(:render).and_call_original render\n\nexpect(view).to have_received(:render).with('shared/header') expect(view).to have_received(:render).with('shared/side_bar') expect(view).to have_received(:render).with('shared/footer')\n\nend\n\nend\n\nThis spec provides a lot of value for the few lines of code it contains. It ensures that our layout is rendering the correct partial templates. The line\n\nallow(view).to receive(:render).and_call_original\n\nis dual purpose. It allows us to add expectations about render calls our view makes, and with the and_call_original call, it allows the render calls to actually happen even though we are mocking all render calls inside our view. This spec isn’t so much about what HTML is rendered, but rather that the correct partial templates are successfully rendered in our layout ﬁle.\n\nWhen we run our spec, we get past the expected shared/header rendering since it already\n\nexists in our layout ﬁle, but then the next expectation fails with the error:\n\nFailures:\n\n1) layouts/application renders the layout\n\nFailure/Error: expect(view).to have_received(:render)\n\n.with('shared/side_bar')\n\nAt templates. Let’s do partial shared/_side_bar.html.erb indicate they are partial templates.\n\nthis point,\n\nit makes sense\n\nto create empty shared/side_bar and shared/footer leading underscores, to respectively,\n\nthat now. Remember\n\nto name\n\nthe ﬁles with\n\nand shared/_footer.html.erb,\n\n75",
      "content_length": 2037,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 85,
      "content": "76\n\n8 Build Homepage Contents\n\nWith our new empty partial templates in place, we can update our layout HTML to create our\n\nactual layout structure:\n\n<body>\n\n<div class=\"container-fluid\">\n\n<%= render 'shared/header' %>\n\n</div>\n\n<main class=\"container-fluid\">\n\n<div class=\"row\">\n\n<div class=\"col-md-9\">\n\n<%= yield %>\n\n</div> <div class=\"col-md-3\">\n\n<%= render 'shared/side_bar' %>\n\n</div>\n\n</div>\n\n</main>\n\n<%= render 'shared/footer' %>\n\n</body>\n\nIn our layout, we use the Bootstrap container-fluid style that will expand our content to ﬁll the entire width of the browser window. Next, we create a row and two col-md-9 and col-md-3 columns. The col-md-9 column will contain the yielded content from the controller action, while the col-md-3 column will contain the side_bar partial template. We also add a footer partial template to the bottom of our layout.\n\nLet’s run our view spec again and see that it passes. We can also visit our homepage in a web\n\nbrowser and see that our layout is rendering correctly.\n\nSidebar Layout\n\nLots of different types of content can appear in a blog sidebar. Some of the more common things I’ve seen are\n\nRecent posts • Recent comments • Archives • Categories • Tag clouds • Search • Social media links\n\nFrom this list of possible sidebar content, I’ve chosen to write about two of the most common ones: an archive and a search form. The archive will be a list of all the month/year combinations that have any page content. The search form will allow our visitors to search our pages by title or by content.\n\nLet’s capture the layout of our sidebar in a view spec. This new spec will be similar to our application layout spec; it will ensure we are rendering the correct partial templates we",
      "content_length": 1724,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 86,
      "content": "Summary\n\nmean to render. Let’s create a new spec ﬁle named _side_bar.html.erb_spec.rb in our spec/views/shared directory with the following content:\n\nrequire 'rails_helper'\n\nRSpec.describe 'shared/_side_bar', type: :view do\n\nit 'renders the side_bar' do\n\nallow(view).to receive(:render).and_call_original render\n\nexpect(view).to have_received(:render).with('shared/search_form') expect(view).to have_received(:render).with('shared/archives')\n\nend\n\nend\n\nRunning this spec, we get the following error:\n\nFailures:\n\n1) shared/_side_bar renders the side_bar\n\nFailure/Error: expect(view).to have_received(:render)\n\n.with('shared/search_form')\n\nFor now, let’s create empty ﬁles for our new partial template ﬁles:\n\n1. app/views/shared/_search_form.html.erb 2. app/views/shared/_archives.html.erb\n\nNow we can update our shared/_side_bar.html.erb partial template to render our new partials:\n\n<%= render 'shared/search_form' %> <%= render 'shared/archives' %>\n\nWith these changes in place, our side_bar view spec passes.\n\nSummary\n\nIn this chapter, we introduced a new layout ﬁle and partial templates to help keep our views organized. In the next chapter, we’ll build out our search form in earnest, as well as our archive listing.\n\n77",
      "content_length": 1225,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 87,
      "content": "Sidebar Contents\n\nIn the previous chapter, we laid out placeholder templates for our overall application layout and our sidebar. In this chapter, we will build out a search service which will allow us to search our blog pages by keyword. We’ll also work up some clever SQL to establish our dynamically generated archive list.\n\nSearch As a Service\n\nWe’ll start this chapter by ﬁrst building a search service. Our search service will be a simple Ruby class that handles searching our page records and will live in between our Search controller and our Page model. We’re going to develop it as a service because it’s neither a model nor is it a controller. It will be called from our controller, but it will not be a controller, and similarly it will operate on our Page model while not being a model itself. All that said, it makes sense to develop it as a service.\n\nYou may ﬁnd other Ruby and Rails developers have strong opinions about when to make a thing into a service or not. I’ve found the best way for me to decide is to ask myself: Is this thing a model? Is this thing a controller? If neither is true, then it’s probably a service. If you’re coming over from the Java world, you may prefer to make a thing into a service even when it could exist just as easily as a worker or a builder/factory class, or something similar. Feel free to do whatever makes sense to you. I’m going to show you what I do.\n\nI also think it’s important to remember that when using Rails, some things we will build won’t always ﬁt comfortably into the model-view-controller (MVC) pattern. It’s up to us to decide how to handle these things when they come up. Rails doesn’t include a formal “service” pattern, but it does not mean we are prohibited from making and using services.\n\nImplementing a Search Service\n\nLet’s start by creating a new spec directory spec/services. This is where we’ll put our search service spec. Then, inside our new directory, let’s create a new spec ﬁle called page_search_spec.rb. Inside our new spec ﬁle, let’s add the following code:\n\nrequire 'rails_helper'\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_9\n\n9\n\n79",
      "content_length": 2260,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 88,
      "content": "80\n\n9 Sidebar Contents\n\nRSpec.describe PageSearch do\n\nsubject { PageSearch }\n\ndescribe '.search' do\n\nit 'nil params returns no pages' do\n\nexpect(subject.search(nil)).to eq([])\n\nend\n\nend\n\nend\n\nAs expected, we see our new spec fail when we run it:\n\nNameError:\n\nuninitialized constant PageSearch\n\nThe error message is telling us that we need to create a PageSearch constant of some sort, so let’s do that. Let’s ﬁrst create a new directory called app/services. Then, inside our new directory, let’s create a new ﬁle called page_search.rb. Inside our new ﬁle, let’s add the following code:\n\nmodule PageSearch end\n\nThis will create a new constant as a Ruby Module. But why did we choose a module instead of a class? The reason is that we’re not going to be creating any instances of our search service. We’re only going to call a single method on it, so it makes sense to make it as a Ruby module. If we were going to be creating actual instances of our search service, then we would have made it a Ruby Class.\n\nWhen we run our spec again, we see that creating our new module moves us to our next error\n\nmessage:\n\nNoMethodError:\n\nundefined method `search' for PageSearch:Module\n\nSpec failures are really good at telling us what we need to do next! Let’s add a search method to our PageSearch module:\n\ndef self.search(params) end",
      "content_length": 1323,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 89,
      "content": "Search As a Service\n\nThe self keyword in Ruby has a number of different meanings depending on the context. In this context, it means that we’re deﬁning a method directly inside our PageSearch module namespace. This allows us to call it like this:\n\nPageSearch.search\n\n# Instead of like this: # PageSearch.new.search\n\nWhen we run our spec again, we see that creating our new method moves us to our next error message:\n\nFailure/Error: expect(subject.search).to eq([])\n\nexpected: []\n\ngot: nil\n\nAt this point, we can make our spec pass by simply returning an empty array:\n\nmodule PageSearch\n\ndef self.search(params)\n\n[]\n\nend\n\nend\n\nThe next thing we will do is get our search service to handle empty parameters. In Ruby, an empty parameter hash is not the same thing as the nil value we passed in our ﬁrst spec. Let’s add a new spec to our page_search_spec.rb ﬁle to capture this idea:\n\nit 'empty params returns no pages' do\n\nexpect(subject.search({})).to eq([])\n\nend\n\nThis spec automatically passes because we’re already returning an empty array by default. So now both of our invalid parameter specs are passing.\n\nThe next thing we will do is get our search service to handle valid parameters. Before we do that, we need to consider what we will do with the parameters our service receives. Ultimately, we’ll use the params to search our database for matching Page records, which sounds a lot like a Rails scope.\n\n81",
      "content_length": 1412,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 90,
      "content": "82\n\n9 Sidebar Contents\n\nSo instead of writing a spec around actual Page search results, let’s write specs to ensure we send only valid parameters to our Page scope:\n\nit 'an empty term is not sent to .by_term' do\n\nallow(Page).to receive(:by_term) PageSearch.search({ term: '' }) expect(Page).to_not have_received(:by_term)\n\nend\n\nit 'a nil term is not sent to .by_term' do\n\nallow(Page).to receive(:by_term) PageSearch.search({ term: nil }) expect(Page).to_not have_received(:by_term)\n\nend\n\nit 'a valid term is sent to .by_term' do\n\nallow(Page).to receive(:by_term) PageSearch.search({ term: 'foo' }) expect(Page).to have_received(:by_term).with('foo')\n\nend\n\nThe allow mocks our call to .by_term, and our expect veriﬁes that our by_term call was made or not. The have_received matcher veriﬁes that a method was called with the correct arguments. When we run our specs, we see they all fail because we haven’t deﬁned the .by_term scope yet:\n\nFailure/Error: allow(Page).to receive(:by_term)\n\n... does not implement: by_term\n\nWe can ﬁx this by stubbing an empty .by_term scope, which we will build out shortly, in our Page model:\n\nscope :by_term, ->(term) { [] }\n\nRunning our spec again, we see that it fails with a new error message:\n\nFailure/Error: expect(Page).to have_received(:by_term).with('foo')\n\n... expected: 1 time with arguments: (\"foo\") received: 0 times\n\nThe error message is telling us that we need to call the .by_term scope from our PageSearch service. But before we do that, we need to consider under what conditions we will call our new",
      "content_length": 1548,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 91,
      "content": "Search As a Service\n\n.by_term scope. We only want to call it when we have a term parameter present, so let’s implement it that way:\n\ndef self.search(params)\n\nreturn [] unless params.present? && params[:term].present?\n\nPage.by_term(params[:term])\n\nend\n\nWe’re examining our params in two different ways here. The ﬁrst way is to check if params are present at all, and if they are not present, we return an empty array, which is similar to searching using Rails ActiveRecord and ﬁnding no results. The second way we examine our params is to check if the term key is present, and if so we call our .by_term scope. When we run our specs again, we can see that they now all pass.\n\nSearching by Term\n\nNow that we have our .by_term scope being called from inside our search service, we can start to implement the scope itself. We want to be able to search by any number or combination of terms. So let’s start by writing a spec that will allow us to search by a single term. Let’s add the following to our existing spec/models/page_spec.rb ﬁle:\n\ndescribe '.by_term' do\n\nlet(:page) { create(:page, content: 'foo') }\n\nbefore { page }\n\nit 'returns pages for the given term' do\n\nexpect(Page.by_term('foo')).to eq([page])\n\nend\n\nend\n\nOur spec fails to ﬁnd an array of Page instances and fails:\n\nFailure/Error: expect(Page.by_term('foo')).to eq([page1])\n\nexpected: [#<Page id: 47, user_id: 118, title: \"Decipio...>]\n\ngot: []\n\n83",
      "content_length": 1413,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 92,
      "content": "84\n\n9 Sidebar Contents\n\nLooks like it’s time to implement our stubbed .by_term scope. We’ll start by assuming that we’ll be searching for a single term. This will change later, but right now we’re doing TDD, and we’re only concerned with this one failing spec. So let’s make it pass with\n\nscope :by_term, ->(term) { where('content LIKE ?', \"%#{term}%\") }\n\nWhen we run our spec again, we see that it passes. Now we can move on to implementing the ability to search by multiple terms. Let’s add a new spec that will allow us to search by multiple terms:\n\ndescribe '.by_term' do\n\nlet(:page1) { create(:page, content: 'foo') } let(:page2) { create(:page, content: 'foo bar') } let(:page3) { create(:page, content: 'foo bar baz') }\n\nbefore do\n\n[page1, page2]\n\nend\n\nit 'returns pages for the given term' do\n\nexpected = [page1, page2, page3] expect(Page.by_term('foo')).to match_array(expected)\n\nend\n\nit 'returns pages for multiple terms' do\n\nexpected = [page3] expect(Page.by_term('foo baz')).to match_array(expected)\n\nend\n\nend\n\nOur ﬁrst spec still passes, but our second spec is failing because we’re not splitting up the term into individual words. Using the Rails console, we can see that the entire string is being searched for like a phrase using the .to_sql method:\n\nbe rails console\n\nirb(main):001:0> Page.by_term('foo baz').to_sql => \"SELECT \\\"pages\\\".* FROM \\\"pages\\\" WHERE (content LIKE '%foo baz%')\"\n\nWe want to split the phrase into individual words and then use the resulting array to form a dynamically generated SQL query. We also want to take care to not break our existing spec that",
      "content_length": 1593,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 93,
      "content": "Searching for Pages\n\nonly queries by one word. We also want to clean up the content of the term or phrase being passed in and only search for alphanumeric characters. Here is the solution I came up with:\n\nscope :by_term, ->(term) do term.gsub!(/[^-\\w ]/, '') terms = term.include?(' ') ? term.split : [term]\n\npages = Page terms.each do |t|\n\npages = pages.where('content ILIKE ?', \"%#{t}%\")\n\nend\n\npages\n\nend\n\nThere’s a lot going on there, so let’s break it down. First, we clean up the incoming term argument by removing any non-alphanumeric characters using gsub with the regular expression. The regular expression may look complicated at ﬁrst glance, but it’s really just a list of characters we want to keep in the term while removing all others.\n\nNext, we check to see if the term contains a space character, which indicates that it is a phrase. If it is a phrase, then we split it into individual terms; otherwise, we just put the single term into an array as a single element. This way, we end up with an array either way.\n\nWe then iterate over the array of term(s) and build up a query that will search for each term. We start with just assigning Page to pages, then we add on a where clause for each term. Rails will join all of our where clauses together with an SQL AND:\n\nirb(main):001:0> Page.by_term('Foo baz!').to_sql => \"SELECT \\\"pages\\\".* FROM \\\"pages\\\" WHERE (content ILIKE '%Foo%') AND (content ILIKE '%baz%')\"\n\nThis way, we can search for as many terms as we like, and the query will be built up correctly. If you plan to run this code in production, you might want to limit the array size to some maximum number of terms of course.\n\nFinally, we return the resulting query result. When we run our specs again, we see they are both\n\npassing. Now we’ll move on to implementing calling our search service from our controller.\n\nSearching for Pages\n\nIn the next section, we will add a search form to our sidebar. We will then implement a search controller and view template to display our search results.\n\n85",
      "content_length": 2020,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 94,
      "content": "86\n\n9 Sidebar Contents\n\nAdding a Search Form\n\nNow that we have our search service implemented, we can pursue adding it to our sidebar and begin using it. Since this next bit of functionality is going to involve a form submission, we’ll test this using a new system spec. In our spec/system directory, we’ll create a new ﬁle called search_spec.rb and add the following code:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Search' do describe 'Searching' do\n\nbefore do\n\ncreate(:page, :published, content: 'Page content')\n\nend\n\ncontext 'with no search term' do\n\nit 'returns no results' do\n\nvisit root_path\n\nwithin 'form' do\n\nfill_in 'term', with: '' click_button 'Search'\n\nend\n\nexpect(page).to have_current_path(search_path(term: '')) expect(page).to have_css('p', text: 'No results found')\n\nend\n\nend\n\nend\n\nend\n\nOur spec is fairly straightforward. We create a page with some content, then visit the root path and submit an empty search term. We check that our form is actually set up to perform a GET request when invoked, which will make the URL useful to examine, compared to a form POST. We then expect to see a message saying that no results were found.\n\nThere are a lot of missing pieces to get this spec working, and we’ll let the spec drive them all out.\n\nWhen we run this spec:\n\nbe rspec spec/system/search_spec.rb\n\nwe see that it fails with\n\n1) Search Searching with no search term returns no results Failure/Error:\n\nwithin 'form' do\n\nfill_in 'term', with: '' click_button 'Search'",
      "content_length": 1481,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 95,
      "content": "Searching for Pages\n\nend\n\nCapybara::ElementNotFound:\n\nUnable to find css \"form\"\n\nOur failure message tells us that our spec can’t ﬁnd a form on the page. Let’s add an actual search form to our _search_form.html.erb partial:\n\n<div>\n\n<%= form_for(:search, url: search_path, method: :get) do %>\n\n<div>\n\n<input type=\"search\" name=\"term\" /> <input type=\"submit\" value=\"Search\" />\n\n</div> <% end %>\n\n</div>\n\nNow when we run our spec, we get our next failure message:\n\n1) Search Searching with no search term returns no results Failure/Error: <%= form_for(:search, url: search_path, method: :get) do %>\n\nActionView::Template::Error:\n\nundefined local variable or method `search_path' for\n\n#<ActionView::Base:0x0000000000cbc0>\n\nOur spec doesn’t currently understand that we’re expecting the search_path variable to be a Rails route, which makes sense since we didn’t add it to our routes ﬁle yet. Let’s add a new route pointing to our search controller. In our config/routes.rb ﬁle, let’s add\n\nget '/search', to: 'search#index'\n\nThis addition to our routes ﬁle will direct a matching GET request to /search to an index action in our SearchController, which of course doesn’t exist yet. So as expected, when we run our spec, we get\n\n1) Search Searching with no search term returns no results Failure/Error: raise MissingController.new(error.message, error.name)\n\nActionController::RoutingError:\n\nuninitialized constant SearchController\n\n87",
      "content_length": 1429,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 96,
      "content": "88\n\n9 Sidebar Contents\n\nThe spec is telling us that we need to create a SearchController. Let’s do that now. In our app/controllers directory, let’s create a new ﬁle called search_controller.rb and add the following code:\n\nclass SearchController < ApplicationController\n\ndef index end\n\nend\n\nOur new search controller is very simple; it just has an empty index action that does nothing useful at the moment. It is the simplest thing we can do to try to move our failing spec along to the next error. When we run our spec again, we’re informed of our missing search index template:\n\n1) Search Searching with no search term returns no results Failure/Error: raise ActionController::MissingExactTemplate, message\n\nActionController::MissingExactTemplate:\n\nSearchController#index is missing a template for request formats:\n\ntext/html\n\nDisplaying Search Results\n\nLet’s add our missing template. Inside our app/views directory, let’s add a new directory named \"search\", and inside that directory, let’s create a new ﬁle named index.html.erb. Running our spec again, we get our next error message:\n\n1) Search Searching with no search term returns no results Failure/Error:\n\nexpect(page).to have_css('p', text: 'No results found') expected to find css \"p\" but there were no matches\n\nLooks like progress. We’re now getting a failure because we don’t have the No results found message on our page. Let’s add that to our new template:\n\n<p>No results found</p>\n\nWith that addition, we now have a passing search spec.",
      "content_length": 1502,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 97,
      "content": "Searching for Pages\n\nNext, we can add a new spec to test the search results display when we do enter an actual search\n\nterm. In our spec/system/search_spec.rb ﬁle, let’s add the following code:\n\ncontext 'with a search term' do\n\nit 'renders search results' do\n\nvisit root_path\n\nwithin 'form' do\n\nfill_in 'term', with: 'content' click_button 'Search'\n\nend\n\nexpect(page).to have_current_path(search_path(term: 'content'))\n\narticles = find_all('article') expect(articles.count).to eq(1)\n\nwithin articles.first do\n\nexpect(page).to have_css('h2', text: Page.last.title)\n\nend\n\nend\n\nend\n\nThis spec is very similar to our previous spec except this time we’re entering an actual search term. We’re then expecting to see the title of the page we created previously as the ﬁrst of an array of <article> tags we ﬁnd using find_all. When we run this spec, we get\n\n1) Search Searching with a search term renders search results Failure/Error: expect(articles.count).to eq(1)\n\nexpected: 1 got: 0\n\nGetting this spec working requires two things. First, we need to get some search results to display. Second, we need to make sure that our search results are actually being rendered inside of <article> tags. Let’s start with the ﬁrst problem. In our SearchController, we need to add some code to actually perform the search. We’ll use our PageSearch service to do the search. In our index action, let’s add\n\nclass SearchController < ApplicationController\n\ndef index\n\n@pages = PageSearch.search(params)\n\nend\n\nend\n\n89",
      "content_length": 1495,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 98,
      "content": "90\n\n9 Sidebar Contents\n\nThen, in our associated view template search/index.html.erb, we can update our code to iterate over our @pages instance variable and render each page inside an <article> tag using our _page.html.erb partial:\n\n<% if @pages.any? %>\n\n<% @pages.each do |page| %>\n\n<%= render partial: 'shared/page',\n\nlocals: {\n\npage: page, content: page.summary\n\n} %>\n\n<% end %>\n\n<% else %>\n\n<p>No results found</p>\n\n<% end %>\n\nThis gets our failing spec to pass. There’s nothing too fancy there; we call any? on our @pages variable to check if there are any pages in the collection. The rest is just collection iteration and partial rendering.\n\nIf you’ve been following along closely with the code in this chapter, you’ll notice that we just\n\nadded a block of code that is very similar to a block of code that we added before:\n\n<% @pages.each do |page| %>\n\n<%= render partial: 'shared/page',\n\nlocals: {\n\npage: page, content: page.summary\n\n} %>\n\n<% end %>\n\nThis same block of code is used in our home/index.html.erb ﬁle too. We should factor this code out to make our app more DRY (don’t repeat yourself). Let’s create a new partial called shared/_pages.html.erb and move the code from our home/index.html.erb action into this new partial. We will leave it mostly the same except we will turn the @page instance variable into a local template variable called Page:\n\n<% pages.each do |page| %>\n\n<%= render partial: 'shared/page',\n\nlocals: {\n\npage: page, content: page.summary\n\n} %>\n\n<% end %>",
      "content_length": 1494,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 99,
      "content": "Pages Archive\n\nNow we can use this new partial in both our home/index.html.erb and search/index. html.erb templates. Let’s clean things up by updating our home/index.html.erb template to use our new partial:\n\n<%= render partial: 'shared/pages', locals: { pages: @pages } %>\n\nAnd then let’s update our search/index.html.erb template to do the same:\n\n<% if @pages.any? %>\n\n<%= render partial: 'shared/pages', locals: { pages: @pages } %>\n\n<% else %>\n\n<p>No results found</p>\n\n<% end %>\n\nWe performed this refactor to make our app more DRY. We’re not repeating ourselves anymore. We’re using a partial to render a collection of pages in a single template ﬁle instead of repeating the same code in multiple places.\n\nWe also performed this refactor “under test,” so it was low risk, but we do need to now re-run our\n\nspecs to make sure they still pass:\n\nbe rspec spec/system/search_spec.rb spec/system/home_spec.rb\n\nIt looks like we didn’t break anything:\n\n...\n\nFinished in 2.51 seconds (files took 1.09 seconds to load) 3 examples, 0 failures\n\nPages Archive\n\nNow that we’ve got a working search feature for our pages, we can next pursue adding our archived pages feature. We’ll add our new Archives section below our search form in our sidebar. This section will display a list of month and year links that have pages in them. When a user clicks a month and year link, they will be taken to a page that displays all of the pages that were created in that month and year.\n\nWe will tackle this feature in three steps:\n\n1. Create a list of months and years that have pages in them 2. Create a search scope to search pages by month and year 3. Add a link to each month and year combination in our sidebar\n\n91",
      "content_length": 1700,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 100,
      "content": "92\n\n9 Sidebar Contents\n\nCreating a List of Months and Years\n\nWe’ll start by creating a list of months and years that have pages in them. We can do this by adding a new method to our Page model called .month_year_list. This method will return an array of hashes that contain month and year key/value pairs. We’ll use these values to create search engine–friendly links in our sidebar. Let’s add the following spec to our page_spec.rb ﬁle:\n\ndescribe '.month_year_list' do\n\nlet(:result) { Page.month_year_list }\n\nbefore do\n\ncreate(:page, created_at: Date.new(2022, 8, 10))\n\nend\n\nit 'returns month and year' do\n\nexpect(result[0]['month_name']).to eq('August') expect(result[0]['month_number']).to eq('08') expect(result[0]['year']).to eq('2022')\n\nend\n\nend\n\nWe will need the month_number and year values to create our search engine–friendly URLs. We will use the month_name and year values for the HTML display values of our URLs. The somewhat redundant month_name and month_number values are personal preference; feel free to use whatever month and year formats you like.\n\nAs expected, our spec fails:\n\n1) Page.month_year_list returns month and year\n\nFailure/Error: let(:result) { Page.month_year_list }\n\nNoMethodError:\n\nundefined method `month_year_list' for Page:Class\n\nLet’s add the .month_year_list method to our Page model:\n\ndef self.month_year_list end\n\nThis progresses our spec failure to the next error:\n\n1) Page.month_year_list returns month and year\n\nFailure/Error: expect(result[0]['month_name']).to eq('August')\n\nNoMethodError:\n\nundefined method `[]' for nil:NilClass",
      "content_length": 1575,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 101,
      "content": "Pages Archive\n\nThis error is telling us that our result variable is nil and that we’re trying to access the ﬁrst element of a nil array. We need to return an array of hashes from our .month_year_list method. To extract the month name from our created_at timestamp, we can use SQL and some Postgres functions:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT\n\nTO_CHAR(created_at, 'Month') AS month_name\n\nFROM pages\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nThis SQL query uses PostgreSQL’s TO_CHAR function to extract the month name from our created_at timestamp ﬁeld. When we run our spec again, we get a somewhat annoying new error:\n\n1) Page.month_year_list returns month and year\n\nFailure/Error: expect(result[0]['month_name']).to eq('August')\n\nexpected: \"August\"\n\ngot: \"August\n\n\"\n\nThis error is telling us that our month_name value has some extra whitespace at the end of it. We can ﬁx this by using the PostgreSQL TRIM function:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT\n\nTRIM(TO_CHAR(created_at, 'Month')) AS month_name\n\nFROM pages\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nNow our ﬁrst expect statement passes, and we get a new error message for our second expect statement:\n\n1) Page.month_year_list returns month and year\n\nFailure/Error: expect(result[0]['month_number']).to eq('08')\n\nexpected: \"08\"\n\ngot: nil\n\n93",
      "content_length": 1349,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 102,
      "content": "94\n\n9 Sidebar Contents\n\nSo let’s add the month_number value to our SQL query:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT\n\nTRIM(TO_CHAR(created_at, 'Month')) AS month_name, TO_CHAR(created_at, 'MM') AS month_number\n\nFROM pages\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nWhen we re-run our spec, we can see this update moves us to the failure for our third expect statement:\n\n1) Page.month_year_list returns month and year\n\nFailure/Error: expect(result[0]['year']).to eq('2022')\n\nexpected: \"2022\"\n\ngot: nil\n\nWe can ﬁx this by adding the year value to our SQL query:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT\n\nTRIM(TO_CHAR(created_at, 'Month')) AS month_name, TO_CHAR(created_at, 'MM') AS month_number, TO_CHAR(created_at, 'YYYY') AS year\n\nFROM pages\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nWith this addition, our entire spec passes. Next, we need to consider the scenario where we have multiple pages that were created in the same month and year. We don’t want to have duplicate month and year values in our list. We can enhance our spec to add a page with the same month and year and then check to see that our list only contains one entry for that month and year:\n\ndescribe '.month_year_list' do\n\nlet(:result) { Page.month_year_list }\n\nbefore do\n\ncreate(:page, created_at: Date.new(2022, 8, 10)) create(:page, created_at: Date.new(2022, 8, 11))\n\nend",
      "content_length": 1386,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 103,
      "content": "Pages Archive\n\nit 'returns a list of results' do expect(result.count).to eq(1)\n\nend\n\nit 'returns month and year' do\n\nexpect(result[0]['month_name']).to eq('August') expect(result[0]['month_number']).to eq('08') expect(result[0]['year']).to eq('2022')\n\nend\n\nend\n\nWhen we run our spec, we get the exact expected failure:\n\n1) Page.month_year_list returns a list of results Failure/Error: expect(result.count).to eq(1)\n\nexpected: 1 got: 2\n\nTo get our spec passing, we can add a DISTINCT modiﬁer to our SQL query. This will modify our results so that we only have one distinct entry for each month and year combination:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT DISTINCT\n\nTRIM(TO_CHAR(created_at, 'Month')) AS month_name, TO_CHAR(created_at, 'MM') AS month_number, TO_CHAR(created_at, 'YYYY') AS year\n\nFROM pages\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nWith this addition, our spec passes. The last thing we need to do is sort our results by year and month. Let’s modify our spec, including our previous “returns a list of results” spec, to test this as well:\n\ndescribe '.month_year_list' do\n\nlet(:result) { Page.month_year_list }\n\nbefore do\n\ncreate(:page, created_at: Date.new(2022, 8, 10)) create(:page, created_at: Date.new(2022, 8, 11)) create(:page, created_at: Date.new(2021, 3, 13))\n\nend\n\n95",
      "content_length": 1313,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 104,
      "content": "96\n\n9 Sidebar Contents\n\nit 'returns a list of results' do expect(result.count).to eq(2)\n\nend\n\nit 'returns month and year' do\n\nexpect(result[0]['month_name']).to eq('August') expect(result[0]['month_number']).to eq('08') expect(result[0]['year']).to eq('2022')\n\nexpect(result[1]['month_name']).to eq('March') expect(result[1]['month_number']).to eq('03') expect(result[1]['year']).to eq('2021')\n\nend\n\nend\n\nThis adds an earlier month and year combination and some more expect statements to test the ordering of the results.\n\nWhen we run our spec, we get the expected ordering failure; it’s not sorted by year and month yet;\n\ninstead, we’re getting the “natural” ordering based on how the data was stored in our database:\n\n1) Page.month_year_list returns month and year\n\nFailure/Error: expect(result[0]['month_name']).to eq('August')\n\nexpected: \"August\"\n\ngot: \"March\"\n\nTo ﬁx this, we can add an ORDER BY clause to our SQL query:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT DISTINCT\n\nTRIM(TO_CHAR(created_at, 'Month')) AS month_name, TO_CHAR(created_at, 'MM') AS month_number, TO_CHAR(created_at, 'YYYY') AS year\n\nFROM pages ORDER BY year DESC, month_number DESC\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nWe order by both the year and month number so that we get the most recent year ﬁrst and then the most recent month next when we have more than one month in a given year. With this addition, our spec passes.",
      "content_length": 1423,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 105,
      "content": "Pages Archive\n\nAn archive list entry implies there will be published pages present for that month and year. The last consideration for our Page.month_year_list method is that we should ﬁlter out any pages that are not yet published. Let’s update our spec to include an unpublished page:\n\ndescribe '.month_year_list' do\n\nlet(:result) { Page.month_year_list }\n\nbefore do\n\ncreate(:page, created_at: Date.new(2022, 7, 4)) create(:page, :published, created_at: Date.new(2022, 8, 10)) create(:page, :published, created_at: Date.new(2022, 8, 11)) create(:page, :published, created_at: Date.new(2021, 3, 13))\n\nend\n\nit 'returns a list of results' do expect(result.count).to eq(2)\n\nend\n\nit 'returns month and year' do\n\nexpect(result[0]['month_name']).to eq('August') expect(result[0]['month_number']).to eq('08') expect(result[0]['year']).to eq('2022')\n\nexpect(result[1]['month_name']).to eq('March') expect(result[1]['month_number']).to eq('03') expect(result[1]['year']).to eq('2021')\n\nend\n\nend\n\nWhen we run our spec, we get the expected failure:\n\n1) Page.month_year_list returns a list of results Failure/Error: expect(result.count).to eq(2)\n\nexpected: 2 got: 3\n\nTo get our spec passing, we can add a WHERE clause to our SQL query to ﬁlter out any pages that are not yet published:\n\ndef self.month_year_list\n\nsql = <<~SQL\n\nSELECT DISTINCT\n\nTRIM(TO_CHAR(created_at, 'Month')) AS month_name, TO_CHAR(created_at, 'MM') AS month_number, TO_CHAR(created_at, 'YYYY') AS year\n\nFROM pages WHERE published = true\n\n97",
      "content_length": 1500,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 106,
      "content": "98\n\n9 Sidebar Contents\n\nORDER BY year DESC, month_number DESC\n\nSQL ActiveRecord::Base.connection.execute(sql)\n\nend\n\nThis gets our spec passing.\n\nIt’s been a fun journey to develop our archive year and month list. It’s completely covered with specs, and we have a Ruby method wrapping our SQL query that we can use to get the data we need. We can now use this method to draw our archive list in our view.\n\nArchive List View\n\nIn the previous section, we developed a method to get a year/month aggregate list of all the pages in our database. Now we will use this method to draw our archive list in our view and show search results for a given month and year.\n\nBefore jumping right into coding our archive list display into our sidebar, we need to consider how it should be wired up. We already have a PageSearch service class that handles searching for pages by keyword. We could probably add a new method to this class to handle searching for pages by month and year without too much additional effort. In fact, we already use our PageSearch service class in our SearchController, so treating archive searching like regular searching seems like a good idea. Let’s work toward that goal. A good next step will be to add a spec to our page_search_spec.rb to test the searching by month and year:\n\nit 'valid year and month are sent to .by_year_month' do\n\nallow(Page).to receive(:by_year_month) PageSearch.search({ year: 2022, month: 8 }) expect(Page).to have_received(:by_year_month).with(2022, 8)\n\nend\n\nWhen we run our spec, we get the expected failure:\n\n1) PageSearch.search valid year and month are sent to .by_year_month Failure/Error: allow(Page).to receive(:by_year_month)\n\nPage(id: integer, user_id: integer ...) does not implement: by_year_month\n\nWe need to add a new method to our Page model to handle searching by year and month:\n\nscope :by_year_month, ->(year, month) do\n\n[]\n\nend",
      "content_length": 1886,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 107,
      "content": "Pages Archive\n\nWhen we run our spec again, we get the expected failure:\n\n1) PageSearch.search valid year and month are sent to .by_year_month Failure/Error: expect(Page).to have_received(:by_year_month) ... Page(id: integer, user_id: integer ...)\n\nexpected: 1 time with arguments: (2022, 8) received: 0 times\n\nWe can ﬁx this failure by improving our parameter handling in our PageSearch.search method:\n\ndef self.search(params)\n\nreturn [] unless params.present?\n\nPage.by_term(params[:term]) if params[:term].present?\n\nif params[:year].present? && params[:month].present? Page.by_year_month(params[:year], params[:month])\n\nend\n\nend\n\nThat gets our spec passing. We now know we’re sending the correct parameters to our Page.by_year_month method. When we have a term parameter, we call our Page.by_term method, and when we have year and month parameters, we instead call our Page.by_year_month method.\n\nNext, we need to build out our Page.by_year_month scope method to actually return the pages for a given year and month. We’ll start by adding a spec to our page_spec.rb to test the Page.by_year_month method:\n\ndescribe '.by_year_month' do\n\nlet(:page1) { create(:page, created_at: Date.new(2022, 8, 10)) } let(:page2) { create(:page, created_at: Date.new(2021, 4, 13)) }\n\nbefore do\n\n[page1, page2]\n\nend\n\nit 'returns pages for the given year and month' do\n\nexpect(Page.by_year_month(2021, 4)).to match_array([page2])\n\nend\n\nend\n\nWhen we run our spec, we get the expected failure:\n\n1) Page scopes .by_year_month returns pages for the given year ... Failure/Error: expect(Page.by_year_month(2021, 4)).to match ...\n\n99",
      "content_length": 1609,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 108,
      "content": "100\n\n9 Sidebar Contents\n\nexpected collection contained: [#<Page id: 694, user_id: ...\n\nactual collection contained: []\n\nTo get this passing, we need to query our database for pages that match the given year and month. We can do this with a parameterized SQL query:\n\nscope :by_year_month, ->(year, month) do\n\nsql = <<~SQL\n\nextract(year from created_at) = ? AND extract(month from created_at) = ?\n\nSQL where(sql, year, month)\n\nend\n\nOur spec passes with this change. We now have a tested and working Page.by_year_month method.\n\nLet’s now go back to our PageSearch.search method and clean it up a bit. We’re passing our incoming params off to the correct scopes, but we’re not currently ordering our results nor are we ﬁltering results by our published status. We can easily ﬁx these issues with a few minor changes:\n\ndef self.search(params)\n\nreturn [] unless params.present?\n\npages = if params[:year].present? && params[:month].present?\n\nPage.by_year_month(params[:year], params[:month])\n\nelsif params[:term].present?\n\nPage.by_term(params[:term])\n\nend\n\nreturn [] unless pages\n\npages.published.ordered\n\nend\n\nAfter that, let’s ensure our specs in page_search_spec.rb are still passing:\n\nbe rspec spec/services/page_search_spec.rb",
      "content_length": 1224,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 109,
      "content": "Pages Archive\n\nAnd we get the expected results:\n\n......\n\nFinished in 0.02775 seconds (files took 1.03 seconds to load) 6 examples, 0 failures\n\nArchive Integration Testing\n\nWith all that, we’re now ready to wrap up this chapter with a high-level system spec to test the archive list and search results when we click a month and year link. We’ll start by adding a new spec to our spec/system directory called archive_spec.rb:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Archives' do describe 'Results page' do\n\nbefore do\n\ncreate(:page, :published, created_at: '2022-08-10')\n\nend\n\nit 'renders archives search results' do\n\nvisit root_path click_on 'August 2022'\n\narticles = find_all('article') expect(articles.count).to eq(1)\n\nwithin articles.first do\n\nexpect(page).to have_css('h2', text: Page.first.title)\n\nend\n\nend\n\nend\n\nend\n\nNext, we’ll create a published page with a known creation date which will in turn give us a known archive entry for our sidebar. Then we’ll visit our root path and click our known-to-be-present August 2022 link. We’ll then expect to have our one article element on the page.\n\n101",
      "content_length": 1101,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 110,
      "content": "102\n\n9 Sidebar Contents\n\nWhen we run our spec, we get the expected failure:\n\n1) Archives Results page renders archives search results Failure/Error: click_on 'August 2022'\n\nCapybara::ElementNotFound:\n\nUnable to find link or button \"August 2022\"\n\nThis error makes sense since we haven’t yet built out our archive sidebar HTML. Let’s do that now. Inside our shared/archives partial, let’s call our new Page.by_year_month method and iterate over each item to build out our archive HTML links in our sidebar:\n\n<div>\n\n<h4>Archives</h4> <ul>\n\n<% Page.month_year_list.each do |item| %>\n\n<li>\n\n<%= link_to\n\n\"#{item['month_name'] } #{item['year']}\", \"/search/#{item['year']}/#{item['month_number']}\" %>\n\n</li> <% end %>\n\n</ul>\n\n</div>\n\nThis will give us a list of links for each month and year that we have pages for, but when we run our spec, we get the following error:\n\n1) Archives Results page renders archives search results Failure/Error: raise ActionController::RoutingError ...\n\nActionController::RoutingError:\n\nNo route matches [GET] \"/search/2022/08\"\n\nLooks like a missing route error. To ﬁx this failure, we need to add a route for our archive link to our config/routes.rb ﬁle:\n\nget 'search/:year/:month', to: 'search#index', year: /\\d{4}/, month: /\\d{2}/",
      "content_length": 1257,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 111,
      "content": "Summary\n\nWe use some simple regular expressions to ensure that the year and month are four and two digits, respectively. We do not need to add a controller action for this route since we’re already using the SearchController#index action for our search results. When we run our spec again, we see that it passes now.\n\nSummary\n\nIn this chapter, we dug into “Search as a Service” and built out our search form and our archive list in our sidebar. Our sidebar content will appear on every page and will help our site visitors ﬁnd the content they’re looking for more easily.\n\nWe also showed how to make custom Rails routes that will allow us to have beautiful URLs, instead of ugly ones containing query parameters. Search engines prefer these types of URLs, and they’re also easier for our users to remember and share.\n\n103",
      "content_length": 821,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 112,
      "content": "Page Tags\n\n10\n\nIn our previous chapter, we built out features for our Page objects. We added a way to search for pages by keyword and a way to look up archives of pages. We did this through a “search service,” which aided in separating our controller logic from our model logic.\n\nIn this chapter, we’ll add other features to our pages. We’ll add the ability to create and tag pages\n\nto categorize them.\n\nAdding Page Tags\n\nFirst, we want to add the ability to add tags to our Page records. Tags are a way to categorize our pages. Instead of using a gem such as acts-as-taggable-on, we’re going to implement our own tagging system. This will give us a better understanding of how tagging systems work and how they can be implemented and customized.\n\nCreating the Tag Model\n\nLet’s use a Rails generator to create a Tag model:\n\nbe rails g model tag \\\n\nname:string:uniq \\ page_tags_count:integer:index\n\nThis will create several ﬁles for us:\n\ninvoke active_record create create invoke create\n\ndb/migrate/20230108193644_create_tags.rb app/models/tag.rb rspec\n\nspec/models/tag_spec.rb\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_10\n\n105",
      "content_length": 1264,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 113,
      "content": "106\n\n10 Page Tags\n\ninvoke create\n\nfactory_bot\n\nspec/factories/tags.rb\n\nWe’re using the uniq option to make sure that our tag names are unique; having duplicates serves no purpose. We’re also adding a page_tags_count column which will allow us to keep track of how many Page records are associated with a given tag. We’ll use this to determine if a tag can be deleted or not, and it also has the nice side effect of allowing us to sort tags by popularity and not having to count them each time we want to sort them.\n\nLet’s run our migrations:\n\nbe rails db:migrate be rails db:migrate RAILS_ENV=test\n\nLet’s ﬁrst update our Tag factory to use a sequence to generate a unique name for each tag:\n\nFactoryBot.define do factory :tag do\n\nsequence(:name) { |n| \"Name #{n} \" }\n\nend\n\nend\n\nNext, let’s update our generated tag_spec.rb ﬁle to add some validation tests:\n\nrequire 'rails_helper'\n\nRSpec.describe Tag, type: :model do\n\nsubject { build(:tag) }\n\nit { is_expected.to validate_presence_of(:name) } it { is_expected.to validate_uniqueness_of(:name) }\n\nend\n\nRunning our spec, we can see that it fails as expected:\n\n1) Tag is expected to validate that :name cannot be empty/falsy Failure/Error: it { is_expected.to validate_presence_of(:name) }\n\nExpected Tag to validate that :name cannot be empty/falsy, but this could not be proved.",
      "content_length": 1327,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 114,
      "content": "Adding Page Tags\n\nWe can ﬁx this failure by adding a :name validation to our Tag model:\n\nvalidates :name, presence: true\n\nRunning our spec again, we can see that it fails in a new way:\n\n1) Tag is expected to validate that :name is case-sensitively unique Failure/Error: it { is_expected.to validate_uniqueness_of(:name) }\n\nExpected Tag to validate that :name is case-sensitively unique, but this could not be proved.\n\nWe can ﬁx this failure by adding a :name uniqueness validation:\n\nvalidates :name, presence: true, uniqueness: true\n\nOur Tag spec should now pass.\n\nCreating the Page Tag Model\n\nNext, we need to create a “join model ” to allow us to associate a Tag to a Page. We’ll again use a Rails generator to create this model:\n\nbe rails g model page_tag \\\n\npage:references \\ tag:references\n\nBefore we run our CreatePageTags migration, we need to update it to add a unique index to our page_id and tag_id columns. This will make sure that we won’t ever have any duplicate PageTag records. Let’s add this line after the end of our create_table block:\n\nadd_index :page_tags, %i[page_id tag_id], unique: true\n\nWith that added, now let’s run our migration:\n\nbe rails db:migrate be rails db:migrate RAILS_ENV=test\n\n107",
      "content_length": 1217,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 115,
      "content": "108\n\n10 Page Tags\n\nNow that we have our page_tags table created in our database, let’s update our page_tags factory to be more useful:\n\nFactoryBot.define do\n\nfactory :page_tag do\n\npage { create(:page) } tag { create(:tag) }\n\nend\n\nend\n\nAfter that, we can next focus on our page_tag_spec.rb ﬁle. We’ll start by adding some validation tests:\n\nrequire 'rails_helper'\n\nRSpec.describe PageTag, type: :model do\n\nsubject { create(:page_tag) }\n\nit { is_expected.to belong_to(:page) } it { is_expected.to belong_to(:tag) }\n\nend\n\nRunning our spec, we can see that it passes. This is because we generated our PageTag model using :references for our Page and Tag columns. This automatically added our belongs_to associations for us.\n\nWe do need to add an extra bit of code to enable our page_tags_count column to be updated\n\nautomatically when we create or destroy PageTag records, but ﬁrst the spec:\n\nit { is_expected.to belong_to(:tag).counter_cache }\n\nThen, once we see it fail:\n\nFailures:\n\n1) PageTag is expected to belong to tag required: true\n\ncounter_cache => true Failure/Error: it { is_expected.to belong_to(:tag).counter_cache }\n\nExpected PageTag to have a belongs_to association called tag (tag should have counter_cache => true)",
      "content_length": 1227,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 116,
      "content": "Adding Page Tags\n\nWe can ﬁx this failure by adding the counter_cache option to our belongs_to:\n\nbelongs_to :tag, counter_cache: true\n\nLet’s now prevent our database from raising an error if we try to create a duplicate PageTag record. We can do this by adding a validation spec:\n\nit { is_expected\n\n.to validate_uniqueness_of(:tag_id) .scoped_to(:page_id) }\n\nThis one actually fails as we might have expected:\n\n1) PageTag is expected to validate that :tag_id is case-sensitively unique within the scope of :page_id\n\nFailure/Error: is_expected.to validate_uniqueness_of(:tag_id)\n\n.scoped_to(:page_id)\n\nExpected PageTag to validate that :tag_id is case-sensitively unique within the scope of :page_id, but this could not be proved.\n\nWe can ﬁx this by adding a validation to our PageTag model:\n\nvalidates :tag_id, uniqueness: { scope: :page_id }\n\nThat should do it for our PageTag model. It’s a pretty simple model, but it’s important to get it right as it’s the glue model that will allow us to associate Tag records to Page records.\n\nJumping Over Relationships\n\nOne of the most useful features in Rails is the ability to jump over relationships using a has_many :through association. This association allows us to create a has_many relationship on a model and then use that relationship to create another has_many relationship on a related model. In our case, we want to be able to jump from an instance of a Page to its related Tags, or from a Tag to its related Pages.\n\nIn other words, we want to be able to do things like this:\n\nPage.last.tags.each do |tag|\n\nputs tag.name\n\nend\n\n109",
      "content_length": 1583,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 117,
      "content": "110\n\n10 Page Tags\n\nor this:\n\nTag.last.pages.each do |page|\n\nputs page.title\n\nend\n\nWe basically want to be able to ignore our PageTag join model. Let’s add some new specs to our page_spec.rb ﬁle to test this behavior:\n\nit { is_expected.to have_many(:page_tags).dependent(:destroy) } it { is_expected.to have_many(:tags).through(:page_tags) }\n\nRunning our specs, we can see that they both fail:\n\n1) Page is expected to have many page_tags dependent => destroy Failure/Error: it { is_expected.to have_many(:page_tags) ... Expected Page to have a has_many association called page_tags (no association called page_tags)\n\n2) Page is expected to have many tags through page_tags Failure/Error: it { is_expected.to have_many(:tags) ...\n\nExpected Page to have a has_many association called tags (no association called tags)\n\nGetting these specs to pass is simple. We just need to add our has_many associations to our Page model:\n\nhas_many :page_tags, dependent: :destroy has_many :tags, through: :page_tags\n\nNow we can add similar specs to our tag_spec.rb ﬁle:\n\nit { is_expected.to have_many(:page_tags).dependent(:destroy) } it { is_expected.to have_many(:pages).through(:page_tags) }\n\nRunning our specs, we can see that they both fail:\n\n1) Tag is expected to have many page_tags dependent => destroy Failure/Error: it { is_expected.to have_many(:page_tags) ... Expected Tag to have a has_many association called page_tags",
      "content_length": 1414,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 118,
      "content": "Tagging Pages\n\n(no association called page_tags)\n\n2) Tag is expected to have many pages through page_tags Failure/Error: it { is_expected.to have_many(:pages) ...\n\nExpected Tag to have a has_many association called pages (no association called pages)\n\nAgain, getting these sorts of specs to pass is easy. We just need to add our has_many associations to our Tag model:\n\nhas_many :page_tags, dependent: :destroy has_many :pages, through: :page_tags\n\nWe can now very easily jump across our relationships and ignore our PageTag join model.\n\nTagging Pages\n\nNow that we have our PageTag model and our has_many :through associations neatly deﬁned and tested, we can start working on our tagging feature itself. We want to be able to pass a comma- separated list of Tag names to our Page model and have it create the appropriate PageTag records for us. We need it to handle the case where a Tag already exists, as well as the case where it does not.\n\nAfter Save Callbacks\n\nWe’ll call our new comma-separated list of Tag names a “tags_string.” We can process it when we save an instance of a Page. Let’s capture this idea by adding a new spec to our page_spec.rb ﬁle:\n\ndescribe '#update_tags' do\n\nlet(:page) { create(:page, tags_string: 'foo, bar') }\n\ncontext 'when tags do not already exist' do\n\nit 'creates new tags' do\n\nexpect { page }.to change(Tag, :count).by(2) expect(page.tags.map(&:name)).to match_array(%w[foo bar])\n\nend\n\nend\n\nend\n\n111",
      "content_length": 1437,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 119,
      "content": "112\n\n10 Page Tags\n\nRunning our new spec, we can see that it fails:\n\n1) Page#update_tags when tags do not already exist creates new tags Failure: let(:page) { create(:page, tags_string: 'foo, bar') }\n\nNoMethodError:\n\nundefined method `tags_string=' for #<Page id: nil, user_id: ...\n\nThe failure message is telling us that we need to add a tags_string attribute to our Page model. We can do that by adding the following to our Page model:\n\nattr_accessor :tags_string\n\nAn attr_accessor is a special type of Ruby method that allows us to read and write to a named instance variable. In our case, we’re creating a new instance variable named tags_string that we can use to store a comma-separated list of Tag names, each of which we want to assign to our Page object. We don’t actually want to store our tags_string value in our database, but we do need it to be accessible inside our Page model for a period of time. We can use an attr_accessor to do exactly that.\n\nThis change moves us on to our next failure message:\n\n1) Page#update_tags when tags do not already exist creates new tags Failure/Error: expect { page }.to change(Tag, :count).by(2)\n\nexpected `Tag.count` to have changed by 2, but was changed by 0\n\nWe need to add a way for our Page model to handle the updating of new Tag records after we save an instance of a Page object. We can do that by using a Rails after_save callback:\n\nafter_save :update_tags\n\nprivate\n\ndef update_tags\n\nreturn if tags_string.blank?\n\ntags_string.split(',').each do |name|\n\nname = name\n\n.downcase .gsub(/[_ ]/, '-') .gsub(/[^-a-z0-9+]/, '') .gsub(/-{2,}/, '-') .gsub(/^-/, '') .chomp('-')\n\ntags << Tag.find_or_create_by(name:)",
      "content_length": 1662,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 120,
      "content": "Tagging Pages\n\nend\n\nend\n\nEvery time we save a Page instance, our update_tags method will be called. It will return early if our tags_string is blank; otherwise, it will split our tags_string into an array of names and then iterate over the array. For each name, we clean it up, just like how we previously cleaned up our title ﬁeld to make our slug ﬁeld. We then ﬁnd or create a new Tag record with that name. Finally, we ﬁnd or create a PageTag record, connecting our Page to that Tag.\n\nBut what about the case where we remove a Tag from our tags_string? We need to also remove the corresponding PageTag record. We need to add a spec to our page_spec.rb ﬁle to make sure we always remove any tags not in our tags_string when our callback is called. Inside our existing “#update_tags” describe block, let’s add the following:\n\ncontext 'when tags are removed' do\n\nlet(:tag_names) { page.tags.map(&:name) }\n\nbefore { page }\n\nit 'removes tags' do\n\npage.update(tags_string: 'foo') expect(tag_names).to match_array(%w[foo])\n\nend\n\nend\n\nWe add a before block to our spec to make sure we have a persisted Page instance with the two known Tag records from our previous spec. Then we update our Page object with a new tags_string and expect one of the tags to be removed. Running this spec, we can see that it fails:\n\n1) Page#update_tags when tags are removed removes tags Failure/Error: expect(tag_names).to match_array(%w[foo])\n\nexpected collection contained: [\"foo\"] actual collection contained: the extra elements were:\n\n[\"bar\", \"foo\"] [\"bar\"]\n\nTo get this passing, we need to clear out all of our PageTag records via our has_many :tags association before we create new ones. Let’s update our update_tags method to do that:\n\ndef update_tags\n\nself.tags = [] return if tags_string.blank?\n\ntags_string.split(',').each do |name|\n\nname = name\n\n113",
      "content_length": 1836,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 121,
      "content": "114\n\n10 Page Tags\n\n.downcase .gsub(/[_ ]/, '-') .gsub(/[^-a-z0-9+]/, '') .gsub(/-{2,}/, '-') .gsub(/^-/, '') .chomp('-')\n\ntags << Tag.find_or_create_by(name:)\n\nend\n\nend\n\nAdmittedly, adding self.tags = [] is a quick and dirty solution. In the future, when our blog is massively popular and we have written millions of PageTag records into our database, and we need to optimize this code, we can cherry-pick exactly the records that we want to destroy by iterating through them and then only destroying those. But for now, this will work just ﬁne.\n\nDisplay Tags on Pages\n\nNow that we can create Tag records when we save a Page, we want to display them as Tag name links. When we click a link, we want to see a list of all the Page records that are associated with that particular Tag. So the ﬁrst thing to do is to create a helper method to display our Tag records as links. Let’s make a helper spec to capture this idea. In our spec/helpers directory, let’s create a new tags_helper_spec.rb ﬁle with the following contents:\n\nrequire 'rails_helper'\n\nRSpec.describe TagsHelper, type: :helper do\n\ndescribe '#tag_links' do\n\nlet(:page) { create(:page, tags_string: 'foo, bar') } let(:result) { helper.tag_links(page.tags) }\n\nit 'returns a list of tag links' do\n\nexpected = <<~HTML.squish\n\n<a href=\"/tags/bar\">bar (1)</a> <a href=\"/tags/foo\">foo (1)</a>\n\nHTML expect(result).to eq(expected)\n\nend\n\nend\n\nend\n\nThis spec will drive out a lot of the functionality we want. We’ll pass in a Tag collection and get back a list of links. We’ll also want to see the number of Page records associated with each Tag, and we’ll want to see the Tag names in alphabetical order.",
      "content_length": 1656,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 122,
      "content": "Tagging Pages\n\nLet’s run our spec and see what happens:\n\nNameError:\n\nuninitialized constant TagsHelper\n\nThis is telling us that we need to create our TagsHelper module. So let’s do that. In our app/helpers directory, let’s create a new ﬁle called tags_helper.rb with the following contents:\n\nmodule TagsHelper end\n\nNow let’s run our spec again:\n\nNoMethodError: undefined method `tag_links'\n\nlet(:result) { helper.tag_links(page.tags) }\n\nOur next failure message is telling us that we need to add our tag_links method to our TagsHelper module. Let’s do that:\n\nmodule TagsHelper\n\ndef tag_links(tags) end\n\nend\n\nNow let’s run our spec again:\n\nFailure/Error: expect(result).to eq(expected)\n\nexpected: \"<a href=\\\"/tags/bar\\\">bar (1)</a> <a ... \"\n\ngot: nil\n\nWe’re getting closer. Our spec is now failing because we’re not returning the correct value, our new tag links. Let’s ﬁx that:\n\nmodule TagsHelper\n\ndef tag_links(tags) tags.map do |tag|\n\n115",
      "content_length": 940,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 123,
      "content": "116\n\n10 Page Tags\n\nlink_to \"#{tag.name} (#{tag.page_tags_count})\",\n\ntag_path(tag.name)\n\nend.join(' ')\n\nend\n\nend\n\nWe iterate over our tags array and create a link for each one. Now our spec failure message is telling us that we have not yet deﬁned a tag_path route:\n\nNoMethodError:\n\nundefined method `tag_path'\n\nLet’s add our new route to our config/routes.rb ﬁle:\n\nget 'tags/:name', to: 'tags#show', name: /[-a-z0-9_+]*/, as: :tag\n\nNow let’s run our spec again:\n\n1) TagsHelper#tag_links returns a list of tag links Failure/Error: expect(result).to eq(expected)\n\nexpected: \"<a href=\\\"/tags/bar\\\">bar (1)</a> <a ... got: \"<a href=\\\"/tags/foo\\\">foo (1)</a> <a ...\n\nWe’re now getting links, but they are in the wrong order. We want them to be in alphabetical order. This is easy; we can add a scope to our Tag model to sort by name:\n\nscope :ordered, -> { order(:name) }\n\nThen we update our spec to use this new scope:\n\nlet(:result) { helper.tag_links(page.tags.ordered) }\n\nThis gets our spec to pass.\n\nI will pause here to mention that we could have made the choice to use a default_scope . Some software engineers (myself included) consider it to be potentially dangerous as it can be difﬁcult to override and can lead to unexpected behavior when doing complex table joins.",
      "content_length": 1270,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 124,
      "content": "Tagging Pages\n\nWe can now proceed with using our new TagsHelper#tag_links method in our views. We’ll start by adding a new system spec to capture this usage. In our spec/system directory, we’ll create a new tag_spec.rb ﬁle with the following contents:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Tag', type: :system do\n\nlet(:page_1) { create(:page, :published, tags_string: 'foo, bar') } let(:page_2) { create(:page, :published, tags_string: 'bar') }\n\nbefore do\n\n[page_1, page_2]\n\nend\n\nit 'displays clickable tags on a page' do\n\nvisit root_path\n\nfind_link(href: '/tags/foo').click expect(page).to have_content(page_1.title) expect(page).to_not have_content(page_2.title)\n\nfind_link(href: '/tags/bar', match: :first).click expect(page).to have_content(page_1.title) expect(page).to have_content(page_2.title)\n\nend\n\nend\n\nWhen we run this spec, we’ll see that it fails:\n\n1) Tag displays clickable tags on a page\n\nFailure/Error: find_link(href: '/tags/foo').click\n\nCapybara::ElementNotFound:\n\nUnable to find link nil with href \"/tags/foo\"\n\nWe need to add a call to our new tag_links method in our _page.html.erb partial that will cause our tag links to appear at the bottom of each page or page summary. Let’s add that:\n\n<p><%= tag_links(page.tags).html_safe %></p>\n\nRunning our spec again, we can see a new failure message:\n\nActionController::RoutingError:\n\nuninitialized constant TagsController\n\n117",
      "content_length": 1394,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 125,
      "content": "118\n\n10 Page Tags\n\nWe could use a Rails generator here to create our missing TagsController, but it’s not a lot of effort to step through it manually. Let’s create our new tags_controller.rb ﬁle in our app/controllers directory:\n\nclass TagsController < ApplicationController end\n\nRunning our spec again, we can see a new failure message:\n\nAbstractController::ActionNotFound:\n\nThe action 'show' could not be found for TagsController\n\nLet’s do as the error message suggests and create a show action in our tags_controller.rb ﬁle:\n\nclass TagsController < ApplicationController\n\ndef show end\n\nend\n\nRunning our spec again, we can see a new failure message:\n\nActionController::MissingExactTemplate:\n\nTagsController#show is missing a template for request formats: text/html\n\nAgain, letting the failure message guide us, let’s create the directory app/views/tags and then create a new show.html.erb ﬁle inside it.\n\nOnce we’ve done that, we can run our spec again and see the next failure message:\n\n1) Tag displays clickable tags on a page\n\nFailure/Error: expect(page).to have_content(page_1.title)\n\nexpected to find text \"Page Title ...\"\n\nThis failure message occurs after we visit our root_path and click a tag. We can see that the show action is being called, but we’re not seeing any pages. This is because we haven’t yet implemented",
      "content_length": 1328,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 126,
      "content": "Tagging Pages\n\nthe logic to ﬁnd the pages that have the tag we clicked. Let’s do that by adding the following to our show action in our tags_controller.rb ﬁle:\n\ndef show\n\ntag = Tag.find_by(name: params[:name]) @pages = tag.pages.published.ordered\n\nend\n\nWe also need to actually render our @pages in our show.html.erb ﬁle. We can do that by adding the following to our show.html.erb ﬁle, reusing our _pages.html.erb partial:\n\n<%= render partial: 'shared/pages', locals: { pages: @pages } %>\n\nWith those changes in place, we can run our spec again and see that it passes.\n\nHandling Missing Tags\n\nWe’ve now implemented the ability to click a tag and see the pages that have that tag. But what happens if we try to visit a tag that doesn’t exist? Let’s add a spec to capture this behavior. In the same system spec we’ve been working in, tag_spec.rb, we’ll add the following new spec:\n\ncontext 'when a tag does not exist' do it 'redirects to the root path' do\n\nvisit '/tags/does-not-exist' expect(page).to have_current_path(root_path)\n\nend\n\nend\n\nHonestly, this spec could just as easily exist as a request spec, but we’re going to keep it in our system spec for now since we already have a very similar tag spec. When we run this spec, we’ll see that it fails with the following error:\n\n1) Tag when a tag does not exist redirects to the root path Failure/Error: @pages = tag.pages.published.ordered\n\nNoMethodError:\n\nundefined method `pages' for nil:NilClass\n\n119",
      "content_length": 1457,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 127,
      "content": "120\n\n10 Page Tags\n\nWe need to handle the case where the tag is not found. Let’s do that by adding a redirect to our root_path in our show action:\n\ndef show\n\ntag = Tag.find_by(name: params[:name]) redirect_to root_path and return unless tag\n\n@pages = tag.pages.published.ordered\n\nend\n\nWith that change in place, we can run our spec again and see that it passes. We redirect and return early to prevent the rest of the show action from being executed, if a tag is not found.\n\nRefactor Duplicate Code\n\nWe’ve made a lot of progress with page tagging, but along the way we’ve created some duplication in our code. Let’s clean that up. We currently have two places in our code where we are cleaning up a string using the same duplicated cleanup code:\n\n.downcase\n\n.gsub(/[_ ]/, '-') .gsub(/[^-a-z0-9+]/, '') .gsub(/-{2,}/, '-') .gsub(/^-/, '') .chomp('-')\n\nLet’s refactor this into a separate Ruby module and remove the duplication. In our spec/models\n\ndirectory, we’ll create a new name_cleanup_spec.rb ﬁle with the following contents:\n\nrequire 'rails_helper'\n\nRSpec.describe NameCleanup do\n\nlet(:name) { ' - -Foo Bar! _ 87 -- ' }\n\ndescribe '.clean' do\n\nit 'cleans a name' do\n\nexpect(NameCleanup.clean(name)).to eq('foo-bar-87')\n\nend\n\nend\n\nend",
      "content_length": 1237,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 128,
      "content": "Tagging Pages\n\nRunning our new spec gives us an expected failure message:\n\nNameError:\n\nuninitialized constant NameCleanup\n\nLet’s create our NameCleanup module. In our app/models directory, let’s create a new ﬁle named name_cleanup.rb with the following contents:\n\nmodule NameCleanup end\n\nThis addition moves us to the next failure:\n\n1) NameCleanup.clean cleans a name\n\nFailure/Error: expect(NameCleanup.clean(name)).to eq('foo-bar-87')\n\nNoMethodError:\n\nundefined method `clean' for NameCleanup:Class\n\nWe can ﬁx this by adding our clean method to our NameCleanup module and using our cleanup code in it:\n\nmodule NameCleanup\n\ndef self.clean(name)\n\nname\n\n.downcase .gsub(/[_ ]/, '-') .gsub(/[^-a-z0-9+]/, '') .gsub(/-{2,}/, '-') .gsub(/^-/, '') .chomp('-')\n\nend\n\nend\n\nThis gets our spec to pass.\n\nNow we can go back to our Page model and use our new NameCleanup module to clean up our\n\nmake_slug method:\n\ndef make_slug\n\nreturn unless title\n\nself.slug = NameCleanup.clean(title)\n\nend\n\n121",
      "content_length": 984,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 129,
      "content": "122\n\n10 Page Tags\n\nand then also our update_tags method:\n\ndef update_tags\n\nself.tags = [] return if tags_string.blank?\n\ntags_string.split(',').each do |name|\n\nname = NameCleanup.clean(name)\n\ntags << Tag.find_or_create_by(name:)\n\nend\n\nend\n\nAnother option to refactor this code might have been to create a local private method instead of our NameCleanup module. But testing it as a private method would have required us to test it through each of its callers, with lots of additional test setup, or by calling it indirectly using Ruby’s send method. I think the module approach is a much better option in this case.\n\nAfter this refactor, our Page model is looking much better. Let’s be sure to re-run our\n\npage_spec.rb spec to make sure we didn’t break anything.\n\nSummary\n\nIn this chapter, we’ve added the ability to tag pages and view pages by tag. We also refactored some of our code to remove duplication. In our next chapter, we’ll begin pursuing our image storage feature.",
      "content_length": 975,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 130,
      "content": "Images\n\nIn this chapter, we will add the ability to store image ﬁles for display in our blog posts. We will leverage the Active Storage gem to provide much of the functionality while working within our own image controller to serve up the image data and to handle missing images.\n\nActive Storage for Images\n\nRails version 5.2 introduced a new feature called Active Storage that provides ﬁle storage function- ality. Active Storage allows us to upload ﬁles to our Rails application, storing the ﬁle binary data as well as metadata, making it the current best way to add images to our blog. I say “current best way” because there are many other ways to add images to our blog, but Active Storage is the easiest and most integrated way to do it, given we’re already using Rails.\n\nGetting Started with Active Storage\n\nActive Storage will need us to create three new tables in our database:\n\n1. active_storage_blobs 2. active_storage_variant_records 3. active_storage_attachments\n\nFortunately, we don’t need to know much about them with Rails having a generator command to create our database migrations for us:\n\nbe rails active_storage:install\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_11\n\n11\n\n123",
      "content_length": 1331,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 131,
      "content": "124\n\n11 Images\n\nLet’s run that command and then migrate our database:\n\nbe rails db:migrate be rails db:migrate RAILS_ENV=test\n\nNext, we need to inform Active Storage how we would like to store our ﬁles. We can do this by adding two conﬁgurations to our config/storage.yml ﬁle, one for our test environment and one for our development environment:\n\ntest:\n\nservice: Disk root: <%= Rails.root.join(\"tmp/storage\") %>\n\nlocal:\n\nservice: Disk root: <%= Rails.root.join(\"storage\") %>\n\nIt’s likely these conﬁgurations will already exist in your own Rails application code, but please do check to make sure.\n\nWe will cover adding a production environment conﬁguration for storage in a later chapter. For now, we’ll just need to conﬁgure our development and test environments, and we’ll use the Disk service for both.\n\nTwo more storage conﬁgurations that may also already exist in your own Rails application code\n\nare in the config/environments directory, the development.rb and the test.rb ﬁles.\n\nInside of development.rb, we need to ensure the following line is present:\n\nconfig.active_storage.service = :local\n\nAnd inside of test.rb, we need to similarly ensure a similar line exists:\n\nconfig.active_storage.service = :test\n\nThe point of these two lines is to tell Active Storage which service, from the services deﬁned in our storage.yml, to use for each environment.\n\nThat’s all we need to do to conﬁgure our Active Storage setup for local development and test usage.\n\nAdding an Image Model\n\nTo actually begin to use Active Storage, we need to create a Rails ActiveRecord model that will represent our image record. This model will be simple, having only a name ﬁeld. We’ll then use Active Storage to attach image data to this model.",
      "content_length": 1727,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 132,
      "content": "Active Storage for Images\n\nLet’s create our model with the following command:\n\nbe rails g model Image name:string\n\nThen we’ll migrate our database:\n\nbe rails db:migrate be rails db:migrate RAILS_ENV=test\n\nWe want to make sure instances of our Image always have a name present, so let’s add a validation spec to our spec/models/image_spec.rb ﬁle:\n\ndescribe 'validations' do\n\nit { should validate_presence_of(:name) }\n\nend\n\nThis spec will fail because we haven’t added the validation to our Image model yet:\n\n1) Image validations is expected to validate that :name cannot be empty/falsy Failure/Error: it { should validate_presence_of(:name) }\n\nExpected Image to validate that :name cannot be empty/falsy, but this could not be proved.\n\nLet’s add the validation to our model:\n\nvalidates :name, presence: true\n\nThis spec should now pass. Next, let’s make sure we have a valid Image factory to use in future specs we will write. Let’s add the following to our spec/models/image_spec.rb ﬁle:\n\ndescribe 'has a valid factory' do\n\nit { expect(build(:image)).to be_valid }\n\nend\n\nThe point of this sort of test is to ensure our Image factory, with no traits applied, is always working. I consider this a good habit to get into since RSpec’s subject does this implicitly, as well as other factory associations.\n\n125",
      "content_length": 1304,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 133,
      "content": "126\n\n11 Images\n\nRunning our spec, we can see that it passes. Now let’s update our Image factory to give it a name\n\nand attach image data:\n\nFactoryBot.define do factory :image do name { 'Name' }\n\nafter(:build) do |image|\n\nio = Rails.root.join('spec/factories/images/image.jpeg').open image.image.attach(io: io,\n\nfilename: 'image.jpeg', content_type: 'image/jpeg')\n\nend\n\nend\n\nend\n\nThe code image.image.attach means that we want our image model to have an image ﬁeld that we can attach data to. The io variable is a ﬁle handle to a ﬁle named image.jpeg.\n\nRunning our spec again, we can see that it now fails:\n\n1) Image has a valid factory\n\nFailure/Error: io = Rails.root.join('spec/factories/images/ ...\n\nErrno::ENOENT:\n\nNo such file or directory @ rb_sysopen - ... image.jpeg\n\nThis error message informs us that we need to provide an image.jpeg ﬁle. Let’s create a directory for our image ﬁles:\n\nmkdir spec/factories/images\n\nAnd then I’ll leave it up to you to ﬁnd an image ﬁle to use for this spec. Any old jpeg ﬁle will work; just be sure to name it “image.jpeg” and place it in the spec/factories/images directory that we just created.\n\nAssuming you’ve successfully provided an image ﬁle, we can now run our spec again, and it will\n\nfail with a different error:\n\n1) Image has a valid factory Failure/Error:\n\nimage.image.attach(io: io,\n\nfilename: 'image.jpeg', content_type: 'image/jpeg')\n\nNoMethodError:",
      "content_length": 1404,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 134,
      "content": "Serving Images\n\nundefined method `image' for #<Image id: nil, name: \"Name\", created_at: nil, updated_at: nil>\n\nNow we can add the Active Storage attachment code to our model. We’ll do this by adding the following to our app/models/image.rb ﬁle:\n\nhas_one_attached :image\n\nhas_one_attached is an Active Storage helper method that will provide instances of our model with an :image ﬁeld to which we can attach image data. We could of course call our :image ﬁeld something else if we wanted to, perhaps :photo, but we’ll stick with :image.\n\nRunning our spec again, we can see that it now passes. We could add more validations to our Image model, but for now we’ll leave it as is. In particular, you might question why we do not have a validation for image data being present. For this, we’re trusting in the Active Storage gem to do the right thing and to have adequate test coverage in place within its own codebase.\n\nServing Images\n\nWe have our images stored in our database, and so we now need a way to serve them up to our site visitors. We’ll do this by creating a controller that will serve up image data from Active Storage.\n\nAdding an Image Controller\n\nA blog wouldn’t be complete without the ability to display images in the page content here and there. So we’ll need an ImagesController with a show action to serve up image data.\n\nAs you might expect, we’ll ﬁrst write a spec for it, a request spec to be exact. Inside our spec/requests directory, let’s add a new ﬁle called images_spec.rb and add the following to it:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Images' do it 'returns an image' do\n\ncreate(:image) get image_path(Image.last)\n\nexpect(response).to be_successful expect(response.content_type).to eq('image/jpeg')\n\nend\n\nend\n\nIn this spec, we create an image record using our new image factory and then make a GET request to our show action in our ImagesController. We then assert that the response is successful and\n\n127",
      "content_length": 1936,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 135,
      "content": "128\n\n11 Images\n\nthat the content type is image/jpeg. This spec will fail in various ways as we work through the implementation of our controller action. Let’s see what the ﬁrst failure message looks like:\n\nbe rspec spec/requests/images_spec.rb\n\nRSpec tells us that we have an undeﬁned method, a Rails route to be speciﬁc:\n\n1) Images returns an image\n\nFailure/Error: get image_path(Image.last)\n\nNoMethodError:\n\nundefined method `image_path' ...\n\nSo let’s add a route to our config/routes.rb ﬁle:\n\nresources :images, only: :show\n\nWe’re adding a standard REST “resources” route, but we only want to make the show action available. We can see what that gives us by running the rails routes command with the -g (grep) option to ﬁlter the output:\n\nbe rails routes -g images\n\nWe can see that Rails has created just the one show route for us:\n\nPrefix Verb URI Pattern image GET /images/:id(.:format) images#show\n\nController#Action\n\nRunning our spec again, we can see that we now have a different error:\n\n1) Images returns an image\n\nFailure/Error: get image_path(Image.last)\n\nActionController::RoutingError:\n\nuninitialized constant ImagesController",
      "content_length": 1139,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 136,
      "content": "Serving Images\n\nLooks like it’s time to create our image controller. We could use the following command to create it, but we won’t because it will create a bunch of extra ﬁles that we don’t need:\n\n# be rails g controller images show\n\nInstead, let’s create the controller ﬁle manually. Let’s add a new ﬁle to our app/controllers directory called images_controller.rb and then add the following to it:\n\nclass ImagesController < ApplicationController end\n\nRunning our spec again, we can see that we now have a different error:\n\n1) Images returns an image\n\nFailure/Error: get image_path(Image.last)\n\nAbstractController::ActionNotFound:\n\nThe action 'show' could not be found for ImagesController\n\nRSpec is telling us that it’s now time to create a show action in our controller. Let’s do that:\n\nclass ImagesController < ApplicationController\n\ndef show end\n\nend\n\nRunning our spec again, we see that we now have a different error:\n\n1) Images returns an image\n\nFailure/Error: get image_path(Image.last)\n\nActionController::MissingExactTemplate:\n\nImagesController#show is missing a template for request formats: text/html\n\nRails wants us to add an HTML/ERB template for use with our show action, but what it doesn’t currently know is that we’re not going to render HTML; we’re instead going to serve up binary image data. Once we have our controller action implemented, Rails will no longer complain about\n\n129",
      "content_length": 1400,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 137,
      "content": "130\n\n11 Images\n\nthe missing template. Let’s add the following code to our show action, and then we will run through how it works:\n\ndef show\n\nimg = Image.find_by(id: params[:id]) image = img.image\n\ndata = image.download type = image.content_type ext = image.filename.to_s.split('.').last filename = \"image_#{img.id}.#{ext}\"\n\nsend_data data, type:, filename:, disposition: 'inline'\n\nend\n\nFirst, we get our img record from our database using the id parameter from our request params. We then get the Active Storage image attachment from the img record. Next, we assign our variables data, type, and filename for use with the Rails send_data method to return the image data to our controller action’s caller.\n\nThe real magic here is the image.download call. This is an Active Storage method that will download the image data from wherever it is stored, locally or remotely. It returns the downloaded binary image data to us, and we then pass that data to the Rails send_data method.\n\nThe filename is not required, but it’s a nice touch to give the image a friendly name that is probably more uniform than the original ﬁlename of the image that was uploaded. We’re also setting the disposition to inline so that the image will be displayed in the browser, rather than be automatically downloaded.\n\nLet’s run our spec again and see that it passes. There are other things we could do in our request spec, such as checking the headers, to make sure\n\nthe Content-Disposition is set to inline, for example:\n\nheaders = response.headers expect(headers['Content-Disposition']).to include('inline')\n\nimage_name = \"image_#{Image.last.id}.jpeg\" expect(headers['Content-Disposition']).to include(image_name)\n\nOr we could check for and handle a missing image ﬁle extension in the ﬁlename; it’s up to you whether you want to add these to your own specs or not.\n\nWe do however want to handle the situation where the “img” record is not found. It may have been deleted from our database, or the id parameter may have been incorrectly set by the caller. Let’s add a spec for handling that scenario:\n\nit 'returns a missing image if the image does not exist' do\n\nget image_path(0)\n\nexpect(response).to be_successful",
      "content_length": 2191,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 138,
      "content": "Serving Images\n\nexpect(response.content_type).to eq('image/jpeg')\n\nend\n\nInstead of showing a broken image, we want to show a “missing” image. We can simulate that scenario by looking for an image with an id of 0. We can then check that the response is successful and the content type is image/jpeg, just like if the image was actually found.\n\nRunning our spec, we can see that it fails:\n\n1) Images returns a missing image if the image does not exist Failure/Error: image = img.image\n\nNoMethodError:\n\nundefined method `image' for nil:NilClass\n\nWe can now update our controller action code to handle our missing image scenario:\n\ndef show\n\nimg = Image.find_by(id: params[:id])\n\nif img\n\nimage = img.image\n\ndata = image.download type = image.content_type ext = image.filename.to_s.split('.').last filename = \"image_#{img.id}.#{ext}\"\n\nelse\n\nimage_path = Rails.public_path.join('missing.jpeg') image = image_path.open('rb')\n\ndata = image.read type = 'image/jpeg' filename = 'missing.jpeg'\n\nend\n\nsend_data data, type:, filename:, disposition: 'inline'\n\nend\n\nRunning this spec again, we can see that it’s still failing, but for a different reason:\n\n1) Images returns a missing image if the image does not exist Failure/Error: image = image_path.open('rb')\n\nErrno::ENOENT:\n\nNo such file or directory @ rb_sysopen - ... missing.jpeg\n\n131",
      "content_length": 1326,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 139,
      "content": "132\n\n11 Images\n\nLet’s add a missing.jpeg ﬁle to our public directory. I will again leave it up to you to provide whatever image you like for your missing.jpeg image ﬁle. Let’s re-run our spec and see that it now passes.\n\nSummary\n\nIn this chapter, we added the ability to upload images and retrieve them using Active Storage. We’ve also added the ability to handle missing images. We’ll add the ability to delete images in a later chapter, when we build out our admin pages. Next, we’re going to tackle user authentication.",
      "content_length": 522,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 140,
      "content": "User Authentication\n\n12\n\nEventually, our blog application will have an administration interface, and we will need to make sure that only an administrator user can access it. To this end, we will need to add the ability to authenticate to our user model. This chapter will cover how to do that.\n\nSome readers may begin wondering why we are not using a third-party authentication library such\n\nas Devise. The reasons are\n\nWe want to always keep our application as simple as possible, with as few dependencies as possible. As you will soon see, adding a user model with salted password authentication is not difﬁcult. It’s important for software engineers to understand at least the basics of how third-party libraries such as Devise work, so we can make informed decisions to use them or not, and to adequately assess risk when we do choose to use them. Can you trust the authors to ship security ﬁxes quickly when exploits become publicly known? basic authentication.\n\n(cid:129)\n\nImproving Our User Model\n\nWe created a User model in a previous chapter. We now need to add functionality to support authentication. In particular, we need to add a password “salt” ﬁeld and a password “hash” ﬁeld. Adding these two ﬁelds will enable us to store one-way hashed passwords, individually salted for each of our users.\n\nPassword Hashing\n\nPassword hashing is a technique that is used to safely store passwords in a database in a way that makes it difﬁcult to recover the original password. The idea is that the password is hashed using a one-way hash function, such as SHA-256. The hash function is a mathematical function that takes a string of characters and produces a different ﬁxed length string of characters representing the original\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_12\n\n133",
      "content_length": 1917,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 141,
      "content": "134\n\n12 User Authentication\n\nvalue. The hash function is one-way in that it is easy to compute the hash of a string of characters, but it is difﬁcult to compute the original string of characters from the hash. The hash function is also deterministic, in that given the same string of characters the hash function will always produce the same hashed value.\n\nThe hash function combines a “salt” value with the user-provided password value to produce a password hash. The salt value is a random string of characters, but it is unique for each password. The salt value is stored in the database along with the password hash. The salt value is used to make it difﬁcult to precompute a table of password hashes. If the salt value was not used, an attacker could precompute a table of password hashes for a large number of common passwords and then compare the password hashes in our database to the precomputed table to determine the passwords. Using salt values makes this attack much more difﬁcult, especially for users who use weak passwords.\n\nNow that we have a basic understanding of password salting and hashing, let’s add our password\n\nﬁelds to our user model.\n\nAdding Fields to Our User Model\n\nLet’s generate a migration to add our password ﬁelds to our user model:\n\nbe rails g migration add_user_password_fields\n\nWe will add two new ﬁelds to our user model, a password_salt ﬁeld and a password_hash ﬁeld. Both ﬁelds will be strings. Let’s modify our new migration ﬁle to add the ﬁelds:\n\nclass AddUserPasswordFields < ActiveRecord::Migration\n\ndef change\n\nadd_column :users, :password_salt, :string add_column :users, :password_hash, :string\n\nend\n\nend\n\nNow let’s run the migration:\n\nbe rails db:migrate be rails db:migrate RAILS_ENV=test\n\nWe now have the ﬁelds we need to store password hashes in our User model. The next step is to add the ability to set a password for a user. We do not want to store the password in our database in plaintext, so we need to be able to control things explicitly. We need a temporary password ﬁeld that we can use to generate the value we will actually store in our database.",
      "content_length": 2110,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 142,
      "content": "Improving Our User Model\n\nInside our spec/models/user_spec.rb ﬁle, let’s capture this idea by adding the following\n\nnew spec:\n\ndescribe 'set a password' do\n\nlet(:user) { build(:user) }\n\nit 'sets a password' do\n\nuser.password = 'changeme' user.save!\n\nexpect(user.password_salt).to be_present expect(user.password_hash).to be_present\n\nend\n\nend\n\nThis spec fails because we have not yet added any sort of password attribute or method to our user model:\n\n1) User password= sets a password\n\nFailure/Error: user.password = 'changeme'\n\nNoMethodError:\n\nundefined method `password=' for #<User id: nil, name: ...\n\nThe failure message indicates that we don’t actually need an attribute; we instead need a password= method.\n\ndef password=(password)\n\nself.password_salt = 'salt' self.password_hash = \"#{password_salt}#{password}\"\n\nend\n\nThis gets our spec to pass, but it is not a very good implementation. We’re capturing the basic idea of salting a password, but nothing is actually being hashed. We can see what is actually happening by running our Rails console:\n\nbe rails c\n\n135",
      "content_length": 1069,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 143,
      "content": "136\n\n12 User Authentication\n\nWhen we create a new user, we can see that the password salt and password hash are being set, but not hashed:\n\nirb(main):001:0> user = User.new(\n\nemail: 'foo@bar.com', name: 'Name', password: 'changeme'\n\n) ... irb(main):002:0> user.password_salt => \"salt\" irb(main):003:0> user.password_hash => \"saltchangeme\"\n\nBeing software engineers, but probably not expert cryptographers, we need to add a hashing library to our application.\n\nAdd a Hashing Library\n\nWe will use the bcrypt gem to add password hashing to our application. The bcrypt gem is a Ruby wrapper around the OpenBSD bcrypt library. Let’s add the gem to our application:\n\nbundle add bcrypt\n\nNext, we need to require the bcrypt library in our User model:\n\nrequire 'bcrypt'\n\nThis will give us access to all of the bcrypt gem’s functionality. We can now modify our password= method to use bcrypt:\n\ndef password=(password)\n\nself.password_salt = BCrypt::Engine.generate_salt self.password_hash = BCrypt::Engine.hash_secret(\n\npassword, password_salt\n\n) end\n\nFirst, we generate a salt value using BCrypt::Engine.generate_salt . Then we use the salt value to generate a hash of the user-provided password string using BCrypt::Engine.hash_ secret. The salt and hash values are then stored in our user record, after our before_save callback is executed.",
      "content_length": 1332,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 144,
      "content": "Improving Our User Model\n\nLet’s re-run our spec and see that it still passes. And then let’s see what we’re actually storing in\n\nour database, now that we’re using bcrypt:\n\nbe rails c\n\nirb(main):001:0> User.destroy_all ... irb(main):002:0> user = User.new(\n\nemail: 'foo@bar.com', name: 'Name', password: 'changeme'\n\n) ... irb(main):003:0> user.password_salt => \"$2a$12$jOaFNA79pCgwWS0poghAlu\" irb(main):004:0> user.password_hash => \"$2a$12$jOaFNA79pCgwWS0poghAluIaInS7I98yvVEdi03apOaXSoE5b1uyy\"\n\nOur salt and password hashes are being stored in our database now. Next, we should perform some actual user validation to verify that our new hash values are being generated correctly and that we can successfully authenticate.\n\nAuthenticating a User\n\nLet’s add a new spec to verify that we can authenticate a user:\n\ndescribe '.authenticate' do\n\nlet(:user) { build(:user) } let(:password) { 'changeme' }\n\nbefore do\n\nuser.password = password user.save!\n\nend\n\nit 'can authenticate' do\n\nexpect(User.authenticate(user.email, password)).to eq(user)\n\nend\n\nend\n\nThe idea here is that a user can authenticate if they provide the correct email address and password. We will call an .authenticate class method to verify the user’s credentials against the values we have stored in our database.\n\n137",
      "content_length": 1283,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 145,
      "content": "138\n\n12 User Authentication\n\nRunning this spec, we will see it fail because we have not yet added our .authenticate class\n\nmethod to our User model:\n\n1) User.authenticate can authenticate\n\nFailure/Error: expect(User.authenticate(user.email, password)).to eq(user)\n\nNoMethodError:\n\nundefined method `authenticate' for User:Class\n\nIf we implement the .authenticate method:\n\ndef self.authenticate end\n\nwe can make some progress to our next failure message:\n\n1) User.authenticate can authenticate Failure/Error:\n\ndef self.authenticate end\n\nArgumentError:\n\nwrong number of arguments (given 2, expected 0)\n\nRSpec is telling us that we need to accept two arguments into our .authenticate method: the user’s email address and the password they are attempting to authenticate with. Let’s add those arguments:\n\ndef self.authenticate(email, password) end\n\nNow that we have a method that accepts two arguments, we get our next failure message:\n\n1) User.authenticate can authenticate\n\nFailure/Error: expect(User.authenticate(user.email, password)).to eq(user)\n\nexpected: #<User id: 40, name: \"First10 Last10\", email: ...\n\ngot: nil",
      "content_length": 1117,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 146,
      "content": "Improving Our User Model\n\nWe’re accepting the correct arguments, but we’re not actually doing anything with them. Let’s add some code to ﬁnd the user record by email address and then verify that the provided password matches our stored password hash:\n\ndef self.authenticate(email, password) user = User.find_by(email: email)\n\npassword_hash = BCrypt::Engine.hash_secret(\n\npassword, user.password_salt\n\n)\n\nif password_hash == user.password_hash\n\nuser\n\nend\n\nend\n\nWe’re again using one-way hashing to generate a hash of the user-provided password and our stored salt value. If our generated hash matches our stored hash, we know that the correct password has been provided, and so we return the user record. If the hashes do not match, we will reach the end of our method, and our return value would be nil since nothing was actually returned.\n\nOur spec should now pass, and this is a good start to our authentication, but we’re not done yet.\n\nThere are a few more things we should do to improve our implementation; we should\n\n1. Return nil if the user’s email address is unknown. 2. Handle email address case sensitivity. 3. Create wrapper methods for any BCrypt methods we’re using.\n\nImproving Authentication\n\nRight now, we’re assuming a user record will always be found when searching by email address, and then we go on to call User.password_salt and User.password_hash. Either of these two calls will raise an exception if the user record is nil. We should not assume a user will be found and instead return nil if the user’s email address is unknown in our database. Let’s add a spec to reproduce the issue:\n\nit 'unknown email fails authentication' do\n\nexpect(User.authenticate('foo@bar.com', password)).to be_nil\n\nend\n\nWhen we run this spec, we get the following error:\n\n1) User.authenticate unknown email fails authenticate Failure/Error: user.password_salt\n\n139",
      "content_length": 1866,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 147,
      "content": "140\n\n12 User Authentication\n\nNoMethodError:\n\nundefined method `password_salt' for nil:NilClass\n\nLet’s ﬁx this by returning nil early in our method if the user record is not found:\n\ndef self.authenticate(email, password) user = User.find_by(email: email) return nil if user.nil?\n\npassword_hash = BCrypt::Engine.hash_secret(\n\npassword, user.password_salt\n\n)\n\nif password_hash == user.password_hash\n\nuser\n\nend\n\nend\n\nThe next issue we have is that we’re not handling email address case sensitivity correctly. If a user signs up with an email address of foo@bar.com and then attempts to authenticate with an email address of Foo@Bar.com, we should still authenticate them. The easiest solution to this is to downcase the email address when we store it in our database and then downcase the email address again when we search for it in our find_by call. This way, we will only ever compare lowercased email addresses. Let’s add a spec to handle downcasing email addresses anytime we save a user record:\n\ndescribe 'email' do\n\ncontext 'on create' do\n\nlet(:user) { create(:user, email: 'Foo@baR.Com') }\n\nit 'is downcased' do\n\nexpect(user.email).to eq('foo@bar.com')\n\nend\n\nend\n\ncontext 'on update' do\n\nlet(:user) { create(:user, email: 'foo@bar.com') }\n\nbefore do\n\nuser.update(email: 'Foo@baR.Com')\n\nend\n\nit 'is downcased' do\n\nexpect(user.email).to eq('foo@bar.com')\n\nend",
      "content_length": 1361,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 148,
      "content": "Improving Our User Model\n\nend\n\nend\n\nWhen we run this spec, we get two failures:\n\n1) User email on create is downcased\n\nFailure/Error: expect(user.email).to eq('foo@bar.com')\n\nexpected: \"foo@bar.com\" got: \"Foo@baR.Com\"\n\n2) User email on update is downcased\n\nFailure/Error: expect(user.email).to eq('foo@bar.com')\n\nexpected: \"foo@bar.com\" got: \"Foo@baR.Com\"\n\nLet’s ﬁx these spec failures by adding a before_save callback into our User model:\n\nbefore_save :downcase_email\n\nprivate\n\ndef downcase_email\n\nself.email = email.downcase\n\nend\n\nThese changes will ensure that anytime we save a user record, on create or on update, our user’s email address will be downcased. Our two new specs should pass now, and we can return to improving our authentication method.\n\nInside our .authenticate method, we’re not handling email address case sensitivity yet. Let’s\n\nadd a spec to reproduce this issue:\n\nit 'mixed case email can authenticate' do\n\nexpect(User.authenticate(user.email.titleize, password)).to eq(user)\n\nend\n\nWe can use titleize as a simple way to uppercase the ﬁrst letter of the email address. This fails as expected:\n\n1) User.authenticate mixed case email can authenticate Failure/Error: expect(User.authenticate(user.email.titleize, password)).to eq(user)\n\n141",
      "content_length": 1262,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 149,
      "content": "142\n\n12 User Authentication\n\nexpected: #<User id: 80, name: \"First12 Last12\", email: ...\n\ngot: nil\n\nTo ﬁx this, we need to downcase the email address before we search for the user record:\n\ndef self.authenticate(email, password)\n\nuser = User.find_by(email: email.downcase) ...\n\nend\n\nRe-running our spec, we see that it now passes, but we just created a new issue. What if the email address is nil? We’ll get an exception when we try to call downcase on a nil value. Let’s add a spec to reproduce this issue:\n\nit 'nil email fails authentication' do\n\nexpect(User.authenticate(nil, password)).to be_nil\n\nend\n\nThis spec fails as expected:\n\n1) User.authenticate nil email fails authentication Failure/Error: user = User.find_by(email: email.downcase)\n\nNoMethodError:\n\nundefined method `downcase' for nil:NilClass\n\nWe can ﬁx this by adding a guard clause to our method to return nil early if the email address is\n\nnil:\n\ndef self.authenticate(email, password)\n\nreturn nil unless email.present?\n\nuser = User.find_by(email: email.downcase) ...\n\nend\n\nRe-running our spec, we see that it now passes.\n\nNext, let’s do some refactoring. We’re using the BCrypt gem to create our password salt and hash values, but what if in the future we decided to use a different gem or even a different algorithm? We",
      "content_length": 1287,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 150,
      "content": "Improving Our User Model\n\nwould have to change our code in multiple places. Let’s extract the logic for creating a password hash into a separate method:\n\ndef self.hash_password(password, salt)\n\nBCrypt::Engine.hash_secret(password, salt)\n\nend\n\nWe can then use this method in our password= method:\n\ndef password=(password)\n\nself.password_salt = BCrypt::Engine.generate_salt self.password_hash = User.hash_password(password, password_salt)\n\nend\n\nand also in our .authenticate method:\n\ndef self.authenticate(email, password)\n\nreturn nil unless email.present?\n\nuser = User.find_by(email: email.downcase) return nil if user.nil?\n\npassword_hash = hash_password(\n\npassword, user.password_salt\n\n)\n\nif password_hash == user.password_hash\n\nuser\n\nend\n\nend\n\nLet’s also create a wrapper method for BCrypt::Engine.generate_salt:\n\ndef self.generate_salt\n\nBCrypt::Engine.generate_salt\n\nend\n\nWe can then use this method in our password= method:\n\ndef password=(password)\n\nself.password_salt = User.generate_salt self.password_hash = User.hash_password(password, password_salt)\n\nend\n\n143",
      "content_length": 1067,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 151,
      "content": "144\n\n12 User Authentication\n\nWe’re still depending on the BCrypt gem, but we’ve isolated the code that depends on it so that if we decide to change gems or algorithms in the future we only have to change the code in one place, and our specs will likely continue to pass.\n\nAlways remember to re-run specs to make sure nothing regressed into a broken state when\n\nrefactoring code or when adding wrapper methods to isolate third-party APIs, as we just did.\n\nPassword Conﬁrmation\n\nSince our user password value is one-way hashed, it would be a good idea to conﬁrm it before saving it. We will never be able to look into our database to conﬁrm it after the save occurs, so we need to conﬁrm it before the save.\n\nLet’s add new shoulda-matcher specs to capture this conﬁrmation behavior:\n\nit { is_expected.to validate_presence_of(:password) } it { is_expected.to validate_confirmation_of(:password) }\n\nOur ﬁrst failing spec is for the presence of the password:\n\n1) User validations is expected to validate that :password cannot be empty/falsy Failure/Error: it { is_expected.to validate_presence_of(:password) }\n\nNoMethodError:\n\nundefined method `password' for #<User id: nil, name: ...\n\nWe don’t have an actual password attribute on our user model, and we don’t want one either. We only want to store the password hash and salt, never the plaintext version a user provides. So to ﬁx this, we need to add a virtual attribute to our user model:\n\nattr_accessor :password\n\nAnd we need to set it inside our password= method:\n\ndef password=(password) @password = password self.password_salt = User.generate_salt self.password_hash = User.hash_password(password, password_salt)\n\nend",
      "content_length": 1669,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 152,
      "content": "Improving Our User Model\n\nThese changes will move us to our next failure message:\n\n1) User validations is expected to validate that :password cannot be empty/falsy Failure/Error: it { is_expected.to validate_presence_of(:password) }\n\nExpected User to validate that :password cannot be empty/falsy, but this could not be proved.\n\nAfter setting :password to ‹nil›, the matcher expected the User to be invalid, but it was valid instead.\n\nIt appears our new password attribute is correctly deﬁned now, but we need to actually validate it for presence. We can do this by adding a validation to our user model:\n\nvalidates :password, presence: true\n\nThis change gets our new spec to pass but breaks many of our other specs. The problem is the subject deﬁned at the top of our User_spec.rb ﬁle:\n\nsubject { build(:user) }\n\nIf we look at our user factory deﬁnition in spec/factories/users.rb, we can see that it does not currently deﬁne a password attribute, which is an easy ﬁx:\n\npassword { 'changeme' }\n\nRe-running our spec ﬁle shows us progress. We’re now getting a new failure message for our password conﬁrmation spec:\n\n1) User validations is expected to validate that :password_confirmation matches :password Failure/Error: it { is_expected.to\n\nvalidate_confirmation_of(:password) }\n\nShoulda::Matchers::ActiveModel::AllowValueMatcher::Attribute ...\n\nThe matcher attempted to set :password_confirmation on the User to \"some value\", but that attribute does not exist.\n\n145",
      "content_length": 1466,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 153,
      "content": "146\n\n12 User Authentication\n\nTo ﬁx this, we need to update our user password validation to include conﬁrmation:\n\nvalidates :password, presence: true, confirmation: true\n\nThis change will enable another virtual attribute in our user model, password_confirmation, which is exactly what our spec is looking for. This causes us to also need to add a separate password conﬁrmation validation:\n\nvalidates :password_confirmation, presence: true\n\nAs before, this gets our new spec to pass but breaks some of our other specs. Our subject is again causing problems, and we again need to update our user factory deﬁnition, this time to include a password conﬁrmation attribute:\n\npassword_confirmation { password }\n\nWe’ll let FactoryBot reuse the password attribute we deﬁned earlier to set our new password_confirmation attribute. This will make it easier to change both values in the future if we need to.\n\nThis gets our spec to pass, but do we always want to require a password and password\n\nconﬁrmation?\n\nSkipping Password Validation\n\nRight now, we are requiring a password and a password conﬁrmation for every user record, both on create and on save. This is not always what we want. For example, if we’re only updating a user’s name, we don’t want to require the password and password conﬁrmation to also be present. We can even imagine a scenario where the user is not even present when another ﬁeld needs to be updated. First, let’s prove the problem actually exists with a spec, and then we’ll ﬁgure out how to ﬁx it:\n\ndescribe 'password' do\n\nbefore { subject.save! }\n\nit 'is not required when updating name' do\n\nuser = User.last expect(user.password).to be_nil\n\nuser.update(name: 'New Name') expect(user).to be_valid\n\nend\n\nend",
      "content_length": 1724,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 154,
      "content": "Improving Our User Model\n\nRunning this spec, we can see that the bug is real:\n\n1) User password is not required when updating name Failure/Error: expect(subject).to be_valid\n\nexpected #<User id: 462, name: \"New Name\", email: \"user16@example.com\", created_at: \"2023-01-22 21:10:55.920524000 +0000\", updated_at: \"2023-01-22 21:10:55.920524000 +0000\", password_salt: [FILTERED], password_hash: [FILTERED]> to be valid, but got errors: Password can't be blank, Password confirmation can't be blank\n\nWe can ﬁx this by making our password validations conditional. There are two conditions where we do want the password validation:\n\n1. When the user has not been saved to our database 2. When the user is updating their password\n\nWe can ﬁrst create a private helper method to check for these conditions:\n\nprivate\n\ndef password_required?\n\n!persisted? || password.present?\n\nend\n\nSo if the user record has not been persisted to our database, because the record is new, or the password is actually present, because the user is updating their password, then we want to execute our password and password conﬁrmation validations. We just need to update our validations to use this helper method to allow them to become conditional:\n\nvalidates :password,\n\npresence: true, confirmation: true, if: :password_required?\n\nvalidates :password_confirmation,\n\npresence: true, if: :password_required?\n\nThis change gets our new spec to pass.\n\n147",
      "content_length": 1421,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 155,
      "content": "148\n\n12 User Authentication\n\nSummary\n\nIn this chapter, we learned how to add a password authentication system to our User model. We learned how to use the bcrypt gem to hash and salt our passwords. We also learned how to use the shoulda-matchers gem to validate password and password conﬁrmation values. We also provided specs and ﬁxes around the password validations to ensure that we only require passwords when we should.\n\nNo Devises were harmed in the making of this chapter.",
      "content_length": 479,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 156,
      "content": "Administration\n\n13\n\nIn this chapter, we will develop an administrative interface for our blog’s application data. Everything we’ve built so far will be given the usual CRUD operations (Create, Read, Update, Delete) we’d expect to have available. We will save a lot of time by leveraging Active Admin to create these interfaces.\n\nAdding Active Admin\n\nActive Admin is a gem that provides a framework for creating administrative interfaces for Rails applications. It is a very powerful tool that can be implemented simply and quickly, but can also be customized to a great degree.\n\nAdding the Gem\n\nThe ﬁrst step is to add the gem to our project:\n\nbundle add activeadmin\n\nNext, we need to run the generator to install the necessary integration ﬁles:\n\nbe rails generate active_admin:install --skip-users --skip-comments\n\nWe will skip the user integration and instead use our own User model for our user authentication. We will also skip the additional Active Admin comments table as we will not be using admin comments in our blog application.\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_13\n\n149",
      "content_length": 1226,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 157,
      "content": "150\n\n13 Administration\n\nFigure 13-1 Active Admin dashboard\n\nThat’s it for the setup. We can now start using Active Admin to create our administrative interfaces.\n\nLet’s start up Rails:\n\nbe rails s\n\nAnd see what we have so far. Visiting the admin URL shows us output like Figure 13-1:\n\nhttp://localhost:3000/admin\n\nIt’s not much at the moment, but we will build it out soon enough.\n\nTesting Active Admin\n\nActive Admin is recipe driven. We will use a DSL (domain-speciﬁc language) provided by Active Admin to tell it what we want it to do for us. As a rule, I don’t usually write specs for third-party gems that already have their own specs, but Active Admin is a special case. Our Active Admin interface code can be considered part of our application and should be tested as such. Our DSL code could very well contain bugs or could become broken by future changes in our models, for example, so we will write high-level system specs to protect us from our future selves.\n\nLogging In\n\nThe ﬁrst thing we should pursue is to prevent anonymous access to our admin interface. Right now, we can access it without logging in; it’s completely unprotected. Let’s begin with a system spec to",
      "content_length": 1180,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 158,
      "content": "Logging In\n\ntest that we can’t access the admin interface without logging in. In our spec/system directory, let’s create a new ﬁle called login_spec.rb and add the following code:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Login Page' do let(:user) { create(:user) }\n\nit 'Admin requires logging in' do\n\nvisit admin_root_path\n\nexpect(page).to have_css('h2', text: 'Sign in')\n\nfill_in 'Email', with: user.email fill_in 'Password', with: 'changeme' click_button 'Submit'\n\nexpect(page).to have_css('h2', text: 'Dashboard')\n\nclick_link 'Logout'\n\nexpect(page).to have_link 'My Blog'\n\nend\n\nend\n\nIn our spec, we try, as an anonymous user, to visit our admin dashboard page and then expect to be redirected away to our login page where we should be encouraged to log in. We then ﬁll in our login form, submit it, and expect to be redirected to our admin dashboard. Finally, we click the logout link and expect to be redirected back to our blog’s public homepage. It’s a very simple spec, but it will go a long way in helping us drive out our admin login/logout implementation code.\n\nWhen we run this spec, we see it fails with the following error:\n\n1) Login Page Admin requires logging in\n\nFailure/Error: expect(page).to have_css('h2', text: 'Sign in')\n\nexpected to find visible css \"h2\" with text \"Sign in\" but there were no matches.\n\nTo get past this particular error, we need to make several changes:\n\n1. Implement our login form 2. Add a Rails route to render our login form 3. Have Active Admin redirect anonymous users\n\n151",
      "content_length": 1518,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 159,
      "content": "152\n\n13 Administration\n\nFor the ﬁrst item, we will need to create a new view template to render our login form. In our app/views directory, let’s create a new directory called sessions and inside that directory create a new ﬁle called new.html.erb with the following content:\n\n<%= form_for(:login, url: login_path) do |f| %>\n\n<h2>Sign in</h2> <div>\n\n<%= f.label :email %> <%= f.email_field :email %>\n\n</div> <div>\n\n<%= f.label :password %> <%= f.password_field :password %>\n\n</div> <div>\n\n<button type=\"submit\">Submit</button>\n\n</div> <% end %>\n\nNext, we need to add our new route to our config/routes.rb ﬁle:\n\nget 'login', to: 'sessions#new'\n\nInstead of using the Rails resources method, we will use the get method to create a named route called login that maps to a controller named sessions with a method of new. This will enable the Rails login_path helper method for us. user\n\nour config/initializers/active_admin.rb ﬁle, we need to uncomment the following line:\n\nNext, we\n\nneed\n\nto\n\nenable\n\nauthentication\n\nin Active Admin.\n\nIn\n\nconfig.authentication_method = :authenticate_admin_user!\n\nIf you read the comment above this line:\n\n# This setting changes the method which Active Admin calls (within # the application controller) to return the currently logged in user.\n\nWe know from reading the comment that we need to create a new method in our application_ controller.rb ﬁle called authenticate_admin_user! that will be called by Active",
      "content_length": 1441,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 160,
      "content": "Logging In\n\nAdmin to authenticate our users. We can verify this is the next thing to pursue by running our spec again:\n\n1) Login Page Admin requires logging in\n\nFailure/Error: send(active_admin_namespace.authentication_method) if active_admin_namespace.authentication_method\n\nNoMethodError:\n\nundefined method `authenticate_admin_user!' for #<Admin::DashboardController:0x0000000000f4d8>\n\nLet’s add the following method to our application_controller.rb ﬁle:\n\ndef authenticate_admin_user!\n\nredirect_to login_path if session[:admin_user_id].nil?\n\n@current_admin_user = User.find_by(id: session[:admin_user_id])\n\nend\n\nThis method will redirect anonymous users to our login page. We consider a user to be anonymous if they do have a session variable name admin_user_id set. If they do have the session variable we’re looking for, then we query our database to try to locate their user account. Either way, we set the query result (nil or other) to an instance variable name @current_admin_user. We can now run our spec again and see that we’re getting a new failure message:\n\n1) ActionController::RoutingError:\n\nuninitialized constant SessionsController\n\nThis error is telling us that we need to create our sessions controller. Let’s do that now by creating a new ﬁle called sessions_controller.rb in our app/controllers directory and adding the following code:\n\nclass SessionsController < ApplicationController end\n\nRunning our spec again, we see that we’ve moved along to the next error message:\n\n1) Login Page Admin requires logging in\n\nFailure/Error: <%= form_for(:login, url: login_path) ...\n\nActionView::Template::Error:\n\nundefined local variable or method `sessions_path'\n\n153",
      "content_length": 1678,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 161,
      "content": "154\n\n13 Administration\n\nWhy is it not complaining about our lack of a new method in our sessions controller? Well, as it turns out, Rails will look for a view template with the same name as the controller method, and if it ﬁnds one, it will automatically render it. In our case, we do have a view template called new.html.erb in our app/view/sessions directory, so Rails will render that for us.\n\nSo what does the error message mean? By default, our form_for helper method is creating an HTML form tag for us that contains a method of post and an action of sessions_path. That particular Rails route does not currently exist in our application, so we need to add it. Let’s do that now by adding the following line to our config/routes.rb ﬁle:\n\npost 'login', to: 'sessions#create'\n\nThis will give us a second login route that maps to a create method in our sessions controller. We can verify this by running the Rails routes command:\n\nbe rails routes -g login\n\nThe output shows both new login routes, one for get and one for post:\n\nPrefix Verb URI Pattern\n\nController#Action\n\nlogin GET /login(.:format) sessions#new\n\nPOST /login(.:format) sessions#create\n\nRunning our spec again, we see that we’ve moved along to the next error message:\n\nAbstractController::ActionNotFound:\n\nThe action 'create' could not be found for SessionsController\n\nIn order to ﬁx this error, we need to add our create method to our sessions controller. Let’s do that now by adding the following code to our sessions_controller.rb ﬁle:\n\nclass SessionsController < ApplicationController\n\ndef create end\n\nend",
      "content_length": 1577,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 162,
      "content": "Logging In\n\nRunning our spec again, we see that we’ve moved along to the next error message:\n\n1) Login Page Admin requires logging in\n\nFailure/Error: expect(page).to have_css('h2', text: 'Dashboard')\n\nexpected to find css \"h2\" but there were no matches\n\nThis error is telling us that we’re submitting our login form successfully, but after that we’re not redirecting to the dashboard page. It’s time to implement the contents of our create method in our SessionsController:\n\ndef create\n\nuser = User.find_by(email: params[:login][:email]) if User.authenticate(user&.email, params[:login][:password])\n\nsession[:admin_user_id] = user.id redirect_to admin_root_path\n\nelse\n\nrender :new\n\nend\n\nend\n\nOur params hash will contain a top-level login key that contains another hash with our actual login form data. We can query our database using the email key of this inner hash to try to locate a matching user account. We then try to authenticate the user using our User.authenticate method that we added to our User model earlier, making sure to use the &. safety operator to avoid a nil error if the user account is not found. If the user is authenticated, we set the session variable admin_user_id and redirect to our admin dashboard page. If the user is not authenticated, we render the new view template again.\n\nRunning our spec again, we see that we’ve moved along to the next error message:\n\n1) Login Page Admin requires logging in Failure/Error: click_link 'Logout'\n\nCapybara::ElementNotFound:\n\nUnable to find link \"Logout\"\n\nIt looks like our login is ﬁnally working. Now we need to work on our logout functionality.\n\nThere are several steps we will work through to get our logout link working:\n\n1. Add a Rails route for our logout link 2. Add a destroy method in our sessions controller 3. Conﬁgure Active Admin to show our logout link\n\n155",
      "content_length": 1840,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 163,
      "content": "156\n\n13 Administration\n\nLet’s start by adding a Rails route for our logout link. We’ll add the following line to our config/routes.rb ﬁle:\n\nget 'logout', to: 'sessions#destroy'\n\nAgain, we’re using a named route. This gives us a logout path that maps to a destroy method in our sessions controller. We can verify this by running the Rails routes command:\n\nbe rails routes -g logout\n\nIt gives us the following output conﬁrming our new route:\n\nPrefix Verb URI Pattern logout GET /logout(.:format) sessions#destroy\n\nController#Action\n\nWe could have just as easily used a delete route instead of a get route if we wanted to. A delete route would be more RESTful, but we’re not actually making any sort of destructive changes to our database, so we’ll use a get route instead.\n\nNext, we need to add our destroy method in our SessionsController. Let’s do that now\n\nby adding the following code:\n\ndef destroy\n\nsession[:admin_user_id] = nil redirect_to root_path\n\nend\n\nThis method simply clears the admin_user_id session variable and redirects us to our homepage. Without the session variable, any future requests to our admin dashboard will be redirected to our login page.\n\nFinally, we need to conﬁgure Active Admin to actually show our logout link; it’s off by default. We need to uncomment and/or (re)conﬁgure the following variables in our active_admin.rb initializer ﬁle:\n\nconfig.current_user_method = :current_admin_user config.logout_link_path = :logout_path config.logout_link_method = :get\n\nThe logout_link_path and the logout_link_method need to match our previous work in our routes and sessions controller. We point them to our logout_path that uses the get method.",
      "content_length": 1669,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 164,
      "content": "Logging In\n\nThe current_user_method variable tells Active Admin which method to call on our ApplicationController to get the current user via our login session variable. We still need to add that, so let’s add this method to our ApplicationController:\n\ndef current_admin_user\n\n@current_admin_user ||= User.find_by(id: session[:admin_user_id])\n\nend\n\nWe memoize the result of our User.find_by database query so that we don’t query our database every time we call this method. Active Admin can and will call this method multiple times during a single HTTP request, so our ||= memoization adds some efﬁciency.\n\nRunning our spec again, we can see it’s ﬁnally passing. We’ve successfully implemented our login\n\nand logout functionality for our admin.\n\nAdmin Layout\n\nRight now, our login page is using our default application.html.erb layout ﬁle, so it includes our header and sidebar sections. It would be nice to have a separate layout ﬁle for our login page that does not include anything extra. In addition, it could also be laid out and styled differently. We can accomplish this by creating a new layout ﬁle and assigning it in our SessionController.\n\nLet’s ﬁrst add an expectation to make sure we’re rendering the correct layout ﬁle. We don’t really need an entire new spec for testing that one layout or another is being used, and we can easily look for the presence of a speciﬁc element on the page to make sure we’re using the one we mean to. Let’s add the following expectation just inside the beginning of our “Admin requires logging in” spec in our login_spec.rb system spec ﬁle:\n\nexpect(page).to have_css('h2', text: 'Admin')\n\nThis expectation will look for an h2 element with the text Admin just before we try to log in. This will fail because we’re not currently using the correct layout ﬁle:\n\n1) Login Page Admin requires logging in\n\nFailure/Error: expect(page).to have_css('h2', text: 'Admin')\n\nexpected to find css \"h2\" but there were no matches\n\nLet’s ﬁx that now by creating a new layout ﬁle called admin.html.erb in our app/views/ layouts directory. We’ll add the following content to our new layout ﬁle:\n\n<!DOCTYPE html> <html>\n\n<head>\n\n<title>Admin</title>\n\n157",
      "content_length": 2178,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 165,
      "content": "158\n\n13 Administration\n\n<%= csrf_meta_tags %> <%= csp_meta_tag %> <%= stylesheet_link_tag \"application\", \"data-turbo-track\": \"reload\" %>\n\n</head> <body>\n\n<h2>Admin</h2> <%= yield %>\n\n</body>\n\n</html>\n\nNext, we need to inform our SessionsController that it should use our new layout ﬁle. We can do that by adding the following line to our SessionsController class near the top:\n\nclass SessionsController < ApplicationController\n\nlayout 'admin'\n\n...\n\nend\n\nThis gets our spec passing. We’re now using the correct layout ﬁle for our login page.\n\nManaging Pages\n\nNow that we have our Active Admin login and logout functionality working, we can begin adding data management interfaces. We’ll ﬁrst add Pages. Inside of our spec/system directory, we’ll create a new directory called admin, then inside of that new directory, we’ll create a new ﬁle called pages_spec.rb with the following content:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Pages' do\n\nlet(:user) { create(:user) }\n\ndescribe 'A new page' do it 'can be added' do\n\nvisit admin_root_path\n\nfill_in 'Email', with: user.email fill_in 'Password', with: 'changeme' click_button 'Submit'\n\nexpect(page).to have_css('h2', text: 'Dashboard')\n\nvisit new_admin_page_path\n\nselect User.last.name, from: 'User'",
      "content_length": 1248,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 166,
      "content": "Managing Pages\n\nfill_in 'Title', with: 'Page Title' fill_in 'Summary', with: 'Summary info' fill_in 'Content', with: 'Content goes here' fill_in 'Tags', with: 'foo, bar'\n\ncheck('Published')\n\nclick_button 'Create Page'\n\nwithin '.flashes' do\n\nexpected = 'Page was successfully created.' expect(page).to have_css('.flash_notice', text: expected)\n\nend\n\nwithin '#main_content' do\n\nexpect(page).to have_css('td', text: user.name) expect(page).to have_css('td', text: 'Page Title') expect(page).to have_css('td', text: 'Summary info') expect(page).to have_css('td', text: 'Content goes here') expect(page).to have_css('span.yes', text: 'YES') expect(page).to have_css('td', text: 'bar, foo')\n\nend\n\nend\n\nend\n\nend\n\nThis spec is a bit more complicated than our previous system specs. We’re going to log in, then we’re going to create a new page with some basic form ﬁeld values. We’ll then verify that the page was created by checking the HTML that is styled with the flashes CSS class and the HTML with the main_content id attribute sections of the show page that appears after a successful page creation.\n\nRunning our new system spec, we get the following error:\n\n1) Pages A new page can be added\n\nFailure/Error: visit new_admin_page_path\n\nNameError:\n\nundefined local variable or method `new_admin_page_path'\n\nWe can see that our spec is failing because it can’t ﬁnd a route for our new_admin_page_path. We need to add a route for this path but not in the usual way of modifying our routes.rb ﬁle. Active Admin adds routes for us if we use the ActiveAdmin.register method to register a new model. In our app/admin directory, let’s create a new ﬁle called pages.rb with the following content:\n\nActiveAdmin.register Page do end\n\n159",
      "content_length": 1722,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 167,
      "content": "160\n\n13 Administration\n\nThis gives us a new route for our new_admin_page_path and moves us along to our next spec failure message:\n\n1) Pages A new page can be added\n\nFailure/Error: fill_in 'Tags', with: 'foo, bar'\n\nCapybara::ElementNotFound:\n\nUnable to find field \"Tags\" that is not disabled\n\nThis error is telling us that Capybara can’t ﬁnd a form ﬁeld with the label of \"Tags\". We need to add a form ﬁeld for our tags_string attribute. Unfortunately, Active Admin doesn’t have an easy way to add a single form ﬁeld to the existing form ﬁelds that it generates for us automatically. We will need to override the entire default form that Active Admin generates for us.\n\nLet’s modify our admin/pages.rb ﬁle to add a custom form:\n\nform do |f|\n\nf.semantic_errors inputs do\n\nf.input :user f.input :title f.input :summary f.input :content f.input :tags_string, label: 'Tags' f.input :published\n\nend f.actions\n\nend\n\nThis gets our tags_string form ﬁeld to show up and also allows us to customize our form if we needed any other customizations. Now when we run our spec, we get the following error:\n\n1) Pages A new page can be added\n\nFailure/Error: raise ActiveModel::ForbiddenAttributesError ...\n\nActiveModel::ForbiddenAttributesError:\n\nActiveModel::ForbiddenAttributesError\n\nWe’re getting this error because we have not yet permitted valid parameters to be processed. This is similar to how we have to permit parameters in our non-admin Rails controllers. We need to add a permitted_params method call and add our Page parameter list:\n\npermit_params :user_id,\n\n:title, :summary, :content,",
      "content_length": 1582,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 168,
      "content": "Managing Pages\n\n:tags_string, :published\n\nThis allows our Active Admin to process the parameters that we’re passing in from our form. Now when we run our spec, we get the following error message:\n\n1) Pages A new page can be added\n\nFailure/Error: expect(page).to have_css('td', text: 'bar, foo')\n\nexpected to find css \"td\" within #<Capybara::Node::Element ...\n\nThe page we land on after a successful Page creation is the Active Admin equivalent of a Rails show page for our Page model. We can see that the tags_string attribute is not being displayed. We have a similar situation as before with our Active Admin generated form; we need to customize the show page output to display our tags_string attribute.\n\nOverriding Active Admin Form Field Values\n\nOur tags_string ﬁeld is not being populated with the existing tag values. We can run our spec using SHOW_CHROME=1 to conﬁrm. The missing values make sense because tags_string is an attr_accessor attribute on our Page model and not an actual ActiveRecord database column.\n\nWe can ﬁx this by providing the value ourselves. First, we need a helper method to convert our tags attribute into a comma-separated string. Let’s add a spec to capture this idea. In our spec/models/page_spec.rb ﬁle, let’s add the following spec:\n\ndescribe '#tags_string_for_form' do\n\nlet(:tag) { create(:tag, name: 'foo') } let(:tag2) { create(:tag, name: 'bar') } let(:page) { create(:page, :published) }\n\nbefore do\n\ncreate(:page_tag, page:, tag:) create(:page_tag, page:, tag: tag2)\n\nend\n\nit 'returns the tags in comma delimited format' do\n\nexpect(page.tags_string_for_form).to eq('bar, foo')\n\nend\n\nend\n\nWe then get our spec failure message:\n\n1) Page#tags_string_for_form returns the tags in comma delimited format Failure/Error: expect(page.tags_string_for_form).to eq('bar, foo')\n\n161",
      "content_length": 1812,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 169,
      "content": "162\n\n13 Administration\n\nNoMethodError:\n\nundefined method `tags_string_for_form' for #<Page id: ...\n\nOur failure message tells us we need to add a method to our Page model named tags_string_ for_form. Let’s modify our app/models/page.rb ﬁle to add it:\n\ndef tags_string_for_form end\n\nWhen we re-run our spec, we get a different failure message:\n\n1) Page#tags_string_for_form returns the tags in comma delimited format Failure/Error: expect(page.tags_string_for_form).to eq('bar, foo')\n\nexpected: \"bar, foo\"\n\ngot: nil\n\nLet’s modify our tags_string_for_form method to return the expected value:\n\ndef tags_string_for_form\n\ntags.ordered.map(&:name).join(', ')\n\nend\n\nWe “map over” our ordered tags attribute, calling the name method on each tag to get the name of the tag. This results in an array that we can then join together using a comma. This ﬁnal string is returned from our method.\n\nWhen we re-run our spec, we can see it’s now passing. Now we can modify our admin/pages.rb ﬁle to add a custom show page that uses our new tags_string_for_form method:\n\nshow do\n\nattributes_table do\n\nrow :user row :title row :slug row :summary row :content row('Tags') { |p| p.tags_string_for_form } row :published\n\nend\n\nend",
      "content_length": 1207,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 170,
      "content": "Managing Pages\n\nThis gets our tags appearing on the page and gets our spec passing. Next, let’s add a spec for our ability to edit a page:\n\ndescribe 'An existing page' do\n\nlet(:the_page) { create(:page, :published, user:) } let(:user2) { create(:user) }\n\nbefore do\n\nthe_page.tags << create(:tag, name: 'foo') the_page.tags << create(:tag, name: 'bar') user2\n\nend\n\nit 'can be edited' do\n\nvisit admin_root_path\n\nfill_in 'Email', with: user.email fill_in 'Password', with: 'changeme' click_button 'Submit'\n\nexpect(page).to have_css('h2', text: 'Dashboard')\n\nvisit admin_pages_path\n\nclick_link 'Edit'\n\nexpect(page).to have_select('page_user_id', selected: user.name) expect(page).to have_field('page_title', with: the_page.title) expect(page).to have_field('page_summary', with: the_page.summary) expect(page).to have_field('page_content', with: the_page.content) expect(page).to have_field('page_tags_string', with: 'bar, foo') expect(page).to have_unchecked_field('page_published')\n\nselect user2.name, from: 'User'\n\nfill_in 'Title', with: 'Page Title' fill_in 'Summary', with: 'Summary info' fill_in 'Content', with: 'Content goes here' fill_in 'Tags', with: 'foo, bar, baz'\n\ncheck('Published')\n\nclick_button('Update Page')\n\nwithin '.flashes' do\n\ntext = 'Page was successfully updated.' expect(page).to have_css('.flash_notice', text:)\n\nend\n\nwithin '#main_content' do\n\nexpect(page).to have_css('td', text: user2.name) expect(page).to have_css('td', text: 'Page Title') expect(page).to have_css('td', text: 'Summary info')\n\n163",
      "content_length": 1524,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 171,
      "content": "164\n\n13 Administration\n\nexpect(page).to have_css('td', text: 'Content goes here') expect(page).to have_css('span.yes', text: 'YES') expect(page).to have_css('td', text: 'bar, baz, foo')\n\nend\n\nend\n\nend\n\nWhen we run our new edit spec, we get the following error:\n\n1) Pages An existing page can be edited\n\nFailure/Error: expect(page).to have_field('page_tags_string',\n\nwith: 'bar, foo') expected to find visible field \"page_tags_string\" that is not disabled with value \"bar, foo\" but there were no matches.\n\nLet’s modify our admin/pages.rb ﬁle to use our tags_string_for_form method. We need to modify our form block to use the input_html attribute to set the value of our tags_string ﬁeld:\n\nf.input :tags_string, label: 'Tags',\n\ninput_html: { value: f.object.tags_string_for_form }\n\nWe can access our Page object using the f.object method, and then we can call our tags_string_for_form method on that to get the comma-separated value we want.\n\nThe rest of the spec is a lot like our previous spec for creating a new page. When we run it again,\n\nwe can see it is now passing, although we have created some code duplication along the way.\n\nFactoring Out Duplicate Login Code\n\nWe’re now logging in to our admin three times in two different spec ﬁles. It’s time to factor out a helper method to reduce code duplication. Let’s create a new directory in our spec directory named support, and inside our new directory, let’s create a new ﬁle called login.rb. Then let’s add a method to our new ﬁle to handle logging in:\n\ndef login_as(user)\n\nvisit admin_root_path\n\nexpect(page).to have_css('h2', text: 'Admin') expect(page).to have_css('h2', text: 'Sign in')\n\nfill_in 'Email', with: user.email fill_in 'Password', with: 'changeme' click_button 'Submit'",
      "content_length": 1742,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 172,
      "content": "Managing Pages\n\nexpect(page).to have_css('h2', text: 'Dashboard')\n\nend\n\nTo give RSpec access to our new login_as method, we need to add the following line to the bottom of our spec/rails_helper.rb ﬁle:\n\nrequire \"#{Rails.root}/spec/support/login\"\n\nThis will load our login.rb ﬁle whenever our spec suite is run.\n\nNow we can replace our three login calls with a single call to our new helper method. The ﬁrst one\n\nis in our system/login_spec.rb ﬁle:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Login Page' do let(:user) { create(:user) }\n\nit 'Admin requires logging in' do\n\nlogin_as(user)\n\nclick_link 'Logout'\n\nexpect(page).to have_link 'My Blog'\n\nend\n\nend\n\nThe other two are in our system/admin/pages_spec.rb ﬁle. Let’s do a similar replacement on them. In fact, in all of our admin pages, we are going to need to log in before doing much else, so let’s add our login_as call in a before block so it’s called before every spec runs:\n\nbefore do\n\nlogin_as(user)\n\nend\n\nOnce we’ve done that, let’s re-run our system specs and make sure they are all still passing:\n\nSHOW_CHROME=1 be rspec spec/system/**/*.rb\n\n165",
      "content_length": 1104,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 173,
      "content": "166\n\n13 Administration\n\nPreviewing a Page\n\nNext, we’re going to customize our Page admin, so we can visit a page directly from within our admin interface. We’ll do this by adding a custom link to our index page. We don’t yet have an index page spec, so let’s start there. Let’s add this new spec to our “An existing page” describe block in our system/admin/pages_spec.rb ﬁle:\n\nit 'can be visited' do\n\nvisit admin_pages_path\n\nwithin '.index_content' do\n\nexpect(page).to have_css('td', text: the_page.title) expect(page).to have_css('td', text: 'bar, foo') expect(page).to have_css('span.yes', text: 'YES')\n\nnew_window = window_opened_by do\n\nclick_link(\"/pages/#{the_page.slug}\")\n\nend\n\nwithin_window new_window do\n\nexpect(page).to have_css('h2', text: the_page.title)\n\nend\n\nend\n\nend\n\nTo start with, we visit our Page index page. Then we use the within method to limit our scope to the .index_content element. This is the element that contains our table of Page objects. We can then use the have_css matcher to check that our Page is listed in the table.\n\nNext, we use the window_opened_by method to open a new window when we click our Page link. We then use the within_window method to switch to that new window and check that it contains our Page title.\n\nLet’s run our spec and see what happens:\n\n1) Pages An existing page can be visited\n\nFailure/Error: expect(page).to have_css('td', text: 'bar, foo')\n\nRight away, we can see that we are going to need to fully customize our index page to show our tags. Let’s do that now by adding a new index block to our ActiveAdmin.register call in our admin/pages.rb ﬁle:\n\nindex do\n\ncolumn :title column('Tags') { |p| p.tags_string_for_form }\n\nend",
      "content_length": 1685,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 174,
      "content": "Managing Pages\n\nThis change breaks our ability to click the “Edit” link, and that breaks a previously working spec, but we’ll get it ﬁxed up momentarily.\n\nThe spec failure we’re concerned with at the moment is the complaint about our published\n\ncolumn:\n\n1) Pages An existing page can be visited\n\nFailure/Error: expect(page).to have_css('span.yes', text: 'YES')\n\nexpected to find css \"span.yes\"\n\nLet’s ﬁx that by adding a new published column to our index block:\n\ncolumn :published\n\nOur next spec failure message complains about our link to visit our Page:\n\n) Pages An existing page can be visited\n\nFailure/Error: click_link(\"/pages/#{the_page.slug}\")\n\nCapybara::ElementNotFound:\n\nUnable to find link\n\nLet’s ﬁx that by adding a link to our non-admin show page. In our index block, we can add a new column with a block that returns a link to the public URL of our page:\n\ncolumn('Preview') do |p|\n\npath = \"/page/#{p.slug}\" link_to path, path, target: '_blank'\n\nend\n\nIf we now run our whole spec ﬁle, we can see that we’ve broken a previous spec. Our edit link is no longer working:\n\n1) Pages An existing page can be edited Failure/Error: click_link 'Edit'\n\nCapybara::ElementNotFound:\n\nUnable to find link \"Edit\"\n\n167",
      "content_length": 1213,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 175,
      "content": "168\n\n13 Administration\n\nWhen we customized the columns in our index block, we accidentally removed our default Edit link. Let’s add it back in, as well as the id column and our batch actions checkbox:\n\nindex do\n\nselectable_column id_column column :title column('Tags') { |p| p.tags_string_for_form } column :published column('Preview') do |p|\n\npath = \"/page/#{p.slug}\" link_to path, path, target: '_blank'\n\nend actions\n\nend\n\nOur Active Admin Page index is back to a fully working state, and all of our specs should be back to passing now.\n\nManaging Images\n\nThe next piece of functionality we’re going to add to our admin is the ability to manage our image uploads. We’ll want to be able to upload images, edit them, and delete them. We’ll also want to provide a thumbnail of an uploaded image as well as a valid HTML <image /> tag that we can easily use in our Page content.\n\nViewing Images\n\nLet’s start by adding a new spec that tests our ability to view images in our admin, in a new Images index page. In our system/admin directory, let’s add a new ﬁle called images_spec.rb with the following content:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Images' do\n\nlet(:user) { create(:user) } let(:img) { Image.last }\n\nbefore do\n\nlogin_as(user)\n\nend\n\ndescribe 'index' do\n\nbefore do\n\ncreate(:image)\n\nend",
      "content_length": 1297,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 176,
      "content": "Managing Images\n\nit 'renders images' do\n\nvisit admin_images_path\n\nwithin 'table.index_table' do\n\nwithin 'td.col-name' do\n\nexpect(page).to have_text(img.name)\n\nend\n\nwithin 'td.col-image' do xpath = <<~IMG.squish\n\n//img[@height='80' and\n\n@alt='#{img.name}' and @title='#{img.name}' and @src='/images/#{img.id}']\n\nIMG expect(page).to have_xpath(xpath)\n\nend\n\nwithin 'td.col-image_tag' do\n\ntext = <<~IMG.squish\n\n<img alt=\"#{img.name}\"\n\ntitle=\"#{img.name}\" src=\"/images/#{img.id}\" />\n\nIMG expect(page).to have_text(text)\n\nend\n\nend\n\nend\n\nend\n\nend\n\nWe’ll test that our admin images index has columns for the image name, a valid thumbnail image, and a valid HTML <image /> tag. We’ll also test that the image name is displayed as the alt and title attributes of the image in our thumbnail and in our <image /> tag.\n\nWe’re using within blocks to limit our scope to the exact td tags where we expect to ﬁnd things. We need to do it this way because our image name is present as a string in one form or another in all three of the columns we’re testing.\n\nWe are using Capybara’s has_xpath matcher to test that our thumbnail image is displayed on our page as properly rendered HTML. We then use Capybara’s has_text matcher to test that a non-rendered string representation of our <image /> tag is displayed on the page as well. This second version can be used to easily copy and paste the <image /> tag into our Page content later when we’re making new pages.\n\nLet’s run our spec and see what happens:\n\n1) Images index renders images\n\nFailure/Error: visit admin_images_path\n\n169",
      "content_length": 1565,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 177,
      "content": "170\n\n13 Administration\n\nNameError:\n\nundefined local variable or method `admin_images_path'\n\nAs before, the admin route we’re trying to access does not yet exist. We can get the route working by simply adding a new Active Admin ﬁle with a proper ActiveAdmin.register block for our Image model. Let’s do that now. In our app/admin directory, let’s add a new ﬁle called images.rb with the following content:\n\nActiveAdmin.register Image do end\n\nRe-running our spec, we can see that we’ve got our Admin Image routes now, and we have a new failure message:\n\n1) Images index renders images Failure/Error: ...\n\nCapybara::ElementNotFound:\n\nUnable to find css \"td.col-image\"\n\nThis error message is telling us that we’re not able to ﬁnd a td tag with the class col-image . Let’s ﬁx that by adding a custom index block to our ActiveAdmin.register block and a column for our image:\n\nindex do\n\ncolumn 'Image' do |i|\n\nimage_tag image_path(i),\n\nheight: 80, alt: i.name, title: i.name\n\nend\n\nend\n\nWe’re using the Rails image_tag helper and our image_path route to create a thumbnail image with a height of 80 pixels that we can use to preview our full-size image. We’re also using the image name ﬁeld to set the alt and title attributes of our image.\n\nLet’s run our spec again and see what happens:\n\n1) Images index renders images Failure/Error: ...",
      "content_length": 1331,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 178,
      "content": "Managing Images\n\nCapybara::ElementNotFound:\n\nUnable to find css \"td.col-name\"\n\nTo get this failure ﬁxed, we need to add a column for our image name. Let’s do that now:\n\nindex do\n\ncolumn :name column 'Image' do |i|\n\nimage_tag image_path(i),\n\nheight: 80, alt: i.name, title: i.name\n\nend\n\nend\n\nThis moves us to our next failure message:\n\n1) Images index renders images Failure/Error: ...\n\nCapybara::ElementNotFound:\n\nUnable to find css \"td.col-image_tag\"\n\nThis failure message is telling us that we’re not able to ﬁnd a td tag with a CSS class col-image_tag. This is our table column where we want to display our HTML <image /> tag. Let’s add a column; it will be similar to our thumbnail column except that we will display the <image /> tag itself, not a rendered HTML image:\n\ncolumn 'Image Tag' do |i|\n\n\"#{image_tag image_path(i), alt: i.name, title: i.name}\"\n\nend\n\nThis gets our spec passing.\n\nBecause we added a custom index block to our ActiveAdmin.register block, we’ve lost some of the default columns that Active Admin provides: selectable_column, id_column, and actions. Let’s add them back in:\n\nindex do\n\nselectable_column id_column column :name column 'Image' do |i|\n\n171",
      "content_length": 1179,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 179,
      "content": "172\n\n13 Administration\n\nimage_tag image_path(i),\n\nheight: 80, alt: i.name, title: i.name\n\nend column 'Image Tag' do |i|\n\n\"#{image_tag image_path(i), alt: i.name, title: i.name}\"\n\nend actions\n\nend\n\nWe created our spec using a factory for our image. We will also want to be able to upload new images via a regular HTML form.\n\nUploading New Images\n\nOur inclusion of Active Storage into our blog application takes care of the image ﬁle storage work for us; it will use whatever we deﬁned in our storage.yml ﬁle. We just need to add an image upload form to facilitate uploading the image from our local machine to our application.\n\nOur spec to capture our image upload functionality is\n\ndescribe 'new' do\n\nit 'uploads an image' do\n\nvisit new_admin_image_path\n\nfill_in 'Name', with: 'Name' file = Rails.root.join('spec/factories/images/image.jpeg') attach_file 'Image', file click_button 'Create Image'\n\nwithin '.flashes' do\n\nexpect(page).to have_css('.flash_notice',\n\ntext: 'Image was successfully created.')\n\nend\n\nwithin '.image table' do\n\nwithin 'tr.row-name td' do\n\nexpect(page).to have_text(img.name)\n\nend\n\nwithin 'tr.row-image td' do\n\nxpath = <<~IMG.squish\n\n//img[@height='80' and\n\n@alt='#{img.name}' and @title='#{img.name}' and @src='/images/#{img.id}']\n\nIMG expect(page).to have_xpath(xpath)\n\nend",
      "content_length": 1299,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 180,
      "content": "Managing Images\n\nwithin 'tr.row-image_tag td' do\n\ntext = <<~IMG.squish\n\n<img alt=\"#{img.name}\"\n\ntitle=\"#{img.name}\" src=\"/images/#{img.id}\" />\n\nIMG expect(page).to have_text(text)\n\nend\n\nend\n\nend\n\nend\n\nWe want to upload an image and also give it a friendly name for use with our HTML alt and title attributes. We use Capybara’s attach_file helper method to attach our image ﬁle to our form. This mimics navigating to the ﬁle on our local computer and selecting it for upload. We pass the attach_file method the ﬁle path to our image ﬁle using Rails’ .root method as the base of our path.\n\nAfter a successful upload, we expect to see a ﬂash message indicating that our image was successfully created. We also expect to see our image name, thumbnail image, and image tag in our table. These are similar to the expectations we have for our index spec, the major difference being that the CSS class names are mostly on the <tr> tags instead of the <td> tags.\n\nRunning our new spec, we get the following failure message:\n\n1) Images new uploads an image\n\nFailure/Error: attach_file 'Image', file\n\nCapybara::ElementNotFound:\n\nUnable to find file field \"Image\"\n\nOur failure message is telling us that Capybara is unable to ﬁnd an Image ﬁle ﬁeld on our form. Ap- parently, Active Admin doesn’t understand our has_one_attached association we added to our Image model. We can ﬁx this by adding a custom form block to our ActiveAdmin.register block and adding an f.input for our image ﬁeld:\n\nform do |f|\n\nf.inputs do\n\nf.input :name f.input :image\n\nend f.actions\n\nend\n\nAnd since we’re adding a custom form block that overrides Active Admin’s default form block, we need to add our name ﬁeld and the Active Admin actions method also.\n\n173",
      "content_length": 1723,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 181,
      "content": "174\n\n13 Administration\n\nWhen we run our spec again, we get a different failure message:\n\n1) Images new uploads an image\n\nFailure/Error: raise ActiveModel::ForbiddenAttributesError\n\nif !attributes.permitted?\n\nActiveModel::ForbiddenAttributesError:\n\nActiveModel::ForbiddenAttributesError\n\nThis failure message is telling us that we’re trying to pass attributes to our Image model that are not permitted. This is similar to how Rails handles strong parameters in a regular controller. We can ﬁx this by adding the Active Admin equivalent of allowing expected parameters to our ActiveAdmin.register block:\n\npermit_params :name, :image\n\nThis ﬁxes our permitted parameters failure message. We now get a different failure message:\n\n1) Images new uploads an image Failure/Error: ...\n\nCapybara::ElementNotFound:\n\nUnable to find css \"tr.row-image td\"\n\nIn Active Admin, after we successfully create a new record, we are redirected to the show page for that record. To get our spec passing, we need to add a custom show block to our ActiveAdmin.register block and customize the rows, just like how we customized the columns for our index block:\n\nshow do\n\nattributes_table do\n\nrow :name row 'Image' do |i|\n\nimage_tag image_path(i),\n\nheight: 80, alt: i.name, title: i.name\n\nend row 'Image Tag' do |i|\n\n\"#{image_tag image_path(i), alt: i.name, title: i.name}\"\n\nend\n\nend\n\nend",
      "content_length": 1359,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 182,
      "content": "Managing Images\n\nThis gets our spec passing. We can now upload images to our application, and we see an image thumbnail and image tags in our index and show pages. We also created some code duplication in our specs.\n\nFactor Out Our Image Matchers Let’s factor out our thumbnail image and image tag matchers into helper methods:\n\nprivate\n\ndef thumbnail_xpath(img)\n\n<<~IMG.squish\n\n//img[@height='80' and\n\n@alt='#{img.name}' and @title='#{img.name}' and @src='/images/#{img.id}']\n\nIMG\n\nend\n\ndef image_tag_string(img)\n\n<<~IMG.squish\n\n<img alt=\"#{img.name}\"\n\ntitle=\"#{img.name}\" src=\"/images/#{img.id}\" />\n\nIMG\n\nend\n\nThen we can replace the locations in our specs where we were using these matchers within our helper methods, ﬁrst in our index spec:\n\nwithin 'td.col-image' do\n\nexpect(page).to have_xpath(thumbnail_xpath(img))\n\nend\n\nwithin 'td.col-image_tag' do\n\nexpect(page).to have_text(image_tag_string(img))\n\nend\n\nAnd then also in our show spec:\n\nwithin 'tr.row-image td' do\n\nexpect(page).to have_xpath(thumbnail_xpath(img))\n\nend\n\nwithin 'tr.row-image_tag td' do\n\nexpect(page).to have_text(image_tag_string(img))\n\nend\n\n175",
      "content_length": 1120,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 183,
      "content": "176\n\n13 Administration\n\nWe can undoubtedly factor things down further, but we risk making things harder to understand and more difﬁcult to work on in the future. There is a balance to be had between reducing code duplication and making things too abstract. You’ll ﬁnd that balance for yourself, or with your team, the more code you write.\n\nWe can now upload images into our application. We will obviously want to be able to modify our\n\nimages too.\n\nEditing Images\n\nAs far as our Active Admin code is concerned, modifying images is very similar to creating images. Our ActiveAdmin.register block will use our existing custom form and show blocks when adding new or editing existing image uploads.\n\nLet’s add a spec for editing an image:\n\ndescribe 'edit' do\n\nlet(:name) { 'New Name' }\n\nbefore do\n\ncreate(:image)\n\nend\n\nit 'updates an image' do\n\nvisit edit_admin_image_path(img)\n\nwithin 'form.image' do\n\nwithin '.inline-hints' do\n\nexpect(page).to have_xpath(thumbnail_xpath(img))\n\nend\n\nend\n\nfill_in 'Name', with: name file = Rails.root.join('spec/factories/images/image.jpeg') attach_file 'Image', file click_button 'Update Image'\n\nwithin '.flashes' do\n\nexpect(page).to have_css('.flash_notice',\n\ntext: 'Image was successfully updated.')\n\nend\n\nimg.reload\n\nwithin '.image table' do\n\nwithin 'tr.row-name td' do\n\nexpect(page).to have_text(name)\n\nend\n\nwithin 'tr.row-image td' do\n\nexpect(page).to have_xpath(thumbnail_xpath(img))\n\nend",
      "content_length": 1426,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 184,
      "content": "Managing Images\n\nwithin 'tr.row-image_tag td' do\n\nexpect(page).to have_text(image_tag_string(img))\n\nend\n\nend\n\nend\n\nend\n\nWe ﬁrst create an image record in our database using our image factory. We don’t need to assign the created image to a local variable because we can use the img from our let at the top of our ﬁle, where it gets the last image created.\n\nNext, we visit the edit page for our image. On the page, we expect to see a thumbnail of our image. This isn’t strictly necessary, but it’s a good sanity check to make sure we’re on the right page and that we’re about to modify the image that we mean to modify. We then ﬁll in the name ﬁeld with our new name. We’ve created this static name string in a let block so that we can use it in multiple places in our spec, and additionally if we change it later, then we only need to modify a single code location.\n\nWe then attach a new image ﬁle to our form. We again use the attach_file method. We click\n\nthe Update Image button and check for our success message.\n\nIf everything has gone as planned, we next need to reload our image record from our database. This is because Active Admin will have updated our image record in our database, but our local img variable will still be pointing to the old record, with the old name and image data. We then check that our show page has our new image name and that our image thumbnail and image tag are both correct.\n\nRunning this spec gives us a failure message:\n\n1) Images edit updates an image Failure/Error:\n\nwithin '.inline-hints' do\n\nexpect(page).to have_xpath(thumbnail_xpath(img))\n\nend\n\nCapybara::ElementNotFound:\n\nUnable to find css \".inline-hints\"\n\nThis is failing because we haven’t added any code to our form block to display the image thumbnail. Active Admin has the concept of a form ﬁeld hint which can be whatever we would like to display below our form ﬁeld. We just need to add a hint option to our f.input image ﬁeld:\n\nform do |f|\n\nhint = image_tag image_path(f.object),\n\nheight: 80, alt: f.object.name, title: f.object.name\n\ninputs do\n\nf.input :name f.input :image, as: :file, hint:\n\n177",
      "content_length": 2102,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 185,
      "content": "178\n\n13 Administration\n\nend f.actions\n\nend\n\nThis will display our image thumbnail below our image ﬁeld in our form. We can run our spec again and see that it passes. We can also see when we run our previous specs that we broke one of them:\n\n1) Images new uploads an image Failure/Error:\n\nhint = image_tag image_path(f.object),\n\nheight: 80, alt: f.object.name, title: f.object.name\n\nActionView::Template::Error:\n\nNo route matches {:action=>\"show\", :controller=>\"images\",\n\n:id=>nil}, missing required keys: [:id]\n\nWhat happened? Well, remember that when we render our Active Admin image upload form, it’s the same form ﬁelds for both our new and edit routes; the only differences are our <form> attributes. This means the hint we have created is trying to display a thumbnail of an image that doesn’t exist yet in our database and therefore does not yet have an id assigned. The evidence is in the error message, where we see the id parameter is set to nil:\n\nNo route matches {:action=>\"show\", :controller=>\"images\", :id=>nil}\n\nWe can ﬁx this by adding a conditional sufﬁx to our hint:\n\nhint = image_tag image_path(f.object),\n\nheight: 80, alt: f.object.name, title: f.object.name if f.object.persisted?\n\nSo now we can support both scenarios, when we have an image that already exists in our database and also when we are creating a new image. We have also created more code duplication. Time to refactor.\n\nFactor Out Duplicate Expectations Two of our specs now have the same show page expectations. We can factor them out into a shared method. We also have the option of using a shared example group, but for this small amount of code,",
      "content_length": 1633,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 186,
      "content": "Managing Images\n\nit’s probably not worth the complexity and additional indirection that it would introduce for our future selves. Let’s add a method to our spec:\n\nprivate\n\ndef validate_show_page(img) within '.image table' do\n\nwithin 'tr.row-name td' do\n\nexpect(page).to have_text(img.name)\n\nend\n\nwithin 'tr.row-image td' do\n\nexpect(page).to have_xpath(thumbnail_xpath(img))\n\nend\n\nwithin 'tr.row-image_tag td' do\n\nexpect(page).to have_text(image_tag_string(img))\n\nend\n\nend\n\nend\n\nWe can then replace our duplicate code in our new spec:\n\ndescribe 'new' do\n\nit 'uploads an image' do\n\n... within '.flashes' do\n\nexpect(page).to have_css('.flash_notice',\n\ntext: 'Image was successfully created.')\n\nend\n\nvalidate_show_page(img)\n\nend\n\nend\n\nAnd also in our edit spec:\n\ndescribe 'edit' do\n\nlet(:name) { 'New Name' }\n\nbefore do\n\ncreate(:image)\n\nend\n\nit 'updates an image' do\n\n... img.reload\n\n179",
      "content_length": 883,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 187,
      "content": "180\n\n13 Administration\n\nvalidate_show_page(img)\n\nend\n\nend\n\nIf you like, you can also factor out our image ﬁle path into a small helper method:\n\nprivate\n\ndef file_path\n\nRails.root.join('spec/factories/images/image.jpeg')\n\nend\n\nDeleting Images\n\nI’ve found through experience supporting users that building ways to delete data into an application isn’t always a good idea. Just as soon as you provide this functionality, someone will use it accidentally, and then you’ll have to spend time restoring the deleted data from backups or creating it brand new again if you don’t yet have backups.\n\nYou are creating backups, right? However you work this out with your own data, in our case we’re going to embrace our Active Admin delete functionality, mostly because it’s a good learning experience. We’ll encounter the need to conﬁrm a destructive action with Capybara, so that will be fun.\n\nLet’s add a spec for deleting an image. The delete functionality and link is already built into Active Admin and is already present on our index page as well as our show page. We just need to add a spec to test it. I would imagine most image deletions will take place from the index page, so let’s add our spec there inside our existing describe ’index’ block:\n\nit 'deletes an image' do\n\nvisit admin_images_path\n\naccept_confirm do\n\nclick_link 'Delete'\n\nend\n\nwithin '.flashes' do\n\nexpect(page).to have_css('.flash_notice',\n\ntext: 'Image was successfully destroyed.')\n\nend\n\nend\n\nThe exciting thing here is the accept_confirm method. This is a Capybara helper method that wraps our click_link call and will accept the resulting conﬁrmation dialog that is displayed. We can run our spec and see that it passes and that we do get a success message.",
      "content_length": 1727,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 188,
      "content": "Managing Images\n\nFigure 13-2 Active Admin image ﬁlters\n\nAdmin Filters\n\nActive Admin provides ﬁlters to search our data on the index page for any type of record we register. This is great except that the default ﬁltering includes all of our ﬁelds, which is not always desirable. For example, right now, on our Images page we have the ﬁlters shown in Figure 13-2 available and turned on by default.\n\nWe can conﬁgure which ﬁelds are available for ﬁltering by adding filter entries. So if we wanted to get rid of the image attachment ﬁlter and the image blob ﬁlters, we could do this by adding only the ﬁlters that we do want to be present into our ActiveAdmin.register block:\n\nActiveAdmin.register Image do\n\nfilter :name filter :created_at filter :updated_at ...\n\nend\n\nIf we have a lot of default ﬁlters that we do want to keep and only a few that we want to remove, we can instead use the different Active Admin remove_filter syntax:\n\nActiveAdmin.register Image do\n\nremove_filter :image_blob, :image_attachment\n\n# other code not shown for brevity\n\nend\n\n181",
      "content_length": 1054,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 189,
      "content": "182\n\n13 Administration\n\nFigure 13-3 Fewer Active Admin image ﬁlters\n\nEither of these options will result in only the ﬁlters we want to be available on our index page to appear, as shown in Figure 13-3.\n\nLet’s also remove an unnecessary ﬁlter from our Pages admin page:\n\nremove_filter :page_tags\n\nWe would never ﬁlter pages by join table data, so this makes sense.\n\nOur Active Admin ﬁlter customizations are minimal, so we will not write any specs for them. It’s also highly unlikely we will remove the name, created_at , or updated_at ﬁelds from our image table anytime soon. Feel free to add specs for your own blog application ﬁlters if you like.\n\nManaging Users\n\nWe’ve now seen how to manage our Image and Page models with Active Admin. Now we’ll see how to manage our User model. The main functionality this addition provides is the ability to create users and then be able to update their passwords and email addresses. You may not ﬁnd this useful as a single administrator for a one-user blog application, but this will likely be the smallest Rails application you ever work on in your entire software engineering career, hopefully.\n\nAdding New Users\n\nLet’s add a spec for creating a new user. We’ll add this new spec into a new ﬁle called users_spec.rb located in our spec/system/admin directory:\n\nrequire 'rails_helper'\n\nRSpec.describe 'Users' do\n\nlet(:user) { create(:user) }\n\nbefore do",
      "content_length": 1395,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 190,
      "content": "Managing Users\n\nlogin_as(user)\n\nend\n\ndescribe 'A new user' do it 'can be added' do\n\nvisit new_admin_user_path\n\nfill_in 'Name', with: 'Foo Bar' fill_in 'Email', with: 'foo@bar.com' fill_in 'user[password]', with: 'changeme' fill_in 'user[password_confirmation]', with: 'changeme'\n\nclick_button 'Create User'\n\nwithin '.flashes' do\n\ntext = 'User was successfully created.' expect(page).to have_css('.flash_notice', text:)\n\nend\n\nwithin '#main_content' do\n\nexpect(page).to have_css('td', text: 'Foo Bar') expect(page).to have_css('td', text: 'foo@bar.com')\n\nend\n\nend\n\nend\n\nend\n\nThere are no real surprises here. The only remarkable change from our previous Active Admin specs is that we cannot use fill_in with the HTML label of Password because given that we will also have a Password Conﬁrmation ﬁeld label on the form, the Password label is not unique. Instead, we have to use the HTML names of our ﬁelds, which are user[password] and user[password_confirmation].\n\nWhen we run this spec, we see that it fails:\n\n1) Users A new user can be added\n\nFailure/Error: visit new_admin_user_path\n\nNameError:\n\nundefined local variable or method `new_admin_user_path'\n\nThe failure message indicates that we need to add a route for our new user path. We can do that by creating a new ﬁle called users.rb in our app/admin directory:\n\nActiveAdmin.register User do end\n\n183",
      "content_length": 1355,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 191,
      "content": "184\n\n13 Administration\n\nThis gets us our route and moves us on to our next failure:\n\n1) Users A new user can be added\n\nFailure/Error: fill_in 'user[password]', with: 'changeme'\n\nCapybara::ElementNotFound:\n\nUnable to find field \"user[password]\" that is not disabled\n\nThis may seem confusing at ﬁrst; we can set the password ﬁeld in our User model, and we already have specs that prove it. The problem is that Active Admin does not automatically include attributes, and recalling back to our User model, our password attribute is not an actual ﬁeld in our database, it is an attr_reader.\n\nWe can ﬁx this by overriding the default form method in our Active Admin User registration\n\nblock:\n\nActiveAdmin.register User do\n\nform do |f|\n\nf.semantic_errors inputs do\n\nf.input :name f.input :email f.input :password f.input :password_confirmation\n\nend f.actions\n\nend\n\nend\n\nRemember, if we override our form block, we have to add all the ﬁelds we want to be included in the form, so we’re adding our password and password_confirmation ﬁelds as well as our name and email ﬁelds. We can now run our spec again and see that we have a new failure:\n\n1) Users A new user can be added\n\nFailure/Error: raise ActiveModel::ForbiddenAttributesError if !attributes.permitted?\n\nActiveModel::ForbiddenAttributesError:\n\nActiveModel::ForbiddenAttributesError\n\nWe’ve seen this error message before. It means that we have not yet permitted our submitted form parameters. We can ﬁx this error by adding them:\n\npermit_params :name,\n\n:email,",
      "content_length": 1509,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 192,
      "content": "Managing Users\n\n:password, :password_confirmation\n\nThis gets our spec to pass. We can now add a spec for updating an existing user record:\n\ndescribe 'An existing user' do\n\nit 'can be updated' do\n\nvisit admin_users_path\n\nclick_link 'Edit'\n\nexpect(page).to have_field('user_name', with: user.name) expect(page).to have_field('user_email', with: user.email)\n\nfill_in 'Name', with: 'Bar Baz' fill_in 'Email', with: 'bar@baz.com' fill_in 'user[password]', with: 'change_me' fill_in 'user[password_confirmation]', with: 'change_me'\n\nclick_button('Update User')\n\nwithin '.flashes' do\n\ntext = 'User was successfully updated.' expect(page).to have_css('.flash_notice', text:)\n\nend\n\nwithin '#main_content' do\n\nexpect(page).to have_css('td', text: 'Bar Baz') expect(page).to have_css('td', text: 'bar@baz.com')\n\nend\n\nend\n\nend\n\nThis spec passes with no changes. We’re reusing the same form and parameters as we did for creating a new user, so we don’t need to make any changes to our Active Admin registration block. Normally, I would never trust a spec that I didn’t see fail at least once, but this spec is very simple, and it reuses the same patterns we’ve seen work in other specs, so I’m going to trust it.\n\nDeleting Users\n\nSince we can add and edit users, we should add a spec for deleting users too:\n\nit 'can be deleted' do\n\nvisit admin_users_path\n\naccept_confirm do\n\nclick_link 'Delete'\n\n185",
      "content_length": 1387,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 193,
      "content": "186\n\n13 Administration\n\nend\n\nwithin '.flashes' do\n\nexpect(page).to have_css('.flash_notice',\n\ntext: 'User was successfully destroyed.')\n\nend\n\nend\n\nThis spec also passes with no changes to our Active Admin registration block. Similar to before, this spec is again very simple, and it reuses the same patterns we’ve seen work in other specs, so I’m again going to trust it.\n\nRight now, our index and show pages are displaying all of our user attributes, including our password_salt and password_hash ﬁelds. Displaying these ﬁelds is not useful, so let’s remove them by overriding our index and show blocks with just the ﬁelds we do want to display:\n\nindex do\n\nselectable_column id_column column :name column :email actions\n\nend\n\nshow do\n\nattributes_table do\n\nrow :name row :email\n\nend\n\nend\n\nOur user ﬁlter block is also displaying all of our user attributes, so let’s remove the password_salt and password_hash ﬁelds from there too.\n\nremove_filter :password_salt, :password_hash\n\nSummary\n\nThis concludes our Active Admin chapter. I’ve shown enough of the basics to get you started with specs for your own Active Admin implementations. You probably want to add an Active Admin interface for managing page tags as well. I’m going to leave that as a TDD exercise for you to complete on your own.",
      "content_length": 1290,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 194,
      "content": "Odds and Ends\n\n14\n\nThis chapter will cover some additions and enhancements to our existing work:\n\n1. Build a sitemap 2. Add pagination for our blog entries 3. Add CSS styling 4. Add syntax highlighting for code blocks\n\nBuild a Sitemap\n\nA sitemap isn’t a hard requirement for a website, but it is a good idea to have one. A sitemap is a URL endpoint, usually living at /sitemap.xml, that is available through a GET request and that lists all of the other URL endpoints on the website. A sitemap helps search engines ﬁnd all of the pages in the website more easily compared to doing a full website crawl. For a large website, it can also help the search engine understand the hierarchical structure.\n\nLet’s add a sitemap to our blog application. To start with, we will add a request spec that will request the /sitemap.xml and verify that it is returning a valid XML response. Let’s add the following to our spec/requests/home_spec.rb ﬁle:\n\ndescribe 'GET /sitemap' do\n\nit 'returns http success' do\n\nget sitemap_path(format: :xml) expect(response).to be_successful\n\nend\n\nend\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_14\n\n187",
      "content_length": 1259,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 195,
      "content": "188\n\n14 Odds and Ends\n\nRunning this spec will result in a failure message because we don’t yet have a route for /sitemap.xml:\n\n1) Home Page GET /sitemap returns http success Failure/Error: get sitemap_path(format: :xml)\n\nNoMethodError:\n\nundefined method `sitemap_path'\n\nLet’s add a route for this URL in our config/routes.rb ﬁle:\n\nget 'sitemap', to: 'home#sitemap'\n\nRe-running our spec moves us to our next error message:\n\n1) Home Page GET /sitemap returns http success Failure/Error: get sitemap_path(format: :xml)\n\nAbstractController::ActionNotFound:\n\nThe action 'sitemap' could not be found for HomeController\n\nAs suggested by the error message, let’s add a sitemap action to our HomeController:\n\ndef sitemap end\n\nThis gets our new request spec to pass. Next, we should parse the XML response and verify that it contains our expected URLs. We can use Nokogiri to parse our XML response body and collect the URL paths into an array, then we can easily check the contents of the array for known URL paths.\n\nBefore we pursue this, we should consider the XML structure of our sitemap and what it should\n\nlook like. We can ﬁnd the standard XML structure for a sitemap published online at\n\nwww.sitemaps.org/protocol.html Notice the <url> and <loc> are required ﬁelds. There are other optional ﬁelds available, but we will stick with just the required ﬁelds for now. Our generated XML should look something like this:\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"> <url>\n\n<loc>http://www.example.com/</loc>\n\n</url> </urlset>",
      "content_length": 1574,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 196,
      "content": "Build a Sitemap\n\nLet’s update our spec to parse the XML response and verify that it contains our expected URL paths:\n\ndescribe 'GET /sitemap' do\n\nlet(:tag) { create(:tag) } let!(:page) do\n\ncreate(\n\n:page, :published, tags: [tag], created_at: '2023-02-19'\n\n) end\n\nit 'returns http success' do\n\nget sitemap_path(format: :xml) expect(response).to be_successful\n\ndoc = Nokogiri::XML(response.body) urls = doc.css('loc').collect(&:text) paths = urls.map{ |url| URI.parse(url).path }\n\nexpect(paths).to include(page_path(slug: page.slug))\n\nend\n\nend\n\nWe’re using the Nokogiri::XML method to parse the XML response body of our request into a Nokogiri document object. We then use the doc’s css method to ﬁnd all of the <loc> elements and collect the URL (via the text ﬁeld) of each <loc> element into an array. We then map over the array of URLs and extract the path portion of each URL using URI.parse. Finally, we can check that the array of paths includes the path for our page object we created using our let!.\n\nWhen we run this spec, we get the following error message:\n\nFailures:\n\n1) Home Page GET /sitemap returns http success\n\nFailure/Error: expect(paths).to include(page_path ...\n\nexpected [] to include \"/page/page-title-1\"\n\nIt looks like our paths array is empty, which makes sense because we have not yet implemented an ERB template for our HomeController sitemap action. Let’s add an ERB template named sitemap.xml.erb in our app/views/home directory and add the following code to it:\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"> <% Page.published.ordered.each do |p| -%> <url>\n\n<loc><%= \"http://127.0.0.1:3000/page/#{p.slug}\" %></loc>\n\n189",
      "content_length": 1700,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 197,
      "content": "190\n\n14 Odds and Ends\n\n</url> <% end -%> </urlset>\n\nThis will generate sitemap XML that contains a <url> element for each published page in our database. We can now run our spec and see that it passes.\n\nWe probably do not want to hard-code the domain name and port number in our sitemap XML template. We should instead make it read from an environment variable and have a default value for when the environment variable is not set. Let’s add this to our sitemap action in our HomeController:\n\ndef sitemap\n\n@url = ENV['BASE_URL'] || 'http://localhost:3000'\n\nend\n\nThen we can update our ERB template to use our new @url instance variable:\n\n<% Page.published.ordered.each do |p| -%> <url>\n\n<loc><%= \"#{@url}/page/#{p.slug}\" %></loc>\n\n</url> <% end -%>\n\nRe-running our spec, we can see that it still passes. We of course need to make sure to set our new environment variable in our production environment, so don’t forget!\n\nLet’s now add another expectation for our Tag URLs:\n\nexpect(paths).to include(tag_path(name: tag.name))\n\nThis fails as expected:\n\nFailures:\n\n1) Home Page GET /sitemap returns http success\n\nFailure/Error: expect(paths).to include(tag_path(name: tag.name))\n\nexpected [\"/page/page-title-1\"] to include \"/tag/name-1\"",
      "content_length": 1232,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 198,
      "content": "Build a Sitemap\n\nWe can ﬁx this error by adding a <url> element for each tag in our sitemap XML:\n\n<% Tag.all.each do |t| -%> <url>\n\n<loc><%= \"#{@url}/tag/#{t.name}\" %></loc>\n\n</url> <% end -%>\n\nThis gets our request spec back to passing.\n\nThe last thing we will add to our spec is an expectation for our sidebar archive links:\n\nexpect(paths).to include('/search/2023/02')\n\nThis fails as expected:\n\nFailures:\n\n1) Home Page GET /sitemap returns http success\n\nFailure/Error: expect(paths).to include('/search/2023/02')\n\nexpected [\"/page/page-title-1\", \"/tag/name-1\"] to include \"/search/2023/02\"\n\nWe can ﬁx this error by adding a <url> element for each archive link in our sitemap XML:\n\n<% Page.month_year_list.each do |i| %> <url>\n\n<loc>\n\n<%= \"#{@url}/search/#{i['year']}/#{i['month_number']}\" %>\n\n</loc>\n\n</url> <% end %>\n\nThis gets our request spec back to passing. We can now do a bit of cleanup by moving our local variables into let statements:\n\ndescribe 'GET /sitemap' do\n\nlet(:doc) { Nokogiri::XML(response.body) } let(:urls) { doc.css('loc').collect(&:text) } let(:paths) { urls.map{ |url| URI.parse(url).path } } let(:tag) { create(:tag) } let!(:page) do\n\ncreate(\n\n:page,\n\n191",
      "content_length": 1183,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 199,
      "content": "192\n\n14 Odds and Ends\n\n:published, tags: [tag], created_at: '2023-02-19'\n\n) end\n\nit 'returns http success' do\n\nget sitemap_path(format: :xml) expect(response).to be_successful\n\nexpect(paths).to include(page_path(slug: page.slug)) expect(paths).to include(tag_path(name: tag.name)) expect(paths).to include('/search/2023/02')\n\nend\n\nend\n\nWe should re-run our spec to make sure it still passes.\n\nPagination\n\nOnce we have more than a handful of pages, we will want to add pagination. Pagination will allow our homepage to load faster, and our back-end database will not have to load as many records all at once for a given request. This will also be true for our tag pages and our search results pages.\n\nInstead of inventing pagination from scratch, we will use the Kaminari gem. Kaminari is a pagination gem that is very easy to use and has a lot of options for customizing the look and feel of the pagination links.\n\nLet’s add the Kaminari gem to our Gemfile:\n\ngem 'kaminari', '~> 1.2.2'\n\nAnd then let’s run the bundle command to install it:\n\nbundle\n\nKaminari has a lot of options for customizing the look and feel of the pagination links. We can generate an initializer ﬁle for Kaminari, which contains all of the default options and values, by running the following command:\n\nbe rails g kaminari:config",
      "content_length": 1302,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 200,
      "content": "Pagination\n\nWe can then update the generated initializer ﬁle kaminari_config.rb values to our liking:\n\n# config/initializers/kaminari_config.rb\n\nKaminari.configure do |config|\n\n# config.default_per_page = 25 # config.max_per_page = nil # config.window = 4 # config.outer_window = 0 # config.left = 0 # config.right = 0 # config.page_method_name = :page # config.param_name = :page # config.max_pages = nil # config.params_on_first_page = false\n\nend\n\nThe defaults are ﬁne for our purposes, so we will leave them as is for now.\n\nNow that we have Kaminari installed, we can add pagination to our blog application. Thinking through it, we will want pagination on any page that displays a list of Page objects, so let’s start with our homepage. We ﬁrst need a spec to test the pagination functionality. Let’s add the following to our spec/system/home_spec.rb ﬁle:\n\ndescribe 'pagination' do\n\ncontext 'with many pages' do\n\nit 'paginates' do\n\ncreate_list(:page, 26, :published)\n\nvisit root_path\n\narticles = find_all('article') expect(articles.size).to eq(25) expect(page).to have_link('Next')\n\nend\n\nend\n\nend\n\nWe begin this spec by calling FactoryBot’s create_list method to create 26 published Page objects. This number of Page objects is just enough to trigger pagination to render since we have the Kaminari default_per_page set to 25 items per page. We then visit the homepage and expect to see exactly 25 Page objects (instead of 26). We then expect to ﬁnd a “Next” link on the page. This will prove our pagination is being rendered on the homepage as expected.\n\n193",
      "content_length": 1562,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 201,
      "content": "194\n\n14 Odds and Ends\n\nWhen we run our spec, we get the following error:\n\n1) Home pagination with many pages paginates Failure/Error: expect(articles.size).to eq(25)\n\nexpected: 25 got: 26\n\nTo ﬁx this error, we need to add a .page call to our ActiveRecord query in our HomeController index method where we assign our @pages object. Let’s update it to look like this:\n\ndef index\n\n@pages = Page.published.ordered.page(params[:page])\n\nend\n\nWhen we re-run our spec, we get a new error message:\n\n1) Home pagination with many pages paginates Failure/Error: expect(page).to have_link('Next')\n\nexpected to find link \"Next\" but there were no matches\n\nTo ﬁx this error, we need to add the pagination links to our homepage. You may recall that our Page objects are rendered in our shared partial template called _pages.html.erb residing in our app/views/shared directory.\n\nLet’s modify our partial to add a call to Kaminari’s paginate method at the bottom of the page\n\nto render our pagination links:\n\n<% pages.each do |page| %>\n\n<%= render partial: 'shared/page',\n\nlocals: {\n\npage: page, content: page.summary\n\n} %>\n\n<% end %>\n\n<%= paginate pages %>\n\nThis gets our spec passing, and this is good, but we can do better.\n\nDo we really need 26 Page objects to test our pagination? If we think about it, we really only need a few Page objects to test pagination. We need a couple of Page objects to render on our ﬁrst page to exercise our render loop and then one more Page object to trigger pagination to render. Let’s update our spec to only create three Page objects:",
      "content_length": 1555,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 202,
      "content": "Pagination\n\nit 'paginates' do\n\ncreate_list(:page, 3, :published)\n\nvisit root_path\n\narticles = find_all('article') expect(articles.size).to eq(2) expect(page).to have_link('Next')\n\nend\n\nThis fails with the following error:\n\n1) Home pagination with many pages paginates Failure/Error: expect(articles.size).to eq(2)\n\nexpected: 2 got: 3\n\nNow we need to adjust our Kaminari initializer conﬁguration to render only one Page object per page and only when we are running a spec. We can accomplish this by adding a conditional to our initializer ﬁle, to look at our Rails.env value and set our default_per_page to only 2 when we are in our test environment:\n\nconfig.default_per_page = Rails.env.test? ? 2 : 25\n\nThis gets our spec passing again. Our system spec for our tags also needs to be updated to use pagination. Let’s add a tag spec into our spec/system/tag_spec.rb ﬁle to test pagination:\n\ndescribe 'pagination' do\n\ncontext 'with many tagged pages' do\n\nit 'paginates' do\n\ntag = create(:tag) create_list(:page, 3, :published) Page.all.each { |page| page.tags << tag }\n\nvisit tag_path(name: tag.name)\n\narticles = find_all('article') expect(articles.size).to eq(2) expect(page).to have_link('Next')\n\nend\n\nend\n\nend\n\n195",
      "content_length": 1214,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 203,
      "content": "196\n\n14 Odds and Ends\n\nThis spec is very similar to the one we added to our homepage spec. We create a Tag object and then create three Page objects with our new tag assigned to each one. We then visit our tag show page and expect to see two Page objects and our “Next” link rendered.\n\nWhen we run our new spec, we get the error:\n\nFailure/Error: visit tag_path(name: tag.name)\n\nActionController::UrlGenerationError:\n\nNo route matches {:action=>\"show\", :controller=>\"tags\", ...\n\nThis error is telling us that we need to add a route. We need to add our Tag show action route. Let’s modify our config/routes.rb ﬁle to add this:\n\nget 'tag/:name', to: 'tags#show', name: /[-a-z0-9_+]*/, as: :tag\n\nThis update moves us to our next error. When we run our spec again, we get\n\n1) Tag displays clickable tags on a page Failure/Error: <%= paginate pages %>\n\nActionView::Template::Error:\n\nundefined method `total_pages'\n\nThis error message may seem a bit cryptic at ﬁrst, but we can assume the call to paginate is failing because we are not passing a Kaminari-like page object. We need to update our TagsController show method to call Kaminari’s page method when we are retrieving our Page objects. Let’s update our show method to look like this:\n\ndef show\n\ntag = Tag.find_by(name: params[:name]) redirect_to root_path and return unless tag\n\n@pages = tag.pages.published.ordered.page(params[:page])\n\nend\n\nThis gets our spec passing.\n\nThe last bit of pagination we need to add is with our search. Let’s add a spec to our\n\nspec/system/search_spec.rb ﬁle to test search results pagination:\n\ndescribe 'pagination' do\n\ncontext 'with many search result pages' do\n\nit 'paginates' do",
      "content_length": 1663,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 204,
      "content": "Pagination\n\ncreate_list(:page, 3, :published, content: 'foo bar baz')\n\nvisit search_path(term: 'foo')\n\narticles = find_all('article') expect(articles.size).to eq(2) expect(page).to have_link('Next')\n\nend\n\nend\n\nend\n\nThis spec fails in the same way as our tag spec:\n\n1) Search Searching with a search term renders search results Failure/Error: <%= paginate pages %>\n\nActionView::Template::Error:\n\nundefined method `total_pages'\n\nThe update for this failure is not going to be in the same location as with our previous controller updates. For searching, we use our PageSearch service class, so the ﬁx will be in there instead of in our SearchController ﬁle. Let’s update our PageSearch class to add our page call:\n\ndef self.search(params)\n\nreturn [] unless params.present?\n\npages = if params[:year].present? && params[:month].present?\n\nPage.by_year_month(params[:year], params[:month])\n\nelsif params[:term].present?\n\nPage.by_term(params[:term])\n\nend\n\nreturn [] unless pages\n\npages.published.ordered.page(params[:page])\n\nend\n\nThis gets our spec passing. The reason we can’t put the ﬁx in the controller is because we sometimes return an empty array from our search method. An empty array does not respond to the page method, so we need to put the ﬁx where we are returning actual ActiveRecord Page objects.\n\nWe could change our two early returns to use Page.none instead of returning an empty array, then we could put our page call in our controller. This is a matter of personal preference, so feel free to pursue that option if you like.\n\n197",
      "content_length": 1540,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 205,
      "content": "198\n\n14 Odds and Ends\n\nFixing Specs\n\nIf we run our entire test suite now:\n\nbe rspec\n\nwe will see that our spec ﬁle index.html.erb_spec.rb located in our spec/views/home directory is failing:\n\n1) home/index renders the page object Failure/Error: <%= paginate pages %>\n\nActionView::Template::Error:\n\nundefined method `total_pages'\n\nThis is similar to our other pagination-related spec failures. We need to update our failing view spec to assign a properly paginated Page object, instead of an array. This will give us access to the total_pages method our view is trying, and failing, to call.\n\nLet’s update our spec to look like this:\n\nrequire 'rails_helper'\n\nRSpec.describe 'home/index', type: :view do\n\nlet!(:page) { create(:page) }\n\nit 'renders the page object' do assign(:pages, Page.page(1)) render expect(rendered).to have_css('h2', text: page.title) expect(rendered).to have_css('p', text: page.created_at.to_fs) expect(rendered).to include(page.summary)\n\nend\n\nend\n\nThe main change here is that we are now assigning a paginated Page object to our view instead of an array, but we also have to change our let to a let! that uses a create so that it is created before we perform our pagination .page call.\n\nIf we run our spec now, we will see that it is passing.",
      "content_length": 1265,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 206,
      "content": "Styling\n\nStyling\n\nWithout a doubt, we’ve paid very little attention to styling our application up to now. We now have a fully functioning application, so we can work to improve its appearance. As before, we are going to continue to use the Bootstrap CSS framework we installed previously.\n\nCSS in Rails\n\nWhen we generated our application using the rails new command, we passed in the option --css=bootstrap to choose Bootstrap as our CSS framework. This option caused our main application.scss ﬁle to be generated with the name application.boostrap.scss . I ﬁnd having this longer ﬁlename serves no real purpose, and I prefer to rename it back to just the default application.scss ﬁlename. Let’s do that now:\n\nmv app/assets/stylesheets/application.bootstrap.scss \\\n\napp/assets/stylesheets/application.scss\n\nRenaming our application.scss ﬁle requires we also update the name in our package.json ﬁle. You might use a sed command to do this:\n\nsed -i '' 's/\\.bootstrap//g' package.json\n\nOr just open our package.json ﬁle and change it manually.\n\nStyling Our Public Pages\n\nFirst, let’s add styling to our _header.html.erb ﬁle, located in our app/views/shared directory. Let’s add additional padding on the top and left side of our <header> container, using ps-1 and pt-1 to bring it down and to the right a bit. Right now, our link in our <h1> tag is underlined, so let’s remove that by adding the text-decoration-none class.\n\nOur updated ﬁle will look like this:\n\n<header class=\"ps-1 pt-1\">\n\n<h1>\n\n<%= link_to 'My Blog', root_path,\n\nclass: 'text-decoration-none' %>\n\n</h1> </header>\n\nNow our header looks like Figure 14-1.\n\n199",
      "content_length": 1623,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 207,
      "content": "200\n\n14 Odds and Ends\n\nFigure 14-1 Header CSS\n\nFigure 14-2 Page summary CSS\n\nNext, let’s add CSS styling to our _page.html.erb partial, located in our app/views/ shared directory. Let’s give our <article> tag the card class, which will give it a rounded gray border as shown in Figure 14-2, and the p-3 and mb-3 classes to give it a bit of inner padding and bottom margin. Our updated ﬁle will look like this:\n\n<article class=\"card p-3 mb-3\">\n\n<h2><%= link_to page.title, page_path(slug: page.slug) %></h2> <p><%= page.created_at.to_fs %></p> <%= content.html_safe %> <p><%= tag_links(page.tags).html_safe %></p>\n\n</article>\n\nWhen we search our blog entries and get no results, we are rendering a “No results found” message in our index.html.erb ﬁle, found in our app/views/search directory. It’s currently a bit tight against the left side of our page. Let’s add the ps-2 class to give it more padding on the left side, as shown in Figure 14-3.",
      "content_length": 945,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 208,
      "content": "Styling\n\nFigure 14-3 No search results CSS\n\nFigure 14-4 Search form CSS\n\n<% if @pages&.any? %>\n\n<%= render partial: 'shared/pages', locals: { pages: @pages } %>\n\n<% else %>\n\n<p class=\"ps-2\">No results found</p>\n\n<% end %>\n\nNow let’s turn our attention to the sidebar section of our blog. First, let’s add CSS styling to our _search_form.html.erb ﬁle, located in our app/views/shared directory. Let’s join our search term text ﬁeld and our search button together by adding the input-group class to our <div> container they live in. We also need to add the form-control class to our search term text ﬁeld itself. And then let’s also add the btn and btn-primary classes to our search button as shown in Figure 14-4. Our updated ﬁle will look like this:\n\n<div>\n\n<%= form_for(:search, url: search_path, method: :get) do %>\n\n<div class=\"input-group\">\n\n<input type=\"search\" name=\"term\" class=\"form-control\" /> <input type=\"submit\" value=\"Search\" class=\"btn btn-primary\" />\n\n</div> <% end %>\n\n</div>\n\nJust below our search form, we have our Archives section which lives in our _archives.html. erb ﬁle in our app/views/shared directory. Like we did with our blog entries’ <article> tag, let’s add the card class to give it the same rounded gray border. Let’s also add the p-3 class to give it some inner padding and the mt-3 class to give it some top margin, to push it down a bit from our search form.\n\nOur archive list is currently decorated with the default list dots that are by default rendered with a <ul> tag. Let’s remove those dots by adding the list-unstyled class to our <ul> tag. Let’s also add the pt-1 class to our <li> tags to give them a bit of top padding, to push them down from each other, as shown in Figure 14-5.\n\n201",
      "content_length": 1729,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 209,
      "content": "202\n\n14 Odds and Ends\n\nFigure 14-5 Archive list CSS\n\nOur updated ﬁle will look like this:\n\n<div class=\"card p-3 mt-3\">\n\n<h4>Archives</h4> <ul class=\"list-unstyled\"> <% Page.month_year_list.each do |item| %>\n\n<li class=\"pt-1\">\n\n<%= link_to \"#{item['month_name'] } #{item['year']}\",\n\n\"/search/#{item['year']}/#{item['month_number']}\" %>\n\n</li> <% end %> </ul>\n\n</div>\n\nThe next bit of styling we will do is to our pagination links. Given the popularity of Bootstrap, and the fact that we’re not creating the very ﬁrst blog application that ever needed pagination styling, it’s no surprise that there is already a Ruby gem to address our exact problem. The gem is called bootstrap5-kaminari-views, and it provides Bootstrap 5 styling for the kaminari pagination gem we’re using.\n\nLet’s add the gem to our Gemfile:\n\ngem 'bootstrap5-kaminari-views', '~> 0.0.1'\n\nAnd then run bundle to install the gem.\n\nTo apply the styling, we need to modify our _pages.html.erb ﬁle located in our app/views/shared directory. We only need to pass the theme parameter with a value of ‘bootstrap-5’. Our updated paginate call will look like this:\n\n<%= paginate pages, theme: 'bootstrap-5' %>\n\nThis makes our pagination links, as shown in Figure 14-6, look similar to the other Bootstrap styles we are already using.",
      "content_length": 1292,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 210,
      "content": "Styling\n\nFigure 14-6 Pagination CSS\n\nStyling Our Admin\n\nThe last bit of styling we will do is to style our Admin login page.\n\nFirst, let’s update our admin.html.erb layout ﬁle that is located in our app/views/ layouts directory. Our <h1> tag is too tight against the top and left sides of the page. Let’s add some extra margin:\n\n<h1 class=\"ms-2 mt-1\">Admin</h1>\n\nThe “ms” means “margin start” or left margin. The “mt” means “margin top” or top margin. The numeric sufﬁx is the amount of margin with higher numbers being more margin than lower numbers. Next, let’s work on improving our login form. Let’s open and modify our new.html.erb template ﬁle located in our app/views/sessions directory. We need to again add some left margin to our form; currently, it’s too close to the left side of the page. Let’s wrap our form in a <div> container and add the ms-2 class to it:\n\n<div class=\"ms-2\"> ... </div>\n\nTo get our form ﬁelds looking a bit nicer, let’s add the form-control class to each of them:\n\n<%= f.email_field :email, class: 'form-control' %>\n\nTo add some space between our form ﬁelds, let’s add the mt-3 class to each of our <div> containers that wrap our form ﬁelds:\n\n<div class=\"mt-3\"> ... </div>\n\n203",
      "content_length": 1211,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 211,
      "content": "204\n\n14 Odds and Ends\n\nFigure 14-7 Admin login CSS\n\nNext, let’s improve our submit <button> by adding \"btn btn-primary\" classes to it:\n\n<button type=\"submit\" class=\"btn btn-primary\">Submit</button>\n\nOur form ﬁelds are looking better, but now they span the entire width of the page. Let’s add a class to our <div> container to pull them in to about a fourth of the page. Bootstrap is based on a 12-column grid system, so 3 columns is a fourth of the page. Let’s add the col-3 class to our <div> container:\n\n<div class=\"col-3 ms-2\">\n\n... </div>\n\nAfter our updates, our ﬁnal new.html.erb ﬁle looks like this, and our login form looks like Figure 14-7:\n\n<div class=\"col-3 ms-2\">\n\n<%= form_for(:login, url: login_path) do |f| %>\n\n<h2>Sign in</h2> <div class=\"mt-3\">\n\n<%= f.label :email %> <%= f.email_field :email, class: 'form-control' %>\n\n</div> <div class=\"mt-3\">\n\n<%= f.label :password %> <%= f.password_field :password, class: 'form-control' %>\n\n</div>",
      "content_length": 952,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 212,
      "content": "Code Highlighting\n\n<div class=\"mt-3\">\n\n<button type=\"submit\" class=\"btn btn-primary\">Submit</button>\n\n</div> <% end %>\n\n</div>\n\nWrapping Up\n\nThis wraps up styling our blog application. We’ve added standard Bootstrap 5 styling to our blog application, and admittedly we could add a lot more. Bootstrap has lots of styling options, and we’ve only barely scratched the surface.\n\nCode Highlighting\n\nTo close out this chapter, we’re going to add code highlighting to our blog application. I’m assuming that you are reading this book because you are or soon will be a software engineer and that you will want to write blog entries that include code that you want to make syntax highlighted. If that’s a wrong assumption, then you can skip this section.\n\nWe’re going rogue here and will not be using a Ruby gem to do this. Instead, we’re going to use a\n\nplain old JavaScript library called Prism:\n\nhttps://prismjs.com/\n\nPrism is a client-side syntax highlighting library that is very popular with software engineers and is used by many popular websites. It’s also very easy to use. We’re going to use the Prism library to highlight our <code> blocks in our blog entries.\n\nThe way it works is very simple. When we create a blog entry, and we include a <code> block in our HTML, we add a language-* CSS class to the <code> tag. For example, if we want to highlight a <code> block as Ruby code, we would add the language-ruby class to our <code> tag. After page load, Prism will look for classes it knows about and will highlight the <code> tag contents accordingly. Prism supports many different programming languages and has great support for Ruby.\n\nBefore we do anything else, let’s add a new system spec, so we’ll know when we have it working.\n\nIn our spec/system directory, let’s modify our existing page_spec.rb ﬁle to add this:\n\ndescribe 'syntax highlighting' do\n\nbefore do\n\ncontent = <<~RUBY.squish\n\n<pre>\n\n<code class=\"language-ruby\">\n\nputs 'hello world!'\n\n</code>\n\n</pre>\n\nRUBY\n\nmy_page.update(content:)\n\nend\n\n205",
      "content_length": 2013,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 213,
      "content": "206\n\n14 Odds and Ends\n\nit 'renders code blocks' do\n\nvisit page_path(slug: my_page.slug)\n\nwithin 'pre' do\n\nexpect(page).to have_text('puts')\n\nwithin 'code.language-ruby span.token.string' do\n\nexpect(page).to have_text('hello world!')\n\nend\n\nend\n\nend\n\nend\n\nWe’re updating our existing my_page variable from the let at the top of the spec ﬁle to have a <code> block in its content ﬁeld. Our <code> block contains a single line of Ruby code that outputs hello world!. We’re then visiting our page and checking to see if our <code> tag is present and has the language-ruby class assigned. This is expected, even without Prism, but then we’re checking to see if there is a <span> tag with CSS classes token and string that contains our string ‘hello world!’. We didn’t add anything to do with <span> tags in our <code> block; that’s what Prism does for us. So when we run our spec, and it begins to pass, we’ll know our Prism setup is working.\n\nRunning our spec, we see that it fails, as expected. We need to install Prism into our application\n\nand conﬁgure it.\n\nThe ﬁrst step is to visit the Prism website and download the JavaScript and CSS ﬁles. On this page,\n\nwe can pick which languages we want to support and then download the ﬁles:\n\nhttps://prismjs.com/download.html\n\nMake sure and choose Ruby as one of the languages to support, then scroll to the bottom of the page and click each of the two Download buttons to download the JavaScript and CSS ﬁles. Move the prism.css CSS ﬁle into our app/assets/stylesheets directory and move the prism.js JavaScript ﬁle into our app/javascript directory.\n\nNext, we need to load the prism.js JavaScript ﬁle into our application. Let’s add this to the\n\nbottom of our app/javascript/application.js ﬁle:\n\nimport './prism'\n\nOur prism.js ﬁle is a plain old JavaScript ﬁle living in the same directory as our application.js ﬁle, so we can just import it into our application using a local path of \"./\". Notice how the ﬁle extension is not included in the import statement; it’s optional and assumed to be .js.\n\nStimulus and Turbo\n\nIn our modern Rails application, we are by default using Stimulus and Turbo, mostly because we didn’t say we didn’t want to use them via the -skip-hotwire option when we created our application using the rails new command previously. But why am I writing about them?",
      "content_length": 2328,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 214,
      "content": "Code Highlighting\n\nGone are the days of simply adding a <script> tag to our HTML to load a plain old JavaScript ﬁle. The modern way, especially inside a Rails application, is to use Stimulus to create a “controller” that is loaded into our HTML using “data” tags. Stimulus then connects and runs our JavaScript code only when and where we need it to. It’s pretty fancy, especially if you’re old enough to have ever supported IE6. But I digress.\n\nTo execute our Prism code, we need to add a Stimulus controller to our application. Let’s create a new ﬁle in our app/javascript/controllers directory called prism_controller.js with this content:\n\nimport { Controller } from \"@hotwired/stimulus\"\n\nexport default class extends Controller {\n\nconnect() {\n\ndocument.addEventListener('turbo:load', function() {\n\nPrism.highlightAll();\n\n});\n\n}\n\n}\n\nThe point of this code is so that we call our Prism.highlightAll() method when the Turbo library has ﬁnished loading our page. Rails is using Turbo to load our pages, and it has a turbo:load event that we can listen for. When that event is ﬁred, we know our page has ﬁnished loading, and we can then safely call our Prism.highlightAll() function.\n\nBut notice how this code is not stand-alone, it’s wrapped inside a Stimulus controller connect\n\nmethod that is called when our Stimulus controller successfully connects to our HTML.\n\nThe next step is to add our new Stimulus controller to our list of all our Stimulus controllers. In our app/javascript/controllers directory, we need to modify our index.js ﬁle to add these two lines at the bottom:\n\nimport PrismController from \"./prism_controller\" application.register(\"prism\", PrismController)\n\nThis is very similar to adding a <script> tag to an HTML ﬁle, but instead of loading a JavaScript ﬁle, we’re loading a Stimulus controller. The ﬁrst line imports our prism_controller.js ﬁle, and the second line registers our controller with Stimulus and gives it the name prism.\n\nThe magic that connects our new Stimulus controller to our HTML is simply the proper naming of our Stimulus controller ﬁle and the presence of a data-controller attribute located somewhere in our HTML. We named our controller ﬁle prism_controller.js, and the part before the _controller.js is important for the next step.\n\nNext, we need to decide where in our HTML we want to connect our Stimulus controller. We could load it at the top of every page, but that’s a heavy-handed approach. We only want to load it on pages that have code blocks that need to be syntax highlighted, and we only want to execute it on\n\n207",
      "content_length": 2578,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 215,
      "content": "208\n\n14 Odds and Ends\n\nblocks of HTML that need to be highlighted. So let’s add our data-controller attribute to our _page.html.erb ﬁle, in our <article> tag:\n\n<article class=\"card p-3 mb-3\" data-controller=\"prism\">\n\n<h2><%= link_to page.title, page_path(slug: page.slug) %></h2> <p><%= page.created_at.to_fs %></p> <%= content.html_safe %> <p><%= tag_links(page.tags).html_safe %></p>\n\n</article>\n\nWith this modiﬁcation, we’re telling Stimulus to load our prism controller after our <article> tag is loaded. We’re also telling Stimulus to connect our Prism controller to this particular block of HTML and then, if that is successful, to execute our connect method.\n\nNow when we re-run our spec, it should pass. We’ve added the necessary JavaScript code in all the correct places, and we’ve added the required HTML data attribute to connect our Stimulus controller to our HTML. The last thing to do is to add our Prism CSS into our application. We already have our prism.css CSS ﬁle in place, we just need to load it. Let’s add this to the bottom of our application.scss ﬁle:\n\n@import './prism';\n\nThis is similar to adding a <link> tag into our HTML to load a CSS ﬁle. With this modiﬁcation, we now get colors and other styling, as shown in Figure 14-8, for our code blocks.\n\nFigure 14-8 Prism syntax highlighting",
      "content_length": 1313,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 216,
      "content": "Summary\n\nSummary\n\nIn this chapter, we wrapped up several odds and ends including building a sitemap, adding pagination for our page entries, and adding CSS styling and code syntax highlighting. We also learned a little about Stimulus and Turbo and how to integrate plain old JavaScript into our modern Rails application.\n\n209",
      "content_length": 325,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 217,
      "content": "Bonus: Deploy to Production\n\n15\n\nIn this “bonus” chapter, we will deploy our Rails blog application into production. You do not need to read this chapter to complete the book. This chapter is extra, for those who are interested in learning how to deploy a Rails application into production.\n\nWe will install and conﬁgure Capistrano,1 a remote server automation and deployment tool, and then command it to perform a repeatable production deployment. On our production server, we will run Debian Linux. We will install and conﬁgure Ruby and Phusion Passenger2 to work with an Apache web server. We will conﬁgure Apache to serve our Rails blog application using a VirtualHost conﬁguration. We will store our code on GitHub and move things across the Internet securely using SSH.\n\nWhy This Non-cloud Approach?\n\nThere is presently a push in “the industry” to move away from the cloud-hosting approach and return to deploying to bare metal. The cloud is expensive, and there is needless additional complexity in managing a cloud environment.\n\nThe cloud is great for scaling up and down, but if you don’t need to scale up and down, then you\n\nprobably don’t need the cloud.\n\nYou can discover more information about exiting the cloud here:\n\nhttps://duckduckgo.com/?q=dhh+exiting+the+cloud\n\nAcquiring a Production Linux Server\n\nIn our current age of modern computing, it is very simple and easy to acquire a production Linux server. We can rent a dedicated server from a hosting provider such as Rackspace, DreamHost, or Namecheap. The options are endless.\n\nHowever you choose to acquire a production Linux server, you will need to have root access to it. This means you will need to be able to log in to the server as the root user, or become the root user using su or sudo, after logging in with your regular unprivileged user account.\n\n1https://capistranorb.com/ 2www.phusionpassenger.com/\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3_15\n\n211",
      "content_length": 2070,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 218,
      "content": "212\n\n15 Bonus: Deploy to Production\n\nFor the purposes of this book, I will assume that you have acquired a Linux server and that you have root access. I will also assume that you have a domain name that you can use to access your production server. You don’t have to have a domain name, but it’s a little easier to remember a domain name compared to an IP address.\n\nMy production server that I will reference while writing this chapter is an EC2 instance running on Amazon Web Services. I’ve acquired a t2.micro instance running Debian Linux version 11. I’m using AWS so I can minimize cost. I will delete my server instance after I’ve written this chapter.\n\nI’ve acquired a domain name from Namecheap, tdd-book.com, and I’ve conﬁgured it to point to my production server’s IP address. None of this will be working anymore by the time you read this book, just so you know.\n\nGetting Production Ready\n\nBefore we can deploy our Rails blog application to production, we need to install and conﬁgure things on our production server. Our Debian operating system will need to be conﬁgured to run Ruby and Phusion Passenger.\n\nInstalling Dependencies\n\nLet’s install all of our dependencies on our Debian server. We will need to become the root user for all of this to work:\n\nsudo su -\n\nThen let’s install the following packages using the apt command:\n\napt update\n\napt install -y apache2 \\\n\napache2-dev \\ build-essential \\ git \\ libcurl4-openssl-dev \\ libffi-dev \\ libpq-dev \\ libssl-dev \\ libreadline-dev \\ libyaml-dev \\ postgresql \\ wget \\ zlib1g-dev\n\nThese are all packages we will get from our Debian operating system repositories. They are not known for being the latest and greatest version; they are instead known for being stable and reliable. We will",
      "content_length": 1749,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 219,
      "content": "Getting Production Ready\n\nventure out into more cutting-edge versions of things with our latest version of Ruby and Phusion Passenger however.\n\nInstalling Ruby\n\nContinuing as the root user, let’s change into our /usr/src directory and download the latest 3.2.2 version of Ruby:\n\ncd /usr/src\n\nwget https://cache.ruby-lang.org/pub/ruby/3.2/ruby-3.2.2.tar.gz\n\nNext let’s extract the archive we downloaded using the tar command:\n\ntar xvf ruby-3.2.2.tar.gz\n\nNow let’s conﬁgure, build, and install our new Ruby:\n\ncd ruby-3.2.2\n\n./configure\n\nmake\n\nmake install\n\nAfter Ruby is installed, let’s use our new gem command to install the bundler and rack gems:\n\ngem install bundler rack\n\nInstalling Phusion Passenger\n\nNext, let’s download the latest 6.0.17 version of Phusion Passenger:\n\ncd /usr/src\n\nwget \\ https://github.com/phusion/passenger/releases/\\ download/release-6.0.17/passenger-6.0.17.tar.gz\n\n213",
      "content_length": 895,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 220,
      "content": "214\n\n15 Bonus: Deploy to Production\n\nBe careful with the preceding wget command and URL. It’s a long URL and is wrapped for use in a shell environment using backslashes. If you copy and paste it into your terminal and it does not work, then you may need to remove the backslashes and paste it in as one long line. If you still have problem, you can instead download the archive ﬁle manually from the Phusion Passenger GitHub page:\n\nhttps://github.com/phusion/passenger/releases\n\nAssuming you downloaded the ﬁle without any issues, let’s now extract it using the tar command:\n\ntar xvf passenger-6.0.17.tar.gz\n\nNow that we’ve untarred our Phusion Passenger download, let’s install it:\n\ncd passenger-6.0.17\n\nbin/passenger-install-apache2-module\n\nYou will be prompted to answer a question about language support:\n\nWhich languages are you interested in?\n\nMake sure to select Ruby using your space bar, and then press Enter. Passenger takes a while to build and install. At the end it will prompt us to add a few lines to our Apache conﬁguration ﬁle. Let’s change into our Apache module directory and create a new ﬁle called passenger.load and put the following contents in it:\n\ncd /etc/apache2/mods-available\n\n# Create a new file called passenger.load with the contents: LoadModule \\\n\npassenger_module \\ /usr/src/passenger-6.0.17/buildout/apache2/mod_passenger.so\n\n<IfModule mod_passenger.c>\n\nPassengerRoot /usr/src/passenger-6.0.17 PassengerDefaultRuby /usr/local/bin/ruby\n\n</IfModule>\n\nThen enable our new passenger.load ﬁle using the a2enmod command:\n\na2enmod passenger",
      "content_length": 1567,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 221,
      "content": "Getting Production Ready\n\nNext, we need to disable the Apache mpm_event module using the a2dismod command; we’re not going to be using it and it’s on by default:\n\na2dismod mpm_event\n\nWe’re going to use the Apache mpm_prefork module instead. We need to enable it and some other Apache modules that we will also need for our Rails application:\n\na2enmod auth_digest \\\n\nheaders \\ mpm_prefork \\ proxy \\ proxy_http \\ rewrite \\ socache_shmcb \\ ssl\n\nNow we can restart our Apache web server and see that we have no errors from our Phusion Passenger install and our module updates:\n\nservice apache2 restart\n\nFinally, let’s modify our PATH to include the Passenger bin directory. Let’s add the following line\n\nto the end of our /etc/bash.bashrc ﬁle:\n\nexport PATH=\"/usr/src/passenger-6.0.17/bin:$PATH\"\n\nConﬁguring PostgreSQL\n\nWe installed PostgreSQL earlier, but we still need to conﬁgure it. Let’s change into our /etc/postgresql/13/main directory and make some additions to our postgresql.conf ﬁle:\n\nclient_min_messages = warning\n\nThis lets PostgreSQL listen on all network interfaces, and it also sets the minimum level of messages that PostgreSQL will log. We want logging but we don’t want to log everything, just warnings and errors. The log levels below “warning” are very noisy and not very useful.\n\n215",
      "content_length": 1300,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 222,
      "content": "216\n\n15 Bonus: Deploy to Production\n\nNext, let’s modify our pg_hba.conf ﬁle to allow us to connect to PostgreSQL locally. We’ll\n\nadd the following lines near the end of the ﬁle:\n\n# TYPE DATABASE USER ADDRESS METHOD all local\n\nall\n\ntrust\n\nThis lets us connect to PostgreSQL locally without a password. If you’re running a shared server with multiple applications using the same PostgreSQL database instance, then you should instead use the md5 option and set passwords for all your PostgreSQL users.\n\nNow we can restart our PostgreSQL service and see that we have no errors:\n\nservice postgresql restart\n\nAgain, as the root user, let’s now switch users and create a new PostgreSQL user named admin\n\nand give them ownership of a new database:\n\nsu - postgres\n\ncreateuser admin\n\ncreatedb blog -O admin\n\nNow that we have a PostgreSQL admin user and a blog database, let’s try them out using the psql command:\n\npsql -U admin -d blog\n\nWe should be able to successfully connect to our new blog database as our new admin user and see that we currently have no tables:\n\nblog=> \\dt Did not find any relations.",
      "content_length": 1097,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 223,
      "content": "Installing Capistrano\n\nPostgreSQL is now conﬁgured. Our Rails app will be able to connect to our blog database using our admin user when we deploy it shortly.\n\nStoring Code on GitHub\n\nYou can store your code anywhere you like, but for this chapter, I will assume that you have a GitHub account and that you have stored your code from this book on GitHub. Hopefully, you’ve been following along and have already done this. If not, read on.\n\nIf you don’t have a GitHub account, you can create one for free at\n\nhttps://github.com\n\nJust to be clear, there is no particular reason why I’m using GitHub. It’s just a popular place to store code, it’s free, and I’m making the assumption that most of my readers will use it or will at least be familiar with it.\n\nIf you’re using something else, then it will probably just be a matter of different URLs when we\n\nconﬁgure our deployment.\n\nInstalling Capistrano\n\nCapistrano is a Ruby gem, so we can add it to our Rails blog application by modifying our Gemfile to add the following in our development group:\n\ngem \"capistrano-rails\", \"~> 1.6\" gem \"capistrano-passenger\", \"~> 0.2.1\"\n\nThese are the latest versions of those gems at the time of writing. You can probably use newer versions without any signiﬁcant changes. We’re using the capistrano-rails gem which will install the capistrano gem for us as a dependency. We’re also using the capistrano-passenger gem which will provide us with some Capistrano Rake tasks to help us more easily work with Phusion Passenger and Apache.\n\nNow let’s install these gems into our application by running the bundle command.\n\nConﬁguring Capistrano\n\nNow that we have our Capistrano gems installed, we need to integrate them into our Rails application. We can do this by running the cap install command:\n\nbe cap install\n\n217",
      "content_length": 1798,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 224,
      "content": "218\n\n15 Bonus: Deploy to Production\n\nThis command will add several new ﬁles to our Rails application:\n\nCapfile config/deploy.rb config/deploy/production.rb config/deploy/staging.rb\n\nWe can delete or ignore the staging.rb ﬁle; we’re not going to be using it. We will make modiﬁcations to the other three ﬁles. Let’s ﬁrst modify our Capfile ﬁle and uncomment the functionality we want to use:\n\nrequire \"capistrano/bundler\" require \"capistrano/rails/assets\" require \"capistrano/rails/migrations\" require \"capistrano/passenger\"\n\nWe need bundler support to install our application’s Ruby gems on our server. We need Rails asset support to compile our assets. We need Rails migration support to run our database migrations, and we need Passenger support to restart our application after we deploy it.\n\nNext, we need to conﬁgure our config/deploy.rb ﬁle. We’ll start by adding the following\n\nlines to the top of the ﬁle:\n\nset :application, 'blog' set :repo_url, 'git@github.com:gdonald/blog.git' set :branch, 'main'\n\nappend :linked_files, 'config/database.yml',\n\n'config/secrets.yml', 'config/storage.yml'\n\nappend :linked_dirs, 'storage',\n\n'log', 'tmp/pids', 'tmp/cache', 'tmp/sockets', 'public/system'\n\nset :passenger_restart_with_touch, true\n\nThere are a number of variables being conﬁgured, so let’s run through them. First, we set our application variable to the name of our application. It’s normally used in the name of our application’s directory on our server. Next, we deﬁne our repo_url variable to the URL of our GitHub repository, and we set our branch variable to the name of the branch we want to deploy. We’re using the main branch, but you can use whatever branch you like.",
      "content_length": 1682,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 225,
      "content": "Deploying Our Rails Application\n\nThe next two variables, linked_files and linked_dirs, are ﬁles and directories that are shared between each deployment we perform. They exist only once on our server and get relinked on each deployment.\n\nThe last conﬁguration ﬁle we will update is named for the environment we will deploy to, our config/deploy/production.rb ﬁle. We need to add the following lines to the top of the ﬁle:\n\nserver 'tdd-book.com', user: 'admin', roles: %w[app db web] set :deploy_to, '/rails/blog' set :rails_env, 'production'\n\nset :pty, true set :ssh_options, {\n\nforward_agent: true, auth_methods: ['publickey'], keys: ['~/aws.pem']\n\n}\n\nFirst is our server variable which deﬁnes the server we will deploy to. This is a fully qualiﬁed domain name, and the username is the user we will use to connect to the server. We’re using our default Debian admin user, but you should use the username of your user. The roles are default for our Rails application because our application code and database are both on the same server.\n\nNext, we set our deploy_to variable to the directory where we will deploy. This is a full path on our production server for which our user owns and has write access. Your deploy_to can be different, of course.\n\nNext, we set our rails_env variable to the environment we will deploy to. For our production\n\nRails application, this will be production.\n\nThe next two variables are used to conﬁgure our SSH connection to our server. We’re using Capistrano to issue commands over a pseudo terminal, so we need to set our pty variable to true. After that, we set our ssh_options variable to a hash of options. Inside there, we’re telling Capistrano to use the forward_agent option to simplify deploying to our remote server. This will allow a remote SSH agent to securely use our local SSH keys.\n\nLast, we’re telling Capistrano with our auth_methods option to use publickey authentica- tion, and then we deﬁne the local path to our public key ﬁle. This key was automatically added to the authorized_keys ﬁle in our . ∼/.ssh directory when creating the EC2 instance on AWS.\n\nDeploying Our Rails Application\n\nOn our production server, we need to create the directory we deﬁned in our deploy_to variable. We can create this directory and change its ownership with the following commands:\n\nmkdir -p /rails/blog\n\nchown -R admin:admin /rails\n\n219",
      "content_length": 2371,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 226,
      "content": "220\n\n15 Bonus: Deploy to Production\n\nNow we can begin to debug our deploy. There are several more steps to perform, but I want to work through each one of them as if we were doing test-driven development. Seeing these errors and ﬁxing them will help us understand what is happening and why.\n\nThe command we need to run is\n\ncap production deploy\n\nThe ﬁrst error we get is\n\n01 git@github.com: Permission denied (publickey). 01 01 fatal: Could not read from remote repository. 01 01 Please make sure you have the correct access rights 01 and the repository exists.\n\nWe’re getting this error because we have not yet put a copy of our public key from our production server into our GitHub account. We can do this by navigating to our GitHub account’s Settings page and then clicking SSH and GPG keys. We can then click the New SSH key button and paste in the contents of our . ∼/.ssh/id_rsa.pub ﬁle. We can then click the Add SSH key button.\n\nIf you ﬁnd you don’t have a . ∼/.ssh/id_rsa.pub ﬁle, you can create one with the following\n\ncommand:\n\nssh-keygen -t rsa\n\nThis will generate a new key pair and will place the public key contents you need for GitHub in the . ∼/.ssh/id_rsa.pub ﬁle.\n\nNow we can try to deploy again:\n\ncap production deploy\n\nThe next error we get is\n\n00:01 deploy:check:linked_files ERROR linked file /rails/blog/shared/config/database.yml does not exist on tdd-book.com",
      "content_length": 1386,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 227,
      "content": "Deploying Our Rails Application\n\nThis error is telling us that we need to create our Rails database.yml ﬁle on our production server in our /rails/blog/shared/conﬁg directory. The contents of this ﬁle should match our PostgreSQL user and database names we created earlier. The content of the ﬁle should look similar to this:\n\ndefault: &default\n\nadapter: postgresql encoding: unicode pool: <%= ENV.fetch(\"RAILS_MAX_THREADS\") { 5 } %> port: <%= ENV['DB_PORT'] || 5432 %>\n\nproduction:\n\n<<: *default database: blog username: admin\n\nRe-running our deploy command gives us our next error message:\n\n00:01 deploy:check:linked_files ERROR linked file /rails/blog/shared/config/secrets.yml does not exist on tdd-book.com\n\nRails needs to keep secrets, so it uses a secrets.yml ﬁle to store a secret key base value that is used to encrypt cookies and other sensitive information. We need to provide this ﬁle like we did with our database.yml ﬁle. The contents of our secrets.yml ﬁle should look similar to this:\n\nproduction:\n\nsecret_key_base: \"make_this_a_long_string_of_random_characters\"\n\nMake sure and replace the value of secret_key_base with a long string of random characters. You can generate a random string of characters with the following command:\n\nrake secret\n\nRe-running our deploy command gives us our next error message:\n\n00:01 deploy:check:linked_files ERROR linked file /rails/blog/shared/config/storage.yml does not exist on tdd-book.com\n\n221",
      "content_length": 1447,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 228,
      "content": "222\n\n15 Bonus: Deploy to Production\n\nOur Rails application uses Active Storage to manage our uploaded images. We need to provide a storage.yml ﬁle to conﬁgure Active Storage for production. The contents of our storage.yml ﬁle should look similar to this:\n\nlocal:\n\nservice: Disk root: <%= Rails.root.join(\"storage\") %>\n\nThis tells Active Storage to store our uploaded image ﬁles in the relative path of storage inside our /rails/blog/shared directory, which in effect means a full path of /rails/blog/shared/ storage. Considering that you need to keep this directory backed up, you may not like this, so feel free to change it to a more convenient path for your particular backup strategy.\n\nRe-running our deploy command gives us our next error message:\n\nbundle stdout: Your bundle only supports platforms [\"arm64-darwin-22\"] but your local platform is x86_64-linux. Add the current platform to the lockfile with `bundle lock --add-platform x86_64-linux` and try again.\n\nI wrote this book and all the Ruby and Rails code on an arm64 Macbook Pro, but we’re trying to deploy to an x86_64 Linux server. Bundler is understandably complaining that we have a platform mismatch in our Gemﬁle.lock ﬁle. We need to add our production platform to our Gemﬁle.lock ﬁle. We can do this by running the command the error message suggests:\n\nbundle lock --add-platform x86_64-linux\n\nAfter we run this command, we need to commit the changes and push them up to GitHub, or wherever you’re storing your code. We can then re-run our deploy command to get our next error message:\n\nExecJS::RuntimeUnavailable: Could not find a JavaScript runtime. See \\url{https://github.com/rails/execjs} for a list of available runtimes.\n\nThis error is telling us that we need to install a JavaScript runtime. We need a JavaScript runtime for the Rails asset pipeline to compile our CSS and JavaScript assets. We can remedy this error by installing Node.js.",
      "content_length": 1918,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 229,
      "content": "Conﬁguring Our Apache Virtual Host\n\nThe version of Node.js available to use from the Debian repositories is too old and does not work with Rails Turbo, so we need to install a newer version from an alternate source. We can install it from nodesource.com.3 To do this, we need to run the following commands:\n\ncurl -fsSL https://deb.nodesource.com/setup_18.x | bash - &&\\ apt-get install -y nodejs\n\nThis will get us the latest stable version of Node.js. We can then re-run our deploy command to get our next error message:\n\nrake stdout: sh: 1: yarn: not found\n\nThis error message is telling us that we need to install the yarn package, a different package manager that we need to assist with compiling our Rails assets. We can do this by running the following commands:\n\nnpm install yarn -g\n\nThis command uses npm, the node package manager, to install the latest version of yarn. The -g option tells npm to install the yarn package globally, so it will be available to all users on our production system, not just the root user performing the install. We can then re-run our deploy command again, and this time we should get a successful deploy with no error messages.\n\nWhen we now visit our domain name on our production server (mine is at http://tdd-book.com), we do not yet see our Rails app running. We instead see the default Apache web server page. This is because we need to conﬁgure our Apache web server’s virtual host conﬁguration, to serve our Rails app using Phusion Passenger.\n\nConﬁguring Our Apache Virtual Host\n\nWe currently have the default Apache web server conﬁguration serving up content from the /var/www/html directory under a single virtual host entry. The conﬁguration ﬁle representing the virtual host is located in the /etc/apache2/sites-available directory and is named 000-default.conf. We need to modify it to serve up content from our /rails/blog/current/public directory instead.\n\nLet’s update the ﬁle to look like this:\n\n<VirtualHost *:80>\n\nServerAdmin admin@tdd-book.com SetEnv RAILS_ENV production\n\n3https://github.com/nodesource/distributions\n\n223",
      "content_length": 2079,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 230,
      "content": "224\n\n15 Bonus: Deploy to Production\n\nServerName tdd-book.com ServerAlias www.tdd-book.com DocumentRoot /rails/blog/current/public <Directory /rails/blog/current/public>\n\nRequire all granted Options -MultiViews\n\n</Directory> ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/tdd-book.com.log combined\n\n</VirtualHost>\n\nBe sure to update the Server* values to match your own domain name and email address.\n\nNotice that we’ve added the SetEnv RAILS_ENV line to tell our Rails app that we’re running in a production environment. This is important, because it will tell our Rails app to use our production database conﬁguration in our database.yml ﬁle, and not look for the default development database conﬁguration.\n\nThere’s also some magic here. Phusion Passenger knows our virtual host is now conﬁgured as a Rails app. When we make some future updates and redeploy our Rails app, Capybara can automatically let Passenger know it needs to hot-reload the new version of our code. We will have zero downtime on redeploys.\n\nUsing Passenger as an Apache web server module, we automatically get all the decades of effort that have gone into making Apache a stable, secure, and performant web server. We also get the ability to automatically serve up static assets from our public directory, which is a “really nice to have” feature in not having to conﬁgure another web server on another port or adding additional conﬁguration to our virtual host entry just to match incoming requests for them.\n\nAfter we make these virtual host changes, we need to restart our Apache web server:\n\nservice apache2 restart\n\nLogging In\n\nWe can now visit our domain name in our web browser and see our Rails app running, but we cannot yet log in to our admin to add any new page content. We do not currently have a user account in our production database. Let’s add one using our Rails console:\n\nRAILS_ENV=production bundle exec rails c",
      "content_length": 1922,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 231,
      "content": "Summary\n\nThis will open a Rails console into our production environment connected to our production database. We can now create a new user account using our user Factory:\n\nFactoryBot.create(:user,\n\nname: 'Greg Donald', email: 'gdonald@gmail.com', password: 'changeme', password_confirmation: 'changeme')\n\nNow we can log in to our admin using the email address and password we just created. We can then add some content to our blog.\n\nSummary\n\nIn this chapter, we learned how to deploy our Rails app to a production server. We set up a Debian Linux server from scratch, installed all the necessary packages and dependencies, and conﬁgured our Apache web server to run Phusion Passenger to serve our Rails app. We also learned how to use Capybara to automatically deploy our Rails app to our production server.\n\n225",
      "content_length": 812,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 232,
      "content": "Index\n\nA accept_confirm method, 180 Active Admin\n\nadding gem, 149–150 description, 149 testing, 150\n\nActive Admin ﬁlter customizations, 182 ActiveAdmin.register method, 159 Active Admin remove_filter syntax, 181 ActiveRecord object, 47 ActiveRecord’s order method, 62 Active storage, images\n\nadd image model, 125 config/storage.yml ﬁle, 124 has_one_attached, 127 Rails application, 123, 124 storage.yml, 124\n\nAuthentication enhancement\n\n.authenticate method, 141, 143. BCrypt::Engine.generate_salt:, 143 BCrypt gem, 142, 144 before_save callback, 141 downcase, 141 error, 139 failures, 141 foo@bar.com, 140 password hash, 143 password= method, 143 titleize, 141 User.password_hash, 139 User.password_salt, 139 user record, 140\n\nacts-as-taggable-on, 105 Adding page tags\n\ncreating page Tag model, 107–109 creating Tag model, 105–107 jump over relationships, 109–111\n\nadd method, 31 Admin ﬁlters, 181–182 admin/pages.rb ﬁle, 166 After save callbacks\n\nattr_accessor, 112 before block, 113 has_many :tags association, 113 Page object, 112 page_spec.rb ﬁle, 111 PageTag record, 113 self.tags . = [], 114 tags_string attribute, 111, 112 update_tags method, 113 Amazon Web Services (AWS), 212 Apache Virtual Host conﬁguration, 223–224 Apache web server, 211 app/controllers directory, 118, 153 apt command, 212 Archive integration test, 101–103 Archive list view, 98–101 authenticate_admin_user!, 152\n\nB BCrypt::Engine.generate_salt, 136 BCrypt::Engine.hash_secret, 136 before_save callback, 136 before_validation callback, 47 Behavior-driven development (BDD)\n\nframework, 27 binding.irb, 31, 32 Blog, 1, 2, 21 Blog database diagram, 2 blog_development database, 34 Bootstrap, 20\n\ncontainer-fluid style, 76 CSS framework, 74, 199, 202\n\nbootstrap5-kaminari-views, 202 Broken Window Theory, 11 Bundler, 17 Bundler’s bundle exec command, 21\n\nC Callback, 47 Capistrano, 217–219 Capybara, 52, 58\n\nattach_file helper method, 173 find_all method, 59\n\n© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024 G. Donald, Hands-on Test-Driven Development, https://doi.org/10.1007/978-1-4842-9748-3\n\n227",
      "content_length": 2120,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 233,
      "content": "228\n\nhas_text matcher, 169 has_xpath matcher, 169 visit method, 64 within method, 59\n\nclean method, 121 Code highlighting, 205–208 Code spikes, 8 Command-line interface1 (CLI), 13 config/environments directory, 124 content variable , 71 CSS\n\narchive list, 201–202 framework, 74 header, 199–200 and JavaScript ﬁles, 206 no search results, 200–201 page summary, 200 pagination, 202–203 in rails, 199 search form, 201\n\ncurrent_user_method, 157\n\nD Debian Linux, 211 Debian operating system\n\ninstalling dependencies, 212–213 installing Phusion Passenger, 213–215 installing Ruby, 213 PostgreSQL, 215–217 repositories, 212\n\ndebug.rb , 31 delete route, 156 Deleting images, 180–181 Deleting users\n\nActive Admin registration block, 186 password_salt, 186 user attributes, 186\n\ndescribe ’index’ block, 180 destroy method, 156 development.rb ﬁle, 124 Display tags on pages\n\nconfig/routes.rb ﬁle, 116 default_scope, 116 failure message, 118 _page.html.erb partial, 117 show.html.erb ﬁle, 118, 119 spec/system directory, 117 Tag collection, 114 tag_links method, 115, 117 tag_path route, 116 Tag records, 114 tags_controller.rb ﬁle, 118, 119 TagsHelper module, 115 tags_helper.rb ﬁle, 115 tags_helper_spec.rb ﬁle, 114 TagsHelper#tag_links method, 116\n\nDomain-speciﬁc language (DSL), 27 Don’t repeat yourself (DRY), 90, 91 DreamHost, 211\n\nE Editing images\n\nActiveAdmin.register block, 176 attach_file page, 177 edit page, 177 factor out duplicate expectations, 178–180 form block, 177 new and edit routes, 178 Embedded Ruby (ERB), 55, 56 Extreme Programming (XP), 3\n\nF FactoryBot\n\ndebugging, 30–32 DSL, 28 FactoryBot.create method, 29 factory_bot_rails , 29 Rails code generators, 29, 30 Rails environments, 29 RSpec, 29 Ruby gem, 29 shoulda-matchers , 30 test data, Rails and ActiveRecord\n\nobjects, 28, 29\n\ntest Rails applications, 28 FactoryBot create method, 64 FactoryBot.create method, 29 factory_bot_rails , 29 find method, 64 foreman command, 24, 25 form_for helper method, 154 form method, 184\n\nG gem command, 17, 18 Gemﬁle, 29 GitHub, 217, 220, 222\n\nH Handling missing tags request spec, 119 root_path, 120 tag_spec.rb, 119\n\nHash function, 134 Hashing library, 136–137 Homebrew, 13–14 HomeController#index action, 61, 63 Homepage Layout, 73 html_safe method, 71\n\nI Image Controller, serve image data\n\nContent-Disposition, 130 GET request, 127 HTML/ERB template, 129 image.download, 130 image/jpeg, 128\n\nIndex",
      "content_length": 2404,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 234,
      "content": "Index\n\nimages_controller.rb, 129 images_spec.rb, 127 img record, 130 “missing” image, 131 missing.jpeg ﬁle, 132 Rails route, 128 show route, 128\n\nimage.image.attach code, 126 Image model, 125 Images management\n\nadmin ﬁlters, 181–182 deleting, 180–181 editing, 176–180 uploading, 172–176 viewing (see Viewing Images)\n\nImage tag matchers, 175 importmap , 20 index block, 167, 168 index_content element, 166\n\nJ Join model, 107 Jump over relationships\n\nhas_many relationship, 109–111 has_many:through\n\nassociation, 109\n\npage_spec.rb ﬁle, 110 tag_spec.rb ﬁle, 110\n\nL layout template, 74–76 let method, 60 Linux server, 211–212 Logging in\n\nactive_admin.rb initializer file, 156 admin layout, 157–158 admin_user_id session, 156 admin_user_id set, 153 ApplicationController, 157 application_controller.rb ﬁle, 152, 153 changes, 151 config/routes.rb ﬁle, 152, 154 create command, 155 error, 151 login_spec.rb ﬁle, 151 logout functionality, 155 new.html.erb ﬁle, 152 routes command, 154, 155 sessions_controller.rb set, 153–155 top-level login key, 155 user authentication, 152\n\nlogin_as method, 165 login_path helper method, 152 login.rb ﬁle, 164 login routes, 154 logout path, 156\n\nM Matz’s Ruby Interpreter (MRI), 15 Model-view-controller (MVC) .month_year_list method, 92, 93\n\nN Namecheap, 211, 212 NameCleanup module, 121 Node.js, 19–20, 222–223 nodesource.com, 223 NoMethodError, 61, 64 Non-cloud approach, 211\n\nO OpenBSD bcrypt library, 136 .ordered scope, 62, 63 Overriding Active Admin form ﬁeld values admin/pages.rb ﬁle, 161, 164 missing values, 161 Page model, 161 spec failure message, 161 spec/models/page_spec.rb\n\nfile, 161\n\ntags_string_for_form\n\nmethod, 161, 164\n\nP Page.by_term method, 99 Page.by_year_month method, 99, 100, 102 Page factory, 48 Page method, 60 Page model\n\nblog post, 33 factory, 42 FactoryBot “build” vs. “create,” 46 migration, 41, 42 .ordered scope , 62 Page factory, 48 Page slug, 46–48 Postgres, 44 rails generate command , 41 random test data, 48–49 RSpec’s “subject,” 45–46 specs, 43\n\nPage.month_year_list method, 97 Page.new(user:), 29 Pages archive, sidebar\n\narchive integration test, 101–103 archive list view, 98–101 create list of months and years, 92–98\n\nPageSearch.search method, 100 PageSearch service class, 98 Pages management error, 160 factoring out duplicate login code, 164–165 flashes CSS class, 159\n\n229",
      "content_length": 2350,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 235,
      "content": "230\n\nnew_admin_page_path, 159, 160 overriding Active Admin form ﬁeld values, 161–164 Page parameter list, 160 page preview, 166–168 pages_spec.rb ﬁle, 158 tags_string attribute, 160, 161\n\nPageTag model creation\n\ncounter_cache option, 109 CreatePageTags migration, 107 create_table block, 107 page_tags_count column, 108 page_tags factory, 108 page_tag_spec.rb file, 108 Rails generator, 107 :references, 108 validation spec, 109 PageTag records, 108 Pagination\n\nconfig/routes.rb ﬁle, 196 FactoryBot’s create_list method, 193 ﬁxing specs, 198 HomeController index method, 194 kaminari_config.rb, 193 Kaminari gem, 192–193 Page.none, 197 Page objects, 194–195 PageSearch service class, 197 spec/system/home_spec.rb\n\nfile, 193\n\nspec/system/search_spec.rb\n\nﬁle, 196–197\n\nspec/system/tag_spec.rb ﬁle, 195 TagsController, 196\n\npassword attribute, 135 Password conﬁrmation\n\nattribute, 146 FactoryBot, 146 failure message, 144 password attribute, 144, 145 password= method, 144 shoulda-matcher specs, 144 spec/factories/users.rb, 145 user password validation, 146 User_spec.rb ﬁle, 145 virtual attribute, 146\n\nPassword Conﬁrmation ﬁeld label, 183 password_hash ﬁeld, 134 Password hashing, 133–134 password= method, 135 password_salt ﬁeld, 134 permitted_params method, 160 Phusion Passenger, 213–215, 224 PostgreSQL, 2, 18–19, 34, 215–217, 221 PostgreSQL’s psql program, 34 PostgreSQL’s TO_CHAR function, 93 PostgreSQL TRIM function, 93 Prism, 205–208 Procfile.dev file, 23, 24 Published Pages, 61\n\n.published scope , 61 Published vs. unpublished pages, 59–61\n\nR Rackspace, 211 Rails application, 211\n\nActive Storage, 222 deploying, 219–223 logging in, 224–225\n\nrails generate command , 33 Rails model validations, 49, 50 rails new command, 20–23 Rails resources method, 152 Rails routes command, 154 rails server command , 23 Rails view templates, 55–57 Random test data, 48–49 rbenv, 14–16 Red-green-refactor development cycle, TDD\n\ngreen phase, 9–10 red phase, 8–9 refactor phase, 10 wash, rinse, and repeat, 10–11\n\nRefactor duplicate code cleanup code, 120 local private method, 122 make_slug method, 121 name_cleanup.rb module, 121 name_cleanup_spec.rb ﬁle, 120\n\nRelational database management system (RDBMS), 2, 18\n\nrender method, 57 Request specs, 51 root method, 53 RSpec\n\nbehavior-driven development, 2 bundle command , 27 DSL, Ruby, 27 Gemﬁle, 27 Rails blog application, 27, 28 Rails development, 27 run rails generate rspec:install\n\ncommand , 28 run rspec command , 27 shoulda-matchers, 38 test environments, 27 testing framework, Ruby, 27\n\nRSpec lets, 60, 62 RSpec’s “subject,” 45–46 Ruby\n\ninstallation, 14–16 MRI, 15 rbenv, 14\n\nRuby gem, 205–206 Ruby on Rails, 1, 5\n\ncode generators, 33 create new Ruby on Rails application Bootstrap, CSS framework, 20 Bundler’s bundle exec command, 21\n\nIndex",
      "content_length": 2797,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 236,
      "content": "Index\n\ndatabase=postgresql option , 20\n\ndevelopment database, 22 error page, 22 JavaScript, 20 rails db:create command , 22 rails new command, 20, 21 RSpec, 20 test database, 22 welcome page, 23\n\ninstallation, 18 install Bundler, 17 Node.js installation, 19–20 PostgreSQL installation, 18–19 run Rails, foreman command, 24, 25 Test::Unit , 27\n\nS Salt value, 134 Search for page, sidebar\n\napp/views directory , 88 GET request, 86 SearchController , 88 search form, 86–88 _search_form.html.erb , 86 search_path variable, 87 search results display, 88–91 search_spec.rb , 86 spec/system directory, 86\n\nSearch service\n\n.by_term scope, 82, 83 empty parameter, 81 PageSearch, 80, 81 page_search_spec.rb , 79 Rails ActiveRecord, 83 Ruby class, 79 Ruby module, 80 search by term, 83–85 Search controller and\n\nPage model , 79\n\nspec/services , 79\n\nsend_data method, 130 SessionsController, 155 Shared partial template, 69–71 Shoulda-matchers, 30, 38, 45, 47, 50, 144 Sidebar layout, 76–77 Sitemap\n\nblog application, 187 config/routes.rb file, 188 ERB template, 189–190 let statements, 191–192 spec/requests/home_spec.rb\n\nfile, 187–188 Tag URLs, 190–191 URL endpoint, 187 XML response, 188–189 Skipping password validation\n\nbug, 147 conditional, 147\n\nprivate helper method, 147\n\n:slug value , 65 spec/helpers directory, 114 spec/models directory, 120 spec/models/image_spec.rb ﬁle, 125 spec/models/user_spec.rb ﬁle, 135 spec/system/admin directory, 182 spec/system directory, 158 SQL query, 93–95, 97, 98 SSH, 211 Stimulus and Turbo, 206–208 Styling\n\nadmin login, 203–205 CSS\n\narchive list, 201–202 header, 199–200 no search results, 200–201 page summary, 200 pagination, 202–203 in rails, 199 search form, 201\n\nfunctioning application, 199 public pages, 199–203 wraps up, 205\n\nsubject variable , 45 system/admin/pages_spec.rb\n\nﬁle, 165, 166\n\nsystem/login_spec.rb ﬁle, 165 System specs\n\narticle element , 59 bundle exec command , 54 capybara , 52 Capybara’s find_all method, 59 Capybara’s within method, 59 conﬁgure Selenium, 57–58 display single page, 64–66 error message, 52 get route , 55 happy path, 63 homepage, testing, 51–54 .last , 59 Rails, 57 Rails g alias also , 54 Rails, root_path , 52 Rails view templates, 55–57 render method, 57 Request specs, 51 root method, 53 simulates user interaction, 51 yield method, 57\n\nT Tag factory, 106 Tagging pages\n\nafter save callbacks, 111–114 display tags on pages, 114–119 handling missing tags, 119–120 refactor duplicate code, 120–122\n\nTag model creation\n\n231",
      "content_length": 2500,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 237,
      "content": "232\n\n:name uniqueness validation, 107 :name validation, 107 page_tags_count column, 106 Rails generator, 105 Tag factory updation, 106 tag_spec.rb ﬁle updation, 106 uniq option, 106 TagsController, 118 TagsHelper module, 115 TagsHelper#tag_links method, 117 tags_string_for_form method, 161, 164 Test-driven development (TDD), 1, 2220\n\nadvantages\n\nacceptance test, 12 code design, 11 code quality, 12 maintain focus, 12 no broken windows, 11 problems with late testwriting\n\ncode spikes, 8 no code design, 7 pass by accident, 7–8\n\nred-green-refactor development cycle\n\ngreen phase, 9–10 red phase, 8–9 refactor phase, 10 wash, rinse, and repeat, 10–11 software design and engineering, 2 writing style, 2 test.rb ﬁle, 124 Third-party authentication library, 133 .to_sql method, 84\n\nU Uploading images\n\nactions method, 173 factor out our image matchers, 175–176 functionality, 172 has_one_attached\n\nassociation, 173\n\nImage model, 174 Rails’ .root method, 173 storage.yml ﬁle, 172\n\nUser.authenticate method, 155 User authentication arguments, 138 .authenticate class method, 137, 138 failure message, 138 one-way hashing, 139 password hash, 139\n\nUser factory, 35–37 User model\n\nblog post, 33 migration, 34, 35 rails generate command, 33\n\nrun specs, 37 user factory, 35–37 validation, 38–41 User model enhancement adding ﬁelds, 134–136 adding hashing library, 136–137 authentication (see Authentication\n\nenhancement)\n\npassword conﬁrmation, 144–146 password hashing, 133–134 skipping password validation, 146–147 user authentication, 137–139\n\nUsers management\n\nadding new users, 182–185 deleting users, 185–186 Image and Page models, 182\n\nUser Spec Cleanup, 49 users.rb ﬁle, 183\n\nV Viewing Images\n\nActiveAdmin.register block, 170 alt and title attributes, 170 within blocks, 169 CSS class col-image_tag, 171 failure message, 171 images_spec.rb ﬁle, 168 “views” or “view” templates, 55 View Specs\n\nBlog page layout, 74 pcontent/p tag, 71 CSS framework, 74 home/index template , 72 homepage, 71 Homepage Layout, 73 html_safe , 71 HTML article tag, 69 layout template, 74–76 pages/show template , 73 <p>tag, 71 shared partial template, 69–71 “show” view spec ﬁle, 72, 73 sidebar layout, 76–77\n\nVirtualHost conﬁguration, 211\n\nW “weblog” or “web log”, 1 within_window method, 166 World Wide Web, 4\n\nY yarn package, 223 yield method, 57\n\nIndex",
      "content_length": 2331,
      "extraction_method": "Unstructured"
    }
  ]
}