{
  "metadata": {
    "title": "building-reactive-microservices-in-java",
    "author": "Clement Escoffier",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 83,
    "conversion_date": "2025-12-19T18:43:50.591744",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "building-reactive-microservices-in-java.pdf",
    "extraction_method": "Unstructured"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-9)",
      "start_page": 1,
      "end_page": 9,
      "detection_method": "topic_boundary",
      "content": "Building Reactive Microservices in Java\n\nAsynchronous and Event-Based Application Design\n\nClement Escoffier\n\nBuilding Reactive Microservices in Java Asynchronous and Event-Based Application Design\n\nClement Escoffier\n\nBeijing Beijing\n\nBoston Boston\n\nFarnham Sebastopol Farnham Sebastopol\n\nTokyo Tokyo\n\nBuilding Reactive Microservices in Java by Clement Escoffier\n\nCopyright © 2017 O’Reilly Media. All rights reserved.\n\nPrinted in the United States of America.\n\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\n\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (http://oreilly.com/safari). For more information, contact our corporate/institutional sales department: 800-998-9938 or corporate@oreilly.com.\n\nEditor: Brian Foster Production Editor: Shiny Kalapurakkel Copyeditor: Christina Edwards Proofreader: Sonia Saruba\n\nInterior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: Rebecca Demarest\n\nMay 2017:\n\nFirst Edition\n\nRevision History for the First Edition 2017-04-06: First Release\n\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Building Reactive Microservices in Java, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.\n\nWhile the publisher and the author have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the author disclaim all responsibility for errors or omissions, including without limi‐ tation responsibility for damages resulting from the use of or reliance on this work. Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsi‐ bility to ensure that your use thereof complies with such licenses and/or rights.\n\n978-1-491-98628-8\n\n[LSI]\n\nTable of Contents\n\n1.\n\nIntroduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Preparing Your Environment 2\n\n2. Understanding Reactive Microservices and Vert.x. . . . . . . . . . . . . . . . 3 Reactive Programming 4 Reactive Systems 7 Reactive Microservices 8 What About Vert.x ? 9 Asynchronous Development Model 11 Verticles—the Building Blocks 14 From Callbacks to Observables 15 Let’s Start Coding! 17 Summary 21\n\n3. Building Reactive Microservices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 First Microservices 23 Implementing HTTP Microservices 24 Consuming HTTP Microservices 28 Are These Microservices Reactive Microservices? 31 The Vert.x Event Bus—A Messaging Backbone 32 Message-Based Microservices 33 Initiating Message-Based Interactions 35 Are We Reactive Now? 37 Summary 40\n\n4. Building Reactive Microservice Systems. . . . . . . . . . . . . . . . . . . . . . . . 43 Service Discovery 43 Stability and Resilience Patterns 47 Summary 54\n\niii\n\n5. Deploying Reactive Microservices in OpenShift. . . . . . . . . . . . . . . . . . 57 What Is OpenShift? 57 Installing OpenShift on Your Machine 60 Deploying a Microservice in OpenShift 62 Service Discovery 64 Scale Up and Down 65 Health Check and Failover 67 Using a Circuit Breaker 68 But Wait, Are We Reactive? 70 Summary 71\n\n6. Conclusion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 What Have We Learned? 73 Microservices Aren’t Easy 74 The Evolution of the Microservice Paradigm 75 Vert.x Versatility 76\n\niv\n\n|\n\nTable of Contents\n\nCHAPTER 1 Introduction\n\nThis report is for developers and architects interested in developing microservices and distributed applications. It does not explain the basics of distributed systems, but instead focuses on the reactive benefits to build efficient microservice systems. Microservices can be seen as an extension of the basic idea of modularity: programs connected by message-passing instead of direct API calls so that they can be distributed among multiple services. Why are microser‐ vices so popular? It’s basically due to the combination of two factors: cloud computing and the need to scale up and down quickly. Cloud computing makes it convenient to deploy thousands of small serv‐ ices; scaling makes it necessary to do so.\n\nIn this report, we will see how Eclipse Vert.x (http://vertx.io) can be used to build reactive microservice systems. Vert.x is a toolkit to build reactive and distributed systems. Vert.x is incredibly flexible. Because it’s a toolkit, you can build simple network utilities, modern web applications, a system ingesting a huge amount of messages, REST services, and, obviously, microservices. This malleability gives Vert.x great popularity, a large community, and a vibrant ecosystem. Vert.x was already promoting microservices before it became so pop‐ ular. Since the beginning, Vert.x has been tailored to build applica‐ tions composed by a set of distributed and autonomous services. Systems using Vert.x are built upon the reactive system principles (http://reactivemanifesto.org). They are responsive, elastic, resilient, and use asynchronous message passing to interact.\n\n1\n\nThis report goes beyond Vert.x and microservices. It looks at the whole environment in which a microservice system runs and intro‐ duces the many tools needed to get the desired results. On this jour‐ ney, we will learn:\n\nWhat Vert.x is and how you can use it\n\nWhat reactive means and what reactive microservices are\n\nHow to implement microservices using HTTP or messages\n\nThe patterns used to build reactive microservice systems\n\nHow to deploy microservices in a virtual or cloud environment\n\nThe code presented in this report is available from https:// github.com/redhat-developer/reactive-microservices-in-java.\n\nPreparing Your Environment Eclipse Vert.x requires Java 8, which we use for the different exam‐ ples provided in this report. We are going to use Apache Maven to build them. Make sure you have the following prerequisites installed:\n\nJDK 1.8\n\nMaven 3.3+\n\nA command-line terminal (Bash, PowerShell, etc.)\n\nEven if not mandatory, we recommend using an IDE such as the Red Hat Development Suite (https://developers.redhat.com/products/ devsuite/overview). In the last chapter, we use OpenShift, a container platform built on top of Kubernetes (https://kubernetes.io) to run containerized microservices. To install OpenShift locally, we recom‐ mend Minishift (https://github.com/minishift/minishift) or the Red Hat Container Development Kit (CDK) v3. You can download the CDK from https://developers.redhat.com/products/cdk/download.\n\nLet’s get started.\n\n2\n\n|\n\nChapter 1: Introduction\n\nCHAPTER 2 Understanding Reactive Microservices and Vert.x\n\nMicroservices are not really a new thing. They arose from research conducted in the 1970s and have come into the spotlight recently because microservices are a way to move faster, to deliver value more easily, and to improve agility. However, microservices have roots in actor-based systems, service design, dynamic and auto‐ nomic systems, domain-driven design, and distributed systems. The fine-grained modular design of microservices inevitably leads devel‐ opers to create distributed systems. As I’m sure you’ve noticed, dis‐ tributed systems are hard. They fail, they are slow, they are bound by the CAP and FLP theorems. In other words, they are very compli‐ cated to build and maintain. That’s where reactive comes in.\n\n30+ Years of Evolution The actor model was introduced by C. Hewitt, P. Bishop, and R. Steiger in 1973. Autonomic computing, a term coined in 2001, refers to the self-managing characteristics (self-healing, self- optimization, etc.) of distributed computing resources.\n\nBut what is reactive? Reactive is an overloaded term these days. The Oxford dictionary defines reactive as “showing a response to a stimu‐ lus.” So, reactive software reacts and adapts its behavior based on the stimuli it receives. However, the responsiveness and adaptability promoted by this definition are programming challenges because\n\n3\n\nthe flow of computation isn’t controlled by the programmer but by the stimuli. In this chapter, we are going to see how Vert.x helps you be reactive by combining:\n\nReactive programming—A development model focusing on the observation of data streams, reacting on changes, and propagat‐ ing them\n\nReactive system—An architecture style used to build responsive and robust distributed systems based on asynchronous message-passing\n\nA reactive microservice is the building block of reactive microservice systems. However, due to their asynchronous aspect, the implemen‐ tation of these microservices is challenging. Reactive programming reduces this complexity. How? Let’s answer this question right now.\n\nReactive Programming\n\nFigure 2-1. Reactive programming is about flow of data and reacting to it\n\nReactive programming is a development model oriented around data flows and the propagation of data. In reactive programming, the stimuli are the data transiting in the flow, which are called streams. There are many ways to implement a reactive programming model. In to use Reactive Extensions (http://reactivex.io/) where streams are called observables, and con‐ sumers subscribe to these observables and react to the values (Figure 2-1).\n\nthis report, we are going\n\n4\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x",
      "page_number": 1
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 10-20)",
      "start_page": 10,
      "end_page": 20,
      "detection_method": "topic_boundary",
      "content": "To make these concepts less abstract, let’s look at an example using RxJava (https://github.com/ReactiveX/RxJava), a library implement‐ ing the Reactive Extensions in Java. These examples are located in the directory reactive-programming in the code repository.\n\nobservable.subscribe( data -> { // onNext System.out.println(data); }, error -> { // onError error.printStackTrace(); }, () -> { // onComplete System.out.println(\"No more data\"); } );\n\nIn this snippet, the code is observing (subscribe) an Observable and is notified when values transit in the flow. The subscriber can receive three types of events. onNext is called when there is a new value, while onError is called when an error is emitted in the stream or a stage throws an Exception. The onComplete callback is invoked when the end of the stream is reached, which would not occur for unbounded streams. RxJava includes a set of operators to produce, transform, and coordinate Observables, such as map to transform a value into another value, or flatMap to produce an Observable or chain another asynchronous action:\n\n// sensor is an unbound observable publishing values. sensor // Groups values 10 by 10, and produces an observable // with these values. .window(10) // Compute the average on each group .flatMap(MathObservable::averageInteger) // Produce a json representation of the average .map(average -> \"{'average': \" + average + \"}\") .subscribe( data -> { System.out.println(data); }, error -> { error.printStackTrace(); } );\n\nRxJava v1.x defines different types of streams as follows:\n\nReactive Programming\n\n|\n\n5\n\nObservables are bounded or unbounded streams expected to contain a sequence of values.\n\nSingles are streams with a single value, generally the deferred result of an operation, similar to futures or promises.\n\nCompletables are streams without value but with an indication of whether an operation completed or failed.\n\nRxJava 2 While RxJava 2.x has been recently released, this report still uses the previous version (RxJava 1.x). RxJava 2.x provides similar concepts. RxJava 2 adds two new types of streams. Observable is used for streams not supporting back-pressure, while Flowable is an Observable with back-pressure. RxJava 2 also introduced the Maybe type, which models a stream where there could be 0 or 1 item or an error.\n\nWhat can we do with RxJava? For instance, we can describe sequen‐ ces of asynchronous actions and orchestrate them. Let’s imagine you want to download a document, process it, and upload it. The down‐ load and upload operations are asynchronous. To develop this sequence, you use something like:\n\n// Asynchronous task downloading a document Future<String> downloadTask = download(); // Create a single completed when the document is downloaded. Single.from(downloadTask) // Process the content .map(content -> process(content)) // Upload the document, this asynchronous operation // just indicates its successful completion or failure. .flatMapCompletable(payload -> upload(payload)) .subscribe( () -> System.out.println(\"Document downloaded, updated and uploaded\"), t -> t.printStackTrace() );\n\nYou can also orchestrate asynchronous tasks. For example, to com‐ bine the results of two asynchronous operations, you use the zip operator combining values of different streams:\n\n6\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x\n\n// Download two documents Single<String> downloadTask1 = downloadFirstDocument(); Single<String> downloadTask2 = downloadSecondDocument();\n\n// When both documents are downloaded, combine them Single.zip(downloadTask1, downloadTask2, (doc1, doc2) -> doc1 + \"\\n\" + doc2) .subscribe( (doc) -> System.out.println(\"Document combined: \" + doc), t -> t.printStackTrace() );\n\nThe use of these operators gives you superpowers: you can coordi‐ nate asynchronous tasks and data flow in a declarative and elegant way. How is this related to reactive microservices? To answer this question, let’s have a look at reactive systems.\n\nReactive Streams You may have heard of reactive streams (http://www.reactive- streams.org/). Reactive streams is an initiative to provide a standard for asynchronous stream processing with back-pressure. It provides a minimal set of interfaces and protocols that describe the opera‐ tions and entities to achieve the asynchronous streams of data with nonblocking back-pressure. It does not define operators manipulat‐ ing the streams, and is mainly used as an interoperability layer. This initiative is supported by Netflix, Lightbend, and Red Hat, among others.\n\nReactive Systems While reactive programming is a development model, reactive sys‐ tems is an architectural style used to build distributed systems (http://www.reactivemanifesto.org/). It’s a set of principles used to achieve responsiveness and build systems that respond to requests in a timely fashion even with failures or under load.\n\nTo build such a system, reactive systems embrace a message-driven approach. All the components interact using messages sent and received asynchronously. To decouple senders and receivers, com‐ ponents send messages to virtual addresses. They also register to the virtual addresses to receive messages. An address is a destination identifier such as an opaque string or a URL. Several receivers can be registered on the same address—the delivery semantic depends\n\nReactive Systems\n\n|\n\n7\n\non the underlying technology. Senders do not block and wait for a response. The sender may receive a response later, but in the mean‐ time, he can receive and send other messages. This asynchronous aspect is particularly important and impacts how your application is developed.\n\nUsing asynchronous message-passing interactions provides reactive systems with two critical properties:\n\nElasticity—The ability to scale horizontally (scale out/in)\n\nResilience—The ability to handle failure and recover\n\nElasticity comes from the decoupling provided by message interac‐ tions. Messages sent to an address can be consumed by a set of con‐ sumers using a load-balancing strategy. When a reactive system faces a spike in load, it can spawn new instances of consumers and dispose of them afterward.\n\nThis resilience characteristic is provided by the ability to handle fail‐ ure without blocking as well as the ability to replicate components. First, message interactions allow components to deal with failure locally. Thanks to the asynchronous aspect, components do not actively wait for responses, so a failure happening in one component would not impact other components. Replication is also a key ability to handle resilience. When one node-processing message fails, the message can be processed by another node registered on the same address.\n\nThanks to these two characteristics, the system becomes responsive. It can adapt to higher or lower loads and continue to serve requests in the face of high loads or failures. This set of principles is primor‐ dial when building microservice systems that are highly distributed, and when dealing with services beyond the control of the caller. It is necessary to run several instances of your services to balance the load and handle failures without breaking the availability. We will see in the next chapters how Vert.x addresses these topics.\n\nReactive Microservices When building a microservice (and thus distributed) system, each service can change, evolve, fail, exhibit slowness, or be withdrawn at any time. Such issues must not impact the behavior of the whole sys‐ tem. Your system must embrace changes and be able to handle fail‐\n\n8\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x\n\nures. You may run in a degraded mode, but your system should still be able to handle the requests.\n\nTo ensure such behavior, reactive microservice systems are com‐ prised of reactive microservices. These microservices have four char‐ acteristics:\n\nAutonomy\n\nAsynchronisity\n\nResilience\n\nElasticity\n\nReactive microservices are autonomous. They can adapt to the avail‐ ability or unavailability of the services surrounding them. However, autonomy comes paired with isolation. Reactive microservices can handle failure locally, act independently, and cooperate with others as needed. A reactive microservice uses asynchronous message- passing to interact with its peers. It also receives messages and has the ability to produce responses to these messages.\n\nThanks to the asynchronous message-passing, reactive microservi‐ ces can face failures and adapt their behavior accordingly. Failures should not be propagated but handled close to the root cause. When a microservice blows up, the consumer microservice must handle the failure and not propagate it. This isolation principle is a key characteristic to prevent failures from bubbling up and breaking the whole system. Resilience is not only about managing failure, it’s also about self-healing. A reactive microservice should implement recov‐ ery or compensation strategies when failures occur.\n\nFinally, a reactive microservice must be elastic, so the system can adapt to the number of instances to manage the load. This implies a set of constraints such as avoiding in-memory state, sharing state between instances if required, or being able to route messages to the same instances for stateful services.\n\nWhat About Vert.x ? Vert.x is a toolkit for building reactive and distributed systems using an asynchronous nonblocking development model. Because it’s a toolkit and not a framework, you use Vert.x as any other library. It does not constrain how you build or structure your system; you use\n\nWhat About Vert.x ?\n\n|\n\n9\n\nit as you want. Vert.x is very flexible; you can use it as a standalone application or embedded in a larger one.\n\nFrom a developer standpoint, Vert.x a set of JAR files. Each Vert.x module is a JAR file that you add to your $CLASSPATH. From HTTP servers and clients, to messaging, to lower-level protocols such as TCP or UDP, Vert.x provides a large set of modules to build your application the way you want. You can pick any of these modules in addition to Vert.x Core (the main Vert.x component) to build your system. Figure 2-2 shows an excerpt view of the Vert.x ecosystem.\n\nFigure 2-2. An incomplete overview of the Vert.x ecosystem\n\n10\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x\n\nVert.x also provides a great stack to help build microservice systems. Vert.x pushed the microservice approach before it became popular. It has been designed and built to provide an intuitive and powerful way to build microservice systems. And that’s not all. With Vert.x you can build reactive microservices. When building a microservice with Vert.x, it infuses one of its core characteristics to the microser‐ vice: it becomes asynchronous all the way.\n\nAsynchronous Development Model All applications built with Vert.x are asynchronous. Vert.x applica‐ tions are event-driven and nonblocking. Your application is notified when something interesting happens. Let’s look at a concrete exam‐ ple. Vert.x provides an easy way to create an HTTP server. This HTTP server is notified every time an HTTP request is received:\n\nvertx.createHttpServer() .requestHandler(request -> { // This handler will be called every time an HTTP // request is received at the server request.response().end(\"hello Vert.x\"); }) .listen(8080);\n\nIn this example, we set a requestHandler to receive the HTTP requests (event) and send hello Vert.x back (reaction). A Handler is a function called when an event occurs. In our example, the code of the handler is executed with each incoming request. Notice that a Handler does not return a result. However, a Handler can provide a result. How this result is provided depends on the type of interac‐ tion. In the last snippet, it just writes the result into the HTTP response. The Handler is chained to a listen request on the socket. Invoking this HTTP endpoint produces a simple HTTP response:\n\nHTTP/1.1 200 OK Content-Length: 12\n\nhello Vert.x\n\nWith very few exceptions, none of the APIs in Vert.x block the call‐ ing thread. If a result can be provided immediately, it will be returned; otherwise, a Handler is used to receive events at a later time. The Handler is notified when an event is ready to be processed or when the result of an asynchronous operation has been compu‐ ted.\n\nAsynchronous Development Model\n\n|\n\n11\n\nIn traditional imperative programming, you would write something like:\n\nint res = compute(1, 2);\n\nIn this code, you wait for the result of the method. When switching to an asynchronous nonblocking development model, you pass a Handler invoked when the result is ready:1\n\ncompute(1, 2, res -> { // Called with the result });\n\nIn the last snippet, compute does not return a result anymore, so you don’t wait until this result is computed and returned. You pass a Handler that is called when the result is ready.\n\nThanks to this nonblocking development model, you can handle a highly concurrent workload using a small number of threads. In most cases, Vert.x calls your handlers using a thread called an event loop. This event loop is depicted in Figure 2-3. It consumes a queue of events and dispatches each event to the interested Handlers.\n\nFigure 2-3. The event loop principle\n\nThe threading model proposed by the event loop has a huge benefit: it simplifies concurrency. As there is only one thread, you are always called by the same thread and never concurrently. However, it also has a very important rule that you must obey:\n\n1 This code uses the lambda expressions introduced in Java 8. More details about this\n\nnotation can be found at http://bit.ly/2nsyJJv.\n\n12\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x\n\nDon’t block the event loop.\n\n—Vert.x golden rule\n\nBecause nothing blocks, an event loop can deliver a huge number of events in a short amount of time. This is called the reactor pattern (https://en.wikipedia.org/wiki/Reactor_pattern).\n\nLet’s imagine, for a moment, that you break the rule. In the previous code snippet, the request handler is always called from the same event loop. So, if the HTTP request processing blocks instead of replying to the user immediately, the other requests would not be handled in a timely fashion and would be queued, waiting for the thread to be released. You would lose the scalability and efficiency benefit of Vert.x. So what can be blocking? The first obvious example is JDBC database accesses. They are blocking by nature. Long com‐ putations are also blocking. For example, a code calculating Pi to the 200,000th decimal point is definitely blocking. Don’t worry—Vert.x also provides constructs to deal with blocking code.\n\nIn a standard reactor implementation, there is a single event loop thread that runs around in a loop delivering all events to all handlers as they arrive. The issue with a single thread is simple: it can only run on a single CPU core at one time. Vert.x works differently here. Instead of a single event loop, each Vert.x instance maintains several event loops, which is called a multireactor pattern, as shown in Figure 2-4.\n\nFigure 2-4. The multireactor principle\n\nThe events are dispatched by the different event loops. However, once a Handler is executed by an event loop, it will always be invoked by this event loop, enforcing the concurrency benefits of the\n\nAsynchronous Development Model\n\n|\n\n13\n\nreactor pattern. If, like in Figure 2-4, you have several event loops, it can balance the load on different CPU cores. How does that work with our HTTP example? Vert.x registers the socket listener once and dispatches the requests to the different event loops.\n\nVerticles—the Building Blocks Vert.x gives you a lot of freedom in how you can shape your applica‐ tion and code. But it also provides bricks to easily start writing Vert.x applications and comes with a simple, scalable, actor-like deployment and concurrency model out of the box. Verticles are chunks of code that get deployed and run by Vert.x. An application, such as a microservice, would typically be comprised of many verti‐ cle instances running in the same Vert.x instance at the same time. A verticle typically creates servers or clients, registers a set of Handlers, and encapsulates a part of the business logic of the sys‐ tem.\n\nRegular verticles are executed on the Vert.x event loop and can never block. Vert.x ensures that each verticle is always executed by the same thread and never concurrently, hence avoiding synchroniza‐ tion constructs. In Java, a verticle is a class extending the Abstract Verticle class:\n\nimport io.vertx.core.AbstractVerticle;\n\npublic class MyVerticle extends AbstractVerticle { @Override public void start() throws Exception { // Executed when the verticle is deployed }\n\n@Override public void stop() throws Exception { // Executed when the verticle is un-deployed } }\n\nWorker Verticle Unlike regular verticles, worker verticles are not executed on the event loop, which means they can execute blocking code. However, this limits your scalability.\n\n14\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x\n\nVerticles have access to the vertx member (provided by the AbstractVerticle class) to create servers and clients and to interact with the other verticles. Verticles can also deploy other verticles, configure them, and set the number of instances to create. The instances are associated with the different event loops (implement‐ ing the multireactor pattern), and Vert.x balances the load among these instances.\n\nFrom Callbacks to Observables As seen in the previous sections, the Vert.x development model uses callbacks. When orchestrating several asynchronous actions, this callback-based development model tends to produce complex code. For example, let’s look at how we would retrieve data from a data‐ base. First, we need a connection to the database, then we send a query to the database, process the results, and release the connec‐ tion. All these operations are asynchronous. Using callbacks, you would write the following code using the Vert.x JDBC client:\n\nclient.getConnection(conn -> { if (conn.failed()) {/* failure handling */} else { SQLConnection connection = conn.result(); connection.query(\"SELECT * from PRODUCTS\", rs -> { if (rs.failed()) {/* failure handling */} else { List<JsonArray> lines = rs.result().getResults(); for (JsonArray l : lines) { System.out.println(new Product(l)); } connection.close(done -> { if (done.failed()) {/* failure handling */} }); } }); } });\n\nWhile still manageable, the example shows that callbacks can quickly lead to unreadable code. You can also use Vert.x Futures to handle asynchronous actions. Unlike Java Futures, Vert.x Futures are nonblocking. Futures provide higher-level composition opera‐ tors to build sequences of actions or to execute actions in parallel. Typically, as demonstrated in the next snippet, we compose futures to build the sequence of asynchronous actions:\n\nFrom Callbacks to Observables\n\n|\n\n15",
      "page_number": 10
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 21-31)",
      "start_page": 21,
      "end_page": 31,
      "detection_method": "topic_boundary",
      "content": "Future<SQLConnection> future = getConnection(); future .compose(conn -> { connection.set(conn); // Return a future of ResultSet return selectProduct(conn); }) // Return a collection of products by mapping // each row to a Product .map(result -> toProducts(result.getResults())) .setHandler(ar -> { if (ar.failed()) { /* failure handling */ } else { ar.result().forEach(System.out::println); } connection.get().close(done -> { if (done.failed()) { /* failure handling */ } }); });\n\nHowever, while Futures make the code a bit more declarative, we are retrieving all the rows in one batch and processing them. This result can be huge and take a lot of time to be retrieved. At the same time, you don’t need the whole result to start processing it. We can process each row one by one as soon as you have them. Fortunately, Vert.x provides an answer to this development model challenge and offers you a way to implement reactive microservices using a reac‐ tive programming development model. Vert.x provides RxJava APIs to:\n\nCombine and coordinate asynchronous tasks\n\nReact to incoming messages as a stream of input\n\nLet’s rewrite the previous code using the RxJava APIs:\n\n// We retrieve a connection and cache it, // so we can retrieve the value later. Single<SQLConnection> connection = client .rxGetConnection(); connection .flatMapObservable(conn -> conn // Execute the query .rxQueryStream(\"SELECT * from PRODUCTS\") // Publish the rows one by one in a new Observable .flatMapObservable(SQLRowStream::toObservable) // Don't forget to close the connection .doAfterTerminate(conn::close) )\n\n16\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x\n\n// Map every row to a Product .map(Product::new) // Display the result one by one .subscribe(System.out::println);\n\nIn addition to improving readability, reactive programming allows you to subscribe to a stream of results and process items as soon as they are available. With Vert.x you can choose the development model you prefer. In this report, we will use both callbacks and RxJava.\n\nLet’s Start Coding! It’s time for you to get your hands dirty. We are going to use Apache Maven and the Vert.x Maven plug-in to develop our first Vert.x application. However, you can use whichever tool you want (Gradle, Apache Maven with another packaging plug-in, or Apache Ant). You will find different examples in the code repository (in the packaging-examples directory). The code shown in this section is located in the hello-vertx directory.\n\nProject Creation Create a directory called my-first-vertx-app and move into this directory:\n\nmkdir my-first-vertx-app cd my-first-vertx-app\n\nThen, issue the following command:\n\nmvn io.fabric8:vertx-maven-plugin:1.0.5:setup \\ -DprojectGroupId=io.vertx.sample \\ -DprojectArtifactId=my-first-vertx-app \\ -Dverticle=io.vertx.sample.MyFirstVerticle\n\nThis command generates the Maven project structure, configures the vertx-maven-plugin, and creates a verticle class (io.vertx.sam ple.MyFirstVerticle), which does nothing.\n\nWrite Your First Verticle It’s now time to write the code for your first verticle. Modify the src/main/java/io/vertx/sample/MyFirstVerticle.java file with the following content:\n\nLet’s Start Coding!\n\n|\n\n17\n\npackage io.vertx.sample;\n\nimport io.vertx.core.AbstractVerticle;\n\n/** * A verticle extends the AbstractVerticle class. */ public class MyFirstVerticle extends AbstractVerticle {\n\n@Override public void start() throws Exception { // We create a HTTP server object vertx.createHttpServer() // The requestHandler is called for each incoming // HTTP request, we print the name of the thread .requestHandler(req -> { req.response().end(\"Hello from \" + Thread.currentThread().getName()); }) .listen(8080); // start the server on port 8080 } }\n\nTo run this application, launch:\n\nmvn compile vertx:run\n\nIf everything went fine, you should be able to see your application by opening http://localhost:8080 in a browser. The vertx:run goal launches the Vert.x application and also watches code alterations. So, if you edit the source code, the application will be automatically recompiled and restarted.\n\nLet’s now look at the application output:\n\nHello from vert.x-eventloop-thread-0\n\nThe request has been processed by the event loop 0. You can try to emit more requests. The requests will always be processed by the same event loop, enforcing the concurrency model of Vert.x. Hit Ctrl+C to stop the execution.\n\nUsing RxJava At this point, let’s take a look at the RxJava support provided by Vert.x to better understand how it works. In your pom.xml file, add the following dependency:\n\n18\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x\n\n<dependency> <groupId>io.vertx</groupId> <artifactId>vertx-rx-java</artifactId> </dependency>\n\nNext, change the <vertx.verticle> property to be io.vertx.sam ple.MyFirstRXVerticle. This property tells the Vert.x Maven plug- in which verticle is the entry point of the application. Create the new verticle class (io.vertx.sample.MyFirstRXVerticle) with the fol‐ lowing content:\n\npackage io.vertx.sample;\n\n// We use the .rxjava. package containing the RX-ified APIs import io.vertx.rxjava.core.AbstractVerticle; import io.vertx.rxjava.core.http.HttpServer;\n\npublic class MyFirstRXVerticle extends AbstractVerticle {\n\n@Override public void start() { HttpServer server = vertx.createHttpServer(); // We get the stream of request as Observable server.requestStream().toObservable() .subscribe(req -> // for each HTTP request, this method is called req.response().end(\"Hello from \" + Thread.currentThread().getName()) ); // We start the server using rxListen returning a // Single of HTTP server. We need to subscribe to // trigger the operation server .rxListen(8080) .subscribe(); } }\n\nThe RxJava variants of the Vert.x APIs are provided in packages with rxjava in their name. RxJava methods are prefixed with rx, such as rxListen. In addition, the APIs are enhanced with methods provid‐ ing Observable objects on which you can subscribe to receive the conveyed data.\n\nLet’s Start Coding!\n\n|\n\n19\n\nPackaging Your Application as a Fat Jar The Vert.x Maven plug-in packages the application in a fat jar. Once packaged, you can easily launch the application using java -jar <name>.jar:\n\nmvn clean package cd target java -jar my-first-vertx-app-1.0-SNAPSHOT.jar\n\nThe application is up again, listening for HTTP traffic on the port specified. Hit Ctrl+C to stop it.\n\nAs an unopinionated toolkit, Vert.x does not promote one packag‐ ing model over another—you are free to use the packaging model you prefer. For instance, you could use fat jars, a filesystem approach with libraries in a specific directory, or embed the applica‐ tion in a war file and start Vert.x programmatically.\n\nIn this report, we will use fat jars, i.e., self-contained JAR embedding the code of the application, its resources, as well as all of its depen‐ dencies. This includes Vert.x, the Vert.x components you are using, and their dependencies. This packaging model uses a flat class loader mechanism, which makes it easier to understand application startup, dependency ordering, and logs. More importantly, it helps reduce the number of moving pieces that need to be installed in pro‐ duction. You don’t deploy an application to an existing app server. Once it is packaged in its fat jar, the application is ready to run with a simple java -jar <name.jar>. The Vert.x Maven plug-in builds a fat jar for you, but you can use another Maven plug-in such as the maven-shader-plugin too.\n\nLogging, Monitoring, and Other Production Elements Having fat jar is a great packaging model for microservices and other types of applications as they simplify the deployment and launch. But what about the features generally offered by app servers that make your application production ready? Typically, we expect to be able to write and collect logs, monitor the application, push external configuration, add health checks, and so on.\n\nDon’t worry—Vert.x provides all these features. And because Vert.x is neutral, it provides several alternatives, letting you choose or implement your own. For example, for logging, Vert.x does not push a specific logging framework but instead allows you to use any log‐\n\n20\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x\n\nging framework you want, such as Apache Log4J 1 or 2, SLF4J, or even JUL (the JDK logging API). If you are interested in the mes‐ sages logged by Vert.x itself, the internal Vert.x logging can be con‐ figured to use any of these logging frameworks. Monitoring Vert.x applications is generally done using JMX. The Vert.x Dropwizard Metric module provides Vert.x metrics to JMX. You can also choose to publish these metrics to a monitoring server such as Prometheus (https://prometheus.io/) or CloudForms (https://www.redhat.com/en/ technologies/management/cloudforms).\n\nSummary In this chapter we learned about reactive microservices and Vert.x. You also created your first Vert.x application. This chapter is by no means a comprehensive guide and just provides a quick introduc‐ tion to the main concepts. If you want to go further on these topics, check out the following resources:\n\nReactive programming vs. Reactive systems\n\nThe Reactive Manifesto\n\nRxJava website\n\nReactive Programming with RxJava\n\nThe Vert.x website\n\nSummary\n\n|\n\n21\n\nCHAPTER 3 Building Reactive Microservices\n\nIn this chapter, we will build our first microservices with Vert.x. As most microservice systems use HTTP interactions, we are going to start with HTTP microservices. But because systems consist of mul‐ tiple communicating microservices, we will build another microser‐ vice that consumes the first one. Then, we will demonstrate why such a design does not completely embrace reactive microservices. Finally, we will implement message-based microservices to see how messaging improves the reactiveness.\n\nFirst Microservices In this chapter we are going to implement the same set of microser‐ vices twice. The first microservice exposes a hello service that we will call hello microservice. Another consumes this service twice (concur‐ rently). The consumer will be called hello consumer microservice. This small system illustrates not only how a service is served, but also how it is consumed. On the left side of Figure 3-1, the microser‐ vices are using HTTP interactions. The hello consumer microser‐ vice uses an HTTP client to invoke the hello microservice. On the right side, the hello consumer microservice uses messages to interact with the hello microservice. This difference impacts the reactiveness of the system.\n\n23\n\nFigure 3-1. The microservices implemented in this chapter using HTTP and message-based interactions\n\nIn the previous chapter, we saw two different ways to use Vert.x APIs: callbacks and RxJava. To illustrate the differences and help you find your preferred approach, the hello microservices are imple‐ mented using the callback-based development model, while the con‐ sumers are implemented using RxJava.\n\nImplementing HTTP Microservices Microservices often expose their API via HTTP and are consumed using HTTP requests. Let’s see how these HTTP interactions can be implemented with Vert.x. The code developed in this section is available in the microservices/hello-microservice-http direc‐ tory of the code repository.\n\nGetting Started Create a directory called hello-microservice-http and then gen‐ erate the project structure:\n\nmkdir hello-microservice-http cd hello-microservice-http\n\nmvn io.fabric8:vertx-maven-plugin:1.0.5:setup \\ -DprojectGroupId=io.vertx.microservice \\ -DprojectArtifactId=hello-microservice-http \\\n\n24\n\n|\n\nChapter 3: Building Reactive Microservices\n\nDverticle=io.vertx.book.http.HelloMicroservice \\ -Ddependencies=web\n\nThis command generates the Maven project and configures the Vert.x Maven plug-in. In addition, it adds the vertx-web depend‐ ency. Vert.x Web is a module that provides everything you need to build modern web applications on top of Vert.x.\n\nThe Verticle\n\nsrc/main/java/io/vertx/book/http/HelloMicroser\n\nOpen vice.java. The generated code of the verticle does nothing very interesting, but it’s a starting point:\n\npackage io.vertx.book.http;\n\nimport io.vertx.core.AbstractVerticle;\n\npublic class HelloMicroservice extends AbstractVerticle {\n\n@Override public void start() {\n\n} }\n\nNow, launch the following Maven command:\n\nmvn compile vertx:run\n\nYou can now edit the verticle. Every time you save the file, the appli‐ cation will be recompiled and restarted automatically.\n\nHTTP Microservice It’s time to make our MyVerticle class do something. Let’s start with an HTTP server. As seen in the previous chapter, to create an HTTP server with Vert.x you just use:\n\n@Override public void start() { vertx.createHttpServer() .requestHandler(req -> req.response() .end(\"hello\")) .listen(8080); }\n\nOnce added and saved, you should be able to see hello at http:// localhost:8080 in a browser. This code creates an HTTP server on\n\nImplementing HTTP Microservices\n\n|\n\n25\n\nport 8080 and registers a requestHandler that is invoked on each incoming HTTP request. For now, we just write hello in the response.\n\nUsing Routes and Parameters Many services are invoked through web URLs, so checking the path is crucial to knowing what the request is asking for. However, doing path checking in the requestHandler to implement different actions can get complicated. Fortunately, Vert.x Web provides a Router on which we can register Routes. Routes are the mechanism by which Vert.x Web checks the path and invokes the associated action. Let’s rewrite the start method, with two routes:\n\n@Override public void start() { Router router = Router.router(vertx); router.get(\"/\").handler(rc -> rc.response().end(\"hello\")); router.get(\"/:name\").handler(rc -> rc.response() .end(\"hello \" + rc.pathParam(\"name\")));\n\nvertx.createHttpServer() .requestHandler(router::accept) .listen(8080); }\n\nOnce we have created the Router object, we register two routes. The first one handles requests on / and just writes hello. The second route has a path parameter (:name). The handler appends the passed the value requestHandler of the HTTP server to use the accept method of the router.\n\nto\n\nthe greeting message. Finally, we change\n\nIf you didn’t stop the vertx:run execution, you should be able to open a browser to:\n\nhttp://localhost:8080—You should see hello • http://localhost:8080/vert.x—You should see hello vert.x\n\nProducing JSON JSON is often used in microservices. Let’s modify the previous class to produce JSON payloads:\n\n26\n\n|\n\nChapter 3: Building Reactive Microservices\n\n@Override public void start() { Router router = Router.router(vertx); router.get(\"/\").handler(this::hello); router.get(\"/:name\").handler(this::hello); vertx.createHttpServer() .requestHandler(router::accept) .listen(8080); }\n\nprivate void hello(RoutingContext rc) { String message = \"hello\"; if (rc.pathParam(\"name\") != null) { message += \" \" + rc.pathParam(\"name\"); } JsonObject json = new JsonObject().put(\"message\", message); rc.response() .putHeader(HttpHeaders.CONTENT_TYPE, \"application/json\") .end(json.encode()); }\n\nVert.x provides a JsonObject class to create and manipulate JSON structures. With this code in place, you should be able to open a browser to:\n\nhttp://localhost:8080—You should see {\"message\": \"hello\"}\n\nhttp://localhost:8080/vert.x—You \"hello vert.x\"}\n\nhttp://localhost:8080/vert.x—You \"hello vert.x\"}\n\nshould\n\nPackaging and Running Stop the vertx:run execution using Ctrl+C and execute the follow‐ ing command from the same directory:\n\nmvn package\n\nthe target directory: hello- This produces a microservice-http-1.0-SNAPSHOT.jar. While fat jars tend to be fat, here the JAR has a reasonable size (~6.3 MB) and contains everything to run the application:\n\nfat\n\njar\n\nin\n\njava -jar target/hello-microservice-http-1.0-SNAPSHOT.jar\n\nYou can check to make sure it is running by opening: http://local host:8080. Keep the process running as the next microservice will invoke it.\n\nImplementing HTTP Microservices\n\n|\n\n27",
      "page_number": 21
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 32-42)",
      "start_page": 32,
      "end_page": 42,
      "detection_method": "topic_boundary",
      "content": "Consuming HTTP Microservices One microservice does not form an application; you need a system of microservices. Now that we have our first microservice running, let’s write a second microservice to consume it. This second micro‐ service also provides an HTTP facade to invoke it, and on each invocation calls the microservice we just implemented. The code shown in this section is available in the microservices/hello- consumer-microservice-http directory of the code repository.\n\nProject Creation As usual, let’s create a new project:\n\nmkdir hello-consumer-microservice-http cd hello-consumer-microservice-http\n\nmvn io.fabric8:vertx-maven-plugin:1.0.5:setup \\ -DprojectGroupId=io.vertx.microservice \\ -DprojectArtifactId=hello-consumer-microservice-http \\ -Dverticle=io.vertx.book.http.HelloConsumerMicroservice \\ -Ddependencies=web,web-client,rx\n\nThe last command adds another dependency: the Vert.x web client, an asynchronous HTTP client. We will use this client to call the first microservice. The command has also added the Vert.x RxJava bind‐ ing we are going to use later.\n\nNow edit the src/main/java/io/vertx/book/http/HelloConsumer Microservice.java file and update it to contain:\n\npackage io.vertx.book.http;\n\nimport io.vertx.core.AbstractVerticle; import io.vertx.core.json.JsonObject; import io.vertx.ext.web.*; import io.vertx.ext.web.client.*; import io.vertx.ext.web.codec.BodyCodec;\n\npublic class HelloConsumerMicroservice extends AbstractVerticle {\n\nprivate WebClient client;\n\n@Override public void start() { client = WebClient.create(vertx);\n\nRouter router = Router.router(vertx);\n\n28\n\n|\n\nChapter 3: Building Reactive Microservices\n\nrouter.get(\"/\").handler(this::invokeMyFirstMicroservice);\n\nvertx.createHttpServer() .requestHandler(router::accept) .listen(8081); }\n\nprivate void invokeMyFirstMicroservice(RoutingContext rc) { HttpRequest<JsonObject> request = client .get(8080, \"localhost\",\"/vert.x\") .as(BodyCodec.jsonObject());\n\nrequest.send(ar -> { if (ar.failed()) { rc.fail(ar.cause()); } else { rc.response().end(ar.result().body().encode()); } }); }\n\n}\n\nIn the start method, we create a WebClient and a Router. On the created router, we register a route on “/” and start the HTTP server, passing the router accept method as requestHandler. The handler of the route is a method reference (hello). This method uses the web client to invoke the first microservice with a specific path (/ vert.x) and write the result to the HTTP response.\n\nOnce the HTTP request is created, we call send to emit the request. The handler we passed in is invoked when either the response arrives or an error occurs. The if-else block checks to see whether the invocation has succeeded. Don’t forget that it’s a remote interac‐ tion and has many reasons to fail. For instance, the first microser‐ vice may not be running. When it succeeds, we write the received payload to the response; otherwise, we reply with a 500 response.\n\nCalling the Service More Than Once Now let’s change the current behavior to call the hello microservice twice with two different (path) parameters:\n\nConsuming HTTP Microservices\n\n|\n\n29\n\nHttpRequest<JsonObject> request1 = client .get(8080, \"localhost\", \"/Luke\") .as(BodyCodec.jsonObject()); HttpRequest<JsonObject> request2 = client .get(8080, \"localhost\", \"/Leia\") .as(BodyCodec.jsonObject());\n\nThese two requests are independent and can be executed concur‐ rently. But here we want to write a response assembling both results. The code required to invoke the service twice and assemble the two results can become convoluted. We need to check to see whether or not the other request has been completed when we receive one of the responses. While this code would still be manageable for two requests, it becomes overly complex when we need to handle more. Fortunately, as noted in the previous chapter, we can use reactive programming and RxJava to simplify this code.\n\nWe instruct the vertx-maven-plugin to import the Vert.x RxJava API. In the HelloConsumerMicroservice, we replace the import statements with:\n\nimport io.vertx.core.json.JsonObject; import io.vertx.rxjava.core.AbstractVerticle; import io.vertx.rxjava.ext.web.*; import io.vertx.rxjava.ext.web.client.*; import io.vertx.rxjava.ext.web.codec.BodyCodec; import rx.Single;\n\nWith RX, the complex code we would have written to call the two requests and build a response out of them becomes much simpler:\n\nprivate void invokeMyFirstMicroservice(RoutingContext rc) { HttpRequest<JsonObject> request1 = client .get(8080, \"localhost\", \"/Luke\") .as(BodyCodec.jsonObject()); HttpRequest<JsonObject> request2 = client .get(8080, \"localhost\", \"/Leia\") .as(BodyCodec.jsonObject()); Single<JsonObject> s1 = request1.rxSend() .map(HttpResponse::body); Single<JsonObject> s2 = request2.rxSend() .map(HttpResponse::body); Single .zip(s1, s2, (luke, leia) -> { // We have the results of both requests in Luke and Leia return new JsonObject() .put(\"Luke\", luke.getString(\"message\")) .put(\"Leia\", leia.getString(\"message\")); }) .subscribe(\n\n30\n\n|\n\nChapter 3: Building Reactive Microservices\n\nresult -> rc.response().end(result.encodePrettily()), error -> { error.printStackTrace(); rc.response() .setStatusCode(500).end(error.getMessage()); } ); }\n\nNotice the rxSend method calls. The RxJava methods from Vert.x are prefixed with rx to be easily recognizable. The result of rxSend is a Single, i.e., an observable of one element representing the deferred result of an operation. The single.zip method takes as input a set of Single, and once all of them have received their value, calls a function with the results. Single.zip produces another Single containing the result of the function. Finally, we subscribe. This method takes two functions as parameters:\n\n1. The first one is called with the result of the zip function (a JSON object). We write the receive JSON payload into the HTTP response.\n\n2. The second one is called if something fails (timeout, exception, etc.). In this case, we respond with an empty JSON object.\n\nWith this code in place, if we open http://localhost:8081 and the hello microservice is still running we should see:\n\n{ \"Luke\" : \"hello Luke\", \"Leia\" : \"hello Leia\" }\n\nAre These Microservices Reactive Microservices? At this point we have two microservices. They are independent and can be deployed and updated at their own pace. They also interact using a lightweight protocol (HTTP). But are they reactive micro‐ services? No, they are not. Remember, to be called reactive a micro‐ service must be:\n\nAutonomous\n\nAsynchronous\n\nAre These Microservices Reactive Microservices?\n\n|\n\n31\n\nResilient\n\nElastic\n\nThe main issue with the current design is the tight coupling between the two microservices. The web client is configured to target the first microservice explicitly. If the first microservice fails, we won’t be able to recover by calling another one. If we are under load, creating a new instance of the hello microservice won’t help us. Thanks to the Vert.x web client, the interactions are asynchronous. However, as we don’t use a virtual address (destination) to invoke the microservice, but its direct URL, it does not provide the resilience and elasticity we need.\n\nIt’s important to note that using reactive programming as in the sec‐ ond microservice does not give you the reactive system’s benefits. It provides an elegant development model to coordinate asynchronous actions, but it does not provide the resilience and elasticity we need.\n\nCan we use HTTP for reactive microservices? Yes. But this requires some infrastructure to route virtual URLs to a set of services. We also need to implement a load-balancing strategy to provide elastic‐ ity and health-check support to improve resilience.\n\nDon’t be disappointed. In the next section we will take a big step toward reactive microservices.\n\nThe Vert.x Event Bus—A Messaging Backbone Vert.x offers an event bus allowing the different components of an application to interact using messages. Messages are sent to addresses and have a set of headers and a body. An address is an opaque string representing a destination. Message consumers register themselves to addresses to receive the messages. The event bus is also clustered, meaning it can dispatch messages over the network between dis‐ tributed senders and consumers. By starting a Vert.x application in cluster mode, nodes are connected to enable shared data structure, hard-stop failure detection, and load-balancing group communica‐ tion. The event bus can dispatch messages among all the nodes in the cluster. To create such a clustered configuration, you can use Apache Ignite, Apache Zookeeper, Infinispan, or Hazelcast. In this report, we are going to use Infinispan, but we won’t go into advanced configuration. For that, refer to the Infinispan documen‐ tation (http://infinispan.org/). While Infinispan (or the technology\n\n32\n\n|\n\nChapter 3: Building Reactive Microservices\n\nyou choose) manages the node discovery and inventory, the event bus communication uses direct peer-to-peer TCP connections.\n\nThe event bus provides three types of delivery semantics. First, the send method allows a component to send a message to an address. A single consumer is going to receive the message. If more than one consumer is registered on this address, Vert.x applies a round-robin strategy to select a consumer:\n\n// Consumer vertx.eventBus().consumer(\"address\", message -> { System.out.println(\"Received: '\" + message.body() + \"'\"); }); // Sender vertx.eventBus().send(\"address\", \"hello\");\n\nIn contrast to send, you can use the publish method to deliver the message to all consumers registered on the address. Finally, the send method can be used with a reply handler. This request/response mechanism allows implementing message-based asynchronous interactions between two components:\n\n// Consumer vertx.eventBus().consumer(\"address\", message -> { message.reply(\"pong\"); }); // Sender vertx.eventBus().send(\"address\", \"ping\", reply -> { if (reply.succeeded()) { System.out.println(\"Received: \" + reply.result().body()); } else { // No reply or failure reply.cause().printStackTrace(); } });\n\nIf you are using Rx-ified APIs, you can use the rxSend method, which returns a Single. This Single receives a value when the reply is received. We are going to see this method in action shortly.\n\nMessage-Based Microservices Let’s reimplement the hello microservice, this time using an event bus instead of an HTTP server to receive the request. The microser‐ vice replied to the message to provide the response.\n\nMessage-Based Microservices\n\n|\n\n33\n\nProject Creation Let’s create a new project. This time we are going to add the Infini‐ span dependency, an in-memory data grid that will be used to man‐ age the cluster:\n\nmkdir hello-microservice-message cd hello-microservice-message\n\nmvn io.fabric8:vertx-maven-plugin:1.0.5:setup \\ -DprojectGroupId=io.vertx.microservice \\ -DprojectArtifactId=hello-microservice-message \\ -Dverticle=io.vertx.book.message.HelloMicroservice \\ -Ddependencies=infinispan\n\nOnce generated, we may need to configure Infinispan to build the cluster. The default configuration uses multicast to discover the nodes. If your network supports multicast, it should be fine. Other‐ wise, check the resource/cluster directory of the code repository.\n\nWriting the Message-Driven Verticle Edit the src/main/java/io/vertx/book/message/HelloMicroser vice.java file and update the start method to be:\n\n@Override public void start() { // Receive message from the address 'hello' vertx.eventBus().<String>consumer(\"hello\", message -> { JsonObject json = new JsonObject() .put(\"served-by\", this.toString()); // Check whether we have received a payload in the // incoming message if (message.body().isEmpty()) { message.reply(json.put(\"message\", \"hello\")); } else { message.reply(json.put(\"message\", \"hello \" + message.body())); } }); }\n\nThis code retrieves the eventBus from the vertx object and registers a consumer on the address hello. When a message is received, it replies to it. Depending on whether or not the incoming message has an empty body, we compute a different response. As in the example in the previous chapter, we send a JSON object back. You may be wondering why we added the served-by entry in the JSON.\n\n34\n\n|\n\nChapter 3: Building Reactive Microservices\n\nYou’ll see why very soon. Now that the verticle is written, it’s time to launch it with:\n\nmvn compile vertx:run \\ -Dvertx.runArgs=\"-cluster -Djava.net.preferIPv4Stack=true\"\n\nThe -cluster tells Vert.x to start in cluster mode.\n\nNow let’s write a microservice consuming this service.\n\nInitiating Message-Based Interactions In this section, we will create another microservice to invoke the hello microservice by sending a message to the hello address and get a reply. The microservice will reimplement the same logic as in the previous chapter and invoke the service twice (once with Luke and once with Leia).\n\nAs usual, let’s create a new project:\n\nmkdir hello-consumer-microservice-message cd hello-consumer-microservice-message\n\nmvn io.fabric8:vertx-maven-plugin:1.0.5:setup \\ -DprojectGroupId=io.vertx.microservice \\ -DprojectArtifactId=hello-consumer-microservice-message \\ -Dverticle=io.vertx.book.message.HelloConsumerMicroservice \\ -Ddependencies=infinispan,rx\n\nHere we also add the Vert.x RxJava support to benefit from the RX- ified APIs provided by Vert.x. If you updated the Infinispan configu‐ ration in the previous section, you need to copy it to this new project.\n\nNow edit the io.vertx.book.message.HelloConsumerMicroser vice. Since we are going to use RxJava, change the import statement to match io.vertx.rxjava.core.AbstractVerticle. Then imple‐ ment the start method with:\n\n@Override public void start() { EventBus bus = vertx.eventBus(); Single<JsonObject> obs1 = bus .<JsonObject>rxSend(\"hello\", \"Luke\") .map(Message::body); Single<JsonObject> obs2 = bus .<JsonObject>rxSend(\"hello\", \"Leia\") .map(Message::body);\n\nInitiating Message-Based Interactions\n\n|\n\n35\n\nSingle .zip(obs1, obs2, (luke, leia) -> new JsonObject() .put(\"Luke\", luke.getString(\"message\")) .put(\"Leia\", leia.getString(\"message\")) ) .subscribe( x -> System.out.println(x.encode()), Throwable::printStackTrace); }\n\nThis code is very similar to the code from the previous chapter. Instead of using a WebClient to invoke an HTTP endpoint, we will use the event bus to send a message to the hello address and extract the body of the reply. We use the zip operation to retrieve the two responses and build the final result. In the subscribe method, we print the final result to the console or print the stack trace.\n\nLet’s combine this with an HTTP server. When an HTTP request is received, we invoke the hello service twice and return the built result as a response:\n\n@Override public void start() { vertx.createHttpServer() .requestHandler( req -> { EventBus bus = vertx.eventBus(); Single<JsonObject> obs1 = bus .<JsonObject>rxSend(\"hello\", \"Luke\") .map(Message::body); Single<JsonObject> obs2 = bus .<JsonObject>rxSend(\"hello\", \"Leia\") .map(Message::body);\n\nSingle .zip(obs1, obs2, (luke, leia) -> new JsonObject() .put(\"Luke\", luke.getString(\"message\") + \" from \" + luke.getString(\"served-by\")) .put(\"Leia\", leia.getString(\"message\") + \" from \" + leia.getString(\"served-by\")) ) .subscribe( x -> req.response().end(x.encodePrettily()), t -> { t.printStackTrace(); req.response().setStatusCode(500)\n\n36\n\n|\n\nChapter 3: Building Reactive Microservices\n\n.end(t.getMessage()); } ); }) .listen(8082); }\n\nThe last code just wraps the event bus interactions into a requestHandler and deals with the HTTP response. In case of fail‐ ure, we return a JSON object containing an error message.\n\ncode with mvn compile vertx:run If -Dvertx.runArgs=\"-cluster -Djava.net.preferIPv4Stack=true\" and open your browser to http://localhost:8082, you should see something like:\n\nyou\n\nrun\n\nthis\n\n{ \"Luke\" : \"hello Luke from ...HelloMicroservice@39721ab\", \"Leia\" : \"hello Leia from ...HelloMicroservice@39721ab\" }\n\nAre We Reactive Now? The code is very close to the HTTP-based microservice we wrote previously. The only difference is we used an event bus instead of HTTP. Does this change our reactiveness? It does! Let’s see why.\n\nElasticity Elasticity is one of the characteristics not enforced by the HTTP ver‐ sion of the microservice. Because the microservice was targeting a specific instance of the microservice (using a hard-coded URL), it didn’t provide the elasticity we need. But now that we are using mes‐ sages sent to an address, this changes the game. Let’s see how this microservice system behaves.\n\nRemember the output of the previous execution. The returned JSON objects display the verticle having computed the hello mes‐ sage. The output always displays the same verticle. The message was indicating the same instance. We expected this because we had a sin‐ gle instance running. Now let’s see what happens with two.\n\nStop the vertx:run execution of the Hello microservice and run:\n\nmvn clean package\n\nAre We Reactive Now?\n\n|\n\n37\n\nThen, open two different terminals in the hello-microservice- message directory and issue the following command (in each termi‐ nal):\n\njava -jar target/hello-microservice-message-1.0-SNAPSHOT.jar \\ --cluster -Djava.net.preferIPv4Stack=true\n\nThis launches two instances of the Hello microservice. Go back to your browser and refresh the page and you should see something like:\n\n{ \"Luke\" : \"hello Luke from ...HelloMicroservice@16d0d069\", \"Leia\" : \"hello Leia from ...HelloMicroservice@411fc4f\" }\n\nThe two instances of Hello are used. The Vert.x cluster connects the different nodes, and the event bus is clustered. Thanks to the event bus round-robin, the Vert.x event bus dispatches messages to the available instances and thus balances the load among the different nodes listening to the same address.\n\nSo, by using the event bus, we have the elasticity characteristic we need.\n\nResilience What about resilience? In the current code, if the hello microservice failed, we would get a failure and execute this code:\n\nt -> { t.printStackTrace(); req.response().setStatusCode(500).end(t.getMessage()); }\n\nEven though the user gets an error message, we don’t crash, we don’t limit our scalability, and we can still handle requests. However, to improve the user experience, we should always reply in a timely fashion to the user, even if we don’t receive the responses from the service. To implement this logic, we can enhance the code with a timeout.\n\nTo illustrate this, let’s modify the Hello microservice to inject fail‐ ures and misbehaviors. This code is located in the microservices/ hello-microservice-faulty directory of the code repository.\n\n38\n\n|\n\nChapter 3: Building Reactive Microservices",
      "page_number": 32
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 43-53)",
      "start_page": 43,
      "end_page": 53,
      "detection_method": "topic_boundary",
      "content": "This new start method randomly selects one of three strategies: (1) reply with an explicit failure, (2) forget to reply (leading to a timeout on the consumer side), or (3) send the correct result.\n\n@Override public void start() { vertx.eventBus().<String>consumer(\"hello\", message -> { double chaos = Math.random(); JsonObject json = new JsonObject() .put(\"served-by\", this.toString());\n\nif (chaos < 0.6) { // Normal behavior if (message.body().isEmpty()) { message.reply(json.put(\"message\", \"hello\")); } else { message.reply(json.put(\"message\", \"hello \" + message.body())); } } else if (chaos < 0.9) { System.out.println(\"Returning a failure\"); // Reply with a failure message.fail(500, \"message processing failure\"); } else { System.out.println(\"Not replying\"); // Just do not reply, leading to a timeout on the // consumer side. } }); }\n\nRepackage and restart the two instances of the Hello microservice.\n\nWith this fault injection in place, we need to improve the fault- tolerance of our consumer. Indeed, the consumer may get a timeout or receive an explicit failure. In the hello consumer microservice, change how we invoke the hello service to:\n\nEventBus bus = vertx.eventBus(); Single<JsonObject> obs1 = bus .<JsonObject>rxSend(\"hello\", \"Luke\") .subscribeOn(RxHelper.scheduler(vertx)) .timeout(3, TimeUnit.SECONDS) .retry() .map(Message::body); Single<JsonObject> obs2 = bus. <JsonObject>rxSend(\"hello\", \"Leia\") .subscribeOn(RxHelper.scheduler(vertx)) .timeout(3, TimeUnit.SECONDS)\n\nAre We Reactive Now?\n\n|\n\n39\n\n.retry() .map(Message::body);\n\nlocated in the microservices/hello-consumer- This code is microservice-timeout directory of the code repository. The time out method emits a failure if we don’t receive a response in the given time. The retry method reattempts to retrieve the value if it gets a failure in the form of a timeout or an explicit failure. The subscribeOn method indicates on which thread the invocations need to be done. We use the Vert.x event loop to call our callbacks. Without this, the methods would be executed by a thread from the default RxJava thread pool, breaking the Vert.x threading model. The RXHelper class is provided by Vert.x. Blindly retrying service invocations is not a very clever fault tolerance strategy. It can even be harmful. The next chapter details different approaches.\n\nNow you can reload the page. You will always get a result, even if there are failures or timeouts. Remember that the thread is not blocked while calling the service, so you can always accept new requests and respond to them in a timely fashion. However, this timeout retry often causes more harm than good, as we will see in the next chapter.\n\nSummary In this section, we learned how to develop an HTTP microservice with Vert.x and also how to consume it. As we learned, hard-coding the URL of the consumed service in the code is not a brilliant idea as it breaks one of the reactive characteristics. In the second part, we replaced the HTTP interactions using messaging, which showed how messaging and the Vert.x event bus help build reactive micro‐ services.\n\nSo, are we there yet? Yes and no. Yes, we know how to build reactive microservices, but there are a couple of shortcomings we need to look at. First, what if you only have HTTP services? How do you avoid hard-coded locations? What about resilience? We have seen timeouts and retries in this chapter, but what about circuit breakers, failovers, and bulkheads? Let’s continue the journey.\n\n40\n\n|\n\nChapter 3: Building Reactive Microservices\n\nIf you want to go further on these topics:\n\nVert.x Web documentation\n\nVert.x Web Client documentation\n\nVert.x reactive microservices\n\nSummary\n\n|\n\n41\n\nCHAPTER 4 Building Reactive Microservice Systems\n\nThe previous chapter focused on building microservices, but this chapter is all about building systems. Again, one microservice doesn’t make a service—they come in systems. When you embrace the microservice architectural style, you will have dozens of micro‐ services. Managing two microservices, as we did in the last chapter, is easy. The more microservices you use, the more complex the application becomes.\n\nFirst, we will learn how service discovery can be used to address location transparency and mobility. Then, we will discuss resilience and stability patterns such as timeouts, circuit breakers, and fail- overs.\n\nService Discovery When you have a set of microservices, the first question you have to answer is: how will these microservices locate each other? In order to communicate with another peer, a microservice needs to know its address. As we did in the previous chapter, we could hard-code the address (event bus address, URLs, location details, etc.) in the code or have it externalized into a configuration file. However, this solu‐ tion does not enable mobility. Your application will be quite rigid and the different pieces won’t be able to move, which contradicts what we try to achieve with microservices.\n\n43\n\nClient- and Server-Side Service Discovery Microservices need to be mobile but addressable. A consumer needs to be able to communicate with a microservice without knowing its exact location in advance, especially since this location may change over time. Location transparency provides elasticity and dynamism: the consumer may call different instances of the microservice using a round-robin strategy, and between two invocations the microser‐ vice may have been moved or updated.\n\nLocation transparency can be addressed by a pattern called service discovery. Each microservice should announce how it can be invoked and its characteristics, including its location of course, but also other metadata such as security policies or versions. These announcements are stored in the service discovery infrastructure, which is generally a service registry provided by the execution envi‐ ronment. A microservice can also decide to withdraw its service from the registry. A microservice looking for another service can also search this service registry to find matching services, select the best one (using any kind of criteria), and start using it. These inter‐ actions are depicted in Figure 4-1.\n\nFigure 4-1. Interactions with the service registry\n\nTwo types of patterns can be used to consume services. When using client-side service discovery, the consumer service looks for a service based on its name and metadata in the service registry, selects a matching service, and uses it. The reference retrieved from the ser‐ vice registry contains a direct link to a microservice. As microservi‐ ces are dynamic entities, the service discovery infrastructure must not only allow providers to publish their services and consumers to look for services, but also provide information about the arrivals and\n\n44\n\n|\n\nChapter 4: Building Reactive Microservice Systems\n\ndepartures of services. When using client-side service discovery, the service registry can take various forms such as a distributed data structure, a dedicated infrastructure such as Consul, or be stored in an inventory service such as Apache Zookeeper or Redis.\n\nAlternatively, you can use server-side service discovery and let a load balancer, a router, a proxy, or an API gateway manage the discovery for you (Figure 4-2). The consumer still looks for a service based on its name and metadata but retrieves a virtual address. When the consumer invokes the service, the request is routed to the actual implementation. You would use this mechanism on Kubernetes or when using AWS Elastic Load Balancer.\n\nFigure 4-2. Server-side service discovery\n\nVert.x Service Discovery Vert.x provides an extensible service discovery mechanism. You can use client-side or server-side service discovery using the same API. The Vert.x service discovery can import or export services from many types of service discovery infrastructures such as Consul or Kubernetes (Figure 4-3). It can also be used without any dedicated service discovery infrastructure. In this case, it uses a distributed data structure shared on the Vert.x cluster.\n\nService Discovery\n\n|\n\n45\n\nFigure 4-3. Import and export of services from and to other service dis‐ covery mechanisms\n\nYou can retrieve services by types to get a configured service client ready to be used. A service type can be an HTTP endpoint, an event bus address, a data source, and so on. For example, if you want to retrieve the HTTP endpoint named hello that we implemented in the previous chapter, you would write the following code:\n\n// We create an instance of service discovery ServiceDiscovery discovery = ServiceDiscovery.create(vertx); // As we know we want to use an HTTP microservice, we can // retrieve a WebClient already configured for the service HttpEndpoint .rxGetWebClient(discovery, // This method is a filter to select the service rec -> rec.getName().endsWith(\"hello\") ) .flatMap(client -> // We have retrieved the WebClient, use it to call // the service client.get(\"/\").as(BodyCodec.string()).rxSend()) .subscribe(response -> System.out.println(response.body()));\n\nThe retrieved WebClient is configured with the service location, which means you can immediately use it to call the service. If your environment is using client-side discovery, the configured URL tar‐ gets a specific instance of the service. If you are using server-side discovery, the client uses a virtual URL.\n\nDepending on your runtime infrastructure, you may have to register your service. But when using server-side service discovery, you usu‐\n\n46\n\n|\n\nChapter 4: Building Reactive Microservice Systems\n\nally don’t have to do this since you declare your service when it is deployed. Otherwise, you need to publish your service explicitly. To publish a service, you need to create a Record containing the service name, location, and metadata:\n\n// We create the service discovery object ServiceDiscovery discovery = ServiceDiscovery.create(vertx); vertx.createHttpServer() .requestHandler(req -> req.response().end(\"hello\")) .rxListen(8083) .flatMap( // Once the HTTP server is started (we are ready to serve) // we publish the service. server -> { // We create a record describing the service and its // location (for HTTP endpoint) Record record = HttpEndpoint.createRecord( \"hello\", // the name of the service \"localhost\", // the host server.actualPort(), // the port \"/\" // the root of the endpoint ); // We publish the service return discovery.rxPublish(record); } ) .subscribe(rec -> System.out.println(\"Service published\"));\n\nService discovery is a key component in a microservice infrastruc‐ ture. It enables dynamism, location transparency, and mobility. When dealing with a small set of services, service discovery may look cumbersome, but it’s a must-have when your system grows. The Vert.x service discovery provides you with a unique API regard‐ less of the infrastructure and the type of service discovery you use. However, when your system grows, there is also another variable that grows exponentially—failures.\n\nStability and Resilience Patterns When dealing with distributed systems, failures are first-class citi‐ zens and you have to live with them. Your microservices must be aware that the services they invoke can fail for many reasons. Every interaction between microservices will eventually fail in some way, and you need to be prepared for that failure. Failure can take differ‐ ent forms, ranging from various network errors to semantic errors.\n\nStability and Resilience Patterns\n\n|\n\n47\n\nManaging Failures in Reactive Microservices Reactive microservices are responsible for managing failures locally. They must avoid propagating the failure to another microservice. In other words, you should not delegate the hot potato to another microservice. Therefore, the code of a reactive microservice consid‐ ers failures as first-class citizens.\n\nThe Vert.x development model makes failures a central entity. When using the callback development model, the Handlers often receive an AsyncResult as a parameter. This structure encapsulates the result of an asynchronous operation. In the case of success, you can retrieve the result. On failure, it contains a Throwable describing the failure:\n\nclient.get(\"/\").as(BodyCodec.jsonObject()) .send(ar -> { if (ar.failed()) { Throwable cause = ar.cause(); // You need to manage the failure. } else { // It's a success JsonObject json = ar.result().body(); } });\n\nWhen using the RxJava APIs, the failure management can be made in the subscribe method:\n\nclient.get(\"/\").as(BodyCodec.jsonObject()) .rxSend() .map(HttpResponse::body) .subscribe( json -> { /* success */ }, err -> { /* failure */ } );\n\nIf a failure is produced in one of the observed streams, the error handler is called. You can also handle the failure earlier, avoiding the error handler in the subscribe method:\n\nclient.get(\"/\").as(BodyCodec.jsonObject()) .rxSend() .map(HttpResponse::body) .onErrorReturn(t -> { // Called if rxSend produces a failure // We can return a default value return new JsonObject(); })\n\n48\n\n|\n\nChapter 4: Building Reactive Microservice Systems\n\n.subscribe( json -> { // Always called, either with the actual result // or with the default value. } );\n\nManaging errors is not fun but it has to be done. The code of a reac‐ tive microservice is responsible for making an adequate decision when facing a failure. It also needs to be prepared to see its requests to other microservices fail.\n\nUsing Timeouts When dealing with distributed interactions, we often use timeouts. A timeout is a simple mechanism that allows you to stop waiting for a response once you think it will not come. Well-placed timeouts provide failure isolation, ensuring the failure is limited to the micro‐ service it affects and allowing you to handle the timeout and con‐ tinue your execution in a degraded mode.\n\nclient.get(path) .rxSend() // Invoke the service // We need to be sure to use the Vert.x event loop .subscribeOn(RxHelper.scheduler(vertx)) // Configure the timeout, if no response, it publishes // a failure in the Observable .timeout(5, TimeUnit.SECONDS) // In case of success, extract the body .map(HttpResponse::bodyAsJsonObject) // Otherwise use a fallback result .onErrorReturn(t -> { // timeout or another exception return new JsonObject().put(\"message\", \"D'oh! Timeout\"); }) .subscribe( json -> { System.out.println(json.encode()); } );\n\nTimeouts are often used together with retries. When a timeout occurs, we can try again. Immediately retrying an operation after a failure has a number of effects, but only some of them are beneficial. If the operation failed because of a significant problem in the called microservice, it is likely to fail again if retried immediately. How‐ ever, some kinds of transient failures can be overcome with a retry,\n\nStability and Resilience Patterns\n\n|\n\n49\n\nespecially network failures such as dropped messages. You can decide whether or not to reattempt the operation as follows:\n\nclient.get(path) .rxSend() .subscribeOn(RxHelper.scheduler(vertx)) .timeout(5, TimeUnit.SECONDS) // Configure the number of retries // here we retry only once. .retry(1) .map(HttpResponse::bodyAsJsonObject) .onErrorReturn(t -> { return new JsonObject().put(\"message\", \"D'oh! Timeout\"); }) .subscribe( json -> System.out.println(json.encode()) );\n\nIt’s also important to remember that a timeout does not imply an operation failure. In a distributed system, there are many reasons for failure. Let’s look at an example. You have two microservices, A and B. A is sending a request to B, but the response does not come in time and A gets a timeout. In this scenario, three types of failure could have occurred:\n\n1. The message between A and B has been lost—the operation is not executed.\n\n2. The operation in B failed—the operation has not completed its execution.\n\n3. The response message between B and A has been lost—the operation has been executed successfully, but A didn’t get the response.\n\nThis last case is often ignored and can be harmful. In this case, com‐ bining the timeout with a retry can break the integrity of the system. Retries can only be used with idempotent operations, i.e., with oper‐ ations you can invoke multiple times without changing the result beyond the initial call. Before using a retry, always check that your system is able to handle reattempted operations gracefully.\n\nRetry also makes the consumer wait even longer to get a response, which is not a good thing either. It is often better to return a fallback than to retry an operation too many times. In addition, continually hammering a failing service may not help it get back on track. These\n\n50\n\n|\n\nChapter 4: Building Reactive Microservice Systems",
      "page_number": 43
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 54-62)",
      "start_page": 54,
      "end_page": 62,
      "detection_method": "topic_boundary",
      "content": "two concerns are managed by another resilience pattern: the circuit breaker.\n\nCircuit Breakers A circuit breaker is a pattern used to deal with repetitive failures. It protects a microservice from calling a failing service again and again. A circuit breaker is a three-state automaton that manages an interaction (Figure 4-4). It starts in a closed state in which the circuit breaker executes operations as usual. If the interaction succeeds, nothing happens. If it fails, however, the circuit breaker makes a note of the failure. Once the number of failures (or frequency of fail‐ ures, in more sophisticated cases) exceeds a threshold, the circuit breaker switches to an open state. In this state, calls to the circuit breaker fail immediately without any attempt to execute the under‐ lying interaction. Instead of executing the operation, the circuit breaker may execute a fallback, providing a default result. After a configured amount of time, the circuit breaker decides that the operation has a chance of succeeding, so it goes into a half-open state. In this state, the next call to the circuit breaker executes the underlying interaction. Depending on the outcome of this call, the circuit breaker resets and returns to the closed state, or returns to the open state until another timeout elapses.\n\nFigure 4-4. Circuit breaker states\n\nThe most well-known circuit breaker implementation in Java is Hys‐ trix (https://github.com/Netflix/Hystrix). While you can use Hystrix in a Vert.x microservice (it uses a thread pool), you need to explic‐ itly switch to the Vert.x event loop to execute the different callbacks. Alternatively, you can use the Vert.x circuit breaker built for asyn‐ chronous operations and enforce the Vert.x nonblocking asynchro‐ nous development model.\n\nStability and Resilience Patterns\n\n|\n\n51\n\nLet’s imagine a failing hello microservice. The consumer should pro‐ tect the interactions with this service and use a circuit breaker as fol‐ lows:\n\nCircuitBreaker circuit = CircuitBreaker.create(\"my-circuit\", vertx, new CircuitBreakerOptions() .setFallbackOnFailure(true) // Call the fallback // on failures .setTimeout(2000) // Set the operation timeout .setMaxFailures(5) // Number of failures before // switching to // the 'open' state .setResetTimeout(5000) // Time before attempting // to reset // the circuit breaker ); // ... circuit.rxExecuteCommandWithFallback( future -> client.get(path) .rxSend() .map(HttpResponse::bodyAsJsonObject) .subscribe(future::complete, future::fail), t -> new JsonObject().put(\"message\", \"D'oh! Fallback\") ).subscribe( json -> { // Get the actual json or the fallback value System.out.println(json.encode()); } );\n\nIn this code, the HTTP interaction is protected by the circuit breaker. When the number of failures reaches the configured thres‐ hold, the circuit breaker will stop calling the microservice and instead call a fallback. Periodically, the circuit breaker will let one invocation pass through to check whether the microservice is back on track and act accordingly. This example uses a web client, but any interaction can be managed with a circuit breaker and protect you against flaky services, exceptions, and other sorts of failures.\n\nA circuit breaker switching to an open state needs to be monitored by your operations team. Both Hystrix and the Vert.x circuit breaker have monitoring capabilities.\n\n52\n\n|\n\nChapter 4: Building Reactive Microservice Systems\n\nHealth Checks and Failovers While timeouts and circuit breakers allow consumers to deal with failures on their side, what about crashes? When facing a crash, a failover strategy restarts the parts of the system that have failed. But before being able to achieve this, we must be able to detect when a microservice has died.\n\nA health check is an API provided by a microservice indicating its state. It tells the caller whether or not the service is healthy. The invocation often uses HTTP interactions but is not necessary. After invocation, a set of checks is executed and the global state is compu‐ ted and returned. When a microservice is detected to be unhealthy, it should not be called anymore, as the outcome is probably going to be a failure. Note that calling a healthy microservice does not guar‐ antee a success either. A health check merely indicates that the microservice is running, not that it will accurately handle your request or that the network will deliver its answer.\n\nDepending on your environment, you may have different levels of health checks. For instance, you may have a readiness check used at deployment time to determine when the microservice is ready to serve requests (when everything has been initialized correctly). Liv‐ eness checks are used to detect misbehaviors and indicate whether the microservice is able to handle requests successfully. When a liv‐ eness check cannot be executed because the targeted microservice does not respond, the microservice has probably crashed.\n\nIn a Vert.x application, there are several ways to implement health checks. You can simply implement a route returning the state, or even use a real request. You can also use the Vert.x health check module to implement several health checks in your application and compose the different outcomes. The following code gives an exam‐ ple of an application providing two levels of health checks:\n\nRouter router = Router.router(vertx); HealthCheckHandler hch = HealthCheckHandler.create(vertx); // A procedure to check if we can get a database connection hch.register(\"db-connection\", future -> { client.rxGetConnection() .subscribe(c -> { future.complete(); c.close(); }, future::fail\n\nStability and Resilience Patterns\n\n|\n\n53\n\n); }); // A second (business) procedure hch.register(\"business-check\", future -> { // ... }); // Map /health to the health check handler router.get(\"/health\").handler(hch); // ...\n\nAfter you have completed health checks, you can implement a fail- over strategy. Generally, the strategy just restarts the dead part of the system, hoping for the best. While failover is often provided by your runtime infrastructure, Vert.x offers a built-in failover, which is trig‐ gered when a node from the cluster dies. With the built-in Vert.x failover, you don’t need a custom health check as the Vert.x cluster pings nodes periodically. When Vert.x loses track of a node, Vert.x chooses a healthy node of the cluster and redeploys the dead part.\n\nFailover keeps your system running but won’t fix the root cause— that’s your job. When an application dies unexpectedly, a postmor‐ tem analysis should be done.\n\nSummary This chapter has addressed several concerns you will face when your microservice system grows. As we learned, service discovery is a must-have in any microservice system to ensure location transpar‐ ency. Then, because failures are inevitable, we discussed a couple of patterns to improve the resilience and stability of your system.\n\nVert.x includes a pluggable service discovery infrastructure that can handle client-side service discovery and server-side service discov‐ ery using the same API. The Vert.x service discovery is also able to import and export services from and to different service discovery infrastructures. Vert.x includes a set of resilience patterns such as timeout, circuit breaker, and failover. We saw different examples of these patterns. Dealing with failure is, unfortunately, part of the job and we all have to do it.\n\nIn the next chapter, we will learn how to deploy Vert.x reactive microservices on OpenShift and illustrate how service discovery, circuit breakers, and failover can be used to make your system almost bulletproof. While these topics are particularly important, don’t underestimate the other concerns that need to be handled\n\n54\n\n|\n\nChapter 4: Building Reactive Microservice Systems\n\nwhen dealing with microservices, such as security, deployment, aggregated logging, testing, etc.\n\nIf you want to learn more about these topics, check the following resources:\n\nReactive Microservices Architecture\n\nThe Vert.x service discovery documentation\n\nRelease It! Design and Deploy Production-Ready Software (O’Reilly) A book providing a list of recipes to make your sys‐ tem ready for production\n\nNetflix Hystrix\n\nThe Vert.x service circuit breaker documentation\n\nSummary\n\n|\n\n55\n\nCHAPTER 5 Deploying Reactive Microservices in OpenShift\n\nSo far, we have only deployed our microservices on a local machine. What happens when we deploy a microservice on the cloud? Most cloud platforms include services to make your deployment and operations easier. The ability to scale up and down and load balance are some of the commonly found features that are particularly rele‐ vant to developing reactive microservices. In this chapter, we will see how these features (and others) can be used to develop and deploy reactive microservices.\n\nTo illustrate these benefits, we will use OpenShift (https://www.open shift.org/). However, most modern cloud platforms include the fea‐ tures we use here. By the end of this chapter, you will see how the cloud makes reactiveness easy for everyone.\n\nWhat Is OpenShift? RedHat OpenShift v3 is an open source container platform. With OpenShift you deploy applications running in containers, which makes their construction and administration easy. OpenShift is built on top of Kubernetes (https://kubernetes.io/).\n\nKubernetes (in blue in Figure 5-1) is a project with lots of function‐ ality for running clusters of microservices inside Linux containers at scale. Google has packaged over a decade of experience with con‐ tainers into Kubernetes. OpenShift is built on top of this experience\n\n57\n\nand extends it with build and deployment automation (in green in Figure 5-1). Use cases such as rolling updates, canary deployments, and continuous delivery pipelines are provided out of the box.\n\nFigure 5-1. The OpenShift container platform\n\nOpenShift has a handful of simple entities, as depicted in Figure 5-2, that we need to understand before putting it to work.\n\n58\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift\n\nFigure 5-2. The OpenShift entities\n\nBuild Configuration The build is the process of creating container images that will be used by OpenShift to instantiate the different containers that make up an application. OpenShift builds can use different strategies:\n\nDocker—Build an image from a Dockerfile\n\nSource to Image (S2I)—Build an image from the application source, built on OpenShift by a builder image\n\nJenkins Pipeline—Build an image using a Jenkins pipeline (https://jenkins.io/doc/book/pipeline) potentially containing mul‐ tiple stages such as build, tests, and deployment\n\nA build configuration can be triggered automatically by a git push, a change in the configuration or an update in a dependent image, and, obviously, manually.\n\nDeployment Configurations A deployment configuration defines the instantiation of the image produced by a build. It defines which image is used to create the containers and the number of instances we need to keep alive. It also describes when a deployment should be triggered. A deployment also acts as a replication controller and is responsible for keeping containers alive. To achieve this, you pass the number of desired instances. The number of desired instances can be adjusted over time or based on the load fluctuation (auto-scaling). The deployment\n\nWhat Is OpenShift?\n\n|\n\n59\n\ncan also specify health checks to manage rolling updates and detect dead containers.\n\nPods A pod is a group of one or more containers. However, it is typically comprised of a single container. The pod orchestration, scheduling, and management are delegated to Kubernetes. Pods are fungible, and can be replaced at any time by another instance. For example, if the container crashes, another instance will be spawned.\n\nServices and Routes Because pods are dynamic entities (the number of instances can change over time), we cannot rely on their direct IP addresses (each pod has its own IP address). Services allow us to communicate with the pods without relying on their addresses but by using the service virtual address. A service acts as a proxy in front of a group of pods. It may also implement a load-balancing strategy.\n\nOther applications running in OpenShift can access the functional‐ ity offered by the pods using the service, but external applications need a route. A route exposes a service at a hostname like www.myservice.com so that external clients can reach it by name.\n\nInstalling OpenShift on Your Machine That’s enough abstract concepts. Now it’s time for action. We are going to install Openshift on your machine using Minishift (https:// github.com/minishift/minishift). Alternatively, you can use Open‐ Shift Online (https://www.openshift.com/devpreview/) or the Red Hat Container Development Kit v3 (https://developers.redhat.com/ products/cdk/download/).\n\nInstalling Minishift (https://github.com/minishift/minishift#installa tion) requires a hypervisor to run the virtual machine containing OpenShift. Depending on your host OS, you have a choice of hyper‐ visors; check the Minishift installation guide for details.\n\nTo install Minishift, just download the latest archive for your OS from the Minishift releases page (https://github.com/minishift/minis hift/releases), unpack it to your preferred location, and add the\n\n60\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift",
      "page_number": 54
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 63-72)",
      "start_page": 63,
      "end_page": 72,
      "detection_method": "topic_boundary",
      "content": "minishift binary to your PATH environment variable. Once installed, start Minishift using:\n\nminishift start\n\nOnce started, you should be able to connect to your OpenShift instance on https://192.168.64.12:8443. You may have to validate the SSL certificate. Log in with developer/developer.\n\nWe also need the OpenShift client (oc), a command-line utility used to interact with your OpenShift instance. Download the latest ver‐ sion of the OpenShift client from https://github.com/openshift/ origin/releases/latest. Unpack it to your preferred location and add the oc binary to your PATH environment variable.\n\nThen, connect to your OpenShift instance using:\n\noc login https://192.168.64.12:8443 -u developer -p developer\n\nOpenShift has a namespace concept called project. To create projects for the examples we are going to deploy, execute:\n\noc new-project reactive-microservices oc policy add-role-to-user admin developer -n reactive-microservices oc policy add-role-to-user view -n reactive-microservices -z default\n\nIn your browser, open https://192.168.64.12:8443/console/project/ reactive-microservices/. You should be able to see the project, which is not very interesting at the moment as we haven’t deployed any‐ thing (Figure 5-3).\n\nFigure 5-3. The created project\n\nInstalling OpenShift on Your Machine\n\n|\n\n61\n\nDeploying a Microservice in OpenShift It’s time to deploy a microservice to OpenShift. The code we are the openshift/hello- going microservice-openshift directory of the code repository. The ver‐ ticle is very close to the hello microservice (HTTP) we developed earlier:\n\nto deploy\n\nis contained\n\nin\n\npackage io.vertx.book.openshift;\n\nimport io.vertx.core.AbstractVerticle; import io.vertx.core.http.HttpHeaders; import io.vertx.core.json.JsonObject; import io.vertx.ext.web.*;\n\npublic class HelloHttpVerticle extends AbstractVerticle {\n\nstatic final String HOSTNAME = System.getenv(\"HOSTNAME\");\n\n@Override public void start() { Router router = Router.router(vertx); router.get(\"/\").handler(this::hello); router.get(\"/:name\").handler(this::hello); vertx.createHttpServer() .requestHandler(router::accept) .listen(8080); }\n\nprivate void hello(RoutingContext rc) { String message = \"hello\"; if (rc.pathParam(\"name\") != null) { message += \" \" + rc.pathParam(\"name\"); } JsonObject json = new JsonObject() .put(\"message\", message) .put(\"served-by\", HOSTNAME); rc.response() .putHeader(HttpHeaders.CONTENT_TYPE, \"application/json\") .end(json.encode()); } }\n\nThis code does not rely on specific OpenShift APIs or constructs. It’s your application as you would have developed it on your machine. The separation of Java code from deployment choices must be a deliberate design choice to make the code runnable on any cloud platform.\n\n62\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift\n\nWe could create all the OpenShift entities manually, but let’s use the Maven plug-in (https://maven.fabric8.io/) provided by Fabric8, an end-to-end development platform for Kubernetes. If you open the pom.xml file, you will see that this plug-in is configured in the open shift profile and collaborates with the Vert.x Maven plug-in to cre‐ ate the OpenShift entities.\n\nTo package and deploy our microservice to OpenShift, launch:\n\nmvn fabric8:deploy -Popenshift\n\nThis command interacts with your OpenShift instance (on which you have logged in with oc) to create a build (using the source to image build strategy) and trigger it. This first build can take some time as it needs to retrieve the builder image. Don’t worry—once everything is cached, the builds will be created faster. The output of the build (and image) is used by the deployment configuration, which is also created by the Fabric8 Maven plug-in. By default, it creates one pod. A service is also created by the plug-in. You can find all this information in the OpenShift dashboard, as shown in Figure 5-4.\n\nFigure 5-4. Entities created during our first deployment\n\nRoutes are not created by default by the Fabric8 Maven plug-in. However, we created one from its description (src/main/fabric8/ route.yml). If you open your browser to http://hello-microservice- reactive-microservices.192.168.64.12.nip.io/Luke, you should see something like:\n\n{\"message\":\"hello Luke\",\"served-by\": \"hello-microservice-1-9r8uv\"}\n\nDeploying a Microservice in OpenShift\n\n|\n\n63\n\nhello-microservice-1-9r8uv is the name of the pod serving the request.\n\nService Discovery Now that we have the hello microservice deployed, let’s consume it from another microservice. The code we are going to deploy in this in the openshift/hello-microservice- section consumer-openshift directory from the code repository.\n\nis contained\n\nTo consume a microservice, we first have to find it. OpenShift pro‐ vides a service discovery mechanism. Service lookup can be done using environment variables, DNS, or the Vert.x service discovery, which we use here. The project pom.xml is configured to import the Vert.x service discovery, the Kubernetes service importer, and a server-side service discovery. You don’t have to explicitly register the service on the provider side as the Fabric8 Maven plug-in declares a service for us. Our consumer is going to retrieve this OpenShift ser‐ vice and not the pods.\n\n@Override public void start() { Router router = Router.router(vertx); router.get(\"/\").handler(this::invokeHelloMicroservice); // Create the service discovery instance ServiceDiscovery.create(vertx, discovery -> { // Look for an HTTP endpoint named \"hello-microservice\" // you can also filter on 'label' Single<WebClient> single = HttpEndpoint.rxGetWebClient (discovery, rec -> rec.getName().equals (\"hello-microservice\"), new JsonObject().put(\"keepAlive\", false)); single.subscribe( client -> { // the configured client to call the microservice this.hello = client; vertx.createHttpServer() .requestHandler(router::accept) .listen(8080); }, err -> System.out.println(\"Oh no, no service\") ); }); }\n\nIn the start method, we use the service discovery to find the hello microservice. Then, if the service is available, we start the HTTP\n\n64\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift\n\nserver and keep a reference on the retrieved WebClient. We also pass a configuration to the WebClient and disable the keep-alive settings (we will see the reason for this in a few minutes). In the invokeHelloMicroservice, we don’t have to pass the port and host to the rxSend method (as we did previously). Indeed, the WebClient is configured to target the hello service:\n\nHttpRequest<JsonObject> request1 = hello.get(\"/Luke\") .as(BodyCodec.jsonObject()); HttpRequest<JsonObject> request2 = hello.get(\"/Leia\") .as(BodyCodec.jsonObject()); Single<JsonObject> s1 = request1.rxSend() .map(HttpResponse::body); Single<JsonObject> s2 = request2.rxSend() .map(HttpResponse::body); // ...\n\nIn a terminal, navigate to the openshift/hello-microservice- consumer-openshift directory to build and deploy this consumer with:\n\nmvn fabric8:deploy -Popenshift\n\nIn the OpenShift dashboard, you should see a second service and route (http://bit.ly/2o4xaSk). If you open the route associated with the hello-consumer service (http://bit.ly/2p2aHTK), you should see:\n\n{ \"luke\" : \"hello Luke hello-microservice-1-sa5pf\", \"leia\" : \"hello Leia hello-microservice-1-sa5pf\" }\n\nYou may see a 503 error page, since the pod has not yet started. Just refresh until you get the right page. So far, nothing surprising. The displayed served-by values are always indicating the same pod (as we have only one).\n\nScale Up and Down If we are using a cloud platform, it’s mainly for scalability reasons. We want to be able to increase and decrease the number of instances of our application depending on the load. In the OpenShift dash‐ board we can scale the number of pods up and down, as shown in Figure 5-5.\n\nScale Up and Down\n\n|\n\n65\n\nFigure 5-5. Scale up and down\n\nYou can also set the number of replicas using the oc command line:\n\n# scale up to 2 replicas oc scale --replicas=2 dc hello-microservice\n\n# scale down to 0 oc scale --replicas=0 dc hello-microservice\n\nLet’s create a second instance of our hello microservice. Then, wait until the second microservice has started correctly (the wait time is annoying, but we will fix that later), and go back to the hello- consumer page in a browser. You should see something like:\n\n{ \"luke\" : \"hello Luke hello-microservice-1-h6bs6\", \"leia\" : \"hello Leia hello-microservice-1-keq8s\" }\n\nIf you refresh several times, you will see that the OpenShift service balances the load between the two instances. Do you remember the keep-alive settings we disabled? When the HTTP connection uses a keep-alive connection, OpenShift forwards the request to the same pod, providing connection affinity. Note that in practice, keep-alive is a very desirable header as it allows reusing connec‐ tions.\n\nIn the previous scenario there is a small issue. When we scale up, OpenShift starts dispatching requests to the new pod without check‐ ing whether the application is ready to serve these requests. So, our consumer may call a microservice that is not ready and get a failure. There are a couple of ways to address this:\n\n1. Using health checks in the microservice\n\n2. Be prepared to face the failure in the consumer code\n\n66\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift\n\nHealth Check and Failover In OpenShift you can declare two types of checks. Readiness checks are used to avoid downtime when updating a microservice. In a roll‐ ing update, OpenShift waits until the new version is ready before shutting down the previous version. It pings the readiness check endpoint of the new microservice until it is ready, and verifies that the microservice has been successfully initialized. Liveness checks are used to determine whether a pod is alive. OpenShift invokes the liveness check endpoint periodically. If a pod does not reply posi‐ tively to the check, it will be restarted. A liveness check focuses on the critical resources required by the microservice to behave cor‐ rectly. In the following example we will use the same endpoint for both checks. However, it’s best to use two different endpoints.\n\nThe code of this example is contained in the openshift/hello- microservice-openshift-health-checks directory. If you open the verticle, you will see the HealthCheck handler verifying whether or not the HTTP server has been started:\n\nprivate boolean started;\n\n@Override public void start() { Router router = Router.router(vertx); router.get(\"/health\").handler( HealthCheckHandler.create(vertx) .register(\"http-server-running\", future -> future.complete( started ? Status.OK() : Status.KO()))); router.get(\"/\").handler(this::hello); router.get(\"/:name\").handler(this::hello); vertx.createHttpServer() .requestHandler(router::accept) .listen(8080, ar -> started = ar.succeeded()); }\n\nThe Fabric8 Maven plug-in is configured to use /health for the readiness and liveness health checks. Once this version of the hello microservice is deployed, all subsequent deployments will use the readiness check to avoid downtime, as shown in Figure 5-6.\n\nHealth Check and Failover\n\n|\n\n67\n\nFigure 5-6. Rolling updates\n\nWhen the pod is ready, OpenShift routes the requests to this pod and shuts down the old one. When we scale up, OpenShift doesn’t route requests to a pod that is not ready.\n\nUsing a Circuit Breaker While using health checks avoids calling a microservice that is not ready and restarts dead ones, we still need to protect ourselves from other failures such as timeouts, network outage, bugs in the called microservice, and so on. In this section we are going to protect the hello consumer using a circuit breaker. The code of this section is openshift/hello-microservice-consumer- located openshift-circuit-breaker directory.\n\nin\n\nthe\n\nIn the verticle, we are using a single circuit breaker to protect against the two calls to the hello microservice. The following code uses this design; however, it’s just one among a large set of possible approaches, such as using one circuit breaker per call, using a single circuit breaker but protecting the two calls independently, etc.:\n\nprivate void invokeHelloMicroservice(RoutingContext rc) { circuit.rxExecuteCommandWithFallback( future -> { HttpRequest<JsonObject> request1 = hello.get(\"/Luke\") .as(BodyCodec.jsonObject()); HttpRequest<JsonObject> request2 = hello.get(\"/Leia\") .as(BodyCodec.jsonObject()); Single<JsonObject> s1 = request1 .rxSend().map(HttpResponse::body); Single<JsonObject> s2 = request2 .rxSend().map(HttpResponse::body);\n\n68\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift\n\nSingle .zip(s1, s2, (luke, leia) -> { // We have the result of both request in Luke and Leia return new JsonObject() .put(\"Luke\", luke.getString(\"message\") + \" \" + luke.getString(\"served-by\")) .put(\"Leia\", leia.getString(\"message\") + \" \" + leia.getString(\"served-by\")); }) .subscribe(future::complete, future::fail); }, error -> new JsonObject().put(\"message\", \"hello (fallback, \" + circuit.state().toString() + \")\") ).subscribe( x -> rc.response().end(x.encodePrettily()), t -> rc.response().end(t.getMessage())); }\n\nIn case of error, we provide a fallback message indicating the state of the circuit breaker. This will help us understand what’s going on. Deploy this project using:\n\nmvn fabric8:deploy -Popenshift\n\nNow let’s scale down the hello microservice to 0. To do this, we can click on the down arrow near the pod, or run:\n\noc scale --replicas=0 dc hello-microservice\n\nNow if you refresh the consumer page (http://hello-consumer- reactive-microservices.192.168.64.12.nip.io/), you should see the fall‐ back message. The first three requests show:\n\n{ \"message\" : \"hello (fallback, CLOSED)\" }\n\nOnce the number of failures is reached, it returns:\n\n{ \"message\" : \"hello (fallback, OPEN)\" }\n\nIf you restore the number of replicas to 1 with:\n\noc scale --replicas=1 dc hello-microservice\n\nyou should get back the normal output once the microservice is ready.\n\nUsing a Circuit Breaker\n\n|\n\n69\n\nBut Wait, Are We Reactive? Yes, we are. Let’s see why.\n\nAll our interactions are asynchronous. They use asynchronous and nonblocking HTTP requests and responses. In addition, thanks to the OpenShift service, we are sending the requests to a virtual address, which enables elasticity. The service balances the load among a set of pods. We can easily scale up and down by adjusting the number of pods or by using auto-scaling. We are also resilient. Thanks to the health checks, we have a failover mechanism ensuring we always have the right number of pods running. On the consumer side, we can use various resilience patterns such as timeouts, retries, or circuit breakers to protect the microservice from failures. So our system is able to handle requests in a timely fashion under load and when facing failures: we are responsive!\n\nCan any system using asynchronous nonblocking HTTP be a reac‐ tive system in a cloud providing load-balancing and some resilience features? Yes, but don’t forget the costs. Vert.x uses an event loop to handle a high level of concurrency with a minimum of threads, exhibiting a cloud native nature. When using approaches relying on thread pools, you will need to 1) tune the thread pool to find the right size; 2) handle the concurrency in your code, which means debugging deadlocks, race conditions, and bottlenecks; and 3) mon‐ itor performance. Cloud environments are based on virtualization, and thread scheduling can become a major issue when you have many threads.\n\nThere are many nonblocking technologies, but not all of them use the same execution model to handle the asynchronous nature We can classify these technologies in three categories:\n\n1. Approaches using a thread pool in the background—Then you are facing a tuning, scheduling, and concurrency challenge shifting the burden to ops.\n\n2. Approaches using another thread for callbacks—You still need to manage the thread-safety of your code while avoiding dead‐ locks and bottlenecks.\n\n3. Approaches, such as Vert.x, using the same thread—You use a small number of threads and are freed from debugging dead‐ locks.\n\n70\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift",
      "page_number": 63
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 73-81)",
      "start_page": 73,
      "end_page": 81,
      "detection_method": "topic_boundary",
      "content": "Could we use messaging systems in the cloud to implement reactive microservice systems? Of course. We could have used the Vert.x event bus to build our reactive microservice in OpenShift. But it would not have demonstrated service virtual address and load- balancing provided by OpenShift as it would have been handled by Vert.x itself. Here we decided to go with HTTP, one design among an infinite number of choices. Shape your system the way you want it!\n\nSummary In this chapter, we deployed microservices in OpenShift and saw how Vert.x and the OpenShift features are combined to build reac‐ tive microservices. Combining asynchronous HTTP servers and cli‐ ents, OpenShift services, load-balancing, failover and consumer-side resilience gives us the characteristics of a reactive system.\n\nThis report focuses on reactive. However, when building a microser‐ vice system, lots of other concerns need to be managed such as secu‐ rity, configuration, logging, etc. Most cloud platforms, including OpenShift, provide services to handle these concerns.\n\nIf you want to learn more about these topics, check out the follow‐ ing resources:\n\nOpenShift website\n\nOpenShift core concepts\n\nKubernetes website\n\nOpenShift health checks documentation\n\nSummary\n\n|\n\n71\n\nCHAPTER 6 Conclusion\n\nWe are at the end of our journey together, but you have many new avenues to explore. We have covered a lot of content in this small report but certainly didn’t cover everything! We have just scratched the surface. There are more things to consider when moving toward reactive microservices. Vert.x is also not limited to microservices and can handle a large set of different use cases.\n\nWhat Have We Learned? So, what did you learn in this report? First, we started with micro‐ services and what are reactive microservices. We learned that reac‐ tive microservices are the building blocks of responsive microservice systems. We also saw how reactive programming helps to build these microservices.\n\nWe discovered Eclipse Vert.x, a toolkit used to build reactive micro‐ services (among many other things). Vert.x provides the perfect paradigm to embrace microservices: asynchronous, failures as first- class citizens, and nonblocking. To tame the asynchronous develop‐ ment model, Vert.x combines its power with RxJava. Our discovery started with HTTP microservices and how to consume them. While HTTP is often used in microservices, we also saw one of its limita‐ tions when we directly referenced an instance of a microservice. To address this, we used the Vert.x event bus and saw how message- based microservices let you build reactive microservices and thus reactive systems.\n\n73\n\nOf course, one microservice does not make an application. They come in systems. To build systems, we have to use service discovery. Service discovery enables location transparency and mobility, two important characteristics in microservice systems. We also covered resilience patterns, since microservice systems are distributed sys‐ tems and you need to be prepared for failure.\n\nIn the last chapter, we deployed our microservices on top of Open‐ Shift, an open source container platform based on Kubernetes. The combination of Vert.x and OpenShift simplifies the deployment and execution of reactive microservices and keeps the whole system on track.\n\nSo, is this the end? No! It’s only the end of the first stage.\n\nMicroservices Aren’t Easy Microservices are expected to improve overall agility. This improve‐ ment is not only a technical issue, it’s also an organization issue. If your organization does not embrace microservices from an organi‐ zation standpoint, no technologies will help you.\n\nWhile building microservices may seem simple, there’s actually a lot more to it. Microservice systems are distributed systems, and thus involve distributed computing laws. Failures are also inevitable. Each microservice should own its data, and you will typically need several persistence technologies.\n\nTo build microservice systems, there are a couple of topics to study further. First, to enable the promised agility, you are going to deploy the different microservices much more often. Therefore, continuous delivery is key. You also need to automate the release and deploy‐ ment of your microservices as much as possible. Don’t forget that your microservices are fungible, and immutable image delivery is a must-have feature in order to scale.\n\nHowever, if our deployed microservices are immutable, how do we pass in configuration information and potentially reconfigure them? For instance, how do we change the log level, configure the database location and credentials, toggle features, and so on? Configuration is a very important part of distributed systems and is difficult with microservices. All systems are different and there is no silver bullet, but there is a wide range of solutions, from environment variables to Git repositories and dedicated configuration servers. Cloud plat‐\n\n74\n\n|\n\nChapter 6: Conclusion\n\nforms also provide configuration abilities. To mitigate this diversity, Vert.x is capable of retrieving configurations from almost anywhere.\n\nOnce you deploy and configure your microservices, you need to keep your system on track. Logging, metrics, and tracing are impor‐ tant concerns to keep in mind when designing and developing a microservice system. You have to retrieve the logged messages, the measures, and the traces from your microservices to aggregate them in a centralized way to enable correlation and visualization. While logging and monitoring are generally well understood, distributed tracing is often ignored. However, traces are priceless in microservi‐ ces because they will help you identify bottlenecks, the affinity between microservices, and give you a good idea of the responsive‐ ness of your system.\n\nThe Evolution of the Microservice Paradigm Microservices are dynamic and always evolving. Recently, the server‐ less trend, also called function as a service, is gaining a lot of attrac‐ tion. In this new paradigm, your unit of deployment is a function. These functions receive and process messages. The serverless para‐ digm stresses the deployment, logging, and tracing facilities, but promotes a simple development model and improves the scalability of the system as you can instantiate as many instances of functions as you need to handle the load.\n\nHTTP/2 is also making a remarkable entrance in the microservice world. It improves the performance and scalability of HTTP 1.1 and allows multiplexing several requests over a single TCP connection. It also offers bidirectional communication. gRPC is a remote proce‐ dure call (RPC) framework relying on HTTP/2 and provides high- performance, multilanguage, secure, bidirectional interactions. It can efficiently connect services in and across data centers with plug‐ gable support for load balancing, tracing, health checking, and authentication. It is also applicable to embedded devices, mobile applications, and browsers. While RPC was initially considered harmful in microservice systems, it’s still widely popular. gRPC addresses the issues encountered with traditional RPC mechanisms, such as blocking calls and partial failures. However, be aware that sharing a contract (interface) between the provider microservice and consumers may limit your agility. Vert.x provides HTTP/2 cli‐\n\nThe Evolution of the Microservice Paradigm\n\n|\n\n75\n\nent and servers. In addition, it has the ability to create and consume gRPC services.\n\nVert.x Versatility While this report has focused on reactive microservices, this is only a single facet of Vert.x. The richness of the Vert.x ecosystem lets you develop lots of different applications. Thanks to its execution model, your applications will be asynchronous and will embrace the reactive system mantra.\n\nModern web applications provide a real-time, interactive experience for users. The information is pushed to the browser and is displayed seamlessly. The Vert.x event bus can be used as the backbone to deliver such an experience. The browser connects to the event bus and receives messages, and can also send messages on and interact with the backend or with other browsers connected to the event bus.\n\nThe Internet of things (IoT) is a thrilling domain but also very het‐ erogeneous. There are many protocols used by smart devices. Mes‐ sages often have to be translated from one protocol to another. Vert.x provides clients for a large set of protocols to implement these translations, and its execution model can handle the high concur‐ rency required to build IoT gateways.\n\nThese two examples illustrate the richness of the Vert.x ecosystem. Vert.x offers an infinite set of possibilities where you are in charge. You can shape your system using the programming language you prefer and the development model you like. Don’t let a framework lead—you are in charge.\n\n76\n\n|\n\nChapter 6: Conclusion\n\nAbout the Author\n\nClement Escoffier (@clementplop) is a principal software engineer at Red Hat. He has had several professional lives, from academic positions to management. Currently, he is working as a Vert.x core developer. He has been involved in projects and products touching many domains and technologies such as OSGi, mobile app develop‐ ment, continuous delivery, and DevOps. Clement is an active con‐ tributor to many open source projects such as Apache Felix, iPOJO, Wisdom Framework, and Eclipse Vert.x.",
      "page_number": 73
    },
    {
      "number": 9,
      "title": "Segment 9 (pages 82-83)",
      "start_page": 82,
      "end_page": 83,
      "detection_method": "topic_boundary",
      "content": "",
      "page_number": 82
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "content": "Building Reactive Microservices in Java\n\nAsynchronous and Event-Based Application Design\n\nClement Escoffier",
      "content_length": 107,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 3,
      "content": "Building Reactive Microservices in Java Asynchronous and Event-Based Application Design\n\nClement Escoffier\n\nBeijing Beijing\n\nBoston Boston\n\nFarnham Sebastopol Farnham Sebastopol\n\nTokyo Tokyo",
      "content_length": 190,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 4,
      "content": "Building Reactive Microservices in Java by Clement Escoffier\n\nCopyright © 2017 O’Reilly Media. All rights reserved.\n\nPrinted in the United States of America.\n\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\n\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (http://oreilly.com/safari). For more information, contact our corporate/institutional sales department: 800-998-9938 or corporate@oreilly.com.\n\nEditor: Brian Foster Production Editor: Shiny Kalapurakkel Copyeditor: Christina Edwards Proofreader: Sonia Saruba\n\nInterior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: Rebecca Demarest\n\nMay 2017:\n\nFirst Edition\n\nRevision History for the First Edition 2017-04-06: First Release\n\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Building Reactive Microservices in Java, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.\n\nWhile the publisher and the author have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the author disclaim all responsibility for errors or omissions, including without limi‐ tation responsibility for damages resulting from the use of or reliance on this work. Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsi‐ bility to ensure that your use thereof complies with such licenses and/or rights.\n\n978-1-491-98628-8\n\n[LSI]",
      "content_length": 1731,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 5,
      "content": "Table of Contents\n\n1.\n\nIntroduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Preparing Your Environment 2\n\n2. Understanding Reactive Microservices and Vert.x. . . . . . . . . . . . . . . . 3 Reactive Programming 4 Reactive Systems 7 Reactive Microservices 8 What About Vert.x ? 9 Asynchronous Development Model 11 Verticles—the Building Blocks 14 From Callbacks to Observables 15 Let’s Start Coding! 17 Summary 21\n\n3. Building Reactive Microservices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 First Microservices 23 Implementing HTTP Microservices 24 Consuming HTTP Microservices 28 Are These Microservices Reactive Microservices? 31 The Vert.x Event Bus—A Messaging Backbone 32 Message-Based Microservices 33 Initiating Message-Based Interactions 35 Are We Reactive Now? 37 Summary 40\n\n4. Building Reactive Microservice Systems. . . . . . . . . . . . . . . . . . . . . . . . 43 Service Discovery 43 Stability and Resilience Patterns 47 Summary 54\n\niii",
      "content_length": 1027,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 6,
      "content": "5. Deploying Reactive Microservices in OpenShift. . . . . . . . . . . . . . . . . . 57 What Is OpenShift? 57 Installing OpenShift on Your Machine 60 Deploying a Microservice in OpenShift 62 Service Discovery 64 Scale Up and Down 65 Health Check and Failover 67 Using a Circuit Breaker 68 But Wait, Are We Reactive? 70 Summary 71\n\n6. Conclusion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 What Have We Learned? 73 Microservices Aren’t Easy 74 The Evolution of the Microservice Paradigm 75 Vert.x Versatility 76\n\niv\n\n|\n\nTable of Contents",
      "content_length": 589,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 7,
      "content": "CHAPTER 1 Introduction\n\nThis report is for developers and architects interested in developing microservices and distributed applications. It does not explain the basics of distributed systems, but instead focuses on the reactive benefits to build efficient microservice systems. Microservices can be seen as an extension of the basic idea of modularity: programs connected by message-passing instead of direct API calls so that they can be distributed among multiple services. Why are microser‐ vices so popular? It’s basically due to the combination of two factors: cloud computing and the need to scale up and down quickly. Cloud computing makes it convenient to deploy thousands of small serv‐ ices; scaling makes it necessary to do so.\n\nIn this report, we will see how Eclipse Vert.x (http://vertx.io) can be used to build reactive microservice systems. Vert.x is a toolkit to build reactive and distributed systems. Vert.x is incredibly flexible. Because it’s a toolkit, you can build simple network utilities, modern web applications, a system ingesting a huge amount of messages, REST services, and, obviously, microservices. This malleability gives Vert.x great popularity, a large community, and a vibrant ecosystem. Vert.x was already promoting microservices before it became so pop‐ ular. Since the beginning, Vert.x has been tailored to build applica‐ tions composed by a set of distributed and autonomous services. Systems using Vert.x are built upon the reactive system principles (http://reactivemanifesto.org). They are responsive, elastic, resilient, and use asynchronous message passing to interact.\n\n1",
      "content_length": 1620,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 8,
      "content": "This report goes beyond Vert.x and microservices. It looks at the whole environment in which a microservice system runs and intro‐ duces the many tools needed to get the desired results. On this jour‐ ney, we will learn:\n\nWhat Vert.x is and how you can use it\n\nWhat reactive means and what reactive microservices are\n\nHow to implement microservices using HTTP or messages\n\nThe patterns used to build reactive microservice systems\n\nHow to deploy microservices in a virtual or cloud environment\n\nThe code presented in this report is available from https:// github.com/redhat-developer/reactive-microservices-in-java.\n\nPreparing Your Environment Eclipse Vert.x requires Java 8, which we use for the different exam‐ ples provided in this report. We are going to use Apache Maven to build them. Make sure you have the following prerequisites installed:\n\nJDK 1.8\n\nMaven 3.3+\n\nA command-line terminal (Bash, PowerShell, etc.)\n\nEven if not mandatory, we recommend using an IDE such as the Red Hat Development Suite (https://developers.redhat.com/products/ devsuite/overview). In the last chapter, we use OpenShift, a container platform built on top of Kubernetes (https://kubernetes.io) to run containerized microservices. To install OpenShift locally, we recom‐ mend Minishift (https://github.com/minishift/minishift) or the Red Hat Container Development Kit (CDK) v3. You can download the CDK from https://developers.redhat.com/products/cdk/download.\n\nLet’s get started.\n\n2\n\n|\n\nChapter 1: Introduction",
      "content_length": 1495,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 9,
      "content": "CHAPTER 2 Understanding Reactive Microservices and Vert.x\n\nMicroservices are not really a new thing. They arose from research conducted in the 1970s and have come into the spotlight recently because microservices are a way to move faster, to deliver value more easily, and to improve agility. However, microservices have roots in actor-based systems, service design, dynamic and auto‐ nomic systems, domain-driven design, and distributed systems. The fine-grained modular design of microservices inevitably leads devel‐ opers to create distributed systems. As I’m sure you’ve noticed, dis‐ tributed systems are hard. They fail, they are slow, they are bound by the CAP and FLP theorems. In other words, they are very compli‐ cated to build and maintain. That’s where reactive comes in.\n\n30+ Years of Evolution The actor model was introduced by C. Hewitt, P. Bishop, and R. Steiger in 1973. Autonomic computing, a term coined in 2001, refers to the self-managing characteristics (self-healing, self- optimization, etc.) of distributed computing resources.\n\nBut what is reactive? Reactive is an overloaded term these days. The Oxford dictionary defines reactive as “showing a response to a stimu‐ lus.” So, reactive software reacts and adapts its behavior based on the stimuli it receives. However, the responsiveness and adaptability promoted by this definition are programming challenges because\n\n3",
      "content_length": 1398,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 10,
      "content": "the flow of computation isn’t controlled by the programmer but by the stimuli. In this chapter, we are going to see how Vert.x helps you be reactive by combining:\n\nReactive programming—A development model focusing on the observation of data streams, reacting on changes, and propagat‐ ing them\n\nReactive system—An architecture style used to build responsive and robust distributed systems based on asynchronous message-passing\n\nA reactive microservice is the building block of reactive microservice systems. However, due to their asynchronous aspect, the implemen‐ tation of these microservices is challenging. Reactive programming reduces this complexity. How? Let’s answer this question right now.\n\nReactive Programming\n\nFigure 2-1. Reactive programming is about flow of data and reacting to it\n\nReactive programming is a development model oriented around data flows and the propagation of data. In reactive programming, the stimuli are the data transiting in the flow, which are called streams. There are many ways to implement a reactive programming model. In to use Reactive Extensions (http://reactivex.io/) where streams are called observables, and con‐ sumers subscribe to these observables and react to the values (Figure 2-1).\n\nthis report, we are going\n\n4\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x",
      "content_length": 1329,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 11,
      "content": "To make these concepts less abstract, let’s look at an example using RxJava (https://github.com/ReactiveX/RxJava), a library implement‐ ing the Reactive Extensions in Java. These examples are located in the directory reactive-programming in the code repository.\n\nobservable.subscribe( data -> { // onNext System.out.println(data); }, error -> { // onError error.printStackTrace(); }, () -> { // onComplete System.out.println(\"No more data\"); } );\n\nIn this snippet, the code is observing (subscribe) an Observable and is notified when values transit in the flow. The subscriber can receive three types of events. onNext is called when there is a new value, while onError is called when an error is emitted in the stream or a stage throws an Exception. The onComplete callback is invoked when the end of the stream is reached, which would not occur for unbounded streams. RxJava includes a set of operators to produce, transform, and coordinate Observables, such as map to transform a value into another value, or flatMap to produce an Observable or chain another asynchronous action:\n\n// sensor is an unbound observable publishing values. sensor // Groups values 10 by 10, and produces an observable // with these values. .window(10) // Compute the average on each group .flatMap(MathObservable::averageInteger) // Produce a json representation of the average .map(average -> \"{'average': \" + average + \"}\") .subscribe( data -> { System.out.println(data); }, error -> { error.printStackTrace(); } );\n\nRxJava v1.x defines different types of streams as follows:\n\nReactive Programming\n\n|\n\n5",
      "content_length": 1586,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 12,
      "content": "Observables are bounded or unbounded streams expected to contain a sequence of values.\n\nSingles are streams with a single value, generally the deferred result of an operation, similar to futures or promises.\n\nCompletables are streams without value but with an indication of whether an operation completed or failed.\n\nRxJava 2 While RxJava 2.x has been recently released, this report still uses the previous version (RxJava 1.x). RxJava 2.x provides similar concepts. RxJava 2 adds two new types of streams. Observable is used for streams not supporting back-pressure, while Flowable is an Observable with back-pressure. RxJava 2 also introduced the Maybe type, which models a stream where there could be 0 or 1 item or an error.\n\nWhat can we do with RxJava? For instance, we can describe sequen‐ ces of asynchronous actions and orchestrate them. Let’s imagine you want to download a document, process it, and upload it. The down‐ load and upload operations are asynchronous. To develop this sequence, you use something like:\n\n// Asynchronous task downloading a document Future<String> downloadTask = download(); // Create a single completed when the document is downloaded. Single.from(downloadTask) // Process the content .map(content -> process(content)) // Upload the document, this asynchronous operation // just indicates its successful completion or failure. .flatMapCompletable(payload -> upload(payload)) .subscribe( () -> System.out.println(\"Document downloaded, updated and uploaded\"), t -> t.printStackTrace() );\n\nYou can also orchestrate asynchronous tasks. For example, to com‐ bine the results of two asynchronous operations, you use the zip operator combining values of different streams:\n\n6\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x",
      "content_length": 1769,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 13,
      "content": "// Download two documents Single<String> downloadTask1 = downloadFirstDocument(); Single<String> downloadTask2 = downloadSecondDocument();\n\n// When both documents are downloaded, combine them Single.zip(downloadTask1, downloadTask2, (doc1, doc2) -> doc1 + \"\\n\" + doc2) .subscribe( (doc) -> System.out.println(\"Document combined: \" + doc), t -> t.printStackTrace() );\n\nThe use of these operators gives you superpowers: you can coordi‐ nate asynchronous tasks and data flow in a declarative and elegant way. How is this related to reactive microservices? To answer this question, let’s have a look at reactive systems.\n\nReactive Streams You may have heard of reactive streams (http://www.reactive- streams.org/). Reactive streams is an initiative to provide a standard for asynchronous stream processing with back-pressure. It provides a minimal set of interfaces and protocols that describe the opera‐ tions and entities to achieve the asynchronous streams of data with nonblocking back-pressure. It does not define operators manipulat‐ ing the streams, and is mainly used as an interoperability layer. This initiative is supported by Netflix, Lightbend, and Red Hat, among others.\n\nReactive Systems While reactive programming is a development model, reactive sys‐ tems is an architectural style used to build distributed systems (http://www.reactivemanifesto.org/). It’s a set of principles used to achieve responsiveness and build systems that respond to requests in a timely fashion even with failures or under load.\n\nTo build such a system, reactive systems embrace a message-driven approach. All the components interact using messages sent and received asynchronously. To decouple senders and receivers, com‐ ponents send messages to virtual addresses. They also register to the virtual addresses to receive messages. An address is a destination identifier such as an opaque string or a URL. Several receivers can be registered on the same address—the delivery semantic depends\n\nReactive Systems\n\n|\n\n7",
      "content_length": 2005,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 14,
      "content": "on the underlying technology. Senders do not block and wait for a response. The sender may receive a response later, but in the mean‐ time, he can receive and send other messages. This asynchronous aspect is particularly important and impacts how your application is developed.\n\nUsing asynchronous message-passing interactions provides reactive systems with two critical properties:\n\nElasticity—The ability to scale horizontally (scale out/in)\n\nResilience—The ability to handle failure and recover\n\nElasticity comes from the decoupling provided by message interac‐ tions. Messages sent to an address can be consumed by a set of con‐ sumers using a load-balancing strategy. When a reactive system faces a spike in load, it can spawn new instances of consumers and dispose of them afterward.\n\nThis resilience characteristic is provided by the ability to handle fail‐ ure without blocking as well as the ability to replicate components. First, message interactions allow components to deal with failure locally. Thanks to the asynchronous aspect, components do not actively wait for responses, so a failure happening in one component would not impact other components. Replication is also a key ability to handle resilience. When one node-processing message fails, the message can be processed by another node registered on the same address.\n\nThanks to these two characteristics, the system becomes responsive. It can adapt to higher or lower loads and continue to serve requests in the face of high loads or failures. This set of principles is primor‐ dial when building microservice systems that are highly distributed, and when dealing with services beyond the control of the caller. It is necessary to run several instances of your services to balance the load and handle failures without breaking the availability. We will see in the next chapters how Vert.x addresses these topics.\n\nReactive Microservices When building a microservice (and thus distributed) system, each service can change, evolve, fail, exhibit slowness, or be withdrawn at any time. Such issues must not impact the behavior of the whole sys‐ tem. Your system must embrace changes and be able to handle fail‐\n\n8\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x",
      "content_length": 2245,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 15,
      "content": "ures. You may run in a degraded mode, but your system should still be able to handle the requests.\n\nTo ensure such behavior, reactive microservice systems are com‐ prised of reactive microservices. These microservices have four char‐ acteristics:\n\nAutonomy\n\nAsynchronisity\n\nResilience\n\nElasticity\n\nReactive microservices are autonomous. They can adapt to the avail‐ ability or unavailability of the services surrounding them. However, autonomy comes paired with isolation. Reactive microservices can handle failure locally, act independently, and cooperate with others as needed. A reactive microservice uses asynchronous message- passing to interact with its peers. It also receives messages and has the ability to produce responses to these messages.\n\nThanks to the asynchronous message-passing, reactive microservi‐ ces can face failures and adapt their behavior accordingly. Failures should not be propagated but handled close to the root cause. When a microservice blows up, the consumer microservice must handle the failure and not propagate it. This isolation principle is a key characteristic to prevent failures from bubbling up and breaking the whole system. Resilience is not only about managing failure, it’s also about self-healing. A reactive microservice should implement recov‐ ery or compensation strategies when failures occur.\n\nFinally, a reactive microservice must be elastic, so the system can adapt to the number of instances to manage the load. This implies a set of constraints such as avoiding in-memory state, sharing state between instances if required, or being able to route messages to the same instances for stateful services.\n\nWhat About Vert.x ? Vert.x is a toolkit for building reactive and distributed systems using an asynchronous nonblocking development model. Because it’s a toolkit and not a framework, you use Vert.x as any other library. It does not constrain how you build or structure your system; you use\n\nWhat About Vert.x ?\n\n|\n\n9",
      "content_length": 1975,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 16,
      "content": "it as you want. Vert.x is very flexible; you can use it as a standalone application or embedded in a larger one.\n\nFrom a developer standpoint, Vert.x a set of JAR files. Each Vert.x module is a JAR file that you add to your $CLASSPATH. From HTTP servers and clients, to messaging, to lower-level protocols such as TCP or UDP, Vert.x provides a large set of modules to build your application the way you want. You can pick any of these modules in addition to Vert.x Core (the main Vert.x component) to build your system. Figure 2-2 shows an excerpt view of the Vert.x ecosystem.\n\nFigure 2-2. An incomplete overview of the Vert.x ecosystem\n\n10\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x",
      "content_length": 704,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 17,
      "content": "Vert.x also provides a great stack to help build microservice systems. Vert.x pushed the microservice approach before it became popular. It has been designed and built to provide an intuitive and powerful way to build microservice systems. And that’s not all. With Vert.x you can build reactive microservices. When building a microservice with Vert.x, it infuses one of its core characteristics to the microser‐ vice: it becomes asynchronous all the way.\n\nAsynchronous Development Model All applications built with Vert.x are asynchronous. Vert.x applica‐ tions are event-driven and nonblocking. Your application is notified when something interesting happens. Let’s look at a concrete exam‐ ple. Vert.x provides an easy way to create an HTTP server. This HTTP server is notified every time an HTTP request is received:\n\nvertx.createHttpServer() .requestHandler(request -> { // This handler will be called every time an HTTP // request is received at the server request.response().end(\"hello Vert.x\"); }) .listen(8080);\n\nIn this example, we set a requestHandler to receive the HTTP requests (event) and send hello Vert.x back (reaction). A Handler is a function called when an event occurs. In our example, the code of the handler is executed with each incoming request. Notice that a Handler does not return a result. However, a Handler can provide a result. How this result is provided depends on the type of interac‐ tion. In the last snippet, it just writes the result into the HTTP response. The Handler is chained to a listen request on the socket. Invoking this HTTP endpoint produces a simple HTTP response:\n\nHTTP/1.1 200 OK Content-Length: 12\n\nhello Vert.x\n\nWith very few exceptions, none of the APIs in Vert.x block the call‐ ing thread. If a result can be provided immediately, it will be returned; otherwise, a Handler is used to receive events at a later time. The Handler is notified when an event is ready to be processed or when the result of an asynchronous operation has been compu‐ ted.\n\nAsynchronous Development Model\n\n|\n\n11",
      "content_length": 2044,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 18,
      "content": "In traditional imperative programming, you would write something like:\n\nint res = compute(1, 2);\n\nIn this code, you wait for the result of the method. When switching to an asynchronous nonblocking development model, you pass a Handler invoked when the result is ready:1\n\ncompute(1, 2, res -> { // Called with the result });\n\nIn the last snippet, compute does not return a result anymore, so you don’t wait until this result is computed and returned. You pass a Handler that is called when the result is ready.\n\nThanks to this nonblocking development model, you can handle a highly concurrent workload using a small number of threads. In most cases, Vert.x calls your handlers using a thread called an event loop. This event loop is depicted in Figure 2-3. It consumes a queue of events and dispatches each event to the interested Handlers.\n\nFigure 2-3. The event loop principle\n\nThe threading model proposed by the event loop has a huge benefit: it simplifies concurrency. As there is only one thread, you are always called by the same thread and never concurrently. However, it also has a very important rule that you must obey:\n\n1 This code uses the lambda expressions introduced in Java 8. More details about this\n\nnotation can be found at http://bit.ly/2nsyJJv.\n\n12\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x",
      "content_length": 1332,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 19,
      "content": "Don’t block the event loop.\n\n—Vert.x golden rule\n\nBecause nothing blocks, an event loop can deliver a huge number of events in a short amount of time. This is called the reactor pattern (https://en.wikipedia.org/wiki/Reactor_pattern).\n\nLet’s imagine, for a moment, that you break the rule. In the previous code snippet, the request handler is always called from the same event loop. So, if the HTTP request processing blocks instead of replying to the user immediately, the other requests would not be handled in a timely fashion and would be queued, waiting for the thread to be released. You would lose the scalability and efficiency benefit of Vert.x. So what can be blocking? The first obvious example is JDBC database accesses. They are blocking by nature. Long com‐ putations are also blocking. For example, a code calculating Pi to the 200,000th decimal point is definitely blocking. Don’t worry—Vert.x also provides constructs to deal with blocking code.\n\nIn a standard reactor implementation, there is a single event loop thread that runs around in a loop delivering all events to all handlers as they arrive. The issue with a single thread is simple: it can only run on a single CPU core at one time. Vert.x works differently here. Instead of a single event loop, each Vert.x instance maintains several event loops, which is called a multireactor pattern, as shown in Figure 2-4.\n\nFigure 2-4. The multireactor principle\n\nThe events are dispatched by the different event loops. However, once a Handler is executed by an event loop, it will always be invoked by this event loop, enforcing the concurrency benefits of the\n\nAsynchronous Development Model\n\n|\n\n13",
      "content_length": 1667,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 20,
      "content": "reactor pattern. If, like in Figure 2-4, you have several event loops, it can balance the load on different CPU cores. How does that work with our HTTP example? Vert.x registers the socket listener once and dispatches the requests to the different event loops.\n\nVerticles—the Building Blocks Vert.x gives you a lot of freedom in how you can shape your applica‐ tion and code. But it also provides bricks to easily start writing Vert.x applications and comes with a simple, scalable, actor-like deployment and concurrency model out of the box. Verticles are chunks of code that get deployed and run by Vert.x. An application, such as a microservice, would typically be comprised of many verti‐ cle instances running in the same Vert.x instance at the same time. A verticle typically creates servers or clients, registers a set of Handlers, and encapsulates a part of the business logic of the sys‐ tem.\n\nRegular verticles are executed on the Vert.x event loop and can never block. Vert.x ensures that each verticle is always executed by the same thread and never concurrently, hence avoiding synchroniza‐ tion constructs. In Java, a verticle is a class extending the Abstract Verticle class:\n\nimport io.vertx.core.AbstractVerticle;\n\npublic class MyVerticle extends AbstractVerticle { @Override public void start() throws Exception { // Executed when the verticle is deployed }\n\n@Override public void stop() throws Exception { // Executed when the verticle is un-deployed } }\n\nWorker Verticle Unlike regular verticles, worker verticles are not executed on the event loop, which means they can execute blocking code. However, this limits your scalability.\n\n14\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x",
      "content_length": 1719,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 21,
      "content": "Verticles have access to the vertx member (provided by the AbstractVerticle class) to create servers and clients and to interact with the other verticles. Verticles can also deploy other verticles, configure them, and set the number of instances to create. The instances are associated with the different event loops (implement‐ ing the multireactor pattern), and Vert.x balances the load among these instances.\n\nFrom Callbacks to Observables As seen in the previous sections, the Vert.x development model uses callbacks. When orchestrating several asynchronous actions, this callback-based development model tends to produce complex code. For example, let’s look at how we would retrieve data from a data‐ base. First, we need a connection to the database, then we send a query to the database, process the results, and release the connec‐ tion. All these operations are asynchronous. Using callbacks, you would write the following code using the Vert.x JDBC client:\n\nclient.getConnection(conn -> { if (conn.failed()) {/* failure handling */} else { SQLConnection connection = conn.result(); connection.query(\"SELECT * from PRODUCTS\", rs -> { if (rs.failed()) {/* failure handling */} else { List<JsonArray> lines = rs.result().getResults(); for (JsonArray l : lines) { System.out.println(new Product(l)); } connection.close(done -> { if (done.failed()) {/* failure handling */} }); } }); } });\n\nWhile still manageable, the example shows that callbacks can quickly lead to unreadable code. You can also use Vert.x Futures to handle asynchronous actions. Unlike Java Futures, Vert.x Futures are nonblocking. Futures provide higher-level composition opera‐ tors to build sequences of actions or to execute actions in parallel. Typically, as demonstrated in the next snippet, we compose futures to build the sequence of asynchronous actions:\n\nFrom Callbacks to Observables\n\n|\n\n15",
      "content_length": 1877,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 22,
      "content": "Future<SQLConnection> future = getConnection(); future .compose(conn -> { connection.set(conn); // Return a future of ResultSet return selectProduct(conn); }) // Return a collection of products by mapping // each row to a Product .map(result -> toProducts(result.getResults())) .setHandler(ar -> { if (ar.failed()) { /* failure handling */ } else { ar.result().forEach(System.out::println); } connection.get().close(done -> { if (done.failed()) { /* failure handling */ } }); });\n\nHowever, while Futures make the code a bit more declarative, we are retrieving all the rows in one batch and processing them. This result can be huge and take a lot of time to be retrieved. At the same time, you don’t need the whole result to start processing it. We can process each row one by one as soon as you have them. Fortunately, Vert.x provides an answer to this development model challenge and offers you a way to implement reactive microservices using a reac‐ tive programming development model. Vert.x provides RxJava APIs to:\n\nCombine and coordinate asynchronous tasks\n\nReact to incoming messages as a stream of input\n\nLet’s rewrite the previous code using the RxJava APIs:\n\n// We retrieve a connection and cache it, // so we can retrieve the value later. Single<SQLConnection> connection = client .rxGetConnection(); connection .flatMapObservable(conn -> conn // Execute the query .rxQueryStream(\"SELECT * from PRODUCTS\") // Publish the rows one by one in a new Observable .flatMapObservable(SQLRowStream::toObservable) // Don't forget to close the connection .doAfterTerminate(conn::close) )\n\n16\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x",
      "content_length": 1654,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 23,
      "content": "// Map every row to a Product .map(Product::new) // Display the result one by one .subscribe(System.out::println);\n\nIn addition to improving readability, reactive programming allows you to subscribe to a stream of results and process items as soon as they are available. With Vert.x you can choose the development model you prefer. In this report, we will use both callbacks and RxJava.\n\nLet’s Start Coding! It’s time for you to get your hands dirty. We are going to use Apache Maven and the Vert.x Maven plug-in to develop our first Vert.x application. However, you can use whichever tool you want (Gradle, Apache Maven with another packaging plug-in, or Apache Ant). You will find different examples in the code repository (in the packaging-examples directory). The code shown in this section is located in the hello-vertx directory.\n\nProject Creation Create a directory called my-first-vertx-app and move into this directory:\n\nmkdir my-first-vertx-app cd my-first-vertx-app\n\nThen, issue the following command:\n\nmvn io.fabric8:vertx-maven-plugin:1.0.5:setup \\ -DprojectGroupId=io.vertx.sample \\ -DprojectArtifactId=my-first-vertx-app \\ -Dverticle=io.vertx.sample.MyFirstVerticle\n\nThis command generates the Maven project structure, configures the vertx-maven-plugin, and creates a verticle class (io.vertx.sam ple.MyFirstVerticle), which does nothing.\n\nWrite Your First Verticle It’s now time to write the code for your first verticle. Modify the src/main/java/io/vertx/sample/MyFirstVerticle.java file with the following content:\n\nLet’s Start Coding!\n\n|\n\n17",
      "content_length": 1560,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 24,
      "content": "package io.vertx.sample;\n\nimport io.vertx.core.AbstractVerticle;\n\n/** * A verticle extends the AbstractVerticle class. */ public class MyFirstVerticle extends AbstractVerticle {\n\n@Override public void start() throws Exception { // We create a HTTP server object vertx.createHttpServer() // The requestHandler is called for each incoming // HTTP request, we print the name of the thread .requestHandler(req -> { req.response().end(\"Hello from \" + Thread.currentThread().getName()); }) .listen(8080); // start the server on port 8080 } }\n\nTo run this application, launch:\n\nmvn compile vertx:run\n\nIf everything went fine, you should be able to see your application by opening http://localhost:8080 in a browser. The vertx:run goal launches the Vert.x application and also watches code alterations. So, if you edit the source code, the application will be automatically recompiled and restarted.\n\nLet’s now look at the application output:\n\nHello from vert.x-eventloop-thread-0\n\nThe request has been processed by the event loop 0. You can try to emit more requests. The requests will always be processed by the same event loop, enforcing the concurrency model of Vert.x. Hit Ctrl+C to stop the execution.\n\nUsing RxJava At this point, let’s take a look at the RxJava support provided by Vert.x to better understand how it works. In your pom.xml file, add the following dependency:\n\n18\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x",
      "content_length": 1441,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 25,
      "content": "<dependency> <groupId>io.vertx</groupId> <artifactId>vertx-rx-java</artifactId> </dependency>\n\nNext, change the <vertx.verticle> property to be io.vertx.sam ple.MyFirstRXVerticle. This property tells the Vert.x Maven plug- in which verticle is the entry point of the application. Create the new verticle class (io.vertx.sample.MyFirstRXVerticle) with the fol‐ lowing content:\n\npackage io.vertx.sample;\n\n// We use the .rxjava. package containing the RX-ified APIs import io.vertx.rxjava.core.AbstractVerticle; import io.vertx.rxjava.core.http.HttpServer;\n\npublic class MyFirstRXVerticle extends AbstractVerticle {\n\n@Override public void start() { HttpServer server = vertx.createHttpServer(); // We get the stream of request as Observable server.requestStream().toObservable() .subscribe(req -> // for each HTTP request, this method is called req.response().end(\"Hello from \" + Thread.currentThread().getName()) ); // We start the server using rxListen returning a // Single of HTTP server. We need to subscribe to // trigger the operation server .rxListen(8080) .subscribe(); } }\n\nThe RxJava variants of the Vert.x APIs are provided in packages with rxjava in their name. RxJava methods are prefixed with rx, such as rxListen. In addition, the APIs are enhanced with methods provid‐ ing Observable objects on which you can subscribe to receive the conveyed data.\n\nLet’s Start Coding!\n\n|\n\n19",
      "content_length": 1390,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 26,
      "content": "Packaging Your Application as a Fat Jar The Vert.x Maven plug-in packages the application in a fat jar. Once packaged, you can easily launch the application using java -jar <name>.jar:\n\nmvn clean package cd target java -jar my-first-vertx-app-1.0-SNAPSHOT.jar\n\nThe application is up again, listening for HTTP traffic on the port specified. Hit Ctrl+C to stop it.\n\nAs an unopinionated toolkit, Vert.x does not promote one packag‐ ing model over another—you are free to use the packaging model you prefer. For instance, you could use fat jars, a filesystem approach with libraries in a specific directory, or embed the applica‐ tion in a war file and start Vert.x programmatically.\n\nIn this report, we will use fat jars, i.e., self-contained JAR embedding the code of the application, its resources, as well as all of its depen‐ dencies. This includes Vert.x, the Vert.x components you are using, and their dependencies. This packaging model uses a flat class loader mechanism, which makes it easier to understand application startup, dependency ordering, and logs. More importantly, it helps reduce the number of moving pieces that need to be installed in pro‐ duction. You don’t deploy an application to an existing app server. Once it is packaged in its fat jar, the application is ready to run with a simple java -jar <name.jar>. The Vert.x Maven plug-in builds a fat jar for you, but you can use another Maven plug-in such as the maven-shader-plugin too.\n\nLogging, Monitoring, and Other Production Elements Having fat jar is a great packaging model for microservices and other types of applications as they simplify the deployment and launch. But what about the features generally offered by app servers that make your application production ready? Typically, we expect to be able to write and collect logs, monitor the application, push external configuration, add health checks, and so on.\n\nDon’t worry—Vert.x provides all these features. And because Vert.x is neutral, it provides several alternatives, letting you choose or implement your own. For example, for logging, Vert.x does not push a specific logging framework but instead allows you to use any log‐\n\n20\n\n|\n\nChapter 2: Understanding Reactive Microservices and Vert.x",
      "content_length": 2232,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 27,
      "content": "ging framework you want, such as Apache Log4J 1 or 2, SLF4J, or even JUL (the JDK logging API). If you are interested in the mes‐ sages logged by Vert.x itself, the internal Vert.x logging can be con‐ figured to use any of these logging frameworks. Monitoring Vert.x applications is generally done using JMX. The Vert.x Dropwizard Metric module provides Vert.x metrics to JMX. You can also choose to publish these metrics to a monitoring server such as Prometheus (https://prometheus.io/) or CloudForms (https://www.redhat.com/en/ technologies/management/cloudforms).\n\nSummary In this chapter we learned about reactive microservices and Vert.x. You also created your first Vert.x application. This chapter is by no means a comprehensive guide and just provides a quick introduc‐ tion to the main concepts. If you want to go further on these topics, check out the following resources:\n\nReactive programming vs. Reactive systems\n\nThe Reactive Manifesto\n\nRxJava website\n\nReactive Programming with RxJava\n\nThe Vert.x website\n\nSummary\n\n|\n\n21",
      "content_length": 1036,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 29,
      "content": "CHAPTER 3 Building Reactive Microservices\n\nIn this chapter, we will build our first microservices with Vert.x. As most microservice systems use HTTP interactions, we are going to start with HTTP microservices. But because systems consist of mul‐ tiple communicating microservices, we will build another microser‐ vice that consumes the first one. Then, we will demonstrate why such a design does not completely embrace reactive microservices. Finally, we will implement message-based microservices to see how messaging improves the reactiveness.\n\nFirst Microservices In this chapter we are going to implement the same set of microser‐ vices twice. The first microservice exposes a hello service that we will call hello microservice. Another consumes this service twice (concur‐ rently). The consumer will be called hello consumer microservice. This small system illustrates not only how a service is served, but also how it is consumed. On the left side of Figure 3-1, the microser‐ vices are using HTTP interactions. The hello consumer microser‐ vice uses an HTTP client to invoke the hello microservice. On the right side, the hello consumer microservice uses messages to interact with the hello microservice. This difference impacts the reactiveness of the system.\n\n23",
      "content_length": 1271,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 30,
      "content": "Figure 3-1. The microservices implemented in this chapter using HTTP and message-based interactions\n\nIn the previous chapter, we saw two different ways to use Vert.x APIs: callbacks and RxJava. To illustrate the differences and help you find your preferred approach, the hello microservices are imple‐ mented using the callback-based development model, while the con‐ sumers are implemented using RxJava.\n\nImplementing HTTP Microservices Microservices often expose their API via HTTP and are consumed using HTTP requests. Let’s see how these HTTP interactions can be implemented with Vert.x. The code developed in this section is available in the microservices/hello-microservice-http direc‐ tory of the code repository.\n\nGetting Started Create a directory called hello-microservice-http and then gen‐ erate the project structure:\n\nmkdir hello-microservice-http cd hello-microservice-http\n\nmvn io.fabric8:vertx-maven-plugin:1.0.5:setup \\ -DprojectGroupId=io.vertx.microservice \\ -DprojectArtifactId=hello-microservice-http \\\n\n24\n\n|\n\nChapter 3: Building Reactive Microservices",
      "content_length": 1075,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 31,
      "content": "Dverticle=io.vertx.book.http.HelloMicroservice \\ -Ddependencies=web\n\nThis command generates the Maven project and configures the Vert.x Maven plug-in. In addition, it adds the vertx-web depend‐ ency. Vert.x Web is a module that provides everything you need to build modern web applications on top of Vert.x.\n\nThe Verticle\n\nsrc/main/java/io/vertx/book/http/HelloMicroser\n\nOpen vice.java. The generated code of the verticle does nothing very interesting, but it’s a starting point:\n\npackage io.vertx.book.http;\n\nimport io.vertx.core.AbstractVerticle;\n\npublic class HelloMicroservice extends AbstractVerticle {\n\n@Override public void start() {\n\n} }\n\nNow, launch the following Maven command:\n\nmvn compile vertx:run\n\nYou can now edit the verticle. Every time you save the file, the appli‐ cation will be recompiled and restarted automatically.\n\nHTTP Microservice It’s time to make our MyVerticle class do something. Let’s start with an HTTP server. As seen in the previous chapter, to create an HTTP server with Vert.x you just use:\n\n@Override public void start() { vertx.createHttpServer() .requestHandler(req -> req.response() .end(\"hello\")) .listen(8080); }\n\nOnce added and saved, you should be able to see hello at http:// localhost:8080 in a browser. This code creates an HTTP server on\n\nImplementing HTTP Microservices\n\n|\n\n25",
      "content_length": 1326,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 32,
      "content": "port 8080 and registers a requestHandler that is invoked on each incoming HTTP request. For now, we just write hello in the response.\n\nUsing Routes and Parameters Many services are invoked through web URLs, so checking the path is crucial to knowing what the request is asking for. However, doing path checking in the requestHandler to implement different actions can get complicated. Fortunately, Vert.x Web provides a Router on which we can register Routes. Routes are the mechanism by which Vert.x Web checks the path and invokes the associated action. Let’s rewrite the start method, with two routes:\n\n@Override public void start() { Router router = Router.router(vertx); router.get(\"/\").handler(rc -> rc.response().end(\"hello\")); router.get(\"/:name\").handler(rc -> rc.response() .end(\"hello \" + rc.pathParam(\"name\")));\n\nvertx.createHttpServer() .requestHandler(router::accept) .listen(8080); }\n\nOnce we have created the Router object, we register two routes. The first one handles requests on / and just writes hello. The second route has a path parameter (:name). The handler appends the passed the value requestHandler of the HTTP server to use the accept method of the router.\n\nto\n\nthe greeting message. Finally, we change\n\nIf you didn’t stop the vertx:run execution, you should be able to open a browser to:\n\nhttp://localhost:8080—You should see hello • http://localhost:8080/vert.x—You should see hello vert.x\n\nProducing JSON JSON is often used in microservices. Let’s modify the previous class to produce JSON payloads:\n\n26\n\n|\n\nChapter 3: Building Reactive Microservices",
      "content_length": 1581,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 33,
      "content": "@Override public void start() { Router router = Router.router(vertx); router.get(\"/\").handler(this::hello); router.get(\"/:name\").handler(this::hello); vertx.createHttpServer() .requestHandler(router::accept) .listen(8080); }\n\nprivate void hello(RoutingContext rc) { String message = \"hello\"; if (rc.pathParam(\"name\") != null) { message += \" \" + rc.pathParam(\"name\"); } JsonObject json = new JsonObject().put(\"message\", message); rc.response() .putHeader(HttpHeaders.CONTENT_TYPE, \"application/json\") .end(json.encode()); }\n\nVert.x provides a JsonObject class to create and manipulate JSON structures. With this code in place, you should be able to open a browser to:\n\nhttp://localhost:8080—You should see {\"message\": \"hello\"}\n\nhttp://localhost:8080/vert.x—You \"hello vert.x\"}\n\nhttp://localhost:8080/vert.x—You \"hello vert.x\"}\n\nshould\n\nPackaging and Running Stop the vertx:run execution using Ctrl+C and execute the follow‐ ing command from the same directory:\n\nmvn package\n\nthe target directory: hello- This produces a microservice-http-1.0-SNAPSHOT.jar. While fat jars tend to be fat, here the JAR has a reasonable size (~6.3 MB) and contains everything to run the application:\n\nfat\n\njar\n\nin\n\njava -jar target/hello-microservice-http-1.0-SNAPSHOT.jar\n\nYou can check to make sure it is running by opening: http://local host:8080. Keep the process running as the next microservice will invoke it.\n\nImplementing HTTP Microservices\n\n|\n\n27",
      "content_length": 1435,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 34,
      "content": "Consuming HTTP Microservices One microservice does not form an application; you need a system of microservices. Now that we have our first microservice running, let’s write a second microservice to consume it. This second micro‐ service also provides an HTTP facade to invoke it, and on each invocation calls the microservice we just implemented. The code shown in this section is available in the microservices/hello- consumer-microservice-http directory of the code repository.\n\nProject Creation As usual, let’s create a new project:\n\nmkdir hello-consumer-microservice-http cd hello-consumer-microservice-http\n\nmvn io.fabric8:vertx-maven-plugin:1.0.5:setup \\ -DprojectGroupId=io.vertx.microservice \\ -DprojectArtifactId=hello-consumer-microservice-http \\ -Dverticle=io.vertx.book.http.HelloConsumerMicroservice \\ -Ddependencies=web,web-client,rx\n\nThe last command adds another dependency: the Vert.x web client, an asynchronous HTTP client. We will use this client to call the first microservice. The command has also added the Vert.x RxJava bind‐ ing we are going to use later.\n\nNow edit the src/main/java/io/vertx/book/http/HelloConsumer Microservice.java file and update it to contain:\n\npackage io.vertx.book.http;\n\nimport io.vertx.core.AbstractVerticle; import io.vertx.core.json.JsonObject; import io.vertx.ext.web.*; import io.vertx.ext.web.client.*; import io.vertx.ext.web.codec.BodyCodec;\n\npublic class HelloConsumerMicroservice extends AbstractVerticle {\n\nprivate WebClient client;\n\n@Override public void start() { client = WebClient.create(vertx);\n\nRouter router = Router.router(vertx);\n\n28\n\n|\n\nChapter 3: Building Reactive Microservices",
      "content_length": 1650,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 35,
      "content": "router.get(\"/\").handler(this::invokeMyFirstMicroservice);\n\nvertx.createHttpServer() .requestHandler(router::accept) .listen(8081); }\n\nprivate void invokeMyFirstMicroservice(RoutingContext rc) { HttpRequest<JsonObject> request = client .get(8080, \"localhost\",\"/vert.x\") .as(BodyCodec.jsonObject());\n\nrequest.send(ar -> { if (ar.failed()) { rc.fail(ar.cause()); } else { rc.response().end(ar.result().body().encode()); } }); }\n\n}\n\nIn the start method, we create a WebClient and a Router. On the created router, we register a route on “/” and start the HTTP server, passing the router accept method as requestHandler. The handler of the route is a method reference (hello). This method uses the web client to invoke the first microservice with a specific path (/ vert.x) and write the result to the HTTP response.\n\nOnce the HTTP request is created, we call send to emit the request. The handler we passed in is invoked when either the response arrives or an error occurs. The if-else block checks to see whether the invocation has succeeded. Don’t forget that it’s a remote interac‐ tion and has many reasons to fail. For instance, the first microser‐ vice may not be running. When it succeeds, we write the received payload to the response; otherwise, we reply with a 500 response.\n\nCalling the Service More Than Once Now let’s change the current behavior to call the hello microservice twice with two different (path) parameters:\n\nConsuming HTTP Microservices\n\n|\n\n29",
      "content_length": 1465,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 36,
      "content": "HttpRequest<JsonObject> request1 = client .get(8080, \"localhost\", \"/Luke\") .as(BodyCodec.jsonObject()); HttpRequest<JsonObject> request2 = client .get(8080, \"localhost\", \"/Leia\") .as(BodyCodec.jsonObject());\n\nThese two requests are independent and can be executed concur‐ rently. But here we want to write a response assembling both results. The code required to invoke the service twice and assemble the two results can become convoluted. We need to check to see whether or not the other request has been completed when we receive one of the responses. While this code would still be manageable for two requests, it becomes overly complex when we need to handle more. Fortunately, as noted in the previous chapter, we can use reactive programming and RxJava to simplify this code.\n\nWe instruct the vertx-maven-plugin to import the Vert.x RxJava API. In the HelloConsumerMicroservice, we replace the import statements with:\n\nimport io.vertx.core.json.JsonObject; import io.vertx.rxjava.core.AbstractVerticle; import io.vertx.rxjava.ext.web.*; import io.vertx.rxjava.ext.web.client.*; import io.vertx.rxjava.ext.web.codec.BodyCodec; import rx.Single;\n\nWith RX, the complex code we would have written to call the two requests and build a response out of them becomes much simpler:\n\nprivate void invokeMyFirstMicroservice(RoutingContext rc) { HttpRequest<JsonObject> request1 = client .get(8080, \"localhost\", \"/Luke\") .as(BodyCodec.jsonObject()); HttpRequest<JsonObject> request2 = client .get(8080, \"localhost\", \"/Leia\") .as(BodyCodec.jsonObject()); Single<JsonObject> s1 = request1.rxSend() .map(HttpResponse::body); Single<JsonObject> s2 = request2.rxSend() .map(HttpResponse::body); Single .zip(s1, s2, (luke, leia) -> { // We have the results of both requests in Luke and Leia return new JsonObject() .put(\"Luke\", luke.getString(\"message\")) .put(\"Leia\", leia.getString(\"message\")); }) .subscribe(\n\n30\n\n|\n\nChapter 3: Building Reactive Microservices",
      "content_length": 1949,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 37,
      "content": "result -> rc.response().end(result.encodePrettily()), error -> { error.printStackTrace(); rc.response() .setStatusCode(500).end(error.getMessage()); } ); }\n\nNotice the rxSend method calls. The RxJava methods from Vert.x are prefixed with rx to be easily recognizable. The result of rxSend is a Single, i.e., an observable of one element representing the deferred result of an operation. The single.zip method takes as input a set of Single, and once all of them have received their value, calls a function with the results. Single.zip produces another Single containing the result of the function. Finally, we subscribe. This method takes two functions as parameters:\n\n1. The first one is called with the result of the zip function (a JSON object). We write the receive JSON payload into the HTTP response.\n\n2. The second one is called if something fails (timeout, exception, etc.). In this case, we respond with an empty JSON object.\n\nWith this code in place, if we open http://localhost:8081 and the hello microservice is still running we should see:\n\n{ \"Luke\" : \"hello Luke\", \"Leia\" : \"hello Leia\" }\n\nAre These Microservices Reactive Microservices? At this point we have two microservices. They are independent and can be deployed and updated at their own pace. They also interact using a lightweight protocol (HTTP). But are they reactive micro‐ services? No, they are not. Remember, to be called reactive a micro‐ service must be:\n\nAutonomous\n\nAsynchronous\n\nAre These Microservices Reactive Microservices?\n\n|\n\n31",
      "content_length": 1517,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 38,
      "content": "Resilient\n\nElastic\n\nThe main issue with the current design is the tight coupling between the two microservices. The web client is configured to target the first microservice explicitly. If the first microservice fails, we won’t be able to recover by calling another one. If we are under load, creating a new instance of the hello microservice won’t help us. Thanks to the Vert.x web client, the interactions are asynchronous. However, as we don’t use a virtual address (destination) to invoke the microservice, but its direct URL, it does not provide the resilience and elasticity we need.\n\nIt’s important to note that using reactive programming as in the sec‐ ond microservice does not give you the reactive system’s benefits. It provides an elegant development model to coordinate asynchronous actions, but it does not provide the resilience and elasticity we need.\n\nCan we use HTTP for reactive microservices? Yes. But this requires some infrastructure to route virtual URLs to a set of services. We also need to implement a load-balancing strategy to provide elastic‐ ity and health-check support to improve resilience.\n\nDon’t be disappointed. In the next section we will take a big step toward reactive microservices.\n\nThe Vert.x Event Bus—A Messaging Backbone Vert.x offers an event bus allowing the different components of an application to interact using messages. Messages are sent to addresses and have a set of headers and a body. An address is an opaque string representing a destination. Message consumers register themselves to addresses to receive the messages. The event bus is also clustered, meaning it can dispatch messages over the network between dis‐ tributed senders and consumers. By starting a Vert.x application in cluster mode, nodes are connected to enable shared data structure, hard-stop failure detection, and load-balancing group communica‐ tion. The event bus can dispatch messages among all the nodes in the cluster. To create such a clustered configuration, you can use Apache Ignite, Apache Zookeeper, Infinispan, or Hazelcast. In this report, we are going to use Infinispan, but we won’t go into advanced configuration. For that, refer to the Infinispan documen‐ tation (http://infinispan.org/). While Infinispan (or the technology\n\n32\n\n|\n\nChapter 3: Building Reactive Microservices",
      "content_length": 2319,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 39,
      "content": "you choose) manages the node discovery and inventory, the event bus communication uses direct peer-to-peer TCP connections.\n\nThe event bus provides three types of delivery semantics. First, the send method allows a component to send a message to an address. A single consumer is going to receive the message. If more than one consumer is registered on this address, Vert.x applies a round-robin strategy to select a consumer:\n\n// Consumer vertx.eventBus().consumer(\"address\", message -> { System.out.println(\"Received: '\" + message.body() + \"'\"); }); // Sender vertx.eventBus().send(\"address\", \"hello\");\n\nIn contrast to send, you can use the publish method to deliver the message to all consumers registered on the address. Finally, the send method can be used with a reply handler. This request/response mechanism allows implementing message-based asynchronous interactions between two components:\n\n// Consumer vertx.eventBus().consumer(\"address\", message -> { message.reply(\"pong\"); }); // Sender vertx.eventBus().send(\"address\", \"ping\", reply -> { if (reply.succeeded()) { System.out.println(\"Received: \" + reply.result().body()); } else { // No reply or failure reply.cause().printStackTrace(); } });\n\nIf you are using Rx-ified APIs, you can use the rxSend method, which returns a Single. This Single receives a value when the reply is received. We are going to see this method in action shortly.\n\nMessage-Based Microservices Let’s reimplement the hello microservice, this time using an event bus instead of an HTTP server to receive the request. The microser‐ vice replied to the message to provide the response.\n\nMessage-Based Microservices\n\n|\n\n33",
      "content_length": 1653,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 40,
      "content": "Project Creation Let’s create a new project. This time we are going to add the Infini‐ span dependency, an in-memory data grid that will be used to man‐ age the cluster:\n\nmkdir hello-microservice-message cd hello-microservice-message\n\nmvn io.fabric8:vertx-maven-plugin:1.0.5:setup \\ -DprojectGroupId=io.vertx.microservice \\ -DprojectArtifactId=hello-microservice-message \\ -Dverticle=io.vertx.book.message.HelloMicroservice \\ -Ddependencies=infinispan\n\nOnce generated, we may need to configure Infinispan to build the cluster. The default configuration uses multicast to discover the nodes. If your network supports multicast, it should be fine. Other‐ wise, check the resource/cluster directory of the code repository.\n\nWriting the Message-Driven Verticle Edit the src/main/java/io/vertx/book/message/HelloMicroser vice.java file and update the start method to be:\n\n@Override public void start() { // Receive message from the address 'hello' vertx.eventBus().<String>consumer(\"hello\", message -> { JsonObject json = new JsonObject() .put(\"served-by\", this.toString()); // Check whether we have received a payload in the // incoming message if (message.body().isEmpty()) { message.reply(json.put(\"message\", \"hello\")); } else { message.reply(json.put(\"message\", \"hello \" + message.body())); } }); }\n\nThis code retrieves the eventBus from the vertx object and registers a consumer on the address hello. When a message is received, it replies to it. Depending on whether or not the incoming message has an empty body, we compute a different response. As in the example in the previous chapter, we send a JSON object back. You may be wondering why we added the served-by entry in the JSON.\n\n34\n\n|\n\nChapter 3: Building Reactive Microservices",
      "content_length": 1736,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 41,
      "content": "You’ll see why very soon. Now that the verticle is written, it’s time to launch it with:\n\nmvn compile vertx:run \\ -Dvertx.runArgs=\"-cluster -Djava.net.preferIPv4Stack=true\"\n\nThe -cluster tells Vert.x to start in cluster mode.\n\nNow let’s write a microservice consuming this service.\n\nInitiating Message-Based Interactions In this section, we will create another microservice to invoke the hello microservice by sending a message to the hello address and get a reply. The microservice will reimplement the same logic as in the previous chapter and invoke the service twice (once with Luke and once with Leia).\n\nAs usual, let’s create a new project:\n\nmkdir hello-consumer-microservice-message cd hello-consumer-microservice-message\n\nmvn io.fabric8:vertx-maven-plugin:1.0.5:setup \\ -DprojectGroupId=io.vertx.microservice \\ -DprojectArtifactId=hello-consumer-microservice-message \\ -Dverticle=io.vertx.book.message.HelloConsumerMicroservice \\ -Ddependencies=infinispan,rx\n\nHere we also add the Vert.x RxJava support to benefit from the RX- ified APIs provided by Vert.x. If you updated the Infinispan configu‐ ration in the previous section, you need to copy it to this new project.\n\nNow edit the io.vertx.book.message.HelloConsumerMicroser vice. Since we are going to use RxJava, change the import statement to match io.vertx.rxjava.core.AbstractVerticle. Then imple‐ ment the start method with:\n\n@Override public void start() { EventBus bus = vertx.eventBus(); Single<JsonObject> obs1 = bus .<JsonObject>rxSend(\"hello\", \"Luke\") .map(Message::body); Single<JsonObject> obs2 = bus .<JsonObject>rxSend(\"hello\", \"Leia\") .map(Message::body);\n\nInitiating Message-Based Interactions\n\n|\n\n35",
      "content_length": 1679,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 42,
      "content": "Single .zip(obs1, obs2, (luke, leia) -> new JsonObject() .put(\"Luke\", luke.getString(\"message\")) .put(\"Leia\", leia.getString(\"message\")) ) .subscribe( x -> System.out.println(x.encode()), Throwable::printStackTrace); }\n\nThis code is very similar to the code from the previous chapter. Instead of using a WebClient to invoke an HTTP endpoint, we will use the event bus to send a message to the hello address and extract the body of the reply. We use the zip operation to retrieve the two responses and build the final result. In the subscribe method, we print the final result to the console or print the stack trace.\n\nLet’s combine this with an HTTP server. When an HTTP request is received, we invoke the hello service twice and return the built result as a response:\n\n@Override public void start() { vertx.createHttpServer() .requestHandler( req -> { EventBus bus = vertx.eventBus(); Single<JsonObject> obs1 = bus .<JsonObject>rxSend(\"hello\", \"Luke\") .map(Message::body); Single<JsonObject> obs2 = bus .<JsonObject>rxSend(\"hello\", \"Leia\") .map(Message::body);\n\nSingle .zip(obs1, obs2, (luke, leia) -> new JsonObject() .put(\"Luke\", luke.getString(\"message\") + \" from \" + luke.getString(\"served-by\")) .put(\"Leia\", leia.getString(\"message\") + \" from \" + leia.getString(\"served-by\")) ) .subscribe( x -> req.response().end(x.encodePrettily()), t -> { t.printStackTrace(); req.response().setStatusCode(500)\n\n36\n\n|\n\nChapter 3: Building Reactive Microservices",
      "content_length": 1453,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 43,
      "content": ".end(t.getMessage()); } ); }) .listen(8082); }\n\nThe last code just wraps the event bus interactions into a requestHandler and deals with the HTTP response. In case of fail‐ ure, we return a JSON object containing an error message.\n\ncode with mvn compile vertx:run If -Dvertx.runArgs=\"-cluster -Djava.net.preferIPv4Stack=true\" and open your browser to http://localhost:8082, you should see something like:\n\nyou\n\nrun\n\nthis\n\n{ \"Luke\" : \"hello Luke from ...HelloMicroservice@39721ab\", \"Leia\" : \"hello Leia from ...HelloMicroservice@39721ab\" }\n\nAre We Reactive Now? The code is very close to the HTTP-based microservice we wrote previously. The only difference is we used an event bus instead of HTTP. Does this change our reactiveness? It does! Let’s see why.\n\nElasticity Elasticity is one of the characteristics not enforced by the HTTP ver‐ sion of the microservice. Because the microservice was targeting a specific instance of the microservice (using a hard-coded URL), it didn’t provide the elasticity we need. But now that we are using mes‐ sages sent to an address, this changes the game. Let’s see how this microservice system behaves.\n\nRemember the output of the previous execution. The returned JSON objects display the verticle having computed the hello mes‐ sage. The output always displays the same verticle. The message was indicating the same instance. We expected this because we had a sin‐ gle instance running. Now let’s see what happens with two.\n\nStop the vertx:run execution of the Hello microservice and run:\n\nmvn clean package\n\nAre We Reactive Now?\n\n|\n\n37",
      "content_length": 1574,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 44,
      "content": "Then, open two different terminals in the hello-microservice- message directory and issue the following command (in each termi‐ nal):\n\njava -jar target/hello-microservice-message-1.0-SNAPSHOT.jar \\ --cluster -Djava.net.preferIPv4Stack=true\n\nThis launches two instances of the Hello microservice. Go back to your browser and refresh the page and you should see something like:\n\n{ \"Luke\" : \"hello Luke from ...HelloMicroservice@16d0d069\", \"Leia\" : \"hello Leia from ...HelloMicroservice@411fc4f\" }\n\nThe two instances of Hello are used. The Vert.x cluster connects the different nodes, and the event bus is clustered. Thanks to the event bus round-robin, the Vert.x event bus dispatches messages to the available instances and thus balances the load among the different nodes listening to the same address.\n\nSo, by using the event bus, we have the elasticity characteristic we need.\n\nResilience What about resilience? In the current code, if the hello microservice failed, we would get a failure and execute this code:\n\nt -> { t.printStackTrace(); req.response().setStatusCode(500).end(t.getMessage()); }\n\nEven though the user gets an error message, we don’t crash, we don’t limit our scalability, and we can still handle requests. However, to improve the user experience, we should always reply in a timely fashion to the user, even if we don’t receive the responses from the service. To implement this logic, we can enhance the code with a timeout.\n\nTo illustrate this, let’s modify the Hello microservice to inject fail‐ ures and misbehaviors. This code is located in the microservices/ hello-microservice-faulty directory of the code repository.\n\n38\n\n|\n\nChapter 3: Building Reactive Microservices",
      "content_length": 1696,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 45,
      "content": "This new start method randomly selects one of three strategies: (1) reply with an explicit failure, (2) forget to reply (leading to a timeout on the consumer side), or (3) send the correct result.\n\n@Override public void start() { vertx.eventBus().<String>consumer(\"hello\", message -> { double chaos = Math.random(); JsonObject json = new JsonObject() .put(\"served-by\", this.toString());\n\nif (chaos < 0.6) { // Normal behavior if (message.body().isEmpty()) { message.reply(json.put(\"message\", \"hello\")); } else { message.reply(json.put(\"message\", \"hello \" + message.body())); } } else if (chaos < 0.9) { System.out.println(\"Returning a failure\"); // Reply with a failure message.fail(500, \"message processing failure\"); } else { System.out.println(\"Not replying\"); // Just do not reply, leading to a timeout on the // consumer side. } }); }\n\nRepackage and restart the two instances of the Hello microservice.\n\nWith this fault injection in place, we need to improve the fault- tolerance of our consumer. Indeed, the consumer may get a timeout or receive an explicit failure. In the hello consumer microservice, change how we invoke the hello service to:\n\nEventBus bus = vertx.eventBus(); Single<JsonObject> obs1 = bus .<JsonObject>rxSend(\"hello\", \"Luke\") .subscribeOn(RxHelper.scheduler(vertx)) .timeout(3, TimeUnit.SECONDS) .retry() .map(Message::body); Single<JsonObject> obs2 = bus. <JsonObject>rxSend(\"hello\", \"Leia\") .subscribeOn(RxHelper.scheduler(vertx)) .timeout(3, TimeUnit.SECONDS)\n\nAre We Reactive Now?\n\n|\n\n39",
      "content_length": 1518,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 46,
      "content": ".retry() .map(Message::body);\n\nlocated in the microservices/hello-consumer- This code is microservice-timeout directory of the code repository. The time out method emits a failure if we don’t receive a response in the given time. The retry method reattempts to retrieve the value if it gets a failure in the form of a timeout or an explicit failure. The subscribeOn method indicates on which thread the invocations need to be done. We use the Vert.x event loop to call our callbacks. Without this, the methods would be executed by a thread from the default RxJava thread pool, breaking the Vert.x threading model. The RXHelper class is provided by Vert.x. Blindly retrying service invocations is not a very clever fault tolerance strategy. It can even be harmful. The next chapter details different approaches.\n\nNow you can reload the page. You will always get a result, even if there are failures or timeouts. Remember that the thread is not blocked while calling the service, so you can always accept new requests and respond to them in a timely fashion. However, this timeout retry often causes more harm than good, as we will see in the next chapter.\n\nSummary In this section, we learned how to develop an HTTP microservice with Vert.x and also how to consume it. As we learned, hard-coding the URL of the consumed service in the code is not a brilliant idea as it breaks one of the reactive characteristics. In the second part, we replaced the HTTP interactions using messaging, which showed how messaging and the Vert.x event bus help build reactive micro‐ services.\n\nSo, are we there yet? Yes and no. Yes, we know how to build reactive microservices, but there are a couple of shortcomings we need to look at. First, what if you only have HTTP services? How do you avoid hard-coded locations? What about resilience? We have seen timeouts and retries in this chapter, but what about circuit breakers, failovers, and bulkheads? Let’s continue the journey.\n\n40\n\n|\n\nChapter 3: Building Reactive Microservices",
      "content_length": 2011,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 47,
      "content": "If you want to go further on these topics:\n\nVert.x Web documentation\n\nVert.x Web Client documentation\n\nVert.x reactive microservices\n\nSummary\n\n|\n\n41",
      "content_length": 148,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 49,
      "content": "CHAPTER 4 Building Reactive Microservice Systems\n\nThe previous chapter focused on building microservices, but this chapter is all about building systems. Again, one microservice doesn’t make a service—they come in systems. When you embrace the microservice architectural style, you will have dozens of micro‐ services. Managing two microservices, as we did in the last chapter, is easy. The more microservices you use, the more complex the application becomes.\n\nFirst, we will learn how service discovery can be used to address location transparency and mobility. Then, we will discuss resilience and stability patterns such as timeouts, circuit breakers, and fail- overs.\n\nService Discovery When you have a set of microservices, the first question you have to answer is: how will these microservices locate each other? In order to communicate with another peer, a microservice needs to know its address. As we did in the previous chapter, we could hard-code the address (event bus address, URLs, location details, etc.) in the code or have it externalized into a configuration file. However, this solu‐ tion does not enable mobility. Your application will be quite rigid and the different pieces won’t be able to move, which contradicts what we try to achieve with microservices.\n\n43",
      "content_length": 1284,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 50,
      "content": "Client- and Server-Side Service Discovery Microservices need to be mobile but addressable. A consumer needs to be able to communicate with a microservice without knowing its exact location in advance, especially since this location may change over time. Location transparency provides elasticity and dynamism: the consumer may call different instances of the microservice using a round-robin strategy, and between two invocations the microser‐ vice may have been moved or updated.\n\nLocation transparency can be addressed by a pattern called service discovery. Each microservice should announce how it can be invoked and its characteristics, including its location of course, but also other metadata such as security policies or versions. These announcements are stored in the service discovery infrastructure, which is generally a service registry provided by the execution envi‐ ronment. A microservice can also decide to withdraw its service from the registry. A microservice looking for another service can also search this service registry to find matching services, select the best one (using any kind of criteria), and start using it. These inter‐ actions are depicted in Figure 4-1.\n\nFigure 4-1. Interactions with the service registry\n\nTwo types of patterns can be used to consume services. When using client-side service discovery, the consumer service looks for a service based on its name and metadata in the service registry, selects a matching service, and uses it. The reference retrieved from the ser‐ vice registry contains a direct link to a microservice. As microservi‐ ces are dynamic entities, the service discovery infrastructure must not only allow providers to publish their services and consumers to look for services, but also provide information about the arrivals and\n\n44\n\n|\n\nChapter 4: Building Reactive Microservice Systems",
      "content_length": 1851,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 51,
      "content": "departures of services. When using client-side service discovery, the service registry can take various forms such as a distributed data structure, a dedicated infrastructure such as Consul, or be stored in an inventory service such as Apache Zookeeper or Redis.\n\nAlternatively, you can use server-side service discovery and let a load balancer, a router, a proxy, or an API gateway manage the discovery for you (Figure 4-2). The consumer still looks for a service based on its name and metadata but retrieves a virtual address. When the consumer invokes the service, the request is routed to the actual implementation. You would use this mechanism on Kubernetes or when using AWS Elastic Load Balancer.\n\nFigure 4-2. Server-side service discovery\n\nVert.x Service Discovery Vert.x provides an extensible service discovery mechanism. You can use client-side or server-side service discovery using the same API. The Vert.x service discovery can import or export services from many types of service discovery infrastructures such as Consul or Kubernetes (Figure 4-3). It can also be used without any dedicated service discovery infrastructure. In this case, it uses a distributed data structure shared on the Vert.x cluster.\n\nService Discovery\n\n|\n\n45",
      "content_length": 1246,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 52,
      "content": "Figure 4-3. Import and export of services from and to other service dis‐ covery mechanisms\n\nYou can retrieve services by types to get a configured service client ready to be used. A service type can be an HTTP endpoint, an event bus address, a data source, and so on. For example, if you want to retrieve the HTTP endpoint named hello that we implemented in the previous chapter, you would write the following code:\n\n// We create an instance of service discovery ServiceDiscovery discovery = ServiceDiscovery.create(vertx); // As we know we want to use an HTTP microservice, we can // retrieve a WebClient already configured for the service HttpEndpoint .rxGetWebClient(discovery, // This method is a filter to select the service rec -> rec.getName().endsWith(\"hello\") ) .flatMap(client -> // We have retrieved the WebClient, use it to call // the service client.get(\"/\").as(BodyCodec.string()).rxSend()) .subscribe(response -> System.out.println(response.body()));\n\nThe retrieved WebClient is configured with the service location, which means you can immediately use it to call the service. If your environment is using client-side discovery, the configured URL tar‐ gets a specific instance of the service. If you are using server-side discovery, the client uses a virtual URL.\n\nDepending on your runtime infrastructure, you may have to register your service. But when using server-side service discovery, you usu‐\n\n46\n\n|\n\nChapter 4: Building Reactive Microservice Systems",
      "content_length": 1474,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 53,
      "content": "ally don’t have to do this since you declare your service when it is deployed. Otherwise, you need to publish your service explicitly. To publish a service, you need to create a Record containing the service name, location, and metadata:\n\n// We create the service discovery object ServiceDiscovery discovery = ServiceDiscovery.create(vertx); vertx.createHttpServer() .requestHandler(req -> req.response().end(\"hello\")) .rxListen(8083) .flatMap( // Once the HTTP server is started (we are ready to serve) // we publish the service. server -> { // We create a record describing the service and its // location (for HTTP endpoint) Record record = HttpEndpoint.createRecord( \"hello\", // the name of the service \"localhost\", // the host server.actualPort(), // the port \"/\" // the root of the endpoint ); // We publish the service return discovery.rxPublish(record); } ) .subscribe(rec -> System.out.println(\"Service published\"));\n\nService discovery is a key component in a microservice infrastruc‐ ture. It enables dynamism, location transparency, and mobility. When dealing with a small set of services, service discovery may look cumbersome, but it’s a must-have when your system grows. The Vert.x service discovery provides you with a unique API regard‐ less of the infrastructure and the type of service discovery you use. However, when your system grows, there is also another variable that grows exponentially—failures.\n\nStability and Resilience Patterns When dealing with distributed systems, failures are first-class citi‐ zens and you have to live with them. Your microservices must be aware that the services they invoke can fail for many reasons. Every interaction between microservices will eventually fail in some way, and you need to be prepared for that failure. Failure can take differ‐ ent forms, ranging from various network errors to semantic errors.\n\nStability and Resilience Patterns\n\n|\n\n47",
      "content_length": 1907,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 54,
      "content": "Managing Failures in Reactive Microservices Reactive microservices are responsible for managing failures locally. They must avoid propagating the failure to another microservice. In other words, you should not delegate the hot potato to another microservice. Therefore, the code of a reactive microservice consid‐ ers failures as first-class citizens.\n\nThe Vert.x development model makes failures a central entity. When using the callback development model, the Handlers often receive an AsyncResult as a parameter. This structure encapsulates the result of an asynchronous operation. In the case of success, you can retrieve the result. On failure, it contains a Throwable describing the failure:\n\nclient.get(\"/\").as(BodyCodec.jsonObject()) .send(ar -> { if (ar.failed()) { Throwable cause = ar.cause(); // You need to manage the failure. } else { // It's a success JsonObject json = ar.result().body(); } });\n\nWhen using the RxJava APIs, the failure management can be made in the subscribe method:\n\nclient.get(\"/\").as(BodyCodec.jsonObject()) .rxSend() .map(HttpResponse::body) .subscribe( json -> { /* success */ }, err -> { /* failure */ } );\n\nIf a failure is produced in one of the observed streams, the error handler is called. You can also handle the failure earlier, avoiding the error handler in the subscribe method:\n\nclient.get(\"/\").as(BodyCodec.jsonObject()) .rxSend() .map(HttpResponse::body) .onErrorReturn(t -> { // Called if rxSend produces a failure // We can return a default value return new JsonObject(); })\n\n48\n\n|\n\nChapter 4: Building Reactive Microservice Systems",
      "content_length": 1584,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 55,
      "content": ".subscribe( json -> { // Always called, either with the actual result // or with the default value. } );\n\nManaging errors is not fun but it has to be done. The code of a reac‐ tive microservice is responsible for making an adequate decision when facing a failure. It also needs to be prepared to see its requests to other microservices fail.\n\nUsing Timeouts When dealing with distributed interactions, we often use timeouts. A timeout is a simple mechanism that allows you to stop waiting for a response once you think it will not come. Well-placed timeouts provide failure isolation, ensuring the failure is limited to the micro‐ service it affects and allowing you to handle the timeout and con‐ tinue your execution in a degraded mode.\n\nclient.get(path) .rxSend() // Invoke the service // We need to be sure to use the Vert.x event loop .subscribeOn(RxHelper.scheduler(vertx)) // Configure the timeout, if no response, it publishes // a failure in the Observable .timeout(5, TimeUnit.SECONDS) // In case of success, extract the body .map(HttpResponse::bodyAsJsonObject) // Otherwise use a fallback result .onErrorReturn(t -> { // timeout or another exception return new JsonObject().put(\"message\", \"D'oh! Timeout\"); }) .subscribe( json -> { System.out.println(json.encode()); } );\n\nTimeouts are often used together with retries. When a timeout occurs, we can try again. Immediately retrying an operation after a failure has a number of effects, but only some of them are beneficial. If the operation failed because of a significant problem in the called microservice, it is likely to fail again if retried immediately. How‐ ever, some kinds of transient failures can be overcome with a retry,\n\nStability and Resilience Patterns\n\n|\n\n49",
      "content_length": 1737,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 56,
      "content": "especially network failures such as dropped messages. You can decide whether or not to reattempt the operation as follows:\n\nclient.get(path) .rxSend() .subscribeOn(RxHelper.scheduler(vertx)) .timeout(5, TimeUnit.SECONDS) // Configure the number of retries // here we retry only once. .retry(1) .map(HttpResponse::bodyAsJsonObject) .onErrorReturn(t -> { return new JsonObject().put(\"message\", \"D'oh! Timeout\"); }) .subscribe( json -> System.out.println(json.encode()) );\n\nIt’s also important to remember that a timeout does not imply an operation failure. In a distributed system, there are many reasons for failure. Let’s look at an example. You have two microservices, A and B. A is sending a request to B, but the response does not come in time and A gets a timeout. In this scenario, three types of failure could have occurred:\n\n1. The message between A and B has been lost—the operation is not executed.\n\n2. The operation in B failed—the operation has not completed its execution.\n\n3. The response message between B and A has been lost—the operation has been executed successfully, but A didn’t get the response.\n\nThis last case is often ignored and can be harmful. In this case, com‐ bining the timeout with a retry can break the integrity of the system. Retries can only be used with idempotent operations, i.e., with oper‐ ations you can invoke multiple times without changing the result beyond the initial call. Before using a retry, always check that your system is able to handle reattempted operations gracefully.\n\nRetry also makes the consumer wait even longer to get a response, which is not a good thing either. It is often better to return a fallback than to retry an operation too many times. In addition, continually hammering a failing service may not help it get back on track. These\n\n50\n\n|\n\nChapter 4: Building Reactive Microservice Systems",
      "content_length": 1860,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 57,
      "content": "two concerns are managed by another resilience pattern: the circuit breaker.\n\nCircuit Breakers A circuit breaker is a pattern used to deal with repetitive failures. It protects a microservice from calling a failing service again and again. A circuit breaker is a three-state automaton that manages an interaction (Figure 4-4). It starts in a closed state in which the circuit breaker executes operations as usual. If the interaction succeeds, nothing happens. If it fails, however, the circuit breaker makes a note of the failure. Once the number of failures (or frequency of fail‐ ures, in more sophisticated cases) exceeds a threshold, the circuit breaker switches to an open state. In this state, calls to the circuit breaker fail immediately without any attempt to execute the under‐ lying interaction. Instead of executing the operation, the circuit breaker may execute a fallback, providing a default result. After a configured amount of time, the circuit breaker decides that the operation has a chance of succeeding, so it goes into a half-open state. In this state, the next call to the circuit breaker executes the underlying interaction. Depending on the outcome of this call, the circuit breaker resets and returns to the closed state, or returns to the open state until another timeout elapses.\n\nFigure 4-4. Circuit breaker states\n\nThe most well-known circuit breaker implementation in Java is Hys‐ trix (https://github.com/Netflix/Hystrix). While you can use Hystrix in a Vert.x microservice (it uses a thread pool), you need to explic‐ itly switch to the Vert.x event loop to execute the different callbacks. Alternatively, you can use the Vert.x circuit breaker built for asyn‐ chronous operations and enforce the Vert.x nonblocking asynchro‐ nous development model.\n\nStability and Resilience Patterns\n\n|\n\n51",
      "content_length": 1824,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 58,
      "content": "Let’s imagine a failing hello microservice. The consumer should pro‐ tect the interactions with this service and use a circuit breaker as fol‐ lows:\n\nCircuitBreaker circuit = CircuitBreaker.create(\"my-circuit\", vertx, new CircuitBreakerOptions() .setFallbackOnFailure(true) // Call the fallback // on failures .setTimeout(2000) // Set the operation timeout .setMaxFailures(5) // Number of failures before // switching to // the 'open' state .setResetTimeout(5000) // Time before attempting // to reset // the circuit breaker ); // ... circuit.rxExecuteCommandWithFallback( future -> client.get(path) .rxSend() .map(HttpResponse::bodyAsJsonObject) .subscribe(future::complete, future::fail), t -> new JsonObject().put(\"message\", \"D'oh! Fallback\") ).subscribe( json -> { // Get the actual json or the fallback value System.out.println(json.encode()); } );\n\nIn this code, the HTTP interaction is protected by the circuit breaker. When the number of failures reaches the configured thres‐ hold, the circuit breaker will stop calling the microservice and instead call a fallback. Periodically, the circuit breaker will let one invocation pass through to check whether the microservice is back on track and act accordingly. This example uses a web client, but any interaction can be managed with a circuit breaker and protect you against flaky services, exceptions, and other sorts of failures.\n\nA circuit breaker switching to an open state needs to be monitored by your operations team. Both Hystrix and the Vert.x circuit breaker have monitoring capabilities.\n\n52\n\n|\n\nChapter 4: Building Reactive Microservice Systems",
      "content_length": 1613,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 59,
      "content": "Health Checks and Failovers While timeouts and circuit breakers allow consumers to deal with failures on their side, what about crashes? When facing a crash, a failover strategy restarts the parts of the system that have failed. But before being able to achieve this, we must be able to detect when a microservice has died.\n\nA health check is an API provided by a microservice indicating its state. It tells the caller whether or not the service is healthy. The invocation often uses HTTP interactions but is not necessary. After invocation, a set of checks is executed and the global state is compu‐ ted and returned. When a microservice is detected to be unhealthy, it should not be called anymore, as the outcome is probably going to be a failure. Note that calling a healthy microservice does not guar‐ antee a success either. A health check merely indicates that the microservice is running, not that it will accurately handle your request or that the network will deliver its answer.\n\nDepending on your environment, you may have different levels of health checks. For instance, you may have a readiness check used at deployment time to determine when the microservice is ready to serve requests (when everything has been initialized correctly). Liv‐ eness checks are used to detect misbehaviors and indicate whether the microservice is able to handle requests successfully. When a liv‐ eness check cannot be executed because the targeted microservice does not respond, the microservice has probably crashed.\n\nIn a Vert.x application, there are several ways to implement health checks. You can simply implement a route returning the state, or even use a real request. You can also use the Vert.x health check module to implement several health checks in your application and compose the different outcomes. The following code gives an exam‐ ple of an application providing two levels of health checks:\n\nRouter router = Router.router(vertx); HealthCheckHandler hch = HealthCheckHandler.create(vertx); // A procedure to check if we can get a database connection hch.register(\"db-connection\", future -> { client.rxGetConnection() .subscribe(c -> { future.complete(); c.close(); }, future::fail\n\nStability and Resilience Patterns\n\n|\n\n53",
      "content_length": 2237,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 60,
      "content": "); }); // A second (business) procedure hch.register(\"business-check\", future -> { // ... }); // Map /health to the health check handler router.get(\"/health\").handler(hch); // ...\n\nAfter you have completed health checks, you can implement a fail- over strategy. Generally, the strategy just restarts the dead part of the system, hoping for the best. While failover is often provided by your runtime infrastructure, Vert.x offers a built-in failover, which is trig‐ gered when a node from the cluster dies. With the built-in Vert.x failover, you don’t need a custom health check as the Vert.x cluster pings nodes periodically. When Vert.x loses track of a node, Vert.x chooses a healthy node of the cluster and redeploys the dead part.\n\nFailover keeps your system running but won’t fix the root cause— that’s your job. When an application dies unexpectedly, a postmor‐ tem analysis should be done.\n\nSummary This chapter has addressed several concerns you will face when your microservice system grows. As we learned, service discovery is a must-have in any microservice system to ensure location transpar‐ ency. Then, because failures are inevitable, we discussed a couple of patterns to improve the resilience and stability of your system.\n\nVert.x includes a pluggable service discovery infrastructure that can handle client-side service discovery and server-side service discov‐ ery using the same API. The Vert.x service discovery is also able to import and export services from and to different service discovery infrastructures. Vert.x includes a set of resilience patterns such as timeout, circuit breaker, and failover. We saw different examples of these patterns. Dealing with failure is, unfortunately, part of the job and we all have to do it.\n\nIn the next chapter, we will learn how to deploy Vert.x reactive microservices on OpenShift and illustrate how service discovery, circuit breakers, and failover can be used to make your system almost bulletproof. While these topics are particularly important, don’t underestimate the other concerns that need to be handled\n\n54\n\n|\n\nChapter 4: Building Reactive Microservice Systems",
      "content_length": 2134,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 61,
      "content": "when dealing with microservices, such as security, deployment, aggregated logging, testing, etc.\n\nIf you want to learn more about these topics, check the following resources:\n\nReactive Microservices Architecture\n\nThe Vert.x service discovery documentation\n\nRelease It! Design and Deploy Production-Ready Software (O’Reilly) A book providing a list of recipes to make your sys‐ tem ready for production\n\nNetflix Hystrix\n\nThe Vert.x service circuit breaker documentation\n\nSummary\n\n|\n\n55",
      "content_length": 484,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 63,
      "content": "CHAPTER 5 Deploying Reactive Microservices in OpenShift\n\nSo far, we have only deployed our microservices on a local machine. What happens when we deploy a microservice on the cloud? Most cloud platforms include services to make your deployment and operations easier. The ability to scale up and down and load balance are some of the commonly found features that are particularly rele‐ vant to developing reactive microservices. In this chapter, we will see how these features (and others) can be used to develop and deploy reactive microservices.\n\nTo illustrate these benefits, we will use OpenShift (https://www.open shift.org/). However, most modern cloud platforms include the fea‐ tures we use here. By the end of this chapter, you will see how the cloud makes reactiveness easy for everyone.\n\nWhat Is OpenShift? RedHat OpenShift v3 is an open source container platform. With OpenShift you deploy applications running in containers, which makes their construction and administration easy. OpenShift is built on top of Kubernetes (https://kubernetes.io/).\n\nKubernetes (in blue in Figure 5-1) is a project with lots of function‐ ality for running clusters of microservices inside Linux containers at scale. Google has packaged over a decade of experience with con‐ tainers into Kubernetes. OpenShift is built on top of this experience\n\n57",
      "content_length": 1340,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 64,
      "content": "and extends it with build and deployment automation (in green in Figure 5-1). Use cases such as rolling updates, canary deployments, and continuous delivery pipelines are provided out of the box.\n\nFigure 5-1. The OpenShift container platform\n\nOpenShift has a handful of simple entities, as depicted in Figure 5-2, that we need to understand before putting it to work.\n\n58\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift",
      "content_length": 432,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 65,
      "content": "Figure 5-2. The OpenShift entities\n\nBuild Configuration The build is the process of creating container images that will be used by OpenShift to instantiate the different containers that make up an application. OpenShift builds can use different strategies:\n\nDocker—Build an image from a Dockerfile\n\nSource to Image (S2I)—Build an image from the application source, built on OpenShift by a builder image\n\nJenkins Pipeline—Build an image using a Jenkins pipeline (https://jenkins.io/doc/book/pipeline) potentially containing mul‐ tiple stages such as build, tests, and deployment\n\nA build configuration can be triggered automatically by a git push, a change in the configuration or an update in a dependent image, and, obviously, manually.\n\nDeployment Configurations A deployment configuration defines the instantiation of the image produced by a build. It defines which image is used to create the containers and the number of instances we need to keep alive. It also describes when a deployment should be triggered. A deployment also acts as a replication controller and is responsible for keeping containers alive. To achieve this, you pass the number of desired instances. The number of desired instances can be adjusted over time or based on the load fluctuation (auto-scaling). The deployment\n\nWhat Is OpenShift?\n\n|\n\n59",
      "content_length": 1323,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 66,
      "content": "can also specify health checks to manage rolling updates and detect dead containers.\n\nPods A pod is a group of one or more containers. However, it is typically comprised of a single container. The pod orchestration, scheduling, and management are delegated to Kubernetes. Pods are fungible, and can be replaced at any time by another instance. For example, if the container crashes, another instance will be spawned.\n\nServices and Routes Because pods are dynamic entities (the number of instances can change over time), we cannot rely on their direct IP addresses (each pod has its own IP address). Services allow us to communicate with the pods without relying on their addresses but by using the service virtual address. A service acts as a proxy in front of a group of pods. It may also implement a load-balancing strategy.\n\nOther applications running in OpenShift can access the functional‐ ity offered by the pods using the service, but external applications need a route. A route exposes a service at a hostname like www.myservice.com so that external clients can reach it by name.\n\nInstalling OpenShift on Your Machine That’s enough abstract concepts. Now it’s time for action. We are going to install Openshift on your machine using Minishift (https:// github.com/minishift/minishift). Alternatively, you can use Open‐ Shift Online (https://www.openshift.com/devpreview/) or the Red Hat Container Development Kit v3 (https://developers.redhat.com/ products/cdk/download/).\n\nInstalling Minishift (https://github.com/minishift/minishift#installa tion) requires a hypervisor to run the virtual machine containing OpenShift. Depending on your host OS, you have a choice of hyper‐ visors; check the Minishift installation guide for details.\n\nTo install Minishift, just download the latest archive for your OS from the Minishift releases page (https://github.com/minishift/minis hift/releases), unpack it to your preferred location, and add the\n\n60\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift",
      "content_length": 2011,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 67,
      "content": "minishift binary to your PATH environment variable. Once installed, start Minishift using:\n\nminishift start\n\nOnce started, you should be able to connect to your OpenShift instance on https://192.168.64.12:8443. You may have to validate the SSL certificate. Log in with developer/developer.\n\nWe also need the OpenShift client (oc), a command-line utility used to interact with your OpenShift instance. Download the latest ver‐ sion of the OpenShift client from https://github.com/openshift/ origin/releases/latest. Unpack it to your preferred location and add the oc binary to your PATH environment variable.\n\nThen, connect to your OpenShift instance using:\n\noc login https://192.168.64.12:8443 -u developer -p developer\n\nOpenShift has a namespace concept called project. To create projects for the examples we are going to deploy, execute:\n\noc new-project reactive-microservices oc policy add-role-to-user admin developer -n reactive-microservices oc policy add-role-to-user view -n reactive-microservices -z default\n\nIn your browser, open https://192.168.64.12:8443/console/project/ reactive-microservices/. You should be able to see the project, which is not very interesting at the moment as we haven’t deployed any‐ thing (Figure 5-3).\n\nFigure 5-3. The created project\n\nInstalling OpenShift on Your Machine\n\n|\n\n61",
      "content_length": 1317,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 68,
      "content": "Deploying a Microservice in OpenShift It’s time to deploy a microservice to OpenShift. The code we are the openshift/hello- going microservice-openshift directory of the code repository. The ver‐ ticle is very close to the hello microservice (HTTP) we developed earlier:\n\nto deploy\n\nis contained\n\nin\n\npackage io.vertx.book.openshift;\n\nimport io.vertx.core.AbstractVerticle; import io.vertx.core.http.HttpHeaders; import io.vertx.core.json.JsonObject; import io.vertx.ext.web.*;\n\npublic class HelloHttpVerticle extends AbstractVerticle {\n\nstatic final String HOSTNAME = System.getenv(\"HOSTNAME\");\n\n@Override public void start() { Router router = Router.router(vertx); router.get(\"/\").handler(this::hello); router.get(\"/:name\").handler(this::hello); vertx.createHttpServer() .requestHandler(router::accept) .listen(8080); }\n\nprivate void hello(RoutingContext rc) { String message = \"hello\"; if (rc.pathParam(\"name\") != null) { message += \" \" + rc.pathParam(\"name\"); } JsonObject json = new JsonObject() .put(\"message\", message) .put(\"served-by\", HOSTNAME); rc.response() .putHeader(HttpHeaders.CONTENT_TYPE, \"application/json\") .end(json.encode()); } }\n\nThis code does not rely on specific OpenShift APIs or constructs. It’s your application as you would have developed it on your machine. The separation of Java code from deployment choices must be a deliberate design choice to make the code runnable on any cloud platform.\n\n62\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift",
      "content_length": 1488,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 69,
      "content": "We could create all the OpenShift entities manually, but let’s use the Maven plug-in (https://maven.fabric8.io/) provided by Fabric8, an end-to-end development platform for Kubernetes. If you open the pom.xml file, you will see that this plug-in is configured in the open shift profile and collaborates with the Vert.x Maven plug-in to cre‐ ate the OpenShift entities.\n\nTo package and deploy our microservice to OpenShift, launch:\n\nmvn fabric8:deploy -Popenshift\n\nThis command interacts with your OpenShift instance (on which you have logged in with oc) to create a build (using the source to image build strategy) and trigger it. This first build can take some time as it needs to retrieve the builder image. Don’t worry—once everything is cached, the builds will be created faster. The output of the build (and image) is used by the deployment configuration, which is also created by the Fabric8 Maven plug-in. By default, it creates one pod. A service is also created by the plug-in. You can find all this information in the OpenShift dashboard, as shown in Figure 5-4.\n\nFigure 5-4. Entities created during our first deployment\n\nRoutes are not created by default by the Fabric8 Maven plug-in. However, we created one from its description (src/main/fabric8/ route.yml). If you open your browser to http://hello-microservice- reactive-microservices.192.168.64.12.nip.io/Luke, you should see something like:\n\n{\"message\":\"hello Luke\",\"served-by\": \"hello-microservice-1-9r8uv\"}\n\nDeploying a Microservice in OpenShift\n\n|\n\n63",
      "content_length": 1521,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 70,
      "content": "hello-microservice-1-9r8uv is the name of the pod serving the request.\n\nService Discovery Now that we have the hello microservice deployed, let’s consume it from another microservice. The code we are going to deploy in this in the openshift/hello-microservice- section consumer-openshift directory from the code repository.\n\nis contained\n\nTo consume a microservice, we first have to find it. OpenShift pro‐ vides a service discovery mechanism. Service lookup can be done using environment variables, DNS, or the Vert.x service discovery, which we use here. The project pom.xml is configured to import the Vert.x service discovery, the Kubernetes service importer, and a server-side service discovery. You don’t have to explicitly register the service on the provider side as the Fabric8 Maven plug-in declares a service for us. Our consumer is going to retrieve this OpenShift ser‐ vice and not the pods.\n\n@Override public void start() { Router router = Router.router(vertx); router.get(\"/\").handler(this::invokeHelloMicroservice); // Create the service discovery instance ServiceDiscovery.create(vertx, discovery -> { // Look for an HTTP endpoint named \"hello-microservice\" // you can also filter on 'label' Single<WebClient> single = HttpEndpoint.rxGetWebClient (discovery, rec -> rec.getName().equals (\"hello-microservice\"), new JsonObject().put(\"keepAlive\", false)); single.subscribe( client -> { // the configured client to call the microservice this.hello = client; vertx.createHttpServer() .requestHandler(router::accept) .listen(8080); }, err -> System.out.println(\"Oh no, no service\") ); }); }\n\nIn the start method, we use the service discovery to find the hello microservice. Then, if the service is available, we start the HTTP\n\n64\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift",
      "content_length": 1803,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 71,
      "content": "server and keep a reference on the retrieved WebClient. We also pass a configuration to the WebClient and disable the keep-alive settings (we will see the reason for this in a few minutes). In the invokeHelloMicroservice, we don’t have to pass the port and host to the rxSend method (as we did previously). Indeed, the WebClient is configured to target the hello service:\n\nHttpRequest<JsonObject> request1 = hello.get(\"/Luke\") .as(BodyCodec.jsonObject()); HttpRequest<JsonObject> request2 = hello.get(\"/Leia\") .as(BodyCodec.jsonObject()); Single<JsonObject> s1 = request1.rxSend() .map(HttpResponse::body); Single<JsonObject> s2 = request2.rxSend() .map(HttpResponse::body); // ...\n\nIn a terminal, navigate to the openshift/hello-microservice- consumer-openshift directory to build and deploy this consumer with:\n\nmvn fabric8:deploy -Popenshift\n\nIn the OpenShift dashboard, you should see a second service and route (http://bit.ly/2o4xaSk). If you open the route associated with the hello-consumer service (http://bit.ly/2p2aHTK), you should see:\n\n{ \"luke\" : \"hello Luke hello-microservice-1-sa5pf\", \"leia\" : \"hello Leia hello-microservice-1-sa5pf\" }\n\nYou may see a 503 error page, since the pod has not yet started. Just refresh until you get the right page. So far, nothing surprising. The displayed served-by values are always indicating the same pod (as we have only one).\n\nScale Up and Down If we are using a cloud platform, it’s mainly for scalability reasons. We want to be able to increase and decrease the number of instances of our application depending on the load. In the OpenShift dash‐ board we can scale the number of pods up and down, as shown in Figure 5-5.\n\nScale Up and Down\n\n|\n\n65",
      "content_length": 1700,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 72,
      "content": "Figure 5-5. Scale up and down\n\nYou can also set the number of replicas using the oc command line:\n\n# scale up to 2 replicas oc scale --replicas=2 dc hello-microservice\n\n# scale down to 0 oc scale --replicas=0 dc hello-microservice\n\nLet’s create a second instance of our hello microservice. Then, wait until the second microservice has started correctly (the wait time is annoying, but we will fix that later), and go back to the hello- consumer page in a browser. You should see something like:\n\n{ \"luke\" : \"hello Luke hello-microservice-1-h6bs6\", \"leia\" : \"hello Leia hello-microservice-1-keq8s\" }\n\nIf you refresh several times, you will see that the OpenShift service balances the load between the two instances. Do you remember the keep-alive settings we disabled? When the HTTP connection uses a keep-alive connection, OpenShift forwards the request to the same pod, providing connection affinity. Note that in practice, keep-alive is a very desirable header as it allows reusing connec‐ tions.\n\nIn the previous scenario there is a small issue. When we scale up, OpenShift starts dispatching requests to the new pod without check‐ ing whether the application is ready to serve these requests. So, our consumer may call a microservice that is not ready and get a failure. There are a couple of ways to address this:\n\n1. Using health checks in the microservice\n\n2. Be prepared to face the failure in the consumer code\n\n66\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift",
      "content_length": 1484,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 73,
      "content": "Health Check and Failover In OpenShift you can declare two types of checks. Readiness checks are used to avoid downtime when updating a microservice. In a roll‐ ing update, OpenShift waits until the new version is ready before shutting down the previous version. It pings the readiness check endpoint of the new microservice until it is ready, and verifies that the microservice has been successfully initialized. Liveness checks are used to determine whether a pod is alive. OpenShift invokes the liveness check endpoint periodically. If a pod does not reply posi‐ tively to the check, it will be restarted. A liveness check focuses on the critical resources required by the microservice to behave cor‐ rectly. In the following example we will use the same endpoint for both checks. However, it’s best to use two different endpoints.\n\nThe code of this example is contained in the openshift/hello- microservice-openshift-health-checks directory. If you open the verticle, you will see the HealthCheck handler verifying whether or not the HTTP server has been started:\n\nprivate boolean started;\n\n@Override public void start() { Router router = Router.router(vertx); router.get(\"/health\").handler( HealthCheckHandler.create(vertx) .register(\"http-server-running\", future -> future.complete( started ? Status.OK() : Status.KO()))); router.get(\"/\").handler(this::hello); router.get(\"/:name\").handler(this::hello); vertx.createHttpServer() .requestHandler(router::accept) .listen(8080, ar -> started = ar.succeeded()); }\n\nThe Fabric8 Maven plug-in is configured to use /health for the readiness and liveness health checks. Once this version of the hello microservice is deployed, all subsequent deployments will use the readiness check to avoid downtime, as shown in Figure 5-6.\n\nHealth Check and Failover\n\n|\n\n67",
      "content_length": 1807,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 74,
      "content": "Figure 5-6. Rolling updates\n\nWhen the pod is ready, OpenShift routes the requests to this pod and shuts down the old one. When we scale up, OpenShift doesn’t route requests to a pod that is not ready.\n\nUsing a Circuit Breaker While using health checks avoids calling a microservice that is not ready and restarts dead ones, we still need to protect ourselves from other failures such as timeouts, network outage, bugs in the called microservice, and so on. In this section we are going to protect the hello consumer using a circuit breaker. The code of this section is openshift/hello-microservice-consumer- located openshift-circuit-breaker directory.\n\nin\n\nthe\n\nIn the verticle, we are using a single circuit breaker to protect against the two calls to the hello microservice. The following code uses this design; however, it’s just one among a large set of possible approaches, such as using one circuit breaker per call, using a single circuit breaker but protecting the two calls independently, etc.:\n\nprivate void invokeHelloMicroservice(RoutingContext rc) { circuit.rxExecuteCommandWithFallback( future -> { HttpRequest<JsonObject> request1 = hello.get(\"/Luke\") .as(BodyCodec.jsonObject()); HttpRequest<JsonObject> request2 = hello.get(\"/Leia\") .as(BodyCodec.jsonObject()); Single<JsonObject> s1 = request1 .rxSend().map(HttpResponse::body); Single<JsonObject> s2 = request2 .rxSend().map(HttpResponse::body);\n\n68\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift",
      "content_length": 1480,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 75,
      "content": "Single .zip(s1, s2, (luke, leia) -> { // We have the result of both request in Luke and Leia return new JsonObject() .put(\"Luke\", luke.getString(\"message\") + \" \" + luke.getString(\"served-by\")) .put(\"Leia\", leia.getString(\"message\") + \" \" + leia.getString(\"served-by\")); }) .subscribe(future::complete, future::fail); }, error -> new JsonObject().put(\"message\", \"hello (fallback, \" + circuit.state().toString() + \")\") ).subscribe( x -> rc.response().end(x.encodePrettily()), t -> rc.response().end(t.getMessage())); }\n\nIn case of error, we provide a fallback message indicating the state of the circuit breaker. This will help us understand what’s going on. Deploy this project using:\n\nmvn fabric8:deploy -Popenshift\n\nNow let’s scale down the hello microservice to 0. To do this, we can click on the down arrow near the pod, or run:\n\noc scale --replicas=0 dc hello-microservice\n\nNow if you refresh the consumer page (http://hello-consumer- reactive-microservices.192.168.64.12.nip.io/), you should see the fall‐ back message. The first three requests show:\n\n{ \"message\" : \"hello (fallback, CLOSED)\" }\n\nOnce the number of failures is reached, it returns:\n\n{ \"message\" : \"hello (fallback, OPEN)\" }\n\nIf you restore the number of replicas to 1 with:\n\noc scale --replicas=1 dc hello-microservice\n\nyou should get back the normal output once the microservice is ready.\n\nUsing a Circuit Breaker\n\n|\n\n69",
      "content_length": 1392,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 76,
      "content": "But Wait, Are We Reactive? Yes, we are. Let’s see why.\n\nAll our interactions are asynchronous. They use asynchronous and nonblocking HTTP requests and responses. In addition, thanks to the OpenShift service, we are sending the requests to a virtual address, which enables elasticity. The service balances the load among a set of pods. We can easily scale up and down by adjusting the number of pods or by using auto-scaling. We are also resilient. Thanks to the health checks, we have a failover mechanism ensuring we always have the right number of pods running. On the consumer side, we can use various resilience patterns such as timeouts, retries, or circuit breakers to protect the microservice from failures. So our system is able to handle requests in a timely fashion under load and when facing failures: we are responsive!\n\nCan any system using asynchronous nonblocking HTTP be a reac‐ tive system in a cloud providing load-balancing and some resilience features? Yes, but don’t forget the costs. Vert.x uses an event loop to handle a high level of concurrency with a minimum of threads, exhibiting a cloud native nature. When using approaches relying on thread pools, you will need to 1) tune the thread pool to find the right size; 2) handle the concurrency in your code, which means debugging deadlocks, race conditions, and bottlenecks; and 3) mon‐ itor performance. Cloud environments are based on virtualization, and thread scheduling can become a major issue when you have many threads.\n\nThere are many nonblocking technologies, but not all of them use the same execution model to handle the asynchronous nature We can classify these technologies in three categories:\n\n1. Approaches using a thread pool in the background—Then you are facing a tuning, scheduling, and concurrency challenge shifting the burden to ops.\n\n2. Approaches using another thread for callbacks—You still need to manage the thread-safety of your code while avoiding dead‐ locks and bottlenecks.\n\n3. Approaches, such as Vert.x, using the same thread—You use a small number of threads and are freed from debugging dead‐ locks.\n\n70\n\n|\n\nChapter 5: Deploying Reactive Microservices in OpenShift",
      "content_length": 2177,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 77,
      "content": "Could we use messaging systems in the cloud to implement reactive microservice systems? Of course. We could have used the Vert.x event bus to build our reactive microservice in OpenShift. But it would not have demonstrated service virtual address and load- balancing provided by OpenShift as it would have been handled by Vert.x itself. Here we decided to go with HTTP, one design among an infinite number of choices. Shape your system the way you want it!\n\nSummary In this chapter, we deployed microservices in OpenShift and saw how Vert.x and the OpenShift features are combined to build reac‐ tive microservices. Combining asynchronous HTTP servers and cli‐ ents, OpenShift services, load-balancing, failover and consumer-side resilience gives us the characteristics of a reactive system.\n\nThis report focuses on reactive. However, when building a microser‐ vice system, lots of other concerns need to be managed such as secu‐ rity, configuration, logging, etc. Most cloud platforms, including OpenShift, provide services to handle these concerns.\n\nIf you want to learn more about these topics, check out the follow‐ ing resources:\n\nOpenShift website\n\nOpenShift core concepts\n\nKubernetes website\n\nOpenShift health checks documentation\n\nSummary\n\n|\n\n71",
      "content_length": 1253,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 79,
      "content": "CHAPTER 6 Conclusion\n\nWe are at the end of our journey together, but you have many new avenues to explore. We have covered a lot of content in this small report but certainly didn’t cover everything! We have just scratched the surface. There are more things to consider when moving toward reactive microservices. Vert.x is also not limited to microservices and can handle a large set of different use cases.\n\nWhat Have We Learned? So, what did you learn in this report? First, we started with micro‐ services and what are reactive microservices. We learned that reac‐ tive microservices are the building blocks of responsive microservice systems. We also saw how reactive programming helps to build these microservices.\n\nWe discovered Eclipse Vert.x, a toolkit used to build reactive micro‐ services (among many other things). Vert.x provides the perfect paradigm to embrace microservices: asynchronous, failures as first- class citizens, and nonblocking. To tame the asynchronous develop‐ ment model, Vert.x combines its power with RxJava. Our discovery started with HTTP microservices and how to consume them. While HTTP is often used in microservices, we also saw one of its limita‐ tions when we directly referenced an instance of a microservice. To address this, we used the Vert.x event bus and saw how message- based microservices let you build reactive microservices and thus reactive systems.\n\n73",
      "content_length": 1405,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 80,
      "content": "Of course, one microservice does not make an application. They come in systems. To build systems, we have to use service discovery. Service discovery enables location transparency and mobility, two important characteristics in microservice systems. We also covered resilience patterns, since microservice systems are distributed sys‐ tems and you need to be prepared for failure.\n\nIn the last chapter, we deployed our microservices on top of Open‐ Shift, an open source container platform based on Kubernetes. The combination of Vert.x and OpenShift simplifies the deployment and execution of reactive microservices and keeps the whole system on track.\n\nSo, is this the end? No! It’s only the end of the first stage.\n\nMicroservices Aren’t Easy Microservices are expected to improve overall agility. This improve‐ ment is not only a technical issue, it’s also an organization issue. If your organization does not embrace microservices from an organi‐ zation standpoint, no technologies will help you.\n\nWhile building microservices may seem simple, there’s actually a lot more to it. Microservice systems are distributed systems, and thus involve distributed computing laws. Failures are also inevitable. Each microservice should own its data, and you will typically need several persistence technologies.\n\nTo build microservice systems, there are a couple of topics to study further. First, to enable the promised agility, you are going to deploy the different microservices much more often. Therefore, continuous delivery is key. You also need to automate the release and deploy‐ ment of your microservices as much as possible. Don’t forget that your microservices are fungible, and immutable image delivery is a must-have feature in order to scale.\n\nHowever, if our deployed microservices are immutable, how do we pass in configuration information and potentially reconfigure them? For instance, how do we change the log level, configure the database location and credentials, toggle features, and so on? Configuration is a very important part of distributed systems and is difficult with microservices. All systems are different and there is no silver bullet, but there is a wide range of solutions, from environment variables to Git repositories and dedicated configuration servers. Cloud plat‐\n\n74\n\n|\n\nChapter 6: Conclusion",
      "content_length": 2327,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 81,
      "content": "forms also provide configuration abilities. To mitigate this diversity, Vert.x is capable of retrieving configurations from almost anywhere.\n\nOnce you deploy and configure your microservices, you need to keep your system on track. Logging, metrics, and tracing are impor‐ tant concerns to keep in mind when designing and developing a microservice system. You have to retrieve the logged messages, the measures, and the traces from your microservices to aggregate them in a centralized way to enable correlation and visualization. While logging and monitoring are generally well understood, distributed tracing is often ignored. However, traces are priceless in microservi‐ ces because they will help you identify bottlenecks, the affinity between microservices, and give you a good idea of the responsive‐ ness of your system.\n\nThe Evolution of the Microservice Paradigm Microservices are dynamic and always evolving. Recently, the server‐ less trend, also called function as a service, is gaining a lot of attrac‐ tion. In this new paradigm, your unit of deployment is a function. These functions receive and process messages. The serverless para‐ digm stresses the deployment, logging, and tracing facilities, but promotes a simple development model and improves the scalability of the system as you can instantiate as many instances of functions as you need to handle the load.\n\nHTTP/2 is also making a remarkable entrance in the microservice world. It improves the performance and scalability of HTTP 1.1 and allows multiplexing several requests over a single TCP connection. It also offers bidirectional communication. gRPC is a remote proce‐ dure call (RPC) framework relying on HTTP/2 and provides high- performance, multilanguage, secure, bidirectional interactions. It can efficiently connect services in and across data centers with plug‐ gable support for load balancing, tracing, health checking, and authentication. It is also applicable to embedded devices, mobile applications, and browsers. While RPC was initially considered harmful in microservice systems, it’s still widely popular. gRPC addresses the issues encountered with traditional RPC mechanisms, such as blocking calls and partial failures. However, be aware that sharing a contract (interface) between the provider microservice and consumers may limit your agility. Vert.x provides HTTP/2 cli‐\n\nThe Evolution of the Microservice Paradigm\n\n|\n\n75",
      "content_length": 2422,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 82,
      "content": "ent and servers. In addition, it has the ability to create and consume gRPC services.\n\nVert.x Versatility While this report has focused on reactive microservices, this is only a single facet of Vert.x. The richness of the Vert.x ecosystem lets you develop lots of different applications. Thanks to its execution model, your applications will be asynchronous and will embrace the reactive system mantra.\n\nModern web applications provide a real-time, interactive experience for users. The information is pushed to the browser and is displayed seamlessly. The Vert.x event bus can be used as the backbone to deliver such an experience. The browser connects to the event bus and receives messages, and can also send messages on and interact with the backend or with other browsers connected to the event bus.\n\nThe Internet of things (IoT) is a thrilling domain but also very het‐ erogeneous. There are many protocols used by smart devices. Mes‐ sages often have to be translated from one protocol to another. Vert.x provides clients for a large set of protocols to implement these translations, and its execution model can handle the high concur‐ rency required to build IoT gateways.\n\nThese two examples illustrate the richness of the Vert.x ecosystem. Vert.x offers an infinite set of possibilities where you are in charge. You can shape your system using the programming language you prefer and the development model you like. Don’t let a framework lead—you are in charge.\n\n76\n\n|\n\nChapter 6: Conclusion",
      "content_length": 1501,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 83,
      "content": "About the Author\n\nClement Escoffier (@clementplop) is a principal software engineer at Red Hat. He has had several professional lives, from academic positions to management. Currently, he is working as a Vert.x core developer. He has been involved in projects and products touching many domains and technologies such as OSGi, mobile app develop‐ ment, continuous delivery, and DevOps. Clement is an active con‐ tributor to many open source projects such as Apache Felix, iPOJO, Wisdom Framework, and Eclipse Vert.x.",
      "content_length": 515,
      "extraction_method": "Unstructured"
    }
  ]
}