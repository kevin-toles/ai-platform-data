{
  "metadata": {
    "title": "Test-Driven Development by Example - Kent Beck",
    "author": "Administrator",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 239,
    "conversion_date": "2025-12-19T17:47:24.699780",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "Test-Driven Development by Example - Kent Beck.pdf",
    "extraction_method": "Unstructured"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-9)",
      "start_page": 1,
      "end_page": 9,
      "detection_method": "topic_boundary",
      "content": "Test-DrivenDevelopment ByExample\n\nKent Beck, Three Rivers Institute\n\nCopyright (c) 2002, Kent Beck, All rights reserved Draft July 14, 2002 1:31 pm\n\nTo Do: Refactorings Opening story To-do lists, cross outs and move them to the margin Glossary definitions Where does factorial example go? Ref Fowler’s new book Cross refs for patterns Code paragraph style throughout Gray keywords Influence diagrams Leading tabs in code private class Pair keyword highlighting Final code formatting Reset to-do lists Bold deltas in code\n\nCHAPTER 3\n\nCHAPTER 4\n\nCHAPTER 1\n\nCHAPTER 2\n\nCHAPTER 3\n\nCHAPTER 4\n\nCHAPTER 5\n\nCHAPTER 6\n\nCHAPTER 7\n\nCHAPTER 8\n\nCHAPTER 9\n\nCHAPTER 10\n\nCHAPTER 11\n\nCHAPTER 12\n\nPreface\n\nviii\n\nAcknowledgements\n\nxiv\n\nStory Time\n\n1\n\nSection I: Money Example\n\nMoney Example\n\n7\n\nDegenerate Objects\n\n15\n\nEquality for All\n\n19\n\nPrivacy\n\n23\n\nFranc-ly Speaking\n\n27\n\nEquality for All, Redux\n\n31\n\nApples and Oranges\n\n37\n\nMakin’ Objects\n\n39\n\nTimes We’re Livin’ In\n\n43\n\nInteresting Times\n\n49\n\n5\n\niv\n\nv\n\nCHAPTER 13\n\nCHAPTER 14\n\nCHAPTER 15\n\nCHAPTER 16\n\nCHAPTER 17\n\nCHAPTER 18\n\nCHAPTER 19\n\nCHAPTER 20\n\nCHAPTER 21\n\nCHAPTER 22\n\nCHAPTER 23\n\nCHAPTER 24\n\nCHAPTER 25\n\nCHAPTER 26\n\nThe Root of all Evil\n\n55\n\nAddition, Finally\n\n57\n\nMake It\n\n63\n\nChange\n\n71\n\nMixed Currencies\n\n77\n\nAbstraction, Finally\n\n81\n\nMoney Retrospective\n\n85\n\nSection II: xUnit\n\n93\n\nSet the Table\n\n99\n\nCleaning Up After\n\n103\n\nCounting 107\n\nDealing with Failure\n\n111\n\nHow Suite It Is\n\n115\n\nxUnit Retrospective\n\n121\n\nCHAPTER 27\n\nCHAPTER 28\n\nCHAPTER 29\n\nCHAPTER 30\n\nCHAPTER 31\n\nCHAPTER 32\n\nCHAPTER 33\n\nCHAPTER 34\n\nCHAPTER 35\n\nCHAPTER 36\n\nCHAPTER 37\n\nCHAPTER 38\n\nSection III: Patterns\n\n123\n\nTest-Driven Development 125 Patterns\n\nRed Bar Patterns\n\n135\n\nTesting Patterns\n\n145\n\nGreen Bar Patterns\n\n153\n\nxUnit Patterns\n\n161\n\nDesign Patterns\n\n171\n\nRefactoring\n\n189\n\nMastering TDD 201\n\nGlossary\n\n215\n\nAppendix 1: Influence Diagrams\n\n217\n\nFibonacci\n\n221\n\nvi\n\nvii\n\nCHAPTER 3\n\nPreface\n\nClean code that works, in Ron Jeffries’ pithy phrase. The goal is clean code that works, and for a whole bunch of reasons:\n\nClean code that works is a predictable way to develop. You know when you are finished, without having to worry about a long bug trail.\n\nClean code that works gives you a chance to learn all the lessons that the code has to teach you. If you only ever slap together the first thing you think of, you never have time to think of a second, better, thing.\n\nClean code that works improves the lives of users of our software.\n\nClean code that works lets your teammates count on you, and you on them.\n\n(cid:127) Writing clean code that works feels good.\n\nBut how do you get to clean code that works? Many forces drive you away from clean code, and even code that works. Without taking too much counsel of our fears, here’s what we do—drive development with automated tests, a style of devel- opment called “Test-Driven Development” (TDD for short). In Test-Driven Devel- opment, you:\n\n(cid:127) Write new code only if you first have a failing automated test.\n\nEliminate duplication.\n\nTest-Driven Development\n\nviii\n\nix\n\nPreface\n\nTwo simple rules, but they generate complex individual and group behavior. Some of the technical implications are:\n\n(cid:127) You must design organically, with running code providing feedback between\n\ndecisions\n\n(cid:127) You must write your own tests, since you can’t wait twenty times a day for\n\nsomeone else to write a test\n\n(cid:127) Your development environment must provide rapid response to small changes (cid:127) Your designs must consist of many highly cohesive, loosely coupled compo-\n\nnents, just to make testing easy\n\nThe two rules imply an order to the tasks of programming:\n\n1. Red—write a little test that doesn’t work, perhaps doesn’t even compile at first\n\n2. Green—make the test work quickly, committing whatever sins necessary in the process\n\n3. Refactor—eliminate all the duplication created in just getting the test to work\n\nRed/green/refactor. The TDDs mantra.\n\nAssuming for the moment that such a style is possible, it might be possible to dra- matically reduce the defect density of code and make the subject of work crystal clear to all involved. If so, writing only code demanded by failing tests also has social implications:\n\nIf the defect density can be reduced enough, QA can shift from reactive to pro- active work\n\nIf the number of nasty surprises can be reduced enough, project managers can estimate accurately enough to involve real customers in daily development\n\nIf the topics of technical conversations can be made clear enough, programmers can work in minute-by-minute collaboration instead of daily or weekly collabo- ration\n\n(cid:127) Again, if the defect density can be reduced enough, we can have shippable soft- ware with new functionality every day, leading to new business relationships with customers\n\nSo, the concept is simple, but what’s my motivation? Why would a programmer take on the additional work of writing automated tests? Why would a programmer work in tiny little steps when their mind is capable of great soaring swoops of design? Courage.\n\nTest-Driven Development\n\nCourage\n\nTest-driven development is a way of managing fear during programming. I don’t mean fear in a bad way, pow widdle prwogwammew needs a pacifiew, but fear in the legitimate, this-is-a-hard-problem-and-I-can’t-see-the-end-from-the-beginning sense. If pain is nature’s way of saying “Stop!”, fear is nature’s way of saying “Be careful.” Being careful is good, but fear has a host of other effects:\n\n(cid:127) Makes you tentative (cid:127) Makes you want to communicate less (cid:127) Makes you shy from feedback (cid:127) Makes you grumpy\n\nNone of these effects are helpful when programming, especially when program- ming something hard. So, how can you face a difficult situation and:\n\nInstead of being tentative, begin learning concretely as quickly as possible.\n\nInstead of clamming up, communicate more clearly.\n\nInstead of avoiding feedback, search out helpful, concrete feedback.\n\n(You’ll have to work on grumpiness on your own.)\n\nImagine programming as turning a crank to pull a bucket of water from a well. When the bucket is small, a free-spinning crank is fine. When the bucket is big and full of water, you’re going to get tired before the bucket is all the way up. You need a ratchet mechanism to enable you to rest between bouts of cranking. The heavier the bucket, the closer the teeth need to be on the ratchet.\n\nThe tests in test-driven development are the teeth of the ratchet. Once you get one test working, you know it is working, now and forever. You are one step closer to having everything working than you were when the test was broken. Now get the next one working, and the next, and the next. By analogy, the tougher the program- ming problem, the less ground should be covered by each test.\n\nReaders of Extreme Programming Explained will notice a difference in tone between XP and TDD. TDD isn’t an absolute like Extreme Programming. XP says, “Here are things you must be able to do to be prepared to evolve further.” TDD is a little fuzzier. TDD is an awareness of the gap between decision and feedback dur- ing programming, and techniques to control that gap. “What if I do a paper design for a week, then test-drive the code? Is that TDD?” Sure, it’s TDD. You were aware of the gap between decision and feedback and you controlled the gap deliberately.\n\nTest-Driven Development\n\nx",
      "page_number": 1
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 10-17)",
      "start_page": 10,
      "end_page": 17,
      "detection_method": "topic_boundary",
      "content": "xi\n\nPreface\n\nThat said, most people who learn TDD find their programming practice changed for good. “Test Infected” is the phrase Erich Gamma coined to describe this shift. You might find yourself writing more tests earlier, and working in smaller steps than you ever dreamed would be sensible. On the other hand, some programmers learn TDD and go back to their earlier practices, reserving TDD for special occa- sions when ordinary programming isn’t making progress.\n\nThere are certainly programming tasks that can’t be driven solely by tests (or at least, not yet). Security software and concurrency, for example, are two topics where TDD is not sufficient to mechanically demonstrate that the goals of the soft- ware have been met. Security relies on essentially defect-free code, true, but also on human judgement about the methods used to secure the software. Subtle concur- rency problems can’t be reliably duplicated by running the code.\n\nOnce you are finished reading this book, you should be ready to:\n\nStart simply\n\n(cid:127) Write automated tests\n\nRefactor to add design decisions one at a time\n\nThis book is organized into three sections.\n\n(cid:127) An example of writing typical model code using TDD. The example is one I got from Ward Cunningham years ago, and have used many times since, multi-cur- rency arithmetic. In it you will learn to write tests before code and grow a design organically.\n\n(cid:127) An example of testing more complicated logic, including reflection and excep- tions, by developing a framework for automated testing. This example also serves to introduce you to the xUnit architecture that is at the heart of many pro- grammer-oriented testing tools. In the second example you will learn to work in even smaller steps than in the first example, including the kind of self-referen- tial hooha beloved of computer scientists.\n\nPatterns for TDD. Included are patterns for the deciding what tests to write, how to write tests using xUnit, and a greatest hits selection of the design patterns and refactorings used in the examples.\n\nI wrote the examples imagining a pair programming session. If you like looking at the map before wandering around, you may want to go straight to the patterns in section 3 and use the examples as illustrations. If you prefer just wandering around and then looking at the map to see where you’ve been, try reading the examples\n\nTest-Driven Development\n\nthrough and refering to the patterns when you want more detail about a technique, then using the patterns as a reference.\n\nSeveral reviewers have commented they got the most out of the examples when they started up a programming environment and entered the code and ran the tests as they read.\n\nA note about the examples. Both examples, multi-currency calculation and a testing framework, appear simple. There are (and I have seen) complicated, ugly, messy ways of solving the same problems. I could have chosen one of those complicated, ugly, messy solutions, to give the book an air of “reality.” However, my goal, and I hope your goal, is to write clean code that works. Before teeing off on the examples as being too simple, spend 15 seconds imagining a programming world in which all code was this clear and direct, where there were no complicated solutions, only apparently complicated problems begging for careful thought. TDD is a practice that can help you lead yourself to exactly that careful thought.\n\nTest-Driven Development\n\nxii\n\nxiii\n\nPreface\n\nTest-Driven Development\n\nCHAPTER 4\n\nAcknowledgements\n\nThanks to all my many brutal and opinionated reviewers. I take full responsibility for the contents, but this book would have been much less readable and useful with- out their help. In the order in which I typed them in, they were: Steve Freeman, Frank Westphal, Ron Jeffries, Dierk König, Edward Hieatt, Tammo Freese, Jim Newkirk, Johannes Link, Manfred Lange, Steve Hayes, Alan Francis, Jonathan Rasmusson, Shane Clauson, Simon Crase, Kay Pentecost, Murray Bishop, Ryan King, Bill Wake, Edmund Schweppe, Kevin Lawrence, John Carter, Phlip, Peter Hansen, Ben Schroeder, Alex Chaffee, Peter van Rooijen, Rick Kawala, Mark van Hamersveld, Doug Swartz, Laurent Bossavit, Ilja Preuß, Daniel Le Berre, Frank Carver, Justin Sampson, Mike Clark, Christian Pekeler, Karl Scotland, Carl Manas- ter, J. B. Rainsberger, Peter Lindberg, Darach Ennis, Kyle Cordes, Justin Sampson, Patrick Logan, Darren Hobbs, Aaron Sansone, Darach Ennis, Syver Enstad, Shi- nobu Kawai, Erik Meade, Patrick Logan, Dan Rawsthorne, Bill Rutiser, Eric Her- man, Paul Chisholm, Asim Jalis, Ivan Moore, Levi Purvis, Rick Mugridge, Anthony Adachi, Nigel Thorne, John Bley, Kari Hoijarvi, Manuel Amago, Kaoru Hosokawa, Pat Eyler, Ross Shaw, Sam Gentle, Jean Rajotte, Phillipe Antras, Jaime Nino,\n\nTo all of the programmers I’ve test-driven code with, I certainly appreciate your patience going along with what was a pretty crazy sounding idea, especially in the early years. I’ve learned far more from you all than I could ever think of myself. Not wishing to offend everyone else, but Massimo Arnoldi, Ralph Beattie, Ron Jef-\n\nxiv\n\nxv\n\nAcknowledgements\n\nfries, Martin Fowler, and last but certainly not least Erich Gamma stand out in my memory as test drivers from whom I’ve learned much.\n\nI would like to thank Martin Fowler for timely Framemaker help. He must be the highest-paid typesetting consultant on the planet, but fortunately he has let me (so far) run a tab.\n\nMy life as a real programmer started with patient mentoring from and continuing collaboration with Ward Cunningham. Sometimes I see TDD as an attempt to give any programmer, working in any environment, the sense of comfort and intimacy we had with our Smalltalk environment and our Smalltalk programs. There is no way to sort out the source of ideas once two people have shared a brain. If you assume all the good ideas here are Ward’s, you won’t be far wrong.\n\nIt is a bit of a cliché to recognize the sacrifices a family makes once one of its mem- bers catches the peculiar mental affliction that results in a book. It is a cliché because family sacrifices are as necessary to book writing as paper. To my children who waited breakfast until I could finish a chapter, and most of all to my wife who spent two months saying everything three times, my profoundest and least adequate thanks.\n\nFinally, to the unknown author of the book which I read as a weird 12-year-old that suggested you type in the expected output tape from a real input tape, then code until the actual results matched the expected result, thank you, thank you, thank you.\n\nCHAPTER 1\n\nStoryTime\n\nEarly one Friday the boss came to Ward to introduce him to Peter, a prospective customer for WyCash, the bond portfolio management system they were selling. Peter said, “I’m very impressed with the functionality I see. However, I notice you only handle US dollar denominated bonds. I’m starting a new bond fund and my strategy requires that I handle bonds in different currencies.” The boss turned to Ward, “Well, can we do it?”\n\nHere is the nightmare scenario for any software designer. You have been cruising along happily and successfully with a set of assumptions. Suddenly, everything changes. And the nightmare wasn’t just for Ward. The boss, an experienced hand at directing software development, wasn’t sure what the answer was going to be.\n\nWyCash had been developed over the course of a couple of years by a small team. It was able to handle most of the varieties of fixed income securities commonly found on the US market, and a few exotic new instruments, like Guaranteed Invest- ment Contracts, that the competition couldn’t handle.\n\nWyCash had been developed all along using objects and an object database. The fundamental abstraction of computation, Dollar, had been outsourced at the begin- ning to a clever group of programmers. The resulting object combined formatting and calculation responsibilities.\n\n1\n\n2\n\nStory Time\n\nFor the last six months, Ward and the rest of the team had been slowly divesting Dollar of its responsibilities. The Smalltalk numerical classes turned out to be just fine at calculation. All the tricky code for rounding to three decimal digits got in the way of producing precise answers. As the answers got more precise, the compli- cated mechanisms in the testing framework for comparing to within a certain toler- ance were replaced by precise matching of expected and actual results.\n\nResponsibility for formatting actually belonged in the user interface classes. As the tests were written at the level of the user interface classes, in particular the report framework1, these tests didn’t have to change to accomodate this refinement. After six months of careful paring, the resulting Dollar didn’t have much responsibility left.\n\nOne of the most complicated algorithms in the system, weighted average, had like- wise been undergoing a slow transformation. At one time there had been many dif- ferent variations of weighted average code scattered throughout the system. As the report framework coalesced from the primodial object soup, it was obvious that there could be one home for the algorithm, in AveragedColumn.\n\nIt was to AveragedColumn that Ward now turned. If weighted averages could be made multi-currency, the rest of the system should be possible. The heart of the algorithm was keeping a count of the money in the column. In fact, the algorithm had been abstracted enough to calculate the weighted average of any object that could act arithmetic. You could have weighted averages of dates, for example.\n\nThe weekend past in the usual weekend activities. Monday morning the boss was back. “Can we do it?” “Give me another day and I’ll tell you for sure.”\n\nSince Dollar acted like a counter in weighted average, in order to calculate in multi- ple currencies they needed an object with a counter per currency, kind of like a polynomial. Instead of 3x2 and 4y3, though, the terms would be 15 USD and 200 CHF.\n\nA quick experiment showed that it was possible to compute with a generic Cur- rency object instead of a Dollar, and return a PolyCurrency when two un-alike cur- rencies were added together. The trick now was to make space for the new functionality without breaking anything that already worked. What would happen if Ward just ran the tests?\n\n1. For more on the report framework, see c2.com/doc/oopsla91.html\n\nAfter adding a few un-implemented operations to Currency, the bulk of the tests passed. By the end of the day, all the tests were passing. Ward checked the code into the build and went to the boss. “We can do it,” he said confidently.\n\nLet’s think a bit about this story. In two days, the potential market was multiplied several fold, multiplying the value of WyCash several fold. The ability to create so much business value so quickly was no accident though. Several factors came into play:\n\n(cid:127) Method—Ward and the WyCash team needed to have constant experience\n\ngrowing the design of the system little-by-little, so the mechanics of the trans- formation were well practiced.\n\n(cid:127) Motive—Ward and team had to understand clearly from the business the impor- tance of making WyCash multi-currency, and to have the courage to start such a seemingly impossible task.\n\n(cid:127) Opportunity— The combination of comprehensive, confidence-generating tests; a well-factored program; and a programming language that made it possible to isolate design decisions meant that there were few sources of error, and those errors were easy to identify.\n\nYou can’t control whether you ever get the motive to multiply the value of your project by spinning technical magic. Method and opportunity, however, are entirely under your control. Ward and his team created method and opportunity by a combi- nation of superior talent, experience, and discipline. Does this mean that if you are not one of the ten best software engineers on the planet and you don’t have a wad of cash in the bank so you can tell your boss to take a hike, you’re going to take the time to do this right, that such moments are forever beyond your reach?\n\nNo. You absolutely can place your projects in a position for you to work magic, even if you are a programmer with ordinary skills and you sometimes buckle under and take shortcuts when the pressure builds. Test-driven development is a set of techniques any programmer can follow, that encourage simple designs and test suites that inspire confidence. If you are a genius, you don’t need these rules. If you are a dolt, the rules won’t help. For the vast majority of us in between, though, fol- lowing these two simple rules can lead us to work much closer to our potential:\n\n(cid:127) Write a failing automated test before you write any code\n\nRemove duplication\n\n3",
      "page_number": 10
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 18-25)",
      "start_page": 18,
      "end_page": 25,
      "detection_method": "topic_boundary",
      "content": "4\n\nStory Time\n\nHow exactly to do this, the subtle gradations in applying these rules, and the lengths to which you can push these two simple rules are the topic of this book. We’ll start with the object Ward created in his moment of inspiration—multi-currency money.\n\nCHAPTER 2\n\nSectionI:Money Example\n\nIn this section we will develop typical model code completely driven by tests (except when we slip, purely for educational purposes). My goal is for you to see the rhythm of test-driven development:\n\n1. Quickly add a test\n\n2. Run all tests and see the new one fail\n\n3. Make a little change\n\n4. Run all tests and see them all succeed\n\n5. Refactor to remove duplication\n\nThe surprises are likely to be:\n\n(cid:127) How each test can cover a small increment of functionality (cid:127) How small and ugly the changes can be to make the new tests run (cid:127) How often the tests are run (cid:127) How many teensy tiny steps make up the refactorings\n\n5\n\n6\n\nSection I: Money Example\n\nCHAPTER 3\n\nMoneyExample\n\nWe’ll start with the object Ward created at WyCash, multi-currency money. Sup- pose we have a report like this:\n\nInstrument\n\nShares\n\nPrice\n\nTotal\n\nIBM\n\n1000\n\n25\n\n25000\n\nGE\n\n400\n\n100\n\n40000\n\nTotal:\n\n65000\n\nTo make a multi-currency report, we need to add currencies:\n\nInstrument\n\nShares\n\nPrice\n\nTotal\n\nIBM\n\n1000\n\n25 USD\n\n25000 USD\n\nNovartis\n\n400\n\n150 CHF\n\n60000 CHF\n\nTotal:\n\n65000 USD\n\nWe also need to specify exchange rates:\n\n7\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10\n\n8\n\nMoney Example\n\nFrom\n\nTo\n\nRate\n\nCHF\n\nUSD\n\n1.5\n\nWhat behavior will we need to produce the revised report? Put another way, what is the set of tests which, when passed, will demonstrate the presence of code we are confident will compute the report correctly?\n\n(cid:127) We need to be able to add amounts in two different currencies and convert the\n\nresult given a set of exchange rates.\n\n(cid:127) We need to be able to multiply an amount (price per share) by a number (num-\n\nber of shares) and receive an amount.\n\nWe’ll make a to-do list to remind us what all we need to do, keep us focused, and tell us when we are finished. When we start working on an item, we’ll make it bold, like this. When we finish an item we’ll cross it off, like this. When we think of another test to write, we’ll add it to the list.\n\nAs you can see from the list, we’ll work on multiplication first. So, what object do we need first? Trick question. We don’t start with objects, we start with tests (I keep having to remind myself of this, so I will pretend you are as dense as I am).\n\nTry again. What test do we need first? Looking at the list, that first test looks com- plicated. Start small or not at all. Multiplication, how hard could that be? We’ll work on that first.\n\nWhen we write a test, we imagine the perfect interface for our operation. We are telling ourselves a story about how the operation will look from the outside. Our story won’t always come true, but better to start from the best possible API and work backwards than to make things complicated, ugly, and “realistic” from the get go.\n\nHere’s a simple example of multiplication:\n\npublic void testMultiplication() { Dollar five= new Dollar(5); five.times(2); assertEquals(10, five.amount);\n\n}\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding?\n\n(I know, I know, public fields, side-effects, integers for monetary amounts and all that. Small steps. We’ll make a note of the stinkiness and move on. We have a fail- ing test and we want it to go green as quickly as possible.)\n\nThe test we just typed in (I’ll explain where and how we type it in later, when we talk more about JUnit) doesn’t even compile. That’s easy enough to fix. What’s the least we can do to get it to compile, even if it doesn’t run? We have four compile errors:\n\n(cid:127) No class “Dollar” (cid:127) No constructor (cid:127) No method “times(int)” (cid:127) No field “amount”\n\nLet’s take them one at a time (I always search for some numerical measure of progress). We can get rid of one error by defining the class Dollar:\n\nDollar\n\nclass Dollar\n\n3 errors. Now we need the constructor, but it doesn’t have to do anything just to get the test to compile:\n\nDollar\n\nDollar(int amount) { }\n\n2 errors. We need a stub implementation of times(). Again we’ll do the least work possible just to get the test to compile:\n\nDollar\n\nvoid times(int multiplier) { }\n\n1 error. Finally, we need an amount field:\n\nDollar\n\nint amount;\n\nTest Driven Development\n\n9\n\n10\n\nMoney Example\n\nBingo! Now we can run the test and watch it fail.\n\nYou are seeing the dreaded red bar. Our testing framework (JUnit, in this case) has run the little snippet of code we started with, and noticed that although we expected “10” as a result, we saw “0”. Sadness.\n\nNo, no. Failure is progress. Now we have a concrete measure of failure. That’s bet- ter than just vaguely knowing we are failing. Our programming problem has been transformed from “give me multi-currency” to “make this test work, and then make the rest of the tests work.” Much simpler. Much smaller scope for fear. We can make this test work.\n\nYou probably aren’t going to like the solution, but the goal right now is not to get the perfect answer, the goal is to pass the test. We’ll make our sacrifice at the altar of truth and beauty later.\n\nHere’s the smallest change I could imagine that would cause our test to pass:\n\nDollar\n\nint amount= 10;\n\nNow we get the green bar, fabled in song and story.\n\nOh joy, oh rapture! Not so fast, hacker boy (or girl). The cycle isn’t complete. There are very few inputs in the world that will cause such a limited, such a smelly,\n\nTest Driven Development\n\n11",
      "page_number": 18
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 26-33)",
      "start_page": 26,
      "end_page": 33,
      "detection_method": "topic_boundary",
      "content": "12\n\nMoney Example\n\nsuch a naïve implementation to pass. We need to generalize before we move on. Remember, the cycle is:\n\n1. Add a little test\n\n2. Run all tests and fail\n\n3. Make a little change\n\n4. Run the tests and succeed\n\n5. Refactor to remove duplication\n\nSidebar: Dependency and Duplication\n\nSteve Freeman pointed out that the problem with the test and code as it sits is not duplication (which I have not yet pointed out to you, but I promise to as soon as this digression is over.) The problem is the dependency between the code and the test— you can’t change one without changing the other. Our goal is to be able to write another test that “makes sense” to us, without having to change the code, something that is not possible with the current implementation.\n\nDependency is the key problem in software development at all scales. If you have details of one vendor’s implementation of SQL scattered throughout the code and you decide to change to another vendor, you will discover that your code is depen- dent on the database vendor. You can’t change the database without changing the code.\n\nIf dependency is the problem, duplication is the symptom. Duplication most often takes the form of duplicate logic—the same expression appearing in multiple places in the code. Objects are excellent for abstracting away the duplication of logic.\n\nUnlike most problems in life, where eliminating the symptoms only makes the problem pop up elsewhere in worse form, eliminating duplication in programs eliminates dependency. That’s why the second rule appears in TDD. By eliminating duplication before we go on to the next test, we maximize our chance of being able to get the next test running with one and only one change.\n\nNow back to your regularly scheduled puzzling example.\n\nWe have run items 1-4. Now we are ready to remove duplication. But where is the duplication? Usually you see duplication between two pieces of code. Here the duplication is between the data in the test and the data in the code. Don’t see it? How about if we write?\n\nDollar\n\nint amount= 5 * 2;\n\nThat “10” had to come from somewhere. We did the multiplication in our heads so fast we didn’t even notice. The “5” and “2” are now in two places, and we must ruthlessly eliminate duplication before moving on. The rules say so.\n\nThere isn’t a single step that will eliminate the 5 and 2. However, what if we move the setting of the amount from object initialization to the times() method?\n\nDollar\n\nint amount;\n\nvoid times(int multiplier) { amount= 5 * 2;\n\n}\n\nThe test still passes, the bar stays green. Happiness is still ours.\n\nDo these steps seem too small to you? Remember, TDD is not about taking teensy tiny steps, it’s about being able to take teensy tiny steps. Would I code day-to-day with steps this small? No. But when things get the least bit weird, I’m glad I can. Try teensy tiny steps with an example of your own choosing. If you can make steps too small, you can certainly make steps the right size. If you only take larger steps, you’ll never know if smaller steps are appropriate.\n\nDefensiveness aside, where were we? Ah, yes, we were getting rid of duplication between the test code and the working code. Where can we get a 5? That was the value passed to the constructor, so if we save it in the amount variable:\n\nDollar\n\nDollar(int amount) {\n\nthis.amount= amount;\n\n}\n\nwe can use it in times():\n\nDollar\n\nvoid times(int multiplier) { amount= amount * 2;\n\n}\n\nTest Driven Development\n\n13\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding?\n\n14\n\nMoney Example\n\nThe value of the parameter “multiplier” is 2, so we can substitute the parameter for the constant:\n\nDollar\n\nvoid times(int multiplier) {\n\namount= amount * multiplier;\n\n}\n\nTo demonstrate our thorough-going knowledge of Java syntax, we will want to use the “*=” operator (which does, it must be said, reduce duplication):\n\nDollar\n\nvoid times(int multiplier) { amount *= multiplier;\n\n}\n\nWe can now mark off the first test as done. Next we’ll take care of those strange side effects. First, though, let’s review. We:\n\n(cid:127) Made a list of the tests we knew we needed to have working\n\nTold a story with a snippet of code about how we wanted to view one operation\n\nIgnored the details of JUnit for the moment\n\n(cid:127) Made the test compile with stubs (cid:127) Made the test run by committing horrible sins (cid:127) Gradually generalized the working code, replacing constants with variables (cid:127) Added items to our to-do list rather than addressing them all at once\n\nCHAPTER 4\n\nDegenerateObjects\n\nThe general TDD cycle is:\n\n1. Write a test. Think about how you would like the operation in your mind to appear in your code. You are writing a story. Invent the interface you wish you had. Include all the elements in the story that you imagine will be necessary to calculate the right answers.\n\n2. Make it run. Quickly getting that bar green dominates everything else. If a clean, simple solution is obvious, type it in. If the clean, simple solution is obvi- ous but it will take you a minute, make a note of it and get back to the main problem, which is getting the bar green in seconds. This shift in aesthetics is hard for some experienced software engineers. They only know how to follow the rules of good engineering. Quick green excuses all sins. But only for a moment.\n\n3. Make it right. Now that the system is behaving, put the sinful ways of the recent past behind you. Step back onto the straight and narrow path of software righ- teousness. Remove the duplication that you have introduced to get to quick green.\n\nThe goal is clean code that works (thanks to Ron Jeffries for this pithy summary). Clean code that works is out of the reach of even the best programmers some of the time, and out of the reach of most programmers (like me) most of the time. Divide and conquer, baby. First we’ll solve the “that works” part of the problem. Then we’ll solve the “clean code” part. (This is the opposite of architecture-driven devel-\n\n15\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding?\n\n16\n\nDegenerate Objects\n\nopment, where you solve “clean code” first, then scramble around trying to inte- grate into the design the things you learn as you solve the “that works” problem.)\n\nWe got one test working, but in the process we noticed something strange—when we perform an operation on a Dollar, the Dollar changes. I would like to be able to write:\n\npublic void testMultiplication() { Dollar five= new Dollar(5); five.times(2); assertEquals(10, five.amount); five.times(3); assertEquals(15, five.amount);\n\n}\n\nI can’t imagine a clean way to get this test working. After the first call to times(), five isn’t five any more, it’s really ten. If, however, we return a new object from times(), we can multiply our original five bucks all day and never have it change. We are changing the interface of Dollar when we make this change, so we have to change the test. That’s okay. Our guesses about the right interface are no more likely to be perfect than our guesses about the right implementation.\n\npublic void testMultiplication() { Dollar five= new Dollar(5); Dollar product= five.times(2); assertEquals(10, product.amount); product= five.times(3); assertEquals(15, product.amount);\n\n}\n\nThe new test won’t compile until we change the declaration of Dollar.times():\n\nDollar\n\nDollar times(int multiplier) { amount *= multiplier; return null;\n\n}\n\nNow the test compiles, but it doesn’t run. Progress! Making it run requires that we return a new Dollar with the correct amount:\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding?\n\nDollar\n\nDollar times(int multiplier) {\n\nreturn new Dollar(amount * multiplier);\n\n}\n\nIn the last chapter when we made a test work we started with a bogus implementa- tion and gradually made it real. Here, we typed in what we thought was the right implementation and prayed while the tests ran (short prayers, to be sure, because running the test takes a few milliseconds.) Because we got lucky and the test ran, we can cross off another item.\n\nThese are two of the three strategies I know for quickly getting to green:\n\nFake It—return a constant and gradually replace constants with variables until you have the real code\n\n(cid:127) Obvious Implementation—type in the real implementation\n\nWhen I use TDD in practice, I commonly shift between these two modes of imple- mentation. When everything is going smoothly and I know what to type, I put in obvious implementation after obvious implementation (running the tests all the time to ensure that what’s obvious to me is still obvious to the computer). As soon as I get an unexpected red bar, I back up, shift to faking implementations, and refactor to the right code. When my confidence is back, I go back to obvious imple- mentations.\n\nThere is a third style of test-driving development, triangulation, which we will demonstrate in the next chapter. However, to review, we:\n\nTranslated a design objection (side effects) into a test case that failed because of the objection\n\n(cid:127) Got the code to compile quickly with a stub implementation (cid:127) Made the test work by typing in what seemed like the right code\n\nThe translation of a feeling (disgust at side effects) into a test (multiply the same Dollar twice) is a common theme of TDD. The longer I do this, the better able I am to translate my aesthetic judgements into tests. When I can do this, my design dis- cussions become much more interesting. First we can talk about whether the system should work like this or like that. Once we decide on the correct behavior, we can talk about the best way of achieving that behavior. We can speculate about truth\n\n17\n\n18\n\nDegenerate Objects\n\nand beauty all we want over beers, but while we are programming we can leave airy-fairy discussions behind and talk cases.\n\nCHAPTER 5\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? Equals()\n\nEqualityforAll\n\nIf I have an integer and I add 1 to it, I don’t expect the original integer to change, I expect to use the new value. Objects usually don’t behave that way. If I have a Con- tract and I add one to its coverage, the Contract’s coverage should change (yes, yes, subject to all sorts of interesting business rules which do not concern us here.)\n\nWe can use objects as values, as we are using our Dollar now. The pattern for this is Value Object. One of the constraints on Value Objects is that the values of the instance variables of the object never change once they have been set in the con- structor.\n\nThere is one huge advantage to using value objects—you don’t have to worry about aliasing problems. Say I have one Check and I set its amount to $5, and then I set another Check’s amount to the same $5. Some of the nastiest bugs in my career have come when changing the first Check’s value inadvertently changed the second Check’s value. This is aliasing.\n\nWhen you have value objects, you don’t have to worry about aliasing. If I have $5, I am guaranteed that it will always and forever be $5. If someone wants $7, they have to make an entirely new object.\n\nOne implication of Value Object is all operations must return a new object, as we saw in the previous chapter. Another implication is that value objects should imple- ment equals(), since one $5 is pretty much as good as another.\n\n19",
      "page_number": 26
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 34-41)",
      "start_page": 34,
      "end_page": 41,
      "detection_method": "topic_boundary",
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode()\n\n20\n\nEquality for All\n\nIf you use Dollars as the key to a hash table, you have to implement hashCode() if you implement equals(). We’ll put that in the list, too, and get to it when it’s a prob- lem.\n\nYou aren’t thinking about the implementation of equals(), are you? Good. Me nei- ther. After snapping the back of my hand with a ruler, I’m thinking about how to test equality. First, $5 should equal $5:\n\npublic void testEquality() {\n\nassertTrue(new Dollar(5).equals(new Dollar(5)));\n\n}\n\nThe bar turns obligingly red. The fake implementation is to just return true:\n\nDollar\n\npublic boolean equals(Object object) {\n\nreturn true;\n\n}\n\nYou and I both know that “true” is really “5 == 5” which is really “amount == 5” which is really “amount == dollar.amount”. If I went through these steps, though, I wouldn’t be able to demonstrate the third and most conservative implementation strategy, triangulation.\n\nIf two receiving stations at a known distance from each other can both measure the direction of a radio signal, there is enough information to calculate the range and bearing of the signal (if you remember more trigonometry than I do, anyway.) This calculation is called triangulation.\n\nBy analogy, when we Triangulate, we only generalize code when we have two or more examples. We briefly ignore the duplication between test and model code. When the second example demands a more general solution, then and only then do we generalize.\n\nSo, to triangulate we need a second example. How about $5 != $6?\n\npublic void testEquality() {\n\nassertTrue(new Dollar(5).equals(new Dollar(5))); assertFalse(new Dollar(5).equals(new Dollar(6)));\n\n}\n\nNow we need to generalize equality:\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode()\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object\n\nDollar\n\npublic boolean equals(Object object) { Dollar dollar= (Dollar) object; return amount == dollar.amount;\n\n}\n\nWe could have used triangulation to drive the generalization of times(), also. If we had $5 x 2 = $10 and $5 x 3 = $15 we would no longer have been able to return a constant.\n\nTriangulation feels funny to me. I only use it when I am completely unsure of how to refactor. If I can see how to eliminate duplication between code and tests and create the general solution, I just do it. Why would I need to write another test to give me permission to write what I probably could have written the first time?\n\nHowever, when the design thoughts just aren’t coming, triangulation gives you a chance to think about the problem from a slightly different direction. What axes of variability are you trying to support in your design? Make some of the them vary and the answer may become clearer.\n\nSo, equality is done for the moment. (What about comparing with null and compar- ing with other objects? These are commonly used operations, but not necessary at the moment, so we’ll them to the list.)\n\nNow that we have equality, we can directly compare Dollars to Dollars. That will let us make amount private, as all good instance variables should be. Reviewing the above, though, we:\n\n(cid:127) Noticed that our design pattern (Value Object) implied an operation\n\nTested for that operation\n\nImplemented it simply\n\n(cid:127) Didn’t refactor immediately, but instead tested further\n\nRefactored to capture the two cases at once\n\n21\n\n22\n\nEquality for All\n\nCHAPTER 6\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object\n\nPrivacy\n\nNow that we have defined equality, we can use it to make out tests more “speak- ing”. Conceptually, the operation Dollar.times() should return a Dollar whose value is the value of the receiver times the multiplier. Our test doesn’t exactly say that:\n\npublic void testMultiplication() { Dollar five= new Dollar(5); Dollar product= five.times(2); assertEquals(10, product.amount); product= five.times(3); assertEquals(15, product.amount);\n\n}\n\nWe can rewrite the first assertion to compare Dollars to Dollars.\n\npublic void testMultiplication() { Dollar five= new Dollar(5); Dollar product= five.times(2); assertEquals(new Dollar(10), product); product= five.times(3); assertEquals(15, product.amount);\n\n}\n\nThat looks better, so we rewrite the second assertion, too:\n\n23\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object\n\n24\n\nPrivacy\n\npublic void testMultiplication() { Dollar five= new Dollar(5); Dollar product= five.times(2); assertEquals(new Dollar(10), product); product= five.times(3); assertEquals(new Dollar(15), product);\n\n}\n\nNow the temporary variable “product” isn’t helping much, so we can inline it:\n\npublic void testMultiplication() { Dollar five= new Dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));\n\n}\n\nThis test speaks to us more clearly, as if it were an assertion of truth, not a sequence of operations.\n\nWith these changes to the test, Dollar is now the only class using its “amount” instance variable, so we can make it private:\n\nDollar\n\nprivate int amount;\n\nAnd we can cross another item off the list. Notice that we have opened ourselves up to a risk. If the test for equality fails to accurately check that equality is working, the test for multiplication could also fail to accurately check that multiplication is working. That is a risk you actively manage in TDD. We aren’t striving for perfec- tion. By saying everything two ways, as both code and tests, we hope to reduce our defects enough to move forward with confidence. From time to time our reasoning will fail us and a defect will slip through. When that happens, we learn our lesson about the test we should have written and move on. The rest of the time we go for- ward boldly under our bravely flapping green bar (my bar doesn’t actually flap, but one can dream.)\n\nReviewing, we:\n\n(cid:127) Used functionality just developed to improve a test (cid:127) Noticed that if two tests fail at once we’re sunk\n\nProceeded in spite of the risk\n\n(cid:127) Used new functionality in the object under test to reduce coupling between the\n\ntests and the code\n\n25\n\n26\n\nPrivacy\n\nCHAPTER 7\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF\n\nFranc-lySpeaking\n\nHow are we going to approach the first test on that list? That’s the test that’s most interesting. It still seems to be a big leap. I’m not sure I can write a test that I can implement in one little step. A pre-requisite seems to be having an object like Dol- lar, but to represent Francs. If we can get Francs working like Dollars work now, we’ll be closer to being able to write and run the mixed addition test.\n\nWe can copy and edit the Dollar test:\n\npublic void testFrancMultiplication() {\n\nFranc five= new Franc(5); assertEquals(new Franc(10), five.times(2)); assertEquals(new Franc(15), five.times(3));\n\n}\n\n(Aren’t you glad we simplified the test in the last chapter? That made our job here easier. Isn’t it amazing how often things work out like this in books? I didn’t actu- ally plan it that way this time, but I won’t make promises for the future.)\n\nWhat short step will get us to a green bar? Copying the Dollar code and replacing “Dollar” with “Franc”.\n\nStop. Hold on. I can hear the aesthetically inclined among you sneering and spit- ting. Copy and paste reuse? The death of abstraction? The killer of clean design?\n\n27",
      "page_number": 34
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 42-50)",
      "start_page": 42,
      "end_page": 50,
      "detection_method": "topic_boundary",
      "content": "28\n\nFranc-ly Speaking\n\nIf you’re upset, take a cleansing breath. In through the nose…hold it 1 2 3…out through the mouth. There. Remember, our cycle has different phases (they go by quickly, often in seconds, but they are phases.):\n\n1. Write a test\n\n2. Make it compile\n\n3. Run it to see that it fails\n\n4. Make it run\n\n5. Remove duplication\n\nThe different phases have different purposes. They call for different styles of solu- tion, different aesthetic viewpoints. The first three phases need to go by quickly, so we get to a known state with the new functionality. You can commit any number of sins to get there, because speed trumps design, just for that brief moment.\n\nNow I’m worried. I’ve given you a license to abandon all the principles of good design. Off you go to your teams—“Kent says all that design stuff doesn’t matter.” Halt. The cycle is not complete. A four legged Aeron chair falls over. The first four steps of the cycle won’t work without the fifth. Good design at good times. Make it run, make it right.\n\nThere, I feel better. Now I’m sure you won’t show anyone except your partner your code until you’ve removed the duplication. Where were we? Ah, yes. Violating all the tenets of good design in the interest of speed (penance for our sin will occupy the next several chapters.)\n\nFranc\n\nclass Franc {\n\nprivate int amount;\n\nFranc(int amount) {\n\nthis.amount= amount;\n\n}\n\nFranc times(int multiplier) {\n\nreturn new Franc(amount * multiplier);\n\n}\n\npublic boolean equals(Object object) { Franc franc= (Franc) object; return amount == franc.amount;\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times\n\n}\n\n}\n\nBecause the step to running code was so short, we were even able to skip the “make it compile” step.\n\nNow we have duplication galore, and we have to eliminate it before writing our next test. We’ll start by generalizing equals(). However, we can cross off an item, even though we have to add two more. Reviewing, we:\n\nCouldn’t tackle a big test, so we invented a small test that represented progress\n\n(cid:127) Wrote the test by shamelessly duplicating and editing\n\nEven worse, made the test work by copying and editing model code wholesale\n\nPromised ourselves we wouldn’t go home until the duplication was gone\n\n29\n\n30\n\nFranc-ly Speaking\n\nCHAPTER 8\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times\n\nEqualityforAll,Redux\n\nThere is a fabulous sequence in Wallace Stegner’s Crossing to Safety where he describes a character’s workshop. Every item is perfectly in place, the floor is spot- less, all is order and cleanliness. The character, however, has never made anything. “Preparing has been his life’s work. He prepares, then he cleans up.” (This is also the book, the ending of which sent me audibly blubbering in business class on a trans-Atlantic 747. Read with caution.)\n\nWe have avoided this trap in the last chapter. We actually got a new test case work- ing. However, we sinned mightily in copying and pasting tons of code so we could do it quickly. Now it is time to clean up.\n\nOne possibility is to make one of our classes extend the other. I tried it, and it hardly saves any code at all. Instead, we are going to find a common superclass for the two classes (I tried this already, too, and it works out great, although it will take a while.)\n\nDollar\n\nMoney\n\nFranc\n\nDollar\n\nFranc\n\n31\n\n32\n\nEquality for All, Redux\n\nWhat if we had a Money class to capture the common equals code? We can start small:\n\nMoney\n\nclass Money\n\nAll the tests still run (not that we could possibly have broken anything, but that’s a good time to run the tests anyway.)\n\nIf Dollar extends Money, that can’t possibly break anything.\n\nDollar\n\nclass Dollar extends Money {\n\nprivate int amount;\n\n}\n\nCan it? No, the tests still all run. Now we can move the “amount” instance variable up to Money:\n\nMoney\n\nclass Money {\n\nprotected int amount;\n\n} Dollar\n\nclass Dollar extends Money { }\n\nThe visibility has to change from private to protected so the subclass can still see it. (If we’d wanted to go even slower we could have declared the field in Money in one step, and then removed it from Dollar in a second step. I’m feeling bold.)\n\nNow we can work on getting the equals() code ready to move up. First we change the declaration of the temporary variable:\n\nDollar\n\npublic boolean equals(Object object) { Money dollar= (Dollar) object; return amount == dollar.amount;\n\n}\n\nAll the tests still run. Now we change the cast:\n\nDollar\n\npublic boolean equals(Object object) { Money dollar= (Money) object; return amount == dollar.amount;\n\n}\n\nTo be communicative, we should also change the name of the temporary variable:\n\nDollar\n\npublic boolean equals(Object object) {\n\nMoney money= (Money) object; return amount == money.amount;\n\n}\n\nNow we can move it from Dollar to Money:\n\nMoney\n\npublic boolean equals(Object object) { Money money= (Money) object; return amount == money.amount;\n\n}\n\nNow we need to eliminate Franc.equals(). First we notice that the tests for equality don’t cover comparing Francs to Francs. Our sins in copying code are catching up with us. Before we change the code, we’ll write the tests that should have been there in the first place.\n\nYou will often be TDDing in code that doesn’t have adequate tests (at least for the next decade or so). When you don’t have enough tests, you are bound to come across refactorings that aren’t supported by tests. You could make a refactoring mistake and the tests would all still run. What do you do?\n\nWrite the tests you wish you had. If you don’t, you will eventually break something while refactoring. Then you’ll get bad feelings about refactoring and stop doing it so much. Then your design will deteriorate. You’ll be fired. Your dog will leave you. You will stop paying attention to your nutrition. Your teeth will go bad. So, to keep your teeth healthy, retroactively test before refactoring.\n\nFortunately, here the tests are easy to write. We just copy the tests for Dollar:\n\npublic void testEquality() {\n\n33\n\n34\n\nEquality for All, Redux\n\nassertTrue(new Dollar(5).equals(new Dollar(5))); assertFalse(new Dollar(5).equals(new Dollar(6))); assertTrue(new Franc(5).equals(new Franc(5))); assertFalse(new Franc(5).equals(new Franc(6)));\n\n}\n\nMore duplication, two lines more! We’ll atone for these sins, too.\n\nTests in place, we can have Franc extend Money:\n\nFranc\n\nclass Franc extends Money { private int amount;\n\n}\n\nWe can delete Franc’s field “amount” in favor of the one in Money:\n\nFranc\n\nclass Franc extends Money { }\n\nFranc.equals() is almost the same as Money.equals(). If we make them precisely the same, we can delete the implementation in Franc without changing the meaning of the program. First we change the declaration of the temporary variable:\n\nFranc\n\npublic boolean equals(Object object) { Money franc= (Franc) object; return amount == franc.amount;\n\n}\n\nThen we change the cast:\n\nFranc\n\npublic boolean equals(Object object) { Money franc= (Money) object; return amount == franc.amount;\n\n}\n\nDo we really have to change the name of the temporary variable to match the super- class? I’ll leave it up to your conscience… Okay, we’ll do it:\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars\n\nFranc\n\npublic boolean equals(Object object) {\n\nMoney money= (Money) object; return amount == money.amount;\n\n}\n\nNow there is no difference between Franc.equals() and Money.equals(), so we delete the redundant implementation in Franc. And run the tests. They run.\n\nWhat happens when we compare Francs and Dollars? We’ll get to that in the next chapter. Reviewing what we did here, we:\n\nStepwise moved common code from one class (Dollar) to a superclass (Money)\n\n(cid:127) Made a second class (Franc) also a subclass\n\nReconciled two implementations (equals()) before eliminating the redundant one\n\n35\n\n36\n\nEquality for All, Redux",
      "page_number": 42
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 51-62)",
      "start_page": 51,
      "end_page": 62,
      "detection_method": "topic_boundary",
      "content": "CHAPTER 9\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars\n\nApplesandOranges\n\nThe thought struck us at the end of the last chapter—what happens when we com- pare Francs and Dollars? We dutifully turned our dreadful thought into an item on our to-do list. But we just can’t get it out of our heads. What does happen?\n\npublic void testEquality() {\n\nassertTrue(new Dollar(5).equals(new Dollar(5))); assertFalse(new Dollar(5).equals(new Dollar(6))); assertTrue(new Franc(5).equals(new Franc(5))); assertFalse(new Franc(5).equals(new Franc(6))); assertFalse(new Franc(5).equals(new Dollar(5)));\n\n}\n\nIt fails. Dollars are Francs. Before you Swiss shoppers get all excited, let’s try to fix the code. The equality code needs to check that it isn’t comparing Dollars and Francs. We can do this right now by comparing the class of the two objects—two Moneys are equal only if their amounts and classes are equal.\n\nMoney\n\npublic boolean equals(Object object) {\n\nMoney money = (Money) object; return amount == money.amount\n\n&& getClass().equals(money.getClass());\n\n}\n\n37\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency?\n\n38\n\nApples and Oranges\n\nUsing classes like this in model code is a bit smelly. We would like to use a criteria that made sense in the domain of finance, not the domain of Java objects. However, we don’t currently have anything like a currency, and this doesn’t seem like suffi- cient reason to introduce one, so this will have to do for the moment.\n\nNow we really need to get rid of the common times() code, so we can get to mixed currency arithmetic. Before we do, though, we can review our grand accomplish- ments of this chapter:\n\n(cid:127)\n\nTook an objection that was bothering us and turned it into a test (cid:127) Made the test run a reasonable, but not perfect way (getClass()) (cid:127) Decided not to introduce more design until we had a better motivation\n\nCHAPTER 10\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency?\n\nMakin’Objects\n\nThe two implementations of times() are remarkably similar:\n\nFranc\n\nFranc times(int multiplier) {\n\nreturn new Franc(amount * multiplier);\n\n} Dollar\n\nDollar times(int multiplier) {\n\nreturn new Dollar(amount * multiplier);\n\n}\n\nWe can take a step towards reconciling them by making them both return a Money:\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn new Franc(amount * multiplier);\n\n} Dollar\n\nMoney times(int multiplier) {\n\nreturn new Dollar(amount * multiplier);\n\n}\n\n39\n\n40\n\nMakin’ Objects\n\nThe next step forward is not obvious. The two subclasses of Money aren’t doing enough work to justify their existence, so we would like to eliminate them. How- ever, we can’t do it with one big step, because that wouldn’t make a very effective demonstration of TDD.\n\nOkay, we would be one step closer to eliminating the subclasses if there were fewer references to the subclasses directly. We can introduce a Factory Method in Money that returns a Dollar. We would use it like this:\n\npublic void testMultiplication() {\n\nDollar five = Money.dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));\n\n}\n\nThe implementation creates and returns a Dollar:\n\nMoney\n\nstatic Dollar dollar(int amount) { return new Dollar(amount);\n\n}\n\nBut we want references to Dollars to disappear, so we need to change the declara- tion in the test:\n\npublic void testMultiplication() {\n\nMoney five = Money.dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));\n\n}\n\nOur compiler politely informs us that times() is not defined for Money. We aren’t ready to implement it just yet, so we make Money abstract (I suppose we should have done that to begin with, shouldn’t we?) and declare Money.times():\n\nMoney\n\nabstract class Money abstract Money times(int multiplier);\n\nNow we can change the declaration of the factory method:\n\nMoney\n\nstatic Money dollar(int amount) {\n\nreturn new Dollar(amount);\n\n}\n\nThe tests all run, so at least we haven’t broken anything. We can now use our fac- tory method everywhere in the tests:\n\npublic void testMultiplication() {\n\nMoney five = Money.dollar(5); assertEquals(Money.dollar(10), five.times(2)); assertEquals(Money.dollar(15), five.times(3));\n\n} public void testEquality() {\n\nassertTrue(Money.dollar(5).equals(Money.dollar(5))); assertFalse(Money.dollar(5).equals(Money.dollar(6))); assertTrue(new Franc(5).equals(new Franc(5))); assertFalse(new Franc(5).equals(new Franc(6))); assertFalse(new Franc(5).equals(Money.dollar(5)));\n\n}\n\nWe are now in a slightly better position than before. No client code knows that there is a subclass called Dollar. By de-coupling the tests from the existence of the subclasses, we have given ourselves freedom to change inheritance without affect- ing any model code.\n\nBefore we go blindly changing the testFrancMultiplication, we notice that it isn’t testing any logic that isn’t tested by the test for Dollar multiplication. If we delete the test, will we lose any confidence in the code? Still a little, so we leave it there. But it’s suspicious.\n\npublic void testEquality() {\n\nassertTrue(Money.dollar(5).equals(Money.dollar(5))); assertFalse(Money.dollar(5).equals(Money.dollar(6))); assertTrue(Money.franc(5).equals(Money.franc(5))); assertFalse(Money.franc(5).equals(Money.franc(6))); assertFalse(Money.franc(5).equals(Money.dollar(5)));\n\n}\n\npublic void testFrancMultiplication() { Money five = Money.franc(5); assertEquals(Money.franc(10), five.times(2));\n\n41\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\n42\n\nMakin’ Objects\n\nassertEquals(Money.franc(15), five.times(3));\n\n}\n\nThe implementation is just like Money.dollar():\n\nMoney\n\nstatic Money franc(int amount) { return new Franc(amount);\n\n}\n\nWe’ll get rid of the duplication of times() next. For now, reviewing, we:\n\nTook a step towards eliminating duplication by reconciling the signatures of two variants of the same method (times())\n\n(cid:127) Moved at least a declaration of the method to the common superclass (cid:127) Decoupled test code from the existence of concrete subclasses by introducing\n\nfactory methods\n\n(cid:127) Noticed that when the subclasses disappear some tests will be redundant, but\n\ntook no action\n\nCHAPTER 11\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\nTimesWe’reLivin’In\n\nWhat is there on our list that might help us eliminate those pesky useless sub- classes?\n\nWhat about currency? What would happen if we introduced the notion of currency?\n\nHow do we want to implement currencies at the moment? I blew it, again. Before the ruler comes out, I’ll rephrase. How do we want to test for currencies at the moment? There. Knuckles saved. For the moment.\n\nWe may want to have complicated objects representing currencies, with flyweight factories to ensure we create no more objects than we really need. However, for the moment Strings will do:\n\npublic void testCurrency() {\n\nassertEquals(\"USD\", Money.dollar(1).currency()); assertEquals(\"CHF\", Money.franc(1).currency());\n\n}\n\nFirst we declare currency() in Money:\n\nMoney\n\nabstract String currency();\n\n43\n\n44\n\nTimes We’re Livin’ In\n\nThen we implement it in both subclasses:\n\nFranc\n\nString currency() { return \"CHF\";\n\n} Dollar\n\nString currency() { return \"USD\";\n\n}\n\nWe want the same implementation to suffice for both classes. We could store the currency in an instance variable and just return the variable. (I’ll start going a little faster with the refactorings in the interest of time. If I go too fast, please tell me to slow down. Oh, wait, this is a book. Perhaps I just won’t speed up much.)\n\nFranc\n\nprivate String currency; Franc(int amount) {\n\nthis.amount = amount; currency = \"CHF\";\n\n} String currency() {\n\nreturn currency;\n\n}\n\nWe can do the same with Dollar:\n\nDollar\n\nprivate String currency; Dollar(int amount) {\n\nthis.amount = amount; currency = \"USD\";\n\n} String currency() {\n\nreturn currency;\n\n}\n\nNow we can push up the declaration of the variable and the implementation of cur- rency(), since they are identical:\n\nMoney\n\nprotected String currency; String currency() {\n\nreturn currency;\n\n}\n\nIf we move the constant strings “USD” and “CHF” to the static factory methods, the two constructors will be identical and we can create a common implementation.\n\nFirst we’ll add a parameter to the constructor:\n\nFranc\n\nFranc(int amount, String currency) {\n\nthis.amount = amount; this.currency = \"CHF\";\n\n}\n\nThis breaks the two callers of the constructor:\n\nMoney\n\nstatic Money franc(int amount) {\n\nreturn new Franc(amount, null);\n\n} Franc\n\nMoney times(int multiplier) {\n\nreturn new Franc(amount * multiplier, null);\n\n}\n\nWait a minute! Why is Franc.times() calling the constructor instead of the factory method? Do we want to make this change now, or will we wait? The dogmatic answer is that we’ll wait, not interrupting what we’re doing. The answer in my practice is that I will entertain a brief interruption, but only a brief one, and I will never interrupt an interruption (Jim Coplien taught me this rule). To be realistic, we’ll clean up times() before proceeding:\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn Money.franc(amount * multiplier);\n\n}\n\nNow the factory method can pass “CHF”:\n\n45\n\n46\n\nTimes We’re Livin’ In\n\nMoney\n\nstatic Money franc(int amount) {\n\nreturn new Franc(amount, \"CHF\");\n\n}\n\nAnd finally we can assign the parameter to the instance variable:\n\nFranc\n\nFranc(int amount, String currency) {\n\nthis.amount = amount; this.currency = currency;\n\n}\n\nI’m feeling defensive again about taking such teeny-tiny steps. Am I recommend- ing that you actually work this way? No. I’m recommending that you be able to work this way. What I actually did just now was I worked in larger steps and made a stupid mistake half way through. I unwound a minute’s worth of changes, shifted to a lower gear, and did it over with little steps. I’m feeling better now, so we’ll see if we can make the analogous change to Dollar in one swell foop:\n\nMoney\n\nstatic Money dollar(int amount) {\n\nreturn new Dollar(amount, \"USD\");\n\n} Dollar\n\nDollar(int amount, String currency) {\n\nthis.amount = amount; this.currency = currency;\n\n} Money times(int multiplier) {\n\nreturn Money.dollar(amount * multiplier);\n\n}\n\nAnd it worked first time. Whew!\n\nThis is the kind of tuning you will be doing constantly with TDD. Are the teeny- tiny steps feeling restrictive? Take bigger steps. Are you feeling a little unsure? Take smaller steps. TDD is a steering process—a little this way, a little that way. There is no right step size, now and forever.\n\nThe two constructors are now identical, so we can push up the implementation:\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\nMoney\n\nMoney(int amount, String currency) {\n\nthis.amount = amount; this.currency = currency;\n\n} Franc\n\nFranc(int amount, String currency) { super(amount, currency);\n\n} Dollar\n\nDollar(int amount, String currency) {\n\nsuper(amount, currency);\n\n}\n\nWe’re almost ready to push up the implementation of times() and eliminate the sub- classes, but first, to review, we:\n\n(cid:127) Were a little stuck on big design ideas, so we worked on something small we\n\nnoticed earlier\n\nReconciled the two constructors by moving the variation to the caller (the fac- tory method)\n\nInterrupted a refactoring for a little twist (using the factory method in times())\n\nRepeated an analogous refactoring (doing to Dollar what we just did to Franc) in one big step\n\nPushed up the identical constructors\n\n47\n\n48\n\nTimes We’re Livin’ In",
      "page_number": 51
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 63-72)",
      "start_page": 63,
      "end_page": 72,
      "detection_method": "topic_boundary",
      "content": "CHAPTER 12\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\nInterestingTimes\n\nWhen we are done with this chapter we will have a single class to represent Money. The two implementations of times() are close, but not identical.\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn Money.franc(amount * multiplier);\n\n} Dollar\n\nMoney times(int multiplier) {\n\nreturn Money.dollar(amount * multiplier);\n\n}\n\nThere’s not an obvious way to make them identical. Sometimes you have to go backwards to go forwards, a little like a Rubik’s Cube. What happens if we inline the factory methods? (I know, I know, we just called the factory method for the first time just one chapter ago. Frustrating, isn’t it?)\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn new Franc(amount * multiplier, \"CHF\");\n\n}\n\n49\n\n50\n\nInteresting Times\n\nDollar\n\nMoney times(int multiplier) {\n\nreturn new Dollar(amount * multiplier, \"USD\");\n\n}\n\nIn Franc, though, we know that the currency instance variable is always “CHF”, so we can write: Franc\n\nMoney times(int multiplier) {\n\nreturn new Franc(amount * multiplier, currency);\n\n}\n\nThat works. The same trick works in Dollar:\n\nDollar\n\nMoney times(int multiplier) {\n\nreturn new Dollar(amount * multiplier, currency);\n\n}\n\nWe’re almost there. Does it really matter whether we have a Franc or a Money? We could carefully reason about this given our knowledge of the system. However, we have clean code and we have tests that give us confidence that the clean code works. Rather than apply minutes of suspect reasoning, we can just ask the com- puter by making the change and running the tests. In teaching TDD I see this situa- tion all the time—excellent programmers spending 5-10 minutes reasoning about a question that can be answered by the computer in 15 seconds. Without the tests you have no choice, you have to reason. With the tests you can decide whether an experiment would answer the question faster. Sometimes you should just ask the computer.\n\nTo run our experiment we change Franc.times() to return a Money:\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn new Money(amount * multiplier, currency);\n\n}\n\nThe compiler tells us that Money must be a concrete class:\n\nMoney\n\nclass Money Money times(int amount) {\n\nreturn null;\n\n}\n\nAnd we get a red bar. The error message says, “expected:<Money.Franc@31aebf> but was: <Money.Money@478a43>”. Not as helpful as we would perhaps like. We can define toString() to give us a better error message:\n\nMoney\n\npublic String toString() {\n\nreturn amount + \" \" + currency;\n\n}\n\nWhoa! Code without a test? Can you do that? We could certainly have written a test for toString() before we coded it. However:\n\n(cid:127) We are about to see the results on the screen\n\n(cid:127)\n\nSince toString() is only used for debug output, the risk of it failing is low (cid:127) We already have a red bar, and we’d prefer not to write a test when we have a\n\nred bar\n\nException noted.\n\nNow the error message says: “expected:<10 CHF> but was:<10 CHF>”. That’s a little better, but still confusing. We got the right data in the answer, but the class was wrong—Money instead of Franc. The problem is in our implementation of equals():\n\nMoney\n\npublic boolean equals(Object object) {\n\nMoney money = (Money) object; return amount == money.amount\n\n&& getClass().equals(money.getClass());\n\n}\n\nWe really should be checking to see that the currencies are the same, not that the classes are the same.\n\nWe’d prefer not to write a test when we have a red bar. However, we are about to change real model code, and we can’t change model code without a test. The con-\n\n51\n\n52\n\nInteresting Times\n\nservative course is to back out the change that caused the red bar so we’re back to green. Then we can change the test for equals(), fix the implementation, and re-try the original change.\n\nThis time, we’ll be conservative (sometimes I plough ahead and write a test on a red, but not while the children are awake.)\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn new Franc(amount * multiplier, currency);\n\n}\n\nThat gets us back to green. The situation that we had was a Franc(10, “CHF”) and a Money(10, “CHF”) that were reported to be not equal, even though we would like them to be equal. We can use exactly this for our test:\n\npublic void testDifferentClassEquality() {\n\nassertTrue(new Money(10, \"CHF\").equals(new Franc(10, \"CHF\")));\n\n}\n\nIt fails, as expected. The equals() code should compare currencies, not classes:\n\nMoney\n\npublic boolean equals(Object object) {\n\nMoney money = (Money) object; return amount == money.amount\n\n&& currency().equals(money.currency());\n\n}\n\nNow we can return a Money from Franc.times() and still pass the tests:\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn new Money(amount * multiplier, currency);\n\n}\n\nWill the same will work for Dollar.times()?\n\nDollar\n\nMoney times(int multiplier) {\n\nreturn new Money(amount * multiplier, currency);\n\n}\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\nYes! Now the two implementations are identical, so we can push them up.\n\nMoney\n\nMoney times(int multiplier) {\n\nreturn new Money(amount * multiplier, currency);\n\n}\n\nMultiplication in place, we are ready to eliminate the stupid subclasses. Reviewing, we:\n\nReconciled two methods (times()) by first inlining the methods they called and then replacing constants with variables\n\n(cid:127) Wrote a toString() without a test just to help us debug\n\nTried a change (returning Money instead of Franc) and let the tests tell us whether it worked\n\nBacked out an experiment and wrote another test. Making the test work made the experiment work.\n\n53\n\n54\n\nInteresting Times\n\nCHAPTER 13\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\nTheRootofallEvil\n\nThe two subclasses, Dollar and Franc, have only their constructors. Only a con- structor is not enough reason to have a subclass, so we want to delete the sub- classes.\n\nWe can replace references to the subclasses by references to the superclass without changing the meaning of the code. First Franc:\n\nFranc\n\nstatic Money franc(int amount) {\n\nreturn new Money(amount, \"CHF\");\n\n}\n\nThen Dollar:\n\nDollar\n\nstatic Money dollar(int amount) {\n\nreturn new Money(amount, \"USD\");\n\n}\n\nNow there are no references to Dollar, so we can delete it. Franc still has one refer- ence, in the test we just wrote.\n\npublic void testDifferentClassEquality() {\n\n55\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\n56\n\nThe Root of all Evil\n\nassertTrue(new Money(10, \"CHF\").equals(new Franc(10, \"CHF\")));\n\n}\n\nIs equality covered elsewhere well enough that we can delete this test? Looking at the other equality test:\n\npublic void testEquality() {\n\nassertTrue(Money.dollar(5).equals(Money.dollar(5))); assertFalse(Money.dollar(5).equals(Money.dollar(6))); assertTrue(Money.franc(5).equals(Money.franc(5))); assertFalse(Money.franc(5).equals(Money.franc(6))); assertFalse(Money.franc(5).equals(Money.dollar(5)));\n\n}\n\nit looks like we have the cases for equality well covered, too well covered, actually. We can delete the third and fourth assertions since they duplicate the exercise of the first and second assertions:\n\npublic void testEquality() {\n\nassertTrue(Money.dollar(5).equals(Money.dollar(5))); assertFalse(Money.dollar(5).equals(Money.dollar(6))); assertFalse(Money.franc(5).equals(Money.dollar(5)));\n\n}\n\nThe test we wrote forcing us to compare currencies instead of classes only makes sense if there are multiple classes. Since we are trying to eliminate the Franc class, a test to ensure that the system works if there is a Franc class is a burden, not a help. Away testDifferentClassEquality() goes, and Franc goes with it.\n\nSimilarly, there are separate tests for dollar and franc multiplication. Looking at the code, we can see there is no difference in the logic at the moment based on the cur- rency (there was a difference when there were two classes). We can delete testFrancMultiplication() without losing any confidence in the behavior of the sys- tem.\n\nSingle class in place, we are ready to tackle addition. First, to review, we:\n\nFinished gutting subclasses and deleted them\n\nEliminated tests that made sense with the old code structure but were redundant with the new code structure\n\nCHAPTER 14\n\n$5 + 10 CHF = $10 if rate is 2:1\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10\n\nAddition,Finally\n\nIt’s a new day, and our to-do list is getting a little cluttered, so we’ll copy the pend- ing items to a fresh list. (I like physically copying to-do items to a new list. If there are lots of little items, I tend to just take care of them rather than copy them. Little stuff that otherwise might build up gets taken care of just because I’m lazy. Play to your strengths.)\n\nI’m not sure how to write the story of the whole addition, so we’ll start with a sim- pler example—$5 + $5 = $10.\n\npublic void testSimpleAddition() {\n\nMoney sum= Money.dollar(5).plus(Money.dollar(5)); assertEquals(Money.dollar(10), sum);\n\n}\n\nWe could fake the implementation by just returning “Money.dollar(10)”, but the implementation seems obvious. We’ll try:\n\nMoney\n\nMoney plus(Money addend) {\n\nreturn new Money(amount + addend.amount, currency);\n\n}\n\n57\n\n58\n\nAddition, Finally\n\n(In general, I will begin speeding up the implementations to save trees and keep your interest. Where the design isn’t obvious I will still fake the implementation and refactor. I hope you will see through this how TDD gives you control over the size of steps.)\n\nHaving said that I was going to go much faster, I will immediately go much slower, not in getting the tests working, but in writing the test itself. There are times and tests that call for careful thought. How are we going to represent multi-currency arithmetic? This is one of those times for careful thought.\n\nThe most difficult design constraint is that we would like most of the code in the system to be unaware that it is (potentially) dealing with multiple currencies. One possible strategy is to immediately convert all money values into a reference cur- rency (I’ll let you guess which reference currency American imperialist pig pro- grammers generally choose). However, this doesn’t allow exchange rates to vary easily.\n\nInstead we would like a solution that lets us conveniently represent multiple exchange rates, and still allows most arithmetic-like expressions to look like, well, arithmetic.\n\nObjects to the rescue. When the object you have doesn’t behave like you want, make another object with the same external protocol (an Imposter), but a different implementation.\n\nThis probably sounds a bit like magic. How do you know to think of creating an imposter here? I won’t kid you—there is no formula for flashes of design insight. Ward came up with the “trick” a decade ago and I haven’t seen it independently duplicated yet, so it must be a pretty tricky trick. TDD can’t guarantee that you will have flashes of insight at the right moment. However, confidence-giving tests and carefully factored code give you preparation for insight, and preparation for apply- ing that insight when it comes.\n\nThe solution is to create an object that acts like a Money, but represents the sum of two Moneys. I’ve tried several different metaphors to explain this idea. One is to treat the sum like a Wallet—you can have several different notes of different denominations and currencies in the same wallet.\n\nAnother metaphor is “expressions”, as in “(2 + 3) * 5”, or in our case “($2 + 3 CHF) * 5”. A Money is the atomic form of an expression. Operations result in Expressions, one of which will be a Sum. Once the operation (like adding up the",
      "page_number": 63
    },
    {
      "number": 9,
      "title": "Segment 9 (pages 73-84)",
      "start_page": 73,
      "end_page": 84,
      "detection_method": "topic_boundary",
      "content": "value of a portfolio) is complete, the resulting Expression can be reduced back a single currency given a set of exchange rates.\n\nApplying this metaphor to our test, we know what we end up with:\n\npublic void testSimpleAddition() {\n\n… assertEquals(Money.dollar(10), reduced);\n\n}\n\nThe reduced Expression is created by applying exchange rates to an Expression. What in the real world applies exchange rates? A bank. We would like to be able to write:\n\npublic void testSimpleAddition() {\n\n… Money reduced= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(10), reduced);\n\n}\n\n(It’s a little weird to be mixing the “bank” metaphor and the “expression” meta- phor. We’ll get the whole story told first, and then we’ll see what we can do about literary value.)\n\nWe have made an important design decision here. We could just as easily have written “…reduce= sum.reduce(“USD”, bank)”. Why make the Bank responsible? One answer is “that’s the first thing that popped into my head,” but that’s not very informative. Why did it pop into my head that reduction should be the responsibil- ity of the bank and not the expression? Here’s what I’m aware of at the moment:\n\nExpressions seem to be at the heart of what we are doing. I try to keep the objects at the heart as ignorant of the rest of the world as possible, so they stay flexible as long as possible (and remain easy to test, and reuse, and understand.)\n\nI can imagine there will be many operations involving Expressions. If we add every operation to Expression, Expression will grow without limit.\n\nThat doesn’t seem like enough reasons to tip the scales permanently, but it is enough for me to start in this direction. I’m also perfectly willing to move responsi- bility for reduction to Expression if it turns out Bank’s don’t need to be involved.\n\nThe Bank in our simple example doesn’t really need to do anything. As long as we have an object we’re okay:\n\n59\n\n60\n\nAddition, Finally\n\npublic void testSimpleAddition() {\n\n… Bank bank= new Bank(); Money reduced= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(10), reduced);\n\n}\n\nThe sum of two Moneys should be an Expression:\n\npublic void testSimpleAddition() {\n\n… Expression sum= five.plus(five); Bank bank= new Bank(); Money reduced= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(10), reduced);\n\n}\n\nAt least we know for sure how to get five dollars:\n\npublic void testSimpleAddition() { Money five= Money.dollar(5); Expression sum= five.plus(five); Bank bank= new Bank(); Money reduced= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(10), reduced);\n\n}\n\nHow do we get this to compile? We need an interface Expression (we could have a class, but an interface is even lighter weight):\n\nExpression\n\ninterface Expression\n\nMoney.plus() needs to return an Expression:\n\nMoney\n\nExpression plus(Money addend) {\n\nreturn new Money(amount + addend.amount, currency);\n\n}\n\nWhich means that Money has to implement Expression (which is easy, since there are no operations yet):\n\nMoney\n\nclass Money implements Expression\n\nWe need an empty Bank class:\n\nBank\n\nclass Bank\n\nWhich stubs out reduce():\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nreturn null;\n\n}\n\nNow it compiles, and fails miserably. Hooray! Progress! We can easily fake the implementation, though:\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nreturn Money.dollar(10);\n\n}\n\nWe’re back to a green bar, and ready to refactor. First, reviewing, we:\n\nReduced a big test to a smaller test that represented progress ($5 + 10 CHF to $5 + $5)\n\nThought carefully about the possible metaphors for our computation\n\nRe-wrote our previous test based on our new metaphor\n\n(cid:127) Got the test to compile quickly (cid:127) Made it run\n\nLooked forward with a bit of trepidation to the refactoring necessary to make the implementation real\n\n61\n\n62\n\nAddition, Finally\n\nCHAPTER 15\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10\n\nMakeIt\n\nWe can’t mark our test for $5 + $5 done until we’ve removed all the duplication. We don’t have code duplication, but we do have data duplication. The $10 in the fake implementation:\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nreturn Money.dollar(10);\n\n}\n\nis really the same as the “$5 + $5” in the test:\n\npublic void testSimpleAddition() { Money five= Money.dollar(5); Expression sum= five.plus(five); Bank bank= new Bank(); Money reduced= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(10), reduced);\n\n}\n\nBefore when we’ve had a fake implementation, it’s been obvious how to work backwards to the real implementation. It’s just been a matter of replacing constants with variables. This time, though, it’s not obvious to me how to work backwards. So, even though it feels a little speculative, we’ll work forwards.\n\n63\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5\n\n64\n\nMake It\n\nFirst, Money.plus() needs to return a real Expression, a Sum, not just a Money (per- haps later we’ll optimize the special case of adding two identical currencies, but that’s later.)\n\nThe sum of two Moneys should be a Sum:\n\npublic void testPlusReturnsSum() {\n\nMoney five= Money.dollar(5); Expression result= five.plus(five); Sum sum= (Sum) result; assertEquals(five, sum.augend); assertEquals(five, sum.addend);\n\n}\n\n(Did you know that the first argument to addition is called the “augend”? I didn’t until I was writing this. Geek joy.)\n\nThe test above is not one I would expect to live a long time. It is deeply concerned with the implementation of our operation, not its externally visible behavior. How- ever, if we make it work, we expect we’ve moved one step closer to our goal.\n\nTo get it to compile, all we need is a Sum class with two fields, augend and addend:\n\nSum\n\nclass Sum {\n\nMoney augend; Money addend;\n\n}\n\nThis gives us a ClassCastException, because Money.plus() is returning a Money, not a Sum: Money\n\nExpression plus(Money addend) { return new Sum(this, addend);\n\n}\n\nSum needs a constructor:\n\nSum\n\nSum(Money augend, Money addend) { }\n\nAnd Sum needs to be a kind of Expression:\n\nSum\n\nclass Sum implements Expression\n\nNow the system compiles again, but the test is still failing, this time because the Sum constructor is not setting the fields (we could fake the implementation by ini- tializing the fields, but I said I’d start going faster):\n\nSum\n\nSum(Money augend, Money addend) {\n\nthis.augend= augend; this.addend= addend;\n\n}\n\nNow Bank.reduce() is being passed a Sum. If the currencies in the Sum are all the same, and the target currency is also the same, the result should be a Money whose amount is the sum of the amounts:\n\npublic void testReduceSum() {\n\nExpression sum= new Sum(Money.dollar(3), Money.dollar(4)); Bank bank= new Bank(); Money result= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(7), result);\n\n}\n\nI carefully chose parameters that would break the existing test. When we reduce a Sum, the result (under these simplified circumstances) should be a Money whose amount is the sum of the amounts of the two Moneys and whose currency is the currency to which we are reducing.\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nSum sum= (Sum) source; int amount= sum.augend.amount + sum.addend.amount; return new Money(amount, to);\n\n}\n\nThis is immediately ugly on two counts:\n\nThe cast. This code should work with any Expression.\n\nThe public fields, and two levels of references at that\n\n65\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money)\n\n66\n\nMake It\n\nEasy enough to fix. First, we can move the body of the method to Sum and get rid of some of the visible fields. We are “sure” we will need the Bank as a parameter in the future, but this is pure, simple refactoring, so we leave it out (actually, just now I put it in because I “knew” I would need it—shame, shame on me.)\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nSum sum= (Sum) source; return sum.reduce(to);\n\n} Sum\n\npublic Money reduce(String to) {\n\nint amount= augend.amount + addend.amount; return new Money(amount, to);\n\n}\n\n(Which brings up the point of how we are going to implement, er… test, Bank.reduce() when the argument is a Money.)\n\nLet’s write that test, since the bar is green and there is nothing else obvious to do with the code above:\n\npublic void testReduceMoney() { Bank bank= new Bank(); Money result= bank.reduce(Money.dollar(1), \"USD\"); assertEquals(Money.dollar(1), result);\n\n} Bank\n\nMoney reduce(Expression source, String to) {\n\nif (source instanceof Money) return (Money) source; Sum sum= (Sum) source; return sum.reduce(to);\n\n}\n\nUgly, ugly, ugly. However, we now have a green bar, and refactoring is possible. Any time you are checking classes explicitly, you should be using polymorphism instead. Since Sum implements reduce(String), if Money implemented it, too, we could then add it to the Expression interface.\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nif (source instanceof Money)\n\nreturn (Money) source.reduce(to);\n\nSum sum= (Sum) source; return sum.reduce(to);\n\n} Money\n\npublic Money reduce(String to) {\n\nreturn this;\n\n}\n\nIf we add reduce(String) to the Expression interface:\n\nExpression\n\nMoney reduce(String to);\n\nWe can eliminate all those ugly casts and class checks:\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nreturn source.reduce(to);\n\n}\n\nI’m not entirely happy with the name of the method being the same in Expression and in Bank, but having different parameter types. I’ve never found a satisfactory general solution to this problem in Java. In languages with keyword parameters, communicating the difference between Bank.reduce(Expression, String) and Expression.reduce(String) is well supported by the language syntax. With posi- tional parameters, it’s not so easy to make the code speak for you about how the two are different.\n\nNext we’ll actually exchange one currency for another. First, reviewing, we:\n\n(cid:127) Didn’t mark a test as done because the duplication had not been eliminated (cid:127) Worked forwards instead of backwards to realize the implementation (cid:127) Wrote a test to force the creation of an object we expected to need later (Sum)\n\nStarted implementing faster (the Sum constructor)\n\nImplemented code with casts in one place, then moved the code where it belonged once the test were running\n\nIntroduced polymorphism to eliminate explicit class checking\n\n67\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion\n\n68\n\nMake It\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String)\n\n69\n\n70\n\nMake It",
      "page_number": 73
    },
    {
      "number": 10,
      "title": "Segment 10 (pages 85-99)",
      "start_page": 85,
      "end_page": 99,
      "detection_method": "topic_boundary",
      "content": "CHAPTER 16\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String)\n\nChange\n\nChange is worth embracing (especially if you have a book out with “embrace change” in the title). Here, though, we are thinking about a much simpler form of change—we have 2 francs and we want a dollar. That sounds like a test case already:\n\npublic void testReduceMoneyDifferentCurrency() {\n\nBank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Money result= bank.reduce(Money.franc(2), \"USD\"); assertEquals(Money.dollar(1), result);\n\n}\n\nWhen I go from francs to dollars, I divide by two (we’re still studiously ignoring all those nasty numerical problems.) We can make the bar green in one piece of ugli- ness:\n\nMoney\n\npublic Money reduce(String to) {\n\nint rate = (currency.equals(\"CHF\") && to.equals(\"USD\"))\n\n? 2 : 1;\n\nreturn new Money(amount / rate, to);\n\n}\n\n71\n\n72\n\nChange\n\nNow, suddenly, Money knows about exchange rates. Yuck. The Bank should be the only place we care about exchange rates. We’ll have to pass the Bank as a parame- ter to Expression.reduce() (see, we knew we would need it, and we were right. In the words of the grandfather in The Princess Bride, “You’re very clever…”) First the caller: Bank\n\nMoney reduce(Expression source, String to) {\n\nreturn source.reduce(this, to);\n\n}\n\nThen the implementors:\n\nExpression\n\nMoney reduce(Bank bank, String to); Sum\n\npublic Money reduce(Bank bank, String to) {\n\nint amount= augend.amount + addend.amount; return new Money(amount, to);\n\n} Money\n\npublic Money reduce(Bank bank, String to) {\n\nint rate = (currency.equals(\"CHF\") && to.equals(\"USD\"))\n\n? 2 : 1;\n\nreturn new Money(amount / rate, to);\n\n}\n\nThe methods have to be public because methods in interfaces have to be public (for some excellent reason, I’m sure.)\n\nNow we can calculate the rate in the Bank:\n\nBank\n\nint rate(String from, String to) {\n\nreturn (from.equals(\"CHF\") && to.equals(\"USD\"))\n\n? 2 : 1;\n\n}\n\nAnd ask the bank for the right rate:\n\nMoney\n\npublic Money reduce(Bank bank, String to) {\n\nint rate = bank.rate(currency, to); return new Money(amount / rate, to);\n\n}\n\nThat pesky “2” still appears in both the test and the code. To get rid of it, we need to keep a table of rates in the Bank and look up a rate when we need it. We could use a Hashtable mapping pairs of currencies to rates. Can we use a two element array containing the two currencies as the key? Does Array.equals() check to see if the elements are equal?\n\npublic void testArrayEquals() {\n\nassertEquals(new Object[] {\"abc\"}, new Object[] {\"abc\"});\n\n}\n\nNope. The test fails, so we have to create a real object for the key:\n\nPair\n\nprivate class Pair {\n\nprivate String from; private String to;\n\nPair(String from, String to) {\n\nthis.from= from; this.to= to;\n\n}\n\n}\n\nBecause we are using Pairs as keys, we have to implement equals() and hash- Code(). I’m not going to write tests for these, because we are writing this code in the context of a refactoring. If we get to the payoff of the refactoring and all the tests run, we expect the code to have been exercised. If I was programming with someone who didn’t see exactly where we were going with this, or if the logic became the least bit complex, I would begin writing separate tests.\n\nPair\n\npublic boolean equals(Object object) {\n\nPair pair= (Pair) object; return from.equals(pair.from) && to.equals(pair.to);\n\n}\n\n73\n\n74\n\nChange\n\npublic int hashCode() {\n\nreturn 0;\n\n}\n\n“0” is a terrible hash value, but it has the advantage that it’s easy to implement and it will get us running quickly. Currency lookup will look like linear search. Later, when we get lots of currencies, we can do a more thorough job with real usage data.\n\nWe need somewhere to store the rates:\n\nBank\n\nprivate Hashtable rates= new Hashtable();\n\nWe need to set the rate when told:\n\nBank\n\nvoid addRate(String from, String to, int rate) {\n\nrates.put(new Pair(from, to), new Integer(rate));\n\n}\n\nAnd then we can look up the rate when asked:\n\nBank\n\nint rate(String from, String to) {\n\nInteger rate= (Integer) rates.get(new Pair(from, to)); return rate.intValue();\n\n}\n\nWait a minute!? We got a red bar. What happened? A little snooping around tells us that if we ask for the rate from USD to USD, we expect the value to be 1. Since this was a surprise, let’s write a test to communicate what we discovered:\n\npublic void testIdentityRate() {\n\nassertEquals(1, new Bank().rate(\"USD\", \"USD\"));\n\n}\n\nNow we have three errors, but we expect them all to be fixed with one change:\n\nBank\n\nint rate(String from, String to) {\n\nif (from.equals(to)) return 1;\n\nInteger rate= (Integer) rates.get(new Pair(from, to)); return rate.intValue();\n\n}\n\nGreen bar!\n\nNext we’ll implement our last big test, $5 + 10 CHF. Several significant techniques have slipped into this chapter:\n\n(cid:127) Added a parameter, in seconds, that we expected we would need\n\nFactored out the data duplication between code and tests\n\n(cid:127) Wrote a test (testArrayEquals) to check an assumption about the operation of\n\nJava\n\nIntroduced a private helper class without distinct tests of its own\n\n(cid:127) Made a mistake in a refactoring and chose to forge ahead, writing another test to\n\nisolate the problem\n\n75\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String)\n\n76\n\nChange\n\nCHAPTER 17\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String)\n\nMixedCurrencies\n\nNow we are finally ready to add the test that started it all, $5 + 10 CHF:\n\npublic void testMixedAddition() {\n\nExpression fiveBucks= Money.dollar(5); Expression tenFrancs= Money.franc(10); Bank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Money result= bank.reduce(fiveBucks.plus(tenFrancs), \"USD\"); assertEquals(Money.dollar(10), result);\n\n}\n\nThis is what we’d like to write. Unfortunately, there are a host of compile errors. When we were generalizing from Money to Expression, we left a lot of loose ends laying around. I was worried about them, but I didn’t want to disturb you. It’s dis- turbing time, now.\n\nWe won’t be able to get the test above to compile quickly. We will make the first change that will ripple to the next and the next. We have two paths forward. We can make it work quickly by writing a more specific test and then generalizing, or we can trust our compiler not to let us make mistakes. I’m with you—let’s go slow (in practice I would probably just fix the rippling changes one at a time).\n\npublic void testMixedAddition() {\n\nMoney fiveBucks= Money.dollar(5);\n\n77\n\n78\n\nMixed Currencies\n\nMoney tenFrancs= Money.franc(10); Bank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Money result= bank.reduce(fiveBucks.plus(tenFrancs), \"USD\"); assertEquals(Money.dollar(10), result);\n\n}\n\nThe test doesn’t work. We get 15 USD instead of 10 USD. It’s as if Sum.reduce() isn’t reducing the arguments. It isn’t:\n\nSum\n\npublic Money reduce(Bank bank, String to) {\n\nint amount= augend.amount + addend.amount; return new Money(amount, to);\n\n}\n\nIf we reduce both of the arguments, the test should pass:\n\nSum\n\npublic Money reduce(Bank bank, String to) {\n\nint amount= augend.reduce(bank, to).amount +\n\naddend.reduce(bank, to).amount; return new Money(amount, to);\n\n}\n\nAnd it does. Now we can begin pecking away at Moneys that should be Expres- sions. To avoid the ripple effect, we’ll start at the edges and work our way back to the test case. For example, the augend and addend can now be Expressions:\n\nSum\n\nExpression augend; Expression addend;\n\nThe arguments to the Sum constructor can also be Expressions:\n\nSum\n\nSum(Expression augend, Expression addend) {\n\nthis.augend= augend; this.addend= addend;\n\n}\n\n(Sum is starting to remind me of Composite, but not so much that I want to general- ize. The moment we want a Sum with other than two parameters, though, I’m ready to transform it.) So much for Sum. How about Money?\n\nThe argument to plus() can be an Expression:\n\nMoney\n\nExpression plus(Expression addend) { return new Sum(this, addend);\n\n}\n\nTimes() can return an Expression:\n\nMoney\n\nExpression times(int multiplier) {\n\nreturn new Money(amount * multiplier, currency);\n\n}\n\nThis suggests that Expression should include the operations plus() and times(). That’s all for Money. We can now change the argument to plus() in our test case:\n\npublic void testMixedAddition() {\n\nMoney fiveBucks= Money.dollar(5); Expression tenFrancs= Money.franc(10); Bank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Money result= bank.reduce(fiveBucks.plus(tenFrancs), \"USD\"); assertEquals(Money.dollar(10), result);\n\n}\n\nWhen we change fiveBucks to an Expression, we have to make several changes. Fortunately we have the compiler’s to-do list to keep us focused. First we make the change:\n\npublic void testMixedAddition() {\n\nExpression fiveBucks= Money.dollar(5); Expression tenFrancs= Money.franc(10); Bank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Money result= bank.reduce(fiveBucks.plus(tenFrancs), \"USD\"); assertEquals(Money.dollar(10), result);\n\n}\n\n79\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String) Sum.plus Expression.times\n\n80\n\nMixed Currencies\n\nWe are politely told that plus() is not defined for Expressions. We define it:\n\nExpression\n\nExpression plus(Expression addend);\n\nAnd then we have to add it to Money and Sum. Money? Yes, it has to be public in Money:\n\nMoney\n\npublic Expression plus(Expression addend) {\n\nreturn new Sum(this, addend);\n\n}\n\nWe’ll just stub out the implementation in Sum, and add it to our list:\n\nSum\n\npublic Expression plus(Expression addend) {\n\nreturn null;\n\n}\n\nNow that the program compiles, the tests all run.\n\nWe are ready to finish generalizing Money to Expression, but first we’ll review. We:\n\n(cid:127) Wrote the test we wanted, then backed off to make it achievable in one step (cid:127) Generalized (used a more abstract declaration) from the leaves back to the root\n\n(the test case)\n\nFollowed the compiler when we made a change (Expression fiveBucks) which caused changes to ripple (added plus() to Expression, etc.)\n\nCHAPTER 18\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String) Sum.plus Expression.times\n\nAbstraction,Finally\n\nWe need to implement Sum.plus() to finish Expression.plus, and then we need Expression.times(), and then we’re finished with the whole example. Here’s the test for Sum.plus():\n\npublic void testSumPlusMoney() {\n\nExpression fiveBucks= Money.dollar(5); Expression tenFrancs= Money.franc(10); Bank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Expression sum= new Sum(fiveBucks, tenFrancs).plus(fiveBucks); Money result= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(15), result);\n\n}\n\nWe could have created a Sum by adding fiveBucks and tenFrancs, but the form above, where we explicitly create the Sum, communicates more directly. You are writing these tests not just to make your experience of programming more fun and rewarding, but also as a Rosetta Stone for future generations to appreciate your genius. Think, oh think, of your readers.\n\nThe test, in this case, is longer than the code. The code is the same as the code in Money (do I hear an abstract class in the distance?):\n\n81\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String) Sum.plus Expression.times\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String) Sum.plus Expression.times\n\n82\n\nAbstraction, Finally\n\nSum\n\npublic Expression plus(Expression addend) {\n\nreturn new Sum(this, addend);\n\n}\n\nYou will likely end up with about the same number of lines of test code as model code when TDDing. For TDD to make economic sense, either you will have to be able to write twice as many lines per day as before, or write half as many lines for the same functionality. You’ll have to measure and see what effect TDD has on your own practice. Be sure to factor debugging, integrating, and explaining time into your metrics, though.\n\nIf we can make Sum.times() work, then declaring Expression.times() will be one simple step. The test is:\n\npublic void testSumTimes() {\n\nExpression fiveBucks= Money.dollar(5); Expression tenFrancs= Money.franc(10); Bank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Expression sum= new Sum(fiveBucks, tenFrancs).times(2); Money result= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(20), result);\n\n}\n\nAgain, the test is longer than the code (you JUnit geeks will know how to fix that— the rest of you will have to read Fixture):\n\nSum\n\nExpression times(int multiplier) {\n\nreturn new Sum(augend.times(multiplier),\n\naddend.times(multiplier)); }\n\nSince we abstracted augend and addend to Expressions in the last chapter, we now have to declare times() in Expression before the code will compile:\n\nExpression\n\nExpression times(int multiplier);\n\nWhich forces us to raise the visibility of Money.times() and Sum.times():\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String) Sum.plus Expression.times\n\nSum\n\npublic Expression times(int multiplier) {\n\nreturn new Sum(augend.times(multiplier),\n\naddend.times(multiplier)); } Money\n\npublic Expression times(int multiplier) {\n\nreturn new Money(amount * multiplier, currency);\n\n}\n\nAnd it works.\n\nThe only loose end to tie up is to experiment with returning a Money when we add $5 + $5. The test would be:\n\npublic void testPlusSameCurrencyReturnsMoney() {\n\nExpression sum= Money.dollar(1).plus(Money.dollar(1)); assertTrue(sum instanceof Money);\n\n}\n\nThis test is a little ugly, because it is testing the guts of the implementation, not the externally visible behavior of the objects. However, it will drive us to make the changes we need to make, and this is only an experiment, after all. Here is the code we would have to modify to make it work:\n\nMoney\n\npublic Expression plus(Expression addend) {\n\nreturn new Sum(this, addend);\n\n}\n\nThere is no obvious, clean way (not to me, anyway, I’m sure you could think of something) to check the currency of the argument if and only if it is a Money. The experiment fails, we delete the test (which we didn’t like much anyway), and away we go.\n\nReviewing, we:\n\n(cid:127) Wrote a test with future readers in mind\n\nSuggested an experiment comparing TDD with your current programming style\n\n(cid:127) Once again had changes of declarations ripple through the system, and once\n\nagain followed the compiler’s advice to fix them\n\n83\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String) Sum.plus Expression.times\n\n84\n\nAbstraction, Finally\n\nTried a brief experiment, then discarded it when it didn’t work out\n\nCHAPTER 19\n\nMoneyRetrospective\n\nLet’s take a look back at the Money example, both the process we used and the results. We will look at:\n\n(cid:127) What Next? (cid:127) Metaphor—the dramatic effect metaphor has on the structure of the design\n\nJUnit Usage—when we ran tests and how we used JUnit\n\nCode Metrics—a numerical abstract of the resulting code\n\nProcess—we say red/green/refactor, but how much work goes into each step?\n\nTest Quality—how do TDD tests stack up by conventional test metrics?\n\nWhat Next?\n\nIs the code finished? No. There is that nasty duplication between Sum.plus() and Money.plus(). If we made Expression a class instead of an interface (not the usual direction, as classes more often become interfaces), we would have a natural home for the common code.\n\nI don’t believe in “finished”. TDD can be used as a way to strive for perfection, but that isn’t its most effective use. If you have a big system, the parts that you touch all the time should be absolutely rock solid, so you can make daily changes confi- dently. As you drift out to the periphery of the system, to parts that don’t change\n\n85",
      "page_number": 85
    },
    {
      "number": 11,
      "title": "Segment 11 (pages 100-107)",
      "start_page": 100,
      "end_page": 107,
      "detection_method": "topic_boundary",
      "content": "86\n\nMoney Retrospective\n\noften, the tests can be spottier and the design uglier without interfering with your confidence.\n\nWhen I’ve done all of the obvious tasks, I like running a code critic, like SmallLint for Smalltalk. Many of the suggestions that come up I already know about, or I dis- agree with. Automated critics don’t forget, though, so if I don’t delete an obsolete implementation I don’t have to stress. The critic will point it out.\n\nAnother “what next?” question is, “What additional tests do I need?” Sometimes you think of a test that “shouldn’t” work, and it does. Then you need to find out why. Sometimes a test that shouldn’t work really doesn’t, and you can record it as a known limitation or as work to be done later.\n\nFinally, when the list is empty is a good time to review the design. Do the words and concepts play together? Is there duplication that is difficult to eliminate given the current design (lingering duplication is a symptom of latent design.)\n\nMetaphor\n\nThe biggest surprise for me in coding the Money example is how different it came out this time. I have programmed Money in production at least three times that I can think of. I have used it as an example in print another half dozen times. I have programmed it live on stage (relax, it’s not as exciting as it sounds…) another fif- teen times. I coded another three or four times preparing for writing (I ripped out Section I and rewrote it based on early reviews.) Then, while I was writing this, I thought of using Expression as the metaphor and the design went in a completely different direction than it has gone before.\n\nI really didn’t expect the metaphor to be so powerful. A metaphor should just be a source of names, shouldn’t it? Apparently not.\n\nThe metaphor Ward used for “several monies together with potentially different currencies” was a vector, like a mathematic vector where the coefficients were cur- rencies instead of x2. I used MoneySum for a while, then MoneyBag (which is nice and physical), and finally Wallet (which is commoner in most folks’ experience). All of these metaphors imply that the collection of Money’s is flat. For example, “2 USD + 5 CHF + 3 USD” would result in “5 USD + 5 CHF”. Two values with the same currency would be merged.\n\nOccurrences\n\n50 45 40\n\n35 30 25 20 15\n\n10 5 0\n\nThe Expression metaphor freed me from a bunch of nasty issues about merging duplicated currencies. The code came out cleaner and clearer than I’ve ever seen it before. I’m concerned about the performance of Expressions, but I’m happy to wait until I see some usage statistics before I start optimizing.\n\nWhat if I got to rewrite everything I ever wrote 20 times? Would I keep finding insight and surprise every time? Is there some way to be more mindful as I program so I can squeeze all the insight out of the first three times? The first time?\n\nJUnit Usage\n\nI had JUnit keep a log while I was coding the Money example. I pressed the Run button precisely 125 times. Because I was writing at the same time as I was pro- gramming, the interval between runs isn’t representative, but during the times I was just programming I ran the tests about once a minute. Only once in that whole time was I surprised by either success or failure, and that was a refactoring done in haste.\n\nHere is a histogram of the time interval between test runs. The large number of large intervals is most likely because of the time I spent writing:\n\n0\n\n1\n\n< 5\n\n< 10\n\n>= 10\n\nMinutes Between Runs\n\n87\n\n88\n\nMoney Retrospective\n\nCode Statistics\n\nHere are some statistics on the code:\n\nFunctional\n\nTest\n\nClasses\n\n5\n\n1\n\nFunctions (1)\n\n22\n\n15\n\nLines (2)\n\n91\n\n89\n\nCyclomatic complexity (3)\n\n1.04\n\n1\n\nLines/function\n\n4.1 (4)\n\n5.9 (5)\n\n1. Because we haven’t implemented the whole API, we can’t evaluate the absolute number of functions, or the number of functions per class, or lines per class. However, the ratios are instructive. There are roughly as many lines and func- tions in the test and functional code.\n\n2. The number of lines of test code can be reduced by extracting common fixtures. The rough correspondence between lines of model code and lines of test code will remain, however.\n\n3. Cyclomatic complexity is a measure of conventional flow complexity. Test complexity is 1 because there are no branches or loops in test code. Functional code complexity is low because of the heavy use of polymorphism as a substi- tute for explicit control flow.\n\n4. This includes the function header and trailing brace.\n\n5. Lines/function in the tests is inflated because we have not factored out common fixture-building code, as explained in the section on JUnit.\n\nProcess\n\nThe TDD cycle is:\n\n(cid:127) Write a test (cid:127) Make it compile, run it to see it fail (cid:127) Make it run\n\nRemove duplication\n\nAssuming that writing a test is a single step, how many changes does it take to com- pile, run, and refactor? (By change, I mean changing a method or class definition.)\n\nNumber of changes per refactoring\n\n10\n\n8\n\n6\n\nrrences\n\n4\n\n2\n\n0\n\n1 3 5 7 9\n\n1 1\n\n3 1\n\n5 1\n\n7 1\n\n9 1\n\n1 2\n\n3 2\n\n5 2\n\n7 2\n\nNumber of Changes\n\nI expect that if we gathered data for a large project, the number of changes to com- pile and run would remain fairly small (they could be even smaller if the program- ming environment understood what the tests were trying to tell it—creating stubs automatically, for instance). However, (here’s at least a master’s thesis) the number of changes per refactoring should follow a “fat tail” or leptokurtotic profile, which is like a bell curve but with more extreme changes than predicted by a standard bell curve. Many measurements in nature follow this profile, like price changes in the stock market.1\n\n1. Fractals and Scaling in Finance, Benoit Mandelbrot, editor, Springer- Verlag, 1997, ISBN: 0387983635\n\n9 2\n\n89\n\n90\n\nMoney Retrospective\n\nTest Quality\n\nThe tests that are a natural by-product of TDD are certainly useful enough to keep running as long as the system is running. Don’t expect them to replace the many other types of testing:\n\nPerformance\n\n(cid:127)\n\nStress (cid:127) Usability\n\nHowever, if the defect density of test-driven code is low enough, the role of profes- sional testing will inevitably change from “adult supervision” to something more closely resembling an amplifier for the communication between those who gener- ally have a feeling for what the system should do and those who will make it do. As a stand-in for a long and interesting conversation about the future of professional testing, here are a couple of widely shared measurements of the tests written above.\n\nStatement coverage is certainly not a sufficient measure of test quality, but it is a starting place. TDD followed religiously should result in 100% statement coverage. JProbe (www.sitraka.com/software/jprobe) reports only one line in one method not covered by the test cases, Money.toString(), which we added explicitly as a debug- ging aid, not real model code.\n\nAnother way of evaluating test quality is defect insertion. The idea is simple— change the meaning of a line of code and a test should break. You can do this man- ually, or with a tool like Jester (jester.sourceforge.net). Jester reports only one line it is able to change without breaking, Pair.hashCode(). We faked the implementa- tion to just return 0. Returning a different constant doesn’t actually change the meaning of the program (one fake number is as good as another), so it isn’t really a defect that has been inserted.\n\nPhlip made a point about test coverage that bears repeating here. A gross measure of coverage is the number of tests testing different aspects of a program divided by the number of aspects that need testing (the complexity of the logic). One way to improve coverage is to write more tests, hence the dramatic difference in the num- ber of tests a TDDer would write for code and the number of tests a professional tester would write (page ??? gives details of an example where I wrote 6 tests and a tester wrote 65 for the same problem). However, another way to improve coverage is to take a fixed set of tests and simplify the logic of the program. The refactoring step often has this effect—conditionals replaced by messages, or by nothing at all. In his words, “… instead of increasing the test coverage to walk all permutations of\n\ninput (more properly an efficiently reduced sample of all possible permutations), we just leave the same tests covering various permutations of code as it shrinks.”\n\nOne Last Review\n\nThe three items that come up time and again as surprises when teaching TDD are:\n\nThe three approaches to making a test work cleanly—fake it, triangulate, and just typing in the right solution to begin with\n\nRemoving duplication between test and code as a way to drive the design\n\nThe ability to control the gap between tests to increase traction when the road gets slippery and cruise faster when conditions are clear\n\n91\n\n92\n\nMoney Retrospective\n\nCHAPTER 20\n\nSectionII:xUnit\n\nHow, oh how, to talk about the implementation of a tool for test-driven develop- ment? Test-driven, naturally.\n\nThe xUnit architecture comes out very smoothly in Python, so I’ll switch to Python for this section. Don’t worry, I’ll give a little commentary on Python, for those of you who haven’t seen it before. When you’re done you’ll have an introduction to Python, you’ll be able to write your own testing framework, and you’ll have seen a trickier example of TDD—three for the price of one.\n\nWriting a testing tool test-first using itself as the tool, may seem a bit like perform- ing brain surgery on yourself (“Don’t touch those motor centers—oh, too bad, game over”). It will get weird from time to time. However, the logic of the testing framework is more complicated than the wimpy money example above. You can read this chapter as a step towards test-driven development of “real” software. You can read this chapter as a computer-sciency exercise in self-referential program- ming.\n\nFirst, we need to be able to create a TestCase and run a test method. For example: TestCase(“testMethod”).run(). We have a bootstrap problem. We are writing test cases to test a framework that we will be using to write the test cases. Since we don’t have a framework yet, we will have to verify the operation of the first tiny step by hand. Fortunately, we are well rested and relaxed and unlikely to make mis-\n\n93",
      "page_number": 100
    },
    {
      "number": 12,
      "title": "Segment 12 (pages 108-122)",
      "start_page": 108,
      "end_page": 122,
      "detection_method": "topic_boundary",
      "content": "Invoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results\n\n94\n\nSection II: xUnit\n\ntakes, which is why we will go in teensy tiny steps, verifying everything six ways from Sunday. Here is the test list I can think of for a testing framework.\n\nWe are still working test-first, of course. For our first proto-test, we need a little program that will print out true if a test method gets called, and false otherwise. If we have a test case that sets a flag inside the test method, we can print the flag after we’re done and make sure it’s correct. Once we have verified it manually, we can automate the process.\n\nHere’s the strategy for our bootstrap test—we will create a TestCase that contains a flag. Before the test method is run, the flag should be false. The test method will set the flag. After the test method is run, the flag should be true. We’ll call the TestCase class “WasRun”, because it’s a test case that reports whether a method was run. The flag (perhaps confusingly, but it’s such a good name) will also be called “wasRun”, so we can eventually write “assert test.wasRun” (assert is a built- in Python facility.)\n\nPython executes statements as it reads a file, so we can start with invoking the test method manually:\n\ntest= WasRun(\"testMethod\") print test.wasRun test.testMethod() print test.wasRun\n\nWe expect this to print “None” (None in Python is like null or nil, and stands for false, along with 0 and a few other objects) before the method was run, and “1” afterwards. It doesn’t, because we haven’t defined the class WasRun yet (test-first, test-first).\n\nWasRun\n\nclass WasRun: pass\n\n(The keyword “pass” is used when there is no implementation of a class or method.) Now we are told we need an attribute “wasRun”. We need to create the attribute when we create the instance is created (the constructor is called “__init__” for convenience). In it, we set the wasRun flag false.\n\nWasRun\n\nclass WasRun: def __init__(self, name):\n\nself.wasRun= None\n\nRunning the file faithfully prints out “None”, then tells us we need to define the method “testMethod” (wouldn’t it be great if your IDE noticed this, provided you with a stub, and opened up an editor on it? Nah, too useful… cf )\n\nWasRun\n\ndef testMethod(self): pass\n\nNow when we execute the file, we see “None” and “None”. We want to see “None” and “1”. We can get it by setting the flag in testMethod():\n\nWasRun\n\ndef testMethod(self): self.wasRun= 1\n\nNow we get the right answer (the green bar, hooray!). Now we have a bunch of refactoring to do, but as long as we maintain the green bar, we know we have made progress.\n\nNext we need to use our real interface, run(), instead of calling the test method directly. The test changes to:\n\ntest= WasRun(\"testMethod\") print test.wasRun test.run() print test.wasRun\n\nThe implementation we can hardwire at the moment to:\n\nWasRun\n\ndef run(self): self.testMethod()\n\nAnd our test is back to printing the right values again. Lots of refactoring has this feel—separating two parts so you can work on them separately. If they go back together when you are finished, fine, if not, you can leave them separate. In this case, we expect to create a superclass TestCase, eventually, but first we have to dif- ferentiate the parts of our one example. There is probably some clever analogy with mitosis in here, but I don’t know enough cellular biology to explain it.\n\n95\n\n96\n\nSection II: xUnit\n\nThe next step is to dynamically invoke the testMethod. If the name attribute of the instance of WasRun is the string “testMethod”, then we can replace the direct call to “self.testMethod()” with “exec “self.” + self.name + “()”” (the dynamic invoca- tion of methods is called Pluggable Selector, and should be used sparingly, and only if there are no reasonable alternatives).\n\nWasRun\n\nclass WasRun: def __init__(self, name): self.wasRun= None self.name= name def run(self): exec \"self.\" + self.name + \"()\"\n\nHere is another general pattern of refactoring—take code that works in one instance and generalize it to work in many by replacing constants with variables. Here the constant was hardwired code, not a data value, but the principle is the same. TDD makes this work well by giving you running concrete examples from which to gen- eralize, instead of having to generalize purely with reasoning.\n\nNow our little WasRun class is doing two distinct jobs—one is keeping track of whether a method was invoked or not, the other is dynamically invoking the method. Time for a little of that mitosis action. First we create an empty TestCase superclass, and make WasRun a subclass:\n\nTestCase\n\nclass TestCase:\n\npass WasRun\n\nclass WasRun(TestCase): …\n\nNow we can move the “name” attribute up to the superclass:\n\nTestCase\n\ndef __init__(self, name): self.name= name\n\nWasRun\n\ndef __init__(self, name): self.wasRun= None TestCase.__init__(self, name)\n\nFinally, the run() method only uses attributes from the superclass, so it probably belongs in the superclass (I’m always looking to put the operations near the data.)\n\nTestCase\n\ndef __init__(self, name): self.name= name\n\ndef run(self):\n\nexec \"self.\" + self.name + \"()\"\n\n(Between every one of these steps I run the tests to make sure I’m getting the same answer.)\n\nWe’re getting tired of looking to see that “None” and “1” are printed every time. Using the mechanism we just built, we can now write:\n\nTestCaseTest\n\nclass TestCaseTest(TestCase): def testRunning(self):\n\ntest= WasRun(\"testMethod\") assert(not test.wasRun) test.run() assert(test.wasRun)\n\nTestCaseTest(\"testRunning\").run()\n\nThe body of the test is just the print statements turned into assertions, so you could just see what we have done as a complicated form of Extract Method.\n\nI’ll let you in on a little secret. I look at the size of the steps in the development above and it looks ridiculous. On the other hand, I tried it with bigger steps, proba- bly six hours in all (I had to spend a lot of time looking up Python stuff), starting from scratch twice, and both times I thought I had the code working when I didn’t. This is about the worst possible case for TDD, because we are trying to get over the bootstrap step.\n\nIt is not necessary to work in such tiny steps as these. Once you’ve mastered TDD, you will be able to work in much bigger leaps of functionality between test cases. However, to master TDD you need to be able to work in such tiny steps when they are called for.\n\nNext we will tackle calling setUp() before running the test. Reviewing first, we:\n\n97\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results\n\n98\n\nSection II: xUnit\n\n(cid:127) After a couple of hubris-fueled false starts, figured out how to begin with a tiny\n\nlittle step\n\nImplemented functionality, first by hardwiring it, then making it more general by replacing constants with variables\n\n(cid:127) Used Pluggable Adaptor, which we promise not to use again for four months,\n\nminimum, because it makes code hard to statically analyze\n\nBootstrapped our testing framework, all in tiny steps\n\nCHAPTER 21\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results\n\nSettheTable\n\nWhen you begin writing tests, you will discover a common pattern (Bill Wake coined the phrase 3A for this):\n\n1. Arrange—create some objects\n\n2. Act—stimulate them\n\n3. Assert—check the results\n\nThe arrange step is often the same test-to-test, while the stimulation and checking steps are unique. I have a 7 and 9. If I add them, I expect 16. If I subtract them, I expect –2, if I multiply them, I expect 63. The stimulation and expected results are unique, the 7 and the 9 don’t change.\n\nIf this pattern repeats at different scales (and it does), then we’re faced with the question of how often do we want to create new objects to test. Looking back at our initial set of constraints, two constraints come into conflict:\n\nPerformance—we would like our tests to run as quickly as possible, so if we use similar objects in several tests we would like to create them once for all tests\n\nIsolation—we would like the success or failure of one test to be irrelevant to other tests, and if one test changes the objects, following tests are likely to change their results\n\n99\n\n100\n\nSet the Table\n\nTest coupling has an obvious nasty effect, where breaking one test causes the next ten to fail even though the code is correct. Test coupling can have a subtle really nasty effect, where the order of tests matters. If I run A before B, they both work, but if I run B before A, then A fails. Or even nastier, the code exercised by B is wrong, but because A ran first, the test passes.\n\nTest coupling—don’t go there. Let’s assume for the moment we can make object creation fast enough. In this case, we would like to create the objects for a test every time the test runs. We’ve already seen a disguised form of this in WasRun, where we wanted to have a flag set to false before we ran the test. Taking steps towards this, first we need a test: TestCaseTest\n\ndef testSetUp(self):\n\ntest= WasRun(\"testMethod\") test.run() assert(test.wasSetUp)\n\nRunning this, (by adding the last line “TestCaseTest(\"testSetUp\").run()” to our file) Python politely informs us that there is no “wasSetUp” attribute. Of course not. We haven’t set it. This method should do it.\n\nWasRun\n\ndef setUp(self):\n\nself.wasSetUp= 1\n\nIt would if we were calling it. Calling setUp is the job of the TestCase, so we turn there:\n\nTestCase\n\ndef setUp(self):\n\npass def run(self):\n\nself.setUp() exec \"self.\" + self.name + \"()\"\n\nThat’s two steps to get a test case running, which is too many in such ticklish cir- cumstances. We’ll see if it will work. Yes, it does pass. However, if you want to learn something, try to figure out how we could have gotten the test to pass by changing no more than one method at a time.\n\nWe can immediately use our new facility to shorten our tests. First, we can simplify WasRun by setting the wasRun flag in setUp:\n\nWasRun\n\ndef setUp(self):\n\nself.wasRun= None self.wasSetUp= 1\n\nWe have to simplify testRunning not to check the flag before running the test. Are we willing to give up this much confidence in our code? Only if testSetUp is in place. This is a common pattern—one test can be simple if and only if another test is in place and running correctly.\n\nTestCaseTest\n\ndef testRunning(self):\n\ntest= WasRun(\"testMethod\") test.run() assert(test.wasRun)\n\nWe can also simplify the tests themselves. In both cases we create an instance of WasRun, exactly that fixture we were talking about earlier. We can create the Was- Run in setUp, and use it in the test methods. Each test method is run in a clean instance of TestCaseTest, so there is no way the two tests can be coupled (assuming the objects don’t interact in some incredibly ugly way, like setting global variables, but we wouldn’t do that, not with all those other readers watching.)\n\nTestCaseTest\n\ndef setUp(self):\n\nself.test= WasRun(\"testMethod\")\n\ndef testRunning(self): self.test.run() assert(self.test.wasRun)\n\ndef testSetUp(self): self.test.run() assert(self.test.wasSetUp)\n\nNext we’ll run tearDown() after the test method. Reviewing this chapter, we:\n\n(cid:127) Decided simplicity of test writing was more important than performance for the\n\nmoment\n\nTested and implemented setUp()\n\n101\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results\n\n102\n\nSet the Table\n\n(cid:127) Used setUp() to simplify the example test case (cid:127) Used setUp() to simplify the test cases checking the example test case (I told\n\nyou this would get like self-brain-surgery)\n\nCHAPTER 22\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun\n\nCleaningUpAfter\n\nTests will sometimes need to allocate external resources in setUp(). If we want the tests to remain independent, a test that allocates external resources should release them before it is done, perhaps in a tearDown() method.\n\nThe simple minded way to write the test for deallocation is to introduce yet another flag. All those flags are starting to bug me, and they are missing an important aspect of the methods—setUp() is called before the test method is run, and tearDown() is called afterwards. I’m going to change the testing strategy to keep a little log of what methods are called. By always appending to the log, we will preserve the order in which the methods are called.\n\nWasRun\n\ndef setUp(self):\n\nself.wasRun= None self.wasSetUp= 1 self.log= \"setUp \"\n\nNow we can change testSetUp() to look at the log instead of the flag:\n\nTestCaseTest\n\ndef testSetUp(self): self.test.run() assert(\"setUp \" == self.test.log)\n\n103\n\n104\n\nCleaning Up After\n\nNow we can delete the wasSetUp flag. We can record the running of the test method, too: WasRun\n\ndef testMethod(self): self.wasRun= 1 self.log= self.log + \"testMethod \"\n\nThis breaks testSetUp, because the actual log contains “setUp testMethod ”. We change the expected value:\n\nTestCaseTest\n\ndef testSetUp(self): self.test.run() assert(\"setUp testMethod \" == self.test.log)\n\nNow this test is doing the work of both tests, so we can delete testRunning and rename testSetUp: TestCaseTest\n\ndef setUp(self):\n\nself.test= WasRun(\"testMethod\")\n\ndef testTemplateMethod(self):\n\nself.test.run() assert(\"setUp testMethod \" == self.test.log)\n\nUnfortunately, we are only using the instance if WasRun in one place, so we have to undo our clever setUp hack:\n\nTestCaseTest\n\ndef testTemplateMethod(self):\n\ntest= WasRun(\"testMethod\") test.run() assert(\"setUp testMethod \" == test.log)\n\n(Doing a refactoring based on a couple of early uses, then having to undo it soon after is fairly common. Some folks wait until they have three or four uses before refactoring because they don’t like undoing work. I prefer to spend my thinking cycles on design, so I just reflexively do the refactorings without worrying about whether I will have to undo them immediately afterward.)\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun\n\nNow we are ready to implement tearDown(). Got you! We are ready to test for tear- Down:\n\nTestCaseTest\n\ndef testTemplateMethod(self):\n\ntest= WasRun(\"testMethod\") test.run() assert(\"setUp testMethod tearDown \" == test.log)\n\nThis fails. Making it work is simple:\n\nTestCase\n\ndef run(self, result):\n\nresult.testStarted() self.setUp() exec \"self.\" + self.name + \"()\" self.tearDown()\n\nWasRun\n\ndef setUp(self):\n\nself.log= \"setUp \" def testMethod(self):\n\nself.log= self.log + \"testMethod \"\n\ndef tearDown(self):\n\nself.log= self.log + \"tearDown \"\n\nSurprisingly, we get an error, not in WasRun, but in the TestCaseTest. We don’t have a no-op implementation of tearDown() in TestCase:\n\nTestCase\n\ndef tearDown(self):\n\npass\n\nThis time we got value out of using the same testing framework we are developing. Yippee…\n\nNo refactoring necessary. The Obvious Implementation, after that one glitch, worked and was clean.\n\nNext we’ll go on to report the results of running a test explicitly, instead of letting Python’s native error handling and reporting system tell us when there is a problem with an assertion. Reviewing, in this chapter we:\n\n105\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun\n\n106\n\nCleaning Up After\n\nRestructured the testing strategy from flags to a log\n\nTested and implemented tearDown() using the new log\n\nFound a problem and, daringly, fixed it instead of backing up (was that a good idea?)\n\nCHAPTER 23\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun\n\nCounting\n\nI was going to implement making sure tearDown() is called regardless of excep- tions during the test method. However, we have to catch exceptions to make the test work (I know, I just tried it, and backed it out.) If we make a mistake implementing this, we won’t be able to see the mistake because the exceptions won’t be reported. In general, the order of implementing the tests is important. When I pick the next test to implement, I find a test that will teach me something but which I have confi- dence I can make work. If I get that test working but get stuck on the next one, I consider backing up two steps. It would be great if your programming environment helped me with this, checkpointing the code every time all the tests ran.\n\nWhat we would like to see is the results of running any number of tests—“5 run, 2 failed, TestCaseTest.testFooBar—ZeroDivideException, MoneyTest.testNega- tion—AssertionError”. Then if the tests stop getting called, or results stop getting reported, at least we have a chance of catching the error. Having the framework automatically report all the test cases it knows nothing about seems a bit far- fetched, at least for the first test case.\n\nWe’ll have TestCase.run() return a TestResult object that records the results of run- ning the test (singular for the moment, but we’ll get to that.)\n\nTestCaseTest\n\ndef testResult(self):\n\ntest= WasRun(\"testMethod\")\n\n107\n\n108\n\nCounting\n\nresult= test.run() assert(\"1 run, 0 failed\" == result.summary())\n\nWe’ll start with a fake implementation:\n\nTestResult\n\nclass TestResult:\n\ndef summary(self):\n\nreturn \"1 run, 0 failed\"\n\nand return a TestResult as the result of TestCase.run()\n\nTestCase\n\ndef run(self):\n\nself.setUp() exec \"self.\" + self.name + \"()\" self.tearDown() return TestResult()\n\nNow that the test runs, we can realize (as in “make real”) the implementation of summary() a little at a time. First, we can make the number of tests run a symbol constant:\n\nTestResult\n\ndef __init__(self):\n\nself.runCount= 1\n\ndef summary(self):\n\nreturn \"%d run, 0 failed\" % self.runCount\n\n(The % operator is Python’s sprintf.) However, runCount shouldn’t be a constant, it should be computed by counting the number of tests run. We can initialize it to 0, then increment it every time a test is run.\n\nTestResult\n\ndef __init__(self):\n\nself.runCount= 0 def testStarted(self):\n\nself.runCount= self.runCount + 1\n\ndef summary(self):\n\nreturn \"%d run, 0 failed\" % self.runCount\n\nWe have to actually call this groovy new method:",
      "page_number": 108
    },
    {
      "number": 13,
      "title": "Segment 13 (pages 123-134)",
      "start_page": 123,
      "end_page": 134,
      "detection_method": "topic_boundary",
      "content": "TestCase\n\ndef run(self):\n\nresult= TestResult() result.testStarted() self.setUp() exec \"self.\" + self.name + \"()\" self.tearDown() return result\n\nWe could turn the constant string “0” for the number of failed tests into a variable in the same way as we realized runCount. However, the tests don’t demand it. So, we write another test. TestCaseTest\n\ndef testFailedResult(self):\n\ntest= WasRun(\"testBrokenMethod\") result= test.run() assert(\"1 run, 1 failed\", result.summary)\n\nWhere:\n\nWasRun\n\ndef testBrokenMethod(self):\n\nraise Exception\n\nThe first thing we notice is that we aren’t catching the exception thrown by Was- Run.testBrokenMethod. We would like to catch the exception and make a note in the result that the test failed. We’ll put this test on the shelf for the moment.\n\nReviewing, we:\n\n(cid:127) Wrote a fake implementation, and gradually began making it real by replacing\n\nconstants with variables\n\n(cid:127) Wrote another test (cid:127) When that test failed, we wrote yet another test, at a smaller scale, to support\n\nmaking the failing test work\n\n109\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun Report failed tests\n\n110\n\nCounting\n\nCHAPTER 24\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun Report failed tests\n\nDealingwithFailure\n\nWe’ll write a smaller grained test to be sure that if we note a failed test, we print out the right results.\n\nTestCaseTest\n\ndef testFailedResultFormatting(self):\n\nresult= TestResult() result.testStarted() result.testFailed() assert(\"1 run, 1 failed\" == result.summary())\n\n“testStarted()” and “testFailed()” are the messages we expect to send to the result when a test starts and when a test fails, respectively. If we can get the summary to print correctly when these messages are sent in this order, then our programming problem is reduced to how to get these messages sent. Once they are sent, we expect the whole thing to work.\n\nThe implementation is to keep a count of failures:\n\nTestResult\n\ndef __init__(self):\n\nself.runCount= 0 self.errorCount= 0\n\ndef testFailed(self):\n\n111\n\n112\n\nDealing with Failure\n\nself.errorCount= self.errorCount + 1\n\nWith the count correct (which I suppose we could have tested for, if we were taking teensy, weensy, tiny steps, but I won’t bother, the coffee has kicked in now), we can print correctly: TestResult\n\ndef summary(self):\n\nreturn \"%d run, %d failed\" % (self.runCount, self.failureCount)\n\nNow we expect if we call testFailed() correctly, we will get the expected answer. When do we call it? When we catch an exception in the test method:\n\nTestCase\n\ndef run(self):\n\nresult= TestResult() result.testStarted() self.setUp() try:\n\nexec \"self.\" + self.name + \"()\"\n\nexcept:\n\nresult.testFailed()\n\nself.tearDown() return result\n\nThere is a subtlety hidden inside this method. The way it is written, if a disaster happens during setUp(), the exception won’t be caught. That can’t be what we mean—we want our tests to run independently of each other. However, we need another test before we can change the code (I taught Bethany, my oldest daughter, TDD as her first programming style around age 12. She thinks you can’t type in code unless there is a broken test. The rest of us have to muddle through reminding ourselves to write the tests.) That next test and its implementation are left as an exercise for the reader (sore fingers, again.)\n\nNext we will work on getting several tests to run together. Reviewing this chapter, we:\n\n(cid:127) Made our small scale test work\n\nReintroduced the larger scale test\n\n(cid:127) Made the larger test work quickly using the mechanism demonstrated by the\n\nsmaller test\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun Report failed tests Catch and report setUp errors\n\n(cid:127) Noticed a potential problem and noted it on the to do list instead of addressing it\n\nimmediately\n\n113\n\n114\n\nDealing with Failure\n\nCHAPTER 25\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun Report failed tests Catch and report setUp errors\n\nHowSuiteItIs\n\nWe can’t leave xUnit without visiting TestSuite. The end of our file, where we invoke all the tests, is looking pretty ratty:\n\nprint TestCaseTest(\"testTemplateMethod\").run().summary() print TestCaseTest(\"testResult\").run().summary() print TestCaseTest(\"testFailedResultFormatting\").run().summary() print TestCaseTest(\"testFailedResult\").run().summary()\n\nDuplication is always a bad thing, unless you look at it as motivation to find the missing design element. What we would like here is the ability to compose tests and run them together (working hard to make them run in isolation doesn’t do us much good if we only ever run one at a time). Another good reason to implement TestSuite is that it gives us a pure example of Composite—we want to be able to treat single tests and groups of tests exactly the same.\n\nWe would like to be able to create a TestSuite, add a few tests to it, then get collec- tive results from running it.\n\nTestCaseTest\n\ndef testSuite(self):\n\nsuite= TestSuite() suite.add(WasRun(\"testMethod\")) suite.add(WasRun(\"testBrokenMethod\"))\n\n115\n\n116\n\nHow Suite It Is\n\nresult= suite.run() assert(\"2 run, 1 failed\" == result.summary())\n\nImplementing the add() method just adds tests to a list:\n\nTestSuite\n\nclass TestSuite:\n\ndef __init__(self):\n\nself.tests= [] def add(self, test):\n\nself.tests.append(test)\n\n(Python note: “[]” creates an empty collection.) The run method is a bit of a prob- lem. We want a single TestResult to be used by all the tests that run. Therefore, we should write:\n\nTestSuite\n\ndef run(self):\n\nresult= TestResult() for test in tests:\n\ntest.run(result)\n\nreturn result\n\n(Python note: “for test in tests” iterates through the elements of “tests”, assigning each one to “test” and evaluating the following code.) However, one of the main constraints on Composite is that the collection has to respond to the same messages as the individual items. If we add a parameter to TestCase.run(), we have to add the same parameter to TestSuite.run(). I can think of three alternatives:\n\n(cid:127) Use Python’s default parameter mechanism. Unfortunately, the default value is evaluated at compile time, not run time, and we don’t want to be reusing the same TestResult\n\nSplit the method into two parts, one which allocates the TestResult and the other which runs the test given a TestResult. I can’t think of good names for the two parts of the method, which suggests that this isn’t a good strategy\n\n(cid:127) Allocate the TestResults in the caller\n\nWe will allocate the TestResults in the callers. This pattern is called Collecting Parameter.\n\nTestCaseTest\n\ndef testSuite(self):\n\nsuite= TestSuite() suite.add(WasRun(\"testMethod\")) suite.add(WasRun(\"testBrokenMethod\")) result= TestResult() suite.run(result) assert(\"2 run, 1 failed\" == result.summary())\n\nThis solution has the advantage that run() now has no explicit return:\n\nTestSuite\n\ndef run(self, result): for test in tests:\n\ntest.run(result)\n\nTestCase\n\ndef run(self, result):\n\nresult.testStarted() self.setUp() try:\n\nexec \"self.\" + self.name + \"()\"\n\nexcept:\n\nresult.testFailed()\n\nself.tearDown()\n\nNow we can clean up the invocation of the tests at the end of the file:\n\nsuite= TestSuite() suite.add(TestCaseTest(\"testTemplateMethod\")) suite.add(TestCaseTest(\"testResult\")) suite.add(TestCaseTest(\"testFailedResultFormatting\")) suite.add(TestCaseTest(\"testFailedResult\")) suite.add(TestCaseTest(\"testSuite\")) result= TestResult() suite.run(result) print result.summary()\n\nThere is substantial duplication here, which we could eliminate if we had a way of constructing a suite automatically given a test class.\n\n117\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun Report failed tests Catch and report setUp errors Create TestSuite from a\n\nTestCase class\n\n118\n\nHow Suite It Is\n\nHowever, first we have to fix the 4 failing tests (they use the old no-argument run interface):\n\nTestCaseTest\n\ndef testTemplateMethod(self):\n\ntest= WasRun(\"testMethod\") result= TestResult() test.run(result) assert(\"setUp testMethod tearDown \" == test.log)\n\ndef testResult(self):\n\ntest= WasRun(\"testMethod\") result= TestResult() test.run(result) assert(\"1 run, 0 failed\" == result.summary())\n\ndef testFailedResult(self):\n\ntest= WasRun(\"testBrokenMethod\") result= TestResult() test.run(result) assert(\"1 run, 1 failed\" == result.summary())\n\ndef testFailedResultFormatting(self):\n\nresult= TestResult() result.testStarted() result.testFailed() assert(\"1 run, 1 failed\" == result.summary())\n\nNotice that each test allocates a TestResult, exactly the problem solved by setUp(). We can simplify the tests (at the cost of making them a little more difficult to read), by creating the TestResult in setUp():\n\nTestCaseTest\n\ndef setUp(self):\n\nself.result= TestResult() def testTemplateMethod(self):\n\ntest= WasRun(\"testMethod\") test.run(self.result) assert(\"setUp testMethod tearDown \" == test.log)\n\ndef testResult(self):\n\ntest= WasRun(\"testMethod\") test.run(self.result) assert(\"1 run, 0 failed\" == self.result.summary())\n\ndef testFailedResult(self):\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun Report failed tests Catch and report setUp errors Create TestSuite from a\n\nTestCase class\n\ntest= WasRun(\"testBrokenMethod\") test.run(self.result) assert(\"1 run, 1 failed\" == self.result.summary())\n\ndef testFailedResultFormatting(self):\n\nself.result.testStarted() self.result.testFailed() assert(\"1 run, 1 failed\" == self.result.summary())\n\ndef testSuite(self):\n\nsuite= TestSuite() suite.add(WasRun(\"testMethod\")) suite.add(WasRun(\"testBrokenMethod\")) suite.run(self.result) assert(\"2 run, 1 failed\" == self.result.summary())\n\nAll those extra “self.”s are a bit ugly, but that’s Python. If it was an object language, the self would be assumed and references to global variables would require qualifi- cation. Instead, it is a scripting language with object support (excellent object sup- port, to be sure) added, so global reference is implied and referring to self is explicit.\n\nI will leave the rest of these items to you and your new-found TDD skills.\n\nReviewing, in this chapter we:\n\n(cid:127) Wrote a test for a TestSuite (cid:127) Wrote part of the implementation, but without making the test work. This was a violation of “da roolz”. If you spotted it at the time, take two test cases out of petty cash. I’m sure there is a simple fake implementation that would have made the test case work so we could refactor under the green bar, but I can’t think what it is at the moment.\n\nChanged the interface of the run method so the item and the composite of items could work identically, then finally got the test working\n\nFactored out the common set-up code\n\n119\n\n120\n\nHow Suite It Is",
      "page_number": 123
    },
    {
      "number": 14,
      "title": "Segment 14 (pages 135-142)",
      "start_page": 135,
      "end_page": 142,
      "detection_method": "topic_boundary",
      "content": "CHAPTER 26\n\nxUnitRetrospective\n\nIf the time comes for you to implement your own testing framework, the above sequence can serve as your guide. The details of the implementation are not nearly as important as the test cases. If you can support a set of test cases like the ones above, you can write tests that are isolated and composeable, and you will be on your way to being able to develop test-first.\n\nxUnit has been ported to more than 30 languages at this writing. Your language is likely to already have an implementation. There are a couple of reasons for imple- menting it yourself even if there is a version already available:\n\n(cid:127) Mastery—The spirit of xUnit is simplicity. Martin Fowler said, “Never in the\n\nannals of software engineering was so much owed by so many to so few lines of code.” Some of the implementations have gotten a little complicated for my taste. Rolling your own will give you a tool over which you have a feeling of mastery.\n\nExploration—When I’m faced with a new programming language, I implement xUnit. By the time I have the first 8-10 tests running, I have explored many of the facilities I will be using in daily programming\n\nWhen you begin using xUnit, you will discover a big difference between assertions that fail and other kinds of errors while running tests—assertion failures consis- tently take much longer to debug. Because of this, most implementations of xUnit\n\n121\n\n122\n\nxUnit Retrospective\n\ndistinguish between failures—meaning assertion failures—and errors. The GUIs present them differently, often with the errors on top.\n\nJUnit declares a simple Test interface that is implemented by both TestCase and TestSuite. If you want your tests to be runnable by JUnit tools, you can implement the Test interface, too.\n\npublic interface Test {\n\npublic abstract int countTestCases(); public abstract void run(TestResult result);\n\n}\n\nLanguages with optimistic (dynamic) typing don’t even have to declare their alle- giance to an interface, they can just implement the operations. If you write a test scripting language, Script can implement countTestCases() to return 1 and run to notify the TestResult on failure and you can run your scripts along with the ordi- nary TestCases.\n\nCHAPTER 27\n\nSectionIII:Patterns\n\nWhat follows are the “greatest hits” patterns for TDD. Some of the patterns are TDD tricks, some are design patterns, and some are refactorings.\n\nIf you are familiar with one of these topics, the patterns here will show you how the topics play with TDD. Otherwise, there is enough material here to get you through the book examples, and whet your appetite for the comprehensive treatments found elsewhere.\n\n123\n\n124\n\nSection III: Patterns\n\nCHAPTER 28\n\nTest-Driven DevelopmentPatterns\n\nThere are some basic strategic question we need to answer before we can talk about the details of how to test:\n\n(cid:127) What do we mean by testing? (cid:127) When do we test? (cid:127) How do we choose what logic to test? (cid:127) How do we choose what data to test?\n\nTest n.\n\nHow do you test your software? Write an automated test.\n\nTest is a verb meaning to evaluate. No programmers release even the tiniest change without testing, except the very confident and the very sloppy. I’ll assume that if you’ve gotten this far, your’re neither. While you may test your changes, testing changes is not the same as having tests. Test is also a noun, a procedure leading to acceptance or rejection. Why does “test” the noun, a procedure that runs automati- cally, feel different than “test” the verb, such as poking a few buttons and looking at answers on the screen?\n\n(What follows in an influence diagram, a la Gerry Weinberg’s Quality Software Management. An arrow between nodes means an increase in the first node implies\n\n125\n\n126\n\nTest-Driven Development Patterns\n\nan increase in the second. An arrow with a circle means an increase in the first node implies a decrease in the second.)\n\nWhat happens when the stress level rises?\n\nFigure 1 has Stress negatively connected to Testing negatively connected to Errors positively connected to Stress.\n\nThis is a positive feedback loop. The more stress you feel, the less testing you will do. The less testing you do, the more errors you will make. The more errors you make, the more stress you feel. Rinse and repeat.\n\nHow do you get out of such a loop? Either introduce a new element, replace one of the elements, or change the arrows. In this case we’ll replace “testing” with “auto- mated testing”.\n\nFigure 2 has Stress positively connected to Automated Testing negatively con- nected to Errors and Stress, and Errors positively connected to Stress.\n\n“Did I just break something else with that change?” With automated tests, when I start to feel stress I run the tests. Tests are the Programmer’s Stone, transmuting fear into boredom. “No, the tests are all still green.” The more stress I feel, the more I run the tests. Running the tests immediately gives me a good feeling, and reduces the number of errors I make, which further reduces the stress I feel.\n\n“We don’t have time to run the tests. Just release it!” The second picture isn’t guar- anteed. If the stress level rises high enough, it breaks down. However, with the automated tests you have a chance to choose your level of fear.\n\nShould you run the test after you write it, even though you know it’s going to fail? No, don’t bother. For example, I was working with a couple of very sharp younger programmers on implementing in-memory transactions (a very cool technique every programming language should have). How were we going to implement roll- back if we started a transaction, changed a few variables, then let the transaction be garbage collected? Simple enough to test, youngsters. Stand back and watch the master at work. Here is the test. Now how are we going to implement this?\n\nTwo hours later, hours marred with frustration because a mistake implementing such low-level features generally crashes the development environment, we rolled back to where we had started. Wrote the test. Ran it on a whim. It passed. Duh… The whole point of the transaction mechanism was that variables weren’t really\n\nchanged until the transaction was committed. Okay, I suppose you could go ahead and run that new test if you want to.\n\nIsolated Test\n\nHow should the running of tests affect each other? Not at all.\n\nWhen I was a young programmer, long long ago when we had to dig our own bits out of the snow and carry heavy buckets of them bare-footed back to our cubicles leaving bloody little footprints for the wolves to follow… Sorry, just reminiscing. My first experience of automated tests was having a set of long-running, overnight, GUI-based tests (you know, record the keystrokes and mouse events and play them back) for a debugger I was working on (hi Jothy, hi John!). Every morning when I came in there would be a neat stack of paper on my chair describing last night’s test runs (hi Al!). On good days there would be a single sheet summarizing that nothing broke. On bad days there would be many many sheets, one for each broken test. I began to dread days when I saw a pile of paper on my chair.\n\nI took two lessons from this experience. First, make the tests so fast to run that I can run them myself, and run them often. That way I can catch errors before anyone else sees them, and I don’t have to dread coming in in the morning. Second, I noticed after a while that a huge stack of paper didn’t usually mean a huge list of problems. More often it meant that one test had broken early, leaving the system in an unpredictable state for the next test.\n\nWe tried to get around this problem by starting and stopping the system between each test, but it took too long, which taught me another lesson about seeking tests at a smaller scale than the whole application. But the main lesson I took was that tests should be able to ignore each other completely. If I had one test broken, I wanted one problem. If I had two tests broken, I wanted two problems.\n\nOne convenient implication of isolated tests is that the tests are order independent. If I want to grab a subset of tests and run them, I can do so without worrying that a test will break now because a prerequisite test is gone.\n\nPerformance is the usual reason cited for having tests share data. A second implica- tion of isolated tests is that you have to work, sometimes work hard, to break your problem into little orthogonal dimensions, so setting up the environment for each test is easy and quick. Isolating tests encourages you to compose solutions out of many highly cohesive, loosely coupled objects. I always heard this was a good idea,\n\n127\n\n128\n\nTest-Driven Development Patterns\n\nand I was happy when I achieved it, but I never knew exactly how to regularly achieve high cohesion and loose coupling until I started writing isolated tests.\n\nTest List\n\nWhat should you test? Before you begin, write a list of all the tests you know you will have to write.\n\nThe first part of our strategy for dealing with programming stress is to never take a step forward unless we know where our foot is going to land. When we sit down to a programming session, what is it we intend to accomplish?\n\nOne strategy for keeping track of what we’re trying to accomplish is to hold it all in our heads. I tried this for several years, and found I got into a positive feedback loop. The more experience I accumulated, the more things I knew that might need to be done. The more things I knew might need to be done, the less attention I had for what I was doing. The less attention I had for what I was doing, the less I accomplished. The less I accomplished, the more things I knew that needed to be done.\n\nJust ignoring random items on the list and programming at whim did not appear to work to break this cycle.\n\nI got in the habit of writing down everything I wanted to accomplish over the next few hours on a slip of paper next to my computer. I had a similar list, but with weekly or monthly scope pinned on the wall. As soon as I had all that written down, I knew I wasn’t going to forget something. When a new item came up, I would quickly and consciously decide whether it belonged on the “now” list, the “later” list, or it didn’t really need to be done at all.\n\nApplied to test-driven development, what we put on the list are the tests we want to implement.First, put on the list examples of every operation that you know you need to implement. Next, for those operations that don’t already exist, put the null version of that operation on the list. Finally, list all the refactorings that you think you will have to do to have clean code at the end of this session.\n\nInstead of outlining the tests, we could just go ahead and implement them all. There are a couple of reasons writing tests en masse hasn’t worked for me. First, every test you implement is a bit of inertia when you have to refactor. With automated refactoring tools (e.g. you have a menu item that renames the declaration and all uses of a variable) this is less of a problem, but when you’ve implemented ten tests",
      "page_number": 135
    },
    {
      "number": 15,
      "title": "Segment 15 (pages 143-150)",
      "start_page": 143,
      "end_page": 150,
      "detection_method": "topic_boundary",
      "content": "and then you discover the arguments need to be in the opposite order, you are just that much less likely to go clean up. Second, if you have ten tests broken, you are a long way from the green bar. If you want to get to green quickly, you have to throw all ten tests away. If you want to get all the tests working, you are going to be star- ing at a red bar for a long time. If you are sufficiently addicted to the green bar you can’t go to the bathroom if the bar is red, that can be an eternity.\n\nConservative mountain climbers have a rule that of your four hands and feet, three of them must be attached at any one time. Dynamic moves where you let go of two at once are much more dangerous. The pure form of TDD, where you are never more than one change away from a green bar, is like that three out of four rule.\n\nAs you make the tests run, the implementation will imply new tests. Write the new tests down on the list. Likewise with refactorings. “This is getting ugly.” “<sigh> Put it on the list. We’ll get to it before we check in.”\n\nItems that are left on the list when the session is done need to be taken care of. If you are really half way through a piece of functionality, use the same list later. If you have discovered larger refactorings that are out of scope for the moment, move them to the “later” list. I can’t recall ever moving a test case to the “later” list. If I can think of a test that might not work, getting it to work is more important than releasing my code.\n\nTest First\n\nWhen should you write your tests? Before you write the code that is to be tested.\n\nYou won’t test after. Your goal as a programmer is running functionality. However, you need a way to think about design, you need a method for scope control.\n\nLet’s look at the usual influence diagram relating stress and testing (but not stress testing, that’s different):\n\nStress above negatively connected to testing below negatively connected to stress.\n\nThe more stress you feel, the less likely you are to test enough. When you know you haven’t tested enough, you add to your stress. Positive feedback loop. Once again, there needs to be a way to break the loop.\n\nWhat if we adopted the rule that we would always test first. Then we can invert the diagram and get a virtuous cycle:\n\n129\n\n130\n\nTest-Driven Development Patterns\n\nTest-first above negatively connected to stress below negatively connected to test- First..\n\nWhen we test first, we reduce the stress, which makes us more likely to test. There are lots of other elements feeding into stress, however, so the tests must live in other virtuous cycles or they will be abandoned when stress increases enough. However, the immediate payoff for testing—a design and scope control tool—sug- gests that we will be able to start doing it, and keep doing it even under moderate stress.\n\nAssert First\n\nWhen should you write the asserts? Try writing them first.\n\nDon’t you just love self-similarity?\n\n(cid:127) Where should you start building a system? With stories you want to be able to\n\ntell about the finished system.\n\n(cid:127) Where should you start writing a bit of functionality? With the tests you want to\n\npass with the finished code.\n\n(cid:127) Where should you start writing a test? With the asserts that will pass when it is\n\ndone.\n\nJim Newkirk introduced me to this technique. When I test assert-first I find it has a powerful simplifying effect. When you are writing a test, you are solving several problems at once, even if you no longer have to think about the implementation.\n\n(cid:127) Where does the functionality belong? Is it a modification of an existing method, a new method on an existing class, an existing method name implemented in a new place, or a new class?\n\n(cid:127) What should the names be called? (cid:127) How are you going to check for the right answer? (cid:127) What is the right answer? (cid:127) What other tests does this test suggest?\n\nPea-sized brains like mine can’t possibly do a good job of solving all these prob- lems at once. The two problems from the list that can be easily separated from the rest are \"what is the right answer?\" and \"how am I going to check?\"\n\nHere’s an example. Suppose we want to communicate with another system over a socket. When we’re done, the socket should be closed and we should have read the string \"abc\".\n\ntestCompleteTransaction() {\n\n... assertTrue(reader.isClosed()); assertEquals(\"abc\", reply.contents());\n\n}\n\nWhere does the reply come from? The socket, of course:\n\ntestCompleteTransaction() {\n\n... Buffer reply= reader.contents(); assertTrue(reader.isClosed()); assertEquals(\"abc\", reply.contents());\n\n}\n\nAnd the socket? We create it by connecting to a server:\n\ntestCompleteTransaction() {\n\n... Socket reader= Socket(\"localhost\", defaultPort()); Buffer reply= reader.contents(); assertTrue(reader.isClosed()); assertEquals(\"abc\", reply.contents());\n\n}\n\nBut before this, we need to open a server:\n\ntestCompleteTransaction() {\n\nServer writer= Server(defaultPort(), \"abc\"); Socket reader= Socket(\"localhost\", defaultPort()); Buffer reply= reader.contents(); assertTrue(reader.isClosed()); assertEquals(\"abc\", reply.contents());\n\n}\n\nNow we may have to adjust the names based on actual usage, but we have created the outlines of the test in teensy tiny steps, informing each decision with feedback within seconds.\n\n131\n\n132\n\nTest-Driven Development Patterns\n\nTest Data\n\nWhat data do you use for test-first tests? Use data that makes the tests easy to read and follow.\n\nYou are writing tests to an audience. Don’t scatter data values around just to be scattering data values around. If there is a difference in the data, it should be mean- ingful. If there isn’t a conceptual difference between 1 and 2, use 1.\n\nTest Data isn’t a license to stop short of full confidence. If your system has to han- dle multiple inputs, your tests should reflect multiple inputs. However, don’t have a list of 10 items as the input data if a list of 3 items will lead you to the same design and implementation decisions.\n\nOne trick in Test Data is to try to never use the same constant to mean more than one thing. If I am testing a plus() method, it is tempting to test 2 + 2, since that is the classic example of addition, or 1 + 1, since that is so simple. What if we got the arguments reversed in the implementation? (Okay, okay, that doesn’t matter in the case of plus(), but you get the idea.) If we use 2 for the first argument we should use 3, for example, for the second. (“3 + 4” was a watershed test case when bringing up a new Smalltalk virtual machine back in the olden days.)\n\nThe alternative to Test Data is Realistic Data, where you use data from the real world. Realistic Data is useful when:\n\n(cid:127) You are testing real-time systems using traces of external events gathered from\n\nthe actual execution\n\n(cid:127) You are matching the output of the current system with the output of a previous\n\nsystem (Parallel Testing)\n\n(cid:127) You are refactoring a simulation and expect precisely the same answers when you are finished, particularly if floating point accuracy may be a problem\n\nEvident Data\n\nHow do you represent the intent of the data? Include expected and actual results in the test itself, and try to make their relationship apparent.\n\nYou are writing tests for a reader, not just the computer. Someone in decades to come will be asking themselves the question, \"What in the heck was this joker\n\nthinking about?\" You’d like to leave as many clues as possible, especially if that frustrated reader is going to be you.\n\nHere’s an example. If we convert from one currency to another, we take a 1.5% commission on the transaction. If the exchange rate from USD to GBP is 2:1, then if we exchange $100, we should get 50 GBP - 1.5% = 49.25 GBP. We could write this test like this:\n\nBank bank= new Bank(). bank.addRate(\"USD\", \"GBP\", STANDARD_RATE); bank.commission(STANDARD_COMMISSION); Money result= bank.convert(new Note(100, \"USD\"), \"GBP\"); assertEquals(new Note(49.25, \"GBP\"), result);\n\nor we could try to make the calculation obvious:\n\nBank bank= new Bank(); bank.addRate(\"USD\", \"GBP\", 2); bank.commission(0.015); Money result= bank.convert(new Note(100, \"USD\"), \"GBP\"); assertEquals(new Note(100 / 2 * (1 - 0.015), \"GBP\"), result);\n\nI can read this test and see the connection between the numbers used in the input and the numbers used to calculate the expected result.\n\nOne beneficial side effect of Evident Data is that it makes programming easier. Once we’ve written the expression in the assertion, we know what we need to pro- gram. Somehow we have to get the program to evaluate a division and a multiplica- tion. We can even use Fake It to discover where the operations belong incrementally.\n\nEvident Data seems to be an exception to the rule that you don’t want magic num- bers in your code. Within the scope of a single method, the relationship between the 5’s is obvious. If I had symbolic constants that were already defined, though, I would use the symbolic form.\n\nFurther Study\n\nBob Binder, Testing Object-Oriented Systems: Models, Patterns, and Tools, Addi- son-Wesley, 1999, ISBN 0201809389 is the comprehensive reference on testing.\n\n133\n\n134\n\nTest-Driven Development Patterns\n\nBrian Marick, Craft of Software Testing: Subsystems Testing Including Object- Based and Object-Oriented Testing, Prentice-Hall, 1997, ISBN 0131774115 is a more pragmatic look at testing.\n\n???others???\n\nCHAPTER 29\n\nRedBarPatterns\n\nThese patterns are about when you write tests, where you write tests, and when you stop writing tests.\n\nOne Step Test\n\nWhich test should you pick next from the list? Pick a test that will teach you some- thing and that you are confident you can implement.\n\nEach test should represent one step towards your overall goal. If we are looking at the following Test List, which test should we pick next?\n\n135\n\n136\n\nRed Bar Patterns\n\nPlus Minus Times Divide Plus like Equals Equals null Null exchange Exchange one currency Exchange two currencies Cross rate\n\nThere is no right answer. What is one step for me, never having implemented these objects before, will be one tenth of a step to you, with your vast experience.\n\nWhen I look at a Test List, I think, “That’s obvious, that’s obvious, I have no idea, obvious, what was I thinking about with that one, ah, this one I can do.” That last test is the test I implement next. It didn’t strike me as obvious, but I’m also confi- dent I can make it work.\n\nIf you don’t find any test on the list that represents one step, add some new tests that would represent progress towards the items there.\n\nA program grown from tests like this can appear to be written top-down, because you can begin with a test that represents a simple case of the entire computation. A program grown from tests can also appear to be written bottom-up, because you start with small pieces and aggregate them larger and larger.\n\nNeither top-down nor bottom-up really describes the process helpfully. First, a ver- tical metaphor is a simplistic visualization of how programs change over time. “Growth” implies a kind of self-similar feedback loop where the environment affects the program and the program affects the environment. Second, if we have to have a direction in our metaphor, “known-to-unknown” is a helpful description. Known-to-unknown implies that we have some knowledge and experience on which to draw, and that we expect to learn in the course of development. Put these two together and we have programs growing from known to unknown.\n\nStarter Test\n\nWhich test should you start with? Start by testing a variant of an operation that doesn’t do anything.",
      "page_number": 143
    },
    {
      "number": 16,
      "title": "Segment 16 (pages 151-158)",
      "start_page": 151,
      "end_page": 158,
      "detection_method": "topic_boundary",
      "content": "The first question you have to ask with a new operation is \"Where does it belong?\" Until you’ve answered this question, you don’t know what to type for the test. In the spirit of solving one problem at a time, how can we answer just this question and no other?\n\nIf you write a “realistic” test first, you will find yourself solving a bunch of prob- lems at once:\n\n(cid:127) Where does the operation belong? (cid:127) What are the correct inputs? (cid:127) What is the correct output given those inputs?\n\nBeginning with a realistic test will leave you too long without feedback. Red/green/ refactor, red/green/refactor. You want that loop to be minutes.\n\nYou can shorten the loop by choosing inputs and outputs that are trivially easy to discover. For example, a poster on the Extreme Programming newsgroup asked about how to write a polygon reducer test-first. The input is a mesh of polygons and the output is a mesh of polygons that describes precisely the same surface, but with the fewest possible polygons. “How can I test-drive this problem since getting a test to work requires reading Ph.D. theses?”\n\nStarter Test provides an answer:\n\nThe output should be the same as the input. Some configurations of polygons are already normalized, incapable of further reduction.\n\nThe input should be as small as possible, like a single polygon, or even an empty list of polygons.\n\nMy Starter Test looked like this:\n\nReducer r= new Reducer(new Polygon()); assertEquals(0, reducer.result().npoints);\n\nBing! First test is running. Now for all the rest of the tests on the list...\n\nOne Step Test applies. Pick a Starter Test that will teach you something but that you are certain you can get working quickly. If you are implementing something for the Nth time, pick a test that will require an operation or two. You will be justi- fiably confident you can get it working. If you are implementing something hairy and complicated for the first time, you need a little courage pill immediately.\n\n137\n\n138\n\nRed Bar Patterns\n\nI find that my Starter Test is often at a higher level, more like an application test, than the following tests. One example I often test-drive is a simple socket-based server. The first test looks like this:\n\nStartServer Socket= new Socket Message= “hello” Socket.write(message) AssertEquals(message, socket.read)\n\nThe rest of the tests are written in the server alone, “assuming we receive a string like this…”\n\nAnother Starter Test came from the game of Life. The folks discussing it were talk- ing about tests for cells, and sizes, and two dimensional arrays vs. hash tables with points as keys. My Starter Test looked like this:\n\nExplanation Test\n\nHow do you spread the use of automated testing? Ask for and give explanations in terms of tests.\n\nIt can be frustrating to be the only TDD on a team. Soon, you will notice fewer inte- gration problems and defect reports in tested code, and the designs will be simpler and easier to explain. It has even happened before that folks get downright enthusi- astic about testing, and testing first.\n\nBeware the enthusiasm of the newly converted. Nothing will stop the spread of TDD faster than pushing it in people’s faces. If you’re a manager or leader, you can’t force anyone to change the way they work.\n\nWhat can you do? A simple start is to start asking for explanations in terms of test cases. “Let me see if I understand what you’re saying. For example, if I have a Foo like this and a Bar like that then the answer should be 76?” A companion technique is to start giving explanations in terms of tests. “Here’s how it works now. When I have a Foo like this and a Bar like that, the answer is 76. If I have a Foo like that and a Bar like this, though, I would like the answer to be 67.”\n\nYou can do this at higher levels of abstraction. If someone is explaining a sequence diagram to you, you can ask for permission to convert it to a more familiar notation.\n\nThen you type in a test case that contains all the externally visible objects and mes- sages in the diagram.\n\nLearning Test1\n\nWhen do you write tests for externally produced software? Before the first time you are going to use a new facility in the package.\n\nLet’s say we are going to develop something on top of the Mobile Information Device Profile library for Java. We want to store some data in the RecordStore and retrieve it. Do we just write the code and expect it to work? That’s one way to develop.\n\nAn alternative is to notice that we are about to use a new method of a new class. Instead of just using it, we write a little test that verifies that the API works as expected. So, we might write:\n\nRecordStore store;\n\npublic void setUp() {\n\nstore= RecordStore.openRecordStore(\"testing\", true);\n\n}\n\npublic void tearDown() {\n\nRecordStore.deleteRecordStore(\"testing\");\n\n}\n\npublic void testStore() {\n\nint id= store.addRecord(new byte[] {5, 6}, 0, 2); assertEquals(2, store.getRecordSize(id)); byte[] buffer= new byte[2]; assertEquals(2, store.getRecord(id, buffer, 0)); assertEquals(5, buffer[0]); assertEquals(6, buffer[1]);\n\n}\n\nIf our understanding of the API is correct, the test will pass first time.\n\n1. Thanks to Jim Newkirk and Laurent Bossavit for independently sug- gesting this pattern.\n\n139\n\n140\n\nRed Bar Patterns\n\nJim Newkirk reported on a project in which Learning Tests were routinely written. When new releases of the package arrived, first the tests were run (and fixed, if nec- essary.) If the tests didn’t run, there was no sense running the application because it certainly wouldn’t run. Once the tests ran, the application ran every time.\n\nAnother Test\n\nHow do you keep a technical discussion from straying off topic? When a tangential idea arises, add a test to the list and go back to the topic.\n\nI love wandering discussions (you’ve read most of the book now, so you’ve proba- bly reached that conclusion yourself). Keeping a conversation strictly on course is a great way to stifle brilliant ideas. You hop from here to there to there, and how did we get here? Who cares, this is cool!\n\nSometimes programming relies on breakthroughs. Most programming, though, is a bit more pedestrian. I have ten things to implement. I become an accomplished pro- crastinator about item number four. Retreating to hummingbird conversation is one of my ways of avoiding work (and maybe the fear that goes along with it.)\n\nWhole unproductive days have taught me that at times it’s best to stay on track. When I’m feeling this way, new ideas are greeted with respect, but not allowed to divert my attention. I write them down on the list, and get back to what I was work- ing on.\n\nRegression Test\n\nWhat’s the first thing you do when a defect is reported? Write the smallest possible test that fails, and that once it runs, the defect will be repaired.\n\nRegression tests are tests that, with perfect foreknowledge, you would have written when coding originally. Every time you have to write a regression test, think about how you could have known to write the test in the first place.\n\nYou will also gain value by testing at the level of the whole application. Regression tests for the application give your users a chance to speak concretely to you about what is wrong and what they expect. Regression tests at the smaller scale are a way for you to improve your testing. The defect report will be about a bizarre large neg- ative number in a report. The lesson for you is that you need to test for integer roll- over when you are writing your test list.\n\nYou may have to refactor the system before you can easily isolate the defect. The defect in this case was your system’s way of telling you, “You aren’t quite done designing me yet.”\n\nBreak\n\nWhat do you do when you feel tired or stuck? Take a break.\n\nTake a drink, take a walk, take a nap. Wash your hands clean of your emotional commitment to the decisions you just made and the characters you typed.\n\nOften, this amount of distance is all it will take to break loose the idea you’ve been lacking. You’ll just be standing up when you realize, “I haven’t tried it with the parameters reversed!” Take the break anyway. Give yourself a couple of minutes. The idea won’t go away.\n\nIf you don’t get “the idea”, review your goals for the session. Are they still realistic or should you pick new goals? Is what you were trying to accomplish impossible? If so, what are the implications for the team?\n\nDave Ungar calls this his Shower Methodology. If you know what to type, type. If you don’t know what to type, take a shower. Many teams would be happier, more productive, and smell a whole lot better if they took his advice.\n\nTDD is a refinement on the Ungar Shower Methodology. If you don’t know what to type, fake it. If the “right” design still isn’t clear, triangulate. If you still don’t know what to type, then you can take that shower.\n\nHere is an influence diagram that shows the positive feedback loop at work:\n\nFatigue negatively affects judgement which negatively affects fatigue\n\nYou’re getting tired, so you’re less capable of realizing that you’re tired, so you keep going and get more tired.\n\nThe way out of this loop is to introduce an additional outside element.\n\n(cid:127) At the scale of hours, keep a water bottle by your keyboard so biology provides\n\nthe motivation for regular breaks.\n\n(cid:127) At the scale of a day, commitments after regular work hours can help you stop\n\nwhen you need sleep before progress.\n\n141\n\n142\n\nRed Bar Patterns\n\n(cid:127) At the scale of a week, weekend commitments help get your conscious, energy-\n\nsucking thoughts off work. (My wife swears I get my best ideas Friday evening.)\n\n(cid:127) At the scale of a year, mandatory vacation policies help you refresh yourself\n\ncompletely. The French do this right—two contiguous weeks of vacation aren’t enough. You spend the first week decompressing, and the second week getting ready to go back to work. Therefore three weeks, or better four, are necessary for you to be your most effective the rest of the year.\n\nThere is a flip side to taking breaks. Sometimes when faced with a tough problem what you need to do is press on, push through it. However, programming culture is so infected with macho, “I’ll ruin my health, alienate my family, and kill myself if necessary,” spirit that I don’t feel compelled to give any advice along these lines. If you find yourself caffeine-addicted and making no progress whatsoever, perhaps you shouldn’t take quite so many breaks. In the meantime, take a walk.\n\nDo Over\n\nWhat do you do when you are feeling lost? Throw away the code and start over.\n\nYou’re lost. You’ve taken the break, rinsed your hands in the brook, sounded the Tibetan temple bell, and still you’re lost. The code that was going so well an hour ago is now a mess, you can’t think of how to get the next test case working, and you’ve thought of 20 more tests that you really should implement.\n\nThis has happened to me several times in writing this book. I would get the code a bit twisted. “But I have to finish the book. The children are starving and the bill col- lectors are pounding on the door.” My gut reaction would be to untwist it just enough to move on. After a pause for reflection, starting over always made more sense. The one time I pressed on regardless, I had to throw away 25 pages of manu- script because it was based on an obviously stupid programming decision.\n\nMy favorite example of Do Over is a story Tim Mackinnon told me. He was inter- viewing someone by the simple expedient of asking her to pair program with him for an hour. At the end of the session, they’d implemented several new test cases and done some nice refactoring. It was the end of the day, though, and they felt tired when they were done, so they discarded their work.\n\nIf you pair program, switching partners is a good way to motivate productive Do Overs. You’ll try to explain the complicated mess you made for a few minutes\n\nwhen your new partner, completely uninvested in the mistakes you’ve made, will gently take the keyboard and say, “I’m terribly sorry for being so dense, but what if we started like this…”\n\nCheap Desk, Nice Chair\n\nWhat physical setup should you use for test-driven development? Get a really nice chair, skimping on the rest of the furniture if necessary.\n\nYou can’t program well if your back hurts. Yet, organizations that will spend a hun- dred thousand dollars a month on a team won’t spend ten thousand dollars on decent chairs.\n\nMy solution is to use cheap, ugly folding tables for my computers, but buy the best chairs I can find. I have plenty of desk space, and I can easily get more, and I am fresh and ready for programming in the afternoon and the morning.\n\nGet comfortable when you’re pair programming. Clean off the desk surface enough that you can slide the keyboard back and forth. Each partner should be able to sit comfortably directly in front of the keyboard when they are driving. One of my favorite coaching tricks is to come up behind a pair that is hacking away and gently slide the keyboard so it is comfortably placed for the person typing.\n\nManfred Lange points out that careful resource allocation also applies to computer hardware. Get cheap/slow/old machines for individual email and surfing, and the hottest possible machines for shared development.\n\nFurther Study\n\nTom DeMarco and Tim Lister, Peopleware, Dorset House, 1999, ISBN 0932633439 is an excellent introduction to the people side of computing.\n\nConstantine, Peopleware Paper\n\nWeinberg, Psychology of Computer Programming,\n\n143\n\n144\n\nRed Bar Patterns",
      "page_number": 151
    },
    {
      "number": 17,
      "title": "Segment 17 (pages 159-166)",
      "start_page": 159,
      "end_page": 166,
      "detection_method": "topic_boundary",
      "content": "CHAPTER 30\n\nTestingPatterns\n\nChild Test\n\nHow do you get a test case running that turns out to be too big? Write a smaller test case that represents the broken part of the bigger test case. Get the smaller test case running. Reintroduce the larger test case.\n\nThe red/green/refactor rhythm is so important for continuous success that when you are at risk of losing it, it is worth extra effort to maintain it. This commonly hap- pens to me when I write a test that accidentally requires several changes to make work. Even ten minutes with a red bar gives me the willies.\n\nWhen I write a test that is too big, I first try to learn the lesson. Why was it too big? What could I have done differently that would have made it smaller? How am I feeling right now?\n\nMetaphysical navel gazing accomplished, I delete the offending test and start over. “Well, getting these three things working at once was too much. If I had A, B, and C working, though, getting the whole thing working would be a cinch.” Sometimes I really delete the test, sometimes I just change the name to begin with an “x” so it won’t be run. (Can I tell you a secret? Sometimes I don’t even bother to delete the offending test. Shhhhh… I live with two, count ‘em two, broken tests for a matter of a couple of minutes while I get the child test working. I could be making a mis-\n\n145\n\n146\n\nTesting Patterns\n\ntake when I do this. Two broken tests could easily be a holdover from my bad old test-last-if-ever days.)\n\nTry it both ways yourself. See if you feel different, program different, when you have two tests broken. Respond as appropriate.\n\nMock Object\n\nHow do you test an object that relies on an expensive or complicated resource? Cre- ate a fake version of the resource that answers constants.\n\nThere is at least a book’s worth of material in Mock Object1, but this will serve as an introduction.\n\nThe classic example is a database. Databases take a long time to start, they are dif- ficult to keep clean, and if they are located on a remote server, they tie your tests to a physical location on a network. The database is also a fertile source of error in development.\n\nThe solution is not to use a real database most of the time. Most tests are written in terms of an object that acts like a database, but is really just sitting in memory.\n\npublic void testOrderLookup() {\n\nDatabase db= new MockDatabase(); db.expectQuery(\"select order_no from Order where cust_no is\n\n123\");\n\ndb.returnResult(new String[] {\"Order 2\" ,\"Order 3\"}); …\n\n}\n\nIf the MockDatabase does not get the query it expects, it throws an exception. If the query is correct, it returns something that looks like a result set constructed from the constant strings.\n\nAnother value of mocks, aside from performance and reliability, is readability. You can read the test above from one end to another. If you have a test database full of realistic data, when you see that a query should have resulted in 14 replies, you have no idea why 14 is the right answer.\n\n1. For example, see www.mockobjects.com.\n\nIf you want to use Mock Objects, you can’t easily store expensive resources in glo- bal variables (even if they masquerade as Singletons). If you do, you will have to set the global to a Mock Object, run the test, and be sure to reset the global when you are done\n\nThere have been times when I was furious at this restriction. Massimo Arnoldi and I were working on some code relying on a set of exchange rates stored in a global variable. Each test needed different subsets of the data, and sometimes they needed different exchange rates. After a while of trying to get the global variable to work, we decided one morning (courageous design decisions come more often in the morning for me) to just pass the Exchange around wherever we needed it. We thought we would have to modify hundreds of methods. In the end, we added a parameter to ten or fifteen methods, and cleaned up other aspects of the design along the way.\n\nMocks will encourage you down the path of carefully considering the visibility of every object, reducing the coupling in your designs.\n\nMock Objects add a risk to the project—what if the mock doesn’t behave like the real object? You can reduce this strategy by having a set of tests for the mock that can also be applied to the real object when it becomes available.\n\nSelf Shunt\n\nHow do you test that one object communicates correctly with another? Have the object under test communicate with the test case instead of with the object it expects.\n\nSuppose we wanted to dynamically update the green bar on the testing user inter- face. If we could connect an object to the TestResult, it could be notified when a test ran, when it failed, when a whole suite started and finished, and so on. When- ever we were notified that a test ran, we would update the interface. Here’s a test for this:\n\nResultListenerTest\n\ndef testNotification(self): result= TestResult() listener= ResultListener() result.addListener(listener) WasRun(\"testMethod\").run(result) assert 1 == listener.count\n\n147\n\n148\n\nTesting Patterns\n\nThe test needs an object to count the number of notifications:\n\nResultListener\n\nclass ResultListener: def __init__(self): self.count= 0 def startTest(self):\n\nself.count= self.count + 1\n\nBut wait. Why do we need a separate object for the listener? We can just use the test case itself. The TestCase itself becomes a kind of Mock Object.\n\nResultListenerTest\n\ndef testNotification(self):\n\nself.count= 0 result= TestResult() result.addListener(self) WasRun(\"testMethod\").run(result) assert 1 == self.count\n\ndef startTest(self):\n\nself.count= self.count + 1\n\nTests written with Self Shunt tend to read better than tests written without. The test above is a good example. The count was 0, and then it was 1. How did it get to be 1? Someone must have called startTest(). How did startTest() get called? It must happen when running the test. This is another example of symmetry—the second version of the test method has the two values for count in one place, where in the first version the count is set to 0 in one class and expected to be 1 in another.\n\nSelf Shunt may require that you use Extract Interface to get an interface to imple- ment. You will have to decide whether extracting the interface is easier or if testing the existing class as a black box is easier. I have noticed, though, that interfaces extracted for shunts tend to get their third and subsequent implementations soon thereafter.\n\nAs a result of using Self Shunt, you will see tests in Java implementing all sorts of bizarre interfaces. In optimistically typed languages, the test case class need only implement those operations that are actually used in the running of the test. In Java, however, you have to implement all the operations of the interface, even if most of the implementations are empty, so you would like interfaces to be as narrow as pos- sible. The implementations should either return a reasonable value or throw an\n\nexception, depending on whether you want to be notified if an unexpected opera- tion is invoked.\n\nLog String\n\nHow do you test that the sequence in which messages are called is correct? Keep a log in a string, and append to the string when a message is called.\n\nThe example from xUnit serves. We have a Template Method which we expect to call setUp(), a testing method, and tearDown(), in that order. By implementing the methods to record in a string that they were called, the test reads nicely:\n\ndef testTemplateMethod(self):\n\ntest= WasRun(\"testMethod\") result= TestResult() test.run(result) assert(\"setUp testMethod tearDown \" == test.log)\n\nAnd the implementation is simple, too:\n\nWasRun\n\ndef setUp(self):\n\nself.log= \"setUp \" def testMethod(self):\n\nself.log= self.log + \"testMethod \"\n\ndef tearDown(self):\n\nself.log= self.log + \"tearDown \"\n\nLog Strings are particularly useful when you are implementing Observer and you expect notifications to come in a certain order. If you expected certain notifications but you didn’t care about the order, you could keep a set of strings, and use set comparison in the assertion.\n\nLog String works well with Self Shunt. The test case implements the methods in the shunted interface by adding to the log and then returning reasonable values.\n\nCrash Test Dummy\n\nHow do you test error code that is unlikely to be invoked? Invoke it anyway with a special object that throws an exception instead of doing real work.\n\n149\n\n150\n\nTesting Patterns\n\nCode that isn’t tested doesn’t work. This seems to be the safe assumption. What to do with all those odd error conditions, then? Do you have to test them, too? Only if you want them to work.\n\nLet’s say we want to test what happens to our application when the file system is full. We could go to a lot of work to create many big files and fill the file system, or we could fake it. “Fake it” doesn’t sound dignified, does it? We’ll simulate it.\n\nHere’s our crash test dummy for a file:\n\nprivate class FullFile extends File { public FullFile(String path) {\n\nsuper(path);\n\n} public boolean createNewFile() throws IOException {\n\nthrow new IOException();\n\n}\n\n}\n\nNow we can write our Expected Exception test:\n\npublic void testFileSystemError() { File f= new FullFile(\"foo\"); try {\n\nsaveAs(f); fail();\n\n} catch (IOException e) { }\n\n}\n\nA Crash Test Dummy is like a Mock Object, except you don’t need to Mock up the whole object. Java’s anonymous inner classes work well for sabotaging just the right method to simulate the error we want to exercise. You can override just the one method you want, right there in your test case, making the the test case easier to read:\n\npublic void testFileSystemError() {\n\nFile f= new File(\"foo\") {\n\npublic boolean createNewFile() throws IOException {\n\nthrow new IOException();\n\n}\n\n};\n\ntry {\n\nsaveAs(f); fail();\n\n} catch (IOException e) { }\n\n}\n\nBroken Test\n\nHow do you leave a programming session when you’re programming alone? Leave the last test broken.\n\nRichard Gabriel taught me the trick of finishing a writing session in mid-sentence. When you sit back down, you look at the half sentence and you have to figure out what you were thinking when you wrote it. Once you have the thought thread back, you finish the sentence and continue. Without the urge to finish the sentence, you can spend many minutes first sniffing around for what to work on next, then trying to remember your mental state, then finally getting back to typing.\n\nI tried the analogous technique for my solo projects and I really like the effect. Fin- ish a solo session by writing a test case and running it to be sure it doesn’t pass. When you come back to the code, you have an obvious place to start, you have an obvious, concrete bookmark to help you remember what you were thinking, and making that test work should be quick work, so you’ll quickly get your feet back on that victory road.\n\nI thought it would bother me to have a test broken overnight. It doesn’t, I think because I know that the program isn’t finished. A broken test doesn’t make the pro- gram any less finished, it just makes the status of the program manifest. The ability to quickly pick up a thread of development after weeks of hiatus is worth that little twinge of walking away from a red bar.\n\nClean Check-in\n\nHow do you leave a programming session when you’re programming in a team? Leave all the tests running.\n\n“Do I contradict myself? Tough.”\n\n–Bubba Whitman, Walt’s stevedore brother\n\n151\n\n152\n\nTesting Patterns\n\nWhen you are responsible to your teammates, the picture changes completely. When you start programming on a team project, you don’t know in detail what has happened to the code since you saw it last. You need to start from a place of confi- dence and certainty. Therefore, always make sure all the tests are running before you check in your code (a bit like how each test case leaves the world in a known- good state, if you are prone to computer metaphors for human behavior, which I’m not (usually)).\n\nThe test suite you run when you check in may be more extensive than the one you are running every minute during development (don’t give up on running the whole suite all the time until it is slow enough to be annoying). You will occasionally find a test broken in the integration suite when you try to check in. What to do?\n\nThe simplest rule is to just throw away your work and start over. The broken test is pretty strong evidence that you didn’t know enough to program what you just pro- grammed. If the team adopted this rule, there would be a tendency for folks to check in more often because the first person to check in doesn’t risk losing any work. Checking in more often is probably a good thing.\n\nA slightly more libertine approach is to give you a chance to fix the defect and try again. To keep from dominating the integration resources, you should probably give up after a few minutes and start over. It goes without saying, so I’ll say it any- way, that commenting out tests to make the suite pass is strictly verboten, and grounds for some serious beer purchasing at that Friday late afternoon’s offsite planning meeting.\n\nFurther Study\n\n???version control/configuration management???\n\nwww.mockobjects.com",
      "page_number": 159
    },
    {
      "number": 18,
      "title": "Segment 18 (pages 167-174)",
      "start_page": 167,
      "end_page": 174,
      "detection_method": "topic_boundary",
      "content": "CHAPTER 31\n\nGreenBarPatterns\n\nOnce you have a broken test, you need to fix it. If you treat a red bar as a condition to be fixed as quickly as possible, you will discover that you can get to green quickly. These patterns are how to make the code pass (even if the result isn’t something you want to live with for even an hour).\n\nFake It (‘Til You Make It)\n\nWhat is your first implementation once you have a broken test? Return a constant. Once you have the test running, gradually transform the constant into an expression using variables.\n\nA simple example occurred in our implementation of xUnit.\n\nreturn \"1 run, 0 failed\"\n\nbecame:\n\nreturn \"%d run, 0 failed\" % self.runCount\n\nbecame:\n\nreturn \"%d run, %d failed\" % (self.runCount , self failureCount)\n\n153\n\n154\n\nGreen Bar Patterns\n\nFake It is a bit like driving a piton above your head when you are climbing a rock. You haven’t really gotten there yet (the test is there but the code structure is wrong). However, when you do get there, you know you will be safe (the test will still run).\n\nFake It really rubs some people the wrong way. Why would you do something that you know you have to rip out? Because having something running is better than not having something running, especially if you have the tests to prove it. Peter Hansen submitted this story:\n\n… something happened just yesterday where, as two newbies to TDD, my partner and I aggressively stuck to the letter of the law and committed sins to get a test working quickly. In the process, we realized we had not properly implemented the test so we went back and fixed that, then made the code work again. The first working code ended up not being anywhere in sight by the time it worked again and we sort of looked at each other and said, “Huh... would you look at that!” because that approach had taught us something we didn’t know.\n\nHow could a fake implementation have taught them their test was written wrong? I don’t know, but I’ll bet they were glad they didn’t invest in the real solution to find out.\n\nThere are a couple of effects that make Fake It powerful:\n\nPsychological—Having a green bar feels completely different than having a red bar. When the bar is green, you know where you stand. You can refactor from there with confidence.\n\nScope control—Programmers are good at imagining all sorts of future prob- lems. Starting with one concrete example and generalizing from there prevents you from prematurely confusing yourself with extraneous concerns. You can do a better job of solving the immediate problem because you are focused. When you go to implement the next test case, you can focus on that one, too, knowing that the previous test is guaranteed to work.\n\nDoes Fake It violate the rule that says you don’t write any code that isn’t needed? I don’t think so, because in the refactoring step you are eliminating duplication of data between the test case and the code. When I write1:\n\nassertEquals(new MyDate(\"28.2.02\"), new MyDate(\"1.3.02\").yesterday());\n\n1. Thanks to Dierk König for the example.\n\nMyDate\n\npublic MyDate yesterday() {\n\nreturn new MyDate(\"28.2.02\");\n\n}\n\nThere is duplication between the test and the code. I can shift it around by writing:\n\nMyDate\n\npublic MyDate yesterday() {\n\nreturn new MyDate(new MyDate(\"31.3.02\").days()-1);\n\n}\n\nBut there is still duplication. However, I can eliminate the data duplication (because this = MyDate(“31.1.02”) for the purposes of my test) by writing:\n\nMyDate\n\npublic MyDate yesterday() {\n\nreturn new MyDate(this.days()-1);\n\n}\n\nNot everyone is convinced by this bit of sophistry, which is why you can Triangu- late, at least until you are tired of it and start using Fake It or even Obvious Imple- mentation.\n\nWhen I use Fake It, I’m reminded of long car trips with kids in the back. I write the first test, I make it work some ugly way, and then, “Don’t make me stop this car and write another test. If I have to pull over, you’ll be sorry.” “Okay, okay, Dad. I’ll clean the code up. You don’t have to get all huffy.”\n\nTriangulate\n\nHow do you most conservatively drive abstraction with tests? Only abstract when you have two or more examples.\n\nHere’s an example. Suppose we want to write a function that will return the sum of two integers. We write:\n\npublic void testSum() {\n\nassertEquals(4, plus(3, 1));\n\n}\n\n155\n\n156\n\nGreen Bar Patterns\n\nprivate int plus(int augend, int addend) {\n\nreturn 4;\n\n}\n\nIf we are triangulating to the right design, we have to write:\n\npublic void testSum() {\n\nassertEquals(4, plus(3, 1)); assertEquals(7, plus(3,4));\n\n}\n\nWhen we have the second example, we can abstract the implementation of plus():\n\nprivate int plus(int augend, int addend) {\n\nreturn augend + addend;\n\n}\n\nTriangulation is attractive because the rules for it seem so clear. The rules for Fake It, where we are relying on our sense of duplication between the test case and the fake implementation to drive abstraction, seem a bit vague and subject to interpre- tation. While they seem simple, the rules for triangulation create an infinite loop. Once we have the two assertions and we have abstracted the correct implementa- tion for plus, we can delete one of the assertions on the grounds that it is completely redundant with the other. If we do that, however, we can simplify the implementa- tion of plus() to just return a constant, which requires us to add an assertion.\n\nI only use triangulation when I’m really, really unsure about the correct abstraction for the calculation. Otherwise I rely on either Obvious Implementation or Fake It.\n\nObvious Implementation\n\nHow do you implement simple operations? Just implement them.\n\nFake It and Triangulation are teensy-weensy tiny steps. Sometimes you are sure you know how to implement an operation. Go ahead. For example, would I really use Fake It to implement something as simple as plus()? Not usually. I would just type in the obvious implementation. If I noticed I was getting surprised by red bars, I would go to smaller steps.\n\nThere’s no particular virtue in the halfway nature of Fake It and Triangulate. If you know what to type, and you can do it quickly, do it. However, by using only Obvi-\n\nous Implementation, you are demanding perfection of yourself2. Psychologically, this can be a devastating move. What if what you write isn’t really the simplest change that could get the test to pass? What if your partner shows you an even sim- pler one? You’re a failure! Your world crumbles around you! You die. Freeze up.\n\nSolving “clean code” at the same time you solve “that works” can be too much to do at once. As soon as it is, go back to solving “that works,” then “clean code” at leisure.\n\nKeep track of how often you get surprised by red bars using Obvious Implementa- tion. I’ll get stuck in these cycles where I’ll type in an Obvious Implementation. It won’t work. But now I’m sure I know what I should type, so I type that. It doesn’t work. So now… This especially happens with off by one errors and positive/nega- tive errors.\n\nYou want to maintain that red/green/refactor rhythm. Obvious Implementation is second gear. Be prepared to downshift if your brain starts writing checks your fin- gers can’t cash.\n\nOne to Many\n\nHow do you implement an operation that works with collections of objects? Imple- ment it without the collections first, then make it work with collections.\n\nFor example, suppose we are writing a function to sum an array of numbers. We can start with one:\n\npublic void testSum() {\n\nassertEquals(5, sum(5));\n\n}\n\nprivate int sum(int value) {\n\nreturn value;\n\n}\n\n(I am implementing sum() in the TestCase class to avoid writing a new class just for one method.)\n\n2. Thanks to Laurent Bossavit for this discussion.\n\n157\n\n158\n\nGreen Bar Patterns\n\nWe want to test sum(new int[] {5, 7}) next. First we add a parameter to sum() tak- ing an array of values:\n\npublic void testSum() {\n\nassertEquals(5, sum(5, new int[] {5}));\n\n}\n\nprivate int sum(int value, int[] values) {\n\nreturn value;\n\n}\n\nYou can look at this step as an example of Isolate Change. Once we add the param- eter in the test case we are free to change the implementation without affecting the test case.\n\nNow we can use the collection instead of the single value:\n\nprivate int sum(int value, int[] values) {\n\nint sum= 0; for (int i= 0; i<values.length; i++)\n\nsum += values[i];\n\nreturn sum;\n\n}\n\nNow we can delete the unused single parameter:\n\npublic void testSum() {\n\nassertEquals(5, sum(new int[] {5}));\n\n}\n\nprivate int sum(int[] values) {\n\nint sum= 0; for (int i= 0; i<values.length; i++)\n\nsum += values[i];\n\nreturn sum;\n\n}\n\nThe previous step is also an example of Isolate Change, where we change the code so we can change the test cases without affecting the code. Now we can enrich the test case as planned:\n\npublic void testSum() {\n\nassertEquals(12, sum(new int[] {5, 7}));\n\n}\n\nFurther Study\n\nPragmatic Programmer\n\nRitchie Elements of Style\n\n159\n\n160\n\nGreen Bar Patterns",
      "page_number": 167
    },
    {
      "number": 19,
      "title": "Segment 19 (pages 175-182)",
      "start_page": 175,
      "end_page": 182,
      "detection_method": "topic_boundary",
      "content": "CHAPTER 32\n\nxUnitPatterns\n\nAssertion\n\nHow do you check that tests worked correctly? Write boolean expressions that automate your judgment about whether the code worked.\n\nIf we are going to make the tests fully automated, every bit of human judgment has to be taken out of the evaluation of the results. We need to push a button and have all the decisions necessary to verify the correct working of the code run by the com- puter. This suggests that:\n\nThe decisions have to be boolean—true generally means everything is okay and false means something unexpected happened\n\nThe state of the booleans have to be checked by computer, by calling some vari- ant of an “assert()” method\n\nI’ve seen assertions like “assertTrue(rectangle.area() != 0)”. You could return any- thing not null and satisfy this test, so it isn’t very useful. Be specific. If the area should be 50, say that it should be 50—“assertTrue(rectangle.area() == 50)”.\n\n161\n\n162\n\nxUnit Patterns\n\nMany xUnit implementations have a special assertion for testing equality. Testing for equality is common, and if you know you are testing equality you can write an informative error message. The expected value generally goes first, so in JUnit we would write the above as “assertEquals(50, rectangle.area())”.\n\nThinking about objects as black boxed is hard. If I have a Contract with a Status that can either be an instance of Offered or Running, I might feel like writing a test based on my expected implementation:\n\nContract contract= new Contract(); // Offered status by default contract.begin(); // Changes status to Running assertEquals(Running.class, contract.status.class);\n\nThis test is too dependent on the current implementation of status. The test should pass even if the representation of status changed to a boolean. Perhaps once the sta- tus changes to Running, it is possible to ask for the actual start date.\n\nassertEquals(…, contract.startDate()); // Throws an exception if the status is Offered\n\nI’m aware that I am swimming against the tide in insisting that all tests be written using only public protocol. There is even a package that extends JUnit, JXUnit, that allows testing the value of variables, even those declared private.\n\nWishing for white box testing is not a testing problem, it is a design problem. Any time I want to use a variable as a way of checking to see whether code ran correctly or not, I have an opportunity to improve the design. If I give in to my fear and just check the variable, I lose that opportunity. That said, if the design idea doesn’t come, it doesn’t come. I’ll check the variable, shed a tear, make a note to come back on one of my smarter days, and move on.\n\nThe original SUnit (the first, Smalltalk, version of the testing framework) had sim- ple assertions. If one broke, a debugger popped up, you fixed the code, and away you went. Because the IDEs for Java aren’t so sophisticated, and because building Java-based software often happens in a batch environment, it makes sense to add information about the assertion which will be printed if it ever fails.\n\nIn JUnit, this takes the form of an optional first parameter1. If you write \"assert- True(\"Should be true\", false)\", when the test is run you will see an error message something like \"Assertion failed: Should be true\". This is often enough information to send you straight to the source of the error in the code. Some teams adopt the convention that all assertions must be accompanied by an informative error mes- sage. Try it both ways and see if the investment in the error messages pays off for you.\n\nFixture\n\nHow do you create common objects needed by several tests? Convert the local vari- ables in the tests into instance variables. Override setUp() and initialize those vari- ables.\n\nIf we want to remove duplication from our model code, do we want to remove it also from our test code? Maybe.\n\nHere’s the problem—often you write more code setting objects up in an interesting state than you write manipulating them and checking results. The code for setting up the objects is the same for several tests (these objects are the test’s fixture, also known as scaffolding.) This duplication is bad:\n\nIt takes a while to write, even to copy-n-paste, and we’d like test writing to be fast\n\nIf we need to change an interface by hand, we have to change it in several tests (exactly what we would expect of duplication)\n\nThe same duplication, however, is also good. Tests written with the set-up code right there with the assertions are readable top to bottom. If we factored the set-up code into a separate method we would have to remember that the method was called, and remember what the objects looked like, before we could write the rest of the test.\n\nxUnit supports both styles of test writing. You can write the test-fixture-creating code with the test, if you expect readers not to be able to easily remember the fix- ture objects. However, you can also move common test-fixture-creating code into a\n\n1. Optional parameters are supposed to come at the end, but for readability it helps to have the explanatory string at the beginning.\n\n163\n\n164\n\nxUnit Patterns\n\nmethod called setUp(). In it, set instance variables to the objects that will be used in the test.\n\nHere is an example too simple to really motivate the value of factoring out common set-up code, but short enough to fit in a book. We could write:\n\nEmptyRectangleTest\n\npublic void testEmpty() {\n\nRectangle empty= new Rectangle(0,0,0,0); assertTrue(empty.isEmpty());\n\n}\n\npublic void testWidth() {\n\nRectangle empty= new Rectangle(0,0,0,0); assertEquals(0.0, empty.getWidth(), 0.0);\n\n}\n\n(This also demonstrates the floating point version of assertEquals(), which requires a tolerance.) We could get rid of the duplication by writing:\n\nEmptyRectangleTest\n\nprivate Rectangle empty;\n\npublic void setUp() {\n\nempty= new Rectangle(0,0,0,0);\n\n}\n\npublic void testEmpty() {\n\nassertTrue(empty.isEmpty());\n\n}\n\npublic void testWidth() {\n\nassertEquals(0.0, empty.getWidth(), 0.0);\n\n}\n\nWe have extracted the common code as a method, one that the framework is guar- anteed to call before our test method is called. The test methods are simpler, but we have to remember what is in setUp() before we can understand them.\n\nWhich style should you use? Try them both. I nearly always factor common set-up code out, but I have a strong memory for detail. Readers of my tests sometimes complain that there is too much to remember, so maybe I should factor out less.\n\nThe relationship of subclasses of TestCase and instances of those subclasses is one of the most confusing parts of xUnit. Each new kind of fixture should be a new sub- class of TestCase. Each new fixture is created in an instance of that subclass, used once, then discarded.\n\nIn our example above, if we wanted to write tests for a non-empty Rectangle, we would create a new class, perhaps NormalRectangleTest, and initialize a different variable to a different rectangle in setUp(). In general, if I find myself wanting a slightly different fixture, I start a new subclass of TestCase.\n\nThis implies that there is no simple relationship between test classes and model classes. Sometimes one fixture serves to test several classes (although this is rare). Sometimes two or three fixtures are needed for a single model class. In practice, you usually end up with roughly the same number of test classes as model classes, but not because for each and every model class you write one and only one test class.\n\nExternal Fixture\n\nHow do you release external resources in the fixture? Override tearDown() and release the resources.\n\nRemember that the goal of each test is to leave the world in exactly the same state as before it ran. For example, if you open a file in a test, you need to be sure to close it before the test completes. You could write:\n\ntestMethod(self):\n\nfile= File(\"foobar\").open() try:\n\n...run the test...\n\nfinally:\n\nfile.close()\n\nIf the file was used in several tests, you could make it part of the common fixture:\n\nsetUp(self):\n\nself.file= File(\"foobar\").open()\n\ntestMethod(self):\n\n165\n\n166\n\nxUnit Patterns\n\ntry:\n\n...run the test...\n\nfinally:\n\nself.file.close()\n\nFirst, there is that pesky duplication of the finally clause telling us that we are miss- ing something in the design. Second, this method is error prone because it is easy to forget the finally clause, or forget to close the file altogether. Lastly, there are three lines of noise in the test—try, finally, and the close itself, which is not central to the running of the test.\n\nxUnit guarantees that a method called tearDown() will be run after the test method. TearDown() will be called regardless of what happens in the test method (although if setUp() fails tearDown() won’t be called). We can transform the above to:\n\nsetUp(self):\n\nself.file= File(\"foobar\").open()\n\ntestMethod(self):\n\n...run the test...\n\ntearDown(self):\n\nself.file.close()\n\nTest Method\n\nHow do you represent a single test case? As a method (whose name begins with “test” by convention.)\n\nYou are going to have hundreds, later thousands, of tests in your system. How are you going to keep track of them all?\n\nObject programming languages have three levels of hierarchy for organization:\n\n(cid:127) Module (“package” in Java)\n\n(cid:127)\n\nClass (cid:127) Method\n\nIf we are writing tests as ordinary source code, we need to find a way to fit into this structure. If we are using classes to represent fixtures, then the natural home for tests is as methods. All the tests sharing a single fixture will be methods in the same class. Tests requiring a different fixture will be in a different class.\n\nBy convention, the name of the method begins with “test”. Tools can look for this pattern to automatically create suites of tests given a class. The remainder of the name of the method should suggest to a future clueless reader why this test was written. JUnit, for example has a test called “testAssertPosInfinityNotEqualsNegIn- finity”. I can’t remember writing this test, but from the name I assume that at some point JUnit’s assertion code for floating point numbers didn’t distinguish between positive and negative infinity. From the test I can quickly find the code in JUnit that handles floating point comparison and see how we handled it (it’s kind of ugly— there’s a special conditional to handle infinity.)\n\nTest methods should be easy to read, pretty much straightline code. If a test method is getting long and complicated, you need to play “Baby Steps”. The goal of the game is to write the smallest test method that represents real progress towards your end goal. Three lines appears to be about the minimum, without deliberate obfusca- tion (and remember, you are writing these tests for people, not just the computer or yourself.)\n\nPatrick Logan contributed an idea I’m going to experiment with, also described by McConnell2 and Caine and Gordon3\n\nFor some reason I’ve been working with \"outlines\" in practically everything I do lately. Testing is no different. When I write tests, I first create a short outline of the tests I want to write, for example... /* Adding to tuple spaces. */ /* Taking from tuple spaces. */ /* Reading from tuple space. */\n\nThese are place holders until I add specific tests under each category. When I add tests, I add another level of comments to the outline... /* Adding to tuple spaces. */ /* Taking from tuple spaces. */ /** Taking a non-existant tuple. **/ /** Taking an existing tuple. **/ /** Taking multiple tuples. **/ /* Reading from tuple space. */\n\nI usually only have two or three levels to the outline. I can’t think of when I had more. But the outline essentially becomes documentation of the contract for the\n\n2. Steve McConnell, Code Complete, chapter 4, Microsoft Press, 19??, ISBN >???. 3. S. H. Caine and E. K. Gordon, “PDL: A Tool for Software Design,” AFIPS Proceedings of the 1975 National Computer Conference.\n\n167\n\n168\n\nxUnit Patterns\n\nclass being tested. The examples here are abbreviated , but they would be more specific in a contract-like language. (I don’t use any kind of add-on to Java for Eiffel-like automation.)\n\nImmediately under the lowest level of the outline is the test case code.\n\nException Test\n\nHow do you test for expected exceptions? Catch expected exceptions and ignore them, failing only if the exception isn’t thrown.\n\nLet’s say we’re writing some code to look up a value. If the value isn’t found, we want to throw an exception. Testing the lookup is easy enough.\n\npublic void testRate() {\n\nexchange.addRate(\"USD\", \"GBP\", 2); int rate= exchange.findRate(“USD”, “GBP”); assertEquals(2, rate);\n\n}\n\nTesting the exception may not be so obvious. Here’s how we do it:\n\npublic void testMissingRate() {\n\ntry {\n\nexchange.findRate(\"USD\", “GBP\"); fail();\n\n} catch (IllegalArgumentException expected) { }\n\n}\n\nIf findRate() doesn’t throw an exception, we will call fail(), an xUnit method which reports that the test failed. Notice that we are careful only to catch the particular exception we expect, so if the wrong kind of exception is thrown, we will also be notified (including assertion failures.)\n\nAllTests\n\nHow do you run all tests together? Make a suite of all the suites, one for each pack- age and one aggregating the package tests for the whole application.\n\nSuppose you add a TestCase subclass to a package and you add a test method to that class. The next time all the tests run that test method should run, too (there’s",
      "page_number": 175
    },
    {
      "number": 20,
      "title": "Segment 20 (pages 183-191)",
      "start_page": 183,
      "end_page": 191,
      "detection_method": "topic_boundary",
      "content": "that test-driven stuff—the preceding is the outline for a test that I would probably just go and implement if I wasn’t busy writing a book.) Because this isn’t supported in most xUnit implementations or IDEs, each package should declare a class AllT- ests that implements a static method suite() that returns a TestSuite. Here is AllT- ests for the Money example:\n\npublic class AllTests {\n\npublic static void main(String[] args) {\n\njunit.swingui.TestRunner.run(AllTests.class);\n\n}\n\npublic static Test suite() {\n\nTestSuite result= new TestSuite(\"TFD tests\"); result.addTestSuite(MoneyTest.class); result.addTestSuite(ExchangeTest.class); result.addTestSuite(IdentityRateTest.class); return result;\n\n}\n\n}\n\nYou can also give AllTests a main() method so the class can be run directly from the IDE or a command line.\n\nFurther Study\n\nThe official site for JUnit is www.junit.org. There is also an active mailing list at http://groups.yahoo.com/group/junit.\n\nYou can find a complete list of xUnit implementations at www.xprogram- ming.com/software.htm (38 languages at the time I’m writing).\n\n169\n\n170\n\nxUnit Patterns\n\nCHAPTER 33\n\nDesignPatterns\n\nOne of the primary insights of patterns1 is that although it may seem like we solve completely different problems all the time, most of the problems we solve are gen- erated by the tools we use, not by the external problem at hand. Because of this, we can expect to find (and actually do find) common problems with common solutions even in the midst of an incredible diversity of external problem solving contexts.\n\nApplying objects to organizing computation is one of the best examples of common internally generated sub-problems being solved in common, predictable ways. The enormous success of design patterns2 is a testimonial to the commonality seen by object programmers. The success of the design patterns book, however, has stifled any diversity in expressing these patterns.\n\nThe design patterns book seems to have a subtle bias towards design as a phase. It certainly makes no nod towards refactoring as a design activity. Design in TDD requires a slightly different look at design patterns.\n\n1. Notes on the Synthesis of Form, Christopher Alexander, Harvard University Press, 1970, ISBN: 0674627512\n\n2. Design Patterns: Elements of Reusable Object Oriented Software, Dr. Erich Gamma, et. al, Addison-Wesley, 199?, ISBN: ???\n\n171\n\n172\n\nDesign Patterns\n\nThe design patterns covered here are not intended to be comprehensive. They are just enough design to get us through the examples. Here they are in summary:\n\nCommand—represent the invocation of a computation as an object, not just a message\n\n(cid:127) Value Object—avoid aliasing problems by making objects whose values never\n\nchange once created\n\n(cid:127) Null Object—represent the base case of a computation by an object\n\nTemplate Method—represent invariant sequences of computation with an abstract method intended to be specialized through inheritance\n\nPluggable Object—represent variation by invoking another object with two or more implementations\n\nPluggable Selector—avoid gratuitous subclasses by dynamically invoking dif- ferent methods for different instances\n\nFactory Method—create an object by calling a method instead of a constructor.\n\nComposite—represent the composition of the behavior of a list of objects with an object\n\nCollecting Parameter—pass around a parameter to be used to aggregate the results of computation in many different objects\n\nImposter—introduce variation by introducing a new implementation of existing protocol\n\nThe design patterns cluster based on where they are used in TDD:\n\nPattern\n\nTest Writing\n\nRefactoring\n\nCommand\n\nX\n\nValue Object\n\nX\n\nNull Object\n\nX\n\nTemplate Method\n\nX\n\nPluggable Object\n\nX\n\nPluggable Selector\n\nX\n\nFactory Method\n\nX\n\nX\n\nComposite\n\nX\n\nX\n\nCollecting Parameter\n\nX\n\nX\n\nImposter\n\nX\n\nX\n\nCommand\n\nWhat do you do when you need the invocation of a computation to be more compli- cated than a simple method call? Make an object for the computation and invoke it.\n\nSending messages is wonderful. Programming languages make sending messages syntactically easy. Programming environments make manipulating messages easy (e.g. refactorings to automatically rename a message). However, sometimes just sending a message isn’t enough.\n\nFor example, suppose you want to log the fact that a message got sent. We could add language features (wrapper methods) to do this, but logging is rare enough, and the value of simple languages is high enough, that we’d rather not do that. Or sup- pose we want to invoke a computation, but later. We could start a thread, immedi- ately suspend it, and re-start it later, but then we’d have all the joys of concurrency to deal with.\n\nComplicated invocations of computation require expensive mechanisms. However, most of the time we don’t need all the complexity, and we’d rather not pay the cost. When we need invocation to be just a little more concrete and manipulable than a message, objects give us the answer. Make an object representing the invocation. Seed it with all the parameters the computation will need. When we’re ready to invoke it, use generic protocol, like “run()”.\n\nThe Java interface Runnable is an excellent example of this.\n\nRunnable\n\ninterface Runnable\n\npublic abstract void run();\n\nIn the implementation of run(), you can do anything you’d like. Unfortunately, Java has no syntactically lightweight way to create and invoke Runnables, so they aren’t used as much as the equivalent—blocks or lambda in Smalltalk/Ruby or LISP—in other languages.\n\n173\n\n174\n\nDesign Patterns\n\nValue Object\n\nHow do you design objects that will be widely shared, but for whom identity is unimportant? Set their state when they are created and never change it. Operations on the object always return a new object.\n\nObjects are wonderful. I can say that here, can’t I? Objects are a great way to orga- nize logic for later understanding and growth. However, there is one little problem (okay, more than one, but this one will do for now.)\n\nSuppose I (an object) have a Rectangle. I compute some value based on the Rectan- gle, like its area. Later, someone politely asks me for my Rectangle, and I, not wanting to appear uncooperative, give it to them. Moments later, lo and behold, the Rectangle has been changed behind my back. The area I computed earlier is out of date, and there is no way for me to know.\n\nThis is the classic aliasing problem. If two objects share a reference to a third, if one object changes the referred object, the other object better not rely on the state of the shared object.\n\nThere are several ways out of the aliasing problem. One solution is never to give out the objects that you rely on, but instead to always make copies. This can get expensive in time and space, and ignores those times when you want to share changes to a shared object. Another solution is Observer, where you explicit regis- ter with objects on which you rely and expect to be notified when they change. Observer can make control flows difficult to follow, and the logic for setting up and removing the dependencies gets ugly.\n\nAnother solution is to treat the object as less than an object. Objects have state that change over time. We can, if we choose, eliminate the “that change over time”. If I have an object and I know it won’t change, I can pass around references to it all I want, knowing that aliasing won’t be a problem. There can be no hidden changes to a shared object if there are no changes.\n\nI remember puzzling over Integers when I was first learning Smalltalk. If I change bit 2 to a 1, why don’t all 2’s become 6’s?\n\na := 2. b := a. a := a bitAt: 2 put: 1. a => 6\n\nb => 2\n\nBecause Integers are really values masquerading as objects. In Smalltalk this is lit- erally true of small integers, and simulated in the case of integers that don’t fit in a single machine word. When I set that bit, what I get back is a new object with the bit set, not the old one with the bit changed.\n\nWhen implementing a Value Object, every operation has to return a fresh object, leaving the original unchanged. Users have to be aware they are using a Value Object and store the result (as in the example above.) All of these object allocations can create performance problems, which should be handled like all performance problems, when you have realistic data sets, realistic usage patterns, profiling data, and complaints about performance.\n\nI have a tendency to use Value Object whenever I have a situation that looks like algebra—geometric shapes being intersected and unioned, unit values where units are carried around with a number, symbolic arithmetic. Any time Value Object makes the least sense I try it, because it makes reading and debugging so much eas- ier.\n\nAll Value Objects have to implement equality (and in many languages by implica- tion they have to implement hashing.) If I have this Contract and that Contract and they aren’t the same object, then they are different, not equal. However, if I have this five francs and that five francs, it doesn’t matter if they are the same five francs, five francs are five francs and they should be equal.\n\nNull Object\n\nHow do you represent special cases using objects? Create an object representing the special case. Give it the same protocol as the regular objects.\n\njava.io.File\n\npublic boolean setReadOnly() {\n\nSecurityManager security = System.getSecurityManager(); if (security != null) {\n\nsecurity.checkWrite(path);\n\n} return fs.setReadOnly(this);\n\n}\n\n175\n\n176\n\nDesign Patterns\n\nThere are 18 places where the same “security != null” check takes place in java.io.File. While I appreciate their diligence in making files safe for the world, I’m also a bit nervous. Are they careful to always check for a null as the result of getSecurityManager()?\n\nThe alternative is to create a new class, LaxSecurity, which doesn’t throw excep- tions ever.\n\njava.io.LaxSecurity\n\npublic void checkWrite(String path) { }\n\nIf someone asks for a SecurityManager and there isn’t one available, we send back a LaxSecurity instead:\n\njava.lang.SecurityManager\n\npublic static SecurityManager getSecurityManager() {\n\nreturn security != null ? security : new LaxSecurity();\n\n}\n\nNow we don’t have to worry about someone forgetting to check for null. The origi- nal code cleans up considerably:\n\njava.io.File\n\npublic boolean setReadOnly() {\n\nSecurityManager security = System.getSecurityManager(); security.checkWrite(path); return fs.setReadOnly(this);\n\n}\n\nErich Gamma and I once got in an argument at an OOPSLA tutorial about whether a Null Object was appropriate somewhere in JHotDraw. I was ahead on points when he calcuated the cost of introducing the Null Object as 10 lines of code, for which we would get to eliminate 1 conditional. I hate those late round TKOs. (We also got extremely bad marks from the audience for not being organized. Appar- ently they weren’t aware that having productive design discussions is a difficult but learnable skill.)\n\nTemplate Method\n\nHow do you represent the invariant sequence of a computation while providing for future refinement? Write a method that is implemented entirely in terms of other methods.\n\nProgramming is full of classic sequences:\n\nInput/process/output\n\nSend message/receive reply\n\nRead command/return result\n\nWe would like to be able to clearly communicate the universality of these sequences, while at the same time providing for variation in the implementation of the steps.\n\nIn inheritance, object languages provide a simple, if limited, mechanism for com- municating universal sequences. A superclass can contain a method written entirely in terms of other methods, and subclasses can implement those methods in different ways. For example, JUnit implements the basic sequence of running a test as\n\nTestCase\n\npublic void runBare() throws Throwable {\n\nsetUp(); try {\n\nrunTest();\n\n} finally {\n\ntearDown();\n\n}\n\n}\n\nSubclasses can implement setUp(), runTest(), and tearDown() however they want.\n\nOne question when writing a Template Method is whether to write a default imple- mentation of the sub-methods. In TestCase.runBare(), all three sub-methods have default implementations:\n\nsetUp() and tearDown() are no-ops\n\nrunTest() dynamically finds and invokes a testing method based on the name of the test case\n\n177",
      "page_number": 183
    },
    {
      "number": 21,
      "title": "Segment 21 (pages 192-200)",
      "start_page": 192,
      "end_page": 200,
      "detection_method": "topic_boundary",
      "content": "178\n\nDesign Patterns\n\nIf the computation makes no sense without a sub-step being filled in, you should note this in whatever way your programming language provides:\n\nJava—declare the sub-method abstract\n\nSmalltalk—implement the method by throwing a SubclassResponsibility error\n\nTemplate methods are best found through experience instead of designed that way from the beginning. Whenver I say to myself, “Ah, this is the sequence and here are the details,” I always find myself inlining the detail methods later and re-extracting the truly variant parts.\n\nWhen you find two variants of a sequence in two subclasses, you need to gradually move them closer together. Once you’ve extracted the parts that are different to other methods, what you are left with is the template method. Then you can move the template method to the superclass and eliminate the duplication.\n\nPluggable Object\n\nThe simplest way to express variation is with explicit conditionals:\n\nif (circle) then { …circley stuff… } else { …non circley stuff }\n\nYou will quickly find that such explicit decision making begins to spread. If you represent the distinction between circles and non-circles as an explicit conditional in one place, the conditional is likely to spread.\n\nSince the second imperative of TDD is the elimination of duplication, you must nip the plague of explicit conditionals in the bud. The second time you see a condi- tional, it is time to pull out the most basic of object design moves, the pluggable object.\n\nThe pluggable objects revealed by simply eliminating duplication are sometimes counter-intuitive. Erich Gamma and I found this, one of my favorite examples of an unpredictable pluggable object. When writing a graphics editor, selection is actu- ally a bit complicated. If you’re over a figure when the button is pressed, then sub- sequent moves of the mouse move that figure and releasing the button leaves the figure selected. If you’re not over a figure, then you are selecting a group of figures,\n\nand subsequent moves of the mouse typically resize a rectangle used to select sev- eral figures. Releasing the button causes the figures inside the rectangle to be selected. The initial code looks something like this:\n\nSelectionTool\n\nFigure selected; public void mouseDown() { selected= findFigure(); if (selected != null)\n\nselect(selected);\n\n} public void mouseMove() { if (selected != null)\n\nmove(selected);\n\nelse\n\nmoveSelectionRectangle();\n\n} public void mouseUp() { if (selected == null) selectAll();\n\n}\n\nThere’s that ugly duplicated conditional (I told you they spread like a disease). The answer in this case is to create a Pluggable Object, a SelectionMode, with two implementations, SingleSelection and MultipleSelection.\n\nSelectionTool\n\nSelectionMode mode; public void mouseDown() { selected= findFigure(); if (selected != null)\n\nmode= SingleSelection(selected);\n\nelse\n\nmode= MultipleSelection();\n\n} public void mouseMove() {\n\nmode.mouseMove();\n\n} public void mouseUp() {\n\nmode.mouseUp();\n\n}\n\n179\n\n180\n\nDesign Patterns\n\nIn languages with explicit interfaces, you will have to implement an interface along with the two (or more) pluggable objects.\n\nPluggable Selector3\n\nHow do you invoke different behavior for different instances? Store the name of a method, and dynamically invoke the method.\n\nWhat do you do when you have ten subclasses of a class, each implementing only one method? Subclassing is a heavyweight mechanism for capturing such a small amount of variation.\n\nabstract class Report {\n\nabstract void print();\n\n}\n\nclass HTMLReport extends Report {\n\nvoid print() { ... }\n\n}\n\nclass XMLReport extends Report {\n\nvoid print() { ... }\n\n}\n\nOne alternative is to have a single class with a switch statement. Depending on the value of a field, you invoke different methods. However, the name of the method appears in three places:\n\nThe creation of the instance\n\nThe switch statement\n\nThe method itself abstract class Report {\n\nString printMessage;\n\n3. For more details see K. Beck, The Smalltalk Best Practice Patterns, p. 70-73, Prentice- Hall, 1997, ISBN 013476904X. It’s bad form to reference your own works, but as noted philosopher Phyllis Diller once said, “Of course I laugh at my own jokes. You can’t trust strangers.”\n\nReport(String printMessage) {\n\nthis.printMessage= printMessage;\n\n}\n\nvoid print() {\n\nswitch (printMessage) { case \"printHTML\" : printHTML(); break;\n\ncase \"printXML\" : printXML(): break;\n\n}\n\n};\n\nvoid printHTML() { }\n\nvoid printXML() { }\n\n}\n\nEvery time you add a new kind of printing you have to be sure to add the printing method and change the switch statement.\n\nThe Pluggable Selector solution is to dynamically invoke the method using reflec- tion:\n\nvoid print() {\n\nMethod runMethod= getClass().getMethod(printMessage, null); runMethod.invoke(this, new Class[0]);\n\n}\n\nNow there is still an ugly dependency between creators of Reports and the names of the print methods, but at least you don’t have the case statement in there, too.\n\nPluggable Selector can definitely be overused. The biggest problem with it is trac- ing code to see whether a method is invoked. Only use Pluggable Selector when you are cleaning up a fairly straightforward situation in which a bunch of sub- classes each have only one method.\n\n181\n\n182\n\nDesign Patterns\n\nFactory Method\n\nHow do you create an object when you want flexibility in creating new object? Cre- ate the object in a method instead of using a constructor.\n\nConstructors are expressive. You can see that you are definitely creating an object when you use one. However, constructors, particularly in Java, lack expressiveness and flexibility.\n\nOne axis of flexibility that we wanted in our Money example was to be able to return an object of a different class when we created an object. We had tests like:\n\npublic void testMultiplication() { Dollar five= new Dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));\n\n}\n\nWe wanted to introduce the Money class, but we couldn’t as long as we were locked into creating an instance of Dollar. By introducing a level of indirection, through a method, we gained the flexibility of returning an instance of a different class without changing the test.\n\npublic void testMultiplication() {\n\nDollar five = Money.dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));\n\n} Money\n\nstatic Dollar dollar(int amount) { return new Dollar(amount);\n\n}\n\nThis method is called a Factory Method, because it makes objects.\n\nThe downside of using Factory Method is precisely its indirection. You have to remember that the method is really creating an object, even though it doesn’t look like a constructor. Use Factory Method only when you need the flexibility it cre- ates. Otherwise, constructors work just fine for creating objects.\n\nImposter\n\nHow do you introduce a new variation into a computation? Introduce a new object with the same protocol as an existing object but a different implementation.\n\nIntroducing variation in a procedural program involves adding conditional logic. As we saw in Pluggable Object, such logic tends to proliferate, and a healthy dose of polymorphic messages are required to cure the duplication.\n\nSuppose you have a structure in place already. There’s an object already. Now you need the system to do something different. If there’s an obvious place to insert an if statement and you’re not duplication logic from elsewhere, go ahead. Often how- ever, the variation would obviously require changes to several methods.\n\nThis moment of decision comes up in two ways in TDD. Sometimes you are writ- ing a test case and you need to represent a new scenario. None of the existing objects expresses what you want to express. Suppose we are testing a graphics edi- tor and we already have rectangles drawing correctly:\n\ntestRectangle() {\n\nDrawing d= new Drawing(); d.addFigure(new RectangleFigure(0, 10, 50, 100)); RecordingMedium brush= new RecordingMedium(); d.display(brush); assertEquals(\"rectangle 0 10 50 100\\n\", brush.log());\n\n}\n\nNow we want to display ovals. In this case, the Imposter is easy to spot—replace a RectangleFigure with an OvalFigure.\n\ntestOval() {\n\nDrawing d= new Drawing(); d.addFigure(new OvalFigure(0, 10, 50, 100)); RecordingMedium brush= new RecordingMedium(); d.display(brush); assertEquals(\"oval 0 10 50 100\\n\", brush.log());\n\n}\n\nGenerally, spotting the possibility of an Imposter the first time requires insight. Ward’s insight that a vector of Moneys could act like a Money is just such a moment. You thought they were different, and now you see that you can see them as being the same.\n\n183\n\n184\n\nDesign Patterns\n\nFollowing are two examples of Imposters that come up during refactoring:\n\n(cid:127) Null Object—you can treat the absence of data the same as the presence of data\n\nComposite—you can treat a collection of objects the same as a single object\n\nFinding Imposters during refactoring is driven by eliminating duplication, just as all refactoring is driven by eliminating duplication.\n\nComposite\n\nHow do you implement an object whose behavior is the composition of the behav- ior of a list of other objects? Make it an Imposter for the component objects.\n\nMy favorite example is also an example of the contradiction of composites: Account and Transaction. Transactions store an increment of value (they are really a lot more complex and interesting, but for now…):\n\nTransaction\n\nTransaction(Money value) { this.value= value;\n\n}\n\nAccounts compute their balance by summing the values of their Transactions:\n\nAccount\n\nTransaction transactions[]; Money balance() {\n\nMoney sum= Money.zero(); for (int i= 0; i < transactions.length; i++)\n\nsum= sum.plus(transactions[i].value);\n\nreturn sum;\n\n}\n\nSeems simple enough:\n\n(cid:127)\n\nTransactions have a value (cid:127) Accounts have a balance\n\nThen comes the interesting part. A customer has a bunch of Accounts, and would like to see an overall balance. The obvious way to implement this is as a new class,\n\nOverallAccount, that sums the balances of a list of Accounts. Duplication! Duplica- tion!\n\nWhat if Account and Balance both implemented the same interface, call it “Hold- ing” because I can’t think of anything better at the moment?\n\nHolding\n\ninterface Holding\n\nMoney balance();\n\nTransactions can implement balance() by returning their value:\n\nTransaction\n\nMoney balance() {\n\nreturn value;\n\n}\n\nNow Accounts can be composed of Holdings, not Transactions:\n\nAccount\n\nHolding holdings[]; Money balance() {\n\nMoney sum= Money.zero(); for (int i= 0; i < holdings.length; i++)\n\nsum= sum.plus(holdings[i].balance());\n\nreturn sum;\n\n}\n\nNow our problem with OverallAccounts disappears. An OverallAccount is just an Account containing Accounts.\n\nThe smell of Composite is illustrated by the above. Transactions don’t have bal- ances, not in the real world. Applying Composite is a programmer’s trick, not gen- erally appreciated by the rest of the world. However, the benefits to program design are enormous, so the conceptual disconnect is often worth it. Folders containing Folders, TestSuites containing TestSuites, Drawings containing Drawings, none of these translate well from the world, but they all make the code so much simpler.\n\nI had to play with Composite for a long time before I found where to use it and where not to use it. As will be obvious from the discussion above, I’m still not able to articulate how to guess when a collection of objects is just a collection of objects\n\n185\n\n186\n\nDesign Patterns\n\nand when you really have a Composite. The good news is, since you’re getting good at refactoring, the moment the duplication appears, you can introduce Com- posite and watch program complexity disappear.\n\nCollecting Parameter\n\nHow do you collect the results of an operation that is spread over several objects? Add a parameter to the operation in which the results will be collected.\n\nA simple example is the java.io.Externalizable interface. The writeExternal method writes an object and all the objects it references. Since the objects all have to coop- erate loosely to get written out, the method is passed a parameter, an ObjectOutput, as the collecting parameter: java.io.Externalizable\n\npublic interface Externalizable extends java.io.Serializable {\n\nvoid writeExternal(ObjectOutput out) throws IOException;\n\n}\n\nAdding a Collecting Parameter is a common consequence of Composite. In devel- oping JUnit, we didn’t need the TestResult to collate the results of several tests until we had several tests.\n\nAs the sophistication of expected results grows, you may find the need to introduce a Collecting Parameter. For example, suppose we are printing Expressions. If all we want is a flat string, concatenation is sufficient:\n\ntestSumPrinting() {\n\nSum sum= new Sum(Money.dollar(5), Money.franc(7)); assertEquals(\"5 USD + 7 CHF\", sum.toString());\n\n}\n\nString toString() {\n\nreturn augend + \" + \" + addend;\n\n}\n\nIf we want the indented tree form of the expression however:\n\ntestSumPrinting() {\n\nSum sum= new Sum(Money.dollar(5), Money.franc(7)); assertEquals(\"+\\n\\t5 USD\\n\\t7 CHF\", sum.toString());\n\n}",
      "page_number": 192
    },
    {
      "number": 22,
      "title": "Segment 22 (pages 201-208)",
      "start_page": 201,
      "end_page": 208,
      "detection_method": "topic_boundary",
      "content": "We will have to introduce a Collecting Parameter, something like this:\n\nString toString() {\n\nIndentingStream writer= new IndentingStream(); toString(writer); return writer.contents();\n\n}\n\nvoid toString(IndentingWriter writer) {\n\nwriter.println(\"+\"); writer.indent(); augend.toString(writer); writer.println(); addend.toString(writer); writer.exdent();\n\n}\n\nSingleton\n\nHow do you provide global variables in languages without global variables? Don’t. Your progams will thank you for taking the time to think about design instead.\n\nFurther Study\n\nDP\n\nPOSA\n\nNature of Order\n\nGRudin, Grace of Great Things\n\nD’Arcy Thompson\n\n187\n\n188\n\nDesign Patterns\n\nCHAPTER 34\n\nRefactoring\n\nThere is a brief description of how to accomplish each refactoring in small steps. More importantly, each refactoring discusses why you might want to use it.\n\nIn TDD we use “refactoring” in an interesting way. Usually, a refactoring cannot change the semantics of the program under any circumstances. In TDD, the circum- stances we care about are the tests that are already passing. So, for example, we can replace constants with variables in TDD and call this operation, in good conscience, a refactoring, because it doesn’t change the set of tests that pass. The only circum- stance under which semantics are preserved may actually be our one test case. Any other test case that was passing would fail. However, we don’t have those tests yet, so we don’t worry about them.\n\nThis “observational equivalence” places a burden on you to have enough tests so as far as you know, a refactoring with respect to the tests is the same as a refactoring with respect to all possible tests, at least by the time you’re done. It’s no excuse to say, “I knew there was a problem, but the tests all passed so I checked the code in.” Write more tests.\n\nReconcile Differences\n\nHow do you unify two similar looking pieces of code? Gradually bring them closer. Unify them only when they are absolutely identical.\n\n189\n\n190\n\nRefactoring\n\nRefactoring can be a nerve-wracking experience. The easy ones are obvious. If I extract a method, as long as I do it mechanically correctly, there is very little chance of changing the system’s behavior. Some refactorings push you to examine the con- trol flows and data values carefully. A long chain of reasoning leads you to believe that the change you are about to make won’t change any answers. Those are the refactorings that enhance your hairline.\n\nSuch a leap of faith refactoring is exactly what we’re trying to avoid with our strat- egy of small steps and concrete feedback. While you can’t always avoid leapy refactorings, you can reduce their incidence.\n\nThis refactoring occurs at all levels of scale:\n\nTwo loops structures are similar. By making them identical, you can merge them.\n\nTwo branches of a conditional are similar. By making the identical, you can eliminate the conditional.\n\nTwo methods are similar. By making them identical, you can eliminate one.\n\nTwo classes are similar. By making them identical, you can eliminate one.\n\nSometimes you need to approach reconciling differences backwards—think about how the last step of the change could be trivial, then work backwards. For example, if you want to remove several subclasses, the trivial last step is if a subclass con- tains nothing. Then the subclass can be replaced by the superclass without changing the behavior of the system. To empty out this subclass, this method needs to be made identical to the one in the superclass. One by one, empty out the subclasses and, when they are empty, replace references to them by references to the super- class.\n\nIsolate Change\n\nHow do you change one part of a multi-part method or object? First, isolate the part that has to change.\n\nThe picture that comes to my mind is surgery, where all of the patient except the part to be operated on is draped. The draping leaves the surgeon with only a fixed set of variables. Now, we could have long arguments over whether this abstraction of a person to a lower left quadrant abdomen leads to good health care, but at the moment of surgery, I’m kind of glad the surgeon can focus.\n\nYou may find that once you’ve isolated the change and then made the change, that the result is so trivial that you can undo the isolation. If we found that really all we needed was to return the instance variable in findRate(), we should consider inlin- ing findRate() everywhere it is used and deleting it. Don’t make these changes automatically, however. Balance the cost of an additional method with the value of having an additional concept explicit in the code.\n\nSome possible ways to Isolate Change are Extract Method (the most common), Extract Object, and Method Object.\n\nMigrate Data\n\nHow do you move from one representation? Temporarily duplicate the data.\n\nHow:\n\nHere is the internal-to-external version, where you change the representation inter- nally and then change the externally visible interface:\n\n(cid:127) Add an instance variable in the new format\n\n(cid:127)\n\nSet the new format variable everywhere you set the old format (cid:127) Use the new format variable everywhere you use the old format (cid:127) Delete the old format\n\nChange the external interface to reflect the new format\n\nSometimes, though, you want to change the API first. Then you should:\n\n(cid:127) Add a parameter in the new format\n\nTranslate from the new format parameter to the old format internal representa- tion\n\n(cid:127) Delete the old format parameter\n\nReplace uses of the old format with the new format\n\n(cid:127) Delete the old format\n\nWhy:\n\nOne to Many creates a data migration problem every time. Suppose we wanted to implement TestSuite using One to Many. We would start with:\n\n191\n\n192\n\nRefactoring\n\ndef testSuite(self):\n\nsuite= TestSuite() suite.add(WasRun(\"testMethod\")) suite.run(self.result) assert(\"1 run, 0 failed\" == self.result.summary())\n\nWhich is implemented (in the “One” part of One to Many) by:\n\nclass TestSuite:\n\ndef add(self, test): self.test= test def run(self, result):\n\nself.test.run(result)\n\nNow we begin duplicating data. First we initialize the collection of tests:\n\nTestSuite\n\ndef __init__(self):\n\nself.tests= []\n\nEverywhere “test” is set, we add to the collection, too:\n\nTestSuite\n\ndef add(self, test): self.test= test self.tests.append(test)\n\nNow we use the list of tests instead of the single test. For purposes of the current test cases this is a refactoring (it preserves semantics) because there is only ever one element in the collection.\n\nTestSuite\n\ndef run(self, result):\n\nfor test in self.tests: test.run(result)\n\nWe delete the now-unused instance variable “test”:\n\nTestSuite\n\ndef add(self, test):\n\nself.tests.append(test)\n\nYou can also use stepwise data migration when moving between equivalent formats with different protocols, as in moving from Java’s Vector/Enumerator to Collec- tion/Iterator.\n\nExtract Method\n\nHow do you make a long, complicated method easier to read? Turn a small part of it into a separate method and call the new method.\n\nHow\n\nExtract Method is actually one of the more complicated atomic refactorings. I’ll describe the typical case here. Fortunately, it is also the most commonly imple- mented automatic refactoring, so you likely won’t have to do it by hand.\n\n1. Find a region of the method that would make sense as its own method. Bodies of loop, whole loops, and branches of conditionals are common candidates for extrac- tion.\n\n2. Make sure there are no assignments to temporary variables declared outside the scope of the region to be extracted.\n\n3. Copy the code from the old method to the new method. Compile it.\n\n4. For each temporary variable or parameter of the original method used in the new method, add a parameter to the new method.\n\n5. Call the new method from the original method\n\nWhy\n\nI use Extract Method when I’m trying to understand complicated code. “Here, this bit here is doing something. What shall we call that?” After half an hour the code is looking better, your partner realizes that really are there to help, and you under- stand much better what is going on.\n\nI use Extract Method to eliminate duplication when I see that two methods have some parts the same and some parts different. I extract out the similar bits as meth- ods (the Smalltalk Refactoring Browser even goes and checks to see if you are extracting a method that is equivalent to one you already have, and offers to use the existing method instead of creating a new one.)\n\n193\n\n194\n\nRefactoring\n\nBreaking methods into tiny bits can sometimes go too far. When I can no longer see a way forward, I often use Inline Method (conveniently, the next refactoring) to get all the code in one place so I can see what should be extracted anew.\n\nInline Method\n\nHow do you simplify control flows that have gotten to twisted or scattered? Replace a method invocation with the method itself.\n\nHow\n\n1. Copy the method.\n\n2. Paste the method over the method invocation.\n\n3. Replace all formal parameters with actual parameters. If you pass, for example, reader.getNext() (an expression causing side effects), be careful to assign it to a local variable.\n\nWhy\n\nA reviewer complained about the sequence in section I where a Bank is asked to reduce an Expression to a single Money.\n\npublic void testSimpleAddition() { Money five= Money.dollar(5); Expression sum= five.plus(five); Bank bank= new Bank(); Money reduced= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(10), reduced);\n\n}\n\n“This is too complicated. Why don’t you just ask the Money to reduce itself?” How do we experiment? Inline the implementation of Bank.reduce() and see what it looks like.\n\npublic void testSimpleAddition() { Money five= Money.dollar(5); Expression sum= five.plus(five); Bank bank= new Bank(); Money reduced= sum.reduce(bank, \"USD\"); assertEquals(Money.dollar(10), reduced);",
      "page_number": 201
    },
    {
      "number": 23,
      "title": "Segment 23 (pages 209-216)",
      "start_page": 209,
      "end_page": 216,
      "detection_method": "topic_boundary",
      "content": "}\n\nYou might like second version better or not. The point to note here is you can use Inline Method to play around with the flow of control. When I’m refactoring, I have a mental picture of the system with bits of logic and control flow sloshing around between the objects. When I think I see something promising, I use the refactorings to try it out and see the result.\n\nIn the heat of battle I’ll occassionally get caught up in my own cleverness (I’m not going to say how often those occassions come.) When I do, Inline Method is a way for me to reel myself back in. “I have this sending to that sending to that... Whoa, Nelly. What’s going on here?” I inline a few layers of abstraction, see what’s really going on, and then I can re-abstract the code according to its actual needs, not my preconceptions.\n\nExtract Interface\n\nHow do you introduce a second implementation of operations in Java? Create an interface containing the shared operations.\n\nHow:\n\n1. Declare an interface. Sometimes the name of the existing class should be the name of the interface, in which case you should first rename the class.\n\n2. Have the existing class implement the interface.\n\n3. Add the necessary methods to the interface, expanding the visibility of the meth- ods in the class if necessary.\n\n4. Change type declarations from the class to the interface where possible.\n\nWhy:\n\nSometimes when you need to extract an interface, you are genuinely moving from the first implementation to the second. You have a Rectangle and you want to add an Oval, so you create a Shape interface. Finding names for the interfaces in this case is generally easy, although sometimes you have to struggle to find the right metaphor.\n\n195\n\n196\n\nRefactoring\n\nSometimes you are introducing a Crash Test Dummy or other Mock Object when you need to extract an interface. Naming is generally tougher in this case, because you still only have one real example. These are the times I’m most tempted to cop out and name the interface IFile and leave the class named File. I’ve schooled myself to stop a moment and see if I don’t understand something deeper about what is going on. Perhaps the interface should be called File and the class DiskFile, because the class assumes that the bits are on a disk.\n\nMove Method\n\nHow do you move a method to where it belongs? Add it to the class where it belongs, then invoke it.\n\nHow:\n\n1. Copy the method.\n\n2. Paste the method, suitably named, into the target class. Compile it.\n\n3. If the original object is referenced in the method, add a parameter to pass the original object. If variables of the original object are referenced, pass them as parameters. If variables of the original object are set, you should like give up.\n\n4. Replace the body of the original method with an invocation of the new method.\n\nHow:\n\nThis is one of my favorite consulting refactorings, because it is so good at uncover- ing unwarranted preconceptions. Calculating areas is the responsibility of the Shape:\n\nShape\n\n... int width= bounds.right() - bounds.left(); int height= bounds.bottom() - bounds.top(); int area= width * height; ...\n\nAny time I see more than one message sent to another object in a method, I get sus- picious. In this case, I see that bounds (a Rectangle) is being sent four messages. Time to move this part of the method:\n\nRectangle\n\npublic int area() {\n\nint width= this.right() - this.left(); int height= this.bottom() - this.top(); return width * height;\n\n} Shape\n\n... int area= bounds.area(); ...\n\nThe three great properties of Move Method are:\n\nIt’s easy to see the need for it without deep understanding of the meaning of the logic. You see two or more messages to a different object and away you go.\n\nThe mechanics are quick and safe.\n\nThe results are often enlightening. “But Rectangles don’t do any calculation... Oh, I see. That is better.”\n\nSometimes you will want to move only part of a method. You can first extract a method, move the whole method, then inline the (now one line) method in the orig- inal class. Or you can figure out the mechanics for doing it in one go.\n\nMethod Object\n\nHow do you represent a complicated method that requires several parameters and local variables? Make an object out of the method.\n\nHow:\n\n(cid:127)\n\nCreate an object with the same parameters as the method. (cid:127) Make the local variables also instance variables of the object.\n\nCreate one method called \"run()\", whose body is the same as the body of the original method.\n\nIn the original method, create a new object and invoke run().\n\nWhy:\n\n197\n\n198\n\nRefactoring\n\nMethod Objects are useful in preparation for adding a whole new kind of logic to the system. For example, you might have several methods involved in computing the cash flow from component cash flows. When you want to start computing the net present value of the cash flows, you can first create a Method Object out of the first style of computation. Then you can write the new style of computation with its own, smaller-scale, tests. Then plugging in the new style will be a single step.\n\nMethod Objects are also good for simplifying code that doesn’t yield to Extract Method. Sometimes you’ll find a block of code that has a bunch of temporary vari- ables and parameters, and every time you try to extract a piece of it you have to carry along five or six temps and parameters. The resulting extracted method doesn’t look any better than the original code, because the method signature is so long. Creating a Method Object gives you a new namespace in which you can extract methods without having to pass anything.\n\nAdd Parameter\n\nHow do you add a parameter to a method?\n\nHow:\n\n(cid:127)\n\nIf the method is in an interface, add the parameter to the interface first (cid:127) Use the compiler errors to tell you what other code you need to change\n\nWhy:\n\nAdding a parameter is often an extension step. You got the first test case running without needing the parameter, but in this new circumstance you have to take more information into account in order to compute correctly.\n\nAdding a parameter can also be part of migrating from one data representation to another. First you add the parameter, then you delete all uses of the old parameter, then you delete the old parameter.\n\nMethod Parameter to Constructor Parameter\n\nHow do you move a parameter from a method or methods to the constructor?\n\nHow:\n\n(cid:127) Add a parameter to the constructor\n\n(cid:127) Add an instance variable with the same name as the parameter\n\nSet the variable in the constructor\n\n(cid:127) One by one, convert references to “parameter” to “this.parameter” (cid:127) When no more references exist to the parameter, delete the parameter from the\n\nmethod and all caller\n\nRemove the now-superfluous “this.” from references\n\nRename the variable correctly\n\nWhy:\n\nIf you pass the same parameter to several different methods in the same object, you can simplify the API by passing the parameter once (eliminating duplication). You can run this refactoring in reverse if you find that an instance variable is only used in one method.\n\nFurther Study\n\nFowler, Refactoring\n\nAlexander, Timeless Way of Building\n\n199\n\n200\n\nRefactoring\n\nCHAPTER 35\n\nMasteringTDD\n\nI hope to raise questions here for you to ponder as you integrate TDD into your own practice. Some of the questions are small, and some are large. Sometimes the answers are here, or at least hinted at here, and sometimes the questions are left for you to explore.\n\nHow large should your steps be?\n\nThere are really two questions lurking here:\n\n(cid:127) How much ground should each test cover? (cid:127) How many intermediate stages should you go through as you refactor?\n\nYou could write the tests so they each encouraged the addition of a single line of logic and a handful of refactorings. You could write the tests so they each encour- aged the addition of hundreds of lines of logic and hours of refactoring. Which should you do?\n\nPart of the answer is that you should be able to do either. The tendency of TDDers over time is clear, though—smaller steps. However, folks are experimenting with driving development from application-level tests, either alone or in conjunction with the programmer-level tests we’ve been writing.\n\n201\n\n202\n\nMastering TDD\n\nAt first when you refactor, you should be prepared to take lots of little tiny steps. Manual refactoring is prone to error, and the more errors you make and only catch later, the less likely you are to refactor. Once you’ve done a refactoring 20 times by hand in little tiny steps, experiment with leaving out some of the steps.\n\nAutomated refactoring accelerates refactoring enormously. What would have taken you 20 manual steps now becomes a single menu item. An order of magnitude change in quantity generally constitute a change in quality, and this is true of auto- mated refactoring. When you know you are supported by an excellent tool, you become much more aggressive in your refactorings, trying many more experiments to see how the code wants to be structured.\n\nThe Refactoring Browser for Smalltalk is as I write still the best refactoring tool available. Java refactoring support is appearing in many Java IDEs, and refactoring support is sure to spread quickly to other languages and environments.\n\nWhat don’t you have to test?\n\nThe simple answer, supplied by Phlip is, “write tests until fear is transformed into boredom.” This is a feedback loop, though, and requires that you find the answer yourself. Since you came to this book for answers, not questions (in which case you’re already reading the wrong section, but enough of the self-referential literary recursion stuff…), try this list. You should test:\n\nConditionals\n\n(cid:127)\n\nLoops (cid:127) Operations\n\nPolymorphism\n\nBut only those that you write. Unless you have reason to distrust it, don’t test code from others. Sometimes, the precise specification of (by which I mean “bugs in”) external code requires you to write more logic of your own. See above for whether you have to test this. Sometimes, just to be extra careful, I will document the pres- ence of, um, unusual behavior in external code with a test that will fail if the bug is ever fixed, er, the behavior is ever refined.",
      "page_number": 209
    },
    {
      "number": 24,
      "title": "Segment 24 (pages 217-224)",
      "start_page": 217,
      "end_page": 224,
      "detection_method": "topic_boundary",
      "content": "How do you know if you have good tests?\n\nThe tests are a canary in a coal mine revealing by their distress the presence of evil design vapors. Here are some attributes of tests suggesting a design in trouble:\n\nLong setup code—If you have to spend a hundred lines creating the objects for one simple assertion, something is wrong. Your objects are too big and need to be split.\n\nSetup duplication—If you can’t easily find a common place for common setup code, there are too many objects too tightly intertwingled.\n\nLong running tests—TDD tests that run a long time won’t be run often, and often haven’t been run for a while, and probably don’t work. Worse than this, though, they suggest that testing the bits and pieces of the application is hard. Difficulty testing bits and pieces is a design problem, and needs to be addressed with design. (The equivalent of 9.8 m/s2 is the ten minute test suite. Suites that take longer than 10 minutes inevitably get trimmed, or the application tuned up, so the suite takes 10 minutes again.)\n\nFragile tests—Tests that break unexpectedly suggest that one part of the appli- cation is surprisingly effecting another part. You need to design until the effect at a distance is eliminated, either by breaking the connection or by bringing the two parts together.\n\nHow does TDD lead to frameworks?\n\nParadox: by not considering the future of your code you make your code much more likely to be able to adapt in the future.\n\nI learned exactly the opposite from books. “Code for today, design for tomorrow.” TDD appears to stand this advice on its head. “Code for tomorrow, design for today.”\n\nHere’s what happens in practice.\n\nThe first feature goes in. It is implemented simply and straightforwardly, so it is done quickly and with few defects.\n\nThe second feature, a variation on the first, goes in. The duplication between the two features is put in one place, while the differences tend to go in different places (different methods or even different classes).\n\n203\n\n204\n\nMastering TDD\n\nThe third feature, a variation on the first two, goes in. The common logic is likely to be reusable as is, perhaps with a few tweaks. The unique logic tends to have an obvious home, either in a different method or different class.\n\nThe Open/Closed Principle (objects should be open for use and closed to further modification) is gradually satisfied, and for precisely those kinds of variation that occur in practice. Test driving development leaves you with frameworks that are good at expressing exactly the kind of variation that occurs, even though they might not be good at expressing the kind of variation that doesn’t occur (or hasn’t occurred yet.)\n\nSo, what happens when an unusual variation pops up three years later? The design undergoes rapid evolution in exactly the necessary spots of accommodate the varia- tion. The Open/Closed Principle is violated, just for a moment, but the violation is not all that costly because you have all those tests to give you confidence you aren’t breaking anything.\n\nAt the limit, where you introduce the variations very quickly, TDD is indistinguish- able from designing ahead. I grew a reporting framework once over the course of a few hours, and observers were absolutely certain it was a trick. I must have started with the resulting framework in mind. No, sorry. I’ve just been test driving devel- opment long enough that I can recover from most of my mistakes faster than you can recognize I’ve made them.\n\nHow much feedback do you need?\n\nHow many tests should you write? Here’s a simple problem—given three integers representing the length of the sides of a triangle, return:\n\n1 if the triangle is equilateral\n\n2 if the triangle is isoceles\n\n3 if the triangle is scalene\n\nand throw an exception if the triangle is not well formed.\n\nGo ahead, try the problem (my Smalltalk solution is listed at the end of this ques- tion).\n\nI wrote 6 tests (kind of like Name That Tune, “I can code that problem in four tests.” “Code that problem.”) Bob Binder, in his comprehensive book Testing\n\nObject-Oriented Software, wrote 65 for the same problem. You’ll have to decide, from experience and reflection, about how many tests you want to write.\n\nI think about Mean Time Between Failure (MTBF) when I think about how many tests to write. For example, Smalltalk integers act like integers, not like a 32-bit counter, so it doesn’t make sense to test MAXINT. Well, there is a maximum size for an integer, but it has to do with how much memory you have. Do I need to write a test that fills up memory with extremely large integers? How will that affect the MTBF of my program? If I’m never going to get anywhere close to that size of tri- angle, my program is not measurably more robust with such a test than without it.\n\nWhether a test makes sense to write depends on how carefully you measure MTBF. If you are trying to get from an MTBF of 10 years to an MTBF of 100 years in your pacemaker, tests for extremely unlikely conditions and combinations of conditions make sense, unless you can demonstrate in some other way that the conditions can- not arise.\n\nTDD’s view of testing is pragmatic. In TDD, the tests are a means to an end, the end being code in which we have great confidence. If our knowledge of the imple- mentation gives us confidence even without a test, we will not write that test. Black box testing, where we deliberately choose to ignore the implementation, has some advantages. By ignoring the code, it demonstrates a different value system—the tests are valuable alone. It’s an appropriate attitude to take in some circumstances. However, it is different than TDD.\n\nTriangleTest\n\ntestEquilateral\n\nself assert: (self evaluate: 2 side: 2 side: 2) = 1\n\ntestIsoceles\n\nself assert: (self evaluate: 1 side: 2 side: 2) = 2\n\ntestScalene\n\nself assert: (self evaluate: 2 side: 3 side: 4) = 3\n\ntestIrrational\n\n[self evaluate: 1 side: 2 side: 3]\n\non: Exception do: [:ex | ^self].\n\nself fail\n\ntestNegative\n\n205\n\n206\n\nMastering TDD\n\n[self evaluate: -1 side: 2 side: 2]\n\non: Exception do: [:ex | ^self].\n\nself fail\n\ntestStrings\n\n[self evaluate: ‘a’ side: ‘b’ side: ‘c’]\n\non: Exception do: [:ex | ^self].\n\nself fail\n\nevaluate: aNumber1 side: aNumber2 side: aNumber3\n\n| sides | sides := SortedCollection with: aNumber1 with: aNumber2 with: aNumber3.\n\nsides first <= 0 ifTrue: [self fail]. (sides at: 1) + (sides at: 2) <= (sides at: 3) ifTrue: [self fail]. ^sides asSet size\n\nWhen should you delete tests?\n\nMore tests is better, but if two tests are redundant with respect to each other, should you keep them both around?\n\nThe first criterion for your tests is confidence. Never delete a test if it reduces your confidence in the behavior of the system.\n\nThe second criterion is communication. If you have two tests that exercise the same path through the code, but they speak to different scenarios for a readers, leave them alone.\n\nThat said, if you have two tests that are redundant with respect to confidence and communication, delete the least useful of the two.\n\nHow does the programming language and environment influence TDD?\n\nTry TDD in Smalltalk with the Refactoring Browser. Try it in C++ with vi. How does your experience differ?\n\nIn programming languages and environments where TDD cycles (test/compile/run/ refactor) are harder to come by, you will likely be tempted to take larger steps:\n\nCover more ground with each test\n\nRefactor with fewer intermediate steps\n\nDoes this make you go faster or slower?\n\nIn programming languages and environments where TDD cycles are plentiful, you will likely be tempted to try lots more experiments. Does this help you go faster or reach better solutions, or would you be better off institutionalizing some kind of time for pure reflection (reviews or literate programs)?\n\nCan you test-drive enormous systems?\n\nDoes TDD scale to extremely large systems? What new tests would you have to write? What new kinds of refactorings would you need?\n\nThe largest system I’ve been involved with that is totally test-driven is at LifeWare (www.lifeware.ch). After four years and 40 person/years, the system contains about 250,000 lines of functional code and 250,000 lines of test code in Smalltalk. There are 4,000 tests, executing in under 20 minutes. The full suite is run several times each day. The amount of functionality in the system seems to have no bearing on the effectiveness of TDD. By eliminating duplication you tend to create more smaller objects, and those objects can be tested in isolation independent of the size of the application.\n\nCan you drive development with application-level tests?\n\nThe problem with driving development with small scale tests (I call them “unit tests”, but they don’t match the accepted definition of unit tests very well) is that you run the risk of implementing what you think a user wants, but having it turn out to be not what they wanted at all. What if we wrote the tests at the level of the appli-\n\n207\n\n208\n\nMastering TDD\n\ncation? Then the users (with help) could write tests themselves for what exactly they wanted the system to do next.\n\nThere is a technical problem—fixturing. How can you write and run a test for a fea- ture that doesn’t exist yet? There always seems to be some way out of this problem, typically by introducing an interpreter which gracefully signals an error when it comes across a test that it doesn’t know how to interpret yet.\n\nThere is also a social problem with application test driven development. Writing tests is a new responsibility for users (by which I really mean a team that includes users), and that responsibility comes at a new place in the development cycle, namely before implementation begins. Organizations resist this kind of shift of responsibility. It will require concerted effort (that is, the effort of many people on the team working in concert) to get application tests written first.\n\nTDD as described in this book is a technique that is entirely under your control. You can pick it up and start using it today if you so choose. Mixing up the rhythm of red/green/refactor, the technical issues of application fixturing, and the organiza- tional change issues surrounding user-written tests is unlikely to be successful. The One Step Test rule applies. Get red/green/refactor going in your own practice, then spread the message.\n\nAnother aspected of ATDD is the length of the cycle between test and feedback. If a customer wrote a test and ten days later it finally worked, you would be staring at a red bar most of the time. I think I would want to still do programmer-level TDD so:\n\nI got immediate green bars\n\nI simplified the internal design\n\nHow do you switch to TDD mid-stream?\n\nYou have a bunch of code which more or less works. You want to test drive your new code. What do you do next?\n\nThere is a whole book (or books) to be written about switching to TDD when you have lots of code. What follows is necessarily only a teaser.\n\nThe biggest problem is that code that isn’t written with tests in mind typically isn’t very testable. The interfaces aren’t designed so it is easy for you to isolate a little piece of logic, run it, and check its results.\n\n“Fix it,” you say. Yes, well, but refactoring (without automated tools) is likely to result in errors, errors that you won’t catch because you don’t have the tests. Chick- ens and eggs. Catch-22. Mutually assured destruction. What do you do?\n\nWhat you don’t do is go write tests for the whole thing and refactor the whole thing. That would take months, months in which no new functionality would appear. Spending money without making it is generally speaking not a sustainable process.\n\nSo first we have to decide to limit the scope of our changes. If we see parts of the system that could be dramatically simplified, but that don’t demand change at the moment, we will leave them alone. Shed a tear, perhaps, for the sins of the past, but leave them alone.\n\nSecond, we have to break the deadlock between tests and refactoring. We can get feedback other ways than with tests, like working very carefully and with a partner. We can get feedback at a gross level, like system level tests that we know aren’t adequate, but give us some confidence. With this feedback, we can make the areas we have to change more accepting of change.\n\nOver time, the parts of the system that change all the time will come to look test- driven. Occassionally we will wander into an unlit back alley and get mugged for our troubles, reminding us how slow things used to be. Then we will slow down, break the deadlock, and get going again.\n\nWho is TDD intended for?\n\nEvery programming practice encodes a value system, explicitly or implicitly. TDD is no different. If you’re happy slamming some code together that more or less works and never looking at the result again, TDD is not for you. TDD rests on a charmingly naïve geekoid assumption that if you write better code, you’ll be more successful. TDD helps you pay attention to the right issues at the right time so you can make your designs cleaner, you can refine your designs as you learn.\n\nI say “naïve”, but that’s perhaps overstating. What’s naïve is assuming that clean code is all there is to success. Good engineering is maybe 20% of a project’s suc- cess. Bad engineering will certainly sink projects, but modest engineering can\n\n209\n\n210\n\nMastering TDD\n\nenable project success as long as the other 80% lines up right. From this perspec- tive, TDD is overkill. It lets you write code with far fewer defects and a much cleaner design than is common in the industry. However, those whose souls are healed by the balm of elegance can find in TDD a way to do well by doing good.\n\nTDD is also good for geeks who form emotional attachments to code. One of the great frustrations of my young engineer’s life was starting a project with great excitement, then watching the code base decay over time. A year later I wanted nothing more than to dump the now-smelly code and get on to the next project. TDD enables you to gain confidence in the code over time. As tests accumulate (and your testing improves), you gain confidence in the behavior of the system. As you refine the design, more and more changes become possible. My goal is to feel better about a project after a year than I did in the starry-eyed beginning, and TDD helps me achieve this.\n\nIs TDD sensitive to initial conditions?\n\nSome orders in which you take the tests seem to work very smoothly. Red/green/ refactor/red/green/refactor. You can take the same tests and implement them in a different order, and it seems like there is not a way to advance in small steps. Is it really true that one sequence of tests is an order of magnitude faster/easier to imple- ment than another? Is this just because my implementation technique is not up to the challenge? Is there something about the tests that should tell me to tackle them in a certain order? If TDD is sensitive to initial conditions in the small, is it predict- able in the large? (In the same way that little eddies in the Mississippi are unpre- dictable, but you can count on 2,000,000 cfs. more or less at the river mouth.)\n\nHow does TDD relate to patterns?\n\nAll of my technical writings have been about trying to find fundamental rules that generate behavior similar to experts. Partly this is because this is how I learn—I find an expert to act like, then gradually figure out what is really going on. I’m cer- tainly not looking for rules to be followed mechanically, although that is how the mechanically minded have interpreted them.\n\nMy oldest daughter (hi Bethany! I told you I would get you in here—be glad it isn’t more embarassing) spent several years learning to do multiplication fast. My wife and I both prided ourselves on doing multiplication fast, and learned very quickly. What was going on? Turns out that every time Bethany was faced with 6 x 9, she",
      "page_number": 217
    },
    {
      "number": 25,
      "title": "Segment 25 (pages 225-234)",
      "start_page": 225,
      "end_page": 234,
      "detection_method": "topic_boundary",
      "content": "would add 6 9 times (or 9 6 times, I suppose). Far from being a slow multiplier, she was a really fast adder.\n\nThe effect that I have noticed, and that I hope others find, is that by reducing repeat- able behavior to rules, applying the rules becomes rote and mechanical. This is quicker than re-debating everything from first principles all the time. When along comes an exception, or a problem that just doesn’t fit any of the rules, you have more time and energy to generate and apply creativity.\n\nThis happened to me when writing the Smalltalk Best Practice Patterns. At some point I decided to just follow the rules I was writing. It was much slower at first, to be looking up the rules, or to be stopping to write a new rule. After a week, though, I discovered that code was ripping off my fingertips that would have required a pause for thought before. This gave me more time and attention for bigger thoughts about design and analysis.\n\nAnother relationship between TDD and patterns is TDD as an implementation method for pattern-driven design. Say we decide we want a Strategy for something. We write a test for the first variant and implement it as a method. Then we con- sciously write a test for the second variant, expecting the refactoring phase to drive us to a Strategy. Robert Martin and I did some research into this style of TDD. The problem is the design keeps surprising you. Perfectly sensible design ideas turn out to be wrong. Better to just think about what you want the system to do, and let the design sort itself out later.\n\nWhy does TDD work?\n\nI saved the weirdest for last. Let’s assume for the moment that TDD helps teams productively build loosely coupled, highly cohesive systems with low defect rates and low cost maintenance profiles. (I’m claiming no such thing in general, but I trust you to imagine impossible things.) How could such a thing happen?\n\nPart of the effect certainly comes from reducing defects. The sooner you find and fix a defect, the cheaper it is, often dramatically so (just ask the Mars Lander.) There are plenty of secondary psychological and social effects from reduced defects. My own practice of programming became much less stressful with I started TDD. No longer did I have to worry about everything at once. I could make this test run, and then all the rest. Relationships with my teammates became more positive. I stopped breaking builds, and people could rely on my software to work. Customers of my systems became more positive, too. A new release of the system just meant\n\n211\n\n212\n\nMastering TDD\n\nmore functionality, not a host of new defects to identify among all of their old favorite bugs.\n\nI’ve said “reduced defects.” Where do I get off claiming such a thing? Do I have scientific proof?\n\nNo. No studies have categorically demonstrated the difference between TDD and any of the many alternatives in quality, productivity, or fun. However, the anec- dotal evidence is overwhelming, and the secondary effects are unmistakable. Pro- grammers really do relax, teams really do develop trust, and customers really do learn to look forward to new releases. “By and large,” I will say, although I haven’t seen the opposite effect. You mileage may vary, but you’ll have to try it to find out.\n\nAnother advantage of TDD that may explain its effect is the way it shortens the feedback loop on design decisions. The feedback loop for implementation deci- sions is obviously short—seconds or minutes, followed by re-running the tests tens or hundreds of times a day. The loop for design decisions goes between the design thought—perhaps the API should like this, or perhaps the metaphor should be that—and the first example, a test that embodies that thought. Rather than design- ing and then waiting weeks or months for someone else to feel the pain or glory, feedback comes in seconds or minutes as you try to translate your ideas into a plau- sible interface.\n\nA weirder answer to “why does TDD work?” comes from the fevered imagination of complex systems. The inimitable Phlip says:\n\nAdopt programming practices that “attract” correct code as a limit function, not as an absolute value. If you write unit tests for every feature, and if you refactor to simplify code between each step, and if you add features one at a time and only after all the unit tests pass, you will create what mathematicians call an “attractor.” This is a point in a state space that all flows converge on. Code is more likely to change for the better over time instead of for the worse; the attractor approaches correctness as a limit function.\n\nThis is the “correctness” that nearly all programmers get by with (except, of course, for medical or aerospace software). But it’s better to explicitly understand the attractor concept than deny it or disregard its importance.\n\nWhat’s with the name?\n\n(cid:127) Development—The old phasist way of thinking about software development is weakened because feedback between decisions is difficult if they are separated in time. Development in this sense means a complex dance of analysis, logical\n\ndesign, physical design, implementation, testing, review, integration and deployment.\n\n(cid:127) Driven—I used to call TDD “test-first programming”. However, the opposite of “first” is “last”, and lots of people test after they have programmed. There is a naming rule that the opposite of a name should be at least vaguely unsatisfac- tory (part of the appeal of structured programming is that no one wants to be unstructured.) If you don’t drive development with tests, what do you drive it with? Speculation? Specifications (ever notice that those two words come from the same root?)\n\nTest—Automated, reified, concrete tests. Push a button and they run. One of the ironies of TDD is that it isn’t a testing technique (the Cunningham Koan). It’s an analysis technique, a design technique, really a technique for all the activities of development.\n\nHow does TDD relate to the practices of Extreme Programming?\n\nSome reviewers have been concerned that by my writing a book exclusively about TDD, folks will take it as an excuse to ignore the rest of the advice in XP. For example, if you test-drive, do you still need to pair? Here is a brief summary of how the rest of XP enhances TDD and TDD enhances the rest of XP.\n\nPairing—The tests you write in TDD are excellent conversation pieces when you are pairing. The problem you avoid is that of the partners not agreeing on what problem they are solving, even though they are trying to work on the same code. This sounds crazy, but it happens all the time, especially when you are learning to pair with someone. Pairing enhances TDD by giving you a fresh mind to take over when you get tired. TDD’s rhythm can suck you in, and lead you to continue program even when you’re tired. Your partner, though, is ready to take the keyboard when you flag.\n\n(cid:127) Work fresh—On a related note, XP advises you to work when you are fresh and stop when you are tired. When you can’t get that next test to work, or those two tests to work together, it’s time for a break. Uncle Bob Martin and I were work- ing on a line break algorithm once and we just couldn’t get it to work. We strug- gled in frustration for a few minutes, but it was obvious we weren’t making progress so we stopped.\n\nContinuous integration—The tests make an excellent resource enabling you to integrate more often. You get another test working and the duplication removed, you check in. The cycle can be 15-30 minutes instead of the 1-2 hours that I usually shoot for. This may be part of the key to having larger teams of pro-\n\n213\n\n214\n\nMastering TDD\n\ngrammers on the same code base. As Bill Wake says, “An n2 problem is not a problem if n is always 1.”\n\nSimple design—By coding only what you need for the tests and removing all duplication, you automatically get a design that is perfectly adapted to the cur- rent requirements and equally prepared for all future stories. The mind set that you are looking for just enough design to have the perfect architecture for the current system also makes writing the tests easier.\n\nRefactoring—The “Remove Duplication” rule is another way of saying “refac- toring.” The tests, though, give you confidence that your larger refactorings haven’t changed the behavior of the system. The higher your confidence, the more aggressive you will be in trying large-scale refactorings that extend the life of your system. By refactoring, you make writing the next round of tests that much easier.\n\nContinuous delivery—If TDD tests really do improve the MTBF of your system (a contention you will have to verify for yourself), you can put code into pro- duction much more often without disrupting customers. Gareth Reeves makes the analogy to day trading. In day trading, you close out your positions every night, because you don’t risk around that you aren’t managing. In programming, you like all of your changes in production because you don’t want code around that you aren’t receiving concrete feedback on.\n\nDarach’s Challenge\n\nDarach Ennis has thrown down a gauntlet for extending the reach of TDD. He says:\n\nFor example, there are a lot of fallacies blowing around various engineering orga- nizations and amongst various engineers that this book could help to dispell and some of these are: (cid:127) You can’t test GUIs automaticaly (eg: Swing, CGI, JSP/Servlets/Struts) (cid:127) You can’t unit test distributed objects automaticaly (eg: RPC and Messaging\n\nstyle, or CORBA/EJB and JMS)\n\n(cid:127) You can’t test-first develop your database schema (eg: JDBC?) (cid:127) There is no need to test third party or code generated by external tools (cid:127) You can’t test first develop a language compiler / interpreter from BNF to\n\nproduction quality implementation\n\nI’m not sure he’s right, but I’m also not sure he’s wrong. He’s given me something to chew on as I think about how far to push TDD.\n\nCHAPTER 36\n\nGlossary\n\nI tend to use technical terms without defining them. If we were talking together, that glazed look in your eyes would tell me I’d wandered off into jargon land. In the absence of your inestimable feedback, here are the terms reviewers have huh’d.\n\nSBPP\n\nvalue object\n\nhashCode\n\ninline\n\nmodel code\n\nmethod signature\n\ngreen bar\n\nred bar\n\nTKO\n\n215\n\n216\n\nGlossary\n\nexception A way of transfering control to a method deeper in the call stack. Used to allow normal processing to be written simply and centralize handling of strange paths through the code (generally error conditions).\n\nleptokurtotic\n\nscalene\n\nisoceles\n\nequilateral\n\nfailure\n\nerror\n\ntransitive closure\n\nCHAPTER 37\n\nAppendix1:Influence Diagrams\n\nYou will find many examples of influence diagrams in the text. The idea of influ- ence diagrams is taken from Gerald Weinberg’s excellent Quality Software Man- agement series, particularly book 1 Systems Thinking (Dorset House, 1992). The purpose of an influence diagram is to see how the elements of a system affect each other.\n\nInfluence diagrams have three elements:\n\n(cid:127) Activities, notated as a word or short phrase\n\n(cid:127)\n\nPositive connections, notated as a directed arrow between two activities, mean- ing that more of the source activity tends to create more of the destination activ- ity or less of the source activity tends to create less of the destination activity (cid:127) Negative connections, notated as a directed arrow between two activities with a circle over it, meaning that more of the source activity tends to create less of the destination activity or less of the source activity tends to create more of the des- tination activity\n\nThat’s lots of words for a simple concept. Here are some examples:\n\nCircus attendance and hedge trimming\n\nFigure N: Two seemingly unrelated activites\n\n217\n\n218\n\nAppendix 1: Influence Diagrams\n\nEating positively connected to weight\n\nFigure N: Positively connected activities\n\nThe more I eat, the more I weigh. The less I eat, the less I weigh. (Personal weight is a far more complicated system than this, of course. Influence diagrams are mod- els to help you understand some aspect of the system, not understand and control it perfectly.)\n\nExercise negatively connected to weight\n\nFigure N: Negatively connected activities\n\nFeedback\n\nInfluence doesn’t just work one way. Often the effects of an activity come back around to change the activity itself, either positively or negatively. For example:\n\nWeight negatively connected to self esteem negatively connected to eating positively connected to weight.\n\nFigure N: Feedback\n\nIf my weight rises, my self-esteem drops, which makes we want to eat more, which makes my weight rise, and so on. Any time you have a cycle in an influence dia- gram, you have feedback.\n\nThere are two kinds of feedback:\n\n(cid:127)\n\nPositive (cid:127) Negative\n\nPositive feedback causes systems to encourage more and more of an activity. You can find positive feedback loops by counting the number of negative connections in a cycle. If there are an even number of negative connections, you have a positive feedback loop. The loop above is a positive feedback loop. It will cause you to keep gaining weight until the influence of some other activity kicks in.\n\nNegative feedback damps or reduces an activity. Cycles with an odd number of negative connections are negative feedback loops.\n\nThe key to system design is\n\nCreating virtuous cycles, where positive feedback loops encourage the growth of good activities\n\n(cid:127) Avoiding death spirals, where positive feedback loops encourage the growth of\n\nunproductive or destructive activities\n\nCreating negative feedback cycles to prevent overuse of good activities\n\nSystem Control\n\nWhen choosing a system of software development practices, you’d like the prac- tices to support each other so that you tend to do about the right amount of any activity, even under stress. Here’s an example of a system of practices that leads to insufficient testing:\n\nTime pressure neg testing neg errors pos time pressure\n\nFigure N: Not enough time to test reduces the available time\n\nUnder the pressure of time, you reduce the amount of testing, which increases the number of errors, which increases the time pressure. Eventually some outside activ- ity (like “Cash Flow Panic”) steps in to ship the software regardless.\n\nWhen you have a system that isn’t behaving, you have a host of options:\n\n(cid:127) Drive a positive feedback loop the other directions. If you have a loop between tests and confidence, and tests have been failing thus reducing confidence, you can make more tests work to increase confidence in your ability to get more test working.\n\nIntroduce a negative feedback loop to control an activity which has grown too large.\n\nCreate or break connections to eliminate loops that are not helping.\n\n219\n\n220\n\nAppendix 1: Influence Diagrams",
      "page_number": 225
    },
    {
      "number": 26,
      "title": "Segment 26 (pages 235-239)",
      "start_page": 235,
      "end_page": 239,
      "detection_method": "topic_boundary",
      "content": "CHAPTER 38\n\nFibonacci\n\nIn answer to a reviewer’s question, I posted a test-driven Fibonacci. Several reviewers commented that this example turned on their light about how test-driven development works. However, it is not long enough, nor does it demonstrate enough of TDD techniques, to replace the existing examples. If your lights are still dark after reading the main examples, take a look here and see.\n\nThe first test shows that fib(0) = 0. The implementation returns a constant.\n\npublic void testFibonacci() { assertEquals(0, fib(0));\n\n}\n\nint fib(int n) { return 0;\n\n}\n\n(I am just using the TestCase class as a home for the code, since it is only a single function.)\n\nThe second test shows that fib(1) = 1.\n\npublic void testFibonacci() { assertEquals(0, fib(0)); assertEquals(1, fib(1));\n\n221\n\n222\n\nFibonacci\n\n}\n\nI just put the second assert in the same method because there didn’t seem to be any substantial communication value to writing “testFibonacciOfOneIsOne”.\n\nThere are several ways I could go to making this run. I’ll choose to treat 0 as a spe- cial case:\n\nint fib(int n) {\n\nif (n == 0) return 0; return 1;\n\n}\n\nThe duplication in the test case is starting to bug me, and it will only get worse as we add new cases. We can factor out the common structure of the assertions by driving the test from a table of input and expected values.\n\npublic void testFibonacci() {\n\nint cases[][]= {{0,0},{1,1}}; for (int i= 0; i < cases.length; i++)\n\nassertEquals(cases[i][1], fib(cases[i][0]));\n\n}\n\nNow adding the next case requires 6 keystrokes and no additional lines:\n\npublic void testFibonacci() {\n\nint cases[][]= {{0,0},{1,1},{2,1}}; for (int i= 0; i < cases.length; i++)\n\nassertEquals(cases[i][1], fib(cases[i][0]));\n\n}\n\nDisconcertingly, the test works. It just so happens that our constant “1” is right for this case as well. On to the next test:\n\npublic void testFibonacci() {\n\nint cases[][]= {{0,0},{1,1},{2,1},{3,2}}; for (int i= 0; i < cases.length; i++)\n\nassertEquals(cases[i][1], fib(cases[i][0]));\n\n}\n\nHooray, it fails. Applying the same strategy as before (treating smaller inputs as special cases), we write:\n\nint fib(int n) {\n\nif (n == 0) return 0; if (n <= 2) return 1; return 2;\n\n}\n\nNow we are ready to generalize. We wrote “2”, but we don’t really mean “2”, we mean “1 + 1”.\n\nint fib(int n) {\n\nif (n == 0) return 0; if (n <= 2) return 1; return 1 + 1;\n\n}\n\nThat first “1” is an example of fib(n-1):\n\nint fib(int n) {\n\nif (n == 0) return 0; if (n <= 2) return 1; return fib(n-1) + 1;\n\n}\n\nThe second “1” is an example of fib(n-2):\n\nint fib(int n) {\n\nif (n == 0) return 0; if (n <= 2) return 1; return fib(n-1) + fib(n-2);\n\n}\n\nCleaning up now, the same structure should work for fib(2), so we can tighten up the second condition:\n\nint fib(int n) {\n\nif (n == 0) return 0; if (n == 1) return 1; return fib(n-1) + fib(n-2);\n\n}\n\nAnd there we have fibonacci, derived totally from the tests.\n\n223\n\n224\n\nFibonacci",
      "page_number": 235
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "content": "Test-DrivenDevelopment ByExample\n\nKent Beck, Three Rivers Institute\n\nCopyright (c) 2002, Kent Beck, All rights reserved Draft July 14, 2002 1:31 pm",
      "content_length": 147,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 3,
      "content": "To Do: Refactorings Opening story To-do lists, cross outs and move them to the margin Glossary definitions Where does factorial example go? Ref Fowler’s new book Cross refs for patterns Code paragraph style throughout Gray keywords Influence diagrams Leading tabs in code private class Pair keyword highlighting Final code formatting Reset to-do lists Bold deltas in code",
      "content_length": 371,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 4,
      "content": "CHAPTER 3\n\nCHAPTER 4\n\nCHAPTER 1\n\nCHAPTER 2\n\nCHAPTER 3\n\nCHAPTER 4\n\nCHAPTER 5\n\nCHAPTER 6\n\nCHAPTER 7\n\nCHAPTER 8\n\nCHAPTER 9\n\nCHAPTER 10\n\nCHAPTER 11\n\nCHAPTER 12\n\nPreface\n\nviii\n\nAcknowledgements\n\nxiv\n\nStory Time\n\n1\n\nSection I: Money Example\n\nMoney Example\n\n7\n\nDegenerate Objects\n\n15\n\nEquality for All\n\n19\n\nPrivacy\n\n23\n\nFranc-ly Speaking\n\n27\n\nEquality for All, Redux\n\n31\n\nApples and Oranges\n\n37\n\nMakin’ Objects\n\n39\n\nTimes We’re Livin’ In\n\n43\n\nInteresting Times\n\n49\n\n5\n\niv",
      "content_length": 464,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 5,
      "content": "v\n\nCHAPTER 13\n\nCHAPTER 14\n\nCHAPTER 15\n\nCHAPTER 16\n\nCHAPTER 17\n\nCHAPTER 18\n\nCHAPTER 19\n\nCHAPTER 20\n\nCHAPTER 21\n\nCHAPTER 22\n\nCHAPTER 23\n\nCHAPTER 24\n\nCHAPTER 25\n\nCHAPTER 26\n\nThe Root of all Evil\n\n55\n\nAddition, Finally\n\n57\n\nMake It\n\n63\n\nChange\n\n71\n\nMixed Currencies\n\n77\n\nAbstraction, Finally\n\n81\n\nMoney Retrospective\n\n85\n\nSection II: xUnit\n\n93\n\nSet the Table\n\n99\n\nCleaning Up After\n\n103\n\nCounting 107\n\nDealing with Failure\n\n111\n\nHow Suite It Is\n\n115\n\nxUnit Retrospective\n\n121",
      "content_length": 471,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 6,
      "content": "CHAPTER 27\n\nCHAPTER 28\n\nCHAPTER 29\n\nCHAPTER 30\n\nCHAPTER 31\n\nCHAPTER 32\n\nCHAPTER 33\n\nCHAPTER 34\n\nCHAPTER 35\n\nCHAPTER 36\n\nCHAPTER 37\n\nCHAPTER 38\n\nSection III: Patterns\n\n123\n\nTest-Driven Development 125 Patterns\n\nRed Bar Patterns\n\n135\n\nTesting Patterns\n\n145\n\nGreen Bar Patterns\n\n153\n\nxUnit Patterns\n\n161\n\nDesign Patterns\n\n171\n\nRefactoring\n\n189\n\nMastering TDD 201\n\nGlossary\n\n215\n\nAppendix 1: Influence Diagrams\n\n217\n\nFibonacci\n\n221\n\nvi",
      "content_length": 431,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 7,
      "content": "vii",
      "content_length": 3,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 8,
      "content": "CHAPTER 3\n\nPreface\n\nClean code that works, in Ron Jeffries’ pithy phrase. The goal is clean code that works, and for a whole bunch of reasons:\n\nClean code that works is a predictable way to develop. You know when you are finished, without having to worry about a long bug trail.\n\nClean code that works gives you a chance to learn all the lessons that the code has to teach you. If you only ever slap together the first thing you think of, you never have time to think of a second, better, thing.\n\nClean code that works improves the lives of users of our software.\n\nClean code that works lets your teammates count on you, and you on them.\n\n(cid:127) Writing clean code that works feels good.\n\nBut how do you get to clean code that works? Many forces drive you away from clean code, and even code that works. Without taking too much counsel of our fears, here’s what we do—drive development with automated tests, a style of devel- opment called “Test-Driven Development” (TDD for short). In Test-Driven Devel- opment, you:\n\n(cid:127) Write new code only if you first have a failing automated test.\n\nEliminate duplication.\n\nTest-Driven Development\n\nviii",
      "content_length": 1150,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 9,
      "content": "ix\n\nPreface\n\nTwo simple rules, but they generate complex individual and group behavior. Some of the technical implications are:\n\n(cid:127) You must design organically, with running code providing feedback between\n\ndecisions\n\n(cid:127) You must write your own tests, since you can’t wait twenty times a day for\n\nsomeone else to write a test\n\n(cid:127) Your development environment must provide rapid response to small changes (cid:127) Your designs must consist of many highly cohesive, loosely coupled compo-\n\nnents, just to make testing easy\n\nThe two rules imply an order to the tasks of programming:\n\n1. Red—write a little test that doesn’t work, perhaps doesn’t even compile at first\n\n2. Green—make the test work quickly, committing whatever sins necessary in the process\n\n3. Refactor—eliminate all the duplication created in just getting the test to work\n\nRed/green/refactor. The TDDs mantra.\n\nAssuming for the moment that such a style is possible, it might be possible to dra- matically reduce the defect density of code and make the subject of work crystal clear to all involved. If so, writing only code demanded by failing tests also has social implications:\n\nIf the defect density can be reduced enough, QA can shift from reactive to pro- active work\n\nIf the number of nasty surprises can be reduced enough, project managers can estimate accurately enough to involve real customers in daily development\n\nIf the topics of technical conversations can be made clear enough, programmers can work in minute-by-minute collaboration instead of daily or weekly collabo- ration\n\n(cid:127) Again, if the defect density can be reduced enough, we can have shippable soft- ware with new functionality every day, leading to new business relationships with customers\n\nSo, the concept is simple, but what’s my motivation? Why would a programmer take on the additional work of writing automated tests? Why would a programmer work in tiny little steps when their mind is capable of great soaring swoops of design? Courage.\n\nTest-Driven Development",
      "content_length": 2038,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 10,
      "content": "Courage\n\nTest-driven development is a way of managing fear during programming. I don’t mean fear in a bad way, pow widdle prwogwammew needs a pacifiew, but fear in the legitimate, this-is-a-hard-problem-and-I-can’t-see-the-end-from-the-beginning sense. If pain is nature’s way of saying “Stop!”, fear is nature’s way of saying “Be careful.” Being careful is good, but fear has a host of other effects:\n\n(cid:127) Makes you tentative (cid:127) Makes you want to communicate less (cid:127) Makes you shy from feedback (cid:127) Makes you grumpy\n\nNone of these effects are helpful when programming, especially when program- ming something hard. So, how can you face a difficult situation and:\n\nInstead of being tentative, begin learning concretely as quickly as possible.\n\nInstead of clamming up, communicate more clearly.\n\nInstead of avoiding feedback, search out helpful, concrete feedback.\n\n(You’ll have to work on grumpiness on your own.)\n\nImagine programming as turning a crank to pull a bucket of water from a well. When the bucket is small, a free-spinning crank is fine. When the bucket is big and full of water, you’re going to get tired before the bucket is all the way up. You need a ratchet mechanism to enable you to rest between bouts of cranking. The heavier the bucket, the closer the teeth need to be on the ratchet.\n\nThe tests in test-driven development are the teeth of the ratchet. Once you get one test working, you know it is working, now and forever. You are one step closer to having everything working than you were when the test was broken. Now get the next one working, and the next, and the next. By analogy, the tougher the program- ming problem, the less ground should be covered by each test.\n\nReaders of Extreme Programming Explained will notice a difference in tone between XP and TDD. TDD isn’t an absolute like Extreme Programming. XP says, “Here are things you must be able to do to be prepared to evolve further.” TDD is a little fuzzier. TDD is an awareness of the gap between decision and feedback dur- ing programming, and techniques to control that gap. “What if I do a paper design for a week, then test-drive the code? Is that TDD?” Sure, it’s TDD. You were aware of the gap between decision and feedback and you controlled the gap deliberately.\n\nTest-Driven Development\n\nx",
      "content_length": 2313,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 11,
      "content": "xi\n\nPreface\n\nThat said, most people who learn TDD find their programming practice changed for good. “Test Infected” is the phrase Erich Gamma coined to describe this shift. You might find yourself writing more tests earlier, and working in smaller steps than you ever dreamed would be sensible. On the other hand, some programmers learn TDD and go back to their earlier practices, reserving TDD for special occa- sions when ordinary programming isn’t making progress.\n\nThere are certainly programming tasks that can’t be driven solely by tests (or at least, not yet). Security software and concurrency, for example, are two topics where TDD is not sufficient to mechanically demonstrate that the goals of the soft- ware have been met. Security relies on essentially defect-free code, true, but also on human judgement about the methods used to secure the software. Subtle concur- rency problems can’t be reliably duplicated by running the code.\n\nOnce you are finished reading this book, you should be ready to:\n\nStart simply\n\n(cid:127) Write automated tests\n\nRefactor to add design decisions one at a time\n\nThis book is organized into three sections.\n\n(cid:127) An example of writing typical model code using TDD. The example is one I got from Ward Cunningham years ago, and have used many times since, multi-cur- rency arithmetic. In it you will learn to write tests before code and grow a design organically.\n\n(cid:127) An example of testing more complicated logic, including reflection and excep- tions, by developing a framework for automated testing. This example also serves to introduce you to the xUnit architecture that is at the heart of many pro- grammer-oriented testing tools. In the second example you will learn to work in even smaller steps than in the first example, including the kind of self-referen- tial hooha beloved of computer scientists.\n\nPatterns for TDD. Included are patterns for the deciding what tests to write, how to write tests using xUnit, and a greatest hits selection of the design patterns and refactorings used in the examples.\n\nI wrote the examples imagining a pair programming session. If you like looking at the map before wandering around, you may want to go straight to the patterns in section 3 and use the examples as illustrations. If you prefer just wandering around and then looking at the map to see where you’ve been, try reading the examples\n\nTest-Driven Development",
      "content_length": 2417,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 12,
      "content": "through and refering to the patterns when you want more detail about a technique, then using the patterns as a reference.\n\nSeveral reviewers have commented they got the most out of the examples when they started up a programming environment and entered the code and ran the tests as they read.\n\nA note about the examples. Both examples, multi-currency calculation and a testing framework, appear simple. There are (and I have seen) complicated, ugly, messy ways of solving the same problems. I could have chosen one of those complicated, ugly, messy solutions, to give the book an air of “reality.” However, my goal, and I hope your goal, is to write clean code that works. Before teeing off on the examples as being too simple, spend 15 seconds imagining a programming world in which all code was this clear and direct, where there were no complicated solutions, only apparently complicated problems begging for careful thought. TDD is a practice that can help you lead yourself to exactly that careful thought.\n\nTest-Driven Development\n\nxii",
      "content_length": 1042,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 13,
      "content": "xiii\n\nPreface\n\nTest-Driven Development",
      "content_length": 38,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 14,
      "content": "CHAPTER 4\n\nAcknowledgements\n\nThanks to all my many brutal and opinionated reviewers. I take full responsibility for the contents, but this book would have been much less readable and useful with- out their help. In the order in which I typed them in, they were: Steve Freeman, Frank Westphal, Ron Jeffries, Dierk König, Edward Hieatt, Tammo Freese, Jim Newkirk, Johannes Link, Manfred Lange, Steve Hayes, Alan Francis, Jonathan Rasmusson, Shane Clauson, Simon Crase, Kay Pentecost, Murray Bishop, Ryan King, Bill Wake, Edmund Schweppe, Kevin Lawrence, John Carter, Phlip, Peter Hansen, Ben Schroeder, Alex Chaffee, Peter van Rooijen, Rick Kawala, Mark van Hamersveld, Doug Swartz, Laurent Bossavit, Ilja Preuß, Daniel Le Berre, Frank Carver, Justin Sampson, Mike Clark, Christian Pekeler, Karl Scotland, Carl Manas- ter, J. B. Rainsberger, Peter Lindberg, Darach Ennis, Kyle Cordes, Justin Sampson, Patrick Logan, Darren Hobbs, Aaron Sansone, Darach Ennis, Syver Enstad, Shi- nobu Kawai, Erik Meade, Patrick Logan, Dan Rawsthorne, Bill Rutiser, Eric Her- man, Paul Chisholm, Asim Jalis, Ivan Moore, Levi Purvis, Rick Mugridge, Anthony Adachi, Nigel Thorne, John Bley, Kari Hoijarvi, Manuel Amago, Kaoru Hosokawa, Pat Eyler, Ross Shaw, Sam Gentle, Jean Rajotte, Phillipe Antras, Jaime Nino,\n\nTo all of the programmers I’ve test-driven code with, I certainly appreciate your patience going along with what was a pretty crazy sounding idea, especially in the early years. I’ve learned far more from you all than I could ever think of myself. Not wishing to offend everyone else, but Massimo Arnoldi, Ralph Beattie, Ron Jef-\n\nxiv",
      "content_length": 1625,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 15,
      "content": "xv\n\nAcknowledgements\n\nfries, Martin Fowler, and last but certainly not least Erich Gamma stand out in my memory as test drivers from whom I’ve learned much.\n\nI would like to thank Martin Fowler for timely Framemaker help. He must be the highest-paid typesetting consultant on the planet, but fortunately he has let me (so far) run a tab.\n\nMy life as a real programmer started with patient mentoring from and continuing collaboration with Ward Cunningham. Sometimes I see TDD as an attempt to give any programmer, working in any environment, the sense of comfort and intimacy we had with our Smalltalk environment and our Smalltalk programs. There is no way to sort out the source of ideas once two people have shared a brain. If you assume all the good ideas here are Ward’s, you won’t be far wrong.\n\nIt is a bit of a cliché to recognize the sacrifices a family makes once one of its mem- bers catches the peculiar mental affliction that results in a book. It is a cliché because family sacrifices are as necessary to book writing as paper. To my children who waited breakfast until I could finish a chapter, and most of all to my wife who spent two months saying everything three times, my profoundest and least adequate thanks.\n\nFinally, to the unknown author of the book which I read as a weird 12-year-old that suggested you type in the expected output tape from a real input tape, then code until the actual results matched the expected result, thank you, thank you, thank you.",
      "content_length": 1482,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 16,
      "content": "CHAPTER 1\n\nStoryTime\n\nEarly one Friday the boss came to Ward to introduce him to Peter, a prospective customer for WyCash, the bond portfolio management system they were selling. Peter said, “I’m very impressed with the functionality I see. However, I notice you only handle US dollar denominated bonds. I’m starting a new bond fund and my strategy requires that I handle bonds in different currencies.” The boss turned to Ward, “Well, can we do it?”\n\nHere is the nightmare scenario for any software designer. You have been cruising along happily and successfully with a set of assumptions. Suddenly, everything changes. And the nightmare wasn’t just for Ward. The boss, an experienced hand at directing software development, wasn’t sure what the answer was going to be.\n\nWyCash had been developed over the course of a couple of years by a small team. It was able to handle most of the varieties of fixed income securities commonly found on the US market, and a few exotic new instruments, like Guaranteed Invest- ment Contracts, that the competition couldn’t handle.\n\nWyCash had been developed all along using objects and an object database. The fundamental abstraction of computation, Dollar, had been outsourced at the begin- ning to a clever group of programmers. The resulting object combined formatting and calculation responsibilities.\n\n1",
      "content_length": 1345,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 17,
      "content": "2\n\nStory Time\n\nFor the last six months, Ward and the rest of the team had been slowly divesting Dollar of its responsibilities. The Smalltalk numerical classes turned out to be just fine at calculation. All the tricky code for rounding to three decimal digits got in the way of producing precise answers. As the answers got more precise, the compli- cated mechanisms in the testing framework for comparing to within a certain toler- ance were replaced by precise matching of expected and actual results.\n\nResponsibility for formatting actually belonged in the user interface classes. As the tests were written at the level of the user interface classes, in particular the report framework1, these tests didn’t have to change to accomodate this refinement. After six months of careful paring, the resulting Dollar didn’t have much responsibility left.\n\nOne of the most complicated algorithms in the system, weighted average, had like- wise been undergoing a slow transformation. At one time there had been many dif- ferent variations of weighted average code scattered throughout the system. As the report framework coalesced from the primodial object soup, it was obvious that there could be one home for the algorithm, in AveragedColumn.\n\nIt was to AveragedColumn that Ward now turned. If weighted averages could be made multi-currency, the rest of the system should be possible. The heart of the algorithm was keeping a count of the money in the column. In fact, the algorithm had been abstracted enough to calculate the weighted average of any object that could act arithmetic. You could have weighted averages of dates, for example.\n\nThe weekend past in the usual weekend activities. Monday morning the boss was back. “Can we do it?” “Give me another day and I’ll tell you for sure.”\n\nSince Dollar acted like a counter in weighted average, in order to calculate in multi- ple currencies they needed an object with a counter per currency, kind of like a polynomial. Instead of 3x2 and 4y3, though, the terms would be 15 USD and 200 CHF.\n\nA quick experiment showed that it was possible to compute with a generic Cur- rency object instead of a Dollar, and return a PolyCurrency when two un-alike cur- rencies were added together. The trick now was to make space for the new functionality without breaking anything that already worked. What would happen if Ward just ran the tests?\n\n1. For more on the report framework, see c2.com/doc/oopsla91.html",
      "content_length": 2448,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 18,
      "content": "After adding a few un-implemented operations to Currency, the bulk of the tests passed. By the end of the day, all the tests were passing. Ward checked the code into the build and went to the boss. “We can do it,” he said confidently.\n\nLet’s think a bit about this story. In two days, the potential market was multiplied several fold, multiplying the value of WyCash several fold. The ability to create so much business value so quickly was no accident though. Several factors came into play:\n\n(cid:127) Method—Ward and the WyCash team needed to have constant experience\n\ngrowing the design of the system little-by-little, so the mechanics of the trans- formation were well practiced.\n\n(cid:127) Motive—Ward and team had to understand clearly from the business the impor- tance of making WyCash multi-currency, and to have the courage to start such a seemingly impossible task.\n\n(cid:127) Opportunity— The combination of comprehensive, confidence-generating tests; a well-factored program; and a programming language that made it possible to isolate design decisions meant that there were few sources of error, and those errors were easy to identify.\n\nYou can’t control whether you ever get the motive to multiply the value of your project by spinning technical magic. Method and opportunity, however, are entirely under your control. Ward and his team created method and opportunity by a combi- nation of superior talent, experience, and discipline. Does this mean that if you are not one of the ten best software engineers on the planet and you don’t have a wad of cash in the bank so you can tell your boss to take a hike, you’re going to take the time to do this right, that such moments are forever beyond your reach?\n\nNo. You absolutely can place your projects in a position for you to work magic, even if you are a programmer with ordinary skills and you sometimes buckle under and take shortcuts when the pressure builds. Test-driven development is a set of techniques any programmer can follow, that encourage simple designs and test suites that inspire confidence. If you are a genius, you don’t need these rules. If you are a dolt, the rules won’t help. For the vast majority of us in between, though, fol- lowing these two simple rules can lead us to work much closer to our potential:\n\n(cid:127) Write a failing automated test before you write any code\n\nRemove duplication\n\n3",
      "content_length": 2388,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 19,
      "content": "4\n\nStory Time\n\nHow exactly to do this, the subtle gradations in applying these rules, and the lengths to which you can push these two simple rules are the topic of this book. We’ll start with the object Ward created in his moment of inspiration—multi-currency money.",
      "content_length": 266,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 20,
      "content": "CHAPTER 2\n\nSectionI:Money Example\n\nIn this section we will develop typical model code completely driven by tests (except when we slip, purely for educational purposes). My goal is for you to see the rhythm of test-driven development:\n\n1. Quickly add a test\n\n2. Run all tests and see the new one fail\n\n3. Make a little change\n\n4. Run all tests and see them all succeed\n\n5. Refactor to remove duplication\n\nThe surprises are likely to be:\n\n(cid:127) How each test can cover a small increment of functionality (cid:127) How small and ugly the changes can be to make the new tests run (cid:127) How often the tests are run (cid:127) How many teensy tiny steps make up the refactorings\n\n5",
      "content_length": 682,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 21,
      "content": "6\n\nSection I: Money Example",
      "content_length": 27,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 22,
      "content": "CHAPTER 3\n\nMoneyExample\n\nWe’ll start with the object Ward created at WyCash, multi-currency money. Sup- pose we have a report like this:\n\nInstrument\n\nShares\n\nPrice\n\nTotal\n\nIBM\n\n1000\n\n25\n\n25000\n\nGE\n\n400\n\n100\n\n40000\n\nTotal:\n\n65000\n\nTo make a multi-currency report, we need to add currencies:\n\nInstrument\n\nShares\n\nPrice\n\nTotal\n\nIBM\n\n1000\n\n25 USD\n\n25000 USD\n\nNovartis\n\n400\n\n150 CHF\n\n60000 CHF\n\nTotal:\n\n65000 USD\n\nWe also need to specify exchange rates:\n\n7",
      "content_length": 451,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 23,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10\n\n8\n\nMoney Example\n\nFrom\n\nTo\n\nRate\n\nCHF\n\nUSD\n\n1.5\n\nWhat behavior will we need to produce the revised report? Put another way, what is the set of tests which, when passed, will demonstrate the presence of code we are confident will compute the report correctly?\n\n(cid:127) We need to be able to add amounts in two different currencies and convert the\n\nresult given a set of exchange rates.\n\n(cid:127) We need to be able to multiply an amount (price per share) by a number (num-\n\nber of shares) and receive an amount.\n\nWe’ll make a to-do list to remind us what all we need to do, keep us focused, and tell us when we are finished. When we start working on an item, we’ll make it bold, like this. When we finish an item we’ll cross it off, like this. When we think of another test to write, we’ll add it to the list.\n\nAs you can see from the list, we’ll work on multiplication first. So, what object do we need first? Trick question. We don’t start with objects, we start with tests (I keep having to remind myself of this, so I will pretend you are as dense as I am).\n\nTry again. What test do we need first? Looking at the list, that first test looks com- plicated. Start small or not at all. Multiplication, how hard could that be? We’ll work on that first.\n\nWhen we write a test, we imagine the perfect interface for our operation. We are telling ourselves a story about how the operation will look from the outside. Our story won’t always come true, but better to start from the best possible API and work backwards than to make things complicated, ugly, and “realistic” from the get go.\n\nHere’s a simple example of multiplication:\n\npublic void testMultiplication() { Dollar five= new Dollar(5); five.times(2); assertEquals(10, five.amount);\n\n}",
      "content_length": 1790,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 24,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding?\n\n(I know, I know, public fields, side-effects, integers for monetary amounts and all that. Small steps. We’ll make a note of the stinkiness and move on. We have a fail- ing test and we want it to go green as quickly as possible.)\n\nThe test we just typed in (I’ll explain where and how we type it in later, when we talk more about JUnit) doesn’t even compile. That’s easy enough to fix. What’s the least we can do to get it to compile, even if it doesn’t run? We have four compile errors:\n\n(cid:127) No class “Dollar” (cid:127) No constructor (cid:127) No method “times(int)” (cid:127) No field “amount”\n\nLet’s take them one at a time (I always search for some numerical measure of progress). We can get rid of one error by defining the class Dollar:\n\nDollar\n\nclass Dollar\n\n3 errors. Now we need the constructor, but it doesn’t have to do anything just to get the test to compile:\n\nDollar\n\nDollar(int amount) { }\n\n2 errors. We need a stub implementation of times(). Again we’ll do the least work possible just to get the test to compile:\n\nDollar\n\nvoid times(int multiplier) { }\n\n1 error. Finally, we need an amount field:\n\nDollar\n\nint amount;\n\nTest Driven Development\n\n9",
      "content_length": 1274,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 25,
      "content": "10\n\nMoney Example\n\nBingo! Now we can run the test and watch it fail.\n\nYou are seeing the dreaded red bar. Our testing framework (JUnit, in this case) has run the little snippet of code we started with, and noticed that although we expected “10” as a result, we saw “0”. Sadness.\n\nNo, no. Failure is progress. Now we have a concrete measure of failure. That’s bet- ter than just vaguely knowing we are failing. Our programming problem has been transformed from “give me multi-currency” to “make this test work, and then make the rest of the tests work.” Much simpler. Much smaller scope for fear. We can make this test work.",
      "content_length": 623,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 26,
      "content": "You probably aren’t going to like the solution, but the goal right now is not to get the perfect answer, the goal is to pass the test. We’ll make our sacrifice at the altar of truth and beauty later.\n\nHere’s the smallest change I could imagine that would cause our test to pass:\n\nDollar\n\nint amount= 10;\n\nNow we get the green bar, fabled in song and story.\n\nOh joy, oh rapture! Not so fast, hacker boy (or girl). The cycle isn’t complete. There are very few inputs in the world that will cause such a limited, such a smelly,\n\nTest Driven Development\n\n11",
      "content_length": 553,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 27,
      "content": "12\n\nMoney Example\n\nsuch a naïve implementation to pass. We need to generalize before we move on. Remember, the cycle is:\n\n1. Add a little test\n\n2. Run all tests and fail\n\n3. Make a little change\n\n4. Run the tests and succeed\n\n5. Refactor to remove duplication\n\nSidebar: Dependency and Duplication\n\nSteve Freeman pointed out that the problem with the test and code as it sits is not duplication (which I have not yet pointed out to you, but I promise to as soon as this digression is over.) The problem is the dependency between the code and the test— you can’t change one without changing the other. Our goal is to be able to write another test that “makes sense” to us, without having to change the code, something that is not possible with the current implementation.\n\nDependency is the key problem in software development at all scales. If you have details of one vendor’s implementation of SQL scattered throughout the code and you decide to change to another vendor, you will discover that your code is depen- dent on the database vendor. You can’t change the database without changing the code.\n\nIf dependency is the problem, duplication is the symptom. Duplication most often takes the form of duplicate logic—the same expression appearing in multiple places in the code. Objects are excellent for abstracting away the duplication of logic.\n\nUnlike most problems in life, where eliminating the symptoms only makes the problem pop up elsewhere in worse form, eliminating duplication in programs eliminates dependency. That’s why the second rule appears in TDD. By eliminating duplication before we go on to the next test, we maximize our chance of being able to get the next test running with one and only one change.\n\nNow back to your regularly scheduled puzzling example.\n\nWe have run items 1-4. Now we are ready to remove duplication. But where is the duplication? Usually you see duplication between two pieces of code. Here the duplication is between the data in the test and the data in the code. Don’t see it? How about if we write?",
      "content_length": 2045,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 28,
      "content": "Dollar\n\nint amount= 5 * 2;\n\nThat “10” had to come from somewhere. We did the multiplication in our heads so fast we didn’t even notice. The “5” and “2” are now in two places, and we must ruthlessly eliminate duplication before moving on. The rules say so.\n\nThere isn’t a single step that will eliminate the 5 and 2. However, what if we move the setting of the amount from object initialization to the times() method?\n\nDollar\n\nint amount;\n\nvoid times(int multiplier) { amount= 5 * 2;\n\n}\n\nThe test still passes, the bar stays green. Happiness is still ours.\n\nDo these steps seem too small to you? Remember, TDD is not about taking teensy tiny steps, it’s about being able to take teensy tiny steps. Would I code day-to-day with steps this small? No. But when things get the least bit weird, I’m glad I can. Try teensy tiny steps with an example of your own choosing. If you can make steps too small, you can certainly make steps the right size. If you only take larger steps, you’ll never know if smaller steps are appropriate.\n\nDefensiveness aside, where were we? Ah, yes, we were getting rid of duplication between the test code and the working code. Where can we get a 5? That was the value passed to the constructor, so if we save it in the amount variable:\n\nDollar\n\nDollar(int amount) {\n\nthis.amount= amount;\n\n}\n\nwe can use it in times():\n\nDollar\n\nvoid times(int multiplier) { amount= amount * 2;\n\n}\n\nTest Driven Development\n\n13",
      "content_length": 1431,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 29,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding?\n\n14\n\nMoney Example\n\nThe value of the parameter “multiplier” is 2, so we can substitute the parameter for the constant:\n\nDollar\n\nvoid times(int multiplier) {\n\namount= amount * multiplier;\n\n}\n\nTo demonstrate our thorough-going knowledge of Java syntax, we will want to use the “*=” operator (which does, it must be said, reduce duplication):\n\nDollar\n\nvoid times(int multiplier) { amount *= multiplier;\n\n}\n\nWe can now mark off the first test as done. Next we’ll take care of those strange side effects. First, though, let’s review. We:\n\n(cid:127) Made a list of the tests we knew we needed to have working\n\nTold a story with a snippet of code about how we wanted to view one operation\n\nIgnored the details of JUnit for the moment\n\n(cid:127) Made the test compile with stubs (cid:127) Made the test run by committing horrible sins (cid:127) Gradually generalized the working code, replacing constants with variables (cid:127) Added items to our to-do list rather than addressing them all at once",
      "content_length": 1096,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 30,
      "content": "CHAPTER 4\n\nDegenerateObjects\n\nThe general TDD cycle is:\n\n1. Write a test. Think about how you would like the operation in your mind to appear in your code. You are writing a story. Invent the interface you wish you had. Include all the elements in the story that you imagine will be necessary to calculate the right answers.\n\n2. Make it run. Quickly getting that bar green dominates everything else. If a clean, simple solution is obvious, type it in. If the clean, simple solution is obvi- ous but it will take you a minute, make a note of it and get back to the main problem, which is getting the bar green in seconds. This shift in aesthetics is hard for some experienced software engineers. They only know how to follow the rules of good engineering. Quick green excuses all sins. But only for a moment.\n\n3. Make it right. Now that the system is behaving, put the sinful ways of the recent past behind you. Step back onto the straight and narrow path of software righ- teousness. Remove the duplication that you have introduced to get to quick green.\n\nThe goal is clean code that works (thanks to Ron Jeffries for this pithy summary). Clean code that works is out of the reach of even the best programmers some of the time, and out of the reach of most programmers (like me) most of the time. Divide and conquer, baby. First we’ll solve the “that works” part of the problem. Then we’ll solve the “clean code” part. (This is the opposite of architecture-driven devel-\n\n15",
      "content_length": 1474,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 31,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding?\n\n16\n\nDegenerate Objects\n\nopment, where you solve “clean code” first, then scramble around trying to inte- grate into the design the things you learn as you solve the “that works” problem.)\n\nWe got one test working, but in the process we noticed something strange—when we perform an operation on a Dollar, the Dollar changes. I would like to be able to write:\n\npublic void testMultiplication() { Dollar five= new Dollar(5); five.times(2); assertEquals(10, five.amount); five.times(3); assertEquals(15, five.amount);\n\n}\n\nI can’t imagine a clean way to get this test working. After the first call to times(), five isn’t five any more, it’s really ten. If, however, we return a new object from times(), we can multiply our original five bucks all day and never have it change. We are changing the interface of Dollar when we make this change, so we have to change the test. That’s okay. Our guesses about the right interface are no more likely to be perfect than our guesses about the right implementation.\n\npublic void testMultiplication() { Dollar five= new Dollar(5); Dollar product= five.times(2); assertEquals(10, product.amount); product= five.times(3); assertEquals(15, product.amount);\n\n}\n\nThe new test won’t compile until we change the declaration of Dollar.times():\n\nDollar\n\nDollar times(int multiplier) { amount *= multiplier; return null;\n\n}\n\nNow the test compiles, but it doesn’t run. Progress! Making it run requires that we return a new Dollar with the correct amount:",
      "content_length": 1584,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 32,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding?\n\nDollar\n\nDollar times(int multiplier) {\n\nreturn new Dollar(amount * multiplier);\n\n}\n\nIn the last chapter when we made a test work we started with a bogus implementa- tion and gradually made it real. Here, we typed in what we thought was the right implementation and prayed while the tests ran (short prayers, to be sure, because running the test takes a few milliseconds.) Because we got lucky and the test ran, we can cross off another item.\n\nThese are two of the three strategies I know for quickly getting to green:\n\nFake It—return a constant and gradually replace constants with variables until you have the real code\n\n(cid:127) Obvious Implementation—type in the real implementation\n\nWhen I use TDD in practice, I commonly shift between these two modes of imple- mentation. When everything is going smoothly and I know what to type, I put in obvious implementation after obvious implementation (running the tests all the time to ensure that what’s obvious to me is still obvious to the computer). As soon as I get an unexpected red bar, I back up, shift to faking implementations, and refactor to the right code. When my confidence is back, I go back to obvious imple- mentations.\n\nThere is a third style of test-driving development, triangulation, which we will demonstrate in the next chapter. However, to review, we:\n\nTranslated a design objection (side effects) into a test case that failed because of the objection\n\n(cid:127) Got the code to compile quickly with a stub implementation (cid:127) Made the test work by typing in what seemed like the right code\n\nThe translation of a feeling (disgust at side effects) into a test (multiply the same Dollar twice) is a common theme of TDD. The longer I do this, the better able I am to translate my aesthetic judgements into tests. When I can do this, my design dis- cussions become much more interesting. First we can talk about whether the system should work like this or like that. Once we decide on the correct behavior, we can talk about the best way of achieving that behavior. We can speculate about truth\n\n17",
      "content_length": 2177,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 33,
      "content": "18\n\nDegenerate Objects\n\nand beauty all we want over beers, but while we are programming we can leave airy-fairy discussions behind and talk cases.",
      "content_length": 146,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 34,
      "content": "CHAPTER 5\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? Equals()\n\nEqualityforAll\n\nIf I have an integer and I add 1 to it, I don’t expect the original integer to change, I expect to use the new value. Objects usually don’t behave that way. If I have a Con- tract and I add one to its coverage, the Contract’s coverage should change (yes, yes, subject to all sorts of interesting business rules which do not concern us here.)\n\nWe can use objects as values, as we are using our Dollar now. The pattern for this is Value Object. One of the constraints on Value Objects is that the values of the instance variables of the object never change once they have been set in the con- structor.\n\nThere is one huge advantage to using value objects—you don’t have to worry about aliasing problems. Say I have one Check and I set its amount to $5, and then I set another Check’s amount to the same $5. Some of the nastiest bugs in my career have come when changing the first Check’s value inadvertently changed the second Check’s value. This is aliasing.\n\nWhen you have value objects, you don’t have to worry about aliasing. If I have $5, I am guaranteed that it will always and forever be $5. If someone wants $7, they have to make an entirely new object.\n\nOne implication of Value Object is all operations must return a new object, as we saw in the previous chapter. Another implication is that value objects should imple- ment equals(), since one $5 is pretty much as good as another.\n\n19",
      "content_length": 1536,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 35,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode()\n\n20\n\nEquality for All\n\nIf you use Dollars as the key to a hash table, you have to implement hashCode() if you implement equals(). We’ll put that in the list, too, and get to it when it’s a prob- lem.\n\nYou aren’t thinking about the implementation of equals(), are you? Good. Me nei- ther. After snapping the back of my hand with a ruler, I’m thinking about how to test equality. First, $5 should equal $5:\n\npublic void testEquality() {\n\nassertTrue(new Dollar(5).equals(new Dollar(5)));\n\n}\n\nThe bar turns obligingly red. The fake implementation is to just return true:\n\nDollar\n\npublic boolean equals(Object object) {\n\nreturn true;\n\n}\n\nYou and I both know that “true” is really “5 == 5” which is really “amount == 5” which is really “amount == dollar.amount”. If I went through these steps, though, I wouldn’t be able to demonstrate the third and most conservative implementation strategy, triangulation.\n\nIf two receiving stations at a known distance from each other can both measure the direction of a radio signal, there is enough information to calculate the range and bearing of the signal (if you remember more trigonometry than I do, anyway.) This calculation is called triangulation.\n\nBy analogy, when we Triangulate, we only generalize code when we have two or more examples. We briefly ignore the duplication between test and model code. When the second example demands a more general solution, then and only then do we generalize.\n\nSo, to triangulate we need a second example. How about $5 != $6?\n\npublic void testEquality() {\n\nassertTrue(new Dollar(5).equals(new Dollar(5))); assertFalse(new Dollar(5).equals(new Dollar(6)));\n\n}\n\nNow we need to generalize equality:",
      "content_length": 1799,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 36,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode()\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object\n\nDollar\n\npublic boolean equals(Object object) { Dollar dollar= (Dollar) object; return amount == dollar.amount;\n\n}\n\nWe could have used triangulation to drive the generalization of times(), also. If we had $5 x 2 = $10 and $5 x 3 = $15 we would no longer have been able to return a constant.\n\nTriangulation feels funny to me. I only use it when I am completely unsure of how to refactor. If I can see how to eliminate duplication between code and tests and create the general solution, I just do it. Why would I need to write another test to give me permission to write what I probably could have written the first time?\n\nHowever, when the design thoughts just aren’t coming, triangulation gives you a chance to think about the problem from a slightly different direction. What axes of variability are you trying to support in your design? Make some of the them vary and the answer may become clearer.\n\nSo, equality is done for the moment. (What about comparing with null and compar- ing with other objects? These are commonly used operations, but not necessary at the moment, so we’ll them to the list.)\n\nNow that we have equality, we can directly compare Dollars to Dollars. That will let us make amount private, as all good instance variables should be. Reviewing the above, though, we:\n\n(cid:127) Noticed that our design pattern (Value Object) implied an operation\n\nTested for that operation\n\nImplemented it simply\n\n(cid:127) Didn’t refactor immediately, but instead tested further\n\nRefactored to capture the two cases at once\n\n21",
      "content_length": 1808,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 37,
      "content": "22\n\nEquality for All",
      "content_length": 20,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 38,
      "content": "CHAPTER 6\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object\n\nPrivacy\n\nNow that we have defined equality, we can use it to make out tests more “speak- ing”. Conceptually, the operation Dollar.times() should return a Dollar whose value is the value of the receiver times the multiplier. Our test doesn’t exactly say that:\n\npublic void testMultiplication() { Dollar five= new Dollar(5); Dollar product= five.times(2); assertEquals(10, product.amount); product= five.times(3); assertEquals(15, product.amount);\n\n}\n\nWe can rewrite the first assertion to compare Dollars to Dollars.\n\npublic void testMultiplication() { Dollar five= new Dollar(5); Dollar product= five.times(2); assertEquals(new Dollar(10), product); product= five.times(3); assertEquals(15, product.amount);\n\n}\n\nThat looks better, so we rewrite the second assertion, too:\n\n23",
      "content_length": 936,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 39,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object\n\n24\n\nPrivacy\n\npublic void testMultiplication() { Dollar five= new Dollar(5); Dollar product= five.times(2); assertEquals(new Dollar(10), product); product= five.times(3); assertEquals(new Dollar(15), product);\n\n}\n\nNow the temporary variable “product” isn’t helping much, so we can inline it:\n\npublic void testMultiplication() { Dollar five= new Dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));\n\n}\n\nThis test speaks to us more clearly, as if it were an assertion of truth, not a sequence of operations.\n\nWith these changes to the test, Dollar is now the only class using its “amount” instance variable, so we can make it private:\n\nDollar\n\nprivate int amount;\n\nAnd we can cross another item off the list. Notice that we have opened ourselves up to a risk. If the test for equality fails to accurately check that equality is working, the test for multiplication could also fail to accurately check that multiplication is working. That is a risk you actively manage in TDD. We aren’t striving for perfec- tion. By saying everything two ways, as both code and tests, we hope to reduce our defects enough to move forward with confidence. From time to time our reasoning will fail us and a defect will slip through. When that happens, we learn our lesson about the test we should have written and move on. The rest of the time we go for- ward boldly under our bravely flapping green bar (my bar doesn’t actually flap, but one can dream.)\n\nReviewing, we:\n\n(cid:127) Used functionality just developed to improve a test (cid:127) Noticed that if two tests fail at once we’re sunk\n\nProceeded in spite of the risk",
      "content_length": 1802,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 40,
      "content": "(cid:127) Used new functionality in the object under test to reduce coupling between the\n\ntests and the code\n\n25",
      "content_length": 112,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 41,
      "content": "26\n\nPrivacy",
      "content_length": 11,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 42,
      "content": "CHAPTER 7\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF\n\nFranc-lySpeaking\n\nHow are we going to approach the first test on that list? That’s the test that’s most interesting. It still seems to be a big leap. I’m not sure I can write a test that I can implement in one little step. A pre-requisite seems to be having an object like Dol- lar, but to represent Francs. If we can get Francs working like Dollars work now, we’ll be closer to being able to write and run the mixed addition test.\n\nWe can copy and edit the Dollar test:\n\npublic void testFrancMultiplication() {\n\nFranc five= new Franc(5); assertEquals(new Franc(10), five.times(2)); assertEquals(new Franc(15), five.times(3));\n\n}\n\n(Aren’t you glad we simplified the test in the last chapter? That made our job here easier. Isn’t it amazing how often things work out like this in books? I didn’t actu- ally plan it that way this time, but I won’t make promises for the future.)\n\nWhat short step will get us to a green bar? Copying the Dollar code and replacing “Dollar” with “Franc”.\n\nStop. Hold on. I can hear the aesthetically inclined among you sneering and spit- ting. Copy and paste reuse? The death of abstraction? The killer of clean design?\n\n27",
      "content_length": 1331,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 43,
      "content": "28\n\nFranc-ly Speaking\n\nIf you’re upset, take a cleansing breath. In through the nose…hold it 1 2 3…out through the mouth. There. Remember, our cycle has different phases (they go by quickly, often in seconds, but they are phases.):\n\n1. Write a test\n\n2. Make it compile\n\n3. Run it to see that it fails\n\n4. Make it run\n\n5. Remove duplication\n\nThe different phases have different purposes. They call for different styles of solu- tion, different aesthetic viewpoints. The first three phases need to go by quickly, so we get to a known state with the new functionality. You can commit any number of sins to get there, because speed trumps design, just for that brief moment.\n\nNow I’m worried. I’ve given you a license to abandon all the principles of good design. Off you go to your teams—“Kent says all that design stuff doesn’t matter.” Halt. The cycle is not complete. A four legged Aeron chair falls over. The first four steps of the cycle won’t work without the fifth. Good design at good times. Make it run, make it right.\n\nThere, I feel better. Now I’m sure you won’t show anyone except your partner your code until you’ve removed the duplication. Where were we? Ah, yes. Violating all the tenets of good design in the interest of speed (penance for our sin will occupy the next several chapters.)\n\nFranc\n\nclass Franc {\n\nprivate int amount;\n\nFranc(int amount) {\n\nthis.amount= amount;\n\n}\n\nFranc times(int multiplier) {\n\nreturn new Franc(amount * multiplier);\n\n}\n\npublic boolean equals(Object object) { Franc franc= (Franc) object; return amount == franc.amount;",
      "content_length": 1563,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 44,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times\n\n}\n\n}\n\nBecause the step to running code was so short, we were even able to skip the “make it compile” step.\n\nNow we have duplication galore, and we have to eliminate it before writing our next test. We’ll start by generalizing equals(). However, we can cross off an item, even though we have to add two more. Reviewing, we:\n\nCouldn’t tackle a big test, so we invented a small test that represented progress\n\n(cid:127) Wrote the test by shamelessly duplicating and editing\n\nEven worse, made the test work by copying and editing model code wholesale\n\nPromised ourselves we wouldn’t go home until the duplication was gone\n\n29",
      "content_length": 842,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 45,
      "content": "30\n\nFranc-ly Speaking",
      "content_length": 21,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 46,
      "content": "CHAPTER 8\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times\n\nEqualityforAll,Redux\n\nThere is a fabulous sequence in Wallace Stegner’s Crossing to Safety where he describes a character’s workshop. Every item is perfectly in place, the floor is spot- less, all is order and cleanliness. The character, however, has never made anything. “Preparing has been his life’s work. He prepares, then he cleans up.” (This is also the book, the ending of which sent me audibly blubbering in business class on a trans-Atlantic 747. Read with caution.)\n\nWe have avoided this trap in the last chapter. We actually got a new test case work- ing. However, we sinned mightily in copying and pasting tons of code so we could do it quickly. Now it is time to clean up.\n\nOne possibility is to make one of our classes extend the other. I tried it, and it hardly saves any code at all. Instead, we are going to find a common superclass for the two classes (I tried this already, too, and it works out great, although it will take a while.)\n\nDollar\n\nMoney\n\nFranc\n\nDollar\n\nFranc\n\n31",
      "content_length": 1226,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 47,
      "content": "32\n\nEquality for All, Redux\n\nWhat if we had a Money class to capture the common equals code? We can start small:\n\nMoney\n\nclass Money\n\nAll the tests still run (not that we could possibly have broken anything, but that’s a good time to run the tests anyway.)\n\nIf Dollar extends Money, that can’t possibly break anything.\n\nDollar\n\nclass Dollar extends Money {\n\nprivate int amount;\n\n}\n\nCan it? No, the tests still all run. Now we can move the “amount” instance variable up to Money:\n\nMoney\n\nclass Money {\n\nprotected int amount;\n\n} Dollar\n\nclass Dollar extends Money { }\n\nThe visibility has to change from private to protected so the subclass can still see it. (If we’d wanted to go even slower we could have declared the field in Money in one step, and then removed it from Dollar in a second step. I’m feeling bold.)\n\nNow we can work on getting the equals() code ready to move up. First we change the declaration of the temporary variable:\n\nDollar\n\npublic boolean equals(Object object) { Money dollar= (Dollar) object; return amount == dollar.amount;\n\n}\n\nAll the tests still run. Now we change the cast:",
      "content_length": 1100,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 48,
      "content": "Dollar\n\npublic boolean equals(Object object) { Money dollar= (Money) object; return amount == dollar.amount;\n\n}\n\nTo be communicative, we should also change the name of the temporary variable:\n\nDollar\n\npublic boolean equals(Object object) {\n\nMoney money= (Money) object; return amount == money.amount;\n\n}\n\nNow we can move it from Dollar to Money:\n\nMoney\n\npublic boolean equals(Object object) { Money money= (Money) object; return amount == money.amount;\n\n}\n\nNow we need to eliminate Franc.equals(). First we notice that the tests for equality don’t cover comparing Francs to Francs. Our sins in copying code are catching up with us. Before we change the code, we’ll write the tests that should have been there in the first place.\n\nYou will often be TDDing in code that doesn’t have adequate tests (at least for the next decade or so). When you don’t have enough tests, you are bound to come across refactorings that aren’t supported by tests. You could make a refactoring mistake and the tests would all still run. What do you do?\n\nWrite the tests you wish you had. If you don’t, you will eventually break something while refactoring. Then you’ll get bad feelings about refactoring and stop doing it so much. Then your design will deteriorate. You’ll be fired. Your dog will leave you. You will stop paying attention to your nutrition. Your teeth will go bad. So, to keep your teeth healthy, retroactively test before refactoring.\n\nFortunately, here the tests are easy to write. We just copy the tests for Dollar:\n\npublic void testEquality() {\n\n33",
      "content_length": 1546,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 49,
      "content": "34\n\nEquality for All, Redux\n\nassertTrue(new Dollar(5).equals(new Dollar(5))); assertFalse(new Dollar(5).equals(new Dollar(6))); assertTrue(new Franc(5).equals(new Franc(5))); assertFalse(new Franc(5).equals(new Franc(6)));\n\n}\n\nMore duplication, two lines more! We’ll atone for these sins, too.\n\nTests in place, we can have Franc extend Money:\n\nFranc\n\nclass Franc extends Money { private int amount;\n\n}\n\nWe can delete Franc’s field “amount” in favor of the one in Money:\n\nFranc\n\nclass Franc extends Money { }\n\nFranc.equals() is almost the same as Money.equals(). If we make them precisely the same, we can delete the implementation in Franc without changing the meaning of the program. First we change the declaration of the temporary variable:\n\nFranc\n\npublic boolean equals(Object object) { Money franc= (Franc) object; return amount == franc.amount;\n\n}\n\nThen we change the cast:\n\nFranc\n\npublic boolean equals(Object object) { Money franc= (Money) object; return amount == franc.amount;\n\n}\n\nDo we really have to change the name of the temporary variable to match the super- class? I’ll leave it up to your conscience… Okay, we’ll do it:",
      "content_length": 1136,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 50,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars\n\nFranc\n\npublic boolean equals(Object object) {\n\nMoney money= (Money) object; return amount == money.amount;\n\n}\n\nNow there is no difference between Franc.equals() and Money.equals(), so we delete the redundant implementation in Franc. And run the tests. They run.\n\nWhat happens when we compare Francs and Dollars? We’ll get to that in the next chapter. Reviewing what we did here, we:\n\nStepwise moved common code from one class (Dollar) to a superclass (Money)\n\n(cid:127) Made a second class (Franc) also a subclass\n\nReconciled two implementations (equals()) before eliminating the redundant one\n\n35",
      "content_length": 844,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 51,
      "content": "36\n\nEquality for All, Redux",
      "content_length": 27,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 52,
      "content": "CHAPTER 9\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars\n\nApplesandOranges\n\nThe thought struck us at the end of the last chapter—what happens when we com- pare Francs and Dollars? We dutifully turned our dreadful thought into an item on our to-do list. But we just can’t get it out of our heads. What does happen?\n\npublic void testEquality() {\n\nassertTrue(new Dollar(5).equals(new Dollar(5))); assertFalse(new Dollar(5).equals(new Dollar(6))); assertTrue(new Franc(5).equals(new Franc(5))); assertFalse(new Franc(5).equals(new Franc(6))); assertFalse(new Franc(5).equals(new Dollar(5)));\n\n}\n\nIt fails. Dollars are Francs. Before you Swiss shoppers get all excited, let’s try to fix the code. The equality code needs to check that it isn’t comparing Dollars and Francs. We can do this right now by comparing the class of the two objects—two Moneys are equal only if their amounts and classes are equal.\n\nMoney\n\npublic boolean equals(Object object) {\n\nMoney money = (Money) object; return amount == money.amount\n\n&& getClass().equals(money.getClass());\n\n}\n\n37",
      "content_length": 1257,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 53,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency?\n\n38\n\nApples and Oranges\n\nUsing classes like this in model code is a bit smelly. We would like to use a criteria that made sense in the domain of finance, not the domain of Java objects. However, we don’t currently have anything like a currency, and this doesn’t seem like suffi- cient reason to introduce one, so this will have to do for the moment.\n\nNow we really need to get rid of the common times() code, so we can get to mixed currency arithmetic. Before we do, though, we can review our grand accomplish- ments of this chapter:\n\n(cid:127)\n\nTook an objection that was bothering us and turned it into a test (cid:127) Made the test run a reasonable, but not perfect way (getClass()) (cid:127) Decided not to introduce more design until we had a better motivation",
      "content_length": 1022,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 54,
      "content": "CHAPTER 10\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency?\n\nMakin’Objects\n\nThe two implementations of times() are remarkably similar:\n\nFranc\n\nFranc times(int multiplier) {\n\nreturn new Franc(amount * multiplier);\n\n} Dollar\n\nDollar times(int multiplier) {\n\nreturn new Dollar(amount * multiplier);\n\n}\n\nWe can take a step towards reconciling them by making them both return a Money:\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn new Franc(amount * multiplier);\n\n} Dollar\n\nMoney times(int multiplier) {\n\nreturn new Dollar(amount * multiplier);\n\n}\n\n39",
      "content_length": 754,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 55,
      "content": "40\n\nMakin’ Objects\n\nThe next step forward is not obvious. The two subclasses of Money aren’t doing enough work to justify their existence, so we would like to eliminate them. How- ever, we can’t do it with one big step, because that wouldn’t make a very effective demonstration of TDD.\n\nOkay, we would be one step closer to eliminating the subclasses if there were fewer references to the subclasses directly. We can introduce a Factory Method in Money that returns a Dollar. We would use it like this:\n\npublic void testMultiplication() {\n\nDollar five = Money.dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));\n\n}\n\nThe implementation creates and returns a Dollar:\n\nMoney\n\nstatic Dollar dollar(int amount) { return new Dollar(amount);\n\n}\n\nBut we want references to Dollars to disappear, so we need to change the declara- tion in the test:\n\npublic void testMultiplication() {\n\nMoney five = Money.dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));\n\n}\n\nOur compiler politely informs us that times() is not defined for Money. We aren’t ready to implement it just yet, so we make Money abstract (I suppose we should have done that to begin with, shouldn’t we?) and declare Money.times():\n\nMoney\n\nabstract class Money abstract Money times(int multiplier);\n\nNow we can change the declaration of the factory method:",
      "content_length": 1406,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 56,
      "content": "Money\n\nstatic Money dollar(int amount) {\n\nreturn new Dollar(amount);\n\n}\n\nThe tests all run, so at least we haven’t broken anything. We can now use our fac- tory method everywhere in the tests:\n\npublic void testMultiplication() {\n\nMoney five = Money.dollar(5); assertEquals(Money.dollar(10), five.times(2)); assertEquals(Money.dollar(15), five.times(3));\n\n} public void testEquality() {\n\nassertTrue(Money.dollar(5).equals(Money.dollar(5))); assertFalse(Money.dollar(5).equals(Money.dollar(6))); assertTrue(new Franc(5).equals(new Franc(5))); assertFalse(new Franc(5).equals(new Franc(6))); assertFalse(new Franc(5).equals(Money.dollar(5)));\n\n}\n\nWe are now in a slightly better position than before. No client code knows that there is a subclass called Dollar. By de-coupling the tests from the existence of the subclasses, we have given ourselves freedom to change inheritance without affect- ing any model code.\n\nBefore we go blindly changing the testFrancMultiplication, we notice that it isn’t testing any logic that isn’t tested by the test for Dollar multiplication. If we delete the test, will we lose any confidence in the code? Still a little, so we leave it there. But it’s suspicious.\n\npublic void testEquality() {\n\nassertTrue(Money.dollar(5).equals(Money.dollar(5))); assertFalse(Money.dollar(5).equals(Money.dollar(6))); assertTrue(Money.franc(5).equals(Money.franc(5))); assertFalse(Money.franc(5).equals(Money.franc(6))); assertFalse(Money.franc(5).equals(Money.dollar(5)));\n\n}\n\npublic void testFrancMultiplication() { Money five = Money.franc(5); assertEquals(Money.franc(10), five.times(2));\n\n41",
      "content_length": 1610,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 57,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\n42\n\nMakin’ Objects\n\nassertEquals(Money.franc(15), five.times(3));\n\n}\n\nThe implementation is just like Money.dollar():\n\nMoney\n\nstatic Money franc(int amount) { return new Franc(amount);\n\n}\n\nWe’ll get rid of the duplication of times() next. For now, reviewing, we:\n\nTook a step towards eliminating duplication by reconciling the signatures of two variants of the same method (times())\n\n(cid:127) Moved at least a declaration of the method to the common superclass (cid:127) Decoupled test code from the existence of concrete subclasses by introducing\n\nfactory methods\n\n(cid:127) Noticed that when the subclasses disappear some tests will be redundant, but\n\ntook no action",
      "content_length": 958,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 58,
      "content": "CHAPTER 11\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\nTimesWe’reLivin’In\n\nWhat is there on our list that might help us eliminate those pesky useless sub- classes?\n\nWhat about currency? What would happen if we introduced the notion of currency?\n\nHow do we want to implement currencies at the moment? I blew it, again. Before the ruler comes out, I’ll rephrase. How do we want to test for currencies at the moment? There. Knuckles saved. For the moment.\n\nWe may want to have complicated objects representing currencies, with flyweight factories to ensure we create no more objects than we really need. However, for the moment Strings will do:\n\npublic void testCurrency() {\n\nassertEquals(\"USD\", Money.dollar(1).currency()); assertEquals(\"CHF\", Money.franc(1).currency());\n\n}\n\nFirst we declare currency() in Money:\n\nMoney\n\nabstract String currency();\n\n43",
      "content_length": 1097,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 59,
      "content": "44\n\nTimes We’re Livin’ In\n\nThen we implement it in both subclasses:\n\nFranc\n\nString currency() { return \"CHF\";\n\n} Dollar\n\nString currency() { return \"USD\";\n\n}\n\nWe want the same implementation to suffice for both classes. We could store the currency in an instance variable and just return the variable. (I’ll start going a little faster with the refactorings in the interest of time. If I go too fast, please tell me to slow down. Oh, wait, this is a book. Perhaps I just won’t speed up much.)\n\nFranc\n\nprivate String currency; Franc(int amount) {\n\nthis.amount = amount; currency = \"CHF\";\n\n} String currency() {\n\nreturn currency;\n\n}\n\nWe can do the same with Dollar:\n\nDollar\n\nprivate String currency; Dollar(int amount) {\n\nthis.amount = amount; currency = \"USD\";\n\n} String currency() {\n\nreturn currency;\n\n}\n\nNow we can push up the declaration of the variable and the implementation of cur- rency(), since they are identical:",
      "content_length": 921,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 60,
      "content": "Money\n\nprotected String currency; String currency() {\n\nreturn currency;\n\n}\n\nIf we move the constant strings “USD” and “CHF” to the static factory methods, the two constructors will be identical and we can create a common implementation.\n\nFirst we’ll add a parameter to the constructor:\n\nFranc\n\nFranc(int amount, String currency) {\n\nthis.amount = amount; this.currency = \"CHF\";\n\n}\n\nThis breaks the two callers of the constructor:\n\nMoney\n\nstatic Money franc(int amount) {\n\nreturn new Franc(amount, null);\n\n} Franc\n\nMoney times(int multiplier) {\n\nreturn new Franc(amount * multiplier, null);\n\n}\n\nWait a minute! Why is Franc.times() calling the constructor instead of the factory method? Do we want to make this change now, or will we wait? The dogmatic answer is that we’ll wait, not interrupting what we’re doing. The answer in my practice is that I will entertain a brief interruption, but only a brief one, and I will never interrupt an interruption (Jim Coplien taught me this rule). To be realistic, we’ll clean up times() before proceeding:\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn Money.franc(amount * multiplier);\n\n}\n\nNow the factory method can pass “CHF”:\n\n45",
      "content_length": 1170,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 61,
      "content": "46\n\nTimes We’re Livin’ In\n\nMoney\n\nstatic Money franc(int amount) {\n\nreturn new Franc(amount, \"CHF\");\n\n}\n\nAnd finally we can assign the parameter to the instance variable:\n\nFranc\n\nFranc(int amount, String currency) {\n\nthis.amount = amount; this.currency = currency;\n\n}\n\nI’m feeling defensive again about taking such teeny-tiny steps. Am I recommend- ing that you actually work this way? No. I’m recommending that you be able to work this way. What I actually did just now was I worked in larger steps and made a stupid mistake half way through. I unwound a minute’s worth of changes, shifted to a lower gear, and did it over with little steps. I’m feeling better now, so we’ll see if we can make the analogous change to Dollar in one swell foop:\n\nMoney\n\nstatic Money dollar(int amount) {\n\nreturn new Dollar(amount, \"USD\");\n\n} Dollar\n\nDollar(int amount, String currency) {\n\nthis.amount = amount; this.currency = currency;\n\n} Money times(int multiplier) {\n\nreturn Money.dollar(amount * multiplier);\n\n}\n\nAnd it worked first time. Whew!\n\nThis is the kind of tuning you will be doing constantly with TDD. Are the teeny- tiny steps feeling restrictive? Take bigger steps. Are you feeling a little unsure? Take smaller steps. TDD is a steering process—a little this way, a little that way. There is no right step size, now and forever.\n\nThe two constructors are now identical, so we can push up the implementation:",
      "content_length": 1406,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 62,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\nMoney\n\nMoney(int amount, String currency) {\n\nthis.amount = amount; this.currency = currency;\n\n} Franc\n\nFranc(int amount, String currency) { super(amount, currency);\n\n} Dollar\n\nDollar(int amount, String currency) {\n\nsuper(amount, currency);\n\n}\n\nWe’re almost ready to push up the implementation of times() and eliminate the sub- classes, but first, to review, we:\n\n(cid:127) Were a little stuck on big design ideas, so we worked on something small we\n\nnoticed earlier\n\nReconciled the two constructors by moving the variation to the caller (the fac- tory method)\n\nInterrupted a refactoring for a little twist (using the factory method in times())\n\nRepeated an analogous refactoring (doing to Dollar what we just did to Franc) in one big step\n\nPushed up the identical constructors\n\n47",
      "content_length": 1069,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 63,
      "content": "48\n\nTimes We’re Livin’ In",
      "content_length": 25,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 64,
      "content": "CHAPTER 12\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\nInterestingTimes\n\nWhen we are done with this chapter we will have a single class to represent Money. The two implementations of times() are close, but not identical.\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn Money.franc(amount * multiplier);\n\n} Dollar\n\nMoney times(int multiplier) {\n\nreturn Money.dollar(amount * multiplier);\n\n}\n\nThere’s not an obvious way to make them identical. Sometimes you have to go backwards to go forwards, a little like a Rubik’s Cube. What happens if we inline the factory methods? (I know, I know, we just called the factory method for the first time just one chapter ago. Frustrating, isn’t it?)\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn new Franc(amount * multiplier, \"CHF\");\n\n}\n\n49",
      "content_length": 1021,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 65,
      "content": "50\n\nInteresting Times\n\nDollar\n\nMoney times(int multiplier) {\n\nreturn new Dollar(amount * multiplier, \"USD\");\n\n}\n\nIn Franc, though, we know that the currency instance variable is always “CHF”, so we can write: Franc\n\nMoney times(int multiplier) {\n\nreturn new Franc(amount * multiplier, currency);\n\n}\n\nThat works. The same trick works in Dollar:\n\nDollar\n\nMoney times(int multiplier) {\n\nreturn new Dollar(amount * multiplier, currency);\n\n}\n\nWe’re almost there. Does it really matter whether we have a Franc or a Money? We could carefully reason about this given our knowledge of the system. However, we have clean code and we have tests that give us confidence that the clean code works. Rather than apply minutes of suspect reasoning, we can just ask the com- puter by making the change and running the tests. In teaching TDD I see this situa- tion all the time—excellent programmers spending 5-10 minutes reasoning about a question that can be answered by the computer in 15 seconds. Without the tests you have no choice, you have to reason. With the tests you can decide whether an experiment would answer the question faster. Sometimes you should just ask the computer.\n\nTo run our experiment we change Franc.times() to return a Money:\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn new Money(amount * multiplier, currency);\n\n}\n\nThe compiler tells us that Money must be a concrete class:",
      "content_length": 1387,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 66,
      "content": "Money\n\nclass Money Money times(int amount) {\n\nreturn null;\n\n}\n\nAnd we get a red bar. The error message says, “expected:<Money.Franc@31aebf> but was: <Money.Money@478a43>”. Not as helpful as we would perhaps like. We can define toString() to give us a better error message:\n\nMoney\n\npublic String toString() {\n\nreturn amount + \" \" + currency;\n\n}\n\nWhoa! Code without a test? Can you do that? We could certainly have written a test for toString() before we coded it. However:\n\n(cid:127) We are about to see the results on the screen\n\n(cid:127)\n\nSince toString() is only used for debug output, the risk of it failing is low (cid:127) We already have a red bar, and we’d prefer not to write a test when we have a\n\nred bar\n\nException noted.\n\nNow the error message says: “expected:<10 CHF> but was:<10 CHF>”. That’s a little better, but still confusing. We got the right data in the answer, but the class was wrong—Money instead of Franc. The problem is in our implementation of equals():\n\nMoney\n\npublic boolean equals(Object object) {\n\nMoney money = (Money) object; return amount == money.amount\n\n&& getClass().equals(money.getClass());\n\n}\n\nWe really should be checking to see that the currencies are the same, not that the classes are the same.\n\nWe’d prefer not to write a test when we have a red bar. However, we are about to change real model code, and we can’t change model code without a test. The con-\n\n51",
      "content_length": 1404,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 67,
      "content": "52\n\nInteresting Times\n\nservative course is to back out the change that caused the red bar so we’re back to green. Then we can change the test for equals(), fix the implementation, and re-try the original change.\n\nThis time, we’ll be conservative (sometimes I plough ahead and write a test on a red, but not while the children are awake.)\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn new Franc(amount * multiplier, currency);\n\n}\n\nThat gets us back to green. The situation that we had was a Franc(10, “CHF”) and a Money(10, “CHF”) that were reported to be not equal, even though we would like them to be equal. We can use exactly this for our test:\n\npublic void testDifferentClassEquality() {\n\nassertTrue(new Money(10, \"CHF\").equals(new Franc(10, \"CHF\")));\n\n}\n\nIt fails, as expected. The equals() code should compare currencies, not classes:\n\nMoney\n\npublic boolean equals(Object object) {\n\nMoney money = (Money) object; return amount == money.amount\n\n&& currency().equals(money.currency());\n\n}\n\nNow we can return a Money from Franc.times() and still pass the tests:\n\nFranc\n\nMoney times(int multiplier) {\n\nreturn new Money(amount * multiplier, currency);\n\n}\n\nWill the same will work for Dollar.times()?\n\nDollar\n\nMoney times(int multiplier) {\n\nreturn new Money(amount * multiplier, currency);\n\n}",
      "content_length": 1292,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 68,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\nYes! Now the two implementations are identical, so we can push them up.\n\nMoney\n\nMoney times(int multiplier) {\n\nreturn new Money(amount * multiplier, currency);\n\n}\n\nMultiplication in place, we are ready to eliminate the stupid subclasses. Reviewing, we:\n\nReconciled two methods (times()) by first inlining the methods they called and then replacing constants with variables\n\n(cid:127) Wrote a toString() without a test just to help us debug\n\nTried a change (returning Money instead of Franc) and let the tests tell us whether it worked\n\nBacked out an experiment and wrote another test. Making the test work made the experiment work.\n\n53",
      "content_length": 924,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 69,
      "content": "54\n\nInteresting Times",
      "content_length": 21,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 70,
      "content": "CHAPTER 13\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\nTheRootofallEvil\n\nThe two subclasses, Dollar and Franc, have only their constructors. Only a con- structor is not enough reason to have a subclass, so we want to delete the sub- classes.\n\nWe can replace references to the subclasses by references to the superclass without changing the meaning of the code. First Franc:\n\nFranc\n\nstatic Money franc(int amount) {\n\nreturn new Money(amount, \"CHF\");\n\n}\n\nThen Dollar:\n\nDollar\n\nstatic Money dollar(int amount) {\n\nreturn new Money(amount, \"USD\");\n\n}\n\nNow there are no references to Dollar, so we can delete it. Franc still has one refer- ence, in the test we just wrote.\n\npublic void testDifferentClassEquality() {\n\n55",
      "content_length": 960,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 71,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 * 2 = $10 Make “amount” private Dollar side-effects? Money rounding? equals() hashCode() Equal null Equal object 5 CHF * 2 = 10 CHF Dollar/Franc duplication Common equals Common times Compare Francs to Dollars Currency? Delete testFrancMultiplication?\n\n56\n\nThe Root of all Evil\n\nassertTrue(new Money(10, \"CHF\").equals(new Franc(10, \"CHF\")));\n\n}\n\nIs equality covered elsewhere well enough that we can delete this test? Looking at the other equality test:\n\npublic void testEquality() {\n\nassertTrue(Money.dollar(5).equals(Money.dollar(5))); assertFalse(Money.dollar(5).equals(Money.dollar(6))); assertTrue(Money.franc(5).equals(Money.franc(5))); assertFalse(Money.franc(5).equals(Money.franc(6))); assertFalse(Money.franc(5).equals(Money.dollar(5)));\n\n}\n\nit looks like we have the cases for equality well covered, too well covered, actually. We can delete the third and fourth assertions since they duplicate the exercise of the first and second assertions:\n\npublic void testEquality() {\n\nassertTrue(Money.dollar(5).equals(Money.dollar(5))); assertFalse(Money.dollar(5).equals(Money.dollar(6))); assertFalse(Money.franc(5).equals(Money.dollar(5)));\n\n}\n\nThe test we wrote forcing us to compare currencies instead of classes only makes sense if there are multiple classes. Since we are trying to eliminate the Franc class, a test to ensure that the system works if there is a Franc class is a burden, not a help. Away testDifferentClassEquality() goes, and Franc goes with it.\n\nSimilarly, there are separate tests for dollar and franc multiplication. Looking at the code, we can see there is no difference in the logic at the moment based on the cur- rency (there was a difference when there were two classes). We can delete testFrancMultiplication() without losing any confidence in the behavior of the sys- tem.\n\nSingle class in place, we are ready to tackle addition. First, to review, we:\n\nFinished gutting subclasses and deleted them\n\nEliminated tests that made sense with the old code structure but were redundant with the new code structure",
      "content_length": 2078,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 72,
      "content": "CHAPTER 14\n\n$5 + 10 CHF = $10 if rate is 2:1\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10\n\nAddition,Finally\n\nIt’s a new day, and our to-do list is getting a little cluttered, so we’ll copy the pend- ing items to a fresh list. (I like physically copying to-do items to a new list. If there are lots of little items, I tend to just take care of them rather than copy them. Little stuff that otherwise might build up gets taken care of just because I’m lazy. Play to your strengths.)\n\nI’m not sure how to write the story of the whole addition, so we’ll start with a sim- pler example—$5 + $5 = $10.\n\npublic void testSimpleAddition() {\n\nMoney sum= Money.dollar(5).plus(Money.dollar(5)); assertEquals(Money.dollar(10), sum);\n\n}\n\nWe could fake the implementation by just returning “Money.dollar(10)”, but the implementation seems obvious. We’ll try:\n\nMoney\n\nMoney plus(Money addend) {\n\nreturn new Money(amount + addend.amount, currency);\n\n}\n\n57",
      "content_length": 941,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 73,
      "content": "58\n\nAddition, Finally\n\n(In general, I will begin speeding up the implementations to save trees and keep your interest. Where the design isn’t obvious I will still fake the implementation and refactor. I hope you will see through this how TDD gives you control over the size of steps.)\n\nHaving said that I was going to go much faster, I will immediately go much slower, not in getting the tests working, but in writing the test itself. There are times and tests that call for careful thought. How are we going to represent multi-currency arithmetic? This is one of those times for careful thought.\n\nThe most difficult design constraint is that we would like most of the code in the system to be unaware that it is (potentially) dealing with multiple currencies. One possible strategy is to immediately convert all money values into a reference cur- rency (I’ll let you guess which reference currency American imperialist pig pro- grammers generally choose). However, this doesn’t allow exchange rates to vary easily.\n\nInstead we would like a solution that lets us conveniently represent multiple exchange rates, and still allows most arithmetic-like expressions to look like, well, arithmetic.\n\nObjects to the rescue. When the object you have doesn’t behave like you want, make another object with the same external protocol (an Imposter), but a different implementation.\n\nThis probably sounds a bit like magic. How do you know to think of creating an imposter here? I won’t kid you—there is no formula for flashes of design insight. Ward came up with the “trick” a decade ago and I haven’t seen it independently duplicated yet, so it must be a pretty tricky trick. TDD can’t guarantee that you will have flashes of insight at the right moment. However, confidence-giving tests and carefully factored code give you preparation for insight, and preparation for apply- ing that insight when it comes.\n\nThe solution is to create an object that acts like a Money, but represents the sum of two Moneys. I’ve tried several different metaphors to explain this idea. One is to treat the sum like a Wallet—you can have several different notes of different denominations and currencies in the same wallet.\n\nAnother metaphor is “expressions”, as in “(2 + 3) * 5”, or in our case “($2 + 3 CHF) * 5”. A Money is the atomic form of an expression. Operations result in Expressions, one of which will be a Sum. Once the operation (like adding up the",
      "content_length": 2432,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 74,
      "content": "value of a portfolio) is complete, the resulting Expression can be reduced back a single currency given a set of exchange rates.\n\nApplying this metaphor to our test, we know what we end up with:\n\npublic void testSimpleAddition() {\n\n… assertEquals(Money.dollar(10), reduced);\n\n}\n\nThe reduced Expression is created by applying exchange rates to an Expression. What in the real world applies exchange rates? A bank. We would like to be able to write:\n\npublic void testSimpleAddition() {\n\n… Money reduced= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(10), reduced);\n\n}\n\n(It’s a little weird to be mixing the “bank” metaphor and the “expression” meta- phor. We’ll get the whole story told first, and then we’ll see what we can do about literary value.)\n\nWe have made an important design decision here. We could just as easily have written “…reduce= sum.reduce(“USD”, bank)”. Why make the Bank responsible? One answer is “that’s the first thing that popped into my head,” but that’s not very informative. Why did it pop into my head that reduction should be the responsibil- ity of the bank and not the expression? Here’s what I’m aware of at the moment:\n\nExpressions seem to be at the heart of what we are doing. I try to keep the objects at the heart as ignorant of the rest of the world as possible, so they stay flexible as long as possible (and remain easy to test, and reuse, and understand.)\n\nI can imagine there will be many operations involving Expressions. If we add every operation to Expression, Expression will grow without limit.\n\nThat doesn’t seem like enough reasons to tip the scales permanently, but it is enough for me to start in this direction. I’m also perfectly willing to move responsi- bility for reduction to Expression if it turns out Bank’s don’t need to be involved.\n\nThe Bank in our simple example doesn’t really need to do anything. As long as we have an object we’re okay:\n\n59",
      "content_length": 1908,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 75,
      "content": "60\n\nAddition, Finally\n\npublic void testSimpleAddition() {\n\n… Bank bank= new Bank(); Money reduced= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(10), reduced);\n\n}\n\nThe sum of two Moneys should be an Expression:\n\npublic void testSimpleAddition() {\n\n… Expression sum= five.plus(five); Bank bank= new Bank(); Money reduced= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(10), reduced);\n\n}\n\nAt least we know for sure how to get five dollars:\n\npublic void testSimpleAddition() { Money five= Money.dollar(5); Expression sum= five.plus(five); Bank bank= new Bank(); Money reduced= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(10), reduced);\n\n}\n\nHow do we get this to compile? We need an interface Expression (we could have a class, but an interface is even lighter weight):\n\nExpression\n\ninterface Expression\n\nMoney.plus() needs to return an Expression:\n\nMoney\n\nExpression plus(Money addend) {\n\nreturn new Money(amount + addend.amount, currency);\n\n}\n\nWhich means that Money has to implement Expression (which is easy, since there are no operations yet):",
      "content_length": 1060,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 76,
      "content": "Money\n\nclass Money implements Expression\n\nWe need an empty Bank class:\n\nBank\n\nclass Bank\n\nWhich stubs out reduce():\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nreturn null;\n\n}\n\nNow it compiles, and fails miserably. Hooray! Progress! We can easily fake the implementation, though:\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nreturn Money.dollar(10);\n\n}\n\nWe’re back to a green bar, and ready to refactor. First, reviewing, we:\n\nReduced a big test to a smaller test that represented progress ($5 + 10 CHF to $5 + $5)\n\nThought carefully about the possible metaphors for our computation\n\nRe-wrote our previous test based on our new metaphor\n\n(cid:127) Got the test to compile quickly (cid:127) Made it run\n\nLooked forward with a bit of trepidation to the refactoring necessary to make the implementation real\n\n61",
      "content_length": 825,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 77,
      "content": "62\n\nAddition, Finally",
      "content_length": 21,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 78,
      "content": "CHAPTER 15\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10\n\nMakeIt\n\nWe can’t mark our test for $5 + $5 done until we’ve removed all the duplication. We don’t have code duplication, but we do have data duplication. The $10 in the fake implementation:\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nreturn Money.dollar(10);\n\n}\n\nis really the same as the “$5 + $5” in the test:\n\npublic void testSimpleAddition() { Money five= Money.dollar(5); Expression sum= five.plus(five); Bank bank= new Bank(); Money reduced= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(10), reduced);\n\n}\n\nBefore when we’ve had a fake implementation, it’s been obvious how to work backwards to the real implementation. It’s just been a matter of replacing constants with variables. This time, though, it’s not obvious to me how to work backwards. So, even though it feels a little speculative, we’ll work forwards.\n\n63",
      "content_length": 899,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 79,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5\n\n64\n\nMake It\n\nFirst, Money.plus() needs to return a real Expression, a Sum, not just a Money (per- haps later we’ll optimize the special case of adding two identical currencies, but that’s later.)\n\nThe sum of two Moneys should be a Sum:\n\npublic void testPlusReturnsSum() {\n\nMoney five= Money.dollar(5); Expression result= five.plus(five); Sum sum= (Sum) result; assertEquals(five, sum.augend); assertEquals(five, sum.addend);\n\n}\n\n(Did you know that the first argument to addition is called the “augend”? I didn’t until I was writing this. Geek joy.)\n\nThe test above is not one I would expect to live a long time. It is deeply concerned with the implementation of our operation, not its externally visible behavior. How- ever, if we make it work, we expect we’ve moved one step closer to our goal.\n\nTo get it to compile, all we need is a Sum class with two fields, augend and addend:\n\nSum\n\nclass Sum {\n\nMoney augend; Money addend;\n\n}\n\nThis gives us a ClassCastException, because Money.plus() is returning a Money, not a Sum: Money\n\nExpression plus(Money addend) { return new Sum(this, addend);\n\n}\n\nSum needs a constructor:\n\nSum\n\nSum(Money augend, Money addend) { }",
      "content_length": 1236,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 80,
      "content": "And Sum needs to be a kind of Expression:\n\nSum\n\nclass Sum implements Expression\n\nNow the system compiles again, but the test is still failing, this time because the Sum constructor is not setting the fields (we could fake the implementation by ini- tializing the fields, but I said I’d start going faster):\n\nSum\n\nSum(Money augend, Money addend) {\n\nthis.augend= augend; this.addend= addend;\n\n}\n\nNow Bank.reduce() is being passed a Sum. If the currencies in the Sum are all the same, and the target currency is also the same, the result should be a Money whose amount is the sum of the amounts:\n\npublic void testReduceSum() {\n\nExpression sum= new Sum(Money.dollar(3), Money.dollar(4)); Bank bank= new Bank(); Money result= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(7), result);\n\n}\n\nI carefully chose parameters that would break the existing test. When we reduce a Sum, the result (under these simplified circumstances) should be a Money whose amount is the sum of the amounts of the two Moneys and whose currency is the currency to which we are reducing.\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nSum sum= (Sum) source; int amount= sum.augend.amount + sum.addend.amount; return new Money(amount, to);\n\n}\n\nThis is immediately ugly on two counts:\n\nThe cast. This code should work with any Expression.\n\nThe public fields, and two levels of references at that\n\n65",
      "content_length": 1377,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 81,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money)\n\n66\n\nMake It\n\nEasy enough to fix. First, we can move the body of the method to Sum and get rid of some of the visible fields. We are “sure” we will need the Bank as a parameter in the future, but this is pure, simple refactoring, so we leave it out (actually, just now I put it in because I “knew” I would need it—shame, shame on me.)\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nSum sum= (Sum) source; return sum.reduce(to);\n\n} Sum\n\npublic Money reduce(String to) {\n\nint amount= augend.amount + addend.amount; return new Money(amount, to);\n\n}\n\n(Which brings up the point of how we are going to implement, er… test, Bank.reduce() when the argument is a Money.)\n\nLet’s write that test, since the bar is green and there is nothing else obvious to do with the code above:\n\npublic void testReduceMoney() { Bank bank= new Bank(); Money result= bank.reduce(Money.dollar(1), \"USD\"); assertEquals(Money.dollar(1), result);\n\n} Bank\n\nMoney reduce(Expression source, String to) {\n\nif (source instanceof Money) return (Money) source; Sum sum= (Sum) source; return sum.reduce(to);\n\n}\n\nUgly, ugly, ugly. However, we now have a green bar, and refactoring is possible. Any time you are checking classes explicitly, you should be using polymorphism instead. Since Sum implements reduce(String), if Money implemented it, too, we could then add it to the Expression interface.\n\nBank\n\nMoney reduce(Expression source, String to) {",
      "content_length": 1509,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 82,
      "content": "if (source instanceof Money)\n\nreturn (Money) source.reduce(to);\n\nSum sum= (Sum) source; return sum.reduce(to);\n\n} Money\n\npublic Money reduce(String to) {\n\nreturn this;\n\n}\n\nIf we add reduce(String) to the Expression interface:\n\nExpression\n\nMoney reduce(String to);\n\nWe can eliminate all those ugly casts and class checks:\n\nBank\n\nMoney reduce(Expression source, String to) {\n\nreturn source.reduce(to);\n\n}\n\nI’m not entirely happy with the name of the method being the same in Expression and in Bank, but having different parameter types. I’ve never found a satisfactory general solution to this problem in Java. In languages with keyword parameters, communicating the difference between Bank.reduce(Expression, String) and Expression.reduce(String) is well supported by the language syntax. With posi- tional parameters, it’s not so easy to make the code speak for you about how the two are different.\n\nNext we’ll actually exchange one currency for another. First, reviewing, we:\n\n(cid:127) Didn’t mark a test as done because the duplication had not been eliminated (cid:127) Worked forwards instead of backwards to realize the implementation (cid:127) Wrote a test to force the creation of an object we expected to need later (Sum)\n\nStarted implementing faster (the Sum constructor)\n\nImplemented code with casts in one place, then moved the code where it belonged once the test were running\n\nIntroduced polymorphism to eliminate explicit class checking\n\n67",
      "content_length": 1454,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 83,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion\n\n68\n\nMake It",
      "content_length": 133,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 84,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String)\n\n69",
      "content_length": 267,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 85,
      "content": "70\n\nMake It",
      "content_length": 11,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 86,
      "content": "CHAPTER 16\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String)\n\nChange\n\nChange is worth embracing (especially if you have a book out with “embrace change” in the title). Here, though, we are thinking about a much simpler form of change—we have 2 francs and we want a dollar. That sounds like a test case already:\n\npublic void testReduceMoneyDifferentCurrency() {\n\nBank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Money result= bank.reduce(Money.franc(2), \"USD\"); assertEquals(Money.dollar(1), result);\n\n}\n\nWhen I go from francs to dollars, I divide by two (we’re still studiously ignoring all those nasty numerical problems.) We can make the bar green in one piece of ugli- ness:\n\nMoney\n\npublic Money reduce(String to) {\n\nint rate = (currency.equals(\"CHF\") && to.equals(\"USD\"))\n\n? 2 : 1;\n\nreturn new Money(amount / rate, to);\n\n}\n\n71",
      "content_length": 928,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 87,
      "content": "72\n\nChange\n\nNow, suddenly, Money knows about exchange rates. Yuck. The Bank should be the only place we care about exchange rates. We’ll have to pass the Bank as a parame- ter to Expression.reduce() (see, we knew we would need it, and we were right. In the words of the grandfather in The Princess Bride, “You’re very clever…”) First the caller: Bank\n\nMoney reduce(Expression source, String to) {\n\nreturn source.reduce(this, to);\n\n}\n\nThen the implementors:\n\nExpression\n\nMoney reduce(Bank bank, String to); Sum\n\npublic Money reduce(Bank bank, String to) {\n\nint amount= augend.amount + addend.amount; return new Money(amount, to);\n\n} Money\n\npublic Money reduce(Bank bank, String to) {\n\nint rate = (currency.equals(\"CHF\") && to.equals(\"USD\"))\n\n? 2 : 1;\n\nreturn new Money(amount / rate, to);\n\n}\n\nThe methods have to be public because methods in interfaces have to be public (for some excellent reason, I’m sure.)\n\nNow we can calculate the rate in the Bank:\n\nBank\n\nint rate(String from, String to) {\n\nreturn (from.equals(\"CHF\") && to.equals(\"USD\"))\n\n? 2 : 1;\n\n}\n\nAnd ask the bank for the right rate:",
      "content_length": 1094,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 88,
      "content": "Money\n\npublic Money reduce(Bank bank, String to) {\n\nint rate = bank.rate(currency, to); return new Money(amount / rate, to);\n\n}\n\nThat pesky “2” still appears in both the test and the code. To get rid of it, we need to keep a table of rates in the Bank and look up a rate when we need it. We could use a Hashtable mapping pairs of currencies to rates. Can we use a two element array containing the two currencies as the key? Does Array.equals() check to see if the elements are equal?\n\npublic void testArrayEquals() {\n\nassertEquals(new Object[] {\"abc\"}, new Object[] {\"abc\"});\n\n}\n\nNope. The test fails, so we have to create a real object for the key:\n\nPair\n\nprivate class Pair {\n\nprivate String from; private String to;\n\nPair(String from, String to) {\n\nthis.from= from; this.to= to;\n\n}\n\n}\n\nBecause we are using Pairs as keys, we have to implement equals() and hash- Code(). I’m not going to write tests for these, because we are writing this code in the context of a refactoring. If we get to the payoff of the refactoring and all the tests run, we expect the code to have been exercised. If I was programming with someone who didn’t see exactly where we were going with this, or if the logic became the least bit complex, I would begin writing separate tests.\n\nPair\n\npublic boolean equals(Object object) {\n\nPair pair= (Pair) object; return from.equals(pair.from) && to.equals(pair.to);\n\n}\n\n73",
      "content_length": 1392,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 89,
      "content": "74\n\nChange\n\npublic int hashCode() {\n\nreturn 0;\n\n}\n\n“0” is a terrible hash value, but it has the advantage that it’s easy to implement and it will get us running quickly. Currency lookup will look like linear search. Later, when we get lots of currencies, we can do a more thorough job with real usage data.\n\nWe need somewhere to store the rates:\n\nBank\n\nprivate Hashtable rates= new Hashtable();\n\nWe need to set the rate when told:\n\nBank\n\nvoid addRate(String from, String to, int rate) {\n\nrates.put(new Pair(from, to), new Integer(rate));\n\n}\n\nAnd then we can look up the rate when asked:\n\nBank\n\nint rate(String from, String to) {\n\nInteger rate= (Integer) rates.get(new Pair(from, to)); return rate.intValue();\n\n}\n\nWait a minute!? We got a red bar. What happened? A little snooping around tells us that if we ask for the rate from USD to USD, we expect the value to be 1. Since this was a surprise, let’s write a test to communicate what we discovered:\n\npublic void testIdentityRate() {\n\nassertEquals(1, new Bank().rate(\"USD\", \"USD\"));\n\n}\n\nNow we have three errors, but we expect them all to be fixed with one change:\n\nBank\n\nint rate(String from, String to) {\n\nif (from.equals(to)) return 1;",
      "content_length": 1189,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 90,
      "content": "Integer rate= (Integer) rates.get(new Pair(from, to)); return rate.intValue();\n\n}\n\nGreen bar!\n\nNext we’ll implement our last big test, $5 + 10 CHF. Several significant techniques have slipped into this chapter:\n\n(cid:127) Added a parameter, in seconds, that we expected we would need\n\nFactored out the data duplication between code and tests\n\n(cid:127) Wrote a test (testArrayEquals) to check an assumption about the operation of\n\nJava\n\nIntroduced a private helper class without distinct tests of its own\n\n(cid:127) Made a mistake in a refactoring and chose to forge ahead, writing another test to\n\nisolate the problem\n\n75",
      "content_length": 622,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 91,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String)\n\n76\n\nChange",
      "content_length": 153,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 92,
      "content": "CHAPTER 17\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String)\n\nMixedCurrencies\n\nNow we are finally ready to add the test that started it all, $5 + 10 CHF:\n\npublic void testMixedAddition() {\n\nExpression fiveBucks= Money.dollar(5); Expression tenFrancs= Money.franc(10); Bank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Money result= bank.reduce(fiveBucks.plus(tenFrancs), \"USD\"); assertEquals(Money.dollar(10), result);\n\n}\n\nThis is what we’d like to write. Unfortunately, there are a host of compile errors. When we were generalizing from Money to Expression, we left a lot of loose ends laying around. I was worried about them, but I didn’t want to disturb you. It’s dis- turbing time, now.\n\nWe won’t be able to get the test above to compile quickly. We will make the first change that will ripple to the next and the next. We have two paths forward. We can make it work quickly by writing a more specific test and then generalizing, or we can trust our compiler not to let us make mistakes. I’m with you—let’s go slow (in practice I would probably just fix the rippling changes one at a time).\n\npublic void testMixedAddition() {\n\nMoney fiveBucks= Money.dollar(5);\n\n77",
      "content_length": 1265,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 93,
      "content": "78\n\nMixed Currencies\n\nMoney tenFrancs= Money.franc(10); Bank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Money result= bank.reduce(fiveBucks.plus(tenFrancs), \"USD\"); assertEquals(Money.dollar(10), result);\n\n}\n\nThe test doesn’t work. We get 15 USD instead of 10 USD. It’s as if Sum.reduce() isn’t reducing the arguments. It isn’t:\n\nSum\n\npublic Money reduce(Bank bank, String to) {\n\nint amount= augend.amount + addend.amount; return new Money(amount, to);\n\n}\n\nIf we reduce both of the arguments, the test should pass:\n\nSum\n\npublic Money reduce(Bank bank, String to) {\n\nint amount= augend.reduce(bank, to).amount +\n\naddend.reduce(bank, to).amount; return new Money(amount, to);\n\n}\n\nAnd it does. Now we can begin pecking away at Moneys that should be Expres- sions. To avoid the ripple effect, we’ll start at the edges and work our way back to the test case. For example, the augend and addend can now be Expressions:\n\nSum\n\nExpression augend; Expression addend;\n\nThe arguments to the Sum constructor can also be Expressions:\n\nSum\n\nSum(Expression augend, Expression addend) {\n\nthis.augend= augend; this.addend= addend;\n\n}",
      "content_length": 1121,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 94,
      "content": "(Sum is starting to remind me of Composite, but not so much that I want to general- ize. The moment we want a Sum with other than two parameters, though, I’m ready to transform it.) So much for Sum. How about Money?\n\nThe argument to plus() can be an Expression:\n\nMoney\n\nExpression plus(Expression addend) { return new Sum(this, addend);\n\n}\n\nTimes() can return an Expression:\n\nMoney\n\nExpression times(int multiplier) {\n\nreturn new Money(amount * multiplier, currency);\n\n}\n\nThis suggests that Expression should include the operations plus() and times(). That’s all for Money. We can now change the argument to plus() in our test case:\n\npublic void testMixedAddition() {\n\nMoney fiveBucks= Money.dollar(5); Expression tenFrancs= Money.franc(10); Bank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Money result= bank.reduce(fiveBucks.plus(tenFrancs), \"USD\"); assertEquals(Money.dollar(10), result);\n\n}\n\nWhen we change fiveBucks to an Expression, we have to make several changes. Fortunately we have the compiler’s to-do list to keep us focused. First we make the change:\n\npublic void testMixedAddition() {\n\nExpression fiveBucks= Money.dollar(5); Expression tenFrancs= Money.franc(10); Bank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Money result= bank.reduce(fiveBucks.plus(tenFrancs), \"USD\"); assertEquals(Money.dollar(10), result);\n\n}\n\n79",
      "content_length": 1344,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 95,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String) Sum.plus Expression.times\n\n80\n\nMixed Currencies\n\nWe are politely told that plus() is not defined for Expressions. We define it:\n\nExpression\n\nExpression plus(Expression addend);\n\nAnd then we have to add it to Money and Sum. Money? Yes, it has to be public in Money:\n\nMoney\n\npublic Expression plus(Expression addend) {\n\nreturn new Sum(this, addend);\n\n}\n\nWe’ll just stub out the implementation in Sum, and add it to our list:\n\nSum\n\npublic Expression plus(Expression addend) {\n\nreturn null;\n\n}\n\nNow that the program compiles, the tests all run.\n\nWe are ready to finish generalizing Money to Expression, but first we’ll review. We:\n\n(cid:127) Wrote the test we wanted, then backed off to make it achievable in one step (cid:127) Generalized (used a more abstract declaration) from the leaves back to the root\n\n(the test case)\n\nFollowed the compiler when we made a change (Expression fiveBucks) which caused changes to ripple (added plus() to Expression, etc.)",
      "content_length": 1096,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 96,
      "content": "CHAPTER 18\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String) Sum.plus Expression.times\n\nAbstraction,Finally\n\nWe need to implement Sum.plus() to finish Expression.plus, and then we need Expression.times(), and then we’re finished with the whole example. Here’s the test for Sum.plus():\n\npublic void testSumPlusMoney() {\n\nExpression fiveBucks= Money.dollar(5); Expression tenFrancs= Money.franc(10); Bank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Expression sum= new Sum(fiveBucks, tenFrancs).plus(fiveBucks); Money result= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(15), result);\n\n}\n\nWe could have created a Sum by adding fiveBucks and tenFrancs, but the form above, where we explicitly create the Sum, communicates more directly. You are writing these tests not just to make your experience of programming more fun and rewarding, but also as a Rosetta Stone for future generations to appreciate your genius. Think, oh think, of your readers.\n\nThe test, in this case, is longer than the code. The code is the same as the code in Money (do I hear an abstract class in the distance?):\n\n81",
      "content_length": 1193,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 97,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String) Sum.plus Expression.times\n\n$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String) Sum.plus Expression.times\n\n82\n\nAbstraction, Finally\n\nSum\n\npublic Expression plus(Expression addend) {\n\nreturn new Sum(this, addend);\n\n}\n\nYou will likely end up with about the same number of lines of test code as model code when TDDing. For TDD to make economic sense, either you will have to be able to write twice as many lines per day as before, or write half as many lines for the same functionality. You’ll have to measure and see what effect TDD has on your own practice. Be sure to factor debugging, integrating, and explaining time into your metrics, though.\n\nIf we can make Sum.times() work, then declaring Expression.times() will be one simple step. The test is:\n\npublic void testSumTimes() {\n\nExpression fiveBucks= Money.dollar(5); Expression tenFrancs= Money.franc(10); Bank bank= new Bank(); bank.addRate(\"CHF\", \"USD\", 2); Expression sum= new Sum(fiveBucks, tenFrancs).times(2); Money result= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(20), result);\n\n}\n\nAgain, the test is longer than the code (you JUnit geeks will know how to fix that— the rest of you will have to read Fixture):\n\nSum\n\nExpression times(int multiplier) {\n\nreturn new Sum(augend.times(multiplier),\n\naddend.times(multiplier)); }\n\nSince we abstracted augend and addend to Expressions in the last chapter, we now have to declare times() in Expression before the code will compile:\n\nExpression\n\nExpression times(int multiplier);\n\nWhich forces us to raise the visibility of Money.times() and Sum.times():",
      "content_length": 1797,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 98,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String) Sum.plus Expression.times\n\nSum\n\npublic Expression times(int multiplier) {\n\nreturn new Sum(augend.times(multiplier),\n\naddend.times(multiplier)); } Money\n\npublic Expression times(int multiplier) {\n\nreturn new Money(amount * multiplier, currency);\n\n}\n\nAnd it works.\n\nThe only loose end to tie up is to experiment with returning a Money when we add $5 + $5. The test would be:\n\npublic void testPlusSameCurrencyReturnsMoney() {\n\nExpression sum= Money.dollar(1).plus(Money.dollar(1)); assertTrue(sum instanceof Money);\n\n}\n\nThis test is a little ugly, because it is testing the guts of the implementation, not the externally visible behavior of the objects. However, it will drive us to make the changes we need to make, and this is only an experiment, after all. Here is the code we would have to modify to make it work:\n\nMoney\n\npublic Expression plus(Expression addend) {\n\nreturn new Sum(this, addend);\n\n}\n\nThere is no obvious, clean way (not to me, anyway, I’m sure you could think of something) to check the currency of the argument if and only if it is a Money. The experiment fails, we delete the test (which we didn’t like much anyway), and away we go.\n\nReviewing, we:\n\n(cid:127) Wrote a test with future readers in mind\n\nSuggested an experiment comparing TDD with your current programming style\n\n(cid:127) Once again had changes of declarations ripple through the system, and once\n\nagain followed the compiler’s advice to fix them\n\n83",
      "content_length": 1577,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 99,
      "content": "$5 + 10 CHF = $10 if rate is 2:1 $5 + $5 = $10 Return Money from $5 + $5 Bank.reduce(Money) Reduce Money with conversion Reduce(Bank, String) Sum.plus Expression.times\n\n84\n\nAbstraction, Finally\n\nTried a brief experiment, then discarded it when it didn’t work out",
      "content_length": 262,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 100,
      "content": "CHAPTER 19\n\nMoneyRetrospective\n\nLet’s take a look back at the Money example, both the process we used and the results. We will look at:\n\n(cid:127) What Next? (cid:127) Metaphor—the dramatic effect metaphor has on the structure of the design\n\nJUnit Usage—when we ran tests and how we used JUnit\n\nCode Metrics—a numerical abstract of the resulting code\n\nProcess—we say red/green/refactor, but how much work goes into each step?\n\nTest Quality—how do TDD tests stack up by conventional test metrics?\n\nWhat Next?\n\nIs the code finished? No. There is that nasty duplication between Sum.plus() and Money.plus(). If we made Expression a class instead of an interface (not the usual direction, as classes more often become interfaces), we would have a natural home for the common code.\n\nI don’t believe in “finished”. TDD can be used as a way to strive for perfection, but that isn’t its most effective use. If you have a big system, the parts that you touch all the time should be absolutely rock solid, so you can make daily changes confi- dently. As you drift out to the periphery of the system, to parts that don’t change\n\n85",
      "content_length": 1119,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 101,
      "content": "86\n\nMoney Retrospective\n\noften, the tests can be spottier and the design uglier without interfering with your confidence.\n\nWhen I’ve done all of the obvious tasks, I like running a code critic, like SmallLint for Smalltalk. Many of the suggestions that come up I already know about, or I dis- agree with. Automated critics don’t forget, though, so if I don’t delete an obsolete implementation I don’t have to stress. The critic will point it out.\n\nAnother “what next?” question is, “What additional tests do I need?” Sometimes you think of a test that “shouldn’t” work, and it does. Then you need to find out why. Sometimes a test that shouldn’t work really doesn’t, and you can record it as a known limitation or as work to be done later.\n\nFinally, when the list is empty is a good time to review the design. Do the words and concepts play together? Is there duplication that is difficult to eliminate given the current design (lingering duplication is a symptom of latent design.)\n\nMetaphor\n\nThe biggest surprise for me in coding the Money example is how different it came out this time. I have programmed Money in production at least three times that I can think of. I have used it as an example in print another half dozen times. I have programmed it live on stage (relax, it’s not as exciting as it sounds…) another fif- teen times. I coded another three or four times preparing for writing (I ripped out Section I and rewrote it based on early reviews.) Then, while I was writing this, I thought of using Expression as the metaphor and the design went in a completely different direction than it has gone before.\n\nI really didn’t expect the metaphor to be so powerful. A metaphor should just be a source of names, shouldn’t it? Apparently not.\n\nThe metaphor Ward used for “several monies together with potentially different currencies” was a vector, like a mathematic vector where the coefficients were cur- rencies instead of x2. I used MoneySum for a while, then MoneyBag (which is nice and physical), and finally Wallet (which is commoner in most folks’ experience). All of these metaphors imply that the collection of Money’s is flat. For example, “2 USD + 5 CHF + 3 USD” would result in “5 USD + 5 CHF”. Two values with the same currency would be merged.",
      "content_length": 2265,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 102,
      "content": "Occurrences\n\n50 45 40\n\n35 30 25 20 15\n\n10 5 0\n\nThe Expression metaphor freed me from a bunch of nasty issues about merging duplicated currencies. The code came out cleaner and clearer than I’ve ever seen it before. I’m concerned about the performance of Expressions, but I’m happy to wait until I see some usage statistics before I start optimizing.\n\nWhat if I got to rewrite everything I ever wrote 20 times? Would I keep finding insight and surprise every time? Is there some way to be more mindful as I program so I can squeeze all the insight out of the first three times? The first time?\n\nJUnit Usage\n\nI had JUnit keep a log while I was coding the Money example. I pressed the Run button precisely 125 times. Because I was writing at the same time as I was pro- gramming, the interval between runs isn’t representative, but during the times I was just programming I ran the tests about once a minute. Only once in that whole time was I surprised by either success or failure, and that was a refactoring done in haste.\n\nHere is a histogram of the time interval between test runs. The large number of large intervals is most likely because of the time I spent writing:\n\n0\n\n1\n\n< 5\n\n< 10\n\n>= 10\n\nMinutes Between Runs\n\n87",
      "content_length": 1221,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 103,
      "content": "88\n\nMoney Retrospective\n\nCode Statistics\n\nHere are some statistics on the code:\n\nFunctional\n\nTest\n\nClasses\n\n5\n\n1\n\nFunctions (1)\n\n22\n\n15\n\nLines (2)\n\n91\n\n89\n\nCyclomatic complexity (3)\n\n1.04\n\n1\n\nLines/function\n\n4.1 (4)\n\n5.9 (5)\n\n1. Because we haven’t implemented the whole API, we can’t evaluate the absolute number of functions, or the number of functions per class, or lines per class. However, the ratios are instructive. There are roughly as many lines and func- tions in the test and functional code.\n\n2. The number of lines of test code can be reduced by extracting common fixtures. The rough correspondence between lines of model code and lines of test code will remain, however.\n\n3. Cyclomatic complexity is a measure of conventional flow complexity. Test complexity is 1 because there are no branches or loops in test code. Functional code complexity is low because of the heavy use of polymorphism as a substi- tute for explicit control flow.\n\n4. This includes the function header and trailing brace.\n\n5. Lines/function in the tests is inflated because we have not factored out common fixture-building code, as explained in the section on JUnit.\n\nProcess\n\nThe TDD cycle is:\n\n(cid:127) Write a test (cid:127) Make it compile, run it to see it fail (cid:127) Make it run\n\nRemove duplication",
      "content_length": 1295,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 104,
      "content": "Assuming that writing a test is a single step, how many changes does it take to com- pile, run, and refactor? (By change, I mean changing a method or class definition.)\n\nNumber of changes per refactoring\n\n10\n\n8\n\n6\n\nrrences\n\n4\n\n2\n\n0\n\n1 3 5 7 9\n\n1 1\n\n3 1\n\n5 1\n\n7 1\n\n9 1\n\n1 2\n\n3 2\n\n5 2\n\n7 2\n\nNumber of Changes\n\nI expect that if we gathered data for a large project, the number of changes to com- pile and run would remain fairly small (they could be even smaller if the program- ming environment understood what the tests were trying to tell it—creating stubs automatically, for instance). However, (here’s at least a master’s thesis) the number of changes per refactoring should follow a “fat tail” or leptokurtotic profile, which is like a bell curve but with more extreme changes than predicted by a standard bell curve. Many measurements in nature follow this profile, like price changes in the stock market.1\n\n1. Fractals and Scaling in Finance, Benoit Mandelbrot, editor, Springer- Verlag, 1997, ISBN: 0387983635\n\n9 2\n\n89",
      "content_length": 1024,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 105,
      "content": "90\n\nMoney Retrospective\n\nTest Quality\n\nThe tests that are a natural by-product of TDD are certainly useful enough to keep running as long as the system is running. Don’t expect them to replace the many other types of testing:\n\nPerformance\n\n(cid:127)\n\nStress (cid:127) Usability\n\nHowever, if the defect density of test-driven code is low enough, the role of profes- sional testing will inevitably change from “adult supervision” to something more closely resembling an amplifier for the communication between those who gener- ally have a feeling for what the system should do and those who will make it do. As a stand-in for a long and interesting conversation about the future of professional testing, here are a couple of widely shared measurements of the tests written above.\n\nStatement coverage is certainly not a sufficient measure of test quality, but it is a starting place. TDD followed religiously should result in 100% statement coverage. JProbe (www.sitraka.com/software/jprobe) reports only one line in one method not covered by the test cases, Money.toString(), which we added explicitly as a debug- ging aid, not real model code.\n\nAnother way of evaluating test quality is defect insertion. The idea is simple— change the meaning of a line of code and a test should break. You can do this man- ually, or with a tool like Jester (jester.sourceforge.net). Jester reports only one line it is able to change without breaking, Pair.hashCode(). We faked the implementa- tion to just return 0. Returning a different constant doesn’t actually change the meaning of the program (one fake number is as good as another), so it isn’t really a defect that has been inserted.\n\nPhlip made a point about test coverage that bears repeating here. A gross measure of coverage is the number of tests testing different aspects of a program divided by the number of aspects that need testing (the complexity of the logic). One way to improve coverage is to write more tests, hence the dramatic difference in the num- ber of tests a TDDer would write for code and the number of tests a professional tester would write (page ??? gives details of an example where I wrote 6 tests and a tester wrote 65 for the same problem). However, another way to improve coverage is to take a fixed set of tests and simplify the logic of the program. The refactoring step often has this effect—conditionals replaced by messages, or by nothing at all. In his words, “… instead of increasing the test coverage to walk all permutations of",
      "content_length": 2509,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 106,
      "content": "input (more properly an efficiently reduced sample of all possible permutations), we just leave the same tests covering various permutations of code as it shrinks.”\n\nOne Last Review\n\nThe three items that come up time and again as surprises when teaching TDD are:\n\nThe three approaches to making a test work cleanly—fake it, triangulate, and just typing in the right solution to begin with\n\nRemoving duplication between test and code as a way to drive the design\n\nThe ability to control the gap between tests to increase traction when the road gets slippery and cruise faster when conditions are clear\n\n91",
      "content_length": 604,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 107,
      "content": "92\n\nMoney Retrospective",
      "content_length": 23,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 108,
      "content": "CHAPTER 20\n\nSectionII:xUnit\n\nHow, oh how, to talk about the implementation of a tool for test-driven develop- ment? Test-driven, naturally.\n\nThe xUnit architecture comes out very smoothly in Python, so I’ll switch to Python for this section. Don’t worry, I’ll give a little commentary on Python, for those of you who haven’t seen it before. When you’re done you’ll have an introduction to Python, you’ll be able to write your own testing framework, and you’ll have seen a trickier example of TDD—three for the price of one.\n\nWriting a testing tool test-first using itself as the tool, may seem a bit like perform- ing brain surgery on yourself (“Don’t touch those motor centers—oh, too bad, game over”). It will get weird from time to time. However, the logic of the testing framework is more complicated than the wimpy money example above. You can read this chapter as a step towards test-driven development of “real” software. You can read this chapter as a computer-sciency exercise in self-referential program- ming.\n\nFirst, we need to be able to create a TestCase and run a test method. For example: TestCase(“testMethod”).run(). We have a bootstrap problem. We are writing test cases to test a framework that we will be using to write the test cases. Since we don’t have a framework yet, we will have to verify the operation of the first tiny step by hand. Fortunately, we are well rested and relaxed and unlikely to make mis-\n\n93",
      "content_length": 1436,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 109,
      "content": "Invoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results\n\n94\n\nSection II: xUnit\n\ntakes, which is why we will go in teensy tiny steps, verifying everything six ways from Sunday. Here is the test list I can think of for a testing framework.\n\nWe are still working test-first, of course. For our first proto-test, we need a little program that will print out true if a test method gets called, and false otherwise. If we have a test case that sets a flag inside the test method, we can print the flag after we’re done and make sure it’s correct. Once we have verified it manually, we can automate the process.\n\nHere’s the strategy for our bootstrap test—we will create a TestCase that contains a flag. Before the test method is run, the flag should be false. The test method will set the flag. After the test method is run, the flag should be true. We’ll call the TestCase class “WasRun”, because it’s a test case that reports whether a method was run. The flag (perhaps confusingly, but it’s such a good name) will also be called “wasRun”, so we can eventually write “assert test.wasRun” (assert is a built- in Python facility.)\n\nPython executes statements as it reads a file, so we can start with invoking the test method manually:\n\ntest= WasRun(\"testMethod\") print test.wasRun test.testMethod() print test.wasRun\n\nWe expect this to print “None” (None in Python is like null or nil, and stands for false, along with 0 and a few other objects) before the method was run, and “1” afterwards. It doesn’t, because we haven’t defined the class WasRun yet (test-first, test-first).\n\nWasRun\n\nclass WasRun: pass\n\n(The keyword “pass” is used when there is no implementation of a class or method.) Now we are told we need an attribute “wasRun”. We need to create the attribute when we create the instance is created (the constructor is called “__init__” for convenience). In it, we set the wasRun flag false.\n\nWasRun\n\nclass WasRun: def __init__(self, name):",
      "content_length": 2044,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 110,
      "content": "self.wasRun= None\n\nRunning the file faithfully prints out “None”, then tells us we need to define the method “testMethod” (wouldn’t it be great if your IDE noticed this, provided you with a stub, and opened up an editor on it? Nah, too useful… cf )\n\nWasRun\n\ndef testMethod(self): pass\n\nNow when we execute the file, we see “None” and “None”. We want to see “None” and “1”. We can get it by setting the flag in testMethod():\n\nWasRun\n\ndef testMethod(self): self.wasRun= 1\n\nNow we get the right answer (the green bar, hooray!). Now we have a bunch of refactoring to do, but as long as we maintain the green bar, we know we have made progress.\n\nNext we need to use our real interface, run(), instead of calling the test method directly. The test changes to:\n\ntest= WasRun(\"testMethod\") print test.wasRun test.run() print test.wasRun\n\nThe implementation we can hardwire at the moment to:\n\nWasRun\n\ndef run(self): self.testMethod()\n\nAnd our test is back to printing the right values again. Lots of refactoring has this feel—separating two parts so you can work on them separately. If they go back together when you are finished, fine, if not, you can leave them separate. In this case, we expect to create a superclass TestCase, eventually, but first we have to dif- ferentiate the parts of our one example. There is probably some clever analogy with mitosis in here, but I don’t know enough cellular biology to explain it.\n\n95",
      "content_length": 1420,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 111,
      "content": "96\n\nSection II: xUnit\n\nThe next step is to dynamically invoke the testMethod. If the name attribute of the instance of WasRun is the string “testMethod”, then we can replace the direct call to “self.testMethod()” with “exec “self.” + self.name + “()”” (the dynamic invoca- tion of methods is called Pluggable Selector, and should be used sparingly, and only if there are no reasonable alternatives).\n\nWasRun\n\nclass WasRun: def __init__(self, name): self.wasRun= None self.name= name def run(self): exec \"self.\" + self.name + \"()\"\n\nHere is another general pattern of refactoring—take code that works in one instance and generalize it to work in many by replacing constants with variables. Here the constant was hardwired code, not a data value, but the principle is the same. TDD makes this work well by giving you running concrete examples from which to gen- eralize, instead of having to generalize purely with reasoning.\n\nNow our little WasRun class is doing two distinct jobs—one is keeping track of whether a method was invoked or not, the other is dynamically invoking the method. Time for a little of that mitosis action. First we create an empty TestCase superclass, and make WasRun a subclass:\n\nTestCase\n\nclass TestCase:\n\npass WasRun\n\nclass WasRun(TestCase): …\n\nNow we can move the “name” attribute up to the superclass:\n\nTestCase\n\ndef __init__(self, name): self.name= name\n\nWasRun\n\ndef __init__(self, name): self.wasRun= None TestCase.__init__(self, name)",
      "content_length": 1464,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 112,
      "content": "Finally, the run() method only uses attributes from the superclass, so it probably belongs in the superclass (I’m always looking to put the operations near the data.)\n\nTestCase\n\ndef __init__(self, name): self.name= name\n\ndef run(self):\n\nexec \"self.\" + self.name + \"()\"\n\n(Between every one of these steps I run the tests to make sure I’m getting the same answer.)\n\nWe’re getting tired of looking to see that “None” and “1” are printed every time. Using the mechanism we just built, we can now write:\n\nTestCaseTest\n\nclass TestCaseTest(TestCase): def testRunning(self):\n\ntest= WasRun(\"testMethod\") assert(not test.wasRun) test.run() assert(test.wasRun)\n\nTestCaseTest(\"testRunning\").run()\n\nThe body of the test is just the print statements turned into assertions, so you could just see what we have done as a complicated form of Extract Method.\n\nI’ll let you in on a little secret. I look at the size of the steps in the development above and it looks ridiculous. On the other hand, I tried it with bigger steps, proba- bly six hours in all (I had to spend a lot of time looking up Python stuff), starting from scratch twice, and both times I thought I had the code working when I didn’t. This is about the worst possible case for TDD, because we are trying to get over the bootstrap step.\n\nIt is not necessary to work in such tiny steps as these. Once you’ve mastered TDD, you will be able to work in much bigger leaps of functionality between test cases. However, to master TDD you need to be able to work in such tiny steps when they are called for.\n\nNext we will tackle calling setUp() before running the test. Reviewing first, we:\n\n97",
      "content_length": 1635,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 113,
      "content": "Invoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results\n\n98\n\nSection II: xUnit\n\n(cid:127) After a couple of hubris-fueled false starts, figured out how to begin with a tiny\n\nlittle step\n\nImplemented functionality, first by hardwiring it, then making it more general by replacing constants with variables\n\n(cid:127) Used Pluggable Adaptor, which we promise not to use again for four months,\n\nminimum, because it makes code hard to statically analyze\n\nBootstrapped our testing framework, all in tiny steps",
      "content_length": 603,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 114,
      "content": "CHAPTER 21\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results\n\nSettheTable\n\nWhen you begin writing tests, you will discover a common pattern (Bill Wake coined the phrase 3A for this):\n\n1. Arrange—create some objects\n\n2. Act—stimulate them\n\n3. Assert—check the results\n\nThe arrange step is often the same test-to-test, while the stimulation and checking steps are unique. I have a 7 and 9. If I add them, I expect 16. If I subtract them, I expect –2, if I multiply them, I expect 63. The stimulation and expected results are unique, the 7 and the 9 don’t change.\n\nIf this pattern repeats at different scales (and it does), then we’re faced with the question of how often do we want to create new objects to test. Looking back at our initial set of constraints, two constraints come into conflict:\n\nPerformance—we would like our tests to run as quickly as possible, so if we use similar objects in several tests we would like to create them once for all tests\n\nIsolation—we would like the success or failure of one test to be irrelevant to other tests, and if one test changes the objects, following tests are likely to change their results\n\n99",
      "content_length": 1248,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 115,
      "content": "100\n\nSet the Table\n\nTest coupling has an obvious nasty effect, where breaking one test causes the next ten to fail even though the code is correct. Test coupling can have a subtle really nasty effect, where the order of tests matters. If I run A before B, they both work, but if I run B before A, then A fails. Or even nastier, the code exercised by B is wrong, but because A ran first, the test passes.\n\nTest coupling—don’t go there. Let’s assume for the moment we can make object creation fast enough. In this case, we would like to create the objects for a test every time the test runs. We’ve already seen a disguised form of this in WasRun, where we wanted to have a flag set to false before we ran the test. Taking steps towards this, first we need a test: TestCaseTest\n\ndef testSetUp(self):\n\ntest= WasRun(\"testMethod\") test.run() assert(test.wasSetUp)\n\nRunning this, (by adding the last line “TestCaseTest(\"testSetUp\").run()” to our file) Python politely informs us that there is no “wasSetUp” attribute. Of course not. We haven’t set it. This method should do it.\n\nWasRun\n\ndef setUp(self):\n\nself.wasSetUp= 1\n\nIt would if we were calling it. Calling setUp is the job of the TestCase, so we turn there:\n\nTestCase\n\ndef setUp(self):\n\npass def run(self):\n\nself.setUp() exec \"self.\" + self.name + \"()\"\n\nThat’s two steps to get a test case running, which is too many in such ticklish cir- cumstances. We’ll see if it will work. Yes, it does pass. However, if you want to learn something, try to figure out how we could have gotten the test to pass by changing no more than one method at a time.",
      "content_length": 1595,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 116,
      "content": "We can immediately use our new facility to shorten our tests. First, we can simplify WasRun by setting the wasRun flag in setUp:\n\nWasRun\n\ndef setUp(self):\n\nself.wasRun= None self.wasSetUp= 1\n\nWe have to simplify testRunning not to check the flag before running the test. Are we willing to give up this much confidence in our code? Only if testSetUp is in place. This is a common pattern—one test can be simple if and only if another test is in place and running correctly.\n\nTestCaseTest\n\ndef testRunning(self):\n\ntest= WasRun(\"testMethod\") test.run() assert(test.wasRun)\n\nWe can also simplify the tests themselves. In both cases we create an instance of WasRun, exactly that fixture we were talking about earlier. We can create the Was- Run in setUp, and use it in the test methods. Each test method is run in a clean instance of TestCaseTest, so there is no way the two tests can be coupled (assuming the objects don’t interact in some incredibly ugly way, like setting global variables, but we wouldn’t do that, not with all those other readers watching.)\n\nTestCaseTest\n\ndef setUp(self):\n\nself.test= WasRun(\"testMethod\")\n\ndef testRunning(self): self.test.run() assert(self.test.wasRun)\n\ndef testSetUp(self): self.test.run() assert(self.test.wasSetUp)\n\nNext we’ll run tearDown() after the test method. Reviewing this chapter, we:\n\n(cid:127) Decided simplicity of test writing was more important than performance for the\n\nmoment\n\nTested and implemented setUp()\n\n101",
      "content_length": 1464,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 117,
      "content": "Invoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results\n\n102\n\nSet the Table\n\n(cid:127) Used setUp() to simplify the example test case (cid:127) Used setUp() to simplify the test cases checking the example test case (I told\n\nyou this would get like self-brain-surgery)",
      "content_length": 367,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 118,
      "content": "CHAPTER 22\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun\n\nCleaningUpAfter\n\nTests will sometimes need to allocate external resources in setUp(). If we want the tests to remain independent, a test that allocates external resources should release them before it is done, perhaps in a tearDown() method.\n\nThe simple minded way to write the test for deallocation is to introduce yet another flag. All those flags are starting to bug me, and they are missing an important aspect of the methods—setUp() is called before the test method is run, and tearDown() is called afterwards. I’m going to change the testing strategy to keep a little log of what methods are called. By always appending to the log, we will preserve the order in which the methods are called.\n\nWasRun\n\ndef setUp(self):\n\nself.wasRun= None self.wasSetUp= 1 self.log= \"setUp \"\n\nNow we can change testSetUp() to look at the log instead of the flag:\n\nTestCaseTest\n\ndef testSetUp(self): self.test.run() assert(\"setUp \" == self.test.log)\n\n103",
      "content_length": 1287,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 119,
      "content": "104\n\nCleaning Up After\n\nNow we can delete the wasSetUp flag. We can record the running of the test method, too: WasRun\n\ndef testMethod(self): self.wasRun= 1 self.log= self.log + \"testMethod \"\n\nThis breaks testSetUp, because the actual log contains “setUp testMethod ”. We change the expected value:\n\nTestCaseTest\n\ndef testSetUp(self): self.test.run() assert(\"setUp testMethod \" == self.test.log)\n\nNow this test is doing the work of both tests, so we can delete testRunning and rename testSetUp: TestCaseTest\n\ndef setUp(self):\n\nself.test= WasRun(\"testMethod\")\n\ndef testTemplateMethod(self):\n\nself.test.run() assert(\"setUp testMethod \" == self.test.log)\n\nUnfortunately, we are only using the instance if WasRun in one place, so we have to undo our clever setUp hack:\n\nTestCaseTest\n\ndef testTemplateMethod(self):\n\ntest= WasRun(\"testMethod\") test.run() assert(\"setUp testMethod \" == test.log)\n\n(Doing a refactoring based on a couple of early uses, then having to undo it soon after is fairly common. Some folks wait until they have three or four uses before refactoring because they don’t like undoing work. I prefer to spend my thinking cycles on design, so I just reflexively do the refactorings without worrying about whether I will have to undo them immediately afterward.)",
      "content_length": 1273,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 120,
      "content": "Invoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun\n\nNow we are ready to implement tearDown(). Got you! We are ready to test for tear- Down:\n\nTestCaseTest\n\ndef testTemplateMethod(self):\n\ntest= WasRun(\"testMethod\") test.run() assert(\"setUp testMethod tearDown \" == test.log)\n\nThis fails. Making it work is simple:\n\nTestCase\n\ndef run(self, result):\n\nresult.testStarted() self.setUp() exec \"self.\" + self.name + \"()\" self.tearDown()\n\nWasRun\n\ndef setUp(self):\n\nself.log= \"setUp \" def testMethod(self):\n\nself.log= self.log + \"testMethod \"\n\ndef tearDown(self):\n\nself.log= self.log + \"tearDown \"\n\nSurprisingly, we get an error, not in WasRun, but in the TestCaseTest. We don’t have a no-op implementation of tearDown() in TestCase:\n\nTestCase\n\ndef tearDown(self):\n\npass\n\nThis time we got value out of using the same testing framework we are developing. Yippee…\n\nNo refactoring necessary. The Obvious Implementation, after that one glitch, worked and was clean.\n\nNext we’ll go on to report the results of running a test explicitly, instead of letting Python’s native error handling and reporting system tell us when there is a problem with an assertion. Reviewing, in this chapter we:\n\n105",
      "content_length": 1305,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 121,
      "content": "Invoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun\n\n106\n\nCleaning Up After\n\nRestructured the testing strategy from flags to a log\n\nTested and implemented tearDown() using the new log\n\nFound a problem and, daringly, fixed it instead of backing up (was that a good idea?)",
      "content_length": 395,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 122,
      "content": "CHAPTER 23\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun\n\nCounting\n\nI was going to implement making sure tearDown() is called regardless of excep- tions during the test method. However, we have to catch exceptions to make the test work (I know, I just tried it, and backed it out.) If we make a mistake implementing this, we won’t be able to see the mistake because the exceptions won’t be reported. In general, the order of implementing the tests is important. When I pick the next test to implement, I find a test that will teach me something but which I have confi- dence I can make work. If I get that test working but get stuck on the next one, I consider backing up two steps. It would be great if your programming environment helped me with this, checkpointing the code every time all the tests ran.\n\nWhat we would like to see is the results of running any number of tests—“5 run, 2 failed, TestCaseTest.testFooBar—ZeroDivideException, MoneyTest.testNega- tion—AssertionError”. Then if the tests stop getting called, or results stop getting reported, at least we have a chance of catching the error. Having the framework automatically report all the test cases it knows nothing about seems a bit far- fetched, at least for the first test case.\n\nWe’ll have TestCase.run() return a TestResult object that records the results of run- ning the test (singular for the moment, but we’ll get to that.)\n\nTestCaseTest\n\ndef testResult(self):\n\ntest= WasRun(\"testMethod\")\n\n107",
      "content_length": 1603,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 123,
      "content": "108\n\nCounting\n\nresult= test.run() assert(\"1 run, 0 failed\" == result.summary())\n\nWe’ll start with a fake implementation:\n\nTestResult\n\nclass TestResult:\n\ndef summary(self):\n\nreturn \"1 run, 0 failed\"\n\nand return a TestResult as the result of TestCase.run()\n\nTestCase\n\ndef run(self):\n\nself.setUp() exec \"self.\" + self.name + \"()\" self.tearDown() return TestResult()\n\nNow that the test runs, we can realize (as in “make real”) the implementation of summary() a little at a time. First, we can make the number of tests run a symbol constant:\n\nTestResult\n\ndef __init__(self):\n\nself.runCount= 1\n\ndef summary(self):\n\nreturn \"%d run, 0 failed\" % self.runCount\n\n(The % operator is Python’s sprintf.) However, runCount shouldn’t be a constant, it should be computed by counting the number of tests run. We can initialize it to 0, then increment it every time a test is run.\n\nTestResult\n\ndef __init__(self):\n\nself.runCount= 0 def testStarted(self):\n\nself.runCount= self.runCount + 1\n\ndef summary(self):\n\nreturn \"%d run, 0 failed\" % self.runCount\n\nWe have to actually call this groovy new method:",
      "content_length": 1083,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 124,
      "content": "TestCase\n\ndef run(self):\n\nresult= TestResult() result.testStarted() self.setUp() exec \"self.\" + self.name + \"()\" self.tearDown() return result\n\nWe could turn the constant string “0” for the number of failed tests into a variable in the same way as we realized runCount. However, the tests don’t demand it. So, we write another test. TestCaseTest\n\ndef testFailedResult(self):\n\ntest= WasRun(\"testBrokenMethod\") result= test.run() assert(\"1 run, 1 failed\", result.summary)\n\nWhere:\n\nWasRun\n\ndef testBrokenMethod(self):\n\nraise Exception\n\nThe first thing we notice is that we aren’t catching the exception thrown by Was- Run.testBrokenMethod. We would like to catch the exception and make a note in the result that the test failed. We’ll put this test on the shelf for the moment.\n\nReviewing, we:\n\n(cid:127) Wrote a fake implementation, and gradually began making it real by replacing\n\nconstants with variables\n\n(cid:127) Wrote another test (cid:127) When that test failed, we wrote yet another test, at a smaller scale, to support\n\nmaking the failing test work\n\n109",
      "content_length": 1060,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 125,
      "content": "Invoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun Report failed tests\n\n110\n\nCounting",
      "content_length": 211,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 126,
      "content": "CHAPTER 24\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun Report failed tests\n\nDealingwithFailure\n\nWe’ll write a smaller grained test to be sure that if we note a failed test, we print out the right results.\n\nTestCaseTest\n\ndef testFailedResultFormatting(self):\n\nresult= TestResult() result.testStarted() result.testFailed() assert(\"1 run, 1 failed\" == result.summary())\n\n“testStarted()” and “testFailed()” are the messages we expect to send to the result when a test starts and when a test fails, respectively. If we can get the summary to print correctly when these messages are sent in this order, then our programming problem is reduced to how to get these messages sent. Once they are sent, we expect the whole thing to work.\n\nThe implementation is to keep a count of failures:\n\nTestResult\n\ndef __init__(self):\n\nself.runCount= 0 self.errorCount= 0\n\ndef testFailed(self):\n\n111",
      "content_length": 1010,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 127,
      "content": "112\n\nDealing with Failure\n\nself.errorCount= self.errorCount + 1\n\nWith the count correct (which I suppose we could have tested for, if we were taking teensy, weensy, tiny steps, but I won’t bother, the coffee has kicked in now), we can print correctly: TestResult\n\ndef summary(self):\n\nreturn \"%d run, %d failed\" % (self.runCount, self.failureCount)\n\nNow we expect if we call testFailed() correctly, we will get the expected answer. When do we call it? When we catch an exception in the test method:\n\nTestCase\n\ndef run(self):\n\nresult= TestResult() result.testStarted() self.setUp() try:\n\nexec \"self.\" + self.name + \"()\"\n\nexcept:\n\nresult.testFailed()\n\nself.tearDown() return result\n\nThere is a subtlety hidden inside this method. The way it is written, if a disaster happens during setUp(), the exception won’t be caught. That can’t be what we mean—we want our tests to run independently of each other. However, we need another test before we can change the code (I taught Bethany, my oldest daughter, TDD as her first programming style around age 12. She thinks you can’t type in code unless there is a broken test. The rest of us have to muddle through reminding ourselves to write the tests.) That next test and its implementation are left as an exercise for the reader (sore fingers, again.)\n\nNext we will work on getting several tests to run together. Reviewing this chapter, we:\n\n(cid:127) Made our small scale test work\n\nReintroduced the larger scale test\n\n(cid:127) Made the larger test work quickly using the mechanism demonstrated by the\n\nsmaller test",
      "content_length": 1558,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 128,
      "content": "Invoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun Report failed tests Catch and report setUp errors\n\n(cid:127) Noticed a potential problem and noted it on the to do list instead of addressing it\n\nimmediately\n\n113",
      "content_length": 339,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 129,
      "content": "114\n\nDealing with Failure",
      "content_length": 25,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 130,
      "content": "CHAPTER 25\n\nInvoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun Report failed tests Catch and report setUp errors\n\nHowSuiteItIs\n\nWe can’t leave xUnit without visiting TestSuite. The end of our file, where we invoke all the tests, is looking pretty ratty:\n\nprint TestCaseTest(\"testTemplateMethod\").run().summary() print TestCaseTest(\"testResult\").run().summary() print TestCaseTest(\"testFailedResultFormatting\").run().summary() print TestCaseTest(\"testFailedResult\").run().summary()\n\nDuplication is always a bad thing, unless you look at it as motivation to find the missing design element. What we would like here is the ability to compose tests and run them together (working hard to make them run in isolation doesn’t do us much good if we only ever run one at a time). Another good reason to implement TestSuite is that it gives us a pure example of Composite—we want to be able to treat single tests and groups of tests exactly the same.\n\nWe would like to be able to create a TestSuite, add a few tests to it, then get collec- tive results from running it.\n\nTestCaseTest\n\ndef testSuite(self):\n\nsuite= TestSuite() suite.add(WasRun(\"testMethod\")) suite.add(WasRun(\"testBrokenMethod\"))\n\n115",
      "content_length": 1316,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 131,
      "content": "116\n\nHow Suite It Is\n\nresult= suite.run() assert(\"2 run, 1 failed\" == result.summary())\n\nImplementing the add() method just adds tests to a list:\n\nTestSuite\n\nclass TestSuite:\n\ndef __init__(self):\n\nself.tests= [] def add(self, test):\n\nself.tests.append(test)\n\n(Python note: “[]” creates an empty collection.) The run method is a bit of a prob- lem. We want a single TestResult to be used by all the tests that run. Therefore, we should write:\n\nTestSuite\n\ndef run(self):\n\nresult= TestResult() for test in tests:\n\ntest.run(result)\n\nreturn result\n\n(Python note: “for test in tests” iterates through the elements of “tests”, assigning each one to “test” and evaluating the following code.) However, one of the main constraints on Composite is that the collection has to respond to the same messages as the individual items. If we add a parameter to TestCase.run(), we have to add the same parameter to TestSuite.run(). I can think of three alternatives:\n\n(cid:127) Use Python’s default parameter mechanism. Unfortunately, the default value is evaluated at compile time, not run time, and we don’t want to be reusing the same TestResult\n\nSplit the method into two parts, one which allocates the TestResult and the other which runs the test given a TestResult. I can’t think of good names for the two parts of the method, which suggests that this isn’t a good strategy\n\n(cid:127) Allocate the TestResults in the caller\n\nWe will allocate the TestResults in the callers. This pattern is called Collecting Parameter.",
      "content_length": 1506,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 132,
      "content": "TestCaseTest\n\ndef testSuite(self):\n\nsuite= TestSuite() suite.add(WasRun(\"testMethod\")) suite.add(WasRun(\"testBrokenMethod\")) result= TestResult() suite.run(result) assert(\"2 run, 1 failed\" == result.summary())\n\nThis solution has the advantage that run() now has no explicit return:\n\nTestSuite\n\ndef run(self, result): for test in tests:\n\ntest.run(result)\n\nTestCase\n\ndef run(self, result):\n\nresult.testStarted() self.setUp() try:\n\nexec \"self.\" + self.name + \"()\"\n\nexcept:\n\nresult.testFailed()\n\nself.tearDown()\n\nNow we can clean up the invocation of the tests at the end of the file:\n\nsuite= TestSuite() suite.add(TestCaseTest(\"testTemplateMethod\")) suite.add(TestCaseTest(\"testResult\")) suite.add(TestCaseTest(\"testFailedResultFormatting\")) suite.add(TestCaseTest(\"testFailedResult\")) suite.add(TestCaseTest(\"testSuite\")) result= TestResult() suite.run(result) print result.summary()\n\nThere is substantial duplication here, which we could eliminate if we had a way of constructing a suite automatically given a test class.\n\n117",
      "content_length": 1025,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 133,
      "content": "Invoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun Report failed tests Catch and report setUp errors Create TestSuite from a\n\nTestCase class\n\n118\n\nHow Suite It Is\n\nHowever, first we have to fix the 4 failing tests (they use the old no-argument run interface):\n\nTestCaseTest\n\ndef testTemplateMethod(self):\n\ntest= WasRun(\"testMethod\") result= TestResult() test.run(result) assert(\"setUp testMethod tearDown \" == test.log)\n\ndef testResult(self):\n\ntest= WasRun(\"testMethod\") result= TestResult() test.run(result) assert(\"1 run, 0 failed\" == result.summary())\n\ndef testFailedResult(self):\n\ntest= WasRun(\"testBrokenMethod\") result= TestResult() test.run(result) assert(\"1 run, 1 failed\" == result.summary())\n\ndef testFailedResultFormatting(self):\n\nresult= TestResult() result.testStarted() result.testFailed() assert(\"1 run, 1 failed\" == result.summary())\n\nNotice that each test allocates a TestResult, exactly the problem solved by setUp(). We can simplify the tests (at the cost of making them a little more difficult to read), by creating the TestResult in setUp():\n\nTestCaseTest\n\ndef setUp(self):\n\nself.result= TestResult() def testTemplateMethod(self):\n\ntest= WasRun(\"testMethod\") test.run(self.result) assert(\"setUp testMethod tearDown \" == test.log)\n\ndef testResult(self):\n\ntest= WasRun(\"testMethod\") test.run(self.result) assert(\"1 run, 0 failed\" == self.result.summary())\n\ndef testFailedResult(self):",
      "content_length": 1529,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 134,
      "content": "Invoke test method Invoke setUp first Invoke tearDown afterwards Invoke tearDown even if the test\n\nmethod fails Run multiple tests Report collected results Log string in WasRun Report failed tests Catch and report setUp errors Create TestSuite from a\n\nTestCase class\n\ntest= WasRun(\"testBrokenMethod\") test.run(self.result) assert(\"1 run, 1 failed\" == self.result.summary())\n\ndef testFailedResultFormatting(self):\n\nself.result.testStarted() self.result.testFailed() assert(\"1 run, 1 failed\" == self.result.summary())\n\ndef testSuite(self):\n\nsuite= TestSuite() suite.add(WasRun(\"testMethod\")) suite.add(WasRun(\"testBrokenMethod\")) suite.run(self.result) assert(\"2 run, 1 failed\" == self.result.summary())\n\nAll those extra “self.”s are a bit ugly, but that’s Python. If it was an object language, the self would be assumed and references to global variables would require qualifi- cation. Instead, it is a scripting language with object support (excellent object sup- port, to be sure) added, so global reference is implied and referring to self is explicit.\n\nI will leave the rest of these items to you and your new-found TDD skills.\n\nReviewing, in this chapter we:\n\n(cid:127) Wrote a test for a TestSuite (cid:127) Wrote part of the implementation, but without making the test work. This was a violation of “da roolz”. If you spotted it at the time, take two test cases out of petty cash. I’m sure there is a simple fake implementation that would have made the test case work so we could refactor under the green bar, but I can’t think what it is at the moment.\n\nChanged the interface of the run method so the item and the composite of items could work identically, then finally got the test working\n\nFactored out the common set-up code\n\n119",
      "content_length": 1739,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 135,
      "content": "120\n\nHow Suite It Is",
      "content_length": 20,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 136,
      "content": "CHAPTER 26\n\nxUnitRetrospective\n\nIf the time comes for you to implement your own testing framework, the above sequence can serve as your guide. The details of the implementation are not nearly as important as the test cases. If you can support a set of test cases like the ones above, you can write tests that are isolated and composeable, and you will be on your way to being able to develop test-first.\n\nxUnit has been ported to more than 30 languages at this writing. Your language is likely to already have an implementation. There are a couple of reasons for imple- menting it yourself even if there is a version already available:\n\n(cid:127) Mastery—The spirit of xUnit is simplicity. Martin Fowler said, “Never in the\n\nannals of software engineering was so much owed by so many to so few lines of code.” Some of the implementations have gotten a little complicated for my taste. Rolling your own will give you a tool over which you have a feeling of mastery.\n\nExploration—When I’m faced with a new programming language, I implement xUnit. By the time I have the first 8-10 tests running, I have explored many of the facilities I will be using in daily programming\n\nWhen you begin using xUnit, you will discover a big difference between assertions that fail and other kinds of errors while running tests—assertion failures consis- tently take much longer to debug. Because of this, most implementations of xUnit\n\n121",
      "content_length": 1421,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 137,
      "content": "122\n\nxUnit Retrospective\n\ndistinguish between failures—meaning assertion failures—and errors. The GUIs present them differently, often with the errors on top.\n\nJUnit declares a simple Test interface that is implemented by both TestCase and TestSuite. If you want your tests to be runnable by JUnit tools, you can implement the Test interface, too.\n\npublic interface Test {\n\npublic abstract int countTestCases(); public abstract void run(TestResult result);\n\n}\n\nLanguages with optimistic (dynamic) typing don’t even have to declare their alle- giance to an interface, they can just implement the operations. If you write a test scripting language, Script can implement countTestCases() to return 1 and run to notify the TestResult on failure and you can run your scripts along with the ordi- nary TestCases.",
      "content_length": 806,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 138,
      "content": "CHAPTER 27\n\nSectionIII:Patterns\n\nWhat follows are the “greatest hits” patterns for TDD. Some of the patterns are TDD tricks, some are design patterns, and some are refactorings.\n\nIf you are familiar with one of these topics, the patterns here will show you how the topics play with TDD. Otherwise, there is enough material here to get you through the book examples, and whet your appetite for the comprehensive treatments found elsewhere.\n\n123",
      "content_length": 443,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 139,
      "content": "124\n\nSection III: Patterns",
      "content_length": 26,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 140,
      "content": "CHAPTER 28\n\nTest-Driven DevelopmentPatterns\n\nThere are some basic strategic question we need to answer before we can talk about the details of how to test:\n\n(cid:127) What do we mean by testing? (cid:127) When do we test? (cid:127) How do we choose what logic to test? (cid:127) How do we choose what data to test?\n\nTest n.\n\nHow do you test your software? Write an automated test.\n\nTest is a verb meaning to evaluate. No programmers release even the tiniest change without testing, except the very confident and the very sloppy. I’ll assume that if you’ve gotten this far, your’re neither. While you may test your changes, testing changes is not the same as having tests. Test is also a noun, a procedure leading to acceptance or rejection. Why does “test” the noun, a procedure that runs automati- cally, feel different than “test” the verb, such as poking a few buttons and looking at answers on the screen?\n\n(What follows in an influence diagram, a la Gerry Weinberg’s Quality Software Management. An arrow between nodes means an increase in the first node implies\n\n125",
      "content_length": 1072,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 141,
      "content": "126\n\nTest-Driven Development Patterns\n\nan increase in the second. An arrow with a circle means an increase in the first node implies a decrease in the second.)\n\nWhat happens when the stress level rises?\n\nFigure 1 has Stress negatively connected to Testing negatively connected to Errors positively connected to Stress.\n\nThis is a positive feedback loop. The more stress you feel, the less testing you will do. The less testing you do, the more errors you will make. The more errors you make, the more stress you feel. Rinse and repeat.\n\nHow do you get out of such a loop? Either introduce a new element, replace one of the elements, or change the arrows. In this case we’ll replace “testing” with “auto- mated testing”.\n\nFigure 2 has Stress positively connected to Automated Testing negatively con- nected to Errors and Stress, and Errors positively connected to Stress.\n\n“Did I just break something else with that change?” With automated tests, when I start to feel stress I run the tests. Tests are the Programmer’s Stone, transmuting fear into boredom. “No, the tests are all still green.” The more stress I feel, the more I run the tests. Running the tests immediately gives me a good feeling, and reduces the number of errors I make, which further reduces the stress I feel.\n\n“We don’t have time to run the tests. Just release it!” The second picture isn’t guar- anteed. If the stress level rises high enough, it breaks down. However, with the automated tests you have a chance to choose your level of fear.\n\nShould you run the test after you write it, even though you know it’s going to fail? No, don’t bother. For example, I was working with a couple of very sharp younger programmers on implementing in-memory transactions (a very cool technique every programming language should have). How were we going to implement roll- back if we started a transaction, changed a few variables, then let the transaction be garbage collected? Simple enough to test, youngsters. Stand back and watch the master at work. Here is the test. Now how are we going to implement this?\n\nTwo hours later, hours marred with frustration because a mistake implementing such low-level features generally crashes the development environment, we rolled back to where we had started. Wrote the test. Ran it on a whim. It passed. Duh… The whole point of the transaction mechanism was that variables weren’t really",
      "content_length": 2390,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 142,
      "content": "changed until the transaction was committed. Okay, I suppose you could go ahead and run that new test if you want to.\n\nIsolated Test\n\nHow should the running of tests affect each other? Not at all.\n\nWhen I was a young programmer, long long ago when we had to dig our own bits out of the snow and carry heavy buckets of them bare-footed back to our cubicles leaving bloody little footprints for the wolves to follow… Sorry, just reminiscing. My first experience of automated tests was having a set of long-running, overnight, GUI-based tests (you know, record the keystrokes and mouse events and play them back) for a debugger I was working on (hi Jothy, hi John!). Every morning when I came in there would be a neat stack of paper on my chair describing last night’s test runs (hi Al!). On good days there would be a single sheet summarizing that nothing broke. On bad days there would be many many sheets, one for each broken test. I began to dread days when I saw a pile of paper on my chair.\n\nI took two lessons from this experience. First, make the tests so fast to run that I can run them myself, and run them often. That way I can catch errors before anyone else sees them, and I don’t have to dread coming in in the morning. Second, I noticed after a while that a huge stack of paper didn’t usually mean a huge list of problems. More often it meant that one test had broken early, leaving the system in an unpredictable state for the next test.\n\nWe tried to get around this problem by starting and stopping the system between each test, but it took too long, which taught me another lesson about seeking tests at a smaller scale than the whole application. But the main lesson I took was that tests should be able to ignore each other completely. If I had one test broken, I wanted one problem. If I had two tests broken, I wanted two problems.\n\nOne convenient implication of isolated tests is that the tests are order independent. If I want to grab a subset of tests and run them, I can do so without worrying that a test will break now because a prerequisite test is gone.\n\nPerformance is the usual reason cited for having tests share data. A second implica- tion of isolated tests is that you have to work, sometimes work hard, to break your problem into little orthogonal dimensions, so setting up the environment for each test is easy and quick. Isolating tests encourages you to compose solutions out of many highly cohesive, loosely coupled objects. I always heard this was a good idea,\n\n127",
      "content_length": 2504,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 143,
      "content": "128\n\nTest-Driven Development Patterns\n\nand I was happy when I achieved it, but I never knew exactly how to regularly achieve high cohesion and loose coupling until I started writing isolated tests.\n\nTest List\n\nWhat should you test? Before you begin, write a list of all the tests you know you will have to write.\n\nThe first part of our strategy for dealing with programming stress is to never take a step forward unless we know where our foot is going to land. When we sit down to a programming session, what is it we intend to accomplish?\n\nOne strategy for keeping track of what we’re trying to accomplish is to hold it all in our heads. I tried this for several years, and found I got into a positive feedback loop. The more experience I accumulated, the more things I knew that might need to be done. The more things I knew might need to be done, the less attention I had for what I was doing. The less attention I had for what I was doing, the less I accomplished. The less I accomplished, the more things I knew that needed to be done.\n\nJust ignoring random items on the list and programming at whim did not appear to work to break this cycle.\n\nI got in the habit of writing down everything I wanted to accomplish over the next few hours on a slip of paper next to my computer. I had a similar list, but with weekly or monthly scope pinned on the wall. As soon as I had all that written down, I knew I wasn’t going to forget something. When a new item came up, I would quickly and consciously decide whether it belonged on the “now” list, the “later” list, or it didn’t really need to be done at all.\n\nApplied to test-driven development, what we put on the list are the tests we want to implement.First, put on the list examples of every operation that you know you need to implement. Next, for those operations that don’t already exist, put the null version of that operation on the list. Finally, list all the refactorings that you think you will have to do to have clean code at the end of this session.\n\nInstead of outlining the tests, we could just go ahead and implement them all. There are a couple of reasons writing tests en masse hasn’t worked for me. First, every test you implement is a bit of inertia when you have to refactor. With automated refactoring tools (e.g. you have a menu item that renames the declaration and all uses of a variable) this is less of a problem, but when you’ve implemented ten tests",
      "content_length": 2427,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 144,
      "content": "and then you discover the arguments need to be in the opposite order, you are just that much less likely to go clean up. Second, if you have ten tests broken, you are a long way from the green bar. If you want to get to green quickly, you have to throw all ten tests away. If you want to get all the tests working, you are going to be star- ing at a red bar for a long time. If you are sufficiently addicted to the green bar you can’t go to the bathroom if the bar is red, that can be an eternity.\n\nConservative mountain climbers have a rule that of your four hands and feet, three of them must be attached at any one time. Dynamic moves where you let go of two at once are much more dangerous. The pure form of TDD, where you are never more than one change away from a green bar, is like that three out of four rule.\n\nAs you make the tests run, the implementation will imply new tests. Write the new tests down on the list. Likewise with refactorings. “This is getting ugly.” “<sigh> Put it on the list. We’ll get to it before we check in.”\n\nItems that are left on the list when the session is done need to be taken care of. If you are really half way through a piece of functionality, use the same list later. If you have discovered larger refactorings that are out of scope for the moment, move them to the “later” list. I can’t recall ever moving a test case to the “later” list. If I can think of a test that might not work, getting it to work is more important than releasing my code.\n\nTest First\n\nWhen should you write your tests? Before you write the code that is to be tested.\n\nYou won’t test after. Your goal as a programmer is running functionality. However, you need a way to think about design, you need a method for scope control.\n\nLet’s look at the usual influence diagram relating stress and testing (but not stress testing, that’s different):\n\nStress above negatively connected to testing below negatively connected to stress.\n\nThe more stress you feel, the less likely you are to test enough. When you know you haven’t tested enough, you add to your stress. Positive feedback loop. Once again, there needs to be a way to break the loop.\n\nWhat if we adopted the rule that we would always test first. Then we can invert the diagram and get a virtuous cycle:\n\n129",
      "content_length": 2278,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 145,
      "content": "130\n\nTest-Driven Development Patterns\n\nTest-first above negatively connected to stress below negatively connected to test- First..\n\nWhen we test first, we reduce the stress, which makes us more likely to test. There are lots of other elements feeding into stress, however, so the tests must live in other virtuous cycles or they will be abandoned when stress increases enough. However, the immediate payoff for testing—a design and scope control tool—sug- gests that we will be able to start doing it, and keep doing it even under moderate stress.\n\nAssert First\n\nWhen should you write the asserts? Try writing them first.\n\nDon’t you just love self-similarity?\n\n(cid:127) Where should you start building a system? With stories you want to be able to\n\ntell about the finished system.\n\n(cid:127) Where should you start writing a bit of functionality? With the tests you want to\n\npass with the finished code.\n\n(cid:127) Where should you start writing a test? With the asserts that will pass when it is\n\ndone.\n\nJim Newkirk introduced me to this technique. When I test assert-first I find it has a powerful simplifying effect. When you are writing a test, you are solving several problems at once, even if you no longer have to think about the implementation.\n\n(cid:127) Where does the functionality belong? Is it a modification of an existing method, a new method on an existing class, an existing method name implemented in a new place, or a new class?\n\n(cid:127) What should the names be called? (cid:127) How are you going to check for the right answer? (cid:127) What is the right answer? (cid:127) What other tests does this test suggest?\n\nPea-sized brains like mine can’t possibly do a good job of solving all these prob- lems at once. The two problems from the list that can be easily separated from the rest are \"what is the right answer?\" and \"how am I going to check?\"",
      "content_length": 1873,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 146,
      "content": "Here’s an example. Suppose we want to communicate with another system over a socket. When we’re done, the socket should be closed and we should have read the string \"abc\".\n\ntestCompleteTransaction() {\n\n... assertTrue(reader.isClosed()); assertEquals(\"abc\", reply.contents());\n\n}\n\nWhere does the reply come from? The socket, of course:\n\ntestCompleteTransaction() {\n\n... Buffer reply= reader.contents(); assertTrue(reader.isClosed()); assertEquals(\"abc\", reply.contents());\n\n}\n\nAnd the socket? We create it by connecting to a server:\n\ntestCompleteTransaction() {\n\n... Socket reader= Socket(\"localhost\", defaultPort()); Buffer reply= reader.contents(); assertTrue(reader.isClosed()); assertEquals(\"abc\", reply.contents());\n\n}\n\nBut before this, we need to open a server:\n\ntestCompleteTransaction() {\n\nServer writer= Server(defaultPort(), \"abc\"); Socket reader= Socket(\"localhost\", defaultPort()); Buffer reply= reader.contents(); assertTrue(reader.isClosed()); assertEquals(\"abc\", reply.contents());\n\n}\n\nNow we may have to adjust the names based on actual usage, but we have created the outlines of the test in teensy tiny steps, informing each decision with feedback within seconds.\n\n131",
      "content_length": 1184,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 147,
      "content": "132\n\nTest-Driven Development Patterns\n\nTest Data\n\nWhat data do you use for test-first tests? Use data that makes the tests easy to read and follow.\n\nYou are writing tests to an audience. Don’t scatter data values around just to be scattering data values around. If there is a difference in the data, it should be mean- ingful. If there isn’t a conceptual difference between 1 and 2, use 1.\n\nTest Data isn’t a license to stop short of full confidence. If your system has to han- dle multiple inputs, your tests should reflect multiple inputs. However, don’t have a list of 10 items as the input data if a list of 3 items will lead you to the same design and implementation decisions.\n\nOne trick in Test Data is to try to never use the same constant to mean more than one thing. If I am testing a plus() method, it is tempting to test 2 + 2, since that is the classic example of addition, or 1 + 1, since that is so simple. What if we got the arguments reversed in the implementation? (Okay, okay, that doesn’t matter in the case of plus(), but you get the idea.) If we use 2 for the first argument we should use 3, for example, for the second. (“3 + 4” was a watershed test case when bringing up a new Smalltalk virtual machine back in the olden days.)\n\nThe alternative to Test Data is Realistic Data, where you use data from the real world. Realistic Data is useful when:\n\n(cid:127) You are testing real-time systems using traces of external events gathered from\n\nthe actual execution\n\n(cid:127) You are matching the output of the current system with the output of a previous\n\nsystem (Parallel Testing)\n\n(cid:127) You are refactoring a simulation and expect precisely the same answers when you are finished, particularly if floating point accuracy may be a problem\n\nEvident Data\n\nHow do you represent the intent of the data? Include expected and actual results in the test itself, and try to make their relationship apparent.\n\nYou are writing tests for a reader, not just the computer. Someone in decades to come will be asking themselves the question, \"What in the heck was this joker",
      "content_length": 2085,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 148,
      "content": "thinking about?\" You’d like to leave as many clues as possible, especially if that frustrated reader is going to be you.\n\nHere’s an example. If we convert from one currency to another, we take a 1.5% commission on the transaction. If the exchange rate from USD to GBP is 2:1, then if we exchange $100, we should get 50 GBP - 1.5% = 49.25 GBP. We could write this test like this:\n\nBank bank= new Bank(). bank.addRate(\"USD\", \"GBP\", STANDARD_RATE); bank.commission(STANDARD_COMMISSION); Money result= bank.convert(new Note(100, \"USD\"), \"GBP\"); assertEquals(new Note(49.25, \"GBP\"), result);\n\nor we could try to make the calculation obvious:\n\nBank bank= new Bank(); bank.addRate(\"USD\", \"GBP\", 2); bank.commission(0.015); Money result= bank.convert(new Note(100, \"USD\"), \"GBP\"); assertEquals(new Note(100 / 2 * (1 - 0.015), \"GBP\"), result);\n\nI can read this test and see the connection between the numbers used in the input and the numbers used to calculate the expected result.\n\nOne beneficial side effect of Evident Data is that it makes programming easier. Once we’ve written the expression in the assertion, we know what we need to pro- gram. Somehow we have to get the program to evaluate a division and a multiplica- tion. We can even use Fake It to discover where the operations belong incrementally.\n\nEvident Data seems to be an exception to the rule that you don’t want magic num- bers in your code. Within the scope of a single method, the relationship between the 5’s is obvious. If I had symbolic constants that were already defined, though, I would use the symbolic form.\n\nFurther Study\n\nBob Binder, Testing Object-Oriented Systems: Models, Patterns, and Tools, Addi- son-Wesley, 1999, ISBN 0201809389 is the comprehensive reference on testing.\n\n133",
      "content_length": 1756,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 149,
      "content": "134\n\nTest-Driven Development Patterns\n\nBrian Marick, Craft of Software Testing: Subsystems Testing Including Object- Based and Object-Oriented Testing, Prentice-Hall, 1997, ISBN 0131774115 is a more pragmatic look at testing.\n\n???others???",
      "content_length": 239,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 150,
      "content": "CHAPTER 29\n\nRedBarPatterns\n\nThese patterns are about when you write tests, where you write tests, and when you stop writing tests.\n\nOne Step Test\n\nWhich test should you pick next from the list? Pick a test that will teach you some- thing and that you are confident you can implement.\n\nEach test should represent one step towards your overall goal. If we are looking at the following Test List, which test should we pick next?\n\n135",
      "content_length": 430,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 151,
      "content": "136\n\nRed Bar Patterns\n\nPlus Minus Times Divide Plus like Equals Equals null Null exchange Exchange one currency Exchange two currencies Cross rate\n\nThere is no right answer. What is one step for me, never having implemented these objects before, will be one tenth of a step to you, with your vast experience.\n\nWhen I look at a Test List, I think, “That’s obvious, that’s obvious, I have no idea, obvious, what was I thinking about with that one, ah, this one I can do.” That last test is the test I implement next. It didn’t strike me as obvious, but I’m also confi- dent I can make it work.\n\nIf you don’t find any test on the list that represents one step, add some new tests that would represent progress towards the items there.\n\nA program grown from tests like this can appear to be written top-down, because you can begin with a test that represents a simple case of the entire computation. A program grown from tests can also appear to be written bottom-up, because you start with small pieces and aggregate them larger and larger.\n\nNeither top-down nor bottom-up really describes the process helpfully. First, a ver- tical metaphor is a simplistic visualization of how programs change over time. “Growth” implies a kind of self-similar feedback loop where the environment affects the program and the program affects the environment. Second, if we have to have a direction in our metaphor, “known-to-unknown” is a helpful description. Known-to-unknown implies that we have some knowledge and experience on which to draw, and that we expect to learn in the course of development. Put these two together and we have programs growing from known to unknown.\n\nStarter Test\n\nWhich test should you start with? Start by testing a variant of an operation that doesn’t do anything.",
      "content_length": 1777,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 152,
      "content": "The first question you have to ask with a new operation is \"Where does it belong?\" Until you’ve answered this question, you don’t know what to type for the test. In the spirit of solving one problem at a time, how can we answer just this question and no other?\n\nIf you write a “realistic” test first, you will find yourself solving a bunch of prob- lems at once:\n\n(cid:127) Where does the operation belong? (cid:127) What are the correct inputs? (cid:127) What is the correct output given those inputs?\n\nBeginning with a realistic test will leave you too long without feedback. Red/green/ refactor, red/green/refactor. You want that loop to be minutes.\n\nYou can shorten the loop by choosing inputs and outputs that are trivially easy to discover. For example, a poster on the Extreme Programming newsgroup asked about how to write a polygon reducer test-first. The input is a mesh of polygons and the output is a mesh of polygons that describes precisely the same surface, but with the fewest possible polygons. “How can I test-drive this problem since getting a test to work requires reading Ph.D. theses?”\n\nStarter Test provides an answer:\n\nThe output should be the same as the input. Some configurations of polygons are already normalized, incapable of further reduction.\n\nThe input should be as small as possible, like a single polygon, or even an empty list of polygons.\n\nMy Starter Test looked like this:\n\nReducer r= new Reducer(new Polygon()); assertEquals(0, reducer.result().npoints);\n\nBing! First test is running. Now for all the rest of the tests on the list...\n\nOne Step Test applies. Pick a Starter Test that will teach you something but that you are certain you can get working quickly. If you are implementing something for the Nth time, pick a test that will require an operation or two. You will be justi- fiably confident you can get it working. If you are implementing something hairy and complicated for the first time, you need a little courage pill immediately.\n\n137",
      "content_length": 1988,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 153,
      "content": "138\n\nRed Bar Patterns\n\nI find that my Starter Test is often at a higher level, more like an application test, than the following tests. One example I often test-drive is a simple socket-based server. The first test looks like this:\n\nStartServer Socket= new Socket Message= “hello” Socket.write(message) AssertEquals(message, socket.read)\n\nThe rest of the tests are written in the server alone, “assuming we receive a string like this…”\n\nAnother Starter Test came from the game of Life. The folks discussing it were talk- ing about tests for cells, and sizes, and two dimensional arrays vs. hash tables with points as keys. My Starter Test looked like this:\n\nExplanation Test\n\nHow do you spread the use of automated testing? Ask for and give explanations in terms of tests.\n\nIt can be frustrating to be the only TDD on a team. Soon, you will notice fewer inte- gration problems and defect reports in tested code, and the designs will be simpler and easier to explain. It has even happened before that folks get downright enthusi- astic about testing, and testing first.\n\nBeware the enthusiasm of the newly converted. Nothing will stop the spread of TDD faster than pushing it in people’s faces. If you’re a manager or leader, you can’t force anyone to change the way they work.\n\nWhat can you do? A simple start is to start asking for explanations in terms of test cases. “Let me see if I understand what you’re saying. For example, if I have a Foo like this and a Bar like that then the answer should be 76?” A companion technique is to start giving explanations in terms of tests. “Here’s how it works now. When I have a Foo like this and a Bar like that, the answer is 76. If I have a Foo like that and a Bar like this, though, I would like the answer to be 67.”\n\nYou can do this at higher levels of abstraction. If someone is explaining a sequence diagram to you, you can ask for permission to convert it to a more familiar notation.",
      "content_length": 1935,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 154,
      "content": "Then you type in a test case that contains all the externally visible objects and mes- sages in the diagram.\n\nLearning Test1\n\nWhen do you write tests for externally produced software? Before the first time you are going to use a new facility in the package.\n\nLet’s say we are going to develop something on top of the Mobile Information Device Profile library for Java. We want to store some data in the RecordStore and retrieve it. Do we just write the code and expect it to work? That’s one way to develop.\n\nAn alternative is to notice that we are about to use a new method of a new class. Instead of just using it, we write a little test that verifies that the API works as expected. So, we might write:\n\nRecordStore store;\n\npublic void setUp() {\n\nstore= RecordStore.openRecordStore(\"testing\", true);\n\n}\n\npublic void tearDown() {\n\nRecordStore.deleteRecordStore(\"testing\");\n\n}\n\npublic void testStore() {\n\nint id= store.addRecord(new byte[] {5, 6}, 0, 2); assertEquals(2, store.getRecordSize(id)); byte[] buffer= new byte[2]; assertEquals(2, store.getRecord(id, buffer, 0)); assertEquals(5, buffer[0]); assertEquals(6, buffer[1]);\n\n}\n\nIf our understanding of the API is correct, the test will pass first time.\n\n1. Thanks to Jim Newkirk and Laurent Bossavit for independently sug- gesting this pattern.\n\n139",
      "content_length": 1306,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 155,
      "content": "140\n\nRed Bar Patterns\n\nJim Newkirk reported on a project in which Learning Tests were routinely written. When new releases of the package arrived, first the tests were run (and fixed, if nec- essary.) If the tests didn’t run, there was no sense running the application because it certainly wouldn’t run. Once the tests ran, the application ran every time.\n\nAnother Test\n\nHow do you keep a technical discussion from straying off topic? When a tangential idea arises, add a test to the list and go back to the topic.\n\nI love wandering discussions (you’ve read most of the book now, so you’ve proba- bly reached that conclusion yourself). Keeping a conversation strictly on course is a great way to stifle brilliant ideas. You hop from here to there to there, and how did we get here? Who cares, this is cool!\n\nSometimes programming relies on breakthroughs. Most programming, though, is a bit more pedestrian. I have ten things to implement. I become an accomplished pro- crastinator about item number four. Retreating to hummingbird conversation is one of my ways of avoiding work (and maybe the fear that goes along with it.)\n\nWhole unproductive days have taught me that at times it’s best to stay on track. When I’m feeling this way, new ideas are greeted with respect, but not allowed to divert my attention. I write them down on the list, and get back to what I was work- ing on.\n\nRegression Test\n\nWhat’s the first thing you do when a defect is reported? Write the smallest possible test that fails, and that once it runs, the defect will be repaired.\n\nRegression tests are tests that, with perfect foreknowledge, you would have written when coding originally. Every time you have to write a regression test, think about how you could have known to write the test in the first place.\n\nYou will also gain value by testing at the level of the whole application. Regression tests for the application give your users a chance to speak concretely to you about what is wrong and what they expect. Regression tests at the smaller scale are a way for you to improve your testing. The defect report will be about a bizarre large neg- ative number in a report. The lesson for you is that you need to test for integer roll- over when you are writing your test list.",
      "content_length": 2256,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 156,
      "content": "You may have to refactor the system before you can easily isolate the defect. The defect in this case was your system’s way of telling you, “You aren’t quite done designing me yet.”\n\nBreak\n\nWhat do you do when you feel tired or stuck? Take a break.\n\nTake a drink, take a walk, take a nap. Wash your hands clean of your emotional commitment to the decisions you just made and the characters you typed.\n\nOften, this amount of distance is all it will take to break loose the idea you’ve been lacking. You’ll just be standing up when you realize, “I haven’t tried it with the parameters reversed!” Take the break anyway. Give yourself a couple of minutes. The idea won’t go away.\n\nIf you don’t get “the idea”, review your goals for the session. Are they still realistic or should you pick new goals? Is what you were trying to accomplish impossible? If so, what are the implications for the team?\n\nDave Ungar calls this his Shower Methodology. If you know what to type, type. If you don’t know what to type, take a shower. Many teams would be happier, more productive, and smell a whole lot better if they took his advice.\n\nTDD is a refinement on the Ungar Shower Methodology. If you don’t know what to type, fake it. If the “right” design still isn’t clear, triangulate. If you still don’t know what to type, then you can take that shower.\n\nHere is an influence diagram that shows the positive feedback loop at work:\n\nFatigue negatively affects judgement which negatively affects fatigue\n\nYou’re getting tired, so you’re less capable of realizing that you’re tired, so you keep going and get more tired.\n\nThe way out of this loop is to introduce an additional outside element.\n\n(cid:127) At the scale of hours, keep a water bottle by your keyboard so biology provides\n\nthe motivation for regular breaks.\n\n(cid:127) At the scale of a day, commitments after regular work hours can help you stop\n\nwhen you need sleep before progress.\n\n141",
      "content_length": 1932,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 157,
      "content": "142\n\nRed Bar Patterns\n\n(cid:127) At the scale of a week, weekend commitments help get your conscious, energy-\n\nsucking thoughts off work. (My wife swears I get my best ideas Friday evening.)\n\n(cid:127) At the scale of a year, mandatory vacation policies help you refresh yourself\n\ncompletely. The French do this right—two contiguous weeks of vacation aren’t enough. You spend the first week decompressing, and the second week getting ready to go back to work. Therefore three weeks, or better four, are necessary for you to be your most effective the rest of the year.\n\nThere is a flip side to taking breaks. Sometimes when faced with a tough problem what you need to do is press on, push through it. However, programming culture is so infected with macho, “I’ll ruin my health, alienate my family, and kill myself if necessary,” spirit that I don’t feel compelled to give any advice along these lines. If you find yourself caffeine-addicted and making no progress whatsoever, perhaps you shouldn’t take quite so many breaks. In the meantime, take a walk.\n\nDo Over\n\nWhat do you do when you are feeling lost? Throw away the code and start over.\n\nYou’re lost. You’ve taken the break, rinsed your hands in the brook, sounded the Tibetan temple bell, and still you’re lost. The code that was going so well an hour ago is now a mess, you can’t think of how to get the next test case working, and you’ve thought of 20 more tests that you really should implement.\n\nThis has happened to me several times in writing this book. I would get the code a bit twisted. “But I have to finish the book. The children are starving and the bill col- lectors are pounding on the door.” My gut reaction would be to untwist it just enough to move on. After a pause for reflection, starting over always made more sense. The one time I pressed on regardless, I had to throw away 25 pages of manu- script because it was based on an obviously stupid programming decision.\n\nMy favorite example of Do Over is a story Tim Mackinnon told me. He was inter- viewing someone by the simple expedient of asking her to pair program with him for an hour. At the end of the session, they’d implemented several new test cases and done some nice refactoring. It was the end of the day, though, and they felt tired when they were done, so they discarded their work.\n\nIf you pair program, switching partners is a good way to motivate productive Do Overs. You’ll try to explain the complicated mess you made for a few minutes",
      "content_length": 2481,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 158,
      "content": "when your new partner, completely uninvested in the mistakes you’ve made, will gently take the keyboard and say, “I’m terribly sorry for being so dense, but what if we started like this…”\n\nCheap Desk, Nice Chair\n\nWhat physical setup should you use for test-driven development? Get a really nice chair, skimping on the rest of the furniture if necessary.\n\nYou can’t program well if your back hurts. Yet, organizations that will spend a hun- dred thousand dollars a month on a team won’t spend ten thousand dollars on decent chairs.\n\nMy solution is to use cheap, ugly folding tables for my computers, but buy the best chairs I can find. I have plenty of desk space, and I can easily get more, and I am fresh and ready for programming in the afternoon and the morning.\n\nGet comfortable when you’re pair programming. Clean off the desk surface enough that you can slide the keyboard back and forth. Each partner should be able to sit comfortably directly in front of the keyboard when they are driving. One of my favorite coaching tricks is to come up behind a pair that is hacking away and gently slide the keyboard so it is comfortably placed for the person typing.\n\nManfred Lange points out that careful resource allocation also applies to computer hardware. Get cheap/slow/old machines for individual email and surfing, and the hottest possible machines for shared development.\n\nFurther Study\n\nTom DeMarco and Tim Lister, Peopleware, Dorset House, 1999, ISBN 0932633439 is an excellent introduction to the people side of computing.\n\nConstantine, Peopleware Paper\n\nWeinberg, Psychology of Computer Programming,\n\n143",
      "content_length": 1614,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 159,
      "content": "144\n\nRed Bar Patterns",
      "content_length": 21,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 160,
      "content": "CHAPTER 30\n\nTestingPatterns\n\nChild Test\n\nHow do you get a test case running that turns out to be too big? Write a smaller test case that represents the broken part of the bigger test case. Get the smaller test case running. Reintroduce the larger test case.\n\nThe red/green/refactor rhythm is so important for continuous success that when you are at risk of losing it, it is worth extra effort to maintain it. This commonly hap- pens to me when I write a test that accidentally requires several changes to make work. Even ten minutes with a red bar gives me the willies.\n\nWhen I write a test that is too big, I first try to learn the lesson. Why was it too big? What could I have done differently that would have made it smaller? How am I feeling right now?\n\nMetaphysical navel gazing accomplished, I delete the offending test and start over. “Well, getting these three things working at once was too much. If I had A, B, and C working, though, getting the whole thing working would be a cinch.” Sometimes I really delete the test, sometimes I just change the name to begin with an “x” so it won’t be run. (Can I tell you a secret? Sometimes I don’t even bother to delete the offending test. Shhhhh… I live with two, count ‘em two, broken tests for a matter of a couple of minutes while I get the child test working. I could be making a mis-\n\n145",
      "content_length": 1345,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 161,
      "content": "146\n\nTesting Patterns\n\ntake when I do this. Two broken tests could easily be a holdover from my bad old test-last-if-ever days.)\n\nTry it both ways yourself. See if you feel different, program different, when you have two tests broken. Respond as appropriate.\n\nMock Object\n\nHow do you test an object that relies on an expensive or complicated resource? Cre- ate a fake version of the resource that answers constants.\n\nThere is at least a book’s worth of material in Mock Object1, but this will serve as an introduction.\n\nThe classic example is a database. Databases take a long time to start, they are dif- ficult to keep clean, and if they are located on a remote server, they tie your tests to a physical location on a network. The database is also a fertile source of error in development.\n\nThe solution is not to use a real database most of the time. Most tests are written in terms of an object that acts like a database, but is really just sitting in memory.\n\npublic void testOrderLookup() {\n\nDatabase db= new MockDatabase(); db.expectQuery(\"select order_no from Order where cust_no is\n\n123\");\n\ndb.returnResult(new String[] {\"Order 2\" ,\"Order 3\"}); …\n\n}\n\nIf the MockDatabase does not get the query it expects, it throws an exception. If the query is correct, it returns something that looks like a result set constructed from the constant strings.\n\nAnother value of mocks, aside from performance and reliability, is readability. You can read the test above from one end to another. If you have a test database full of realistic data, when you see that a query should have resulted in 14 replies, you have no idea why 14 is the right answer.\n\n1. For example, see www.mockobjects.com.",
      "content_length": 1687,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 162,
      "content": "If you want to use Mock Objects, you can’t easily store expensive resources in glo- bal variables (even if they masquerade as Singletons). If you do, you will have to set the global to a Mock Object, run the test, and be sure to reset the global when you are done\n\nThere have been times when I was furious at this restriction. Massimo Arnoldi and I were working on some code relying on a set of exchange rates stored in a global variable. Each test needed different subsets of the data, and sometimes they needed different exchange rates. After a while of trying to get the global variable to work, we decided one morning (courageous design decisions come more often in the morning for me) to just pass the Exchange around wherever we needed it. We thought we would have to modify hundreds of methods. In the end, we added a parameter to ten or fifteen methods, and cleaned up other aspects of the design along the way.\n\nMocks will encourage you down the path of carefully considering the visibility of every object, reducing the coupling in your designs.\n\nMock Objects add a risk to the project—what if the mock doesn’t behave like the real object? You can reduce this strategy by having a set of tests for the mock that can also be applied to the real object when it becomes available.\n\nSelf Shunt\n\nHow do you test that one object communicates correctly with another? Have the object under test communicate with the test case instead of with the object it expects.\n\nSuppose we wanted to dynamically update the green bar on the testing user inter- face. If we could connect an object to the TestResult, it could be notified when a test ran, when it failed, when a whole suite started and finished, and so on. When- ever we were notified that a test ran, we would update the interface. Here’s a test for this:\n\nResultListenerTest\n\ndef testNotification(self): result= TestResult() listener= ResultListener() result.addListener(listener) WasRun(\"testMethod\").run(result) assert 1 == listener.count\n\n147",
      "content_length": 2000,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 163,
      "content": "148\n\nTesting Patterns\n\nThe test needs an object to count the number of notifications:\n\nResultListener\n\nclass ResultListener: def __init__(self): self.count= 0 def startTest(self):\n\nself.count= self.count + 1\n\nBut wait. Why do we need a separate object for the listener? We can just use the test case itself. The TestCase itself becomes a kind of Mock Object.\n\nResultListenerTest\n\ndef testNotification(self):\n\nself.count= 0 result= TestResult() result.addListener(self) WasRun(\"testMethod\").run(result) assert 1 == self.count\n\ndef startTest(self):\n\nself.count= self.count + 1\n\nTests written with Self Shunt tend to read better than tests written without. The test above is a good example. The count was 0, and then it was 1. How did it get to be 1? Someone must have called startTest(). How did startTest() get called? It must happen when running the test. This is another example of symmetry—the second version of the test method has the two values for count in one place, where in the first version the count is set to 0 in one class and expected to be 1 in another.\n\nSelf Shunt may require that you use Extract Interface to get an interface to imple- ment. You will have to decide whether extracting the interface is easier or if testing the existing class as a black box is easier. I have noticed, though, that interfaces extracted for shunts tend to get their third and subsequent implementations soon thereafter.\n\nAs a result of using Self Shunt, you will see tests in Java implementing all sorts of bizarre interfaces. In optimistically typed languages, the test case class need only implement those operations that are actually used in the running of the test. In Java, however, you have to implement all the operations of the interface, even if most of the implementations are empty, so you would like interfaces to be as narrow as pos- sible. The implementations should either return a reasonable value or throw an",
      "content_length": 1923,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 164,
      "content": "exception, depending on whether you want to be notified if an unexpected opera- tion is invoked.\n\nLog String\n\nHow do you test that the sequence in which messages are called is correct? Keep a log in a string, and append to the string when a message is called.\n\nThe example from xUnit serves. We have a Template Method which we expect to call setUp(), a testing method, and tearDown(), in that order. By implementing the methods to record in a string that they were called, the test reads nicely:\n\ndef testTemplateMethod(self):\n\ntest= WasRun(\"testMethod\") result= TestResult() test.run(result) assert(\"setUp testMethod tearDown \" == test.log)\n\nAnd the implementation is simple, too:\n\nWasRun\n\ndef setUp(self):\n\nself.log= \"setUp \" def testMethod(self):\n\nself.log= self.log + \"testMethod \"\n\ndef tearDown(self):\n\nself.log= self.log + \"tearDown \"\n\nLog Strings are particularly useful when you are implementing Observer and you expect notifications to come in a certain order. If you expected certain notifications but you didn’t care about the order, you could keep a set of strings, and use set comparison in the assertion.\n\nLog String works well with Self Shunt. The test case implements the methods in the shunted interface by adding to the log and then returning reasonable values.\n\nCrash Test Dummy\n\nHow do you test error code that is unlikely to be invoked? Invoke it anyway with a special object that throws an exception instead of doing real work.\n\n149",
      "content_length": 1454,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 165,
      "content": "150\n\nTesting Patterns\n\nCode that isn’t tested doesn’t work. This seems to be the safe assumption. What to do with all those odd error conditions, then? Do you have to test them, too? Only if you want them to work.\n\nLet’s say we want to test what happens to our application when the file system is full. We could go to a lot of work to create many big files and fill the file system, or we could fake it. “Fake it” doesn’t sound dignified, does it? We’ll simulate it.\n\nHere’s our crash test dummy for a file:\n\nprivate class FullFile extends File { public FullFile(String path) {\n\nsuper(path);\n\n} public boolean createNewFile() throws IOException {\n\nthrow new IOException();\n\n}\n\n}\n\nNow we can write our Expected Exception test:\n\npublic void testFileSystemError() { File f= new FullFile(\"foo\"); try {\n\nsaveAs(f); fail();\n\n} catch (IOException e) { }\n\n}\n\nA Crash Test Dummy is like a Mock Object, except you don’t need to Mock up the whole object. Java’s anonymous inner classes work well for sabotaging just the right method to simulate the error we want to exercise. You can override just the one method you want, right there in your test case, making the the test case easier to read:\n\npublic void testFileSystemError() {\n\nFile f= new File(\"foo\") {\n\npublic boolean createNewFile() throws IOException {\n\nthrow new IOException();\n\n}\n\n};",
      "content_length": 1333,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 166,
      "content": "try {\n\nsaveAs(f); fail();\n\n} catch (IOException e) { }\n\n}\n\nBroken Test\n\nHow do you leave a programming session when you’re programming alone? Leave the last test broken.\n\nRichard Gabriel taught me the trick of finishing a writing session in mid-sentence. When you sit back down, you look at the half sentence and you have to figure out what you were thinking when you wrote it. Once you have the thought thread back, you finish the sentence and continue. Without the urge to finish the sentence, you can spend many minutes first sniffing around for what to work on next, then trying to remember your mental state, then finally getting back to typing.\n\nI tried the analogous technique for my solo projects and I really like the effect. Fin- ish a solo session by writing a test case and running it to be sure it doesn’t pass. When you come back to the code, you have an obvious place to start, you have an obvious, concrete bookmark to help you remember what you were thinking, and making that test work should be quick work, so you’ll quickly get your feet back on that victory road.\n\nI thought it would bother me to have a test broken overnight. It doesn’t, I think because I know that the program isn’t finished. A broken test doesn’t make the pro- gram any less finished, it just makes the status of the program manifest. The ability to quickly pick up a thread of development after weeks of hiatus is worth that little twinge of walking away from a red bar.\n\nClean Check-in\n\nHow do you leave a programming session when you’re programming in a team? Leave all the tests running.\n\n“Do I contradict myself? Tough.”\n\n–Bubba Whitman, Walt’s stevedore brother\n\n151",
      "content_length": 1662,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 167,
      "content": "152\n\nTesting Patterns\n\nWhen you are responsible to your teammates, the picture changes completely. When you start programming on a team project, you don’t know in detail what has happened to the code since you saw it last. You need to start from a place of confi- dence and certainty. Therefore, always make sure all the tests are running before you check in your code (a bit like how each test case leaves the world in a known- good state, if you are prone to computer metaphors for human behavior, which I’m not (usually)).\n\nThe test suite you run when you check in may be more extensive than the one you are running every minute during development (don’t give up on running the whole suite all the time until it is slow enough to be annoying). You will occasionally find a test broken in the integration suite when you try to check in. What to do?\n\nThe simplest rule is to just throw away your work and start over. The broken test is pretty strong evidence that you didn’t know enough to program what you just pro- grammed. If the team adopted this rule, there would be a tendency for folks to check in more often because the first person to check in doesn’t risk losing any work. Checking in more often is probably a good thing.\n\nA slightly more libertine approach is to give you a chance to fix the defect and try again. To keep from dominating the integration resources, you should probably give up after a few minutes and start over. It goes without saying, so I’ll say it any- way, that commenting out tests to make the suite pass is strictly verboten, and grounds for some serious beer purchasing at that Friday late afternoon’s offsite planning meeting.\n\nFurther Study\n\n???version control/configuration management???\n\nwww.mockobjects.com",
      "content_length": 1747,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 168,
      "content": "CHAPTER 31\n\nGreenBarPatterns\n\nOnce you have a broken test, you need to fix it. If you treat a red bar as a condition to be fixed as quickly as possible, you will discover that you can get to green quickly. These patterns are how to make the code pass (even if the result isn’t something you want to live with for even an hour).\n\nFake It (‘Til You Make It)\n\nWhat is your first implementation once you have a broken test? Return a constant. Once you have the test running, gradually transform the constant into an expression using variables.\n\nA simple example occurred in our implementation of xUnit.\n\nreturn \"1 run, 0 failed\"\n\nbecame:\n\nreturn \"%d run, 0 failed\" % self.runCount\n\nbecame:\n\nreturn \"%d run, %d failed\" % (self.runCount , self failureCount)\n\n153",
      "content_length": 756,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 169,
      "content": "154\n\nGreen Bar Patterns\n\nFake It is a bit like driving a piton above your head when you are climbing a rock. You haven’t really gotten there yet (the test is there but the code structure is wrong). However, when you do get there, you know you will be safe (the test will still run).\n\nFake It really rubs some people the wrong way. Why would you do something that you know you have to rip out? Because having something running is better than not having something running, especially if you have the tests to prove it. Peter Hansen submitted this story:\n\n… something happened just yesterday where, as two newbies to TDD, my partner and I aggressively stuck to the letter of the law and committed sins to get a test working quickly. In the process, we realized we had not properly implemented the test so we went back and fixed that, then made the code work again. The first working code ended up not being anywhere in sight by the time it worked again and we sort of looked at each other and said, “Huh... would you look at that!” because that approach had taught us something we didn’t know.\n\nHow could a fake implementation have taught them their test was written wrong? I don’t know, but I’ll bet they were glad they didn’t invest in the real solution to find out.\n\nThere are a couple of effects that make Fake It powerful:\n\nPsychological—Having a green bar feels completely different than having a red bar. When the bar is green, you know where you stand. You can refactor from there with confidence.\n\nScope control—Programmers are good at imagining all sorts of future prob- lems. Starting with one concrete example and generalizing from there prevents you from prematurely confusing yourself with extraneous concerns. You can do a better job of solving the immediate problem because you are focused. When you go to implement the next test case, you can focus on that one, too, knowing that the previous test is guaranteed to work.\n\nDoes Fake It violate the rule that says you don’t write any code that isn’t needed? I don’t think so, because in the refactoring step you are eliminating duplication of data between the test case and the code. When I write1:\n\nassertEquals(new MyDate(\"28.2.02\"), new MyDate(\"1.3.02\").yesterday());\n\n1. Thanks to Dierk König for the example.",
      "content_length": 2275,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 170,
      "content": "MyDate\n\npublic MyDate yesterday() {\n\nreturn new MyDate(\"28.2.02\");\n\n}\n\nThere is duplication between the test and the code. I can shift it around by writing:\n\nMyDate\n\npublic MyDate yesterday() {\n\nreturn new MyDate(new MyDate(\"31.3.02\").days()-1);\n\n}\n\nBut there is still duplication. However, I can eliminate the data duplication (because this = MyDate(“31.1.02”) for the purposes of my test) by writing:\n\nMyDate\n\npublic MyDate yesterday() {\n\nreturn new MyDate(this.days()-1);\n\n}\n\nNot everyone is convinced by this bit of sophistry, which is why you can Triangu- late, at least until you are tired of it and start using Fake It or even Obvious Imple- mentation.\n\nWhen I use Fake It, I’m reminded of long car trips with kids in the back. I write the first test, I make it work some ugly way, and then, “Don’t make me stop this car and write another test. If I have to pull over, you’ll be sorry.” “Okay, okay, Dad. I’ll clean the code up. You don’t have to get all huffy.”\n\nTriangulate\n\nHow do you most conservatively drive abstraction with tests? Only abstract when you have two or more examples.\n\nHere’s an example. Suppose we want to write a function that will return the sum of two integers. We write:\n\npublic void testSum() {\n\nassertEquals(4, plus(3, 1));\n\n}\n\n155",
      "content_length": 1265,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 171,
      "content": "156\n\nGreen Bar Patterns\n\nprivate int plus(int augend, int addend) {\n\nreturn 4;\n\n}\n\nIf we are triangulating to the right design, we have to write:\n\npublic void testSum() {\n\nassertEquals(4, plus(3, 1)); assertEquals(7, plus(3,4));\n\n}\n\nWhen we have the second example, we can abstract the implementation of plus():\n\nprivate int plus(int augend, int addend) {\n\nreturn augend + addend;\n\n}\n\nTriangulation is attractive because the rules for it seem so clear. The rules for Fake It, where we are relying on our sense of duplication between the test case and the fake implementation to drive abstraction, seem a bit vague and subject to interpre- tation. While they seem simple, the rules for triangulation create an infinite loop. Once we have the two assertions and we have abstracted the correct implementa- tion for plus, we can delete one of the assertions on the grounds that it is completely redundant with the other. If we do that, however, we can simplify the implementa- tion of plus() to just return a constant, which requires us to add an assertion.\n\nI only use triangulation when I’m really, really unsure about the correct abstraction for the calculation. Otherwise I rely on either Obvious Implementation or Fake It.\n\nObvious Implementation\n\nHow do you implement simple operations? Just implement them.\n\nFake It and Triangulation are teensy-weensy tiny steps. Sometimes you are sure you know how to implement an operation. Go ahead. For example, would I really use Fake It to implement something as simple as plus()? Not usually. I would just type in the obvious implementation. If I noticed I was getting surprised by red bars, I would go to smaller steps.\n\nThere’s no particular virtue in the halfway nature of Fake It and Triangulate. If you know what to type, and you can do it quickly, do it. However, by using only Obvi-",
      "content_length": 1833,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 172,
      "content": "ous Implementation, you are demanding perfection of yourself2. Psychologically, this can be a devastating move. What if what you write isn’t really the simplest change that could get the test to pass? What if your partner shows you an even sim- pler one? You’re a failure! Your world crumbles around you! You die. Freeze up.\n\nSolving “clean code” at the same time you solve “that works” can be too much to do at once. As soon as it is, go back to solving “that works,” then “clean code” at leisure.\n\nKeep track of how often you get surprised by red bars using Obvious Implementa- tion. I’ll get stuck in these cycles where I’ll type in an Obvious Implementation. It won’t work. But now I’m sure I know what I should type, so I type that. It doesn’t work. So now… This especially happens with off by one errors and positive/nega- tive errors.\n\nYou want to maintain that red/green/refactor rhythm. Obvious Implementation is second gear. Be prepared to downshift if your brain starts writing checks your fin- gers can’t cash.\n\nOne to Many\n\nHow do you implement an operation that works with collections of objects? Imple- ment it without the collections first, then make it work with collections.\n\nFor example, suppose we are writing a function to sum an array of numbers. We can start with one:\n\npublic void testSum() {\n\nassertEquals(5, sum(5));\n\n}\n\nprivate int sum(int value) {\n\nreturn value;\n\n}\n\n(I am implementing sum() in the TestCase class to avoid writing a new class just for one method.)\n\n2. Thanks to Laurent Bossavit for this discussion.\n\n157",
      "content_length": 1549,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 173,
      "content": "158\n\nGreen Bar Patterns\n\nWe want to test sum(new int[] {5, 7}) next. First we add a parameter to sum() tak- ing an array of values:\n\npublic void testSum() {\n\nassertEquals(5, sum(5, new int[] {5}));\n\n}\n\nprivate int sum(int value, int[] values) {\n\nreturn value;\n\n}\n\nYou can look at this step as an example of Isolate Change. Once we add the param- eter in the test case we are free to change the implementation without affecting the test case.\n\nNow we can use the collection instead of the single value:\n\nprivate int sum(int value, int[] values) {\n\nint sum= 0; for (int i= 0; i<values.length; i++)\n\nsum += values[i];\n\nreturn sum;\n\n}\n\nNow we can delete the unused single parameter:\n\npublic void testSum() {\n\nassertEquals(5, sum(new int[] {5}));\n\n}\n\nprivate int sum(int[] values) {\n\nint sum= 0; for (int i= 0; i<values.length; i++)\n\nsum += values[i];\n\nreturn sum;\n\n}\n\nThe previous step is also an example of Isolate Change, where we change the code so we can change the test cases without affecting the code. Now we can enrich the test case as planned:\n\npublic void testSum() {\n\nassertEquals(12, sum(new int[] {5, 7}));",
      "content_length": 1115,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 174,
      "content": "}\n\nFurther Study\n\nPragmatic Programmer\n\nRitchie Elements of Style\n\n159",
      "content_length": 70,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 175,
      "content": "160\n\nGreen Bar Patterns",
      "content_length": 23,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 176,
      "content": "CHAPTER 32\n\nxUnitPatterns\n\nAssertion\n\nHow do you check that tests worked correctly? Write boolean expressions that automate your judgment about whether the code worked.\n\nIf we are going to make the tests fully automated, every bit of human judgment has to be taken out of the evaluation of the results. We need to push a button and have all the decisions necessary to verify the correct working of the code run by the com- puter. This suggests that:\n\nThe decisions have to be boolean—true generally means everything is okay and false means something unexpected happened\n\nThe state of the booleans have to be checked by computer, by calling some vari- ant of an “assert()” method\n\nI’ve seen assertions like “assertTrue(rectangle.area() != 0)”. You could return any- thing not null and satisfy this test, so it isn’t very useful. Be specific. If the area should be 50, say that it should be 50—“assertTrue(rectangle.area() == 50)”.\n\n161",
      "content_length": 934,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 177,
      "content": "162\n\nxUnit Patterns\n\nMany xUnit implementations have a special assertion for testing equality. Testing for equality is common, and if you know you are testing equality you can write an informative error message. The expected value generally goes first, so in JUnit we would write the above as “assertEquals(50, rectangle.area())”.\n\nThinking about objects as black boxed is hard. If I have a Contract with a Status that can either be an instance of Offered or Running, I might feel like writing a test based on my expected implementation:\n\nContract contract= new Contract(); // Offered status by default contract.begin(); // Changes status to Running assertEquals(Running.class, contract.status.class);\n\nThis test is too dependent on the current implementation of status. The test should pass even if the representation of status changed to a boolean. Perhaps once the sta- tus changes to Running, it is possible to ask for the actual start date.\n\nassertEquals(…, contract.startDate()); // Throws an exception if the status is Offered\n\nI’m aware that I am swimming against the tide in insisting that all tests be written using only public protocol. There is even a package that extends JUnit, JXUnit, that allows testing the value of variables, even those declared private.\n\nWishing for white box testing is not a testing problem, it is a design problem. Any time I want to use a variable as a way of checking to see whether code ran correctly or not, I have an opportunity to improve the design. If I give in to my fear and just check the variable, I lose that opportunity. That said, if the design idea doesn’t come, it doesn’t come. I’ll check the variable, shed a tear, make a note to come back on one of my smarter days, and move on.\n\nThe original SUnit (the first, Smalltalk, version of the testing framework) had sim- ple assertions. If one broke, a debugger popped up, you fixed the code, and away you went. Because the IDEs for Java aren’t so sophisticated, and because building Java-based software often happens in a batch environment, it makes sense to add information about the assertion which will be printed if it ever fails.",
      "content_length": 2138,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 178,
      "content": "In JUnit, this takes the form of an optional first parameter1. If you write \"assert- True(\"Should be true\", false)\", when the test is run you will see an error message something like \"Assertion failed: Should be true\". This is often enough information to send you straight to the source of the error in the code. Some teams adopt the convention that all assertions must be accompanied by an informative error mes- sage. Try it both ways and see if the investment in the error messages pays off for you.\n\nFixture\n\nHow do you create common objects needed by several tests? Convert the local vari- ables in the tests into instance variables. Override setUp() and initialize those vari- ables.\n\nIf we want to remove duplication from our model code, do we want to remove it also from our test code? Maybe.\n\nHere’s the problem—often you write more code setting objects up in an interesting state than you write manipulating them and checking results. The code for setting up the objects is the same for several tests (these objects are the test’s fixture, also known as scaffolding.) This duplication is bad:\n\nIt takes a while to write, even to copy-n-paste, and we’d like test writing to be fast\n\nIf we need to change an interface by hand, we have to change it in several tests (exactly what we would expect of duplication)\n\nThe same duplication, however, is also good. Tests written with the set-up code right there with the assertions are readable top to bottom. If we factored the set-up code into a separate method we would have to remember that the method was called, and remember what the objects looked like, before we could write the rest of the test.\n\nxUnit supports both styles of test writing. You can write the test-fixture-creating code with the test, if you expect readers not to be able to easily remember the fix- ture objects. However, you can also move common test-fixture-creating code into a\n\n1. Optional parameters are supposed to come at the end, but for readability it helps to have the explanatory string at the beginning.\n\n163",
      "content_length": 2046,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 179,
      "content": "164\n\nxUnit Patterns\n\nmethod called setUp(). In it, set instance variables to the objects that will be used in the test.\n\nHere is an example too simple to really motivate the value of factoring out common set-up code, but short enough to fit in a book. We could write:\n\nEmptyRectangleTest\n\npublic void testEmpty() {\n\nRectangle empty= new Rectangle(0,0,0,0); assertTrue(empty.isEmpty());\n\n}\n\npublic void testWidth() {\n\nRectangle empty= new Rectangle(0,0,0,0); assertEquals(0.0, empty.getWidth(), 0.0);\n\n}\n\n(This also demonstrates the floating point version of assertEquals(), which requires a tolerance.) We could get rid of the duplication by writing:\n\nEmptyRectangleTest\n\nprivate Rectangle empty;\n\npublic void setUp() {\n\nempty= new Rectangle(0,0,0,0);\n\n}\n\npublic void testEmpty() {\n\nassertTrue(empty.isEmpty());\n\n}\n\npublic void testWidth() {\n\nassertEquals(0.0, empty.getWidth(), 0.0);\n\n}\n\nWe have extracted the common code as a method, one that the framework is guar- anteed to call before our test method is called. The test methods are simpler, but we have to remember what is in setUp() before we can understand them.",
      "content_length": 1120,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 180,
      "content": "Which style should you use? Try them both. I nearly always factor common set-up code out, but I have a strong memory for detail. Readers of my tests sometimes complain that there is too much to remember, so maybe I should factor out less.\n\nThe relationship of subclasses of TestCase and instances of those subclasses is one of the most confusing parts of xUnit. Each new kind of fixture should be a new sub- class of TestCase. Each new fixture is created in an instance of that subclass, used once, then discarded.\n\nIn our example above, if we wanted to write tests for a non-empty Rectangle, we would create a new class, perhaps NormalRectangleTest, and initialize a different variable to a different rectangle in setUp(). In general, if I find myself wanting a slightly different fixture, I start a new subclass of TestCase.\n\nThis implies that there is no simple relationship between test classes and model classes. Sometimes one fixture serves to test several classes (although this is rare). Sometimes two or three fixtures are needed for a single model class. In practice, you usually end up with roughly the same number of test classes as model classes, but not because for each and every model class you write one and only one test class.\n\nExternal Fixture\n\nHow do you release external resources in the fixture? Override tearDown() and release the resources.\n\nRemember that the goal of each test is to leave the world in exactly the same state as before it ran. For example, if you open a file in a test, you need to be sure to close it before the test completes. You could write:\n\ntestMethod(self):\n\nfile= File(\"foobar\").open() try:\n\n...run the test...\n\nfinally:\n\nfile.close()\n\nIf the file was used in several tests, you could make it part of the common fixture:\n\nsetUp(self):\n\nself.file= File(\"foobar\").open()\n\ntestMethod(self):\n\n165",
      "content_length": 1842,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 181,
      "content": "166\n\nxUnit Patterns\n\ntry:\n\n...run the test...\n\nfinally:\n\nself.file.close()\n\nFirst, there is that pesky duplication of the finally clause telling us that we are miss- ing something in the design. Second, this method is error prone because it is easy to forget the finally clause, or forget to close the file altogether. Lastly, there are three lines of noise in the test—try, finally, and the close itself, which is not central to the running of the test.\n\nxUnit guarantees that a method called tearDown() will be run after the test method. TearDown() will be called regardless of what happens in the test method (although if setUp() fails tearDown() won’t be called). We can transform the above to:\n\nsetUp(self):\n\nself.file= File(\"foobar\").open()\n\ntestMethod(self):\n\n...run the test...\n\ntearDown(self):\n\nself.file.close()\n\nTest Method\n\nHow do you represent a single test case? As a method (whose name begins with “test” by convention.)\n\nYou are going to have hundreds, later thousands, of tests in your system. How are you going to keep track of them all?\n\nObject programming languages have three levels of hierarchy for organization:\n\n(cid:127) Module (“package” in Java)\n\n(cid:127)\n\nClass (cid:127) Method\n\nIf we are writing tests as ordinary source code, we need to find a way to fit into this structure. If we are using classes to represent fixtures, then the natural home for tests is as methods. All the tests sharing a single fixture will be methods in the same class. Tests requiring a different fixture will be in a different class.",
      "content_length": 1541,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 182,
      "content": "By convention, the name of the method begins with “test”. Tools can look for this pattern to automatically create suites of tests given a class. The remainder of the name of the method should suggest to a future clueless reader why this test was written. JUnit, for example has a test called “testAssertPosInfinityNotEqualsNegIn- finity”. I can’t remember writing this test, but from the name I assume that at some point JUnit’s assertion code for floating point numbers didn’t distinguish between positive and negative infinity. From the test I can quickly find the code in JUnit that handles floating point comparison and see how we handled it (it’s kind of ugly— there’s a special conditional to handle infinity.)\n\nTest methods should be easy to read, pretty much straightline code. If a test method is getting long and complicated, you need to play “Baby Steps”. The goal of the game is to write the smallest test method that represents real progress towards your end goal. Three lines appears to be about the minimum, without deliberate obfusca- tion (and remember, you are writing these tests for people, not just the computer or yourself.)\n\nPatrick Logan contributed an idea I’m going to experiment with, also described by McConnell2 and Caine and Gordon3\n\nFor some reason I’ve been working with \"outlines\" in practically everything I do lately. Testing is no different. When I write tests, I first create a short outline of the tests I want to write, for example... /* Adding to tuple spaces. */ /* Taking from tuple spaces. */ /* Reading from tuple space. */\n\nThese are place holders until I add specific tests under each category. When I add tests, I add another level of comments to the outline... /* Adding to tuple spaces. */ /* Taking from tuple spaces. */ /** Taking a non-existant tuple. **/ /** Taking an existing tuple. **/ /** Taking multiple tuples. **/ /* Reading from tuple space. */\n\nI usually only have two or three levels to the outline. I can’t think of when I had more. But the outline essentially becomes documentation of the contract for the\n\n2. Steve McConnell, Code Complete, chapter 4, Microsoft Press, 19??, ISBN >???. 3. S. H. Caine and E. K. Gordon, “PDL: A Tool for Software Design,” AFIPS Proceedings of the 1975 National Computer Conference.\n\n167",
      "content_length": 2284,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 183,
      "content": "168\n\nxUnit Patterns\n\nclass being tested. The examples here are abbreviated , but they would be more specific in a contract-like language. (I don’t use any kind of add-on to Java for Eiffel-like automation.)\n\nImmediately under the lowest level of the outline is the test case code.\n\nException Test\n\nHow do you test for expected exceptions? Catch expected exceptions and ignore them, failing only if the exception isn’t thrown.\n\nLet’s say we’re writing some code to look up a value. If the value isn’t found, we want to throw an exception. Testing the lookup is easy enough.\n\npublic void testRate() {\n\nexchange.addRate(\"USD\", \"GBP\", 2); int rate= exchange.findRate(“USD”, “GBP”); assertEquals(2, rate);\n\n}\n\nTesting the exception may not be so obvious. Here’s how we do it:\n\npublic void testMissingRate() {\n\ntry {\n\nexchange.findRate(\"USD\", “GBP\"); fail();\n\n} catch (IllegalArgumentException expected) { }\n\n}\n\nIf findRate() doesn’t throw an exception, we will call fail(), an xUnit method which reports that the test failed. Notice that we are careful only to catch the particular exception we expect, so if the wrong kind of exception is thrown, we will also be notified (including assertion failures.)\n\nAllTests\n\nHow do you run all tests together? Make a suite of all the suites, one for each pack- age and one aggregating the package tests for the whole application.\n\nSuppose you add a TestCase subclass to a package and you add a test method to that class. The next time all the tests run that test method should run, too (there’s",
      "content_length": 1530,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 184,
      "content": "that test-driven stuff—the preceding is the outline for a test that I would probably just go and implement if I wasn’t busy writing a book.) Because this isn’t supported in most xUnit implementations or IDEs, each package should declare a class AllT- ests that implements a static method suite() that returns a TestSuite. Here is AllT- ests for the Money example:\n\npublic class AllTests {\n\npublic static void main(String[] args) {\n\njunit.swingui.TestRunner.run(AllTests.class);\n\n}\n\npublic static Test suite() {\n\nTestSuite result= new TestSuite(\"TFD tests\"); result.addTestSuite(MoneyTest.class); result.addTestSuite(ExchangeTest.class); result.addTestSuite(IdentityRateTest.class); return result;\n\n}\n\n}\n\nYou can also give AllTests a main() method so the class can be run directly from the IDE or a command line.\n\nFurther Study\n\nThe official site for JUnit is www.junit.org. There is also an active mailing list at http://groups.yahoo.com/group/junit.\n\nYou can find a complete list of xUnit implementations at www.xprogram- ming.com/software.htm (38 languages at the time I’m writing).\n\n169",
      "content_length": 1089,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 185,
      "content": "170\n\nxUnit Patterns",
      "content_length": 19,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 186,
      "content": "CHAPTER 33\n\nDesignPatterns\n\nOne of the primary insights of patterns1 is that although it may seem like we solve completely different problems all the time, most of the problems we solve are gen- erated by the tools we use, not by the external problem at hand. Because of this, we can expect to find (and actually do find) common problems with common solutions even in the midst of an incredible diversity of external problem solving contexts.\n\nApplying objects to organizing computation is one of the best examples of common internally generated sub-problems being solved in common, predictable ways. The enormous success of design patterns2 is a testimonial to the commonality seen by object programmers. The success of the design patterns book, however, has stifled any diversity in expressing these patterns.\n\nThe design patterns book seems to have a subtle bias towards design as a phase. It certainly makes no nod towards refactoring as a design activity. Design in TDD requires a slightly different look at design patterns.\n\n1. Notes on the Synthesis of Form, Christopher Alexander, Harvard University Press, 1970, ISBN: 0674627512\n\n2. Design Patterns: Elements of Reusable Object Oriented Software, Dr. Erich Gamma, et. al, Addison-Wesley, 199?, ISBN: ???\n\n171",
      "content_length": 1267,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 187,
      "content": "172\n\nDesign Patterns\n\nThe design patterns covered here are not intended to be comprehensive. They are just enough design to get us through the examples. Here they are in summary:\n\nCommand—represent the invocation of a computation as an object, not just a message\n\n(cid:127) Value Object—avoid aliasing problems by making objects whose values never\n\nchange once created\n\n(cid:127) Null Object—represent the base case of a computation by an object\n\nTemplate Method—represent invariant sequences of computation with an abstract method intended to be specialized through inheritance\n\nPluggable Object—represent variation by invoking another object with two or more implementations\n\nPluggable Selector—avoid gratuitous subclasses by dynamically invoking dif- ferent methods for different instances\n\nFactory Method—create an object by calling a method instead of a constructor.\n\nComposite—represent the composition of the behavior of a list of objects with an object\n\nCollecting Parameter—pass around a parameter to be used to aggregate the results of computation in many different objects\n\nImposter—introduce variation by introducing a new implementation of existing protocol\n\nThe design patterns cluster based on where they are used in TDD:\n\nPattern\n\nTest Writing\n\nRefactoring\n\nCommand\n\nX\n\nValue Object\n\nX\n\nNull Object\n\nX\n\nTemplate Method\n\nX\n\nPluggable Object\n\nX\n\nPluggable Selector\n\nX\n\nFactory Method\n\nX\n\nX",
      "content_length": 1403,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 188,
      "content": "Composite\n\nX\n\nX\n\nCollecting Parameter\n\nX\n\nX\n\nImposter\n\nX\n\nX\n\nCommand\n\nWhat do you do when you need the invocation of a computation to be more compli- cated than a simple method call? Make an object for the computation and invoke it.\n\nSending messages is wonderful. Programming languages make sending messages syntactically easy. Programming environments make manipulating messages easy (e.g. refactorings to automatically rename a message). However, sometimes just sending a message isn’t enough.\n\nFor example, suppose you want to log the fact that a message got sent. We could add language features (wrapper methods) to do this, but logging is rare enough, and the value of simple languages is high enough, that we’d rather not do that. Or sup- pose we want to invoke a computation, but later. We could start a thread, immedi- ately suspend it, and re-start it later, but then we’d have all the joys of concurrency to deal with.\n\nComplicated invocations of computation require expensive mechanisms. However, most of the time we don’t need all the complexity, and we’d rather not pay the cost. When we need invocation to be just a little more concrete and manipulable than a message, objects give us the answer. Make an object representing the invocation. Seed it with all the parameters the computation will need. When we’re ready to invoke it, use generic protocol, like “run()”.\n\nThe Java interface Runnable is an excellent example of this.\n\nRunnable\n\ninterface Runnable\n\npublic abstract void run();\n\nIn the implementation of run(), you can do anything you’d like. Unfortunately, Java has no syntactically lightweight way to create and invoke Runnables, so they aren’t used as much as the equivalent—blocks or lambda in Smalltalk/Ruby or LISP—in other languages.\n\n173",
      "content_length": 1770,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 189,
      "content": "174\n\nDesign Patterns\n\nValue Object\n\nHow do you design objects that will be widely shared, but for whom identity is unimportant? Set their state when they are created and never change it. Operations on the object always return a new object.\n\nObjects are wonderful. I can say that here, can’t I? Objects are a great way to orga- nize logic for later understanding and growth. However, there is one little problem (okay, more than one, but this one will do for now.)\n\nSuppose I (an object) have a Rectangle. I compute some value based on the Rectan- gle, like its area. Later, someone politely asks me for my Rectangle, and I, not wanting to appear uncooperative, give it to them. Moments later, lo and behold, the Rectangle has been changed behind my back. The area I computed earlier is out of date, and there is no way for me to know.\n\nThis is the classic aliasing problem. If two objects share a reference to a third, if one object changes the referred object, the other object better not rely on the state of the shared object.\n\nThere are several ways out of the aliasing problem. One solution is never to give out the objects that you rely on, but instead to always make copies. This can get expensive in time and space, and ignores those times when you want to share changes to a shared object. Another solution is Observer, where you explicit regis- ter with objects on which you rely and expect to be notified when they change. Observer can make control flows difficult to follow, and the logic for setting up and removing the dependencies gets ugly.\n\nAnother solution is to treat the object as less than an object. Objects have state that change over time. We can, if we choose, eliminate the “that change over time”. If I have an object and I know it won’t change, I can pass around references to it all I want, knowing that aliasing won’t be a problem. There can be no hidden changes to a shared object if there are no changes.\n\nI remember puzzling over Integers when I was first learning Smalltalk. If I change bit 2 to a 1, why don’t all 2’s become 6’s?\n\na := 2. b := a. a := a bitAt: 2 put: 1. a => 6",
      "content_length": 2112,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 190,
      "content": "b => 2\n\nBecause Integers are really values masquerading as objects. In Smalltalk this is lit- erally true of small integers, and simulated in the case of integers that don’t fit in a single machine word. When I set that bit, what I get back is a new object with the bit set, not the old one with the bit changed.\n\nWhen implementing a Value Object, every operation has to return a fresh object, leaving the original unchanged. Users have to be aware they are using a Value Object and store the result (as in the example above.) All of these object allocations can create performance problems, which should be handled like all performance problems, when you have realistic data sets, realistic usage patterns, profiling data, and complaints about performance.\n\nI have a tendency to use Value Object whenever I have a situation that looks like algebra—geometric shapes being intersected and unioned, unit values where units are carried around with a number, symbolic arithmetic. Any time Value Object makes the least sense I try it, because it makes reading and debugging so much eas- ier.\n\nAll Value Objects have to implement equality (and in many languages by implica- tion they have to implement hashing.) If I have this Contract and that Contract and they aren’t the same object, then they are different, not equal. However, if I have this five francs and that five francs, it doesn’t matter if they are the same five francs, five francs are five francs and they should be equal.\n\nNull Object\n\nHow do you represent special cases using objects? Create an object representing the special case. Give it the same protocol as the regular objects.\n\njava.io.File\n\npublic boolean setReadOnly() {\n\nSecurityManager security = System.getSecurityManager(); if (security != null) {\n\nsecurity.checkWrite(path);\n\n} return fs.setReadOnly(this);\n\n}\n\n175",
      "content_length": 1837,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 191,
      "content": "176\n\nDesign Patterns\n\nThere are 18 places where the same “security != null” check takes place in java.io.File. While I appreciate their diligence in making files safe for the world, I’m also a bit nervous. Are they careful to always check for a null as the result of getSecurityManager()?\n\nThe alternative is to create a new class, LaxSecurity, which doesn’t throw excep- tions ever.\n\njava.io.LaxSecurity\n\npublic void checkWrite(String path) { }\n\nIf someone asks for a SecurityManager and there isn’t one available, we send back a LaxSecurity instead:\n\njava.lang.SecurityManager\n\npublic static SecurityManager getSecurityManager() {\n\nreturn security != null ? security : new LaxSecurity();\n\n}\n\nNow we don’t have to worry about someone forgetting to check for null. The origi- nal code cleans up considerably:\n\njava.io.File\n\npublic boolean setReadOnly() {\n\nSecurityManager security = System.getSecurityManager(); security.checkWrite(path); return fs.setReadOnly(this);\n\n}\n\nErich Gamma and I once got in an argument at an OOPSLA tutorial about whether a Null Object was appropriate somewhere in JHotDraw. I was ahead on points when he calcuated the cost of introducing the Null Object as 10 lines of code, for which we would get to eliminate 1 conditional. I hate those late round TKOs. (We also got extremely bad marks from the audience for not being organized. Appar- ently they weren’t aware that having productive design discussions is a difficult but learnable skill.)",
      "content_length": 1471,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 192,
      "content": "Template Method\n\nHow do you represent the invariant sequence of a computation while providing for future refinement? Write a method that is implemented entirely in terms of other methods.\n\nProgramming is full of classic sequences:\n\nInput/process/output\n\nSend message/receive reply\n\nRead command/return result\n\nWe would like to be able to clearly communicate the universality of these sequences, while at the same time providing for variation in the implementation of the steps.\n\nIn inheritance, object languages provide a simple, if limited, mechanism for com- municating universal sequences. A superclass can contain a method written entirely in terms of other methods, and subclasses can implement those methods in different ways. For example, JUnit implements the basic sequence of running a test as\n\nTestCase\n\npublic void runBare() throws Throwable {\n\nsetUp(); try {\n\nrunTest();\n\n} finally {\n\ntearDown();\n\n}\n\n}\n\nSubclasses can implement setUp(), runTest(), and tearDown() however they want.\n\nOne question when writing a Template Method is whether to write a default imple- mentation of the sub-methods. In TestCase.runBare(), all three sub-methods have default implementations:\n\nsetUp() and tearDown() are no-ops\n\nrunTest() dynamically finds and invokes a testing method based on the name of the test case\n\n177",
      "content_length": 1314,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 193,
      "content": "178\n\nDesign Patterns\n\nIf the computation makes no sense without a sub-step being filled in, you should note this in whatever way your programming language provides:\n\nJava—declare the sub-method abstract\n\nSmalltalk—implement the method by throwing a SubclassResponsibility error\n\nTemplate methods are best found through experience instead of designed that way from the beginning. Whenver I say to myself, “Ah, this is the sequence and here are the details,” I always find myself inlining the detail methods later and re-extracting the truly variant parts.\n\nWhen you find two variants of a sequence in two subclasses, you need to gradually move them closer together. Once you’ve extracted the parts that are different to other methods, what you are left with is the template method. Then you can move the template method to the superclass and eliminate the duplication.\n\nPluggable Object\n\nThe simplest way to express variation is with explicit conditionals:\n\nif (circle) then { …circley stuff… } else { …non circley stuff }\n\nYou will quickly find that such explicit decision making begins to spread. If you represent the distinction between circles and non-circles as an explicit conditional in one place, the conditional is likely to spread.\n\nSince the second imperative of TDD is the elimination of duplication, you must nip the plague of explicit conditionals in the bud. The second time you see a condi- tional, it is time to pull out the most basic of object design moves, the pluggable object.\n\nThe pluggable objects revealed by simply eliminating duplication are sometimes counter-intuitive. Erich Gamma and I found this, one of my favorite examples of an unpredictable pluggable object. When writing a graphics editor, selection is actu- ally a bit complicated. If you’re over a figure when the button is pressed, then sub- sequent moves of the mouse move that figure and releasing the button leaves the figure selected. If you’re not over a figure, then you are selecting a group of figures,",
      "content_length": 1998,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 194,
      "content": "and subsequent moves of the mouse typically resize a rectangle used to select sev- eral figures. Releasing the button causes the figures inside the rectangle to be selected. The initial code looks something like this:\n\nSelectionTool\n\nFigure selected; public void mouseDown() { selected= findFigure(); if (selected != null)\n\nselect(selected);\n\n} public void mouseMove() { if (selected != null)\n\nmove(selected);\n\nelse\n\nmoveSelectionRectangle();\n\n} public void mouseUp() { if (selected == null) selectAll();\n\n}\n\nThere’s that ugly duplicated conditional (I told you they spread like a disease). The answer in this case is to create a Pluggable Object, a SelectionMode, with two implementations, SingleSelection and MultipleSelection.\n\nSelectionTool\n\nSelectionMode mode; public void mouseDown() { selected= findFigure(); if (selected != null)\n\nmode= SingleSelection(selected);\n\nelse\n\nmode= MultipleSelection();\n\n} public void mouseMove() {\n\nmode.mouseMove();\n\n} public void mouseUp() {\n\nmode.mouseUp();\n\n}\n\n179",
      "content_length": 1005,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 195,
      "content": "180\n\nDesign Patterns\n\nIn languages with explicit interfaces, you will have to implement an interface along with the two (or more) pluggable objects.\n\nPluggable Selector3\n\nHow do you invoke different behavior for different instances? Store the name of a method, and dynamically invoke the method.\n\nWhat do you do when you have ten subclasses of a class, each implementing only one method? Subclassing is a heavyweight mechanism for capturing such a small amount of variation.\n\nabstract class Report {\n\nabstract void print();\n\n}\n\nclass HTMLReport extends Report {\n\nvoid print() { ... }\n\n}\n\nclass XMLReport extends Report {\n\nvoid print() { ... }\n\n}\n\nOne alternative is to have a single class with a switch statement. Depending on the value of a field, you invoke different methods. However, the name of the method appears in three places:\n\nThe creation of the instance\n\nThe switch statement\n\nThe method itself abstract class Report {\n\nString printMessage;\n\n3. For more details see K. Beck, The Smalltalk Best Practice Patterns, p. 70-73, Prentice- Hall, 1997, ISBN 013476904X. It’s bad form to reference your own works, but as noted philosopher Phyllis Diller once said, “Of course I laugh at my own jokes. You can’t trust strangers.”",
      "content_length": 1231,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 196,
      "content": "Report(String printMessage) {\n\nthis.printMessage= printMessage;\n\n}\n\nvoid print() {\n\nswitch (printMessage) { case \"printHTML\" : printHTML(); break;\n\ncase \"printXML\" : printXML(): break;\n\n}\n\n};\n\nvoid printHTML() { }\n\nvoid printXML() { }\n\n}\n\nEvery time you add a new kind of printing you have to be sure to add the printing method and change the switch statement.\n\nThe Pluggable Selector solution is to dynamically invoke the method using reflec- tion:\n\nvoid print() {\n\nMethod runMethod= getClass().getMethod(printMessage, null); runMethod.invoke(this, new Class[0]);\n\n}\n\nNow there is still an ugly dependency between creators of Reports and the names of the print methods, but at least you don’t have the case statement in there, too.\n\nPluggable Selector can definitely be overused. The biggest problem with it is trac- ing code to see whether a method is invoked. Only use Pluggable Selector when you are cleaning up a fairly straightforward situation in which a bunch of sub- classes each have only one method.\n\n181",
      "content_length": 1015,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 197,
      "content": "182\n\nDesign Patterns\n\nFactory Method\n\nHow do you create an object when you want flexibility in creating new object? Cre- ate the object in a method instead of using a constructor.\n\nConstructors are expressive. You can see that you are definitely creating an object when you use one. However, constructors, particularly in Java, lack expressiveness and flexibility.\n\nOne axis of flexibility that we wanted in our Money example was to be able to return an object of a different class when we created an object. We had tests like:\n\npublic void testMultiplication() { Dollar five= new Dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));\n\n}\n\nWe wanted to introduce the Money class, but we couldn’t as long as we were locked into creating an instance of Dollar. By introducing a level of indirection, through a method, we gained the flexibility of returning an instance of a different class without changing the test.\n\npublic void testMultiplication() {\n\nDollar five = Money.dollar(5); assertEquals(new Dollar(10), five.times(2)); assertEquals(new Dollar(15), five.times(3));\n\n} Money\n\nstatic Dollar dollar(int amount) { return new Dollar(amount);\n\n}\n\nThis method is called a Factory Method, because it makes objects.\n\nThe downside of using Factory Method is precisely its indirection. You have to remember that the method is really creating an object, even though it doesn’t look like a constructor. Use Factory Method only when you need the flexibility it cre- ates. Otherwise, constructors work just fine for creating objects.",
      "content_length": 1572,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 198,
      "content": "Imposter\n\nHow do you introduce a new variation into a computation? Introduce a new object with the same protocol as an existing object but a different implementation.\n\nIntroducing variation in a procedural program involves adding conditional logic. As we saw in Pluggable Object, such logic tends to proliferate, and a healthy dose of polymorphic messages are required to cure the duplication.\n\nSuppose you have a structure in place already. There’s an object already. Now you need the system to do something different. If there’s an obvious place to insert an if statement and you’re not duplication logic from elsewhere, go ahead. Often how- ever, the variation would obviously require changes to several methods.\n\nThis moment of decision comes up in two ways in TDD. Sometimes you are writ- ing a test case and you need to represent a new scenario. None of the existing objects expresses what you want to express. Suppose we are testing a graphics edi- tor and we already have rectangles drawing correctly:\n\ntestRectangle() {\n\nDrawing d= new Drawing(); d.addFigure(new RectangleFigure(0, 10, 50, 100)); RecordingMedium brush= new RecordingMedium(); d.display(brush); assertEquals(\"rectangle 0 10 50 100\\n\", brush.log());\n\n}\n\nNow we want to display ovals. In this case, the Imposter is easy to spot—replace a RectangleFigure with an OvalFigure.\n\ntestOval() {\n\nDrawing d= new Drawing(); d.addFigure(new OvalFigure(0, 10, 50, 100)); RecordingMedium brush= new RecordingMedium(); d.display(brush); assertEquals(\"oval 0 10 50 100\\n\", brush.log());\n\n}\n\nGenerally, spotting the possibility of an Imposter the first time requires insight. Ward’s insight that a vector of Moneys could act like a Money is just such a moment. You thought they were different, and now you see that you can see them as being the same.\n\n183",
      "content_length": 1813,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 199,
      "content": "184\n\nDesign Patterns\n\nFollowing are two examples of Imposters that come up during refactoring:\n\n(cid:127) Null Object—you can treat the absence of data the same as the presence of data\n\nComposite—you can treat a collection of objects the same as a single object\n\nFinding Imposters during refactoring is driven by eliminating duplication, just as all refactoring is driven by eliminating duplication.\n\nComposite\n\nHow do you implement an object whose behavior is the composition of the behav- ior of a list of other objects? Make it an Imposter for the component objects.\n\nMy favorite example is also an example of the contradiction of composites: Account and Transaction. Transactions store an increment of value (they are really a lot more complex and interesting, but for now…):\n\nTransaction\n\nTransaction(Money value) { this.value= value;\n\n}\n\nAccounts compute their balance by summing the values of their Transactions:\n\nAccount\n\nTransaction transactions[]; Money balance() {\n\nMoney sum= Money.zero(); for (int i= 0; i < transactions.length; i++)\n\nsum= sum.plus(transactions[i].value);\n\nreturn sum;\n\n}\n\nSeems simple enough:\n\n(cid:127)\n\nTransactions have a value (cid:127) Accounts have a balance\n\nThen comes the interesting part. A customer has a bunch of Accounts, and would like to see an overall balance. The obvious way to implement this is as a new class,",
      "content_length": 1360,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 200,
      "content": "OverallAccount, that sums the balances of a list of Accounts. Duplication! Duplica- tion!\n\nWhat if Account and Balance both implemented the same interface, call it “Hold- ing” because I can’t think of anything better at the moment?\n\nHolding\n\ninterface Holding\n\nMoney balance();\n\nTransactions can implement balance() by returning their value:\n\nTransaction\n\nMoney balance() {\n\nreturn value;\n\n}\n\nNow Accounts can be composed of Holdings, not Transactions:\n\nAccount\n\nHolding holdings[]; Money balance() {\n\nMoney sum= Money.zero(); for (int i= 0; i < holdings.length; i++)\n\nsum= sum.plus(holdings[i].balance());\n\nreturn sum;\n\n}\n\nNow our problem with OverallAccounts disappears. An OverallAccount is just an Account containing Accounts.\n\nThe smell of Composite is illustrated by the above. Transactions don’t have bal- ances, not in the real world. Applying Composite is a programmer’s trick, not gen- erally appreciated by the rest of the world. However, the benefits to program design are enormous, so the conceptual disconnect is often worth it. Folders containing Folders, TestSuites containing TestSuites, Drawings containing Drawings, none of these translate well from the world, but they all make the code so much simpler.\n\nI had to play with Composite for a long time before I found where to use it and where not to use it. As will be obvious from the discussion above, I’m still not able to articulate how to guess when a collection of objects is just a collection of objects\n\n185",
      "content_length": 1483,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 201,
      "content": "186\n\nDesign Patterns\n\nand when you really have a Composite. The good news is, since you’re getting good at refactoring, the moment the duplication appears, you can introduce Com- posite and watch program complexity disappear.\n\nCollecting Parameter\n\nHow do you collect the results of an operation that is spread over several objects? Add a parameter to the operation in which the results will be collected.\n\nA simple example is the java.io.Externalizable interface. The writeExternal method writes an object and all the objects it references. Since the objects all have to coop- erate loosely to get written out, the method is passed a parameter, an ObjectOutput, as the collecting parameter: java.io.Externalizable\n\npublic interface Externalizable extends java.io.Serializable {\n\nvoid writeExternal(ObjectOutput out) throws IOException;\n\n}\n\nAdding a Collecting Parameter is a common consequence of Composite. In devel- oping JUnit, we didn’t need the TestResult to collate the results of several tests until we had several tests.\n\nAs the sophistication of expected results grows, you may find the need to introduce a Collecting Parameter. For example, suppose we are printing Expressions. If all we want is a flat string, concatenation is sufficient:\n\ntestSumPrinting() {\n\nSum sum= new Sum(Money.dollar(5), Money.franc(7)); assertEquals(\"5 USD + 7 CHF\", sum.toString());\n\n}\n\nString toString() {\n\nreturn augend + \" + \" + addend;\n\n}\n\nIf we want the indented tree form of the expression however:\n\ntestSumPrinting() {\n\nSum sum= new Sum(Money.dollar(5), Money.franc(7)); assertEquals(\"+\\n\\t5 USD\\n\\t7 CHF\", sum.toString());\n\n}",
      "content_length": 1621,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 202,
      "content": "We will have to introduce a Collecting Parameter, something like this:\n\nString toString() {\n\nIndentingStream writer= new IndentingStream(); toString(writer); return writer.contents();\n\n}\n\nvoid toString(IndentingWriter writer) {\n\nwriter.println(\"+\"); writer.indent(); augend.toString(writer); writer.println(); addend.toString(writer); writer.exdent();\n\n}\n\nSingleton\n\nHow do you provide global variables in languages without global variables? Don’t. Your progams will thank you for taking the time to think about design instead.\n\nFurther Study\n\nDP\n\nPOSA\n\nNature of Order\n\nGRudin, Grace of Great Things\n\nD’Arcy Thompson\n\n187",
      "content_length": 622,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 203,
      "content": "188\n\nDesign Patterns",
      "content_length": 20,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 204,
      "content": "CHAPTER 34\n\nRefactoring\n\nThere is a brief description of how to accomplish each refactoring in small steps. More importantly, each refactoring discusses why you might want to use it.\n\nIn TDD we use “refactoring” in an interesting way. Usually, a refactoring cannot change the semantics of the program under any circumstances. In TDD, the circum- stances we care about are the tests that are already passing. So, for example, we can replace constants with variables in TDD and call this operation, in good conscience, a refactoring, because it doesn’t change the set of tests that pass. The only circum- stance under which semantics are preserved may actually be our one test case. Any other test case that was passing would fail. However, we don’t have those tests yet, so we don’t worry about them.\n\nThis “observational equivalence” places a burden on you to have enough tests so as far as you know, a refactoring with respect to the tests is the same as a refactoring with respect to all possible tests, at least by the time you’re done. It’s no excuse to say, “I knew there was a problem, but the tests all passed so I checked the code in.” Write more tests.\n\nReconcile Differences\n\nHow do you unify two similar looking pieces of code? Gradually bring them closer. Unify them only when they are absolutely identical.\n\n189",
      "content_length": 1324,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 205,
      "content": "190\n\nRefactoring\n\nRefactoring can be a nerve-wracking experience. The easy ones are obvious. If I extract a method, as long as I do it mechanically correctly, there is very little chance of changing the system’s behavior. Some refactorings push you to examine the con- trol flows and data values carefully. A long chain of reasoning leads you to believe that the change you are about to make won’t change any answers. Those are the refactorings that enhance your hairline.\n\nSuch a leap of faith refactoring is exactly what we’re trying to avoid with our strat- egy of small steps and concrete feedback. While you can’t always avoid leapy refactorings, you can reduce their incidence.\n\nThis refactoring occurs at all levels of scale:\n\nTwo loops structures are similar. By making them identical, you can merge them.\n\nTwo branches of a conditional are similar. By making the identical, you can eliminate the conditional.\n\nTwo methods are similar. By making them identical, you can eliminate one.\n\nTwo classes are similar. By making them identical, you can eliminate one.\n\nSometimes you need to approach reconciling differences backwards—think about how the last step of the change could be trivial, then work backwards. For example, if you want to remove several subclasses, the trivial last step is if a subclass con- tains nothing. Then the subclass can be replaced by the superclass without changing the behavior of the system. To empty out this subclass, this method needs to be made identical to the one in the superclass. One by one, empty out the subclasses and, when they are empty, replace references to them by references to the super- class.\n\nIsolate Change\n\nHow do you change one part of a multi-part method or object? First, isolate the part that has to change.\n\nThe picture that comes to my mind is surgery, where all of the patient except the part to be operated on is draped. The draping leaves the surgeon with only a fixed set of variables. Now, we could have long arguments over whether this abstraction of a person to a lower left quadrant abdomen leads to good health care, but at the moment of surgery, I’m kind of glad the surgeon can focus.",
      "content_length": 2161,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 206,
      "content": "You may find that once you’ve isolated the change and then made the change, that the result is so trivial that you can undo the isolation. If we found that really all we needed was to return the instance variable in findRate(), we should consider inlin- ing findRate() everywhere it is used and deleting it. Don’t make these changes automatically, however. Balance the cost of an additional method with the value of having an additional concept explicit in the code.\n\nSome possible ways to Isolate Change are Extract Method (the most common), Extract Object, and Method Object.\n\nMigrate Data\n\nHow do you move from one representation? Temporarily duplicate the data.\n\nHow:\n\nHere is the internal-to-external version, where you change the representation inter- nally and then change the externally visible interface:\n\n(cid:127) Add an instance variable in the new format\n\n(cid:127)\n\nSet the new format variable everywhere you set the old format (cid:127) Use the new format variable everywhere you use the old format (cid:127) Delete the old format\n\nChange the external interface to reflect the new format\n\nSometimes, though, you want to change the API first. Then you should:\n\n(cid:127) Add a parameter in the new format\n\nTranslate from the new format parameter to the old format internal representa- tion\n\n(cid:127) Delete the old format parameter\n\nReplace uses of the old format with the new format\n\n(cid:127) Delete the old format\n\nWhy:\n\nOne to Many creates a data migration problem every time. Suppose we wanted to implement TestSuite using One to Many. We would start with:\n\n191",
      "content_length": 1581,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 207,
      "content": "192\n\nRefactoring\n\ndef testSuite(self):\n\nsuite= TestSuite() suite.add(WasRun(\"testMethod\")) suite.run(self.result) assert(\"1 run, 0 failed\" == self.result.summary())\n\nWhich is implemented (in the “One” part of One to Many) by:\n\nclass TestSuite:\n\ndef add(self, test): self.test= test def run(self, result):\n\nself.test.run(result)\n\nNow we begin duplicating data. First we initialize the collection of tests:\n\nTestSuite\n\ndef __init__(self):\n\nself.tests= []\n\nEverywhere “test” is set, we add to the collection, too:\n\nTestSuite\n\ndef add(self, test): self.test= test self.tests.append(test)\n\nNow we use the list of tests instead of the single test. For purposes of the current test cases this is a refactoring (it preserves semantics) because there is only ever one element in the collection.\n\nTestSuite\n\ndef run(self, result):\n\nfor test in self.tests: test.run(result)\n\nWe delete the now-unused instance variable “test”:\n\nTestSuite\n\ndef add(self, test):\n\nself.tests.append(test)",
      "content_length": 972,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 208,
      "content": "You can also use stepwise data migration when moving between equivalent formats with different protocols, as in moving from Java’s Vector/Enumerator to Collec- tion/Iterator.\n\nExtract Method\n\nHow do you make a long, complicated method easier to read? Turn a small part of it into a separate method and call the new method.\n\nHow\n\nExtract Method is actually one of the more complicated atomic refactorings. I’ll describe the typical case here. Fortunately, it is also the most commonly imple- mented automatic refactoring, so you likely won’t have to do it by hand.\n\n1. Find a region of the method that would make sense as its own method. Bodies of loop, whole loops, and branches of conditionals are common candidates for extrac- tion.\n\n2. Make sure there are no assignments to temporary variables declared outside the scope of the region to be extracted.\n\n3. Copy the code from the old method to the new method. Compile it.\n\n4. For each temporary variable or parameter of the original method used in the new method, add a parameter to the new method.\n\n5. Call the new method from the original method\n\nWhy\n\nI use Extract Method when I’m trying to understand complicated code. “Here, this bit here is doing something. What shall we call that?” After half an hour the code is looking better, your partner realizes that really are there to help, and you under- stand much better what is going on.\n\nI use Extract Method to eliminate duplication when I see that two methods have some parts the same and some parts different. I extract out the similar bits as meth- ods (the Smalltalk Refactoring Browser even goes and checks to see if you are extracting a method that is equivalent to one you already have, and offers to use the existing method instead of creating a new one.)\n\n193",
      "content_length": 1775,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 209,
      "content": "194\n\nRefactoring\n\nBreaking methods into tiny bits can sometimes go too far. When I can no longer see a way forward, I often use Inline Method (conveniently, the next refactoring) to get all the code in one place so I can see what should be extracted anew.\n\nInline Method\n\nHow do you simplify control flows that have gotten to twisted or scattered? Replace a method invocation with the method itself.\n\nHow\n\n1. Copy the method.\n\n2. Paste the method over the method invocation.\n\n3. Replace all formal parameters with actual parameters. If you pass, for example, reader.getNext() (an expression causing side effects), be careful to assign it to a local variable.\n\nWhy\n\nA reviewer complained about the sequence in section I where a Bank is asked to reduce an Expression to a single Money.\n\npublic void testSimpleAddition() { Money five= Money.dollar(5); Expression sum= five.plus(five); Bank bank= new Bank(); Money reduced= bank.reduce(sum, \"USD\"); assertEquals(Money.dollar(10), reduced);\n\n}\n\n“This is too complicated. Why don’t you just ask the Money to reduce itself?” How do we experiment? Inline the implementation of Bank.reduce() and see what it looks like.\n\npublic void testSimpleAddition() { Money five= Money.dollar(5); Expression sum= five.plus(five); Bank bank= new Bank(); Money reduced= sum.reduce(bank, \"USD\"); assertEquals(Money.dollar(10), reduced);",
      "content_length": 1362,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 210,
      "content": "}\n\nYou might like second version better or not. The point to note here is you can use Inline Method to play around with the flow of control. When I’m refactoring, I have a mental picture of the system with bits of logic and control flow sloshing around between the objects. When I think I see something promising, I use the refactorings to try it out and see the result.\n\nIn the heat of battle I’ll occassionally get caught up in my own cleverness (I’m not going to say how often those occassions come.) When I do, Inline Method is a way for me to reel myself back in. “I have this sending to that sending to that... Whoa, Nelly. What’s going on here?” I inline a few layers of abstraction, see what’s really going on, and then I can re-abstract the code according to its actual needs, not my preconceptions.\n\nExtract Interface\n\nHow do you introduce a second implementation of operations in Java? Create an interface containing the shared operations.\n\nHow:\n\n1. Declare an interface. Sometimes the name of the existing class should be the name of the interface, in which case you should first rename the class.\n\n2. Have the existing class implement the interface.\n\n3. Add the necessary methods to the interface, expanding the visibility of the meth- ods in the class if necessary.\n\n4. Change type declarations from the class to the interface where possible.\n\nWhy:\n\nSometimes when you need to extract an interface, you are genuinely moving from the first implementation to the second. You have a Rectangle and you want to add an Oval, so you create a Shape interface. Finding names for the interfaces in this case is generally easy, although sometimes you have to struggle to find the right metaphor.\n\n195",
      "content_length": 1703,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 211,
      "content": "196\n\nRefactoring\n\nSometimes you are introducing a Crash Test Dummy or other Mock Object when you need to extract an interface. Naming is generally tougher in this case, because you still only have one real example. These are the times I’m most tempted to cop out and name the interface IFile and leave the class named File. I’ve schooled myself to stop a moment and see if I don’t understand something deeper about what is going on. Perhaps the interface should be called File and the class DiskFile, because the class assumes that the bits are on a disk.\n\nMove Method\n\nHow do you move a method to where it belongs? Add it to the class where it belongs, then invoke it.\n\nHow:\n\n1. Copy the method.\n\n2. Paste the method, suitably named, into the target class. Compile it.\n\n3. If the original object is referenced in the method, add a parameter to pass the original object. If variables of the original object are referenced, pass them as parameters. If variables of the original object are set, you should like give up.\n\n4. Replace the body of the original method with an invocation of the new method.\n\nHow:\n\nThis is one of my favorite consulting refactorings, because it is so good at uncover- ing unwarranted preconceptions. Calculating areas is the responsibility of the Shape:\n\nShape\n\n... int width= bounds.right() - bounds.left(); int height= bounds.bottom() - bounds.top(); int area= width * height; ...\n\nAny time I see more than one message sent to another object in a method, I get sus- picious. In this case, I see that bounds (a Rectangle) is being sent four messages. Time to move this part of the method:",
      "content_length": 1614,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 212,
      "content": "Rectangle\n\npublic int area() {\n\nint width= this.right() - this.left(); int height= this.bottom() - this.top(); return width * height;\n\n} Shape\n\n... int area= bounds.area(); ...\n\nThe three great properties of Move Method are:\n\nIt’s easy to see the need for it without deep understanding of the meaning of the logic. You see two or more messages to a different object and away you go.\n\nThe mechanics are quick and safe.\n\nThe results are often enlightening. “But Rectangles don’t do any calculation... Oh, I see. That is better.”\n\nSometimes you will want to move only part of a method. You can first extract a method, move the whole method, then inline the (now one line) method in the orig- inal class. Or you can figure out the mechanics for doing it in one go.\n\nMethod Object\n\nHow do you represent a complicated method that requires several parameters and local variables? Make an object out of the method.\n\nHow:\n\n(cid:127)\n\nCreate an object with the same parameters as the method. (cid:127) Make the local variables also instance variables of the object.\n\nCreate one method called \"run()\", whose body is the same as the body of the original method.\n\nIn the original method, create a new object and invoke run().\n\nWhy:\n\n197",
      "content_length": 1223,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 213,
      "content": "198\n\nRefactoring\n\nMethod Objects are useful in preparation for adding a whole new kind of logic to the system. For example, you might have several methods involved in computing the cash flow from component cash flows. When you want to start computing the net present value of the cash flows, you can first create a Method Object out of the first style of computation. Then you can write the new style of computation with its own, smaller-scale, tests. Then plugging in the new style will be a single step.\n\nMethod Objects are also good for simplifying code that doesn’t yield to Extract Method. Sometimes you’ll find a block of code that has a bunch of temporary vari- ables and parameters, and every time you try to extract a piece of it you have to carry along five or six temps and parameters. The resulting extracted method doesn’t look any better than the original code, because the method signature is so long. Creating a Method Object gives you a new namespace in which you can extract methods without having to pass anything.\n\nAdd Parameter\n\nHow do you add a parameter to a method?\n\nHow:\n\n(cid:127)\n\nIf the method is in an interface, add the parameter to the interface first (cid:127) Use the compiler errors to tell you what other code you need to change\n\nWhy:\n\nAdding a parameter is often an extension step. You got the first test case running without needing the parameter, but in this new circumstance you have to take more information into account in order to compute correctly.\n\nAdding a parameter can also be part of migrating from one data representation to another. First you add the parameter, then you delete all uses of the old parameter, then you delete the old parameter.\n\nMethod Parameter to Constructor Parameter\n\nHow do you move a parameter from a method or methods to the constructor?\n\nHow:\n\n(cid:127) Add a parameter to the constructor",
      "content_length": 1862,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 214,
      "content": "(cid:127) Add an instance variable with the same name as the parameter\n\nSet the variable in the constructor\n\n(cid:127) One by one, convert references to “parameter” to “this.parameter” (cid:127) When no more references exist to the parameter, delete the parameter from the\n\nmethod and all caller\n\nRemove the now-superfluous “this.” from references\n\nRename the variable correctly\n\nWhy:\n\nIf you pass the same parameter to several different methods in the same object, you can simplify the API by passing the parameter once (eliminating duplication). You can run this refactoring in reverse if you find that an instance variable is only used in one method.\n\nFurther Study\n\nFowler, Refactoring\n\nAlexander, Timeless Way of Building\n\n199",
      "content_length": 731,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 215,
      "content": "200\n\nRefactoring",
      "content_length": 16,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 216,
      "content": "CHAPTER 35\n\nMasteringTDD\n\nI hope to raise questions here for you to ponder as you integrate TDD into your own practice. Some of the questions are small, and some are large. Sometimes the answers are here, or at least hinted at here, and sometimes the questions are left for you to explore.\n\nHow large should your steps be?\n\nThere are really two questions lurking here:\n\n(cid:127) How much ground should each test cover? (cid:127) How many intermediate stages should you go through as you refactor?\n\nYou could write the tests so they each encouraged the addition of a single line of logic and a handful of refactorings. You could write the tests so they each encour- aged the addition of hundreds of lines of logic and hours of refactoring. Which should you do?\n\nPart of the answer is that you should be able to do either. The tendency of TDDers over time is clear, though—smaller steps. However, folks are experimenting with driving development from application-level tests, either alone or in conjunction with the programmer-level tests we’ve been writing.\n\n201",
      "content_length": 1062,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 217,
      "content": "202\n\nMastering TDD\n\nAt first when you refactor, you should be prepared to take lots of little tiny steps. Manual refactoring is prone to error, and the more errors you make and only catch later, the less likely you are to refactor. Once you’ve done a refactoring 20 times by hand in little tiny steps, experiment with leaving out some of the steps.\n\nAutomated refactoring accelerates refactoring enormously. What would have taken you 20 manual steps now becomes a single menu item. An order of magnitude change in quantity generally constitute a change in quality, and this is true of auto- mated refactoring. When you know you are supported by an excellent tool, you become much more aggressive in your refactorings, trying many more experiments to see how the code wants to be structured.\n\nThe Refactoring Browser for Smalltalk is as I write still the best refactoring tool available. Java refactoring support is appearing in many Java IDEs, and refactoring support is sure to spread quickly to other languages and environments.\n\nWhat don’t you have to test?\n\nThe simple answer, supplied by Phlip is, “write tests until fear is transformed into boredom.” This is a feedback loop, though, and requires that you find the answer yourself. Since you came to this book for answers, not questions (in which case you’re already reading the wrong section, but enough of the self-referential literary recursion stuff…), try this list. You should test:\n\nConditionals\n\n(cid:127)\n\nLoops (cid:127) Operations\n\nPolymorphism\n\nBut only those that you write. Unless you have reason to distrust it, don’t test code from others. Sometimes, the precise specification of (by which I mean “bugs in”) external code requires you to write more logic of your own. See above for whether you have to test this. Sometimes, just to be extra careful, I will document the pres- ence of, um, unusual behavior in external code with a test that will fail if the bug is ever fixed, er, the behavior is ever refined.",
      "content_length": 1981,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 218,
      "content": "How do you know if you have good tests?\n\nThe tests are a canary in a coal mine revealing by their distress the presence of evil design vapors. Here are some attributes of tests suggesting a design in trouble:\n\nLong setup code—If you have to spend a hundred lines creating the objects for one simple assertion, something is wrong. Your objects are too big and need to be split.\n\nSetup duplication—If you can’t easily find a common place for common setup code, there are too many objects too tightly intertwingled.\n\nLong running tests—TDD tests that run a long time won’t be run often, and often haven’t been run for a while, and probably don’t work. Worse than this, though, they suggest that testing the bits and pieces of the application is hard. Difficulty testing bits and pieces is a design problem, and needs to be addressed with design. (The equivalent of 9.8 m/s2 is the ten minute test suite. Suites that take longer than 10 minutes inevitably get trimmed, or the application tuned up, so the suite takes 10 minutes again.)\n\nFragile tests—Tests that break unexpectedly suggest that one part of the appli- cation is surprisingly effecting another part. You need to design until the effect at a distance is eliminated, either by breaking the connection or by bringing the two parts together.\n\nHow does TDD lead to frameworks?\n\nParadox: by not considering the future of your code you make your code much more likely to be able to adapt in the future.\n\nI learned exactly the opposite from books. “Code for today, design for tomorrow.” TDD appears to stand this advice on its head. “Code for tomorrow, design for today.”\n\nHere’s what happens in practice.\n\nThe first feature goes in. It is implemented simply and straightforwardly, so it is done quickly and with few defects.\n\nThe second feature, a variation on the first, goes in. The duplication between the two features is put in one place, while the differences tend to go in different places (different methods or even different classes).\n\n203",
      "content_length": 2000,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 219,
      "content": "204\n\nMastering TDD\n\nThe third feature, a variation on the first two, goes in. The common logic is likely to be reusable as is, perhaps with a few tweaks. The unique logic tends to have an obvious home, either in a different method or different class.\n\nThe Open/Closed Principle (objects should be open for use and closed to further modification) is gradually satisfied, and for precisely those kinds of variation that occur in practice. Test driving development leaves you with frameworks that are good at expressing exactly the kind of variation that occurs, even though they might not be good at expressing the kind of variation that doesn’t occur (or hasn’t occurred yet.)\n\nSo, what happens when an unusual variation pops up three years later? The design undergoes rapid evolution in exactly the necessary spots of accommodate the varia- tion. The Open/Closed Principle is violated, just for a moment, but the violation is not all that costly because you have all those tests to give you confidence you aren’t breaking anything.\n\nAt the limit, where you introduce the variations very quickly, TDD is indistinguish- able from designing ahead. I grew a reporting framework once over the course of a few hours, and observers were absolutely certain it was a trick. I must have started with the resulting framework in mind. No, sorry. I’ve just been test driving devel- opment long enough that I can recover from most of my mistakes faster than you can recognize I’ve made them.\n\nHow much feedback do you need?\n\nHow many tests should you write? Here’s a simple problem—given three integers representing the length of the sides of a triangle, return:\n\n1 if the triangle is equilateral\n\n2 if the triangle is isoceles\n\n3 if the triangle is scalene\n\nand throw an exception if the triangle is not well formed.\n\nGo ahead, try the problem (my Smalltalk solution is listed at the end of this ques- tion).\n\nI wrote 6 tests (kind of like Name That Tune, “I can code that problem in four tests.” “Code that problem.”) Bob Binder, in his comprehensive book Testing",
      "content_length": 2051,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 220,
      "content": "Object-Oriented Software, wrote 65 for the same problem. You’ll have to decide, from experience and reflection, about how many tests you want to write.\n\nI think about Mean Time Between Failure (MTBF) when I think about how many tests to write. For example, Smalltalk integers act like integers, not like a 32-bit counter, so it doesn’t make sense to test MAXINT. Well, there is a maximum size for an integer, but it has to do with how much memory you have. Do I need to write a test that fills up memory with extremely large integers? How will that affect the MTBF of my program? If I’m never going to get anywhere close to that size of tri- angle, my program is not measurably more robust with such a test than without it.\n\nWhether a test makes sense to write depends on how carefully you measure MTBF. If you are trying to get from an MTBF of 10 years to an MTBF of 100 years in your pacemaker, tests for extremely unlikely conditions and combinations of conditions make sense, unless you can demonstrate in some other way that the conditions can- not arise.\n\nTDD’s view of testing is pragmatic. In TDD, the tests are a means to an end, the end being code in which we have great confidence. If our knowledge of the imple- mentation gives us confidence even without a test, we will not write that test. Black box testing, where we deliberately choose to ignore the implementation, has some advantages. By ignoring the code, it demonstrates a different value system—the tests are valuable alone. It’s an appropriate attitude to take in some circumstances. However, it is different than TDD.\n\nTriangleTest\n\ntestEquilateral\n\nself assert: (self evaluate: 2 side: 2 side: 2) = 1\n\ntestIsoceles\n\nself assert: (self evaluate: 1 side: 2 side: 2) = 2\n\ntestScalene\n\nself assert: (self evaluate: 2 side: 3 side: 4) = 3\n\ntestIrrational\n\n[self evaluate: 1 side: 2 side: 3]\n\non: Exception do: [:ex | ^self].\n\nself fail\n\ntestNegative\n\n205",
      "content_length": 1923,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 221,
      "content": "206\n\nMastering TDD\n\n[self evaluate: -1 side: 2 side: 2]\n\non: Exception do: [:ex | ^self].\n\nself fail\n\ntestStrings\n\n[self evaluate: ‘a’ side: ‘b’ side: ‘c’]\n\non: Exception do: [:ex | ^self].\n\nself fail\n\nevaluate: aNumber1 side: aNumber2 side: aNumber3\n\n| sides | sides := SortedCollection with: aNumber1 with: aNumber2 with: aNumber3.\n\nsides first <= 0 ifTrue: [self fail]. (sides at: 1) + (sides at: 2) <= (sides at: 3) ifTrue: [self fail]. ^sides asSet size\n\nWhen should you delete tests?\n\nMore tests is better, but if two tests are redundant with respect to each other, should you keep them both around?\n\nThe first criterion for your tests is confidence. Never delete a test if it reduces your confidence in the behavior of the system.\n\nThe second criterion is communication. If you have two tests that exercise the same path through the code, but they speak to different scenarios for a readers, leave them alone.\n\nThat said, if you have two tests that are redundant with respect to confidence and communication, delete the least useful of the two.",
      "content_length": 1051,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 222,
      "content": "How does the programming language and environment influence TDD?\n\nTry TDD in Smalltalk with the Refactoring Browser. Try it in C++ with vi. How does your experience differ?\n\nIn programming languages and environments where TDD cycles (test/compile/run/ refactor) are harder to come by, you will likely be tempted to take larger steps:\n\nCover more ground with each test\n\nRefactor with fewer intermediate steps\n\nDoes this make you go faster or slower?\n\nIn programming languages and environments where TDD cycles are plentiful, you will likely be tempted to try lots more experiments. Does this help you go faster or reach better solutions, or would you be better off institutionalizing some kind of time for pure reflection (reviews or literate programs)?\n\nCan you test-drive enormous systems?\n\nDoes TDD scale to extremely large systems? What new tests would you have to write? What new kinds of refactorings would you need?\n\nThe largest system I’ve been involved with that is totally test-driven is at LifeWare (www.lifeware.ch). After four years and 40 person/years, the system contains about 250,000 lines of functional code and 250,000 lines of test code in Smalltalk. There are 4,000 tests, executing in under 20 minutes. The full suite is run several times each day. The amount of functionality in the system seems to have no bearing on the effectiveness of TDD. By eliminating duplication you tend to create more smaller objects, and those objects can be tested in isolation independent of the size of the application.\n\nCan you drive development with application-level tests?\n\nThe problem with driving development with small scale tests (I call them “unit tests”, but they don’t match the accepted definition of unit tests very well) is that you run the risk of implementing what you think a user wants, but having it turn out to be not what they wanted at all. What if we wrote the tests at the level of the appli-\n\n207",
      "content_length": 1924,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 223,
      "content": "208\n\nMastering TDD\n\ncation? Then the users (with help) could write tests themselves for what exactly they wanted the system to do next.\n\nThere is a technical problem—fixturing. How can you write and run a test for a fea- ture that doesn’t exist yet? There always seems to be some way out of this problem, typically by introducing an interpreter which gracefully signals an error when it comes across a test that it doesn’t know how to interpret yet.\n\nThere is also a social problem with application test driven development. Writing tests is a new responsibility for users (by which I really mean a team that includes users), and that responsibility comes at a new place in the development cycle, namely before implementation begins. Organizations resist this kind of shift of responsibility. It will require concerted effort (that is, the effort of many people on the team working in concert) to get application tests written first.\n\nTDD as described in this book is a technique that is entirely under your control. You can pick it up and start using it today if you so choose. Mixing up the rhythm of red/green/refactor, the technical issues of application fixturing, and the organiza- tional change issues surrounding user-written tests is unlikely to be successful. The One Step Test rule applies. Get red/green/refactor going in your own practice, then spread the message.\n\nAnother aspected of ATDD is the length of the cycle between test and feedback. If a customer wrote a test and ten days later it finally worked, you would be staring at a red bar most of the time. I think I would want to still do programmer-level TDD so:\n\nI got immediate green bars\n\nI simplified the internal design\n\nHow do you switch to TDD mid-stream?\n\nYou have a bunch of code which more or less works. You want to test drive your new code. What do you do next?\n\nThere is a whole book (or books) to be written about switching to TDD when you have lots of code. What follows is necessarily only a teaser.",
      "content_length": 1984,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 224,
      "content": "The biggest problem is that code that isn’t written with tests in mind typically isn’t very testable. The interfaces aren’t designed so it is easy for you to isolate a little piece of logic, run it, and check its results.\n\n“Fix it,” you say. Yes, well, but refactoring (without automated tools) is likely to result in errors, errors that you won’t catch because you don’t have the tests. Chick- ens and eggs. Catch-22. Mutually assured destruction. What do you do?\n\nWhat you don’t do is go write tests for the whole thing and refactor the whole thing. That would take months, months in which no new functionality would appear. Spending money without making it is generally speaking not a sustainable process.\n\nSo first we have to decide to limit the scope of our changes. If we see parts of the system that could be dramatically simplified, but that don’t demand change at the moment, we will leave them alone. Shed a tear, perhaps, for the sins of the past, but leave them alone.\n\nSecond, we have to break the deadlock between tests and refactoring. We can get feedback other ways than with tests, like working very carefully and with a partner. We can get feedback at a gross level, like system level tests that we know aren’t adequate, but give us some confidence. With this feedback, we can make the areas we have to change more accepting of change.\n\nOver time, the parts of the system that change all the time will come to look test- driven. Occassionally we will wander into an unlit back alley and get mugged for our troubles, reminding us how slow things used to be. Then we will slow down, break the deadlock, and get going again.\n\nWho is TDD intended for?\n\nEvery programming practice encodes a value system, explicitly or implicitly. TDD is no different. If you’re happy slamming some code together that more or less works and never looking at the result again, TDD is not for you. TDD rests on a charmingly naïve geekoid assumption that if you write better code, you’ll be more successful. TDD helps you pay attention to the right issues at the right time so you can make your designs cleaner, you can refine your designs as you learn.\n\nI say “naïve”, but that’s perhaps overstating. What’s naïve is assuming that clean code is all there is to success. Good engineering is maybe 20% of a project’s suc- cess. Bad engineering will certainly sink projects, but modest engineering can\n\n209",
      "content_length": 2397,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 225,
      "content": "210\n\nMastering TDD\n\nenable project success as long as the other 80% lines up right. From this perspec- tive, TDD is overkill. It lets you write code with far fewer defects and a much cleaner design than is common in the industry. However, those whose souls are healed by the balm of elegance can find in TDD a way to do well by doing good.\n\nTDD is also good for geeks who form emotional attachments to code. One of the great frustrations of my young engineer’s life was starting a project with great excitement, then watching the code base decay over time. A year later I wanted nothing more than to dump the now-smelly code and get on to the next project. TDD enables you to gain confidence in the code over time. As tests accumulate (and your testing improves), you gain confidence in the behavior of the system. As you refine the design, more and more changes become possible. My goal is to feel better about a project after a year than I did in the starry-eyed beginning, and TDD helps me achieve this.\n\nIs TDD sensitive to initial conditions?\n\nSome orders in which you take the tests seem to work very smoothly. Red/green/ refactor/red/green/refactor. You can take the same tests and implement them in a different order, and it seems like there is not a way to advance in small steps. Is it really true that one sequence of tests is an order of magnitude faster/easier to imple- ment than another? Is this just because my implementation technique is not up to the challenge? Is there something about the tests that should tell me to tackle them in a certain order? If TDD is sensitive to initial conditions in the small, is it predict- able in the large? (In the same way that little eddies in the Mississippi are unpre- dictable, but you can count on 2,000,000 cfs. more or less at the river mouth.)\n\nHow does TDD relate to patterns?\n\nAll of my technical writings have been about trying to find fundamental rules that generate behavior similar to experts. Partly this is because this is how I learn—I find an expert to act like, then gradually figure out what is really going on. I’m cer- tainly not looking for rules to be followed mechanically, although that is how the mechanically minded have interpreted them.\n\nMy oldest daughter (hi Bethany! I told you I would get you in here—be glad it isn’t more embarassing) spent several years learning to do multiplication fast. My wife and I both prided ourselves on doing multiplication fast, and learned very quickly. What was going on? Turns out that every time Bethany was faced with 6 x 9, she",
      "content_length": 2550,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 226,
      "content": "would add 6 9 times (or 9 6 times, I suppose). Far from being a slow multiplier, she was a really fast adder.\n\nThe effect that I have noticed, and that I hope others find, is that by reducing repeat- able behavior to rules, applying the rules becomes rote and mechanical. This is quicker than re-debating everything from first principles all the time. When along comes an exception, or a problem that just doesn’t fit any of the rules, you have more time and energy to generate and apply creativity.\n\nThis happened to me when writing the Smalltalk Best Practice Patterns. At some point I decided to just follow the rules I was writing. It was much slower at first, to be looking up the rules, or to be stopping to write a new rule. After a week, though, I discovered that code was ripping off my fingertips that would have required a pause for thought before. This gave me more time and attention for bigger thoughts about design and analysis.\n\nAnother relationship between TDD and patterns is TDD as an implementation method for pattern-driven design. Say we decide we want a Strategy for something. We write a test for the first variant and implement it as a method. Then we con- sciously write a test for the second variant, expecting the refactoring phase to drive us to a Strategy. Robert Martin and I did some research into this style of TDD. The problem is the design keeps surprising you. Perfectly sensible design ideas turn out to be wrong. Better to just think about what you want the system to do, and let the design sort itself out later.\n\nWhy does TDD work?\n\nI saved the weirdest for last. Let’s assume for the moment that TDD helps teams productively build loosely coupled, highly cohesive systems with low defect rates and low cost maintenance profiles. (I’m claiming no such thing in general, but I trust you to imagine impossible things.) How could such a thing happen?\n\nPart of the effect certainly comes from reducing defects. The sooner you find and fix a defect, the cheaper it is, often dramatically so (just ask the Mars Lander.) There are plenty of secondary psychological and social effects from reduced defects. My own practice of programming became much less stressful with I started TDD. No longer did I have to worry about everything at once. I could make this test run, and then all the rest. Relationships with my teammates became more positive. I stopped breaking builds, and people could rely on my software to work. Customers of my systems became more positive, too. A new release of the system just meant\n\n211",
      "content_length": 2545,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 227,
      "content": "212\n\nMastering TDD\n\nmore functionality, not a host of new defects to identify among all of their old favorite bugs.\n\nI’ve said “reduced defects.” Where do I get off claiming such a thing? Do I have scientific proof?\n\nNo. No studies have categorically demonstrated the difference between TDD and any of the many alternatives in quality, productivity, or fun. However, the anec- dotal evidence is overwhelming, and the secondary effects are unmistakable. Pro- grammers really do relax, teams really do develop trust, and customers really do learn to look forward to new releases. “By and large,” I will say, although I haven’t seen the opposite effect. You mileage may vary, but you’ll have to try it to find out.\n\nAnother advantage of TDD that may explain its effect is the way it shortens the feedback loop on design decisions. The feedback loop for implementation deci- sions is obviously short—seconds or minutes, followed by re-running the tests tens or hundreds of times a day. The loop for design decisions goes between the design thought—perhaps the API should like this, or perhaps the metaphor should be that—and the first example, a test that embodies that thought. Rather than design- ing and then waiting weeks or months for someone else to feel the pain or glory, feedback comes in seconds or minutes as you try to translate your ideas into a plau- sible interface.\n\nA weirder answer to “why does TDD work?” comes from the fevered imagination of complex systems. The inimitable Phlip says:\n\nAdopt programming practices that “attract” correct code as a limit function, not as an absolute value. If you write unit tests for every feature, and if you refactor to simplify code between each step, and if you add features one at a time and only after all the unit tests pass, you will create what mathematicians call an “attractor.” This is a point in a state space that all flows converge on. Code is more likely to change for the better over time instead of for the worse; the attractor approaches correctness as a limit function.\n\nThis is the “correctness” that nearly all programmers get by with (except, of course, for medical or aerospace software). But it’s better to explicitly understand the attractor concept than deny it or disregard its importance.\n\nWhat’s with the name?\n\n(cid:127) Development—The old phasist way of thinking about software development is weakened because feedback between decisions is difficult if they are separated in time. Development in this sense means a complex dance of analysis, logical",
      "content_length": 2532,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 228,
      "content": "design, physical design, implementation, testing, review, integration and deployment.\n\n(cid:127) Driven—I used to call TDD “test-first programming”. However, the opposite of “first” is “last”, and lots of people test after they have programmed. There is a naming rule that the opposite of a name should be at least vaguely unsatisfac- tory (part of the appeal of structured programming is that no one wants to be unstructured.) If you don’t drive development with tests, what do you drive it with? Speculation? Specifications (ever notice that those two words come from the same root?)\n\nTest—Automated, reified, concrete tests. Push a button and they run. One of the ironies of TDD is that it isn’t a testing technique (the Cunningham Koan). It’s an analysis technique, a design technique, really a technique for all the activities of development.\n\nHow does TDD relate to the practices of Extreme Programming?\n\nSome reviewers have been concerned that by my writing a book exclusively about TDD, folks will take it as an excuse to ignore the rest of the advice in XP. For example, if you test-drive, do you still need to pair? Here is a brief summary of how the rest of XP enhances TDD and TDD enhances the rest of XP.\n\nPairing—The tests you write in TDD are excellent conversation pieces when you are pairing. The problem you avoid is that of the partners not agreeing on what problem they are solving, even though they are trying to work on the same code. This sounds crazy, but it happens all the time, especially when you are learning to pair with someone. Pairing enhances TDD by giving you a fresh mind to take over when you get tired. TDD’s rhythm can suck you in, and lead you to continue program even when you’re tired. Your partner, though, is ready to take the keyboard when you flag.\n\n(cid:127) Work fresh—On a related note, XP advises you to work when you are fresh and stop when you are tired. When you can’t get that next test to work, or those two tests to work together, it’s time for a break. Uncle Bob Martin and I were work- ing on a line break algorithm once and we just couldn’t get it to work. We strug- gled in frustration for a few minutes, but it was obvious we weren’t making progress so we stopped.\n\nContinuous integration—The tests make an excellent resource enabling you to integrate more often. You get another test working and the duplication removed, you check in. The cycle can be 15-30 minutes instead of the 1-2 hours that I usually shoot for. This may be part of the key to having larger teams of pro-\n\n213",
      "content_length": 2542,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 229,
      "content": "214\n\nMastering TDD\n\ngrammers on the same code base. As Bill Wake says, “An n2 problem is not a problem if n is always 1.”\n\nSimple design—By coding only what you need for the tests and removing all duplication, you automatically get a design that is perfectly adapted to the cur- rent requirements and equally prepared for all future stories. The mind set that you are looking for just enough design to have the perfect architecture for the current system also makes writing the tests easier.\n\nRefactoring—The “Remove Duplication” rule is another way of saying “refac- toring.” The tests, though, give you confidence that your larger refactorings haven’t changed the behavior of the system. The higher your confidence, the more aggressive you will be in trying large-scale refactorings that extend the life of your system. By refactoring, you make writing the next round of tests that much easier.\n\nContinuous delivery—If TDD tests really do improve the MTBF of your system (a contention you will have to verify for yourself), you can put code into pro- duction much more often without disrupting customers. Gareth Reeves makes the analogy to day trading. In day trading, you close out your positions every night, because you don’t risk around that you aren’t managing. In programming, you like all of your changes in production because you don’t want code around that you aren’t receiving concrete feedback on.\n\nDarach’s Challenge\n\nDarach Ennis has thrown down a gauntlet for extending the reach of TDD. He says:\n\nFor example, there are a lot of fallacies blowing around various engineering orga- nizations and amongst various engineers that this book could help to dispell and some of these are: (cid:127) You can’t test GUIs automaticaly (eg: Swing, CGI, JSP/Servlets/Struts) (cid:127) You can’t unit test distributed objects automaticaly (eg: RPC and Messaging\n\nstyle, or CORBA/EJB and JMS)\n\n(cid:127) You can’t test-first develop your database schema (eg: JDBC?) (cid:127) There is no need to test third party or code generated by external tools (cid:127) You can’t test first develop a language compiler / interpreter from BNF to\n\nproduction quality implementation\n\nI’m not sure he’s right, but I’m also not sure he’s wrong. He’s given me something to chew on as I think about how far to push TDD.",
      "content_length": 2302,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 230,
      "content": "CHAPTER 36\n\nGlossary\n\nI tend to use technical terms without defining them. If we were talking together, that glazed look in your eyes would tell me I’d wandered off into jargon land. In the absence of your inestimable feedback, here are the terms reviewers have huh’d.\n\nSBPP\n\nvalue object\n\nhashCode\n\ninline\n\nmodel code\n\nmethod signature\n\ngreen bar\n\nred bar\n\nTKO\n\n215",
      "content_length": 366,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 231,
      "content": "216\n\nGlossary\n\nexception A way of transfering control to a method deeper in the call stack. Used to allow normal processing to be written simply and centralize handling of strange paths through the code (generally error conditions).\n\nleptokurtotic\n\nscalene\n\nisoceles\n\nequilateral\n\nfailure\n\nerror\n\ntransitive closure",
      "content_length": 315,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 232,
      "content": "CHAPTER 37\n\nAppendix1:Influence Diagrams\n\nYou will find many examples of influence diagrams in the text. The idea of influ- ence diagrams is taken from Gerald Weinberg’s excellent Quality Software Man- agement series, particularly book 1 Systems Thinking (Dorset House, 1992). The purpose of an influence diagram is to see how the elements of a system affect each other.\n\nInfluence diagrams have three elements:\n\n(cid:127) Activities, notated as a word or short phrase\n\n(cid:127)\n\nPositive connections, notated as a directed arrow between two activities, mean- ing that more of the source activity tends to create more of the destination activ- ity or less of the source activity tends to create less of the destination activity (cid:127) Negative connections, notated as a directed arrow between two activities with a circle over it, meaning that more of the source activity tends to create less of the destination activity or less of the source activity tends to create more of the des- tination activity\n\nThat’s lots of words for a simple concept. Here are some examples:\n\nCircus attendance and hedge trimming\n\nFigure N: Two seemingly unrelated activites\n\n217",
      "content_length": 1162,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 233,
      "content": "218\n\nAppendix 1: Influence Diagrams\n\nEating positively connected to weight\n\nFigure N: Positively connected activities\n\nThe more I eat, the more I weigh. The less I eat, the less I weigh. (Personal weight is a far more complicated system than this, of course. Influence diagrams are mod- els to help you understand some aspect of the system, not understand and control it perfectly.)\n\nExercise negatively connected to weight\n\nFigure N: Negatively connected activities\n\nFeedback\n\nInfluence doesn’t just work one way. Often the effects of an activity come back around to change the activity itself, either positively or negatively. For example:\n\nWeight negatively connected to self esteem negatively connected to eating positively connected to weight.\n\nFigure N: Feedback\n\nIf my weight rises, my self-esteem drops, which makes we want to eat more, which makes my weight rise, and so on. Any time you have a cycle in an influence dia- gram, you have feedback.\n\nThere are two kinds of feedback:\n\n(cid:127)\n\nPositive (cid:127) Negative\n\nPositive feedback causes systems to encourage more and more of an activity. You can find positive feedback loops by counting the number of negative connections in a cycle. If there are an even number of negative connections, you have a positive feedback loop. The loop above is a positive feedback loop. It will cause you to keep gaining weight until the influence of some other activity kicks in.\n\nNegative feedback damps or reduces an activity. Cycles with an odd number of negative connections are negative feedback loops.",
      "content_length": 1556,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 234,
      "content": "The key to system design is\n\nCreating virtuous cycles, where positive feedback loops encourage the growth of good activities\n\n(cid:127) Avoiding death spirals, where positive feedback loops encourage the growth of\n\nunproductive or destructive activities\n\nCreating negative feedback cycles to prevent overuse of good activities\n\nSystem Control\n\nWhen choosing a system of software development practices, you’d like the prac- tices to support each other so that you tend to do about the right amount of any activity, even under stress. Here’s an example of a system of practices that leads to insufficient testing:\n\nTime pressure neg testing neg errors pos time pressure\n\nFigure N: Not enough time to test reduces the available time\n\nUnder the pressure of time, you reduce the amount of testing, which increases the number of errors, which increases the time pressure. Eventually some outside activ- ity (like “Cash Flow Panic”) steps in to ship the software regardless.\n\nWhen you have a system that isn’t behaving, you have a host of options:\n\n(cid:127) Drive a positive feedback loop the other directions. If you have a loop between tests and confidence, and tests have been failing thus reducing confidence, you can make more tests work to increase confidence in your ability to get more test working.\n\nIntroduce a negative feedback loop to control an activity which has grown too large.\n\nCreate or break connections to eliminate loops that are not helping.\n\n219",
      "content_length": 1462,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 235,
      "content": "220\n\nAppendix 1: Influence Diagrams",
      "content_length": 35,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 236,
      "content": "CHAPTER 38\n\nFibonacci\n\nIn answer to a reviewer’s question, I posted a test-driven Fibonacci. Several reviewers commented that this example turned on their light about how test-driven development works. However, it is not long enough, nor does it demonstrate enough of TDD techniques, to replace the existing examples. If your lights are still dark after reading the main examples, take a look here and see.\n\nThe first test shows that fib(0) = 0. The implementation returns a constant.\n\npublic void testFibonacci() { assertEquals(0, fib(0));\n\n}\n\nint fib(int n) { return 0;\n\n}\n\n(I am just using the TestCase class as a home for the code, since it is only a single function.)\n\nThe second test shows that fib(1) = 1.\n\npublic void testFibonacci() { assertEquals(0, fib(0)); assertEquals(1, fib(1));\n\n221",
      "content_length": 798,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 237,
      "content": "222\n\nFibonacci\n\n}\n\nI just put the second assert in the same method because there didn’t seem to be any substantial communication value to writing “testFibonacciOfOneIsOne”.\n\nThere are several ways I could go to making this run. I’ll choose to treat 0 as a spe- cial case:\n\nint fib(int n) {\n\nif (n == 0) return 0; return 1;\n\n}\n\nThe duplication in the test case is starting to bug me, and it will only get worse as we add new cases. We can factor out the common structure of the assertions by driving the test from a table of input and expected values.\n\npublic void testFibonacci() {\n\nint cases[][]= {{0,0},{1,1}}; for (int i= 0; i < cases.length; i++)\n\nassertEquals(cases[i][1], fib(cases[i][0]));\n\n}\n\nNow adding the next case requires 6 keystrokes and no additional lines:\n\npublic void testFibonacci() {\n\nint cases[][]= {{0,0},{1,1},{2,1}}; for (int i= 0; i < cases.length; i++)\n\nassertEquals(cases[i][1], fib(cases[i][0]));\n\n}\n\nDisconcertingly, the test works. It just so happens that our constant “1” is right for this case as well. On to the next test:\n\npublic void testFibonacci() {\n\nint cases[][]= {{0,0},{1,1},{2,1},{3,2}}; for (int i= 0; i < cases.length; i++)\n\nassertEquals(cases[i][1], fib(cases[i][0]));\n\n}\n\nHooray, it fails. Applying the same strategy as before (treating smaller inputs as special cases), we write:",
      "content_length": 1326,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 238,
      "content": "int fib(int n) {\n\nif (n == 0) return 0; if (n <= 2) return 1; return 2;\n\n}\n\nNow we are ready to generalize. We wrote “2”, but we don’t really mean “2”, we mean “1 + 1”.\n\nint fib(int n) {\n\nif (n == 0) return 0; if (n <= 2) return 1; return 1 + 1;\n\n}\n\nThat first “1” is an example of fib(n-1):\n\nint fib(int n) {\n\nif (n == 0) return 0; if (n <= 2) return 1; return fib(n-1) + 1;\n\n}\n\nThe second “1” is an example of fib(n-2):\n\nint fib(int n) {\n\nif (n == 0) return 0; if (n <= 2) return 1; return fib(n-1) + fib(n-2);\n\n}\n\nCleaning up now, the same structure should work for fib(2), so we can tighten up the second condition:\n\nint fib(int n) {\n\nif (n == 0) return 0; if (n == 1) return 1; return fib(n-1) + fib(n-2);\n\n}\n\nAnd there we have fibonacci, derived totally from the tests.\n\n223",
      "content_length": 780,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 239,
      "content": "224\n\nFibonacci",
      "content_length": 14,
      "extraction_method": "Unstructured"
    }
  ]
}