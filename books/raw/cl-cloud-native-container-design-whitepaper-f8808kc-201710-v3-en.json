{
  "metadata": {
    "title": "cl-cloud-native-container-design-whitepaper-f8808kc-201710-v3-en",
    "author": "Unknown Author",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 8,
    "conversion_date": "2025-12-19T18:44:08.097698",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "cl-cloud-native-container-design-whitepaper-f8808kc-201710-v3-en.pdf",
    "extraction_method": "Unstructured"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "detection_method": "synthetic",
      "content": "PRINCIPLES OF SOFTWARE DESIGN:\n\nKeep it simple, stupid (KISS)\n\nDon’t repeat yourself (DRY)\n\nYou aren’t gonna need it\n\n(YAGNI)\n\nSeparation of concerns (SoC)\n\nRED HAT APPROACH TO CLOUD-NATIVE CONTAINERS:\n\nSingle concern principle (SCP)\n\nHigh observability\n\nprinciple (HOP)\n\nLife-cycle conformance\n\nprinciple (LCP)\n\nImage immutability\n\nprinciple (IIP)\n\nProcess disposability principle (PDP)\n\nSelf-containment\n\nprinciple (S-CP)\n\nRuntime confinement\n\nprinciple (RCP)\n\nfacebook.com/redhatinc @redhatnews linkedin.com/company/red-hat\n\nredhat.com\n\nWHITEPAPER\n\nPRINCIPLES OF CONTAINER-BASED APPLICATION DESIGN\n\nBy Bilgin Ibryam\n\nEXECUTIVE SUMMARY\n\n“Cloud native” is a term used to describe applications designed specifically to run on a cloud- based infrastructure. Typically, cloud-native applications are developed as loosely coupled microservices running in containers managed by platforms. These applications anticipate failure, and they run and scale reliably even when their underlying infrastructure is experienc- ing outages. To offer such capabilities, cloud-native platforms impose a set of contracts and constraints on the applications running on them. These contracts ensure that the applications conform to certain constraints and allow the platforms to automate the management of the con- tainerized applications.\n\nMany organizations understand the necessity and importance of becoming cloud native, but do not know where to start. Ensuring that cloud-native platforms and the containerized applica- tions that run on them work seamlessly together provides the ability to anticipate failure and the reliability to run and scale even when the underlying infrastructure experiences outages. This whitepaper describes a number of principles that containerized applications must comply with in order to become good cloud-native citizens. Adhering to these principles will help ensure that your applications are suitable for automation in cloud-native platforms such as Kubernetes.\n\nCOMMON CONTAINER- RELATED BEST PRACTICES:\n\nAim for small images.\n\nSupport arbitrary user IDs.\n\nMark important ports.\n\nUse volumes for\n\npersistent data.\n\nSet image metadata.\n\nSynchronize host and image.\n\nredhat.com\n\nPRINCIPLES OF SOFTWARE DESIGN\n\nPrinciples exist in many areas of life, and they generally represent a fundamental truth or belief from which others are derived. In software, principles are rather abstract guidelines, which are sup- posed to be followed while designing software. They can be applied to any programming language, implemented using different patterns, and achieved following different practices.\n\nTypically, patterns and practices are the tools used to achieve the desired outcome of the principles. There are fundamental principles for writing quality software from which all the other principles are derived. Examples of such principles include:\n\nKISS — Keep it simple, stupid.\n\nDRY — Don’t repeat yourself.\n\nYAGNI — You aren’t gonna need it.\n\nSoC — Separation of concerns.\n\nEven if these principles do not specify concrete rules, they represent a language and common wisdom that many developers understand and refer to regularly.\n\nThere are also SOLID (Single responsibility, Open/closed, Liskov substitution, Interface segregation, Dependency inversion) principles that were introduced by Robert C. Martin, which represent guide- lines for writing better object-oriented software. It is a framework consisting of complementary prin- ciples that are generic and open for interpretation but still give enough direction for creating better object-oriented designs. The expectation from SOLID principles is that, when applied, we are more likely to create a system that has higher-quality attributes and is more maintainable in the long term.\n\nThe SOLID principles use object-oriented primitives and concepts such as classes, interfaces, and inheritance for reasoning about object-oriented designs. In a similar way, there also principles for designing cloud-native applications in which the main primitive is the container image rather than a class. Following these principles, we are more likely to create containerized applications that are better suited for cloud-native platforms such as Kubernetes.\n\nRED HAT APPROACH TO CLOUD-NATIVE CONTAINERS\n\nNowadays, it is possible to put almost any application in a container and run it. But to create a con- tainerized application that can be automated and orchestrated effectively by a cloud-native platform such as Kubernetes requires additional effort.\n\nThe ideas below are inspired by many other works such as “The Twelve-Factor App,” in which the scope ranges from source code management to application scalability models. However, the scope of the following principles is constrained to designing containerized microservices-based applica- tions for cloud-native platforms such as Kubernetes.\n\nThe principles for creating containerized applications listed below use the container image as the basic primitive and the container orchestration platform as the target container runtime environ- ment. Following these principles will ensure that the resulting containers behave like a good cloud- native citizen in most container orchestration engines, allowing them to be scheduled, scaled, and monitored in an automated fashion. These principles are presented in no particular order.\n\nWHITEPAPER Principles of container-based application design\n\n2\n\nSINGLE CONCERN PRINCIPLE (SCP)\n\nIn many ways, this principle is similar to the single responsibility principle (SRP) from SOLID, which advises that a class should have only one responsibility. The motivation behind the SRP is that each responsibility is an axis of change and a class should have one — and only one — reason to change. The word “concern” in the SCP principle highlights concern as a higher level of abstraction than responsibility, and it better describes the scope as a container as opposed to a class. While the main motivation for SRP is to have a single reason for a change, the main motivation for SCP is container image reuse and replaceability. If you create a container that addresses a single concern, and it does it in a feature-complete way, the chances are higher of container image reuse in different appli- cation contexts.\n\nThus, the SCP principle dictates that every container should address a single concern and do it well. Achieving it is easier than achieving SRP in the object-oriented world, as containers usually manage a single process, and most of the time that single process addresses a single concern.\n\nCONTAINER 1 Single concern\n\nCONTAINER 2 Single concern\n\nDeployment unit (pod)\n\nFigure 1. Multiple single-concern containers in one deployment unit\n\nIf your containerized microservice needs to address multiple concerns, it can use patterns such as sidecar and init-containers to combine multiple containers into a single deployment unit (pod), where each container still handles a single concern. Similarly, you can swap containers that address the same concern. For example, replace the web server container, or a queue implementation con- tainer, with a newer and more scalable one.\n\nHIGH OBSERVABILITY PRINCIPLE (HOP)\n\nContainers provide a unified way for packaging and running applications by treating them like a black box. But any container aiming to become a cloud-native citizen must provide application pro- gramming interfaces (APIs) for the runtime environment to observe the container health and act accordingly. This is a fundamental prerequisite for automating container updates and life cycles in a unified way, which in turn improves the system’s resilience and user experience.\n\nredhat.com\n\n3\n\nprocess health\n\nCONTAINER\n\nmetrics\n\nreadiness\n\ntracing\n\nliveness\n\nlogs\n\nFigure 2. A container with multiple observability APIs (containers have multiple APIs to enable observability)\n\nIn practical terms, at a very minimum, your containerized application must provide APIs for the different kinds of health checks—liveness and readiness. Even better-behaving applications must provide other means to observe the state of the containerized application. The application should log important events into the standard error (STDERR) and standard output (STDOUT) for log aggre- gation by tools such as Fluentd and Logstash and integrate with tracing and metrics-gathering librar- ies such as OpenTracing, Prometheus, and others.\n\nTreat your application as a black box, but implement all necessary APIs to help the platform observe and manage your application in the best way possible.\n\nLIFE-CYCLE CONFORMANCE PRINCIPLE (LCP)\n\nThe HOP dictates that your container provide APIs for the platform to read from. The LCP dictates that your application have a way to read the events coming from the platform. Moreover, apart from getting events, the container should conform and react to those events. This is where the name of the principle comes from. It is almost like having “write API” in your application to interact with the platform.\n\nCONTAINER\n\nSIGTERM\n\nPreStop\n\nSIGKILL\n\nPostStart\n\nFigure 3. A container providing APIs and conforming to platform events\n\nredhat.com\n\n4\n\nThere are all kind of events coming from the managing platform that are intended to help you manage the life cycle of your container. It is up to your application to decide which events to handle and whether to react to those events or not.\n\nBut some events are more important than others. For example, any application that requires a clean shutdown process needs to catch signal: terminate (SIGTERM) messages and shut down as quickly as possible. This is to avoid the forceful shutdown through a signal: kill (SIGKILL) that follows a SIGTERM.\n\nThere are also other events, such as PostStart and PreStop, that might be significant to your appli- cation life-cycle management. For example, some applications need to warm up before service requests and some need to release resources before shutting down cleanly.\n\nIMAGE IMMUTABILITY PRINCIPLE (IIP)\n\nContainerized applications are meant to be immutable, and once built are not expected to change between different environments. This implies the use of an external means of storing the runtime data and relying on externalized configurations that vary across environments, rather than creating or modifying containers per environment. Any change in the containerized application should result in building a new container image and reusing it across all environments. The same principle is also popular under the name of immutable server/infrastructure and used for server/host man- agement, too.\n\nCONTAINER\n\napp.jar\n\nJavaTM\n\nDev\n\nTest\n\nProd\n\nFigure 4. Immutable container images are used across all environments\n\nFollowing the IIP principle should prevent the creation of similar container images for different envi- ronments, but stick to one container image configured for each environment. This principle allows practices such as automatic roll-back and roll-forward during application updates, which is an impor- tant aspect of cloud-native automation.\n\nPROCESS DISPOSABILITY PRINCIPLE (PDP)\n\nOne of the primary motivations for moving to containerized applications is that containers need to be as ephemeral as possible and ready to be replaced by another container instance at any point in time. There are many reasons to replace a container, such as failing a health check, scaling down the application, migrating the containers to a different host, platform resource starvation, or another issue.\n\nredhat.com\n\n5\n\nstart/stop\n\nCONTAINER\n\nFigure 5. A containerized application with quick start up and shut down for easy replaceability\n\nThis means that containerized applications must keep their state externalized or distributed and redundant. It also means the application should be quick in starting up and shutting down, and even be ready for a sudden, complete hardware failure.\n\nAnother helpful practice in implementing this principle is to create small containers. Containers in cloud-native environments may be automatically scheduled and started on different hosts. Having smaller containers leads to quicker start-up times because before being restarted, containers need to be physically copied to the host system.\n\nSELF-CONTAINMENT PRINCIPLE (S-CP)\n\nThis principle dictates that a container should contain everything it needs at build time. The con- tainer should rely only on the presence of the Linux® kernel and have any additional libraries added into it at the time the container is built. In addition to the libraries, it should also contain things such as the language runtime, the application platform if required, and other dependencies needed to run the containerized application.\n\nConfigs\n\nCONTAINER\n\napp.jar\n\nB u\n\ni l\n\nd t i\n\nm e\n\nR u n t i\n\nm e\n\nJava\n\nStorage\n\nFigure 6. Containers should have baked in all dependencies at build time except environment-specific ones.\n\nredhat.com\n\n6\n\nThe only exceptions are things such as configurations, which vary between different environments and must be provided at runtime; for example, through Kubernetes ConfigMap.\n\nSome applications are composed of multiple containerized components. For example, a container- ized web application may also require a database container. This principle does not suggest merging both containers. Instead, it suggests that the database container contain everything needed to run the database, and the web application container contain everything needed to run the web applica- tion, such as the web server. At runtime, the web application container will depend on and access the database container as needed.\n\nRUNTIME CONFINEMENT PRINCIPLE (RCP)\n\nS-CP looks at the containers from a build-time perspective and the resulting binary with its content. But a container is not just a single-dimensional black box of one size on the disk. Containers have multiple dimensions at runtime, such as memory usage dimension, CPU usage dimension, and other resource consumption dimensions.\n\n) B ( e z i s\n\nCONTAINER\n\nr e n a t n o C\n\ni\n\nPython\n\nglibc\n\nCPU (R)\n\nMemory (R)\n\nFigure 7. A container that declares its runtime resource requirements and respects them at runtime\n\nThis RCP principle suggests that every container declare its resource requirements and pass that information to the platform. It should share the resource profile of a container in terms of CPU, memory, networking, disk influence on how the platform performs scheduling, auto-scaling, capacity management, and the general service-level agreements (SLAs) of the container.\n\nIn addition to passing the resource requirements of the container, it is also important that the appli- cation stay confined to the indicated resource requirements. If the application stays confined, the platform is less likely to consider it for termination and migration when resource starvation occurs.\n\nredhat.com\n\n7\n\nABOUT RED HAT\n\nRed Hat is the world’s leading provider of open source software solutions, using a community-powered approach to provide reliable and high- performing cloud, Linux, middleware, storage, and virtualization technologies. Red Hat also offers award- winning support, training, and consulting services. As a connective hub in a global network of enterprises, partners, and open source communities, Red Hat helps create relevant, innovative technologies that liberate resources for growth and prepare customers for the future of IT.\n\nNORTH AMERICA 1 888 REDHAT1\n\nEUROPE, MIDDLE EAST, AND AFRICA 00800 7334 2835 europe@redhat.com\n\nASIA PACIFIC +65 6490 4200 apac@redhat.com\n\nLATIN AMERICA +54 11 4329 7300 info-latam@redhat.com\n\nfacebook.com/redhatinc @redhatnews linkedin.com/company/red-hat\n\nredhat.com #f8808_1017\n\nWHITEPAPER Principles of container-based application design\n\nCONCLUSION\n\nCloud native is more than an end state — it is a way of working. This whitepaper described a number of principles that represent foundational guidelines that containerized applications must comply with in order to be good cloud-native citizens.\n\nIn addition to those principles, creating good containerized applications requires familiarity with other container-related best practices and techniques. While the principles described above are more fundamental and apply to most use cases, the best practices listed below require judg- ment on when to apply or not apply. Here are some of the more common container-related best practices:\n\nAim for small images. Create smaller images by cleaning up temporary files and avoiding the installation of unnecessary packages. This reduces container size, build time, and networking time when copying container images.\n\nSupport arbitrary user IDs. Avoid using the sudo command or requiring a specific userid to\n\nrun your container.\n\nMark important ports. While it is possible to specify port numbers at runtime, specifying them using the EXPOSE command makes it easier for both humans and software to use your image.\n\nUse volumes for persistent data. The data that needs to be preserved after a container is\n\ndestroyed must be written to a volume.\n\nSet image metadata. Image metadata in the form of tags, labels, and annotations makes your\n\ncontainer images more usable, resulting in a better experience for developers using your images.\n\nSynchronize host and image. Some containerized applications require the container to be\n\nsynchronized with the host on certain attributes such as time and machine ID.\n\nHere are links to resources with patterns and best practices to help you implement the above- listed principles more effectively:\n\nhttps://www.slideshare.net/luebken/container-patterns\n\nhttps://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices\n\nhttp://docs.projectatomic.io/container-best-practices\n\nhttps://docs.openshift.com/enterprise/3.0/creating_images/guidelines.html\n\nhttps://www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf\n\nhttps://leanpub.com/k8spatterns/\n\nhttps://12factor.net/\n\nCopyright © 2017 Red Hat, Inc. Red Hat, Red Hat Enterprise Linux, the Shadowman logo, and JBoss are trademarks or registered trademarks of Red Hat, Inc. or its subsidiaries in the United States and other countries. Linux® is the registered trademark of Linus Torvalds in the U.S. and other countries.",
      "page_number": 1
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "content": "PRINCIPLES OF SOFTWARE DESIGN:\n\nKeep it simple, stupid (KISS)\n\nDon’t repeat yourself (DRY)\n\nYou aren’t gonna need it\n\n(YAGNI)\n\nSeparation of concerns (SoC)\n\nRED HAT APPROACH TO CLOUD-NATIVE CONTAINERS:\n\nSingle concern principle (SCP)\n\nHigh observability\n\nprinciple (HOP)\n\nLife-cycle conformance\n\nprinciple (LCP)\n\nImage immutability\n\nprinciple (IIP)\n\nProcess disposability principle (PDP)\n\nSelf-containment\n\nprinciple (S-CP)\n\nRuntime confinement\n\nprinciple (RCP)\n\nfacebook.com/redhatinc @redhatnews linkedin.com/company/red-hat\n\nredhat.com\n\nWHITEPAPER\n\nPRINCIPLES OF CONTAINER-BASED APPLICATION DESIGN\n\nBy Bilgin Ibryam\n\nEXECUTIVE SUMMARY\n\n“Cloud native” is a term used to describe applications designed specifically to run on a cloud- based infrastructure. Typically, cloud-native applications are developed as loosely coupled microservices running in containers managed by platforms. These applications anticipate failure, and they run and scale reliably even when their underlying infrastructure is experienc- ing outages. To offer such capabilities, cloud-native platforms impose a set of contracts and constraints on the applications running on them. These contracts ensure that the applications conform to certain constraints and allow the platforms to automate the management of the con- tainerized applications.\n\nMany organizations understand the necessity and importance of becoming cloud native, but do not know where to start. Ensuring that cloud-native platforms and the containerized applica- tions that run on them work seamlessly together provides the ability to anticipate failure and the reliability to run and scale even when the underlying infrastructure experiences outages. This whitepaper describes a number of principles that containerized applications must comply with in order to become good cloud-native citizens. Adhering to these principles will help ensure that your applications are suitable for automation in cloud-native platforms such as Kubernetes.",
      "content_length": 1981,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 2,
      "content": "COMMON CONTAINER- RELATED BEST PRACTICES:\n\nAim for small images.\n\nSupport arbitrary user IDs.\n\nMark important ports.\n\nUse volumes for\n\npersistent data.\n\nSet image metadata.\n\nSynchronize host and image.\n\nredhat.com\n\nPRINCIPLES OF SOFTWARE DESIGN\n\nPrinciples exist in many areas of life, and they generally represent a fundamental truth or belief from which others are derived. In software, principles are rather abstract guidelines, which are sup- posed to be followed while designing software. They can be applied to any programming language, implemented using different patterns, and achieved following different practices.\n\nTypically, patterns and practices are the tools used to achieve the desired outcome of the principles. There are fundamental principles for writing quality software from which all the other principles are derived. Examples of such principles include:\n\nKISS — Keep it simple, stupid.\n\nDRY — Don’t repeat yourself.\n\nYAGNI — You aren’t gonna need it.\n\nSoC — Separation of concerns.\n\nEven if these principles do not specify concrete rules, they represent a language and common wisdom that many developers understand and refer to regularly.\n\nThere are also SOLID (Single responsibility, Open/closed, Liskov substitution, Interface segregation, Dependency inversion) principles that were introduced by Robert C. Martin, which represent guide- lines for writing better object-oriented software. It is a framework consisting of complementary prin- ciples that are generic and open for interpretation but still give enough direction for creating better object-oriented designs. The expectation from SOLID principles is that, when applied, we are more likely to create a system that has higher-quality attributes and is more maintainable in the long term.\n\nThe SOLID principles use object-oriented primitives and concepts such as classes, interfaces, and inheritance for reasoning about object-oriented designs. In a similar way, there also principles for designing cloud-native applications in which the main primitive is the container image rather than a class. Following these principles, we are more likely to create containerized applications that are better suited for cloud-native platforms such as Kubernetes.\n\nRED HAT APPROACH TO CLOUD-NATIVE CONTAINERS\n\nNowadays, it is possible to put almost any application in a container and run it. But to create a con- tainerized application that can be automated and orchestrated effectively by a cloud-native platform such as Kubernetes requires additional effort.\n\nThe ideas below are inspired by many other works such as “The Twelve-Factor App,” in which the scope ranges from source code management to application scalability models. However, the scope of the following principles is constrained to designing containerized microservices-based applica- tions for cloud-native platforms such as Kubernetes.\n\nThe principles for creating containerized applications listed below use the container image as the basic primitive and the container orchestration platform as the target container runtime environ- ment. Following these principles will ensure that the resulting containers behave like a good cloud- native citizen in most container orchestration engines, allowing them to be scheduled, scaled, and monitored in an automated fashion. These principles are presented in no particular order.\n\nWHITEPAPER Principles of container-based application design\n\n2",
      "content_length": 3425,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 3,
      "content": "SINGLE CONCERN PRINCIPLE (SCP)\n\nIn many ways, this principle is similar to the single responsibility principle (SRP) from SOLID, which advises that a class should have only one responsibility. The motivation behind the SRP is that each responsibility is an axis of change and a class should have one — and only one — reason to change. The word “concern” in the SCP principle highlights concern as a higher level of abstraction than responsibility, and it better describes the scope as a container as opposed to a class. While the main motivation for SRP is to have a single reason for a change, the main motivation for SCP is container image reuse and replaceability. If you create a container that addresses a single concern, and it does it in a feature-complete way, the chances are higher of container image reuse in different appli- cation contexts.\n\nThus, the SCP principle dictates that every container should address a single concern and do it well. Achieving it is easier than achieving SRP in the object-oriented world, as containers usually manage a single process, and most of the time that single process addresses a single concern.\n\nCONTAINER 1 Single concern\n\nCONTAINER 2 Single concern\n\nDeployment unit (pod)\n\nFigure 1. Multiple single-concern containers in one deployment unit\n\nIf your containerized microservice needs to address multiple concerns, it can use patterns such as sidecar and init-containers to combine multiple containers into a single deployment unit (pod), where each container still handles a single concern. Similarly, you can swap containers that address the same concern. For example, replace the web server container, or a queue implementation con- tainer, with a newer and more scalable one.\n\nHIGH OBSERVABILITY PRINCIPLE (HOP)\n\nContainers provide a unified way for packaging and running applications by treating them like a black box. But any container aiming to become a cloud-native citizen must provide application pro- gramming interfaces (APIs) for the runtime environment to observe the container health and act accordingly. This is a fundamental prerequisite for automating container updates and life cycles in a unified way, which in turn improves the system’s resilience and user experience.\n\nredhat.com\n\n3",
      "content_length": 2254,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 4,
      "content": "process health\n\nCONTAINER\n\nmetrics\n\nreadiness\n\ntracing\n\nliveness\n\nlogs\n\nFigure 2. A container with multiple observability APIs (containers have multiple APIs to enable observability)\n\nIn practical terms, at a very minimum, your containerized application must provide APIs for the different kinds of health checks—liveness and readiness. Even better-behaving applications must provide other means to observe the state of the containerized application. The application should log important events into the standard error (STDERR) and standard output (STDOUT) for log aggre- gation by tools such as Fluentd and Logstash and integrate with tracing and metrics-gathering librar- ies such as OpenTracing, Prometheus, and others.\n\nTreat your application as a black box, but implement all necessary APIs to help the platform observe and manage your application in the best way possible.\n\nLIFE-CYCLE CONFORMANCE PRINCIPLE (LCP)\n\nThe HOP dictates that your container provide APIs for the platform to read from. The LCP dictates that your application have a way to read the events coming from the platform. Moreover, apart from getting events, the container should conform and react to those events. This is where the name of the principle comes from. It is almost like having “write API” in your application to interact with the platform.\n\nCONTAINER\n\nSIGTERM\n\nPreStop\n\nSIGKILL\n\nPostStart\n\nFigure 3. A container providing APIs and conforming to platform events\n\nredhat.com\n\n4",
      "content_length": 1464,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 5,
      "content": "There are all kind of events coming from the managing platform that are intended to help you manage the life cycle of your container. It is up to your application to decide which events to handle and whether to react to those events or not.\n\nBut some events are more important than others. For example, any application that requires a clean shutdown process needs to catch signal: terminate (SIGTERM) messages and shut down as quickly as possible. This is to avoid the forceful shutdown through a signal: kill (SIGKILL) that follows a SIGTERM.\n\nThere are also other events, such as PostStart and PreStop, that might be significant to your appli- cation life-cycle management. For example, some applications need to warm up before service requests and some need to release resources before shutting down cleanly.\n\nIMAGE IMMUTABILITY PRINCIPLE (IIP)\n\nContainerized applications are meant to be immutable, and once built are not expected to change between different environments. This implies the use of an external means of storing the runtime data and relying on externalized configurations that vary across environments, rather than creating or modifying containers per environment. Any change in the containerized application should result in building a new container image and reusing it across all environments. The same principle is also popular under the name of immutable server/infrastructure and used for server/host man- agement, too.\n\nCONTAINER\n\napp.jar\n\nJavaTM\n\nDev\n\nTest\n\nProd\n\nFigure 4. Immutable container images are used across all environments\n\nFollowing the IIP principle should prevent the creation of similar container images for different envi- ronments, but stick to one container image configured for each environment. This principle allows practices such as automatic roll-back and roll-forward during application updates, which is an impor- tant aspect of cloud-native automation.\n\nPROCESS DISPOSABILITY PRINCIPLE (PDP)\n\nOne of the primary motivations for moving to containerized applications is that containers need to be as ephemeral as possible and ready to be replaced by another container instance at any point in time. There are many reasons to replace a container, such as failing a health check, scaling down the application, migrating the containers to a different host, platform resource starvation, or another issue.\n\nredhat.com\n\n5",
      "content_length": 2366,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 6,
      "content": "start/stop\n\nCONTAINER\n\nFigure 5. A containerized application with quick start up and shut down for easy replaceability\n\nThis means that containerized applications must keep their state externalized or distributed and redundant. It also means the application should be quick in starting up and shutting down, and even be ready for a sudden, complete hardware failure.\n\nAnother helpful practice in implementing this principle is to create small containers. Containers in cloud-native environments may be automatically scheduled and started on different hosts. Having smaller containers leads to quicker start-up times because before being restarted, containers need to be physically copied to the host system.\n\nSELF-CONTAINMENT PRINCIPLE (S-CP)\n\nThis principle dictates that a container should contain everything it needs at build time. The con- tainer should rely only on the presence of the Linux® kernel and have any additional libraries added into it at the time the container is built. In addition to the libraries, it should also contain things such as the language runtime, the application platform if required, and other dependencies needed to run the containerized application.\n\nConfigs\n\nCONTAINER\n\napp.jar\n\nB u\n\ni l\n\nd t i\n\nm e\n\nR u n t i\n\nm e\n\nJava\n\nStorage\n\nFigure 6. Containers should have baked in all dependencies at build time except environment-specific ones.\n\nredhat.com\n\n6",
      "content_length": 1389,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 7,
      "content": "The only exceptions are things such as configurations, which vary between different environments and must be provided at runtime; for example, through Kubernetes ConfigMap.\n\nSome applications are composed of multiple containerized components. For example, a container- ized web application may also require a database container. This principle does not suggest merging both containers. Instead, it suggests that the database container contain everything needed to run the database, and the web application container contain everything needed to run the web applica- tion, such as the web server. At runtime, the web application container will depend on and access the database container as needed.\n\nRUNTIME CONFINEMENT PRINCIPLE (RCP)\n\nS-CP looks at the containers from a build-time perspective and the resulting binary with its content. But a container is not just a single-dimensional black box of one size on the disk. Containers have multiple dimensions at runtime, such as memory usage dimension, CPU usage dimension, and other resource consumption dimensions.\n\n) B ( e z i s\n\nCONTAINER\n\nr e n a t n o C\n\ni\n\nPython\n\nglibc\n\nCPU (R)\n\nMemory (R)\n\nFigure 7. A container that declares its runtime resource requirements and respects them at runtime\n\nThis RCP principle suggests that every container declare its resource requirements and pass that information to the platform. It should share the resource profile of a container in terms of CPU, memory, networking, disk influence on how the platform performs scheduling, auto-scaling, capacity management, and the general service-level agreements (SLAs) of the container.\n\nIn addition to passing the resource requirements of the container, it is also important that the appli- cation stay confined to the indicated resource requirements. If the application stays confined, the platform is less likely to consider it for termination and migration when resource starvation occurs.\n\nredhat.com\n\n7",
      "content_length": 1942,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 8,
      "content": "ABOUT RED HAT\n\nRed Hat is the world’s leading provider of open source software solutions, using a community-powered approach to provide reliable and high- performing cloud, Linux, middleware, storage, and virtualization technologies. Red Hat also offers award- winning support, training, and consulting services. As a connective hub in a global network of enterprises, partners, and open source communities, Red Hat helps create relevant, innovative technologies that liberate resources for growth and prepare customers for the future of IT.\n\nNORTH AMERICA 1 888 REDHAT1\n\nEUROPE, MIDDLE EAST, AND AFRICA 00800 7334 2835 europe@redhat.com\n\nASIA PACIFIC +65 6490 4200 apac@redhat.com\n\nLATIN AMERICA +54 11 4329 7300 info-latam@redhat.com\n\nfacebook.com/redhatinc @redhatnews linkedin.com/company/red-hat\n\nredhat.com #f8808_1017\n\nWHITEPAPER Principles of container-based application design\n\nCONCLUSION\n\nCloud native is more than an end state — it is a way of working. This whitepaper described a number of principles that represent foundational guidelines that containerized applications must comply with in order to be good cloud-native citizens.\n\nIn addition to those principles, creating good containerized applications requires familiarity with other container-related best practices and techniques. While the principles described above are more fundamental and apply to most use cases, the best practices listed below require judg- ment on when to apply or not apply. Here are some of the more common container-related best practices:\n\nAim for small images. Create smaller images by cleaning up temporary files and avoiding the installation of unnecessary packages. This reduces container size, build time, and networking time when copying container images.\n\nSupport arbitrary user IDs. Avoid using the sudo command or requiring a specific userid to\n\nrun your container.\n\nMark important ports. While it is possible to specify port numbers at runtime, specifying them using the EXPOSE command makes it easier for both humans and software to use your image.\n\nUse volumes for persistent data. The data that needs to be preserved after a container is\n\ndestroyed must be written to a volume.\n\nSet image metadata. Image metadata in the form of tags, labels, and annotations makes your\n\ncontainer images more usable, resulting in a better experience for developers using your images.\n\nSynchronize host and image. Some containerized applications require the container to be\n\nsynchronized with the host on certain attributes such as time and machine ID.\n\nHere are links to resources with patterns and best practices to help you implement the above- listed principles more effectively:\n\nhttps://www.slideshare.net/luebken/container-patterns\n\nhttps://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices\n\nhttp://docs.projectatomic.io/container-best-practices\n\nhttps://docs.openshift.com/enterprise/3.0/creating_images/guidelines.html\n\nhttps://www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf\n\nhttps://leanpub.com/k8spatterns/\n\nhttps://12factor.net/\n\nCopyright © 2017 Red Hat, Inc. Red Hat, Red Hat Enterprise Linux, the Shadowman logo, and JBoss are trademarks or registered trademarks of Red Hat, Inc. or its subsidiaries in the United States and other countries. Linux® is the registered trademark of Linus Torvalds in the U.S. and other countries.",
      "content_length": 3378,
      "extraction_method": "Unstructured"
    }
  ]
}