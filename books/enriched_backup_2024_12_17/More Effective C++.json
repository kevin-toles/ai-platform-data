{
  "metadata": {
    "title": "0321515811.Pdf",
    "author": "Unknown Author",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 335,
    "conversion_date": "2025-11-23T09:58:34.594619",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "More Effective C++.pdf"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "detection_method": "topic_boundary",
      "content": ">\n\nMore Effective C+\n\n35 New Ways\nto Improve }OGF\nPrograms@inig Designs\n\nScott MGVGTS\n\n‘=\n=\n4\nR\n03\nZ\nz\nvw\nJ\n-\n<\n~\nx\nmn\nwy\nyy\nz\n~\nZz\n>\na\nS\nc\nr\n=\nos\nies\n— |\nZz\ni)\ny\nnm\n2\nnm\nw”\n\nPraise for More Effective C++: 35 New Ways \nto Improve Your Programs and Designs\n“This is an enlightening book on many aspects of C++: both the regions of the \nlanguage you seldom visit, and the familiar ones you THOUGHT you understood. \nOnly by understanding deeply how the C++ compiler interprets your code can \nyou hope to write robust software using this language. This book is an invaluable \nresource for gaining that level of understanding. After reading this book, I feel like \nI've been through a code review with a master C++ programmer, and picked up \nmany of his most valuable insights.”\n— Fred Wild, Vice President of Technology, \nAdvantage Software Technologies\n“This book includes a great collection of important techniques for writing \nprograms that use C++ well. It explains how to design and implement the ideas, \nand what hidden pitfalls lurk in some obvious alternative designs. It also includes \nclear explanations of features recently added to C++. Anyone who wants to use \nthese new features will want a copy of this book close at hand for ready reference.”\n— Christopher J. Van Wyk, Professor, \nMathematics and Computer Science, Drew University\n“Industrial strength C++ at its best. The perfect companion to those who have \nread Effective C++.” \n— Eric Nagler, C++ Instructor and Author, \nUniversity of California Santa Cruz Extension\n“More Effective C++ is a thorough and valuable follow-up to Scott's first book, \nEffective C++. I believe that every professional C++ developer should read and \ncommit to memory the tips in both Effective C++ and More Effective C++. I've \nfound that the tips cover poorly understood, yet important and sometimes arcane \nfacets of the language. I strongly recommend this book, along with his first, to \ndevelopers, testers, and managers ... everyone can benefit from his expert \nknowledge and excellent presentation.”\n— Steve Burkett, Software Consultant\n\n\nThis page intentionally left blank \n\n\nMore Effective C++\n\n\nAddison-Wesley Professional Computing Series\nBrian W. Kernighan, Consulting Editor \nMatthew H. Austern, Generic Programming and the STL: Using and Extending the C++ Standard Template Library\nDavid R. Butenhof, Programming with POSIX® Threads\nBrent Callaghan, NFS Illustrated\nTom Cargill, C++ Programming Style\nWilliam R. Cheswick/Steven M. Bellovin/Aviel D. Rubin, Firewalls and Internet Security, Second Edition: Repelling \nthe Wily Hacker\nDavid A. Curry, UNIX® System Security: A Guide for Users and System Administrators\nStephen C. Dewhurst, C++ Gotchas: Avoiding Common Problems in Coding and Design\nDan Farmer/Wietse Venema, Forensic Discovery\nErich Gamma/Richard Helm/Ralph Johnson/John Vlissides, Design Patterns: Elements of Reusable Object-\nOriented Software\nErich Gamma/Richard Helm/Ralph Johnson/John Vlissides, Design Patterns CD: Elements of Reusable Object-\nOriented Software \nPeter Haggar, Practical Java™Programming Language Guide\nDavid R. Hanson, C Interfaces and Implementations: Techniques for Creating Reusable Software\nMark Harrison/Michael McLennan, Effective Tcl/Tk Programming: Writing Better Programs with Tcl and Tk\nMichi Henning/Steve Vinoski, Advanced CORBA® Programming with C++\nBrian W. Kernighan/Rob Pike, The Practice of Programming\nS. Keshav, An Engineering Approach to Computer Networking: ATM Networks, the Internet, and the Telephone Network\nJohn Lakos, Large-Scale C++ Software Design\nScott Meyers, Effective C++ CD: 85 Specific Ways to Improve Your Programs and Designs\nScott Meyers, Effective C++, Third Edition: 55 Specific Ways to Improve Your Programs and Designs\nScott Meyers, More Effective C++: 35 New Ways to Improve Your Programs and Designs\nScott Meyers, Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library\nRobert B. Murray, C++ Strategies and Tactics\nDavid R. Musser/Gillmer J. Derge/Atul Saini, STL Tutorial and Reference Guide, Second Edition: \nC++ Programming with the Standard Template Library\nJohn K. Ousterhout, Tcl and the Tk Toolkit\nCraig Partridge, Gigabit Networking\nRadia Perlman, Interconnections, Second Edition: Bridges, Routers, Switches, and Internetworking Protocols\nStephen A. Rago, UNIX® System V Network Programming\nEric S. Raymond, The Art of UNIX Programming\nMarc J. Rochkind, Advanced UNIX Programming, Second Edition\nCurt Schimmel, UNIX® Systems for Modern Architectures: Symmetric Multiprocessing and Caching for Kernel Programmers\nW. Richard Stevens, TCP/IP Illustrated, Volume 1: The Protocols\nW. Richard Stevens, TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX®\nDomain Protocols\nW. Richard Stevens/Bill Fenner/Andrew M. Rudoff,  UNIX Network Programming Volume 1, Third Edition: The \nSockets Networking API\nW. Richard Stevens/Stephen A. Rago, Advanced Programming in the UNIX® Environment, Second Edition\nW. Richard Stevens/Gary R. Wright, TCP/IP Illustrated Volumes 1-3 Boxed Set\nJohn Viega/Gary McGraw, Building Secure Software: How to Avoid Security Problems the Right Way\nGary R. Wright/W. Richard Stevens, TCP/IP Illustrated, Volume 2: The Implementation\nRuixi Yuan/W. Timothy Strayer, Virtual Private Networks: Technologies and Solutions\nVisit www.awprofessional.com/series/professionalcomputing for more information about these titles.\n\n\nMore Effective C++\n35 New Ways to Improve Your Programs and Designs\nScott Meyers\nUpper Saddle River, NJ • Boston • Indianapolis • San Francisco\nNew York • Toronto • Montreal • London • Munich • Paris • Madrid\nCape Town • Sydney • Tokyo • Singapore • Mexico City\n\n\nMany of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. \nWhere those designations appear in this book, and the publisher was aware of a trademark claim, the designations have \nbeen printed with initial capital letters or in all capitals.\nThe authors and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of \nany kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential \ndamages in connection with or arising out of the use of the information or programs contained herein.\nThe publisher offers excellent discounts on this book when ordered in quantity for bulk purchases or special sales, which \nmay include electronic versions and/or custom covers and content particular to your business, training goals, marketing \nfocus, and branding interests. For more information, please contact:\nU.S. Corporate and Government Sales\n(800) 382-3419\ncorpsales@pearsontechgroup.com\nFor sales outside the United States please contact:\nInternational Sales\ninternational@pearsoned.com\nLibrary of Congress Cataloging-in-Publication Data\nMeyers, Scott (Scott Douglas)\nMore effective C++: 35 new ways to improve your programs and \ndesigns / Scott Meyers.\np.  cm. — (Addison-Wesley professional computing series)\nIncludes bibliographical references and index.\nISBN 0-201-63371-X (paperback: alk. paper)\n1. C++ (Computer program language)  I. Series.\nQA76.73.C153M495  1996\n005.13'3—dc20\n95–47354\n      CIP\nCopyright © 1996 by Addison-Wesley\nAll rights reserved. Printed in the United States of America. This publication is protected by copyright, and permission \nmust be obtained from the publisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in \nany form or by any means, electronic, mechanical, photocopying, recording, or likewise. For information regarding per-\nmissions, write to:\nPearson Education, Inc\nRights and Contracts Department\n501 Boylston Street, Suite 900\nBoston, MA 02116\nFax (617) 671-3447\nISBN-13: 978-0-201-63371-9\nISBN-10:\n0-201-63371-X\nText printed in the United States on recycled paper at Courier in Stoughton, Massachusetts.\nTwenty-fourth printing\nApril 2007\n\n\nFor Clancy,\nmy favorite enemy within.\n",
      "page_number": 1,
      "chapter_number": 1,
      "summary": "It explains how to design and implement the ideas, \nand what hidden pitfalls lurk in some obvious alternative designs Key topics include programs, programming, and software.",
      "keywords": [
        "Effective",
        "Richard Stevens",
        "Programming",
        "Designs Scott MGVGTS",
        "Scott Meyers",
        "Improve Your Programs",
        "UNIX Network Programming",
        "Programs",
        "Standard Template Library",
        "Improve",
        "Designs",
        "Richard",
        "Advanced UNIX Programming",
        "Scott",
        "Programs and Designs"
      ],
      "concepts": [
        "programs",
        "programming",
        "software",
        "networking",
        "unix",
        "john",
        "designs",
        "designations",
        "effective",
        "sales"
      ],
      "similar_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 2,
          "title": "Segment 2 (pages 10-17)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 42,
          "title": "Segment 42 (pages 849-853)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "AntiPatterns",
          "chapter": 1,
          "title": "Segment 1 (pages 2-12)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "AntiPatterns",
          "chapter": 4,
          "title": "Segment 4 (pages 30-37)",
          "relevance_score": 0.56,
          "method": "api"
        }
      ]
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 9-16)",
      "start_page": 9,
      "end_page": 16,
      "detection_method": "topic_boundary",
      "content": "This page intentionally left blank \n\n\nContents\nAcknowledgments\nxi\nIntroduction\n1\nBasics\n9\nItem 1:\nDistinguish between pointers and references.\n9\nItem 2:\nPrefer C++-style casts.\n12\nItem 3:\nNever treat arrays polymorphically.\n16\nItem 4:\nAvoid gratuitous default constructors.\n19\nOperators\n24\nItem 5:\nBe wary of user-defined conversion functions.\n24\nItem 6:\nDistinguish between prefix and postfix forms of \nincrement and decrement operators.\n31\nItem 7:\nNever overload &&, ||, or ,.\n35\nItem 8:\nUnderstand the different meanings of new\nand delete.\n38\nExceptions\n44\nItem 9:\nUse destructors to prevent resource leaks.\n45\nItem 10:\nPrevent resource leaks in constructors.\n50\nItem 11:\nPrevent exceptions from leaving destructors.\n58\nItem 12:\nUnderstand how throwing an exception differs from \npassing a parameter or calling a virtual function.\n61\nItem 13:\nCatch exceptions by reference.\n68\nItem 14:\nUse exception specifications judiciously.\n72\nItem 15:\nUnderstand the costs of exception handling.\n78\n\n\nx\nContents\nEfficiency\n81\nItem 16:\nRemember the 80-20 rule.\n82\nItem 17:\nConsider using lazy evaluation.\n85\nItem 18:\nAmortize the cost of expected computations.\n93\nItem 19:\nUnderstand the origin of temporary objects.\n98\nItem 20:\nFacilitate the return value optimization.\n101\nItem 21:\nOverload to avoid implicit type conversions.\n105\nItem 22:\nConsider using op= instead of stand-alone op.\n107\nItem 23:\nConsider alternative libraries.\n110\nItem 24:\nUnderstand the costs of virtual functions, multiple \ninheritance, virtual base classes, and RTTI.\n113\nTechniques\n123\nItem 25:\nVirtualizing constructors and non-member\nfunctions.\n123\nItem 26:\nLimiting the number of objects of a class.\n130\nItem 27:\nRequiring or prohibiting heap-based objects.\n145\nItem 28:\nSmart pointers.\n159\nItem 29:\nReference counting.\n183\nItem 30:\nProxy classes.\n213\nItem 31:\nMaking functions virtual with respect to more\nthan one object.\n228\nMiscellany\n252\nItem 32:\nProgram in the future tense.\n252\nItem 33:\nMake non-leaf classes abstract.\n258\nItem 34:\nUnderstand how to combine C++ and C in the\nsame program.\n270\nItem 35:\nFamiliarize yourself with the language standard.\n277\nRecommended Reading\n285\nAn auto_ptr Implementation\n291\nGeneral Index\n295\nIndex of Example Classes, Functions, and Templates\n313\n\n\nAcknowledgments\nA great number of people helped bring this book into existence. Some\ncontributed ideas for technical topics, some helped with the process of\nproducing the book, and some just made life more fun while I was\nworking on it. \nWhen the number of contributors to a book is large, it is not uncom-\nmon to dispense with individual acknowledgments in favor of a ge-\nneric “Contributors to this book are too numerous to mention.” I\nprefer to follow the expansive lead of John L. Hennessy and David A.\nPatterson in Computer Architecture: A Quantitative Approach (Morgan\nKaufmann, first edition 1990). In addition to motivating the compre-\nhensive acknowledgments that follow, their book provides hard data\nfor the 90-10 rule, which I refer to in Item 16.\nThe Items\nWith the exception of direct quotations, all the words in this book are\nmine. However, many of the ideas I discuss came from others. I have\ndone my best to keep track of who contributed what, but I know I have\nincluded information from sources I now fail to recall, foremost among\nthem many posters to the Usenet newsgroups comp.lang.c++ and\ncomp.std.c++.\nMany ideas in the C++ community have been developed independently\nby many people. In what follows, I note only where I was exposed to\nparticular ideas, not necessarily where those ideas originated.\nBrian Kernighan suggested the use of macros to approximate the syn-\ntax of the new C++ casting operators I describe in Item 2.\nIn Item 3, my warning about deleting an array of derived class objects\nthrough a base class pointer is based on material in Dan Saks’ “Got-\nchas” talk, which he’s given at several conferences and trade shows.\n\n\nxii\nAcknowledgments\nIn Item 5, the proxy class technique for preventing unwanted applica-\ntion of single-argument constructors is based on material in Andrew\nKoenig's column in the January 1994 C++ Report.\nJames Kanze made a posting to comp.lang.c++ on implementing\npostfix increment and decrement operators via the corresponding pre-\nfix functions; I use his technique in Item 6.\nDavid Cok, writing me about material I covered in Effective C++,\nbrought to my attention the distinction between operator new and the\nnew operator that is the crux of Item 8. Even after reading his letter, I\ndidn’t really understand the distinction, but without his initial prod-\nding, I probably still wouldn’t.\nThe notion of using destructors to prevent resource leaks (used in Item\n9) comes from section 15.3 of Margaret A. Ellis’ and Bjarne Strous-\ntrup’s The Annotated C++ Reference Manual (see page 285). There the\ntechnique is called resource acquisition is initialization. Tom Cargill\nsuggested I shift the focus of the approach from resource acquisition\nto resource release. \nSome of my discussion in Item 11 was inspired by material in Chapter\n4 of Taligent’s Guide to Designing Programs (Addison-Wesley, 1994).\nMy description of over-eager memory allocation for the DynArray class\nin Item 18 is based on Tom Cargill’s article, “A Dynamic vector is\nharder than it looks,” in the June 1992 C++ Report. A more sophisti-\ncated design for a dynamic array class can be found in Cargill’s follow-\nup column in the January 1994 C++ Report.\nItem 21 was inspired by Brian Kernighan’s paper, “An AWK to C++\nTranslator,” at the 1991 USENIX C++ Conference. His use of over-\nloaded operators (sixty-seven of them!) to handle mixed-type arith-\nmetic operations, though designed to solve a problem unrelated to the\none I explore in Item 21, led me to consider multiple overloadings as a\nsolution to the problem of temporary creation.\nIn Item 26, my design of a template class for counting objects is based\non a posting to comp.lang.c++ by Jamshid Afshar.\nThe idea of a mixin class to keep track of pointers from operator new\n(see Item 27) is based on a suggestion by Don Box. Steve Clamage\nmade the idea practical by explaining how dynamic_cast can be used\nto find the beginning of memory for an object.\nThe discussion of smart pointers in Item 28 is based in part on Steven\nBuroff’s and Rob Murray’s C++ Oracle column in the October 1993 C++\nReport; on Daniel R. Edelson’s classic paper, “Smart Pointers: They’re\nSmart, but They’re Not Pointers,” in the proceedings of the 1992\n\n\nAcknowledgments\nxiii\nUSENIX C++ Conference; on section 15.9.1 of Bjarne Stroustrup’s The\nDesign and Evolution of C++ (see page 285); on Gregory Colvin’s “C++\nMemory Management” class notes from C/C++ Solutions ’95; and on\nCay Horstmann’s column in the March-April 1993 issue of the C++ Re-\nport. I developed some of the material myself, though. Really.\nIn Item 29, the use of a base class to store reference counts and of\nsmart pointers to manipulate those counts is based on Rob Murray’s\ndiscussions of the same topics in sections 6.3.2 and 7.4.2, respec-\ntively, of his C++ Strategies and Tactics (see page 286). The design for\nadding reference counting to existing classes follows that presented by\nCay Horstmann in his March-April 1993 column in the C++ Report.\nIn Item 30, my discussion of lvalue contexts is based on comments in\nDan Saks’ column in the C User’s Journal (now the C/C++ Users Jour-\nnal) of January 1993. The observation that non-proxy member func-\ntions are unavailable when called through proxies comes from an\nunpublished paper by Cay Horstmann.\nThe use of runtime type information to build vtbl-like arrays of func-\ntion pointers (in Item 31) is based on ideas put forward by Bjarne\nStroustrup in postings to comp.lang.c++ and in section 13.8.1 of his\nThe Design and Evolution of C++ (see page 285).\nThe material in Item 33 is based on several of my C++ Report columns\nin 1994 and 1995. Those columns, in turn, included comments I re-\nceived from Klaus Kreft about how to use dynamic_cast to implement\na virtual operator= that detects arguments of the wrong type.\nMuch of the material in Item 34 was motivated by Steve Clamage’s ar-\nticle, “Linking C++ with other languages,” in the May 1992 C++ Re-\nport. In that same Item, my treatment of the problems caused by\nfunctions like strdup was motivated by an anonymous reviewer.\nThe Book\nReviewing draft copies of a book is hard — and vitally important —\nwork. I am grateful that so many people were willing to invest their\ntime and energy on my behalf. I am especially grateful to Jill Huchital,\nTim Johnson, Brian Kernighan, Eric Nagler, and Chris Van Wyk, as\nthey read the book (or large portions of it) more than once. In addition\nto these gluttons for punishment, complete drafts of the manuscript\nwere read by Katrina Avery, Don Box, Steve Burkett, Tom Cargill,\nTony Davis, Carolyn Duby, Bruce Eckel, Read Fleming, Cay Horst-\nmann, James Kanze, Russ Paielli, Steve Rosenthal, Robin Rowe, Dan\nSaks, Chris Sells, Webb Stacy, Dave Swift, Steve Vinoski, and Fred\nWild. Partial drafts were reviewed by Bob Beauchaine, Gerd Hoeren,\n\n\nxiv\nAcknowledgments\nJeff Jackson, and Nancy L. Urbano. Each of these reviewers made\ncomments that greatly improved the accuracy, utility, and presenta-\ntion of the material you find here.\nOnce the book came out, I received corrections and suggestions from\nmany people: Luis Kida, John Potter, Tim Uttormark, Mike Fulkerson,\nDan Saks, Wolfgang Glunz, Clovis Tondo, Michael Loftus, Liz Hanks, Wil\nEvers, Stefan Kuhlins, Jim McCracken, Alan Duchan, John Jacobsma,\nRamesh Nagabushnam, Ed Willink, Kirk Swenson, Jack Reeves, Doug\nSchmidt, Tim Buchowski, Paul Chisholm, Andrew Klein, Eric Nagler,\nJeffrey Smith, Sam Bent, Oleg Shteynbuk, Anton Doblmaier, Ulf\nMichaelis, Sekhar Muddana, Michael Baker, Yechiel Kimchi, David Pap-\nurt, Ian Haggard, Robert Schwartz, David Halpin, Graham Mark, David\nBarrett, Damian Kanarek, Ron Coutts, Lance Whitesel, Jon Lachelt,\nCheryl Ferguson, Munir Mahmood, Klaus-Georg Adams, David Goh,\nChris Morley, Rainer Baumschlager, Christopher Tavares, Brian Ker-\nnighan, Charles Green, Mark Rodgers, Bobby Schmidt, Sivaramakrish-\nnan J., Eric Anderson, Phil Brabbin, Feliks Kluzniak, Evan McLean,\nKurt Miller, Niels Dekker, Balog Pal, Dean Stanton, William Mattison,\nChulsu Park, Pankaj Datta, John Newell, Ani Taggu, Christopher\nCreutzi, Chris Wineinger, Alexander Bogdanchikov, Michael Tegtmeyer,\nAharon Robbins, Davide Gennaro, Adrian Spermezan, Matthias Hof-\nmann, Chang Chen, John Wismar, Mark Symonds, Thomas Kim, Ita\nRyan, and Rice Yeh. Their suggestions allowed me to improve More Effec-\ntive C++ in updated printings (such as this one), and I greatly appreciate\ntheir help.\nDuring preparation of this book, I faced many questions about the\nemerging ISO/ANSI standard for C++, and I am grateful to Steve\nClamage and Dan Saks for taking the time to respond to my incessant\nemail queries.\nJohn Max Skaller and Steve Rumsby conspired to get me the HTML for\nthe draft ANSI C++ standard before it was widely available. Vivian Neou\npointed me to the Netscape WWW browser as a stand-alone HTML\nviewer under (16 bit) Microsoft Windows, and I am deeply grateful to the\nfolks at Netscape Communications for making their fine viewer freely\navailable on such a pathetic excuse for an operating system.\nBryan Hobbs and Hachemi Zenad generously arranged to get me a\ncopy of the internal engineering version of the MetaWare C++ compiler\nso I could check the code in this book using the latest features of the\nlanguage. Cay Horstmann helped me get the compiler up and running\nin the very foreign world of DOS and DOS extenders. Borland (now In-\nprise) provided a beta copy of their most advanced compiler, and Eric\nNagler and Chris Sells provided invaluable help in testing code for me\non compilers to which I had no access.\n\n\nxv\nAcknowledgments\nWithout the staff at the Corporate and Professional Publishing Divi-\nsion of Addison-Wesley, there would be no book, and I am indebted to\nKim Dawley, Lana Langlois, Simone Payment, Marty Rabinowitz,\nPradeepa Siva, John Wait, and the rest of the staff for their encourage-\nment, patience, and help with the production of this work.\nChris Guzikowski helped draft the back cover copy for this book, and\nTim Johnson stole time from his research on low-temperature physics\nto critique later versions of that text.\nTom Cargill graciously agreed to make his C++ Report article on excep-\ntions (see page 287) available at the Addison-Wesley Internet site. \nThe People\nKathy Reed was responsible for my introduction to programming;\nsurely she didn’t deserve to have to put up with a kid like me. Donald\nFrench had faith in my ability to develop and present C++ teaching\nmaterials when I had no track record. He also introduced me to John\nWait, my editor at Addison-Wesley, an act for which I will always be\ngrateful. The triumvirate at Beaver Ridge — Jayni Besaw, Lorri Fields,\nand Beth McKee — provided untold entertainment on my breaks as I\nworked on the book. \nMy wife, Nancy L. Urbano, put up with me and put up with me and\nput up with me as I worked on the book, continued to work on the\nbook, and kept working on the book. How many times did she hear me\nsay we’d do something after the book was done? Now the book is\ndone, and we will do those things. She amazes me. I love her.\nFinally, I must acknowledge our puppy, Persephone, whose existence\nchanged our world forever. Without her, this book would have been\nfinished both sooner and with less sleep deprivation, but also with\nsubstantially less comic relief.\n",
      "page_number": 9,
      "chapter_number": 2,
      "summary": "This chapter covers segment 2 (pages 9-16). Key topics include item, classes, and john. 19\nOperators\n24\nItem 5:\nBe wary of user-defined conversion functions.",
      "keywords": [
        "Item",
        "book",
        "intentionally left blank",
        "John",
        "based",
        "Report",
        "Steve",
        "pointers",
        "Tom Cargill",
        "Acknowledgments",
        "Cay Horstmann",
        "material",
        "left blank Contents",
        "David",
        "page intentionally left"
      ],
      "concepts": [
        "item",
        "classes",
        "john",
        "david",
        "acknowledgments",
        "acknowledge",
        "provides",
        "provided",
        "functions",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Python Distilled",
          "chapter": 8,
          "title": "Segment 8 (pages 62-70)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 17,
          "title": "Segment 17 (pages 165-174)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 27,
          "title": "Segment 27 (pages 850-883)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 55,
          "title": "Segment 55 (pages 1103-1105)",
          "relevance_score": 0.53,
          "method": "api"
        }
      ]
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 17-24)",
      "start_page": 17,
      "end_page": 24,
      "detection_method": "topic_boundary",
      "content": "This page intentionally left blank \n\n\nIntroduction\nIntroduction\nThese are heady days for C++ programmers. Commercially available\nless than a decade, C++ has nevertheless emerged as the language of\nchoice for systems programming on nearly all major computing plat-\nforms. Companies and individuals with challenging programming\nproblems increasingly embrace the language, and the question faced\nby those who do not use C++ is often when they will start, not if. Stan-\ndardization of C++ is complete, and the breadth and scope of the ac-\ncompanying library — which both dwarfs and subsumes that of C —\nmakes it possible to write rich, complex programs without sacrificing\nportability or implementing common algorithms and data structures\nfrom scratch. C++ compilers continue to proliferate, the features they\noffer continue to expand, and the quality of the code they generate con-\ntinues to improve. Tools and environments for C++ development grow\never more abundant, powerful, and robust. Commercial libraries all\nbut obviate the need to write code in many application areas.\nAs the language has matured and our experience with it has increased,\nour needs for information about it have changed. In 1990, people\nwanted to know what C++ was. By 1992, they wanted to know how to\nmake it work. Now C++ programmers ask higher-level questions: How\ncan I design my software so it will adapt to future demands? How can\nI improve the efficiency of my code without compromising its correct-\nness or making it harder to use? How can I implement sophisticated\nfunctionality not directly supported by the language? \nIn this book, I answer these questions and many others like them.\nThis book shows how to design and implement C++ software that is\nmore effective: more likely to behave correctly; more robust in the face\nof exceptions; more efficient; more portable; makes better use of lan-\nguage features; adapts to change more gracefully; works better in a\nmixed-language environment; is easier to use correctly; is harder to\nuse incorrectly. In short, software that’s just better.\n\n\n2\nIntroduction\nThe material in this book is divided into 35 Items. Each Item summa-\nrizes accumulated wisdom of the C++ programming community on a\nparticular topic. Most Items take the form of guidelines, and the expla-\nnation accompanying each guideline describes why the guideline ex-\nists, what happens if you fail to follow it, and under what conditions it\nmay make sense to violate the guideline anyway.\nItems fall into several categories. Some concern particular language\nfeatures, especially newer features with which you may have little ex-\nperience. For example, Items 9 through 15 are devoted to exceptions.\nOther Items explain how to combine the features of the language to\nachieve higher-level goals. Items 25 through 31, for instance, describe\nhow to constrain the number or placement of objects, how to create\nfunctions that act “virtual” on the type of more than one object, how to\ncreate “smart pointers,” and more. Still other Items address broader\ntopics; Items 16 through 24 focus on efficiency. No matter what the\ntopic of a particular Item, each takes a no-nonsense approach to the\nsubject. In More Effective C++, you learn how to use C++ more effec-\ntively. The descriptions of language features that make up the bulk of\nmost C++ texts are in this book mere background information.\nAn implication of this approach is that you should be familiar with C++\nbefore reading this book. I take for granted that you understand\nclasses, protection levels, virtual and nonvirtual functions, etc., and I\nassume you are acquainted with the concepts behind templates and\nexceptions. At the same time, I don’t expect you to be a language ex-\npert, so when poking into lesser-known corners of C++, I always ex-\nplain what’s going on.\nThe C++ in More Effective C++\nThe C++ I describe in this book is the language specified by the 1998\nInternational Standard for C++. This means I may use a few features\nyour compilers don’t yet support. Don’t worry. The only “new” feature\nI assume you have is templates, and templates are now almost univer-\nsally available. I use exceptions, too, but that use is largely confined to\nItems 9 through 15, which are specifically devoted to exceptions. If you\ndon’t have access to a compiler offering exceptions, that’s okay. It\nwon’t affect your ability to take advantage of the material in the other\nparts of the book. Furthermore, you should read Items 9 through 15\neven if you don’t have support for exceptions, because those items ex-\namine issues you need to understand in any case.\nI recognize that just because the standardization committee blesses a\nfeature or endorses a practice, there’s no guarantee that the feature is\npresent in current compilers or the practice is applicable to existing\n\n\nIntroduction\n3\nenvironments. When faced with a discrepancy between theory (what\nthe committee says) and practice (what actually works), I discuss both,\nthough my bias is toward things that work. Because I discuss both,\nthis book will aid you as your compilers approach conformance with\nthe standard. It will show you how to use existing constructs to ap-\nproximate language features your compilers don’t yet support, and it\nwill guide you when you decide to transform workarounds into newly-\nsupported features.\nNotice that I refer to your compilers — plural. Different compilers im-\nplement varying approximations to the standard, so I encourage you to\ndevelop your code under at least two compilers. Doing so will help you\navoid inadvertent dependence on one vendor’s proprietary language\nextension or its misinterpretation of the standard. It will also help keep\nyou away from the bleeding edge of compiler technology, e.g., from new\nfeatures supported by only one vendor. Such features are often poorly\nimplemented (buggy or slow — frequently both), and upon their intro-\nduction, the C++ community lacks experience to advise you in their\nproper use. Blazing trails can be exciting, but when your goal is pro-\nducing reliable code, it’s often best to let others test the waters before\njumping in.\nThere are two constructs you’ll see in this book that may not be famil-\niar to you. Both are relatively recent language extensions. Some com-\npilers support them, but if your compilers don’t, you can easily\napproximate them with features you do have.\nThe first construct is the bool type, which has as its values the key-\nwords true and false. If your compilers haven’t implemented bool,\nthere are two ways to approximate it. One is to use a global enum:\nenum bool { false, true };\nThis allows you to overload functions on the basis of whether they take\na bool or an int, but it has the disadvantage that the built-in compar-\nison operators (i.e., ==, <, >=, etc.) still return ints. As a result, code\nlike the following will not behave the way it’s supposed to:\nvoid f(int);\nvoid f(bool);\nint x, y;\n...\nf( x < y );\n// calls f(int), but it\n// should call f(bool) \nThe enum approximation may thus lead to code whose behavior\nchanges when you submit it to a compiler that truly supports bool.\n\n\n4\nIntroduction\nAn alternative is to use a typedef for bool and constant objects for\ntrue and false:\ntypedef int bool;\nconst bool false = 0;\nconst bool true = 1;\nThis is compatible with the traditional semantics of C and C++, and the\nbehavior of programs using this approximation won’t change when\nthey’re ported to bool-supporting compilers. The drawback is that you\ncan’t differentiate between bool and int when overloading functions.\nBoth approximations are reasonable. Choose the one that best fits\nyour circumstances.\nThe second new construct is really four constructs, the casting forms\nstatic_cast, const_cast, dynamic_cast, and reinterpret_cast.\nIf you’re not familiar with these casts, you’ll want to turn to Item 2 and\nread all about them. Not only do they do more than the C-style casts\nthey replace, they do it better. I use these new casting forms whenever\nI need to perform a cast in this book.\nThere is more to C++ than the language itself. There is also the stan-\ndard library. Where possible, I employ the standard string type in-\nstead of using raw char* pointers, and I encourage you to do the\nsame. string objects are no more difficult to manipulate than char*-\nbased strings, and they relieve you of most memory-management con-\ncerns. Furthermore, string objects are less susceptible to memory\nleaks if an exception is thrown (see Items 9 and 10). A well-imple-\nmented string type can hold its own in an efficiency contest with its\nchar* equivalent, and it may even do better. (For insight into how this\ncould be, see Item 29.) If you don’t have access to an implementation\nof the standard string type, you almost certainly have access to some\nstring-like class. Use it. Just about anything is preferable to raw\nchar*s.\nI use data structures from the standard library whenever I can. Such\ndata structures are drawn from the Standard Template Library (the\n“STL” — see Item 35). The STL includes bitsets, vectors, lists, queues,\nstacks, maps, sets, and more, and you should prefer these standard-\nized data structures to the ad hoc equivalents you might otherwise be\ntempted to write. Your compilers may not have the STL bundled in, but\ndon’t let that keep you from using it. Thanks to Silicon Graphics, you\ncan download a free copy that works with many compilers from the\nSGI STL web site: http://www.sgi.com/tech/stl/.\n\n\nIntroduction\n5\nIf you currently use a library of algorithms and data structures and are\nhappy with it, there’s no need to switch to the STL just because it’s\n“standard.” However, if you have a choice between using an STL com-\nponent or writing your own code from scratch, you should lean toward\nusing the STL. Remember code reuse? STL (and the rest of the stan-\ndard library) has lots of code that is very much worth reusing.\nConventions and Terminology\nAny time I mention inheritance in this book, I mean public inheritance.\nIf I don’t mean public inheritance, I’ll say so explicitly. When drawing\ninheritance hierarchies, I depict base-derived relationships by drawing\narrows from derived classes to base classes. For example, here is a hi-\nerarchy from Item 31:\nThis notation is the reverse of the convention I employed in the first\n(but not the second) edition of Effective C++. I’m now convinced that\nmost C++ practitioners draw inheritance arrows from derived to base\nclasses, and I am happy to follow suit. Within such diagrams, abstract\nclasses (e.g., GameObject) are shaded and concrete classes (e.g.,\nSpaceShip) are unshaded.\nInheritance gives rise to pointers and references with two different\ntypes, a static type and a dynamic type. The static type of a pointer or\nreference is its declared type. The dynamic type is determined by the\ntype of object it actually refers to. Here are some examples based on\nthe classes above:\nGameObject *pgo =\n// static type of pgo is\nnew SpaceShip;\n// GameObject*, dynamic\n// type is SpaceShip*\nAsteroid *pa = new Asteroid;\n// static type of pa is\n// Asteroid*. So is its\n// dynamic type\npgo = pa;\n// static type of pgo is\n// still (and always)\n// GameObject*. Its \n// dynamic type is now\n// Asteroid*\nGameObject\nSpaceShip\nSpaceStation\nAsteroid\n\n\n6\nIntroduction\nGameObject& rgo = *pa;\n// static type of rgo is\n// GameObject, dynamic\n// type is Asteroid\nThese examples also demonstrate a naming convention I like. pgo is a\npointer-to-GameObject; pa is a pointer-to-Asteroid; rgo is a refer-\nence-to-GameObject. I often concoct pointer and reference names in\nthis fashion. \nTwo of my favorite parameter names are lhs and rhs, abbreviations\nfor “left-hand side” and “right-hand side,” respectively. To understand\nthe rationale behind these names, consider a class for representing ra-\ntional numbers:\nclass Rational { ... };\nIf I wanted a function to compare pairs of Rational objects, I’d declare\nit like this:\nbool operator==(const Rational& lhs, const Rational& rhs);\nThat would let me write this kind of code:\nRational r1, r2;\n...\nif (r1 == r2) ...\nWithin the call to operator==, r1 appears on the left-hand side of the\n“==” and is bound to lhs, while r2 appears on the right-hand side of\nthe “==” and is bound to rhs.\nOther abbreviations I employ include ctor for “constructor,” dtor for\n“destructor,” and RTTI for C++’s support for runtime type identification\n(of which dynamic_cast is the most commonly used component).\nWhen you allocate memory and fail to free it, you have a memory leak.\nMemory leaks arise in both C and C++, but in C++, memory leaks leak\nmore than just memory. That’s because C++ automatically calls con-\nstructors when objects are created, and constructors may themselves\nallocate resources. For example, consider this code:\nclass Widget { ... };\n// some class — it doesn’t\n// matter what it is\nWidget *pw = new Widget;\n// dynamically allocate a\n// Widget object\n...\n// assume pw is never\n// deleted\nThis code leaks memory, because the Widget pointed to by pw is never\ndeleted. However, if the Widget constructor allocates additional re-\n\n\nIntroduction\n7\nsources that are to be released when the Widget is destroyed (such as\nfile descriptors, semaphores, window handles, database locks, etc.),\nthose resources are lost just as surely as the memory is. To emphasize\nthat memory leaks in C++ often leak other resources, too, I usually\nspeak of resource leaks in this book rather than memory leaks.\nYou won’t see many inline functions in this book. That’s not because I\ndislike inlining. Far from it, I believe that inline functions are an im-\nportant feature of C++. However, the criteria for determining whether a\nfunction should be inlined can be complex, subtle, and platform-de-\npendent. As a result, I avoid inlining unless there is a point about in-\nlining I wish to make. When you see a non-inline function in More\nEffective C++, that doesn’t mean I think it would be a bad idea to de-\nclare the function inline, it just means the decision to inline that\nfunction is independent of the material I’m examining at that point in\nthe book.\nA few C++ features have been deprecated by the standardization com-\nmittee. Such features are slated for eventual removal from the lan-\nguage, because newer features have been added that do what the\ndeprecated features do, but do it better. In this book, I identify depre-\ncated constructs and explain what features replace them. You should\ntry to avoid deprecated features where you can, but there’s no reason\nto be overly concerned about their use. In the interest of preserving\nbackward compatibility for their customers, compiler vendors are\nlikely to support deprecated features for many years.\nA client is somebody (a programmer) or something (a class or function,\ntypically) that uses the code you write. For example, if you write a Date\nclass (for representing birthdays, deadlines, when the Second Coming\noccurs, etc.), anybody using that class is your client. Furthermore, any\nsections of code that use the Date class are your clients as well. Cli-\nents are important. In fact, clients are the name of the game! If nobody\nuses the software you write, why write it? You will find I worry a lot\nabout making things easier for clients, often at the expense of making\nthings more difficult for you, because good software is “clientcentric”\n— it revolves around clients. If this strikes you as unreasonably phil-\nanthropic, view it instead through a lens of self-interest. Do you ever\nuse the classes or functions you write? If so, you’re your own client, so\nmaking things easier for clients in general also makes them easier for\nyou.\nWhen discussing class or function templates and the classes or func-\ntions generated from them, I reserve the right to be sloppy about the\ndifference between the templates and their instantiations. For exam-\nple, if Array is a class template taking a type parameter T, I may refer\nto a particular instantiation of the template as an Array, even though\n",
      "page_number": 17,
      "chapter_number": 3,
      "summary": "This chapter covers segment 3 (pages 17-24). Key topics include classes, compilers, and features. Commercially available\nless than a decade, C++ has nevertheless emerged as the language of\nchoice for systems programming on nearly all major computing plat-\nforms.",
      "keywords": [
        "type",
        "Items",
        "features",
        "n’t",
        "book",
        "code",
        "compilers",
        "language",
        "static type",
        "bool",
        "page intentionally left",
        "intentionally left blank",
        "STL",
        "Standard",
        "language features"
      ],
      "concepts": [
        "classes",
        "compilers",
        "features",
        "language",
        "items",
        "uses",
        "inheritance",
        "type",
        "functionality",
        "functions"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 1,
          "title": "Segment 1 (pages 1-35)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "Segment 61 (pages 1953-1984)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 64,
          "title": "Segment 64 (pages 2050-2080)",
          "relevance_score": 0.66,
          "method": "api"
        }
      ]
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 25-32)",
      "start_page": 25,
      "end_page": 32,
      "detection_method": "topic_boundary",
      "content": "8\nIntroduction\nArray<T> is really the name of the class. Similarly, if swap is a func-\ntion template taking a type parameter T, I may refer to an instantiation\nas swap instead of swap<T>. In cases where this kind of shorthand\nmight be unclear, I include template parameters when referring to\ntemplate instantiations.\nReporting Bugs, Making Suggestions, Getting Book Updates\nI have tried to make this book as accurate, readable, and useful as\npossible, but I know there is room for improvement. If you find an error\nof any kind — technical, grammatical, typographical, whatever —\nplease tell me about it. I will try to correct the mistake in future print-\nings of the book, and if you are the first person to report it, I will gladly\nadd your name to the book’s acknowledgments. If you have other sug-\ngestions for improvement, I welcome those, too.\nI continue to collect guidelines for effective programming in C++. If you\nhave ideas for new guidelines, I’d be delighted if you’d share them with\nme. Send your guidelines, your comments, your criticisms, and your\nbug reports to:\nScott Meyers\nc/o Editor-in-Chief, Corporate and Professional Publishing\nAddison-Wesley Publishing Company\n1 Jacob Way\nReading, MA 01867\nU. S. A.\nAlternatively, you may send electronic mail to mec++@awl.com.\nI maintain a list of changes to this book since its first printing, includ-\ning bug-fixes, clarifications, and technical updates. This list, along\nwith other book-related information, is available from Addison-Wesley\nat World Wide Web URL http://www.awl.com/cp/mec++.html. It is\nalso available via anonymous FTP from ftp.awl.com in the directory\ncp/mec++. If you would like a copy of the list of changes to this book,\nbut you lack access to the Internet, please send a request to one of the\naddresses above, and I will see that the list is sent to you.\nIf you’d like to be notified when I make changes to this book, consider\njoining my mailing list. For details, consult http://www.aristeia.com/\nMailingList/index.html.\nEnough preliminaries. On with the show!\n\n\nBasics\nBasics\nAh, the basics. Pointers, references, casts, arrays, constructors — you\ncan’t get much more basic than that. All but the simplest C++ pro-\ngrams use most of these features, and many programs use them all. \nIn spite of our familiarity with these parts of the language, sometimes\nthey can still surprise us. This is especially true for programmers mak-\ning the transition from C to C++, because the concepts behind refer-\nences, dynamic casts, default constructors, and other non-C features\nare usually a little murky.\nThis chapter describes the differences between pointers and references\nand offers guidance on when to use each. It introduces the new C++\nsyntax for casts and explains why the new casts are superior to the C-\nstyle casts they replace. It examines the C notion of arrays and the C++\nnotion of polymorphism, and it describes why mixing the two is an idea\nwhose time will never come. Finally, it considers the pros and cons of\ndefault constructors and suggests ways to work around language re-\nstrictions that encourage you to have one when none makes sense.\nBy heeding the advice in the items that follow, you’ll make progress to-\nward a worthy goal: producing software that expresses your design in-\ntentions clearly and correctly.\nItem 1:\nDistinguish between pointers and references.\nPointers versus References\nPointers and references look different enough (pointers use the “*” and\n“->” operators, references use “.”), but they seem to do similar things.\nBoth pointers and references let you refer to other objects indirectly.\nHow, then, do you decide when to use one and not the other?\nFirst, recognize that there is no such thing as a null reference. A refer-\nence must always refer to some object. As a result, if you have a vari-\nable whose purpose is to refer to another object, but it is possible that\nthere might not be an object to refer to, you should make the variable\n\n\n10\nItem 1\na pointer, because then you can set it to null. On the other hand, if the\nvariable must always refer to an object, i.e., if your design does not\nallow for the possibility that the variable is null, you should probably\nmake the variable a reference.\n“But wait,” you wonder, “what about underhandedness like this?”\nchar *pc = 0;\n// set pointer to null\nchar& rc = *pc;\n// make reference refer to\n// dereferenced null pointer\nWell, this is evil, pure and simple. The results are undefined (compilers\ncan generate output to do anything they like), and people who write\nthis kind of code should be shunned until they agree to cease and de-\nsist. If you have to worry about things like this in your software, you’re\nprobably best off avoiding references entirely. Either that or finding a\nbetter class of programmers to work with. We’ll henceforth ignore the\npossibility that a reference can be “null.”\nBecause a reference must refer to an object, C++ requires that refer-\nences be initialized:\nstring& rs;\n// error! References must\n// be initialized\nstring s(\"xyzzy\");\nstring& rs = s;\n// okay, rs refers to s\nPointers are subject to no such restriction:\nstring *ps;\n// uninitialized pointer:\n// valid but risky\nThe fact that there is no such thing as a null reference implies that it\ncan be more efficient to use references than to use pointers. That’s be-\ncause there’s no need to test the validity of a reference before using it:\nvoid printDouble(const double& rd)\n{\ncout << rd; \n// no need to test rd; it\n}\n// must refer to a double\nPointers, on the other hand, should generally be tested against null:\nvoid printDouble(const double *pd)\n{\nif (pd) { \n// check for null pointer\ncout << *pd; \n}\n}\n\n\nPointers versus References\n11\nAnother important difference between pointers and references is that\npointers may be reassigned to refer to different objects. A reference,\nhowever, always refers to the object with which it is initialized:\nstring s1(\"Nancy\");\nstring s2(\"Clancy\");\nstring& rs = s1;\n// rs refers to s1\nstring *ps = &s1;\n// ps points to s1\nrs = s2;\n// rs still refers to s1,\n// but s1’s value is now\n// \"Clancy\"\nps = &s2;\n// ps now points to s2;\n// s1 is unchanged \nIn general, you should use a pointer whenever you need to take into\naccount the possibility that there’s nothing to refer to (in which case\nyou can set the pointer to null) or whenever you need to be able to refer\nto different things at different times (in which case you can change\nwhere the pointer points). You should use a reference whenever you\nknow there will always be an object to refer to and you also know that\nonce you’re referring to that object, you’ll never want to refer to any-\nthing else.\nThere is one other situation in which you should use a reference, and\nthat’s when you’re implementing certain operators. The most common\nexample is operator[]. This operator typically needs to return some-\nthing that can be used as the target of an assignment:\nvector<int> v(10);\n// create an int vector of size 10; \n// vector is a template in the \n// standard C++ library (see Item 35)\nv[5] = 10;\n// the target of this assignment is\n// the return value of operator[]\nIf operator[] returned a pointer, this last statement would have to be\nwritten this way:\n*v[5] = 10;\nBut this makes it look like v is a vector of pointers, which it’s not. For\nthis reason, you’ll almost always want operator[] to return a refer-\nence. (For an interesting exception to this rule, see Item 30.)\nReferences, then, are the feature of choice when you know you have\nsomething to refer to and when you’ll never want to refer to anything\nelse. They’re also appropriate when implementing operators whose\nsyntactic requirements make the use of pointers undesirable. In all\nother cases, stick with pointers.\n\n\n12\nItem 2\nItem 2:\nPrefer C++-style casts.\nNew Casting Operators\nConsider the lowly cast. Nearly as much a programming pariah as the\ngoto, it nonetheless endures, because when worse comes to worst and\npush comes to shove, casts can be necessary. Casts are especially nec-\nessary when worse comes to worst and push comes to shove.\nStill, C-style casts are not all they might be. For one thing, they’re\nrather crude beasts, letting you cast pretty much any type to pretty\nmuch any other type. It would be nice to be able to specify more pre-\ncisely the purpose of each cast. There is a great difference, for example,\nbetween a cast that changes a pointer-to-const-object into a pointer-\nto-non-const-object (i.e., a cast that changes only the constness of an\nobject) and a cast that changes a pointer-to-base-class-object into a\npointer-to-derived-class-object (i.e., a cast that completely changes an\nobject’s type). Traditional C-style casts make no such distinctions.\n(This is hardly a surprise. C-style casts were designed for C, not C++.)\nA second problem with casts is that they are hard to find. Syntacti-\ncally, casts consist of little more than a pair of parentheses and an\nidentifier, and parentheses and identifiers are used everywhere in C++.\nThis makes it tough to answer even the most basic cast-related ques-\ntions, questions like, “Are any casts used in this program?” That’s be-\ncause human readers are likely to overlook casts, and tools like grep\ncannot distinguish them from non-cast constructs that are syntacti-\ncally similar.\nC++ addresses the shortcomings of C-style casts by introducing four\nnew cast operators, static_cast, const_cast, dynamic_cast, and\nreinterpret_cast. For most purposes, all you need to know about\nthese operators is that what you are accustomed to writing like this,\n(type) expression\nyou should now generally write like this:\nstatic_cast<type>(expression)\nFor example, suppose you’d like to cast an int to a double to force an\nexpression involving ints to yield a floating point value. Using C-style\ncasts, you could do it like this:\nint firstNumber, secondNumber;\n...\ndouble result = ((double)firstNumber)/secondNumber;\nWith the new casts, you’d write it this way:\ndouble result = static_cast<double>(firstNumber)/secondNumber;\n\n\nNew Casting Operators\n13\nNow there’s a cast that’s easy to see, both for humans and for pro-\ngrams.\nstatic_cast has basically the same power and meaning as the gen-\neral-purpose C-style cast. It also has the same kind of restrictions. For\nexample, you can’t cast a struct into an int or a double into a\npointer using static_cast any more than you can with a C-style cast.\nFurthermore, static_cast can’t remove constness from an expres-\nsion, because another new cast, const_cast, is designed specifically\nto do that.\nThe other new C++ casts are used for more restricted purposes.\nconst_cast is used to cast away the constness or volatileness of\nan expression. By using a const_cast, you emphasize (to both hu-\nmans and compilers) that the only thing you want to change through\nthe cast is the constness or volatileness of something. This mean-\ning is enforced by compilers. If you try to employ const_cast for any-\nthing other than modifying the constness or volatileness of an\nexpression, your cast will be rejected. Here are some examples:\nclass Widget { ... };\nclass SpecialWidget: public Widget { ... };\nvoid update(SpecialWidget *psw);\nSpecialWidget sw;\n// sw is a non-const object,\nconst SpecialWidget& csw = sw;\n// but csw is a reference to\n// it as a const object\nupdate(&csw);\n// error! can’t pass a const\n// SpecialWidget* to a function\n// taking a SpecialWidget*\nupdate(const_cast<SpecialWidget*>(&csw));\n// fine, the constness of &csw is \n// explicitly cast away (and \n// csw — and sw — may now be \n// changed inside update)\nupdate((SpecialWidget*)&csw);\n// same as above, but using a\n// harder-to-recognize C-style cast\nWidget *pw = new SpecialWidget;\nupdate(pw);\n// error! pw’s type is Widget*, but\n// update takes a SpecialWidget*\nupdate(const_cast<SpecialWidget*>(pw));\n// error! const_cast can be used only\n// to affect constness or volatileness,\n// never to cast down the inheritance\n// hierarchy\nBy far the most common use of const_cast is to cast away the const-\nness of an object.\n\n\n14\nItem 2\nThe second specialized type of cast, dynamic_cast, is used to perform\nsafe casts down or across an inheritance hierarchy. That is, you use\ndynamic_cast to cast pointers or references to base class objects into\npointers or references to derived or sibling base class objects in such a\nway that you can determine whether the casts succeeded.† Failed\ncasts are indicated by a null pointer (when casting pointers) or an ex-\nception (when casting references):\nWidget *pw;\n...\nupdate(dynamic_cast<SpecialWidget*>(pw));\n// fine, passes to update a pointer\n// to the SpecialWidget pw points to \n// if pw really points to one, \n// otherwise passes the null pointer\nvoid updateViaRef(SpecialWidget& rsw);\nupdateViaRef(dynamic_cast<SpecialWidget&>(*pw));\n// fine, passes to updateViaRef the \n// SpecialWidget pw points to if pw \n// really points to one, otherwise \n// throws an exception\ndynamic_casts are restricted to helping you navigate inheritance hi-\nerarchies. They cannot be applied to types lacking virtual functions\n(see also Item 24), nor can they cast away constness:\nint firstNumber, secondNumber;\n...\ndouble result = dynamic_cast<double>(firstNumber)/secondNumber;\n// error! int has no virtual functions\nconst SpecialWidget sw;\n...\nupdate(dynamic_cast<SpecialWidget*>(&sw));\n// error! dynamic_cast can’t cast \n// away constness\nIf you want to perform a cast on a type where inheritance is not in-\nvolved, you probably want a static_cast. To cast constness away,\nyou always want a const_cast.\nThe last of the four new casting forms is reinterpret_cast. This op-\nerator is used to perform type conversions whose result is nearly al-\nways implementation-defined. As a result, reinterpret_casts are\nrarely portable.\n† A second, unrelated use of dynamic_cast is to find the beginning of the memory oc-\ncupied by an object. We explore that capability in Item 27.\n\n\nNew Casting Operators\n15\nThe most common use of reinterpret_cast is to cast between func-\ntion pointer types. For example, suppose you have an array of pointers\nto functions of a particular type:\ntypedef void (*FuncPtr)();\n// a FuncPtr is a pointer \n// to a function taking no\n// args and returning void\nFuncPtr funcPtrArray[10];\n// funcPtrArray is an array\n// of 10 FuncPtrs\nLet us suppose you wish (for some unfathomable reason) to place a\npointer to the following function into funcPtrArray:\nint doSomething();\nYou can’t do what you want without a cast, because doSomething has\nthe wrong type for funcPtrArray. The functions in funcPtrArray re-\nturn void, but doSomething returns an int:\nfuncPtrArray[0] = &doSomething;\n// error! type mismatch\nA reinterpret_cast lets you force compilers to see things your way:\nfuncPtrArray[0] =\n// this compiles\nreinterpret_cast<FuncPtr>(&doSomething);\nCasting function pointers is not portable (C++ offers no guarantee that\nall function pointers are represented the same way), and in some cases\nsuch casts yield incorrect results (see Item 31), so you should avoid\ncasting function pointers unless your back’s to the wall and a knife’s\nat your throat. A sharp knife. A very sharp knife.\nIf your compilers lack support for the new casting forms, you can use\ntraditional casts in place of static_cast, const_cast, and\nreinterpret_cast. Furthermore, you can use macros to approxi-\nmate the new syntax:\n#define static_cast(TYPE,EXPR) \n((TYPE)(EXPR))\n#define const_cast(TYPE,EXPR) \n((TYPE)(EXPR))\n#define reinterpret_cast(TYPE,EXPR) ((TYPE)(EXPR))\nYou’d use the approximations like this:\ndouble result = static_cast(double, firstNumber)/secondNumber;\nupdate(const_cast(SpecialWidget*, &sw));\nfuncPtrArray[0] = reinterpret_cast(FuncPtr, &doSomething);\nThese approximations won’t be as safe as the real things, of course,\nbut they will simplify the process of upgrading your code when your\ncompilers support the new casts.\n",
      "page_number": 25,
      "chapter_number": 4,
      "summary": "This chapter covers segment 4 (pages 25-32). Key topics include casts, pointers, and type. I continue to collect guidelines for effective programming in C++.",
      "keywords": [
        "cast",
        "Pointers",
        "refer",
        "C-style casts",
        "references",
        "const",
        "SpecialWidget",
        "type",
        "object",
        "Item",
        "C-style",
        "double",
        "update",
        "null",
        "null pointer"
      ],
      "concepts": [
        "casts",
        "pointers",
        "type",
        "refer",
        "referring",
        "references",
        "making",
        "make",
        "likely",
        "updates"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 32,
          "title": "Segment 32 (pages 1015-1044)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "Segment 16 (pages 162-174)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 5,
          "title": "Segment 5 (pages 36-48)",
          "relevance_score": 0.67,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 14,
          "title": "Segment 14 (pages 142-153)",
          "relevance_score": 0.67,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 15,
          "title": "Segment 15 (pages 154-161)",
          "relevance_score": 0.67,
          "method": "api"
        }
      ]
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 33-40)",
      "start_page": 33,
      "end_page": 40,
      "detection_method": "topic_boundary",
      "content": "16\nItem 3\nThere is no easy way to emulate the behavior of a dynamic_cast, but\nmany libraries provide functions to perform safe inheritance-based\ncasts for you. If you lack such functions and you must perform this\ntype of cast, you can fall back on C-style casts for those, too, but then\nyou forego the ability to tell if the casts fail. Needless to say, you can\ndefine a macro to look like dynamic_cast, just as you can for the other\ncasts:\n#define dynamic_cast(TYPE,EXPR)\n((TYPE)(EXPR))\nRemember that this approximation is not performing a true\ndynamic_cast; there is no way to tell if the cast fails.\nI know, I know, the new casts are ugly and hard to type. If you find\nthem too unpleasant to look at, take solace in the knowledge that C-\nstyle casts continue to be valid. However, what the new casts lack in\nbeauty they make up for in precision of meaning and easy recogniz-\nability. Programs that use the new casts are easier to parse (both for\nhumans and for tools), and they allow compilers to diagnose casting\nerrors that would otherwise go undetected. These are powerful argu-\nments for abandoning C-style casts, and there may also be a third:\nperhaps making casts ugly and hard to type is a good thing.\nItem 3:\nNever treat arrays polymorphically.\nArrays and Polymorphism\nOne of the most important features of inheritance is that you can ma-\nnipulate derived class objects through pointers and references to base\nclass objects. Such pointers and references are said to behave polymor-\nphically — as if they had multiple types. C++ also allows you to manip-\nulate arrays of derived class objects through base class pointers and\nreferences. This is no feature at all, because it almost never works the\nway you want it to.\nFor example, suppose you have a class BST (for binary search tree ob-\njects) and a second class, BalancedBST, that inherits from BST:\nclass BST { ... };\nclass BalancedBST: public BST { ... };\nIn a real program such classes would be templates, but that’s unim-\nportant here, and adding all the template syntax just makes things\nharder to read. For this discussion, we’ll assume BST and Bal-\nancedBST objects contain only ints.\nConsider a function to print out the contents of each BST in an array\nof BSTs:\n\n\nArrays and Polymorphism\n17\nvoid printBSTArray(ostream& s,\nconst BST array[],\nint numElements)\n{\nfor (int i = 0; i < numElements; ++i) {\ns << array[i];\n// this assumes an\n}\n// operator<< is defined\n}\n// for BST objects\nThis will work fine when you pass it an array of BST objects:\nBST BSTArray[10];\n...\nprintBSTArray(cout, BSTArray, 10);\n// works fine\nConsider, however, what happens when you pass printBSTArray an\narray of BalancedBST objects:\nBalancedBST bBSTArray[10];\n...\nprintBSTArray(cout, bBSTArray, 10);\n// works fine?\nYour compilers will accept this function call without complaint, but\nlook again at the loop for which they must generate code:\nfor (int i = 0; i < numElements; ++i) {\ns << array[i];\n}\nNow, array[i] is really just shorthand for an expression involving\npointer arithmetic: it stands for *(array+i). We know that array is a\npointer to the beginning of the array, but how far away from the mem-\nory location pointed to by array is the memory location pointed to by\narray+i? The distance between them is i*sizeof(an object in the\narray), because there are i objects between array[0] and array[i].\nIn order for compilers to emit code that walks through the array cor-\nrectly, they must be able to determine the size of the objects in the ar-\nray. This is easy for them to do. The parameter array is declared to be\nof type array-of-BST, so each element of the array must be a BST, and\nthe distance between array and array+i must be i*sizeof(BST).\nAt least that’s how your compilers look at it. But if you’ve passed an\narray of BalancedBST objects to printBSTArray, your compilers are\nprobably wrong. In that case, they’d assume each object in the array is\nthe size of a BST, but each object would actually be the size of a Bal-\nancedBST. Derived classes usually have more data members than their\nbase classes, so derived class objects are usually larger than base\nclass objects. We thus expect a BalancedBST object to be larger than a\n\n\n18\nItem 3\nBST object. If it is, the pointer arithmetic generated for printBSTArray\nwill be wrong for arrays of BalancedBST objects, and there’s no telling\nwhat will happen when printBSTArray is invoked on a BalancedBST\narray. Whatever does happen, it’s a good bet it won’t be pleasant.\nThe problem pops up in a different guise if you try to delete an array of\nderived class objects through a base class pointer. Here’s one way you\nmight innocently attempt to do it:\n// delete an array, but first log a message about its\n// deletion\nvoid deleteArray(ostream& logStream, BST array[])\n{\nlogStream << \"Deleting array at address \" \n<< static_cast<void*>(array) << ’\\n’;\ndelete [] array;\n}\nBalancedBST *balTreeArray =\n// create a BalancedBST\nnew BalancedBST[50];\n// array\n...\ndeleteArray(cout, balTreeArray);\n// log its deletion\nYou can’t see it, but there’s pointer arithmetic going on here, too. When\nan array is deleted, a destructor for each element of the array must be\ncalled (see Item 8). When compilers see the statement\ndelete [] array;\nthey must generate code that does something like this:\n// destruct the objects in *array in the inverse order\n// in which they were constructed\nfor (int i = the number of elements in the array - 1;\ni >= 0;\n--i)\n{\narray[i].BST::~BST();\n// call array[i]’s\n}\n// destructor\nJust as this kind of loop failed to work when you wrote it, it will fail to\nwork when your compilers write it, too. The language specification\nsays the result of deleting an array of derived class objects through a\nbase class pointer is undefined, but we know what that really means:\nexecuting the code is almost certain to lead to grief. Polymorphism and\npointer arithmetic simply don’t mix. Array operations almost always\ninvolve pointer arithmetic, so arrays and polymorphism don’t mix. \nNote that you’re unlikely to make the mistake of treating an array poly-\nmorphically if you avoid having a concrete class (like BalancedBST) in-\n\n\nDefault Constructors\n19\nherit from another concrete class (such as BST). As Item 33 explains,\ndesigning your software so that concrete classes never inherit from one\nanother has many benefits. I encourage you to turn to Item 33 and\nread all about them.\nItem 4:\nAvoid gratuitous default constructors.\nDefault Constructors\nA default constructor (i.e., a constructor that can be called with no ar-\nguments) is the C++ way of saying you can get something for nothing.\nConstructors initialize objects, so default constructors initialize ob-\njects without any information from the place where the object is being\ncreated. Sometimes this makes perfect sense. Objects that act like\nnumbers, for example, may reasonably be initialized to zero or to un-\ndefined values. Objects that act like pointers (see Item 28) may reason-\nably be initialized to null or to undefined values. Data structures like\nlinked lists, hash tables, maps, and the like may reasonably be initial-\nized to empty containers. \nNot all objects fall into this category. For many objects, there is no rea-\nsonable way to perform a complete initialization in the absence of out-\nside information. For example, an object representing an entry in an\naddress book makes no sense unless the name of the thing being en-\ntered is provided. In some companies, all equipment must be tagged\nwith a corporate ID number, and creating an object to model a piece of\nequipment in such companies is nonsensical unless the appropriate\nID number is provided.\nIn a perfect world, classes in which objects could reasonably be cre-\nated from nothing would contain default constructors and classes in\nwhich information was required for object construction would not.\nAlas, ours is not the best of all possible worlds, so we must take addi-\ntional concerns into account. In particular, if a class lacks a default\nconstructor, there are restrictions on how you can use that class.\nConsider a class for company equipment in which the corporate ID\nnumber of the equipment is a mandatory constructor argument:\nclass EquipmentPiece {\npublic:\nEquipmentPiece(int IDNumber);\n...\n};\nBecause EquipmentPiece lacks a default constructor, its use may be\nproblematic in three contexts. The first is the creation of arrays. There\n\n\n20\nItem 4\nis, in general, no way to specify constructor arguments for objects in\narrays, so it is not usually possible to create arrays of Equipment-\nPiece objects:\nEquipmentPiece bestPieces[10];\n// error! No way to call\n// EquipmentPiece ctors\nEquipmentPiece *bestPieces = \nnew EquipmentPiece[10];\n// error! same problem\nThere are three ways to get around this restriction. A solution for non-\nheap arrays is to provide the necessary arguments at the point where\nthe array is defined:\nint ID1, ID2, ID3, ..., ID10;\n// variables to hold\n// equipment ID numbers\n...\nEquipmentPiece bestPieces[] = {\n// fine, ctor arguments\nEquipmentPiece(ID1), \n// are provided\nEquipmentPiece(ID2),\nEquipmentPiece(ID3),\n...,\nEquipmentPiece(ID10)\n};\nUnfortunately, there is no way to extend this strategy to heap arrays.\nA more general approach is to use an array of pointers instead of an\narray of objects:\ntypedef EquipmentPiece* PEP;\n// a PEP is a pointer to\n// an EquipmentPiece\nPEP bestPieces[10];\n// fine, no ctors called\nPEP *bestPieces = new PEP[10];\n// also fine\nEach pointer in the array can then be made to point to a different\nEquipmentPiece object:\nfor (int i = 0; i < 10; ++i)\nbestPieces[i] = new EquipmentPiece( ID Number );\nThere are two disadvantages to this approach. First, you have to re-\nmember to delete all the objects pointed to by the array. If you forget,\nyou have a resource leak. Second, the total amount of memory you\nneed increases, because you need the space for the pointers as well as\nthe space for the EquipmentPiece objects.\nYou can avoid the space penalty if you allocate the raw memory for the\narray, then use “placement new” (see Item 8) to construct the Equip-\nmentPiece objects in the memory:\n\n\nDefault Constructors\n21\n// allocate enough raw memory for an array of 10\n// EquipmentPiece objects; see Item 8 for details on\n// the operator new[] function\nvoid *rawMemory =\noperator new[](10*sizeof(EquipmentPiece));\n// make bestPieces point to it so it can be treated as an\n// EquipmentPiece array\nEquipmentPiece *bestPieces =\nstatic_cast<EquipmentPiece*>(rawMemory);\n// construct the EquipmentPiece objects in the memory \n// using \"placement new\" (see Item 8)\nfor (int i = 0; i < 10; ++i)\nnew (bestPieces+i) EquipmentPiece( ID Number );\nNotice that you still have to provide a constructor argument for each\nEquipmentPiece object. This technique (as well as the array-of-point-\ners idea) allows you to create arrays of objects when a class lacks a de-\nfault constructor; it doesn’t show you how to bypass required\nconstructor arguments. There is no way to do that. If there were, it\nwould defeat the purpose of constructors, which is to guarantee that\nobjects are initialized.\nThe downside to using placement new, aside from the fact that most\nprogrammers are unfamiliar with it (which will make maintenance\nmore difficult), is that you must manually call destructors on the ob-\njects in the array when you want them to go out of existence, then you\nmust manually deallocate the raw memory by calling operator de-\nlete[] (again, see Item 8):\n// destruct the objects in bestPieces in the inverse\n// order in which they were constructed\nfor (int i = 9; i >= 0; --i)\nbestPieces[i].~EquipmentPiece();\n// deallocate the raw memory\noperator delete[](rawMemory);\nIf you forget this requirement and use the normal array-deletion syn-\ntax, your program will behave unpredictably. That’s because the result\nof deleting a pointer that didn’t come from the new operator is unde-\nfined:\ndelete [] bestPieces;\n// undefined! bestPieces\n// didn’t come from the new\n// operator\nFor more information on the new operator, placement new and how\nthey interact with constructors and destructors, see Item 8.\n\n\n22\nItem 4\nThe second problem with classes lacking default constructors is that\nthey are ineligible for use with many template-based container classes.\nThat’s because it’s a common requirement for such templates that the\ntype used to instantiate the template provide a default constructor.\nThis requirement almost always grows out of the fact that inside the\ntemplate, an array of the template parameter type is being created. For\nexample, a template for an Array class might look something like this:\ntemplate<class T>\nclass Array {\npublic:\nArray(int size);\n...\nprivate:\nT *data;\n};\ntemplate<class T>\nArray<T>::Array(int size)\n{\ndata = new T[size];\n// calls T::T() for each\n...\n// element of the array\n}\nIn most cases, careful template design can eliminate the need for a de-\nfault constructor. For example, the standard vector template (which\ngenerates classes that act like extensible arrays) has no requirement\nthat its type parameter have a default constructor. Unfortunately,\nmany templates are designed in a manner that is anything but careful.\nThat being the case, classes without default constructors will be in-\ncompatible with many templates. As C++ programmers learn more\nabout template design, this problem should recede in significance.\nHow long it will take for that to happen, however, is anyone’s guess.\nThe final consideration in the to-provide-a-default-constructor-or-not-\nto-provide-a-default-constructor dilemma has to do with virtual base\nclasses. Virtual base classes lacking default constructors are a pain to\nwork with. That’s because the arguments for virtual base class con-\nstructors must be provided by the most derived class of the object\nbeing constructed. As a result, a virtual base class lacking a default\nconstructor requires that all classes derived from that class — no mat-\nter how far removed — must know about, understand the meaning of,\nand provide for the virtual base class’s constructors’ arguments. Au-\nthors of derived classes neither expect nor appreciate this require-\nment.\nBecause of the restrictions imposed on classes lacking default con-\nstructors, some people believe all classes should have them, even if a\n\n\nDefault Constructors\n23\ndefault constructor doesn’t have enough information to fully initialize\nobjects of that class. For example, adherents to this philosophy might\nmodify EquipmentPiece as follows:\nclass EquipmentPiece {\npublic:\nEquipmentPiece(int IDNumber = UNSPECIFIED);\n...\nprivate:\nstatic const int UNSPECIFIED;\n// magic ID number value\n// meaning no ID was\n};\n// specified\nThis allows EquipmentPiece objects to be created like this:\nEquipmentPiece e;\n// now okay\nSuch a transformation almost always complicates the other member\nfunctions of the class, because there is no longer any guarantee that\nthe fields of an EquipmentPiece object have been meaningfully initial-\nized. Assuming it makes no sense to have an EquipmentPiece without\nan ID field, most member functions must check to see if the ID is\npresent. If it’s not, they’ll have to figure out how to stumble on anyway.\nOften it’s not clear how to do that, and many implementations choose\na solution that offers nothing but expediency: they throw an exception\nor they call a function that terminates the program. When that hap-\npens, it’s difficult to argue that the overall quality of the software has\nbeen improved by including a default constructor in a class where\nnone was warranted.\nInclusion of meaningless default constructors affects the efficiency of\nclasses, too. If member functions have to test to see if fields have truly\nbeen initialized, clients of those functions have to pay for the time\nthose tests take. Furthermore, they have to pay for the code that goes\ninto those tests, because that makes executables and libraries bigger.\nThey also have to pay for the code that handles the cases where the\ntests fail. All those costs are avoided if a class’s constructors ensure\nthat all fields of an object are correctly initialized. Often default con-\nstructors can’t offer that kind of assurance, so it’s best to avoid them\nin classes where they make no sense. That places some limits on how\nsuch classes can be used, yes, but it also guarantees that when you do\nuse such classes, you can expect that the objects they generate are\nfully initialized and are efficiently implemented.\n",
      "page_number": 33,
      "chapter_number": 5,
      "summary": "This chapter covers segment 5 (pages 33-40). Key topics include arrays, classes, and constructors. If you lack such functions and you must perform this\ntype of cast, you can fall back on C-style casts for those, too, but then\nyou forego the ability to tell if the casts fail.",
      "keywords": [
        "array",
        "objects",
        "BST",
        "EquipmentPiece",
        "Default Constructors",
        "class objects",
        "Default",
        "Item",
        "derived class objects",
        "Constructors",
        "BST array",
        "classes",
        "base class",
        "BST objects",
        "EquipmentPiece objects"
      ],
      "concepts": [
        "arrays",
        "classes",
        "constructors",
        "object",
        "initialize",
        "initialized",
        "initial",
        "casts",
        "templates",
        "delete"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "Segment 61 (pages 1953-1984)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 64,
          "title": "Segment 64 (pages 2050-2080)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "Segment 62 (pages 1985-2015)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 11,
          "title": "Segment 11 (pages 113-123)",
          "relevance_score": 0.56,
          "method": "api"
        }
      ]
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 41-51)",
      "start_page": 41,
      "end_page": 51,
      "detection_method": "topic_boundary",
      "content": "Operators\nOperators\nOverloadable operators — you gotta love ’em! They allow you to give\nyour types the same syntax as C++’s built-in types, yet they let you put\na measure of power into the functions behind the operators that’s un-\nheard of for the built-ins. Of course, the fact that you can make sym-\nbols like “+” and “==” do anything you want also means you can use\noverloaded operators to produce programs best described as impene-\ntrable. Adept C++ programmers know how to harness the power of op-\nerator overloading without descending into the incomprehensible.\nRegrettably, it is easy to make the descent. Single-argument construc-\ntors and implicit type conversion operators are particularly trouble-\nsome, because they can be invoked without there being any source\ncode showing the calls. This can lead to program behavior that is diffi-\ncult to understand. A different problem arises when you overload op-\nerators like && and ||, because the shift from built-in operator to user-\ndefined function yields a subtle change in semantics that’s easy to\noverlook. Finally, many operators are related to one another in stan-\ndard ways, but the ability to overload operators makes it possible to vi-\nolate the accepted relationships.\nIn the items that follow, I focus on explaining when and how over-\nloaded operators are called, how they behave, how they should relate\nto one another, and how you can seize control of these aspects of over-\nloaded operators. With the information in this chapter under your belt,\nyou’ll be overloading (or not overloading) operators like a pro.\nItem 5:\nBe wary of user-defined conversion functions.\nConversion Functions\nC++ allows compilers to perform implicit conversions between types. In\nhonor of its C heritage, for example, the language allows silent conver-\nsions from char to int and from short to double. This is why you can\npass a short to a function that expects a double and still have the call\nsucceed. The more frightening conversions in C — those that may lose\n\n\nConversion Functions\n25\ninformation — are also present in C++, including conversion of int to\nshort and double to (of all things) char.\nYou can’t do anything about such conversions, because they’re hard-\ncoded into the language. When you add your own types, however, you\nhave more control, because you can choose whether to provide the\nfunctions compilers are allowed to use for implicit type conversions.\nTwo kinds of functions allow compilers to perform such conversions:\nsingle-argument constructors and implicit type conversion operators. A\nsingle-argument constructor is a constructor that may be called with\nonly one argument. Such a constructor may declare a single parameter\nor it may declare multiple parameters, with each parameter after the\nfirst having a default value. Here are two examples:\nclass Name {\n// for names of things\npublic:\nName(const string& s);\n// converts string to\n// Name\n...\n};\nclass Rational {\n// for rational numbers\npublic:\nRational(int numerator = 0,\n// converts int to \nint denominator = 1);\n// Rational\n...\n};\nAn implicit type conversion operator is simply a member function with\na strange-looking name: the word operator followed by a type specifi-\ncation. You aren’t allowed to specify a type for the function’s return\nvalue, because the type of the return value is basically just the name\nof the function. For example, to allow Rational objects to be implicitly\nconverted to doubles (which might be useful for mixed-mode arith-\nmetic involving Rational objects), you might define class Rational\nlike this:\nclass Rational {\npublic:\n...\noperator double() const;\n// converts Rational to\n};\n// double\nThis function would be automatically invoked in contexts like this:\nRational r(1, 2);\n// r has the value 1/2\ndouble d = 0.5 * r;\n// converts r to a double,\n// then does multiplication\n\n\n26\nItem 5\nPerhaps all this is review. That’s fine, because what I really want to ex-\nplain is why you usually don’t want to provide type conversion func-\ntions of any ilk.\nThe fundamental problem is that such functions often end up being\ncalled when you neither want nor expect them to be. The result can be\nincorrect and unintuitive program behavior that is maddeningly diffi-\ncult to diagnose.\nLet us deal first with implicit type conversion operators, as they are the\neasiest case to handle. Suppose you have a class for rational numbers\nsimilar to the one above, and you’d like to print Rational objects as if\nthey were a built-in type. That is, you’d like to be able to do this:\nRational r(1, 2);\ncout << r;\n// should print \"1/2\"\nFurther suppose you forgot to write an operator<< for Rational ob-\njects. You would probably expect that the attempt to print r would fail,\nbecause there is no appropriate operator<< to call. You would be mis-\ntaken. Your compilers, faced with a call to a function called opera-\ntor<< that takes a Rational, would find that no such function\nexisted, but they would then try to find an acceptable sequence of im-\nplicit type conversions they could apply to make the call succeed. The\nrules defining which sequences of conversions are acceptable are com-\nplicated, but in this case your compilers would discover they could\nmake the call succeed by implicitly converting r to a double by calling\nRational::operator double. The result of the code above would be to\nprint r as a floating point number, not as a rational number. This is\nhardly a disaster, but it demonstrates the disadvantage of implicit type\nconversion operators: their presence can lead to the wrong function\nbeing called (i.e., one other than the one intended).\nThe solution is to replace the operators with equivalent functions that\ndon’t have the syntactically magic names. For example, to allow con-\nversion of a Rational object to a double, replace operator double\nwith a function called something like asDouble:\nclass Rational {\npublic:\n...\ndouble asDouble() const;\n// converts Rational\n};\n// to double\nSuch a member function must be called explicitly:\nRational r(1, 2);\ncout << r;\n// error! No operator<<\n// for Rationals\n\n\nConversion Functions\n27\ncout << r.asDouble();\n// fine, prints r as a\n// double\nIn most cases, the inconvenience of having to call conversion functions\nexplicitly is more than compensated for by the fact that unintended\nfunctions can no longer be silently invoked. In general, the more expe-\nrience C++ programmers have, the more likely they are to eschew type\nconversion operators. The members of the committee working on the\nstandard C++ library (see Item 35), for example, are among the most\nexperienced in the business, and perhaps that’s why the string type\nthey added to the library contains no implicit conversion from a\nstring object to a C-style char*. Instead, there’s an explicit member\nfunction, c_str, that performs that conversion. Coincidence? I think\nnot.\nImplicit conversions via single-argument constructors are more diffi-\ncult to eliminate. Furthermore, the problems these functions cause are\nin many cases worse than those arising from implicit type conversion\noperators. \nAs an example, consider a class template for array objects. These ar-\nrays allow clients to specify upper and lower index bounds:\ntemplate<class T>\nclass Array {\npublic:\nArray(int lowBound, int highBound);\nArray(int size);\nT& operator[](int index);\n...\n};\nThe first constructor in the class allows clients to specify a range of\narray indices, for example, from 10 to 20. As a two-argument construc-\ntor, this function is ineligible for use as a type-conversion function. The\nsecond constructor, which allows clients to define Array objects by\nspecifying only the number of elements in the array (in a manner sim-\nilar to that used with built-in arrays), is different. It can be used as a\ntype conversion function, and that can lead to endless anguish.\nFor example, consider a template specialization for comparing Ar-\nray<int> objects and some code that uses such objects:\nbool operator==( const Array<int>& lhs, \nconst Array<int>& rhs);\n\n\n28\nItem 5\nArray<int> a(10);\nArray<int> b(10);\n...\nfor (int i = 0; i < 10; ++i)\nif (a == b[i]) {\n// oops! \"a\" should be \"a[i]\"\ndo something for when\na[i] and b[i] are equal;\n}\nelse {\ndo something for when they’re not;\n}\nWe intended to compare each element of a to the corresponding ele-\nment in b, but we accidentally omitted the subscripting syntax when\nwe typed a. Certainly we expect this to elicit all manner of unpleasant\ncommentary from our compilers, but they will complain not at all.\nThat’s because they see a call to operator== with arguments of type\nArray<int> (for a) and int (for b[i]), and though there is no opera-\ntor== function taking those types, our compilers notice they can con-\nvert the int into an Array<int> object by calling the Array<int>\nconstructor that takes a single int as an argument. This they proceed\nto do, thus generating code for a program we never meant to write, one\nthat looks like this:\nfor (int i = 0; i < 10; ++i)\nif (a == static_cast< Array<int> >(b[i])) ...\nEach iteration through the loop thus compares the contents of a with\nthe contents of a temporary array of size b[i] (whose contents are pre-\nsumably undefined). Not only is this unlikely to behave in a satisfac-\ntory manner, it is also tremendously inefficient, because each time\nthrough the loop we both create and destroy a temporary Array<int>\nobject (see Item 19).\nThe drawbacks to implicit type conversion operators can be avoided by\nsimply failing to declare the operators, but single-argument construc-\ntors cannot be so easily waved away. After all, you may really want to\noffer single-argument constructors to your clients. At the same time,\nyou may wish to prevent compilers from calling such constructors in-\ndiscriminately. Fortunately, there is a way to have it all. In fact, there\nare two ways: the easy way and the way you’ll have to use if your com-\npilers don’t yet support the easy way.\nThe easy way is to avail yourself of one of the newest C++ features, the\nexplicit keyword. This feature was introduced specifically to address\nthe problem of implicit type conversion, and its use is about as\nstraightforward as can be. Constructors can be declared explicit,\nand if they are, compilers are prohibited from invoking them for pur-\n\n\nConversion Functions\n29\nposes of implicit type conversion. Explicit conversions are still legal,\nhowever:\ntemplate<class T>\nclass Array {\npublic:\n...\nexplicit Array(int size);\n// note use of \"explicit\"\n...\n};\nArray<int> a(10);\n// okay, explicit ctors can\n// be used as usual for \n// object construction\nArray<int> b(10);\n// also okay\nif (a == b[i]) ...\n// error! no way to\n// implicitly convert\n// int to Array<int>\nif (a == Array<int>(b[i])) ... // okay, the conversion\n// from int to Array<int> is\n// explicit (but the logic of\n// the code is suspect)\nif (a == static_cast< Array<int> >(b[i])) ...\n// equally okay, equally\n// suspect\nif (a == (Array<int>)b[i]) ... // C-style casts are also\n// okay, but the logic of\n// the code is still suspect\nIn the example using static_cast (see Item 2), the space separating\nthe two “>” characters is no accident. If the statement were written like\nthis,\nif (a == static_cast<Array<int>>(b[i])) ...\nit would have a different meaning. That’s because C++ compilers parse\n“>>” as a single token. Without a space between the “>” characters, the\nstatement would generate a syntax error.\nIf your compilers don’t yet support explicit, you’ll have to fall back\non home-grown methods for preventing the use of single-argument\nconstructors as implicit type conversion functions. Such methods are\nobvious only after you’ve seen them.\nI mentioned earlier that there are complicated rules governing which\nsequences of implicit type conversions are legitimate and which are\nnot. One of those rules is that no sequence of conversions is allowed to\ncontain more than one user-defined conversion (i.e., a call to a single-\nargument constructor or an implicit type conversion operator). By con-\n\n\n30\nItem 5\nstructing your classes properly, you can take advantage of this rule so\nthat the object constructions you want to allow are legal, but the im-\nplicit conversions you don’t want to allow are illegal.\nConsider the Array template again. You need a way to allow an integer\nspecifying the size of the array to be used as a constructor argument,\nbut you must at the same time prevent the implicit conversion of an in-\nteger into a temporary Array object. You accomplish this by first cre-\nating a new class, ArraySize. Objects of this type have only one\npurpose: they represent the size of an array that’s about to be created.\nYou then modify Array’s single-argument constructor to take an Ar-\nraySize object instead of an int. The code looks like this:\ntemplate<class T>\nclass Array {\npublic:\nclass ArraySize {\n// this class is new\npublic:\nArraySize(int numElements): theSize(numElements) {}\nint size() const { return theSize; }\nprivate:\nint theSize;\n};\nArray(int lowBound, int highBound);\nArray(ArraySize size);\n// note new declaration\n...\n};\nHere you’ve nested ArraySize inside Array to emphasize the fact that\nit’s always used in conjunction with that class. You’ve also made Ar-\nraySize public in Array so that anybody can use it. Good.\nConsider what happens when an Array object is defined via the class’s\nsingle-argument constructor:\nArray<int> a(10);\nYour compilers are asked to call a constructor in the Array<int> class\nthat takes an int, but there is no such constructor. Compilers realize\nthey can convert the int argument into a temporary ArraySize ob-\nject, and that ArraySize object is just what the Array<int> construc-\ntor needs, so compilers perform the conversion with their usual gusto.\nThis allows the function call (and the attendant object construction) to\nsucceed. \nThe fact that you can still construct Array objects with an int argu-\nment is reassuring, but it does you little good unless the type conver-\n\n\nIncrement and Decrement Operators\n31\nsions you want to avoid are prevented. They are. Consider this code\nagain:\nbool operator==( const Array<int>& lhs, \nconst Array<int>& rhs);\nArray<int> a(10);\nArray<int> b(10);\n...\nfor (int i = 0; i < 10; ++i)\nif (a == b[i]) ...\n// oops! \"a\" should be \"a[i]\";\n// this is now an error\nCompilers need an object of type Array<int> on the right-hand side of\nthe “==” in order to call operator== for Array<int> objects, but there\nis no single-argument constructor taking an int argument. Further-\nmore, compilers cannot consider converting the int into a temporary\nArraySize object and then creating the necessary Array<int> object\nfrom this temporary, because that would call for two user-defined con-\nversions, one from int to ArraySize and one from ArraySize to Ar-\nray<int>. Such a conversion sequence is verboten, so compilers must\nissue an error for the code attempting to perform the comparison.\nThe use of the ArraySize class in this example might look like a spe-\ncial-purpose hack, but it’s actually a specific instance of a more gen-\neral technique. Classes like ArraySize are often called proxy classes,\nbecause each object of such a class stands for (is a proxy for) some\nother object. An ArraySize object is really just a stand-in for the inte-\nger used to specify the size of the Array being created. Proxy objects\ncan give you control over aspects of your software’s behavior — in this\ncase implicit type conversions — that is otherwise beyond your grasp,\nso it’s well worth your while to learn how to use them. How, you might\nwonder, can you acquire such learning? One way is to turn to Item 30;\nit’s devoted to proxy classes.\nBefore you turn to proxy classes, however, reflect a bit on the lessons\nof this Item. Granting compilers license to perform implicit type con-\nversions usually leads to more harm than good, so don’t provide con-\nversion functions unless you’re sure you want them.\nItem 6:\nDistinguish between prefix and postfix forms \nof increment and decrement operators.\nIncrement and Decrement Operators\nLong, long ago (the late ’80s) in a language far, far away (C++ at that\ntime), there was no way to distinguish between prefix and postfix invo-\ncations of the ++ and -- operators. Programmers being programmers,\n\n\n32\nItem 6\nthey kvetched about this omission, and C++ was extended to allow\noverloading both forms of increment and decrement operators. \nThere was a syntactic problem, however, and that was that overloaded\nfunctions are differentiated on the basis of the parameter types they\ntake, but neither prefix nor postfix increment or decrement takes an\nargument. To surmount this linguistic pothole, it was decreed that\npostfix forms take an int argument, and compilers silently pass 0 as\nthat int when those functions are called:\nclass UPInt {\n// \"unlimited precision int\"\npublic:\nUPInt& operator++();\n// prefix ++\nconst UPInt operator++(int);\n// postfix ++\nUPInt& operator--();\n// prefix --\nconst UPInt operator--(int); // postfix --\nUPInt& operator+=(int);\n// a += operator for UPInts\n// and ints\n...\n};\nUPInt i;\n++i;\n// calls i.operator++();\ni++;\n// calls i.operator++(0);\n--i;\n// calls i.operator--();\ni--;\n// calls i.operator--(0);\nThis convention is a little on the odd side, but you’ll get used to it. More\nimportant to get used to, however, is this: the prefix and postfix forms\nof these operators return different types. In particular, prefix forms re-\nturn a reference, postfix forms return a const object. We’ll focus here\non the prefix and postfix ++ operators, but the story for the -- operators\nis analogous. \nFrom your days as a C programmer, you may recall that the prefix\nform of the increment operator is sometimes called “increment and\nfetch,” while the postfix form is often known as “fetch and increment.”\nThese two phrases are important to remember, because they all but act\nas formal specifications for how prefix and postfix increment should be\nimplemented:\n// prefix form: increment and fetch\nUPInt& UPInt::operator++()\n{\n*this += 1;\n// increment\nreturn *this;\n// fetch\n}\n\n\nIncrement and Decrement Operators\n33\n// postfix form: fetch and increment\nconst UPInt UPInt::operator++(int)\n{\nconst UPInt oldValue = *this;\n// fetch\n++(*this);\n// increment\nreturn oldValue;\n// return what was\n}\n// fetched\nNote how the postfix operator makes no use of its parameter. This is\ntypical. The only purpose of the parameter is to distinguish prefix from\npostfix function invocation. Many compilers issue warnings if you fail\nto use named parameters in the body of the function to which they ap-\nply, and this can be annoying. To avoid such warnings, a common\nstrategy is to omit names for parameters you don’t plan to use; that’s\nwhat’s been done above.\nIt’s clear why postfix increment must return an object (it’s returning\nan old value), but why a const object? Imagine that it did not. Then\nthe following would be legal:\nUPInt i;\ni++++;\n// apply postfix increment\n// twice\nThis is the same as\ni.operator++(0).operator++(0);\nand it should be clear that the second invocation of operator++ is\nbeing applied to the object returned from the first invocation.\nThere are two reasons to abhor this. First, it’s inconsistent with the be-\nhavior of the built-in types. A good rule to follow when designing\nclasses is when in doubt, do as the ints do, and the ints most cer-\ntainly do not allow double application of postfix increment:\nint i;\ni++++;\n// error!\nThe second reason is that double application of postfix increment al-\nmost never does what clients expect it to. As noted above, the second\napplication of operator++ in a double increment changes the value of\nthe object returned from the first invocation, not the value of the orig-\ninal object. Hence, if \ni++++;\nwere legal, i would be incremented only once. This is counterintuitive\nand confusing (for both ints and UPInts), so it’s best prohibited. \n\n\n34\nItem 6\nC++ prohibits it for ints, but you must prohibit it yourself for classes\nyou write. The easiest way to do this is to make the return type of post-\nfix increment a const object. Then when compilers see\ni++++;\n// same as i.operator++(0).operator++(0);\nthey recognize that the const object returned from the first call to op-\nerator++ is being used to call operator++ again. operator++, how-\never, is a non-const member function, so const objects — such as\nthose returned from postfix operator++ — can’t call it.† If you’ve ever\nwondered if it makes sense to have functions return const objects,\nnow you know: sometimes it does, and postfix increment and decre-\nment are examples.\nIf you’re the kind who worries about efficiency, you probably broke into\na sweat when you first saw the postfix increment function. That func-\ntion has to create a temporary object for its return value (see Item 19),\nand the implementation above also creates an explicit temporary ob-\nject (oldValue) that has to be constructed and destructed. The prefix\nincrement function has no such temporaries. This leads to the possibly\nstartling conclusion that, for efficiency reasons alone, clients of UPInt\nshould prefer prefix increment to postfix increment unless they really\nneed the behavior of postfix increment. Let us be explicit about this.\nWhen dealing with user-defined types, prefix increment should be\nused whenever possible, because it’s inherently more efficient.\nLet us make one more observation about the prefix and postfix incre-\nment operators. Except for their return values, they do the same thing:\nthey increment a value. That is, they’re supposed to do the same thing.\nHow can you be sure the behavior of postfix increment is consistent\nwith that of prefix increment? What guarantee do you have that their\nimplementations won’t diverge over time, possibly as a result of differ-\nent programmers maintaining and enhancing them? Unless you’ve fol-\nlowed the design principle embodied by the code above, you have no\nsuch guarantee. That principle is that postfix increment and decre-\nment should be implemented in terms of their prefix counterparts. You\nthen need only maintain the prefix versions, because the postfix ver-\nsions will automatically behave in a consistent fashion.\nAs you can see, mastering prefix and postfix increment and decrement\nis easy. Once you know their proper return types and that the postfix\noperators should be implemented in terms of the prefix operators,\nthere’s very little more to learn.\n† Alas, it is not uncommon for compilers to fail to enforce this restriction. Before you\nwrite programs that rely on it, test your compilers to make sure they behave correctly.\n",
      "page_number": 41,
      "chapter_number": 6,
      "summary": "With the information in this chapter under your belt,\nyou’ll be overloading (or not overloading) operators like a pro Key topics include functions, operators, and array.",
      "keywords": [
        "array",
        "int",
        "type conversion operators",
        "implicit type conversion",
        "type conversion",
        "operator",
        "conversion",
        "Rational",
        "Increment",
        "type",
        "implicit type",
        "conversion operators",
        "postfix increment",
        "postfix",
        "conversion functions"
      ],
      "concepts": [
        "functions",
        "operators",
        "array",
        "conversions",
        "classes",
        "increment",
        "objects",
        "rational",
        "types",
        "typed"
      ],
      "similar_chapters": [
        {
          "book": "Fluent Python 2nd",
          "chapter": 30,
          "title": "Segment 30 (pages 596-614)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 31,
          "title": "Segment 31 (pages 615-636)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 79,
          "title": "Segment 79 (pages 2535-2565)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 76,
          "title": "Segment 76 (pages 2442-2473)",
          "relevance_score": 0.52,
          "method": "api"
        }
      ]
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 52-60)",
      "start_page": 52,
      "end_page": 60,
      "detection_method": "topic_boundary",
      "content": "Overloading &&, ||, and ,\n35\nItem 7:\nNever overload &&, ||, or ,.\nOverloading &&, ||, and ,\nLike C, C++ employs short-circuit evaluation of boolean expressions.\nThis means that once the truth or falsehood of an expression has been\ndetermined, evaluation of the expression ceases, even if some parts of\nthe expression haven’t yet been examined. For example, in this case,\nchar *p;\n... \nif ((p != 0) && (strlen(p) > 10)) ...\nthere is no need to worry about invoking strlen on p if it’s a null\npointer, because if the test of p against 0 fails, strlen will never be\ncalled. Similarly, given\nint rangeCheck(int index)\n{\nif ((index < lowerBound) || (index > upperBound)) ... \n...\n}\nindex will never be compared to upperBound if it’s less than lower-\nBound.\nThis is the behavior that has been drummed into C and C++ program-\nmers since time immemorial, so this is what they expect. Furthermore,\nthey write programs whose correct behavior depends on short-circuit\nevaluation. In the first code fragment above, for example, it is impor-\ntant that strlen not be invoked if p is a null pointer, because the stan-\ndard for C++ states (as does the standard for C) that the result of\ninvoking strlen on a null pointer is undefined.\nC++ allows you to customize the behavior of the && and || operators\nfor user-defined types. You do it by overloading the functions opera-\ntor&& and operator||, and you can do this at the global scope or on\na per-class basis. If you decide to take advantage of this opportunity,\nhowever, you must be aware that you are changing the rules of the\ngame quite radically, because you are replacing short-circuit seman-\ntics with function call semantics. That is, if you overload operator&&,\nwhat looks to you like this,\nif (expression1 && expression2) ...\nlooks to compilers like one of these:\nif (expression1.operator&&(expression2)) ...\n// when operator&& is a\n// member function\n\n\n36\nItem 7\nif (operator&&(expression1, expression2)) ...\n// when operator&& is a\n// global function\nThis may not seem like that big a deal, but function call semantics dif-\nfer from short-circuit semantics in two crucial ways. First, when a\nfunction call is made, all parameters must be evaluated, so when call-\ning the functions operator&& and operator||, both parameters are\nevaluated. There is, in other words, no short circuit. Second, the lan-\nguage specification leaves undefined the order of evaluation of param-\neters to a function call, so there is no way of knowing whether\nexpression1 or expression2 will be evaluated first. This stands in\nstark contrast to short-circuit evaluation, which always evaluates its\narguments in left-to-right order.\nAs a result, if you overload && or ||, there is no way to offer program-\nmers the behavior they both expect and have come to depend on. So\ndon’t overload && or ||.\nThe situation with the comma operator is similar, but before we delve\ninto that, I’ll pause and let you catch the breath you lost when you\ngasped, “The comma operator? There’s a comma operator?” There is in-\ndeed. \nThe comma operator is used to form expressions, and you’re most\nlikely to run across it in the update part of a for loop. The following\nfunction, for example, is based on one in the second edition of Ker-\nnighan’s and Ritchie’s classic The C Programming Language (Prentice-\nHall, 1988):\n// reverse string s in place\nvoid reverse(char s[])\n{\nfor (int i = 0, j = strlen(s)-1;\ni < j;\n++i, --j)\n// aha! the comma operator!\n{\nint c = s[i];\ns[i] = s[j];\ns[j] = c;\n}\n}\nHere, i is incremented and j is decremented in the final part of the for\nloop. It is convenient to use the comma operator here, because only an\nexpression is valid in the final part of a for loop; separate statements\nto change the values of i and j would be illegal.\n\n\nOverloading &&, ||, and ,\n37\nJust as there are rules in C++ defining how && and || behave for built-\nin types, there are rules defining how the comma operator behaves for\nsuch types. An expression containing a comma is evaluated by first\nevaluating the part of the expression to the left of the comma, then\nevaluating the expression to the right of the comma; the result of the\noverall comma expression is the value of the expression on the right.\nSo in the final part of the loop above, compilers first evaluate ++i, then\n--j, and the result of the comma expression is the value returned\nfrom --j.\nPerhaps you’re wondering why you need to know this. You need to\nknow because you need to mimic this behavior if you’re going to take\nit upon yourself to write your own comma operator. Unfortunately, you\ncan’t perform the requisite mimicry.\nIf you write operator, as a non-member function, you’ll never be able\nto guarantee that the left-hand expression is evaluated before the\nright-hand expression, because both expressions will be passed as ar-\nguments in a function call (to operator,). But you have no control\nover the order in which a function’s arguments are evaluated. So the\nnon-member approach is definitely out.\nThat leaves only the possibility of writing operator, as a member\nfunction. Even here you can’t rely on the left-hand operand to the\ncomma operator being evaluated first, because compilers are not con-\nstrained to do things that way. Hence, you can’t overload the comma\noperator and also guarantee it will behave the way it’s supposed to. It\ntherefore seems imprudent to overload it at all.\nYou may be wondering if there’s an end to this overloading madness.\nAfter all, if you can overload the comma operator, what can’t you over-\nload? As it turns out, there are limits. You can’t overload the following\noperators:\n.\n.*\n::\n?:\nnew\ndelete\nsizeof\ntypeid\nstatic_cast\ndynamic_cast const_cast\nreinterpret_cast\nYou can overload these:\noperator new\noperator delete\noperator new[]\noperator delete[]\n+   \n- \n* \n/\n%\n^\n&\n|\n~\n!\n=\n<\n>\n+=\n-=\n*=\n/=\n%=\n^=\n&=\n|=\n<<\n>>\n>>=\n<<=\n==\n!=\n<=\n>=\n&&\n||\n++\n--\n,\n->*\n->\n()\n[]\n\n\n38\nItem 8\n(For information on the new and delete operators, as well as opera-\ntor new, operator delete, operator new[], and operator de-\nlete[], see Item 8.)\nOf course, just because you can overload these operators is no reason\nto run off and do it. The purpose of operator overloading is to make\nprograms easier to read, write, and understand, not to dazzle others\nwith your knowledge that comma is an operator. If you don’t have a\ngood reason for overloading an operator, don’t overload it. In the case\nof &&, ||, and ,, it’s difficult to have a good reason, because no matter\nhow hard you try, you can’t make them behave the way they’re sup-\nposed to.\nItem 8:\nUnderstand the different meanings of new\nand delete.\nThe Different Meanings of new and delete\nIt occasionally seems as if people went out of their way to make C++\nterminology difficult to understand. Case in point: the difference be-\ntween the new operator and operator new.\nWhen you write code like this,\nstring *ps = new string(\"Memory Management\");\nthe new you are using is the new operator. This operator is built into\nthe language and, like sizeof, you can’t change its meaning: it always\ndoes the same thing. What it does is twofold. First, it allocates enough\nmemory to hold an object of the type requested. In the example above,\nit allocates enough memory to hold a string object. Second, it calls a\nconstructor to initialize an object in the memory that was allocated.\nThe new operator always does those two things; you can’t change its\nbehavior in any way.\nWhat you can change is how the memory for an object is allocated. The\nnew operator calls a function to perform the requisite memory alloca-\ntion, and you can rewrite or overload that function to change its behav-\nior. The name of the function the new operator calls to allocate memory\nis operator new. Honest.\nThe operator new function is usually declared like this:\nvoid * operator new(size_t size);\nThe return type is void*, because this function returns a pointer to\nraw, uninitialized memory. (If you like, you can write a version of op-\nerator new that initializes the memory to some value before returning\na pointer to it, but this is not commonly done.) The size_t parameter\nspecifies how much memory to allocate. You can overload operator\n\n\nThe Different Meanings of new and delete\n39\nnew by adding additional parameters, but the first parameter must al-\nways be of type size_t.\nYou’ll probably never want to call operator new directly, but on the off\nchance you do, you’ll call it just like any other function:\nvoid *rawMemory = operator new(sizeof(string));\nHere operator new will return a pointer to a chunk of memory large\nenough to hold a string object.\nLike malloc, operator new’s only responsibility is to allocate memory.\nIt knows nothing about constructors. All operator new understands is\nmemory allocation. It is the job of the new operator to take the raw\nmemory that operator new returns and transform it into an object.\nWhen your compilers see a statement like\nstring *ps = new string(\"Memory Management\");\nthey must generate code that more or less corresponds to this:\nvoid *memory =\n// get raw memory\noperator new(sizeof(string));\n// for a string\n// object\ncall string::string(\"Memory Management\")\n// initialize the\non *memory;\n// object in the\n// memory\nstring *ps = \n// make ps point to\nstatic_cast<string*>(memory);\n// the new object\nNotice that the second step above involves calling a constructor, some-\nthing you, a mere programmer, are prohibited from doing. Your com-\npilers are unconstrained by mortal limits, however, and they can do\nwhatever they like. That’s why you must use the new operator if you\nwant to conjure up a heap-based object: you can’t directly call the con-\nstructor necessary to initialize the object (including such crucial com-\nponents as its vtbl — see Item 24).\nPlacement new\nThere are times when you really want to call a constructor directly. In-\nvoking a constructor on an existing object makes no sense, because\nconstructors initialize objects, and an object can only be initialized —\ngiven its first value — once. But occasionally you have some raw mem-\nory that’s already been allocated, and you need to construct an object\nin the memory you have. A special version of operator new called\nplacement new allows you to do it.\nAs an example of how placement new might be used, consider this:\n\n\n40\nItem 8\nclass Widget {\npublic:\nWidget(int widgetSize);\n...\n};\nWidget * constructWidgetInBuffer(void *buffer,\nint widgetSize)\n{\nreturn new (buffer) Widget(widgetSize);\n}\nThis function returns a pointer to a Widget object that’s constructed\nwithin the buffer passed to the function. Such a function might be use-\nful for applications using shared memory or memory-mapped I/O, be-\ncause objects in such applications must be placed at specific\naddresses or in memory allocated by special routines. (For a different\nexample of how placement new can be used, see Item 4.)\nInside constructWidgetInBuffer, the expression being returned is\nnew (buffer) Widget(widgetSize)\nThis looks a little strange at first, but it’s just a use of the new operator\nin which an additional argument (buffer) is being specified for the im-\nplicit call that the new operator makes to operator new. The operator\nnew thus called must, in addition to the mandatory size_t argument,\naccept a void* parameter that points to the memory the object being\nconstructed is to occupy. That operator new is placement new, and it\nlooks like this:\nvoid * operator new(size_t, void *location)\n{\nreturn location;\n}\nThis is probably simpler than you expected, but this is all placement\nnew needs to do. After all, the purpose of operator new is to find mem-\nory for an object and return a pointer to that memory. In the case of\nplacement new, the caller already knows what the pointer to the mem-\nory should be, because the caller knows where the object is supposed\nto be placed. All placement new has to do, then, is return the pointer\nthat’s passed into it. (The unused (but mandatory) size_t parameter\nhas no name to keep compilers from complaining about its not being\nused; see Item 6.) Placement new is part of the standard C++ library.\nTo use placement new, all you have to do is #include <new> (or, if your\ncompilers don’t yet support the new-style header names, <new.h>).\nIf we step back from placement new for a moment, we’ll see that the re-\nlationship between the new operator and operator new, though per-\nhaps terminologically confusing, is conceptually straightforward. If\n\n\nThe Different Meanings of new and delete\n41\nyou want to create an object on the heap, use the new operator. It both\nallocates memory and calls a constructor for the object. If you only\nwant to allocate memory, call operator new; no constructor will be\ncalled. If you want to customize the memory allocation that takes place\nwhen heap objects are created, write your own version of operator\nnew and use the new operator; it will automatically invoke your custom\nversion of operator new. If you want to construct an object in memory\nyou’ve already got a pointer to, use placement new.\nDeletion and Memory Deallocation\nTo avoid resource leaks, every dynamic allocation must be matched by\nan equal and opposite deallocation. The function operator delete is\nto the built-in delete operator as operator new is to the new operator.\nWhen you say something like this,\nstring *ps;\n...\ndelete ps;\n// use the delete operator\nyour compilers must generate code both to destruct the object ps\npoints to and to deallocate the memory occupied by that object.\nThe memory deallocation is performed by the operator delete func-\ntion, which is usually declared like this:\nvoid operator delete(void *memoryToBeDeallocated);\nHence,\ndelete ps;\ncauses compilers to generate code that approximately corresponds to\nthis:\nps->~string();\n// call the object’s dtor\noperator delete(ps);\n// deallocate the memory\n// the object occupied\nOne implication of this is that if you want to deal only with raw, unini-\ntialized memory, you should bypass the new and delete operators en-\ntirely. Instead, you should call operator new to get the memory and\noperator delete to return it to the system:\nvoid *buffer = \n// allocate enough\noperator new(50*sizeof(char));\n// memory to hold 50\n// chars; call no ctors\n...\noperator delete(buffer);\n// deallocate the memory;\n// call no dtors\n\n\n42\nItem 8\nThis is the C++ equivalent of calling malloc and free.\nIf you use placement new to create an object in some memory, you\nshould avoid using the delete operator on that memory. That’s be-\ncause the delete operator calls operator delete to deallocate the\nmemory, but the memory containing the object wasn’t allocated by op-\nerator new in the first place; placement new just returned the pointer\nthat was passed to it. Who knows where that pointer came from? In-\nstead, you should undo the effect of the constructor by explicitly call-\ning the object’s destructor:\n// functions for allocating and deallocating memory in\n// shared memory\nvoid * mallocShared(size_t size);\nvoid freeShared(void *memory);\nvoid *sharedMemory = mallocShared(sizeof(Widget));\nWidget *pw =\n// as above,\nconstructWidgetInBuffer( sharedMemory, 10);\n// placement\n// new is used\n...\ndelete pw;\n// undefined! sharedMemory came from\n// mallocShared, not operator new\npw->~Widget();\n// fine, destructs the Widget pointed to\n// by pw, but doesn’t deallocate the \n// memory containing the Widget\nfreeShared(pw);\n// fine, deallocates the memory pointed\n// to by pw, but calls no destructor\nAs this example demonstrates, if the raw memory passed to placement\nnew was itself dynamically allocated (through some unconventional\nmeans), you must still deallocate that memory if you wish to avoid a\nmemory leak.\nArrays\nSo far so good, but there’s farther to go. Everything we’ve examined so\nfar concerns itself with only one object at a time. What about array al-\nlocation? What happens here?\nstring *ps = new string[10];\n// allocate an array of\n// objects\nThe new being used is still the new operator, but because an array is\nbeing created, the new operator behaves slightly differently from the\ncase of single-object creation. For one thing, memory is no longer allo-\ncated by operator new. Instead, it’s allocated by the array-allocation\nequivalent, a function called operator new[] (often referred to as “ar-\n\n\nThe Different Meanings of new and delete\n43\nray new.”) Like operator new, operator new[] can be overloaded.\nThis allows you to seize control of memory allocation for arrays in the\nsame way you can control memory allocation for single objects.\n(operator new[] is a relatively recent addition to C++, so your compil-\ners may not support it yet. If they don’t, the global version of operator\nnew will be used to allocate memory for every array, regardless of the\ntype of objects in the array. Customizing array-memory allocation\nunder such compilers is daunting, because it requires that you rewrite\nthe global operator new. This is not a task to be undertaken lightly.\nBy default, the global operator new handles all dynamic memory allo-\ncation in a program, so any change in its behavior has a dramatic and\npervasive effect. Furthermore, there is only one global operator new\nwith the “normal” signature (i.e., taking the single size_t parameter),\nso if you decide to claim it as your own, you instantly render your soft-\nware incompatible with any library that makes the same decision. (See\nalso Item 27.) As a result of these considerations, custom memory\nmanagement for arrays is not usually a reasonable design decision for\ncompilers lacking support for operator new[].)\nThe second way in which the new operator behaves differently for ar-\nrays than for objects is in the number of constructor calls it makes. For\narrays, a constructor must be called for each object in the array:\nstring *ps =\n// call operator new[] to allocate\nnew string[10];\n// memory for 10 string objects,\n// then call the default string\n// ctor for each array element\nSimilarly, when the delete operator is used on an array, it calls a de-\nstructor for each array element and then calls operator delete[] to\ndeallocate the memory:\ndelete [] ps;\n// call the string dtor for each\n// array element, then call \n// operator delete[] to \n// deallocate the array’s memory\nJust as you can replace or overload operator delete, you can replace\nor overload operator delete[]. There are some restrictions on how\nthey can be overloaded, however; consult a good C++ text for details.\n(For ideas on good C++ texts, see the recommendations beginning on\npage 285.)\nSo there you have it. The new and delete operators are built-in and\nbeyond your control, but the memory allocation and deallocation func-\ntions they call are not. When you think about customizing the behavior\nof the new and delete operators, remember that you can’t really do it.\nYou can modify how they do what they do, but what they do is fixed by\nthe language.\n",
      "page_number": 52,
      "chapter_number": 7,
      "summary": "This chapter covers segment 7 (pages 52-60). Key topics include memory, operators, and object. Covers function. This is the behavior that has been drummed into C and C++ program-\nmers since time immemorial, so this is what they expect.",
      "keywords": [
        "operator",
        "Memory",
        "operator delete",
        "comma operator",
        "delete",
        "object",
        "call",
        "calls operator delete",
        "function",
        "string",
        "call operator",
        "overload operator delete",
        "n’t",
        "comma",
        "overload operator"
      ],
      "concepts": [
        "memory",
        "operators",
        "object",
        "void",
        "likely",
        "string",
        "functions",
        "function",
        "expressions",
        "expression"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 21,
          "title": "Segment 21 (pages 223-230)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 30,
          "title": "Segment 30 (pages 317-324)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 13,
          "title": "Segment 13 (pages 134-141)",
          "relevance_score": 0.62,
          "method": "api"
        }
      ]
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 61-75)",
      "start_page": 61,
      "end_page": 75,
      "detection_method": "topic_boundary",
      "content": "Exceptions\nExceptions\nThe addition of exceptions to C++ changes things. Profoundly. Radi-\ncally. Possibly uncomfortably. The use of raw, unadorned pointers, for\nexample, becomes risky. Opportunities for resource leaks increase in\nnumber. It becomes more difficult to write constructors and destruc-\ntors that behave the way we want them to. Special care must be taken\nto prevent program execution from abruptly halting. Executables and\nlibraries typically increase in size and decrease in speed.\nAnd these are just the things we know. There is much the C++ commu-\nnity does not know about writing programs using exceptions, includ-\ning, for the most part, how to do it correctly. There is as yet no\nagreement on a body of techniques that, when applied routinely, leads\nto software that behaves predictably and reliably when exceptions are\nthrown. (For insight into some of the issues involved, see the article by\nTom Cargill I refer to on page 287.)\nWe do know this much: programs that behave well in the presence of\nexceptions do so because they were designed to, not because they hap-\npen to. Exception-safe programs are not created by accident. The\nchances of a program behaving well in the presence of exceptions when\nit was not designed for exceptions are about the same as the chances\nof a program behaving well in the presence of multiple threads of con-\ntrol when it was not designed for multi-threaded execution: about zero.\nThat being the case, why use exceptions? Error codes have sufficed for\nC programmers ever since C was invented, so why mess with excep-\ntions, especially if they’re as problematic as I say? The answer is sim-\nple: exceptions cannot be ignored. If a function signals an exceptional\ncondition by setting a status variable or returning an error code, there\nis no way to guarantee the function’s caller will check the variable or\nexamine the code. As a result, execution may continue long past the\npoint where the condition was encountered. If the function signals the\n\n\nUsing Destructors to Prevent Resource Leaks\n45\ncondition by throwing an exception, however, and that exception is not\ncaught, program execution immediately ceases. \nThis is behavior that C programmers can approach only by using set-\njmp and longjmp. But longjmp exhibits a serious deficiency when\nused with C++: it fails to call destructors for local objects when it ad-\njusts the stack. Most C++ programs depend on such destructors being\ncalled, so setjmp and longjmp make a poor substitute for true excep-\ntions. If you need a way of signaling exceptional conditions that cannot\nbe ignored, and if you must ensure that local destructors are called\nwhen searching the stack for code that can handle exceptional condi-\ntions, you need C++ exceptions. It’s as simple as that.\nBecause we have much to learn about programming with exceptions,\nthe Items that follow comprise an incomplete guide to writing excep-\ntion-safe software. Nevertheless, they introduce important consider-\nations for anyone using exceptions in C++. By heeding the guidance in\nthe material below, you’ll improve the correctness, robustness, and ef-\nficiency of the software you write, and you’ll sidestep many problems\nthat commonly arise when working with exceptions.\nItem 9:\nUse destructors to prevent resource leaks.\nUsing Destructors to Prevent Resource Leaks\nSay good-bye to pointers. Admit it: you never really liked them that\nmuch anyway. \nOkay, you don’t have to say good-bye to all pointers, but you do need\nto say sayonara to pointers that are used to manipulate local re-\nsources. Suppose, for example, you’re writing software at the Shelter\nfor Adorable Little Animals, an organization that finds homes for pup-\npies and kittens. Each day the shelter creates a file containing infor-\nmation on the adoptions it arranged that day, and your job is to write\na program to read these files and do the appropriate processing for\neach adoption.\nA reasonable approach to this task is to define an abstract base class,\nALA (“Adorable Little Animal”), plus concrete derived classes for pup-\npies and kittens. A virtual function, processAdoption, handles the\nnecessary species-specific processing:\nALA\nKitten\nPuppy\n\n\n46\nItem 9\nclass ALA {\npublic:\nvirtual void processAdoption() = 0;\n...\n};\nclass Puppy: public ALA {\npublic:\nvirtual void processAdoption();\n...\n};\nclass Kitten: public ALA {\npublic:\nvirtual void processAdoption();\n...\n};\nYou’ll need a function that can read information from a file and pro-\nduce either a Puppy object or a Kitten object, depending on the infor-\nmation in the file. This is a perfect job for a virtual constructor, a kind\nof function described in Item 25. For our purposes here, the function’s\ndeclaration is all we need:\n// read animal information from s, then return a pointer\n// to a newly allocated object of the appropriate type\nALA * readALA(istream& s);\nThe heart of your program is likely to be a function that looks some-\nthing like this:\nvoid processAdoptions(istream& dataSource)\n{\nwhile (dataSource) {\n// while there’s data\nALA *pa = readALA(dataSource);\n// get next animal\npa->processAdoption();\n// process adoption\ndelete pa;\n// delete object that\n}\n// readALA returned\n}\nThis function loops through the information in dataSource, process-\ning each entry as it goes. The only mildly tricky thing is the need to re-\nmember to delete pa at the end of each iteration. This is necessary\nbecause readALA creates a new heap object each time it’s called. With-\nout the call to delete, the loop would contain a resource leak.\nNow consider what would happen if pa->processAdoption threw an\nexception. processAdoptions fails to catch exceptions, so the excep-\ntion would propagate to processAdoptions’s caller. In doing so, all\nstatements in processAdoptions after the call to pa->processAdop-\ntion would be skipped, and that means pa would never be deleted. As\n\n\nUsing Destructors to Prevent Resource Leaks\n47\na result, anytime pa->processAdoption throws an exception, pro-\ncessAdoptions contains a resource leak.\nPlugging the leak is easy enough,\nvoid processAdoptions(istream& dataSource)\n{\nwhile (dataSource) {\nALA *pa = readALA(dataSource);\ntry {\npa->processAdoption();\n}\ncatch (...) {\n// catch all exceptions\ndelete pa;\n// avoid resource leak when an \n// exception is thrown\nthrow;\n// propagate exception to caller\n}\ndelete pa;\n// avoid resource leak when no\n}\n// exception is thrown\n}\nbut then you have to litter your code with try and catch blocks. More\nimportantly, you are forced to duplicate cleanup code that is common\nto both normal and exceptional paths of control. In this case, the call\nto delete must be duplicated. Like all replicated code, this is annoy-\ning to write and difficult to maintain, but it also feels wrong. Regard-\nless of whether we leave processAdoptions by a normal return or by\nthrowing an exception, we need to delete pa, so why should we have to\nsay that in more than one place?\nWe don’t have to if we can somehow move the cleanup code that must\nalways be executed into the destructor for an object local to process-\nAdoptions. That’s because local objects are always destroyed when\nleaving a function, regardless of how that function is exited. (The only\nexception to this rule is when you call longjmp, and this shortcoming\nof longjmp is the primary reason why C++ has support for exceptions\nin the first place.) Our real concern, then, is moving the delete from\nprocessAdoptions into a destructor for an object local to processA-\ndoptions.\nThe solution is to replace the pointer pa with an object that acts like a\npointer. That way, when the pointer-like object is (automatically) de-\nstroyed, we can have its destructor call delete. Objects that act like\npointers, but do more, are called smart pointers, and, as Item 28 ex-\nplains, you can make pointer-like objects very smart indeed. In this\ncase, we don’t need a particularly brainy pointer, we just need a\n\n\n48\nItem 9\npointer-like object that knows enough to delete what it points to when\nthe pointer-like object goes out of scope.\nIt’s not difficult to write a class for such objects, but we don’t need to.\nThe standard C++ library contains a class template called auto_ptr\nthat does just what we want. Each auto_ptr class takes a pointer to a\nheap object in its constructor and deletes that object in its destructor.\nBoiled down to these essential functions, auto_ptr looks like this:\ntemplate<class T>\nclass auto_ptr {\npublic:\nauto_ptr(T *p = 0): ptr(p) {}\n// save ptr to object\n~auto_ptr() { delete ptr; }\n// delete ptr to object\nprivate:\nT *ptr;\n// raw ptr to object\n};\nThe standard version of auto_ptr is much fancier, and this stripped-\ndown implementation isn’t suitable for real use† (we must add at least\nthe copy constructor, assignment operator, and pointer-emulating\nfunctions discussed in Item 28), but the concept behind it should be\nclear: use auto_ptr objects instead of raw pointers, and you won’t\nhave to worry about heap objects not being deleted, not even when ex-\nceptions are thrown. (Because the auto_ptr destructor uses the sin-\ngle-object form of delete, auto_ptr is not suitable for use with\npointers to arrays of objects. If you’d like an auto_ptr-like template\nfor arrays, you’ll have to write your own. In such cases, however, it’s\noften a better design decision to use a vector instead of an array, any-\nway.)\nUsing an auto_ptr object instead of a raw pointer, processAdop-\ntions looks like this:\nvoid processAdoptions(istream& dataSource)\n{\nwhile (dataSource) {\nauto_ptr<ALA> pa(readALA(dataSource));\npa->processAdoption();\n}\n}\nThis version of processAdoptions differs from the original in only\ntwo ways. First, pa is declared to be an auto_ptr<ALA> object, not a\nraw ALA* pointer. Second, there is no delete statement at the end of\nthe loop. That’s it. Everything else is identical, because, except for de-\nstruction, auto_ptr objects act just like normal pointers. Easy, huh?\n† A complete implementation of an almost-standard auto_ptr appears on pages 291-294.\n\n\nUsing Destructors to Prevent Resource Leaks\n49\nThe idea behind auto_ptr — using an object to store a resource that\nneeds to be automatically released and relying on that object’s de-\nstructor to release it — applies to more than just pointer-based re-\nsources. Consider a function in a GUI application that needs to create\na window to display some information:\n// this function may leak resources if an exception\n// is thrown\nvoid displayInfo(const Information& info)\n{\nWINDOW_HANDLE w(createWindow());\ndisplay info in window corresponding to w;\ndestroyWindow(w);\n}\nMany window systems have C-like interfaces that use functions like\ncreateWindow and destroyWindow to acquire and release window re-\nsources. If an exception is thrown during the process of displaying\ninfo in w, the window for which w is a handle will be lost just as surely\nas any other dynamically allocated resource. \nThe solution is the same as it was before. Create a class whose con-\nstructor and destructor acquire and release the resource:\n// class for acquiring and releasing a window handle\nclass WindowHandle {\npublic:\nWindowHandle(WINDOW_HANDLE handle): w(handle) {}\n~WindowHandle() { destroyWindow(w); }\noperator WINDOW_HANDLE() { return w; }\n// see below\nprivate:\nWINDOW_HANDLE w;\n// The following functions are declared private to prevent \n// multiple copies of a WINDOW_HANDLE from being created.\n// See Item 28 for a discussion of a more flexible approach.\nWindowHandle(const WindowHandle&);\nWindowHandle& operator=(const WindowHandle&);\n};\nThis looks just like the auto_ptr template, except that assignment\nand copying are explicitly prohibited, and there is an implicit conver-\nsion operator that can be used to turn a WindowHandle into a\nWINDOW_HANDLE. This capability is essential to the practical applica-\ntion of a WindowHandle object, because it means you can use a Win-\ndowHandle just about anywhere you would normally use a raw\nWINDOW_HANDLE. (See Item 5, however, for why you should generally be\nleery of implicit type conversion operators.)\n\n\n50\nItem 10\nGiven the WindowHandle class, we can rewrite displayInfo as fol-\nlows:\n// this function avoids leaking resources if an \n// exception is thrown\nvoid displayInfo(const Information& info)\n{\nWindowHandle w(createWindow());\ndisplay info in window corresponding to w;\n}\nEven if an exception is thrown within displayInfo, the window cre-\nated by createWindow will always† be destroyed.\nBy adhering to the rule that resources should be encapsulated inside\nobjects, you can usually avoid resource leaks in the presence of excep-\ntions. But what happens if an exception is thrown while you’re in the\nprocess of acquiring a resource, e.g., while you’re in the constructor of\na resource-acquiring class? What happens if an exception is thrown\nduring the automatic destruction of such resources? Don’t construc-\ntors and destructors call for special techniques? They do, and you can\nread about them in Items 10 and 11.\nItem 10: Prevent resource leaks in constructors.\nAvoiding Resource Leaks in Constructors\nImagine you’re developing software for a multimedia address book.\nSuch an address book might hold, in addition to the usual textual in-\nformation of a person’s name, address, and phone numbers, a picture\nof the person and the sound of their voice (possibly giving the proper\npronunciation of their name).\nTo implement the book, you might come up with a design like this:\nclass Image {\n// for image data\npublic:\nImage(const string& imageDataFileName);\n...\n};\nclass AudioClip {\n// for audio data\npublic:\nAudioClip(const string& audioDataFileName);\n...\n};\nclass PhoneNumber { ... };\n// for holding phone numbers\n† Well, almost always. If the exception is not caught, the program will terminate. In that\ncase, there is no guarantee that local objects (such as w in the example) will have their\ndestructors called. Some compilers call them, some do not. Both behaviors are valid.\n\n\nAvoiding Resource Leaks in Constructors\n51\nclass BookEntry {\n// for each entry in the\npublic:\n// address book\nBookEntry(const string& name,\nconst string& address = \"\",\nconst string& imageFileName = \"\",\nconst string& audioClipFileName = \"\");\n~BookEntry();\n// phone numbers are added via this function\nvoid addPhoneNumber(const PhoneNumber& number);\n...\nprivate:\nstring theName;\n// person’s name\nstring theAddress;\n// their address \nlist<PhoneNumber> thePhones; // their phone numbers\nImage *theImage;\n// their image\nAudioClip *theAudioClip;\n// an audio clip from them\n};\nEach BookEntry must have name data, so you require that as a con-\nstructor argument (see Item 4), but the other fields — the person’s ad-\ndress and the names of files containing image and audio data — are\noptional. Note the use of the list class to hold the person’s phone\nnumbers. This is one of several container classes that are part of the\nstandard C++ library (see Item 35).\nA straightforward way to write the BookEntry constructor and de-\nstructor is as follows:\nBookEntry::BookEntry(const string& name, \nconst string& address,\nconst string& imageFileName,\nconst string& audioClipFileName)\n: theName(name), theAddress(address), \ntheImage(0), theAudioClip(0)\n{\nif (imageFileName != \"\") {\ntheImage = new Image(imageFileName);\n}\nif (audioClipFileName != \"\") {\ntheAudioClip = new AudioClip(audioClipFileName);\n}\n}\nBookEntry::~BookEntry()\n{\ndelete theImage;\ndelete theAudioClip;\n}\n\n\n52\nItem 10\nThe constructor initializes the pointers theImage and theAudioClip\nto null, then makes them point to real objects if the corresponding ar-\nguments are non-empty strings. The destructor deletes both pointers,\nthus ensuring that a BookEntry object doesn’t give rise to a resource\nleak. Because C++ guarantees it’s safe to delete null pointers, BookEn-\ntry’s destructor need not check to see if the pointers actually point to\nsomething before deleting them.\nEverything looks fine here, and under normal conditions everything is\nfine, but under abnormal conditions — under exceptional conditions —\nthings are not fine at all. \nConsider what will happen if an exception is thrown during execution\nof this part of the BookEntry constructor:\nif (audioClipFileName != \"\") {\ntheAudioClip = new AudioClip(audioClipFileName);\n}\nAn exception might arise because operator new (see Item 8) is unable\nto allocate enough memory for an AudioClip object. One might also\narise because the AudioClip constructor itself throws an exception.\nRegardless of the cause of the exception, if one is thrown within the\nBookEntry constructor, it will be propagated to the site where the\nBookEntry object is being created.\nNow, if an exception is thrown during creation of the object theAudio-\nClip is supposed to point to (thus transferring control out of the\nBookEntry constructor), who deletes the object that theImage already\npoints to? The obvious answer is that BookEntry’s destructor does,\nbut the obvious answer is wrong. BookEntry’s destructor will never be\ncalled. Never.\nC++ destroys only fully constructed objects, and an object isn’t fully\nconstructed until its constructor has run to completion. So if a\nBookEntry object b is created as a local object,\nvoid testBookEntryClass()\n{\nBookEntry b(\"Addison-Wesley Publishing Company\",\n\"One Jacob Way, Reading, MA 01867\");\n...\n}\nand an exception is thrown during construction of b, b’s destructor will\nnot be called. Furthermore, if you try to take matters into your own\nhands by allocating b on the heap and then calling delete if an excep-\ntion is thrown,\n\n\nAvoiding Resource Leaks in Constructors\n53\nvoid testBookEntryClass()\n{\nBookEntry *pb = 0;\ntry {\npb = new BookEntry( \"Addison-Wesley Publishing Company\",\n\"One Jacob Way, Reading, MA 01867\");\n...\n}\ncatch (...) {\n// catch all exceptions\ndelete pb;\n// delete pb when an\n// exception is thrown\nthrow;\n// propagate exception to\n}\n// caller\ndelete pb;\n// delete pb normally\n}\nyou’ll find that the Image object allocated inside BookEntry’s con-\nstructor is still lost, because no assignment is made to pb unless the\nnew operation succeeds. If BookEntry’s constructor throws an excep-\ntion, pb will be the null pointer, so deleting it in the catch block does\nnothing except make you feel better about yourself. Using the smart\npointer class auto_ptr<BookEntry> (see Item 9) instead of a raw\nBookEntry* won’t do you any good either, because the assignment to\npb still won’t be made unless the new operation succeeds.\nThere is a reason why C++ refuses to call destructors for objects that\nhaven’t been fully constructed, and it’s not simply to make your life\nmore difficult. It’s because it would, in many cases, be a nonsensical\nthing — possibly a harmful thing — to do. If a destructor were invoked\non an object that wasn’t fully constructed, how would the destructor\nknow what to do? The only way it could know would be if bits had been\nadded to each object indicating how much of the constructor had been\nexecuted. Then the destructor could check the bits and (maybe) figure\nout what actions to take. Such bookkeeping would slow down con-\nstructors, and it would make each object larger, too. C++ avoids this\noverhead, but the price you pay is that partially constructed objects\naren’t automatically destroyed.\nBecause C++ won’t clean up after objects that throw exceptions during\nconstruction, you must design your constructors so that they clean up\nafter themselves. Often, this involves simply catching all possible ex-\nceptions, executing some cleanup code, then rethrowing the exception\nso it continues to propagate. This strategy can be incorporated into the\nBookEntry constructor like this:\n\n\n54\nItem 10\nBookEntry::BookEntry( const string& name, \nconst string& address,\nconst string& imageFileName,\nconst string& audioClipFileName)\n: theName(name), theAddress(address), \ntheImage(0), theAudioClip(0)\n{\ntry {\n// this try block is new\nif (imageFileName != \"\") {\ntheImage = new Image(imageFileName);\n}\nif (audioClipFileName != \"\") {\ntheAudioClip = new AudioClip(audioClipFileName);\n}\n}\ncatch (...) {\n// catch any exception\ndelete theImage;\n// perform necessary\ndelete theAudioClip;\n// cleanup actions\nthrow;\n// propagate the exception\n}\n}\nThere is no need to worry about BookEntry’s non-pointer data mem-\nbers. Data members are automatically initialized before a class’s con-\nstructor is called, so if a BookEntry constructor body begins\nexecuting, the object’s theName, theAddress, and thePhones data\nmembers have already been fully constructed. As fully constructed ob-\njects, these data members will be automatically destroyed even if an\nexception arises in the BookEntry constructor†. Of course, if these ob-\njects’ constructors call functions that might throw exceptions, those\nconstructors have to worry about catching the exceptions and per-\nforming any necessary cleanup before allowing them to propagate.\nYou may have noticed that the statements in BookEntry’s catch block\nare almost the same as those in BookEntry’s destructor. Code dupli-\ncation here is no more tolerable than it is anywhere else, so the best\nway to structure things is to move the common code into a private\nhelper function and have both the constructor and the destructor call\nit:\nclass BookEntry {\npublic:\n...\n// as before\nprivate:\n...\nvoid cleanup();\n// common cleanup statements\n};\n† Provided, again, that the exception is caught.\n\n\nAvoiding Resource Leaks in Constructors\n55\nvoid BookEntry::cleanup()\n{\ndelete theImage;\ndelete theAudioClip;\n}\nBookEntry::BookEntry( const string& name, \nconst string& address,\nconst string& imageFileName,\nconst string& audioClipFileName)\n: theName(name), theAddress(address), \ntheImage(0), theAudioClip(0)\n{\ntry {\n...\n// as before\n}\ncatch (...) {\ncleanup();\n// release resources\nthrow;\n// propagate exception\n}\n}\nBookEntry::~BookEntry()\n{\ncleanup();\n}\nThis is nice, but it doesn’t put the topic to rest. Let us suppose we de-\nsign our BookEntry class slightly differently so that theImage and\ntheAudioClip are constant pointers:\nclass BookEntry {\npublic:\n...\n// as above\nprivate:\n...\nImage * const theImage;\n// pointers are now \nAudioClip * const theAudioClip;\n// const\n};\nSuch pointers must be initialized via the member initialization lists of\nBookEntry’s constructors, because there is no other way to give const\npointers a value. A common temptation is to initialize theImage and\ntheAudioClip like this,\n\n\n56\nItem 10\n// an implementation that may leak resources if an\n// exception is thrown\nBookEntry::BookEntry(const string& name, \nconst string& address,\nconst string& imageFileName,\nconst string& audioClipFileName)\n: theName(name), theAddress(address),\ntheImage(imageFileName != \"\" \n? new Image(imageFileName)\n: 0),\ntheAudioClip(audioClipFileName != \"\"\n? new AudioClip(audioClipFileName)\n: 0)\n{}\nbut this leads to the problem we originally wanted to eliminate: if an\nexception is thrown during initialization of theAudioClip, the object\npointed to by theImage is never destroyed. Furthermore, we can’t\nsolve the problem by adding try and catch blocks to the constructor,\nbecause try and catch are statements, and member initialization lists\nallow only expressions. (That’s why we had to use the ?: syntax in-\nstead of the if-then-else syntax in the initialization of theImage and\ntheAudioClip.)\nNevertheless, the only way to perform cleanup chores before excep-\ntions propagate out of a constructor is to catch those exceptions, so if\nwe can’t put try and catch in a member initialization list, we’ll have\nto put them somewhere else. One possibility is inside private member\nfunctions that return pointers with which theImage and theAudio-\nClip should be initialized:\nclass BookEntry {\npublic:\n...\n// as above\nprivate:\n...\n// data members as above\nImage * initImage(const string& imageFileName);\nAudioClip * initAudioClip(const string&\naudioClipFileName);\n};\nBookEntry::BookEntry(const string& name, \nconst string& address,\nconst string& imageFileName,\nconst string& audioClipFileName)\n: theName(name), theAddress(address), \ntheImage(initImage(imageFileName)),\ntheAudioClip(initAudioClip(audioClipFileName))\n{}\n\n\nAvoiding Resource Leaks in Constructors\n57\n// theImage is initialized first, so there is no need to\n// worry about a resource leak if this initialization\n// fails. This function therefore handles no exceptions\nImage * BookEntry::initImage(const string& imageFileName)\n{\nif (imageFileName != \"\") return new Image(imageFileName);\nelse return 0;\n}\n// theAudioClip is initialized second, so it must make\n// sure theImage’s resources are released if an exception\n// is thrown during initialization of theAudioClip. That’s\n// why this function uses try...catch.\nAudioClip * BookEntry::initAudioClip(const string&\naudioClipFileName)\n{\ntry {\nif (audioClipFileName != \"\") {\nreturn new AudioClip(audioClipFileName);\n}\nelse return 0;\n}\ncatch (...) {\ndelete theImage;\nthrow;\n}\n}\nThis is perfectly kosher, and it even solves the problem we’ve been la-\nboring to overcome. The drawback is that code that conceptually be-\nlongs in a constructor is now dispersed across several functions, and\nthat’s a maintenance headache.\nA better solution is to adopt the advice of Item 9 and treat the objects\npointed to by theImage and theAudioClip as resources to be man-\naged by local objects. This solution takes advantage of the facts that\nboth theImage and theAudioClip are pointers to dynamically allo-\ncated objects and that those objects should be deleted when the point-\ners themselves go away. This is precisely the set of conditions for\nwhich the auto_ptr classes (see Item 9) were designed. We can there-\nfore change the raw pointer types of theImage and theAudioClip to\ntheir auto_ptr equivalents: \nclass BookEntry {\npublic:\n...\n// as above\nprivate:\n...\nconst auto_ptr<Image> theImage;\n// these are now\nconst auto_ptr<AudioClip> theAudioClip; // auto_ptr objects\n};\n\n\n58\nItem 11\nDoing this makes BookEntry’s constructor leak-safe in the presence of\nexceptions, and it lets us initialize theImage and theAudioClip using\nthe member initialization list:\nBookEntry::BookEntry(const string& name, \nconst string& address,\nconst string& imageFileName,\nconst string& audioClipFileName)\n: theName(name), theAddress(address), \ntheImage(imageFileName != \"\" \n? new Image(imageFileName)\n: 0),\ntheAudioClip(audioClipFileName != \"\"\n? new AudioClip(audioClipFileName)\n: 0)\n{}\nIn this design, if an exception is thrown during initialization of the-\nAudioClip, theImage is already a fully constructed object, so it will\nautomatically be destroyed, just like theName, theAddress, and the-\nPhones. Furthermore, because theImage and theAudioClip are now\nobjects, they’ll be destroyed automatically when the BookEntry object\ncontaining them is. Hence there’s no need to manually delete what\nthey point to. That simplifies BookEntry’s destructor considerably:\nBookEntry::~BookEntry()\n{}\n// nothing to do!\nThis means you could eliminate BookEntry’s destructor entirely.\nIt all adds up to this: if you replace pointer class members with their\ncorresponding auto_ptr objects, you fortify your constructors against\nresource leaks in the presence of exceptions, you eliminate the need to\nmanually deallocate resources in destructors, and you allow const\nmember pointers to be handled in the same graceful fashion as non-\nconst pointers. \nDealing with the possibility of exceptions during construction can be\ntricky, but auto_ptr (and auto_ptr-like classes) can eliminate most\nof the drudgery. Their use leaves behind code that’s not only easy to\nunderstand, it’s robust in the face of exceptions, too.\nItem 11: Prevent exceptions from leaving destructors.\nExceptions and Destructors\nThere are two situations in which a destructor is called. The first is\nwhen an object is destroyed under “normal” conditions, e.g., when it\ngoes out of scope or is explicitly deleted. The second is when an object\nis destroyed by the exception-handling mechanism during the stack-\nunwinding part of exception propagation.\n",
      "page_number": 61,
      "chapter_number": 8,
      "summary": "This chapter covers segment 8 (pages 61-75). Key topics include objects, pointers, and classes. Covers exception. Special care must be taken\nto prevent program execution from abruptly halting.",
      "keywords": [
        "const string",
        "Prevent Resource Leaks",
        "BookEntry",
        "resource leaks",
        "exception",
        "const",
        "object",
        "Exceptions",
        "resource",
        "string",
        "Avoiding Resource Leaks",
        "Item",
        "ptr",
        "delete",
        "theImage"
      ],
      "concepts": [
        "objects",
        "pointers",
        "classes",
        "exceptions",
        "exception",
        "exceptional",
        "liked",
        "likely",
        "delete",
        "deleted"
      ],
      "similar_chapters": [
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 3,
          "title": "Segment 3 (pages 17-24)",
          "relevance_score": 0.71,
          "method": "api"
        },
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 4,
          "title": "Segment 4 (pages 25-32)",
          "relevance_score": 0.69,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 1,
          "title": "Segment 1 (pages 1-20)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 21,
          "title": "Segment 21 (pages 193-203)",
          "relevance_score": 0.67,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 34,
          "title": "Segment 34 (pages 683-702)",
          "relevance_score": 0.66,
          "method": "api"
        }
      ]
    },
    {
      "number": 9,
      "title": "Segment 9 (pages 76-97)",
      "start_page": 76,
      "end_page": 97,
      "detection_method": "topic_boundary",
      "content": "Exceptions and Destructors\n59\nThat being the case, an exception may or may not be active when a de-\nstructor is invoked. Regrettably, there is no way to distinguish between\nthese conditions from inside a destructor.† As a result, you must write\nyour destructors under the conservative assumption that an exception\nis active, because if control leaves a destructor due to an exception\nwhile another exception is active, C++ calls the terminate function.\nThat function does just what its name suggests: it terminates execu-\ntion of your program. Furthermore, it terminates it immediately; not\neven local objects are destroyed.\nAs an example, consider a Session class for monitoring on-line com-\nputer sessions, i.e., things that happen from the time you log in\nthrough the time you log out. Each Session object notes the date and\ntime of its creation and destruction:\nclass Session {\npublic:\nSession();\n~Session();\n...\nprivate:\nstatic void logCreation(Session *objAddr);\nstatic void logDestruction(Session *objAddr);\n};\nThe functions logCreation and logDestruction are used to record\nobject creations and destructions, respectively. We might therefore ex-\npect that we could code Session’s destructor like this:\nSession::~Session()\n{\nlogDestruction(this);\n}\nThis looks fine, but consider what would happen if logDestruction\nthrows an exception. The exception would not be caught in Session’s\ndestructor, so it would be propagated to the caller of that destructor.\nBut if the destructor was itself being called because some other excep-\ntion had been thrown, the terminate function would automatically be\ninvoked, and that would stop your program dead in its tracks.\nIn many cases, this is not what you’ll want to have happen. It may be\nunfortunate that the Session object’s destruction can’t be logged, it\nmight even be a major inconvenience, but is it really so horrific a pros-\n† Now there is. In July 1995, the ISO/ANSI standardization committee for C++ added a\nfunction, uncaught_exception, that returns true if an exception is active and has\nnot yet been caught.\n\n\n60\nItem 11\npect that the program can’t continue running? If not, you’ll have to\nprevent the exception thrown by logDestruction from propagating\nout of Session’s destructor. The only way to do that is by using try\nand catch blocks. A naive attempt might look like this,\nSession::~Session()\n{\ntry {\nlogDestruction(this);\n}\ncatch (...) {\ncerr << \"Unable to log destruction of Session object \"\n<< \"at address \" \n<< this\n<< \".\\n\";\n}\n}\nbut this is probably no safer than our original code. If one of the calls\nto operator<< in the catch block results in an exception being\nthrown, we’re back where we started, with an exception leaving the\nSession destructor. \nWe could always put a try block inside the catch block, but that\nseems a bit extreme. Instead, we’ll just forget about logging Session\ndestructions if logDestruction throws an exception:\nSession::~Session()\n{\ntry {\nlogDestruction(this);\n}\ncatch (...) {}\n}\nThe catch block appears to do nothing, but appearances can be de-\nceiving. That block prevents exceptions thrown from logDestruction\nfrom propagating beyond Session’s destructor. That’s all it needs to\ndo. We can now rest easy knowing that if a Session object is destroyed\nas part of stack unwinding, terminate will not be called.\nThere is a second reason why it’s bad practice to allow exceptions to\npropagate out of destructors. If an exception is thrown from a destruc-\ntor and is not caught there, that destructor won’t run to completion. (It\nwill stop at the point where the exception is thrown.) If the destructor\ndoesn’t run to completion, it won’t do everything it’s supposed to do.\nFor example, consider a modified version of the Session class where\nthe creation of a session starts a database transaction and the termi-\nnation of a session ends that transaction:\n\n\nThrowing Exceptions Compared to Calling Functions\n61\nSession::Session()\n// to keep things simple,\n{\n// this ctor handles no\n// exceptions\nlogCreation(this);\nstartTransaction();\n// start DB transaction\n}\nSession::~Session()\n{\nlogDestruction(this);\nendTransaction();\n// end DB transaction\n}\nHere, if logDestruction throws an exception, the transaction started\nin the Session constructor will never be ended. In this case, we might\nbe able to reorder the function calls in Session’s destructor to elimi-\nnate the problem, but if endTransaction might throw an exception,\nwe’ve no choice but to revert to try and catch blocks.\nWe thus find ourselves with two good reasons for keeping exceptions\nfrom propagating out of destructors. First, it prevents terminate from\nbeing called during the stack-unwinding part of exception propaga-\ntion. Second, it helps ensure that destructors always accomplish ev-\nerything they are supposed to accomplish. Each argument is\nconvincing in its own right, but together, the case is ironclad.\nItem 12: Understand how throwing an exception \ndiffers from passing a parameter or calling a \nvirtual function.\nThrowing Exceptions Compared to Calling Functions\nThe syntax for declaring function parameters is almost the same as\nthat for catch clauses:\nclass Widget { ... };\n// some class; it makes no\n// difference what it is\nvoid f1(Widget w);\n// all these functions\nvoid f2(Widget& w);\n// take parameters of\nvoid f3(const Widget& w);\n// type Widget, Widget&, or\nvoid f4(Widget *pw);\n// Widget*\nvoid f5(const Widget *pw);\ncatch (Widget w) ...\n// all these catch clauses\ncatch (Widget& w) ...\n// catch exceptions of\ncatch (const Widget& w) ...\n// type Widget, Widget&, or\ncatch (Widget *pw) ...\n// Widget*\ncatch (const Widget *pw) ...\nYou might therefore assume that passing an exception from a throw\nsite to a catch clause is basically the same as passing an argument\n\n\n62\nItem 12\nfrom a function call site to the function’s parameter. There are some\nsimilarities, to be sure, but there are significant differences, too.\nLet us begin with a similarity. You can pass both function parameters\nand exceptions by value, by reference, or by pointer. What happens\nwhen you pass parameters and exceptions, however, is quite different.\nThis difference grows out of the fact that when you call a function, con-\ntrol eventually returns to the call site (unless the function fails to re-\nturn), but when you throw an exception, control does not return to the\nthrow site. \nConsider a function that both passes a Widget as a parameter and\nthrows a Widget as an exception:\n// function to read the value of a Widget from a stream\nistream operator>>(istream& s, Widget& w);\nvoid passAndThrowWidget()\n{\nWidget localWidget;\ncin >> localWidget;\n// pass localWidget to operator>>\nthrow localWidget;\n// throw localWidget as an exception\n}\nWhen localWidget is passed to operator>>, no copying is per-\nformed. Instead, the reference w inside operator>> is bound to lo-\ncalWidget, and anything done to w is really done to localWidget. It’s\na different story when localWidget is thrown as an exception. Re-\ngardless of whether the exception is caught by value or by reference (it\ncan’t be caught by pointer — that would be a type mismatch), a copy\nof localWidget will be made, and it is the copy that is passed to the\ncatch clause. This must be the case, because localWidget will go out\nof scope once control leaves passAndThrowWidget, and when local-\nWidget goes out of scope, its destructor will be called. If localWidget\nitself were passed to a catch clause, the clause would receive a de-\nstructed Widget, an ex-Widget, a former Widget, the carcass of what\nonce was but is no longer a Widget. That would not be useful, and\nthat’s why C++ specifies that an object thrown as an exception is cop-\nied.\nThis copying occurs even if the object being thrown is not in danger of\nbeing destroyed. For example, if passAndThrowWidget declares lo-\ncalWidget to be static,\nvoid passAndThrowWidget()\n{\nstatic Widget localWidget;\n// this is now static; it\n// will exist until the\n// end of the program\n\n\nThrowing Exceptions Compared to Calling Functions\n63\ncin >> localWidget;\n// this works as before\nthrow localWidget;\n// a copy of localWidget is\n}\n// still made and thrown\na copy of localWidget would still be made when the exception was\nthrown. This means that even if the exception is caught by reference,\nit is not possible for the catch block to modify localWidget; it can\nonly modify a copy of localWidget. This mandatory copying of excep-\ntion objects† helps explain another difference between parameter pass-\ning and throwing an exception: the latter is typically much slower than\nthe former (see Item 15).\nWhen an object is copied for use as an exception, the copying is per-\nformed by the object’s copy constructor. This copy constructor is the\none in the class corresponding to the object’s static type, not its dy-\nnamic type. For example, consider this slightly modified version of\npassAndThrowWidget:\nclass Widget { ... };\nclass SpecialWidget: public Widget { ... };\nvoid passAndThrowWidget()\n{\nSpecialWidget localSpecialWidget;\n...\nWidget& rw = localSpecialWidget;\n// rw refers to a\n// SpecialWidget\nthrow rw;\n// this throws an\n// exception of type\n}\n// Widget!\nHere a Widget exception is thrown, even though rw refers to a Spe-\ncialWidget. That’s because rw’s static type is Widget, not Special-\nWidget. That rw actually refers to a SpecialWidget is of no concern\nto your compilers; all they care about is rw’s static type. This behavior\nmay not be what you want, but it’s consistent with all other cases in\nwhich C++ copies objects. Copying is always based on an object’s static\ntype (but see Item 25 for a technique that lets you make copies on the\nbasis of an object’s dynamic type).\nThe fact that exceptions are copies of other objects has an impact on\nhow you propagate exceptions from a catch block. Consider these two\ncatch blocks, which at first glance appear to do the same thing:\n† Compiler writers are actually allowed a slight bit of leeway regarding the “mandatory”\nnature of the copying; it can be eliminated under certain circumstances. Similar lee-\nway provides the foundation for the return value optimization (see Item 20).\n\n\n64\nItem 12\ncatch (Widget& w)\n// catch Widget exceptions\n{\n...\n// handle the exception\nthrow;\n// rethrow the exception so it\n}\n// continues to propagate\ncatch (Widget& w)\n// catch Widget exceptions\n{\n...\n// handle the exception\nthrow w;\n// propagate a copy of the\n}\n// caught exception\nThe only difference between these blocks is that the first one rethrows\nthe current exception, while the second one throws a new copy of the\ncurrent exception. Setting aside the performance cost of the additional\ncopy operation, is there a difference between these approaches? \nThere is. The first block rethrows the current exception, regardless of\nits type. In particular, if the exception originally thrown was of type\nSpecialWidget, the first block would propagate a SpecialWidget ex-\nception, even though w’s static type is Widget. This is because no copy\nis made when the exception is rethrown. The second catch block\nthrows a new exception, which will always be of type Widget, because\nthat’s w’s static type. In general, you’ll want to use the \nthrow;\nsyntax to rethrow the current exception, because there’s no chance\nthat that will change the type of the exception being propagated. Fur-\nthermore, it’s more efficient, because there’s no need to generate a new\nexception object.\n(Incidentally, the copy made for an exception is a temporary object. As\nItem 19 explains, this gives compilers the right to optimize it out of ex-\nistence. I wouldn’t expect your compilers to work that hard, however.\nExceptions are supposed to be rare, so it makes little sense for com-\npiler vendors to pour a lot of energy into their optimization.)\nLet us examine the three kinds of catch clauses that could catch the\nWidget exception thrown by passAndThrowWidget. They are:\ncatch (Widget w) ...\n// catch exception by value\ncatch (Widget& w) ...\n// catch exception by\n// reference\ncatch (const Widget& w) ...\n// catch exception by\n// reference-to-const\nRight away we notice another difference between parameter passing\nand exception propagation. A thrown object (which, as explained\n\n\nThrowing Exceptions Compared to Calling Functions\n65\nabove, is always a temporary) may be caught by simple reference; it\nneed not be caught by reference-to-const. Passing a temporary object\nto a non-const reference parameter is not allowed for function calls\n(see Item 19), but it is for exceptions.\nLet us overlook this difference, however, and return to our examina-\ntion of copying exception objects. We know that when we pass a func-\ntion argument by value, we make a copy of the passed object, and we\nstore that copy in a function parameter. The same thing happens when\nwe pass an exception by value. Thus, when we declare a catch clause\nlike this,\ncatch (Widget w) ...\n// catch by value\nwe expect to pay for the creation of two copies of the thrown object, one\nto create the temporary that all exceptions generate, the second to\ncopy that temporary into w. Similarly, when we catch an exception by\nreference, \ncatch (Widget& w) ...\n// catch by reference\ncatch (const Widget& w) ...\n// also catch by reference\nwe still expect to pay for the creation of a copy of the exception: the\ncopy that is the temporary. In contrast, when we pass function param-\neters by reference, no copying takes place. When throwing an excep-\ntion, then, we expect to construct (and later destruct) one more copy of\nthe thrown object than if we passed the same object to a function.\nWe have not yet discussed throwing exceptions by pointer, but throw\nby pointer is equivalent to pass by pointer. Either way, a copy of the\npointer is passed. About all you need to remember is not to throw a\npointer to a local object, because that local object will be destroyed\nwhen the exception leaves the local object’s scope. The catch clause\nwould then be initialized with a pointer to an object that had already\nbeen destroyed. This is the behavior the mandatory copying rule is de-\nsigned to avoid.\nThe way in which objects are moved from call or throw sites to param-\neters or catch clauses is one way in which argument passing differs\nfrom exception propagation. A second difference lies in what consti-\ntutes a type match between caller or thrower and callee or catcher.\nConsider the sqrt function from the standard math library:\ndouble sqrt(double);\n// from <cmath> or <math.h>\nWe can determine the square root of an integer like this:\nint i;\ndouble sqrtOfi = sqrt(i);\n\n\n66\nItem 12\nThere is nothing surprising here. The language allows implicit conver-\nsion from int to double, so in the call to sqrt, i is silently converted\nto a double, and the result of sqrt corresponds to that double. (See\nItem 5 for a fuller discussion of implicit type conversions.) In general,\nsuch conversions are not applied when matching exceptions to catch\nclauses. In this code,\nvoid f(int value)\n{\ntry {\nif (someFunction()) {\n// if someFunction() returns\nthrow value;\n// true, throw an int\n}\n...\n}\ncatch (double d) {\n// handle exceptions of \n...\n// type double here\n}\n...\n}\nthe int exception thrown inside the try block will never be caught by\nthe catch clause that takes a double. That clause catches only excep-\ntions that are exactly of type double; no type conversions are applied.\nAs a result, if the int exception is to be caught, it will have to be by\nsome other (dynamically enclosing) catch clause taking an int or an\nint& (possibly modified by const or volatile).\nTwo kinds of conversions are applied when matching exceptions to\ncatch clauses. The first is inheritance-based conversions. A catch\nclause for base class exceptions is allowed to handle exceptions of (pub-\nlicly) derived class types, too. For example, consider the diagnostics por-\ntion of the hierarchy of exceptions defined by the standard C++ library:\ninvalid_argument\nexception\nruntime_error\nlogic_error\nlength_error\nrange_error\noverflow_error\ndomain_error\nout_of_range\nunderflow_error\n\n\nThrowing Exceptions Compared to Calling Functions\n67\nA catch clause for runtime_errors can catch exceptions of type\nrange_error, underflow_error, and overflow_error, too, and a\ncatch clause accepting an object of the root class exception can\ncatch any kind of exception derived from this hierarchy.\nThis inheritance-based exception-conversion rule applies to values,\nreferences, and pointers in the usual fashion (though Item 13 explains\nwhy catching values or pointers is generally a bad idea):\ncatch (runtime_error) ...\n// can catch errors of type\ncatch (runtime_error&) ...\n// runtime_error,\ncatch (const runtime_error&) ... // range_error, or\n// overflow_error\ncatch (runtime_error*) ...\n// can catch errors of type\ncatch (const runtime_error*) ... // runtime_error*,\n// range_error*, or\n// overflow_error*\nThe second type of allowed conversion is from a typed to an untyped\npointer, so a catch clause taking a const void* pointer will catch an\nexception of any pointer type:\ncatch (const void*) ...\n// catches any exception \n// that’s a pointer\nThe final difference between passing a parameter and propagating an\nexception is that catch clauses are always tried in the order of their ap-\npearance. Hence, it is possible for an exception of a (publicly) derived\nclass type to be handled by a catch clause for one of its base class\ntypes — even when a catch clause for the derived class is associated\nwith the same try block! For example,\ntry {\n...\n}\ncatch (logic_error& ex) {\n// this block will catch \n...\n// all logic_error \n}\n// exceptions, even those\n// of derived types\ncatch (invalid_argument& ex) { // this block can never be\n...\n// executed, because all\n}\n// invalid_argument\n// exceptions will be caught\n// by the clause above\nContrast this behavior with what happens when you call a virtual\nfunction. When you call a virtual function, the function invoked is the\none in the class closest to the dynamic type of the object invoking the\nfunction. You might say that virtual functions employ a “best fit” algo-\nrithm, while exception handling follows a “first fit” strategy. Compilers\nmay warn you if a catch clause for a derived class comes after one for\na base class (some issue an error, because such code used to be illegal\n\n\n68\nItem 13\nin C++), but your best course of action is preemptive: never put a\ncatch clause for a base class before a catch clause for a derived class.\nThe code above, for example, should be reordered like this:\ntry {\n...\n}\ncatch (invalid_argument& ex) { // handle invalid_argument\n...\n// exceptions here\n}\ncatch (logic_error& ex) {\n// handle all other\n...\n// logic_errors here\n}\nThere are thus three primary ways in which passing an object to a\nfunction or using that object to invoke a virtual function differs from\nthrowing the object as an exception. First, exception objects are always\ncopied; when caught by value, they are copied twice. Objects passed to\nfunction parameters need not be copied at all. Second, objects thrown\nas exceptions are subject to fewer forms of type conversion than are\nobjects passed to functions. Finally, catch clauses are examined in\nthe order in which they appear in the source code, and the first one\nthat can succeed is selected for execution. When an object is used to\ninvoke a virtual function, the function selected is the one that provides\nthe best match for the type of the object, even if it’s not the first one\nlisted in the source code.\nItem 13: Catch exceptions by reference.\nCatching Exceptions\nWhen you write a catch clause, you must specify how exception ob-\njects are to be passed to that clause. You have three choices, just as\nwhen specifying how parameters should be passed to functions: by\npointer, by value, or by reference.\nLet us consider first catch by pointer. In theory, this should be the\nleast inefficient way to implement the invariably slow process of mov-\ning an exception from throw site to catch clause (see Item 15). That’s\nbecause throw by pointer is the only way of moving exception informa-\ntion without copying an object (see Item 12). For example:\nclass exception { ... };\n// from the standard C++\n// library exception \n// hierarchy (see Item 12)\nvoid someFunction()\n{\nstatic exception ex;\n// exception object\n...\n\n\nCatching Exceptions\n69\nthrow &ex;\n// throw a pointer to ex\n...\n}\nvoid doSomething()\n{\ntry {\nsomeFunction();\n// may throw an exception*\n}\ncatch (exception *ex) {\n// catches the exception*;\n...\n// no object is copied \n}\n}\nThis looks neat and tidy, but it’s not quite as well-kept as it appears.\nFor this to work, programmers must define exception objects in a way\nthat guarantees the objects exist after control leaves the functions\nthrowing pointers to them. Global and static objects work fine, but it’s\neasy for programmers to forget the constraint. If they do, they typically\nend up writing code like this:\nvoid someFunction()\n{\nexception ex;\n// local exception object; \n// will be destroyed when \n// this function’s scope is\n...\n// exited\nthrow &ex;\n// throw a pointer to an\n...\n// object that’s about to\n}\n// be destroyed\nThis is worse than useless, because the catch clause handling this ex-\nception receives a pointer to an object that no longer exists.\nAn alternative is to throw a pointer to a new heap object:\nvoid someFunction()\n{\n...\nthrow new exception;\n// throw a pointer to a new heap-\n...\n// based object (and hope that \n}\n// operator new — see Item 8 —\n// doesn’t itself throw an \n// exception!)\nThis avoids the I-just-caught-a-pointer-to-a-destroyed-object problem,\nbut now authors of catch clauses confront a nasty question: should\nthey delete the pointer they receive? If the exception object was allo-\ncated on the heap, they must, otherwise they suffer a resource leak. If\n\n\n70\nItem 13\nthe exception object wasn’t allocated on the heap, they mustn’t, other-\nwise they suffer undefined program behavior. What to do?\nIt’s impossible to know. Some clients might pass the address of a glo-\nbal or static object, others might pass the address of an exception on\nthe heap. Catch by pointer thus gives rise to the Hamlet conundrum:\nto delete or not to delete? It’s a question with no good answer. You’re\nbest off ducking it.\nFurthermore, catch-by-pointer runs contrary to the convention estab-\nlished by the language itself. The four standard exceptions —\nbad_alloc (thrown when operator new (see Item 8) can’t satisfy a\nmemory request), bad_cast (thrown when a dynamic_cast to a refer-\nence fails; see Item 2), bad_typeid (thrown when typeid is applied to\na dereferenced null pointer), and bad_exception (available for unex-\npected exceptions; see Item 14) — are all objects, not pointers to ob-\njects, so you have to catch them by value or by reference, anyway.\nCatch-by-value eliminates questions about exception deletion and\nworks with the standard exception types. However, it requires that ex-\nception objects be copied twice each time they’re thrown (see Item 12).\nIt also gives rise to the specter of the slicing problem, whereby derived\nclass exception objects caught as base class exceptions have their de-\nrivedness “sliced off.” Such “sliced” objects are base class objects: they\nlack derived class data members, and when virtual functions are called\non them, they resolve to virtual functions of the base class. (Exactly\nthe same thing happens when an object is passed to a function by\nvalue.) For example, consider an application employing an exception\nclass hierarchy that extends the standard one:\nclass exception {\n// as above, this is a \npublic:\n// standard exception class\nvirtual const char * what() const throw();\n// returns a brief descrip.\n...\n// of the exception (see\n// Item 14 for info about\n};\n// the \"throw()\" at the\n// end of the declaration)\nclass runtime_error:\n// also from the standard\npublic exception { ... };\n// C++ exception hierarchy\nclass Validation_error:\n// this is a class added by\npublic runtime_error {\n// a client\npublic:\nvirtual const char * what() const throw();\n// this is a redefinition\n...\n// of the function declared\n};\n// in class exception above\n\n\nCatching Exceptions\n71\nvoid someFunction()\n// may throw a validation\n{\n// exception\n...\nif (a validation test fails) {\nthrow Validation_error();\n}\n...\n}\nvoid doSomething()\n{\ntry {\nsomeFunction();\n// may throw a validation\n}\n// exception\ncatch (exception ex) {\n// catches all exceptions\n// in or derived from \n// the standard hierarchy\ncerr << ex.what();\n// calls exception::what(),\n...\n// never \n}\n// Validation_error::what()\n}\nThe version of what that is called is that of the base class, even though\nthe thrown exception is of type Validation_error and\nValidation_error redefines that virtual function. This kind of slicing\nbehavior is almost never what you want.\nThat leaves only catch-by-reference. Catch-by-reference suffers from\nnone of the problems we have discussed. Unlike catch-by-pointer, the\nquestion of object deletion fails to arise, and there is no difficulty in\ncatching the standard exception types. Unlike catch-by-value, there is\nno slicing problem, and exception objects are copied only once.\nIf we rewrite the last example using catch-by-reference, it looks like\nthis:\nvoid someFunction()\n// nothing changes in this\n{\n// function\n...\nif (a validation test fails) {\nthrow Validation_error();\n}\n...\n}\n\n\n72\nItem 14\nvoid doSomething()\n{\ntry {\nsomeFunction();\n// no change here\n}\ncatch (exception& ex) {\n// here we catch by reference\n// instead of by value\ncerr << ex.what();\n// now calls\n// Validation_error::what(),\n...\n// not exception::what()\n}\n}\nThere is no change at the throw site, and the only change in the catch\nclause is the addition of an ampersand. This tiny modification makes\na big difference, however, because virtual functions in the catch block\nnow work as we expect: functions in Validation_error are invoked if\nthey redefine those in exception. Of course, if there is no need to\nmodify the exception object in the handler, you’d catch not just by ref-\nerence, but by reference to const.\nWhat a happy confluence of events! If you catch by reference, you side-\nstep questions about object deletion that leave you damned if you do\nand damned if you don’t; you avoid slicing exception objects; you re-\ntain the ability to catch standard exceptions; and you limit the number\nof times exception objects need to be copied. So what are you waiting\nfor? Catch exceptions by reference!\nItem 14: Use exception specifications judiciously.\nException Specifications\nThere’s no denying it: exception specifications have appeal. They make\ncode easier to understand, because they explicitly state what excep-\ntions a function may throw. But they’re more than just fancy com-\nments. Compilers are sometimes able to detect inconsistent exception\nspecifications during compilation. Furthermore, if a function throws\nan exception not listed in its exception specification, that fault is de-\ntected at runtime, and the special function unexpected is automati-\ncally invoked. Both as a documentation aid and as an enforcement\nmechanism for constraints on exception usage, then, exception speci-\nfications seem attractive.\nAs is often the case, however, beauty is only skin deep. The default be-\nhavior for unexpected is to call terminate, and the default behavior\nfor terminate is to call abort, so the default behavior for a program\nwith a violated exception specification is to halt. Local variables in ac-\ntive stack frames are not destroyed, because abort shuts down pro-\ngram execution without performing such cleanup. A violated exception\nspecification is therefore a cataclysmic thing, something that should\nalmost never happen.\n\n\nException Specifications\n73\nUnfortunately, it’s easy to write functions that make this terrible thing\noccur. Compilers only partially check exception usage for consistency\nwith exception specifications. What they do not check for — what the\nlanguage standard prohibits them from rejecting (though they may\nissue a warning) — is a call to a function that might violate the excep-\ntion specification of the function making the call.\nConsider a declaration for a function f1 that has no exception specifi-\ncation. Such a function may throw any kind of exception:\nextern void f1();\n// might throw anything\nNow consider a function f2 that claims, through its exception specifi-\ncation, it will throw only exceptions of type int:\nvoid f2() throw(int);\nIt is perfectly legal C++ for f2 to call f1, even though f1 might throw\nan exception that would violate f2’s exception specification:\nvoid f2() throw(int)\n{\n...\nf1();\n// legal even though f1 might throw\n// something besides an int\n...\n}\nThis kind of flexibility is essential if new code with exception specifica-\ntions is to be integrated with older code lacking such specifications.\nBecause your compilers are content to let you call functions whose ex-\nception specifications are inconsistent with those of the routine con-\ntaining the calls, and because such calls might result in your\nprogram’s execution being terminated, it’s important to write your\nsoftware in such a way that these kinds of inconsistencies are mini-\nmized. A good way to start is to avoid putting exception specifications\non templates that take type arguments. Consider this template, which\ncertainly looks as if it couldn’t throw any exceptions:\n// a poorly designed template wrt exception specifications\ntemplate<class T>\nbool operator==(const T& lhs, const T& rhs) throw()\n{\nreturn &lhs == &rhs;\n}\nThis template defines an operator== function for all types. For any\npair of objects of the same type, it returns true if the objects have the\nsame address, otherwise it returns false.\n\n\n74\nItem 14\nThis template contains an exception specification stating that the\nfunctions generated from the template will throw no exceptions. But\nthat’s not necessarily true, because it’s possible that operator& (the\naddress-of operator) has been overloaded for some types. If it has, op-\nerator& may throw an exception when called from inside opera-\ntor==. If it does, our exception specification is violated, and off to\nunexpected we go.\nThis is a specific example of a more general problem, namely, that\nthere is no way to know anything about the exceptions thrown by a\ntemplate’s type parameters. We can almost never provide a meaningful\nexception specification for a template, because templates almost in-\nvariably use their type parameter in some way. The conclusion? Tem-\nplates and exception specifications don’t mix.\nA second technique you can use to avoid calls to unexpected is to omit\nexception specifications on functions making calls to functions that\nthemselves lack exception specifications. This is simple common\nsense, but there is one case that is easy to forget. That’s when allowing\nusers to register callback functions:\n// Function pointer type for a window system callback\n// when a window system event occurs\ntypedef void (*CallBackPtr)(int eventXLocation,\nint eventYLocation,\nvoid *dataToPassBack);\n// Window system class for holding onto callback\n// functions registered by window system clients\nclass CallBack {\npublic:\nCallBack(CallBackPtr fPtr, void *dataToPassBack)\n: func(fPtr), data(dataToPassBack) {}\nvoid makeCallBack(int eventXLocation,\nint eventYLocation) const throw();\nprivate:\nCallBackPtr func;\n// function to call when\n// callback is made\nvoid *data;\n// data to pass to callback\n};\n// function\n// To implement the callback, we call the registered func-\n// tion with event’s coordinates and the registered data\nvoid CallBack::makeCallBack(int eventXLocation,\nint eventYLocation) const throw()\n{\nfunc(eventXLocation, eventYLocation, data);\n}\n\n\nException Specifications\n75\nHere the call to func in makeCallBack runs the risk of a violated ex-\nception specification, because there is no way of knowing what excep-\ntions func might throw. \nThis problem can be eliminated by tightening the exception specifica-\ntion in the CallBackPtr typedef:†\ntypedef void (*CallBackPtr)(int eventXLocation,\nint eventYLocation,\nvoid *dataToPassBack) throw();\nGiven this typedef, it is now an error to register a callback function\nthat fails to guarantee it throws nothing:\n// a callback function without an exception specification\nvoid callBackFcn1(int eventXLocation, int eventYLocation,\nvoid *dataToPassBack);\nvoid *callBackData;\n...\nCallBack c1(callBackFcn1, callBackData);\n// error! callBackFcn1\n// might throw an exception\n// a callback function with an exception specification\nvoid callBackFcn2(int eventXLocation,\nint eventYLocation,\nvoid *dataToPassBack) throw();\nCallBack c2(callBackFcn2, callBackData);\n// okay, callBackFcn2 has a\n// conforming ex. spec.\nThis checking of exception specifications when passing function point-\ners is a relatively recent addition to the language, so don’t be surprised\nif your compilers don’t yet support it. If they don’t, it’s up to you to en-\nsure you don’t make this kind of mistake.\nA third technique you can use to avoid calls to unexpected is to handle\nexceptions “the system” may throw. Of these exceptions, the most com-\nmon is bad_alloc, which is thrown by operator new and operator\nnew[] when a memory allocation fails (see Item 8). If you use the new\noperator (again, see Item 8) in any function, you must be prepared for\nthe possibility that the function will encounter a bad_alloc exception.\nNow, an ounce of prevention may be better than a pound of cure, but\nsometimes prevention is hard and cure is easy. That is, sometimes it’s\neasier to cope with unexpected exceptions directly than to prevent\nthem from arising in the first place. If, for example, you’re writing soft-\n† Alas, it can’t, at least not portably. Though many compilers accept the code shown on\nthis page, the standardization committee has inexplicably decreed that “an exception\nspecification shall not appear in a  typedef.” I don’t know why. If you need a portable\nsolution, you must — it hurts me to write this — make CallBackPtr a macro, sigh.\n\n\n76\nItem 14\nware that uses exception specifications rigorously, but you’re forced to\ncall functions in libraries that don’t use exception specifications, it’s\nimpractical to prevent unexpected exceptions from arising, because\nthat would require changing the code in the libraries. \nIf preventing unexpected exceptions isn’t practical, you can exploit the\nfact that C++ allows you to replace unexpected exceptions with excep-\ntions of a different type. For example, suppose you’d like all unex-\npected exceptions to be replaced by UnexpectedException objects.\nYou can set it up like this,\nclass UnexpectedException {};\n// all unexpected exception\n// objects will be replaced\n// by objects of this type\nvoid convertUnexpected()\n// function to call if\n{\n// an unexpected exception\nthrow UnexpectedException(); // is thrown\n}\nand make it happen by replacing the default unexpected function\nwith convertUnexpected:\nset_unexpected(convertUnexpected);\nOnce you’ve done this, any unexpected exception results in convert-\nUnexpected being called. The unexpected exception is then replaced\nby a new exception of type UnexpectedException. Provided the ex-\nception specification that was violated includes UnexpectedExcep-\ntion, exception propagation will then continue as if the exception\nspecification had always been satisfied. (If the exception specification\ndoes not include UnexpectedException, terminate will be called,\njust as if you had never replaced unexpected.)\nAnother way to translate unexpected exceptions into a well known type\nis to rely on the fact that if the unexpected function’s replacement re-\nthrows the current exception, that exception will be replaced by a new\nexception of the standard type bad_exception. Here’s how you’d ar-\nrange for that to happen:\nvoid convertUnexpected()\n// function to call if\n{\n// an unexpected exception\nthrow;\n// is thrown; just rethrow\n}\n// the current exception\nset_unexpected(convertUnexpected);\n// install convertUnexpected\n// as the unexpected\n// replacement\n\n\nException Specifications\n77\nIf you do this and you include bad_exception (or its base class, the\nstandard class exception) in all your exception specifications, you’ll\nnever have to worry about your program halting if an unexpected ex-\nception is encountered. Instead, any wayward exception will be re-\nplaced by a bad_exception, and that exception will be propagated in\nthe stead of the original one.\nBy now you understand that exception specifications can be a lot of\ntrouble. Compilers perform only partial checks for their consistent us-\nage, they’re problematic in templates, they’re easy to violate inadvert-\nently, and, by default, they lead to abrupt program termination when\nthey’re violated. Exception specifications have another drawback, too,\nand that’s that they result in unexpected being invoked even when a\nhigher-level caller is prepared to cope with the exception that’s arisen.\nFor example, consider this code, which is taken almost verbatim from\nItem 11:\nclass Session {\n// for modeling online\npublic:\n// sessions\n~Session();\n...\nprivate:\nstatic void logDestruction(Session *objAddr) throw();\n};\nSession::~Session()\n{\ntry {\nlogDestruction(this);\n}\ncatch (...) {}\n}\nThe Session destructor calls logDestruction to record the fact that\na Session object is being destroyed, but it explicitly catches any ex-\nceptions that might be thrown by logDestruction. However, logDe-\nstruction comes with an exception specification asserting that it\nthrows no exceptions. Now, suppose some function called by logDe-\nstruction throws an exception that logDestruction fails to catch.\nThis isn’t supposed to happen, but as we’ve seen, it isn’t difficult to\nwrite code that leads to the violation of exception specifications. When\nthis unanticipated exception propagates through logDestruction,\nunexpected will be called, and, by default, that will result in termina-\ntion of the program. This is correct behavior, to be sure, but is it the\nbehavior the author of Session’s destructor wanted? That author took\npains to handle all possible exceptions, so it seems almost unfair to\nhalt the program without giving Session’s destructor’s catch block a\nchance to work. If logDestruction had no exception specification,\n\n\n78\nItem 15\nthis I’m-willing-to-catch-it-if-you’ll-just-give-me-a-chance scenario\nwould never arise. (One way to prevent it is to replace unexpected as\ndescribed above.)\nIt’s important to keep a balanced view of exception specifications. They\nprovide excellent documentation on the kinds of exceptions a function\nis expected to throw, and for situations in which violating an exception\nspecification is so dire as to justify immediate program termination,\nthey offer that behavior by default. At the same time, they are only\npartly checked by compilers and they are easy to violate inadvertently.\nFurthermore, they can prevent high-level exception handlers from\ndealing with unexpected exceptions, even when they know how to.\nThat being the case, exception specifications are a tool to be applied ju-\ndiciously. Before adding them to your functions, consider whether the\nbehavior they impart to your software is really the behavior you want.\nItem 15: Understand the costs of exception handling.\nThe Costs of Exception Handling\nTo handle exceptions at runtime, programs must do a fair amount of\nbookkeeping. At each point during execution, they must be able to\nidentify the objects that require destruction if an exception is thrown;\nthey must make note of each entry to and exit from a try block; and\nfor each try block, they must keep track of the associated catch\nclauses and the types of exceptions those clauses can handle. This\nbookkeeping is not free. Nor are the runtime comparisons necessary to\nensure that exception specifications are satisfied. Nor is the work ex-\npended to destroy the appropriate objects and find the correct catch\nclause when an exception is thrown. No, exception handling has costs,\nand you pay at least some of them even if you never use the keywords\ntry, throw, or catch.\nLet us begin with the things you pay for even if you never use any ex-\nception-handling features. You pay for the space used by the data\nstructures needed to keep track of which objects are fully constructed\n(see Item 10), and you pay for the time needed to keep these data\nstructures up to date. These costs are typically quite modest. Never-\ntheless, programs compiled without support for exceptions are typi-\ncally both faster and smaller than their counterparts compiled with\nsupport for exceptions.\nIn theory, you don’t have a choice about these costs: exceptions are\npart of C++, compilers have to support them, and that’s that. You can’t\neven expect compiler vendors to eliminate the costs if you use no ex-\nception-handling features, because programs are typically composed\nof multiple independently generated object files, and just because one\nobject file doesn’t do anything with exceptions doesn’t mean others\n\n\nThe Costs of Exception Handling\n79\ndon’t. Furthermore, even if none of the object files linked to form an ex-\necutable use exceptions, what about the libraries they’re linked with?\nIf any part of a program uses exceptions, the rest of the program must\nsupport them, too. Otherwise it may not be possible to provide correct\nexception-handling behavior at runtime.\nThat’s the theory. In practice, most vendors who support exception\nhandling allow you to control whether support for exceptions is in-\ncluded in the code they generate. If you know that no part of your pro-\ngram uses try, throw, or catch, and you also know that no library\nwith which you’ll link uses try, throw, or catch, you might as well\ncompile without exception-handling support and save yourself the size\nand speed penalty you’d otherwise probably be assessed for a feature\nyou’re not using. As time goes on and libraries employing exceptions\nbecome more common, this strategy will become less tenable, but\ngiven the current state of C++ software development, compiling with-\nout support for exceptions is a reasonable performance optimization if\nyou have already decided not to use exceptions. It may also be an at-\ntractive optimization for libraries that eschew exceptions, provided\nthey can guarantee that exceptions thrown from client code never\npropagate into the library. This is a difficult guarantee to make, as it\nprecludes client redefinitions of library-declared virtual functions; it\nalso rules out client-defined callback functions.\nA second cost of exception-handling arises from try blocks, and you\npay it whenever you use one, i.e., whenever you decide you want to be\nable to catch exceptions. Different compilers implement try blocks in\ndifferent ways, so the cost varies from compiler to compiler. As a rough\nestimate, expect your overall code size to increase by 5-10% and your\nruntime to go up by a similar amount if you use try blocks. This as-\nsumes no exceptions are thrown; what we’re discussing here is just the\ncost of having try blocks in your programs. To minimize this cost, you\nshould avoid unnecessary try blocks.\nCompilers tend to generate code for exception specifications much as\nthey do for try blocks, so an exception specification generally incurs\nabout the same cost as a try block. Excuse me? You say you thought\nexception specifications were just specifications, you didn’t think they\ngenerated code? Well, now you have something new to think about.\nWhich brings us to the heart of the matter, the cost of throwing an ex-\nception. In truth, this shouldn’t be much of a concern, because excep-\ntions should be rare. After all, they indicate the occurrence of events\nthat are exceptional. The 80-20 rule (see Item 16) tells us that such\nevents should almost never have much impact on a program’s overall\nperformance. Nevertheless, I know you’re curious about just how big a\nhit you’ll take if you throw an exception, and the answer is it’s proba-\n\n\n80\nItem 15\nbly a big one. Compared to a normal function return, returning from a\nfunction by throwing an exception may be as much as three orders of\nmagnitude slower. That’s quite a hit. But you’ll take it only if you throw\nan exception, and that should be almost never. If, however, you’ve been\nthinking of using exceptions to indicate relatively common conditions\nlike the completion of a data structure traversal or the termination of\na loop, now would be an excellent time to think again.\nBut wait. How can I know this stuff? If support for exceptions is a rel-\natively recent addition to most compilers (it is), and if different compil-\ners implement their support in different ways (they do), how can I say\nthat a program’s size will generally grow by about 5-10%, its speed will\ndecrease by a similar amount, and it may run orders of magnitude\nslower if lots of exceptions are thrown? The answer is frightening: a lit-\ntle rumor and a handful of benchmarks (see Item 23). The fact is that\nmost people — including most compiler vendors — have little experi-\nence with exceptions, so though we know there are costs associated\nwith them, it is difficult to predict those costs accurately. \nThe prudent course of action is to be aware of the costs described in\nthis item, but not to take the numbers very seriously. Whatever the\ncost of exception handling, you don’t want to pay any more than you\nhave to. To minimize your exception-related costs, compile without\nsupport for exceptions when that is feasible; limit your use of try\nblocks and exception specifications to those locations where you hon-\nestly need them; and throw exceptions only under conditions that are\ntruly exceptional. If you still have performance problems, profile your\nsoftware (see Item 16) to determine if exception support is a contribut-\ning factor. If it is, consider switching to different compilers, ones that\nprovide more efficient implementations of C++’s exception-handling\nfeatures.\n",
      "page_number": 76,
      "chapter_number": 9,
      "summary": "This chapter covers segment 9 (pages 76-97). Key topics include exceptions, exception, and exceptional. Covers function, exception. That function does just what its name suggests: it terminates execu-\ntion of your program.",
      "keywords": [
        "exception",
        "Exceptions",
        "exception specifications",
        "catch",
        "Widget",
        "catch Widget exceptions",
        "Session",
        "function",
        "Item",
        "throw",
        "catch clause",
        "object",
        "exception objects",
        "catch exceptions",
        "Throwing Exceptions Compared"
      ],
      "concepts": [
        "exceptions",
        "exception",
        "exceptional",
        "objects",
        "throws",
        "function",
        "functions",
        "catch",
        "catches",
        "void"
      ],
      "similar_chapters": [
        {
          "book": "Python Distilled",
          "chapter": 10,
          "title": "Segment 10 (pages 79-89)",
          "relevance_score": 0.72,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 37,
          "title": "Segment 37 (pages 741-758)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 11,
          "title": "Segment 11 (pages 88-95)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 36,
          "title": "Segment 36 (pages 324-332)",
          "relevance_score": 0.63,
          "method": "api"
        }
      ]
    },
    {
      "number": 10,
      "title": "Segment 10 (pages 98-107)",
      "start_page": 98,
      "end_page": 107,
      "detection_method": "topic_boundary",
      "content": "Efficiency\nEfficiency\nI harbor a suspicion that someone has performed secret Pavlovian ex-\nperiments on C++ software developers. How else can one explain the\nfact that when the word “efficiency” is mentioned, scores of program-\nmers start to drool?\nIn fact, efficiency is no laughing matter. Programs that are too big or\ntoo slow fail to find acceptance, no matter how compelling their merits.\nThis is perhaps as it should be. Software is supposed to help us do\nthings better, and it’s difficult to argue that slower is better, that de-\nmanding 32 megabytes of memory is better than requiring a mere 16,\nthat chewing up 100 megabytes of disk space is better than swallowing\nonly 50. Furthermore, though some programs take longer and use\nmore memory because they perform more ambitious computations,\ntoo many programs can blame their sorry pace and bloated footprint\non nothing more than bad design and slipshod programming.\nWriting efficient programs in C++ starts with the recognition that C++\nmay well have nothing to do with any performance problems you’ve\nbeen having. If you want to write an efficient C++ program, you must\nfirst be able to write an efficient program. Too many developers over-\nlook this simple truth. Yes, loops may be unrolled by hand and multi-\nplications may be replaced by shift operations, but such micro-tuning\nleads nowhere if the higher-level algorithms you employ are inherently\ninefficient. Do you use quadratic algorithms when linear ones are\navailable? Do you compute the same value over and over? Do you\nsquander opportunities to reduce the average cost of expensive opera-\ntions? If so, you can hardly be surprised if your programs are de-\nscribed like second-rate tourist attractions: worth a look, but only if\nyou’ve got some extra time.\nThe material in this chapter attacks the topic of efficiency from two an-\ngles. The first is language-independent, focusing on things you can do\nin any programming language. C++ provides a particularly appealing\n\n\n82\nItem 16\nimplementation medium for these ideas, because its strong support for\nencapsulation makes it possible to replace inefficient class implemen-\ntations with better algorithms and data structures that support the\nsame interface. \nThe second focus is on C++ itself. High-performance algorithms and\ndata structures are great, but sloppy implementation practices can re-\nduce their effectiveness considerably. The most insidious mistake is\nboth simple to make and hard to recognize: creating and destroying too\nmany objects. Superfluous object constructions and destructions act\nlike a hemorrhage on your program’s performance, with precious\nclock-ticks bleeding away each time an unnecessary object is created\nand destroyed. This problem is so pervasive in C++ programs, I devote\nfour separate items to describing where these objects come from and\nhow you can eliminate them without compromising the correctness of\nyour code.\nPrograms don’t get big and slow only by creating too many objects.\nOther potholes on the road to high performance include library selec-\ntion and implementations of language features. In the items that fol-\nlow, I address these issues, too.\nAfter reading the material in this chapter, you’ll be familiar with sev-\neral principles that can improve the performance of virtually any pro-\ngram you write, you’ll know exactly how to prevent unnecessary\nobjects from creeping into your software, and you’ll have a keener\nawareness of how your compilers behave when generating executables. \nIt’s been said that forewarned is forearmed. If so, think of the informa-\ntion that follows as preparation for battle.\nItem 16: Remember the 80-20 rule.\nThe 80-20 Rule\nThe 80-20 rule states that 80 percent of a program’s resources are\nused by about 20 percent of the code: 80 percent of the runtime is\nspent in approximately 20 percent of the code; 80 percent of the mem-\nory is used by some 20 percent of the code; 80 percent of the disk ac-\ncesses are performed for about 20 percent of the code; 80 percent of\nthe maintenance effort is devoted to around 20 percent of the code.\nThe rule has been repeatedly verified through examinations of count-\nless machines, operating systems, and applications. The 80-20 rule is\nmore than just a catchy phrase; it’s a guideline about system perfor-\nmance that has both wide applicability and a solid empirical basis.\nWhen considering the 80-20 rule, it’s important not to get too hung up\non numbers. Some people favor the more stringent 90-10 rule, and\nthere’s experimental evidence to back that, too. Whatever the precise\n\n\nThe 80-20 Rule\n83\nnumbers, the fundamental point is this: the overall performance of\nyour software is almost always determined by a small part of its con-\nstituent code.\nAs a programmer striving to maximize your software’s performance,\nthe 80-20 rule both simplifies and complicates your life. On one hand,\nthe 80-20 rule implies that most of the time you can produce code\nwhose performance is, frankly, rather mediocre, because 80 percent of\nthe time its efficiency doesn’t affect the overall performance of the sys-\ntem you’re working on. That may not do much for your ego, but it\nshould reduce your stress level a little. On the other hand, the rule im-\nplies that if your software has a performance problem, you’ve got a\ntough job ahead of you, because you not only have to locate the small\npockets of code that are causing the problem, you have to find ways to\nincrease their performance dramatically. Of these tasks, the more\ntroublesome is generally locating the bottlenecks. There are two funda-\nmentally different ways to approach the matter: the way most people\ndo it and the right way.\nThe way most people locate bottlenecks is to guess. Using experience,\nintuition, tarot cards and Ouija boards, rumors or worse, developer\nafter developer solemnly proclaims that a program’s efficiency prob-\nlems can be traced to network delays, improperly tuned memory allo-\ncators, compilers that don’t optimize aggressively enough, or some\nbonehead manager’s refusal to permit assembly language for crucial\ninner loops. Such assessments are generally delivered with a conde-\nscending sneer, and usually both the sneerers and their prognostica-\ntions are flat-out wrong.\nMost programmers have lousy intuition about the performance char-\nacteristics of their programs, because program performance charac-\nteristics tend to be highly unintuitive. As a result, untold effort is\npoured into improving the efficiency of parts of programs that will\nnever have a noticeable effect on their overall behavior. For example,\nfancy algorithms and data structures that minimize computation may\nbe added to a program, but it’s all for naught if the program is I/O-\nbound. Souped-up I/O libraries (see Item 23) may be substituted for\nthe ones shipped with compilers, but there’s not much point if the pro-\ngrams using them are CPU-bound. \nThat being the case, what do you do if you’re faced with a slow program\nor one that uses too much memory? The 80-20 rule means that im-\nproving random parts of the program is unlikely to help very much.\nThe fact that programs tend to have unintuitive performance charac-\nteristics means that trying to guess the causes of performance bottle-\nnecks is unlikely to be much better than just improving random parts\nof your program. What, then, will work?\n\n\n84\nItem 16\nWhat will work is to empirically identify the 20 percent of your program\nthat is causing you heartache, and the way to identify that horrid 20\npercent is to use a program profiler. Not just any profiler will do, how-\never. You want one that directly measures the resources you are inter-\nested in. For example, if your program is too slow, you want a profiler\nthat tells you how much time is being spent in different parts of the\nprogram. That way you can focus on those places where a significant\nimprovement in local efficiency will also yield a significant improve-\nment in overall efficiency. \nProfilers that tell you how many times each statement is executed or\nhow many times each function is called are of limited utility. From a\nperformance point of view, you do not care how many times a state-\nment is executed or a function is called. It is, after all, rather rare to\nencounter a user of a program or a client of a library who complains\nthat too many statements are being executed or too many functions\nare being called. If your software is fast enough, nobody cares how\nmany statements are executed, and if it’s too slow, nobody cares how\nfew. All they care about is that they hate to wait, and if your program\nis making them do it, they hate you, too.\nStill, knowing how often statements are executed or functions are\ncalled can sometimes yield insight into what your software is doing. If,\nfor example, you think you’re creating about a hundred objects of a\nparticular type, it would certainly be worthwhile to discover that you’re\ncalling constructors in that class thousands of times. Furthermore,\nstatement and function call counts can indirectly help you understand\nfacets of your software’s behavior you can’t directly measure. If you\nhave no direct way of measuring dynamic memory usage, for example,\nit may be helpful to know at least how often memory allocation and\ndeallocation functions (e.g., operators new, new[], delete, and de-\nlete[] — see Item 8) are called.\nOf course, even the best of profilers is hostage to the data it’s given to\nprocess. If you profile your program while it’s processing unrepresen-\ntative input data, you’re in no position to complain if the profiler leads\nyou to fine-tune parts of your software — the parts making up some 80\npercent of it — that have no bearing on its usual performance. Remem-\nber that a profiler can only tell you how a program behaved on a par-\nticular run (or set of runs), so if you profile a program using input data\nthat is unrepresentative, you’re going to get back a profile that is\nequally unrepresentative. That, in turn, is likely to lead to you to opti-\nmize your software’s behavior for uncommon uses, and the overall im-\npact on common uses may even be negative.\nThe best way to guard against these kinds of pathological results is to\nprofile your software using as many data sets as possible. Moreover,\n\n\nLazy Evaluation\n85\nyou must ensure that each data set is representative of how the soft-\nware is used by its clients (or at least its most important clients). It is\nusually easy to acquire representative data sets, because many clients\nare happy to let you use their data when profiling. After all, you’ll then\nbe tuning your software to meet their needs, and that can only be good\nfor both of you.\nItem 17: Consider using lazy evaluation.\nLazy Evaluation\nFrom the perspective of efficiency, the best computations are those you\nnever perform at all. That’s fine, but if you don’t need to do something,\nwhy would you put code in your program to do it in the first place? And\nif you do need to do something, how can you possibly avoid executing\nthe code that does it?\nThe key is to be lazy. \nRemember when you were a child and your parents told you to clean\nyour room? If you were anything like me, you’d say “Okay,” then\npromptly go back to what you were doing. You would not clean your\nroom. In fact, cleaning your room would be the last thing on your mind\n— until you heard your parents coming down the hall to confirm that\nyour room had, in fact, been cleaned. Then you’d sprint to your room\nand get to work as fast as you possibly could. If you were lucky, your\nparents would never check, and you’d avoid all the work cleaning your\nroom normally entails.\nIt turns out that the same delay tactics that work for a five year old\nwork for a C++ programmer. In Computer Science, however, we dignify\nsuch procrastination with the name lazy evaluation. When you employ\nlazy evaluation, you write your classes in such a way that they defer\ncomputations until the results of those computations are required. If\nthe results are never required, the computations are never performed,\nand neither your software’s clients nor your parents are any the wiser.\nPerhaps you’re wondering exactly what I’m talking about. Perhaps an\nexample would help. Well, lazy evaluation is applicable in an enormous\nvariety of application areas, so I’ll describe four.\nReference Counting\nConsider this code:\nclass String { ... };\n// a string class (the standard\n// string type may be implemented\n// as described below, but it\n// doesn’t have to be)\n\n\n86\nItem 17\nString s1 = \"Hello\";\nString s2 = s1;\n// call String copy ctor\nA common implementation for the String copy constructor would re-\nsult in s1 and s2 each having its own copy of “Hello” after s2 is ini-\ntialized with s1. Such a copy constructor would incur a relatively large\nexpense, because it would have to make a copy of s1’s value to give to\ns2, and that would typically entail allocating heap memory via the new\noperator (see Item 8) and calling strcpy to copy the data in s1 into the\nmemory allocated by s2. This is eager evaluation: making a copy of s1\nand putting it into s2 just because the String copy constructor was\ncalled. At this point, however, there has been no real need for s2 to\nhave a copy of the value, because s2 hasn’t been used yet.\nThe lazy approach is a lot less work. Instead of giving s2 a copy of s1’s\nvalue, we have s2 share s1’s value. All we have to do is a little book-\nkeeping so we know who’s sharing what, and in return we save the\ncost of a call to new and the expense of copying anything. The fact that\ns1 and s2 are sharing a data structure is transparent to clients, and it\ncertainly makes no difference in statements like the following, because\nthey only read values, they don’t write them:\ncout << s1;\n// read s1’s value\ncout << s1 + s2;\n// read s1’s and s2’s values\nIn fact, the only time the sharing of values makes a difference is when\none or the other string is modified; then it’s important that only one\nstring be changed, not both. In this statement,\ns2.convertToUpperCase();\nit’s crucial that only s2’s value be changed, not s1’s also. \nTo handle statements like this, we have to implement String’s con-\nvertToUpperCase function so that it makes a copy of s2’s value and\nmakes that value private to s2 before modifying it. Inside convert-\nToUpperCase, we can be lazy no longer: we have to make a copy of s2’s\n(shared) value for s2’s private use. On the other hand, if s2 is never\nmodified, we never have to make a private copy of its value. It can con-\ntinue to share a value as long as it exists. If we’re lucky, s2 will never\nbe modified, in which case we’ll never have to expend the effort to give\nit its own value.\nThe details on making this kind of value sharing work (including all the\ncode) are provided in Item 29, but the idea is lazy evaluation: don’t\nbother to make a copy of something until you really need one. Instead,\nbe lazy — use someone else’s copy as long as you can get away with it.\nIn some application areas, you can often get away with it forever.\n\n\nLazy Evaluation\n87\nDistinguishing Reads from Writes\nPursuing the example of reference-counting strings a bit further, we\ncome upon a second way in which lazy evaluation can help us. Con-\nsider this code:\nString s = \"Homer’s Iliad\";\n// Assume s is a \n// reference-counted string\n...\ncout << s[3];\n// call operator[] to read s[3]\ns[3] = ’x’;\n// call operator[] to write s[3]\nThe first call to operator[] is to read part of a string, but the second\ncall is to perform a write. We’d like to be able to distinguish the read\ncall from the write, because reading a reference-counted string is\ncheap, but writing to such a string may require splitting off a new copy\nof the string’s value prior to the write.\nThis puts us in a difficult implementation position. To achieve what we\nwant, we need to do different things inside operator[] (depending on\nwhether it’s being called to perform a read or a write). How can we de-\ntermine whether operator[] has been called in a read or a write con-\ntext? The brutal truth is that we can’t. By using lazy evaluation and\nproxy classes as described in Item 30, however, we can defer the deci-\nsion on whether to take read actions or write actions until we can de-\ntermine which is correct.\nLazy Fetching\nAs a third example of lazy evaluation, imagine you’ve got a program\nthat uses large objects containing many constituent fields. Such ob-\njects must persist across program runs, so they’re stored in a data-\nbase. Each object has a unique object identifier that can be used to\nretrieve the object from the database:\nclass LargeObject {\n// large persistent objects\npublic:\nLargeObject(ObjectID id);\n// restore object from disk\nconst string& field1() const;\n// value of field 1\nint field2() const;\n// value of field 2\ndouble field3() const;\n// ...\nconst string& field4() const;\nconst string& field5() const;\n...\n};\nNow consider the cost of restoring a LargeObject from disk:\n\n\n88\nItem 17\nvoid restoreAndProcessObject(ObjectID id)\n{\nLargeObject object(id);\n// restore object\n...\n}\nBecause LargeObject instances are big, getting all the data for such\nan object might be a costly database operation, especially if the data\nmust be retrieved from a remote database and pushed across a net-\nwork. In some cases, the cost of reading all that data would be unnec-\nessary. For example, consider this kind of application:\nvoid restoreAndProcessObject(ObjectID id)\n{\nLargeObject object(id);\nif (object.field2() == 0) {\ncout << \"Object \" << id << \": null field2.\\n\";\n}\n}\nHere only the value of field2 is required, so any effort spent setting\nup the other fields is wasted.\nThe lazy approach to this problem is to read no data from disk when a\nLargeObject object is created. Instead, only the “shell” of an object is\ncreated, and data is retrieved from the database only when that partic-\nular data is needed inside the object. Here’s one way to implement this\nkind of “demand-paged” object initialization:\nclass LargeObject {\npublic:\nLargeObject(ObjectID id);\nconst string& field1() const;\nint field2() const;\ndouble field3() const;\nconst string& field4() const;\n...\nprivate:\nObjectID oid;\nmutable string *field1Value;\n// see below for a\nmutable int *field2Value;\n// discussion of \"mutable\"\nmutable double *field3Value;\nmutable string *field4Value;\n...\n};\n\n\nLazy Evaluation\n89\nLargeObject::LargeObject(ObjectID id)\n: oid(id), field1Value(0), field2Value(0), field3Value(0), ...\n{}\nconst string& LargeObject::field1() const\n{\nif (field1Value == 0) {\nread the data for field 1 from the database and make\nfield1Value point to it;\n}\nreturn *field1Value;\n}\nEach field in the object is represented as a pointer to the necessary\ndata, and the LargeObject constructor initializes each pointer to null.\nSuch null pointers signify fields that have not yet been read from the\ndatabase. Each LargeObject member function must check the state\nof a field’s pointer before accessing the data it points to. If the pointer\nis null, the corresponding data must be read from the database before\nperforming any operations on that data.\nWhen implementing lazy fetching, you must confront the problem that\nnull pointers may need to be initialized to point to real data from inside\nany member function, including const member functions like field1.\nHowever, compilers get cranky when you try to modify data members\ninside const member functions, so you’ve got to find a way to say, “It’s\nokay, I know what I’m doing.” The best way to say that is to declare the\npointer fields mutable, which means they can be modified inside any\nmember function, even inside const member functions. That’s why\nthe fields inside LargeObject above are declared mutable.\nThe mutable keyword is a relatively recent addition to C++, so it’s pos-\nsible your vendors don’t yet support it. If not, you’ll need to find an-\nother way to convince your compilers to let you modify data members\ninside const member functions. One workable strategy is the “fake\nthis” approach, whereby you create a pointer-to-non-const that\npoints to the same object as this does. When you want to modify a\ndata member, you access it through the “fake this” pointer:\nclass LargeObject {\npublic:\nconst string& field1() const;\n// unchanged\n...\nprivate:\nstring *field1Value;\n// not declared mutable\n...\n// so that older \n};\n// compilers will accept it\n\n\n90\nItem 17\nconst string& LargeObject::field1() const\n{\n// declare a pointer, fakeThis, that points where this\n// does, but where the constness of the object has been\n// cast away\nLargeObject * const fakeThis =\nconst_cast<LargeObject* const>(this);\nif (field1Value == 0) {\nfakeThis->field1Value =\n// this assignment is OK,\nthe appropriate data\n// because what fakeThis\nfrom the database;\n// points to isn’t const\n}\nreturn *field1Value;\n}\nThis function employs a const_cast (see Item 2) to cast away the\nconstness of *this. If your compilers don’t support const_cast, you\ncan use an old C-style cast:\n// Use of old-style cast to help emulate mutable\nconst string& LargeObject::field1() const\n{\nLargeObject * const fakeThis = (LargeObject* const)this;\n...\n// as above\n}\nLook again at the pointers inside LargeObject. Let’s face it, it’s te-\ndious and error-prone to have to initialize all those pointers to null,\nthen test each one before use. Fortunately, such drudgery can be au-\ntomated through the use of smart pointers, which you can read about\nin Item 28. If you use smart pointers inside LargeObject, you’ll also\nfind you no longer need to declare the pointers mutable. Alas, it’s only\na temporary respite, because you’ll wind up needing mutable once you\nsit down to implement the smart pointer classes. Think of it as conser-\nvation of inconvenience.\nLazy Expression Evaluation\nA final example of lazy evaluation comes from numerical applications.\nConsider this code:\ntemplate<class T>\nclass Matrix { ... };\n// for homogeneous matrices\nMatrix<int> m1(1000, 1000);\n// a 1000 by 1000 matrix\nMatrix<int> m2(1000, 1000);\n// ditto\n...\nMatrix<int> m3 = m1 + m2;\n// add m1 and m2\n",
      "page_number": 98,
      "chapter_number": 10,
      "summary": "The material in this chapter attacks the topic of efficiency from two an-\ngles Key topics include performed, performance, and objects. How else can one explain the\nfact that when the word “efficiency” is mentioned, scores of program-\nmers start to drool.",
      "keywords": [
        "const",
        "Lazy Evaluation",
        "String",
        "const string",
        "data",
        "program",
        "LargeObject",
        "Lazy",
        "object",
        "Item",
        "Evaluation",
        "80-20 rule",
        "performance",
        "copy",
        "const member functions"
      ],
      "concepts": [
        "performed",
        "performance",
        "objects",
        "fields",
        "program",
        "programming",
        "data",
        "string",
        "strings",
        "lazy"
      ],
      "similar_chapters": [
        {
          "book": "Python Architecture Patterns",
          "chapter": 14,
          "title": "[ 465 ]",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Python Microservices Development",
          "chapter": 22,
          "title": "Segment 22 (pages 175-182)",
          "relevance_score": 0.48,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.47,
          "method": "api"
        },
        {
          "book": "AI Engineering Building Applications",
          "chapter": 19,
          "title": "Segment 19 (pages 375-397)",
          "relevance_score": 0.46,
          "method": "api"
        },
        {
          "book": "AI Engineering Building Applications",
          "chapter": 39,
          "title": "Segment 39 (pages 789-807)",
          "relevance_score": 0.45,
          "method": "api"
        }
      ]
    },
    {
      "number": 11,
      "title": "Segment 11 (pages 108-115)",
      "start_page": 108,
      "end_page": 115,
      "detection_method": "topic_boundary",
      "content": "Lazy Evaluation\n91\nThe usual implementation of operator+ would use eager evaluation;\nin this case it would compute and return the sum of m1 and m2. That’s\na fair amount of computation (1,000,000 additions), and of course\nthere’s the cost of allocating the memory to hold all those values, too. \nThe lazy evaluation strategy says that’s way too much work, so it\ndoesn’t do it. Instead, it sets up a data structure inside m3 that indi-\ncates that m3’s value is the sum of m1 and m2. Such a data structure\nmight consist of nothing more than a pointer to each of m1 and m2, plus\nan enum indicating that the operation on them is addition. Clearly, it’s\ngoing to be faster to set up this data structure than to add m1 and m2,\nand it’s going to use a lot less memory, too.\nSuppose that later in the program, before m3 has been used, this code\nis executed:\nMatrix<int> m4(1000, 1000);\n...\n// give m4 some values\nm3 = m4 * m1;\nNow we can forget all about m3 being the sum of m1 and m2 (and\nthereby save the cost of the computation), and in its place we can start\nremembering that m3 is the product of m4 and m1. Needless to say, we\ndon’t perform the multiplication. Why bother? We’re lazy, remember?\nThis example looks contrived, because no good programmer would\nwrite a program that computed the sum of two matrices and failed to\nuse it, but it’s not as contrived as it seems. No good programmer would\ndeliberately compute a value that’s not needed, but during mainte-\nnance, it’s not uncommon for a programmer to modify the paths\nthrough a program in such a way that a formerly useful computation\nbecomes unnecessary. The likelihood of that happening is reduced by\ndefining objects immediately prior to use, but it’s still a problem that\noccurs from time to time. \nNevertheless, if that were the only time lazy evaluation paid off, it\nwould hardly be worth the trouble. A more common scenario is that we\nneed only part of a computation. For example, suppose we use m3 as\nfollows after initializing it to the sum of m1 and m2:\ncout << m3[4];\n// print the 4th row of m3\nClearly we can be completely lazy no longer — we’ve got to compute the\nvalues in the fourth row of m3. But let’s not be overly ambitious, either.\nThere’s no reason we have to compute any more than the fourth row of\nm3; the remainder of m3 can remain uncomputed until it’s actually\nneeded. With luck, it never will be.\n\n\n92\nItem 17\nHow likely are we to be lucky? Experience in the domain of matrix\ncomputations suggests the odds are in our favor. In fact, lazy evalua-\ntion lies behind the wonder that is APL. APL was developed in the\n1960s for interactive use by people who needed to perform matrix-\nbased calculations. Running on computers that had less computa-\ntional horsepower than the chips now found in high-end microwave\novens, APL was seemingly able to add, multiply, and even divide large\nmatrices instantly! Its trick was lazy evaluation. The trick was usually\neffective, because APL users typically added, multiplied, or divided ma-\ntrices not because they needed the entire resulting matrix, but only be-\ncause they needed a small part of it. APL employed lazy evaluation to\ndefer its computations until it knew exactly what part of a result ma-\ntrix was needed, then it computed only that part. In practice, this al-\nlowed users to perform computationally intensive tasks interactively in\nan environment where the underlying machine was hopelessly inade-\nquate for an implementation employing eager evaluation. Machines are\nfaster today, but data sets are bigger and users less patient, so many\ncontemporary matrix libraries continue to take advantage of lazy eval-\nuation.\nTo be fair, laziness sometimes fails to pay off. If m3 is used in this way,\ncout << m3;\n// print out all of m3\nthe jig is up and we’ve got to compute a complete value for m3. Simi-\nlarly, if one of the matrices on which m3 is dependent is about to be\nmodified, we have to take immediate action:\nm3 = m1 + m2;\n// remember that m3 is the\n// sum of m1 and m2\nm1 = m4;\n// now m3 is the sum of m2\n// and the OLD value of m1!\nHere we’ve got to do something to ensure that the assignment to m1\ndoesn’t change m3. Inside the Matrix<int> assignment operator, we\nmight compute m3’s value prior to changing m1 or we might make a\ncopy of the old value of m1 and make m3 dependent on that, but we\nhave to do something to guarantee that m3 has the value it’s supposed\nto have after m1 has been the target of an assignment. Other functions\nthat might modify a matrix must be handled in a similar fashion.\nBecause of the need to store dependencies between values; to maintain\ndata structures that can store values, dependencies, or a combination\nof the two; and to overload operators like assignment, copying, and ad-\ndition, lazy evaluation in a numerical domain is a lot of work. On the\nother hand, it often ends up saving significant amounts of time and\nspace during program runs, and in many applications, that’s a payoff\nthat easily justifies the significant effort lazy evaluation requires.\n\n\nAmortizing the Cost of Expected Computations\n93\nSummary\nThese four examples show that lazy evaluation can be useful in a vari-\nety of domains: to avoid unnecessary copying of objects, to distinguish\nreads from writes using operator[], to avoid unnecessary reads from\ndatabases, and to avoid unnecessary numerical computations. Never-\ntheless, it’s not always a good idea. Just as procrastinating on your\nclean-up chores won’t save you any work if your parents always check\nup on you, lazy evaluation won’t save your program any work if all your\ncomputations are necessary. Indeed, if all your computations are es-\nsential, lazy evaluation may slow you down and increase your use of\nmemory, because, in addition to having to do all the computations you\nwere hoping to avoid, you’ll also have to manipulate the fancy data\nstructures needed to make lazy evaluation possible in the first place.\nLazy evaluation is only useful when there’s a reasonable chance your\nsoftware will be asked to perform computations that can be avoided.\nThere’s nothing about lazy evaluation that’s specific to C++. The tech-\nnique can be applied in any programming language, and several lan-\nguages — notably APL, some dialects of Lisp, and virtually all dataflow\nlanguages — embrace the idea as a fundamental part of the language.\nMainstream programming languages employ eager evaluation, how-\never, and C++ is mainstream. Yet C++ is particularly suitable as a ve-\nhicle for user-implemented lazy evaluation, because its support for\nencapsulation makes it possible to add lazy evaluation to a class with-\nout clients of that class knowing it’s been done. \nLook again at the code fragments used in the above examples, and you\ncan verify that the class interfaces offer no hints about whether eager\nor lazy evaluation is used by the classes. That means it’s possible to\nimplement a class using a straightforward eager evaluation strategy,\nbut then, if your profiling investigations (see Item 16) show that class’s\nimplementation is a performance bottleneck, you can replace its im-\nplementation with one based on lazy evaluation. The only change your\nclients will see (after recompilation or relinking) is improved perfor-\nmance. That’s the kind of software enhancement clients love, one that\ncan make you downright proud to be lazy.\nItem 18: Amortize the cost of expected computations.\nAmortizing the Cost of Expected Computations\nIn Item 17, I extolled the virtues of laziness, of putting things off as\nlong as possible, and I explained how laziness can improve the effi-\nciency of your programs. In this item, I adopt a different stance. Here,\nlaziness has no place. I now encourage you to improve the perfor-\nmance of your software by having it do more than it’s asked to do. The\n\n\n94\nItem 18\nphilosophy of this item might be called over-eager evaluation: doing\nthings before you’re asked to do them.\nConsider, for example, a template for classes representing large collec-\ntions of numeric data:\ntemplate<class NumericalType>\nclass DataCollection {\npublic:\nNumericalType min() const;\nNumericalType max() const;\nNumericalType avg() const;\n...\n};\nAssuming the min, max, and avg functions return the current mini-\nmum, maximum, and average values of the collection, there are three\nways in which these functions can be implemented. Using eager eval-\nuation, we’d examine all the data in the collection when min, max, or\navg was called, and we’d return the appropriate value. Using lazy eval-\nuation, we’d have the functions return data structures that could be\nused to determine the appropriate value whenever the functions’ re-\nturn values were actually used. Using over-eager evaluation, we’d keep\ntrack of the running minimum, maximum, and average values of the\ncollection, so when min, max, or avg was called, we’d be able to return\nthe correct value immediately — no computation would be required. If\nmin, max, and avg were called frequently, we’d be able to amortize the\ncost of keeping track of the collection’s minimum, maximum, and av-\nerage values over all the calls to those functions, and the amortized\ncost per call would be lower than with eager or lazy evaluation.\nThe idea behind over-eager evaluation is that if you expect a computa-\ntion to be requested frequently, you can lower the average cost per re-\nquest by designing your data structures to handle the requests\nespecially efficiently. \nOne of the simplest ways to do this is by caching values that have al-\nready been computed and are likely to be needed again. For example,\nsuppose you’re writing a program to provide information about em-\nployees, and one of the pieces of information you expect to be re-\nquested frequently is an employee’s cubicle number. Further suppose\nthat employee information is stored in a database, but, for most appli-\ncations, an employee’s cubicle number is irrelevant, so the database is\nnot optimized to find it. To avoid having your specialized application\nunduly stress the database with repeated lookups of employee cubicle\nnumbers, you could write a findCubicleNumber function that caches\nthe cubicle numbers it looks up. Subsequent requests for cubicle\n\n\nAmortizing the Cost of Expected Computations\n95\nnumbers that have already been retrieved can then be satisfied by con-\nsulting the cache instead of querying the database. \nHere’s one way to implement findCubicleNumber; it uses a map object\nfrom the Standard Template Library (the “STL” — see Item 35) as a\nlocal cache:\nint findCubicleNumber(const string& employeeName)\n{\n// define a static map to hold (employee name, cubicle number)\n// pairs. This map is the local cache.\ntypedef map<string, int> CubicleMap;\nstatic CubicleMap cubes;\n// try to find an entry for employeeName in the cache;\n// the STL iterator \"it\" will then point to the found \n// entry, if there is one (see Item 35 for details)\nCubicleMap::iterator it = cubes.find(employeeName);\n// \"it\"’s value will be cubes.end() if no entry was\n// found (this is standard STL behavior). If this is \n// the case, consult the database for the cubicle \n// number, then add it to the cache\nif (it == cubes.end()) {\nint cubicle = \nthe result of looking up employeeName’s cubicle\nnumber in the database;\ncubes[employeeName] = cubicle;\n// add the pair\n// (employeeName, cubicle)\n// to the cache\nreturn cubicle;\n}\nelse {\n// \"it\" points to the correct cache entry, which is a\n// (employee name, cubicle number) pair. We want only\n// the second component of this pair, and the member\n// \"second\" will give it to us\nreturn (*it).second;\n}\n}\nTry not to get bogged down in the details of the STL code (which will be\nclearer after you’ve read Item 35). Instead, focus on the general strat-\negy embodied by this function. That strategy is to use a local cache to\nreplace comparatively expensive database queries with comparatively\ninexpensive lookups in an in-memory data structure. Provided we’re\ncorrect in assuming that cubicle numbers will frequently be requested\nmore than once, the use of a cache in findCubicleNumber should re-\nduce the average cost of returning an employee’s cubicle number.\n\n\n96\nItem 18\n(One detail of the code requires explanation. The final statement re-\nturns (*it).second instead of the more conventional it->second.\nWhy? The answer has to do with the conventions followed by the STL.\nIn brief, the iterator it is an object, not a pointer, so there is no guar-\nantee that “->” can be applied to it.† The STL does require that “.”\nand “*” be valid for iterators, however, so (*it).second, though syn-\ntactically clumsy, is guaranteed to work.)\nCaching is one way to amortize the cost of anticipated computations.\nPrefetching is another. You can think of prefetching as the computa-\ntional equivalent of a discount for buying in bulk. Disk controllers, for\nexample, read entire blocks or sectors of data when they read from\ndisk, even if a program asks for only a small amount of data. That’s be-\ncause it’s faster to read a big chunk once than to read two or three\nsmall chunks at different times. Furthermore, experience has shown\nthat if data in one place is requested, it’s quite common to want nearby\ndata, too. This is the infamous locality of reference phenomenon, and\nsystems designers rely on it to justify disk caches, memory caches for\nboth instructions and data, and instruction prefetches.\nExcuse me? You say you don’t worry about such low-level things as\ndisk controllers or CPU caches? No problem. Prefetching can yield div-\nidends for even one as high-level as you. Imagine, for example, you’d\nlike to implement a template for dynamic arrays, i.e., arrays that start\nwith a size of one and automatically extend themselves so that all non-\nnegative indices are valid:\ntemplate<class T>\n// template for dynamic\nclass DynArray { ... };\n// array-of-T classes\nDynArray<double> a;\n// at this point, only a[0]\n// is a legitimate array\n// element\na[22] = 3.5;\n// a is automatically\n// extended: valid indices\n// are now 0-22\na[32] = 0;\n// a extends itself again;\n// now a[0]-a[32] are valid\nHow does a DynArray object go about extending itself when it needs\nto? A straightforward strategy would be to allocate only as much addi-\ntional memory as needed, something like this:\n† In July 1995, the ISO/ANSI committee standardizing C++ added a requirement that\nmost STL iterators support the “->” operator, so it->second should now work. Some\nSTL implementations fail to satisfy this requirement, however, so (*it).second is\nstill the more portable construct.\n\n\nAmortizing the Cost of Expected Computations\n97\ntemplate<class T>\nT& DynArray<T>::operator[](int index)\n{\nif (index < 0) {\nthrow an exception;\n// negative indices are\n}\n// still invalid\nif (index > the current maximum index value) {\ncall new to allocate enough additional memory so that \nindex is valid;\n}\nreturn the indexth element of the array;\n}\nThis approach simply calls new each time it needs to increase the size\nof the array, but calls to new invoke operator new (see Item 8), and\ncalls to operator new (and operator delete) are usually expensive.\nThat’s because they typically result in calls to the underlying operating\nsystem, and system calls are generally slower than are in-process\nfunction calls. As a result, we’d like to make as few system calls as pos-\nsible.\nAn over-eager evaluation strategy employs this reasoning: if we have to\nincrease the size of the array now to accommodate index i, the locality\nof reference principle suggests we’ll probably have to increase it in the\nfuture to accommodate some other index a bit larger than i. To avoid\nthe cost of the memory allocation for the second (anticipated) expan-\nsion, we’ll increase the size of the DynArray now by more than is re-\nquired to make i valid, and we’ll hope that future expansions occur\nwithin the range we have thereby provided for. For example, we could\nwrite DynArray::operator[] like this:\ntemplate<class T>\nT& DynArray<T>::operator[](int index)\n{\nif (index < 0) throw an exception;\nif (index > the current maximum index value) {\nint diff = index - the current maximum index value;\ncall new to allocate enough additional memory so that \nindex+diff is valid;\n}\nreturn the indexth element of the array;\n}\nThis function allocates twice as much memory as needed each time the\narray must be extended. If we look again at the usage scenario we saw\nearlier, we note that the DynArray must allocate additional memory\nonly once, even though its logical size is extended twice:\n\n\n98\nItem 19\nDynArray<double> a;\n// only a[0] is valid\na[22] = 3.5;\n// new is called to expand\n// a’s storage through\n// index 44; a’s logical\n// size becomes 23\na[32] = 0;\n// a’s logical size is\n// changed to allow a[32],\n// but new isn’t called\nIf a needs to be extended again, that extension, too, will be inexpen-\nsive, provided the new maximum index is no greater than 44.\nThere is a common theme running through this Item, and that’s that\ngreater speed can often be purchased at a cost of increased memory\nusage. Keeping track of running minima, maxima, and averages re-\nquires extra space, but it saves time. Caching results necessitates\ngreater memory usage but reduces the time needed to regenerate the\nresults once they’ve been cached. Prefetching demands a place to put\nthe things that are prefetched, but it reduces the time needed to access\nthose things. The story is as old as Computer Science: you can often\ntrade space for time. (Not always, however. Using larger objects means\nfewer fit on a virtual memory or cache page. In rare cases, making ob-\njects bigger reduces the performance of your software, because your\npaging activity increases, your cache hit rate decreases, or both. How\ndo you find out if you’re suffering from such problems? You profile,\nprofile, profile (see Item 16).)\nThe advice I proffer in this Item — that you amortize the cost of antic-\nipated computations through over-eager strategies like caching and\nprefetching — is not contradictory to the advice on lazy evaluation I\nput forth in Item 17. Lazy evaluation is a technique for improving the\nefficiency of programs when you must support operations whose re-\nsults are not always needed. Over-eager evaluation is a technique for\nimproving the efficiency of programs when you must support opera-\ntions whose results are almost always needed or whose results are\noften needed more than once. Both are more difficult to implement\nthan run-of-the-mill eager evaluation, but both can yield significant\nperformance improvements in programs whose behavioral character-\nistics justify the extra programming effort.\nItem 19: Understand the origin of temporary objects.\nTemporary Objects\nWhen programmers speak amongst themselves, they often refer to\nvariables that are needed for only a short while as “temporaries.” For\nexample, in this swap routine,\n",
      "page_number": 108,
      "chapter_number": 11,
      "summary": "This chapter covers segment 11 (pages 108-115). Key topics include caching, caches, and compute. Instead, it sets up a data structure inside m3 that indi-\ncates that m3’s value is the sum of m1 and m2.",
      "keywords": [
        "Lazy Evaluation",
        "Evaluation",
        "Lazy",
        "Item",
        "cost",
        "computations",
        "Expected Computations",
        "data",
        "index",
        "needed",
        "cubicle",
        "eager evaluation",
        "Cost of Expected",
        "over-eager evaluation",
        "cubicle number"
      ],
      "concepts": [
        "caching",
        "caches",
        "compute",
        "computation",
        "computations",
        "lazy",
        "laziness",
        "values",
        "item",
        "operator"
      ],
      "similar_chapters": [
        {
          "book": "AI Engineering Building Applications",
          "chapter": 40,
          "title": "Segment 40 (pages 808-829)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 18,
          "title": "Segment 18 (pages 354-371)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 33,
          "title": "Segment 33 (pages 662-682)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 37,
          "title": "Segment 37 (pages 343-350)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 38,
          "title": "Segment 38 (pages 351-358)",
          "relevance_score": 0.57,
          "method": "api"
        }
      ]
    },
    {
      "number": 12,
      "title": "Segment 12 (pages 116-123)",
      "start_page": 116,
      "end_page": 123,
      "detection_method": "topic_boundary",
      "content": "Temporary Objects\n99\ntemplate<class T>\nvoid swap(T& object1, T& object2)\n{\nT temp = object1;\nobject1 = object2;\nobject2 = temp;\n}\nit’s common to call temp a “temporary.” As far as C++ is concerned,\nhowever, temp is not a temporary at all. It’s simply an object local to a\nfunction. \nTrue temporary objects in C++ are invisible — they don’t appear in\nyour source code. They arise whenever a non-heap object is created\nbut not named. Such unnamed objects usually arise in one of two sit-\nuations: when implicit type conversions are applied to make function\ncalls succeed and when functions return objects. It’s important to un-\nderstand how and why these temporary objects are created and de-\nstroyed, because the attendant costs of their construction and\ndestruction can have a noticeable impact on the performance of your\nprograms.\nConsider first the case in which temporary objects are created to make\nfunction calls succeed. This happens when the type of object passed to\na function is not the same as the type of the parameter to which it is\nbeing bound. For example, consider a function that counts the number\nof occurrences of a character in a string:\n// returns the number of occurrences of ch in str\nsize_t countChar(const string& str, char ch);\nchar buffer[MAX_STRING_LEN];\nchar c;\n// read in a char and a string; use setw to avoid \n// overflowing buffer when reading the string\ncin >> c >> setw(MAX_STRING_LEN) >> buffer;\ncout << \"There are \" << countChar(buffer, c) \n<< \" occurrences of the character \" << c\n<< \" in \" << buffer << endl;\nLook at the call to countChar. The first argument passed is a char ar-\nray, but the corresponding function parameter is of type const\nstring&. This call can succeed only if the type mismatch can be elim-\ninated, and your compilers will be happy to eliminate it by creating a\ntemporary object of type string. That temporary object is initialized\nby calling the string constructor with buffer as its argument. The\nstr parameter of countChar is then bound to this temporary string\nobject. When the statement containing the call to countChar finishes\nexecuting, the temporary object is automatically destroyed.\n\n\n100\nItem 19\nConversions such as these are convenient (though dangerous — see\nItem 5), but from an efficiency point of view, the construction and de-\nstruction of a temporary string object is an unnecessary expense.\nThere are two general ways to eliminate it. One is to redesign your code\nso conversions like these can’t take place. That strategy is examined in\nItem 5. An alternative tack is to modify your software so that the con-\nversions are unnecessary. Item 21 describes how you can do that.\nThese conversions occur only when passing objects by value or when\npassing to a reference-to-const parameter. They do not occur when\npassing an object to a reference-to-non-const parameter. Consider\nthis function:\nvoid uppercasify(string& str);\n// changes all chars in\n// str to upper case\nIn the character-counting example, a char array could be successfully\npassed to countChar, but here, trying to call uppercasify with a\nchar array fails:\nchar subtleBookPlug[] = \"Effective C++\";\nuppercasify(subtleBookPlug);\n// error!\nNo temporary is created to make the call succeed. Why not?\nSuppose a temporary were created. Then the temporary would be\npassed to uppercasify, which would modify the temporary so its\ncharacters were in upper case. But the actual argument to the func-\ntion call — subtleBookPlug — would not be affected; only the tempo-\nrary string object generated from subtleBookPlug would be\nchanged. Surely this is not what the programmer intended. That pro-\ngrammer passed subtleBookPlug to uppercasify, and that pro-\ngrammer expected subtleBookPlug to be modified. Implicit type\nconversion for references-to-non-const objects, then, would allow\ntemporary objects to be changed when programmers expected non-\ntemporary objects to be modified. That’s why the language prohibits\nthe generation of temporaries for non-const reference parameters.\nReference-to-const parameters don’t suffer from this problem, be-\ncause such parameters, by virtue of being const, can’t be changed.\nThe second set of circumstances under which temporary objects are\ncreated is when a function returns an object. For instance, operator+\nmust return an object that represents the sum of its operands. Given\na type Number, for example, operator+ for that type would be declared\nlike this:\nconst Number operator+(const Number& lhs,\nconst Number& rhs);\n\n\nThe Return Value Optimization\n101\nThe return value of this function is a temporary, because it has no\nname: it’s just the function’s return value. You must pay to construct\nand destruct this object each time you call operator+. (For an expla-\nnation of why the return value is const, see Item 6.)\nAs usual, you don’t want to incur this cost. For this particular func-\ntion, you can avoid paying by switching to a similar function, opera-\ntor+=; Item 22 tells you about this transformation. For most functions\nthat return objects, however, switching to a different function is not an\noption and there is no way to avoid the construction and destruction\nof the return value. At least, there’s no way to avoid it conceptually. Be-\ntween concept and reality, however, lies a murky zone called optimiza-\ntion, and sometimes you can write your object-returning functions in a\nway that allows your compilers to optimize temporary objects out of ex-\nistence. Of these optimizations, the most common and useful is the re-\nturn value optimization, which is the subject of Item 20. \nThe bottom line is that temporary objects can be costly, so you want to\neliminate them whenever you can. More important than this, however,\nis to train yourself to look for places where temporary objects may be\ncreated. Anytime you see a reference-to-const parameter, the possibil-\nity exists that a temporary will be created to bind to that parameter.\nAnytime you see a function returning an object, a temporary will be\ncreated (and later destroyed). Learn to look for such constructs, and\nyour insight into the cost of “behind the scenes” compiler actions will\nmarkedly improve.\nItem 20: Facilitate the return value optimization.\nThe Return Value Optimization\nA function that returns an object is frustrating to efficiency aficiona-\ndos, because the by-value return, including the constructor and de-\nstructor calls it implies (see Item 19), cannot be eliminated. The\nproblem is simple: a function either has to return an object in order to\noffer correct behavior or it doesn’t. If it does, there’s no way to get rid\nof the object being returned. Period.\nConsider the operator* function for rational numbers:\n\n\n102\nItem 20\nclass Rational {\npublic:\nRational(int numerator = 0, int denominator = 1);\n...\nint numerator() const;\nint denominator() const;\n};\n// For an explanation of why the return value is const,\n// see Item 6\nconst Rational operator*(const Rational& lhs,\nconst Rational& rhs);\nWithout even looking at the code for operator*, we know it must re-\nturn an object, because it returns the product of two arbitrary num-\nbers. These are arbitrary numbers. How can operator* possibly avoid\ncreating a new object to hold their product? It can’t, so it must create\na new object and return it. C++ programmers have nevertheless ex-\npended Herculean efforts in a search for the legendary elimination of\nthe by-value return. \nSometimes people return pointers, which leads to this syntactic trav-\nesty:\n// an unreasonable way to avoid returning an object\nconst Rational * operator*(const Rational& lhs,\nconst Rational& rhs);\nRational a = 10;\nRational b(1, 2);\nRational c = *(a * b);\n// Does this look \"natural\"\n// to you?\nIt also raises a question. Should the caller delete the pointer returned\nby the function? The answer is usually yes, and that usually leads to\nresource leaks.\nOther developers return references. That yields an acceptable syntax,\n// a dangerous (and incorrect) way to avoid returning\n// an object\nconst Rational& operator*(const Rational& lhs,\nconst Rational& rhs);\nRational a = 10;\nRational b(1, 2);\nRational c = a * b;\n// looks perfectly reasonable\nbut such functions can’t be implemented in a way that behaves cor-\nrectly. A common attempt looks like this:\n\n\nThe Return Value Optimization\n103\n// another dangerous (and incorrect) way to avoid \n// returning an object\nconst Rational& operator*(const Rational& lhs,\nconst Rational& rhs)\n{\nRational result(lhs.numerator() * rhs.numerator(),\nlhs.denominator() * rhs.denominator());\nreturn result;\n}\nThis function returns a reference to an object that no longer exists. In\nparticular, it returns a reference to the local object result, but re-\nsult is automatically destroyed when operator* is exited. Returning\na reference to an object that’s been destroyed is hardly useful.\nTrust me on this: some functions (operator* among them) just have\nto return objects. That’s the way it is. Don’t fight it. You can’t win.\nThat is, you can’t win in your effort to eliminate by-value returns from\nfunctions that require them. But that’s the wrong war to wage. From\nan efficiency point of view, you shouldn’t care that a function returns\nan object, you should only care about the cost of that object. What you\nneed to do is channel your efforts into finding a way to reduce the cost\nof returned objects, not to eliminate the objects themselves (which we\nnow recognize is a futile quest). If no cost is associated with such ob-\njects, who cares how many get created?\nIt is frequently possible to write functions that return objects in such\na way that compilers can eliminate the cost of the temporaries. The\ntrick is to return constructor arguments instead of objects, and you can\ndo it like this:\n// an efficient and correct way to implement a \n// function that returns an object\nconst Rational operator*(const Rational& lhs,\nconst Rational& rhs)\n{\nreturn Rational(lhs.numerator() * rhs.numerator(),\nlhs.denominator() * rhs.denominator());\n}\nLook closely at the expression being returned. It looks like you’re call-\ning a Rational constructor, and in fact you are. You’re creating a tem-\nporary Rational object through this expression,\nRational(lhs.numerator() * rhs.numerator(),\nlhs.denominator() * rhs.denominator());\nand it is this temporary object the function is copying for its return\nvalue.\n\n\n104\nItem 20\nThis business of returning constructor arguments instead of local ob-\njects doesn’t appear to have bought you a lot, because you still have to\npay for the construction and destruction of the temporary created in-\nside the function, and you still have to pay for the construction and de-\nstruction of the object the function returns. But you have gained\nsomething. The rules for C++ allow compilers to optimize temporary\nobjects out of existence. As a result, if you call operator* in a context\nlike this,\nRational a = 10;\nRational b(1, 2);\nRational c = a * b;\n// operator* is called here\nyour compilers are allowed to eliminate both the temporary inside op-\nerator* and the temporary returned by operator*. They can con-\nstruct the object defined by the return expression inside the memory\nallotted for the object c. If your compilers do this, the total cost of tem-\nporary objects as a result of your calling operator* is zero: no tempo-\nraries are created. Instead, you pay for only one constructor call — the\none to create c. Furthermore, you can’t do any better than this, be-\ncause c is a named object, and named objects can’t be eliminated (see\nalso Item 22).† You can, however, eliminate the overhead of the call to\noperator* by declaring that function inline:\n// the most efficient way to write a function returning\n// an object\ninline const Rational operator*(const Rational& lhs,\nconst Rational& rhs)\n{\nreturn Rational(lhs.numerator() * rhs.numerator(),\nlhs.denominator() * rhs.denominator());\n}\n“Yeah, yeah,” you mutter, “optimization, schmoptimization. Who cares\nwhat compilers can do? I want to know what they do do. Does any of\nthis nonsense work with real compilers?” It does. This particular opti-\nmization — eliminating a local temporary by using a function’s return\nlocation (and possibly replacing that with an object at the function’s\ncall site) — is both well-known and commonly implemented. It even\nhas a name: the return value optimization. In fact, the existence of a\nname for this optimization may explain why it’s so widely available.\nProgrammers looking for a C++ compiler can ask vendors whether the\nreturn value optimization is implemented. If one vendor says yes and\nanother says “The what?,” the first vendor has a notable competitive\nadvantage. Ah, capitalism. Sometimes you just gotta love it.\n† In July 1996, the ISO/ANSI standardization committee declared that both named and\nunnamed objects may be optimized away via the return value optimization.\n\n\nOverloading to Avoid Implicit Type Conversions\n105\nItem 21: Overload to avoid implicit type conversions.\nOverloading to Avoid Implicit Type Conversions\nHere’s some code that looks nothing if not eminently reasonable:\nclass UPInt {\n// class for unlimited\npublic:\n// precision integers\nUPInt();\nUPInt(int value);\n...\n};\n// For an explanation of why the return value is const,\n// see Item 6\nconst UPInt operator+(const UPInt& lhs, const UPInt& rhs);\nUPInt upi1, upi2;\n...\nUPInt upi3 = upi1 + upi2;\nThere are no surprises here. upi1 and upi2 are both UPInt objects, so\nadding them together just calls operator+ for UPInts.\nNow consider these statements:\nupi3 = upi1 + 10;\nupi3 = 10 + upi2;\nThese statements also succeed. They do so through the creation of\ntemporary objects to convert the integer 10 into UPInts (see Item 19). \nIt is convenient to have compilers perform these kinds of conversions,\nbut the temporary objects created to make the conversions work are a\ncost we may not wish to bear. Just as most people want government\nbenefits without having to pay for them, most C++ programmers want\nimplicit type conversions without incurring any cost for temporaries.\nBut without the computational equivalent of deficit spending, how can\nwe do it?\nWe can take a step back and recognize that our goal isn’t really type\nconversion, it’s being able to make calls to operator+ with a combina-\ntion of UPInt and int arguments. Implicit type conversion happens to\nbe a means to that end, but let us not confuse means and ends. There\nis another way to make mixed-type calls to operator+ succeed, and\nthat’s to eliminate the need for type conversions in the first place. If we\nwant to be able to add UPInt and int objects, all we have to do is say\nso. We do it by declaring several functions, each with a different set of\nparameter types:\nconst UPInt operator+(const UPInt& lhs,\n// add UPInt\nconst UPInt& rhs);\n// and UPInt\n\n\n106\nItem 21\nconst UPInt operator+(const UPInt& lhs,\n// add UPInt\nint rhs);\n// and int\nconst UPInt operator+(int lhs,\n// add int and \nconst UPInt& rhs);\n// UPInt\nUPInt upi1, upi2;\n...\nUPInt upi3 = upi1 + upi2;\n// fine, no temporary for \n// upi1 or upi2\nupi3 = upi1 + 10;\n// fine, no temporary for\n// upi1 or 10\nupi3 = 10 + upi2;\n// fine, no temporary for \n// 10 or upi2\nOnce you start overloading to eliminate type conversions, you run the\nrisk of getting swept up in the passion of the moment and declaring\nfunctions like this:\nconst UPInt operator+(int lhs, int rhs);\n// error!\nThe thinking here is reasonable enough. For the types UPInt and int,\nwe want to overload on all possible combinations for operator+. Given\nthe three overloadings above, the only one missing is operator+ tak-\ning two int arguments, so we want to add it.\nReasonable or not, there are rules to this C++ game, and one of them\nis that every overloaded operator must take at least one argument of a\nuser-defined type. int isn’t a user-defined type, so we can’t overload\nan operator taking only arguments of that type. (If this rule didn’t ex-\nist, programmers would be able to change the meaning of predefined\noperations, and that would surely lead to chaos. For example, the at-\ntempted overloading of operator+ above would change the meaning of\naddition on ints. Is that really something we want people to be able to\ndo?)\nOverloading to avoid temporaries isn’t limited to operator functions.\nFor example, in most programs, you’ll want to allow a string object\neverywhere a char* is acceptable, and vice versa. Similarly, if you’re\nusing a numerical class like complex (see Item 35), you’ll want types\nlike int and double to be valid anywhere a numerical object is. As a\nresult, any function taking arguments of type string, char*, com-\nplex, etc., is a reasonable candidate for overloading to eliminate type\nconversions.\nStill, it’s important to keep the 80-20 rule (see Item 16) in mind. There\nis no point in implementing a slew of overloaded functions unless you\n",
      "page_number": 116,
      "chapter_number": 12,
      "summary": "This chapter covers segment 12 (pages 116-123). Key topics include objects, returns, and function. Covers function. It’s simply an object local to a\nfunction.",
      "keywords": [
        "const Rational",
        "rational",
        "object const Rational",
        "object",
        "Temporary Objects",
        "const",
        "Temporary",
        "const Rational operator",
        "Item",
        "function",
        "operator",
        "const UPInt",
        "UPInt",
        "type",
        "const UPInt operator"
      ],
      "concepts": [
        "objects",
        "returns",
        "function",
        "operator",
        "operations",
        "item",
        "types",
        "rational",
        "char",
        "temporary"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 3,
          "title": "Segment 3 (pages 17-24)",
          "relevance_score": 0.73,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 30,
          "title": "Segment 30 (pages 317-324)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.68,
          "method": "api"
        }
      ]
    },
    {
      "number": 13,
      "title": "Segment 13 (pages 124-132)",
      "start_page": 124,
      "end_page": 132,
      "detection_method": "topic_boundary",
      "content": "op= Compared to Stand-Alone op\n107\nhave good reason to believe that it will make a noticeable improvement\nin the overall efficiency of the programs that use them.\nItem 22: Consider using op= instead of stand-alone op.\nop= Compared to Stand-Alone op\nMost programmers expect that if they can say things like these,\nx = x + y;\nx = x - y;\nthey can also say things like these:\nx += y;\nx -= y;\nIf x and y are of a user-defined type, there is no guarantee that this is\nso. As far as C++ is concerned, there is no relationship between oper-\nator+, operator=, and operator+=, so if you want all three operators\nto exist and to have the expected relationship, you must implement\nthat yourself. Ditto for the operators -, *, /, etc.\nA good way to ensure that the natural relationship between the assign-\nment version of an operator (e.g., operator+=) and the stand-alone\nversion (e.g., operator+) exists is to implement the latter in terms of\nthe former (see also Item 6). This is easy to do:\nclass Rational {\npublic:\n...\nRational& operator+=(const Rational& rhs);\nRational& operator-=(const Rational& rhs);\n};\n// operator+ implemented in terms of operator+=; see\n// Item 6 for an explanation of why the return value is\n// const and page 109 for a warning about implementation\nconst Rational operator+(const Rational& lhs,\nconst Rational& rhs)\n{\nreturn Rational(lhs) += rhs;\n}\n// operator- implemented in terms of operator -=\nconst Rational operator-(const Rational& lhs,\nconst Rational& rhs)\n{\nreturn Rational(lhs) -= rhs;\n}\nIn this example, operators += and -= are implemented (elsewhere)\nfrom scratch, and operator+ and operator- call them to provide\ntheir own functionality. With this design, only the assignment versions\nof these operators need to be maintained. Furthermore, assuming the\n\n\n108\nItem 22\nassignment versions of the operators are in the class’s public interface,\nthere is never a need for the stand-alone operators to be friends of the\nclass. \nIf you don’t mind putting all stand-alone operators at global scope, you\ncan use templates to eliminate the need to write the stand-alone func-\ntions:\ntemplate<class T>\nconst T operator+(const T& lhs, const T& rhs)\n{\nreturn T(lhs) += rhs;\n// see discussion below\n}\ntemplate<class T>\nconst T operator-(const T& lhs, const T& rhs)\n{\nreturn T(lhs) -= rhs;\n// see discussion below\n}\n...\nWith these templates, as long as an assignment version of an operator\nis defined for some type T, the corresponding stand-alone operator will\nautomatically be generated if it’s needed.\nAll this is well and good, but so far we have failed to consider the issue\nof efficiency, and efficiency is, after all, the topic of this chapter. Three\naspects of efficiency are worth noting here. The first is that, in general,\nassignment versions of operators are more efficient than stand-alone\nversions, because stand-alone versions must typically return a new\nobject, and that costs us the construction and destruction of a tempo-\nrary (see Items 19 and 20). Assignment versions of operators write to\ntheir left-hand argument, so there is no need to generate a temporary\nto hold the operator’s return value.\nThe second point is that by offering assignment versions of operators\nas well as stand-alone versions, you allow clients of your classes to\nmake the difficult trade-off between efficiency and convenience. That\nis, your clients can decide whether to write their code like this,\nRational a, b, c, d, result;\n...\nresult = a + b + c + d;\n// probably uses 3 temporary\n// objects, one for each call\n// to operator+\nor like this:\nresult = a;\n// no temporary needed\nresult += b;\n// no temporary needed\nresult += c;\n// no temporary needed\nresult += d;\n// no temporary needed\n\n\nop= Compared to Stand-Alone op\n109\nThe former is easier to write, debug, and maintain, and it offers accept-\nable performance about 80% of the time (see Item 16). The latter is\nmore efficient, and, one supposes, more intuitive for assembly lan-\nguage programmers. By offering both options, you let clients develop\nand debug code using the easier-to-read stand-alone operators while\nstill reserving the right to replace them with the more efficient assign-\nment versions of the operators. Furthermore, by implementing the\nstand-alones in terms of the assignment versions, you ensure that\nwhen clients switch from one to the other, the semantics of the opera-\ntions remain constant.\nThe final efficiency observation concerns implementing the stand-\nalone operators. Look again at the implementation for operator+:\ntemplate<class T>\nconst T operator+(const T& lhs, const T& rhs)\n{ return T(lhs) += rhs; }\nThe expression T(lhs) is a call to T’s copy constructor. It creates a\ntemporary object whose value is the same as that of lhs. This tempo-\nrary is then used to invoke operator+= with rhs, and the result of\nthat operation is returned from operator+.† This code seems unnec-\nessarily cryptic. Wouldn’t it be better to write it like this?\ntemplate<class T>\nconst T operator+(const T& lhs, const T& rhs)\n{\nT result(lhs);\n// copy lhs into result\nreturn result += rhs;\n// add rhs to it and return\n}\nThis template is almost equivalent to the one above, but there is a cru-\ncial difference. This second template contains a named object, result.\nThe fact that this object is named means that the return value optimi-\nzation (see Item 20) was, until relatively recently, unavailable for this\nimplementation of operator+ (see the footnote on page 104). The first\nimplementation has always been eligible for the return value optimi-\nzation, so the odds may be better that the compilers you use will gen-\nerate optimized code for it.\nNow, truth in advertising compels me to point out that the expression \nreturn T(lhs) += rhs;\nis more complex than most compilers are willing to subject to the re-\nturn value optimization. The first implementation above may thus cost\nyou one temporary object within the function, just as you’d pay for\nusing the named object result. However, the fact remains that un-\nnamed objects have historically been easier to eliminate than named\nobjects, so when faced with a choice between a named object and a\n† At least that’s what’s supposed to happen. Alas, some compilers treat T(lhs) as a cast\nto remove lhs’s constness, then add rhs to lhs and return a reference to the modified\nlhs! Test your compilers before relying on the behavior described above.\n\n\n110\nItem 23\ntemporary object, you may be better off using the temporary. It should\nnever cost you more than its named colleague, and, especially with\nolder compilers, it may cost you less.\nAll this talk of named objects, unnamed objects, and compiler optimi-\nzations is interesting, but let us not forget the big picture. The big pic-\nture is that assignment versions of operators (such as operator+=)\ntend to be more efficient than stand-alone versions of those operators\n(e.g. operator+). As a library designer, you should offer both, and as\nan application developer, you should consider using assignment ver-\nsions of operators instead of stand-alone versions whenever perfor-\nmance is at a premium.\nItem 23: Consider alternative libraries.\nConsidering Alternative Libraries\nLibrary design is an exercise in compromise. The ideal library is small,\nfast, powerful, flexible, extensible, intuitive, universally available, well\nsupported, free of use restrictions, and bug-free. It is also nonexistent.\nLibraries optimized for size and speed are typically not portable. Li-\nbraries with rich functionality are rarely intuitive. Bug-free libraries\nare limited in scope. In the real world, you can’t have everything; some-\nthing always has to give.\nDifferent designers assign different priorities to these criteria. They\nthus sacrifice different things in their designs. As a result, it is not un-\ncommon for two libraries offering similar functionality to have quite\ndifferent performance profiles. \nAs an example, consider the iostream and stdio libraries, both of which\nshould be available to every C++ programmer. The iostream library has\nseveral advantages over its C counterpart. It’s type-safe, for example,\nand it’s extensible. In terms of efficiency, however, the iostream library\ngenerally suffers in comparison with stdio, because stdio usually re-\nsults in executables that are both smaller and faster than those arising\nfrom iostreams.\nConsider first the speed issue. One way to get a feel for the difference\nin performance between iostreams and stdio is to run benchmark ap-\nplications using both libraries. Now, it’s important to bear in mind that\nbenchmarks lie. Not only is it difficult to come up with a set of inputs\nthat correspond to “typical” usage of a program or library, it’s also use-\nless unless you have a reliable way of determining how “typical” you or\nyour clients are. Nevertheless, benchmarks can provide some insight\ninto the comparative performance of different approaches to a prob-\nlem, so though it would be foolish to rely on them completely, it would\nalso be foolish to ignore them.\n\n\nConsidering Alternative Libraries\n111\nLet’s examine a simple-minded benchmark program that exercises\nonly the most rudimentary I/O functionality. This program reads\n30,000 floating point numbers from standard input and writes them to\nstandard output in a fixed format. The choice between the iostream\nand stdio libraries is made during compilation and is determined by\nthe preprocessor symbol STDIO. If this symbol is defined, the stdio li-\nbrary is used, otherwise the iostream library is employed.\n#ifdef STDIO\n#include <stdio.h>\n#else\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n#endif\nconst int VALUES = 30000; \n// # of values to read/write\nint main()\n{\ndouble d;\nfor (int n = 1; n <= VALUES; ++n) {\n#ifdef STDIO\nscanf(\"%lf\", &d);\nprintf(\"%10.5f\", d);\n#else\ncin >> d;\ncout << setw(10)\n// set field width\n<< setprecision(5)\n// set decimal places\n<< setiosflags(ios::showpoint)\n// keep trailing 0s\n<< setiosflags(ios::fixed)\n// use these settings\n<< d;\n#endif\nif (n % 5 == 0) {\n#ifdef STDIO\nprintf(\"\\n\");\n#else\ncout << '\\n';\n#endif\n}\n}\nreturn 0;\n}\nWhen this program is given the natural logarithms of the positive inte-\ngers as input, it produces output like this:\n\n\n112\nItem 23\n0.00000   0.69315   1.09861   1.38629   1.60944\n1.79176   1.94591   2.07944   2.19722   2.30259\n2.39790   2.48491   2.56495   2.63906   2.70805\n2.77259   2.83321   2.89037   2.94444   2.99573\n3.04452   3.09104   3.13549   3.17805   3.21888\nSuch output demonstrates, if nothing else, that it’s possible to produce\nfixed-format I/O using iostreams. Of course, \ncout << setw(10)\n<< setprecision(5)\n<< setiosflags(ios::showpoint)\n<< setiosflags(ios::fixed)\n<< d;\nis nowhere near as easy to type as\nprintf(\"%10.5f\", d);\nbut operator<< is both type-safe and extensible, and printf is nei-\nther.\nI have run this program on several combinations of machines, operat-\ning systems, and compilers, and in every case the stdio version has\nbeen faster. Sometimes it’s been only a little faster (about 20%), some-\ntimes it’s been substantially faster (nearly 200%), but I’ve never come\nacross an iostream implementation that was as fast as the correspond-\ning stdio implementation. In addition, the size of this trivial program’s\nexecutable using stdio tends to be smaller (sometimes much smaller)\nthan the corresponding program using iostreams. (For programs of a\nrealistic size, this difference is rarely significant.)\nBear in mind that any efficiency advantages of stdio are highly imple-\nmentation-dependent, so future implementations of systems I’ve\ntested or existing implementations of systems I haven’t tested may\nshow a negligible performance difference between iostreams and stdio.\nIn fact, one can reasonably hope to discover an iostream implementa-\ntion that’s faster than stdio, because iostreams determine the types of\ntheir operands during compilation, while stdio functions typically\nparse a format string at runtime.\nThe contrast in performance between iostreams and stdio is just an\nexample, however, it’s not the main point. The main point is that dif-\nferent libraries offering similar functionality often feature different per-\nformance trade-offs, so once you’ve identified the bottlenecks in your\nsoftware (via profiling — see Item 16), you should see if it’s possible to\nremove those bottlenecks by replacing one library with another. If your\nprogram has an I/O bottleneck, for example, you might consider re-\nplacing iostreams with stdio, but if it spends a significant portion of its\ntime on dynamic memory allocation and deallocation, you might see if\n\n\nThe Costs of Various Language Features\n113\nthere are alternative implementations of operator new and operator\ndelete available (see Item 8). Because different libraries embody dif-\nferent design decisions regarding efficiency, extensibility, portability,\ntype safety, and other issues, you can sometimes significantly improve\nthe efficiency of your software by switching to libraries whose design-\ners gave more weight to performance considerations than to other fac-\ntors.\nItem 24: Understand the costs of virtual functions, \nmultiple inheritance, virtual base classes, \nand RTTI.\nThe Costs of Various Language Features\nC++ compilers must find a way to implement each feature in the lan-\nguage. Such implementation details are, of course, compiler-depen-\ndent, and different compilers implement language features in different\nways. For the most part, you need not concern yourself with such mat-\nters. However, the implementation of some features can have a notice-\nable impact on the size of objects and the speed at which member\nfunctions execute, so for those features, it’s important to have a basic\nunderstanding of what compilers are likely to be doing under the hood.\nThe foremost example of such a feature is virtual functions.\nWhen a virtual function is called, the code executed must correspond\nto the dynamic type of the object on which the function is invoked; the\ntype of the pointer or reference to the object is immaterial. How can\ncompilers provide this behavior efficiently? Most implementations use\nvirtual tables and virtual table pointers. Virtual tables and virtual table\npointers are commonly referred to as vtbls and vptrs, respectively.\nA vtbl is usually an array of pointers to functions. (Some compilers use\na form of linked list instead of an array, but the fundamental strategy\nis the same.) Each class in a program that declares or inherits virtual\nfunctions has its own vtbl, and the entries in a class’s vtbl are pointers\nto the implementations of the virtual functions for that class. For ex-\nample, given a class definition like this,\n\n\n114\nItem 24\nclass C1 {\npublic:\nC1();\nvirtual ~C1();\nvirtual void f1();\nvirtual int f2(char c) const;\nvirtual void f3(const string& s);\nvoid f4() const;\n...\n};\nC1’s virtual table array will look something like this:\nNote that the nonvirtual function f4 is not in the table, nor is C1’s con-\nstructor. Nonvirtual functions — including constructors, which are by\ndefinition nonvirtual — are implemented just like ordinary C func-\ntions, so there are no special performance considerations surrounding\ntheir use.\nIf a class C2 inherits from C1, redefines some of the virtual functions it\ninherits, and adds some new ones of its own,\nclass C2: public C1 {\npublic:\nC2();\n// nonvirtual function\nvirtual ~C2();\n// redefined function\nvirtual void f1();\n// redefined function\nvirtual void f5(char *str);\n// new virtual function\n...\n};\nits virtual table entries point to the functions that are appropriate for\nobjects of its type. These entries include pointers to the C1 virtual\nfunctions that C2 chose not to redefine:\nThis discussion brings out the first cost of virtual functions: you have\nto set aside space for a virtual table for each class that contains virtual\nimplementation of C1::f1\nimplementation of C1::f2\nimplementation of C1::f3\nC1’s\nvtbl\nimplementation of C1::~C1\nimplementation of C2::f1\nimplementation of C1::f2\nimplementation of C1::f3\nC2’s\nvtbl\nimplementation of C2::~C2\nimplementation of C2::f5\n\n\nThe Costs of Various Language Features\n115\nfunctions. The size of a class’s vtbl is proportional to the number of vir-\ntual functions declared for that class (including those it inherits from\nits base classes). There should be only one virtual table per class, so\nthe total amount of space required for virtual tables is not usually sig-\nnificant, but if you have a large number of classes or a large number of\nvirtual functions in each class, you may find that the vtbls take a sig-\nnificant bite out of your address space. \nBecause you need only one copy of a class’s vtbl in your programs,\ncompilers must address a tricky problem: where to put it. Most pro-\ngrams and libraries are created by linking together many object files,\nbut each object file is generated independently of the others. Which ob-\nject file should contain the vtbl for any given class? You might think to\nput it in the object file containing main, but libraries have no main,\nand at any rate the source file containing main may make no mention\nof many of the classes requiring vtbls. How could compilers then know\nwhich vtbls they were supposed to create?\nA different strategy must be adopted, and compiler vendors tend to fall\ninto two camps. For vendors who provide an integrated environment\ncontaining both compiler and linker, a brute-force strategy is to gener-\nate a copy of the vtbl in each object file that might need it. The linker\nthen strips out duplicate copies, leaving only a single instance of each\nvtbl in the final executable or library.\nA more common design is to employ a heuristic to determine which ob-\nject file should contain the vtbl for a class. Usually this heuristic is as\nfollows: a class’s vtbl is generated in the object file containing the def-\ninition (i.e., the body) of the first non-inline non-pure virtual function\nin that class. Thus, the vtbl for class C1 above would be placed in the\nobject file containing the definition of C1::~C1 (provided that function\nwasn’t inline), and the vtbl for class C2 would be placed in the object\nfile containing the definition of C2::~C2 (again, provided that function\nwasn’t inline).\nIn practice, this heuristic works well, but you can get into trouble if\nyou go overboard on declaring virtual functions inline. If all virtual\nfunctions in a class are declared inline, the heuristic fails, and most\nheuristic-based implementations then generate a copy of the class’s\nvtbl in every object file that uses it. In large systems, this can lead to\nprograms containing hundreds or thousands of copies of a class’s vtbl!\nMost compilers following this heuristic give you some way to control\nvtbl generation manually, but a better solution to this problem is to\navoid declaring virtual functions inline. As we’ll see below, there are\n",
      "page_number": 124,
      "chapter_number": 13,
      "summary": "All this is well and good, but so far we have failed to consider the issue\nof efficiency, and efficiency is, after all, the topic of this chapter Key topics include functionality, function, and functions.",
      "keywords": [
        "const Rational",
        "operator",
        "const Rational operator",
        "virtual",
        "virtual functions",
        "Rational",
        "const",
        "stdio",
        "functions",
        "object",
        "Item",
        "lhs",
        "implementation",
        "Rational operator",
        "rhs"
      ],
      "concepts": [
        "functionality",
        "function",
        "functions",
        "operator",
        "operation",
        "implement",
        "implemented",
        "implementations",
        "library",
        "libraries"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 18,
          "title": "Segment 18 (pages 159-166)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 80,
          "title": "Segment 80 (pages 2566-2598)",
          "relevance_score": 0.58,
          "method": "api"
        }
      ]
    },
    {
      "number": 14,
      "title": "Segment 14 (pages 133-140)",
      "start_page": 133,
      "end_page": 140,
      "detection_method": "topic_boundary",
      "content": "116\nItem 24\ngood reasons why present compilers typically ignore the inline direc-\ntive for virtual functions, anyway.\nVirtual tables are half the implementation machinery for virtual func-\ntions, but by themselves they are useless. They become useful only\nwhen there is some way of indicating which vtbl corresponds to each\nobject, and it is the job of the virtual table pointer to establish that cor-\nrespondence.\nEach object whose class declares virtual functions carries with it a hid-\nden data member that points to the virtual table for that class. This\nhidden data member — the vptr — is added by compilers at a location\nin the object known only to the compilers. Conceptually, we can think\nof the layout of an object that has virtual functions as looking like this:\nThis picture shows the vptr at the end of the object, but don’t be fooled:\ndifferent compilers put them in different places. In the presence of in-\nheritance, an object’s vptr is often surrounded by data members. Mul-\ntiple inheritance complicates this picture, but we’ll deal with that a bit\nlater. At this point, simply note the second cost of virtual functions:\nyou have to pay for an extra pointer inside each object that is of a class\ncontaining virtual functions.\nIf your objects are small, this can be a significant cost. If your objects\ncontain, on average, four bytes of member data, for example, the addi-\ntion of a vptr can double their size (assuming four bytes are devoted to\nthe vptr). On systems with limited memory, this means the number of\nobjects you can create is reduced. Even on systems with uncon-\nstrained memory, you may find that the performance of your software\ndecreases, because larger objects mean fewer fit on each cache or vir-\ntual memory page, and that means your paging activity will probably\nincrease.\nSuppose we have a program with several objects of types C1 and C2.\nGiven the relationships among objects, vptrs, and vtbls that we have\nData members\nfor\nthe object\nObject’s vptr\n\n\nThe Costs of Various Language Features\n117\njust seen, we can envision the objects in our program like this:\nNow consider this program fragment:\nvoid makeACall(C1 *pC1)\n{\npC1->f1();\n}\nThis is a call to the virtual function f1 through the pointer pC1. By\nlooking only at this code, there is no way to know which f1 function —\nC1::f1 or C2::f1 — should be invoked, because pC1 might point to a C1\nobject or to a C2 object. Your compilers must nevertheless generate\ncode for the call to f1 inside makeACall, and they must ensure that\nthe correct function is called, no matter what pC1 points to. They do\nthis by generating code to do the following:\n1.\nFollow the object’s vptr to its vtbl. This is a simple operation, be-\ncause the compilers know where to look inside the object for the\nvptr. (After all, they put it there.) As a result, this costs only an\noffset adjustment (to get to the vptr) and a pointer indirection (to\nget to the vtbl).\n2.\nFind the pointer in the vtbl that corresponds to the function be-\ning called (f1 in this example). This, too, is simple, because com-\npilers assign each virtual function a unique index within the\ntable. The cost of this step is just an offset into the vtbl array.\n3.\nInvoke the function pointed to by the pointer located in step 2.\nC2’s\nvtbl\nC1’s\nvtbl\nC1 Object\nvptr\nData\nMembers\nC1 Object\nvptr\nData\nMembers\nC1 Object\nvptr\nData\nMembers\nC2 Object\nvptr\nData\nMembers\nC2 Object\nvptr\nData\nMembers\nC2 Object\nvptr\nData\nMembers\nImplementations\nof C1’s virtual\nfunctions\nImplementations\nof C2’s virtual\nfunctions\n\n\n118\nItem 24\nIf we imagine that each object has a hidden member called vptr and\nthat the vtbl index of function f1 is i, the code generated for the state-\nment\npC1->f1();\nis\n(*pC1->vptr[i])(pC1);\n// call the function pointed to by the\n// i-th entry in the vtbl pointed to \n// by pC1->vptr; pC1 is passed to the\n// function as the \"this\" pointer\nThis is almost as efficient as a non-virtual function call: on most ma-\nchines it executes only a few more instructions. The cost of calling a\nvirtual function is thus basically the same as that of calling a function\nthrough a function pointer. Virtual functions per se are not usually a\nperformance bottleneck.\nThe real runtime cost of virtual functions has to do with their interac-\ntion with inlining. For all practical purposes, virtual functions aren’t\ninlined. That’s because “inline” means “during compilation, replace the\ncall site with the body of the called function,” but “virtual” means “wait\nuntil runtime to see which function is called.” If your compilers don’t\nknow which function will be called at a particular call site, you can un-\nderstand why they won’t inline that function call. This is the third cost\nof virtual functions: you effectively give up inlining. (Virtual functions\ncan be inlined when invoked through objects, but most virtual function\ncalls are made through pointers or references to objects, and such calls\nare not inlined. Because such calls are the norm, virtual functions are\neffectively not inlined.)\nEverything we’ve seen so far applies to both single and multiple inher-\nitance, but when multiple inheritance enters the picture, things get\nmore complex. There is no point in dwelling on details, but with multi-\nple inheritance, offset calculations to find vptrs within objects become\nmore complicated; there are multiple vptrs within a single object (one\nper base class); and special vtbls must be generated for base classes in\naddition to the stand-alone vtbls we have discussed. As a result, both\nthe per-class and the per-object space overhead for virtual functions\nincreases, and the runtime invocation cost grows slightly, too.\nMultiple inheritance often leads to the need for virtual base classes.\nWithout virtual base classes, if a derived class has more than one in-\nheritance path to a base class, the data members of that base class are\nreplicated within each derived class object, one copy for each path be-\ntween the derived class and the base class. Such replication is almost\nnever what programmers want, and making base classes virtual elim-\ninates the replication. Virtual base classes may incur a cost of their\n\n\nThe Costs of Various Language Features\n119\nown, however, because implementations of virtual base classes often\nuse pointers to virtual base class parts as the means for avoiding the\nreplication, and one or more of those pointers may be stored inside\nyour objects. \nFor example, consider this, which I generally call “the dreaded multiple\ninheritance diamond:”\nHere A is a virtual base class because B and C virtually inherit from it.\nWith some compilers (especially older compilers), the layout for an ob-\nject of type D is likely to look like this:\nIt seems a little strange to place the base class data members at the\nend of the object, but that’s often how it’s done. Of course, implemen-\ntations are free to organize memory any way they like, so you should\nnever rely on this picture for anything more than a conceptual over-\nview of how virtual base classes may lead to the addition of hidden\npointers to your objects. Some implementations add fewer pointers,\nand some find ways to add none at all. (Such implementations make\nthe vptr and vtbl serve double duty).\nIf we combine this picture with the earlier one showing how virtual\ntable pointers are added to objects, we realize that if the base class A\nclass A { ... };\nclass B: virtual public A { ... };\nclass C: virtual public A { ... };\nclass D: public B, public C { ... };\nB\nD\nC\nA\nB Data Members\nC Data Members\nD Data Members\nA Data Members\nPointer to virtual base class\nPointer to virtual base class\n\n\n120\nItem 24\nin the hierarchy on page 119 has any virtual functions, the memory\nlayout for an object of type D could look like this:\nHere I’ve shaded the parts of the object that are added by compilers.\nThe picture may be misleading, because the ratio of shaded to un-\nshaded areas is determined by the amount of data in your classes. For\nsmall classes, the relative overhead is large. For classes with more\ndata, the relative overhead is less significant, though it is typically no-\nticeable.\nAn oddity in the above diagram is that there are only three vptrs even\nthough four classes are involved. Implementations are free to generate\nfour vptrs if they like, but three suffice (it turns out that B and D can\nshare a vptr), and most implementations take advantage of this oppor-\ntunity to reduce the compiler-generated overhead.\nWe’ve now seen how virtual functions make objects larger and pre-\nclude inlining, and we’ve examined how multiple inheritance and vir-\ntual base classes can also increase the size of objects. Let us therefore\nturn to our final topic, the cost of runtime type identification (RTTI).\nRTTI lets us discover information about objects and classes at run-\ntime, so there has to be a place to store the information we’re allowed\nto query. That information is stored in an object of type type_info,\nand you can access the type_info object for a class by using the\ntypeid operator.\nThere only needs to be a single copy of the RTTI information for each\nclass, but there must be a way to get to that information for any object.\nActually, that’s not quite true. The language specification states that\nwe’re guaranteed accurate information on an object’s dynamic type\nB Data Members\nC Data Members\nD Data Members\nA Data Members\nPointer to virtual base class\nPointer to virtual base class\nvptr\nvptr\nvptr\n\n\nThe Costs of Various Language Features\n121\nonly if that type has at least one virtual function. This makes RTTI\ndata sound a lot like a virtual function table. We need only one copy of\nthe information per class, and we need a way to get to the appropriate\ninformation from any object containing a virtual function. This parallel\nbetween RTTI and virtual function tables is no accident: RTTI was de-\nsigned to be implementable in terms of a class’s vtbl.\nFor example, index 0 of a vtbl array might contain a pointer to the\ntype_info object for the class corresponding to that vtbl. The vtbl for\nclass C1 on page 114 would then look like this:\nWith this implementation, the space cost of RTTI is an additional entry\nin each class vtbl plus the cost of the storage for the type_info object\nfor each class. Just as the memory for virtual tables is unlikely to be\nnoticeable for most applications, however, you’re unlikely to run into\nproblems due to the size of type_info objects. \nThe following table summarizes the primary costs of virtual functions,\nmultiple inheritance, virtual base classes, and RTTI:\nIncreases\nIncreases\nReduces\nFeature\nSize of Objects\nPer-Class Data\nInlining\nVirtual Functions\nYes\nYes\nYes\nMultiple Inheritance\nYes\nYes\nNo\nVirtual Base Classes\nOften\nSometimes\nNo\nRTTI\nNo\nYes\nNo\nSome people look at this table and are aghast. “I’m sticking with C!”,\nthey declare. Fair enough. But remember that each of these features\noffers functionality you’d otherwise have to code by hand. In most\ncases, your manual approximation would probably be less efficient\nand less robust than the compiler-generated code. Using nested\nswitch statements or cascading if-then-elses to emulate virtual\nfunction calls, for example, yields more code than virtual function calls\ndo, and the code runs more slowly, too. Furthermore, you must man-\nually track object types yourself, which means your objects carry\naround type tags of their own; you thus often fail to gain even the ben-\nefit of smaller objects. \nimplementation of C1::f1\nimplementation of C1::f2\nimplementation of C1::f3\nimplementation of C1::~C1\nC1’s type_info object\nC1’s\nvtbl\n\n\n122\nItem 24\nIt is important to understand the costs of virtual functions, multiple\ninheritance, virtual base classes, and RTTI, but it is equally important\nto understand that if you need the functionality these features offer,\nyou will pay for it, one way or another. Sometimes you have legitimate\nreasons for bypassing the compiler-generated services. For example,\nhidden vptrs and pointers to virtual base classes can make it difficult\nto store C++ objects in databases or to move them across process\nboundaries, so you may wish to emulate these features in a way that\nmakes it easier to accomplish these other tasks. From the point of view\nof efficiency, however, you are unlikely to do better than the compiler-\ngenerated implementations by coding these features yourself.\n\n\nTechniques\nTechniques\nMost of this book is concerned with programming guidelines. Such\nguidelines are important, but no programmer lives by guidelines alone.\nAccording to the old TV show Felix the Cat, “Whenever he gets in a fix,\nhe reaches into his bag of tricks.” Well, if a cartoon character can have\na bag of tricks, so too can C++ programmers. Think of this chapter as\na starter set for your bag of tricks. \nSome problems crop up repeatedly when designing C++ software. How\ncan you make constructors and non-member functions act like virtual\nfunctions? How can you limit the number of instances of a class? How\ncan you prevent objects from being created on the heap? How can you\nguarantee that they will be created there? How can you create objects\nthat automatically perform some actions anytime some other class’s\nmember functions are called? How can you have different objects\nshare data structures while giving clients the illusion that each has its\nown copy? How can you distinguish between read and write usage of\noperator[]? How can you create a virtual function whose behavior\ndepends on the dynamic types of more than one object?\nAll these questions (and more) are answered in this chapter, in which\nI describe proven solutions to problems commonly encountered by C++\nprogrammers. I call such solutions techniques, but they’re also known\nas idioms and, when documented in a stylized fashion, patterns. Re-\ngardless of what you call them, the information that follows will serve\nyou well as you engage in the day-to-day skirmishes of practical soft-\nware development. It should also convince you that no matter what\nyou want to do, there is almost certainly a way to do it in C++.\nItem 25: Virtualizing constructors and non-member \nfunctions.\nVirtualizing Constructors and Non-Member Functions\nOn the face of it, it doesn’t make much sense to talk about “virtual con-\nstructors.” You call a virtual function to achieve type-specific behavior\n",
      "page_number": 133,
      "chapter_number": 14,
      "summary": "This chapter covers segment 14 (pages 133-140). Key topics include object, virtual, and functions. Covers function. They become useful only\nwhen there is some way of indicating which vtbl corresponds to each\nobject, and it is the job of the virtual table pointer to establish that cor-\nrespondence.",
      "keywords": [
        "virtual functions",
        "virtual",
        "virtual base classes",
        "virtual base",
        "data members",
        "object",
        "virtual base class",
        "data",
        "function",
        "functions",
        "base class",
        "base",
        "virtual function calls",
        "members",
        "vptr"
      ],
      "concepts": [
        "object",
        "virtual",
        "functions",
        "function",
        "functionality",
        "classes",
        "compilers",
        "pointer",
        "types",
        "inheritance"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.73,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 30,
          "title": "Segment 30 (pages 317-324)",
          "relevance_score": 0.71,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.71,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 7,
          "title": "Segment 7 (pages 53-62)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 21,
          "title": "Segment 21 (pages 651-684)",
          "relevance_score": 0.69,
          "method": "api"
        }
      ]
    },
    {
      "number": 15,
      "title": "Segment 15 (pages 141-151)",
      "start_page": 141,
      "end_page": 151,
      "detection_method": "topic_boundary",
      "content": "124\nItem 25\nwhen you have a pointer or reference to an object but you don’t know\nwhat the real type of the object is. You call a constructor only when you\ndon’t yet have an object but you know exactly what type you’d like to\nhave. How, then, can one talk of virtual constructors?\nIt’s easy. Though virtual constructors may seem nonsensical, they are\nremarkably useful. (If you think nonsensical ideas are never useful,\nhow do you explain the success of modern physics?) For example, sup-\npose you write applications for working with newsletters, where a\nnewsletter consists of components that are either textual or graphical.\nYou might organize things this way:\nclass NLComponent {\n// abstract base class for\npublic:\n// newsletter components\n...\n// contains at least one\n};\n// pure virtual function\nclass TextBlock: public NLComponent {\npublic:\n...\n// contains no pure virtual\n};\n// functions\nclass Graphic: public NLComponent {\npublic:\n...\n// contains no pure virtual\n};\n// functions\nclass NewsLetter {\n// a newsletter object\npublic:\n// consists of a list of\n...\n// NLComponent objects\nprivate:\nlist<NLComponent*> components;\n};\nThe classes relate in this way: \nThe list class used inside NewsLetter is part of the Standard Tem-\nplate Library, which is part of the standard C++ library (see Item 35).\nNLComponent\nTextBlock\nGraphic\nNewsLetter\nobject\nlist\nobject\npublic\ninheritance\npointers\n\n\nVirtualizing Constructors and Non-Member Functions\n125\nObjects of type list behave like doubly linked lists, though they need\nnot be implemented in that way.\nNewsLetter objects, when not being worked on, would likely be stored\non disk. To support the creation of a Newsletter from its on-disk rep-\nresentation, it would be convenient to give NewsLetter a constructor\nthat takes an istream. The constructor would read information from\nthe stream as it created the necessary in-core data structures:\nclass NewsLetter {\npublic:\nNewsLetter(istream& str);\n...\n};\nPseudocode for this constructor might look like this,\nNewsLetter::NewsLetter(istream& str)\n{\nwhile (str) {\nread the next component object from str;\nadd the object to the list of this\nnewsletter’s components;\n}\n}\nor, after moving the tricky stuff into a separate function called read-\nComponent, like this:\nclass NewsLetter {\npublic:\n...\nprivate:\n// read the data for the next NLComponent from str,\n// create the component and return a pointer to it\nstatic NLComponent * readComponent(istream& str);\n...\n};\nNewsLetter::NewsLetter(istream& str)\n{\nwhile (str) {\n// add the pointer returned by readComponent to the\n// end of the components list; \"push_back\" is a list\n// member function that inserts at the end of the list\ncomponents.push_back(readComponent(str));\n}\n}\nConsider what readComponent does. It creates a new object, either a\nTextBlock or a Graphic, depending on the data it reads. Because it\n\n\n126\nItem 25\ncreates new objects, it acts much like a constructor, but because it can\ncreate different types of objects, we call it a virtual constructor. A virtual\nconstructor is a function that creates different types of objects depend-\ning on the input it is given. Virtual constructors are useful in many\ncontexts, only one of which is reading object information from disk (or\noff a network connection or from a tape, etc.).\nA particular kind of virtual constructor — the virtual copy constructor\n— is also widely useful. A virtual copy constructor returns a pointer to\na new copy of the object invoking the function. Because of this behav-\nior, virtual copy constructors are typically given names like copySelf,\ncloneSelf, or, as shown below, just plain clone. Few functions are\nimplemented in a more straightforward manner:\nclass NLComponent {\npublic:\n// declaration of virtual copy constructor\nvirtual NLComponent * clone() const = 0;\n...\n};\nclass TextBlock: public NLComponent {\npublic:\nvirtual TextBlock * clone() const\n// virtual copy\n{ return new TextBlock(*this); }\n// constructor\n...\n};\nclass Graphic: public NLComponent {\npublic:\nvirtual Graphic * clone() const\n// virtual copy\n{ return new Graphic(*this); }\n// constructor\n...\n};\nAs you can see, a class’s virtual copy constructor just calls its real copy\nconstructor. The meaning of “copy” is hence the same for both func-\ntions. If the real copy constructor performs a shallow copy, so does the\nvirtual copy constructor. If the real copy constructor performs a deep\ncopy, so does the virtual copy constructor. If the real copy constructor\ndoes something fancy like reference counting or copy-on-write (see\nItem 29), so does the virtual copy constructor. Consistency — what a\nwonderful thing.\nNotice that the above implementation takes advantage of a relaxation\nin the rules for virtual function return types that was adopted rela-\ntively recently. No longer must a derived class’s redefinition of a base\nclass’s virtual function declare the same return type. Instead, if the\n\n\nVirtualizing Constructors and Non-Member Functions\n127\nfunction’s return type is a pointer (or a reference) to a base class, the\nderived class’s function may return a pointer (or reference) to a class\nderived from that base class. This opens no holes in C++’s type system,\nand it makes it possible to accurately declare functions such as virtual\ncopy constructors. That’s why TextBlock’s clone can return a Text-\nBlock* and Graphic’s clone can return a Graphic*, even though the\nreturn type of NLComponent’s clone is NLComponent*.\nThe existence of a virtual copy constructor in NLComponent makes it\neasy to implement a (normal) copy constructor for NewsLetter:\nclass NewsLetter {\npublic:\nNewsLetter(const NewsLetter& rhs);\n...\nprivate:\nlist<NLComponent*> components;\n};\nNewsLetter::NewsLetter(const NewsLetter& rhs)\n{\n// iterate over rhs’s list, using each element’s\n// virtual copy constructor to copy the element into\n// the components list for this object. For details on\n// how the following code works, see Item 35.\nfor (list<NLComponent*>::const_iterator it =\nrhs.components.begin();\nit != rhs.components.end();\n++it) {\n// \"it\" points to the current element of rhs.components,\n// so call that element’s clone function to get a copy\n// of the element, and add that copy to the end of\n// this object’s list of components\ncomponents.push_back((*it)->clone());\n}\n}\nUnless you are familiar with the Standard Template Library, this code\nlooks bizarre, I know, but the idea is simple: just iterate over the list of\ncomponents for the NewsLetter object being copied, and for each\ncomponent in the list, call its virtual copy constructor. We need a vir-\ntual copy constructor here, because the list contains pointers to\nNLComponent objects, but we know each pointer really points to a\nTextBlock or a Graphic. We want to copy whatever the pointer really\npoints to, and the virtual copy constructor does that for us.\n\n\n128\nItem 25\nMaking Non-Member Functions Act Virtual\nJust as constructors can’t really be virtual, neither can non-member\nfunctions. However, just as it makes sense to conceive of functions\nthat construct new objects of different types, it makes sense to con-\nceive of non-member functions whose behavior depends on the dy-\nnamic types of their parameters. For example, suppose you’d like to\nimplement output operators for the TextBlock and Graphic classes.\nThe obvious approach to this problem is to make the output operator\nvirtual. However, the output operator is operator<<, and that func-\ntion takes an ostream& as its left-hand argument; that effectively rules\nout the possibility of making it a member function of the TextBlock or\nGraphic classes.\n(It can be done, but then look what happens:\nclass NLComponent {\npublic:\n// unconventional declaration of output operator\nvirtual ostream& operator<<(ostream& str) const = 0;\n...\n};\nclass TextBlock: public NLComponent {\npublic:\n// virtual output operator (also unconventional)\nvirtual ostream& operator<<(ostream& str) const;\n};\nclass Graphic: public NLComponent {\npublic:\n// virtual output operator (still unconventional)\nvirtual ostream& operator<<(ostream& str) const;\n};\nTextBlock t;\nGraphic g;\n...\nt << cout;\n// print t on cout via \n// virtual operator<<; note\n// unconventional syntax\ng << cout;\n// print g on cout via\n// virtual operator<<; note\n// unconventional syntax\nClients must place the stream object on the right-hand side of the “<<”\nsymbol, and that’s contrary to the convention for output operators. To\nget back to the normal syntax, we must move operator<< out of the\nTextBlock and Graphic classes, but if we do that, we can no longer\ndeclare it virtual.) \n\n\nVirtualizing Constructors and Non-Member Functions\n129\nAn alternate approach is to declare a virtual function for printing (e.g.,\nprint) and define it for the TextBlock and Graphic classes. But if we\ndo that, the syntax for printing TextBlock and Graphic objects is in-\nconsistent with that for the other types in the language, all of which\nrely on operator<< as their output operator.\nNeither of these solutions is very satisfying. What we want is a non-\nmember function called operator<< that exhibits the behavior of a\nvirtual function like print. This description of what we want is in fact\nvery close to a description of how to get it. We define both operator<<\nand print and have the former call the latter!\nclass NLComponent {\npublic:\nvirtual ostream& print(ostream& s) const = 0;\n...\n};\nclass TextBlock: public NLComponent {\npublic:\nvirtual ostream& print(ostream& s) const;\n...\n};\nclass Graphic: public NLComponent {\npublic:\nvirtual ostream& print(ostream& s) const;\n...\n};\ninline\nostream& operator<<(ostream& s, const NLComponent& c)\n{\nreturn c.print(s);\n}\nVirtual-acting non-member functions, then, are easy. You write virtual\nfunctions to do the work, then write a non-virtual function that does\nnothing but call the virtual function. To avoid incurring the cost of a\nfunction call for this syntactic sleight-of-hand, of course, you inline the\nnon-virtual function.\nNow that you know how to make non-member functions act virtually\non one of their arguments, you may wonder if it’s possible to make\nthem act virtually on more than one of their arguments. It is, but it’s\nnot easy. How hard is it? Turn to Item 31; it’s devoted to that question.\n\n\n130\nItem 26\nItem 26: Limiting the number of objects of a class.\nLimiting Object Instantiations\nOkay, you’re crazy about objects, but sometimes you’d like to bound\nyour insanity. For example, you’ve got only one printer in your system,\nso you’d like to somehow limit the number of printer objects to one. Or\nyou’ve got only 16 file descriptors you can hand out, so you’ve got to\nmake sure there are never more than that many file descriptor objects\nin existence. How can you do such things? How can you limit the num-\nber of objects?\nIf this were a proof by mathematical induction, we might start with\nn = 1, then build from there. Fortunately, this is neither a proof nor an\ninduction. Moreover, it turns out to be instructive to begin with n = 0,\nso we’ll start there instead. How do you prevent objects from being in-\nstantiated at all?\nAllowing Zero or One Objects\nEach time an object is instantiated, we know one thing for sure: a con-\nstructor will be called. That being the case, the easiest way to prevent\nobjects of a particular class from being created is to declare the con-\nstructors of that class private:\nclass CantBeInstantiated {\nprivate:\nCantBeInstantiated();\nCantBeInstantiated(const CantBeInstantiated&);\n...\n};\nHaving thus removed everybody’s right to create objects, we can selec-\ntively loosen the restriction. If, for example, we want to create a class\nfor printers, but we also want to abide by the constraint that there is\nonly one printer available to us, we can encapsulate the printer object\ninside a function so that everybody has access to the printer, but only\na single printer object is created:\nclass PrintJob;\n// forward declaration\nclass Printer {\npublic:\nvoid submitJob(const PrintJob& job);\nvoid reset();\nvoid performSelfTest();\n...\nfriend Printer& thePrinter();\n\n\nLimiting Object Instantiations\n131\nprivate:\nPrinter();\nPrinter(const Printer& rhs);\n...\n};\nPrinter& thePrinter()\n{\nstatic Printer p;\n// the single printer object\nreturn p;\n}\nThere are three separate components to this design. First, the con-\nstructors of the Printer class are private. That suppresses object cre-\nation. Second, the global function thePrinter is declared a friend of\nthe class. That lets thePrinter escape the restriction imposed by the\nprivate constructors. Finally, thePrinter contains a static Printer\nobject. That means only a single object will be created.\nClient code refers to thePrinter whenever it wishes to interact with\nthe system’s lone printer. By returning a reference to a Printer object,\nthePrinter can be used in any context where a Printer object itself\ncould be:\nclass PrintJob {\npublic:\nPrintJob(const string& whatToPrint);\n...\n};\nstring buffer;\n...\n// put stuff in buffer\nthePrinter().reset();\nthePrinter().submitJob(buffer);\nIt’s possible, of course, that thePrinter strikes you as a needless ad-\ndition to the global namespace. “Yes,” you may say, “as a global func-\ntion it looks more like a global variable, but global variables are\ngauche, and I’d prefer to localize all printer-related functionality inside\nthe Printer class.” Well, far be it from me to argue with someone who\nuses words like gauche. thePrinter can just as easily be made a\nstatic member function of Printer, and that puts it right where you\nwant it. It also eliminates the need for a friend declaration, which\nmany regard as tacky in its own right. Using a static member function,\nPrinter looks like this:\n\n\n132\nItem 26\nclass Printer {\npublic:\nstatic Printer& thePrinter();\n...\nprivate:\nPrinter();\nPrinter(const Printer& rhs);\n...\n};\nPrinter& Printer::thePrinter()\n{\nstatic Printer p;\nreturn p;\n}\nClients must now be a bit wordier when they refer to the printer:\nPrinter::thePrinter().reset();\nPrinter::thePrinter().submitJob(buffer);\nAnother approach is to move Printer and thePrinter out of the glo-\nbal scope and into a namespace. Namespaces are a recent addition to\nC++. Anything that can be declared at global scope can also be de-\nclared in a namespace. This includes classes, structs, functions, vari-\nables, objects, typedefs, etc. The fact that something is in a namespace\ndoesn’t affect its behavior, but it does prevent name conflicts between\nentities in different namespaces. By putting the Printer class and the\nthePrinter function into a namespace, we don’t have to worry about\nwhether anybody else happened to choose the names Printer or\nthePrinter for themselves; our namespace prevents name conflicts.\nSyntactically, namespaces look much like classes, but there are no\npublic, protected, or private sections; everything is public. This is how\nwe’d put Printer and thePrinter into a namespace called Print-\ningStuff:\nnamespace PrintingStuff {\nclass Printer {\n// this class is in the\npublic:\n// PrintingStuff namespace\nvoid submitJob(const PrintJob& job);\nvoid reset();\nvoid performSelfTest();\n...\nfriend Printer& thePrinter();\n\n\nLimiting Object Instantiations\n133\nprivate:\nPrinter();\nPrinter(const Printer& rhs);\n...\n};\nPrinter& thePrinter()\n// so is this function \n{\nstatic Printer p;\nreturn p;\n}\n} \n// this is the end of the\n// namespace\nGiven this namespace, clients can refer to thePrinter using a fully-\nqualified name (i.e., one that includes the name of the namespace),\nPrintingStuff::thePrinter().reset();\nPrintingStuff::thePrinter().submitJob(buffer);\nbut they can also employ a using declaration to save themselves key-\nstrokes:\nusing PrintingStuff::thePrinter; // import the name\n// \"thePrinter\" from the\n// namespace \"PrintingStuff\"\n// into the current scope\nthePrinter().reset();\n// now thePrinter can be\nthePrinter().submitJob(buffer);\n// used as if it were a\n// local name\nThere are two subtleties in the implementation of thePrinter that are\nworth exploring. First, it’s important that the single Printer object be\nstatic in a function and not in a class. An object that’s static in a class\nis, for all intents and purposes, always constructed (and destructed),\neven if it’s never used. In contrast, an object that’s static in a function\nis created the first time through the function, so if the function is never\ncalled, the object is never created. (You do, however, pay for a check\neach time the function is called to see whether the object needs to be\ncreated.) One of the philosophical pillars on which C++ was built is the\nidea that you shouldn’t pay for things you don’t use, and defining an\nobject like our printer as a static object in a function is one way of ad-\nhering to this philosophy. It’s a philosophy you should adhere to when-\never you can.\nThere is another drawback to making the printer a class static versus\na function static, and that has to do with its time of initialization. We\nknow exactly when a function static is initialized: the first time\nthrough the function at the point where the static is defined. The situ-\n\n\n134\nItem 26\nation with a class static (or, for that matter, a global static, should you\nbe so gauche as to use one) is less well defined. C++ offers certain\nguarantees regarding the order of initialization of statics within a par-\nticular translation unit (i.e., a body of source code that yields a single\nobject file), but it says nothing about the initialization order of static\nobjects in different translation units. In practice, this turns out to be a\nsource of countless headaches. Function statics, when they can be\nmade to suffice, allow us to avoid these headaches. In our example\nhere, they can, so why suffer?\nThe second subtlety has to do with the interaction of inlining and static\nobjects inside functions. Look again at the code for the non-member\nversion of thePrinter:\nPrinter& thePrinter()\n{\nstatic Printer p;\nreturn p;\n}\nExcept for the first time through this function (when p must be con-\nstructed), this is a one-line function — it consists entirely of the state-\nment “return p;”. If ever there were a good candidate for inlining, this\nfunction would certainly seem to be the one. Yet it’s not declared in-\nline. Why not?\nConsider for a moment why you’d declare an object to be static. It’s\nusually because you want only a single copy of that object, right? Now\nconsider what inline means. Conceptually, it means compilers\nshould replace each call to the function with a copy of the function\nbody, but for non-member functions, it also means something else. It\nmeans the functions in question have internal linkage.\nYou don’t ordinarily need to worry about such linguistic mumbo\njumbo, but there is one thing you must remember: functions with in-\nternal linkage may be duplicated within a program (i.e., the object code\nfor the program may contain more than one copy of each function with\ninternal linkage), and this duplication includes static objects contained\nwithin the functions. The result? If you create an inline non-member\nfunction containing a local static object, you may end up with more\nthan one copy of the static object in your program! So don’t create in-\nline non-member functions that contain local static data.†\nBut maybe you think this business of creating a function to return a\nreference to a hidden object is the wrong way to go about limiting the\nnumber of objects in the first place. Perhaps you think it’s better to\nsimply count the number of objects in existence and throw an excep-\n† In July 1996, the ISO/ANSI standardization committee changed the default linkage of\ninline functions to external, so the problem I describe here has been eliminated, at\nleast on paper. Your compilers may not yet be in accord with the standard, however,\nso your best bet is still to shy away from inline functions with static data.\n",
      "page_number": 141,
      "chapter_number": 15,
      "summary": "This chapter covers segment 15 (pages 141-151). Key topics include object, classes, and function. Covers function. You call a constructor only when you\ndon’t yet have an object but you know exactly what type you’d like to\nhave.",
      "keywords": [
        "virtual copy constructor",
        "printer",
        "virtual",
        "function",
        "object",
        "copy constructor",
        "virtual copy",
        "printer object",
        "copy",
        "constructor",
        "functions",
        "public",
        "Graphic",
        "virtual function",
        "static Printer"
      ],
      "concepts": [
        "object",
        "classes",
        "function",
        "functions",
        "functionality",
        "virtual",
        "virtually",
        "printer",
        "likely",
        "public"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 3,
          "title": "Segment 3 (pages 17-24)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 30,
          "title": "Segment 30 (pages 317-324)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 21,
          "title": "Segment 21 (pages 651-684)",
          "relevance_score": 0.58,
          "method": "api"
        }
      ]
    },
    {
      "number": 16,
      "title": "Segment 16 (pages 152-161)",
      "start_page": 152,
      "end_page": 161,
      "detection_method": "topic_boundary",
      "content": "Limiting Object Instantiations\n135\ntion in a constructor if too many objects are requested. In other words,\nmaybe you think we should handle printer creation like this:\nclass Printer {\npublic:\nclass TooManyObjects{};\n// exception class for use\n// when too many objects\n// are requested\nPrinter();\n~Printer();\n...\nprivate:\nstatic size_t numObjects;\nPrinter(const Printer& rhs); // there is a limit of 1\n// printer, so never allow\n};\n// copying\nThe idea is to use numObjects to keep track of how many Printer ob-\njects are in existence. This value will be incremented in the class con-\nstructor and decremented in its destructor. If an attempt is made to\nconstruct too many Printer objects, we throw an exception of type\nTooManyObjects:\n// Obligatory definition of the class static\nsize_t Printer::numObjects = 0;\nPrinter::Printer()\n{\nif (numObjects >= 1) {\nthrow TooManyObjects();\n}\nproceed with normal construction here;\n++numObjects;\n}\nPrinter::~Printer()\n{\nperform normal destruction here;\n--numObjects;\n}\nThis approach to limiting object creation is attractive for a couple of\nreasons. For one thing, it’s straightforward — everybody should be\nable to understand what’s going on. For another, it’s easy to generalize\nso that the maximum number of objects is some number other than\none.\n\n\n136\nItem 26\nContexts for Object Construction\nThere is also a problem with this strategy. Suppose we have a special\nkind of printer, say, a color printer. The class for such printers would\nhave much in common with our generic printer class, so of course we’d\ninherit from it:\nclass ColorPrinter: public Printer {\n...\n};\nNow suppose we have one generic printer and one color printer in our\nsystem:\nPrinter p;\nColorPrinter cp;\nHow many Printer objects result from these object definitions? The\nanswer is two: one for p and one for the Printer part of cp. At run-\ntime, a TooManyObjects exception will be thrown during the con-\nstruction of the base class part of cp. For many programmers, this is\nneither what they want nor what they expect. (Designs that avoid hav-\ning concrete classes inherit from other concrete classes do not suffer\nfrom this problem. For details on this design philosophy, see Item 33.)\nA similar problem occurs when Printer objects are contained inside\nother objects:\nclass CPFMachine {\n// for machines that can\nprivate:\n// copy, print, and fax\nPrinter p;\n// for printing capabilities\nFaxMachine f;\n// for faxing capabilities\nCopyMachine c;\n// for copying capabilities\n...\n};\nCPFMachine m1;\n// fine\nCPFMachine m2;\n// throws TooManyObjects exception\nThe problem is that Printer objects can exist in three different con-\ntexts: on their own, as base class parts of more derived objects, and\nembedded inside larger objects. The presence of these different con-\ntexts significantly muddies the waters regarding what it means to keep\ntrack of the “number of objects in existence,” because what you con-\nsider to be the existence of an object may not jibe with your compilers’.\nOften you will be interested only in allowing objects to exist on their\nown, and you will wish to limit the number of those kinds of instantia-\ntions. That restriction is easy to satisfy if you adopt the strategy exem-\n\n\nLimiting Object Instantiations\n137\nplified by our original Printer class, because the Printer\nconstructors are private, and (in the absence of friend declarations)\nclasses with private constructors can’t be used as base classes, nor\ncan they be embedded inside other objects. \nThe fact that you can’t derive from classes with private constructors\nleads to a general scheme for preventing derivation, one that doesn’t\nnecessarily have to be coupled with limiting object instantiations. Sup-\npose, for example, you have a class, FSA, for representing finite state\nautomata. (Such state machines are useful in many contexts, among\nthem user interface design.) Further suppose you’d like to allow any\nnumber of FSA objects to be created, but you’d also like to ensure that\nno class ever inherits from FSA. (One reason for doing this might be to\njustify the presence of a nonvirtual destructor in FSA. As Item 24 ex-\nplains, classes without virtual functions yield smaller objects than do\nequivalent classes with virtual functions.) Here’s how you can design\nFSA to satisfy both criteria:\nclass FSA {\npublic:\n// pseudo-constructors\nstatic FSA * makeFSA();\nstatic FSA * makeFSA(const FSA& rhs);\n...\nprivate:\nFSA();\nFSA(const FSA& rhs);\n...\n};\nFSA * FSA::makeFSA()\n{ return new FSA(); }\nFSA * FSA::makeFSA(const FSA& rhs)\n{ return new FSA(rhs); }\nUnlike the thePrinter function that always returned a reference to a\nsingle object, each makeFSA pseudo-constructor returns a pointer to a\nunique object. That’s what allows an unlimited number of FSA objects\nto be created.\nThis is nice, but the fact that each pseudo-constructor calls new im-\nplies that callers will have to remember to call delete. Otherwise a re-\nsource leak will be introduced. Callers who wish to have delete called\nautomatically when the current scope is exited can store the pointer\nreturned from makeFSA in an auto_ptr object (see Item 9); such ob-\njects automatically delete what they point to when they themselves go\nout of scope:\n\n\n138\nItem 26\n// indirectly call default FSA constructor\nauto_ptr<FSA> pfsa1(FSA::makeFSA());\n// indirectly call FSA copy constructor\nauto_ptr<FSA> pfsa2(FSA::makeFSA(*pfsa1));\n...\n// use pfsa1 and pfsa2 as normal pointers,\n// but don’t worry about deleting them\nAllowing Objects to Come and Go\nWe now know how to design a class that allows only a single instanti-\nation, we know that keeping track of the number of objects of a partic-\nular class is complicated by the fact that object constructors are called\nin three different contexts, and we know that we can eliminate the con-\nfusion surrounding object counts by making constructors private. It is\nworthwhile to make one final observation. Our use of the thePrinter\nfunction to encapsulate access to a single object limits the number of\nPrinter objects to one, but it also limits us to a single Printer object\nfor each run of the program. As a result, it’s not possible to write code\nlike this:\ncreate Printer object p1;\nuse p1;\ndestroy p1;\ncreate Printer object p2;\nuse p2;\ndestroy p2;\n...\nThis design never instantiates more than a single Printer object at a\ntime, but it does use different Printer objects in different parts of the\nprogram. It somehow seems unreasonable that this isn’t allowed. After\nall, at no point do we violate the constraint that only one printer may\nexist. Isn’t there a way to make this legal?\nThere is. All we have to do is combine the object-counting code we used\nearlier with the pseudo-constructors we just saw:\nclass Printer {\npublic:\nclass TooManyObjects{};\n// pseudo-constructor\nstatic Printer * makePrinter();\n~Printer();\n\n\nLimiting Object Instantiations\n139\nvoid submitJob(const PrintJob& job);\nvoid reset();\nvoid performSelfTest();\n...\nprivate:\nstatic size_t numObjects;\nPrinter();\nPrinter(const Printer& rhs); // we don’t define this\n};\n// function, because we’ll\n// never allow copying\n// Obligatory definition of class static\nsize_t Printer::numObjects = 0;\nPrinter::Printer()\n{\nif (numObjects >= 1) {\nthrow TooManyObjects();\n}\nproceed with normal object construction here;\n++numObjects;\n}\nPrinter * Printer::makePrinter()\n{ return new Printer; }\nIf the notion of throwing an exception when too many objects are re-\nquested strikes you as unreasonably harsh, you could have the\npseudo-constructor return a null pointer instead. Clients would then\nhave to check for this before doing anything with it, of course.\nClients use this Printer class just as they would any other class, ex-\ncept they must call the pseudo-constructor function instead of the real\nconstructor:\nPrinter p1;\n// error! default ctor is\n// private\nPrinter *p2 =\nPrinter::makePrinter();\n// fine, indirectly calls\n// default ctor\nPrinter p3 = *p2;\n// error! copy ctor is \n// private\np2->performSelfTest();\n// all other functions are\np2->reset();\n// called as usual\n...\ndelete p2;\n// avoid resource leak; this\n// would be unnecessary if\n// p2 were an auto_ptr\n\n\n140\nItem 26\nThis technique is easily generalized to any number of objects. All we\nhave to do is replace the hard-wired constant 1 with a class-specific\nvalue, then lift the restriction against copying objects. For example, the\nfollowing revised implementation of our Printer class allows up to 10\nPrinter objects to exist:\nclass Printer {\npublic:\nclass TooManyObjects{};\n// pseudo-constructors \nstatic Printer * makePrinter();\nstatic Printer * makePrinter(const Printer& rhs);\n...\nprivate:\nstatic size_t numObjects;\nstatic const size_t maxObjects = 10;\n// see below\nPrinter();\nPrinter(const Printer& rhs);\n};\n// Obligatory definitions of class statics\nsize_t Printer::numObjects = 0;\nconst size_t Printer::maxObjects;\nPrinter::Printer()\n{\nif (numObjects >= maxObjects) {\nthrow TooManyObjects();\n}\n...\n}\nPrinter::Printer(const Printer& rhs)\n{\nif (numObjects >= maxObjects) {\nthrow TooManyObjects();\n}\n...\n}\nPrinter * Printer::makePrinter()\n{ return new Printer; }\nPrinter * Printer::makePrinter(const Printer& rhs)\n{ return new Printer(rhs); }\nDon’t be surprised if your compilers get all upset about the declaration\nof Printer::maxObjects in the class definition above. In particular, be\n\n\nLimiting Object Instantiations\n141\nprepared for them to complain about the specification of 10 as an ini-\ntial value for that variable. The ability to specify initial values for static\nconst members (of integral type, e.g., ints, chars, enums, etc.) inside\na class definition was added to C++ only relatively recently, so some\ncompilers don’t yet allow it. If your compilers are as-yet-unupdated,\npacify them by declaring maxObjects to be an enumerator inside a pri-\nvate anonymous enum,\nclass Printer {\nprivate:\nenum { maxObjects = 10 };\n// within this class,\n...\n// maxObjects is the\n};\n// constant 10\nor by initializing the constant static like a non-const static member:\nclass Printer {\nprivate:\nstatic const size_t maxObjects;\n// no initial value given\n...\n};\n// this goes in a single implementation file\nconst size_t Printer::maxObjects = 10;\nThis latter approach has the same effect as the original code above, but\nexplicitly specifying the initial value is easier for other programmers to\nunderstand. When your compilers support the specification of initial\nvalues for const static members in class definitions, you should take\nadvantage of that capability.\nAn Object-Counting Base Class\nInitialization of statics aside, the approach above works like the pro-\nverbial charm, but there is one aspect of it that continues to nag. If we\nhad a lot of classes like Printer whose instantiations needed to be\nlimited, we’d have to write this same code over and over, once per\nclass. That would be mind-numbingly dull. Given a fancy-pants lan-\nguage like C++, it somehow seems we should be able to automate the\nprocess. Isn’t there a way to encapsulate the notion of counting in-\nstances and bundle it into a class?\nWe can easily come up with a base class for counting object instances\nand have classes like Printer inherit from that, but it turns out we\ncan do even better. We can actually come up with a way to encapsulate\nthe whole counting kit and kaboodle, by which I mean not only the\nfunctions to manipulate the instance count, but also the instance\ncount itself. (We’ll see the need for a similar trick when we examine ref-\nerence counting in Item 29.) \n\n\n142\nItem 26\nThe counter in the Printer class is the static variable numObjects, so\nwe need to move that variable into an instance-counting class. How-\never, we also need to make sure that each class for which we’re count-\ning instances has a separate counter. Use of a counting class template\nlets us automatically generate the appropriate number of counters, be-\ncause we can make the counter a static member of the classes gener-\nated from the template:\ntemplate<class BeingCounted>\nclass Counted {\npublic:\nclass TooManyObjects{};\n// for throwing exceptions\nstatic size_t objectCount() { return numObjects; }\nprotected:\nCounted();\nCounted(const Counted& rhs);\n~Counted() { --numObjects; }\nprivate:\nstatic size_t numObjects;\nstatic const size_t maxObjects;\nvoid init();\n// to avoid ctor code\n};\n// duplication\ntemplate<class BeingCounted>\nCounted<BeingCounted>::Counted()\n{ init(); }\ntemplate<class BeingCounted>\nCounted<BeingCounted>::Counted(const Counted<BeingCounted>&)\n{ init(); }\ntemplate<class BeingCounted>\nvoid Counted<BeingCounted>::init()\n{\nif (numObjects >= maxObjects) throw TooManyObjects();\n++numObjects;\n}\nThe classes generated from this template are designed to be used only\nas base classes, hence the protected constructors and destructor. Note\nthe use of the private member function init to avoid duplicating the\nstatements in the two Counted constructors.\nWe can now modify the Printer class to use the Counted template:\n\n\nLimiting Object Instantiations\n143\nclass Printer: private Counted<Printer> {\npublic:\n// pseudo-constructors\nstatic Printer * makePrinter();\nstatic Printer * makePrinter(const Printer& rhs);\n~Printer();\nvoid submitJob(const PrintJob& job);\nvoid reset();\nvoid performSelfTest();\n...\nusing Counted<Printer>::objectCount;\n// see below\nusing Counted<Printer>::TooManyObjects;\n// see below\nprivate:\nPrinter();\nPrinter(const Printer& rhs);\n};\nThe fact that Printer uses the Counted template to keep track of how\nmany Printer objects exist is, frankly, nobody’s business but the au-\nthor of Printer’s. Such implementation details are best kept private,\nand that’s why private inheritance is used here. The alternative would\nbe to use public inheritance between Printer and\nCounted<Printer>, but then we’d be obliged to give the Counted\nclasses a virtual destructor. (Otherwise we’d risk incorrect behavior if\nsomebody deleted a Printer object through a Counted<Printer>*\npointer.) As Item 24 makes clear, the presence of a virtual function in\nCounted would almost certainly affect the size and layout of objects of\nclasses inheriting from Counted. We don’t want to absorb that over-\nhead, and the use of private inheritance lets us avoid it.\nQuite properly, most of what Counted does is hidden from Printer’s\nclients, but those clients might reasonably want to find out how many\nPrinter objects exist. The Counted template offers the objectCount\nfunction to provide this information, but that function becomes private\nin Printer due to our use of private inheritance. To restore the public\naccessibility of that function, we employ a using declaration:\nclass Printer: private Counted<Printer> {\npublic:\n...\nusing Counted<Printer>::objectCount;\n// make this function\n// public for clients\n...\n// of Printer\n};\n\n\n144\nItem 26\nThis is perfectly legitimate, but if your compilers don’t yet support\nnamespaces, they won’t allow it. If they don’t, you can use the older ac-\ncess declaration syntax:\nclass Printer: private Counted<Printer> {\npublic:\n...\nCounted<Printer>::objectCount;\n// make objectCount\n// public in Printer\n...\n};\nThis more traditional syntax has the same meaning as the using dec-\nlaration, but it’s deprecated. The class TooManyObjects is handled in\nthe same fashion as objectCount, because clients of Printer must\nhave access to TooManyObjects if they are to be able to catch excep-\ntions of that type.\nWhen Printer inherits from Counted<Printer>, it can forget about\ncounting objects. The class can be written as if somebody else were\ndoing the counting for it, because somebody else (Counted<Printer>)\nis. A Printer constructor now looks like this:\nPrinter::Printer()\n{\nproceed with normal object construction;\n}\nWhat’s interesting here is not what you see, it’s what you don’t. No\nchecking of the number of objects to see if the limit is about to be ex-\nceeded, no incrementing the number of objects in existence once the\nconstructor is done. All that is now handled by the Counted<Printer>\nconstructors, and because Counted<Printer> is a base class of\nPrinter, we know that a Counted<Printer> constructor will always\nbe called before a Printer constructor. If too many objects are cre-\nated, a Counted<Printer> constructor throws an exception, and the\nPrinter constructor won’t even be invoked. Nifty, huh?\nNifty or not, there’s one loose end that demands to be tied, and that’s\nthe mandatory definitions of the statics inside Counted. It’s easy\nenough to take care of numObjects — we just put this in Counted’s\nimplementation file:\ntemplate<class BeingCounted>\n// defines numObjects\nsize_t Counted<BeingCounted>::numObjects;\n// and automatically\n// initializes it to 0\nThe situation with maxObjects is a bit trickier. To what value should\nwe initialize this variable? If we want to allow up to 10 printers, we\nshould initialize Counted<Printer>::maxObjects to 10. If, on the\n",
      "page_number": 152,
      "chapter_number": 16,
      "summary": "This chapter covers segment 16 (pages 152-161). Key topics include classes, printer, and object. In other words,\nmaybe you think we should handle printer creation like this:\nclass Printer {\npublic:\nclass TooManyObjects{};\n// exception class for use\n// when too many objects\n// are requested\nPrinter();\n~Printer();.",
      "keywords": [
        "printer",
        "Printer objects",
        "class Printer",
        "Counted",
        "FSA",
        "const Printer",
        "objects",
        "static Printer",
        "Limiting Object Instantiations",
        "single Printer object",
        "Printer objects exist",
        "Limiting Object",
        "create Printer object",
        "static",
        "Object Instantiations"
      ],
      "concepts": [
        "classes",
        "printer",
        "object",
        "counts",
        "constructor",
        "statics",
        "instantiations",
        "instantiates",
        "public",
        "functions"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 9,
          "title": "Segment 9 (pages 68-76)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 24,
          "title": "Segment 24 (pages 241-248)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 2,
          "title": "Segment 2 (pages 11-18)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 3,
          "title": "Segment 3 (pages 17-26)",
          "relevance_score": 0.5,
          "method": "api"
        }
      ]
    },
    {
      "number": 17,
      "title": "Segment 17 (pages 162-169)",
      "start_page": 162,
      "end_page": 169,
      "detection_method": "topic_boundary",
      "content": "Requiring or Prohibiting Heap-Based Objects\n145\nother hand, we want to allow up to 16 file descriptor objects, we should\ninitialize Counted<FileDescriptor>::maxObjects to 16. What to do?\nWe take the easy way out: we do nothing. We provide no initialization\nat all for maxObjects. Instead, we require that clients of the class pro-\nvide the appropriate initialization. The author of Printer must add\nthis to an implementation file:\nconst size_t Counted<Printer>::maxObjects = 10;\nSimilarly, the author of FileDescriptor must add this:\nconst size_t Counted<FileDescriptor>::maxObjects = 16;\nWhat will happen if these authors forget to provide a suitable definition\nfor maxObjects? Simple: they’ll get an error during linking, because\nmaxObjects will be undefined. Provided we’ve adequately documented\nthis requirement for clients of Counted, they can then say “Duh” to\nthemselves and go back and add the requisite initialization.\nItem 27: Requiring or prohibiting heap-based objects.\nRequiring or Prohibiting Heap-Based Objects\nSometimes you want to arrange things so that objects of a particular\ntype can commit suicide, i.e., can “delete this.” Such an arrange-\nment clearly requires that objects of that type be allocated on the heap.\nOther times you’ll want to bask in the certainty that there can be no\nmemory leaks for a particular class, because none of the objects could\nhave been allocated on the heap. This might be the case if you are\nworking on an embedded system, where memory leaks are especially\ntroublesome and heap space is at a premium. Is it possible to produce\ncode that requires or prohibits heap-based objects? Often it is, but it\nalso turns out that the notion of being “on the heap” is more nebulous\nthan you might think.\nRequiring Heap-Based Objects\nLet us begin with the prospect of limiting object creation to the heap.\nTo enforce such a restriction, you’ve got to find a way to prevent clients\nfrom creating objects other than by calling new. This is easy to do. Non-\nheap objects are automatically constructed at their point of definition\nand automatically destructed at the end of their lifetime, so it suffices\nto simply make these implicit constructions and destructions illegal. \nThe straightforward way to make these calls illegal is to declare the\nconstructors and the destructor private. This is overkill. There’s no\nreason why they both need to be private. Better to make the destructor\nprivate and the constructors public. Then, in a process that should be\nfamiliar from Item 26, you can introduce a privileged pseudo-destruc-\n\n\n146\nItem 27\ntor function that has access to the real destructor. Clients then call the\npseudo-destructor to destroy the objects they’ve created.\nIf, for example, we want to ensure that objects representing unlimited\nprecision numbers are created only on the heap, we can do it like this:\nclass UPNumber {\npublic:\nUPNumber();\nUPNumber(int initValue);\nUPNumber(double initValue);\nUPNumber(const UPNumber& rhs);\n// pseudo-destructor (a const member function, because\n// even const objects may be destroyed)\nvoid destroy() const { delete this; }\n...\nprivate:\n~UPNumber();\n};\nClients would then program like this:\nUPNumber n;\n// error! (legal here, but\n// illegal when n’s dtor is\n// later implicitly invoked)\nUPNumber *p = new UPNumber;\n// fine\n...\ndelete p;\n// error! attempt to call\n// private destructor\np->destroy();\n// fine\nAn alternative is to declare all the constructors private. The drawback\nto that idea is that a class often has many constructors, and the class’s\nauthor must remember to declare each of them private. This includes\nthe copy constructor, and it may include a default constructor, too, if\nthese functions would otherwise be generated by compilers; compiler-\ngenerated functions are always public. As a result, it’s easier to declare\nonly the destructor private, because a class can have only one of those.\nRestricting access to a class’s destructor or its constructors prevents\nthe creation of non-heap objects, but, in a story that is told in Item 26,\nit also prevents both inheritance and containment:\nclass UPNumber { ... };\n// declares dtor or ctors\n// private\nclass NonNegativeUPNumber:\npublic UPNumber { ... };\n// error! dtor or ctors\n// won’t compile\n\n\nRequiring or Prohibiting Heap-Based Objects\n147\nclass Asset {\nprivate:\nUPNumber value;\n...\n// error! dtor or ctors\n// won’t compile\n};\nNeither of these difficulties is insurmountable. The inheritance prob-\nlem can be solved by making UPNumber’s destructor protected (while\nkeeping its constructors public), and classes that need to contain ob-\njects of type UPNumber can be modified to contain pointers to UPNumber\nobjects instead:\nclass UPNumber { ... };\n// declares dtor protected\nclass NonNegativeUPNumber:\npublic UPNumber { ... };\n// now okay; derived \n// classes have access to \n// protected members\nclass Asset {\npublic:\nAsset(int initValue);\n~Asset();\n...\nprivate:\nUPNumber *value;\n};\nAsset::Asset(int initValue)\n: value(new UPNumber(initValue))\n// fine\n{ ... }\nAsset::~Asset()\n{ value->destroy(); }\n// also fine\nDetermining Whether an Object is On The Heap\nIf we adopt this strategy, we must reexamine what it means to be “on\nthe heap.” Given the class definition sketched above, it’s legal to define\na non-heap NonNegativeUPNumber object:\nNonNegativeUPNumber n;\n// fine \nNow, the UPNumber part of the NonNegativeUPNumber object n is not\non the heap. Is that okay? The answer depends on the details of the\nclass’s design and implementation, but let us suppose it is not okay,\nthat all UPNumber objects — even base class parts of more derived ob-\njects — must be on the heap. How can we enforce this restriction?\nThere is no easy way. It is not possible for a UPNumber constructor to\ndetermine whether it’s being invoked as the base class part of a heap-\n\n\n148\nItem 27\nbased object. That is, there is no way for the UPNumber constructor to\ndetect that the following contexts are different:\nNonNegativeUPNumber *n1 =\nnew NonNegativeUPNumber;\n// on heap\nNonNegativeUPNumber n2;\n// not on heap\nBut perhaps you don’t believe me. Perhaps you think you can play\ngames with the interaction among the new operator, operator new and\nthe constructor that the new operator calls (see Item 8). Perhaps you\nthink you can outsmart them all by modifying UPNumber as follows:\nclass UPNumber {\npublic:\n// exception to throw if a non-heap object is created\nclass HeapConstraintViolation {};\nstatic void * operator new(size_t size);\nUPNumber();\n...\nprivate:\nstatic bool onTheHeap;\n// inside ctors, whether\n// the object being\n...\n// constructed is on heap\n};\n// obligatory definition of class static\nbool UPNumber::onTheHeap = false;\nvoid *UPNumber::operator new(size_t size)\n{\nonTheHeap = true;\nreturn ::operator new(size);\n}\nUPNumber::UPNumber()\n{\nif (!onTheHeap) {\nthrow HeapConstraintViolation();\n}\nproceed with normal construction here;\nonTheHeap = false;\n// clear flag for next obj.\n}\nThere’s nothing deep going on here. The idea is to take advantage of\nthe fact that when an object is allocated on the heap, operator new is\ncalled to allocate the raw memory, then a constructor is called to ini-\ntialize an object in that memory. In particular, operator new sets\nonTheHeap to true, and each constructor checks onTheHeap to see if\nthe raw memory of the object being constructed was allocated by op-\n\n\nRequiring or Prohibiting Heap-Based Objects\n149\nerator new. If not, an exception of type HeapConstraintViolation is\nthrown. Otherwise, construction proceeds as usual, and when con-\nstruction is finished, onTheHeap is set to false, thus resetting the de-\nfault value for the next object to be constructed.\nThis is a nice enough idea, but it won’t work. Consider this potential\nclient code:\nUPNumber *numberArray = new UPNumber[100];\nThe first problem is that the memory for the array is allocated by op-\nerator new[], not operator new, but (provided your compilers sup-\nport it) you can write the former function as easily as the latter. What\nis more troublesome is the fact that numberArray has 100 elements,\nso there will be 100 constructor calls. But there is only one call to al-\nlocate memory, so onTheHeap will be set to true for only the first of\nthose 100 constructors. When the second constructor is called, an ex-\nception is thrown, and woe is you.\nEven without arrays, this bit-setting business may fail. Consider this\nstatement:\nUPNumber *pn = new UPNumber(*new UPNumber);\nHere we create two UPNumbers on the heap and make pn point to one\nof them; it’s initialized with the value of the second one. This code has\na resource leak, but let us ignore that in favor of an examination of\nwhat happens during execution of this expression:\nnew UPNumber(*new UPNumber)\nThis contains two calls to the new operator, hence two calls to opera-\ntor new and two calls to UPNumber constructors (see Item 8). Program-\nmers typically expect these function calls to be executed in this order,\n1.\nCall operator new for first object (the leftmost one above)\n2.\nCall constructor for first object\n3.\nCall operator new for second object (the one used as an argu-\nment to the first UPNumber’s constructor)\n4.\nCall constructor for second object\nbut the language makes no guarantee that this is how it will be done.\nSome compilers generate the function calls in this order instead:\n1.\nCall operator new for first object\n2.\nCall operator new for second object\n3.\nCall constructor for second object\n4.\nCall constructor for first object\n\n\n150\nItem 27\nThere is nothing wrong with compilers that generate this kind of code,\nbut the set-a-bit-in-operator-new trick fails with such compilers.\nThat’s because the bit set in steps 1 and 2 is cleared in step 3, thus\nmaking the object constructed in step 3 think it’s not on the heap, even\nthough it is.\nThese difficulties don’t invalidate the basic idea of having each con-\nstructor check to see if *this is on the heap. Rather, they indicate that\nchecking a bit set inside operator new (or operator new[]) is not a\nreliable way to determine this information. What we need is a better\nway to figure it out.\nIf you’re desperate enough, you might be tempted to descend into the\nrealm of the unportable. For example, you might decide to take advan-\ntage of the fact that on many systems, a program’s address space is or-\nganized as a linear sequence of addresses, with the program’s stack\ngrowing down from the top of the address space and the heap rising up\nfrom the bottom:\nOn systems that organize a program’s memory in this way (many do,\nbut many do not), you might think you could use the following func-\ntion to determine whether a particular address is on the heap:\n// incorrect attempt to determine whether an address\n// is on the heap\nbool onHeap(const void *address)\n{\nchar onTheStack;\n// local stack variable\nreturn address < &onTheStack;\n}\nThe thinking behind this function is interesting. Inside onHeap,\nonTheStack is a local variable. As such, it is, well, it’s on the stack.\nHigh\nAddresses\nLow\nAddresses\nHeap\nStack\n(Grows Down)\n(Grows Up)\nProgram’s\nAddress\nSpace\n(Incomplete\nPicture)\n\n\nRequiring or Prohibiting Heap-Based Objects\n151\nWhen onHeap is called, its stack frame (i.e., its activation record) will\nbe placed at the top of the program’s stack, and because the stack\ngrows down (toward lower addresses) in this architecture, the address\nof onTheStack must be less than the address of any other stack-based\nvariable or object. If the parameter address is less than the location of\nonTheStack, it can’t be on the stack, so it must be on the heap.\nSuch logic is fine, as far as it goes, but it doesn’t go far enough. The\nfundamental problem is that there are three places where objects may\nbe allocated, not two. Yes, the stack and the heap hold objects, but let\nus not forget about static objects. Static objects are those that are ini-\ntialized only once during a program run. Static objects comprise not\nonly those objects explicitly declared static, but also objects at global\nand namespace scope. Such objects have to go somewhere, and that\nsomewhere is neither the stack nor the heap.\nWhere they go is system-dependent, but on many of the systems that\nhave the stack and heap grow toward one another, they go below the\nheap. The earlier picture of memory organization, while telling the\ntruth and nothing but the truth for many systems, failed to tell the\nwhole truth for those systems. With static objects added to the picture,\nit looks like this:\nSuddenly it becomes clear why onHeap won’t work, not even on sys-\ntems where it’s purported to: it fails to distinguish between heap ob-\njects and static objects:\nvoid allocateSomeObjects()\n{\nchar *pc = new char;\n// heap object: onHeap(pc)\n// will return true\nHigh\nAddresses\nLow\nAddresses\nHeap\nStack\nStatic\nObjects\n(Grows Down)\n(Grows Up)\nProgram’s\nAddress\nSpace\n(Complete\nPicture)\n\n\n152\nItem 27\nchar c;\n// stack object: onHeap(&c)\n// will return false\nstatic char sc;\n// static object: onHeap(&sc)\n// will return true\n...\n}\nNow, you may be desperate for a way to tell heap objects from stack ob-\njects, and in your desperation you may be willing to strike a deal with\nthe portability Devil, but are you so desperate that you’ll strike a deal\nthat fails to guarantee you the right answers? Surely not, so I know\nyou’ll reject this seductive but unreliable compare-the-addresses trick.\nThe sad fact is there’s not only no portable way to determine whether\nan object is on the heap, there isn’t even a semi-portable way that\nworks most of the time.† If you absolutely, positively have to tell\nwhether an address is on the heap, you’re going to have to turn to un-\nportable, implementation-dependent system calls, and that’s that.\nThat being the case, you’re better off trying to redesign your software\nso you don’t need to determine whether an object is on the heap in the\nfirst place.\nIf you find yourself obsessing over whether an object is on the heap,\nthe likely cause is that you want to know if it’s safe to invoke delete\non it. Often such deletion will take the form of the infamous “delete\nthis.” Knowing whether it’s safe to delete a pointer, however, is not the\nsame as simply knowing whether that pointer points to something on\nthe heap, because not all pointers to things on the heap can be safely\ndeleted. Consider again an Asset object that contains a UPNumber\nobject:\nclass Asset {\nprivate:\nUPNumber value;\n...\n};\nAsset *pa = new Asset;\nClearly *pa (including its member value) is on the heap. Equally\nclearly, it’s not safe to invoke delete on a pointer to pa->value, be-\ncause no such pointer was ever returned from new.\nAs luck would have it, it’s easier to determine whether it’s safe to delete\na pointer than to determine whether a pointer points to something on\nthe heap, because all we need to answer the former question is a col-\nlection of addresses that have been returned by operator new. Since\nwe can write operator new ourselves, it’s easy to construct such a col-\nlection. Here’s how we might approach the problem:\n† I have since become convinced that signature-based techniques are all but foolproof.\nFor details, consult http://www.aristeia.com/BookErrata/M27Comments.html.\n",
      "page_number": 162,
      "chapter_number": 17,
      "summary": "This chapter covers segment 17 (pages 162-169). Key topics include objects, heap, and classes. We provide no initialization\nat all for maxObjects.",
      "keywords": [
        "UPNumber",
        "Objects",
        "heap",
        "Prohibiting Heap-Based Objects",
        "Heap-Based Objects",
        "operator",
        "Asset",
        "Requiring or Prohibiting",
        "constructor",
        "static objects",
        "Prohibiting Heap-Based",
        "class UPNumber",
        "stack",
        "private",
        "call"
      ],
      "concepts": [
        "objects",
        "heap",
        "classes",
        "address",
        "addresses",
        "static",
        "stack",
        "item",
        "constructors",
        "asset"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 6,
          "title": "Segment 6 (pages 48-56)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 21,
          "title": "Segment 21 (pages 193-203)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 38,
          "title": "Segment 38 (pages 351-358)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 36,
          "title": "Segment 36 (pages 1145-1179)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.54,
          "method": "api"
        }
      ]
    },
    {
      "number": 18,
      "title": "Segment 18 (pages 170-177)",
      "start_page": 170,
      "end_page": 177,
      "detection_method": "topic_boundary",
      "content": "Requiring or Prohibiting Heap-Based Objects\n153\nvoid *operator new(size_t size)\n{\nvoid *p = getMemory(size);\n// call some function to\n// allocate memory and\n// handle out-of-memory\n// conditions\nadd p to the collection of allocated addresses;\nreturn p;\n}\nvoid operator delete(void *ptr)\n{\nreleaseMemory(ptr);\n// return memory to\n// free store\nremove ptr from the collection of allocated addresses;\n}\nbool isSafeToDelete(const void *address)\n{\nreturn whether address is in collection of \nallocated addresses;\n}\nThis is about as simple as it gets. operator new adds entries to a col-\nlection of allocated addresses, operator delete removes entries, and\nisSafeToDelete does a lookup in the collection to see if a particular\naddress is there. If the operator new and operator delete functions\nare at global scope, this should work for all types, even the built-ins.\nIn practice, three things are likely to dampen our enthusiasm for this\ndesign. The first is our extreme reluctance to define anything at global\nscope, especially functions with predefined meanings like operator\nnew and operator delete. Knowing as we do that there is but one glo-\nbal scope and but a single version of operator new and operator de-\nlete with the “normal” signatures (i.e., sets of parameter types) within\nthat scope, the last thing we want to do is seize those function signa-\ntures for ourselves. Doing so would render our software incompatible\nwith any other software that also implements global versions of oper-\nator new and operator delete (such as many object-oriented data-\nbase systems).\nOur second consideration is one of efficiency: why burden all heap al-\nlocations with the bookkeeping overhead necessary to keep track of re-\nturned addresses if we don’t need to?\nOur final concern is pedestrian, but important. It turns out to be es-\nsentially impossible to implement isSafeToDelete so that it always\nworks. The difficulty has to do with the fact that objects with multiple\n\n\n154\nItem 27\nor virtual base classes have multiple addresses, so there’s no guaran-\ntee that the address passed to isSafeToDelete is the same as the one\nreturned from operator new, even if the object in question was allo-\ncated on the heap. For details, see Items 24 and 31.\nWhat we’d like is the functionality provided by these functions without\nthe concomitant pollution of the global namespace, the mandatory\noverhead, and the correctness problems. Fortunately, C++ gives us ex-\nactly what we need in the form of an abstract mixin base class. \nAn abstract base class is a base class that can’t be instantiated, i.e.,\none with at least one pure virtual function. A mixin (“mix in”) class is\none that provides a single well-defined capability and is designed to be\ncompatible with any other capabilities an inheriting class might pro-\nvide. Such classes are nearly always abstract. We can therefore come\nup with an abstract mixin base class that offers derived classes the\nability to determine whether a pointer was allocated from operator\nnew. Here’s such a class:\nclass HeapTracked {\n// mixin class; keeps track of \npublic:\n// ptrs returned from op. new\nclass MissingAddress{};\n// exception class; see below\nvirtual ~HeapTracked() = 0;\nstatic void *operator new(size_t size);\nstatic void operator delete(void *ptr);\nbool isOnHeap() const;\nprivate:\ntypedef const void* RawAddress;\nstatic list<RawAddress> addresses;\n};\nThis class uses the list data structure that’s part of the standard C++\nlibrary (see Item 35) to keep track of all pointers returned from oper-\nator new. That function allocates memory and adds entries to the list;\noperator delete deallocates memory and removes entries from the\nlist; and isOnHeap returns whether an object’s address is in the list.\nImplementation of the HeapTracked class is simple, because the glo-\nbal operator new and operator delete functions are called to per-\nform the real memory allocation and deallocation, and the list class\nhas functions to make insertion, removal, and lookup single-statement\noperations. Here’s the full implementation of HeapTracked:\n// mandatory definition of static class member\nlist<RawAddress> HeapTracked::addresses;\n\n\nRequiring or Prohibiting Heap-Based Objects\n155\n// HeapTracked’s destructor is pure virtual to make the \n// class abstract. The destructor must still be \n// defined, however, so we provide this empty definition.\nHeapTracked::~HeapTracked() {}\nvoid * HeapTracked::operator new(size_t size)\n{\nvoid *memPtr = ::operator new(size);// get the memory\naddresses.push_front(memPtr);\n// put its address at\n// the front of the list\nreturn memPtr;\n}\nvoid HeapTracked::operator delete(void *ptr)\n{\n// gracefully hande null pointers\nif (ptr == 0) return;\n// get an \"iterator\" that identifies the list\n// entry containing ptr; see Item 35 for details\nlist<RawAddress>::iterator it =\nfind(addresses.begin(), addresses.end(), ptr);\n  if (it != addresses.end()) {\n// if an entry was found\naddresses.erase(it);\n// remove the entry \n::operator delete(ptr);\n// deallocate the memory\n} else {\n// otherwise\nthrow MissingAddress();\n// ptr wasn’t allocated by\n}\n// op. new, so throw an\n}\n// exception\nbool HeapTracked::isOnHeap() const\n{\n// get a pointer to the beginning of the memory\n// occupied by *this; see below for details\nconst void *rawAddress = dynamic_cast<const void*>(this);\n// look up the pointer in the list of addresses \n// returned by operator new\nlist<RawAddress>::iterator it =\nfind(addresses.begin(), addresses.end(), rawAddress);\n  return it != addresses.end();\n// return whether it was\n}\n// found\nThis code is straightforward, though it may not look that way if you are\nunfamiliar with the list class and the other components of the Stan-\ndard Template Library. Item 35 explains everything, but the comments\nin the code above should be sufficient to explain what’s happening in\nthis example. \nThe only other thing that may confound you is this statement (in\nisOnHeap):\nconst void *rawAddress = dynamic_cast<const void*>(this);\n\n\n156\nItem 27\nI mentioned earlier that writing the global function isSafeToDelete is\ncomplicated by the fact that objects with multiple or virtual base\nclasses have several addresses. That problem plagues us in isOnHeap,\ntoo, but because isOnHeap applies only to HeapTracked objects, we\ncan exploit a special feature of the dynamic_cast operator (see Item 2)\nto eliminate the problem. Simply put, dynamic_casting a pointer to\nvoid* (or const void* or volatile void* or, for those who can’t get\nenough modifiers in their usual diet, const volatile void*) yields a\npointer to the beginning of the memory for the object pointed to by the\npointer. But dynamic_cast is applicable only to pointers to objects\nthat have at least one virtual function. Our ill-fated isSafeToDelete\nfunction had to work with any type of pointer, so dynamic_cast\nwouldn’t help it. isOnHeap is more selective (it tests only pointers to\nHeapTracked objects), so dynamic_casting this to const void*\ngives us a pointer to the beginning of the memory for the current ob-\nject. That’s the pointer that HeapTracked::operator new must have\nreturned if the memory for the current object was allocated by Heap-\nTracked::operator new in the first place. Provided your compilers\nsupport the dynamic_cast operator, this technique is completely por-\ntable.\nGiven this class, even BASIC programmers could add to a class the\nability to track pointers to heap allocations. All they’d need to do is\nhave the class inherit from HeapTracked. If, for example, we want to\nbe able to determine whether a pointer to an Asset object points to a\nheap-based object, we’d modify Asset’s class definition to specify\nHeapTracked as a base class:\nclass Asset: public HeapTracked {\nprivate:\nUPNumber value;\n...\n};\nWe could then query Asset* pointers as follows:\nvoid inventoryAsset(const Asset *ap)\n{\nif (ap->isOnHeap()) {\nap is a heap-based asset — inventory it as such;\n}\nelse {\nap is a non-heap-based asset — record it that way;\n}\n}\nA disadvantage of a mixin class like HeapTracked is that it can’t be\nused with the built-in types, because types like int and char can’t in-\n\n\nRequiring or Prohibiting Heap-Based Objects\n157\nherit from anything. Still, the most common reason for wanting to use\na class like HeapTracked is to determine whether it’s okay to “delete\nthis,” and you’ll never want to do that with a built-in type because\nsuch types have no this pointer.\nProhibiting Heap-Based Objects\nThus ends our examination of determining whether an object is on the\nheap. At the opposite end of the spectrum is preventing objects from\nbeing allocated on the heap. Here the outlook is a bit brighter. There\nare, as usual, three cases: objects that are directly instantiated, ob-\njects instantiated as base class parts of derived class objects, and ob-\njects embedded inside other objects. We’ll consider each in turn.\nPreventing clients from directly instantiating objects on the heap is\neasy, because such objects are always created by calls to new and you\ncan make it impossible for clients to call new. Now, you can’t affect the\navailability of the new operator (that’s built into the language), but you\ncan take advantage of the fact that the new operator always calls op-\nerator new (see Item 8), and that function is one you can declare your-\nself. In particular, it is one you can declare private. If, for example,\nyou want to keep clients from creating UPNumber objects on the heap,\nyou could do it this way:\nclass UPNumber {\nprivate:\nstatic void *operator new(size_t size);\nstatic void operator delete(void *ptr);\n...\n};\nClients can now do only what they’re supposed to be able to do:\nUPNumber n1;\n// okay\nstatic UPNumber n2;\n// also okay\nUPNumber *p = new UPNumber;\n// error! attempt to call \n// private operator new\nIt suffices to declare operator new private, but it looks strange to have\noperator new be private and operator delete be public, so unless\nthere’s a compelling reason to split up the pair, it’s best to declare\nthem in the same part of a class. If you’d like to prohibit heap-based\narrays of UPNumber objects, too, you could declare operator new[]\nand operator delete[] (see Item 8) private as well.\nInterestingly, declaring operator new private often also prevents UP-\nNumber objects from being instantiated as base class parts of heap-\n\n\n158\nItem 27\nbased derived class objects. That’s because operator new and oper-\nator delete are inherited, so if these functions aren’t declared public\nin a derived class, that class inherits the private versions declared in\nits base(s):\nclass UPNumber { ... };\n// as above\nclass NonNegativeUPNumber:\n// assume this class\npublic UPNumber {\n// declares no operator new\n...\n};\nNonNegativeUPNumber n1;\n// okay\nstatic NonNegativeUPNumber n2; // also okay\nNonNegativeUPNumber *p =\n// error! attempt to call\nnew NonNegativeUPNumber;\n// private operator new\nIf the derived class declares an operator new of its own, that function\nwill be called when allocating derived class objects on the heap, and a\ndifferent way will have to be found to prevent UPNumber base class\nparts from winding up there. Similarly, the fact that UPNumber’s oper-\nator new is private has no effect on attempts to allocate objects con-\ntaining UPNumber objects as members:\nclass Asset {\npublic:\nAsset(int initValue);\n...\nprivate:\nUPNumber value;\n};\nAsset *pa = new Asset(100);\n// fine, calls \n// Asset::operator new or\n// ::operator new, not\n// UPNumber::operator new\nFor all practical purposes, this brings us back to where we were when\nwe wanted to throw an exception in the UPNumber constructors if a UP-\nNumber object was being constructed in memory that wasn’t on the\nheap. This time, of course, we want to throw an exception if the object\nin question is on the heap. Just as there is no portable way to deter-\nmine if an address is on the heap, however, there is no portable way to\ndetermine that it is not on the heap, so we’re out of luck. This should\nbe no surprise. After all, if we could tell when an address is on the\nheap, we could surely tell when an address is not on the heap. But we\ncan’t, so we can’t. Oh well.\n\n\nSmart Pointers\n159\nItem 28: Smart pointers.\nSmart Pointers\nSmart pointers are objects that are designed to look, act, and feel like\nbuilt-in pointers, but to offer greater functionality. They have a variety\nof applications, including resource management (see Items 9, 10, 25,\nand 31) and the automation of repetitive coding tasks (see Items 17\nand 29).\nWhen you use smart pointers in place of C++’s built-in pointers (i.e.,\ndumb pointers), you gain control over the following aspects of pointer\nbehavior:\n■Construction and destruction. You determine what happens\nwhen a smart pointer is created and destroyed. It is common to\ngive smart pointers a default value of 0 to avoid the headaches as-\nsociated with uninitialized pointers. Some smart pointers are\nmade responsible for deleting the object they point to when the\nlast smart pointer pointing to the object is destroyed. This can go a\nlong way toward eliminating resource leaks.\n■Copying and assignment. You control what happens when a\nsmart pointer is copied or is involved in an assignment. For some\nsmart pointer types, the desired behavior is to automatically copy\nor make an assignment to what is pointed to, i.e., to perform a\ndeep copy. For others, only the pointer itself should be copied or\nassigned. For still others, these operations should not be allowed\nat all. Regardless of what behavior you consider “right,” the use of\nsmart pointers lets you call the shots.\n■Dereferencing. What should happen when a client refers to the\nobject pointed to by a smart pointer? You get to decide. You could,\nfor example, use smart pointers to help implement the lazy fetch-\ning strategy outlined in Item 17. \nSmart pointers are generated from templates because, like built-in\npointers, they must be strongly typed; the template parameter speci-\nfies the type of object pointed to. Most smart pointer templates look\nsomething like this:\n\n\n160\nItem 28\ntemplate<class T>\n// template for smart\nclass SmartPtr {\n// pointer objects\npublic:\nSmartPtr(T* realPtr = 0);\n// create a smart ptr to an\n// obj given a dumb ptr to\n// it; uninitialized ptrs\n// default to 0 (null)\nSmartPtr(const SmartPtr& rhs); // copy a smart ptr \n~SmartPtr();\n// destroy a smart ptr\n// make an assignment to a smart ptr\nSmartPtr& operator=(const SmartPtr& rhs);\nT* operator->() const;\n// dereference a smart ptr\n// to get at a member of\n// what it points to\nT& operator*() const;\n// dereference a smart ptr\nprivate:\nT *pointee;\n// what the smart ptr\n};\n// points to\nThe copy constructor and assignment operator are both shown public\nhere. For smart pointer classes where copying and assignment are not\nallowed, they would typically be declared private. The two dereferenc-\ning operators are declared const, because dereferencing a pointer\ndoesn’t modify it (though it may lead to modification of what the\npointer points to). Finally, each smart pointer-to-T object is imple-\nmented by containing a dumb pointer-to-T within it. It is this dumb\npointer that does the actual pointing.\nBefore going into the details of smart pointer implementation, it’s\nworth seeing how clients might use smart pointers. Consider a distrib-\nuted system in which some objects are local and some are remote. Ac-\ncess to local objects is generally simpler and faster than access to\nremote objects, because remote access may require remote procedure\ncalls or some other way of communicating with a distant machine. \nFor clients writing application code, the need to handle local and re-\nmote objects differently is a nuisance. It is more convenient to have all\nobjects appear to be located in the same place. Smart pointers allow a\nlibrary to offer this illusion:\ntemplate<class T>\n// template for smart ptrs\nclass DBPtr {\n// to objects in a\npublic:\n// distributed DB\nDBPtr(T *realPtr = 0);\n// create a smart ptr to a \n// DB object given a local\n// dumb pointer to it\n",
      "page_number": 170,
      "chapter_number": 18,
      "summary": "A mixin (“mix in”) class is\none that provides a single well-defined capability and is designed to be\ncompatible with any other capabilities an inheriting class might pro-\nvide Key topics include classes, objects, and operator.",
      "keywords": [
        "operator",
        "Smart Pointers",
        "Objects",
        "Smart",
        "operator delete",
        "pointer",
        "void",
        "Item",
        "void operator delete",
        "smart ptr",
        "ptr",
        "HeapTracked",
        "base class",
        "const void",
        "Asset"
      ],
      "concepts": [
        "classes",
        "objects",
        "operator",
        "operations",
        "pointer",
        "asset",
        "address",
        "void",
        "base",
        "based"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 19,
          "title": "Segment 19 (pages 188-197)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "Segment 16 (pages 162-174)",
          "relevance_score": 0.46,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 26,
          "title": "Segment 26 (pages 230-237)",
          "relevance_score": 0.45,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 30,
          "title": "Segment 30 (pages 950-980)",
          "relevance_score": 0.43,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 15,
          "title": "Segment 15 (pages 154-161)",
          "relevance_score": 0.43,
          "method": "api"
        }
      ]
    },
    {
      "number": 19,
      "title": "Segment 19 (pages 178-189)",
      "start_page": 178,
      "end_page": 189,
      "detection_method": "topic_boundary",
      "content": "Smart Pointers\n161\nDBPtr(DataBaseID id);\n// create a smart ptr to a\n// DB object given its\n// unique DB identifier\n...\n// other smart ptr\n};\n// functions as above\nclass Tuple {\n// class for database\npublic:\n// tuples\n...\nvoid displayEditDialog();\n// present a graphical \n// dialog box allowing a\n// user to edit the tuple\nbool isValid() const;\n// return whether *this\n};\n// passes validity check\n// class template for making log entries whenever a T\n// object is modified; see below for details\ntemplate<class T>\nclass LogEntry {\npublic:\nLogEntry(const T& objectToBeModified);\n~LogEntry();\n};\nvoid editTuple(DBPtr<Tuple>& pt)\n{\nLogEntry<Tuple> entry(*pt);\n// make log entry for this\n// editing operation; see \n// below for details\n// repeatedly display edit dialog until valid values\n// are provided\ndo {\npt->displayEditDialog();\n} while (pt->isValid() == false);\n}\nThe tuple to be edited inside editTuple may be physically located on\na remote machine, but the programmer writing editTuple need not be\nconcerned with such matters; the smart pointer class hides that as-\npect of the system. As far as the programmer is concerned, all tuples\nare accessed through objects that, except for how they’re declared, act\njust like run-of-the-mill built-in pointers.\nNotice the use of a LogEntry object in editTuple. A more conven-\ntional design would have been to surround the call to displayEdit-\nDialog with calls to begin and end the log entry. In the approach\nshown here, the LogEntry’s constructor begins the log entry and its\ndestructor ends the log entry. As Item 9 explains, using an object to\nbegin and end logging is more robust in the face of exceptions than ex-\nplicitly calling functions, so you should accustom yourself to using\n\n\n162\nItem 28\nclasses like LogEntry. Besides, it’s easier to create a single LogEntry\nobject than to add separate calls to start and stop an entry.\nAs you can see, using a smart pointer isn’t much different from using\nthe dumb pointer it replaces. That’s testimony to the effectiveness of\nencapsulation. Clients of smart pointers are supposed to be able to\ntreat them as dumb pointers. As we shall see, sometimes the substitu-\ntion is more transparent than others.\nConstruction, Assignment, and Destruction of Smart Pointers\nConstruction of a smart pointer is usually straightforward: locate an\nobject to point to (typically by using the smart pointer’s constructor ar-\nguments), then make the smart pointer’s internal dumb pointer point\nthere. If no object can be located, set the internal pointer to 0 or signal\nan error (possibly by throwing an exception).\nImplementing a smart pointer’s copy constructor, assignment opera-\ntor(s) and destructor is complicated somewhat by the issue of owner-\nship. If a smart pointer owns the object it points to, it is responsible for\ndeleting that object when it (the smart pointer) is destroyed. This as-\nsumes the object pointed to by the smart pointer is dynamically allo-\ncated. Such an assumption is common when working with smart\npointers. (For ideas on how to make sure the assumption is true, see\nItem 27.)\nConsider the auto_ptr template from the standard C++ library. As\nItem 9 explains, an auto_ptr object is a smart pointer that points to a\nheap-based object until it (the auto_ptr) is destroyed. When that hap-\npens, the auto_ptr’s destructor deletes the pointed-to object. The\nauto_ptr template might be implemented like this:\ntemplate<class T>\nclass auto_ptr {\npublic:\nauto_ptr(T *ptr = 0): pointee(ptr) {}\n~auto_ptr() { delete pointee; }\n...\nprivate:\nT *pointee;\n};\nThis works fine provided only one auto_ptr owns an object. But what\nshould happen when an auto_ptr is copied or assigned?\nauto_ptr<TreeNode> ptn1(new TreeNode);\nauto_ptr<TreeNode> ptn2 = ptn1;\n// call to copy ctor;\n// what should happen?\n\n\nSmart Pointers\n163\nauto_ptr<TreeNode> ptn3;\nptn3 = ptn2;\n// call to operator=;\n// what should happen?\nIf we just copied the internal dumb pointer, we’d end up with two\nauto_ptrs pointing to the same object. This would lead to grief, be-\ncause each auto_ptr would delete what it pointed to when the\nauto_ptr was destroyed. That would mean we’d delete an object more\nthan once. The results of such double-deletes are undefined (and are\nfrequently disastrous).\nAn alternative would be to create a new copy of what was pointed to by\ncalling new. That would guarantee we didn’t have too many auto_ptrs\npointing to a single object, but it might engender an unacceptable per-\nformance hit for the creation (and later destruction) of the new object.\nFurthermore, we wouldn’t necessarily know what type of object to cre-\nate, because an auto_ptr<T> object need not point to an object of type\nT; it might point to an object of a type derived from T. Virtual construc-\ntors (see Item 25) can help solve this problem, but it seems inappropri-\nate to require their use in a general-purpose class like auto_ptr.\nThe problems would vanish if auto_ptr prohibited copying and assign-\nment, but a more flexible solution was adopted for the auto_ptr classes:\nobject ownership is transferred when an auto_ptr is copied or assigned:\ntemplate<class T>\nclass auto_ptr {\npublic:\n...\nauto_ptr(auto_ptr<T>& rhs);\n// copy constructor\nauto_ptr<T>&\n// assignment\noperator=(auto_ptr<T>& rhs);\n// operator\n...\n};\ntemplate<class T>\nauto_ptr<T>::auto_ptr(auto_ptr<T>& rhs)\n{\npointee = rhs.pointee;\n// transfer ownership of\n// *pointee to *this\nrhs.pointee = 0;\n// rhs no longer owns\n}\n// anything\n\n\n164\nItem 28\ntemplate<class T>\nauto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<T>& rhs)\n{\nif (this == &rhs)\n// do nothing if this\nreturn *this;\n// object is being assigned\n// to itself\ndelete pointee;\n// delete currently owned\n// object\npointee = rhs.pointee;\n// transfer ownership of\nrhs.pointee = 0;\n// *pointee from rhs to *this\nreturn *this;\n}\nNotice that the assignment operator must delete the object it owns be-\nfore assuming ownership of a new object. If it failed to do this, the ob-\nject would never be deleted. Remember, nobody but the auto_ptr\nobject owns the object the auto_ptr points to.\nBecause object ownership is transferred when auto_ptr’s copy con-\nstructor is called, passing auto_ptrs by value is often a very bad idea.\nHere’s why:\n// this function will often lead to disaster\nvoid printTreeNode(ostream& s, auto_ptr<TreeNode> p)\n{ s << *p; }\nint main()\n{\nauto_ptr<TreeNode> ptn(new TreeNode);\n...\nprintTreeNode(cout, ptn);\n// pass auto_ptr by value\n...\n}\nWhen printTreeNode’s parameter p is initialized (by calling\nauto_ptr’s copy constructor), ownership of the object pointed to by\nptn is transferred to p. When printTreeNode finishes executing, p\ngoes out of scope and its destructor deletes what it points to (which is\nwhat ptn used to point to). ptn, however, no longer points to anything\n(its underlying dumb pointer is null), so just about any attempt to use\nit after the call to printTreeNode will yield undefined behavior. Pass-\ning auto_ptrs by value, then, is something to be done only if you’re\nsure you want to transfer ownership of an object to a (transient) func-\ntion parameter. Only rarely will you want to do this.\n\n\nSmart Pointers\n165\nThis doesn’t mean you can’t pass auto_ptrs as parameters, it just\nmeans that pass-by-value is not the way to do it. Pass-by-reference-to-\nconst is:\n// this function behaves much more intuitively\nvoid printTreeNode(ostream& s, \nconst auto_ptr<TreeNode>& p)\n{ s << *p; }\nIn this function, p is a reference, not an object, so no constructor is\ncalled to initialize p. When ptn is passed to this version of print-\nTreeNode, it retains ownership of the object it points to, and ptn can\nsafely be used after the call to printTreeNode. Thus, passing\nauto_ptrs by reference-to-const avoids the hazards arising from\npass-by-value.\nThe notion of transferring ownership from one smart pointer to an-\nother during copying and assignment is interesting, but you may have\nbeen at least as interested in the unconventional declarations of the\ncopy constructor and assignment operator. These functions normally\ntake const parameters, but above they do not. In fact, the code above\nchanges these parameters during the copy or the assignment. In other\nwords, auto_ptr objects are modified if they are copied or are the\nsource of an assignment!\nYes, that’s exactly what’s happening. Isn’t it nice that C++ is flexible\nenough to let you do this? If the language required that copy construc-\ntors and assignment operators take const parameters, you’d probably\nhave to cast away the parameters’ constness or play other games to\nimplement ownership transferral. Instead, you get to say exactly what\nyou want to say: when an object is copied or is the source of an assign-\nment, that object is changed. This may not seem intuitive, but it’s sim-\nple, direct, and, in this case, accurate.\nIf you find this examination of auto_ptr member functions interest-\ning, you may wish to see a complete implementation. You’ll find one on\npages 291-294, where you’ll also see that the auto_ptr template in\nthe standard C++ library has copy constructors and assignment oper-\nators that are more flexible than those described here. In the standard\nauto_ptr template, those functions are member function templates,\nnot just member functions. (Member function templates are described\nlater in this Item.)\nA smart pointer’s destructor often looks like this:\n\n\n166\nItem 28\ntemplate<class T>\nSmartPtr<T>::~SmartPtr()\n{\nif (*this owns *pointee) {\ndelete pointee;\n}\n}\nSometimes there is no need for the test. An auto_ptr always owns\nwhat it points to, for example. At other times the test is a bit more com-\nplicated. A smart pointer that employs reference counting (see Item 29)\nmust adjust a reference count before determining whether it has the\nright to delete what it points to. Of course, some smart pointers are like\ndumb pointers: they have no effect on the object they point to when\nthey themselves are destroyed.\nImplementing the Dereferencing Operators\nLet us now turn our attention to the very heart of smart pointers, the\noperator* and operator-> functions. The former returns the object\npointed to. Conceptually, this is simple:\ntemplate<class T>\nT& SmartPtr<T>::operator*() const \n{\nperform \"smart pointer\" processing;\nreturn *pointee;\n}\nFirst the function does whatever processing is needed to initialize or\notherwise make pointee valid. For example, if lazy fetching is being\nused (see Item 17), the function may have to conjure up a new object\nfor pointee to point to. Once pointee is valid, the operator* func-\ntion just returns a reference to the pointed-to object.\nNote that the return type is a reference. It would be disastrous to re-\nturn an object instead, though compilers will let you do it. Bear in\nmind that pointee need not point to an object of type T; it may point\nto an object of a class derived from T. If that is the case and your op-\nerator* function returns a T object instead of a reference to the ac-\ntual derived class object, your function will return an object of the\nwrong type! (This is the slicing problem — see Item 13.) Virtual func-\ntions invoked on the object returned from your star-crossed opera-\ntor* will not invoke the function corresponding to the dynamic type of\nthe pointed-to object. In essence, your smart pointer will not properly\nsupport virtual functions, and how smart is a pointer like that? Be-\nsides, returning a reference is more efficient anyway, because there is\nno need to construct a temporary object (see Item 19). This is one of\n\n\nSmart Pointers\n167\nthose happy occasions when correctness and efficiency go hand in\nhand.\nIf you’re the kind who likes to worry, you may wonder what you should\ndo if somebody invokes operator* on a null smart pointer, i.e., one\nwhose embedded dumb pointer is null. Relax. You can do anything you\nwant. The result of dereferencing a null pointer is undefined, so there\nis no “wrong” behavior. Wanna throw an exception? Go ahead, throw it.\nWanna call abort (possibly by having an assert call fail)? Fine, call it.\nWanna walk through memory setting every byte to your birth date\nmodulo 256? That’s okay, too. It’s not nice, but as far as the language\nis concerned, you are completely unfettered.\nThe story with operator-> is similar to that for operator*, but before\nexamining operator->, let us remind ourselves of the unusual mean-\ning of a call to this function. Consider again the editTuple function\nthat uses a smart pointer-to-Tuple object:\nvoid editTuple(DBPtr<Tuple>& pt)\n{\nLogEntry<Tuple> entry(*pt);\ndo {\npt->displayEditDialog();\n} while (pt->isValid() == false);\n}\nThe statement\npt->displayEditDialog();\nis interpreted by compilers as:\n(pt.operator->())->displayEditDialog();\nThat means that whatever operator-> returns, it must be legal to\napply the member-selection operator (->) to it. There are thus only two\nthings operator-> can return: a dumb pointer to an object or another\nsmart pointer object. Most of the time, you’ll want to return an ordi-\nnary dumb pointer. In those cases, you implement operator-> as fol-\nlows:\ntemplate<class T>\nT* SmartPtr<T>::operator->() const\n{\nperform \"smart pointer\" processing;\nreturn pointee;\n}\nThis will work fine. Because this function returns a pointer, virtual\nfunction calls via operator-> will behave the way they’re supposed to.\n\n\n168\nItem 28\nFor many applications, this is all you need to know about smart point-\ners. The reference-counting code of Item 29, for example, draws on no\nmore functionality than we’ve discussed here. If you want to push your\nsmart pointers further, however, you must know more about dumb\npointer behavior and how smart pointers can and cannot emulate it. If\nyour motto is “Most people stop at the Z — but not me!”, the material\nthat follows is for you.\nTesting Smart Pointers for Nullness\nWith the functions we have discussed so far, we can create, destroy,\ncopy, assign, and dereference smart pointers. One of the things we\ncannot do, however, is find out if a smart pointer is null:\nSmartPtr<TreeNode> ptn;\n...\nif (ptn == 0) ...\n// error!\nif (ptn) ...\n// error!\nif (!ptn) ...\n// error!\nThis is a serious limitation. \nIt would be easy to add an isNull member function to our smart\npointer classes, but that wouldn’t address the problem that smart\npointers don’t act like dumb pointers when testing for nullness. A dif-\nferent approach is to provide an implicit conversion operator that al-\nlows the tests above to compile. The conversion traditionally employed\nfor this purpose is to void*:\ntemplate<class T>\nclass SmartPtr {\npublic:\n...\noperator void*();\n// returns 0 if the smart\n...\n// ptr is null, nonzero\n};\n// otherwise\nSmartPtr<TreeNode> ptn;\n...\nif (ptn == 0) ...\n// now fine\nif (ptn) ...\n// also fine\nif (!ptn) ...\n// fine\nThis is similar to a conversion provided by the iostream classes, and it\nexplains why it’s possible to write code like this:\nifstream inputFile(\"datafile.dat\");\n\n\nSmart Pointers\n169\nif (inputFile) ...\n// test to see if inputFile\n// was successfully \n// opened\nLike all type conversion functions, this one has the drawback of letting\nfunction calls succeed that most programmers would expect to fail (see\nItem 5). In particular, it allows comparisons of smart pointers of com-\npletely different types:\nSmartPtr<Apple> pa;\nSmartPtr<Orange> po;\n...\nif (pa == po) ...\n// this compiles!\nEven if there is no operator== taking a SmartPtr<Apple> and a\nSmartPtr<Orange>, this compiles, because both smart pointers can\nbe implicitly converted into void* pointers, and there is a built-in\ncomparison function for built-in pointers. This kind of behavior makes\nimplicit conversion functions dangerous. (Again, see Item 5, and keep\nseeing it over and over until you can see it in the dark.)\nThere are variations on the conversion-to-void* motif. Some designers\nadvocate conversion to const void*, others embrace conversion to\nbool. Neither of these variations eliminates the problem of allowing\nmixed-type comparisons.\nThere is a middle ground that allows you to offer a reasonable syntac-\ntic form for testing for nullness while minimizing the chances of acci-\ndentally comparing smart pointers of different types. It is to overload\noperator! for your smart pointer classes so that operator! returns\ntrue if and only if the smart pointer on which it’s invoked is null:\ntemplate<class T>\nclass SmartPtr {\npublic:\n...\nbool operator!() const;\n// returns true if and only\n...\n// if the smart ptr is null\n};\nThis lets your clients program like this,\n\n\n170\nItem 28\nSmartPtr<TreeNode> ptn;\n...\nif (!ptn) {\n// fine\n...\n// ptn is null \n}\nelse {\n...\n// ptn is not null\n}\nbut not like this:\nif (ptn == 0) ...\n// still an error\nif (ptn) ...\n// also an error\nThe only risk for mixed-type comparisons is statements such as these:\nSmartPtr<Apple> pa;\nSmartPtr<Orange> po;\n...\nif (!pa == !po) ...\n// alas, this compiles\nFortunately, programmers don’t write code like this very often. Inter-\nestingly, iostream library implementations provide an operator! in\naddition to the implicit conversion to void*, but these two functions\ntypically test for slightly different stream states. (In the C++ library\nstandard (see Item 35), the implicit conversion to void* has been re-\nplaced by an implicit conversion to bool, and operator bool always\nreturns the negation of operator!.)\nConverting Smart Pointers to Dumb Pointers\nSometimes you’d like to add smart pointers to an application or library\nthat already uses dumb pointers. For example, your distributed data-\nbase system may not originally have been distributed, so you may have\nsome old library functions that aren’t designed to use smart pointers:\nclass Tuple { ... };\n// as before\nvoid normalize(Tuple *pt);\n// put *pt into canonical\n// form; note use of dumb\n// pointer\nConsider what will happen if you try to call normalize with a smart\npointer-to-Tuple:\nDBPtr<Tuple> pt;\n...\nnormalize(pt);\n// error!\n\n\nSmart Pointers\n171\nThe call will fail to compile, because there is no way to convert a\nDBPtr<Tuple> to a Tuple*. You can make it work by doing this,\nnormalize(&*pt);\n// gross, but legal\nbut I hope you’ll agree this is repugnant.\nThe call can be made to succeed by adding to the smart pointer-to-T\ntemplate an implicit conversion operator to a dumb pointer-to-T:\ntemplate<class T>\n// as before \nclass DBPtr {\npublic:\n...\noperator T*() { return pointee; }\n...\n};\nDBPtr<Tuple> pt;\n...\nnormalize(pt);\n// this now works\nAddition of this function also eliminates the problem of testing for\nnullness:\nif (pt == 0) ...\n// fine, converts pt to a\n// Tuple*\nif (pt) ...\n// ditto\nif (!pt) ...\n// ditto (reprise)\nHowever, there is a dark side to such conversion functions. (There al-\nmost always is. Have you been seeing Item 5?) They make it easy for\nclients to program directly with dumb pointers, thus bypassing the\nsmarts your pointer-like objects are designed to provide:\nvoid processTuple(DBPtr<Tuple>& pt)\n{\nTuple *rawTuplePtr = pt;\n// converts DBPtr<Tuple> to\n// Tuple*\nuse rawTuplePtr to modify the tuple;\n}\nUsually, the “smart” behavior provided by a smart pointer is an essen-\ntial component of your design, so allowing clients to use dumb pointers\ntypically leads to disaster. For example, if DBPtr implements the refer-\nence-counting strategy of Item 29, allowing clients to manipulate\ndumb pointers directly will almost certainly lead to bookkeeping errors\nthat corrupt the reference-counting data structures.\n\n\n172\nItem 28\nEven if you provide an implicit conversion operator to go from a smart\npointer to the dumb pointer it’s built on, your smart pointer will never\nbe truly interchangeable with the dumb pointer. That’s because the\nconversion from a smart pointer to a dumb pointer is a user-defined\nconversion, and compilers are forbidden from applying more than one\nsuch conversion at a time. For example, suppose you have a class rep-\nresenting all the clients who have accessed a particular tuple:\nclass TupleAccessors {\npublic:\nTupleAccessors(const Tuple *pt);\n// pt identifies the\n...\n// tuple whose accessors\n};\n// we care about\nAs usual, TupleAccessors’ single-argument constructor also acts as\na type-conversion operator from Tuple* to TupleAccessors (see Item\n5). Now consider a function for merging the information in two Tuple-\nAccessors objects:\nTupleAccessors merge(const TupleAccessors& ta1,\nconst TupleAccessors& ta2);\nBecause a Tuple* may be implicitly converted to a TupleAccessors,\ncalling merge with two dumb Tuple* pointers is fine:\nTuple *pt1, *pt2;\n...\nmerge(pt1, pt2);\n// fine, both pointers are converted\n// to TupleAccessors objects\nThe corresponding call with smart DBPtr<Tuple> pointers, however,\nfails to compile:\nDBPtr<Tuple> pt1, pt2;\n...\nmerge(pt1, pt2);\n// error! No way to convert pt1 and\n// pt2 to TupleAccessors objects\nThat’s because a conversion from DBPtr<Tuple> to TupleAccessors\ncalls for two user-defined conversions (one from DBPtr<Tuple> to Tu-\nple* and one from Tuple* to TupleAccessors), and such sequences\nof conversions are prohibited by the language.\nSmart pointer classes that provide an implicit conversion to a dumb\npointer open the door to a particularly nasty bug. Consider this code:\nDBPtr<Tuple> pt = new Tuple;\n...\ndelete pt;\n",
      "page_number": 178,
      "chapter_number": 19,
      "summary": "As Item 9 explains, using an object to\nbegin and end logging is more robust in the face of exceptions than ex-\nplicitly calling functions, so you should accustom yourself to using\n 162\nItem 28\nclasses like LogEntry Key topics include operation, operator, and object.",
      "keywords": [
        "smart pointer",
        "Smart",
        "pointer",
        "auto",
        "ptr",
        "object",
        "Tuple",
        "dumb pointer",
        "Item",
        "operator",
        "smart pointer classes",
        "smart pointer object",
        "dumb",
        "function",
        "ptn"
      ],
      "concepts": [
        "operation",
        "operator",
        "object",
        "pointers",
        "functions",
        "function",
        "functionality",
        "smart",
        "classes",
        "void"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 5,
          "title": "Segment 5 (pages 46-58)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 53,
          "title": "Segment 53 (pages 1064-1083)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 13,
          "title": "Segment 13 (pages 250-271)",
          "relevance_score": 0.48,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 11,
          "title": "Segment 11 (pages 90-99)",
          "relevance_score": 0.48,
          "method": "api"
        },
        {
          "book": "C++ Concurrency in Action",
          "chapter": 6,
          "title": "Segment 6 (pages 50-58)",
          "relevance_score": 0.47,
          "method": "api"
        }
      ]
    },
    {
      "number": 20,
      "title": "Segment 20 (pages 190-199)",
      "start_page": 190,
      "end_page": 199,
      "detection_method": "topic_boundary",
      "content": "Smart Pointers\n173\nThis should not compile. After all, pt is not a pointer, it’s an object,\nand you can’t delete an object. Only pointers can be deleted, right? \nRight. But remember from Item 5 that compilers use implicit type con-\nversions to make function calls succeed whenever they can, and recall\nfrom Item 8 that use of the delete operator leads to calls to a destruc-\ntor and to operator delete, both of which are functions. Compilers\nwant these function calls to succeed, so in the delete statement\nabove, they implicitly convert pt to a Tuple*, then they delete that.\nThis will almost certainly break your program. \nIf pt owns the object it points to, that object is now deleted twice, once\nat the point where delete is called, a second time when pt’s destruc-\ntor is invoked. If pt doesn’t own the object, somebody else does. That\nsomebody may be the person who deleted pt, in which case all is well.\nIf, however, the owner of the object pointed to by pt is not the person\nwho deleted pt, we can expect the rightful owner to delete that object\nagain later. The first and last of these scenarios leads to an object\nbeing deleted twice, and deleting an object more than once yields un-\ndefined behavior.\nThis bug is especially pernicious because the whole idea behind smart\npointers is to make them look and feel as much like dumb pointers as\npossible. The closer you get to this ideal, the more likely your clients\nare to forget they are using smart pointers. If they do, who can blame\nthem if they continue to think that in order to avoid resource leaks,\nthey must call delete if they called new?\nThe bottom line is simple: don’t provide implicit conversion operators\nto dumb pointers unless there is a compelling reason to do so. \nSmart Pointers and Inheritance-Based Type Conversions\nSuppose we have a public inheritance hierarchy modeling consumer\nproducts for storing music:\nclass MusicProduct {\npublic:\nMusicProduct(const string& title);\nvirtual void play() const = 0;\nvirtual void displayTitle() const = 0;\n...\n};\nMusicProduct\nCD\nCassette\n\n\n174\nItem 28\nclass Cassette: public MusicProduct {\npublic:\nCassette(const string& title);\nvirtual void play() const;\nvirtual void displayTitle() const;\n...\n};\nclass CD: public MusicProduct {\npublic:\nCD(const string& title);\nvirtual void play() const;\nvirtual void displayTitle() const;\n...\n};\nFurther suppose we have a function that, given a MusicProduct ob-\nject, displays the title of the product and then plays it:\nvoid displayAndPlay(const MusicProduct* pmp, int numTimes)\n{\nfor (int i = 1; i <= numTimes; ++i) {\npmp->displayTitle();\npmp->play();\n}\n}\nSuch a function might be used like this:\nCassette *funMusic = new Cassette(\"Alapalooza\");\nCD *nightmareMusic = new CD(\"Disco Hits of the 70s\");\ndisplayAndPlay(funMusic, 10);\ndisplayAndPlay(nightmareMusic, 0);\nThere are no surprises here, but look what happens if we replace the\ndumb pointers with their allegedly smart counterparts:\nvoid displayAndPlay(const SmartPtr<MusicProduct>& pmp,\nint numTimes);\nSmartPtr<Cassette> funMusic(new Cassette(\"Alapalooza\"));\nSmartPtr<CD> nightmareMusic(new CD(\"Disco Hits of the 70s\"));\ndisplayAndPlay(funMusic, 10);\n// error!\ndisplayAndPlay(nightmareMusic, 0);\n// error!\nIf smart pointers are so brainy, why won’t these compile?\nThey won’t compile because there is no conversion from a SmartPtr<CD>\nor a SmartPtr<Cassette> to a SmartPtr<MusicProduct>. As far as\ncompilers are concerned, these are three separate classes — they have\nno relationship to one another. Why should compilers think otherwise?\nAfter all, it’s not like SmartPtr<CD> or SmartPtr<Cassette> inherits\nfrom SmartPtr<MusicProduct>. With no inheritance relationship be-\n\n\nSmart Pointers\n175\ntween these classes, we can hardly expect compilers to run around\nconverting objects of one type to objects of other types. \nFortunately, there is a way to get around this limitation, and the idea\n(if not the practice) is simple: give each smart pointer class an implicit\ntype conversion operator (see Item 5) for each smart pointer class to\nwhich it should be implicitly convertible. For example, in the music hi-\nerarchy, you’d add an operator SmartPtr<MusicProduct> to the\nsmart pointer classes for Cassette and CD:\nclass SmartPtr<Cassette> {\npublic:\noperator SmartPtr<MusicProduct>()\n{ return SmartPtr<MusicProduct>(pointee); }\n...\nprivate:\nCassette *pointee;\n};\nclass SmartPtr<CD> {\npublic:\noperator SmartPtr<MusicProduct>()\n{ return SmartPtr<MusicProduct>(pointee); }\n...\nprivate:\nCD *pointee;\n};\nThe drawbacks to this approach are twofold. First, you must manually\nspecialize the SmartPtr class instantiations so you can add the neces-\nsary implicit type conversion operators, but that pretty much defeats\nthe purpose of templates. Second, you may have to add many such\nconversion operators, because your pointed-to object may be deep in\nan inheritance hierarchy, and you must provide a conversion operator\nfor each base class from which that object directly or indirectly inher-\nits. (If you think you can get around this by providing only an implicit\ntype conversion operator for each direct base class, think again. Be-\ncause compilers are prohibited from employing more than one user-\ndefined type conversion function at a time, they can’t convert a smart\npointer-to-T to a smart pointer-to-indirect-base-class-of-T unless they\ncan do it in a single step.)\nIt would be quite the time-saver if you could somehow get compilers to\nwrite all these implicit type conversion functions for you. Thanks to a\nrecent language extension, you can. The extension in question is the\nability to declare (nonvirtual) member function templates (usually just\n\n\n176\nItem 28\ncalled member templates), and you use it to generate smart pointer\nconversion functions like this:\ntemplate<class T>\n// template class for smart\nclass SmartPtr {\n// pointers-to-T objects\npublic:\nSmartPtr(T* realPtr = 0);\nT* operator->() const;\nT& operator*() const;\ntemplate<class newType>\n// template function for\noperator SmartPtr<newType>() // implicit conversion ops.\n{\nreturn SmartPtr<newType>(pointee);\n}\n...\n};\nNow hold on to your headlights, this isn’t magic — but it’s close. It\nworks as follows. (I’ll give a specific example in a moment, so don’t de-\nspair if the remainder of this paragraph reads like so much gobbledy-\ngook. After you’ve seen the example, it’ll make more sense, I promise.)\nSuppose a compiler has a smart pointer-to-T object, and it’s faced with\nthe need to convert that object into a smart pointer-to-base-class-of-T.\nThe compiler checks the class definition for SmartPtr<T> to see if the\nrequisite conversion operator is declared, but it is not. (It can’t be: no\nconversion operators are declared in the template above.) The compiler\nthen checks to see if there’s a member function template it can instan-\ntiate that would let it perform the conversion it’s looking for. It finds\nsuch a template (the one taking the formal type parameter newType),\nso it instantiates the template with newType bound to the base class of\nT that’s the target of the conversion. At that point, the only question is\nwhether the code for the instantiated member function will compile. In\norder for it to compile, it must be legal to pass the (dumb) pointer\npointee to the constructor for the smart pointer-to-base-of-T. poin-\ntee is of type T, so it is certainly legal to convert it into a pointer to its\n(public or protected) base classes. Hence, the code for the type conver-\nsion operator will compile, and the implicit conversion from smart\npointer-to-T to smart pointer-to-base-of-T will succeed. \nAn example will help. Let us return to the music hierarchy of CDs, cas-\nsettes, and music products. We saw earlier that the following code\nwouldn’t compile, because there was no way for compilers to convert\nthe smart pointers to CDs or cassettes into smart pointers to music\nproducts:\n\n\nSmart Pointers\n177\nvoid displayAndPlay(const SmartPtr<MusicProduct>& pmp,\nint howMany);\nSmartPtr<Cassette> funMusic(new Cassette(\"Alapalooza\"));\nSmartPtr<CD> nightmareMusic(new CD(\"Disco Hits of the 70s\"));\ndisplayAndPlay(funMusic, 10);\n// used to be an error\ndisplayAndPlay(nightmareMusic, 0);\n// used to be an error\nWith the revised smart pointer class containing the member function\ntemplate for implicit type conversion operators, this code will succeed.\nTo see why, look at this call:\ndisplayAndPlay(funMusic, 10);\nThe object funMusic is of type SmartPtr<Cassette>. The function\ndisplayAndPlay expects a SmartPtr<MusicProduct> object. Com-\npilers detect the type mismatch and seek a way to convert funMusic\ninto a SmartPtr<MusicProduct> object. They look for a single-argu-\nment constructor (see Item 5) in the SmartPtr<MusicProduct> class\nthat takes a SmartPtr<Cassette>, but they find none. They look for\nan implicit type conversion operator in the SmartPtr<Cassette> class\nthat yields a SmartPtr<MusicProduct> class, but that search also\nfails. They then look for a member function template they can instan-\ntiate to yield one of these functions. They discover that the template in-\nside SmartPtr<Cassette>, when instantiated with newType bound to\nMusicProduct, generates the necessary function. They instantiate the\nfunction, yielding the following code:\nSmartPtr<Cassette>::operator SmartPtr<MusicProduct>()\n{\nreturn SmartPtr<MusicProduct>(pointee);\n}\nWill this compile? For all intents and purposes, nothing is happening\nhere except the calling of the SmartPtr<MusicProduct> constructor\nwith pointee as its argument, so the real question is whether one can\nconstruct a SmartPtr<MusicProduct> object with a Cassette*\npointer. The SmartPtr<MusicProduct> constructor expects a Mu-\nsicProduct* pointer, but now we’re on the familiar ground of conver-\nsions between dumb pointer types, and it’s clear that Cassette* can\nbe passed in where a MusicProduct* is expected. The construction of\nthe SmartPtr<MusicProduct> is therefore successful, and the con-\nversion of the SmartPtr<Cassette> to SmartPtr<MusicProduct> is\nequally successful. Voilà! Implicit conversion of smart pointer types.\nWhat could be simpler?\nFurthermore, what could be more powerful? Don’t be misled by this\nexample into assuming that this works only for pointer conversions up\nan inheritance hierarchy. The method shown succeeds for any legal\n\n\n178\nItem 28\nimplicit conversion between pointer types. If you’ve got a dumb pointer\ntype T1* and another dumb pointer type T2*, you can implicitly con-\nvert a smart pointer-to-T1 to a smart pointer-to-T2 if and only if you\ncan implicitly convert a T1* to a T2*.\nThis technique gives you exactly the behavior you want — almost. Sup-\npose we augment our MusicProduct hierarchy with a new class,\nCasSingle, for representing cassette singles. The revised hierarchy\nlooks like this:\nNow consider this code:\ntemplate<class T>\n// as above, including member tem-\nclass SmartPtr { ... };\n// plate for conversion operators\nvoid displayAndPlay(const SmartPtr<MusicProduct>& pmp,\nint howMany);\nvoid displayAndPlay(const SmartPtr<Cassette>& pc,\nint howMany);\nSmartPtr<CasSingle> dumbMusic(new CasSingle(\"Achy Breaky Heart\"));\ndisplayAndPlay(dumbMusic, 1);\n// error!\nIn this example, displayAndPlay is overloaded, with one function\ntaking a SmartPtr<MusicProduct> object and the other taking a\nSmartPtr<Cassette> object. When we invoke displayAndPlay with\na SmartPtr<CasSingle>, we expect the SmartPtr<Cassette> func-\ntion to be chosen, because CasSingle inherits directly from Cassette\nand only indirectly from MusicProduct. Certainly that’s how it would\nwork with dumb pointers. Alas, our smart pointers aren’t that smart.\nThey employ member functions as conversion operators, and as far as\nC++ compilers are concerned, all calls to conversion functions are\nequally good. As a result, the call to displayAndPlay is ambiguous,\nbecause the conversion from SmartPtr<CasSingle> to\nMusicProduct\nCasSingle\nCD\nCassette\n\n\nSmart Pointers\n179\nSmartPtr<Cassette> is no better than the conversion to\nSmartPtr<MusicProduct>.\nImplementing smart pointer conversions through member templates\nhas two additional drawbacks. First, support for member templates is\nrare, so this technique is currently anything but portable. In the fu-\nture, that will change, but nobody knows just how far in the future\nthat will be. Second, the mechanics of why this works are far from\ntransparent, relying as they do on a detailed understanding of argu-\nment-matching rules for function calls, implicit type conversion func-\ntions, implicit instantiation of template functions, and the existence of\nmember function templates. Pity the poor programmer who has never\nseen this trick before and is then asked to maintain or enhance code\nthat relies on it. The technique is clever, that’s for sure, but too much\ncleverness can be a dangerous thing.\nLet’s stop beating around the bush. What we really want to know is\nhow we can make smart pointer classes behave just like dumb point-\ners for purposes of inheritance-based type conversions. The answer is\nsimple: we can’t. As Daniel Edelson has noted, smart pointers are\nsmart, but they’re not pointers. The best we can do is to use member\ntemplates to generate conversion functions, then use casts (see Item 2)\nin those cases where ambiguity results. This isn’t a perfect state of af-\nfairs, but it’s pretty good, and having to cast away ambiguity in a few\ncases is a small price to pay for the sophisticated functionality smart\npointers can provide.\nSmart Pointers and const\nRecall that for dumb pointers, const can refer to the thing pointed to,\nto the pointer itself, or both:\nCD goodCD(\"Flood\");\nconst CD *p;\n// p is a non-const pointer\n// to a const CD object\nCD * const p = &goodCD;\n// p is a const pointer to \n// a non-const CD object;\n// because p is const, it\n// must be initialized\nconst CD * const p = &goodCD;\n// p is a const pointer to\n// a const CD object\nNaturally, we’d like to have the same flexibility with smart pointers.\nUnfortunately, there’s only one place to put the const, and there it ap-\nplies to the pointer, not to the object pointed to:\nconst SmartPtr<CD> p =\n// p is a const smart ptr\n&goodCD;\n// to a non-const CD object\n\n\n180\nItem 28\nThis seems simple enough to remedy — just create a smart pointer to\na const CD:\nSmartPtr<const CD> p =\n// p is a non-const smart ptr\n&goodCD;\n// to a const CD object\nNow we can create the four combinations of const and non-const ob-\njects and pointers we seek:\nSmartPtr<CD> p;\n// non-const object, \n// non-const pointer\nSmartPtr<const CD> p;\n// const object,\n// non-const pointer\nconst SmartPtr<CD> p = &goodCD;\n// non-const object,\n// const pointer\nconst SmartPtr<const CD> p = &goodCD; // const object,\n// const pointer\nAlas, this ointment has a fly in it. Using dumb pointers, we can initial-\nize const pointers with non-const pointers and we can initialize\npointers to const objects with pointers to non-consts; the rules for\nassignments are analogous. For example:\nCD *pCD = new CD(\"Famous Movie Themes\");\nconst CD * pConstCD = pCD;\n// fine\nBut look what happens if we try the same thing with smart pointers:\nSmartPtr<CD> pCD = new CD(\"Famous Movie Themes\");\nSmartPtr<const CD> pConstCD = pCD;\n// fine?\nSmartPtr<CD> and SmartPtr<const CD> are completely different\ntypes. As far as your compilers know, they are unrelated, so they have\nno reason to believe they are assignment-compatible. In what must be\nan old story by now, the only way these two types will be considered\nassignment-compatible is if you’ve provided a function to convert ob-\njects of type SmartPtr<CD> to objects of type SmartPtr<const CD>. If\nyou’ve got a compiler that supports member templates, you can use\nthe technique shown above for automatically generating the implicit\ntype conversion operators you need. (I remarked earlier that the tech-\nnique worked anytime the corresponding conversion for dumb pointers\nwould work, and I wasn’t kidding. Conversions involving const are no\nexception.) If you don’t have such a compiler, you have to jump\nthrough one more hoop.\nConversions involving const are a one-way street: it’s safe to go from\nnon-const to const, but it’s not safe to go from const to non-const.\nFurthermore, anything you can do with a const pointer you can do\nwith a non-const pointer, but with non-const pointers you can do\n\n\nSmart Pointers\n181\nother things, too (for example, assignment). Similarly, anything you\ncan do with a pointer-to-const is legal for a pointer-to-non-const, but\nyou can do some things (such as assignment) with pointers-to-non-\nconsts that you can’t do with pointers-to-consts.\nThese rules sound like the rules for public inheritance. You can con-\nvert from a derived class object to a base class object, but not vice\nversa, and you can do anything to a derived class object you can do to\na base class object, but you can typically do additional things to a de-\nrived class object, as well. We can take advantage of this similarity\nwhen implementing smart pointers by having each smart pointer-to-T\nclass publicly inherit from a corresponding smart pointer-to-const-T\nclass:\ntemplate<class T>\n// smart pointers to const\nclass SmartPtrToConst {\n// objects\n...\n// the usual smart pointer\n// member functions\nprotected:\nunion {\nconst T* constPointee;\n// for SmartPtrToConst access\nT* pointee;\n// for SmartPtr access\n};\n};\ntemplate<class T>\n// smart pointers to\nclass SmartPtr:\n// non-const objects\npublic SmartPtrToConst<T> {\n...\n// no data members\n};\nWith this design, the smart pointer-to-non-const-T object needs to\ncontain a dumb pointer-to-non-const-T, and the smart pointer-to-\nconst-T needs to contain a dumb pointer-to-const-T. The naive way\nto handle this would be to put a dumb pointer-to-const-T in the base\nSmart\nSmart\npointer-to-const-T\npointer-to-non-const-T\n\n\n182\nItem 28\nclass and a dumb pointer-to-non-const-T in the derived class. That\nwould be wasteful, however, because SmartPtr objects would contain\ntwo dumb pointers: the one they inherited from SmartPtrToConst and\nthe one in SmartPtr itself. \nThis problem is resolved by employing that old battle axe of the C\nworld, a union, which can be as useful in C++ as it is in C. The union\nis protected, so both classes have access to it, and it contains both of\nthe necessary dumb pointer types. SmartPtrToConst<T> objects use\nthe constPointee pointer, SmartPtr<T> objects use the pointee\npointer. We therefore get the advantages of two different pointers with-\nout having to allocate space for more than one. Such is the beauty of a\nunion. Of course, the member functions of the two classes must con-\nstrain themselves to using only the appropriate pointer, and you’ll get\nno help from compilers in enforcing that constraint. Such is the risk of\na union.\nWith this new design, we get the behavior we want:\nSmartPtr<CD> pCD = new CD(\"Famous Movie Themes\");\nSmartPtrToConst<CD> pConstCD = pCD;\n// fine\nEvaluation\nThat wraps up the subject of smart pointers, but before we leave the\ntopic, we should ask this question: are they worth the trouble, espe-\ncially if your compilers lack support for member function templates?\nOften they are. The reference-counting code of Item 29, for example, is\ngreatly simplified by using smart pointers. Furthermore, as that exam-\nple demonstrates, some uses of smart pointers are sufficiently limited\nin scope that things like testing for nullness, conversion to dumb\npointers, inheritance-based conversions, and support for pointers-to-\nconsts are irrelevant. At the same time, smart pointers can be tricky\nto implement, understand, and maintain. Debugging code using smart\npointers is more difficult than debugging code using dumb pointers.\nTry as you may, you will never succeed in designing a general-purpose\nsmart pointer that can seamlessly replace its dumb pointer counter-\npart.\nSmart pointers nevertheless make it possible to achieve effects in your\ncode that would otherwise be difficult to implement. Smart pointers\nshould be used judiciously, but every C++ programmer will find them\nuseful at one time or another.\n",
      "page_number": 190,
      "chapter_number": 20,
      "summary": "This chapter covers segment 20 (pages 190-199). Key topics include pointers, classes, and smart. After all, pt is not a pointer, it’s an object,\nand you can’t delete an object.",
      "keywords": [
        "Smart Pointers",
        "Smart",
        "Pointers",
        "SmartPtr",
        "const",
        "Cassette",
        "object",
        "conversion",
        "smart pointer class",
        "dumb pointers",
        "MusicProduct",
        "implicit type conversion",
        "type",
        "Cassette Smart Pointers",
        "type conversion"
      ],
      "concepts": [
        "pointers",
        "classes",
        "smart",
        "object",
        "cassette",
        "conversions",
        "functions",
        "functionality",
        "types",
        "member"
      ],
      "similar_chapters": [
        {
          "book": "C++ Concurrency in Action",
          "chapter": 24,
          "title": "Segment 24 (pages 246-258)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 13,
          "title": "Segment 13 (pages 134-141)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 15,
          "title": "Segment 15 (pages 154-161)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 25,
          "title": "Segment 25 (pages 219-229)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 14,
          "title": "Segment 14 (pages 142-153)",
          "relevance_score": 0.57,
          "method": "api"
        }
      ]
    },
    {
      "number": 21,
      "title": "Segment 21 (pages 200-215)",
      "start_page": 200,
      "end_page": 215,
      "detection_method": "topic_boundary",
      "content": "Reference Counting\n183\nItem 29: Reference counting.\nReference Counting\nReference counting is a technique that allows multiple objects with the\nsame value to share a single representation of that value. There are\ntwo common motivations for the technique. The first is to simplify the\nbookkeeping surrounding heap objects. Once an object is allocated by\ncalling new, it’s crucial to keep track of who owns that object, because\nthe owner — and only the owner — is responsible for calling delete on\nit. But ownership can be transferred from object to object as a program\nruns (by passing pointers as parameters, for example), so keeping\ntrack of an object’s ownership is hard work. Classes like auto_ptr (see\nItem 9) can help with this task, but experience has shown that most\nprograms still fail to get it right. Reference counting eliminates the\nburden of tracking object ownership, because when an object employs\nreference counting, it owns itself. When nobody is using it any longer,\nit destroys itself automatically. Thus, reference counting constitutes a\nsimple form of garbage collection.\nThe second motivation for reference counting is simple common sense.\nIf many objects have the same value, it’s silly to store that value more\nthan once. Instead, it’s better to let all the objects with that value share\nits representation. Doing so not only saves memory, it also leads to\nfaster-running programs, because there’s no need to construct and de-\nstruct redundant copies of the same object value. \nLike most simple ideas, this one hovers above a sea of interesting de-\ntails. God may or may not be in the details, but successful implemen-\ntations of reference counting certainly are. Before delving into details,\nhowever, let us master basics. A good way to begin is by seeing how we\nmight come to have many objects with the same value in the first\nplace. Here’s one way:\nclass String {\n// the standard string type may\npublic:\n// employ the techniques in this\n// Item, but that is not required\nString(const char *value = \"\");\nString& operator=(const String& rhs);\n...\nprivate:\nchar *data;\n};\nString a, b, c, d, e;\na = b = c = d = e = \"Hello\";\nIt should be apparent that objects a through e all have the same value,\nnamely “Hello”. How that value is represented depends on how the\n\n\n184\nItem 29\nString class is implemented, but a common implementation would\nhave each String object carry its own copy of the value. For example,\nString’s assignment operator might be implemented like this:\nString& String::operator=(const String& rhs)\n{\nif (this == &rhs) return *this;\ndelete [] data;\ndata = new char[strlen(rhs.data) + 1];\nstrcpy(data, rhs.data);\nreturn *this;\n}\nGiven this implementation, we can envision the five objects and their\nvalues as follows:\nThe redundancy in this approach is clear. In an ideal world, we’d like\nto change the picture to look like this:\nHere only one copy of the value “Hello” is stored, and all the String\nobjects with that value share its representation. \nIn practice, it isn’t possible to achieve this ideal, because we need to\nkeep track of how many objects are sharing a value. If object a above\nis assigned a different value from “Hello”, we can’t destroy the value\n“Hello”, because four other objects still need it. On the other hand, if\nonly a single object had the value “Hello” and that object went out of\nscope, no object would have that value and we’d have to destroy the\nvalue to avoid a resource leak.\nHello\na\nHello\nb\nHello\nc\nHello\nd\nHello\ne\na\nb\nHello\nc\nd\ne\n\n\nReference Counting\n185\nThe need to store information on the number of objects currently shar-\ning — referring to — a value means our ideal picture must be modified\nsomewhat to take into account the existence of a reference count:\n(Some people call this number a use count, but I am not one of them.\nC++ has enough idiosyncrasies of its own; the last thing it needs is ter-\nminological factionalism.)\nImplementing Reference Counting\nCreating a reference-counted String class isn’t difficult, but it does\nrequire attention to detail, so we’ll walk through the implementation of\nthe most common member functions of such a class. Before we do\nthat, however, it’s important to recognize that we need a place to store\nthe reference count for each String value. That place cannot be in a\nString object, because we need one reference count per string value,\nnot one reference count per string object. That implies a coupling be-\ntween values and reference counts, so we’ll create a class to store ref-\nerence counts and the values they track. We’ll call this class\nStringValue, and because its only raison d’être is to help implement\nthe String class, we’ll nest it inside String’s private section. Further-\nmore, it will be convenient to give all the member functions of String\nfull access to the StringValue data structure, so we’ll declare\nStringValue to be a struct. This is a trick worth knowing: nesting a\nstruct in the private part of a class is a convenient way to give access\nto the struct to all the members of the class, but to deny access to ev-\nerybody else (except, of course, friends of the class).\nOur basic design looks like this:\n5\na\nb\nHello\nc\nd\ne\n\n\n186\nItem 29\nclass String {\npublic:\n...\n// the usual String member\n// functions go here\nprivate:\nstruct StringValue { ... };\n// holds a reference count\n// and a string value\nStringValue *value;\n// value of this String\n};\nWe could give this class a different name (RCString, perhaps) to em-\nphasize that it’s implemented using reference counting, but the imple-\nmentation of a class shouldn’t be of concern to clients of that class.\nRather, clients should interest themselves only in a class’s public in-\nterface. Our reference-counting implementation of the String inter-\nface supports exactly the same operations as a non-reference-counted\nversion, so why muddy the conceptual waters by embedding imple-\nmentation decisions in the names of classes that correspond to ab-\nstract concepts? Why indeed? So we don’t.\nHere’s StringValue:\nclass String {\nprivate:\nstruct StringValue {\nsize_t refCount;\nchar *data;\nStringValue(const char *initValue);\n~StringValue();\n};\n...\n};\nString::StringValue::StringValue(const char *initValue)\n: refCount(1)\n{\ndata = new char[strlen(initValue) + 1];\nstrcpy(data, initValue);\n}\nString::StringValue::~StringValue()\n{\ndelete [] data;\n}\nThat’s all there is to it, and it should be clear that’s nowhere near\nenough to implement the full functionality of a reference-counted\nstring. For one thing, there’s neither a copy constructor nor an assign-\n\n\nReference Counting\n187\nment operator, and for another, there’s no manipulation of the ref-\nCount field. Worry not — the missing functionality will be provided by\nthe String class. The primary purpose of StringValue is to give us a\nplace to associate a particular value with a count of the number of\nString objects sharing that value. StringValue gives us that, and\nthat’s enough.\nWe’re now ready to walk our way through String’s member functions.\nWe’ll begin with the constructors:\nclass String {\npublic:\nString(const char *initValue = \"\");\nString(const String& rhs);\n...\n};\nThe first constructor is implemented about as simply as possible. We\nuse the passed-in char* string to create a new StringValue object,\nthen we make the String object we’re constructing point to the newly-\nminted StringValue:\nString::String(const char *initValue)\n: value(new StringValue(initValue))\n{}\nFor client code that looks like this,\nString s(\"More Effective C++\");\nwe end up with a data structure that looks like this:\nString objects constructed separately, but with the same initial value\ndo not share a data structure, so client code of this form,\nString s1(\"More Effective C++\");\nString s2(\"More Effective C++\");\nyields this data structure:\nIt is possible to eliminate such duplication by having String (or\nStringValue) keep track of existing StringValue objects and create\nnew ones only for truly unique strings, but such refinements on refer-\nMore Effective C++\ns\n1\nMore Effective C++\ns1\n1\nMore Effective C++\ns2\n1\n\n\n188\nItem 29\nence counting are somewhat off the beaten path. As a result, I’ll leave\nthem in the form of the feared and hated exercise for the reader.\nThe String copy constructor is not only unfeared and unhated, it’s\nalso efficient: the newly created String object shares the same\nStringValue object as the String object that’s being copied:\nString::String(const String& rhs)\n: value(rhs.value)\n{\n++value->refCount;\n}\nGraphically, code like this,\nString s1(\"More Effective C++\");\nString s2 = s1;\nresults in this data structure:\nThis is substantially more efficient than a conventional (non-reference-\ncounted) String class, because there is no need to allocate memory\nfor the second copy of the string value, no need to deallocate that mem-\nory later, and no need to copy the value that would go in that memory.\nInstead, we merely copy a pointer and increment a reference count. \nThe String destructor is also easy to implement, because most of the\ntime it doesn’t do anything. As long as the reference count for a\nStringValue is non-zero, at least one String object is using the\nvalue; it must therefore not be destroyed. Only when the String being\ndestructed is the sole user of the value — i.e., when the value’s refer-\nence count is 1 — should the String destructor destroy the\nStringValue object:\nclass String {\npublic:\n~String();\n...\n};\nString::~String()\n{\nif (--value->refCount == 0) delete value;\n}\nMore Effective C++\ns1\n2\ns2\n\n\nReference Counting\n189\nCompare the efficiency of this function with that of the destructor for\na non-reference-counted implementation. Such a function would al-\nways call delete and would almost certainly have a nontrivial runtime\ncost. Provided that different String objects do in fact sometimes have\nthe same values, the implementation above will sometimes do nothing\nmore than decrement a counter and compare it to zero.\nIf, at this point, the appeal of reference counting is not becoming ap-\nparent, you’re just not paying attention.\nThat’s all there is to String construction and destruction, so we’ll\nmove on to consideration of the String assignment operator:\nclass String {\npublic:\nString& operator=(const String& rhs);\n...\n};\nWhen a client writes code like this,\ns1 = s2;\n// s1 and s2 are both String objects\nthe result of the assignment should be that s1 and s2 both point to the\nsame StringValue object. That object’s reference count should there-\nfore be incremented during the assignment. Furthermore, the\nStringValue object that s1 pointed to prior to the assignment should\nhave its reference count decremented, because s1 will no longer have\nthat value. If s1 was the only String with that value, the value should\nbe destroyed. In C++, all that looks like this:\nString& String::operator=(const String& rhs)\n{\nif (value == rhs.value) {\n// do nothing if the values\nreturn *this;\n// are already the same; this\n}\n// subsumes the usual test of\n// this against &rhs\nif (--value->refCount == 0) {\n// destroy *this’s value if\ndelete value;\n// no one else is using it\n}\nvalue = rhs.value;\n// have *this share rhs’s\n++value->refCount;\n// value\nreturn *this;\n}\n\n\n190\nItem 29\nCopy-on-Write\nTo round out our examination of reference-counted strings, consider\nan array-bracket operator ([]), which allows individual characters\nwithin strings to be read and written:\nclass String {\npublic:\nconst char&\noperator[](int index) const;\n// for const Strings\nchar& operator[](int index);\n// for non-const Strings\n...\n};\nImplementation of the const version of this function is straightfor-\nward, because it’s a read-only operation; the value of the string can’t\nbe affected:\nconst char& String::operator[](int index) const\n{\nreturn value->data[index];\n}\n(This function performs sanity checking on index in the grand C++\ntradition, which is to say not at all. As usual, if you’d like a greater de-\ngree of parameter validation, it’s easy to add.)\nThe non-const version of operator[] is a completely different story.\nThis function may be called to read a character, but it might be called\nto write one, too:\nString s;\n...\ncout << s[3];\n// this is a read\ns[5] = ’x’;\n// this is a write\nWe’d like to deal with reads and writes differently. A simple read can be\ndealt with in the same way as the const version of operator[] above,\nbut a write must be implemented in quite a different fashion. \nWhen we modify a String’s value, we have to be careful to avoid mod-\nifying the value of other String objects that happen to be sharing the\nsame StringValue object. Unfortunately, there is no way for C++\ncompilers to tell us whether a particular use of operator[] is for a\nread or a write, so we must be pessimistic and assume that all calls to\nthe non-const operator[] are for writes. (Proxy classes can help us\ndifferentiate reads from writes — see Item 30.)\nTo implement the non-const operator[] safely, we must ensure that\nno other String object shares the StringValue to be modified by the\n\n\nReference Counting\n191\npresumed write. In short, we must ensure that the reference count for\na String’s StringValue object is exactly one any time we return a ref-\nerence to a character inside that StringValue object. Here’s how we\ndo it:\nchar& String::operator[](int index)\n{\n// if we’re sharing a value with other String objects,\n// break off a separate copy of the value for ourselves\nif (value->refCount > 1) {\n--value->refCount;\n// decrement current value’s\n// refCount, because we won’t\n// be using that value any more\nvalue =\n// make a copy of the\nnew StringValue(value->data);\n// value for ourselves\n}\n// return a reference to a character inside our\n// unshared StringValue object\nreturn value->data[index];\n}\nThis idea — that of sharing a value with other objects until we have to\nwrite on our own copy of the value — has a long and distinguished his-\ntory in Computer Science, especially in operating systems, where pro-\ncesses are routinely allowed to share pages until they want to modify\ndata on their own copy of a page. The technique is common enough to\nhave a name: copy-on-write. It’s a specific example of a more general\napproach to efficiency, that of lazy evaluation (see Item 17).\nPointers, References, and Copy-on-Write\nThis implementation of copy-on-write allows us to preserve both effi-\nciency and correctness — almost. There is one lingering problem. Con-\nsider this code:\nString s1 = \"Hello\";\nchar *p = &s1[1];\nOur data structure at this point looks like this:\nNow consider an additional statement:\nString s2 = s1;\nHello\ns1\n1\np\n\n\n192\nItem 29\nThe String copy constructor will make s2 share s1’s StringValue, so\nthe resulting data structure will be this one:\nThe implications of a statement such as the following, then, are not\npleasant to contemplate:\n*p = ’x’;\n// modifies both s1 and s2!\nThere is no way the String copy constructor can detect this problem,\nbecause it has no way to know that a pointer into s1’s StringValue\nobject exists. And this problem isn’t limited to pointers: it would exist\nif someone had saved a reference to the result of a call to String’s non-\nconst operator[].\nThere are at least three ways of dealing with this problem. The first is\nto ignore it, to pretend it doesn’t exist. This approach turns out to be\ndistressingly common in class libraries that implement reference-\ncounted strings. If you have access to a reference-counted string, try\nthe above example and see if you’re distressed, too. If you’re not sure if\nyou have access to a reference-counted string, try the example any-\nway. Through the wonder of encapsulation, you may be using such a\ntype without knowing it.\nNot all implementations ignore such problems. A slightly more sophis-\nticated way of dealing with such difficulties is to define them out of ex-\nistence. Implementations adopting this strategy typically put\nsomething in their documentation that says, more or less, “Don’t do\nthat. If you do, results are undefined.” If you then do it anyway — wit-\ntingly or no — and complain about the results, they respond, “Well, we\ntold you not to do that.” Such implementations are often efficient, but\nthey leave much to be desired in the usability department.\nThere is a third solution, and that’s to eliminate the problem. It’s not\ndifficult to implement, but it can reduce the amount of value sharing\nbetween objects. Its essence is this: add a flag to each StringValue\nobject indicating whether that object is shareable. Turn the flag on ini-\ntially (the object is shareable), but turn it off whenever the non-const\noperator[] is invoked on the value represented by that object. Once\nthe flag is set to false, it stays that way forever.†\n† The string type in the standard C++ library (see Item 35) uses a combination of so-\nlutions two and three. The reference returned from the non-const operator[] is\nguaranteed to be valid until the next function call that might modify the string. After\nthat, use of the reference (or the character to which it refers) yields undefined results.\nThis allows the string’s shareability flag to be reset to true whenever a function is\ncalled that might modify the string.\ns1\n2\ns2\nHello\np\n\n\nReference Counting\n193\nHere’s a modified version of StringValue that includes a shareability\nflag:\nclass String {\nprivate:\nstruct StringValue {\nsize_t refCount;\nbool shareable;\n// add this\nchar *data;\nStringValue(const char *initValue);\n~StringValue();\n};\n...\n};\nString::StringValue::StringValue(const char *initValue)\n: refCount(1),\nshareable(true)\n// add this\n{\ndata = new char[strlen(initValue) + 1];\nstrcpy(data, initValue);\n}\nString::StringValue::~StringValue()\n{\ndelete [] data;\n}\nAs you can see, not much needs to change; the two lines that require\nmodification are flagged with comments. Of course, String’s member\nfunctions must be updated to take the shareable field into account.\nHere’s how the copy constructor would do that:\nString::String(const String& rhs)\n{\nif (rhs.value->shareable) {\nvalue = rhs.value;\n++value->refCount;\n}\nelse {\nvalue = new StringValue(rhs.value->data);\n}\n}\nAll the other String member functions would have to check the\nshareable field in an analogous fashion. The non-const version of\noperator[] would be the only function to set the shareable flag to\nfalse:\n\n\n194\nItem 29\nchar& String::operator[](int index)\n{\nif (value->refCount > 1) {\n--value->refCount;\nvalue = new StringValue(value->data);\n}\nvalue->shareable = false;\n// add this\nreturn value->data[index];\n}\nIf you use the proxy class technique of Item 30 to distinguish read\nusage from write usage in operator[], you can usually reduce the\nnumber of StringValue objects that must be marked unshareable.\nA Reference-Counting Base Class\nReference counting is useful for more than just strings. Any class in\nwhich different objects may have values in common is a legitimate can-\ndidate for reference counting. Rewriting a class to take advantage of\nreference counting can be a lot of work, however, and most of us al-\nready have more than enough to do. Wouldn’t it be nice if we could\nsomehow write (and test and document) the reference counting code in\na context-independent manner, then just graft it onto classes when\nneeded? Of course it would. In a curious twist of fate, there’s a way to\ndo it (or at least to do most of it).\nThe first step is to create a base class, RCObject, for reference-counted\nobjects. Any class wishing to take advantage of automatic reference\ncounting must inherit from this class. RCObject encapsulates the ref-\nerence count itself, as well as functions for incrementing and decre-\nmenting that count. It also contains the code for destroying a value\nwhen it is no longer in use, i.e., when its reference count becomes 0.\nFinally, it contains a field that keeps track of whether this value is\nshareable, and it provides functions to query this value and set it to\nfalse. There is no need for a function to set the shareability field to\ntrue, because all values are shareable by default. As noted above, once\nan object has been tagged unshareable, there is no way to make it\nshareable again.\nRCObject’s class definition looks like this:\nclass RCObject {\npublic:\nRCObject();\nRCObject(const RCObject& rhs);\nRCObject& operator=(const RCObject& rhs);\nvirtual ~RCObject() = 0;\n\n\nReference Counting\n195\nvoid addReference();\nvoid removeReference();\nvoid markUnshareable();\nbool isShareable() const;\nbool isShared() const;\nprivate:\nsize_t refCount;\nbool shareable;\n};\nRCObjects can be created (as the base class parts of more derived ob-\njects) and destroyed; they can have new references added to them and\ncan have current references removed; their shareability status can be\nqueried and can be disabled; and they can report whether they are\ncurrently being shared. That’s all they offer. As a class encapsulating\nthe notion of being reference-countable, that’s really all we have a right\nto expect them to do. Note the tell-tale virtual destructor, a sure sign\nthis class is designed for use as a base class. Note also how the de-\nstructor is a pure virtual function, a sure sign this class is designed to\nbe used only as a base class.\nThe code to implement RCObject is, if nothing else, brief:\nRCObject::RCObject()\n: refCount(0), shareable(true) {}\nRCObject::RCObject(const RCObject&)\n: refCount(0), shareable(true) {}\nRCObject& RCObject::operator=(const RCObject&)\n{ return *this; }\nRCObject::~RCObject() {}\n// virtual dtors must always\n// be implemented, even if\n// they are pure virtual\n// and do nothing (see also\n// Item 33)\nvoid RCObject::addReference() { ++refCount; }\nvoid RCObject::removeReference()\n{ if (--refCount == 0) delete this; }\nvoid RCObject::markUnshareable()\n{ shareable = false; }\nbool RCObject::isShareable() const\n{ return shareable; }\nbool RCObject::isShared() const\n{ return refCount > 1; }\n\n\n196\nItem 29\nCuriously, we set refCount to 0 inside both constructors. This seems\ncounterintuitive. Surely at least the creator of the new RCObject is re-\nferring to it! As it turns out, it simplifies things for the creators of\nRCObjects to set refCount to 1 themselves, so we oblige them here by\nnot getting in their way. We’ll get a chance to see the resulting code\nsimplification shortly.\nAnother curious thing is that the copy constructor always sets ref-\nCount to 0, regardless of the value of refCount for the RCObject we’re\ncopying. That’s because we’re creating a new object representing a\nvalue, and new values are always unshared and referenced only by\ntheir creator. Again, the creator is responsible for setting the refCount\nto its proper value.\nThe RCObject assignment operator looks downright subversive: it\ndoes nothing. Frankly, it’s unlikely this operator will ever be called.\nRCObject is a base class for a shared value object, and in a system\nbased on reference counting, such objects are not assigned to one an-\nother, objects pointing to them are. In our case, we don’t expect\nStringValue objects to be assigned to one another, we expect only\nString objects to be involved in assignments. In such assignments, no\nchange is made to the value of a StringValue — only the\nStringValue reference count is modified.\nNevertheless, it is conceivable that some as-yet-unwritten class might\nsomeday inherit from RCObject and might wish to allow assignment of\nreference-counted values (see Item 32). If so, RCObject’s assignment\noperator should do the right thing, and the right thing is to do nothing.\nTo see why, imagine that we wished to allow assignments between\nStringValue objects. Given StringValue objects sv1 and sv2, what\nshould happen to sv1’s and sv2’s reference counts in an assignment?\nsv1 = sv2;\n// how are sv1’s and sv2’s reference\n// counts affected?\nBefore the assignment, some number of String objects are pointing to\nsv1. That number is unchanged by the assignment, because only\nsv1’s value changes. Similarly, some number of String objects are\npointing to sv2 prior to the assignment, and after the assignment, ex-\nactly the same String objects point to sv2. sv2’s reference count is\nalso unchanged. When RCObjects are involved in an assignment,\nthen, the number of objects pointing to those objects is unaffected,\nhence RCObject::operator= should change no reference counts.\nThat’s exactly what the implementation above does. Counterintuitive?\nPerhaps, but it’s still correct.\nThe code for RCObject::removeReference is responsible not only for\ndecrementing the object’s refCount, but also for destroying the object\n\n\nReference Counting\n197\nif the new value of refCount is 0. It accomplishes this latter task by\ndeleteing this, which, as Item 27 explains, is safe only if we know\nthat *this is a heap object. For this class to be successful, we must\nengineer things so that RCObjects can be created only on the heap.\nGeneral approaches to achieving that end are discussed in Item 27,\nbut the specific measures we’ll employ in this case are described at the\nconclusion of this Item.\nTo take advantage of our new reference-counting base class, we modify\nStringValue to inherit its reference counting capabilities from RCOb-\nject:\nclass String {\nprivate:\nstruct StringValue: public RCObject {\nchar *data;\nStringValue(const char *initValue);\n~StringValue();\n};\n...\n};\nString::StringValue::StringValue(const char *initValue)\n{\ndata = new char[strlen(initValue) + 1];\nstrcpy(data, initValue);\n}\nString::StringValue::~StringValue()\n{\ndelete [] data;\n}\nThis version of StringValue is almost identical to the one we saw ear-\nlier. The only thing that’s changed is that StringValue’s member\nfunctions no longer manipulate the refCount field. RCObject now\nhandles what they used to do. \nDon’t feel bad if you blanched at the sight of a nested class\n(StringValue) inheriting from a class (RCObject) that’s unrelated to\nthe nesting class (String). It looks weird to everybody at first, but it’s\nperfectly kosher. A nested class is just as much a class as any other,\nso it has the freedom to inherit from whatever other classes it likes. In\ntime, you won’t think twice about such inheritance relationships.\n\n\n198\nItem 29\nAutomating Reference Count Manipulations\nThe RCObject class gives us a place to store a reference count, and it\ngives us member functions through which that reference count can be\nmanipulated, but the calls to those functions must still be manually\ninserted in other classes. It is still up to the String copy constructor\nand the String assignment operator to call addReference and re-\nmoveReference on StringValue objects. This is clumsy. We’d like to\nmove those calls out into a reusable class, too, thus freeing authors of\nclasses like String from worrying about any of the details of reference\ncounting. Can it be done? Isn’t C++ supposed to support reuse?\nIt can, and it does. There’s no easy way to arrange things so that all ref-\nerence-counting considerations can be moved out of application\nclasses, but there is a way to eliminate most of them for most classes.\n(In some application classes, you can eliminate all reference-counting\ncode, but our String class, alas, isn’t one of them. One member func-\ntion spoils the party, and I suspect you won’t be too surprised to hear\nit’s our old nemesis, the non-const version of operator[]. Take\nheart, however; we’ll tame that miscreant in the end.)\nNotice that each String object contains a pointer to the StringValue\nobject representing that String’s value:\nclass String {\nprivate:\nstruct StringValue: public RCObject { ... };\nStringValue *value;\n// value of this String\n...\n};\nWe have to manipulate the refCount field of the StringValue object\nanytime anything interesting happens to one of the pointers pointing\nto it. “Interesting happenings” include copying a pointer, reassigning\none, and destroying one. If we could somehow make the pointer itself\ndetect these happenings and automatically perform the necessary ma-\nnipulations of the refCount field, we’d be home free. Unfortunately,\npointers are rather dense creatures, and the chances of them detecting\nanything, much less automatically reacting to things they detect, are\npretty slim. Fortunately, there’s a way to smarten them up: replace\nthem with objects that act like pointers, but that do more.\nSuch objects are called smart pointers, and you can read about them\nin more detail than you probably care to in Item 28. For our purposes\nhere, it’s enough to know that smart pointer objects support the mem-\nber selection (->) and dereferencing (*) operations, just like real point-\ners (which, in this context, are generally referred to as dumb pointers),\n",
      "page_number": 200,
      "chapter_number": 21,
      "summary": "This chapter covers segment 21 (pages 200-215). Key topics include string, strings, and objects. Reference Counting\nReference counting is a technique that allows multiple objects with the\nsame value to share a single representation of that value.",
      "keywords": [
        "String",
        "Reference Counting",
        "String objects",
        "class String",
        "Reference",
        "StringValue",
        "const String",
        "object",
        "StringValue object",
        "Counting",
        "RCObject",
        "String object shares",
        "Item",
        "const",
        "strings"
      ],
      "concepts": [
        "string",
        "strings",
        "objects",
        "counting",
        "reference",
        "referring",
        "refer",
        "value",
        "item",
        "operator"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 14,
          "title": "Segment 14 (pages 142-153)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 50,
          "title": "Segment 50 (pages 1600-1629)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 13,
          "title": "Segment 13 (pages 250-271)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 27,
          "title": "Segment 27 (pages 850-883)",
          "relevance_score": 0.52,
          "method": "api"
        }
      ]
    },
    {
      "number": 22,
      "title": "Segment 22 (pages 216-223)",
      "start_page": 216,
      "end_page": 223,
      "detection_method": "topic_boundary",
      "content": "Reference Counting\n199\nand, like dumb pointers, they are strongly typed: you can’t make a\nsmart pointer-to-T point to an object that isn’t of type T. \nHere’s a template for objects that act as smart pointers to reference-\ncounted objects:\n// template class for smart pointers-to-T objects. T must\n// support the RCObject interface, typically by inheriting\n// from RCObject\ntemplate<class T>\nclass RCPtr {\npublic:\nRCPtr(T* realPtr = 0);\nRCPtr(const RCPtr& rhs);\n~RCPtr();\nRCPtr& operator=(const RCPtr& rhs);\nT* operator->() const;\n// see Item 28\nT& operator*() const; \n// see Item 28\nprivate:\nT *pointee;\n// dumb pointer this\n// object is emulating\nvoid init();\n// common initialization \n};\n// code\nThis template gives smart pointer objects control over what happens\nduring their construction, assignment, and destruction. When such\nevents occur, these objects can automatically perform the appropriate\nmanipulations of the refCount field in the objects to which they point. \nFor example, when an RCPtr is created, the object it points to needs to\nhave its reference count increased. There’s no need to burden applica-\ntion developers with the requirement to tend to this irksome detail\nmanually, because RCPtr constructors can handle it themselves. The\ncode in the two constructors is all but identical — only the member ini-\ntialization lists differ — so rather than write it twice, we put it in a pri-\nvate member function called init and have both constructors call\nthat:\ntemplate<class T>\nRCPtr<T>::RCPtr(T* realPtr): pointee(realPtr)\n{\ninit();\n}\ntemplate<class T>\nRCPtr<T>::RCPtr(const RCPtr& rhs): pointee(rhs.pointee)\n{\ninit();\n}\n\n\n200\nItem 29\ntemplate<class T>\nvoid RCPtr<T>::init()\n{\nif (pointee == 0) {\n// if the dumb pointer is\nreturn;\n// null, so is the smart one\n}\nif (pointee->isShareable() == false) {\n// if the value\npointee = new T(*pointee);\n// isn’t shareable,\n}\n// copy it\npointee->addReference();\n// note that there is now a\n}\n// new reference to the value\nMoving common code into a separate function like init is exemplary\nsoftware engineering, but its luster dims when, as in this case, the\nfunction doesn’t behave correctly. \nThe problem is this. When init needs to create a new copy of a value\n(because the existing copy isn’t shareable), it executes the following\ncode:\npointee = new T(*pointee);\nThe type of pointee is pointer-to-T, so this statement creates a new T\nobject and initializes it by calling T’s copy constructor. In the case of an\nRCPtr in the String class, T will be String::StringValue, so the\nstatement above will call String::StringValue’s copy constructor.\nWe haven’t declared a copy constructor for that class, however, so our\ncompilers will generate one for us. The copy constructor so generated\nwill, in accordance with the rules for automatically generated copy\nconstructors in C++, copy only StringValue’s data pointer; it will not\ncopy the char* string data points to. Such behavior is disastrous in\nnearly any class (not just reference-counted classes), and that’s why\nyou should get into the habit of writing a copy constructor (and an as-\nsignment operator) for all your classes that contain pointers. \n\n\nReference Counting\n201\nThe correct behavior of the RCPtr<T> template depends on T contain-\ning a copy constructor that makes a truly independent copy (i.e., a\ndeep copy) of the value represented by T. We must augment\nStringValue with such a constructor before we can use it with the\nRCPtr class:\nclass String {\nprivate:\nstruct StringValue: public RCObject {\nStringValue(const StringValue& rhs);\n...\n};\n...\n};\nString::StringValue::StringValue(const StringValue& rhs)\n{\ndata = new char[strlen(rhs.data) + 1];\nstrcpy(data, rhs.data);\n}\nThe existence of a deep-copying copy constructor is not the only as-\nsumption RCPtr<T> makes about T. It also requires that T inherit from\nRCObject, or at least that T provide all the functionality that RCObject\ndoes. In view of the fact that RCPtr objects are designed to point only\nto reference-counted objects, this is hardly an unreasonable assump-\ntion. Nevertheless, the assumption must be documented.\nA final assumption in RCPtr<T> is that the type of the object pointed\nto is T. This seems obvious enough. After all, pointee is declared to be\nof type T*. But pointee might really point to a class derived from T.\nFor example, if we had a class SpecialStringValue that inherited\nfrom String::StringValue,\nclass String {\nprivate:\nstruct StringValue: public RCObject { ... };\nstruct SpecialStringValue: public StringValue { ... };\n...\n};\n\n\n202\nItem 29\nwe could end up with a String containing a RCPtr<StringValue>\npointing to a SpecialStringValue object. In that case, we’d want this\npart of init,\npointee = new T(*pointee);\n// T is StringValue, but\n// pointee really points to\n// a SpecialStringValue\nto call SpecialStringValue’s copy constructor, not StringValue’s.\nWe can arrange for this to happen by using a virtual copy constructor\n(see Item 25). In the case of our String class, we don’t expect classes\nto derive from StringValue, so we’ll disregard this issue.\nWith RCPtr’s constructors out of the way, the rest of the class’s func-\ntions can be dispatched with considerably greater alacrity. Assignment\nof an RCPtr is straightforward, though the need to test whether the\nnewly assigned value is shareable complicates matters slightly. Fortu-\nnately, such complications have already been handled by the init\nfunction that was created for RCPtr’s constructors. We take advantage\nof that fact by using it again here:\ntemplate<class T>\nRCPtr<T>& RCPtr<T>::operator=(const RCPtr& rhs)\n{\nif (pointee != rhs.pointee) {\n// skip assignments\n// where the value\n// doesn’t change\nT *oldPointee = pointee;\n// save old pointee value\npointee = rhs.pointee;\n// point to new value\ninit();\n// if possible, share it\n// else make own copy\nif (oldPointee) {\noldPointee->removeReference();// remove reference to\n}\n// current value\nreturn *this;\n}\nThe destructor is easier. When an RCPtr is destroyed, it simply re-\nmoves its reference to the reference-counted object:\ntemplate<class T>\nRCPtr<T>::~RCPtr()\n{\nif (pointee) pointee->removeReference();\n}\nIf the RCPtr that just expired was the last reference to the object, that\nobject will be destroyed inside RCObject’s removeReference member\nfunction. Hence RCPtr objects never need to worry about destroying\nthe values they point to.\n\n\nReference Counting\n203\nFinally, RCPtr’s pointer-emulating operators are part of the smart\npointer boilerplate you can read about in Item 28:\ntemplate<class T>\nT* RCPtr<T>::operator->() const { return pointee; }\ntemplate<class T>\nT& RCPtr<T>::operator*() const { return *pointee; }\nPutting it All Together\nEnough! Finis! At long last we are in a position to put all the pieces to-\ngether and build a reference-counted String class based on the reus-\nable RCObject and RCPtr classes. With luck, you haven’t forgotten\nthat that was our original goal. \nEach reference-counted string is implemented via this data structure:\nThe classes making up this data structure are defined like this:\ntemplate<class T>\n// template class for smart\nclass RCPtr {\n// pointers-to-T objects; T\npublic:\n// must inherit from RCObject\nRCPtr(T* realPtr = 0);\nRCPtr(const RCPtr& rhs);\n~RCPtr();\nRCPtr& operator=(const RCPtr& rhs);\nT* operator->() const;\nT& operator*() const;\nprivate:\nT *pointee;\nvoid init();\n};\nString\nobject\nRCPtr\nobject\nStringValue\nobject\nRCObject\nclass\nHeap Memory\npublic\ninheritance\npointer\npointer\n\n\n204\nItem 29\nclass RCObject {\n// base class for reference-\npublic:\n// counted objects\nRCObject();\nRCObject(const RCObject& rhs);\nRCObject& operator=(const RCObject& rhs);\nvirtual ~RCObject() = 0;\nvoid addReference();\nvoid removeReference();\nvoid markUnshareable();\nbool isShareable() const;\nbool isShared() const;\nprivate:\nsize_t refCount;\nbool shareable;\n};\nclass String {\n// class to be used by\npublic:\n// application developers\nString(const char *value = \"\");\nconst char& operator[](int index) const;\nchar& operator[](int index);\nprivate:\n// class representing string values\nstruct StringValue: public RCObject {\nchar *data;\nStringValue(const char *initValue);\nStringValue(const StringValue& rhs);\nvoid init(const char *initValue);\n~StringValue();\n};\nRCPtr<StringValue> value;\n};\nFor the most part, this is just a recap of what we’ve already developed,\nso nothing should be much of a surprise. Close examination reveals\nwe’ve added an init function to String::StringValue, but, as we’ll\nsee below, that serves the same purpose as the corresponding function\nin RCPtr: it prevents code duplication in the constructors. \nThere is a significant difference between the public interface of this\nString class and the one we used at the beginning of this Item. Where\nis the copy constructor? Where is the assignment operator? Where is\nthe destructor? Something is definitely amiss here.\n\n\nReference Counting\n205\nActually, no. Nothing is amiss. In fact, some things are working per-\nfectly. If you don’t see what they are, prepare yourself for a C++ epiph-\nany. \nWe don’t need those functions anymore. Sure, copying of String ob-\njects is still supported, and yes, the copying will correctly handle the\nunderlying reference-counted StringValue objects, but the String\nclass doesn’t have to provide a single line of code to make this happen.\nThat’s because the compiler-generated copy constructor for String\nwill automatically call the copy constructor for String’s RCPtr mem-\nber, and the copy constructor for that class will perform all the neces-\nsary manipulations of the StringValue object, including its reference\ncount. An RCPtr is a smart pointer, remember? We designed it to take\ncare of the details of reference counting, so that’s what it does. It also\nhandles assignment and destruction, and that’s why String doesn’t\nneed to write those functions, either. Our original goal was to move the\nunreusable reference-counting code out of our hand-written String\nclass and into context-independent classes where it would be available\nfor use with any class. Now we’ve done it (in the form of the RCObject\nand RCPtr classes), so don’t be so surprised when it suddenly starts\nworking. It’s supposed to work.\nJust so you have everything in one place, here’s the implementation of\nRCObject:\nRCObject::RCObject()\n: refCount(0), shareable(true) {}\nRCObject::RCObject(const RCObject&)\n: refCount(0), shareable(true) {}\nRCObject& RCObject::operator=(const RCObject&)\n{ return *this; }\nRCObject::~RCObject() {}\nvoid RCObject::addReference() { ++refCount; }\nvoid RCObject::removeReference()\n{ if (--refCount == 0) delete this; }\nvoid RCObject::markUnshareable()\n{ shareable = false; }\nbool RCObject::isShareable() const\n{ return shareable; }\nbool RCObject::isShared() const\n{ return refCount > 1; }\nAnd here’s the implementation of RCPtr:\n\n\n206\nItem 29\ntemplate<class T>\nvoid RCPtr<T>::init()\n{\nif (pointee == 0) return;\nif (pointee->isShareable() == false) {\npointee = new T(*pointee);\n}\npointee->addReference();\n}\ntemplate<class T>\nRCPtr<T>::RCPtr(T* realPtr)\n: pointee(realPtr)\n{ init(); }\ntemplate<class T>\nRCPtr<T>::RCPtr(const RCPtr& rhs)\n: pointee(rhs.pointee)\n{ init(); }\ntemplate<class T>\nRCPtr<T>::~RCPtr()\n{ if (pointee) pointee->removeReference(); }\ntemplate<class T>\nRCPtr<T>& RCPtr<T>::operator=(const RCPtr& rhs)\n{\nif (pointee != rhs.pointee) {\nT *oldPointee = pointee;\npointee = rhs.pointee;\ninit();\nif (oldPointee) oldPointee->removeReference();\n}\nreturn *this;\n}\ntemplate<class T>\nT* RCPtr<T>::operator->() const { return pointee; }\ntemplate<class T>\nT& RCPtr<T>::operator*() const { return *pointee; }\nThe implementation of String::StringValue looks like this:\nvoid String::StringValue::init(const char *initValue)\n{\ndata = new char[strlen(initValue) + 1];\nstrcpy(data, initValue);\n}\nString::StringValue::StringValue(const char *initValue)\n{ init(initValue); }\n",
      "page_number": 216,
      "chapter_number": 22,
      "summary": "This chapter covers segment 22 (pages 216-223). Key topics include classes, string, and copy. Here’s a template for objects that act as smart pointers to reference-\ncounted objects:\n// template class for smart pointers-to-T objects.",
      "keywords": [
        "RCPtr",
        "String",
        "const",
        "pointee",
        "RCObject",
        "StringValue",
        "const RCPtr",
        "String class",
        "copy",
        "copy constructor",
        "template",
        "init",
        "constructor",
        "operator",
        "rhs"
      ],
      "concepts": [
        "classes",
        "string",
        "copy",
        "pointers",
        "value",
        "counting",
        "object",
        "assignment",
        "assignments",
        "public"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 14,
          "title": "Segment 14 (pages 142-153)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 41,
          "title": "Segment 41 (pages 1309-1342)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 57,
          "title": "Segment 57 (pages 1824-1855)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 15,
          "title": "Segment 15 (pages 456-487)",
          "relevance_score": 0.63,
          "method": "api"
        }
      ]
    },
    {
      "number": 23,
      "title": "Segment 23 (pages 224-233)",
      "start_page": 224,
      "end_page": 233,
      "detection_method": "topic_boundary",
      "content": "Reference Counting\n207\nString::StringValue::StringValue(const StringValue& rhs)\n{ init(rhs.data); }\nString::StringValue::~StringValue()\n{ delete [] data; }\nUltimately, all roads lead to String, and that class is implemented\nthis way:\nString::String(const char *initValue)\n: value(new StringValue(initValue)) {}\nconst char& String::operator[](int index) const\n{ return value->data[index]; }\nchar& String::operator[](int index)\n{\nif (value->isShared()) {\nvalue = new StringValue(value->data);\n}\nvalue->markUnshareable();\nreturn value->data[index];\n}\nIf you compare the code for this String class with that we developed\nfor the String class using dumb pointers, you’ll be struck by two\nthings. First, there’s a lot less of it here than there. That’s because\nRCPtr has assumed much of the reference-counting burden that used\nto fall on String. Second, the code that remains in String is nearly\nunchanged: the smart pointer replaced the dumb pointer essentially\nseamlessly. In fact, the only changes are in operator[], where we call\nisShared instead of checking the value of refCount directly and\nwhere our use of the smart RCPtr object eliminates the need to manu-\nally manipulate the reference count during a copy-on-write.\nThis is all very nice, of course. Who can object to less code? Who can\noppose encapsulation success stories? The bottom line, however, is de-\ntermined more by the impact of this newfangled String class on its\nclients than by any of its implementation details, and it is here that\nthings really shine. If no news is good news, the news here is very good\nindeed. The String interface has not changed. We added reference\ncounting, we added the ability to mark individual string values as un-\nshareable, we moved the notion of reference countability into a new\nbase class, we added smart pointers to automate the manipulation of\nreference counts, yet not one line of client code needs to be changed.\nSure, we changed the String class definition, so clients who want to\ntake advantage of reference-counted strings must recompile and\nrelink, but their investment in code is completely and utterly pre-\nserved. You see? Encapsulation really is a wonderful thing.\n\n\n208\nItem 29\nAdding Reference Counting to Existing Classes\nEverything we’ve discussed so far assumes we have access to the\nsource code of the classes we’re interested in. But what if we’d like to\napply the benefits of reference counting to some class Widget that’s in\na library we can’t modify? There’s no way to make Widget inherit from\nRCObject, so we can’t use smart RCPtrs with it. Are we out of luck?\nWe’re not. With some minor modifications to our design, we can add\nreference counting to any type.\nFirst, let’s consider what our design would look like if we could have\nWidget inherit from RCObject. In that case, we’d have to add a class,\nRCWidget, for clients to use, but everything would then be analogous\nto our String/StringValue example, with RCWidget playing the role\nof String and Widget playing the role of StringValue. The design\nwould look like this:\nWe can now apply the maxim that most problems in Computer Science\ncan be solved with an additional level of indirection. We add a new\nclass, CountHolder, to hold the reference count, and we have Count-\nHolder inherit from RCObject. We also have CountHolder contain a\npointer to a Widget. We then replace the smart RCPtr template with an\nequally smart RCIPtr template that knows about the existence of the\nCountHolder class. (The “I” in RCIPtr stands for “indirect.”) The mod-\nified design looks like this:\nRCWidget\nobject\nRCPtr\nobject\nWidget\nobject\nRCObject\nclass\npublic\ninheritance\npointer\nRCWidget\nRCIPtr\nobject\nRCObject\nclass\npublic\ninheritance\npointer\npointer\nWidget\nobject\nCountHolder\nobject\nobject\n\n\nReference Counting\n209\nJust as StringValue was an implementation detail hidden from cli-\nents of String, CountHolder is an implementation detail hidden from\nclients of RCWidget. In fact, it’s an implementation detail of RCIPtr, so\nit’s nested inside that class. RCIPtr is implemented this way:\ntemplate<class T>\nclass RCIPtr {\npublic:\nRCIPtr(T* realPtr = 0);\nRCIPtr(const RCIPtr& rhs);\n~RCIPtr();\nRCIPtr& operator=(const RCIPtr& rhs);\nT* operator->() const;\nT& operator*() const;\nRCObject& getRCObject()\n// give clients access to\n{ return *counter; }\n// isShared, etc.\nprivate:\nstruct CountHolder: public RCObject {\n~CountHolder() { delete pointee; }\nT *pointee;\n};\nCountHolder *counter;\nvoid init();\n};\ntemplate<class T>\nvoid RCIPtr<T>::init()\n{\nif (counter->isShareable() == false) {\nT *oldValue = counter->pointee;\ncounter = new CountHolder;\ncounter->pointee = oldValue ? new T(*oldValue) : 0;\n}\ncounter->addReference();\n}\ntemplate<class T>\nRCIPtr<T>::RCIPtr(T* realPtr)\n: counter(new CountHolder)\n{\ncounter->pointee = realPtr;\ninit();\n}\ntemplate<class T>\nRCIPtr<T>::RCIPtr(const RCIPtr& rhs)\n: counter(rhs.counter)\n{ init(); }\ntemplate<class T>\nRCIPtr<T>::~RCIPtr()\n{ counter->removeReference(); }\n\n\n210\nItem 29\ntemplate<class T>\nRCIPtr<T>& RCIPtr<T>::operator=(const RCIPtr& rhs)\n{\nif (counter != rhs.counter) {\ncounter->removeReference();\ncounter = rhs.counter;\ninit();\n}\nreturn *this;\n}\ntemplate<class T>\nT* RCIPtr<T>::operator->() const\n{ return counter->pointee; }\ntemplate<class T>\nT& RCIPtr<T>::operator*() const\n{ return *(counter->pointee); }\nIf you compare this implementation with that of RCPtr, you’ll see they\nare conceptually identical. They differ only in that RCPtr objects point\nto values directly, while RCIPtr objects point to values through an in-\ntervening CountHolder object.\nGiven RCIPtr, it’s easy to implement RCWidget, because each function\nin RCWidget is implemented by forwarding the call through the under-\nlying RCIPtr to a Widget object. For example, if Widget looks like this,\nclass Widget {\npublic:\nWidget(int size);\nWidget(const Widget& rhs);\n~Widget();\n  Widget& operator=(const Widget& rhs);\n  void doThis();\nint showThat() const;\n};\nRCWidget will be defined this way:\nclass RCWidget {\npublic:\nRCWidget(int size): value(new Widget(size)) {}\n  void doThis()\n{\nif (value.getRCObject().isShared()) { // do COW if \nvalue = new Widget(*value);\n// Widget is shared\n}\nvalue->doThis();\n}\nint showThat() const { return value->showThat(); }\nprivate:\nRCIPtr<Widget> value;\n};\n\n\nReference Counting\n211\nNote how the RCWidget constructor calls the Widget constructor (via\nthe new operator — see Item 8) with the argument it was passed; how\nRCWidget’s doThis calls doThis in the Widget class; and how RCWid-\nget::showThat returns whatever its Widget counterpart returns. No-\ntice also how RCWidget declares no copy constructor, no assignment\noperator, and no destructor. As with the String class, there is no need\nto write these functions. Thanks to the behavior of the RCIPtr class,\nthe default versions do the right things. \nIf the thought occurs to you that creation of RCWidget is so mechani-\ncal, it could be automated, you’re right. It would not be difficult to\nwrite a program that takes a class like Widget as input and produces\na class like RCWidget as output. If you write such a program, please\nlet me know.\nEvaluation\nLet us disentangle ourselves from the details of widgets, strings, val-\nues, smart pointers, and reference-counting base classes. That gives\nus an opportunity to step back and view reference counting in a\nbroader context. In that more general context, we must address a\nhigher-level question, namely, when is reference counting an appro-\npriate technique?\nReference-counting implementations are not without cost. Each refer-\nence-counted value carries a reference count with it, and most opera-\ntions require that this reference count be examined or manipulated in\nsome way. Object values therefore require more memory, and we\nsometimes execute more code when we work with them. Furthermore,\nthe underlying source code is considerably more complex for a refer-\nence-counted class than for a less elaborate implementation. An un-\nreference-counted string class typically stands on its own, while our\nfinal String class is useless unless it’s augmented with three auxiliary\nclasses (StringValue, RCObject, and RCPtr). True, our more compli-\ncated design holds out the promise of greater efficiency when values\ncan be shared, it eliminates the need to track object ownership, and it\npromotes reusability of the reference counting idea and implementa-\ntion. Nevertheless, that quartet of classes has to be written, tested,\ndocumented, and maintained, and that’s going to be more work than\nwriting, testing, documenting, and maintaining a single class. Even a\nmanager can see that.\nReference counting is an optimization technique predicated on the as-\nsumption that objects will commonly share values (see also Item 18). If\nthis assumption fails to hold, reference counting will use more memory\nthan a more conventional implementation and it will execute more\ncode. On the other hand, if your objects do tend to have common val-\n\n\n212\nItem 29\nues, reference counting should save you both time and space. The big-\nger your object values and the more objects that can simultaneously\nshare values, the more memory you’ll save. The more you copy and as-\nsign values between objects, the more time you’ll save. The more ex-\npensive it is to create and destroy a value, the more time you’ll save\nthere, too. In short, reference counting is most useful for improving ef-\nficiency under the following conditions:\n■Relatively few values are shared by relatively many objects.\nSuch sharing typically arises through calls to assignment opera-\ntors and copy constructors. The higher the objects/values ratio,\nthe better the case for reference counting.\n■Object values are expensive to create or destroy, or they use\nlots of memory. Even when this is the case, reference counting\nstill buys you nothing unless these values can be shared by multi-\nple objects. \nThere is only one sure way to tell whether these conditions are satis-\nfied, and that way is not to guess or rely on your programmer’s intu-\nition (see Item 16). The reliable way to find out whether your program\ncan benefit from reference counting is to profile or instrument it. That\nway you can find out if creating and destroying values is a perfor-\nmance bottleneck, and you can measure the objects/values ratio. Only\nwhen you have such data in hand are you in a position to determine\nwhether the benefits of reference counting (of which there are many)\noutweigh the disadvantages (of which there are also many).\nEven when the conditions above are satisfied, a design employing ref-\nerence counting may still be inappropriate. Some data structures (e.g.,\ndirected graphs) lead to self-referential or circular dependency struc-\ntures. Such data structures have a tendency to spawn isolated collec-\ntions of objects, used by no one, whose reference counts never drop to\nzero. That’s because each object in the unused structure is pointed to\nby at least one other object in the same structure. Industrial-strength\ngarbage collectors use special techniques to find such structures and\neliminate them, but the simple reference-counting approach we’ve ex-\namined here is not easily extended to include such techniques.\nReference counting can be attractive even if efficiency is not your pri-\nmary concern. If you find yourself weighed down with uncertainty over\nwho’s allowed to delete what, reference counting could be just the\ntechnique you need to ease your burden. Many programmers are de-\nvoted to reference counting for this reason alone.\nLet us close this discussion on a technical note by tying up one re-\nmaining loose end. When RCObject::removeReference decrements\nan object’s reference count, it checks to see if the new count is 0. If it\n\n\nProxy Classes\n213\nis, removeReference destroys the object by deleteing this. This is a\nsafe operation only if the object was allocated by calling new, so we\nneed some way of ensuring that RCObjects are created only in that\nmanner.\nIn this case we do it by convention. RCObject is designed for use as a\nbase class of reference-counted value objects, and those value objects\nshould be referred to only by smart RCPtr pointers. Furthermore, the\nvalue objects should be instantiated only by application objects that\nrealize values are being shared; the classes describing the value ob-\njects should never be available for general use. In our example, the\nclass for value objects is StringValue, and we limit its use by making\nit private in String. Only String can create StringValue objects, so\nit is up to the author of the String class to ensure that all such objects\nare allocated via new.\nOur approach to the constraint that RCObjects be created only on the\nheap, then, is to assign responsibility for conformance to this con-\nstraint to a well-defined set of classes and to ensure that only that set\nof classes can create RCObjects. There is no possibility that random\nclients can accidently (or maliciously) create RCObjects in an inappro-\npriate manner. We limit the right to create reference-counted objects,\nand when we do hand out the right, we make it clear that it’s accom-\npanied by the concomitant responsibility to follow the rules governing\nobject creation.\nItem 30: Proxy classes.\nProxy Classes\nThough your in-laws may be one-dimensional, the world, in general, is\nnot. Unfortunately, C++ hasn’t yet caught on to that fact. At least,\nthere’s little evidence for it in the language’s support for arrays. You\ncan create two-dimensional, three-dimensional — heck, you can create\nn-dimensional — arrays in FORTRAN, in BASIC, even in COBOL (okay,\nFORTRAN only allows up to seven dimensions, but let’s not quibble),\nbut can you do it in C++? Only sometimes, and even then only sort of.\nThis much is legal:\nint data[10][20];\n// 2D array: 10 by 20\nThe corresponding construct using variables as dimension sizes, how-\never, is not:\nvoid processInput(int dim1, int dim2)\n{\nint data[dim1][dim2];\n// error! array dimensions\n...\n// must be known during\n}\n// compilation\n\n\n214\nItem 30\nIt’s not even legal for a heap-based allocation:\nint *data =\nnew int[dim1][dim2];\n// error!\nImplementing Two-Dimensional Arrays\nMultidimensional arrays are as useful in C++ as they are in any other\nlanguage, so it’s important to come up with a way to get decent support\nfor them. The usual way is the standard one in C++: create a class to\nrepresent the objects we need but that are missing in the language\nproper. Hence we can define a class template for two-dimensional ar-\nrays:\ntemplate<class T>\nclass Array2D {\npublic:\nArray2D(int dim1, int dim2);\n...\n};\nNow we can define the arrays we want:\nArray2D<int> data(10, 20);\n// fine\nArray2D<float> *data =\nnew Array2D<float>(10, 20);\n// fine\nvoid processInput(int dim1, int dim2)\n{\nArray2D<int> data(dim1, dim2);\n// fine\n...\n}\nUsing these array objects, however, isn’t quite as straightforward. In\nkeeping with the grand syntactic tradition of both C and C++, we’d like\nto be able to use brackets to index into our arrays,\ncout << data[3][6];\nbut how do we declare the indexing operator in Array2D to let us do\nthis?\nOur first impulse might be to declare operator[][] functions, like\nthis:\n\n\nProxy Classes\n215\ntemplate<class T>\nclass Array2D {\npublic:\n// declarations that won’t compile\nT& operator[][](int index1, int index2);\nconst T& operator[][](int index1, int index2) const;\n...\n};\nWe’d quickly learn to rein in such impulses, however, because there is\nno such thing as operator[][], and don’t think your compilers will\nforget it. (For a complete list of operators, overloadable and otherwise,\nsee Item 7.) We’ll have to do something else.\nIf you can stomach the syntax, you might follow the lead of the many\nprogramming languages that use parentheses to index into arrays. To\nuse parentheses, you just overload operator():\ntemplate<class T>\nclass Array2D {\npublic:\n// declarations that will compile\nT& operator()(int index1, int index2);\nconst T& operator()(int index1, int index2) const;\n...\n};\nClients then use arrays this way:\ncout << data(3, 6);\nThis is easy to implement and easy to generalize to as many dimen-\nsions as you like. The drawback is that your Array2D objects don’t\nlook like built-in arrays any more. In fact, the above access to element\n(3, 6) of data looks, on the face of it, like a function call.\nIf you reject the thought of your arrays looking like FORTRAN refu-\ngees, you might turn again to the notion of using brackets as the in-\ndexing operator. Although there is no such thing as operator[][], it\nis nonetheless legal to write code that appears to use it:\nint data[10][20];\n...\ncout << data[3][6];\n// fine\nWhat gives? \n\n\n216\nItem 30\nWhat gives is that the variable data is not really a two-dimensional\narray at all, it’s a 10-element one-dimensional array. Each of those 10\nelements is itself a 20-element array, so the expression data[3][6]\nreally means (data[3])[6], i.e., the seventh element of the array that\nis the fourth element of data. In short, the value yielded by the first ap-\nplication of the brackets is another array, so the second application of\nthe brackets gets an element from that secondary array.\nWe can play the same game with our Array2D class by overloading op-\nerator[] to return an object of a new class, Array1D. We can then\noverload operator[] again in Array1D to return an element in our\noriginal two-dimensional array:\ntemplate<class T>\nclass Array2D {\npublic:\nclass Array1D {\npublic:\nT& operator[](int index);\nconst T& operator[](int index) const;\n...\n};\nArray1D operator[](int index);\nconst Array1D operator[](int index) const;\n...\n};\nThe following then becomes legal:\nArray2D<float> data(10, 20);\n...\ncout << data[3][6];\n// fine\nHere, data[3] yields an Array1D object and the operator[] invoca-\ntion on that object yields the float in position (3, 6) of the original two-\ndimensional array.\nClients of the Array2D class need not be aware of the presence of the\nArray1D class. Objects of this latter class stand for one-dimensional\narray objects that, conceptually, do not exist for clients of Array2D.\nSuch clients program as if they were using real, live, honest-to-Allah\ntwo-dimensional arrays. It is of no concern to Array2D clients that\nthose objects must, in order to satisfy the vagaries of C++, be syntacti-\ncally compatible with one-dimensional arrays of other one-dimen-\nsional arrays.\n",
      "page_number": 224,
      "chapter_number": 23,
      "summary": "This chapter covers segment 23 (pages 224-233). Key topics include value, classes, and object. Second, the code that remains in String is nearly\nunchanged: the smart pointer replaced the dumb pointer essentially\nseamlessly.",
      "keywords": [
        "Reference Counting",
        "String class",
        "String",
        "Widget",
        "Reference",
        "int",
        "RCIPtr",
        "objects",
        "const",
        "Counting",
        "operator",
        "data",
        "Widget object",
        "arrays",
        "Classes"
      ],
      "concepts": [
        "value",
        "classes",
        "object",
        "arrays",
        "reference",
        "refer",
        "referred",
        "data",
        "widget",
        "counting"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 15,
          "title": "Segment 15 (pages 154-161)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 14,
          "title": "Segment 14 (pages 142-153)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 3,
          "title": "Segment 3 (pages 17-24)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "Segment 16 (pages 162-174)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 15,
          "title": "Segment 15 (pages 285-307)",
          "relevance_score": 0.61,
          "method": "api"
        }
      ]
    },
    {
      "number": 24,
      "title": "Segment 24 (pages 234-241)",
      "start_page": 234,
      "end_page": 241,
      "detection_method": "topic_boundary",
      "content": "Proxy Classes\n217\nEach Array1D object stands for a one-dimensional array that is absent\nfrom the conceptual model used by clients of Array2D. Objects that\nstand for other objects are often called proxy objects, and the classes\nthat give rise to proxy objects are often called proxy classes. In this ex-\nample, Array1D is a proxy class. Its instances stand for one-dimen-\nsional arrays that, conceptually, do not exist. (The terminology for\nproxy objects and classes is far from universal; objects of such classes\nare also sometimes known as surrogates.)\nDistinguishing Reads from Writes via operator[]\nThe use of proxies to implement classes whose instances act like mul-\ntidimensional arrays is common, but proxy classes are more flexible\nthan that. Item 5, for example, shows how proxy classes can be em-\nployed to prevent single-argument constructors from being used to\nperform unwanted type conversions. Of the varied uses of proxy\nclasses, however, the most heralded is that of helping distinguish\nreads from writes through operator[].\nConsider a reference-counted string type that supports operator[].\nSuch a type is examined in detail in Item 29. If the concepts behind ref-\nerence counting have slipped your mind, it would be a good idea to fa-\nmiliarize yourself with the material in that Item now.\nA string type supporting operator[] allows clients to write code like\nthis:\nString s1, s2;\n// a string-like class; the\n// use of proxies keeps this\n// class from conforming to\n// the standard string\n...\n// interface\ncout << s1[5];\n// read s1\ns2[5] = ’x’;\n// write s2\ns1[3] = s2[8];\n// write s1, read s2\nNote that operator[] can be called in two different contexts: to read\na character or to write a character. Reads are known as rvalue usages;\nwrites are known as lvalue usages. (The terms come from the field of\ncompilers, where an lvalue goes on the left-hand side of an assignment\nand an rvalue goes on the right-hand side.) In general, using an object\nas an lvalue means using it such that it might be modified, and using\nit as an rvalue means using it such that it cannot be modified.\nWe’d like to distinguish between lvalue and rvalue usage of opera-\ntor[] because, especially for reference-counted data structures, reads\ncan be much less expensive to implement than writes. As Item 29 ex-\n\n\n218\nItem 30\nplains, writes of reference-counted objects may involve copying an en-\ntire data structure, but reads never require more than the simple\nreturning of a value. Unfortunately, inside operator[], there is no\nway to determine the context in which the function was called; it is not\npossible to distinguish lvalue usage from rvalue usage within opera-\ntor[].\n“But wait,” you say, “we don’t need to. We can overload operator[] on\nthe basis of its constness, and that will allow us to distinguish reads\nfrom writes.” In other words, you suggest we solve our problem this\nway:\nclass String {\npublic:\nconst char& operator[](int index) const;\n// for reads\nchar& operator[](int index);\n// for writes\n...\n};\nAlas, this won’t work. Compilers choose between const and non-\nconst member functions by looking only at whether the object invok-\ning a function is const. No consideration is given to the context in\nwhich a call is made. Hence:\nString s1, s2;\n...\ncout << s1[5];\n// calls non-const operator[],\n// because s1 isn’t const\ns2[5] = ’x’;\n// also calls non-const\n// operator[]: s2 isn’t const\ns1[3] = s2[8];\n// both calls are to non-const\n// operator[], because both s1\n// and s2 are non-const objects\nOverloading operator[], then, fails to distinguish reads from writes.\nIn Item 29, we resigned ourselves to this unsatisfactory state of affairs\nand made the conservative assumption that all calls to operator[]\nwere for writes. This time we shall not give up so easily. It may be im-\npossible to distinguish lvalue from rvalue usage inside operator[],\nbut we still want to do it. We will therefore find a way. What fun is life\nif you allow yourself to be limited by the possible?\nOur approach is based on the fact that though it may be impossible to\ntell whether operator[] is being invoked in an lvalue or an rvalue\ncontext from within operator[], we can still treat reads differently\nfrom writes if we delay our lvalue-versus-rvalue actions until we see\n\n\nProxy Classes\n219\nhow the result of operator[] is used. All we need is a way to postpone\nour decision on whether our object is being read or written until after\noperator[] has returned. (This is an example of lazy evaluation — see\nItem 17.)\nA proxy class allows us to buy the time we need, because we can mod-\nify operator[] to return a proxy for a string character instead of a\nstring character itself. We can then wait to see how the proxy is used.\nIf it’s read, we can belatedly treat the call to operator[] as a read. If\nit’s written, we must treat the call to operator[] as a write.\nWe will see the code for this in a moment, but first it is important to\nunderstand the proxies we’ll be using. There are only three things you\ncan do with a proxy:\n■Create it, i.e., specify which string character it stands for.\n■Use it as the target of an assignment, in which case you are really\nmaking an assignment to the string character it stands for. When\nused in this way, a proxy represents an lvalue use of the string on\nwhich operator[] was invoked.\n■Use it in any other way. When used like this, a proxy represents\nan rvalue use of the string on which operator[] was invoked.\nHere are the class definitions for a reference-counted String class\nusing a proxy class to distinguish between lvalue and rvalue usages of\noperator[]:\nclass String {\n// reference-counted strings;\npublic:\n// see Item 29 for details\nclass CharProxy {\n// proxies for string chars\npublic:\nCharProxy(String& str, int index);\n// creation\nCharProxy& operator=(const CharProxy& rhs); // lvalue\nCharProxy& operator=(char c);\n// uses\noperator char() const;\n// rvalue\n// use\nprivate:\nString& theString;\n// string this proxy pertains to\nint charIndex;\n// char within that string\n// this proxy stands for\n};\n// continuation of String class \nconst CharProxy\noperator[](int index) const;\n// for const Strings\n\n\n220\nItem 30\nCharProxy operator[](int index);\n// for non-const Strings\n...\nfriend class CharProxy;\nprivate:\nRCPtr<StringValue> value;\n};\nOther than the addition of the CharProxy class (which we’ll examine\nbelow), the only difference between this String class and the final\nString class in Item 29 is that both operator[] functions now return\nCharProxy objects. Clients of String can generally ignore this, how-\never, and program as if the operator[] functions returned characters\n(or references to characters — see Item 1) in the usual manner:\nString s1, s2;\n// reference-counted strings\n// using proxies\n...\ncout << s1[5];\n// still legal, still works\ns2[5] = ’x’;\n// also legal, also works\ns1[3] = s2[8];\n// of course it’s legal,\n// of course it works\nWhat’s interesting is not that this works. What’s interesting is how it\nworks.\nConsider first this statement:\ncout << s1[5];\nThe expression s1[5] yields a CharProxy object. No output operator\nis defined for such objects, so your compilers labor to find an implicit\ntype conversion they can apply to make the call to operator<< suc-\nceed (see Item 5). They find one: the implicit conversion from Char-\nProxy to char declared in the CharProxy class. They automatically\ninvoke this conversion operator, and the result is that the string char-\nacter represented by the CharProxy is printed. This is representative\nof the CharProxy-to-char conversion that takes place for all Char-\nProxy objects used as rvalues.\nLvalue usage is handled differently. Look again at\ns2[5] = ’x’;\nAs before, the expression s2[5] yields a CharProxy object, but this\ntime that object is the target of an assignment. Which assignment op-\nerator is invoked? The target of the assignment is a CharProxy, so the\nassignment operator that’s called is in the CharProxy class. This is\ncrucial, because inside a CharProxy assignment operator, we know\n\n\nProxy Classes\n221\nthat the CharProxy object being assigned to is being used as an lvalue.\nWe therefore know that the string character for which the proxy stands\nis being used as an lvalue, and we must take whatever actions are nec-\nessary to implement lvalue access for that character.\nSimilarly, the statement\ns1[3] = s2[8];\ncalls the assignment operator for two CharProxy objects, and inside\nthat operator we know the object on the left is being used as an lvalue\nand the object on the right as an rvalue.\n“Yeah, yeah, yeah,” you grumble, “show me.” Okay. Here’s the code for\nString’s operator[] functions:\nconst String::CharProxy String::operator[](int index) const\n{\nreturn CharProxy(const_cast<String&>(*this), index); \n}\nString::CharProxy String::operator[](int index)\n{\nreturn CharProxy(*this, index); \n}\nEach function just creates and returns a proxy for the requested char-\nacter. No action is taken on the character itself: we defer such action\nuntil we know whether the access is for a read or a write. \nNote that the const version of operator[] returns a const proxy. Be-\ncause CharProxy::operator= isn’t a const member function, such\nproxies can’t be used as the target of assignments. Hence neither the\nproxy returned from the const version of operator[] nor the charac-\nter for which it stands may be used as an lvalue. Conveniently enough,\nthat’s exactly the behavior we want for the const version of opera-\ntor[].\nNote also the use of a const_cast (see Item 2) on *this when creating\nthe CharProxy object that the const operator[] returns. That’s nec-\nessary to satisfy the constraints of the CharProxy constructor, which\naccepts only a non-const String. Casts are usually worrisome, but in\nthis case the CharProxy object returned by operator[] is itself\nconst, so there is no risk the String containing the character to\nwhich the proxy refers will be modified.\nEach proxy returned by an operator[] function remembers which\nstring it pertains to and, within that string, the index of the character\nit represents:\n\n\n222\nItem 30\nString::CharProxy::CharProxy(String& str, int index)\n: theString(str), charIndex(index) {}\nConversion of a proxy to an rvalue is straightforward — we just return\na copy of the character represented by the proxy:\nString::CharProxy::operator char() const\n{\nreturn theString.value->data[charIndex];\n}\nIf you’ve forgotten the relationship among a String object, its value\nmember, and the data member it points to, you can refresh your mem-\nory by turning to Item 29. Because this function returns a character\nby value, and because C++ limits the use of such by-value returns to\nrvalue contexts only, this conversion function can be used only in\nplaces where an rvalue is legal.\nWe thus turn to implementation of CharProxy’s assignment operators,\nwhich is where we must deal with the fact that a character represented\nby a proxy is being used as the target of an assignment, i.e., as an\nlvalue. We can implement CharProxy’s conventional assignment oper-\nator as follows:\nString::CharProxy&\nString::CharProxy::operator=(const CharProxy& rhs)\n{\n// if the string is sharing a value with other String objects,\n// break off a separate copy of the value for this string only\nif (theString.value->isShared()) {\ntheString.value = new StringValue(theString.value->data);\n}\n// now make the assignment: assign the value of the char\n// represented by rhs to the char represented by *this\ntheString.value->data[charIndex] = \nrhs.theString.value->data[rhs.charIndex];\nreturn *this;\n}\nIf you compare this with the implementation of the non-const\nString::operator[] in Item 29 on page 207, you’ll see that they are\nstrikingly similar. This is to be expected. In Item 29, we pessimistically\nassumed that all invocations of the non-const operator[] were\nwrites, so we treated them as such. Here, we moved the code imple-\nmenting a write into CharProxy’s assignment operators, and that al-\nlows us to avoid paying for a write when the non-const operator[] is\nused only in an rvalue context. Note, by the way, that this function re-\nquires access to String’s private data member value. That’s why\n\n\nProxy Classes\n223\nCharProxy is declared a friend in the earlier class definition for\nString.\nThe second CharProxy assignment operator is almost identical:\nString::CharProxy& String::CharProxy::operator=(char c)\n{\nif (theString.value->isShared()) {\ntheString.value = new StringValue(theString.value->data);\n}\ntheString.value->data[charIndex] = c;\nreturn *this;\n}\nAs an accomplished software engineer, you would, of course, banish\nthe code duplication present in these two assignment operators to a\nprivate CharProxy member function that both would call. Aren’t you\nthe modular one?\nLimitations\nThe use of a proxy class is a nice way to distinguish lvalue and rvalue\nusage of operator[], but the technique is not without its drawbacks.\nWe’d like proxy objects to seamlessly replace the objects they stand for,\nbut this ideal is difficult to achieve. That’s because objects are used as\nlvalues in contexts other than just assignment, and using proxies in\nsuch contexts usually yields behavior different from using real objects. \nConsider again the code fragment from Item 29 that motivated our de-\ncision to add a shareability flag to each StringValue object. If\nString::operator[] returns a CharProxy instead of a char&, that\ncode will no longer compile:\nString s1 = \"Hello\";\nchar *p = &s1[1];\n// error!\nThe expression s1[1] returns a CharProxy, so the type of the expres-\nsion on the right-hand side of the “=” is CharProxy*. There is no con-\nversion from a CharProxy* to a char*, so the initialization of p fails to\ncompile. In general, taking the address of a proxy yields a different\ntype of pointer than does taking the address of a real object. \nTo eliminate this difficulty, you’ll need to overload the address-of oper-\nators for the CharProxy class:\n\n\n224\nItem 30\nclass String {\npublic:\nclass CharProxy {\npublic:\n...\nchar * operator&();\nconst char * operator&() const;\n...\n};\n...\n};\nThese functions are easy to implement. The const function just re-\nturns a pointer to a const version of the character represented by the\nproxy:\nconst char * String::CharProxy::operator&() const\n{\nreturn &(theString.value->data[charIndex]);\n}\nThe non-const function is a bit more work, because it returns a\npointer to a character that may be modified. This is analogous to the\nbehavior of the non-const version of String::operator[] in Item 29,\nand the implementation is equally analogous:\nchar * String::CharProxy::operator&()\n{\n// make sure the character to which this function returns\n// a pointer isn’t shared by any other String objects\nif (theString.value->isShared()) {\ntheString.value = new StringValue(theString.value->data);\n}\n// we don’t know how long the pointer this function \n// returns will be kept by clients, so the StringValue\n// object can never be shared\ntheString.value->markUnshareable();\nreturn &(theString.value->data[charIndex]);\n}\nMuch of this code is common to other CharProxy member functions,\nso I know you’d encapsulate it in a private member function that all\nwould call.\nA second difference between chars and the CharProxys that stand for\nthem becomes apparent if we have a template for reference-counted\narrays that use proxy classes to distinguish lvalue and rvalue invoca-\ntions of operator[]:\n",
      "page_number": 234,
      "chapter_number": 24,
      "summary": "This chapter covers segment 24 (pages 234-241). Key topics include string, strings, and operator. Objects that\nstand for other objects are often called proxy objects, and the classes\nthat give rise to proxy objects are often called proxy classes.",
      "keywords": [
        "string",
        "operator",
        "CharProxy",
        "Proxy",
        "Item",
        "Proxy Classes",
        "const",
        "string character",
        "char",
        "Classes",
        "Objects",
        "String class",
        "lvalue",
        "rvalue",
        "character"
      ],
      "concepts": [
        "string",
        "strings",
        "operator",
        "proxy",
        "proxies",
        "char",
        "objects",
        "classes",
        "returning",
        "different"
      ],
      "similar_chapters": [
        {
          "book": "Python Distilled",
          "chapter": 38,
          "title": "Segment 38 (pages 345-352)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 10,
          "title": "Segment 10 (pages 77-87)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 24,
          "title": "Segment 24 (pages 241-248)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 49,
          "title": "Segment 49 (pages 993-1010)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.56,
          "method": "api"
        }
      ]
    },
    {
      "number": 25,
      "title": "Segment 25 (pages 242-261)",
      "start_page": 242,
      "end_page": 261,
      "detection_method": "topic_boundary",
      "content": "Proxy Classes\n225\ntemplate<class T>\n// reference-counted array\nclass Array {\n// using proxies\npublic:\nclass Proxy {\npublic:\nProxy(Array<T>& array, int index);\nProxy& operator=(const T& rhs);\noperator T() const;\n...\n};\nconst Proxy operator[](int index) const;\nProxy operator[](int index);\n...\n};\nConsider how these arrays might be used:\nArray<int> intArray;\n...\nintArray[5] = 22;\n// fine\nintArray[5] += 5;\n// error!\n++intArray[5];\n// error!\nAs expected, use of operator[] as the target of a simple assignment\nsucceeds, but use of operator[] on the left-hand side of a call to op-\nerator+= or operator++ fails. That’s because operator[] returns a\nproxy, and there is no operator+= or operator++ for Proxy objects.\nA similar situation exists for other operators that require lvalues, in-\ncluding operator*=, operator<<=, operator--, etc. If you want\nthese operators to work with operator[] functions that return prox-\nies, you must define each of these functions for the Array<T>::Proxy\nclass. That’s a lot of work, and you probably don’t want to do it. Unfor-\ntunately, you either do the work or you do without. Them’s the breaks.\nA related problem has to do with invoking member functions on real\nobjects through proxies. To be blunt about it, you can’t. For example,\nsuppose we’d like to work with reference-counted arrays of rational\nnumbers. We could define a class Rational and then use the Array\ntemplate we just saw:\nclass Rational {\npublic:\nRational(int numerator = 0, int denominator = 1);\nint numerator() const;\nint denominator() const;\n...\n};\nArray<Rational> array;\n\n\n226\nItem 30\nThis is how we’d expect to be able to use such arrays, but, alas, we’d\nbe disappointed:\ncout << array[4].numerator();\n// error!\nint denom = array[22].denominator(); \n// error!\nBy now the difficulty is predictable; operator[] returns a proxy for a\nrational number, not an actual Rational object. But the numerator\nand denominator member functions exist only for Rationals, not\ntheir proxies. Hence the complaints by your compilers. To make prox-\nies behave like the objects they stand for, you must overload each\nfunction applicable to the real objects so it applies to proxies, too. \nYet another situation in which proxies fail to replace real objects is\nwhen being passed to functions that take references to non-const ob-\njects:\nvoid swap(char& a, char& b);\n// swaps the value of a and b\nString s = \"+C+\";\n// oops, should be \"C++\"\nswap(s[0], s[1]);\n// this should fix the\n// problem, but it won’t\n// compile\nString::operator[] returns a CharProxy, but swap demands that its\narguments be of type char&. A CharProxy may be implicitly converted\ninto a char, but there is no conversion function to a char&. Further-\nmore, the char to which it may be converted can’t be bound to swap’s\nchar& parameters, because that char is a temporary object (it’s oper-\nator char’s return value) and, as Item 19 explains, there are good rea-\nsons for refusing to bind temporary objects to non-const reference\nparameters.\nA final way in which proxies fail to seamlessly replace real objects has\nto do with implicit type conversions. When a proxy object is implicitly\nconverted into the real object it stands for, a user-defined conversion\nfunction is invoked. For instance, a CharProxy can be converted into\nthe char it stands for by calling operator char. As Item 5 explains,\ncompilers may use only one user-defined conversion function when\nconverting a parameter at a call site into the type needed by the corre-\nsponding function parameter. As a result, it is possible for function\ncalls that succeed when passed real objects to fail when passed prox-\nies. For example, suppose we have a TVStation class and a function,\nwatchTV:\nclass TVStation {\npublic:\nTVStation(int channel);\n...\n};\n\n\nProxy Classes\n227\nvoid watchTV(const TVStation& station, float hoursToWatch);\nThanks to implicit type conversion from int to TVStation (see Item 5),\nwe could then do this:\nwatchTV(10, 2.5);\n// watch channel 10 for\n// 2.5 hours\nUsing the template for reference-counted arrays that use proxy classes\nto distinguish lvalue and rvalue invocations of operator[], however,\nwe could not do this:\nArray<int> intArray;\nintArray[4] = 10;\nwatchTV(intArray[4], 2.5);\n// error! no conversion\n// from Proxy<int> to\n// TVStation\nGiven the problems that accompany implicit type conversions, it’s\nhard to get too choked up about this. In fact, a better design for the\nTVStation class would declare its constructor explicit, in which\ncase even the first call to watchTV would fail to compile. For all the de-\ntails on implicit type conversions and how explicit affects them, see\nItem 5.\nEvaluation\nProxy classes allow you to achieve some types of behavior that are oth-\nerwise difficult or impossible to implement. Multidimensional arrays\nare one example, lvalue/rvalue differentiation is a second, suppression\nof implicit conversions (see Item 5) is a third. \nAt the same time, proxy classes have disadvantages. As function re-\nturn values, proxy objects are temporaries (see Item 19), so they must\nbe created and destroyed. That’s not free, though the cost may be more\nthan recouped through their ability to distinguish write operations\nfrom read operations. The very existence of proxy classes increases the\ncomplexity of software systems that employ them, because additional\nclasses make things harder to design, implement, understand, and\nmaintain, not easier. \nFinally, shifting from a class that works with real objects to a class that\nworks with proxies often changes the semantics of the class, because\nproxy objects usually exhibit behavior that is subtly different from that\nof the real objects they represent. Sometimes this makes proxies a\npoor choice when designing a system, but in many cases there is little\nneed for the operations that would make the presence of proxies ap-\nparent to clients. For instance, few clients will want to take the address\n\n\n228\nItem 31\nof an Array1D object in the two-dimensional array example we saw at\nthe beginning of this Item, and there isn’t much chance that an Ar-\nraySize object (see Item 5) would be passed to a function expecting a\ndifferent type. In many cases, proxies can stand in for real objects per-\nfectly acceptably. When they can, it is often the case that nothing else\nwill do.\nItem 31: Making functions virtual with respect to \nmore than one object.\nImplementing Multiple Dispatch\nSometimes, to borrow a phrase from Jacqueline Susann, once is not\nenough. Suppose, for example, you’re bucking for one of those high-\nprofile, high-prestige, high-paying programming jobs at that famous\nsoftware company in Redmond, Washington — by which of course I\nmean Nintendo. To bring yourself to the attention of Nintendo’s man-\nagement, you might decide to write a video game. Such a game might\ntake place in outer space and involve space ships, space stations, and\nasteroids.\nAs the ships, stations, and asteroids whiz around in your artificial\nworld, they naturally run the risk of colliding with one another. Let’s\nassume the rules for such collisions are as follows:\n■If a ship and a station collide at low velocity, the ship docks at the\nstation. Otherwise the ship and the station sustain damage that’s\nproportional to the speed at which they collide.\n■If a ship and a ship or a station and a station collide, both partici-\npants in the collision sustain damage that’s proportional to the\nspeed at which they hit.\n■If a small asteroid collides with a ship or a station, the asteroid is\ndestroyed. If it’s a big asteroid, the ship or the station is destroyed.\n■If an asteroid collides with another asteroid, both break into\npieces and scatter little baby asteroids in all directions.\nThis may sound like a dull game, but it suffices for our purpose here,\nwhich is to consider how to structure the C++ code that handles colli-\nsions between objects.\nWe begin by noting that ships, stations, and asteroids share some\ncommon features. If nothing else, they’re all in motion, so they all have\na velocity that describes that motion. Given this commonality, it is nat-\nural to define a base class from which they all inherit. In practice, such\na class is almost invariably an abstract base class, and, if you heed the\n\n\nImplementing Multiple Dispatch\n229\nwarning I give in Item 33, base classes are always abstract. The hier-\narchy might therefore look like this:\nclass GameObject { ... };\nclass SpaceShip: public GameObject { ... };\nclass SpaceStation: public GameObject { ... };\nclass Asteroid: public GameObject { ... };\nNow, suppose you’re deep in the bowels of your program, writing the\ncode to check for and handle object collisions. You might come up with\na function that looks something like this:\nvoid checkForCollision(GameObject& object1,\nGameObject& object2)\n{\nif (theyJustCollided(object1, object2)) {\nprocessCollision(object1, object2);\n}\nelse {\n...\n}\n}\nThis is where the programming challenge becomes apparent. When\nyou call processCollision, you know that object1 and object2\njust collided, and you know that what happens in that collision de-\npends on what object1 really is and what object2 really is, but you\ndon’t know what kinds of objects they really are; all you know is that\nthey’re both GameObjects. If the collision processing depended only on\nthe dynamic type of object1, you could make processCollision vir-\ntual in GameObject and call object1.processCollision(object2).\nYou could do the same thing with object2 if the details of the collision\ndepended only on its dynamic type. What happens in the collision,\nhowever, depends on both their dynamic types. A function call that’s\nvirtual on only one object, you see, is not enough.\nWhat you need is a kind of function whose behavior is somehow virtual\non the types of more than one object. C++ offers no such function. Nev-\nGameObject\nSpaceShip\nSpaceStation\nAsteroid\n\n\n230\nItem 31\nertheless, you still have to implement the behavior required above. The\nquestion, then, is how you are going to do it.\nOne possibility is to scrap the use of C++ and choose another program-\nming language. You could turn to CLOS, for example, the Common\nLisp Object System. CLOS supports what is possibly the most general\nobject-oriented function-invocation mechanism one can imagine:\nmulti-methods. A multi-method is a function that’s virtual on as many\nparameters as you’d like, and CLOS goes even further by giving you\nsubstantial control over how calls to overloaded multi-methods are re-\nsolved. \nLet us assume, however, that you must implement your game in C++\n— that you must come up with your own way of implementing what is\ncommonly referred to as double-dispatching. (The name comes from\nthe object-oriented programming community, where what C++ pro-\ngrammers know as a virtual function call is termed a “message dis-\npatch.” A call that’s virtual on two parameters is implemented through\na “double dispatch.” The generalization of this — a function acting vir-\ntual on several parameters — is called multiple dispatch.) There are\nseveral approaches you might consider. None is without its disadvan-\ntages, but that shouldn’t surprise you. C++ offers no direct support for\ndouble-dispatching, so you must yourself do the work compilers do\nwhen they implement virtual functions (see Item 24). If that were easy\nto do, we’d probably all be doing it ourselves and simply programming\nin C. We aren’t and we don’t, so fasten your seat belts, it’s going to be\na bumpy ride.\nUsing Virtual Functions and RTTI\nVirtual functions implement a single dispatch; that’s half of what we\nneed; and compilers do virtual functions for us, so we begin by declar-\ning a virtual function collide in GameObject. This function is over-\nridden in the derived classes in the usual manner:\nclass GameObject {\npublic:\nvirtual void collide(GameObject& otherObject) = 0;\n...\n};\nclass SpaceShip: public GameObject {\npublic:\nvirtual void collide(GameObject& otherObject);\n...\n};\nHere I’m showing only the derived class SpaceShip, but SpaceSta-\ntion and Asteroid are handled in exactly the same manner.\n\n\nImplementing Multiple Dispatch\n231\nThe most common approach to double-dispatching returns us to the\nunforgiving world of virtual function emulation via chains of if-then-\nelses. In this harsh world, we first discover the real type of otherOb-\nject, then we test it against all the possibilities:\n// if we collide with an object of unknown type, we\n// throw an exception of this type:\nclass CollisionWithUnknownObject {\npublic:\nCollisionWithUnknownObject(GameObject& whatWeHit);\n...\n};\nvoid SpaceShip::collide(GameObject& otherObject)\n{\nconst type_info& objectType = typeid(otherObject);\nif (objectType == typeid(SpaceShip)) {\nSpaceShip& ss = static_cast<SpaceShip&>(otherObject);\nprocess a SpaceShip-SpaceShip collision;\n}\nelse if (objectType == typeid(SpaceStation)) {\nSpaceStation& ss =\nstatic_cast<SpaceStation&>(otherObject);\nprocess a SpaceShip-SpaceStation collision;\n}\nelse if (objectType == typeid(Asteroid)) {\nAsteroid& a = static_cast<Asteroid&>(otherObject);\nprocess a SpaceShip-Asteroid collision;\n}\nelse {\nthrow CollisionWithUnknownObject(otherObject);\n}\n}\nNotice how we need to determine the type of only one of the objects in-\nvolved in the collision. The other object is *this, and its type is deter-\nmined by the virtual function mechanism. We’re inside a SpaceShip\nmember function, so *this must be a SpaceShip object. Thus we only\nhave to figure out the real type of otherObject.\nThere’s nothing complicated about this code. It’s easy to write. It’s even\neasy to make work. That’s one of the reasons RTTI is worrisome: it\nlooks harmless. The true danger in this code is hinted at only by the\nfinal else clause and the exception that’s thrown there. \n\n\n232\nItem 31\nWe’ve pretty much bidden adios to encapsulation, because each col-\nlide function must be aware of each of its sibling classes, i.e., those\nclasses that inherit from GameObject. In particular, if a new type of\nobject — a new class — is added to the game, we must update each\nRTTI-based if-then-else chain in the program that might encounter\nthe new object type. If we forget even a single one, the program will\nhave a bug, and the bug will not be obvious. Furthermore, compilers\nare in no position to help us detect such an oversight, because they\nhave no idea what we’re doing.\nThis kind of type-based programming has a long history in C, and one\nof the things we know about it is that it yields programs that are essen-\ntially unmaintainable. Enhancement of such programs eventually be-\ncomes unthinkable. This is the primary reason why virtual functions\nwere invented in the first place: to shift the burden of generating and\nmaintaining type-based function calls from programmers to compilers.\nWhen we employ RTTI to implement double-dispatching, we are hark-\ning back to the bad old days. \nThe techniques of the bad old days led to errors in C, and they’ll lead\nto errors in C++, too. In recognition of our human frailty, we’ve in-\ncluded a final else clause in the collide function, a clause where\ncontrol winds up if we hit an object we don’t know about. Such a situ-\nation is, in principle, impossible, but where were our principles when\nwe decided to use RTTI? There are various ways to handle such unan-\nticipated interactions, but none is very satisfying. In this case, we’ve\nchosen to throw an exception, but it’s not clear how our callers can\nhope to handle the error any better than we can, since we’ve just run\ninto something we didn’t know existed.\nUsing Virtual Functions Only\nThere is a way to minimize the risks inherent in an RTTI approach to\nimplementing double-dispatching, but before we look at that, it’s con-\nvenient to see how to attack the problem using nothing but virtual\nfunctions. That strategy begins with the same basic structure as the\nRTTI approach. The collide function is declared virtual in GameOb-\nject and is redefined in each derived class. In addition, collide is\noverloaded in each class, one overloading for each derived class in the\nhierarchy:\nclass SpaceShip;\n// forward declarations\nclass SpaceStation;\nclass Asteroid;\n\n\nImplementing Multiple Dispatch\n233\nclass GameObject {\npublic:\nvirtual void collide(GameObject&\notherObject) = 0;\nvirtual void collide(SpaceShip&\notherObject) = 0;\nvirtual void collide(SpaceStation& otherObject) = 0;\nvirtual void collide(Asteroid&\notherobject) = 0;\n...\n};\nclass SpaceShip: public GameObject {\npublic:\nvirtual void collide(GameObject&\notherObject);\nvirtual void collide(SpaceShip&\notherObject);\nvirtual void collide(SpaceStation& otherObject);\nvirtual void collide(Asteroid&\notherobject);\n...\n};\nThe basic idea is to implement double-dispatching as two single dis-\npatches, i.e., as two separate virtual function calls: the first deter-\nmines the dynamic type of the first object, the second determines that\nof the second object. As before, the first virtual call is to the collide\nfunction taking a GameObject& parameter. That function’s implemen-\ntation now becomes startlingly simple:\nvoid SpaceShip::collide(GameObject& otherObject)\n{\notherObject.collide(*this);\n}\nAt first glance, this appears to be nothing more than a recursive call to\ncollide with the order of the parameters reversed, i.e., with other-\nObject becoming the object calling the member function and *this\nbecoming the function’s parameter. Glance again, however, because\nthis is not a recursive call. As you know, compilers figure out which of\na set of functions to call on the basis of the static types of the argu-\nments passed to the function. In this case, four different collide\nfunctions could be called, but the one chosen is based on the static\ntype of *this. What is that static type? Being inside a member func-\ntion of the class SpaceShip, *this must be of type SpaceShip. The\ncall is therefore to the collide function taking a SpaceShip&, not the\ncollide function taking a GameObject&.\nAll the collide functions are virtual, so the call inside Space-\nShip::collide resolves to the implementation of collide correspond-\ning to the real type of otherObject. Inside that implementation of\ncollide, the real types of both objects are known, because the left-\nhand object is *this (and therefore has as its type the class imple-\n\n\n234\nItem 31\nmenting the member function) and the right-hand object’s real type is\nSpaceShip, the same as the declared type of the parameter.\nAll this may be clearer when you see the implementations of the other\ncollide functions in SpaceShip:\nvoid SpaceShip::collide(SpaceShip& otherObject)\n{\nprocess a SpaceShip-SpaceShip collision;\n}\nvoid SpaceShip::collide(SpaceStation& otherObject)\n{\nprocess a SpaceShip-SpaceStation collision;\n}\nvoid SpaceShip::collide(Asteroid& otherObject)\n{\nprocess a SpaceShip-Asteroid collision;\n}\nAs you can see, there’s no muss, no fuss, no RTTI, no need to throw\nexceptions for unexpected object types. There can be no unexpected\nobject types — that’s the whole point of using virtual functions. In fact,\nwere it not for its fatal flaw, this would be the perfect solution to the\ndouble-dispatching problem.\nThe flaw is one it shares with the RTTI approach we saw earlier: each\nclass must know about its siblings. As new classes are added, the code\nmust be updated. However, the way in which the code must be up-\ndated is different in this case. True, there are no if-then-elses to\nmodify, but there is something that is often worse: each class defini-\ntion must be amended to include a new virtual function. If, for exam-\nple, you decide to add a new class Satellite (inheriting from\nGameObject) to your game, you’d have to add a new collide function\nto each of the existing classes in the program.\nModifying existing classes is something you are frequently in no posi-\ntion to do. If, instead of writing the entire video game yourself, you\nstarted with an off-the-shelf class library comprising a video game ap-\nplication framework, you might not have write access to the GameOb-\nject class or the framework classes derived from it. In that case,\nadding new member functions, virtual or otherwise, is not an option.\nAlternatively, you may have physical access to the classes requiring\nmodification, but you may not have practical access. For example, sup-\npose you were hired by Nintendo and were put to work on programs\nusing a library containing GameObject and other useful classes.\nSurely you wouldn’t be the only one using that library, and Nintendo\nwould probably be less than thrilled about recompiling every applica-\ntion using that library each time you decided to add a new type of ob-\n\n\nImplementing Multiple Dispatch\n235\nject to your program. In practice, libraries in wide use are modified\nonly rarely, because the cost of recompiling everything using those li-\nbraries is too great.\nThe long and short of it is if you need to implement double-dispatching\nin your program, your best recourse is to modify your design to elimi-\nnate the need. Failing that, the virtual function approach is safer than\nthe RTTI strategy, but it constrains the extensibility of your system to\nmatch that of your ability to edit header files. The RTTI approach, on\nthe other hand, makes no recompilation demands, but, if implemented\nas shown above, it generally leads to software that is unmaintainable.\nYou pays your money and you takes your chances.\nEmulating Virtual Function Tables\nThere is a way to improve those chances. You may recall from Item 24\nthat compilers typically implement virtual functions by creating an\narray of function pointers (the vtbl) and then indexing into that array\nwhen a virtual function is called. Using a vtbl eliminates the need for\ncompilers to perform chains of if-then-else-like computations, and\nit allows compilers to generate the same code at all virtual function call\nsites: determine the correct vtbl index, then call the function pointed\nto at that position in the vtbl. \nThere is no reason you can’t do this yourself. If you do, you not only\nmake your RTTI-based code more efficient (indexing into an array and\nfollowing a function pointer is almost always more efficient than run-\nning through a series of if-then-else tests, and it generates less\ncode, too), you also isolate the use of RTTI to a single location: the\nplace where your array of function pointers is initialized. I should men-\ntion that the meek may inherit the earth, but the meek of heart may\nwish to take a few deep breaths before reading what follows.\nWe begin by making some modifications to the functions in the\nGameObject hierarchy:\nclass GameObject {\npublic:\nvirtual void collide(GameObject& otherObject) = 0;\n...\n};\nclass SpaceShip: public GameObject {\npublic:\nvirtual void collide(GameObject& otherObject);\nvirtual void hitSpaceShip(SpaceShip& otherObject);\nvirtual void hitSpaceStation(SpaceStation& otherObject);\nvirtual void hitAsteroid(Asteroid& otherobject);\n...\n};\n\n\n236\nItem 31\nvoid SpaceShip::hitSpaceShip(SpaceShip& otherObject)\n{\nprocess a SpaceShip-SpaceShip collision;\n}\nvoid SpaceShip::hitSpaceStation(SpaceStation& otherObject)\n{\nprocess a SpaceShip-SpaceStation collision;\n}\nvoid SpaceShip::hitAsteroid(Asteroid& otherObject)\n{\nprocess a SpaceShip-Asteroid collision;\n}\nLike the RTTI-based hierarchy we started out with, the GameObject\nclass contains only one function for processing collisions, the one that\nperforms the first of the two necessary dispatches. Like the virtual-\nfunction-based hierarchy we saw later, each kind of interaction is en-\ncapsulated in a separate function, though in this case the functions\nhave different names instead of sharing the name collide. There is a\nreason for this abandonment of overloading, and we shall see it soon.\nFor the time being, note that the design above contains everything we\nneed except an implementation for SpaceShip::collide; that’s where\nthe various hit functions will be invoked. As before, once we success-\nfully implement the SpaceShip class, the SpaceStation and Aster-\noid classes will follow suit.\nInside SpaceShip::collide, we need a way to map the dynamic type\nof the parameter otherObject to a member function pointer that\npoints to the appropriate collision-handling function. An easy way to\ndo this is to create an associative array that, given a class name, yields\nthe appropriate member function pointer. It’s possible to implement\ncollide using such an associative array directly, but it’s a bit easier\nto understand what’s going on if we add an intervening function,\nlookup, that takes a GameObject and returns the appropriate mem-\nber function pointer. That is, you pass lookup a GameObject, and it\nreturns a pointer to the member function to call when you collide with\nsomething of that GameObject’s type.\nHere’s the declaration of lookup:\nclass SpaceShip: public GameObject {\nprivate:\ntypedef void (SpaceShip::*HitFunctionPtr)(GameObject&);\nstatic HitFunctionPtr lookup(const GameObject& whatWeHit);\n...\n};\n\n\nImplementing Multiple Dispatch\n237\nThe syntax of function pointers is never very pretty, and for member\nfunction pointers it’s worse than usual, so we’ve typedefed HitFunc-\ntionPtr to be shorthand for a pointer to a member function of Space-\nShip that takes a GameObject& and returns nothing.\nOnce we’ve got lookup, implementation of collide becomes the pro-\nverbial piece of cake:\nvoid SpaceShip::collide(GameObject& otherObject)\n{\nHitFunctionPtr hfp =\nlookup(otherObject);\n// find the function to call\nif (hfp) {\n// if a function was found\n(this->*hfp)(otherObject);\n// call it\n}\nelse {\nthrow CollisionWithUnknownObject(otherObject);\n}\n}\nProvided we’ve kept the contents of our associative array in sync with\nthe class hierarchy under GameObject, lookup must always find a\nvalid function pointer for the object we pass it. People are people, how-\never, and mistakes have been known to creep into even the most care-\nfully crafted software systems. That’s why we still check to make sure\na valid pointer was returned from lookup, and that’s why we still\nthrow an exception if the impossible occurs and the lookup fails.\nAll that remains now is the implementation of lookup. Given an asso-\nciative array that maps from object types to member function pointers,\nthe lookup itself is easy, but creating, initializing, and destroying the\nassociative array is an interesting problem of its own.\nSuch an array should be created and initialized before it’s used, and it\nshould be destroyed when it’s no longer needed. We could use new and\ndelete to create and destroy the array manually, but that would be\nerror-prone: how could we guarantee the array wasn’t used before we\ngot around to initializing it? A better solution is to have compilers au-\ntomate the process, and we can do that by making the associative\narray static in lookup. That way it will be created and initialized the\nfirst time lookup is called, and it will be automatically destroyed some-\ntime after main is exited. \nFurthermore, we can use the map template from the Standard Tem-\nplate Library (see Item 35) as the associative array, because that’s\nwhat a map is:\n\n\n238\nItem 31\nclass SpaceShip: public GameObject {\nprivate:\ntypedef void (SpaceShip::*HitFunctionPtr)(GameObject&);\ntypedef map<string, HitFunctionPtr> HitMap;\n...\n};\nSpaceShip::HitFunctionPtr\nSpaceShip::lookup(const GameObject& whatWeHit)\n{\nstatic HitMap collisionMap;\n...\n}\nHere, collisionMap is our associative array. It maps the name of a\nclass (as a string object) to a SpaceShip member function pointer.\nBecause map<string, HitFunctionPtr> is quite a mouthful, we use\na typedef to make it easier to swallow. (For fun, try writing the declara-\ntion of collisionMap without using the HitMap and HitFunctionPtr\ntypedefs. Most people will want to do this only once.)\nGiven collisionMap, the implementation of lookup is rather anticli-\nmactic. That’s because searching for something is an operation di-\nrectly supported by the map class, and the one member function we\ncan always (portably) call on the result of a typeid invocation is name\n(which, predictably†, yields the name of the object’s dynamic type). To\nimplement lookup, then, we just find the entry in collisionMap cor-\nresponding to the dynamic type of lookup’s argument. \nThe code for lookup is straightforward, but if you’re not familiar with\nthe Standard Template Library (again, see Item 35), it may not seem\nthat way. Don’t worry. The comments in the function explain what’s\ngoing on.\nSpaceShip::HitFunctionPtr\nSpaceShip::lookup(const GameObject& whatWeHit)\n{\nstatic HitMap collisionMap;\n// we’ll see how to\n// initialize this below\n// look up the collision-processing function for the type\n// of whatWeHit. The value returned is a pointer-like \n// object called an \"iterator\" (see Item 35).\nHitMap::iterator mapEntry=\ncollisionMap.find(typeid(whatWeHit).name());\n// mapEntry == collisionMap.end() if the lookup failed;\n// this is standard map behavior. Again, see Item 35.\nif (mapEntry == collisionMap.end()) return 0;\n† It turns out that it’s not so predictable after all. The C++ standard doesn’t specify the\nreturn value of type_info::name, and different implementations do behave different-\nly. A preferable design is to use a container-friendly class that wraps type_info ob-\njects, such as Andrei Alexandrescu’s TypeInfo class, which is described in section 2.8\nof his Modern C++ Design (Addison Wesley, 2001).\n\n\nImplementing Multiple Dispatch\n239\n// If we get here, the search succeeded. mapEntry \n// points to a complete map entry, which is a \n// (string, HitFunctionPtr) pair. We want only the\n// second part of the pair, so that’s what we return.\nreturn (*mapEntry).second;\n}\nThe final statement in the function returns (*mapEntry).second in-\nstead of the more conventional mapEntry->second in order to satisfy\nthe vagaries of the STL. For details, see page 96.\nInitializing Emulated Virtual Function Tables\nWhich brings us to the initialization of collisionMap. We’d like to say\nsomething like this,\n// An incorrect implementation\nSpaceShip::HitFunctionPtr\nSpaceShip::lookup(const GameObject& whatWeHit)\n{\nstatic HitMap collisionMap;\ncollisionMap[\"SpaceShip\"] = &hitSpaceShip;\ncollisionMap[\"SpaceStation\"] = &hitSpaceStation;\ncollisionMap[\"Asteroid\"] = &hitAsteroid;\n...\n}\nbut this inserts the member function pointers into collisionMap each\ntime lookup is called, and that’s needlessly inefficient. In addition, this\nwon’t compile, but that’s a secondary problem we’ll address shortly.\nWhat we need now is a way to put the member function pointers into\ncollisionMap only once — when collisionMap is created. That’s\neasy enough to accomplish; we just write a private static member func-\ntion called initializeCollisionMap to create and initialize our map,\nthen we initialize collisionMap with initializeCollisionMap’s re-\nturn value:\nclass SpaceShip: public GameObject {\nprivate:\nstatic HitMap initializeCollisionMap();\n...\n};\nSpaceShip::HitFunctionPtr\nSpaceShip::lookup(const GameObject& whatWeHit)\n{\nstatic HitMap collisionMap = initializeCollisionMap();\n...\n}\n\n\n240\nItem 31\nBut this means we may have to pay the cost of copying the map object\nreturned from initializeCollisionMap into collisionMap (see\nItems 19 and 20). We’d prefer not to do that. We wouldn’t have to pay\nif initializeCollisionMap returned a pointer, but then we’d have to\nworry about making sure the map object the pointer pointed to was de-\nstroyed at an appropriate time. \nFortunately, there’s a way for us to have it all. We can turn colli-\nsionMap into a smart pointer (see Item 28) that automatically deletes\nwhat it points to when the pointer itself is destroyed. In fact, the stan-\ndard C++ library contains a template, auto_ptr, for just such a smart\npointer (see Item 9). By making collisionMap a static auto_ptr in\nlookup, we can have initializeCollisionMap return a pointer to\nan initialized map object, yet never have to worry about a resource leak;\nthe map to which collisionMap points will be automatically destroyed\nwhen collisionMap is. Thus:\nclass SpaceShip: public GameObject {\nprivate:\nstatic HitMap * initializeCollisionMap();\n...\n};\nSpaceShip::HitFunctionPtr\nSpaceShip::lookup(const GameObject& whatWeHit)\n{\nstatic auto_ptr<HitMap> \ncollisionMap(initializeCollisionMap());\n...\n}\nThe clearest way to implement initializeCollisionMap would seem\nto be this, \nSpaceShip::HitMap * SpaceShip::initializeCollisionMap()\n{\nHitMap *phm = new HitMap;\n(*phm)[\"SpaceShip\"] = &hitSpaceShip;\n(*phm)[\"SpaceStation\"] = &hitSpaceStation;\n(*phm)[\"Asteroid\"] = &hitAsteroid;\nreturn phm;\n}\nbut as I noted earlier, this won’t compile. That’s because a HitMap is\ndeclared to hold pointers to member functions that all take the same\n\n\nImplementing Multiple Dispatch\n241\ntype of argument, namely GameObject. But hitSpaceShip takes a\nSpaceShip, hitSpaceStation takes a SpaceStation, and, hitAst-\neroid takes an Asteroid. Even though SpaceShip, SpaceStation,\nand Asteroid can all be implicitly converted to GameObject, there is\nno such conversion for pointers to functions taking these argument\ntypes.\nTo placate your compilers, you might be tempted to employ\nreinterpret_casts (see Item 2), which are generally the casts of\nchoice when converting between function pointer types:\n// A bad idea...\nSpaceShip::HitMap * SpaceShip::initializeCollisionMap()\n{\nHitMap *phm = new HitMap;\n(*phm)[\"SpaceShip\"] =\nreinterpret_cast<HitFunctionPtr>(&hitSpaceShip);\n(*phm)[\"SpaceStation\"] =\nreinterpret_cast<HitFunctionPtr>(&hitSpaceStation);\n(*phm)[\"Asteroid\"] =\nreinterpret_cast<HitFunctionPtr>(&hitAsteroid);\nreturn phm;\n}\nThis will compile, but it’s a bad idea. It entails doing something you\nshould never do: lying to your compilers. Telling them that hitSpace-\nShip, hitSpaceStation, and hitAsteroid are functions expecting a\nGameObject argument is simply not true. hitSpaceShip expects a\nSpaceShip, hitSpaceStation expects a SpaceStation, and hitAs-\nteroid expects an Asteroid. The casts say otherwise. The casts lie.\nMore than morality is on the line here. Compilers don’t like to be lied\nto, and they often find a way to exact revenge when they discover\nthey’ve been deceived. In this case, they’re likely to get back at you by\ngenerating bad code for functions you call through *phm in cases\nwhere GameObject’s derived classes employ multiple inheritance or\nhave virtual base classes. In other words, if SpaceStation, Space-\nShip, or Asteroid had other base classes (in addition to GameObject),\nyou’d probably find that your calls to collision-processing functions in\ncollide would behave quite rudely. \n\n\n242\nItem 31\nConsider again the A-B-C-D inheritance hierarchy and the possible ob-\nject layout for a D object that is described in Item 24:\nEach of the four class parts in a D object has a different address. This\nis important, because even though pointers and references behave dif-\nferently (see Item 1), compilers typically implement references by using\npointers in the generated code. Thus, pass-by-reference is typically im-\nplemented by passing a pointer to an object. When an object with mul-\ntiple base classes (such as a D object) is passed by reference, it is\ncrucial that compilers pass the correct address — the one correspond-\ning to the declared type of the parameter in the function being called.\nBut what if you’ve lied to your compilers and told them your function\nexpects a GameObject when it really expects a SpaceShip or a\nSpaceStation? Then they’ll pass the wrong address when you call the\nfunction, and the resulting runtime carnage will probably be grue-\nsome. It will also be very difficult to determine the cause of the prob-\nlem. There are good reasons why casting is discouraged. This is one of\nthem.\nOkay, so casting is out. Fine. But the type mismatch between the func-\ntion pointers a HitMap is willing to contain and the pointers to the\nhitSpaceShip, hitSpaceStation, and hitAsteroid functions re-\nmains. There is only one way to resolve the conflict: change the types\nof the functions so they all take GameObject arguments:\nclass GameObject {\n// this is unchanged\npublic:\nvirtual void collide(GameObject& otherObject) = 0;\n...\n};\nB Data Members\nC Data Members\nD Data Members\nA Data Members\nPointer to virtual base class\nPointer to virtual base class\nvptr\nvptr\nB\nD\nC\nA\nvptr\n\n\nImplementing Multiple Dispatch\n243\nclass SpaceShip: public GameObject {\npublic:\nvirtual void collide(GameObject& otherObject);\n// these functions now all take a GameObject parameter\nvirtual void hitSpaceShip(GameObject& spaceShip);\nvirtual void hitSpaceStation(GameObject& spaceStation);\nvirtual void hitAsteroid(GameObject& asteroid);\n...\n};\nOur solution to the double-dispatching problem that was based on vir-\ntual functions overloaded the function name collide. Now we are in a\nposition to understand why we didn’t follow suit here — why we de-\ncided to use an associative array of member function pointers instead.\nAll the hit functions take the same parameter type, so we must give\nthem different names.\nNow we can write initializeCollisionMap the way we always\nwanted to:\nSpaceShip::HitMap * SpaceShip::initializeCollisionMap()\n{\nHitMap *phm = new HitMap;\n(*phm)[\"SpaceShip\"] = &hitSpaceShip;\n(*phm)[\"SpaceStation\"] = &hitSpaceStation;\n(*phm)[\"Asteroid\"] = &hitAsteroid;\nreturn phm;\n}\nRegrettably, our hit functions now get a general GameObject param-\neter instead of the derived class parameters they expect. To bring real-\nity into accord with expectation, we must resort to a dynamic_cast\n(see Item 2) at the top of each function:\nvoid SpaceShip::hitSpaceShip(GameObject& spaceShip)\n{\nSpaceShip& otherShip=\ndynamic_cast<SpaceShip&>(spaceShip);\nprocess a SpaceShip-SpaceShip collision;\n}\nvoid SpaceShip::hitSpaceStation(GameObject& spaceStation)\n{\nSpaceStation& station=\ndynamic_cast<SpaceStation&>(spaceStation);\nprocess a SpaceShip-SpaceStation collision;\n}\n\n\n244\nItem 31\nvoid SpaceShip::hitAsteroid(GameObject& asteroid)\n{\nAsteroid& theAsteroid =\ndynamic_cast<Asteroid&>(asteroid);\nprocess a SpaceShip-Asteroid collision;\n}\nEach of the dynamic_casts will throw a bad_cast exception if the\ncast fails. They should never fail, of course, because the hit functions\nshould never be called with incorrect parameter types. Still, we’re bet-\nter off safe than sorry.\nUsing Non-Member Collision-Processing Functions\nWe now know how to build a vtbl-like associative array that lets us im-\nplement the second half of a double-dispatch, and we know how to en-\ncapsulate the details of the associative array inside a lookup function.\nBecause this array contains pointers to member functions, however,\nwe still have to modify class definitions if a new type of GameObject is\nadded to the game, and that means everybody has to recompile, even\npeople who don’t care about the new type of object. For example, if\nSatellite were added to our game, we’d have to augment the Space-\nShip class with a declaration of a function to handle collisions between\nsatellites and spaceships. All SpaceShip clients would then have to re-\ncompile, even if they couldn’t care less about the existence of satellites.\nThis is the problem that led us to reject the implementation of double-\ndispatching based purely on virtual functions, and that solution was a\nlot less work than the one we’ve just seen.\nThe recompilation problem would go away if our associative array con-\ntained pointers to non-member functions. Furthermore, switching to\nnon-member collision-processing functions would let us address a de-\nsign question we have so far ignored, namely, in which class should\ncollisions between objects of different types be handled? With the im-\nplementation we just developed, if object 1 and object 2 collide and ob-\nject 1 happens to be the left-hand argument to processCollision,\nthe collision will be handled inside the class for object 1. If object 2\nhappens to be the left-hand argument to processCollision, how-\never, the collision will be handled inside the class for object 2. Does\nthis make sense? Wouldn’t it be better to design things so that colli-\nsions between objects of types A and B are handled by neither A nor B\nbut instead in some neutral location outside both classes?\nIf we move the collision-processing functions out of our classes, we can\ngive clients header files that contain class definitions without any hit\nor collide functions. We can then structure our implementation file\nfor processCollision as follows:\n",
      "page_number": 242,
      "chapter_number": 25,
      "summary": "This chapter covers segment 25 (pages 242-261). Key topics include classes, functions, and function. Covers function. That’s because operator[] returns a\nproxy, and there is no operator+= or operator++ for Proxy objects.",
      "keywords": [
        "function",
        "virtual void collide",
        "SpaceShip",
        "GameObject",
        "functions",
        "virtual",
        "virtual function",
        "virtual void",
        "member function",
        "Implementing Multiple Dispatch",
        "Item",
        "object",
        "collide",
        "asteroid",
        "type"
      ],
      "concepts": [
        "classes",
        "functions",
        "function",
        "objects",
        "spaceship",
        "arrays",
        "implement",
        "implementing",
        "implementations",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 3,
          "title": "Segment 3 (pages 17-24)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 14,
          "title": "Segment 14 (pages 116-123)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 11,
          "title": "Segment 11 (pages 113-123)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 30,
          "title": "Segment 30 (pages 317-324)",
          "relevance_score": 0.55,
          "method": "api"
        }
      ]
    },
    {
      "number": 26,
      "title": "Segment 26 (pages 262-270)",
      "start_page": 262,
      "end_page": 270,
      "detection_method": "topic_boundary",
      "content": "Implementing Multiple Dispatch\n245\n#include \"SpaceShip.h\"\n#include \"SpaceStation.h\"\n#include \"Asteroid.h\"\nnamespace {\n// unnamed namespace — see below\n// primary collision-processing functions\nvoid shipAsteroid(GameObject& spaceShip,\nGameObject& asteroid);\nvoid shipStation(GameObject& spaceShip,\nGameObject& spaceStation);\nvoid asteroidStation(GameObject& asteroid,\nGameObject& spaceStation);\n...\n// secondary collision-processing functions that just\n// implement symmetry: swap the parameters and call a\n// primary function\nvoid asteroidShip(GameObject& asteroid,\nGameObject& spaceShip)\n{ shipAsteroid(spaceShip, asteroid); }\nvoid stationShip(GameObject& spaceStation,\nGameObject& spaceShip)\n{ shipStation(spaceShip, spaceStation); }\nvoid stationAsteroid(GameObject& spaceStation,\nGameObject& asteroid)\n{ asteroidStation(asteroid, spaceStation); }\n...\n// see below for a description of these types/functions\ntypedef void (*HitFunctionPtr)(GameObject&, GameObject&);\ntypedef map< pair<string,string>, HitFunctionPtr > HitMap;\npair<string,string> makeStringPair(const char *s1,\nconst char *s2);\nHitMap * initializeCollisionMap();\nHitFunctionPtr lookup(const string& class1,\nconst string& class2);\n} // end namespace\nvoid processCollision(GameObject& object1,\nGameObject& object2)\n{\nHitFunctionPtr phf = lookup(typeid(object1).name(),\ntypeid(object2).name());\nif (phf) phf(object1, object2);\nelse throw UnknownCollision(object1, object2);\n}\n\n\n246\nItem 31\nNote the use of the unnamed namespace to contain the functions used\nto implement processCollision. Everything in such an unnamed\nnamespace is private to the current translation unit (essentially the\ncurrent file) — it’s just like the functions were declared static at file\nscope. With the advent of namespaces, however, statics at file scope\nhave been deprecated, so you should accustom yourself to using un-\nnamed namespaces as soon as your compilers support them.\nConceptually, this implementation is the same as the one that used\nmember functions, but there are some minor differences. First, Hit-\nFunctionPtr is now a typedef for a pointer to a non-member function.\nSecond, the exception class CollisionWithUnknownObject has been\nrenamed UnknownCollision and modified to take two objects instead\nof one. Finally, lookup must now take two type names and perform\nboth parts of the double-dispatch. This means our collision map must\nnow hold three pieces of information: two types names and a HitFunc-\ntionPtr.\nAs fate would have it, the standard map class is defined to hold only\ntwo pieces of information. We can finesse that problem by using the\nstandard pair template, which lets us bundle the two type names to-\ngether as a single object. initializeCollisionMap, along with its\nmakeStringPair helper function, then looks like this:\n// we use this function to create pair<string,string>\n// objects from two char* literals. It’s used in\n// initializeCollisionMap below. Note how this function\n// enables the return value optimization (see Item 20).\nnamespace {\n// unnamed namespace again — see below\npair<string,string> makeStringPair(const char *s1,\nconst char *s2)\n{ return pair<string,string>(s1, s2); }\n} // end namespace\nnamespace {\n// still the unnamed namespace — see below\nHitMap * initializeCollisionMap()\n{\nHitMap *phm = new HitMap;\n(*phm)[makeStringPair(\"SpaceShip\",\"Asteroid\")] =\n&shipAsteroid;\n(*phm)[makeStringPair(\"SpaceShip\", \"SpaceStation\")] =\n&shipStation;\n...\nreturn phm;\n}\n} // end namespace\n\n\nImplementing Multiple Dispatch\n247\nlookup must also be modified to work with the pair<string,\nstring> objects that now comprise the first component of the collision\nmap:\nnamespace {\n// I explain this below — trust me\nHitFunctionPtr lookup(const string& class1,\nconst string& class2)\n{\nstatic auto_ptr<HitMap> \ncollisionMap(initializeCollisionMap());\n// see below for a description of make_pair\nHitMap::iterator mapEntry=\ncollisionMap->find(make_pair(class1, class2));\nif (mapEntry == collisionMap->end()) return 0;\nreturn (*mapEntry).second;\n}\n} // end namespace\nThis is almost exactly what we had before. The only real difference is\nthe use of the make_pair function in this statement:\nHitMap::iterator mapEntry=\ncollisionMap->find(make_pair(class1, class2));\nmake_pair is just a convenience function (template) in the standard li-\nbrary (see Item 35) that saves us the trouble of specifying the types\nwhen constructing a pair object. We could just as well have written\nthe statement like this:\nHitMap::iterator mapEntry=\ncollisionMap->find(pair<string,string>(class1, class2));\nThis calls for more typing, however, and specifying the types for the\npair is redundant (they’re the same as the types of class1 and\nclass2), so the make_pair form is more commonly used.\nBecause makeStringPair, initializeCollisionMap, and lookup\nwere declared inside an unnamed namespace, each must be imple-\nmented within the same namespace. That’s why the implementations\nof the functions above are in the unnamed namespace (for the same\ntranslation unit as their declarations): so the linker will correctly asso-\nciate their definitions (i.e., their implementations) with their earlier\ndeclarations.\nWe have finally achieved our goals. If new subclasses of GameObject\nare added to our hierarchy, existing classes need not recompile (unless\nthey wish to use the new classes). We have no tangle of RTTI-based\nswitch or if-then-else conditionals to maintain. The addition of new\nclasses to the hierarchy requires only well-defined and localized\n\n\n248\nItem 31\nchanges to our system: the addition of one or more map insertions in\ninitializeCollisionMap and the declarations of the new collision-\nprocessing functions in the unnamed namespace associated with the\nimplementation of processCollision. It may have been a lot of work\nto get here, but at least the trip was worthwhile. Yes? Yes?\nMaybe.\nInheritance and Emulated Virtual Function Tables\nThere is one final problem we must confront. (If, at this point, you are\nwondering if there will always be one final problem to confront, you\nhave truly come to appreciate the difficulty of designing an implemen-\ntation mechanism for virtual functions.) Everything we’ve done will\nwork fine as long as we never need to allow inheritance-based type\nconversions when calling collision-processing functions. But suppose\nwe develop a game in which we must sometimes distinguish between\ncommercial space ships and military space ships. We could modify our\nhierarchy as follows, where we’ve heeded the guidance of Item 33 and\nmade the concrete classes CommercialShip and MilitaryShip in-\nherit from the newly abstract class SpaceShip:\nSuppose commercial and military ships behave identically when they\ncollide with something. Then we’d expect to be able to use the same\ncollision-processing functions we had before CommercialShip and\nMilitaryShip were added. In particular, if a MilitaryShip object\nand an Asteroid collided, we’d expect\nvoid shipAsteroid(GameObject& spaceShip,\nGameObject& asteroid);\nto be called. It would not be. Instead, an UnknownCollision exception\nwould be thrown. That’s because lookup would be asked to find a\nfunction corresponding to the type names “MilitaryShip” and “Aster-\noid,” and no such function would be found in collisionMap. Even\nMilitary\nShip\nCommercial\nShip\nSpaceStation\nGameObject\nSpaceShip\nAsteroid\n\n\nImplementing Multiple Dispatch\n249\nthough a MilitaryShip can be treated like a SpaceShip, lookup has\nno way of knowing that.\nFurthermore, there is no easy way of telling it. If you need to imple-\nment double-dispatching and you need to support inheritance-based\nparameter conversions such as these, your only practical recourse is\nto fall back on the double-virtual-function-call mechanism we exam-\nined earlier. That implies you’ll also have to put up with everybody re-\ncompiling when you add to your inheritance hierarchy, but that’s just\nthe way life is sometimes.\nInitializing Emulated Virtual Function Tables (Reprise)\nThat’s really all there is to say about double-dispatching, but it would\nbe unpleasant to end the discussion on such a downbeat note, and un-\npleasantness is, well, unpleasant. Instead, let’s conclude by outlining\nan alternative approach to initializing collisionMap.\nAs things stand now, our design is entirely static. Once we’ve regis-\ntered a function for processing collisions between two types of objects,\nthat’s it; we’re stuck with that function forever. What if we’d like to add,\nremove, or change collision-processing functions as the game pro-\nceeds? There’s no way to do it.\nBut there can be. We can turn the concept of a map for storing colli-\nsion-processing functions into a class that offers member functions al-\nlowing us to modify the contents of the map dynamically. For example:\nclass CollisionMap {\npublic:\ntypedef void (*HitFunctionPtr)(GameObject&, GameObject&);\nvoid addEntry(const string& type1,\nconst string& type2,\nHitFunctionPtr collisionFunction,\nbool symmetric = true);\n// see below\nvoid removeEntry(const string& type1,\nconst string& type2);\nHitFunctionPtr lookup(const string& type1,\nconst string& type2);\n// this function returns a reference to the one and only\n// map — see Item 26\nstatic CollisionMap& theCollisionMap();\nprivate:\n// these functions are private to prevent the creation\n// of multiple maps — see Item 26\nCollisionMap();\nCollisionMap(const CollisionMap&);\n};\n\n\n250\nItem 31\nThis class lets us add entries to the map, remove them from it, and\nlook up the collision-processing function associated with a particular\npair of type names. It also uses the techniques of Item 26 to limit the\nnumber of CollisionMap objects to one, because there is only one\nmap in our system. (More complex games with multiple maps are easy\nto imagine.) Finally, it allows us to simplify the addition of symmetric\ncollisions to the map (i.e., collisions in which the effect of an object of\ntype T1 hitting an object of type T2 is the same as that of an object of\ntype T2 hitting an object of type T1) by automatically adding the im-\nplied map entry when addEntry is called with the optional parameter\nsymmetric set to true.\nWith the CollisionMap class, each client wishing to add an entry to\nthe map does so directly:\nvoid shipAsteroid(GameObject& spaceShip,\nGameObject& asteroid);\nCollisionMap::theCollisionMap().addEntry(\"SpaceShip\",\n\"Asteroid\",\n&shipAsteroid);\nvoid shipStation(GameObject& spaceShip,\nGameObject& spaceStation);\nCollisionMap::theCollisionMap().addEntry(\"SpaceShip\",\n\"SpaceStation\",\n&shipStation);\nvoid asteroidStation(GameObject& asteroid,\nGameObject& spaceStation);\nCollisionMap::theCollisionMap().addEntry(\"Asteroid\",\n\"SpaceStation\",\n&asteroidStation);\n...\nCare must be taken to ensure that these map entries are added to the\nmap before any collisions occur that would call the associated func-\ntions. One way to do this would be to have constructors in GameObject\nsubclasses check to make sure the appropriate mappings had been\nadded each time an object was created. Such an approach would exact\na small performance penalty at runtime. An alternative would be to\ncreate a RegisterCollisionFunction class:\nclass RegisterCollisionFunction {\npublic:\nRegisterCollisionFunction(\nconst string& type1,\nconst string& type2,\nCollisionMap::HitFunctionPtr collisionFunction,\nbool symmetric = true)\n{\nCollisionMap::theCollisionMap().addEntry(type1, type2,\ncollisionFunction,\nsymmetric);\n}\n};\n\n\nImplementing Multiple Dispatch\n251\nClients could then use global objects of this type to automatically reg-\nister the functions they need:\nRegisterCollisionFunction cf1(\"SpaceShip\", \"Asteroid\",\n&shipAsteroid);\nRegisterCollisionFunction cf2(\"SpaceShip\", \"SpaceStation\",\n&shipStation);\nRegisterCollisionFunction cf3(\"Asteroid\", \"SpaceStation\",\n&asteroidStation);\n...\nint main(int argc, char * argv[])\n{\n...\n}\nBecause these objects are created before main is invoked, the func-\ntions their constructors register are also added to the map before main\nis called. If, later, a new derived class is added\nclass Satellite: public GameObject { ... };\nand one or more new collision-processing functions are written,\nvoid satelliteShip(GameObject& satellite, \nGameObject& spaceShip);\nvoid satelliteAsteroid(GameObject& satellite,\nGameObject& asteroid);\nthese new functions can be similarly added to the map without dis-\nturbing existing code:\nRegisterCollisionFunction cf4(\"Satellite\", \"SpaceShip\",\n&satelliteShip);\nRegisterCollisionFunction cf5(\"Satellite\", \"Asteroid\",\n&satelliteAsteroid);\nThis doesn’t change the fact that there’s no perfect way to implement\nmultiple dispatch, but it does make it easy to provide data for a map-\nbased implementation if we decide such an approach is the best match\nfor our needs.\n\n\nMiscellany\nMiscellany\nWe thus arrive at the organizational back of the bus, the chapter con-\ntaining the guidelines no one else would have. We begin with two Items\non C++ software development that describe how to design systems that\naccommodate change. One of the strengths of the object-oriented ap-\nproach to systems building is its support for change, and these Items\ndescribe specific steps you can take to fortify your software against the\nslings and arrows of a world that refuses to stand still.\nWe then examine how to combine C and C++ in the same program.\nThis necessarily leads to consideration of extralinguistic issues, but\nC++ exists in the real world, so sometimes we must confront such\nthings.\nFinally, I summarize changes to the C++ language standard since pub-\nlication of the de facto reference. I especially cover the sweeping\nchanges that have been made in the standard library. If you have not\nbeen following the standardization process closely, you are probably in\nfor some surprises — many of them quite pleasant.\nItem 32: Program in the future tense.\nProgramming in the Future Tense\nThings change.\nAs software developers, we may not know much, but we do know that\nthings will change. We don’t necessarily know what will change, how\nthe changes will be brought about, when the changes will occur, or\nwhy they will take place, but we do know this: things will change.\nGood software adapts well to change. It accommodates new features, it\nports to new platforms, it adjusts to new demands, it handles new in-\nputs. Software this flexible, this robust, and this reliable does not\ncome about by accident. It is designed and implemented by program-\nmers who conform to the constraints of today while keeping in mind\nthe probable needs of tomorrow. This kind of software — software that\n\n\nProgramming in the Future Tense\n253\naccepts change gracefully — is written by people who program in the fu-\nture tense.\nTo program in the future tense is to accept that things will change and\nto be prepared for it. It is to recognize that new functions will be added\nto libraries, that new overloadings will occur, and to watch for the po-\ntentially ambiguous function calls that might result. It is to acknowl-\nedge that new classes will be added to hierarchies, that present-day\nderived classes may be tomorrow’s base classes, and to prepare for\nthat possibility. It is to accept that new applications will be written,\nthat functions will be called in new contexts, and to write those func-\ntions so they continue to perform correctly. It is to remember that the\nprogrammers charged with software maintenance are typically not the\ncode’s original developers, hence to design and implement in a fashion\nthat facilitates comprehension, modification, and enhancement by\nothers.\nOne way to do this is to express design constraints in C++ instead of\n(or in addition to) comments or other documentation. For example, if a\nclass is designed to never have derived classes, don’t just put a com-\nment in the header file above the class, use C++ to prevent derivation;\nItem 26 shows you how. If a class requires that all instances be on the\nheap, don’t just tell clients that, enforce the restriction by applying the\napproach of Item 27. If copying and assignment make no sense for a\nclass, prevent those operations by declaring the copy constructor and\nthe assignment operator private. C++ offers great power, flexibility, and\nexpressiveness. Use these characteristics of the language to enforce\nthe design decisions in your programs.\nGiven that things will change, write classes that can withstand the\nrough-and-tumble world of software evolution. Avoid “demand-paged”\nvirtual functions, whereby you make no functions virtual unless some-\nbody comes along and demands that you do it. Instead, determine the\nmeaning of a function and whether it makes sense to let it be redefined\nin derived classes. If it does, declare it virtual, even if nobody redefines\nit right away. If it doesn’t, declare it nonvirtual, and don’t change it\nlater just because it would be convenient for someone; make sure the\nchange makes sense in the context of the entire class and the abstrac-\ntion it represents.\nHandle assignment and copy construction in every class, even if “no-\nbody ever does those things.” Just because they don’t do them now\ndoesn’t mean they won’t do them in the future. If these functions are\ndifficult to implement, declare them private. That way no one will in-\nadvertently call compiler-generated functions that do the wrong thing\n(as often happens with default assignment operators and copy con-\nstructors). \n",
      "page_number": 262,
      "chapter_number": 26,
      "summary": "This chapter covers segment 26 (pages 262-270). Key topics include classes, function. Covers function. Everything in such an unnamed\nnamespace is private to the current translation unit (essentially the\ncurrent file) — it’s just like the functions were declared static at file\nscope.",
      "keywords": [
        "GameObject",
        "functions",
        "const string",
        "function",
        "asteroid",
        "void",
        "spaceShip",
        "const",
        "namespace",
        "map",
        "Item",
        "collisionMap",
        "pair",
        "Implementing Multiple Dispatch",
        "unnamed namespace"
      ],
      "concepts": [
        "classes",
        "function",
        "map",
        "maps",
        "mappings",
        "changes",
        "object",
        "item",
        "spaceship",
        "collisions"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 3,
          "title": "Segment 3 (pages 17-24)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 4,
          "title": "Segment 4 (pages 36-45)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 7,
          "title": "Segment 7 (pages 53-62)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 14,
          "title": "Segment 14 (pages 116-123)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 8,
          "title": "Segment 8 (pages 142-159)",
          "relevance_score": 0.58,
          "method": "api"
        }
      ]
    },
    {
      "number": 27,
      "title": "Segment 27 (pages 271-284)",
      "start_page": 271,
      "end_page": 284,
      "detection_method": "topic_boundary",
      "content": "254\nItem 32\nAdhere to the principle of least astonishment: strive to provide classes\nwhose operators and functions have a natural syntax and an intuitive\nsemantics. Preserve consistency with the behavior of the built-in\ntypes: when in doubt, do as the ints do.\nRecognize that anything somebody can do, they will do. They’ll throw\nexceptions, they’ll assign objects to themselves, they’ll use objects be-\nfore giving them values, they’ll give objects values and never use them,\nthey’ll give them huge values, they’ll give them tiny values, they’ll give\nthem null values. In general, if it will compile, somebody will do it. As\na result, make your classes easy to use correctly and hard to use in-\ncorrectly. Accept that clients will make mistakes, and design your\nclasses so you can prevent, detect, or correct such errors (see, for ex-\nample, Item 33). \nStrive for portable code. It’s not much harder to write portable pro-\ngrams than to write unportable ones, and only rarely will the difference\nin performance be significant enough to justify unportable constructs\n(see Item 16). Even programs designed for custom hardware often end\nup being ported, because stock hardware generally achieves an equiv-\nalent level of performance within a few years. Writing portable code al-\nlows you to switch platforms easily, to enlarge your client base, and to\nbrag about supporting open systems. It also makes it easier to recover\nif you bet wrong in the operating system sweepstakes.\nDesign your code so that when changes are necessary, the impact is\nlocalized. Encapsulate as much as you can; make implementation de-\ntails private. Where applicable, use unnamed namespaces or file-\nstatic objects and functions (see Item 31). Try to avoid designs that\nlead to virtual base classes, because such classes must be initialized\nby every class derived from them — even those derived indirectly (see\nItem 4). Avoid RTTI-based designs that make use of cascading if-\nthen-else statements (see Item 31 again). Every time the class hierar-\nchy changes, each set of statements must be updated, and if you forget\none, you’ll receive no warning from your compilers.\nThese are well known and oft-repeated exhortations, but most pro-\ngrammers are still stuck in the present tense. As are many authors,\nunfortunately. Consider this advice by a well-regarded C++ expert:\nYou need a virtual destructor whenever someone deletes a B*\nthat actually points to a D.\nHere B is a base class and D is a derived class. In other words, this au-\nthor suggests that if your program looks like this, you don’t need a vir-\ntual destructor in B:\n\n\nProgramming in the Future Tense\n255\nclass B { ... };\n// no virtual dtor needed\nclass D: public B { ... };\nB *pb = new D;\nHowever, the situation changes if you add this statement:\ndelete pb;\n// NOW you need the virtual\n// destructor in B\nThe implication is that a minor change to client code — the addition of\na delete statement — can result in the need to change the class defi-\nnition for B. When that happens, all B’s clients must recompile. Follow-\ning this author’s advice, then, the addition of a single statement in one\nfunction can lead to extensive code recompilation and relinking for all\nclients of a library. This is anything but effective software design.\nOn the same topic, a different author writes:\nIf a public base class does not have a virtual destructor, no de-\nrived class nor members of a derived class should have a de-\nstructor.\nIn other words, this is okay,\nclass string {\n// from the standard C++ library\npublic:\n~string();\n};\nclass B { ... };\n// no data members with dtors,\n// no virtual dtor needed\nbut if a new class is derived from B, things change:\nclass D: public B {\nstring name;\n// NOW ~B needs to be virtual\n};\nAgain, a small change to the way B is used (here, the addition of a de-\nrived class that contains a member with a destructor) may necessitate\nextensive recompilation and relinking by clients. But small changes in\nsoftware should have small impacts on systems. This design fails that\ntest.\nThe same author writes:\nIf a multiple inheritance hierarchy has any destructors, every\nbase class should have a virtual destructor.\nIn all these quotations, note the present-tense thinking. How do clients\nmanipulate pointers now? What class members have destructors now?\nWhat classes in the hierarchy have destructors now?\n\n\n256\nItem 32\nFuture-tense thinking is quite different. Instead of asking how a class\nis used now, it asks how the class is designed to be used. Future-tense\nthinking says, if a class is designed to be used as a base class (even if\nit’s not used as one now), it should have a virtual destructor. Such\nclasses behave correctly both now and in the future, and they don’t af-\nfect other library clients when new classes derive from them. (At least,\nthey have no effect as far as their destructor is concerned. If additional\nchanges to the class are required, other clients may be affected.)\nA commercial class library (one that predates the string specification\nin the C++ library standard) contains a string class with no virtual de-\nstructor. The vendor’s explanation?\nWe didn’t make the destructor virtual, because we didn’t want\nString to have a vtbl. We have no intention of ever having a\nString*, so this is not a problem. We are well aware of the dif-\nficulties this could cause.\nIs this present-tense or future-tense thinking?\nCertainly the vtbl issue is a legitimate technical concern (see Item 24).\nThe implementation of most String classes contains only a single\nchar* pointer inside each String object, so adding a vptr to each\nString would double the size of those objects. It is easy to understand\nwhy a vendor would be unwilling to do that, especially for a highly vis-\nible, heavily used class like String. The performance of such a class\nmight easily fall within the 20% of a program that makes a difference\n(see Item 16).\nStill, the total memory devoted to a string object — the memory for the\nobject itself plus the heap memory needed to hold the string’s value —\nis typically much greater than just the space needed to hold a char*\npointer. From this perspective, the overhead imposed by a vptr is less\nsignificant. Nevertheless, it is a legitimate technical consideration.\n(Certainly the ISO/ANSI standardization committee seems to think so:\nthe standard string type has a nonvirtual destructor.)\nSomewhat more troubling is the vendor’s remark, “We have no inten-\ntion of ever having a String*, so this is not a problem.” That may be\ntrue, but their String class is part of a library they make available to\nthousands of developers. That’s a lot of developers, each with a differ-\nent level of experience with C++, each doing something unique. Do\nthose developers understand the consequences of there being no vir-\ntual destructor in String? Are they likely to know that because\nString has no virtual destructor, deriving new classes from String is\na high-risk venture? Is this vendor confident their clients will under-\nstand that in the absence of a virtual destructor, deleting objects\nthrough String* pointers will not work properly and RTTI operations\n\n\nProgramming in the Future Tense\n257\non pointers and references to Strings may return incorrect informa-\ntion? Is this class easy to use correctly and hard to use incorrectly?\nThis vendor should provide documentation for its String class that\nmakes clear the class is not designed for derivation, but what if pro-\ngrammers overlook the caveat or flat-out fail to read the documenta-\ntion?\nAn alternative would be to use C++ itself to prohibit derivation. Item 26\ndescribes how to do this by limiting object creation to the heap and\nthen using auto_ptr objects to manipulate the heap objects. The in-\nterface for String creation would then be both unconventional and in-\nconvenient, requiring this,\nauto_ptr<String> ps(String::makeString(\"Future tense C++\"));\n...\n// treat ps as a pointer to\n// a String object, but don’t\n// worry about deleting it\ninstead of this,\nString s(\"Future tense C++\");\nbut perhaps the reduction in the risk of improperly behaving derived\nclasses would be worth the syntactic inconvenience. (For String, this\nis unlikely to be the case, but for other classes, the trade-off might well\nbe worth it.)\nThere is a need, of course, for present-tense thinking. The software\nyou’re developing has to work with current compilers; you can’t afford\nto wait until the latest language features are implemented. It has to\nrun on the hardware you currently support and it must do so under\nconfigurations your clients have available; you can’t force your cus-\ntomers to upgrade their systems or modify their operating environ-\nment. It has to offer acceptable performance now; promises of smaller,\nfaster programs some years down the line don’t generally warm the\ncockles of potential customers’ hearts. And the software you’re work-\ning on must be available “soon,” which often means some time in the\nrecent past. These are important constraints. You cannot ignore them.\nFuture-tense thinking simply adds a few additional considerations: \n■Provide complete classes, even if some parts aren’t currently used.\nWhen new demands are made on your classes, you’re less likely to\nhave to go back and modify them. \n\n\n258\nItem 33\n■Design your interfaces to facilitate common operations and pre-\nvent common errors. Make the classes easy to use correctly, hard\nto use incorrectly. For example, prohibit copying and assignment\nfor classes where those operations make no sense. Prevent partial\nassignments (see Item 33).\n■If there is no great penalty for generalizing your code, generalize it.\nFor example, if you are writing an algorithm for tree traversal, con-\nsider generalizing it to handle any kind of directed acyclic graph.\nFuture tense thinking increases the reusability of the code you write,\nenhances its maintainability, makes it more robust, and facilitates\ngraceful change in an environment where change is a certainty. It\nmust be balanced against present-tense constraints. Too many pro-\ngrammers focus exclusively on current needs, however, and in doing\nso they sacrifice the long-term viability of the software they design and\nimplement. Be different. Be a renegade. Program in the future tense.\nItem 33: Make non-leaf classes abstract.\nMaking Non-Leaf Classes Abstract\nSuppose you’re working on a project whose software deals with ani-\nmals. Within this software, most animals can be treated pretty much\nthe same, but two kinds of animals — lizards and chickens — require\nspecial handling. That being the case, the obvious way to relate the\nclasses for animals, lizards, and chickens is like this:\nThe Animal class embodies the features shared by all the creatures\nyou deal with, and the Lizard and Chicken classes specialize Animal\nin ways appropriate for lizards and chickens, respectively.\nHere’s a sketch of the definitions for these classes:\nclass Animal {\npublic:\nAnimal& operator=(const Animal& rhs);\n...\n};\nAnimal\nLizard\nChicken\n\n\nMaking Non-Leaf Classes Abstract\n259\nclass Lizard: public Animal {\npublic:\nLizard& operator=(const Lizard& rhs);\n...\n};\nclass Chicken: public Animal {\npublic:\nChicken& operator=(const Chicken& rhs);\n...\n};\nOnly the assignment operators are shown here, but that’s more than\nenough to keep us busy for a while. Consider this code:\nLizard liz1;\nLizard liz2;\nAnimal *pAnimal1 = &liz1;\nAnimal *pAnimal2 = &liz2;\n...\n*pAnimal1 = *pAnimal2;\nThere are two problems here. First, the assignment operator invoked\non the last line is that of the Animal class, even though the objects in-\nvolved are of type Lizard. As a result, only the Animal part of liz1\nwill be modified. This is a partial assignment. After the assignment,\nliz1’s Animal members have the values they got from liz2, but\nliz1’s Lizard members remain unchanged.\nThe second problem is that real programmers write code like this. It’s\nnot uncommon to make assignments to objects through pointers, es-\npecially for experienced C programmers who have moved to C++. That\nbeing the case, we’d like to make the assignment behave in a more rea-\nsonable fashion. As Item 32 points out, our classes should be easy to\nuse correctly and difficult to use incorrectly, and the classes in the hi-\nerarchy above are easy to use incorrectly.\nOne approach to the problem is to make the assignment operators vir-\ntual. If Animal::operator= were virtual, the assignment would invoke\nthe Lizard assignment operator, which is certainly the correct one to\ncall. However, look what happens if we declare the assignment opera-\ntors virtual:\nclass Animal {\npublic:\nvirtual Animal& operator=(const Animal& rhs);\n...\n};\n\n\n260\nItem 33\nclass Lizard: public Animal {\npublic:\nvirtual Lizard& operator=(const Animal& rhs);\n...\n};\nclass Chicken: public Animal {\npublic:\nvirtual Chicken& operator=(const Animal& rhs);\n...\n};\nDue to relatively recent changes to the language, we can customize the\nreturn value of the assignment operators so that each returns a refer-\nence to the correct class, but the rules of C++ force us to declare iden-\ntical parameter types for a virtual function in every class in which it is\ndeclared. That means the assignment operator for the Lizard and\nChicken classes must be prepared to accept any kind of Animal object\non the right-hand side of an assignment. That, in turn, means we have\nto confront the fact that code like the following is legal:\nLizard liz;\nChicken chick;\nAnimal *pAnimal1 = &liz;\nAnimal *pAnimal2 = &chick;\n...\n*pAnimal1 = *pAnimal2;\n// assign a chicken to\n// a lizard!\nThis is a mixed-type assignment: a Lizard is on the left and a Chicken\nis on the right. Mixed-type assignments aren’t usually a problem in\nC++, because the language’s strong typing generally renders them ille-\ngal. By making Animal’s assignment operator virtual, however, we\nopened the door to such mixed-type operations.\nThis puts us in a difficult position. We’d like to allow same-type assign-\nments through pointers, but we’d like to forbid mixed-type assign-\nments through those same pointers. In other words, we want to allow\nthis,\nAnimal *pAnimal1 = &liz1;\nAnimal *pAnimal2 = &liz2;\n...\n*pAnimal1 = *pAnimal2;\n// assign a lizard to a lizard\n\n\nMaking Non-Leaf Classes Abstract\n261\nbut we want to prohibit this:\nAnimal *pAnimal1 = &liz;\nAnimal *pAnimal2 = &chick;\n...\n*pAnimal1 = *pAnimal2;\n// assign a chicken to a lizard\nDistinctions such as these can be made only at runtime, because\nsometimes assigning *pAnimal2 to *pAnimal1 is valid, sometimes it’s\nnot. We thus enter the murky world of type-based runtime errors. In\nparticular, we need to signal an error inside operator= if we’re faced\nwith a mixed-type assignment, but if the types are the same, we want\nto perform the assignment in the usual fashion. \nWe can use a dynamic_cast (see Item 2) to implement this behavior.\nHere’s how to do it for Lizard’s assignment operator:\nLizard& Lizard::operator=(const Animal& rhs)\n{\n// make sure rhs is really a lizard\nconst Lizard& rhs_liz = dynamic_cast<const Lizard&>(rhs);\nproceed with a normal assignment of rhs_liz to *this;\n}\nThis function assigns rhs to *this only if rhs is really a Lizard. If it’s\nnot, the function propagates the bad_cast exception that\ndynamic_cast throws when the cast to a reference fails. (Actually, the\ntype of the exception is std::bad_cast, because the components of the\nstandard library, including the exceptions thrown by the standard\ncomponents, are in the namespace std. For an overview of the stan-\ndard library, see Item 35.)\nEven without worrying about exceptions, this function seems need-\nlessly complicated and expensive — the dynamic_cast must consult a\ntype_info structure; see Item 24 — in the common case where one\nLizard object is assigned to another:\nLizard liz1, liz2;\n...\nliz1 = liz2;\n// no need to perform a\n// dynamic_cast: this\n// assignment must be valid\nWe can handle this case without paying for the complexity or cost of a\ndynamic_cast by adding to Lizard the conventional assignment op-\nerator:\n\n\n262\nItem 33\nclass Lizard: public Animal {\npublic:\nvirtual Lizard& operator=(const Animal& rhs);\nLizard& operator=(const Lizard& rhs);\n// add this\n...\n};\nLizard liz1, liz2;\n...\nliz1 = liz2;\n// calls operator= taking\n// a const Lizard&\nAnimal *pAnimal1 = &liz1;\nAnimal *pAnimal2 = &liz2;\n...\n*pAnimal1 = *pAnimal2;\n// calls operator= taking\n// a const Animal&\nIn fact, given this latter operator=, it’s simplicity itself to implement\nthe former one in terms of it:\nLizard& Lizard::operator=(const Animal& rhs)\n{\nreturn operator=(dynamic_cast<const Lizard&>(rhs));\n}\nThis function attempts to cast rhs to be a Lizard. If the cast succeeds,\nthe normal class assignment operator is called. Otherwise, a bad_cast\nexception is thrown.\nFrankly, all this business of checking types at runtime and using\ndynamic_casts makes me nervous. For one thing, some compilers\nstill lack support for dynamic_cast, so code that uses it, though the-\noretically portable, is not necessarily portable in practice. More impor-\ntantly, it requires that clients of Lizard and Chicken be prepared to\ncatch bad_cast exceptions and do something sensible with them each\ntime they perform an assignment. In my experience, there just aren’t\nthat many programmers who are willing to program that way. If they\ndon’t, it’s not clear we’ve gained a whole lot over our original situation\nwhere we were trying to guard against partial assignments.\nGiven this rather unsatisfactory state of affairs regarding virtual as-\nsignment operators, it makes sense to regroup and try to find a way to\nprevent clients from making problematic assignments in the first\nplace. If such assignments are rejected during compilation, we don’t\nhave to worry about them doing the wrong thing.\n\n\nMaking Non-Leaf Classes Abstract\n263\nThe easiest way to prevent such assignments is to make operator=\nprivate in Animal. That way, lizards can be assigned to lizards and\nchickens can be assigned to chickens, but partial and mixed-type as-\nsignments are forbidden:\nclass Animal {\nprivate:\nAnimal& operator=(const Animal& rhs);\n// this is now\n...\n// private\n};\nclass Lizard: public Animal {\npublic:\nLizard& operator=(const Lizard& rhs);\n...\n};\nclass Chicken: public Animal {\npublic:\nChicken& operator=(const Chicken& rhs);\n...\n};\nLizard liz1, liz2;\n...\nliz1 = liz2;\n// fine\nChicken chick1, chick2;\n...\nchick1 = chick2;\n// also fine\nAnimal *pAnimal1 = &liz1;\nAnimal *pAnimal2 = &chick1;\n...\n*pAnimal1 = *pAnimal2;\n// error! attempt to call\n// private Animal::operator=\nUnfortunately, Animal is a concrete class, and this approach also\nmakes assignments between Animal objects illegal:\nAnimal animal1, animal2;\n...\nanimal1 = animal2;\n// error! attempt to call\n// private Animal::operator=\nMoreover, it makes it impossible to implement the Lizard and\nChicken assignment operators correctly, because assignment opera-\ntors in derived classes are responsible for calling assignment operators\nin their base classes:\n\n\n264\nItem 33\nLizard& Lizard::operator=(const Lizard& rhs)\n{\nif (this == &rhs) return *this;\nAnimal::operator=(rhs);\n// error! attempt to call \n// private function. But\n// Lizard::operator= must\n// call this function to\n...\n// assign the Animal parts\n}\n// of *this!\nWe can solve this latter problem by declaring Animal::operator= pro-\ntected, but the conundrum of allowing assignments between Animal\nobjects while preventing partial assignments of Lizard and Chicken\nobjects through Animal pointers remains. What’s a poor programmer\nto do?\nThe easiest thing is to eliminate the need to allow assignments be-\ntween Animal objects, and the easiest way to do that is to make Ani-\nmal an abstract class. As an abstract class, Animal can’t be\ninstantiated, so there will be no need to allow assignments between\nAnimals. Of course, this leads to a new problem, because our original\ndesign for this system presupposed that Animal objects were neces-\nsary. There is an easy way around this difficulty. Instead of making\nAnimal itself abstract, we create a new class — AbstractAnimal, say\n— consisting of the common features of Animal, Lizard, and Chicken\nobjects, and we make that class abstract. Then we have each of our\nconcrete classes inherit from AbstractAnimal. The revised hierarchy\nlooks like this,\nand the class definitions are as follows:\nclass AbstractAnimal {\nprotected:\nAbstractAnimal& operator=(const AbstractAnimal& rhs);\npublic:\nvirtual ~AbstractAnimal() = 0;\n// see below\n...\n};\nAbstractAnimal\nLizard\nAnimal\nChicken\n\n\nMaking Non-Leaf Classes Abstract\n265\nclass Animal: public AbstractAnimal {\npublic:\nAnimal& operator=(const Animal& rhs);\n...\n};\nclass Lizard: public AbstractAnimal {\npublic:\nLizard& operator=(const Lizard& rhs);\n...\n};\nclass Chicken: public AbstractAnimal {\npublic:\nChicken& operator=(const Chicken& rhs);\n...\n};\nThis design gives you everything you need. Homogeneous assignments\nare allowed for lizards, chickens, and animals; partial assignments\nand heterogeneous assignments are prohibited; and derived class as-\nsignment operators may call the assignment operator in the base\nclass. Furthermore, none of the code written in terms of the Animal,\nLizard, or Chicken classes requires modification, because these\nclasses continue to exist and to behave as they did before Abstract-\nAnimal was introduced. Sure, such code has to be recompiled, but\nthat’s a small price to pay for the security of knowing that assignments\nthat compile will behave intuitively and assignments that would be-\nhave unintuitively won’t compile.\nFor all this to work, AbstractAnimal must be abstract — it must con-\ntain at least one pure virtual function. In most cases, coming up with\na suitable function is not a problem, but on rare occasions you may\nfind yourself facing the need to create a class like AbstractAnimal in\nwhich none of the member functions would naturally be declared pure\nvirtual. In such cases, the conventional technique is to make the de-\nstructor a pure virtual function; that’s what’s shown above. In order to\nsupport polymorphism through pointers correctly, base classes need\nvirtual destructors anyway, so the only cost associated with making\nsuch destructors pure virtual is the inconvenience of having to imple-\nment them outside their class definitions. (For an example, see page\n195.)\n(If the notion of implementing a pure virtual function strikes you as\nodd, you just haven’t been getting out enough. Declaring a function\npure virtual doesn’t mean it has no implementation, it means \n■the current class is abstract, and \n■any concrete class inheriting from the current class must declare\nthe function as a “normal” virtual function (i.e., without the “=0”).\n\n\n266\nItem 33\nTrue, most pure virtual functions are never implemented, but pure vir-\ntual destructors are a special case. They must be implemented, be-\ncause they are called whenever a derived class destructor is invoked.\nFurthermore, they often perform useful tasks, such as releasing re-\nsources (see Item 9) or logging messages. Implementing pure virtual\nfunctions may be uncommon in general, but for pure virtual destruc-\ntors, it’s not just common, it’s mandatory.)\nYou may have noticed that this discussion of assignment through base\nclass pointers is based on the assumption that concrete derived\nclasses like Lizard contain data members. If there are no data mem-\nbers in a derived class, you might point out, there is no problem, and\nit would be safe to have a dataless concrete class inherit from another\nconcrete class. However, just because a class has no data now is no\nreason to conclude that it will have no data in the future. If it might\nhave data members in the future, all you’re doing is postponing the\nproblem until the data members are added, in which case you’re\nmerely trading short-term convenience for long-term grief (see also\nItem 32). \nReplacement of a concrete base class like Animal with an abstract\nbase class like AbstractAnimal yields benefits far beyond simply\nmaking the behavior of operator= easier to understand. It also re-\nduces the chances that you’ll try to treat arrays polymorphically, the\nunpleasant consequences of which are examined in Item 3. The most\nsignificant benefit of the technique, however, occurs at the design level,\nbecause replacing concrete base classes with abstract base classes\nforces you to explicitly recognize the existence of useful abstractions.\nThat is, it makes you create new abstract classes for useful concepts,\neven if you aren’t aware of the fact that the useful concepts exist.\nIf you have two concrete classes C1 and C2 and you’d like C2 to pub-\nlicly inherit from C1, you should transform that two-class hierarchy\ninto a three-class hierarchy by creating a new abstract class A and\nhaving both C1 and C2 publicly inherit from it:\nA\nC2\nC1\nC2\nYour initial idea\nYour transformed hierarchy\nC1\n\n\nMaking Non-Leaf Classes Abstract\n267\nThe primary value of this transformation is that it forces you to identify\nthe abstract class A. Clearly, C1 and C2 have something in common;\nthat’s why they’re related by public inheritance. With this transforma-\ntion, you must identify what that something is. Furthermore, you must\nformalize the something as a class in C++, at which point it becomes\nmore than just a vague something, it achieves the status of a formal\nabstraction, one with well-defined member functions and well-defined\nsemantics.\nAll of which leads to some worrisome thinking. After all, every class\nrepresents some kind of abstraction, so shouldn’t we create two\nclasses for every concept in our hierarchy, one being abstract (to em-\nbody the abstract part of the abstraction) and one being concrete (to\nembody the object-generation part of the abstraction)? No. If you do,\nyou’ll end up with a hierarchy with too many classes. Such a hierarchy\nis difficult to understand, hard to maintain, and expensive to compile.\nThat is not the goal of object-oriented design.\nThe goal is to identify useful abstractions and to force them — and only\nthem — into existence as abstract classes. But how do you identify\nuseful abstractions? Who knows what abstractions might prove useful\nin the future? Who can predict who’s going to want to inherit from\nwhat?\nWell, I don’t know how to predict the future uses of an inheritance hi-\nerarchy, but I do know one thing: the need for an abstraction in one\ncontext may be coincidental, but the need for an abstraction in more\nthan one context is usually meaningful. Useful abstractions, then, are\nthose that are needed in more than one context. That is, they corre-\nspond to classes that are useful in their own right (i.e., it is useful to\nhave objects of that type) and that are also useful for purposes of one\nor more derived classes. \nThis is precisely why the transformation from concrete base class to\nabstract base class is useful: it forces the introduction of a new ab-\nstract class only when an existing concrete class is about to be used as\na base class, i.e., when the class is about to be (re)used in a new con-\ntext. Such abstractions are useful, because they have, through demon-\nstrated need, shown themselves to be so. \nThe first time a concept is needed, we can’t justify the creation of both\nan abstract class (for the concept) and a concrete class (for the objects\ncorresponding to that concept), but the second time that concept is\nneeded, we can justify the creation of both the abstract and the con-\ncrete classes. The transformation I’ve described simply mechanizes\nthis process, and in so doing it forces designers and programmers to\nrepresent explicitly those abstractions that are useful, even if the de-\n",
      "page_number": 271,
      "chapter_number": 27,
      "summary": "This chapter covers segment 27 (pages 271-284). Key topics include classes, operators, and operating. As\na result, make your classes easy to use correctly and hard to use in-\ncorrectly.",
      "keywords": [
        "Animal",
        "Lizard",
        "classes",
        "const Animal",
        "class Lizard",
        "const Lizard",
        "string",
        "Item",
        "public Animal",
        "class Animal",
        "operator",
        "Chicken",
        "virtual",
        "assignment",
        "abstract"
      ],
      "concepts": [
        "classes",
        "operators",
        "operating",
        "operations",
        "make",
        "making",
        "assignment",
        "assignments",
        "animals",
        "lizards"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 4,
          "title": "Segment 4 (pages 36-45)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 49,
          "title": "Segment 49 (pages 993-1010)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 22,
          "title": "Segment 22 (pages 184-191)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 31,
          "title": "Segment 31 (pages 325-333)",
          "relevance_score": 0.49,
          "method": "api"
        }
      ]
    },
    {
      "number": 28,
      "title": "Segment 28 (pages 285-292)",
      "start_page": 285,
      "end_page": 292,
      "detection_method": "topic_boundary",
      "content": "268\nItem 33\nsigners and programmers are not consciously aware of the useful con-\ncepts. It also happens to make it a lot easier to bring sanity to the\nbehavior of assignment operators.\nLet’s consider a brief example. Suppose you’re working on an applica-\ntion that deals with moving information between computers on a net-\nwork by breaking it into packets and transmitting them according to\nsome protocol. All we’ll consider here is the class or classes for repre-\nsenting packets. We’ll assume such classes make sense for this appli-\ncation. \nSuppose you deal with only a single kind of transfer protocol and only\na single kind of packet. Perhaps you’ve heard that other protocols and\npacket types exist, but you’ve never supported them, nor do you have\nany plans to support them in the future. Should you make an abstract\nclass for packets (for the concept that a packet represents) as well as a\nconcrete class for the packets you’ll actually be using? If you do, you\ncould hope to add new packet types later without changing the base\nclass for packets. That would save you from having to recompile\npacket-using applications if you add new packet types. But that design\nrequires two classes, and right now you need only one (for the particu-\nlar type of packets you use). Is it worth complicating your design now\nto allow for future extension that may never take place?\nThere is no unequivocally correct choice to be made here, but experi-\nence has shown it is nearly impossible to design good classes for con-\ncepts we do not understand well. If you create an abstract class for\npackets, how likely are you to get it right, especially since your experi-\nence is limited to only a single packet type? Remember that you gain\nthe benefit of an abstract class for packets only if you can design that\nclass so that future classes can inherit from it without its being\nchanged in any way. (If it needs to be changed, you have to recompile\nall packet clients, and you’ve gained nothing.)\nIt is unlikely you could design a satisfactory abstract packet class un-\nless you were well versed in many different kinds of packets and in the\nvaried contexts in which they are used. Given your limited experience\nin this case, my advice would be not to define an abstract class for\npackets, adding one later only if you find a need to inherit from the\nconcrete packet class.\nThe transformation I’ve described here is a way to identify the need for\nabstract classes, not the way. There are many other ways to identify\ngood candidates for abstract classes; books on object-oriented analysis\nare filled with them. It’s not the case that the only time you should in-\ntroduce abstract classes is when you find yourself wanting to have a\nconcrete class inherit from another concrete class. However, the desire\n\n\nMaking Non-Leaf Classes Abstract\n269\nto relate two concrete classes by public inheritance is usually indica-\ntive of a need for a new abstract class.\nAs is often the case in such matters, brash reality sometimes intrudes\non the peaceful ruminations of theory. Third-party C++ class libraries\nare proliferating with gusto, and what are you to do if you find yourself\nwanting to create a concrete class that inherits from a concrete class\nin a library to which you have only read access?\nYou can’t modify the library to insert a new abstract class, so your\nchoices are both limited and unappealing:\n■Derive your concrete class from the existing concrete class, and\nput up with the assignment-related problems we examined at the\nbeginning of this Item. You’ll also have to watch out for the array-\nrelated pitfalls described in Item 3.\n■Try to find an abstract class higher in the library hierarchy that\ndoes most of what you need, then inherit from that class. Of\ncourse, there may not be a suitable class, and even if there is, you\nmay have to duplicate a lot of effort that has already been put into\nthe implementation of the concrete class whose functionality you’d\nlike to extend.\n■Implement your new class in terms of the library class you’d like\nto inherit from. For example, you could have an object of the li-\nbrary class as a data member, then reimplement the library class’s\ninterface in your new class:\nclass Window {\n// this is the library class\npublic:\nvirtual void resize(int newWidth, int newHeight);\nvirtual void repaint() const;\nint width() const;\nint height() const;\n};\nclass SpecialWindow {\n// this is the class you\npublic:\n// wanted to have inherit\n...\n// from Window\n// pass-through implementations of nonvirtual functions\nint width() const { return w.width(); }\nint height() const { return w.height(); }\n// new implementations of \"inherited\" virtual functions\nvirtual void resize(int newWidth, int newHeight);\nvirtual void repaint() const;\nprivate:\nWindow w;\n};\n\n\n270\nItem 34\nThis strategy requires that you be prepared to update your class\neach time the library vendor updates the class on which you’re de-\npendent. It also requires that you be willing to forgo the ability to\nredefine virtual functions declared in the library class, because\nyou can’t redefine virtual functions unless you inherit them.\n■Make do with what you’ve got. Use the concrete class that’s in the\nlibrary and modify your software so that the class suffices. Write\nnon-member functions to provide the functionality you’d like to\nadd to the class, but can’t. The resulting software may not be as\nclear, as efficient, as maintainable, or as extensible as you’d like,\nbut at least it will get the job done.\nNone of these choices is particularly attractive, so you have to apply\nsome engineering judgment and choose the poison you find least un-\nappealing. It’s not much fun, but life’s like that sometimes. To make\nthings easier for yourself (and the rest of us) in the future, complain to\nthe vendors of libraries whose designs you find wanting. With luck\n(and a lot of comments from clients), those designs will improve as time\ngoes on.\nStill, the general rule remains: non-leaf classes should be abstract.\nYou may need to bend the rule when working with outside libraries,\nbut in code over which you have control, adherence to it will yield div-\nidends in the form of increased reliability, robustness, comprehensibil-\nity, and extensibility throughout your software.\nItem 34: Understand how to combine C++ and C in the \nsame program.\nCombining C++ and C in the Same Program\nIn many ways, the things you have to worry about when making a pro-\ngram out of some components in C++ and some in C are the same as\nthose you have to worry about when cobbling together a C program out\nof object files produced by more than one C compiler. There is no way\nto combine such files unless the different compilers agree on imple-\nmentation-dependent features like the size of ints and doubles, the\nmechanism by which parameters are passed from caller to callee, and\nwhether the caller or the callee orchestrates the passing. These prag-\nmatic aspects of mixed-compiler software development are quite prop-\nerly ignored by language standardization efforts, so the only reliable\nway to know that object files from compiler A and compiler B can be\nsafely combined in a program is to obtain assurances from the vendors\nof A and B that their products produce compatible output. This is as\ntrue for programs made up of C++ and C as it is for all-C++ or all-C\nprograms, so before you try to mix C++ and C in the same program,\nmake sure your C++ and C compilers generate compatible object files.\n\n\nCombining C++ and C in the Same Program\n271\nHaving done that, there are four other things you need to consider:\nname mangling, initialization of statics, dynamic memory allocation,\nand data structure compatibility.\nName Mangling\nName mangling, as you may know, is the process through which your\nC++ compilers give each function in your program a unique name. In\nC, this process is unnecessary, because you can’t overload function\nnames, but nearly all C++ programs have at least a few functions with\nthe same name. (Consider, for example, the iostream library, which de-\nclares several versions of operator<< and operator>>.) Overloading\nis incompatible with most linkers, because linkers generally take a dim\nview of multiple functions with the same name. Name mangling is a\nconcession to the realities of linkers; in particular, to the fact that link-\ners usually insist on all function names being unique.\nAs long as you stay within the confines of C++, name mangling is not\nlikely to concern you. If you have a function name drawLine that a\ncompiler mangles into xyzzy, you’ll always use the name drawLine,\nand you’ll have little reason to care that the underlying object files\nhappen to refer to xyzzy.\nIt’s a different story if drawLine is in a C library. In that case, your C++\nsource file probably includes a header file that contains a declaration\nlike this,\nvoid drawLine(int x1, int y1, int x2, int y2);\nand your code contains calls to drawLine in the usual fashion. Each\nsuch call is translated by your compilers into a call to the mangled\nname of that function, so when you write this,\ndrawLine(a, b, c, d);\n// call to unmangled function name\nyour object files contain a function call that corresponds to this:\nxyzzy(a, b, c, d);\n// call to mangled function mame\nBut if drawLine is a C function, the object file (or archive or dynami-\ncally linked library, etc.) that contains the compiled version of draw-\nLine contains a function called drawLine; no name mangling has\ntaken place. When you try to link the object files comprising your pro-\ngram together, you’ll get an error, because the linker is looking for a\nfunction called xyzzy, and there is no such function.\nTo solve this problem, you need a way to tell your C++ compilers not to\nmangle certain function names. You never want to mangle the names\nof functions written in other languages, whether they be in C, assem-\nbler, FORTRAN, Lisp, Forth, or what-have-you. (Yes, what-have-you\n\n\n272\nItem 34\nwould include COBOL, but then what would you have?) After all, if you\ncall a C function named drawLine, it’s really called drawLine, and\nyour object code should contain a reference to that name, not to some\nmangled version of that name.\nTo suppress name mangling, use C++’s extern \"C\" directive:\n// declare a function called drawLine; don’t mangle\n// its name\nextern \"C\" \nvoid drawLine(int x1, int y1, int x2, int y2);\nDon’t be drawn into the trap of assuming that where there’s an extern\n\"C\", there must be an extern \"Pascal\" and an extern \"FORTRAN\" as\nwell. There’s not, at least not in the standard. The best way to view ex-\ntern \"C\" is not as an assertion that the associated function is written\nin C, but as a statement that the function should be called as if it were\nwritten in C. (Technically, extern \"C\" means the function has C link-\nage, but what that means is far from clear. One thing it always means,\nhowever, is that name mangling is suppressed.) \nFor example, if you were so unfortunate as to have to write a function\nin assembler, you could declare it extern \"C\", too:\n// this function is in assembler — don’t mangle its name\nextern \"C\" void twiddleBits(unsigned char bits);\nYou can even declare C++ functions extern \"C\". This can be useful if\nyou’re writing a library in C++ that you’d like to provide to clients using\nother programming languages. By suppressing the name mangling of\nyour C++ function names, your clients can use the natural and intui-\ntive names you choose instead of the mangled names your compilers\nwould otherwise generate:\n// the following C++ function is designed for use outside\n// C++ and should not have its name mangled\nextern \"C\" void simulate(int iterations);\nOften you’ll have a slew of functions whose names you don’t want\nmangled, and it would be a pain to precede each with extern \"C\". For-\ntunately, you don’t have to. extern \"C\" can also be made to apply to\na whole set of functions. Just enclose them all in curly braces:\nextern \"C\" {\n// disable name mangling for\n// all the following functions\nvoid drawLine(int x1, int y1, int x2, int y2);\nvoid twiddleBits(unsigned char bits);\nvoid simulate(int iterations);\n...\n}\n\n\nCombining C++ and C in the Same Program\n273\nThis use of extern \"C\" simplifies the maintenance of header files that\nmust be used with both C++ and C. When compiling for C++, you’ll\nwant to include extern \"C\", but when compiling for C, you won’t. By\ntaking advantage of the fact that the preprocessor symbol\n__cplusplus is defined only for C++ compilations, you can structure\nyour polyglot header files as follows:\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nvoid drawLine(int x1, int y1, int x2, int y2);\nvoid twiddleBits(unsigned char bits);\nvoid simulate(int iterations);\n...\n#ifdef __cplusplus\n}\n#endif\nThere is, by the way, no such thing as a “standard” name mangling al-\ngorithm. Different compilers are free to mangle names in different\nways, and different compilers do. This is a good thing. If all compilers\nmangled names the same way, you might be lulled into thinking they\nall generated compatible code. The way things are now, if you try to\nmix object code from incompatible C++ compilers, there’s a good\nchance you’ll get an error during linking, because the mangled names\nwon’t match up. This implies you’ll probably have other compatibility\nproblems, too, and it’s better to find out about such incompatibilities\nsooner than later,\nInitialization of Statics\nOnce you’ve mastered name mangling, you need to deal with the fact\nthat in C++, lots of code can get executed before and after main. In par-\nticular, the constructors of static class objects and objects at global,\nnamespace, and file scope are usually called before the body of main is\nexecuted. This process is known as static initialization. This is in direct\nopposition to the way we normally think about C++ and C programs,\nin which we view main as the entry point to execution of the program.\nSimilarly, objects that are created through static initialization must\nhave their destructors called during static destruction; that process\ntypically takes place after main has finished executing.\nTo resolve the dilemma that main is supposed to be invoked first, yet\nobjects need to be constructed before main is executed, many compil-\ners insert a call to a special compiler-written function at the beginning\n\n\n274\nItem 34\nof main, and it is this special function that takes care of static initial-\nization. Similarly, compilers often insert a call to another special func-\ntion at the end of main to take care of the destruction of static objects.\nCode generated for main often looks as if main had been written like\nthis:\nint main(int argc, char *argv[])\n{\nperformStaticInitialization();\n// generated by the \n// implementation\nthe statements you put in main go here;\nperformStaticDestruction();\n// generated by the\n// implementation\n}\nNow don’t take this too literally. The functions performStaticIni-\ntialization and performStaticDestruction usually have much\nmore cryptic names, and they may even be generated inline, in which\ncase you won’t see any functions for them in your object files. The im-\nportant point is this: if a C++ compiler adopts this approach to the ini-\ntialization and destruction of static objects, such objects will be\nneither initialized nor destroyed unless main is written in C++. Be-\ncause this approach to static initialization and destruction is common,\nyou should try to write main in C++ if you write any part of a software\nsystem in C++.\nSometimes it would seem to make more sense to write main in C — say\nif most of a program is in C and C++ is just a support library. Never-\ntheless, there’s a good chance the C++ library contains static objects (if\nit doesn’t now, it probably will in the future — see Item 32), so it’s still\na good idea to write main in C++ if you possibly can. That doesn’t mean\nyou need to rewrite your C code, however. Just rename the main you\nwrote in C to be realMain, then have the C++ version of main call\nrealMain:\nextern \"C\"\n// implement this\nint realMain(int argc, char *argv[]);\n// function in C\nint main(int argc, char *argv[])\n// write this in C++\n{\nreturn realMain(argc, argv);\n}\nIf you do this, it’s a good idea to put a comment above main explaining\nwhat is going on.\nIf you cannot write main in C++, you’ve got a problem, because there is\nno other portable way to ensure that constructors and destructors for\nstatic objects are called. This doesn’t mean all is lost, it just means\n\n\nCombining C++ and C in the Same Program\n275\nyou’ll have to work a little harder. Compiler vendors are well ac-\nquainted with this problem, so almost all provide some extralinguistic\nmechanism for initiating the process of static initialization and static\ndestruction. For information on how this works with your compilers,\ndig into your compilers’ documentation or contact their vendors.\nDynamic Memory Allocation\nThat brings us to dynamic memory allocation. The general rule is sim-\nple: the C++ parts of a program use new and delete (see Item 8), and\nthe C parts of a program use malloc (and its variants) and free. As\nlong as memory that came from new is deallocated via delete and\nmemory that came from malloc is deallocated via free, all is well.\nCalling free on a newed pointer yields undefined behavior, however, as\ndoes deleteing a malloced pointer. The only thing to remember, then,\nis to segregate rigorously your news and deletes from your mallocs\nand frees.\nSometimes this is easier said than done. Consider the humble (but\nhandy) strdup function, which, though standard in neither C nor C++,\nis nevertheless widely available:\nchar * strdup(const char *ps);\n// return a copy of the\n// string pointed to by ps\nIf a memory leak is to be avoided, the memory allocated inside strdup\nmust be deallocated by strdup’s caller. But how is the memory to be\ndeallocated? By using delete? By calling free? If the strdup you’re\ncalling is from a C library, it’s the latter. If it was written for a C++ li-\nbrary, it’s probably the former. What you need to do after calling str-\ndup, then, varies not only from system to system, but also from\ncompiler to compiler. To reduce such portability headaches, try to\navoid calling functions that are neither in the standard library (see\nItem 35) nor available in a stable form on most computing platforms.\nData Structure Compatibility\nWhich brings us at long last to passing data between C++ and C pro-\ngrams. There’s no hope of making C functions understand C++ fea-\ntures, so the level of discourse between the two languages must be\nlimited to those concepts that C can express. Thus, it should be clear\nthere’s no portable way to pass objects or to pass pointers to member\nfunctions to routines written in C. C does understand normal pointers,\nhowever, so, provided your C++ and C compilers produce compatible\noutput, functions in the two languages can safely exchange pointers to\nobjects and pointers to non-member or static functions. Naturally,\n",
      "page_number": 285,
      "chapter_number": 28,
      "summary": "Should you make an abstract\nclass for packets (for the concept that a packet represents) as well as a\nconcrete class for the packets you’ll actually be using Key topics include functionality, functions, and function. Covers function.",
      "keywords": [
        "int",
        "function",
        "concrete class",
        "abstract class",
        "functions",
        "main",
        "library",
        "extern",
        "program",
        "n’t",
        "library class",
        "abstract",
        "object files",
        "packets",
        "compilers"
      ],
      "concepts": [
        "functionality",
        "functions",
        "function",
        "classes",
        "compiler",
        "compilations",
        "packets",
        "files",
        "object",
        "calls"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 11,
          "title": "Segment 11 (pages 99-106)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 5,
          "title": "Segment 5 (pages 36-43)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 27,
          "title": "Segment 27 (pages 238-246)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 49,
          "title": "Segment 49 (pages 993-1010)",
          "relevance_score": 0.49,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 20,
          "title": "Segment 20 (pages 392-414)",
          "relevance_score": 0.48,
          "method": "api"
        }
      ]
    },
    {
      "number": 29,
      "title": "Segment 29 (pages 293-301)",
      "start_page": 293,
      "end_page": 301,
      "detection_method": "topic_boundary",
      "content": "276\nItem 34\nstructs and variables of built-in types (e.g., ints, chars, etc.) can also\nfreely cross the C++/C border.\nBecause the rules governing the layout of a struct in C++ are consis-\ntent with those of C, it is safe to assume that a structure definition that\ncompiles in both languages is laid out the same way by both compilers.\nSuch structs can be safely passed back and forth between C++ and C.\nIf you add nonvirtual functions to the C++ version of the struct, its\nmemory layout should not change, so objects of a struct (or class) con-\ntaining only non-virtual functions should be compatible with their C\nbrethren whose structure definition lacks only the member function\ndeclarations. Adding virtual functions ends the game, because the ad-\ndition of virtual functions to a class causes objects of that type to use\na different memory layout (see Item 24). Having a struct inherit from\nanother struct (or class) usually changes its layout, too, so structs with\nbase structs (or classes) are also poor candidates for exchange with C\nfunctions.\nFrom a data structure perspective, it boils down to this: it is safe to\npass data structures from C++ to C and from C to C++ provided the\ndefinition of those structures compiles in both C++ and C. Adding non-\nvirtual member functions to the C++ version of a struct that’s other-\nwise compatible with C will probably not affect its compatibility, but\nalmost any other change to the struct will.\nSummary\nIf you want to mix C++ and C in the same program, remember the fol-\nlowing simple guidelines:\n■Make sure the C++ and C compilers produce compatible object\nfiles.\n■Declare functions to be used by both languages extern \"C\".\n■If at all possible, write main in C++.\n■Always use delete with memory from new; always use free with\nmemory from malloc.\n■Limit what you pass between the two languages to data structures\nthat compile under C; the C++ version of structs may contain non-\nvirtual member functions.\n\n\nThe C++ Language and Library Standard\n277\nItem 35: Familiarize yourself with the language \nstandard.\nThe C++ Language and Library Standard\nSince its publication in 1990, The Annotated C++ Reference Manual\n(see page 285) has been the definitive reference for working program-\nmers needing to know what is in C++ and what is not. In the years\nsince the ARM (as it’s fondly known) came out, the ISO/ANSI commit-\ntee standardizing the language has changed (primarily extended) the\nlanguage in ways both big and small. As a definitive reference, the\nARM no longer suffices. \nThe post-ARM changes to C++ significantly affect how good programs\nare written. As a result, it is important for C++ programmers to be fa-\nmiliar with the primary ways in which the C++ specified by the stan-\ndard differs from that described by the ARM.\nThe ISO/ANSI standard for C++ is what vendors will consult when im-\nplementing compilers, what authors will examine when preparing\nbooks, and what programmers will look to for definitive answers to\nquestions about C++. Among the most important changes to C++ since\nthe ARM are the following:\n■New features have been added: RTTI, namespaces, bool, the mu-\ntable and explicit keywords, the ability to overload operators\nfor enums, and the ability to initialize constant integral static\nclass members within a class definition.\n■Templates have been extended: member templates are now al-\nlowed, there is a standard syntax for forcing template instantia-\ntions, non-type arguments are now allowed in function templates,\nand class templates may themselves be used as template argu-\nments.\n■Exception handling has been refined: exception specifications\nare now more rigorously checked during compilation, and the un-\nexpected function may now throw a bad_exception object.\n■Memory allocation routines have been modified: operator\nnew[] and operator delete[] have been added, the operators\nnew/new[] now throw an exception if memory can’t be allocated,\nand there are now alternative versions of the operators new/new[]\nthat return 0 when an allocation fails.\n\n\n278\nItem 35\n■New casting forms have been added: static_cast, dynamic_cast,\nconst_cast, and reinterpret_cast.\n■Language rules have been refined: redefinitions of virtual func-\ntions need no longer have a return type that exactly matches that\nof the function they redefine, and the lifetime of temporary objects\nhas been defined precisely.\nAlmost all these changes are described in The Design and Evolution of\nC++ (see page 285). Current C++ textbooks (those written after 1994)\nshould include them, too. (If you find one that doesn’t, reject it.) In ad-\ndition, More Effective C++ (that’s this book) contains examples of how\nto use most of these new features. If you’re curious about something\non this list, try looking it up in the index.\nThe changes to C++ proper pale in comparison to what’s happened to\nthe standard library. Furthermore, the evolution of the standard li-\nbrary has not been as well publicized as that of the language. The De-\nsign and Evolution of C++, for example, makes almost no mention of\nthe standard library. The books that do discuss the library are some-\ntimes out of date, because the library changed quite substantially in\n1994.\nThe capabilities of the standard library can be broken down into the\nfollowing general categories:\n■Support for the standard C library. Fear not, C++ still remem-\nbers its roots. Some minor tweaks have brought the C++ version of\nthe C library into conformance with C++’s stricter type checking,\nbut for all intents and purposes, everything you know and love (or\nhate) about the C library continues to be knowable and lovable (or\nhateable) in C++, too.\n■Support for strings. As Chair of the working group for the stan-\ndard C++ library, Mike Vilot was told, “If there isn’t a standard\nstring type, there will be blood in the streets!” (Some people get\nso emotional.) Calm yourself and put away those hatchets and\ntruncheons — the standard C++ library has strings. \n■Support for localization. Different cultures use different charac-\nter sets and follow different conventions when displaying dates\nand times, sorting strings, printing monetary values, etc. Localiza-\ntion support within the standard library facilitates the develop-\nment of programs that accommodate such cultural differences. \n■Support for I/O. The iostream library remains part of the C++\nstandard, but the committee has tinkered with it a bit. Though\nsome classes have been eliminated (notably iostream and\nfstream) and some have been replaced (e.g., string-based\n\n\nThe C++ Language and Library Standard\n279\nstringstreams replace char*-based strstreams, which are now\ndeprecated), the basic capabilities of the standard iostream\nclasses mirror those of the implementations that have existed for\nseveral years.\n■Support for numeric applications. Complex numbers, long a\nmainstay of examples in C++ texts, have finally been enshrined in\nthe standard library. In addition, the library contains special array\nclasses (valarrays) that restrict aliasing. These arrays are eligible\nfor more aggressive optimization than are built-in arrays, espe-\ncially on multiprocessing architectures. The library also provides a\nfew commonly useful numeric functions, including partial sum\nand adjacent difference.\n■Support for general-purpose containers and algorithms. Con-\ntained within the standard C++ library is a set of class and func-\ntion templates collectively known as the Standard Template\nLibrary (STL). The STL is the most revolutionary part of the stan-\ndard C++ library. I summarize its features below.\nBefore I describe the STL, though, I must dispense with two idiosyn-\ncrasies of the standard C++ library you need to know about.\nFirst, almost everything in the library is a template. In this book, I may\nhave referred to the standard string class, but in fact there is no such\nclass. Instead, there is a class template called basic_string that rep-\nresents sequences of characters, and this template takes as a param-\neter the type of the characters making up the sequences. This allows\nfor strings to be made up of chars, wide chars, Unicode chars, what-\never.\nWhat we normally think of as the string class is really the template\ninstantiation basic_string<char>. Because its use is so common,\nthe standard library provides a typedef:\ntypedef basic_string<char> string;\nEven this glosses over many details, because the basic_string tem-\nplate takes three arguments; all but the first have default values. To re-\nally understand the string type, you must face this full, unexpurgated\ndeclaration of basic_string:\ntemplate<class charT, \nclass traits = char_traits<charT>,\nclass Allocator = allocator<charT> >\nclass basic_string;\nYou don’t need to understand this gobbledygook to use the string\ntype, because even though string is a typedef for The Template In-\nstantiation from Hell, it behaves as if it were the unassuming non-tem-\n\n\n280\nItem 35\nplate class the typedef makes it appear to be. Just tuck away in the\nback of your mind the fact that if you ever need to customize the types\nof characters that go into strings, or if you want to fine-tune the behav-\nior of those characters, or if you want to seize control over the way\nmemory for strings is allocated, the basic_string template allows\nyou to do these things. \nThe approach taken in the design of the string type — generalize it\nand make the generalization a template — is repeated throughout the\nstandard C++ library. IOstreams? They’re templates; a type parameter\ndefines the type of character making up the streams. Complex num-\nbers? Also templates; a type parameter defines how the components of\nthe numbers should be stored. Valarrays? Templates; a type parame-\nter specifies what’s in each array. And of course the STL consists al-\nmost entirely of templates. If you are not comfortable with templates,\nnow would be an excellent time to start making serious headway to-\nward that goal.\nThe other thing to know about the standard library is that virtually ev-\nerything it contains is inside the namespace std. To use things in the\nstandard library without explicitly qualifying their names, you’ll have\nto employ a using directive or (preferably) using declarations. Fortu-\nnately, this syntactic administrivia is automatically taken care of when\nyou #include the appropriate headers. \nThe Standard Template Library\nThe biggest news in the standard C++ library is the STL, the Standard\nTemplate Library. (Since almost everything in the C++ library is a tem-\nplate, the name STL is not particularly descriptive. Nevertheless, this\nis the name of the containers and algorithms portion of the library, so\ngood name or bad, this is what we use.)\nThe STL is likely to influence the organization of many — perhaps most\n— C++ libraries, so it’s important that you be familiar with its general\nprinciples. They are not difficult to understand. The STL is based on\nthree fundamental concepts: containers, iterators, and algorithms.\nContainers hold collections of objects. Iterators are pointer-like objects\nthat let you walk through STL containers just as you’d use pointers to\nwalk through built-in arrays. Algorithms are functions that work on\nSTL containers and that use iterators to help them do their work.\nIt is easiest to understand the STL view of the world if we remind our-\nselves of the C++ (and C) rules for arrays. There is really only one rule\nwe need to know: a pointer to an array can legitimately point to any el-\nement of the array or to one element beyond the end of the array. If the\npointer points to the element beyond the end of the array, it can be\n\n\nThe C++ Language and Library Standard\n281\ncompared only to other pointers to the array; the results of dereferenc-\ning it are undefined. \nWe can take advantage of this rule to write a function to find a partic-\nular value in an array. For an array of integers, our function might look\nlike this:\nint * find(int *begin, int *end, int value)\n{\nwhile (begin != end && *begin != value) ++begin;\nreturn begin;\n}\nThis function looks for value in the range between begin and end (ex-\ncluding end — end points to one beyond the end of the array) and re-\nturns a pointer to the first occurrence of value in the array; if none is\nfound, it returns end.\nReturning end seems like a funny way to signal a fruitless search.\nWouldn’t 0 (the null pointer) be better? Certainly null seems more nat-\nural, but that doesn’t make it “better.” The find function must return\nsome distinctive pointer value to indicate the search failed, and for this\npurpose, the end pointer is as good as the null pointer. In addition, as\nwe’ll soon see, the end pointer generalizes to other types of containers\nbetter than the null pointer.\nFrankly, this is probably not the way you’d write the find function,\nbut it’s not unreasonable, and it generalizes astonishingly well. If you\nfollowed this simple example, you have mastered most of the ideas on\nwhich the STL is founded.\nYou could use the find function like this:\nint values[50];\n...\nint *firstFive = find(values, \n// search the range\nvalues+50,\n// values[0] - values[49]\n5);\n// for the value 5\nif (firstFive != values+50) {\n// did the search succeed?\n...\n// yes\n}\nelse {\n...\n// no, the search failed\n}\nYou can also use find to search subranges of the array:\n\n\n282\nItem 35\nint *firstFive = find(values, \n// search the range\nvalues+10,\n// values[0] - values[9]\n5);\n// for the value 5\nint age = 36;\n...\nint *firstValue = find(values+10, // search the range\nvalues+20, // values[10] - values[19]\nage);\n// for the value in age\nThere’s nothing inherent in the find function that limits its applicabil-\nity to arrays of ints, so it should really be a template:\ntemplate<class T>\nT * find(T *begin, T *end, const T& value)\n{\nwhile (begin != end && *begin != value) ++begin;\nreturn begin;\n}\nIn the transformation to a template, notice how we switched from\npass-by-value for value to pass-by-reference-to-const. That’s be-\ncause now that we’re passing arbitrary types around, we have to worry\nabout the cost of pass-by-value. Each by-value parameter costs us a\ncall to the parameter’s constructor and destructor every time the func-\ntion is invoked. We avoid these costs by using pass-by-reference,\nwhich involves no object construction or destruction.\nThis template is nice, but it can be generalized further. Look at the op-\nerations on begin and end. The only ones used are comparison for in-\nequality, dereferencing, prefix increment (see Item 6), and copying (for\nthe function’s return value — see Item 19). These are all operations we\ncan overload, so why limit find to using pointers? Why not allow any\nobject that supports these operations to be used in addition to point-\ners? Doing so would free the find function from the built-in meaning\nof pointer operations. For example, we could define a pointer-like ob-\nject for a linked list whose prefix increment operator moved us to the\nnext element in the list.\nThis is the concept behind STL iterators. Iterators are pointer-like ob-\njects designed for use with STL containers. They are first cousins to\nthe smart pointers of Item 28, but smart pointers tend to be more am-\nbitious in what they do than do STL iterators. From a technical view-\npoint, however, they are implemented using the same techniques.\nEmbracing the notion of iterators as pointer-like objects, we can re-\nplace the pointers in find with iterators, thus rewriting find like this:\n\n\nThe C++ Language and Library Standard\n283\ntemplate<class Iterator, class T>\nIterator find(Iterator begin, Iterator end, const T& value)\n{\nwhile (begin != end && *begin != value) ++begin;\nreturn begin;\n}\nCongratulations! You have just written part of the Standard Template\nLibrary. The STL contains dozens of algorithms that work with con-\ntainers and iterators, and find is one of them. \nContainers in STL include bitset, vector, list, deque, queue,\npriority_queue, stack, set, and map, and you can apply find to\nany of these container types:\nlist<char> charList;\n// create STL list object\n// for holding chars\n...\n// find the first occurrence of ’x’ in charList\nlist<char>::iterator it = find(charList.begin(),\ncharList.end(),\n’x’);\n“Whoa!”, I hear you cry, “This doesn’t look anything like it did in the\narray examples above!” Ah, but it does; you just have to know what to\nlook for. \nTo call find for a list object, you need to come up with iterators that\npoint to the first element of the list and to one past the last element of\nthe list. Without some help from the list class, this is a difficult task,\nbecause you have no idea how a list is implemented. Fortunately,\nlist (like all STL containers) obliges by providing the member func-\ntions begin and end. These member functions return the iterators you\nneed, and it is those iterators that are passed into the first two param-\neters of find above.\nWhen find is finished, it returns an iterator object that points to the\nfound element (if there is one) or to charList.end() (if there’s not).\nBecause you know nothing about how list is implemented, you also\nknow nothing about how iterators into lists are implemented. How,\nthen, are you to know what type of object is returned by find? Again,\nthe list class, like all STL containers, comes to the rescue: it provides\na typedef, iterator, that is the type of iterators into lists. Since\ncharList is a list of chars, the type of an iterator into such a list is\nlist<char>::iterator, and that’s what’s used in the example above.\n(Each STL container class actually defines two iterator types, itera-\ntor and const_iterator. The former acts like a normal pointer, the\nlatter like a pointer-to-const.)\n\n\n284\nItem 35\nExactly the same approach can be used with the other STL containers.\nFurthermore, C++ pointers are STL iterators, so the original array ex-\namples work with the STL find function, too:\nint values[50];\n...\nint *firstFive = find(values, values+50, 5);\n// fine, calls\n// STL find\nAt its core, STL is very simple. It is just a collection of class and func-\ntion templates that adhere to a set of conventions. The STL collection\nclasses provide functions like begin and end that return iterator ob-\njects of types defined by the classes. The STL algorithm functions move\nthrough collections of objects by using iterator objects over STL collec-\ntions. STL iterators act like pointers. That’s really all there is to it.\nThere’s no big inheritance hierarchy, no virtual functions, none of that\nstuff. Just some class and function templates and a set of conventions\nto which they all subscribe.\nWhich leads to another revelation: STL is extensible. You can add your\nown collections, algorithms, and iterators to the STL family. As long as\nyou follow the STL conventions, the standard STL collections will work\nwith your algorithms and your collections will work with the standard\nSTL algorithms. Of course, your templates won’t be part of the stan-\ndard C++ library, but they’ll be built on the same principles and will be\njust as reusable.\nThere is much more to the C++ library than I’ve described here. Before\nyou can use the library effectively, you must learn more about it than\nI’ve had room to summarize, and before you can write your own STL-\ncompliant templates, you must learn more about the conventions of\nthe STL. The standard C++ library is far richer than the C library, and\nthe time you take to familiarize yourself with it is time well spent. Fur-\nthermore, the design principles embodied by the library — those of\ngenerality, extensibility, customizability, efficiency, and reusability —\nare well worth learning in their own right. By studying the standard\nC++ library, you not only increase your knowledge of the ready-made\ncomponents available for use in your software, you learn how to apply\nthe features of C++ more effectively, and you gain insight into how to\ndesign better libraries of your own.\n",
      "page_number": 293,
      "chapter_number": 29,
      "summary": "This chapter covers segment 29 (pages 293-301). Key topics include classes, templates, and contain. Adding virtual functions ends the game, because the ad-\ndition of virtual functions to a class causes objects of that type to use\na different memory layout (see Item 24).",
      "keywords": [
        "STL",
        "standard library",
        "Library",
        "Standard",
        "STL iterators",
        "Standard Template Library",
        "STL containers",
        "find",
        "template",
        "STL find function",
        "Standard Template",
        "standard STL collections",
        "iterators",
        "find function",
        "end"
      ],
      "concepts": [
        "classes",
        "templates",
        "contain",
        "library",
        "libraries",
        "types",
        "pointer",
        "standard",
        "functions",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 30,
          "title": "Segment 30 (pages 317-324)",
          "relevance_score": 0.76,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.73,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 68,
          "title": "Segment 68 (pages 2181-2212)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 15,
          "title": "Segment 15 (pages 456-487)",
          "relevance_score": 0.69,
          "method": "api"
        }
      ]
    },
    {
      "number": 30,
      "title": "Segment 30 (pages 302-311)",
      "start_page": 302,
      "end_page": 311,
      "detection_method": "topic_boundary",
      "content": "Recommended Reading\nSo your appetite for information on C++ remains unsated. Fear not,\nthere’s more — much more. In the sections that follow, I put forth my\nrecommendations for further reading on C++. It goes without saying\nthat such recommendations are both subjective and selective, but in\nview of the litigious age in which we live, it’s probably a good idea to\nsay it anyway.\nBooks\nThere are hundreds — possibly thousands — of books on C++, and\nnew contenders join the fray with great frequency. I haven’t seen all\nthese books, much less read them, but my experience has been that\nwhile some books are very good, some of them, well, some of them\naren’t.\nWhat follows is the list of books I find myself consulting when I have\nquestions about software development in C++. Other good books are\navailable, I’m sure, but these are the ones I use, the ones I can truly\nrecommend.\nA good place to begin is with the books that describe the language it-\nself. Unless you are crucially dependent on the nuances of the official\nstandards documents, I suggest you do, too.\nThe Annotated C++ Reference Manual, Margaret A. Ellis and\nBjarne Stroustrup, Addison-Wesley, 1990, ISBN 0-201-51459-1.\nThe Design and Evolution of C++, Bjarne Stroustrup, Addison-\nWesley, 1994, ISBN 0-201-54330-3.\nThese books contain not just a description of what’s in the language,\nthey also explain the rationale behind the design decisions — some-\nthing you won’t find in the official standard documents. The Anno-\n\n\n286\nRecommended Reading\ntated C++ Reference Manual is now incomplete (several language fea-\ntures have been added since it was published — see Item 35) and is in\nsome cases out of date, but it is still the best reference for the core\nparts of the language, including templates and exceptions. The Design\nand Evolution of C++ covers most of what’s missing in The Annotated\nC++ Reference Manual; the only thing it lacks is a discussion of the\nStandard Template Library (again, see Item 35). These books are not\ntutorials, they’re references, but you can’t truly understand C++ un-\nless you understand the material in these books.\nFor a more general reference on the language, the standard library,\nand how to apply it, there is no better place to look than the book by\nthe man responsible for C++ in the first place:\nThe C++ Programming Language (Third Edition), Bjarne Strous-\ntrup, Addison-Wesley, 1997, ISBN 0-201-88954-4.\nStroustrup has been intimately involved in the language’s design, im-\nplementation, application, and standardization since its inception,\nand he probably knows more about it than anybody else does. His de-\nscriptions of language features make for dense reading, but that’s pri-\nmarily because they contain so much information. The chapters on\nthe standard C++ library provide a good introduction to this crucial\naspect of modern C++.\nIf you’re ready to move beyond the language itself and are interested\nin how to apply it effectively, you might consider my other book on the\nsubject:\nEffective C++, Second Edition: 50 Specific Ways to Improve Your\nPrograms and Designs, Scott Meyers, Addison-Wesley, 1998,\nISBN 0-201-92488-9.\nThat book is organized similarly to this one, but it covers different (ar-\nguably more fundamental) material.\nA book pitched at roughly the same level as my Effective C++ books,\nbut covering different topics, is\nC++ Strategies and Tactics, Robert Murray, Addison-Wesley,\n1993, ISBN 0-201-56382-7.\nMurray’s book is especially strong on the fundamentals of template\ndesign, a topic to which he devotes two chapters. He also includes a\nchapter on the important topic of migrating from C development to\nC++ development. Much of my discussion on reference counting (see\nItem 29) is based on the ideas in C++ Strategies and Tactics.\nIf you’re the kind of person who likes to learn proper programming\ntechnique by reading code, the book for you is\n\n\nRecommended Reading\n287\nC++ Programming Style, Tom Cargill, Addison-Wesley, 1992, \nISBN 0-201-56365-7.\nEach chapter in this book starts with some C++ software that has\nbeen published as an example of how to do something correctly.\nCargill then proceeds to dissect — nay, vivisect — each program, iden-\ntifying likely trouble spots, poor design choices, brittle implementation\ndecisions, and things that are just plain wrong. He then iteratively re-\nwrites each example to eliminate the weaknesses, and by the time he’s\ndone, he’s produced code that is more robust, more maintainable,\nmore efficient, and more portable, and it still fulfills the original prob-\nlem specification. Anybody programming in C++ would do well to heed\nthe lessons of this book, but it is especially important for those in-\nvolved in code inspections.\n(One topic Cargill does not discuss in C++ Programming Style is excep-\ntions. He turns his critical eye to this language feature in the following\narticle, however, which demonstrates why writing exception-safe code\nis more difficult than most programmers realize:\n“Exception Handling: A False Sense of Security,” C++ Report,\nVolume 6, Number 9, November-December 1994, pages 21-24.\nIf you are contemplating the use of exceptions, read this article before\nyou proceed. If you don’t have access to back issues of the C++ Report,\nyou can find the article at the Addison-Wesley Internet site. The World\nWide Web URL is http://www.awl.com/cp/mec++.html. If you pre-\nfer anonymous FTP, you can get the article from ftp.awl.com in the\ndirectory cp/mec++.)\nOnce you’ve mastered the basics of C++ and are ready to start push-\ning the envelope, you must familiarize yourself with\nAdvanced C++: Programming Styles and Idioms, James Coplien,\nAddison-Wesley, 1992, ISBN 0-201-54855-0.\nI generally refer to this as “the LSD book,” because it’s purple and it\nwill expand your mind. Coplien covers some straightforward material,\nbut his focus is really on showing you how to do things in C++ you’re\nnot supposed to be able to do. You want to construct objects on top of\none another? He shows you how. You want to bypass strong typing?\nHe gives you a way. You want to add data and functions to classes as\nyour programs are running? He explains how to do it. Most of the\ntime, you’ll want to steer clear of the techniques he describes, but\nsometimes they provide just the solution you need for a tricky prob-\nlem you’re facing. Furthermore, it’s illuminating just to see what\n\n\n288\nRecommended Reading\nkinds of things can be done with C++. This book may frighten you, it\nmay dazzle you, but when you’ve read it, you’ll never look at C++ the\nsame way again.\nIf you have anything to do with the design and implementation of C++\nlibraries, you would be foolhardy to overlook\nDesigning and Coding Reusable C++, Martin D. Carroll and\nMargaret A. Ellis, Addison-Wesley, 1995, ISBN 0-201-51284-X.\nCarroll and Ellis discuss many practical aspects of library design and\nimplementation that are simply ignored by everybody else. Good li-\nbraries are small, fast, extensible, easily upgraded, graceful during\ntemplate instantiation, powerful, and robust. It is not possible to opti-\nmize for each of these attributes, so one must make trade-offs that\nimprove some aspects of a library at the expense of others. Designing\nand Coding Reusable C++ examines these trade-offs and offers down-\nto-earth advice on how to go about making them.\nRegardless of whether you write software for scientific and engineering\napplications, you owe yourself a look at\nScientific and Engineering C++, John J. Barton and Lee R.\nNackman, Addison-Wesley, 1994, ISBN 0-201-53393-6.\nThe first part of the book explains C++ for FORTRAN programmers\n(now there’s an unenviable task), but the latter parts cover techniques\nthat are relevant in virtually any domain. The extensive material on\ntemplates is close to revolutionary; it’s probably the most advanced\nthat’s currently available, and I suspect that when you’ve seen the\nmiracles these authors perform with templates, you’ll never again\nthink of them as little more than souped-up macros.\nFinally, the emerging discipline of patterns in object-oriented software\ndevelopment (see page 123) is described in\nDesign Patterns: Elements of Reusable Object-Oriented Soft-\nware, Erich Gamma, Richard Helm, Ralph Johnson, and John\nVlissides, Addison-Wesley, 1995, ISBN 0-201-63361-2.\nThis book provides an overview of the ideas behind patterns, but its\nprimary contribution is a catalogue of 23 fundamental patterns that\nare useful in many application areas. A stroll through these pages will\nalmost surely reveal a pattern you’ve had to invent yourself at one\ntime or another, and when you find one, you’re almost certain to dis-\ncover that the design in the book is superior to the ad-hoc approach\nyou came up with. The names of the patterns here have already be-\ncome part of an emerging vocabulary for object-oriented design; fail-\nure to know these names may soon be hazardous to your ability to\n\n\nRecommended Reading\n289\ncommunicate with your colleagues. A particular strength of the book\nis its emphasis on designing and implementing software so that future\nevolution is gracefully accommodated (see Items 32 and 33).\nDesign Patterns is also available as a CD-ROM:\nDesign Patterns CD: Elements of Reusable Object-Oriented Soft-\nware, Erich Gamma, Richard Helm, Ralph Johnson, and John\nVlissides, Addison-Wesley, 1998, ISBN 0-201-63498-8.\nMagazines\nFor hard-core C++ programmers, there’s really only one game in town:\nC++ Report, SIGS Publications, New York, NY.\nThe magazine has made a conscious decision to move away from its\n“C++ only” roots, but the increased coverage of domain- and system-\nspecific programming issues is worthwhile in its own right, and the\nmaterial on C++, if occasionally a bit off the deep end, continues to be\nthe best available.\nIf you’re more comfortable with C than with C++, or if you find the C++\nReport’s material too extreme to be useful, you may find the articles in\nthis magazine more to your taste:\nC/C++ Users Journal, Miller Freeman, Inc., Lawrence, KS.\nAs the name suggests, this covers both C and C++. The articles on\nC++ tend to assume a weaker background than those in the C++ Re-\nport. In addition, the editorial staff keeps a tighter rein on its authors\nthan does the Report, so the material in the magazine tends to be rela-\ntively mainstream. This helps filter out ideas on the lunatic fringe, but\nit also limits your exposure to techniques that are truly cutting-edge.\nUsenet Newsgroups\nThree Usenet newsgroups are devoted to C++. The general-purpose\nanything-goes newsgroup is comp.lang.c++. The postings there run\nthe gamut from detailed explanations of advanced programming tech-\nniques to rants and raves by those who love or hate C++ to undergrad-\nuates the world over asking for help with the homework assignments\nthey neglected until too late. Volume in the newsgroup is extremely\nhigh. Unless you have hours of free time on your hands, you’ll want to\nemploy a filter to help separate the wheat from the chaff. Get a good\nfilter — there’s a lot of chaff.\nIn November 1995, a moderated version of comp.lang.c++ was cre-\nated. Named comp.lang.c++.moderated, this newsgroup is also de-\nsigned for general discussion of C++ and related issues, but the\nmoderators aim to weed out implementation-specific questions and\n\n\n290\nRecommended Reading\ncomments, questions covered in the extensive on-line FAQ (“Fre-\nquently Asked Questions” list), flame wars, and other matters of little\ninterest to most C++ practitioners. \nA more narrowly focused newsgroup is comp.std.c++, which is de-\nvoted to a discussion of the C++ standard itself. Language lawyers\nabound in this group, but it’s a good place to turn if your picky ques-\ntions about C++ go unanswered in the references otherwise available\nto you. The newsgroup is moderated, so the signal-to-noise ratio is\nquite good; you won’t see any pleas for homework assistance here.\n\n\nAn auto_ptr Implementation\nItems 9, 10, 26, 31 and 32 attest to the remarkable utility of the\nauto_ptr template. Unfortunately, few compilers currently ship with\na “correct” implementation.† Items 9 and 28 sketch how you might\nwrite one yourself, but it’s nice to have more than a sketch when em-\nbarking on real-world projects. \nBelow are two presentations of an implementation for auto_ptr. The\nfirst presentation documents the class interface and implements all\nthe member functions outside the class definition. The second imple-\nments each member function within the class definition. Stylistically,\nthe second presentation is inferior to the first, because it fails to sepa-\nrate the class interface from its implementation. However, auto_ptr\nyields simple classes, and the second presentation brings that out\nmuch more clearly than does the first.\nHere is auto_ptr with its interface documented:\ntemplate<class T>\nclass auto_ptr {\npublic:\nexplicit auto_ptr(T *p = 0); // see Item 5 for a \n// description of \"explicit\"\ntemplate<class U>\n// copy constructor member\nauto_ptr(auto_ptr<U>& rhs);\n// template (see Item 28):\n// initialize a new auto_ptr\n// with any compatible \n// auto_ptr\n~auto_ptr();\ntemplate<class U>\n// assignment operator \nauto_ptr<T>&\n// member template (see\noperator=(auto_ptr<U>& rhs); // Item 28): assign from any\n// compatible auto_ptr \n† This is primarily because the specification for auto_ptr has for years been a moving\ntarget. The final specification was adopted only in November 1997. For details, consult\nthe auto_ptr information at this book’s WWW and FTP sites (see page 8). Note that\nthe auto_ptr described here omits a few details present in the official version, such\nas the fact that auto_ptr is in the std namespace (see Item 35) and that its member\nfunctions promise not to throw exceptions.\n\n\n292\nAn auto_ptr Implementation\nT& operator*() const;\n// see Item 28\nT* operator->() const;\n// see Item 28\nT* get() const;\n// return value of current\n// dumb pointer\nT* release();\n// relinquish ownership of\n// current dumb pointer and\n// return its value\nvoid reset(T *p = 0);\n// delete owned pointer;\n// assume ownership of p\nprivate:\nT *pointee;\ntemplate<class U>\n// make all auto_ptr classes\nfriend class auto_ptr<U>;\n// friends of one another\n};\ntemplate<class T>\ninline auto_ptr<T>::auto_ptr(T *p)\n: pointee(p)\n{}\ntemplate<class T>\ntemplate<class U>\ninline auto_ptr<T>::auto_ptr(auto_ptr<U>& rhs)\n: pointee(rhs.release())\n{}\ntemplate<class T>\ninline auto_ptr<T>::~auto_ptr()\n{ delete pointee; }\ntemplate<class T>\ntemplate<class U>\ninline auto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<U>& rhs)\n{\nif (this != &rhs) reset(rhs.release());\nreturn *this;\n}\ntemplate<class T>\ninline T& auto_ptr<T>::operator*() const\n{ return *pointee; }\ntemplate<class T>\ninline T* auto_ptr<T>::operator->() const\n{ return pointee; }\ntemplate<class T>\ninline T* auto_ptr<T>::get() const\n{ return pointee; }\n\n\nAn auto_ptr Implementation\n293\ntemplate<class T>\ninline T* auto_ptr<T>::release()\n{\nT *oldPointee = pointee;\npointee = 0;\nreturn oldPointee;\n}\ntemplate<class T>\ninline void auto_ptr<T>::reset(T *p)\n{\nif (pointee != p) {\ndelete pointee;\npointee = p;\n}\n}\nHere is auto_ptr with all the functions defined in the class definition.\nAs you can see, there’s no brain surgery going on here:\ntemplate<class T>\nclass auto_ptr {\npublic:\nexplicit auto_ptr(T *p = 0): pointee(p) {}\ntemplate<class U>\nauto_ptr(auto_ptr<U>& rhs): pointee(rhs.release()) {}\n~auto_ptr() { delete pointee; }\ntemplate<class U>\nauto_ptr<T>& operator=(auto_ptr<U>& rhs)\n{\nif (this != &rhs) reset(rhs.release());\nreturn *this;\n}\nT& operator*() const { return *pointee; }\nT* operator->() const { return pointee; }\nT* get() const { return pointee; }\nT* release()\n{\nT *oldPointee = pointee;\npointee = 0;\nreturn oldPointee;\n}\nvoid reset(T *p = 0)\n{\nif (pointee != p) {\ndelete pointee;\npointee = p;\n}\n}\n\n\n294\nAn auto_ptr Implementation\nprivate:\nT *pointee;\ntemplate<class U> friend class auto_ptr<U>;\n};\nIf your compilers don’t yet support explicit, you may safely #define\nit out of existence:\n#define explicit\nThis won’t make auto_ptr any less functional, but it will render it\nslightly less safe. For details, see Item 5.\nIf your compilers lack support for member templates, you can use the\nnon-template auto_ptr copy constructor and assignment operator de-\nscribed in Item 28. This will make your auto_ptrs less convenient to\nuse, but there is, alas, no way to approximate the behavior of member\ntemplates. If member templates (or other language features, for that\nmatter) are important to you, let your compiler vendors know. The\nmore customers ask for new language features, the sooner vendors will\nimplement them.\n",
      "page_number": 302,
      "chapter_number": 30,
      "summary": "The Design\nand Evolution of C++ covers most of what’s missing in The Annotated\nC++ Reference Manual; the only thing it lacks is a discussion of the\nStandard Template Library (again, see Item 35) Key topics include templates, design, and programming.",
      "keywords": [
        "auto",
        "ptr",
        "pointee",
        "Template",
        "class auto",
        "ISBN",
        "Item",
        "book",
        "ptr Implementation",
        "Design",
        "Recommended Reading",
        "language",
        "inline auto",
        "Reading",
        "friend class auto"
      ],
      "concepts": [
        "templates",
        "design",
        "programming",
        "programs",
        "reading",
        "books",
        "specific",
        "good",
        "implementation",
        "implement"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 1,
          "title": "Segment 1 (pages 1-35)",
          "relevance_score": 0.69,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 30,
          "title": "Segment 30 (pages 950-980)",
          "relevance_score": 0.67,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 57,
          "title": "Segment 57 (pages 1824-1855)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 63,
          "title": "Segment 63 (pages 2016-2049)",
          "relevance_score": 0.62,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 64,
          "title": "Segment 64 (pages 2050-2080)",
          "relevance_score": 0.62,
          "method": "api"
        }
      ]
    },
    {
      "number": 31,
      "title": "Segment 31 (pages 312-319)",
      "start_page": 312,
      "end_page": 319,
      "detection_method": "topic_boundary",
      "content": "General Index\nThis index is for everything in this book except the classes, functions,\nand templates I use as examples. If you’re looking for a reference to a\nparticular class, function, or template I use as an example, please\nturn to the index beginning on page 313. For everything else, this is\nthe place to be. In particular, classes, functions, and templates in the\nstandard C++ library (e.g., string, auto_ptr, list, vector, etc.) are\nindexed here.\nFor the most part, operators are listed under operator. For example,\noperator<< is listed under operator<<, not under <<, etc. However,\noperators whose names are words or are word-like (e.g., new, delete,\nsizeof, const_cast, etc.) are listed under the appropriate words\n(e.g., new, delete, sizeof, const_cast, etc.).\nExample uses of new and lesser-known language features are indexed\nunder example uses.\nBefore A\n#define 294\n?:, vs. if/then 56\n__cplusplus 273\n“>>”, vs. “> >” 29\n80-20 rule 79, 82–85, 106\n90-10 rule xi, 82\nA\nabort\nand assert 167\nand object destruction 72\nrelationship to terminate 72\nabstract classes\nand inheritance 258–270\nand vtbls 115\ndrawing 5\nidentifying 267, 268\ntransforming from concrete 266–\n269\nabstract mixin base classes 154\nabstractions\nidentifying 267, 268\nuseful 267\naccess-declarations 144\nadding data and functions to \nclasses at runtime 287\nAddison-Wesley Internet site 8, 287\naddress comparisons to determine \nobject locations 150–152\naddress-of operator —\nsee operator&\n\n\n296\n General Index\nAdvanced C++: Programming Styles \nand Idioms 287\nAdventure, allusion to 271\nallocation of memory — see memory \nallocation\namortizing computational \ncosts 93–98\nAnnotated C++ Reference Manual, \nThe 277, 285\nANSI/ISO standardization \ncommittee 2, 59, 96, 256, 277\nAPL 92\napplication framework 234\napproximating\nbool 3–4\nC++-style casts 15–16\nconst static data \nmembers 141\nexplicit 29–31\nin-class using declarations 144\nmember templates 294\nmutable 89–90\nvirtual functions 121\nvtbls 235–251\nARM, the 277\narray new 42\narrays\nand auto_ptr 48\nand default constructors 19–21\nand inheritance 17–18\nand pointer arithmetic 17\nassociative 236, 237\ndynamic 96–98\nmemory allocation for 42–43\nmulti-dimensional 213–217\nof pointers to functions 15, 113\nof pointers, as substitute for \narrays of objects 20\npointers into 280\nusing placement new to \ninitialize 20–21\nassert, and abort 167\nassignment operators —\nsee operator=\nassignments\nin reference-counted value \nclasses 196\nmixed-type 260, 261, 263–265\nof pointers and references 11\npartial 259, 263–265\nthrough pointers 259, 260\nassociative arrays 236, 237\nauto_ptr 49, 53, 57, 58, 137, 139,\n162, 240, 257\nand heap arrays 48\nand object ownership 183\nand pass-by-reference 165\nand pass-by-value 164\nand preventing resource \nleaks 48, 58\nassignment of 162–165\ncopying of 162–165\nimplementation 291–294\nB\nbad_alloc class 70, 75\nbad_cast class 70, 261, 262\nbad_exception class 70, 77\nbad_typeid class 70\nBarton, John J. 288\nbase classes\nand catch clauses 67\nand delete 18\nfor counting objects 141–145\nBASIC 156, 213\nbasic_string class 279, 280\nbegin function 283\nbenchmarks 80, 110, 111\nbest fit 67\nBible, allusion to 235\nbitset template 4, 283\nbooks, recommended 285–289\nbool 3, 4\nbugs in this book, reporting 8\nbypassing\nconstructors 21\nexception-related costs 79\nRTTI information 122\nsmart pointer smartness 171\nstrong typing 287\nvirtual base classes 122\nvirtual functions 122\nC\nC\ndynamic memory allocation 275\n\n\nGeneral Index\n297\nfunctions and name \nmangling 271\nlinkage 272\nmigrating to C++ 286\nmixing with C++ 270–276\nstandard library 278\nC Programming Language, The 36\nC-style casts 12, 90\nC++\ndynamic memory allocation 275\nmigrating from C 286\nmixing with C 270–276\nstandard library — see stan-\ndard C++ library\nC++ Programming Language, \nThe 286\nC++ Programming Style 287\nC++ Report 287, 289\nC++-style casts 12–16\napproximating 15–16\nC/C++ Users Journal 289\nc_str 27\ncaching 94–95, 98\ncallback functions 74–75, 79\nCandide, allusion to 19\nCargill, Tom 44, 287\nCarroll, Martin D. 288\ncasts\nC++-style 12–16\nC-style 12, 90\nof function pointers 15, 242\nsafe 14\nto remove constness or \nvolatileness 13, 221\ncatch 56\nand inheritance 67\nand temporary objects 65\nby pointer 70\nby reference 71\nby value 70\nclauses, order of \nexamination 67–68\nclauses, vs. virtual functions 67\nsee also pass-by-value, pass-by-\nreference, and pass-by-\npointer\nchange, designing for 252–270\nchar*s, vs. string objects 4\ncharacters\nUnicode 279\nwide 279\nClancy — see Urbano, Nancy L.\nclasses\nabstract mixin bases 154\nabstract, drawing 5\nadding members at runtime 287\nbase — see base classes\nconcrete, drawing 5\nderived — see derived classes\ndesigning — see design\ndiagnostic, in the standard \nlibrary 66\nfor registering things 250\nmixin 154\nmodifying, and \nrecompilation 234, 249\nnested, and inheritance 197\nproxy — see proxy classes\ntemplates for, specializing 175\ntransforming concrete into \nabstract 266–269\ncleaning your room 85\nclient, definition 7\nCLOS 230\nCOBOL 213, 272\ncode duplication 47, 54, 142, 204,\n223, 224\ncode reuse\nvia smart pointer templates and \nbase classes 211\nvia the standard library 5\ncode, generalizing 258\ncomma operator —\nsee operator,\ncommittee for C++ standardization \n— see ANSI/ISO standardiza-\ntion committee\ncomp.lang.c++ 289\ncomp.lang.c++.moderated 289\ncomp.std.c++ 290\ncomparing addresses to determine \nobject location 150–152\ncompilers, lying to 241\ncomplex numbers 279, 280\n\n\n298\n General Index\nconcrete classes\nand inheritance 258–270\ndrawing 5\ntransforming into abstract 266–\n269\nconsistency\namong +, =, and +=, etc. 107\nbetween built-in and user-\ndefined types 254\nbetween prefix and postfix oper-\nator++ and operator-- 34\nbetween real and virtual copy \nconstructors 126\nconst member functions 89, 160,\n218\nconst return types 33–34, 101\nconst static data members, \ninitialization 140\nconst_cast 13, 14, 15, 37, 90\nconst_iterator type 127, 283\nconstant pointers 55–56\nconstness, casting away 13, 221\nconstructing objects on top of one \nanother 287\nconstructors\nand fully constructed objects 52\nand malloc 39\nand memory leaks 6\nand operator new 39, 149–150\nand operator new[] 43\nand references 165\nand static initialization 273\nas type conversion functions 27–\n31\nbypassing 21\ncalling directly 39\ncopy — see copy constructors\ndefault — see default construc-\ntors\nlazy 88–90\npreventing exception-related \nresource leaks 50–58\nprivate 130, 137, 146\nprotected 142\npseudo — see pseudo-construc-\ntors\npurpose 21\nrelationship to new operator and \noperator new 40\nsingle-argument 25, 27–31, 177\nvirtual — see virtual constructors\ncontacting this book’s author 8\ncontainers —\nsee Standard Template Library\ncontexts for object \nconstruction 136\nconventions\nand the STL 284\nfor I/O operators 128\nused in this book 5–8\nconversion functions —\nsee type conversion functions\nconversions — see type conversions\nCoplien, James 287\ncopy constructors 146\nand classes with pointers 200\nand exceptions 63, 68\nand non-const parameters 165\nand smart pointers 205\nfor strings 86\nvirtual — see virtual copy con-\nstructors\ncopying objects\nand exceptions 68\nstatic type vs. dynamic type 63\nwhen throwing an exception 62–\n63\ncopy-on-write 190–194\ncounting object instantiations 141–\n145\nC-style casts 12\nctor, definition 6\ncustomizing memory \nmanagement 38–43\nD\ndata members\nadding at runtime 287\nauto_ptr 58\ninitialization when const 55–56\ninitialization when static 140\nreplication, under multiple \ninheritance 118–120\nstatic, in templates 144\ndataflow languages 93\nDavis, Bette, allusion to 230\ndecrement operator —\nsee operator--\n\n\nGeneral Index\n299\ndefault constructors\nand arrays 19–21\nand templates 22\nand virtual base classes 22\ndefinition 19\nmeaningless 23\nrestrictions from 19–22\nwhen to/not to declare 19\ndelete\nand inheritance 18\nand memory not from new 21\nand nonvirtual destructors 256\nand null pointers 52\nand objects 173\nand smart pointers 173\nand this 145, 152, 157, 197, 213\ndetermining when valid 152–157\nsee also delete operator and \nownership\ndelete operator 37, 41, 173\nand operator delete[] and \ndestructors 43\nand placement new 42\nand this 145, 152, 157, 197, 213\ndeprecated features 7\naccess declarators 144\nstatics at file scope 246\nstrstream class 279\ndeque template 283\nderived classes\nand catch clauses 67\nand delete 18\nand operator= 263\nprohibiting 137\ndesign\nand multiple dispatch 235\nfor change 252–270\nof classes 33, 133, 186, 227, 258,\n268\nof function locations 244\nof libraries 110, 113, 284, 286,\n288\nof templates 286\nof virtual function \nimplementation 248\npatterns 123, 288\nDesign and Evolution of C++, \nThe 278, 285\nDesign Patterns: Elements of Reus-\nable Object-Oriented \nSoftware 288\nDesigning and Coding Reusable \nC++ 288\ndestruction, static 273–275\ndestructors\nand delete 256\nand exceptions 45\nand fully constructed objects 52\nand longjmp 47\nand memory leaks 6\nand operator delete[] 43\nand partially constructed \nobjects 53\nand smart pointers 205\nprivate 145\nprotected 142, 147\npseudo 145, 146\npure virtual 195, 265\nvirtual 143, 254–257\ndetermining whether a pointer can \nbe deleted 152–157\ndetermining whether an object is on \nthe heap 147–157\ndiagnostics classes of the standard \nlibrary 66\ndispatching — see multiple dispatch\ndistinguishing lvalue and rvalue \nuse of operator[] 87, 217–\n223\ndomain_error class 66\ndouble application of increment \nand decrement 33\ndouble-dispatch —\nsee multiple dispatch\ndtor, definition 6\ndumb pointers 159, 207\nduplication of code 47, 54, 142,\n204, 223, 224\ndynamic arrays 96–98\ndynamic type\nvs. static type 5–6\nvs. static type, when copying 63\ndynamic_cast 6, 37, 261–262\nand null pointer 70\nand virtual functions 14, 156\napproximating 16\nmeaning 14\n\n\n300\n General Index\nto get a pointer to the beginning of \nan object 155\nto reference, failed 70\nto void* 156\nE\neager evaluation 86, 91, 92, 94, 98\nconverting to lazy evaluation 93\nEdelson, Daniel 179\nEffective C++ 5, 100, 286\nefficiency\nand assigning smart \npointers 163\nand benchmarks 110\nand cache hit rate 98\nand constructors and \ndestructors 53\nand copying smart pointers 163\nand encapsulation 82\nand function return values 101\nand inlining 129\nand libraries 110, 113\nand maintenance 91\nand multiple inheritance 118–\n120\nand object size 98\nand operators new and \ndelete 97, 113\nand paging behavior 98\nand pass-by-pointer 65\nand pass-by-reference 65\nand pass-by-value 65\nand profiling 84–85, 93\nand reference counting 183, 211\nand system calls 97\nand temporary objects 99–101\nand tracking heap \nallocations 153\nand virtual functions 113–118\nand vptrs 116, 256\nand vtbls 114, 256\ncaching 94–95, 98\nclass statics vs. function \nstatics 133\ncost amortization 93–98\nimplications of meaningless \ndefault constructors 23\niostreams vs. stdio 110–112\nlocating bottlenecks 83\nmanual methods vs. language \nfeatures 122\nof exception-related features 64,\n70, 78–80\nof prefix vs. postfix increment and \ndecrement 34\nof stand-alone operators vs. \nassignment versions 108\nprefetching 96–98\nreading vs. writing reference-\ncounted objects 87, 217\nspace vs. time 98\nsummary of costs of various lan-\nguage features 121\nvirtual functions vs. manual \nmethods 121, 235\nvs. syntactic convenience 108\nsee also optimization\nEllis, Margaret A. 285, 288\nemulating features —\nsee approximating\nencapsulation\nallowing class implementations \nto change 207\nand efficiency 82\nend function 283\nenums\nand overloading operators 277\nas class constants 141\nevaluation\nconverting eager to lazy 93\neager 86, 91, 92, 94, 98\nlazy 85–93, 94, 98, 191, 219\nover-eager 94–98\nshort-circuit 35, 36\nexample uses\n__cplusplus 273\nauto_ptr 48, 57, 138, 164, 165,\n240, 247, 257\nconst pointers 55\nconst_cast 13, 90, 221\ndynamic_cast 14, 155, 243,\n244, 261, 262\nexception specifications 70, 73,\n74, 75, 77\nexplicit 29, 291, 293\nfind function 283\n\n\nGeneral Index\n301\nimplicit type conversion \noperators 25, 26, 49, 171,\n175, 219, 225\nin-class initialization of const\nstatic members 140\nlist template 51, 124, 154, 283\nmake_pair template 247\nmap template 95, 238, 245\nmember templates 176, 291, 292,\n293\nmutable 88\nnamespace 132, 245, 246, 247\nnested class using \ninheritance 197\noperator delete 41, 155\noperator delete[] 21\noperator new 41, 155\noperator new[] 21\noperator& 224\noperator->* (built-in) 237\npair template 246\nplacement new 21, 40\npointers to member \nfunctions 236, 238\npure virtual destructors 154, 194\nreference data member 219\nrefined return type of virtual \nfunctions 126, 260\nreinterpret_cast 15\nsetiosflags 111\nsetprecision 111\nsetw 99, 111\nStandard Template Library 95,\n125, 127, 155, 238, 247, 283,\n284\nstatic_cast 12, 18, 21, 28, 29,\n231\ntypeid 231, 238, 245\nusing declarations 133, 143\nvector template 11\nexception class 66, 77\nexception specifications 72–78\nadvantages 72\nand callback functions 74–75\nand layered designs 77\nand libraries 76, 79\nand templates 73–74\nchecking for consistency 72\ncost of 79\nmixing code with and without 73,\n75\nexception::what 70, 71\nexceptions 287\nand destructors 45\nand operator new 52\nand type conversions 66–67\nand virtual functions 79\ncausing resource leaks in \nconstructors 52\nchoices for passing 68\ndisadvantages 44\nefficiency 63, 65, 78–80\nmandatory copying 62–63\nmodifying throw expressions 63\nmotivation 44\noptimization 64\nrecent revisions to 277\nrethrowing 64\nspecifications — see exception\nspecifications\nstandard 66, 70\nunexpected — see unexpected \nexceptions\nuse of copy constructor 63\nuse to indicate common \nconditions 80\nvs. setjmp and longjmp 45\nsee also catch, throw\nexplicit 28–31, 227, 294\nextern \"C\" 272–273\nF\nfake this 89\nfalse 3\nFelix the Cat 123\nfetch and increment 32\nfetching, lazy 87–90\nfind function 283\nfirst fit 67\nfixed-format I/O 112\nForth 271\nFORTRAN 213, 215, 271, 288\nfree 42, 275\nFrench, gratuitous use of 177, 185\nfriends, avoiding 108, 131\nfstream class 278\n\n\n302\n General Index\nFTP site\nfor this book 8, 287\nfully constructed objects 52\nfunction call semantics 35–36\nfunctions\nadding at runtime 287\nC, and name mangling 271\ncallback 74–75, 79\nfor type conversions 25–31\ninline, in this book 7\nmember — see member functions\nmember template — see mem-\nber templates\nreturn types — see return types\nvirtual — see virtual functions\nfuture tense programming 252–258\nG\nGamma, Erich 288\ngarbage collection 183, 212\ngeneralizing code 258\nGerman, gratuitous use of 31\nglobal overloading of operator\nnew/delete 43, 153\nGUI systems 49, 74–75\nH\nHamlet, allusion to 22, 70, 252\nheap objects — see objects\nHelm, Richard 288\nheuristic for vtbl generation 115\nI\nidentifying abstractions 267, 268\nidioms 123\nIliad, Homer’s 87\nimplementation\nof + in terms of +=, etc. 107\nof libraries 288\nof multiple dispatch 230–251\nof operators ++ and -- 34\nof pass-by-reference 242\nof pure virtual functions 265\nof references 242\nof RTTI 120–121\nof virtual base classes 118–120\nof virtual functions 113–118\nimplicit type conversion operators \n— see type conversion operators\nimplicit type conversions —\nsee type conversions\nincrement and fetch 32\nincrement operator —\nsee operator++\nindexing, array\nand inheritance 17–18\nand pointer arithmetic 17\ninheritance\nand abstract classes 258–270\nand catch clauses 67\nand concrete classes 258–270\nand delete 18\nand emulated vtbls 248–249\nand libraries 269–270\nand nested classes 197\nand operator delete 158\nand operator new 158\nand private constructors and \ndestructors 137, 146\nand smart pointers 163, 173–179\nand type conversions of \nexceptions 66\nmultiple — see multiple inherit-\nance\nprivate 143\ninitialization\ndemand-paged 88\nof arrays via placement new 20–\n21\nof const pointer members 55–56\nof const static members 140\nof emulated vtbls 239–244, 249–\n251\nof function statics 133\nof objects 39, 237\nof pointers 10\nof references 10\norder, in different translation \nunits 133\nstatic 273–275\ninlining\nand “virtual” non-member \nfunctions 129\n",
      "page_number": 312,
      "chapter_number": 31,
      "summary": "This chapter covers segment 31 (pages 312-319). Key topics include classes, functions, and function. If you’re looking for a reference to a\nparticular class, function, or template I use as an example, please\nturn to the index beginning on page 313.",
      "keywords": [
        "operator",
        "virtual functions",
        "functions",
        "virtual",
        "General Index",
        "classes",
        "type conversion operators",
        "pointers",
        "type",
        "operator delete",
        "objects",
        "function",
        "delete",
        "Index",
        "virtual base classes"
      ],
      "concepts": [
        "classes",
        "functions",
        "function",
        "templates",
        "object",
        "operators",
        "pointer",
        "statics",
        "virtual",
        "members"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.78,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 21,
          "title": "Segment 21 (pages 651-684)",
          "relevance_score": 0.76,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 30,
          "title": "Segment 30 (pages 950-980)",
          "relevance_score": 0.76,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 38,
          "title": "Segment 38 (pages 345-352)",
          "relevance_score": 0.75,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 31,
          "title": "Segment 31 (pages 981-1014)",
          "relevance_score": 0.74,
          "method": "api"
        }
      ]
    },
    {
      "number": 32,
      "title": "Segment 32 (pages 320-329)",
      "start_page": 320,
      "end_page": 329,
      "detection_method": "topic_boundary",
      "content": "General Index\n303\nand function statics 134\nand the return value \noptimization 104\nand vtbl generation 115\nin this book 7\ninstantiations, of templates 7\ninternal linkage 134\nInternet site\nfor free STL implementation 4\nfor this book 8, 287\ninvalid_argument class 66\niostream class 278\niostreams 280\nand fixed-format I/O 112\nand operator! 170\nconversion to void* 168\nvs. stdio 110–112\nISO standardization committee — \nsee ANSI/ISO standardization \ncommittee\niterators 283\nand operator-> 96\nvs. pointers 282, 284\nsee also Standard Template \nLibrary\nJ\nJapanese, gratuitous use of 45\nJohnson, Ralph 288\nK\nKernighan, Brian W. 36\nKirk, Captain, allusion to 79\nL\nlanguage lawyers 276, 290\nLatin, gratuitous use of 203, 252\nlazy construction 88–90\nlazy evaluation 85–93, 94, 191, 219\nand object dependencies 92\nconversion from eager 93\nwhen appropriate 93, 98\nlazy fetching 87–90\nleaks, memory — see memory leaks\nleaks, resource —\nsee resource leaks\nlength_error class 66\nlhs, definition 6\nlibraries\nand exception specifications 75,\n76, 79\ndesign and implementation 110,\n113, 284, 286, 288\nimpact of modification 235\ninheriting from 269–270\nlibrary, C++ standard — see stan-\ndard C++ library\nlifetime of temporary objects 278\nlimitations on type conversion \nsequences 29, 31, 172, 175, 226\nlimiting object instantiations 130–\n145\nlinkage\nC 272\ninternal 134\nlinkers, and overloading 271\nLisp 93, 230, 271\nlist template 4, 51, 124, 125, 154,\n283\nlocality of reference 96, 97\nlocalization, support in standard \nC++ library 278\nlogic_error class 66\nlongjmp\nand destructors 47\nand setjmp, vs. exceptions 45\nLSD 287\nlvalue, definition 217\nlying to compilers 241\nM\nmagazines, recommended 289\nmain 251, 273, 274\nmaintenance 57, 91, 107, 179, 211,\n227, 253, 267, 270, 273\nand RTTI 232\nmake_pair template 247\nmalloc 39, 42, 275\nand constructors 39\nand operator new 39\nmap template 4, 95, 237, 246, 283\nmember data —\nsee data members\n\n\n304\n General Index\nmember functions\nand compatibility of C++ and C \nstructs 276\nconst 89, 160, 218\ninvocation through proxies 226\npointers to 240\nmember initialization lists 58\nand ?: vs. if/then 56\nand try and catch 56\nmember templates 165\nand assigning smart \npointers 180\nand copying smart pointers 180\napproximating 294\nfor type conversions 175–179\nportability of 179\nmemory allocation 112\nfor basic_string class 280\nfor heap arrays 42–43\nfor heap objects 38\nin C++ vs. C 275\nmemory leaks 6, 7, 42, 145\nsee also resource leaks\nmemory management, \ncustomizing 38–43\nmemory values, after calling oper-\nator new 38\nmemory, shared 40\nmemory-mapped I/O 40\nmessage dispatch —\nsee multiple dispatch\nmigrating from C to C++ 286\nmixed-type assignments 260, 261\nprohibiting 263–265\nmixed-type comparisons 169\nmixin classes 154\nmixing code\nC++ and C 270–276\nwith and without exception \nspecifications 75\nmulti-dimensional arrays 213–217\nmulti-methods 230\nmultiple dispatch 230–251\nmultiple inheritance 153\nand object addresses 241\nand vptrs and vtbls 118–120\nmutable 88–90\nN\nNackman, Lee R. 288\nname function 238\nname mangling 271–273\nnamed objects 109\nand optimization 104\nvs. temporary objects 109\nnamespaces 132, 144\nand the standard C++ library 280\nstd 261\nunnamed 246, 247\nnested classes, and \ninheritance 197\nnew language features, \nsummary 277\nnew operator 37, 38, 42\nand bad_alloc 75\nand operator new and \nconstructors 39, 40\nand operator new[] and \nconstructors 43\nnew, placement —\nsee placement new\nnewsgroups, recommended 289\nNewton, allusion to 41\nnon-member functions, acting \nvirtual 128–129\nnull pointers\nand dynamic_cast 70\nand strlen 35\nand the STL 281\ndeleting 52\ndereferencing 10\nin smart pointers 167\ntesting for 10\nnull references 9–10\nnumeric applications 90, 279\nO\nobjects\naddresses 241\nallowing exactly one 130–134\nand virtual functions 118\nas function return type 99\nassignments through \npointers 259, 260\n\n\nGeneral Index\n305\nconstructing on top of one \nanother 287\nconstruction, lazy 88–90\ncontexts for construction 136\ncopying, and exceptions 62–63,\n68\ncounting instantiations 141–145\ndeleting 173\ndetermining location via address \ncomparisons 150–152\ndetermining whether on the \nheap 147–157\ninitialization 39, 88, 237\nlimiting the number of 130–145\nlocations 151\nmemory layout diagrams 116,\n119, 120, 242\nmodifying when thrown 63\nnamed — see named objects\nownership 162, 163–165, 183\npartially constructed 53\npreventing instantiations 130\nprohibiting from heap 157–158\nproxy — see proxy objects\nrestricting to heap 145–157\nsize, and cache hit rate 98\nsize, and paging behavior 98\nstatic — see static objects\nsurrogate 217\ntemporary — see temporary \nobjects\nunnamed — see temporary \nobjects\nusing dynamic_cast to find the \nbeginning 155\nusing to prevent resource \nleaks 47–50, 161\nvs. pointers, in classes 147\nOn Beyond Zebra, allusion to 168\noperatordelete 37, 41, 84, 113,\n173\nand efficiency 97\nand inheritance 158\noperator delete[] 37, 84\nand delete operator and \ndestructors 43\nprivate 157\noperator new 37, 38, 69, 70, 84,\n113, 149\nand bad_alloc 75\nand constructors 39, 149–150\nand efficiency 97\nand exceptions 52\nand inheritance 158\nand malloc 39\nand new operator and \nconstructors 40\ncalling directly 39\noverloading at global scope 43,\n153\nprivate 157\nvalues in memory returned \nfrom 38\noperator new[] 37, 42, 84, 149\nand bad_alloc 75\nand new operator and \nconstructors 43\nprivate 157\noperator overloading, purpose 38\noperator void* 168–169\noperator! 37\nin iostream classes 170\nin smart pointers classes 169\noperator!= 37\noperator% 37\noperator%= 37\noperator& 37, 74, 223\noperator&& 35–36, 37\noperator&= 37\noperator() 37, 215\noperator* 37, 101, 103, 104, 107\nand null smart pointers 167\nand STL iterators 96\nas const member function 160\noperator*= 37, 107, 225\noperator+ 37, 91, 100, 107, 109\ntemplate for 108\noperator++ 31–34, 37, 225\ndouble application of 33\nprefix vs. postfix 34\noperator+= 37, 107, 109, 225\noperator, 36–37\noperator- 37, 107\ntemplate for 108\noperator-= 37, 107\n\n\n306\n General Index\noperator-> 37\nand STL iterators 96\nas const member function 160\noperator->* 37\noperator-- 31–34, 37, 225\ndouble application of 33\nprefix vs. postfix 34\noperator. 37\nand proxy objects 226\noperator.* 37\noperator/ 37, 107\noperator/= 37, 107\noperator:: 37\noperator< 37\noperator<< 37, 112, 129\nwhy a member function 128\noperator<<= 37, 225\noperator<= 37\noperator= 37, 107, 268\nand classes with pointers 200\nand derived classes 263\nand inheritance 259–265\nand mixed-type \nassignments 260, 261, 263–\n265\nand non-const parameters 165\nand partial assignments 259,\n263–265\nand smart pointers 205\nvirtual 259–262\noperator== 37\noperator> 37\noperator>= 37\noperator>> 37\noperator>>= 37\noperator?: 37, 56\noperator[] 11, 37, 216\nconst vs. non-const 218\ndistinguishing lvalue and rvalue \nuse 87, 217–223\noperator[][] 214\noperator^ 37\noperator^= 37\noperator| 37\noperator|= 37\noperator|| 35–36, 37\noperator~ 37\noperators\nimplicit type conversion — see \ntype conversion operators\nnot overloadable 37\noverloadable 37\nreturning pointers 102\nreturning references 102\nstand-alone vs. assignment \nversions 107–110\noptimization\nand profiling data 84\nand return expressions 104\nand temporary objects 104\nof exceptions 64\nof reference counting 187\nof vptrs under multiple \ninheritance 120\nreturn value — see return value \noptimization\nvia valarray objects 279\nsee also efficiency\norder of examination of catch\nclauses 67–68\nOuija boards 83\nout_of_range class 66\nover-eager evaluation 94–98\noverflow_error class 66\noverloadable operators 37\noverloading\nand enums 277\nand function pointers 243\nand linkers 271\nand user-defined types 106\noperatornew/delete at global \nscope 43, 153\nresolution of function calls 233\nrestrictions 106\nto avoid type conversions 105–\n107\nownership of objects 162, 183\ntransferring 163–165\nP\npair template 246\nparameters\npassing, vs. throwing \nexceptions 62–67\nunused 33, 40\n\n\nGeneral Index\n307\npartial assignments 259, 263–265\npartial computation 91\npartially constructed objects, and \ndestructors 53\npass-by-pointer 65\npass-by-reference\nand auto_ptrs 165\nand const 100\nand temporary objects 100\nand the STL 282\nand type conversions 100\nefficiency, and exceptions 65\nimplementation 242\npass-by-value\nand auto_ptrs 164\nand the STL 282\nand virtual functions 70\nefficiency, and exceptions 65\npassing exceptions, choices 68\npatterns 123, 288\nPavlov, allusion to 81\nperformance — see efficiency\nplacement new 39–40\nand array initialization 20–21\nand delete operator 42\npointer arithmetic\nand array indexing 17\nand inheritance 17–18\npointers\nand object assignments 259, 260\nand proxy objects 223\nand virtual functions 118\nas parameters — see pass-by-\npointer\nassignment 11\nconstant 55\ndereferencing when null 10\ndetermining whether they can be \ndeleted 152–157\ndumb 159\nimplications for copy construc-\ntors and assignment \noperators 200\ninitialization 10, 55–56\ninto arrays 280\nnull — see null pointers\nreplacing dumb with smart 207\nreturning from operators 102\nsmart — see smart pointers\ntesting for nullness 10\nto functions 15, 241, 243\nto member functions 240\nvs. iterators 284\nvs. objects, in classes 147\nvs. references 9–11\nwhen to use 11\npolymorphism, definition 16\nPoor Richard’s Almanac, allusion \nto 75\nportability\nand non-standard functions 275\nof casting function pointers 15\nof determining object \nlocations 152, 158\nof dynamic_cast to void* 156\nof member templates 179\nof passing data between C++ and \nC 275\nof reinterpret_cast 14\nof static initialization and \ndestruction 274\nprefetching 96–98\npreventing object instantiation 130\nprinciple of least astonishment 254\nprintf 112\npriority_queue template 283\nprivate inheritance 143\nprofiling — see program profiling\nprogram profiling 84–85, 93, 98,\n112, 212\nprogramming in the future \ntense 252–258\nprotected constructors and \ndestructors 142\nproxy classes 31, 87, 190, 194, 213–\n228\ndefinition 217\nlimitations 223–227\nsee also proxy objects\nproxy objects\nand ++, --, +=, etc. 225\nand member function \ninvocations 226\nand operator. 226\nand pointers 223\nas temporary objects 227\npassing to non-const reference \nparameters 226\nsee also proxy classes\n\n\n308\n General Index\npseudo-constructors 138, 139, 140\npseudo-destructors 145, 146\npure virtual destructors 195, 265\npure virtual functions —\nsee virtual functions\nPython, Monty, allusion to 62\nQ\nqueue template 4, 283\nR\nrange_error class 66\nrecommended reading\nbooks 285–289\nmagazines 289\non exceptions 287\nUsenet newsgroups 289\nrecompilation, impact of 234, 249\nreference counting 85–87, 171,\n183–213, 286\nand efficiency 211\nand read-only types 208–211\nand shareability 192–194\nassignments 189\nautomating 194–203\nbase class for 194–197\nconstructors 187–188\ncost of reads vs. writes 87, 217\ndesign diagrams 203, 208\ndestruction 188\nimplementation of String\nclass 203–207\noperator[] 190–194\noptimization 187\npros and cons 211–212\nsmart pointer for 198–203\nwhen appropriate 212\nreferences\nand constructors 165\nand virtual functions 118\nas operator[] return type 11\nas parameters — see pass-by-\nreference\nassignment 11\nimplementation 242\nmandatory initialization 10\nnull 9–10\nreturning from operators 102\nto locals, returning 103\nvs. pointers 9–11\nwhen to use 11\nrefined return type of virtual \nfunctions 126\nreinterpret_cast 14–15, 37,\n241\nrelationships\namong delete operator, opera-\ntor delete, and \ndestructors 41\namong delete operator, opera-\ntor delete[], and \ndestructors 43\namong new operator, operator\nnew, and constructors 40\namong new operator, operator\nnew[], and constructors 43\namong operator+, operator=,\nand operator+= 107\nbetween operator new and \nbad_alloc 75\nbetween operator new[] and \nbad_alloc 75\nbetween terminate and \nabort 72\nbetween the new operator and \nbad_alloc 75\nbetween unexpected and \nterminate 72\nreplication of code 47, 54, 142, 204,\n223, 224\nreplication of data under multiple \ninheritance 118–120\nreporting bugs in this book 8\nresolution of calls to overloaded \nfunctions 233\nresource leaks 46, 52, 69, 102, 137,\n149, 173, 240\nand exceptions 45–58\nand smart pointers 159\ndefinition 7\nin constructors 52, 53\npreventing via use of objects 47–\n50, 58, 161\nvs. memory leaks 7\nrestrictions on classes with default \nconstructors 19–22\n\n\nGeneral Index\n309\nrethrowing exceptions 64\nreturn expression, and \noptimization 104\nreturn types\nand temporary objects 100–104\nconst 33–34, 101\nobjects 99\nof operator-- 32\nof operator++ 32\nof operator[] 11\nof smart pointer dereferencing \noperators 166\nof virtual functions 126\nreferences 103\nreturn value optimization 101–104,\n109\nreuse — see code reuse\nrhs, definition 6\nrights and responsibilities 213\nRitchie, Dennis M. 36\nRomeo and Juliet, allusion to 166\nRTTI 6, 261–262\nand maintenance 232\nand virtual functions 120, 256\nand vtbls 120\nimplementation 120–121\nvs. virtual functions 231–232\nruntime type identification —\nsee RTTI\nruntime_error class 66\nrvalue, definition 217\nS\nsafe casts 14\nScarlet Letter, The, allusion to 232\nScientific and Engineering C++ 288\nsemantics of function calls 35–36\nsequences of type conversions 29,\n31, 172, 175, 226\nset template 4, 283\nset_unexpected function 76\nsetiosflags, example use 111\nsetjmp and longjmp, vs. \nexceptions 45\nsetprecision, example use 111\nsetw, example uses 99, 111\nshared memory 40\nsharing values 86\nsee also reference counting\nshort-circuit evaluation 35, 36\nsingle-argument constructors — \nsee constructors\nsizeof 37\nslicing problem 70, 71\nsmart pointers 47, 90, 159–182,\n240, 282\nand const 179–182\nand distributed systems 160–162\nand inheritance 163, 173–179\nand member templates 175–182\nand resource leaks 159, 173\nand virtual constructors 163\nand virtual copy \nconstructors 202\nand virtual functions 166\nassignments 162–165, 180\nconstruction 162\nconversion to dumb \npointers 170–173\ncopying 162–165, 180\ndebugging 182\ndeleting 173\ndestruction 165–166\nfor reference counting 198–203\noperator* 166–167\noperator-> 166–167\nreplacing dumb pointers 207\ntesting for nullness 168–170, 171\nSpanish, gratuitous use of 232\nsqrt function 65\nstack objects — see objects\nstack template 4, 283\nstandard C library 278\nstandard C++ library 1, 4–5, 11, 48,\n51, 280\nand code reuse 5\ndiagnostics classes 66\nsummary of features 278–279\nuse of templates 279–280\nsee also Standard Template \nLibrary\nStandard Template Library 4–5,\n95–96, 280–284\nand pass-by-reference 282\nand pass-by-value 282\nconventions 284\n\n\n310\n General Index\nexample uses — see example\nuses\nextensibility 284\nfree implementation 4\niterators and operator-> 96\nstandardization committee —\nsee ANSI/ISO standardization \ncommittee\nStar Wars, allusion to 31\nstatic destruction 273–275\nstatic initialization 273–275\nstatic objects 151\nand inlining 134\nat file scope 246\nin classes vs. in functions 133–\n134\nin functions 133, 237\nwhen initialized 133\nstatic type vs. dynamic type 5–6\nwhen copying 63\nstatic_cast 13, 14, 15, 37\nstd namespace 261\nand standard C++ library 280\nstdio, vs. iostreams 110–112\nSTL — see Standard Template \nLibrary\nstrdup 275\nstring class 27, 279–280\nc_str member function 27\ndestructor 256\nString class —\nsee reference counting\nstring objects, vs. char*s 4\nstringstream class 278\nstrlen, and null pointer 35\nstrong typing, bypassing 287\nStroustrup, Bjarne 285, 286\nstrstream class 278\nstructs\ncompatibility between C++ and \nC 276\nprivate 185\nsummaries\nof efficiency costs of various lan-\nguage features 121\nof new language features 277\nof standard C++ library 278–279\nsuppressing\ntype conversions 26, 28–29\nwarnings for unused \nparameters 33, 40\nSurgeon General’s tobacco warn-\ning, allusion to 288\nsurrogates 217\nSusann, Jacqueline 228\nsystem calls 97\nT\ntemplates 286, 288\nand “>>”, vs. “> >” 29\nand default constructors 22\nand exception specifications 73–\n74\nand pass-by-reference 282\nand pass-by-value 282\nand static data members 144\nfor operator+ and operator-\n108\nin standard C++ library 279–280\nmember — see member tem-\nplates\nrecent extensions 277\nspecializing 175\nvs. template instantiations 7\ntemporary objects 34, 64, 98–101,\n105, 108, 109\nand efficiency 99–101\nand exceptions 68\nand function return types 100–\n104\nand optimization 104\nand pass-by-reference 100\nand type conversions 99–100\ncatching vs. parameter \npassing 65\neliminating 100, 103–104\nlifetime of 278\nvs. named objects 109\nterminate 72, 76\nterminology used in this book 5–8\nthis, deleting 145, 152, 157, 197,\n213\nthrow\nby pointer 70\ncost of executing 63, 79\nmodifying objects thrown 63\nto rethrow current exception 64\n\n\nGeneral Index\n311\nvs. parameter passing 62–67\nsee also catch\ntransforming concrete classes into \nabstract 266–269\ntrue 3\ntry blocks 56, 79\ntype conversion functions 25–31\nvalid sequences of 29, 31, 172,\n175, 226\ntype conversion operators 25, 26–\n27, 49, 168\nand smart pointers 175\nvia member templates 175–179\ntype conversions 66, 220, 226\nand exceptions 66–67\nand function pointers 241\nand pass-by-reference 100\nand temporary objects 99–100\navoiding via overloading 105–107\nimplicit 66, 99\nsuppressing 26, 28–29\nvia implicit conversion \noperators 25, 26–27, 49\nvia single-argument \nconstructors 27–31\ntype errors, detecting at \nruntime 261–262\ntype system, bypassing 287\ntype_info class 120, 121, 261\nname member function 238\ntypeid 37, 120, 238\ntypes, static vs. dynamic 5–6\nwhen copying 63\nU\nundefined behavior\ncalling strlen with null \npointer 35\ndeleting memory not returned by \nnew 21\ndeleting objects twice 163, 173\ndereferencing null pointers 10,\n167\ndereferencing pointers beyond \narrays 281\nmixing new/free or malloc/\ndelete 275\nunexpected 72, 74, 76, 77, 78\nunexpected exceptions 70\nhandling 75–77\nreplacing with other \nexceptions 76\nsee also unexpected\nUnicode 279\nunion, using to avoid unnecessary \ndata 182\nunnamed namespaces 246, 247\nunnamed objects —\nsee temporary objects\nunused parameters, suppressing \nwarnings about 33, 40\nUrbano, Nancy L. — see Clancy\nURL for this book 8, 287\nuse counting 185\nsee also reference counting\nuseful abstractions 267\nUsenet newsgroups, \nrecommended 289\nuser-defined conversion functions \n— see type conversion functions\nuser-defined types\nand overloaded operators 106\nconsistency with built-ins 254\nusing declarations 133, 143\nV\nvalarray class 279, 280\nvalues, as parameters —\nsee pass-by-value\nvector template 4, 11, 22, 283\nvirtual base classes 118–120, 154\nand default constructors 22\nand object addresses 241\nvirtual constructors 46, 123–127\nand smart pointers 163\ndefinition 126\nexample uses 46, 125\nvirtual copy constructors 126–127\nand smart pointers 202\nvirtual destructors 143, 254–257\nand delete 256\nsee also pure virtual destructors\nvirtual functions\n“demand-paged” 253\nand dynamic_cast 14, 156\nand efficiency 113–118\n\n\n312\n General Index\nand exceptions 79\nand mixed-type \nassignments 260, 261\nand pass/catch-by-reference 72\nand pass/catch-by-value 70\nand RTTI 120, 256\nand smart pointers 166\ndesign challenges 248\nefficiency 118\nimplementation 113–118\npure 154, 265\nrefined return type 126, 260\nvs. catch clauses 67\nvs. RTTI 231–232\nvtbl index 117\n“virtual” non-member \nfunctions 128–129\nvirtual table pointers — see vptrs\nvirtual tables — see vtbls\nVlissides, John 288\nvoid*, dynamic_cast to 156\nvolatileness, casting away 13\nvptrs 113, 116, 117, 256\nand efficiency 116\neffective overhead of 256\noptimization under multiple \ninheritance 120\nvtbls 113–116, 117, 121, 256\nand abstract classes 115\nand inline virtual \nfunctions 115\nand RTTI 120\nemulating 235–251\nheuristic for generating 115\nW\nwarnings, suppressing\nfor unused parameters 33, 40\nwhat function 70, 71\nwide characters 279\nWorld Wide Web URL for this \nbook 8, 287\nY\nYiddish, gratuitous use of 32\n",
      "page_number": 320,
      "chapter_number": 32,
      "summary": "This chapter covers segment 32 (pages 320-329). Key topics include classes, object, and operator. 288\nname function 238\nname mangling 271–273\nnamed objects 109\nand optimization 104\nvs.",
      "keywords": [
        "operator",
        "virtual functions",
        "objects",
        "General Index",
        "pointers",
        "functions",
        "smart pointers",
        "virtual",
        "Standard Template Library",
        "type",
        "function",
        "temporary objects",
        "type conversion operators",
        "General Index operator",
        "Template"
      ],
      "concepts": [
        "classes",
        "object",
        "operator",
        "function",
        "functions",
        "pointers",
        "templates",
        "type",
        "typing",
        "virtual"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.8,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 32,
          "title": "Segment 32 (pages 1015-1044)",
          "relevance_score": 0.79,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 15,
          "title": "Segment 15 (pages 456-487)",
          "relevance_score": 0.77,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 21,
          "title": "Segment 21 (pages 651-684)",
          "relevance_score": 0.77,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 25,
          "title": "Segment 25 (pages 784-814)",
          "relevance_score": 0.77,
          "method": "api"
        }
      ]
    },
    {
      "number": 33,
      "title": "Segment 33 (pages 330-335)",
      "start_page": 330,
      "end_page": 335,
      "detection_method": "topic_boundary",
      "content": "Index of Example Classes,\nFunctions, and Templates\nClasses and Class Templates\nAbstractAnimal 264\nALA 46\nAnimal 258, 259, 263, 265\nArray 22, 27, 29, 30, 225\nArray::ArraySize 30\nArray::Proxy 225\nArray2D 214, 215, 216\nArray2D::Array1D 216\nAsset 147, 152, 156, 158\nAsteroid 229\nAudioClip 50\nB 255\nBalancedBST 16\nBookEntry 51, 54, 55, 56, 57\nBST 16\nC1 114\nC2 114\nCallBack 74\nCantBeInstantiated 130\nCassette 174\nCasSingle 178\nCD 174\nChicken 259, 260, 263, 265\nCollisionMap 249\nCollisionWithUnknownObject\n231\nColorPrinter 136\nCounted 142\nCPFMachine 136\nD 255\nDataCollection 94\nDBPtr 160, 171\nDynArray 96\nEquipmentPiece 19, 23\nFSA 137\nGameObject 229, 230, 233, 235,\n242\nGraphic 124, 126, 128, 129\nHeapTracked 154\nHeapTracked::MissingAddress\n154\nImage 50\nKitten 46\nLargeObject 87, 88, 89\nLizard 259, 260, 262, 263, 265\nLogEntry 161\nMatrix 90\nMusicProduct 173\nName 25\nNewsLetter 124, 125, 127\nNLComponent 124, 126, 128, 129\nNonNegativeUPNumber 146,\n147, 158\nPhoneNumber 50\nPrinter 130, 132, 135, 138,\n140, 141, 143, 144\nPrinter::TooManyObjects\n135, 138, 140\nPrintingStuff::Printer 132\nPrintJob 130, 131\nPuppy 46\nRational 6, 25, 26, 102, 107,\n225\nRCIPtr 209\nRCObject 194, 204\n\n\n314\n Examples Index\nRCPtr 199, 203\nRCWidget 210\nRegisterCollisionFunction\n250\nSatellite 251\nSession 59, 77\nSmartPtr 160, 168, 169, 176,\n178, 181\nSmartPtr<Cassette> 175\nSmartPtr<CD> 175\nSmartPtrToConst 181\nSpaceShip 229, 230, 233, 235,\n236, 238, 239, 240, 243\nSpaceStation 229\nSpecialWidget 13, 63\nSpecialWindow 269\nString 85, 183, 186, 187, 188,\n189, 190, 193, 197, 198, 200,\n201, 204, 218, 219, 224\nString::CharProxy 219, 224\nString::SpecialStringValue\n201\nString::StringValue 186,\n193, 197, 200, 201, 204\nTextBlock 124, 126, 128, 129\nTuple 161, 170\nTupleAccessors 172\nTVStation 226\nUnexpectedException 76\nUPInt 32, 105\nUPNumber 146, 147, 148, 157,\n158\nUPNumber::\nHeapConstraintViolation\n148\nValidation_error 70\nWidget 6, 13, 40, 61, 63, 210\nWindow 269\nWindowHandle 49\nFunctions and Function \nTemplates\nAbstractAnimal::\n~AbstractAnimal 264\noperator= 264\nALA::processAdoption 46\nallocateSomeObjects 151\nAnimal::operator= 258, 259,\n263, 265\nArray::\nArray 22, 27, 29, 30\noperator[] 27\nArray::ArraySize::\nArraySize 30\nsize 30\nArray<T>::Proxy::\noperator T 225\noperator= 225\nProxy 225\nArray2D::\nArray2D 214\noperator() 215\noperator[] 216\nAsset::\n~Asset 147\nAsset 147, 158\nasteroidShip 245\nasteroidStation 245, 250\nAudioClip::AudioClip 50\nBookEntry::\n~BookEntry 51, 55, 58\nBookEntry 51, 54, 55, 56, 58\ncleanup 54, 55\ninitAudioClip 57\ninitImage 57\nC1::\n~C1 114\nC1 114\nf1 114\nf2 114\nf3 114\nf4 114\nC2::\n~C2 114\nC2 114\nf1 114\nf5 114\nCallBack::\nCallBack 74\nmakeCallBack 74\ncallBackFcn1 75\ncallBackFcn2 75\n\n\nExamples Index\n315\nCantBeInstantiated::\nCantBeInstantiated 130\nCassette::\nCassette 174\ndisplayTitle 174\nplay 174\nCD::\nCD 174\ndisplayTitle 174\nplay 174\ncheckForCollision 229\nChicken::operator= 259,\n260, 263, 265\nCollisionMap::\naddEntry 249\nCollisionMap 249\nlookup 249\nremoveEntry 249\ntheCollisionMap 249\nCollisionWithUnknownObject::\nCollisionWithUnknownObject\n231\nconstructWidgetInBuffer 40\nconvertUnexpected 76\ncountChar 99\nCounted::\n~Counted 142\nCounted 142\ninit 142\nobjectCount 142\nDataCollection::\navg 94\nmax 94\nmin 94\nDBPtr<T>::\nDBPtr 160, 161\noperator T* 171\ndeleteArray 18\ndisplayAndPlay 174, 177, 178\ndisplayInfo 49, 50\ndoSomething 69, 71, 72\ndrawLine 271, 272, 273\nDynArray::operator[] 97\neditTuple 161, 167\nEquipmentPiece::\nEquipmentPiece 19\nf 3, 66\nf1 61, 73\nf2 61, 73\nf3 61\nf4 61\nf5 61\nfind 281, 282, 283\nfindCubicleNumber 95\nfreeShared 42\nFSA::\nFSA 137\nmakeFSA 137\nGameObject::collide 230,\n233, 235, 242\nGraphic::\nclone 126\noperator<< 128\nprint 129\nHeapTracked::\n~HeapTracked 154, 155\nisOnHeap 154, 155\noperator delete 154, 155\noperator new 154, 155\nImage::Image 50\ninitializeCollisionMap\n245, 246\ninventoryAsset 156\nisSafeToDelete 153\nKitten::processAdoption 46\nLargeObject::\nfield1 87, 88, 89, 90\nfield2 87, 88\nfield3 87, 88\nfield4 87, 88\nfield5 87\nLargeObject 87, 88, 89\nLizard::operator= 259, 260,\n261, 262, 263, 264, 265\nLogEntry::\n~LogEntry 161\nLogEntry 161\nlookup 245, 247\nmain 111, 251, 274\nmakeStringPair 245, 246\nmallocShared 42\nmerge 172\n\n\n316\n Examples Index\nMusicProduct::\ndisplayTitle 173\nMusicProduct 173\nplay 173\nName::Name 25\nNewsLetter::\nNewsLetter 125, 127\nreadComponent 125\nNLComponent::\nclone 126\noperator<< 128\nprint 129\nnormalize 170\nonHeap 150\noperator delete 41, 153\noperator new 38, 40, 153\noperator* 102, 103, 104\noperator+ 100, 105, 106, 107,\n108, 109\noperator- 107, 108\noperator<< 129\noperator= 6\noperator== 27, 31, 73\noperator>> 62\npassAndThrowWidget 62, 63\nprintBSTArray 17\nprintDouble 10\nPrinter::\n~Printer 135, 138, 143\nmakePrinter 138, 139, 140,\n143\nperformSelfTest 130, 139,\n143\nPrinter 131, 132, 135, 139,\n140, 143\nreset 130, 139, 143\nsubmitJob 130, 139, 143\nthePrinter 132\nPrintingStuff::Printer::\nperformSelfTest 132\nPrinter 133\nreset 132\nsubmitJob 132\nPrintingStuff::thePrinter\n132, 133\nPrintJob::PrintJob 131\nprintTreeNode 164, 165\nprocessAdoptions 46, 47, 48\nprocessCollision 245\nprocessInput 213, 214\nprocessTuple 171\nPuppy::processAdoption 46\nrangeCheck 35\nRational::\nasDouble 26\ndenominator 102, 225\nnumerator 102, 225\noperator double 25\noperator+= 107\noperator-= 107\nRational 25, 102, 225\nRCIPtr::\n~RCIPtr 209\nCountHolder 209\ninit 209\noperator* 209, 210\noperator= 209, 210\noperator-> 209, 210\nRCIPtr 209\nRCIPtr::CountHolder::\n~CountHolder 209\nRCObject::\n~RCObject 194, 204, 205\naddReference 195, 204, 205\nisShareable 195, 204, 205\nisShared 195, 204, 205\nmarkUnshareable 195, 204,\n205\noperator= 194, 195, 204, 205\nRCObject 194, 195, 204, 205\nremoveReference 195, 204,\n205\nRCPtr::\n~RCPtr 199, 202, 203, 206\ninit 199, 200, 203, 206\noperator* 199, 203, 206\noperator= 199, 202, 203, 206\noperator-> 199, 203, 206\nRCPtr 199, 203, 206\n\n\nExamples Index\n317\nRCWidget::\ndoThis 210\nRCWidget 210\nshowThat 210\nrealMain 274\nRegisterCollisionFunction::\nRegisterCollisionFunction\n250\nrestoreAndProcessObject 88\nreverse 36\nsatelliteAsteroid 251\nsatelliteShip 251\nSession::\n~Session 59, 60, 61, 77\nlogCreation 59\nlogDestruction 59, 77\nSession 59, 61\nshipAsteroid 245, 248, 250\nshipStation 245, 250\nsimulate 272, 273\nSmartPtr<Cassette>::\noperator\nSmartPtr<MusicProduct>\n175\nSmartPtr<CD>::\noperator\nSmartPtr<MusicProduct>\n175\nSmartPtr<T>::\n~SmartPtr 160, 166\noperator SmartPtr<U> 176\noperator void* 168\noperator! 169\noperator* 160, 166, 176\noperator= 160\noperator-> 160, 167, 176\nSmartPtr 160, 176\nsomeFunction 68, 69, 71\nSpaceShip::\ncollide 230, 231, 233, 234,\n235, 237, 243\nhitAsteroid 235, 236, 243,\n244\nhitSpaceShip 235, 236, 243\nhitSpaceStation 235, 236,\n243\ninitializeCollisionMap\n239, 240, 241, 243\nlookup 236, 238, 239, 240\nSpecialWindow::\nheight 269\nrepaint 269\nresize 269\nwidth 269\nstationAsteroid 245\nstationShip 245\nString::\n~String 188\nmarkUnshareable 207\noperator= 183, 184, 189\noperator[]\n190,\n191,\n194,\n204, 207, 218, 219, 220,\n221\nString 183, 187, 188, 193,\n204, 207\nString::CharProxy::\nCharProxy 219, 222\noperator char 219, 222\noperator& 224\noperator= 219, 222, 223\nString::StringValue::\n~StringValue 186, 193, 197,\n204, 207\ninit 204, 206\nStringValue 186, 193, 197,\n201, 204, 206, 207\nswap 99, 226\ntestBookEntryClass 52, 53\nTextBlock::\nclone 126\noperator<< 128\nprint 129\nthePrinter 130, 131, 134\nTuple::\ndisplayEditDialog 161\nisValid 161\nTupleAccessors::\nTupleAccessors 172\nTVStation::TVStation 226\ntwiddleBits 272, 273\nupdate 13\nupdateViaRef 14\n\n\n318\n Examples Index\nUPInt::\noperator-- 32\noperator++ 32, 33\noperator+= 32\nUPInt 105\nUPNumber::\n~UPNumber 146\ndestroy 146\noperator delete 157\noperator new 148, 157\nUPNumber 146, 148\nuppercasify 100\nValidation_error::what 70\nwatchTV 227\nWidget::\n~Widget 210\ndoThis 210\noperator= 210\nshowThat 210\nWidget 40, 210\nWindow::\nheight 269\nrepaint 269\nresize 269\nwidth 269\nWindowHandle::\n~WindowHandle 49\noperator WINDOW_HANDLE 49\noperator= 49\nWindowHandle 49\n",
      "page_number": 330,
      "chapter_number": 33,
      "summary": "This chapter covers segment 33 (pages 330-335). Key topics include operator, printer, and processadoptions.",
      "keywords": [
        "operator",
        "SmartPtr",
        "Printer",
        "String",
        "Class Templates",
        "Index",
        "Templates",
        "Array",
        "Cassette",
        "operator delete",
        "MusicProduct",
        "UPNumber",
        "RCIPtr",
        "Classes",
        "Asset"
      ],
      "concepts": [
        "operator",
        "printer",
        "processadoptions",
        "session",
        "lookup",
        "string",
        "examples",
        "widget",
        "array",
        "rational"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "Segment 16 (pages 162-174)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 38,
          "title": "Segment 38 (pages 1211-1240)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 3,
          "title": "Segment 3 (pages 17-24)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 25,
          "title": "Segment 25 (pages 784-814)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 53,
          "title": "Segment 53 (pages 1697-1728)",
          "relevance_score": 0.64,
          "method": "api"
        }
      ]
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "chapter": null,
      "content": ">\n\nMore Effective C+\n\n35 New Ways\nto Improve }OGF\nPrograms@inig Designs\n\nScott MGVGTS\n\n‘=\n=\n4\nR\n03\nZ\nz\nvw\nJ\n-\n<\n~\nx\nmn\nwy\nyy\nz\n~\nZz\n>\na\nS\nc\nr\n=\nos\nies\n— |\nZz\ni)\ny\nnm\n2\nnm\nw”",
      "content_length": 173,
      "extraction_method": "OCR"
    },
    {
      "page_number": 2,
      "chapter": null,
      "content": "Praise for More Effective C++: 35 New Ways \nto Improve Your Programs and Designs\n“This is an enlightening book on many aspects of C++: both the regions of the \nlanguage you seldom visit, and the familiar ones you THOUGHT you understood. \nOnly by understanding deeply how the C++ compiler interprets your code can \nyou hope to write robust software using this language. This book is an invaluable \nresource for gaining that level of understanding. After reading this book, I feel like \nI've been through a code review with a master C++ programmer, and picked up \nmany of his most valuable insights.”\n— Fred Wild, Vice President of Technology, \nAdvantage Software Technologies\n“This book includes a great collection of important techniques for writing \nprograms that use C++ well. It explains how to design and implement the ideas, \nand what hidden pitfalls lurk in some obvious alternative designs. It also includes \nclear explanations of features recently added to C++. Anyone who wants to use \nthese new features will want a copy of this book close at hand for ready reference.”\n— Christopher J. Van Wyk, Professor, \nMathematics and Computer Science, Drew University\n“Industrial strength C++ at its best. The perfect companion to those who have \nread Effective C++.” \n— Eric Nagler, C++ Instructor and Author, \nUniversity of California Santa Cruz Extension\n“More Effective C++ is a thorough and valuable follow-up to Scott's first book, \nEffective C++. I believe that every professional C++ developer should read and \ncommit to memory the tips in both Effective C++ and More Effective C++. I've \nfound that the tips cover poorly understood, yet important and sometimes arcane \nfacets of the language. I strongly recommend this book, along with his first, to \ndevelopers, testers, and managers ... everyone can benefit from his expert \nknowledge and excellent presentation.”\n— Steve Burkett, Software Consultant\n",
      "content_length": 1912,
      "extraction_method": "Direct"
    },
    {
      "page_number": 3,
      "chapter": null,
      "content": "This page intentionally left blank \n",
      "content_length": 36,
      "extraction_method": "Direct"
    },
    {
      "page_number": 4,
      "chapter": null,
      "content": "More Effective C++\n",
      "content_length": 19,
      "extraction_method": "Direct"
    },
    {
      "page_number": 5,
      "chapter": null,
      "content": "Addison-Wesley Professional Computing Series\nBrian W. Kernighan, Consulting Editor \nMatthew H. Austern, Generic Programming and the STL: Using and Extending the C++ Standard Template Library\nDavid R. Butenhof, Programming with POSIX® Threads\nBrent Callaghan, NFS Illustrated\nTom Cargill, C++ Programming Style\nWilliam R. Cheswick/Steven M. Bellovin/Aviel D. Rubin, Firewalls and Internet Security, Second Edition: Repelling \nthe Wily Hacker\nDavid A. Curry, UNIX® System Security: A Guide for Users and System Administrators\nStephen C. Dewhurst, C++ Gotchas: Avoiding Common Problems in Coding and Design\nDan Farmer/Wietse Venema, Forensic Discovery\nErich Gamma/Richard Helm/Ralph Johnson/John Vlissides, Design Patterns: Elements of Reusable Object-\nOriented Software\nErich Gamma/Richard Helm/Ralph Johnson/John Vlissides, Design Patterns CD: Elements of Reusable Object-\nOriented Software \nPeter Haggar, Practical Java™Programming Language Guide\nDavid R. Hanson, C Interfaces and Implementations: Techniques for Creating Reusable Software\nMark Harrison/Michael McLennan, Effective Tcl/Tk Programming: Writing Better Programs with Tcl and Tk\nMichi Henning/Steve Vinoski, Advanced CORBA® Programming with C++\nBrian W. Kernighan/Rob Pike, The Practice of Programming\nS. Keshav, An Engineering Approach to Computer Networking: ATM Networks, the Internet, and the Telephone Network\nJohn Lakos, Large-Scale C++ Software Design\nScott Meyers, Effective C++ CD: 85 Specific Ways to Improve Your Programs and Designs\nScott Meyers, Effective C++, Third Edition: 55 Specific Ways to Improve Your Programs and Designs\nScott Meyers, More Effective C++: 35 New Ways to Improve Your Programs and Designs\nScott Meyers, Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library\nRobert B. Murray, C++ Strategies and Tactics\nDavid R. Musser/Gillmer J. Derge/Atul Saini, STL Tutorial and Reference Guide, Second Edition: \nC++ Programming with the Standard Template Library\nJohn K. Ousterhout, Tcl and the Tk Toolkit\nCraig Partridge, Gigabit Networking\nRadia Perlman, Interconnections, Second Edition: Bridges, Routers, Switches, and Internetworking Protocols\nStephen A. Rago, UNIX® System V Network Programming\nEric S. Raymond, The Art of UNIX Programming\nMarc J. Rochkind, Advanced UNIX Programming, Second Edition\nCurt Schimmel, UNIX® Systems for Modern Architectures: Symmetric Multiprocessing and Caching for Kernel Programmers\nW. Richard Stevens, TCP/IP Illustrated, Volume 1: The Protocols\nW. Richard Stevens, TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX®\nDomain Protocols\nW. Richard Stevens/Bill Fenner/Andrew M. Rudoff,  UNIX Network Programming Volume 1, Third Edition: The \nSockets Networking API\nW. Richard Stevens/Stephen A. Rago, Advanced Programming in the UNIX® Environment, Second Edition\nW. Richard Stevens/Gary R. Wright, TCP/IP Illustrated Volumes 1-3 Boxed Set\nJohn Viega/Gary McGraw, Building Secure Software: How to Avoid Security Problems the Right Way\nGary R. Wright/W. Richard Stevens, TCP/IP Illustrated, Volume 2: The Implementation\nRuixi Yuan/W. Timothy Strayer, Virtual Private Networks: Technologies and Solutions\nVisit www.awprofessional.com/series/professionalcomputing for more information about these titles.\n",
      "content_length": 3282,
      "extraction_method": "Direct"
    },
    {
      "page_number": 6,
      "chapter": null,
      "content": "More Effective C++\n35 New Ways to Improve Your Programs and Designs\nScott Meyers\nUpper Saddle River, NJ • Boston • Indianapolis • San Francisco\nNew York • Toronto • Montreal • London • Munich • Paris • Madrid\nCape Town • Sydney • Tokyo • Singapore • Mexico City\n",
      "content_length": 262,
      "extraction_method": "Direct"
    },
    {
      "page_number": 7,
      "chapter": null,
      "content": "Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. \nWhere those designations appear in this book, and the publisher was aware of a trademark claim, the designations have \nbeen printed with initial capital letters or in all capitals.\nThe authors and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of \nany kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential \ndamages in connection with or arising out of the use of the information or programs contained herein.\nThe publisher offers excellent discounts on this book when ordered in quantity for bulk purchases or special sales, which \nmay include electronic versions and/or custom covers and content particular to your business, training goals, marketing \nfocus, and branding interests. For more information, please contact:\nU.S. Corporate and Government Sales\n(800) 382-3419\ncorpsales@pearsontechgroup.com\nFor sales outside the United States please contact:\nInternational Sales\ninternational@pearsoned.com\nLibrary of Congress Cataloging-in-Publication Data\nMeyers, Scott (Scott Douglas)\nMore effective C++: 35 new ways to improve your programs and \ndesigns / Scott Meyers.\np.  cm. — (Addison-Wesley professional computing series)\nIncludes bibliographical references and index.\nISBN 0-201-63371-X (paperback: alk. paper)\n1. C++ (Computer program language)  I. Series.\nQA76.73.C153M495  1996\n005.13'3—dc20\n95–47354\n      CIP\nCopyright © 1996 by Addison-Wesley\nAll rights reserved. Printed in the United States of America. This publication is protected by copyright, and permission \nmust be obtained from the publisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in \nany form or by any means, electronic, mechanical, photocopying, recording, or likewise. For information regarding per-\nmissions, write to:\nPearson Education, Inc\nRights and Contracts Department\n501 Boylston Street, Suite 900\nBoston, MA 02116\nFax (617) 671-3447\nISBN-13: 978-0-201-63371-9\nISBN-10:\n0-201-63371-X\nText printed in the United States on recycled paper at Courier in Stoughton, Massachusetts.\nTwenty-fourth printing\nApril 2007\n",
      "content_length": 2272,
      "extraction_method": "Direct"
    },
    {
      "page_number": 8,
      "chapter": null,
      "content": "For Clancy,\nmy favorite enemy within.\n",
      "content_length": 38,
      "extraction_method": "Direct"
    },
    {
      "page_number": 9,
      "chapter": null,
      "content": "This page intentionally left blank \n",
      "content_length": 36,
      "extraction_method": "Direct"
    },
    {
      "page_number": 10,
      "chapter": null,
      "content": "Contents\nAcknowledgments\nxi\nIntroduction\n1\nBasics\n9\nItem 1:\nDistinguish between pointers and references.\n9\nItem 2:\nPrefer C++-style casts.\n12\nItem 3:\nNever treat arrays polymorphically.\n16\nItem 4:\nAvoid gratuitous default constructors.\n19\nOperators\n24\nItem 5:\nBe wary of user-defined conversion functions.\n24\nItem 6:\nDistinguish between prefix and postfix forms of \nincrement and decrement operators.\n31\nItem 7:\nNever overload &&, ||, or ,.\n35\nItem 8:\nUnderstand the different meanings of new\nand delete.\n38\nExceptions\n44\nItem 9:\nUse destructors to prevent resource leaks.\n45\nItem 10:\nPrevent resource leaks in constructors.\n50\nItem 11:\nPrevent exceptions from leaving destructors.\n58\nItem 12:\nUnderstand how throwing an exception differs from \npassing a parameter or calling a virtual function.\n61\nItem 13:\nCatch exceptions by reference.\n68\nItem 14:\nUse exception specifications judiciously.\n72\nItem 15:\nUnderstand the costs of exception handling.\n78\n",
      "content_length": 952,
      "extraction_method": "Direct"
    },
    {
      "page_number": 11,
      "chapter": null,
      "content": "x\nContents\nEfficiency\n81\nItem 16:\nRemember the 80-20 rule.\n82\nItem 17:\nConsider using lazy evaluation.\n85\nItem 18:\nAmortize the cost of expected computations.\n93\nItem 19:\nUnderstand the origin of temporary objects.\n98\nItem 20:\nFacilitate the return value optimization.\n101\nItem 21:\nOverload to avoid implicit type conversions.\n105\nItem 22:\nConsider using op= instead of stand-alone op.\n107\nItem 23:\nConsider alternative libraries.\n110\nItem 24:\nUnderstand the costs of virtual functions, multiple \ninheritance, virtual base classes, and RTTI.\n113\nTechniques\n123\nItem 25:\nVirtualizing constructors and non-member\nfunctions.\n123\nItem 26:\nLimiting the number of objects of a class.\n130\nItem 27:\nRequiring or prohibiting heap-based objects.\n145\nItem 28:\nSmart pointers.\n159\nItem 29:\nReference counting.\n183\nItem 30:\nProxy classes.\n213\nItem 31:\nMaking functions virtual with respect to more\nthan one object.\n228\nMiscellany\n252\nItem 32:\nProgram in the future tense.\n252\nItem 33:\nMake non-leaf classes abstract.\n258\nItem 34:\nUnderstand how to combine C++ and C in the\nsame program.\n270\nItem 35:\nFamiliarize yourself with the language standard.\n277\nRecommended Reading\n285\nAn auto_ptr Implementation\n291\nGeneral Index\n295\nIndex of Example Classes, Functions, and Templates\n313\n",
      "content_length": 1268,
      "extraction_method": "Direct"
    },
    {
      "page_number": 12,
      "chapter": null,
      "content": "Acknowledgments\nA great number of people helped bring this book into existence. Some\ncontributed ideas for technical topics, some helped with the process of\nproducing the book, and some just made life more fun while I was\nworking on it. \nWhen the number of contributors to a book is large, it is not uncom-\nmon to dispense with individual acknowledgments in favor of a ge-\nneric “Contributors to this book are too numerous to mention.” I\nprefer to follow the expansive lead of John L. Hennessy and David A.\nPatterson in Computer Architecture: A Quantitative Approach (Morgan\nKaufmann, first edition 1990). In addition to motivating the compre-\nhensive acknowledgments that follow, their book provides hard data\nfor the 90-10 rule, which I refer to in Item 16.\nThe Items\nWith the exception of direct quotations, all the words in this book are\nmine. However, many of the ideas I discuss came from others. I have\ndone my best to keep track of who contributed what, but I know I have\nincluded information from sources I now fail to recall, foremost among\nthem many posters to the Usenet newsgroups comp.lang.c++ and\ncomp.std.c++.\nMany ideas in the C++ community have been developed independently\nby many people. In what follows, I note only where I was exposed to\nparticular ideas, not necessarily where those ideas originated.\nBrian Kernighan suggested the use of macros to approximate the syn-\ntax of the new C++ casting operators I describe in Item 2.\nIn Item 3, my warning about deleting an array of derived class objects\nthrough a base class pointer is based on material in Dan Saks’ “Got-\nchas” talk, which he’s given at several conferences and trade shows.\n",
      "content_length": 1660,
      "extraction_method": "Direct"
    },
    {
      "page_number": 13,
      "chapter": null,
      "content": "xii\nAcknowledgments\nIn Item 5, the proxy class technique for preventing unwanted applica-\ntion of single-argument constructors is based on material in Andrew\nKoenig's column in the January 1994 C++ Report.\nJames Kanze made a posting to comp.lang.c++ on implementing\npostfix increment and decrement operators via the corresponding pre-\nfix functions; I use his technique in Item 6.\nDavid Cok, writing me about material I covered in Effective C++,\nbrought to my attention the distinction between operator new and the\nnew operator that is the crux of Item 8. Even after reading his letter, I\ndidn’t really understand the distinction, but without his initial prod-\nding, I probably still wouldn’t.\nThe notion of using destructors to prevent resource leaks (used in Item\n9) comes from section 15.3 of Margaret A. Ellis’ and Bjarne Strous-\ntrup’s The Annotated C++ Reference Manual (see page 285). There the\ntechnique is called resource acquisition is initialization. Tom Cargill\nsuggested I shift the focus of the approach from resource acquisition\nto resource release. \nSome of my discussion in Item 11 was inspired by material in Chapter\n4 of Taligent’s Guide to Designing Programs (Addison-Wesley, 1994).\nMy description of over-eager memory allocation for the DynArray class\nin Item 18 is based on Tom Cargill’s article, “A Dynamic vector is\nharder than it looks,” in the June 1992 C++ Report. A more sophisti-\ncated design for a dynamic array class can be found in Cargill’s follow-\nup column in the January 1994 C++ Report.\nItem 21 was inspired by Brian Kernighan’s paper, “An AWK to C++\nTranslator,” at the 1991 USENIX C++ Conference. His use of over-\nloaded operators (sixty-seven of them!) to handle mixed-type arith-\nmetic operations, though designed to solve a problem unrelated to the\none I explore in Item 21, led me to consider multiple overloadings as a\nsolution to the problem of temporary creation.\nIn Item 26, my design of a template class for counting objects is based\non a posting to comp.lang.c++ by Jamshid Afshar.\nThe idea of a mixin class to keep track of pointers from operator new\n(see Item 27) is based on a suggestion by Don Box. Steve Clamage\nmade the idea practical by explaining how dynamic_cast can be used\nto find the beginning of memory for an object.\nThe discussion of smart pointers in Item 28 is based in part on Steven\nBuroff’s and Rob Murray’s C++ Oracle column in the October 1993 C++\nReport; on Daniel R. Edelson’s classic paper, “Smart Pointers: They’re\nSmart, but They’re Not Pointers,” in the proceedings of the 1992\n",
      "content_length": 2555,
      "extraction_method": "Direct"
    },
    {
      "page_number": 14,
      "chapter": null,
      "content": "Acknowledgments\nxiii\nUSENIX C++ Conference; on section 15.9.1 of Bjarne Stroustrup’s The\nDesign and Evolution of C++ (see page 285); on Gregory Colvin’s “C++\nMemory Management” class notes from C/C++ Solutions ’95; and on\nCay Horstmann’s column in the March-April 1993 issue of the C++ Re-\nport. I developed some of the material myself, though. Really.\nIn Item 29, the use of a base class to store reference counts and of\nsmart pointers to manipulate those counts is based on Rob Murray’s\ndiscussions of the same topics in sections 6.3.2 and 7.4.2, respec-\ntively, of his C++ Strategies and Tactics (see page 286). The design for\nadding reference counting to existing classes follows that presented by\nCay Horstmann in his March-April 1993 column in the C++ Report.\nIn Item 30, my discussion of lvalue contexts is based on comments in\nDan Saks’ column in the C User’s Journal (now the C/C++ Users Jour-\nnal) of January 1993. The observation that non-proxy member func-\ntions are unavailable when called through proxies comes from an\nunpublished paper by Cay Horstmann.\nThe use of runtime type information to build vtbl-like arrays of func-\ntion pointers (in Item 31) is based on ideas put forward by Bjarne\nStroustrup in postings to comp.lang.c++ and in section 13.8.1 of his\nThe Design and Evolution of C++ (see page 285).\nThe material in Item 33 is based on several of my C++ Report columns\nin 1994 and 1995. Those columns, in turn, included comments I re-\nceived from Klaus Kreft about how to use dynamic_cast to implement\na virtual operator= that detects arguments of the wrong type.\nMuch of the material in Item 34 was motivated by Steve Clamage’s ar-\nticle, “Linking C++ with other languages,” in the May 1992 C++ Re-\nport. In that same Item, my treatment of the problems caused by\nfunctions like strdup was motivated by an anonymous reviewer.\nThe Book\nReviewing draft copies of a book is hard — and vitally important —\nwork. I am grateful that so many people were willing to invest their\ntime and energy on my behalf. I am especially grateful to Jill Huchital,\nTim Johnson, Brian Kernighan, Eric Nagler, and Chris Van Wyk, as\nthey read the book (or large portions of it) more than once. In addition\nto these gluttons for punishment, complete drafts of the manuscript\nwere read by Katrina Avery, Don Box, Steve Burkett, Tom Cargill,\nTony Davis, Carolyn Duby, Bruce Eckel, Read Fleming, Cay Horst-\nmann, James Kanze, Russ Paielli, Steve Rosenthal, Robin Rowe, Dan\nSaks, Chris Sells, Webb Stacy, Dave Swift, Steve Vinoski, and Fred\nWild. Partial drafts were reviewed by Bob Beauchaine, Gerd Hoeren,\n",
      "content_length": 2603,
      "extraction_method": "Direct"
    },
    {
      "page_number": 15,
      "chapter": null,
      "content": "xiv\nAcknowledgments\nJeff Jackson, and Nancy L. Urbano. Each of these reviewers made\ncomments that greatly improved the accuracy, utility, and presenta-\ntion of the material you find here.\nOnce the book came out, I received corrections and suggestions from\nmany people: Luis Kida, John Potter, Tim Uttormark, Mike Fulkerson,\nDan Saks, Wolfgang Glunz, Clovis Tondo, Michael Loftus, Liz Hanks, Wil\nEvers, Stefan Kuhlins, Jim McCracken, Alan Duchan, John Jacobsma,\nRamesh Nagabushnam, Ed Willink, Kirk Swenson, Jack Reeves, Doug\nSchmidt, Tim Buchowski, Paul Chisholm, Andrew Klein, Eric Nagler,\nJeffrey Smith, Sam Bent, Oleg Shteynbuk, Anton Doblmaier, Ulf\nMichaelis, Sekhar Muddana, Michael Baker, Yechiel Kimchi, David Pap-\nurt, Ian Haggard, Robert Schwartz, David Halpin, Graham Mark, David\nBarrett, Damian Kanarek, Ron Coutts, Lance Whitesel, Jon Lachelt,\nCheryl Ferguson, Munir Mahmood, Klaus-Georg Adams, David Goh,\nChris Morley, Rainer Baumschlager, Christopher Tavares, Brian Ker-\nnighan, Charles Green, Mark Rodgers, Bobby Schmidt, Sivaramakrish-\nnan J., Eric Anderson, Phil Brabbin, Feliks Kluzniak, Evan McLean,\nKurt Miller, Niels Dekker, Balog Pal, Dean Stanton, William Mattison,\nChulsu Park, Pankaj Datta, John Newell, Ani Taggu, Christopher\nCreutzi, Chris Wineinger, Alexander Bogdanchikov, Michael Tegtmeyer,\nAharon Robbins, Davide Gennaro, Adrian Spermezan, Matthias Hof-\nmann, Chang Chen, John Wismar, Mark Symonds, Thomas Kim, Ita\nRyan, and Rice Yeh. Their suggestions allowed me to improve More Effec-\ntive C++ in updated printings (such as this one), and I greatly appreciate\ntheir help.\nDuring preparation of this book, I faced many questions about the\nemerging ISO/ANSI standard for C++, and I am grateful to Steve\nClamage and Dan Saks for taking the time to respond to my incessant\nemail queries.\nJohn Max Skaller and Steve Rumsby conspired to get me the HTML for\nthe draft ANSI C++ standard before it was widely available. Vivian Neou\npointed me to the Netscape WWW browser as a stand-alone HTML\nviewer under (16 bit) Microsoft Windows, and I am deeply grateful to the\nfolks at Netscape Communications for making their fine viewer freely\navailable on such a pathetic excuse for an operating system.\nBryan Hobbs and Hachemi Zenad generously arranged to get me a\ncopy of the internal engineering version of the MetaWare C++ compiler\nso I could check the code in this book using the latest features of the\nlanguage. Cay Horstmann helped me get the compiler up and running\nin the very foreign world of DOS and DOS extenders. Borland (now In-\nprise) provided a beta copy of their most advanced compiler, and Eric\nNagler and Chris Sells provided invaluable help in testing code for me\non compilers to which I had no access.\n",
      "content_length": 2739,
      "extraction_method": "Direct"
    },
    {
      "page_number": 16,
      "chapter": null,
      "content": "xv\nAcknowledgments\nWithout the staff at the Corporate and Professional Publishing Divi-\nsion of Addison-Wesley, there would be no book, and I am indebted to\nKim Dawley, Lana Langlois, Simone Payment, Marty Rabinowitz,\nPradeepa Siva, John Wait, and the rest of the staff for their encourage-\nment, patience, and help with the production of this work.\nChris Guzikowski helped draft the back cover copy for this book, and\nTim Johnson stole time from his research on low-temperature physics\nto critique later versions of that text.\nTom Cargill graciously agreed to make his C++ Report article on excep-\ntions (see page 287) available at the Addison-Wesley Internet site. \nThe People\nKathy Reed was responsible for my introduction to programming;\nsurely she didn’t deserve to have to put up with a kid like me. Donald\nFrench had faith in my ability to develop and present C++ teaching\nmaterials when I had no track record. He also introduced me to John\nWait, my editor at Addison-Wesley, an act for which I will always be\ngrateful. The triumvirate at Beaver Ridge — Jayni Besaw, Lorri Fields,\nand Beth McKee — provided untold entertainment on my breaks as I\nworked on the book. \nMy wife, Nancy L. Urbano, put up with me and put up with me and\nput up with me as I worked on the book, continued to work on the\nbook, and kept working on the book. How many times did she hear me\nsay we’d do something after the book was done? Now the book is\ndone, and we will do those things. She amazes me. I love her.\nFinally, I must acknowledge our puppy, Persephone, whose existence\nchanged our world forever. Without her, this book would have been\nfinished both sooner and with less sleep deprivation, but also with\nsubstantially less comic relief.\n",
      "content_length": 1729,
      "extraction_method": "Direct"
    },
    {
      "page_number": 17,
      "chapter": null,
      "content": "This page intentionally left blank \n",
      "content_length": 36,
      "extraction_method": "Direct"
    },
    {
      "page_number": 18,
      "chapter": null,
      "content": "Introduction\nIntroduction\nThese are heady days for C++ programmers. Commercially available\nless than a decade, C++ has nevertheless emerged as the language of\nchoice for systems programming on nearly all major computing plat-\nforms. Companies and individuals with challenging programming\nproblems increasingly embrace the language, and the question faced\nby those who do not use C++ is often when they will start, not if. Stan-\ndardization of C++ is complete, and the breadth and scope of the ac-\ncompanying library — which both dwarfs and subsumes that of C —\nmakes it possible to write rich, complex programs without sacrificing\nportability or implementing common algorithms and data structures\nfrom scratch. C++ compilers continue to proliferate, the features they\noffer continue to expand, and the quality of the code they generate con-\ntinues to improve. Tools and environments for C++ development grow\never more abundant, powerful, and robust. Commercial libraries all\nbut obviate the need to write code in many application areas.\nAs the language has matured and our experience with it has increased,\nour needs for information about it have changed. In 1990, people\nwanted to know what C++ was. By 1992, they wanted to know how to\nmake it work. Now C++ programmers ask higher-level questions: How\ncan I design my software so it will adapt to future demands? How can\nI improve the efficiency of my code without compromising its correct-\nness or making it harder to use? How can I implement sophisticated\nfunctionality not directly supported by the language? \nIn this book, I answer these questions and many others like them.\nThis book shows how to design and implement C++ software that is\nmore effective: more likely to behave correctly; more robust in the face\nof exceptions; more efficient; more portable; makes better use of lan-\nguage features; adapts to change more gracefully; works better in a\nmixed-language environment; is easier to use correctly; is harder to\nuse incorrectly. In short, software that’s just better.\n",
      "content_length": 2032,
      "extraction_method": "Direct"
    },
    {
      "page_number": 19,
      "chapter": null,
      "content": "2\nIntroduction\nThe material in this book is divided into 35 Items. Each Item summa-\nrizes accumulated wisdom of the C++ programming community on a\nparticular topic. Most Items take the form of guidelines, and the expla-\nnation accompanying each guideline describes why the guideline ex-\nists, what happens if you fail to follow it, and under what conditions it\nmay make sense to violate the guideline anyway.\nItems fall into several categories. Some concern particular language\nfeatures, especially newer features with which you may have little ex-\nperience. For example, Items 9 through 15 are devoted to exceptions.\nOther Items explain how to combine the features of the language to\nachieve higher-level goals. Items 25 through 31, for instance, describe\nhow to constrain the number or placement of objects, how to create\nfunctions that act “virtual” on the type of more than one object, how to\ncreate “smart pointers,” and more. Still other Items address broader\ntopics; Items 16 through 24 focus on efficiency. No matter what the\ntopic of a particular Item, each takes a no-nonsense approach to the\nsubject. In More Effective C++, you learn how to use C++ more effec-\ntively. The descriptions of language features that make up the bulk of\nmost C++ texts are in this book mere background information.\nAn implication of this approach is that you should be familiar with C++\nbefore reading this book. I take for granted that you understand\nclasses, protection levels, virtual and nonvirtual functions, etc., and I\nassume you are acquainted with the concepts behind templates and\nexceptions. At the same time, I don’t expect you to be a language ex-\npert, so when poking into lesser-known corners of C++, I always ex-\nplain what’s going on.\nThe C++ in More Effective C++\nThe C++ I describe in this book is the language specified by the 1998\nInternational Standard for C++. This means I may use a few features\nyour compilers don’t yet support. Don’t worry. The only “new” feature\nI assume you have is templates, and templates are now almost univer-\nsally available. I use exceptions, too, but that use is largely confined to\nItems 9 through 15, which are specifically devoted to exceptions. If you\ndon’t have access to a compiler offering exceptions, that’s okay. It\nwon’t affect your ability to take advantage of the material in the other\nparts of the book. Furthermore, you should read Items 9 through 15\neven if you don’t have support for exceptions, because those items ex-\namine issues you need to understand in any case.\nI recognize that just because the standardization committee blesses a\nfeature or endorses a practice, there’s no guarantee that the feature is\npresent in current compilers or the practice is applicable to existing\n",
      "content_length": 2740,
      "extraction_method": "Direct"
    },
    {
      "page_number": 20,
      "chapter": null,
      "content": "Introduction\n3\nenvironments. When faced with a discrepancy between theory (what\nthe committee says) and practice (what actually works), I discuss both,\nthough my bias is toward things that work. Because I discuss both,\nthis book will aid you as your compilers approach conformance with\nthe standard. It will show you how to use existing constructs to ap-\nproximate language features your compilers don’t yet support, and it\nwill guide you when you decide to transform workarounds into newly-\nsupported features.\nNotice that I refer to your compilers — plural. Different compilers im-\nplement varying approximations to the standard, so I encourage you to\ndevelop your code under at least two compilers. Doing so will help you\navoid inadvertent dependence on one vendor’s proprietary language\nextension or its misinterpretation of the standard. It will also help keep\nyou away from the bleeding edge of compiler technology, e.g., from new\nfeatures supported by only one vendor. Such features are often poorly\nimplemented (buggy or slow — frequently both), and upon their intro-\nduction, the C++ community lacks experience to advise you in their\nproper use. Blazing trails can be exciting, but when your goal is pro-\nducing reliable code, it’s often best to let others test the waters before\njumping in.\nThere are two constructs you’ll see in this book that may not be famil-\niar to you. Both are relatively recent language extensions. Some com-\npilers support them, but if your compilers don’t, you can easily\napproximate them with features you do have.\nThe first construct is the bool type, which has as its values the key-\nwords true and false. If your compilers haven’t implemented bool,\nthere are two ways to approximate it. One is to use a global enum:\nenum bool { false, true };\nThis allows you to overload functions on the basis of whether they take\na bool or an int, but it has the disadvantage that the built-in compar-\nison operators (i.e., ==, <, >=, etc.) still return ints. As a result, code\nlike the following will not behave the way it’s supposed to:\nvoid f(int);\nvoid f(bool);\nint x, y;\n...\nf( x < y );\n// calls f(int), but it\n// should call f(bool) \nThe enum approximation may thus lead to code whose behavior\nchanges when you submit it to a compiler that truly supports bool.\n",
      "content_length": 2292,
      "extraction_method": "Direct"
    },
    {
      "page_number": 21,
      "chapter": null,
      "content": "4\nIntroduction\nAn alternative is to use a typedef for bool and constant objects for\ntrue and false:\ntypedef int bool;\nconst bool false = 0;\nconst bool true = 1;\nThis is compatible with the traditional semantics of C and C++, and the\nbehavior of programs using this approximation won’t change when\nthey’re ported to bool-supporting compilers. The drawback is that you\ncan’t differentiate between bool and int when overloading functions.\nBoth approximations are reasonable. Choose the one that best fits\nyour circumstances.\nThe second new construct is really four constructs, the casting forms\nstatic_cast, const_cast, dynamic_cast, and reinterpret_cast.\nIf you’re not familiar with these casts, you’ll want to turn to Item 2 and\nread all about them. Not only do they do more than the C-style casts\nthey replace, they do it better. I use these new casting forms whenever\nI need to perform a cast in this book.\nThere is more to C++ than the language itself. There is also the stan-\ndard library. Where possible, I employ the standard string type in-\nstead of using raw char* pointers, and I encourage you to do the\nsame. string objects are no more difficult to manipulate than char*-\nbased strings, and they relieve you of most memory-management con-\ncerns. Furthermore, string objects are less susceptible to memory\nleaks if an exception is thrown (see Items 9 and 10). A well-imple-\nmented string type can hold its own in an efficiency contest with its\nchar* equivalent, and it may even do better. (For insight into how this\ncould be, see Item 29.) If you don’t have access to an implementation\nof the standard string type, you almost certainly have access to some\nstring-like class. Use it. Just about anything is preferable to raw\nchar*s.\nI use data structures from the standard library whenever I can. Such\ndata structures are drawn from the Standard Template Library (the\n“STL” — see Item 35). The STL includes bitsets, vectors, lists, queues,\nstacks, maps, sets, and more, and you should prefer these standard-\nized data structures to the ad hoc equivalents you might otherwise be\ntempted to write. Your compilers may not have the STL bundled in, but\ndon’t let that keep you from using it. Thanks to Silicon Graphics, you\ncan download a free copy that works with many compilers from the\nSGI STL web site: http://www.sgi.com/tech/stl/.\n",
      "content_length": 2339,
      "extraction_method": "Direct"
    },
    {
      "page_number": 22,
      "chapter": null,
      "content": "Introduction\n5\nIf you currently use a library of algorithms and data structures and are\nhappy with it, there’s no need to switch to the STL just because it’s\n“standard.” However, if you have a choice between using an STL com-\nponent or writing your own code from scratch, you should lean toward\nusing the STL. Remember code reuse? STL (and the rest of the stan-\ndard library) has lots of code that is very much worth reusing.\nConventions and Terminology\nAny time I mention inheritance in this book, I mean public inheritance.\nIf I don’t mean public inheritance, I’ll say so explicitly. When drawing\ninheritance hierarchies, I depict base-derived relationships by drawing\narrows from derived classes to base classes. For example, here is a hi-\nerarchy from Item 31:\nThis notation is the reverse of the convention I employed in the first\n(but not the second) edition of Effective C++. I’m now convinced that\nmost C++ practitioners draw inheritance arrows from derived to base\nclasses, and I am happy to follow suit. Within such diagrams, abstract\nclasses (e.g., GameObject) are shaded and concrete classes (e.g.,\nSpaceShip) are unshaded.\nInheritance gives rise to pointers and references with two different\ntypes, a static type and a dynamic type. The static type of a pointer or\nreference is its declared type. The dynamic type is determined by the\ntype of object it actually refers to. Here are some examples based on\nthe classes above:\nGameObject *pgo =\n// static type of pgo is\nnew SpaceShip;\n// GameObject*, dynamic\n// type is SpaceShip*\nAsteroid *pa = new Asteroid;\n// static type of pa is\n// Asteroid*. So is its\n// dynamic type\npgo = pa;\n// static type of pgo is\n// still (and always)\n// GameObject*. Its \n// dynamic type is now\n// Asteroid*\nGameObject\nSpaceShip\nSpaceStation\nAsteroid\n",
      "content_length": 1791,
      "extraction_method": "Direct"
    },
    {
      "page_number": 23,
      "chapter": null,
      "content": "6\nIntroduction\nGameObject& rgo = *pa;\n// static type of rgo is\n// GameObject, dynamic\n// type is Asteroid\nThese examples also demonstrate a naming convention I like. pgo is a\npointer-to-GameObject; pa is a pointer-to-Asteroid; rgo is a refer-\nence-to-GameObject. I often concoct pointer and reference names in\nthis fashion. \nTwo of my favorite parameter names are lhs and rhs, abbreviations\nfor “left-hand side” and “right-hand side,” respectively. To understand\nthe rationale behind these names, consider a class for representing ra-\ntional numbers:\nclass Rational { ... };\nIf I wanted a function to compare pairs of Rational objects, I’d declare\nit like this:\nbool operator==(const Rational& lhs, const Rational& rhs);\nThat would let me write this kind of code:\nRational r1, r2;\n...\nif (r1 == r2) ...\nWithin the call to operator==, r1 appears on the left-hand side of the\n“==” and is bound to lhs, while r2 appears on the right-hand side of\nthe “==” and is bound to rhs.\nOther abbreviations I employ include ctor for “constructor,” dtor for\n“destructor,” and RTTI for C++’s support for runtime type identification\n(of which dynamic_cast is the most commonly used component).\nWhen you allocate memory and fail to free it, you have a memory leak.\nMemory leaks arise in both C and C++, but in C++, memory leaks leak\nmore than just memory. That’s because C++ automatically calls con-\nstructors when objects are created, and constructors may themselves\nallocate resources. For example, consider this code:\nclass Widget { ... };\n// some class — it doesn’t\n// matter what it is\nWidget *pw = new Widget;\n// dynamically allocate a\n// Widget object\n...\n// assume pw is never\n// deleted\nThis code leaks memory, because the Widget pointed to by pw is never\ndeleted. However, if the Widget constructor allocates additional re-\n",
      "content_length": 1816,
      "extraction_method": "Direct"
    },
    {
      "page_number": 24,
      "chapter": null,
      "content": "Introduction\n7\nsources that are to be released when the Widget is destroyed (such as\nfile descriptors, semaphores, window handles, database locks, etc.),\nthose resources are lost just as surely as the memory is. To emphasize\nthat memory leaks in C++ often leak other resources, too, I usually\nspeak of resource leaks in this book rather than memory leaks.\nYou won’t see many inline functions in this book. That’s not because I\ndislike inlining. Far from it, I believe that inline functions are an im-\nportant feature of C++. However, the criteria for determining whether a\nfunction should be inlined can be complex, subtle, and platform-de-\npendent. As a result, I avoid inlining unless there is a point about in-\nlining I wish to make. When you see a non-inline function in More\nEffective C++, that doesn’t mean I think it would be a bad idea to de-\nclare the function inline, it just means the decision to inline that\nfunction is independent of the material I’m examining at that point in\nthe book.\nA few C++ features have been deprecated by the standardization com-\nmittee. Such features are slated for eventual removal from the lan-\nguage, because newer features have been added that do what the\ndeprecated features do, but do it better. In this book, I identify depre-\ncated constructs and explain what features replace them. You should\ntry to avoid deprecated features where you can, but there’s no reason\nto be overly concerned about their use. In the interest of preserving\nbackward compatibility for their customers, compiler vendors are\nlikely to support deprecated features for many years.\nA client is somebody (a programmer) or something (a class or function,\ntypically) that uses the code you write. For example, if you write a Date\nclass (for representing birthdays, deadlines, when the Second Coming\noccurs, etc.), anybody using that class is your client. Furthermore, any\nsections of code that use the Date class are your clients as well. Cli-\nents are important. In fact, clients are the name of the game! If nobody\nuses the software you write, why write it? You will find I worry a lot\nabout making things easier for clients, often at the expense of making\nthings more difficult for you, because good software is “clientcentric”\n— it revolves around clients. If this strikes you as unreasonably phil-\nanthropic, view it instead through a lens of self-interest. Do you ever\nuse the classes or functions you write? If so, you’re your own client, so\nmaking things easier for clients in general also makes them easier for\nyou.\nWhen discussing class or function templates and the classes or func-\ntions generated from them, I reserve the right to be sloppy about the\ndifference between the templates and their instantiations. For exam-\nple, if Array is a class template taking a type parameter T, I may refer\nto a particular instantiation of the template as an Array, even though\n",
      "content_length": 2893,
      "extraction_method": "Direct"
    },
    {
      "page_number": 25,
      "chapter": null,
      "content": "8\nIntroduction\nArray<T> is really the name of the class. Similarly, if swap is a func-\ntion template taking a type parameter T, I may refer to an instantiation\nas swap instead of swap<T>. In cases where this kind of shorthand\nmight be unclear, I include template parameters when referring to\ntemplate instantiations.\nReporting Bugs, Making Suggestions, Getting Book Updates\nI have tried to make this book as accurate, readable, and useful as\npossible, but I know there is room for improvement. If you find an error\nof any kind — technical, grammatical, typographical, whatever —\nplease tell me about it. I will try to correct the mistake in future print-\nings of the book, and if you are the first person to report it, I will gladly\nadd your name to the book’s acknowledgments. If you have other sug-\ngestions for improvement, I welcome those, too.\nI continue to collect guidelines for effective programming in C++. If you\nhave ideas for new guidelines, I’d be delighted if you’d share them with\nme. Send your guidelines, your comments, your criticisms, and your\nbug reports to:\nScott Meyers\nc/o Editor-in-Chief, Corporate and Professional Publishing\nAddison-Wesley Publishing Company\n1 Jacob Way\nReading, MA 01867\nU. S. A.\nAlternatively, you may send electronic mail to mec++@awl.com.\nI maintain a list of changes to this book since its first printing, includ-\ning bug-fixes, clarifications, and technical updates. This list, along\nwith other book-related information, is available from Addison-Wesley\nat World Wide Web URL http://www.awl.com/cp/mec++.html. It is\nalso available via anonymous FTP from ftp.awl.com in the directory\ncp/mec++. If you would like a copy of the list of changes to this book,\nbut you lack access to the Internet, please send a request to one of the\naddresses above, and I will see that the list is sent to you.\nIf you’d like to be notified when I make changes to this book, consider\njoining my mailing list. For details, consult http://www.aristeia.com/\nMailingList/index.html.\nEnough preliminaries. On with the show!\n",
      "content_length": 2046,
      "extraction_method": "Direct"
    },
    {
      "page_number": 26,
      "chapter": null,
      "content": "Basics\nBasics\nAh, the basics. Pointers, references, casts, arrays, constructors — you\ncan’t get much more basic than that. All but the simplest C++ pro-\ngrams use most of these features, and many programs use them all. \nIn spite of our familiarity with these parts of the language, sometimes\nthey can still surprise us. This is especially true for programmers mak-\ning the transition from C to C++, because the concepts behind refer-\nences, dynamic casts, default constructors, and other non-C features\nare usually a little murky.\nThis chapter describes the differences between pointers and references\nand offers guidance on when to use each. It introduces the new C++\nsyntax for casts and explains why the new casts are superior to the C-\nstyle casts they replace. It examines the C notion of arrays and the C++\nnotion of polymorphism, and it describes why mixing the two is an idea\nwhose time will never come. Finally, it considers the pros and cons of\ndefault constructors and suggests ways to work around language re-\nstrictions that encourage you to have one when none makes sense.\nBy heeding the advice in the items that follow, you’ll make progress to-\nward a worthy goal: producing software that expresses your design in-\ntentions clearly and correctly.\nItem 1:\nDistinguish between pointers and references.\nPointers versus References\nPointers and references look different enough (pointers use the “*” and\n“->” operators, references use “.”), but they seem to do similar things.\nBoth pointers and references let you refer to other objects indirectly.\nHow, then, do you decide when to use one and not the other?\nFirst, recognize that there is no such thing as a null reference. A refer-\nence must always refer to some object. As a result, if you have a vari-\nable whose purpose is to refer to another object, but it is possible that\nthere might not be an object to refer to, you should make the variable\n",
      "content_length": 1911,
      "extraction_method": "Direct"
    },
    {
      "page_number": 27,
      "chapter": null,
      "content": "10\nItem 1\na pointer, because then you can set it to null. On the other hand, if the\nvariable must always refer to an object, i.e., if your design does not\nallow for the possibility that the variable is null, you should probably\nmake the variable a reference.\n“But wait,” you wonder, “what about underhandedness like this?”\nchar *pc = 0;\n// set pointer to null\nchar& rc = *pc;\n// make reference refer to\n// dereferenced null pointer\nWell, this is evil, pure and simple. The results are undefined (compilers\ncan generate output to do anything they like), and people who write\nthis kind of code should be shunned until they agree to cease and de-\nsist. If you have to worry about things like this in your software, you’re\nprobably best off avoiding references entirely. Either that or finding a\nbetter class of programmers to work with. We’ll henceforth ignore the\npossibility that a reference can be “null.”\nBecause a reference must refer to an object, C++ requires that refer-\nences be initialized:\nstring& rs;\n// error! References must\n// be initialized\nstring s(\"xyzzy\");\nstring& rs = s;\n// okay, rs refers to s\nPointers are subject to no such restriction:\nstring *ps;\n// uninitialized pointer:\n// valid but risky\nThe fact that there is no such thing as a null reference implies that it\ncan be more efficient to use references than to use pointers. That’s be-\ncause there’s no need to test the validity of a reference before using it:\nvoid printDouble(const double& rd)\n{\ncout << rd; \n// no need to test rd; it\n}\n// must refer to a double\nPointers, on the other hand, should generally be tested against null:\nvoid printDouble(const double *pd)\n{\nif (pd) { \n// check for null pointer\ncout << *pd; \n}\n}\n",
      "content_length": 1702,
      "extraction_method": "Direct"
    },
    {
      "page_number": 28,
      "chapter": null,
      "content": "Pointers versus References\n11\nAnother important difference between pointers and references is that\npointers may be reassigned to refer to different objects. A reference,\nhowever, always refers to the object with which it is initialized:\nstring s1(\"Nancy\");\nstring s2(\"Clancy\");\nstring& rs = s1;\n// rs refers to s1\nstring *ps = &s1;\n// ps points to s1\nrs = s2;\n// rs still refers to s1,\n// but s1’s value is now\n// \"Clancy\"\nps = &s2;\n// ps now points to s2;\n// s1 is unchanged \nIn general, you should use a pointer whenever you need to take into\naccount the possibility that there’s nothing to refer to (in which case\nyou can set the pointer to null) or whenever you need to be able to refer\nto different things at different times (in which case you can change\nwhere the pointer points). You should use a reference whenever you\nknow there will always be an object to refer to and you also know that\nonce you’re referring to that object, you’ll never want to refer to any-\nthing else.\nThere is one other situation in which you should use a reference, and\nthat’s when you’re implementing certain operators. The most common\nexample is operator[]. This operator typically needs to return some-\nthing that can be used as the target of an assignment:\nvector<int> v(10);\n// create an int vector of size 10; \n// vector is a template in the \n// standard C++ library (see Item 35)\nv[5] = 10;\n// the target of this assignment is\n// the return value of operator[]\nIf operator[] returned a pointer, this last statement would have to be\nwritten this way:\n*v[5] = 10;\nBut this makes it look like v is a vector of pointers, which it’s not. For\nthis reason, you’ll almost always want operator[] to return a refer-\nence. (For an interesting exception to this rule, see Item 30.)\nReferences, then, are the feature of choice when you know you have\nsomething to refer to and when you’ll never want to refer to anything\nelse. They’re also appropriate when implementing operators whose\nsyntactic requirements make the use of pointers undesirable. In all\nother cases, stick with pointers.\n",
      "content_length": 2064,
      "extraction_method": "Direct"
    },
    {
      "page_number": 29,
      "chapter": null,
      "content": "12\nItem 2\nItem 2:\nPrefer C++-style casts.\nNew Casting Operators\nConsider the lowly cast. Nearly as much a programming pariah as the\ngoto, it nonetheless endures, because when worse comes to worst and\npush comes to shove, casts can be necessary. Casts are especially nec-\nessary when worse comes to worst and push comes to shove.\nStill, C-style casts are not all they might be. For one thing, they’re\nrather crude beasts, letting you cast pretty much any type to pretty\nmuch any other type. It would be nice to be able to specify more pre-\ncisely the purpose of each cast. There is a great difference, for example,\nbetween a cast that changes a pointer-to-const-object into a pointer-\nto-non-const-object (i.e., a cast that changes only the constness of an\nobject) and a cast that changes a pointer-to-base-class-object into a\npointer-to-derived-class-object (i.e., a cast that completely changes an\nobject’s type). Traditional C-style casts make no such distinctions.\n(This is hardly a surprise. C-style casts were designed for C, not C++.)\nA second problem with casts is that they are hard to find. Syntacti-\ncally, casts consist of little more than a pair of parentheses and an\nidentifier, and parentheses and identifiers are used everywhere in C++.\nThis makes it tough to answer even the most basic cast-related ques-\ntions, questions like, “Are any casts used in this program?” That’s be-\ncause human readers are likely to overlook casts, and tools like grep\ncannot distinguish them from non-cast constructs that are syntacti-\ncally similar.\nC++ addresses the shortcomings of C-style casts by introducing four\nnew cast operators, static_cast, const_cast, dynamic_cast, and\nreinterpret_cast. For most purposes, all you need to know about\nthese operators is that what you are accustomed to writing like this,\n(type) expression\nyou should now generally write like this:\nstatic_cast<type>(expression)\nFor example, suppose you’d like to cast an int to a double to force an\nexpression involving ints to yield a floating point value. Using C-style\ncasts, you could do it like this:\nint firstNumber, secondNumber;\n...\ndouble result = ((double)firstNumber)/secondNumber;\nWith the new casts, you’d write it this way:\ndouble result = static_cast<double>(firstNumber)/secondNumber;\n",
      "content_length": 2274,
      "extraction_method": "Direct"
    },
    {
      "page_number": 30,
      "chapter": null,
      "content": "New Casting Operators\n13\nNow there’s a cast that’s easy to see, both for humans and for pro-\ngrams.\nstatic_cast has basically the same power and meaning as the gen-\neral-purpose C-style cast. It also has the same kind of restrictions. For\nexample, you can’t cast a struct into an int or a double into a\npointer using static_cast any more than you can with a C-style cast.\nFurthermore, static_cast can’t remove constness from an expres-\nsion, because another new cast, const_cast, is designed specifically\nto do that.\nThe other new C++ casts are used for more restricted purposes.\nconst_cast is used to cast away the constness or volatileness of\nan expression. By using a const_cast, you emphasize (to both hu-\nmans and compilers) that the only thing you want to change through\nthe cast is the constness or volatileness of something. This mean-\ning is enforced by compilers. If you try to employ const_cast for any-\nthing other than modifying the constness or volatileness of an\nexpression, your cast will be rejected. Here are some examples:\nclass Widget { ... };\nclass SpecialWidget: public Widget { ... };\nvoid update(SpecialWidget *psw);\nSpecialWidget sw;\n// sw is a non-const object,\nconst SpecialWidget& csw = sw;\n// but csw is a reference to\n// it as a const object\nupdate(&csw);\n// error! can’t pass a const\n// SpecialWidget* to a function\n// taking a SpecialWidget*\nupdate(const_cast<SpecialWidget*>(&csw));\n// fine, the constness of &csw is \n// explicitly cast away (and \n// csw — and sw — may now be \n// changed inside update)\nupdate((SpecialWidget*)&csw);\n// same as above, but using a\n// harder-to-recognize C-style cast\nWidget *pw = new SpecialWidget;\nupdate(pw);\n// error! pw’s type is Widget*, but\n// update takes a SpecialWidget*\nupdate(const_cast<SpecialWidget*>(pw));\n// error! const_cast can be used only\n// to affect constness or volatileness,\n// never to cast down the inheritance\n// hierarchy\nBy far the most common use of const_cast is to cast away the const-\nness of an object.\n",
      "content_length": 2002,
      "extraction_method": "Direct"
    },
    {
      "page_number": 31,
      "chapter": null,
      "content": "14\nItem 2\nThe second specialized type of cast, dynamic_cast, is used to perform\nsafe casts down or across an inheritance hierarchy. That is, you use\ndynamic_cast to cast pointers or references to base class objects into\npointers or references to derived or sibling base class objects in such a\nway that you can determine whether the casts succeeded.† Failed\ncasts are indicated by a null pointer (when casting pointers) or an ex-\nception (when casting references):\nWidget *pw;\n...\nupdate(dynamic_cast<SpecialWidget*>(pw));\n// fine, passes to update a pointer\n// to the SpecialWidget pw points to \n// if pw really points to one, \n// otherwise passes the null pointer\nvoid updateViaRef(SpecialWidget& rsw);\nupdateViaRef(dynamic_cast<SpecialWidget&>(*pw));\n// fine, passes to updateViaRef the \n// SpecialWidget pw points to if pw \n// really points to one, otherwise \n// throws an exception\ndynamic_casts are restricted to helping you navigate inheritance hi-\nerarchies. They cannot be applied to types lacking virtual functions\n(see also Item 24), nor can they cast away constness:\nint firstNumber, secondNumber;\n...\ndouble result = dynamic_cast<double>(firstNumber)/secondNumber;\n// error! int has no virtual functions\nconst SpecialWidget sw;\n...\nupdate(dynamic_cast<SpecialWidget*>(&sw));\n// error! dynamic_cast can’t cast \n// away constness\nIf you want to perform a cast on a type where inheritance is not in-\nvolved, you probably want a static_cast. To cast constness away,\nyou always want a const_cast.\nThe last of the four new casting forms is reinterpret_cast. This op-\nerator is used to perform type conversions whose result is nearly al-\nways implementation-defined. As a result, reinterpret_casts are\nrarely portable.\n† A second, unrelated use of dynamic_cast is to find the beginning of the memory oc-\ncupied by an object. We explore that capability in Item 27.\n",
      "content_length": 1870,
      "extraction_method": "Direct"
    },
    {
      "page_number": 32,
      "chapter": null,
      "content": "New Casting Operators\n15\nThe most common use of reinterpret_cast is to cast between func-\ntion pointer types. For example, suppose you have an array of pointers\nto functions of a particular type:\ntypedef void (*FuncPtr)();\n// a FuncPtr is a pointer \n// to a function taking no\n// args and returning void\nFuncPtr funcPtrArray[10];\n// funcPtrArray is an array\n// of 10 FuncPtrs\nLet us suppose you wish (for some unfathomable reason) to place a\npointer to the following function into funcPtrArray:\nint doSomething();\nYou can’t do what you want without a cast, because doSomething has\nthe wrong type for funcPtrArray. The functions in funcPtrArray re-\nturn void, but doSomething returns an int:\nfuncPtrArray[0] = &doSomething;\n// error! type mismatch\nA reinterpret_cast lets you force compilers to see things your way:\nfuncPtrArray[0] =\n// this compiles\nreinterpret_cast<FuncPtr>(&doSomething);\nCasting function pointers is not portable (C++ offers no guarantee that\nall function pointers are represented the same way), and in some cases\nsuch casts yield incorrect results (see Item 31), so you should avoid\ncasting function pointers unless your back’s to the wall and a knife’s\nat your throat. A sharp knife. A very sharp knife.\nIf your compilers lack support for the new casting forms, you can use\ntraditional casts in place of static_cast, const_cast, and\nreinterpret_cast. Furthermore, you can use macros to approxi-\nmate the new syntax:\n#define static_cast(TYPE,EXPR) \n((TYPE)(EXPR))\n#define const_cast(TYPE,EXPR) \n((TYPE)(EXPR))\n#define reinterpret_cast(TYPE,EXPR) ((TYPE)(EXPR))\nYou’d use the approximations like this:\ndouble result = static_cast(double, firstNumber)/secondNumber;\nupdate(const_cast(SpecialWidget*, &sw));\nfuncPtrArray[0] = reinterpret_cast(FuncPtr, &doSomething);\nThese approximations won’t be as safe as the real things, of course,\nbut they will simplify the process of upgrading your code when your\ncompilers support the new casts.\n",
      "content_length": 1955,
      "extraction_method": "Direct"
    },
    {
      "page_number": 33,
      "chapter": null,
      "content": "16\nItem 3\nThere is no easy way to emulate the behavior of a dynamic_cast, but\nmany libraries provide functions to perform safe inheritance-based\ncasts for you. If you lack such functions and you must perform this\ntype of cast, you can fall back on C-style casts for those, too, but then\nyou forego the ability to tell if the casts fail. Needless to say, you can\ndefine a macro to look like dynamic_cast, just as you can for the other\ncasts:\n#define dynamic_cast(TYPE,EXPR)\n((TYPE)(EXPR))\nRemember that this approximation is not performing a true\ndynamic_cast; there is no way to tell if the cast fails.\nI know, I know, the new casts are ugly and hard to type. If you find\nthem too unpleasant to look at, take solace in the knowledge that C-\nstyle casts continue to be valid. However, what the new casts lack in\nbeauty they make up for in precision of meaning and easy recogniz-\nability. Programs that use the new casts are easier to parse (both for\nhumans and for tools), and they allow compilers to diagnose casting\nerrors that would otherwise go undetected. These are powerful argu-\nments for abandoning C-style casts, and there may also be a third:\nperhaps making casts ugly and hard to type is a good thing.\nItem 3:\nNever treat arrays polymorphically.\nArrays and Polymorphism\nOne of the most important features of inheritance is that you can ma-\nnipulate derived class objects through pointers and references to base\nclass objects. Such pointers and references are said to behave polymor-\nphically — as if they had multiple types. C++ also allows you to manip-\nulate arrays of derived class objects through base class pointers and\nreferences. This is no feature at all, because it almost never works the\nway you want it to.\nFor example, suppose you have a class BST (for binary search tree ob-\njects) and a second class, BalancedBST, that inherits from BST:\nclass BST { ... };\nclass BalancedBST: public BST { ... };\nIn a real program such classes would be templates, but that’s unim-\nportant here, and adding all the template syntax just makes things\nharder to read. For this discussion, we’ll assume BST and Bal-\nancedBST objects contain only ints.\nConsider a function to print out the contents of each BST in an array\nof BSTs:\n",
      "content_length": 2233,
      "extraction_method": "Direct"
    },
    {
      "page_number": 34,
      "chapter": null,
      "content": "Arrays and Polymorphism\n17\nvoid printBSTArray(ostream& s,\nconst BST array[],\nint numElements)\n{\nfor (int i = 0; i < numElements; ++i) {\ns << array[i];\n// this assumes an\n}\n// operator<< is defined\n}\n// for BST objects\nThis will work fine when you pass it an array of BST objects:\nBST BSTArray[10];\n...\nprintBSTArray(cout, BSTArray, 10);\n// works fine\nConsider, however, what happens when you pass printBSTArray an\narray of BalancedBST objects:\nBalancedBST bBSTArray[10];\n...\nprintBSTArray(cout, bBSTArray, 10);\n// works fine?\nYour compilers will accept this function call without complaint, but\nlook again at the loop for which they must generate code:\nfor (int i = 0; i < numElements; ++i) {\ns << array[i];\n}\nNow, array[i] is really just shorthand for an expression involving\npointer arithmetic: it stands for *(array+i). We know that array is a\npointer to the beginning of the array, but how far away from the mem-\nory location pointed to by array is the memory location pointed to by\narray+i? The distance between them is i*sizeof(an object in the\narray), because there are i objects between array[0] and array[i].\nIn order for compilers to emit code that walks through the array cor-\nrectly, they must be able to determine the size of the objects in the ar-\nray. This is easy for them to do. The parameter array is declared to be\nof type array-of-BST, so each element of the array must be a BST, and\nthe distance between array and array+i must be i*sizeof(BST).\nAt least that’s how your compilers look at it. But if you’ve passed an\narray of BalancedBST objects to printBSTArray, your compilers are\nprobably wrong. In that case, they’d assume each object in the array is\nthe size of a BST, but each object would actually be the size of a Bal-\nancedBST. Derived classes usually have more data members than their\nbase classes, so derived class objects are usually larger than base\nclass objects. We thus expect a BalancedBST object to be larger than a\n",
      "content_length": 1954,
      "extraction_method": "Direct"
    },
    {
      "page_number": 35,
      "chapter": null,
      "content": "18\nItem 3\nBST object. If it is, the pointer arithmetic generated for printBSTArray\nwill be wrong for arrays of BalancedBST objects, and there’s no telling\nwhat will happen when printBSTArray is invoked on a BalancedBST\narray. Whatever does happen, it’s a good bet it won’t be pleasant.\nThe problem pops up in a different guise if you try to delete an array of\nderived class objects through a base class pointer. Here’s one way you\nmight innocently attempt to do it:\n// delete an array, but first log a message about its\n// deletion\nvoid deleteArray(ostream& logStream, BST array[])\n{\nlogStream << \"Deleting array at address \" \n<< static_cast<void*>(array) << ’\\n’;\ndelete [] array;\n}\nBalancedBST *balTreeArray =\n// create a BalancedBST\nnew BalancedBST[50];\n// array\n...\ndeleteArray(cout, balTreeArray);\n// log its deletion\nYou can’t see it, but there’s pointer arithmetic going on here, too. When\nan array is deleted, a destructor for each element of the array must be\ncalled (see Item 8). When compilers see the statement\ndelete [] array;\nthey must generate code that does something like this:\n// destruct the objects in *array in the inverse order\n// in which they were constructed\nfor (int i = the number of elements in the array - 1;\ni >= 0;\n--i)\n{\narray[i].BST::~BST();\n// call array[i]’s\n}\n// destructor\nJust as this kind of loop failed to work when you wrote it, it will fail to\nwork when your compilers write it, too. The language specification\nsays the result of deleting an array of derived class objects through a\nbase class pointer is undefined, but we know what that really means:\nexecuting the code is almost certain to lead to grief. Polymorphism and\npointer arithmetic simply don’t mix. Array operations almost always\ninvolve pointer arithmetic, so arrays and polymorphism don’t mix. \nNote that you’re unlikely to make the mistake of treating an array poly-\nmorphically if you avoid having a concrete class (like BalancedBST) in-\n",
      "content_length": 1946,
      "extraction_method": "Direct"
    },
    {
      "page_number": 36,
      "chapter": null,
      "content": "Default Constructors\n19\nherit from another concrete class (such as BST). As Item 33 explains,\ndesigning your software so that concrete classes never inherit from one\nanother has many benefits. I encourage you to turn to Item 33 and\nread all about them.\nItem 4:\nAvoid gratuitous default constructors.\nDefault Constructors\nA default constructor (i.e., a constructor that can be called with no ar-\nguments) is the C++ way of saying you can get something for nothing.\nConstructors initialize objects, so default constructors initialize ob-\njects without any information from the place where the object is being\ncreated. Sometimes this makes perfect sense. Objects that act like\nnumbers, for example, may reasonably be initialized to zero or to un-\ndefined values. Objects that act like pointers (see Item 28) may reason-\nably be initialized to null or to undefined values. Data structures like\nlinked lists, hash tables, maps, and the like may reasonably be initial-\nized to empty containers. \nNot all objects fall into this category. For many objects, there is no rea-\nsonable way to perform a complete initialization in the absence of out-\nside information. For example, an object representing an entry in an\naddress book makes no sense unless the name of the thing being en-\ntered is provided. In some companies, all equipment must be tagged\nwith a corporate ID number, and creating an object to model a piece of\nequipment in such companies is nonsensical unless the appropriate\nID number is provided.\nIn a perfect world, classes in which objects could reasonably be cre-\nated from nothing would contain default constructors and classes in\nwhich information was required for object construction would not.\nAlas, ours is not the best of all possible worlds, so we must take addi-\ntional concerns into account. In particular, if a class lacks a default\nconstructor, there are restrictions on how you can use that class.\nConsider a class for company equipment in which the corporate ID\nnumber of the equipment is a mandatory constructor argument:\nclass EquipmentPiece {\npublic:\nEquipmentPiece(int IDNumber);\n...\n};\nBecause EquipmentPiece lacks a default constructor, its use may be\nproblematic in three contexts. The first is the creation of arrays. There\n",
      "content_length": 2252,
      "extraction_method": "Direct"
    },
    {
      "page_number": 37,
      "chapter": null,
      "content": "20\nItem 4\nis, in general, no way to specify constructor arguments for objects in\narrays, so it is not usually possible to create arrays of Equipment-\nPiece objects:\nEquipmentPiece bestPieces[10];\n// error! No way to call\n// EquipmentPiece ctors\nEquipmentPiece *bestPieces = \nnew EquipmentPiece[10];\n// error! same problem\nThere are three ways to get around this restriction. A solution for non-\nheap arrays is to provide the necessary arguments at the point where\nthe array is defined:\nint ID1, ID2, ID3, ..., ID10;\n// variables to hold\n// equipment ID numbers\n...\nEquipmentPiece bestPieces[] = {\n// fine, ctor arguments\nEquipmentPiece(ID1), \n// are provided\nEquipmentPiece(ID2),\nEquipmentPiece(ID3),\n...,\nEquipmentPiece(ID10)\n};\nUnfortunately, there is no way to extend this strategy to heap arrays.\nA more general approach is to use an array of pointers instead of an\narray of objects:\ntypedef EquipmentPiece* PEP;\n// a PEP is a pointer to\n// an EquipmentPiece\nPEP bestPieces[10];\n// fine, no ctors called\nPEP *bestPieces = new PEP[10];\n// also fine\nEach pointer in the array can then be made to point to a different\nEquipmentPiece object:\nfor (int i = 0; i < 10; ++i)\nbestPieces[i] = new EquipmentPiece( ID Number );\nThere are two disadvantages to this approach. First, you have to re-\nmember to delete all the objects pointed to by the array. If you forget,\nyou have a resource leak. Second, the total amount of memory you\nneed increases, because you need the space for the pointers as well as\nthe space for the EquipmentPiece objects.\nYou can avoid the space penalty if you allocate the raw memory for the\narray, then use “placement new” (see Item 8) to construct the Equip-\nmentPiece objects in the memory:\n",
      "content_length": 1713,
      "extraction_method": "Direct"
    },
    {
      "page_number": 38,
      "chapter": null,
      "content": "Default Constructors\n21\n// allocate enough raw memory for an array of 10\n// EquipmentPiece objects; see Item 8 for details on\n// the operator new[] function\nvoid *rawMemory =\noperator new[](10*sizeof(EquipmentPiece));\n// make bestPieces point to it so it can be treated as an\n// EquipmentPiece array\nEquipmentPiece *bestPieces =\nstatic_cast<EquipmentPiece*>(rawMemory);\n// construct the EquipmentPiece objects in the memory \n// using \"placement new\" (see Item 8)\nfor (int i = 0; i < 10; ++i)\nnew (bestPieces+i) EquipmentPiece( ID Number );\nNotice that you still have to provide a constructor argument for each\nEquipmentPiece object. This technique (as well as the array-of-point-\ners idea) allows you to create arrays of objects when a class lacks a de-\nfault constructor; it doesn’t show you how to bypass required\nconstructor arguments. There is no way to do that. If there were, it\nwould defeat the purpose of constructors, which is to guarantee that\nobjects are initialized.\nThe downside to using placement new, aside from the fact that most\nprogrammers are unfamiliar with it (which will make maintenance\nmore difficult), is that you must manually call destructors on the ob-\njects in the array when you want them to go out of existence, then you\nmust manually deallocate the raw memory by calling operator de-\nlete[] (again, see Item 8):\n// destruct the objects in bestPieces in the inverse\n// order in which they were constructed\nfor (int i = 9; i >= 0; --i)\nbestPieces[i].~EquipmentPiece();\n// deallocate the raw memory\noperator delete[](rawMemory);\nIf you forget this requirement and use the normal array-deletion syn-\ntax, your program will behave unpredictably. That’s because the result\nof deleting a pointer that didn’t come from the new operator is unde-\nfined:\ndelete [] bestPieces;\n// undefined! bestPieces\n// didn’t come from the new\n// operator\nFor more information on the new operator, placement new and how\nthey interact with constructors and destructors, see Item 8.\n",
      "content_length": 1988,
      "extraction_method": "Direct"
    },
    {
      "page_number": 39,
      "chapter": null,
      "content": "22\nItem 4\nThe second problem with classes lacking default constructors is that\nthey are ineligible for use with many template-based container classes.\nThat’s because it’s a common requirement for such templates that the\ntype used to instantiate the template provide a default constructor.\nThis requirement almost always grows out of the fact that inside the\ntemplate, an array of the template parameter type is being created. For\nexample, a template for an Array class might look something like this:\ntemplate<class T>\nclass Array {\npublic:\nArray(int size);\n...\nprivate:\nT *data;\n};\ntemplate<class T>\nArray<T>::Array(int size)\n{\ndata = new T[size];\n// calls T::T() for each\n...\n// element of the array\n}\nIn most cases, careful template design can eliminate the need for a de-\nfault constructor. For example, the standard vector template (which\ngenerates classes that act like extensible arrays) has no requirement\nthat its type parameter have a default constructor. Unfortunately,\nmany templates are designed in a manner that is anything but careful.\nThat being the case, classes without default constructors will be in-\ncompatible with many templates. As C++ programmers learn more\nabout template design, this problem should recede in significance.\nHow long it will take for that to happen, however, is anyone’s guess.\nThe final consideration in the to-provide-a-default-constructor-or-not-\nto-provide-a-default-constructor dilemma has to do with virtual base\nclasses. Virtual base classes lacking default constructors are a pain to\nwork with. That’s because the arguments for virtual base class con-\nstructors must be provided by the most derived class of the object\nbeing constructed. As a result, a virtual base class lacking a default\nconstructor requires that all classes derived from that class — no mat-\nter how far removed — must know about, understand the meaning of,\nand provide for the virtual base class’s constructors’ arguments. Au-\nthors of derived classes neither expect nor appreciate this require-\nment.\nBecause of the restrictions imposed on classes lacking default con-\nstructors, some people believe all classes should have them, even if a\n",
      "content_length": 2162,
      "extraction_method": "Direct"
    },
    {
      "page_number": 40,
      "chapter": null,
      "content": "Default Constructors\n23\ndefault constructor doesn’t have enough information to fully initialize\nobjects of that class. For example, adherents to this philosophy might\nmodify EquipmentPiece as follows:\nclass EquipmentPiece {\npublic:\nEquipmentPiece(int IDNumber = UNSPECIFIED);\n...\nprivate:\nstatic const int UNSPECIFIED;\n// magic ID number value\n// meaning no ID was\n};\n// specified\nThis allows EquipmentPiece objects to be created like this:\nEquipmentPiece e;\n// now okay\nSuch a transformation almost always complicates the other member\nfunctions of the class, because there is no longer any guarantee that\nthe fields of an EquipmentPiece object have been meaningfully initial-\nized. Assuming it makes no sense to have an EquipmentPiece without\nan ID field, most member functions must check to see if the ID is\npresent. If it’s not, they’ll have to figure out how to stumble on anyway.\nOften it’s not clear how to do that, and many implementations choose\na solution that offers nothing but expediency: they throw an exception\nor they call a function that terminates the program. When that hap-\npens, it’s difficult to argue that the overall quality of the software has\nbeen improved by including a default constructor in a class where\nnone was warranted.\nInclusion of meaningless default constructors affects the efficiency of\nclasses, too. If member functions have to test to see if fields have truly\nbeen initialized, clients of those functions have to pay for the time\nthose tests take. Furthermore, they have to pay for the code that goes\ninto those tests, because that makes executables and libraries bigger.\nThey also have to pay for the code that handles the cases where the\ntests fail. All those costs are avoided if a class’s constructors ensure\nthat all fields of an object are correctly initialized. Often default con-\nstructors can’t offer that kind of assurance, so it’s best to avoid them\nin classes where they make no sense. That places some limits on how\nsuch classes can be used, yes, but it also guarantees that when you do\nuse such classes, you can expect that the objects they generate are\nfully initialized and are efficiently implemented.\n",
      "content_length": 2160,
      "extraction_method": "Direct"
    },
    {
      "page_number": 41,
      "chapter": null,
      "content": "Operators\nOperators\nOverloadable operators — you gotta love ’em! They allow you to give\nyour types the same syntax as C++’s built-in types, yet they let you put\na measure of power into the functions behind the operators that’s un-\nheard of for the built-ins. Of course, the fact that you can make sym-\nbols like “+” and “==” do anything you want also means you can use\noverloaded operators to produce programs best described as impene-\ntrable. Adept C++ programmers know how to harness the power of op-\nerator overloading without descending into the incomprehensible.\nRegrettably, it is easy to make the descent. Single-argument construc-\ntors and implicit type conversion operators are particularly trouble-\nsome, because they can be invoked without there being any source\ncode showing the calls. This can lead to program behavior that is diffi-\ncult to understand. A different problem arises when you overload op-\nerators like && and ||, because the shift from built-in operator to user-\ndefined function yields a subtle change in semantics that’s easy to\noverlook. Finally, many operators are related to one another in stan-\ndard ways, but the ability to overload operators makes it possible to vi-\nolate the accepted relationships.\nIn the items that follow, I focus on explaining when and how over-\nloaded operators are called, how they behave, how they should relate\nto one another, and how you can seize control of these aspects of over-\nloaded operators. With the information in this chapter under your belt,\nyou’ll be overloading (or not overloading) operators like a pro.\nItem 5:\nBe wary of user-defined conversion functions.\nConversion Functions\nC++ allows compilers to perform implicit conversions between types. In\nhonor of its C heritage, for example, the language allows silent conver-\nsions from char to int and from short to double. This is why you can\npass a short to a function that expects a double and still have the call\nsucceed. The more frightening conversions in C — those that may lose\n",
      "content_length": 2011,
      "extraction_method": "Direct"
    },
    {
      "page_number": 42,
      "chapter": null,
      "content": "Conversion Functions\n25\ninformation — are also present in C++, including conversion of int to\nshort and double to (of all things) char.\nYou can’t do anything about such conversions, because they’re hard-\ncoded into the language. When you add your own types, however, you\nhave more control, because you can choose whether to provide the\nfunctions compilers are allowed to use for implicit type conversions.\nTwo kinds of functions allow compilers to perform such conversions:\nsingle-argument constructors and implicit type conversion operators. A\nsingle-argument constructor is a constructor that may be called with\nonly one argument. Such a constructor may declare a single parameter\nor it may declare multiple parameters, with each parameter after the\nfirst having a default value. Here are two examples:\nclass Name {\n// for names of things\npublic:\nName(const string& s);\n// converts string to\n// Name\n...\n};\nclass Rational {\n// for rational numbers\npublic:\nRational(int numerator = 0,\n// converts int to \nint denominator = 1);\n// Rational\n...\n};\nAn implicit type conversion operator is simply a member function with\na strange-looking name: the word operator followed by a type specifi-\ncation. You aren’t allowed to specify a type for the function’s return\nvalue, because the type of the return value is basically just the name\nof the function. For example, to allow Rational objects to be implicitly\nconverted to doubles (which might be useful for mixed-mode arith-\nmetic involving Rational objects), you might define class Rational\nlike this:\nclass Rational {\npublic:\n...\noperator double() const;\n// converts Rational to\n};\n// double\nThis function would be automatically invoked in contexts like this:\nRational r(1, 2);\n// r has the value 1/2\ndouble d = 0.5 * r;\n// converts r to a double,\n// then does multiplication\n",
      "content_length": 1821,
      "extraction_method": "Direct"
    },
    {
      "page_number": 43,
      "chapter": null,
      "content": "26\nItem 5\nPerhaps all this is review. That’s fine, because what I really want to ex-\nplain is why you usually don’t want to provide type conversion func-\ntions of any ilk.\nThe fundamental problem is that such functions often end up being\ncalled when you neither want nor expect them to be. The result can be\nincorrect and unintuitive program behavior that is maddeningly diffi-\ncult to diagnose.\nLet us deal first with implicit type conversion operators, as they are the\neasiest case to handle. Suppose you have a class for rational numbers\nsimilar to the one above, and you’d like to print Rational objects as if\nthey were a built-in type. That is, you’d like to be able to do this:\nRational r(1, 2);\ncout << r;\n// should print \"1/2\"\nFurther suppose you forgot to write an operator<< for Rational ob-\njects. You would probably expect that the attempt to print r would fail,\nbecause there is no appropriate operator<< to call. You would be mis-\ntaken. Your compilers, faced with a call to a function called opera-\ntor<< that takes a Rational, would find that no such function\nexisted, but they would then try to find an acceptable sequence of im-\nplicit type conversions they could apply to make the call succeed. The\nrules defining which sequences of conversions are acceptable are com-\nplicated, but in this case your compilers would discover they could\nmake the call succeed by implicitly converting r to a double by calling\nRational::operator double. The result of the code above would be to\nprint r as a floating point number, not as a rational number. This is\nhardly a disaster, but it demonstrates the disadvantage of implicit type\nconversion operators: their presence can lead to the wrong function\nbeing called (i.e., one other than the one intended).\nThe solution is to replace the operators with equivalent functions that\ndon’t have the syntactically magic names. For example, to allow con-\nversion of a Rational object to a double, replace operator double\nwith a function called something like asDouble:\nclass Rational {\npublic:\n...\ndouble asDouble() const;\n// converts Rational\n};\n// to double\nSuch a member function must be called explicitly:\nRational r(1, 2);\ncout << r;\n// error! No operator<<\n// for Rationals\n",
      "content_length": 2227,
      "extraction_method": "Direct"
    },
    {
      "page_number": 44,
      "chapter": null,
      "content": "Conversion Functions\n27\ncout << r.asDouble();\n// fine, prints r as a\n// double\nIn most cases, the inconvenience of having to call conversion functions\nexplicitly is more than compensated for by the fact that unintended\nfunctions can no longer be silently invoked. In general, the more expe-\nrience C++ programmers have, the more likely they are to eschew type\nconversion operators. The members of the committee working on the\nstandard C++ library (see Item 35), for example, are among the most\nexperienced in the business, and perhaps that’s why the string type\nthey added to the library contains no implicit conversion from a\nstring object to a C-style char*. Instead, there’s an explicit member\nfunction, c_str, that performs that conversion. Coincidence? I think\nnot.\nImplicit conversions via single-argument constructors are more diffi-\ncult to eliminate. Furthermore, the problems these functions cause are\nin many cases worse than those arising from implicit type conversion\noperators. \nAs an example, consider a class template for array objects. These ar-\nrays allow clients to specify upper and lower index bounds:\ntemplate<class T>\nclass Array {\npublic:\nArray(int lowBound, int highBound);\nArray(int size);\nT& operator[](int index);\n...\n};\nThe first constructor in the class allows clients to specify a range of\narray indices, for example, from 10 to 20. As a two-argument construc-\ntor, this function is ineligible for use as a type-conversion function. The\nsecond constructor, which allows clients to define Array objects by\nspecifying only the number of elements in the array (in a manner sim-\nilar to that used with built-in arrays), is different. It can be used as a\ntype conversion function, and that can lead to endless anguish.\nFor example, consider a template specialization for comparing Ar-\nray<int> objects and some code that uses such objects:\nbool operator==( const Array<int>& lhs, \nconst Array<int>& rhs);\n",
      "content_length": 1931,
      "extraction_method": "Direct"
    },
    {
      "page_number": 45,
      "chapter": null,
      "content": "28\nItem 5\nArray<int> a(10);\nArray<int> b(10);\n...\nfor (int i = 0; i < 10; ++i)\nif (a == b[i]) {\n// oops! \"a\" should be \"a[i]\"\ndo something for when\na[i] and b[i] are equal;\n}\nelse {\ndo something for when they’re not;\n}\nWe intended to compare each element of a to the corresponding ele-\nment in b, but we accidentally omitted the subscripting syntax when\nwe typed a. Certainly we expect this to elicit all manner of unpleasant\ncommentary from our compilers, but they will complain not at all.\nThat’s because they see a call to operator== with arguments of type\nArray<int> (for a) and int (for b[i]), and though there is no opera-\ntor== function taking those types, our compilers notice they can con-\nvert the int into an Array<int> object by calling the Array<int>\nconstructor that takes a single int as an argument. This they proceed\nto do, thus generating code for a program we never meant to write, one\nthat looks like this:\nfor (int i = 0; i < 10; ++i)\nif (a == static_cast< Array<int> >(b[i])) ...\nEach iteration through the loop thus compares the contents of a with\nthe contents of a temporary array of size b[i] (whose contents are pre-\nsumably undefined). Not only is this unlikely to behave in a satisfac-\ntory manner, it is also tremendously inefficient, because each time\nthrough the loop we both create and destroy a temporary Array<int>\nobject (see Item 19).\nThe drawbacks to implicit type conversion operators can be avoided by\nsimply failing to declare the operators, but single-argument construc-\ntors cannot be so easily waved away. After all, you may really want to\noffer single-argument constructors to your clients. At the same time,\nyou may wish to prevent compilers from calling such constructors in-\ndiscriminately. Fortunately, there is a way to have it all. In fact, there\nare two ways: the easy way and the way you’ll have to use if your com-\npilers don’t yet support the easy way.\nThe easy way is to avail yourself of one of the newest C++ features, the\nexplicit keyword. This feature was introduced specifically to address\nthe problem of implicit type conversion, and its use is about as\nstraightforward as can be. Constructors can be declared explicit,\nand if they are, compilers are prohibited from invoking them for pur-\n",
      "content_length": 2251,
      "extraction_method": "Direct"
    },
    {
      "page_number": 46,
      "chapter": null,
      "content": "Conversion Functions\n29\nposes of implicit type conversion. Explicit conversions are still legal,\nhowever:\ntemplate<class T>\nclass Array {\npublic:\n...\nexplicit Array(int size);\n// note use of \"explicit\"\n...\n};\nArray<int> a(10);\n// okay, explicit ctors can\n// be used as usual for \n// object construction\nArray<int> b(10);\n// also okay\nif (a == b[i]) ...\n// error! no way to\n// implicitly convert\n// int to Array<int>\nif (a == Array<int>(b[i])) ... // okay, the conversion\n// from int to Array<int> is\n// explicit (but the logic of\n// the code is suspect)\nif (a == static_cast< Array<int> >(b[i])) ...\n// equally okay, equally\n// suspect\nif (a == (Array<int>)b[i]) ... // C-style casts are also\n// okay, but the logic of\n// the code is still suspect\nIn the example using static_cast (see Item 2), the space separating\nthe two “>” characters is no accident. If the statement were written like\nthis,\nif (a == static_cast<Array<int>>(b[i])) ...\nit would have a different meaning. That’s because C++ compilers parse\n“>>” as a single token. Without a space between the “>” characters, the\nstatement would generate a syntax error.\nIf your compilers don’t yet support explicit, you’ll have to fall back\non home-grown methods for preventing the use of single-argument\nconstructors as implicit type conversion functions. Such methods are\nobvious only after you’ve seen them.\nI mentioned earlier that there are complicated rules governing which\nsequences of implicit type conversions are legitimate and which are\nnot. One of those rules is that no sequence of conversions is allowed to\ncontain more than one user-defined conversion (i.e., a call to a single-\nargument constructor or an implicit type conversion operator). By con-\n",
      "content_length": 1718,
      "extraction_method": "Direct"
    },
    {
      "page_number": 47,
      "chapter": null,
      "content": "30\nItem 5\nstructing your classes properly, you can take advantage of this rule so\nthat the object constructions you want to allow are legal, but the im-\nplicit conversions you don’t want to allow are illegal.\nConsider the Array template again. You need a way to allow an integer\nspecifying the size of the array to be used as a constructor argument,\nbut you must at the same time prevent the implicit conversion of an in-\nteger into a temporary Array object. You accomplish this by first cre-\nating a new class, ArraySize. Objects of this type have only one\npurpose: they represent the size of an array that’s about to be created.\nYou then modify Array’s single-argument constructor to take an Ar-\nraySize object instead of an int. The code looks like this:\ntemplate<class T>\nclass Array {\npublic:\nclass ArraySize {\n// this class is new\npublic:\nArraySize(int numElements): theSize(numElements) {}\nint size() const { return theSize; }\nprivate:\nint theSize;\n};\nArray(int lowBound, int highBound);\nArray(ArraySize size);\n// note new declaration\n...\n};\nHere you’ve nested ArraySize inside Array to emphasize the fact that\nit’s always used in conjunction with that class. You’ve also made Ar-\nraySize public in Array so that anybody can use it. Good.\nConsider what happens when an Array object is defined via the class’s\nsingle-argument constructor:\nArray<int> a(10);\nYour compilers are asked to call a constructor in the Array<int> class\nthat takes an int, but there is no such constructor. Compilers realize\nthey can convert the int argument into a temporary ArraySize ob-\nject, and that ArraySize object is just what the Array<int> construc-\ntor needs, so compilers perform the conversion with their usual gusto.\nThis allows the function call (and the attendant object construction) to\nsucceed. \nThe fact that you can still construct Array objects with an int argu-\nment is reassuring, but it does you little good unless the type conver-\n",
      "content_length": 1936,
      "extraction_method": "Direct"
    },
    {
      "page_number": 48,
      "chapter": null,
      "content": "Increment and Decrement Operators\n31\nsions you want to avoid are prevented. They are. Consider this code\nagain:\nbool operator==( const Array<int>& lhs, \nconst Array<int>& rhs);\nArray<int> a(10);\nArray<int> b(10);\n...\nfor (int i = 0; i < 10; ++i)\nif (a == b[i]) ...\n// oops! \"a\" should be \"a[i]\";\n// this is now an error\nCompilers need an object of type Array<int> on the right-hand side of\nthe “==” in order to call operator== for Array<int> objects, but there\nis no single-argument constructor taking an int argument. Further-\nmore, compilers cannot consider converting the int into a temporary\nArraySize object and then creating the necessary Array<int> object\nfrom this temporary, because that would call for two user-defined con-\nversions, one from int to ArraySize and one from ArraySize to Ar-\nray<int>. Such a conversion sequence is verboten, so compilers must\nissue an error for the code attempting to perform the comparison.\nThe use of the ArraySize class in this example might look like a spe-\ncial-purpose hack, but it’s actually a specific instance of a more gen-\neral technique. Classes like ArraySize are often called proxy classes,\nbecause each object of such a class stands for (is a proxy for) some\nother object. An ArraySize object is really just a stand-in for the inte-\nger used to specify the size of the Array being created. Proxy objects\ncan give you control over aspects of your software’s behavior — in this\ncase implicit type conversions — that is otherwise beyond your grasp,\nso it’s well worth your while to learn how to use them. How, you might\nwonder, can you acquire such learning? One way is to turn to Item 30;\nit’s devoted to proxy classes.\nBefore you turn to proxy classes, however, reflect a bit on the lessons\nof this Item. Granting compilers license to perform implicit type con-\nversions usually leads to more harm than good, so don’t provide con-\nversion functions unless you’re sure you want them.\nItem 6:\nDistinguish between prefix and postfix forms \nof increment and decrement operators.\nIncrement and Decrement Operators\nLong, long ago (the late ’80s) in a language far, far away (C++ at that\ntime), there was no way to distinguish between prefix and postfix invo-\ncations of the ++ and -- operators. Programmers being programmers,\n",
      "content_length": 2276,
      "extraction_method": "Direct"
    },
    {
      "page_number": 49,
      "chapter": null,
      "content": "32\nItem 6\nthey kvetched about this omission, and C++ was extended to allow\noverloading both forms of increment and decrement operators. \nThere was a syntactic problem, however, and that was that overloaded\nfunctions are differentiated on the basis of the parameter types they\ntake, but neither prefix nor postfix increment or decrement takes an\nargument. To surmount this linguistic pothole, it was decreed that\npostfix forms take an int argument, and compilers silently pass 0 as\nthat int when those functions are called:\nclass UPInt {\n// \"unlimited precision int\"\npublic:\nUPInt& operator++();\n// prefix ++\nconst UPInt operator++(int);\n// postfix ++\nUPInt& operator--();\n// prefix --\nconst UPInt operator--(int); // postfix --\nUPInt& operator+=(int);\n// a += operator for UPInts\n// and ints\n...\n};\nUPInt i;\n++i;\n// calls i.operator++();\ni++;\n// calls i.operator++(0);\n--i;\n// calls i.operator--();\ni--;\n// calls i.operator--(0);\nThis convention is a little on the odd side, but you’ll get used to it. More\nimportant to get used to, however, is this: the prefix and postfix forms\nof these operators return different types. In particular, prefix forms re-\nturn a reference, postfix forms return a const object. We’ll focus here\non the prefix and postfix ++ operators, but the story for the -- operators\nis analogous. \nFrom your days as a C programmer, you may recall that the prefix\nform of the increment operator is sometimes called “increment and\nfetch,” while the postfix form is often known as “fetch and increment.”\nThese two phrases are important to remember, because they all but act\nas formal specifications for how prefix and postfix increment should be\nimplemented:\n// prefix form: increment and fetch\nUPInt& UPInt::operator++()\n{\n*this += 1;\n// increment\nreturn *this;\n// fetch\n}\n",
      "content_length": 1790,
      "extraction_method": "Direct"
    },
    {
      "page_number": 50,
      "chapter": null,
      "content": "Increment and Decrement Operators\n33\n// postfix form: fetch and increment\nconst UPInt UPInt::operator++(int)\n{\nconst UPInt oldValue = *this;\n// fetch\n++(*this);\n// increment\nreturn oldValue;\n// return what was\n}\n// fetched\nNote how the postfix operator makes no use of its parameter. This is\ntypical. The only purpose of the parameter is to distinguish prefix from\npostfix function invocation. Many compilers issue warnings if you fail\nto use named parameters in the body of the function to which they ap-\nply, and this can be annoying. To avoid such warnings, a common\nstrategy is to omit names for parameters you don’t plan to use; that’s\nwhat’s been done above.\nIt’s clear why postfix increment must return an object (it’s returning\nan old value), but why a const object? Imagine that it did not. Then\nthe following would be legal:\nUPInt i;\ni++++;\n// apply postfix increment\n// twice\nThis is the same as\ni.operator++(0).operator++(0);\nand it should be clear that the second invocation of operator++ is\nbeing applied to the object returned from the first invocation.\nThere are two reasons to abhor this. First, it’s inconsistent with the be-\nhavior of the built-in types. A good rule to follow when designing\nclasses is when in doubt, do as the ints do, and the ints most cer-\ntainly do not allow double application of postfix increment:\nint i;\ni++++;\n// error!\nThe second reason is that double application of postfix increment al-\nmost never does what clients expect it to. As noted above, the second\napplication of operator++ in a double increment changes the value of\nthe object returned from the first invocation, not the value of the orig-\ninal object. Hence, if \ni++++;\nwere legal, i would be incremented only once. This is counterintuitive\nand confusing (for both ints and UPInts), so it’s best prohibited. \n",
      "content_length": 1817,
      "extraction_method": "Direct"
    },
    {
      "page_number": 51,
      "chapter": null,
      "content": "34\nItem 6\nC++ prohibits it for ints, but you must prohibit it yourself for classes\nyou write. The easiest way to do this is to make the return type of post-\nfix increment a const object. Then when compilers see\ni++++;\n// same as i.operator++(0).operator++(0);\nthey recognize that the const object returned from the first call to op-\nerator++ is being used to call operator++ again. operator++, how-\never, is a non-const member function, so const objects — such as\nthose returned from postfix operator++ — can’t call it.† If you’ve ever\nwondered if it makes sense to have functions return const objects,\nnow you know: sometimes it does, and postfix increment and decre-\nment are examples.\nIf you’re the kind who worries about efficiency, you probably broke into\na sweat when you first saw the postfix increment function. That func-\ntion has to create a temporary object for its return value (see Item 19),\nand the implementation above also creates an explicit temporary ob-\nject (oldValue) that has to be constructed and destructed. The prefix\nincrement function has no such temporaries. This leads to the possibly\nstartling conclusion that, for efficiency reasons alone, clients of UPInt\nshould prefer prefix increment to postfix increment unless they really\nneed the behavior of postfix increment. Let us be explicit about this.\nWhen dealing with user-defined types, prefix increment should be\nused whenever possible, because it’s inherently more efficient.\nLet us make one more observation about the prefix and postfix incre-\nment operators. Except for their return values, they do the same thing:\nthey increment a value. That is, they’re supposed to do the same thing.\nHow can you be sure the behavior of postfix increment is consistent\nwith that of prefix increment? What guarantee do you have that their\nimplementations won’t diverge over time, possibly as a result of differ-\nent programmers maintaining and enhancing them? Unless you’ve fol-\nlowed the design principle embodied by the code above, you have no\nsuch guarantee. That principle is that postfix increment and decre-\nment should be implemented in terms of their prefix counterparts. You\nthen need only maintain the prefix versions, because the postfix ver-\nsions will automatically behave in a consistent fashion.\nAs you can see, mastering prefix and postfix increment and decrement\nis easy. Once you know their proper return types and that the postfix\noperators should be implemented in terms of the prefix operators,\nthere’s very little more to learn.\n† Alas, it is not uncommon for compilers to fail to enforce this restriction. Before you\nwrite programs that rely on it, test your compilers to make sure they behave correctly.\n",
      "content_length": 2698,
      "extraction_method": "Direct"
    },
    {
      "page_number": 52,
      "chapter": null,
      "content": "Overloading &&, ||, and ,\n35\nItem 7:\nNever overload &&, ||, or ,.\nOverloading &&, ||, and ,\nLike C, C++ employs short-circuit evaluation of boolean expressions.\nThis means that once the truth or falsehood of an expression has been\ndetermined, evaluation of the expression ceases, even if some parts of\nthe expression haven’t yet been examined. For example, in this case,\nchar *p;\n... \nif ((p != 0) && (strlen(p) > 10)) ...\nthere is no need to worry about invoking strlen on p if it’s a null\npointer, because if the test of p against 0 fails, strlen will never be\ncalled. Similarly, given\nint rangeCheck(int index)\n{\nif ((index < lowerBound) || (index > upperBound)) ... \n...\n}\nindex will never be compared to upperBound if it’s less than lower-\nBound.\nThis is the behavior that has been drummed into C and C++ program-\nmers since time immemorial, so this is what they expect. Furthermore,\nthey write programs whose correct behavior depends on short-circuit\nevaluation. In the first code fragment above, for example, it is impor-\ntant that strlen not be invoked if p is a null pointer, because the stan-\ndard for C++ states (as does the standard for C) that the result of\ninvoking strlen on a null pointer is undefined.\nC++ allows you to customize the behavior of the && and || operators\nfor user-defined types. You do it by overloading the functions opera-\ntor&& and operator||, and you can do this at the global scope or on\na per-class basis. If you decide to take advantage of this opportunity,\nhowever, you must be aware that you are changing the rules of the\ngame quite radically, because you are replacing short-circuit seman-\ntics with function call semantics. That is, if you overload operator&&,\nwhat looks to you like this,\nif (expression1 && expression2) ...\nlooks to compilers like one of these:\nif (expression1.operator&&(expression2)) ...\n// when operator&& is a\n// member function\n",
      "content_length": 1895,
      "extraction_method": "Direct"
    },
    {
      "page_number": 53,
      "chapter": null,
      "content": "36\nItem 7\nif (operator&&(expression1, expression2)) ...\n// when operator&& is a\n// global function\nThis may not seem like that big a deal, but function call semantics dif-\nfer from short-circuit semantics in two crucial ways. First, when a\nfunction call is made, all parameters must be evaluated, so when call-\ning the functions operator&& and operator||, both parameters are\nevaluated. There is, in other words, no short circuit. Second, the lan-\nguage specification leaves undefined the order of evaluation of param-\neters to a function call, so there is no way of knowing whether\nexpression1 or expression2 will be evaluated first. This stands in\nstark contrast to short-circuit evaluation, which always evaluates its\narguments in left-to-right order.\nAs a result, if you overload && or ||, there is no way to offer program-\nmers the behavior they both expect and have come to depend on. So\ndon’t overload && or ||.\nThe situation with the comma operator is similar, but before we delve\ninto that, I’ll pause and let you catch the breath you lost when you\ngasped, “The comma operator? There’s a comma operator?” There is in-\ndeed. \nThe comma operator is used to form expressions, and you’re most\nlikely to run across it in the update part of a for loop. The following\nfunction, for example, is based on one in the second edition of Ker-\nnighan’s and Ritchie’s classic The C Programming Language (Prentice-\nHall, 1988):\n// reverse string s in place\nvoid reverse(char s[])\n{\nfor (int i = 0, j = strlen(s)-1;\ni < j;\n++i, --j)\n// aha! the comma operator!\n{\nint c = s[i];\ns[i] = s[j];\ns[j] = c;\n}\n}\nHere, i is incremented and j is decremented in the final part of the for\nloop. It is convenient to use the comma operator here, because only an\nexpression is valid in the final part of a for loop; separate statements\nto change the values of i and j would be illegal.\n",
      "content_length": 1863,
      "extraction_method": "Direct"
    },
    {
      "page_number": 54,
      "chapter": null,
      "content": "Overloading &&, ||, and ,\n37\nJust as there are rules in C++ defining how && and || behave for built-\nin types, there are rules defining how the comma operator behaves for\nsuch types. An expression containing a comma is evaluated by first\nevaluating the part of the expression to the left of the comma, then\nevaluating the expression to the right of the comma; the result of the\noverall comma expression is the value of the expression on the right.\nSo in the final part of the loop above, compilers first evaluate ++i, then\n--j, and the result of the comma expression is the value returned\nfrom --j.\nPerhaps you’re wondering why you need to know this. You need to\nknow because you need to mimic this behavior if you’re going to take\nit upon yourself to write your own comma operator. Unfortunately, you\ncan’t perform the requisite mimicry.\nIf you write operator, as a non-member function, you’ll never be able\nto guarantee that the left-hand expression is evaluated before the\nright-hand expression, because both expressions will be passed as ar-\nguments in a function call (to operator,). But you have no control\nover the order in which a function’s arguments are evaluated. So the\nnon-member approach is definitely out.\nThat leaves only the possibility of writing operator, as a member\nfunction. Even here you can’t rely on the left-hand operand to the\ncomma operator being evaluated first, because compilers are not con-\nstrained to do things that way. Hence, you can’t overload the comma\noperator and also guarantee it will behave the way it’s supposed to. It\ntherefore seems imprudent to overload it at all.\nYou may be wondering if there’s an end to this overloading madness.\nAfter all, if you can overload the comma operator, what can’t you over-\nload? As it turns out, there are limits. You can’t overload the following\noperators:\n.\n.*\n::\n?:\nnew\ndelete\nsizeof\ntypeid\nstatic_cast\ndynamic_cast const_cast\nreinterpret_cast\nYou can overload these:\noperator new\noperator delete\noperator new[]\noperator delete[]\n+   \n- \n* \n/\n%\n^\n&\n|\n~\n!\n=\n<\n>\n+=\n-=\n*=\n/=\n%=\n^=\n&=\n|=\n<<\n>>\n>>=\n<<=\n==\n!=\n<=\n>=\n&&\n||\n++\n--\n,\n->*\n->\n()\n[]\n",
      "content_length": 2120,
      "extraction_method": "Direct"
    },
    {
      "page_number": 55,
      "chapter": null,
      "content": "38\nItem 8\n(For information on the new and delete operators, as well as opera-\ntor new, operator delete, operator new[], and operator de-\nlete[], see Item 8.)\nOf course, just because you can overload these operators is no reason\nto run off and do it. The purpose of operator overloading is to make\nprograms easier to read, write, and understand, not to dazzle others\nwith your knowledge that comma is an operator. If you don’t have a\ngood reason for overloading an operator, don’t overload it. In the case\nof &&, ||, and ,, it’s difficult to have a good reason, because no matter\nhow hard you try, you can’t make them behave the way they’re sup-\nposed to.\nItem 8:\nUnderstand the different meanings of new\nand delete.\nThe Different Meanings of new and delete\nIt occasionally seems as if people went out of their way to make C++\nterminology difficult to understand. Case in point: the difference be-\ntween the new operator and operator new.\nWhen you write code like this,\nstring *ps = new string(\"Memory Management\");\nthe new you are using is the new operator. This operator is built into\nthe language and, like sizeof, you can’t change its meaning: it always\ndoes the same thing. What it does is twofold. First, it allocates enough\nmemory to hold an object of the type requested. In the example above,\nit allocates enough memory to hold a string object. Second, it calls a\nconstructor to initialize an object in the memory that was allocated.\nThe new operator always does those two things; you can’t change its\nbehavior in any way.\nWhat you can change is how the memory for an object is allocated. The\nnew operator calls a function to perform the requisite memory alloca-\ntion, and you can rewrite or overload that function to change its behav-\nior. The name of the function the new operator calls to allocate memory\nis operator new. Honest.\nThe operator new function is usually declared like this:\nvoid * operator new(size_t size);\nThe return type is void*, because this function returns a pointer to\nraw, uninitialized memory. (If you like, you can write a version of op-\nerator new that initializes the memory to some value before returning\na pointer to it, but this is not commonly done.) The size_t parameter\nspecifies how much memory to allocate. You can overload operator\n",
      "content_length": 2277,
      "extraction_method": "Direct"
    },
    {
      "page_number": 56,
      "chapter": null,
      "content": "The Different Meanings of new and delete\n39\nnew by adding additional parameters, but the first parameter must al-\nways be of type size_t.\nYou’ll probably never want to call operator new directly, but on the off\nchance you do, you’ll call it just like any other function:\nvoid *rawMemory = operator new(sizeof(string));\nHere operator new will return a pointer to a chunk of memory large\nenough to hold a string object.\nLike malloc, operator new’s only responsibility is to allocate memory.\nIt knows nothing about constructors. All operator new understands is\nmemory allocation. It is the job of the new operator to take the raw\nmemory that operator new returns and transform it into an object.\nWhen your compilers see a statement like\nstring *ps = new string(\"Memory Management\");\nthey must generate code that more or less corresponds to this:\nvoid *memory =\n// get raw memory\noperator new(sizeof(string));\n// for a string\n// object\ncall string::string(\"Memory Management\")\n// initialize the\non *memory;\n// object in the\n// memory\nstring *ps = \n// make ps point to\nstatic_cast<string*>(memory);\n// the new object\nNotice that the second step above involves calling a constructor, some-\nthing you, a mere programmer, are prohibited from doing. Your com-\npilers are unconstrained by mortal limits, however, and they can do\nwhatever they like. That’s why you must use the new operator if you\nwant to conjure up a heap-based object: you can’t directly call the con-\nstructor necessary to initialize the object (including such crucial com-\nponents as its vtbl — see Item 24).\nPlacement new\nThere are times when you really want to call a constructor directly. In-\nvoking a constructor on an existing object makes no sense, because\nconstructors initialize objects, and an object can only be initialized —\ngiven its first value — once. But occasionally you have some raw mem-\nory that’s already been allocated, and you need to construct an object\nin the memory you have. A special version of operator new called\nplacement new allows you to do it.\nAs an example of how placement new might be used, consider this:\n",
      "content_length": 2102,
      "extraction_method": "Direct"
    },
    {
      "page_number": 57,
      "chapter": null,
      "content": "40\nItem 8\nclass Widget {\npublic:\nWidget(int widgetSize);\n...\n};\nWidget * constructWidgetInBuffer(void *buffer,\nint widgetSize)\n{\nreturn new (buffer) Widget(widgetSize);\n}\nThis function returns a pointer to a Widget object that’s constructed\nwithin the buffer passed to the function. Such a function might be use-\nful for applications using shared memory or memory-mapped I/O, be-\ncause objects in such applications must be placed at specific\naddresses or in memory allocated by special routines. (For a different\nexample of how placement new can be used, see Item 4.)\nInside constructWidgetInBuffer, the expression being returned is\nnew (buffer) Widget(widgetSize)\nThis looks a little strange at first, but it’s just a use of the new operator\nin which an additional argument (buffer) is being specified for the im-\nplicit call that the new operator makes to operator new. The operator\nnew thus called must, in addition to the mandatory size_t argument,\naccept a void* parameter that points to the memory the object being\nconstructed is to occupy. That operator new is placement new, and it\nlooks like this:\nvoid * operator new(size_t, void *location)\n{\nreturn location;\n}\nThis is probably simpler than you expected, but this is all placement\nnew needs to do. After all, the purpose of operator new is to find mem-\nory for an object and return a pointer to that memory. In the case of\nplacement new, the caller already knows what the pointer to the mem-\nory should be, because the caller knows where the object is supposed\nto be placed. All placement new has to do, then, is return the pointer\nthat’s passed into it. (The unused (but mandatory) size_t parameter\nhas no name to keep compilers from complaining about its not being\nused; see Item 6.) Placement new is part of the standard C++ library.\nTo use placement new, all you have to do is #include <new> (or, if your\ncompilers don’t yet support the new-style header names, <new.h>).\nIf we step back from placement new for a moment, we’ll see that the re-\nlationship between the new operator and operator new, though per-\nhaps terminologically confusing, is conceptually straightforward. If\n",
      "content_length": 2143,
      "extraction_method": "Direct"
    },
    {
      "page_number": 58,
      "chapter": null,
      "content": "The Different Meanings of new and delete\n41\nyou want to create an object on the heap, use the new operator. It both\nallocates memory and calls a constructor for the object. If you only\nwant to allocate memory, call operator new; no constructor will be\ncalled. If you want to customize the memory allocation that takes place\nwhen heap objects are created, write your own version of operator\nnew and use the new operator; it will automatically invoke your custom\nversion of operator new. If you want to construct an object in memory\nyou’ve already got a pointer to, use placement new.\nDeletion and Memory Deallocation\nTo avoid resource leaks, every dynamic allocation must be matched by\nan equal and opposite deallocation. The function operator delete is\nto the built-in delete operator as operator new is to the new operator.\nWhen you say something like this,\nstring *ps;\n...\ndelete ps;\n// use the delete operator\nyour compilers must generate code both to destruct the object ps\npoints to and to deallocate the memory occupied by that object.\nThe memory deallocation is performed by the operator delete func-\ntion, which is usually declared like this:\nvoid operator delete(void *memoryToBeDeallocated);\nHence,\ndelete ps;\ncauses compilers to generate code that approximately corresponds to\nthis:\nps->~string();\n// call the object’s dtor\noperator delete(ps);\n// deallocate the memory\n// the object occupied\nOne implication of this is that if you want to deal only with raw, unini-\ntialized memory, you should bypass the new and delete operators en-\ntirely. Instead, you should call operator new to get the memory and\noperator delete to return it to the system:\nvoid *buffer = \n// allocate enough\noperator new(50*sizeof(char));\n// memory to hold 50\n// chars; call no ctors\n...\noperator delete(buffer);\n// deallocate the memory;\n// call no dtors\n",
      "content_length": 1841,
      "extraction_method": "Direct"
    },
    {
      "page_number": 59,
      "chapter": null,
      "content": "42\nItem 8\nThis is the C++ equivalent of calling malloc and free.\nIf you use placement new to create an object in some memory, you\nshould avoid using the delete operator on that memory. That’s be-\ncause the delete operator calls operator delete to deallocate the\nmemory, but the memory containing the object wasn’t allocated by op-\nerator new in the first place; placement new just returned the pointer\nthat was passed to it. Who knows where that pointer came from? In-\nstead, you should undo the effect of the constructor by explicitly call-\ning the object’s destructor:\n// functions for allocating and deallocating memory in\n// shared memory\nvoid * mallocShared(size_t size);\nvoid freeShared(void *memory);\nvoid *sharedMemory = mallocShared(sizeof(Widget));\nWidget *pw =\n// as above,\nconstructWidgetInBuffer( sharedMemory, 10);\n// placement\n// new is used\n...\ndelete pw;\n// undefined! sharedMemory came from\n// mallocShared, not operator new\npw->~Widget();\n// fine, destructs the Widget pointed to\n// by pw, but doesn’t deallocate the \n// memory containing the Widget\nfreeShared(pw);\n// fine, deallocates the memory pointed\n// to by pw, but calls no destructor\nAs this example demonstrates, if the raw memory passed to placement\nnew was itself dynamically allocated (through some unconventional\nmeans), you must still deallocate that memory if you wish to avoid a\nmemory leak.\nArrays\nSo far so good, but there’s farther to go. Everything we’ve examined so\nfar concerns itself with only one object at a time. What about array al-\nlocation? What happens here?\nstring *ps = new string[10];\n// allocate an array of\n// objects\nThe new being used is still the new operator, but because an array is\nbeing created, the new operator behaves slightly differently from the\ncase of single-object creation. For one thing, memory is no longer allo-\ncated by operator new. Instead, it’s allocated by the array-allocation\nequivalent, a function called operator new[] (often referred to as “ar-\n",
      "content_length": 1979,
      "extraction_method": "Direct"
    },
    {
      "page_number": 60,
      "chapter": null,
      "content": "The Different Meanings of new and delete\n43\nray new.”) Like operator new, operator new[] can be overloaded.\nThis allows you to seize control of memory allocation for arrays in the\nsame way you can control memory allocation for single objects.\n(operator new[] is a relatively recent addition to C++, so your compil-\ners may not support it yet. If they don’t, the global version of operator\nnew will be used to allocate memory for every array, regardless of the\ntype of objects in the array. Customizing array-memory allocation\nunder such compilers is daunting, because it requires that you rewrite\nthe global operator new. This is not a task to be undertaken lightly.\nBy default, the global operator new handles all dynamic memory allo-\ncation in a program, so any change in its behavior has a dramatic and\npervasive effect. Furthermore, there is only one global operator new\nwith the “normal” signature (i.e., taking the single size_t parameter),\nso if you decide to claim it as your own, you instantly render your soft-\nware incompatible with any library that makes the same decision. (See\nalso Item 27.) As a result of these considerations, custom memory\nmanagement for arrays is not usually a reasonable design decision for\ncompilers lacking support for operator new[].)\nThe second way in which the new operator behaves differently for ar-\nrays than for objects is in the number of constructor calls it makes. For\narrays, a constructor must be called for each object in the array:\nstring *ps =\n// call operator new[] to allocate\nnew string[10];\n// memory for 10 string objects,\n// then call the default string\n// ctor for each array element\nSimilarly, when the delete operator is used on an array, it calls a de-\nstructor for each array element and then calls operator delete[] to\ndeallocate the memory:\ndelete [] ps;\n// call the string dtor for each\n// array element, then call \n// operator delete[] to \n// deallocate the array’s memory\nJust as you can replace or overload operator delete, you can replace\nor overload operator delete[]. There are some restrictions on how\nthey can be overloaded, however; consult a good C++ text for details.\n(For ideas on good C++ texts, see the recommendations beginning on\npage 285.)\nSo there you have it. The new and delete operators are built-in and\nbeyond your control, but the memory allocation and deallocation func-\ntions they call are not. When you think about customizing the behavior\nof the new and delete operators, remember that you can’t really do it.\nYou can modify how they do what they do, but what they do is fixed by\nthe language.\n",
      "content_length": 2588,
      "extraction_method": "Direct"
    },
    {
      "page_number": 61,
      "chapter": null,
      "content": "Exceptions\nExceptions\nThe addition of exceptions to C++ changes things. Profoundly. Radi-\ncally. Possibly uncomfortably. The use of raw, unadorned pointers, for\nexample, becomes risky. Opportunities for resource leaks increase in\nnumber. It becomes more difficult to write constructors and destruc-\ntors that behave the way we want them to. Special care must be taken\nto prevent program execution from abruptly halting. Executables and\nlibraries typically increase in size and decrease in speed.\nAnd these are just the things we know. There is much the C++ commu-\nnity does not know about writing programs using exceptions, includ-\ning, for the most part, how to do it correctly. There is as yet no\nagreement on a body of techniques that, when applied routinely, leads\nto software that behaves predictably and reliably when exceptions are\nthrown. (For insight into some of the issues involved, see the article by\nTom Cargill I refer to on page 287.)\nWe do know this much: programs that behave well in the presence of\nexceptions do so because they were designed to, not because they hap-\npen to. Exception-safe programs are not created by accident. The\nchances of a program behaving well in the presence of exceptions when\nit was not designed for exceptions are about the same as the chances\nof a program behaving well in the presence of multiple threads of con-\ntrol when it was not designed for multi-threaded execution: about zero.\nThat being the case, why use exceptions? Error codes have sufficed for\nC programmers ever since C was invented, so why mess with excep-\ntions, especially if they’re as problematic as I say? The answer is sim-\nple: exceptions cannot be ignored. If a function signals an exceptional\ncondition by setting a status variable or returning an error code, there\nis no way to guarantee the function’s caller will check the variable or\nexamine the code. As a result, execution may continue long past the\npoint where the condition was encountered. If the function signals the\n",
      "content_length": 1999,
      "extraction_method": "Direct"
    },
    {
      "page_number": 62,
      "chapter": null,
      "content": "Using Destructors to Prevent Resource Leaks\n45\ncondition by throwing an exception, however, and that exception is not\ncaught, program execution immediately ceases. \nThis is behavior that C programmers can approach only by using set-\njmp and longjmp. But longjmp exhibits a serious deficiency when\nused with C++: it fails to call destructors for local objects when it ad-\njusts the stack. Most C++ programs depend on such destructors being\ncalled, so setjmp and longjmp make a poor substitute for true excep-\ntions. If you need a way of signaling exceptional conditions that cannot\nbe ignored, and if you must ensure that local destructors are called\nwhen searching the stack for code that can handle exceptional condi-\ntions, you need C++ exceptions. It’s as simple as that.\nBecause we have much to learn about programming with exceptions,\nthe Items that follow comprise an incomplete guide to writing excep-\ntion-safe software. Nevertheless, they introduce important consider-\nations for anyone using exceptions in C++. By heeding the guidance in\nthe material below, you’ll improve the correctness, robustness, and ef-\nficiency of the software you write, and you’ll sidestep many problems\nthat commonly arise when working with exceptions.\nItem 9:\nUse destructors to prevent resource leaks.\nUsing Destructors to Prevent Resource Leaks\nSay good-bye to pointers. Admit it: you never really liked them that\nmuch anyway. \nOkay, you don’t have to say good-bye to all pointers, but you do need\nto say sayonara to pointers that are used to manipulate local re-\nsources. Suppose, for example, you’re writing software at the Shelter\nfor Adorable Little Animals, an organization that finds homes for pup-\npies and kittens. Each day the shelter creates a file containing infor-\nmation on the adoptions it arranged that day, and your job is to write\na program to read these files and do the appropriate processing for\neach adoption.\nA reasonable approach to this task is to define an abstract base class,\nALA (“Adorable Little Animal”), plus concrete derived classes for pup-\npies and kittens. A virtual function, processAdoption, handles the\nnecessary species-specific processing:\nALA\nKitten\nPuppy\n",
      "content_length": 2187,
      "extraction_method": "Direct"
    },
    {
      "page_number": 63,
      "chapter": null,
      "content": "46\nItem 9\nclass ALA {\npublic:\nvirtual void processAdoption() = 0;\n...\n};\nclass Puppy: public ALA {\npublic:\nvirtual void processAdoption();\n...\n};\nclass Kitten: public ALA {\npublic:\nvirtual void processAdoption();\n...\n};\nYou’ll need a function that can read information from a file and pro-\nduce either a Puppy object or a Kitten object, depending on the infor-\nmation in the file. This is a perfect job for a virtual constructor, a kind\nof function described in Item 25. For our purposes here, the function’s\ndeclaration is all we need:\n// read animal information from s, then return a pointer\n// to a newly allocated object of the appropriate type\nALA * readALA(istream& s);\nThe heart of your program is likely to be a function that looks some-\nthing like this:\nvoid processAdoptions(istream& dataSource)\n{\nwhile (dataSource) {\n// while there’s data\nALA *pa = readALA(dataSource);\n// get next animal\npa->processAdoption();\n// process adoption\ndelete pa;\n// delete object that\n}\n// readALA returned\n}\nThis function loops through the information in dataSource, process-\ning each entry as it goes. The only mildly tricky thing is the need to re-\nmember to delete pa at the end of each iteration. This is necessary\nbecause readALA creates a new heap object each time it’s called. With-\nout the call to delete, the loop would contain a resource leak.\nNow consider what would happen if pa->processAdoption threw an\nexception. processAdoptions fails to catch exceptions, so the excep-\ntion would propagate to processAdoptions’s caller. In doing so, all\nstatements in processAdoptions after the call to pa->processAdop-\ntion would be skipped, and that means pa would never be deleted. As\n",
      "content_length": 1681,
      "extraction_method": "Direct"
    },
    {
      "page_number": 64,
      "chapter": null,
      "content": "Using Destructors to Prevent Resource Leaks\n47\na result, anytime pa->processAdoption throws an exception, pro-\ncessAdoptions contains a resource leak.\nPlugging the leak is easy enough,\nvoid processAdoptions(istream& dataSource)\n{\nwhile (dataSource) {\nALA *pa = readALA(dataSource);\ntry {\npa->processAdoption();\n}\ncatch (...) {\n// catch all exceptions\ndelete pa;\n// avoid resource leak when an \n// exception is thrown\nthrow;\n// propagate exception to caller\n}\ndelete pa;\n// avoid resource leak when no\n}\n// exception is thrown\n}\nbut then you have to litter your code with try and catch blocks. More\nimportantly, you are forced to duplicate cleanup code that is common\nto both normal and exceptional paths of control. In this case, the call\nto delete must be duplicated. Like all replicated code, this is annoy-\ning to write and difficult to maintain, but it also feels wrong. Regard-\nless of whether we leave processAdoptions by a normal return or by\nthrowing an exception, we need to delete pa, so why should we have to\nsay that in more than one place?\nWe don’t have to if we can somehow move the cleanup code that must\nalways be executed into the destructor for an object local to process-\nAdoptions. That’s because local objects are always destroyed when\nleaving a function, regardless of how that function is exited. (The only\nexception to this rule is when you call longjmp, and this shortcoming\nof longjmp is the primary reason why C++ has support for exceptions\nin the first place.) Our real concern, then, is moving the delete from\nprocessAdoptions into a destructor for an object local to processA-\ndoptions.\nThe solution is to replace the pointer pa with an object that acts like a\npointer. That way, when the pointer-like object is (automatically) de-\nstroyed, we can have its destructor call delete. Objects that act like\npointers, but do more, are called smart pointers, and, as Item 28 ex-\nplains, you can make pointer-like objects very smart indeed. In this\ncase, we don’t need a particularly brainy pointer, we just need a\n",
      "content_length": 2038,
      "extraction_method": "Direct"
    },
    {
      "page_number": 65,
      "chapter": null,
      "content": "48\nItem 9\npointer-like object that knows enough to delete what it points to when\nthe pointer-like object goes out of scope.\nIt’s not difficult to write a class for such objects, but we don’t need to.\nThe standard C++ library contains a class template called auto_ptr\nthat does just what we want. Each auto_ptr class takes a pointer to a\nheap object in its constructor and deletes that object in its destructor.\nBoiled down to these essential functions, auto_ptr looks like this:\ntemplate<class T>\nclass auto_ptr {\npublic:\nauto_ptr(T *p = 0): ptr(p) {}\n// save ptr to object\n~auto_ptr() { delete ptr; }\n// delete ptr to object\nprivate:\nT *ptr;\n// raw ptr to object\n};\nThe standard version of auto_ptr is much fancier, and this stripped-\ndown implementation isn’t suitable for real use† (we must add at least\nthe copy constructor, assignment operator, and pointer-emulating\nfunctions discussed in Item 28), but the concept behind it should be\nclear: use auto_ptr objects instead of raw pointers, and you won’t\nhave to worry about heap objects not being deleted, not even when ex-\nceptions are thrown. (Because the auto_ptr destructor uses the sin-\ngle-object form of delete, auto_ptr is not suitable for use with\npointers to arrays of objects. If you’d like an auto_ptr-like template\nfor arrays, you’ll have to write your own. In such cases, however, it’s\noften a better design decision to use a vector instead of an array, any-\nway.)\nUsing an auto_ptr object instead of a raw pointer, processAdop-\ntions looks like this:\nvoid processAdoptions(istream& dataSource)\n{\nwhile (dataSource) {\nauto_ptr<ALA> pa(readALA(dataSource));\npa->processAdoption();\n}\n}\nThis version of processAdoptions differs from the original in only\ntwo ways. First, pa is declared to be an auto_ptr<ALA> object, not a\nraw ALA* pointer. Second, there is no delete statement at the end of\nthe loop. That’s it. Everything else is identical, because, except for de-\nstruction, auto_ptr objects act just like normal pointers. Easy, huh?\n† A complete implementation of an almost-standard auto_ptr appears on pages 291-294.\n",
      "content_length": 2087,
      "extraction_method": "Direct"
    },
    {
      "page_number": 66,
      "chapter": null,
      "content": "Using Destructors to Prevent Resource Leaks\n49\nThe idea behind auto_ptr — using an object to store a resource that\nneeds to be automatically released and relying on that object’s de-\nstructor to release it — applies to more than just pointer-based re-\nsources. Consider a function in a GUI application that needs to create\na window to display some information:\n// this function may leak resources if an exception\n// is thrown\nvoid displayInfo(const Information& info)\n{\nWINDOW_HANDLE w(createWindow());\ndisplay info in window corresponding to w;\ndestroyWindow(w);\n}\nMany window systems have C-like interfaces that use functions like\ncreateWindow and destroyWindow to acquire and release window re-\nsources. If an exception is thrown during the process of displaying\ninfo in w, the window for which w is a handle will be lost just as surely\nas any other dynamically allocated resource. \nThe solution is the same as it was before. Create a class whose con-\nstructor and destructor acquire and release the resource:\n// class for acquiring and releasing a window handle\nclass WindowHandle {\npublic:\nWindowHandle(WINDOW_HANDLE handle): w(handle) {}\n~WindowHandle() { destroyWindow(w); }\noperator WINDOW_HANDLE() { return w; }\n// see below\nprivate:\nWINDOW_HANDLE w;\n// The following functions are declared private to prevent \n// multiple copies of a WINDOW_HANDLE from being created.\n// See Item 28 for a discussion of a more flexible approach.\nWindowHandle(const WindowHandle&);\nWindowHandle& operator=(const WindowHandle&);\n};\nThis looks just like the auto_ptr template, except that assignment\nand copying are explicitly prohibited, and there is an implicit conver-\nsion operator that can be used to turn a WindowHandle into a\nWINDOW_HANDLE. This capability is essential to the practical applica-\ntion of a WindowHandle object, because it means you can use a Win-\ndowHandle just about anywhere you would normally use a raw\nWINDOW_HANDLE. (See Item 5, however, for why you should generally be\nleery of implicit type conversion operators.)\n",
      "content_length": 2034,
      "extraction_method": "Direct"
    },
    {
      "page_number": 67,
      "chapter": null,
      "content": "50\nItem 10\nGiven the WindowHandle class, we can rewrite displayInfo as fol-\nlows:\n// this function avoids leaking resources if an \n// exception is thrown\nvoid displayInfo(const Information& info)\n{\nWindowHandle w(createWindow());\ndisplay info in window corresponding to w;\n}\nEven if an exception is thrown within displayInfo, the window cre-\nated by createWindow will always† be destroyed.\nBy adhering to the rule that resources should be encapsulated inside\nobjects, you can usually avoid resource leaks in the presence of excep-\ntions. But what happens if an exception is thrown while you’re in the\nprocess of acquiring a resource, e.g., while you’re in the constructor of\na resource-acquiring class? What happens if an exception is thrown\nduring the automatic destruction of such resources? Don’t construc-\ntors and destructors call for special techniques? They do, and you can\nread about them in Items 10 and 11.\nItem 10: Prevent resource leaks in constructors.\nAvoiding Resource Leaks in Constructors\nImagine you’re developing software for a multimedia address book.\nSuch an address book might hold, in addition to the usual textual in-\nformation of a person’s name, address, and phone numbers, a picture\nof the person and the sound of their voice (possibly giving the proper\npronunciation of their name).\nTo implement the book, you might come up with a design like this:\nclass Image {\n// for image data\npublic:\nImage(const string& imageDataFileName);\n...\n};\nclass AudioClip {\n// for audio data\npublic:\nAudioClip(const string& audioDataFileName);\n...\n};\nclass PhoneNumber { ... };\n// for holding phone numbers\n† Well, almost always. If the exception is not caught, the program will terminate. In that\ncase, there is no guarantee that local objects (such as w in the example) will have their\ndestructors called. Some compilers call them, some do not. Both behaviors are valid.\n",
      "content_length": 1881,
      "extraction_method": "Direct"
    },
    {
      "page_number": 68,
      "chapter": null,
      "content": "Avoiding Resource Leaks in Constructors\n51\nclass BookEntry {\n// for each entry in the\npublic:\n// address book\nBookEntry(const string& name,\nconst string& address = \"\",\nconst string& imageFileName = \"\",\nconst string& audioClipFileName = \"\");\n~BookEntry();\n// phone numbers are added via this function\nvoid addPhoneNumber(const PhoneNumber& number);\n...\nprivate:\nstring theName;\n// person’s name\nstring theAddress;\n// their address \nlist<PhoneNumber> thePhones; // their phone numbers\nImage *theImage;\n// their image\nAudioClip *theAudioClip;\n// an audio clip from them\n};\nEach BookEntry must have name data, so you require that as a con-\nstructor argument (see Item 4), but the other fields — the person’s ad-\ndress and the names of files containing image and audio data — are\noptional. Note the use of the list class to hold the person’s phone\nnumbers. This is one of several container classes that are part of the\nstandard C++ library (see Item 35).\nA straightforward way to write the BookEntry constructor and de-\nstructor is as follows:\nBookEntry::BookEntry(const string& name, \nconst string& address,\nconst string& imageFileName,\nconst string& audioClipFileName)\n: theName(name), theAddress(address), \ntheImage(0), theAudioClip(0)\n{\nif (imageFileName != \"\") {\ntheImage = new Image(imageFileName);\n}\nif (audioClipFileName != \"\") {\ntheAudioClip = new AudioClip(audioClipFileName);\n}\n}\nBookEntry::~BookEntry()\n{\ndelete theImage;\ndelete theAudioClip;\n}\n",
      "content_length": 1452,
      "extraction_method": "Direct"
    },
    {
      "page_number": 69,
      "chapter": null,
      "content": "52\nItem 10\nThe constructor initializes the pointers theImage and theAudioClip\nto null, then makes them point to real objects if the corresponding ar-\nguments are non-empty strings. The destructor deletes both pointers,\nthus ensuring that a BookEntry object doesn’t give rise to a resource\nleak. Because C++ guarantees it’s safe to delete null pointers, BookEn-\ntry’s destructor need not check to see if the pointers actually point to\nsomething before deleting them.\nEverything looks fine here, and under normal conditions everything is\nfine, but under abnormal conditions — under exceptional conditions —\nthings are not fine at all. \nConsider what will happen if an exception is thrown during execution\nof this part of the BookEntry constructor:\nif (audioClipFileName != \"\") {\ntheAudioClip = new AudioClip(audioClipFileName);\n}\nAn exception might arise because operator new (see Item 8) is unable\nto allocate enough memory for an AudioClip object. One might also\narise because the AudioClip constructor itself throws an exception.\nRegardless of the cause of the exception, if one is thrown within the\nBookEntry constructor, it will be propagated to the site where the\nBookEntry object is being created.\nNow, if an exception is thrown during creation of the object theAudio-\nClip is supposed to point to (thus transferring control out of the\nBookEntry constructor), who deletes the object that theImage already\npoints to? The obvious answer is that BookEntry’s destructor does,\nbut the obvious answer is wrong. BookEntry’s destructor will never be\ncalled. Never.\nC++ destroys only fully constructed objects, and an object isn’t fully\nconstructed until its constructor has run to completion. So if a\nBookEntry object b is created as a local object,\nvoid testBookEntryClass()\n{\nBookEntry b(\"Addison-Wesley Publishing Company\",\n\"One Jacob Way, Reading, MA 01867\");\n...\n}\nand an exception is thrown during construction of b, b’s destructor will\nnot be called. Furthermore, if you try to take matters into your own\nhands by allocating b on the heap and then calling delete if an excep-\ntion is thrown,\n",
      "content_length": 2096,
      "extraction_method": "Direct"
    },
    {
      "page_number": 70,
      "chapter": null,
      "content": "Avoiding Resource Leaks in Constructors\n53\nvoid testBookEntryClass()\n{\nBookEntry *pb = 0;\ntry {\npb = new BookEntry( \"Addison-Wesley Publishing Company\",\n\"One Jacob Way, Reading, MA 01867\");\n...\n}\ncatch (...) {\n// catch all exceptions\ndelete pb;\n// delete pb when an\n// exception is thrown\nthrow;\n// propagate exception to\n}\n// caller\ndelete pb;\n// delete pb normally\n}\nyou’ll find that the Image object allocated inside BookEntry’s con-\nstructor is still lost, because no assignment is made to pb unless the\nnew operation succeeds. If BookEntry’s constructor throws an excep-\ntion, pb will be the null pointer, so deleting it in the catch block does\nnothing except make you feel better about yourself. Using the smart\npointer class auto_ptr<BookEntry> (see Item 9) instead of a raw\nBookEntry* won’t do you any good either, because the assignment to\npb still won’t be made unless the new operation succeeds.\nThere is a reason why C++ refuses to call destructors for objects that\nhaven’t been fully constructed, and it’s not simply to make your life\nmore difficult. It’s because it would, in many cases, be a nonsensical\nthing — possibly a harmful thing — to do. If a destructor were invoked\non an object that wasn’t fully constructed, how would the destructor\nknow what to do? The only way it could know would be if bits had been\nadded to each object indicating how much of the constructor had been\nexecuted. Then the destructor could check the bits and (maybe) figure\nout what actions to take. Such bookkeeping would slow down con-\nstructors, and it would make each object larger, too. C++ avoids this\noverhead, but the price you pay is that partially constructed objects\naren’t automatically destroyed.\nBecause C++ won’t clean up after objects that throw exceptions during\nconstruction, you must design your constructors so that they clean up\nafter themselves. Often, this involves simply catching all possible ex-\nceptions, executing some cleanup code, then rethrowing the exception\nso it continues to propagate. This strategy can be incorporated into the\nBookEntry constructor like this:\n",
      "content_length": 2091,
      "extraction_method": "Direct"
    },
    {
      "page_number": 71,
      "chapter": null,
      "content": "54\nItem 10\nBookEntry::BookEntry( const string& name, \nconst string& address,\nconst string& imageFileName,\nconst string& audioClipFileName)\n: theName(name), theAddress(address), \ntheImage(0), theAudioClip(0)\n{\ntry {\n// this try block is new\nif (imageFileName != \"\") {\ntheImage = new Image(imageFileName);\n}\nif (audioClipFileName != \"\") {\ntheAudioClip = new AudioClip(audioClipFileName);\n}\n}\ncatch (...) {\n// catch any exception\ndelete theImage;\n// perform necessary\ndelete theAudioClip;\n// cleanup actions\nthrow;\n// propagate the exception\n}\n}\nThere is no need to worry about BookEntry’s non-pointer data mem-\nbers. Data members are automatically initialized before a class’s con-\nstructor is called, so if a BookEntry constructor body begins\nexecuting, the object’s theName, theAddress, and thePhones data\nmembers have already been fully constructed. As fully constructed ob-\njects, these data members will be automatically destroyed even if an\nexception arises in the BookEntry constructor†. Of course, if these ob-\njects’ constructors call functions that might throw exceptions, those\nconstructors have to worry about catching the exceptions and per-\nforming any necessary cleanup before allowing them to propagate.\nYou may have noticed that the statements in BookEntry’s catch block\nare almost the same as those in BookEntry’s destructor. Code dupli-\ncation here is no more tolerable than it is anywhere else, so the best\nway to structure things is to move the common code into a private\nhelper function and have both the constructor and the destructor call\nit:\nclass BookEntry {\npublic:\n...\n// as before\nprivate:\n...\nvoid cleanup();\n// common cleanup statements\n};\n† Provided, again, that the exception is caught.\n",
      "content_length": 1718,
      "extraction_method": "Direct"
    },
    {
      "page_number": 72,
      "chapter": null,
      "content": "Avoiding Resource Leaks in Constructors\n55\nvoid BookEntry::cleanup()\n{\ndelete theImage;\ndelete theAudioClip;\n}\nBookEntry::BookEntry( const string& name, \nconst string& address,\nconst string& imageFileName,\nconst string& audioClipFileName)\n: theName(name), theAddress(address), \ntheImage(0), theAudioClip(0)\n{\ntry {\n...\n// as before\n}\ncatch (...) {\ncleanup();\n// release resources\nthrow;\n// propagate exception\n}\n}\nBookEntry::~BookEntry()\n{\ncleanup();\n}\nThis is nice, but it doesn’t put the topic to rest. Let us suppose we de-\nsign our BookEntry class slightly differently so that theImage and\ntheAudioClip are constant pointers:\nclass BookEntry {\npublic:\n...\n// as above\nprivate:\n...\nImage * const theImage;\n// pointers are now \nAudioClip * const theAudioClip;\n// const\n};\nSuch pointers must be initialized via the member initialization lists of\nBookEntry’s constructors, because there is no other way to give const\npointers a value. A common temptation is to initialize theImage and\ntheAudioClip like this,\n",
      "content_length": 1009,
      "extraction_method": "Direct"
    },
    {
      "page_number": 73,
      "chapter": null,
      "content": "56\nItem 10\n// an implementation that may leak resources if an\n// exception is thrown\nBookEntry::BookEntry(const string& name, \nconst string& address,\nconst string& imageFileName,\nconst string& audioClipFileName)\n: theName(name), theAddress(address),\ntheImage(imageFileName != \"\" \n? new Image(imageFileName)\n: 0),\ntheAudioClip(audioClipFileName != \"\"\n? new AudioClip(audioClipFileName)\n: 0)\n{}\nbut this leads to the problem we originally wanted to eliminate: if an\nexception is thrown during initialization of theAudioClip, the object\npointed to by theImage is never destroyed. Furthermore, we can’t\nsolve the problem by adding try and catch blocks to the constructor,\nbecause try and catch are statements, and member initialization lists\nallow only expressions. (That’s why we had to use the ?: syntax in-\nstead of the if-then-else syntax in the initialization of theImage and\ntheAudioClip.)\nNevertheless, the only way to perform cleanup chores before excep-\ntions propagate out of a constructor is to catch those exceptions, so if\nwe can’t put try and catch in a member initialization list, we’ll have\nto put them somewhere else. One possibility is inside private member\nfunctions that return pointers with which theImage and theAudio-\nClip should be initialized:\nclass BookEntry {\npublic:\n...\n// as above\nprivate:\n...\n// data members as above\nImage * initImage(const string& imageFileName);\nAudioClip * initAudioClip(const string&\naudioClipFileName);\n};\nBookEntry::BookEntry(const string& name, \nconst string& address,\nconst string& imageFileName,\nconst string& audioClipFileName)\n: theName(name), theAddress(address), \ntheImage(initImage(imageFileName)),\ntheAudioClip(initAudioClip(audioClipFileName))\n{}\n",
      "content_length": 1708,
      "extraction_method": "Direct"
    },
    {
      "page_number": 74,
      "chapter": null,
      "content": "Avoiding Resource Leaks in Constructors\n57\n// theImage is initialized first, so there is no need to\n// worry about a resource leak if this initialization\n// fails. This function therefore handles no exceptions\nImage * BookEntry::initImage(const string& imageFileName)\n{\nif (imageFileName != \"\") return new Image(imageFileName);\nelse return 0;\n}\n// theAudioClip is initialized second, so it must make\n// sure theImage’s resources are released if an exception\n// is thrown during initialization of theAudioClip. That’s\n// why this function uses try...catch.\nAudioClip * BookEntry::initAudioClip(const string&\naudioClipFileName)\n{\ntry {\nif (audioClipFileName != \"\") {\nreturn new AudioClip(audioClipFileName);\n}\nelse return 0;\n}\ncatch (...) {\ndelete theImage;\nthrow;\n}\n}\nThis is perfectly kosher, and it even solves the problem we’ve been la-\nboring to overcome. The drawback is that code that conceptually be-\nlongs in a constructor is now dispersed across several functions, and\nthat’s a maintenance headache.\nA better solution is to adopt the advice of Item 9 and treat the objects\npointed to by theImage and theAudioClip as resources to be man-\naged by local objects. This solution takes advantage of the facts that\nboth theImage and theAudioClip are pointers to dynamically allo-\ncated objects and that those objects should be deleted when the point-\ners themselves go away. This is precisely the set of conditions for\nwhich the auto_ptr classes (see Item 9) were designed. We can there-\nfore change the raw pointer types of theImage and theAudioClip to\ntheir auto_ptr equivalents: \nclass BookEntry {\npublic:\n...\n// as above\nprivate:\n...\nconst auto_ptr<Image> theImage;\n// these are now\nconst auto_ptr<AudioClip> theAudioClip; // auto_ptr objects\n};\n",
      "content_length": 1751,
      "extraction_method": "Direct"
    },
    {
      "page_number": 75,
      "chapter": null,
      "content": "58\nItem 11\nDoing this makes BookEntry’s constructor leak-safe in the presence of\nexceptions, and it lets us initialize theImage and theAudioClip using\nthe member initialization list:\nBookEntry::BookEntry(const string& name, \nconst string& address,\nconst string& imageFileName,\nconst string& audioClipFileName)\n: theName(name), theAddress(address), \ntheImage(imageFileName != \"\" \n? new Image(imageFileName)\n: 0),\ntheAudioClip(audioClipFileName != \"\"\n? new AudioClip(audioClipFileName)\n: 0)\n{}\nIn this design, if an exception is thrown during initialization of the-\nAudioClip, theImage is already a fully constructed object, so it will\nautomatically be destroyed, just like theName, theAddress, and the-\nPhones. Furthermore, because theImage and theAudioClip are now\nobjects, they’ll be destroyed automatically when the BookEntry object\ncontaining them is. Hence there’s no need to manually delete what\nthey point to. That simplifies BookEntry’s destructor considerably:\nBookEntry::~BookEntry()\n{}\n// nothing to do!\nThis means you could eliminate BookEntry’s destructor entirely.\nIt all adds up to this: if you replace pointer class members with their\ncorresponding auto_ptr objects, you fortify your constructors against\nresource leaks in the presence of exceptions, you eliminate the need to\nmanually deallocate resources in destructors, and you allow const\nmember pointers to be handled in the same graceful fashion as non-\nconst pointers. \nDealing with the possibility of exceptions during construction can be\ntricky, but auto_ptr (and auto_ptr-like classes) can eliminate most\nof the drudgery. Their use leaves behind code that’s not only easy to\nunderstand, it’s robust in the face of exceptions, too.\nItem 11: Prevent exceptions from leaving destructors.\nExceptions and Destructors\nThere are two situations in which a destructor is called. The first is\nwhen an object is destroyed under “normal” conditions, e.g., when it\ngoes out of scope or is explicitly deleted. The second is when an object\nis destroyed by the exception-handling mechanism during the stack-\nunwinding part of exception propagation.\n",
      "content_length": 2108,
      "extraction_method": "Direct"
    },
    {
      "page_number": 76,
      "chapter": null,
      "content": "Exceptions and Destructors\n59\nThat being the case, an exception may or may not be active when a de-\nstructor is invoked. Regrettably, there is no way to distinguish between\nthese conditions from inside a destructor.† As a result, you must write\nyour destructors under the conservative assumption that an exception\nis active, because if control leaves a destructor due to an exception\nwhile another exception is active, C++ calls the terminate function.\nThat function does just what its name suggests: it terminates execu-\ntion of your program. Furthermore, it terminates it immediately; not\neven local objects are destroyed.\nAs an example, consider a Session class for monitoring on-line com-\nputer sessions, i.e., things that happen from the time you log in\nthrough the time you log out. Each Session object notes the date and\ntime of its creation and destruction:\nclass Session {\npublic:\nSession();\n~Session();\n...\nprivate:\nstatic void logCreation(Session *objAddr);\nstatic void logDestruction(Session *objAddr);\n};\nThe functions logCreation and logDestruction are used to record\nobject creations and destructions, respectively. We might therefore ex-\npect that we could code Session’s destructor like this:\nSession::~Session()\n{\nlogDestruction(this);\n}\nThis looks fine, but consider what would happen if logDestruction\nthrows an exception. The exception would not be caught in Session’s\ndestructor, so it would be propagated to the caller of that destructor.\nBut if the destructor was itself being called because some other excep-\ntion had been thrown, the terminate function would automatically be\ninvoked, and that would stop your program dead in its tracks.\nIn many cases, this is not what you’ll want to have happen. It may be\nunfortunate that the Session object’s destruction can’t be logged, it\nmight even be a major inconvenience, but is it really so horrific a pros-\n† Now there is. In July 1995, the ISO/ANSI standardization committee for C++ added a\nfunction, uncaught_exception, that returns true if an exception is active and has\nnot yet been caught.\n",
      "content_length": 2066,
      "extraction_method": "Direct"
    },
    {
      "page_number": 77,
      "chapter": null,
      "content": "60\nItem 11\npect that the program can’t continue running? If not, you’ll have to\nprevent the exception thrown by logDestruction from propagating\nout of Session’s destructor. The only way to do that is by using try\nand catch blocks. A naive attempt might look like this,\nSession::~Session()\n{\ntry {\nlogDestruction(this);\n}\ncatch (...) {\ncerr << \"Unable to log destruction of Session object \"\n<< \"at address \" \n<< this\n<< \".\\n\";\n}\n}\nbut this is probably no safer than our original code. If one of the calls\nto operator<< in the catch block results in an exception being\nthrown, we’re back where we started, with an exception leaving the\nSession destructor. \nWe could always put a try block inside the catch block, but that\nseems a bit extreme. Instead, we’ll just forget about logging Session\ndestructions if logDestruction throws an exception:\nSession::~Session()\n{\ntry {\nlogDestruction(this);\n}\ncatch (...) {}\n}\nThe catch block appears to do nothing, but appearances can be de-\nceiving. That block prevents exceptions thrown from logDestruction\nfrom propagating beyond Session’s destructor. That’s all it needs to\ndo. We can now rest easy knowing that if a Session object is destroyed\nas part of stack unwinding, terminate will not be called.\nThere is a second reason why it’s bad practice to allow exceptions to\npropagate out of destructors. If an exception is thrown from a destruc-\ntor and is not caught there, that destructor won’t run to completion. (It\nwill stop at the point where the exception is thrown.) If the destructor\ndoesn’t run to completion, it won’t do everything it’s supposed to do.\nFor example, consider a modified version of the Session class where\nthe creation of a session starts a database transaction and the termi-\nnation of a session ends that transaction:\n",
      "content_length": 1784,
      "extraction_method": "Direct"
    },
    {
      "page_number": 78,
      "chapter": null,
      "content": "Throwing Exceptions Compared to Calling Functions\n61\nSession::Session()\n// to keep things simple,\n{\n// this ctor handles no\n// exceptions\nlogCreation(this);\nstartTransaction();\n// start DB transaction\n}\nSession::~Session()\n{\nlogDestruction(this);\nendTransaction();\n// end DB transaction\n}\nHere, if logDestruction throws an exception, the transaction started\nin the Session constructor will never be ended. In this case, we might\nbe able to reorder the function calls in Session’s destructor to elimi-\nnate the problem, but if endTransaction might throw an exception,\nwe’ve no choice but to revert to try and catch blocks.\nWe thus find ourselves with two good reasons for keeping exceptions\nfrom propagating out of destructors. First, it prevents terminate from\nbeing called during the stack-unwinding part of exception propaga-\ntion. Second, it helps ensure that destructors always accomplish ev-\nerything they are supposed to accomplish. Each argument is\nconvincing in its own right, but together, the case is ironclad.\nItem 12: Understand how throwing an exception \ndiffers from passing a parameter or calling a \nvirtual function.\nThrowing Exceptions Compared to Calling Functions\nThe syntax for declaring function parameters is almost the same as\nthat for catch clauses:\nclass Widget { ... };\n// some class; it makes no\n// difference what it is\nvoid f1(Widget w);\n// all these functions\nvoid f2(Widget& w);\n// take parameters of\nvoid f3(const Widget& w);\n// type Widget, Widget&, or\nvoid f4(Widget *pw);\n// Widget*\nvoid f5(const Widget *pw);\ncatch (Widget w) ...\n// all these catch clauses\ncatch (Widget& w) ...\n// catch exceptions of\ncatch (const Widget& w) ...\n// type Widget, Widget&, or\ncatch (Widget *pw) ...\n// Widget*\ncatch (const Widget *pw) ...\nYou might therefore assume that passing an exception from a throw\nsite to a catch clause is basically the same as passing an argument\n",
      "content_length": 1891,
      "extraction_method": "Direct"
    },
    {
      "page_number": 79,
      "chapter": null,
      "content": "62\nItem 12\nfrom a function call site to the function’s parameter. There are some\nsimilarities, to be sure, but there are significant differences, too.\nLet us begin with a similarity. You can pass both function parameters\nand exceptions by value, by reference, or by pointer. What happens\nwhen you pass parameters and exceptions, however, is quite different.\nThis difference grows out of the fact that when you call a function, con-\ntrol eventually returns to the call site (unless the function fails to re-\nturn), but when you throw an exception, control does not return to the\nthrow site. \nConsider a function that both passes a Widget as a parameter and\nthrows a Widget as an exception:\n// function to read the value of a Widget from a stream\nistream operator>>(istream& s, Widget& w);\nvoid passAndThrowWidget()\n{\nWidget localWidget;\ncin >> localWidget;\n// pass localWidget to operator>>\nthrow localWidget;\n// throw localWidget as an exception\n}\nWhen localWidget is passed to operator>>, no copying is per-\nformed. Instead, the reference w inside operator>> is bound to lo-\ncalWidget, and anything done to w is really done to localWidget. It’s\na different story when localWidget is thrown as an exception. Re-\ngardless of whether the exception is caught by value or by reference (it\ncan’t be caught by pointer — that would be a type mismatch), a copy\nof localWidget will be made, and it is the copy that is passed to the\ncatch clause. This must be the case, because localWidget will go out\nof scope once control leaves passAndThrowWidget, and when local-\nWidget goes out of scope, its destructor will be called. If localWidget\nitself were passed to a catch clause, the clause would receive a de-\nstructed Widget, an ex-Widget, a former Widget, the carcass of what\nonce was but is no longer a Widget. That would not be useful, and\nthat’s why C++ specifies that an object thrown as an exception is cop-\nied.\nThis copying occurs even if the object being thrown is not in danger of\nbeing destroyed. For example, if passAndThrowWidget declares lo-\ncalWidget to be static,\nvoid passAndThrowWidget()\n{\nstatic Widget localWidget;\n// this is now static; it\n// will exist until the\n// end of the program\n",
      "content_length": 2196,
      "extraction_method": "Direct"
    },
    {
      "page_number": 80,
      "chapter": null,
      "content": "Throwing Exceptions Compared to Calling Functions\n63\ncin >> localWidget;\n// this works as before\nthrow localWidget;\n// a copy of localWidget is\n}\n// still made and thrown\na copy of localWidget would still be made when the exception was\nthrown. This means that even if the exception is caught by reference,\nit is not possible for the catch block to modify localWidget; it can\nonly modify a copy of localWidget. This mandatory copying of excep-\ntion objects† helps explain another difference between parameter pass-\ning and throwing an exception: the latter is typically much slower than\nthe former (see Item 15).\nWhen an object is copied for use as an exception, the copying is per-\nformed by the object’s copy constructor. This copy constructor is the\none in the class corresponding to the object’s static type, not its dy-\nnamic type. For example, consider this slightly modified version of\npassAndThrowWidget:\nclass Widget { ... };\nclass SpecialWidget: public Widget { ... };\nvoid passAndThrowWidget()\n{\nSpecialWidget localSpecialWidget;\n...\nWidget& rw = localSpecialWidget;\n// rw refers to a\n// SpecialWidget\nthrow rw;\n// this throws an\n// exception of type\n}\n// Widget!\nHere a Widget exception is thrown, even though rw refers to a Spe-\ncialWidget. That’s because rw’s static type is Widget, not Special-\nWidget. That rw actually refers to a SpecialWidget is of no concern\nto your compilers; all they care about is rw’s static type. This behavior\nmay not be what you want, but it’s consistent with all other cases in\nwhich C++ copies objects. Copying is always based on an object’s static\ntype (but see Item 25 for a technique that lets you make copies on the\nbasis of an object’s dynamic type).\nThe fact that exceptions are copies of other objects has an impact on\nhow you propagate exceptions from a catch block. Consider these two\ncatch blocks, which at first glance appear to do the same thing:\n† Compiler writers are actually allowed a slight bit of leeway regarding the “mandatory”\nnature of the copying; it can be eliminated under certain circumstances. Similar lee-\nway provides the foundation for the return value optimization (see Item 20).\n",
      "content_length": 2155,
      "extraction_method": "Direct"
    },
    {
      "page_number": 81,
      "chapter": null,
      "content": "64\nItem 12\ncatch (Widget& w)\n// catch Widget exceptions\n{\n...\n// handle the exception\nthrow;\n// rethrow the exception so it\n}\n// continues to propagate\ncatch (Widget& w)\n// catch Widget exceptions\n{\n...\n// handle the exception\nthrow w;\n// propagate a copy of the\n}\n// caught exception\nThe only difference between these blocks is that the first one rethrows\nthe current exception, while the second one throws a new copy of the\ncurrent exception. Setting aside the performance cost of the additional\ncopy operation, is there a difference between these approaches? \nThere is. The first block rethrows the current exception, regardless of\nits type. In particular, if the exception originally thrown was of type\nSpecialWidget, the first block would propagate a SpecialWidget ex-\nception, even though w’s static type is Widget. This is because no copy\nis made when the exception is rethrown. The second catch block\nthrows a new exception, which will always be of type Widget, because\nthat’s w’s static type. In general, you’ll want to use the \nthrow;\nsyntax to rethrow the current exception, because there’s no chance\nthat that will change the type of the exception being propagated. Fur-\nthermore, it’s more efficient, because there’s no need to generate a new\nexception object.\n(Incidentally, the copy made for an exception is a temporary object. As\nItem 19 explains, this gives compilers the right to optimize it out of ex-\nistence. I wouldn’t expect your compilers to work that hard, however.\nExceptions are supposed to be rare, so it makes little sense for com-\npiler vendors to pour a lot of energy into their optimization.)\nLet us examine the three kinds of catch clauses that could catch the\nWidget exception thrown by passAndThrowWidget. They are:\ncatch (Widget w) ...\n// catch exception by value\ncatch (Widget& w) ...\n// catch exception by\n// reference\ncatch (const Widget& w) ...\n// catch exception by\n// reference-to-const\nRight away we notice another difference between parameter passing\nand exception propagation. A thrown object (which, as explained\n",
      "content_length": 2059,
      "extraction_method": "Direct"
    },
    {
      "page_number": 82,
      "chapter": null,
      "content": "Throwing Exceptions Compared to Calling Functions\n65\nabove, is always a temporary) may be caught by simple reference; it\nneed not be caught by reference-to-const. Passing a temporary object\nto a non-const reference parameter is not allowed for function calls\n(see Item 19), but it is for exceptions.\nLet us overlook this difference, however, and return to our examina-\ntion of copying exception objects. We know that when we pass a func-\ntion argument by value, we make a copy of the passed object, and we\nstore that copy in a function parameter. The same thing happens when\nwe pass an exception by value. Thus, when we declare a catch clause\nlike this,\ncatch (Widget w) ...\n// catch by value\nwe expect to pay for the creation of two copies of the thrown object, one\nto create the temporary that all exceptions generate, the second to\ncopy that temporary into w. Similarly, when we catch an exception by\nreference, \ncatch (Widget& w) ...\n// catch by reference\ncatch (const Widget& w) ...\n// also catch by reference\nwe still expect to pay for the creation of a copy of the exception: the\ncopy that is the temporary. In contrast, when we pass function param-\neters by reference, no copying takes place. When throwing an excep-\ntion, then, we expect to construct (and later destruct) one more copy of\nthe thrown object than if we passed the same object to a function.\nWe have not yet discussed throwing exceptions by pointer, but throw\nby pointer is equivalent to pass by pointer. Either way, a copy of the\npointer is passed. About all you need to remember is not to throw a\npointer to a local object, because that local object will be destroyed\nwhen the exception leaves the local object’s scope. The catch clause\nwould then be initialized with a pointer to an object that had already\nbeen destroyed. This is the behavior the mandatory copying rule is de-\nsigned to avoid.\nThe way in which objects are moved from call or throw sites to param-\neters or catch clauses is one way in which argument passing differs\nfrom exception propagation. A second difference lies in what consti-\ntutes a type match between caller or thrower and callee or catcher.\nConsider the sqrt function from the standard math library:\ndouble sqrt(double);\n// from <cmath> or <math.h>\nWe can determine the square root of an integer like this:\nint i;\ndouble sqrtOfi = sqrt(i);\n",
      "content_length": 2345,
      "extraction_method": "Direct"
    },
    {
      "page_number": 83,
      "chapter": null,
      "content": "66\nItem 12\nThere is nothing surprising here. The language allows implicit conver-\nsion from int to double, so in the call to sqrt, i is silently converted\nto a double, and the result of sqrt corresponds to that double. (See\nItem 5 for a fuller discussion of implicit type conversions.) In general,\nsuch conversions are not applied when matching exceptions to catch\nclauses. In this code,\nvoid f(int value)\n{\ntry {\nif (someFunction()) {\n// if someFunction() returns\nthrow value;\n// true, throw an int\n}\n...\n}\ncatch (double d) {\n// handle exceptions of \n...\n// type double here\n}\n...\n}\nthe int exception thrown inside the try block will never be caught by\nthe catch clause that takes a double. That clause catches only excep-\ntions that are exactly of type double; no type conversions are applied.\nAs a result, if the int exception is to be caught, it will have to be by\nsome other (dynamically enclosing) catch clause taking an int or an\nint& (possibly modified by const or volatile).\nTwo kinds of conversions are applied when matching exceptions to\ncatch clauses. The first is inheritance-based conversions. A catch\nclause for base class exceptions is allowed to handle exceptions of (pub-\nlicly) derived class types, too. For example, consider the diagnostics por-\ntion of the hierarchy of exceptions defined by the standard C++ library:\ninvalid_argument\nexception\nruntime_error\nlogic_error\nlength_error\nrange_error\noverflow_error\ndomain_error\nout_of_range\nunderflow_error\n",
      "content_length": 1474,
      "extraction_method": "Direct"
    },
    {
      "page_number": 84,
      "chapter": null,
      "content": "Throwing Exceptions Compared to Calling Functions\n67\nA catch clause for runtime_errors can catch exceptions of type\nrange_error, underflow_error, and overflow_error, too, and a\ncatch clause accepting an object of the root class exception can\ncatch any kind of exception derived from this hierarchy.\nThis inheritance-based exception-conversion rule applies to values,\nreferences, and pointers in the usual fashion (though Item 13 explains\nwhy catching values or pointers is generally a bad idea):\ncatch (runtime_error) ...\n// can catch errors of type\ncatch (runtime_error&) ...\n// runtime_error,\ncatch (const runtime_error&) ... // range_error, or\n// overflow_error\ncatch (runtime_error*) ...\n// can catch errors of type\ncatch (const runtime_error*) ... // runtime_error*,\n// range_error*, or\n// overflow_error*\nThe second type of allowed conversion is from a typed to an untyped\npointer, so a catch clause taking a const void* pointer will catch an\nexception of any pointer type:\ncatch (const void*) ...\n// catches any exception \n// that’s a pointer\nThe final difference between passing a parameter and propagating an\nexception is that catch clauses are always tried in the order of their ap-\npearance. Hence, it is possible for an exception of a (publicly) derived\nclass type to be handled by a catch clause for one of its base class\ntypes — even when a catch clause for the derived class is associated\nwith the same try block! For example,\ntry {\n...\n}\ncatch (logic_error& ex) {\n// this block will catch \n...\n// all logic_error \n}\n// exceptions, even those\n// of derived types\ncatch (invalid_argument& ex) { // this block can never be\n...\n// executed, because all\n}\n// invalid_argument\n// exceptions will be caught\n// by the clause above\nContrast this behavior with what happens when you call a virtual\nfunction. When you call a virtual function, the function invoked is the\none in the class closest to the dynamic type of the object invoking the\nfunction. You might say that virtual functions employ a “best fit” algo-\nrithm, while exception handling follows a “first fit” strategy. Compilers\nmay warn you if a catch clause for a derived class comes after one for\na base class (some issue an error, because such code used to be illegal\n",
      "content_length": 2238,
      "extraction_method": "Direct"
    },
    {
      "page_number": 85,
      "chapter": null,
      "content": "68\nItem 13\nin C++), but your best course of action is preemptive: never put a\ncatch clause for a base class before a catch clause for a derived class.\nThe code above, for example, should be reordered like this:\ntry {\n...\n}\ncatch (invalid_argument& ex) { // handle invalid_argument\n...\n// exceptions here\n}\ncatch (logic_error& ex) {\n// handle all other\n...\n// logic_errors here\n}\nThere are thus three primary ways in which passing an object to a\nfunction or using that object to invoke a virtual function differs from\nthrowing the object as an exception. First, exception objects are always\ncopied; when caught by value, they are copied twice. Objects passed to\nfunction parameters need not be copied at all. Second, objects thrown\nas exceptions are subject to fewer forms of type conversion than are\nobjects passed to functions. Finally, catch clauses are examined in\nthe order in which they appear in the source code, and the first one\nthat can succeed is selected for execution. When an object is used to\ninvoke a virtual function, the function selected is the one that provides\nthe best match for the type of the object, even if it’s not the first one\nlisted in the source code.\nItem 13: Catch exceptions by reference.\nCatching Exceptions\nWhen you write a catch clause, you must specify how exception ob-\njects are to be passed to that clause. You have three choices, just as\nwhen specifying how parameters should be passed to functions: by\npointer, by value, or by reference.\nLet us consider first catch by pointer. In theory, this should be the\nleast inefficient way to implement the invariably slow process of mov-\ning an exception from throw site to catch clause (see Item 15). That’s\nbecause throw by pointer is the only way of moving exception informa-\ntion without copying an object (see Item 12). For example:\nclass exception { ... };\n// from the standard C++\n// library exception \n// hierarchy (see Item 12)\nvoid someFunction()\n{\nstatic exception ex;\n// exception object\n...\n",
      "content_length": 1987,
      "extraction_method": "Direct"
    },
    {
      "page_number": 86,
      "chapter": null,
      "content": "Catching Exceptions\n69\nthrow &ex;\n// throw a pointer to ex\n...\n}\nvoid doSomething()\n{\ntry {\nsomeFunction();\n// may throw an exception*\n}\ncatch (exception *ex) {\n// catches the exception*;\n...\n// no object is copied \n}\n}\nThis looks neat and tidy, but it’s not quite as well-kept as it appears.\nFor this to work, programmers must define exception objects in a way\nthat guarantees the objects exist after control leaves the functions\nthrowing pointers to them. Global and static objects work fine, but it’s\neasy for programmers to forget the constraint. If they do, they typically\nend up writing code like this:\nvoid someFunction()\n{\nexception ex;\n// local exception object; \n// will be destroyed when \n// this function’s scope is\n...\n// exited\nthrow &ex;\n// throw a pointer to an\n...\n// object that’s about to\n}\n// be destroyed\nThis is worse than useless, because the catch clause handling this ex-\nception receives a pointer to an object that no longer exists.\nAn alternative is to throw a pointer to a new heap object:\nvoid someFunction()\n{\n...\nthrow new exception;\n// throw a pointer to a new heap-\n...\n// based object (and hope that \n}\n// operator new — see Item 8 —\n// doesn’t itself throw an \n// exception!)\nThis avoids the I-just-caught-a-pointer-to-a-destroyed-object problem,\nbut now authors of catch clauses confront a nasty question: should\nthey delete the pointer they receive? If the exception object was allo-\ncated on the heap, they must, otherwise they suffer a resource leak. If\n",
      "content_length": 1494,
      "extraction_method": "Direct"
    },
    {
      "page_number": 87,
      "chapter": null,
      "content": "70\nItem 13\nthe exception object wasn’t allocated on the heap, they mustn’t, other-\nwise they suffer undefined program behavior. What to do?\nIt’s impossible to know. Some clients might pass the address of a glo-\nbal or static object, others might pass the address of an exception on\nthe heap. Catch by pointer thus gives rise to the Hamlet conundrum:\nto delete or not to delete? It’s a question with no good answer. You’re\nbest off ducking it.\nFurthermore, catch-by-pointer runs contrary to the convention estab-\nlished by the language itself. The four standard exceptions —\nbad_alloc (thrown when operator new (see Item 8) can’t satisfy a\nmemory request), bad_cast (thrown when a dynamic_cast to a refer-\nence fails; see Item 2), bad_typeid (thrown when typeid is applied to\na dereferenced null pointer), and bad_exception (available for unex-\npected exceptions; see Item 14) — are all objects, not pointers to ob-\njects, so you have to catch them by value or by reference, anyway.\nCatch-by-value eliminates questions about exception deletion and\nworks with the standard exception types. However, it requires that ex-\nception objects be copied twice each time they’re thrown (see Item 12).\nIt also gives rise to the specter of the slicing problem, whereby derived\nclass exception objects caught as base class exceptions have their de-\nrivedness “sliced off.” Such “sliced” objects are base class objects: they\nlack derived class data members, and when virtual functions are called\non them, they resolve to virtual functions of the base class. (Exactly\nthe same thing happens when an object is passed to a function by\nvalue.) For example, consider an application employing an exception\nclass hierarchy that extends the standard one:\nclass exception {\n// as above, this is a \npublic:\n// standard exception class\nvirtual const char * what() const throw();\n// returns a brief descrip.\n...\n// of the exception (see\n// Item 14 for info about\n};\n// the \"throw()\" at the\n// end of the declaration)\nclass runtime_error:\n// also from the standard\npublic exception { ... };\n// C++ exception hierarchy\nclass Validation_error:\n// this is a class added by\npublic runtime_error {\n// a client\npublic:\nvirtual const char * what() const throw();\n// this is a redefinition\n...\n// of the function declared\n};\n// in class exception above\n",
      "content_length": 2317,
      "extraction_method": "Direct"
    },
    {
      "page_number": 88,
      "chapter": null,
      "content": "Catching Exceptions\n71\nvoid someFunction()\n// may throw a validation\n{\n// exception\n...\nif (a validation test fails) {\nthrow Validation_error();\n}\n...\n}\nvoid doSomething()\n{\ntry {\nsomeFunction();\n// may throw a validation\n}\n// exception\ncatch (exception ex) {\n// catches all exceptions\n// in or derived from \n// the standard hierarchy\ncerr << ex.what();\n// calls exception::what(),\n...\n// never \n}\n// Validation_error::what()\n}\nThe version of what that is called is that of the base class, even though\nthe thrown exception is of type Validation_error and\nValidation_error redefines that virtual function. This kind of slicing\nbehavior is almost never what you want.\nThat leaves only catch-by-reference. Catch-by-reference suffers from\nnone of the problems we have discussed. Unlike catch-by-pointer, the\nquestion of object deletion fails to arise, and there is no difficulty in\ncatching the standard exception types. Unlike catch-by-value, there is\nno slicing problem, and exception objects are copied only once.\nIf we rewrite the last example using catch-by-reference, it looks like\nthis:\nvoid someFunction()\n// nothing changes in this\n{\n// function\n...\nif (a validation test fails) {\nthrow Validation_error();\n}\n...\n}\n",
      "content_length": 1220,
      "extraction_method": "Direct"
    },
    {
      "page_number": 89,
      "chapter": null,
      "content": "72\nItem 14\nvoid doSomething()\n{\ntry {\nsomeFunction();\n// no change here\n}\ncatch (exception& ex) {\n// here we catch by reference\n// instead of by value\ncerr << ex.what();\n// now calls\n// Validation_error::what(),\n...\n// not exception::what()\n}\n}\nThere is no change at the throw site, and the only change in the catch\nclause is the addition of an ampersand. This tiny modification makes\na big difference, however, because virtual functions in the catch block\nnow work as we expect: functions in Validation_error are invoked if\nthey redefine those in exception. Of course, if there is no need to\nmodify the exception object in the handler, you’d catch not just by ref-\nerence, but by reference to const.\nWhat a happy confluence of events! If you catch by reference, you side-\nstep questions about object deletion that leave you damned if you do\nand damned if you don’t; you avoid slicing exception objects; you re-\ntain the ability to catch standard exceptions; and you limit the number\nof times exception objects need to be copied. So what are you waiting\nfor? Catch exceptions by reference!\nItem 14: Use exception specifications judiciously.\nException Specifications\nThere’s no denying it: exception specifications have appeal. They make\ncode easier to understand, because they explicitly state what excep-\ntions a function may throw. But they’re more than just fancy com-\nments. Compilers are sometimes able to detect inconsistent exception\nspecifications during compilation. Furthermore, if a function throws\nan exception not listed in its exception specification, that fault is de-\ntected at runtime, and the special function unexpected is automati-\ncally invoked. Both as a documentation aid and as an enforcement\nmechanism for constraints on exception usage, then, exception speci-\nfications seem attractive.\nAs is often the case, however, beauty is only skin deep. The default be-\nhavior for unexpected is to call terminate, and the default behavior\nfor terminate is to call abort, so the default behavior for a program\nwith a violated exception specification is to halt. Local variables in ac-\ntive stack frames are not destroyed, because abort shuts down pro-\ngram execution without performing such cleanup. A violated exception\nspecification is therefore a cataclysmic thing, something that should\nalmost never happen.\n",
      "content_length": 2327,
      "extraction_method": "Direct"
    },
    {
      "page_number": 90,
      "chapter": null,
      "content": "Exception Specifications\n73\nUnfortunately, it’s easy to write functions that make this terrible thing\noccur. Compilers only partially check exception usage for consistency\nwith exception specifications. What they do not check for — what the\nlanguage standard prohibits them from rejecting (though they may\nissue a warning) — is a call to a function that might violate the excep-\ntion specification of the function making the call.\nConsider a declaration for a function f1 that has no exception specifi-\ncation. Such a function may throw any kind of exception:\nextern void f1();\n// might throw anything\nNow consider a function f2 that claims, through its exception specifi-\ncation, it will throw only exceptions of type int:\nvoid f2() throw(int);\nIt is perfectly legal C++ for f2 to call f1, even though f1 might throw\nan exception that would violate f2’s exception specification:\nvoid f2() throw(int)\n{\n...\nf1();\n// legal even though f1 might throw\n// something besides an int\n...\n}\nThis kind of flexibility is essential if new code with exception specifica-\ntions is to be integrated with older code lacking such specifications.\nBecause your compilers are content to let you call functions whose ex-\nception specifications are inconsistent with those of the routine con-\ntaining the calls, and because such calls might result in your\nprogram’s execution being terminated, it’s important to write your\nsoftware in such a way that these kinds of inconsistencies are mini-\nmized. A good way to start is to avoid putting exception specifications\non templates that take type arguments. Consider this template, which\ncertainly looks as if it couldn’t throw any exceptions:\n// a poorly designed template wrt exception specifications\ntemplate<class T>\nbool operator==(const T& lhs, const T& rhs) throw()\n{\nreturn &lhs == &rhs;\n}\nThis template defines an operator== function for all types. For any\npair of objects of the same type, it returns true if the objects have the\nsame address, otherwise it returns false.\n",
      "content_length": 2006,
      "extraction_method": "Direct"
    },
    {
      "page_number": 91,
      "chapter": null,
      "content": "74\nItem 14\nThis template contains an exception specification stating that the\nfunctions generated from the template will throw no exceptions. But\nthat’s not necessarily true, because it’s possible that operator& (the\naddress-of operator) has been overloaded for some types. If it has, op-\nerator& may throw an exception when called from inside opera-\ntor==. If it does, our exception specification is violated, and off to\nunexpected we go.\nThis is a specific example of a more general problem, namely, that\nthere is no way to know anything about the exceptions thrown by a\ntemplate’s type parameters. We can almost never provide a meaningful\nexception specification for a template, because templates almost in-\nvariably use their type parameter in some way. The conclusion? Tem-\nplates and exception specifications don’t mix.\nA second technique you can use to avoid calls to unexpected is to omit\nexception specifications on functions making calls to functions that\nthemselves lack exception specifications. This is simple common\nsense, but there is one case that is easy to forget. That’s when allowing\nusers to register callback functions:\n// Function pointer type for a window system callback\n// when a window system event occurs\ntypedef void (*CallBackPtr)(int eventXLocation,\nint eventYLocation,\nvoid *dataToPassBack);\n// Window system class for holding onto callback\n// functions registered by window system clients\nclass CallBack {\npublic:\nCallBack(CallBackPtr fPtr, void *dataToPassBack)\n: func(fPtr), data(dataToPassBack) {}\nvoid makeCallBack(int eventXLocation,\nint eventYLocation) const throw();\nprivate:\nCallBackPtr func;\n// function to call when\n// callback is made\nvoid *data;\n// data to pass to callback\n};\n// function\n// To implement the callback, we call the registered func-\n// tion with event’s coordinates and the registered data\nvoid CallBack::makeCallBack(int eventXLocation,\nint eventYLocation) const throw()\n{\nfunc(eventXLocation, eventYLocation, data);\n}\n",
      "content_length": 1980,
      "extraction_method": "Direct"
    },
    {
      "page_number": 92,
      "chapter": null,
      "content": "Exception Specifications\n75\nHere the call to func in makeCallBack runs the risk of a violated ex-\nception specification, because there is no way of knowing what excep-\ntions func might throw. \nThis problem can be eliminated by tightening the exception specifica-\ntion in the CallBackPtr typedef:†\ntypedef void (*CallBackPtr)(int eventXLocation,\nint eventYLocation,\nvoid *dataToPassBack) throw();\nGiven this typedef, it is now an error to register a callback function\nthat fails to guarantee it throws nothing:\n// a callback function without an exception specification\nvoid callBackFcn1(int eventXLocation, int eventYLocation,\nvoid *dataToPassBack);\nvoid *callBackData;\n...\nCallBack c1(callBackFcn1, callBackData);\n// error! callBackFcn1\n// might throw an exception\n// a callback function with an exception specification\nvoid callBackFcn2(int eventXLocation,\nint eventYLocation,\nvoid *dataToPassBack) throw();\nCallBack c2(callBackFcn2, callBackData);\n// okay, callBackFcn2 has a\n// conforming ex. spec.\nThis checking of exception specifications when passing function point-\ners is a relatively recent addition to the language, so don’t be surprised\nif your compilers don’t yet support it. If they don’t, it’s up to you to en-\nsure you don’t make this kind of mistake.\nA third technique you can use to avoid calls to unexpected is to handle\nexceptions “the system” may throw. Of these exceptions, the most com-\nmon is bad_alloc, which is thrown by operator new and operator\nnew[] when a memory allocation fails (see Item 8). If you use the new\noperator (again, see Item 8) in any function, you must be prepared for\nthe possibility that the function will encounter a bad_alloc exception.\nNow, an ounce of prevention may be better than a pound of cure, but\nsometimes prevention is hard and cure is easy. That is, sometimes it’s\neasier to cope with unexpected exceptions directly than to prevent\nthem from arising in the first place. If, for example, you’re writing soft-\n† Alas, it can’t, at least not portably. Though many compilers accept the code shown on\nthis page, the standardization committee has inexplicably decreed that “an exception\nspecification shall not appear in a  typedef.” I don’t know why. If you need a portable\nsolution, you must — it hurts me to write this — make CallBackPtr a macro, sigh.\n",
      "content_length": 2309,
      "extraction_method": "Direct"
    },
    {
      "page_number": 93,
      "chapter": null,
      "content": "76\nItem 14\nware that uses exception specifications rigorously, but you’re forced to\ncall functions in libraries that don’t use exception specifications, it’s\nimpractical to prevent unexpected exceptions from arising, because\nthat would require changing the code in the libraries. \nIf preventing unexpected exceptions isn’t practical, you can exploit the\nfact that C++ allows you to replace unexpected exceptions with excep-\ntions of a different type. For example, suppose you’d like all unex-\npected exceptions to be replaced by UnexpectedException objects.\nYou can set it up like this,\nclass UnexpectedException {};\n// all unexpected exception\n// objects will be replaced\n// by objects of this type\nvoid convertUnexpected()\n// function to call if\n{\n// an unexpected exception\nthrow UnexpectedException(); // is thrown\n}\nand make it happen by replacing the default unexpected function\nwith convertUnexpected:\nset_unexpected(convertUnexpected);\nOnce you’ve done this, any unexpected exception results in convert-\nUnexpected being called. The unexpected exception is then replaced\nby a new exception of type UnexpectedException. Provided the ex-\nception specification that was violated includes UnexpectedExcep-\ntion, exception propagation will then continue as if the exception\nspecification had always been satisfied. (If the exception specification\ndoes not include UnexpectedException, terminate will be called,\njust as if you had never replaced unexpected.)\nAnother way to translate unexpected exceptions into a well known type\nis to rely on the fact that if the unexpected function’s replacement re-\nthrows the current exception, that exception will be replaced by a new\nexception of the standard type bad_exception. Here’s how you’d ar-\nrange for that to happen:\nvoid convertUnexpected()\n// function to call if\n{\n// an unexpected exception\nthrow;\n// is thrown; just rethrow\n}\n// the current exception\nset_unexpected(convertUnexpected);\n// install convertUnexpected\n// as the unexpected\n// replacement\n",
      "content_length": 2006,
      "extraction_method": "Direct"
    },
    {
      "page_number": 94,
      "chapter": null,
      "content": "Exception Specifications\n77\nIf you do this and you include bad_exception (or its base class, the\nstandard class exception) in all your exception specifications, you’ll\nnever have to worry about your program halting if an unexpected ex-\nception is encountered. Instead, any wayward exception will be re-\nplaced by a bad_exception, and that exception will be propagated in\nthe stead of the original one.\nBy now you understand that exception specifications can be a lot of\ntrouble. Compilers perform only partial checks for their consistent us-\nage, they’re problematic in templates, they’re easy to violate inadvert-\nently, and, by default, they lead to abrupt program termination when\nthey’re violated. Exception specifications have another drawback, too,\nand that’s that they result in unexpected being invoked even when a\nhigher-level caller is prepared to cope with the exception that’s arisen.\nFor example, consider this code, which is taken almost verbatim from\nItem 11:\nclass Session {\n// for modeling online\npublic:\n// sessions\n~Session();\n...\nprivate:\nstatic void logDestruction(Session *objAddr) throw();\n};\nSession::~Session()\n{\ntry {\nlogDestruction(this);\n}\ncatch (...) {}\n}\nThe Session destructor calls logDestruction to record the fact that\na Session object is being destroyed, but it explicitly catches any ex-\nceptions that might be thrown by logDestruction. However, logDe-\nstruction comes with an exception specification asserting that it\nthrows no exceptions. Now, suppose some function called by logDe-\nstruction throws an exception that logDestruction fails to catch.\nThis isn’t supposed to happen, but as we’ve seen, it isn’t difficult to\nwrite code that leads to the violation of exception specifications. When\nthis unanticipated exception propagates through logDestruction,\nunexpected will be called, and, by default, that will result in termina-\ntion of the program. This is correct behavior, to be sure, but is it the\nbehavior the author of Session’s destructor wanted? That author took\npains to handle all possible exceptions, so it seems almost unfair to\nhalt the program without giving Session’s destructor’s catch block a\nchance to work. If logDestruction had no exception specification,\n",
      "content_length": 2216,
      "extraction_method": "Direct"
    },
    {
      "page_number": 95,
      "chapter": null,
      "content": "78\nItem 15\nthis I’m-willing-to-catch-it-if-you’ll-just-give-me-a-chance scenario\nwould never arise. (One way to prevent it is to replace unexpected as\ndescribed above.)\nIt’s important to keep a balanced view of exception specifications. They\nprovide excellent documentation on the kinds of exceptions a function\nis expected to throw, and for situations in which violating an exception\nspecification is so dire as to justify immediate program termination,\nthey offer that behavior by default. At the same time, they are only\npartly checked by compilers and they are easy to violate inadvertently.\nFurthermore, they can prevent high-level exception handlers from\ndealing with unexpected exceptions, even when they know how to.\nThat being the case, exception specifications are a tool to be applied ju-\ndiciously. Before adding them to your functions, consider whether the\nbehavior they impart to your software is really the behavior you want.\nItem 15: Understand the costs of exception handling.\nThe Costs of Exception Handling\nTo handle exceptions at runtime, programs must do a fair amount of\nbookkeeping. At each point during execution, they must be able to\nidentify the objects that require destruction if an exception is thrown;\nthey must make note of each entry to and exit from a try block; and\nfor each try block, they must keep track of the associated catch\nclauses and the types of exceptions those clauses can handle. This\nbookkeeping is not free. Nor are the runtime comparisons necessary to\nensure that exception specifications are satisfied. Nor is the work ex-\npended to destroy the appropriate objects and find the correct catch\nclause when an exception is thrown. No, exception handling has costs,\nand you pay at least some of them even if you never use the keywords\ntry, throw, or catch.\nLet us begin with the things you pay for even if you never use any ex-\nception-handling features. You pay for the space used by the data\nstructures needed to keep track of which objects are fully constructed\n(see Item 10), and you pay for the time needed to keep these data\nstructures up to date. These costs are typically quite modest. Never-\ntheless, programs compiled without support for exceptions are typi-\ncally both faster and smaller than their counterparts compiled with\nsupport for exceptions.\nIn theory, you don’t have a choice about these costs: exceptions are\npart of C++, compilers have to support them, and that’s that. You can’t\neven expect compiler vendors to eliminate the costs if you use no ex-\nception-handling features, because programs are typically composed\nof multiple independently generated object files, and just because one\nobject file doesn’t do anything with exceptions doesn’t mean others\n",
      "content_length": 2725,
      "extraction_method": "Direct"
    },
    {
      "page_number": 96,
      "chapter": null,
      "content": "The Costs of Exception Handling\n79\ndon’t. Furthermore, even if none of the object files linked to form an ex-\necutable use exceptions, what about the libraries they’re linked with?\nIf any part of a program uses exceptions, the rest of the program must\nsupport them, too. Otherwise it may not be possible to provide correct\nexception-handling behavior at runtime.\nThat’s the theory. In practice, most vendors who support exception\nhandling allow you to control whether support for exceptions is in-\ncluded in the code they generate. If you know that no part of your pro-\ngram uses try, throw, or catch, and you also know that no library\nwith which you’ll link uses try, throw, or catch, you might as well\ncompile without exception-handling support and save yourself the size\nand speed penalty you’d otherwise probably be assessed for a feature\nyou’re not using. As time goes on and libraries employing exceptions\nbecome more common, this strategy will become less tenable, but\ngiven the current state of C++ software development, compiling with-\nout support for exceptions is a reasonable performance optimization if\nyou have already decided not to use exceptions. It may also be an at-\ntractive optimization for libraries that eschew exceptions, provided\nthey can guarantee that exceptions thrown from client code never\npropagate into the library. This is a difficult guarantee to make, as it\nprecludes client redefinitions of library-declared virtual functions; it\nalso rules out client-defined callback functions.\nA second cost of exception-handling arises from try blocks, and you\npay it whenever you use one, i.e., whenever you decide you want to be\nable to catch exceptions. Different compilers implement try blocks in\ndifferent ways, so the cost varies from compiler to compiler. As a rough\nestimate, expect your overall code size to increase by 5-10% and your\nruntime to go up by a similar amount if you use try blocks. This as-\nsumes no exceptions are thrown; what we’re discussing here is just the\ncost of having try blocks in your programs. To minimize this cost, you\nshould avoid unnecessary try blocks.\nCompilers tend to generate code for exception specifications much as\nthey do for try blocks, so an exception specification generally incurs\nabout the same cost as a try block. Excuse me? You say you thought\nexception specifications were just specifications, you didn’t think they\ngenerated code? Well, now you have something new to think about.\nWhich brings us to the heart of the matter, the cost of throwing an ex-\nception. In truth, this shouldn’t be much of a concern, because excep-\ntions should be rare. After all, they indicate the occurrence of events\nthat are exceptional. The 80-20 rule (see Item 16) tells us that such\nevents should almost never have much impact on a program’s overall\nperformance. Nevertheless, I know you’re curious about just how big a\nhit you’ll take if you throw an exception, and the answer is it’s proba-\n",
      "content_length": 2955,
      "extraction_method": "Direct"
    },
    {
      "page_number": 97,
      "chapter": null,
      "content": "80\nItem 15\nbly a big one. Compared to a normal function return, returning from a\nfunction by throwing an exception may be as much as three orders of\nmagnitude slower. That’s quite a hit. But you’ll take it only if you throw\nan exception, and that should be almost never. If, however, you’ve been\nthinking of using exceptions to indicate relatively common conditions\nlike the completion of a data structure traversal or the termination of\na loop, now would be an excellent time to think again.\nBut wait. How can I know this stuff? If support for exceptions is a rel-\natively recent addition to most compilers (it is), and if different compil-\ners implement their support in different ways (they do), how can I say\nthat a program’s size will generally grow by about 5-10%, its speed will\ndecrease by a similar amount, and it may run orders of magnitude\nslower if lots of exceptions are thrown? The answer is frightening: a lit-\ntle rumor and a handful of benchmarks (see Item 23). The fact is that\nmost people — including most compiler vendors — have little experi-\nence with exceptions, so though we know there are costs associated\nwith them, it is difficult to predict those costs accurately. \nThe prudent course of action is to be aware of the costs described in\nthis item, but not to take the numbers very seriously. Whatever the\ncost of exception handling, you don’t want to pay any more than you\nhave to. To minimize your exception-related costs, compile without\nsupport for exceptions when that is feasible; limit your use of try\nblocks and exception specifications to those locations where you hon-\nestly need them; and throw exceptions only under conditions that are\ntruly exceptional. If you still have performance problems, profile your\nsoftware (see Item 16) to determine if exception support is a contribut-\ning factor. If it is, consider switching to different compilers, ones that\nprovide more efficient implementations of C++’s exception-handling\nfeatures.\n",
      "content_length": 1971,
      "extraction_method": "Direct"
    },
    {
      "page_number": 98,
      "chapter": null,
      "content": "Efficiency\nEfficiency\nI harbor a suspicion that someone has performed secret Pavlovian ex-\nperiments on C++ software developers. How else can one explain the\nfact that when the word “efficiency” is mentioned, scores of program-\nmers start to drool?\nIn fact, efficiency is no laughing matter. Programs that are too big or\ntoo slow fail to find acceptance, no matter how compelling their merits.\nThis is perhaps as it should be. Software is supposed to help us do\nthings better, and it’s difficult to argue that slower is better, that de-\nmanding 32 megabytes of memory is better than requiring a mere 16,\nthat chewing up 100 megabytes of disk space is better than swallowing\nonly 50. Furthermore, though some programs take longer and use\nmore memory because they perform more ambitious computations,\ntoo many programs can blame their sorry pace and bloated footprint\non nothing more than bad design and slipshod programming.\nWriting efficient programs in C++ starts with the recognition that C++\nmay well have nothing to do with any performance problems you’ve\nbeen having. If you want to write an efficient C++ program, you must\nfirst be able to write an efficient program. Too many developers over-\nlook this simple truth. Yes, loops may be unrolled by hand and multi-\nplications may be replaced by shift operations, but such micro-tuning\nleads nowhere if the higher-level algorithms you employ are inherently\ninefficient. Do you use quadratic algorithms when linear ones are\navailable? Do you compute the same value over and over? Do you\nsquander opportunities to reduce the average cost of expensive opera-\ntions? If so, you can hardly be surprised if your programs are de-\nscribed like second-rate tourist attractions: worth a look, but only if\nyou’ve got some extra time.\nThe material in this chapter attacks the topic of efficiency from two an-\ngles. The first is language-independent, focusing on things you can do\nin any programming language. C++ provides a particularly appealing\n",
      "content_length": 1989,
      "extraction_method": "Direct"
    },
    {
      "page_number": 99,
      "chapter": null,
      "content": "82\nItem 16\nimplementation medium for these ideas, because its strong support for\nencapsulation makes it possible to replace inefficient class implemen-\ntations with better algorithms and data structures that support the\nsame interface. \nThe second focus is on C++ itself. High-performance algorithms and\ndata structures are great, but sloppy implementation practices can re-\nduce their effectiveness considerably. The most insidious mistake is\nboth simple to make and hard to recognize: creating and destroying too\nmany objects. Superfluous object constructions and destructions act\nlike a hemorrhage on your program’s performance, with precious\nclock-ticks bleeding away each time an unnecessary object is created\nand destroyed. This problem is so pervasive in C++ programs, I devote\nfour separate items to describing where these objects come from and\nhow you can eliminate them without compromising the correctness of\nyour code.\nPrograms don’t get big and slow only by creating too many objects.\nOther potholes on the road to high performance include library selec-\ntion and implementations of language features. In the items that fol-\nlow, I address these issues, too.\nAfter reading the material in this chapter, you’ll be familiar with sev-\neral principles that can improve the performance of virtually any pro-\ngram you write, you’ll know exactly how to prevent unnecessary\nobjects from creeping into your software, and you’ll have a keener\nawareness of how your compilers behave when generating executables. \nIt’s been said that forewarned is forearmed. If so, think of the informa-\ntion that follows as preparation for battle.\nItem 16: Remember the 80-20 rule.\nThe 80-20 Rule\nThe 80-20 rule states that 80 percent of a program’s resources are\nused by about 20 percent of the code: 80 percent of the runtime is\nspent in approximately 20 percent of the code; 80 percent of the mem-\nory is used by some 20 percent of the code; 80 percent of the disk ac-\ncesses are performed for about 20 percent of the code; 80 percent of\nthe maintenance effort is devoted to around 20 percent of the code.\nThe rule has been repeatedly verified through examinations of count-\nless machines, operating systems, and applications. The 80-20 rule is\nmore than just a catchy phrase; it’s a guideline about system perfor-\nmance that has both wide applicability and a solid empirical basis.\nWhen considering the 80-20 rule, it’s important not to get too hung up\non numbers. Some people favor the more stringent 90-10 rule, and\nthere’s experimental evidence to back that, too. Whatever the precise\n",
      "content_length": 2578,
      "extraction_method": "Direct"
    },
    {
      "page_number": 100,
      "chapter": null,
      "content": "The 80-20 Rule\n83\nnumbers, the fundamental point is this: the overall performance of\nyour software is almost always determined by a small part of its con-\nstituent code.\nAs a programmer striving to maximize your software’s performance,\nthe 80-20 rule both simplifies and complicates your life. On one hand,\nthe 80-20 rule implies that most of the time you can produce code\nwhose performance is, frankly, rather mediocre, because 80 percent of\nthe time its efficiency doesn’t affect the overall performance of the sys-\ntem you’re working on. That may not do much for your ego, but it\nshould reduce your stress level a little. On the other hand, the rule im-\nplies that if your software has a performance problem, you’ve got a\ntough job ahead of you, because you not only have to locate the small\npockets of code that are causing the problem, you have to find ways to\nincrease their performance dramatically. Of these tasks, the more\ntroublesome is generally locating the bottlenecks. There are two funda-\nmentally different ways to approach the matter: the way most people\ndo it and the right way.\nThe way most people locate bottlenecks is to guess. Using experience,\nintuition, tarot cards and Ouija boards, rumors or worse, developer\nafter developer solemnly proclaims that a program’s efficiency prob-\nlems can be traced to network delays, improperly tuned memory allo-\ncators, compilers that don’t optimize aggressively enough, or some\nbonehead manager’s refusal to permit assembly language for crucial\ninner loops. Such assessments are generally delivered with a conde-\nscending sneer, and usually both the sneerers and their prognostica-\ntions are flat-out wrong.\nMost programmers have lousy intuition about the performance char-\nacteristics of their programs, because program performance charac-\nteristics tend to be highly unintuitive. As a result, untold effort is\npoured into improving the efficiency of parts of programs that will\nnever have a noticeable effect on their overall behavior. For example,\nfancy algorithms and data structures that minimize computation may\nbe added to a program, but it’s all for naught if the program is I/O-\nbound. Souped-up I/O libraries (see Item 23) may be substituted for\nthe ones shipped with compilers, but there’s not much point if the pro-\ngrams using them are CPU-bound. \nThat being the case, what do you do if you’re faced with a slow program\nor one that uses too much memory? The 80-20 rule means that im-\nproving random parts of the program is unlikely to help very much.\nThe fact that programs tend to have unintuitive performance charac-\nteristics means that trying to guess the causes of performance bottle-\nnecks is unlikely to be much better than just improving random parts\nof your program. What, then, will work?\n",
      "content_length": 2773,
      "extraction_method": "Direct"
    },
    {
      "page_number": 101,
      "chapter": null,
      "content": "84\nItem 16\nWhat will work is to empirically identify the 20 percent of your program\nthat is causing you heartache, and the way to identify that horrid 20\npercent is to use a program profiler. Not just any profiler will do, how-\never. You want one that directly measures the resources you are inter-\nested in. For example, if your program is too slow, you want a profiler\nthat tells you how much time is being spent in different parts of the\nprogram. That way you can focus on those places where a significant\nimprovement in local efficiency will also yield a significant improve-\nment in overall efficiency. \nProfilers that tell you how many times each statement is executed or\nhow many times each function is called are of limited utility. From a\nperformance point of view, you do not care how many times a state-\nment is executed or a function is called. It is, after all, rather rare to\nencounter a user of a program or a client of a library who complains\nthat too many statements are being executed or too many functions\nare being called. If your software is fast enough, nobody cares how\nmany statements are executed, and if it’s too slow, nobody cares how\nfew. All they care about is that they hate to wait, and if your program\nis making them do it, they hate you, too.\nStill, knowing how often statements are executed or functions are\ncalled can sometimes yield insight into what your software is doing. If,\nfor example, you think you’re creating about a hundred objects of a\nparticular type, it would certainly be worthwhile to discover that you’re\ncalling constructors in that class thousands of times. Furthermore,\nstatement and function call counts can indirectly help you understand\nfacets of your software’s behavior you can’t directly measure. If you\nhave no direct way of measuring dynamic memory usage, for example,\nit may be helpful to know at least how often memory allocation and\ndeallocation functions (e.g., operators new, new[], delete, and de-\nlete[] — see Item 8) are called.\nOf course, even the best of profilers is hostage to the data it’s given to\nprocess. If you profile your program while it’s processing unrepresen-\ntative input data, you’re in no position to complain if the profiler leads\nyou to fine-tune parts of your software — the parts making up some 80\npercent of it — that have no bearing on its usual performance. Remem-\nber that a profiler can only tell you how a program behaved on a par-\nticular run (or set of runs), so if you profile a program using input data\nthat is unrepresentative, you’re going to get back a profile that is\nequally unrepresentative. That, in turn, is likely to lead to you to opti-\nmize your software’s behavior for uncommon uses, and the overall im-\npact on common uses may even be negative.\nThe best way to guard against these kinds of pathological results is to\nprofile your software using as many data sets as possible. Moreover,\n",
      "content_length": 2902,
      "extraction_method": "Direct"
    },
    {
      "page_number": 102,
      "chapter": null,
      "content": "Lazy Evaluation\n85\nyou must ensure that each data set is representative of how the soft-\nware is used by its clients (or at least its most important clients). It is\nusually easy to acquire representative data sets, because many clients\nare happy to let you use their data when profiling. After all, you’ll then\nbe tuning your software to meet their needs, and that can only be good\nfor both of you.\nItem 17: Consider using lazy evaluation.\nLazy Evaluation\nFrom the perspective of efficiency, the best computations are those you\nnever perform at all. That’s fine, but if you don’t need to do something,\nwhy would you put code in your program to do it in the first place? And\nif you do need to do something, how can you possibly avoid executing\nthe code that does it?\nThe key is to be lazy. \nRemember when you were a child and your parents told you to clean\nyour room? If you were anything like me, you’d say “Okay,” then\npromptly go back to what you were doing. You would not clean your\nroom. In fact, cleaning your room would be the last thing on your mind\n— until you heard your parents coming down the hall to confirm that\nyour room had, in fact, been cleaned. Then you’d sprint to your room\nand get to work as fast as you possibly could. If you were lucky, your\nparents would never check, and you’d avoid all the work cleaning your\nroom normally entails.\nIt turns out that the same delay tactics that work for a five year old\nwork for a C++ programmer. In Computer Science, however, we dignify\nsuch procrastination with the name lazy evaluation. When you employ\nlazy evaluation, you write your classes in such a way that they defer\ncomputations until the results of those computations are required. If\nthe results are never required, the computations are never performed,\nand neither your software’s clients nor your parents are any the wiser.\nPerhaps you’re wondering exactly what I’m talking about. Perhaps an\nexample would help. Well, lazy evaluation is applicable in an enormous\nvariety of application areas, so I’ll describe four.\nReference Counting\nConsider this code:\nclass String { ... };\n// a string class (the standard\n// string type may be implemented\n// as described below, but it\n// doesn’t have to be)\n",
      "content_length": 2219,
      "extraction_method": "Direct"
    },
    {
      "page_number": 103,
      "chapter": null,
      "content": "86\nItem 17\nString s1 = \"Hello\";\nString s2 = s1;\n// call String copy ctor\nA common implementation for the String copy constructor would re-\nsult in s1 and s2 each having its own copy of “Hello” after s2 is ini-\ntialized with s1. Such a copy constructor would incur a relatively large\nexpense, because it would have to make a copy of s1’s value to give to\ns2, and that would typically entail allocating heap memory via the new\noperator (see Item 8) and calling strcpy to copy the data in s1 into the\nmemory allocated by s2. This is eager evaluation: making a copy of s1\nand putting it into s2 just because the String copy constructor was\ncalled. At this point, however, there has been no real need for s2 to\nhave a copy of the value, because s2 hasn’t been used yet.\nThe lazy approach is a lot less work. Instead of giving s2 a copy of s1’s\nvalue, we have s2 share s1’s value. All we have to do is a little book-\nkeeping so we know who’s sharing what, and in return we save the\ncost of a call to new and the expense of copying anything. The fact that\ns1 and s2 are sharing a data structure is transparent to clients, and it\ncertainly makes no difference in statements like the following, because\nthey only read values, they don’t write them:\ncout << s1;\n// read s1’s value\ncout << s1 + s2;\n// read s1’s and s2’s values\nIn fact, the only time the sharing of values makes a difference is when\none or the other string is modified; then it’s important that only one\nstring be changed, not both. In this statement,\ns2.convertToUpperCase();\nit’s crucial that only s2’s value be changed, not s1’s also. \nTo handle statements like this, we have to implement String’s con-\nvertToUpperCase function so that it makes a copy of s2’s value and\nmakes that value private to s2 before modifying it. Inside convert-\nToUpperCase, we can be lazy no longer: we have to make a copy of s2’s\n(shared) value for s2’s private use. On the other hand, if s2 is never\nmodified, we never have to make a private copy of its value. It can con-\ntinue to share a value as long as it exists. If we’re lucky, s2 will never\nbe modified, in which case we’ll never have to expend the effort to give\nit its own value.\nThe details on making this kind of value sharing work (including all the\ncode) are provided in Item 29, but the idea is lazy evaluation: don’t\nbother to make a copy of something until you really need one. Instead,\nbe lazy — use someone else’s copy as long as you can get away with it.\nIn some application areas, you can often get away with it forever.\n",
      "content_length": 2529,
      "extraction_method": "Direct"
    },
    {
      "page_number": 104,
      "chapter": null,
      "content": "Lazy Evaluation\n87\nDistinguishing Reads from Writes\nPursuing the example of reference-counting strings a bit further, we\ncome upon a second way in which lazy evaluation can help us. Con-\nsider this code:\nString s = \"Homer’s Iliad\";\n// Assume s is a \n// reference-counted string\n...\ncout << s[3];\n// call operator[] to read s[3]\ns[3] = ’x’;\n// call operator[] to write s[3]\nThe first call to operator[] is to read part of a string, but the second\ncall is to perform a write. We’d like to be able to distinguish the read\ncall from the write, because reading a reference-counted string is\ncheap, but writing to such a string may require splitting off a new copy\nof the string’s value prior to the write.\nThis puts us in a difficult implementation position. To achieve what we\nwant, we need to do different things inside operator[] (depending on\nwhether it’s being called to perform a read or a write). How can we de-\ntermine whether operator[] has been called in a read or a write con-\ntext? The brutal truth is that we can’t. By using lazy evaluation and\nproxy classes as described in Item 30, however, we can defer the deci-\nsion on whether to take read actions or write actions until we can de-\ntermine which is correct.\nLazy Fetching\nAs a third example of lazy evaluation, imagine you’ve got a program\nthat uses large objects containing many constituent fields. Such ob-\njects must persist across program runs, so they’re stored in a data-\nbase. Each object has a unique object identifier that can be used to\nretrieve the object from the database:\nclass LargeObject {\n// large persistent objects\npublic:\nLargeObject(ObjectID id);\n// restore object from disk\nconst string& field1() const;\n// value of field 1\nint field2() const;\n// value of field 2\ndouble field3() const;\n// ...\nconst string& field4() const;\nconst string& field5() const;\n...\n};\nNow consider the cost of restoring a LargeObject from disk:\n",
      "content_length": 1906,
      "extraction_method": "Direct"
    },
    {
      "page_number": 105,
      "chapter": null,
      "content": "88\nItem 17\nvoid restoreAndProcessObject(ObjectID id)\n{\nLargeObject object(id);\n// restore object\n...\n}\nBecause LargeObject instances are big, getting all the data for such\nan object might be a costly database operation, especially if the data\nmust be retrieved from a remote database and pushed across a net-\nwork. In some cases, the cost of reading all that data would be unnec-\nessary. For example, consider this kind of application:\nvoid restoreAndProcessObject(ObjectID id)\n{\nLargeObject object(id);\nif (object.field2() == 0) {\ncout << \"Object \" << id << \": null field2.\\n\";\n}\n}\nHere only the value of field2 is required, so any effort spent setting\nup the other fields is wasted.\nThe lazy approach to this problem is to read no data from disk when a\nLargeObject object is created. Instead, only the “shell” of an object is\ncreated, and data is retrieved from the database only when that partic-\nular data is needed inside the object. Here’s one way to implement this\nkind of “demand-paged” object initialization:\nclass LargeObject {\npublic:\nLargeObject(ObjectID id);\nconst string& field1() const;\nint field2() const;\ndouble field3() const;\nconst string& field4() const;\n...\nprivate:\nObjectID oid;\nmutable string *field1Value;\n// see below for a\nmutable int *field2Value;\n// discussion of \"mutable\"\nmutable double *field3Value;\nmutable string *field4Value;\n...\n};\n",
      "content_length": 1368,
      "extraction_method": "Direct"
    },
    {
      "page_number": 106,
      "chapter": null,
      "content": "Lazy Evaluation\n89\nLargeObject::LargeObject(ObjectID id)\n: oid(id), field1Value(0), field2Value(0), field3Value(0), ...\n{}\nconst string& LargeObject::field1() const\n{\nif (field1Value == 0) {\nread the data for field 1 from the database and make\nfield1Value point to it;\n}\nreturn *field1Value;\n}\nEach field in the object is represented as a pointer to the necessary\ndata, and the LargeObject constructor initializes each pointer to null.\nSuch null pointers signify fields that have not yet been read from the\ndatabase. Each LargeObject member function must check the state\nof a field’s pointer before accessing the data it points to. If the pointer\nis null, the corresponding data must be read from the database before\nperforming any operations on that data.\nWhen implementing lazy fetching, you must confront the problem that\nnull pointers may need to be initialized to point to real data from inside\nany member function, including const member functions like field1.\nHowever, compilers get cranky when you try to modify data members\ninside const member functions, so you’ve got to find a way to say, “It’s\nokay, I know what I’m doing.” The best way to say that is to declare the\npointer fields mutable, which means they can be modified inside any\nmember function, even inside const member functions. That’s why\nthe fields inside LargeObject above are declared mutable.\nThe mutable keyword is a relatively recent addition to C++, so it’s pos-\nsible your vendors don’t yet support it. If not, you’ll need to find an-\nother way to convince your compilers to let you modify data members\ninside const member functions. One workable strategy is the “fake\nthis” approach, whereby you create a pointer-to-non-const that\npoints to the same object as this does. When you want to modify a\ndata member, you access it through the “fake this” pointer:\nclass LargeObject {\npublic:\nconst string& field1() const;\n// unchanged\n...\nprivate:\nstring *field1Value;\n// not declared mutable\n...\n// so that older \n};\n// compilers will accept it\n",
      "content_length": 2020,
      "extraction_method": "Direct"
    },
    {
      "page_number": 107,
      "chapter": null,
      "content": "90\nItem 17\nconst string& LargeObject::field1() const\n{\n// declare a pointer, fakeThis, that points where this\n// does, but where the constness of the object has been\n// cast away\nLargeObject * const fakeThis =\nconst_cast<LargeObject* const>(this);\nif (field1Value == 0) {\nfakeThis->field1Value =\n// this assignment is OK,\nthe appropriate data\n// because what fakeThis\nfrom the database;\n// points to isn’t const\n}\nreturn *field1Value;\n}\nThis function employs a const_cast (see Item 2) to cast away the\nconstness of *this. If your compilers don’t support const_cast, you\ncan use an old C-style cast:\n// Use of old-style cast to help emulate mutable\nconst string& LargeObject::field1() const\n{\nLargeObject * const fakeThis = (LargeObject* const)this;\n...\n// as above\n}\nLook again at the pointers inside LargeObject. Let’s face it, it’s te-\ndious and error-prone to have to initialize all those pointers to null,\nthen test each one before use. Fortunately, such drudgery can be au-\ntomated through the use of smart pointers, which you can read about\nin Item 28. If you use smart pointers inside LargeObject, you’ll also\nfind you no longer need to declare the pointers mutable. Alas, it’s only\na temporary respite, because you’ll wind up needing mutable once you\nsit down to implement the smart pointer classes. Think of it as conser-\nvation of inconvenience.\nLazy Expression Evaluation\nA final example of lazy evaluation comes from numerical applications.\nConsider this code:\ntemplate<class T>\nclass Matrix { ... };\n// for homogeneous matrices\nMatrix<int> m1(1000, 1000);\n// a 1000 by 1000 matrix\nMatrix<int> m2(1000, 1000);\n// ditto\n...\nMatrix<int> m3 = m1 + m2;\n// add m1 and m2\n",
      "content_length": 1678,
      "extraction_method": "Direct"
    },
    {
      "page_number": 108,
      "chapter": null,
      "content": "Lazy Evaluation\n91\nThe usual implementation of operator+ would use eager evaluation;\nin this case it would compute and return the sum of m1 and m2. That’s\na fair amount of computation (1,000,000 additions), and of course\nthere’s the cost of allocating the memory to hold all those values, too. \nThe lazy evaluation strategy says that’s way too much work, so it\ndoesn’t do it. Instead, it sets up a data structure inside m3 that indi-\ncates that m3’s value is the sum of m1 and m2. Such a data structure\nmight consist of nothing more than a pointer to each of m1 and m2, plus\nan enum indicating that the operation on them is addition. Clearly, it’s\ngoing to be faster to set up this data structure than to add m1 and m2,\nand it’s going to use a lot less memory, too.\nSuppose that later in the program, before m3 has been used, this code\nis executed:\nMatrix<int> m4(1000, 1000);\n...\n// give m4 some values\nm3 = m4 * m1;\nNow we can forget all about m3 being the sum of m1 and m2 (and\nthereby save the cost of the computation), and in its place we can start\nremembering that m3 is the product of m4 and m1. Needless to say, we\ndon’t perform the multiplication. Why bother? We’re lazy, remember?\nThis example looks contrived, because no good programmer would\nwrite a program that computed the sum of two matrices and failed to\nuse it, but it’s not as contrived as it seems. No good programmer would\ndeliberately compute a value that’s not needed, but during mainte-\nnance, it’s not uncommon for a programmer to modify the paths\nthrough a program in such a way that a formerly useful computation\nbecomes unnecessary. The likelihood of that happening is reduced by\ndefining objects immediately prior to use, but it’s still a problem that\noccurs from time to time. \nNevertheless, if that were the only time lazy evaluation paid off, it\nwould hardly be worth the trouble. A more common scenario is that we\nneed only part of a computation. For example, suppose we use m3 as\nfollows after initializing it to the sum of m1 and m2:\ncout << m3[4];\n// print the 4th row of m3\nClearly we can be completely lazy no longer — we’ve got to compute the\nvalues in the fourth row of m3. But let’s not be overly ambitious, either.\nThere’s no reason we have to compute any more than the fourth row of\nm3; the remainder of m3 can remain uncomputed until it’s actually\nneeded. With luck, it never will be.\n",
      "content_length": 2379,
      "extraction_method": "Direct"
    },
    {
      "page_number": 109,
      "chapter": null,
      "content": "92\nItem 17\nHow likely are we to be lucky? Experience in the domain of matrix\ncomputations suggests the odds are in our favor. In fact, lazy evalua-\ntion lies behind the wonder that is APL. APL was developed in the\n1960s for interactive use by people who needed to perform matrix-\nbased calculations. Running on computers that had less computa-\ntional horsepower than the chips now found in high-end microwave\novens, APL was seemingly able to add, multiply, and even divide large\nmatrices instantly! Its trick was lazy evaluation. The trick was usually\neffective, because APL users typically added, multiplied, or divided ma-\ntrices not because they needed the entire resulting matrix, but only be-\ncause they needed a small part of it. APL employed lazy evaluation to\ndefer its computations until it knew exactly what part of a result ma-\ntrix was needed, then it computed only that part. In practice, this al-\nlowed users to perform computationally intensive tasks interactively in\nan environment where the underlying machine was hopelessly inade-\nquate for an implementation employing eager evaluation. Machines are\nfaster today, but data sets are bigger and users less patient, so many\ncontemporary matrix libraries continue to take advantage of lazy eval-\nuation.\nTo be fair, laziness sometimes fails to pay off. If m3 is used in this way,\ncout << m3;\n// print out all of m3\nthe jig is up and we’ve got to compute a complete value for m3. Simi-\nlarly, if one of the matrices on which m3 is dependent is about to be\nmodified, we have to take immediate action:\nm3 = m1 + m2;\n// remember that m3 is the\n// sum of m1 and m2\nm1 = m4;\n// now m3 is the sum of m2\n// and the OLD value of m1!\nHere we’ve got to do something to ensure that the assignment to m1\ndoesn’t change m3. Inside the Matrix<int> assignment operator, we\nmight compute m3’s value prior to changing m1 or we might make a\ncopy of the old value of m1 and make m3 dependent on that, but we\nhave to do something to guarantee that m3 has the value it’s supposed\nto have after m1 has been the target of an assignment. Other functions\nthat might modify a matrix must be handled in a similar fashion.\nBecause of the need to store dependencies between values; to maintain\ndata structures that can store values, dependencies, or a combination\nof the two; and to overload operators like assignment, copying, and ad-\ndition, lazy evaluation in a numerical domain is a lot of work. On the\nother hand, it often ends up saving significant amounts of time and\nspace during program runs, and in many applications, that’s a payoff\nthat easily justifies the significant effort lazy evaluation requires.\n",
      "content_length": 2649,
      "extraction_method": "Direct"
    },
    {
      "page_number": 110,
      "chapter": null,
      "content": "Amortizing the Cost of Expected Computations\n93\nSummary\nThese four examples show that lazy evaluation can be useful in a vari-\nety of domains: to avoid unnecessary copying of objects, to distinguish\nreads from writes using operator[], to avoid unnecessary reads from\ndatabases, and to avoid unnecessary numerical computations. Never-\ntheless, it’s not always a good idea. Just as procrastinating on your\nclean-up chores won’t save you any work if your parents always check\nup on you, lazy evaluation won’t save your program any work if all your\ncomputations are necessary. Indeed, if all your computations are es-\nsential, lazy evaluation may slow you down and increase your use of\nmemory, because, in addition to having to do all the computations you\nwere hoping to avoid, you’ll also have to manipulate the fancy data\nstructures needed to make lazy evaluation possible in the first place.\nLazy evaluation is only useful when there’s a reasonable chance your\nsoftware will be asked to perform computations that can be avoided.\nThere’s nothing about lazy evaluation that’s specific to C++. The tech-\nnique can be applied in any programming language, and several lan-\nguages — notably APL, some dialects of Lisp, and virtually all dataflow\nlanguages — embrace the idea as a fundamental part of the language.\nMainstream programming languages employ eager evaluation, how-\never, and C++ is mainstream. Yet C++ is particularly suitable as a ve-\nhicle for user-implemented lazy evaluation, because its support for\nencapsulation makes it possible to add lazy evaluation to a class with-\nout clients of that class knowing it’s been done. \nLook again at the code fragments used in the above examples, and you\ncan verify that the class interfaces offer no hints about whether eager\nor lazy evaluation is used by the classes. That means it’s possible to\nimplement a class using a straightforward eager evaluation strategy,\nbut then, if your profiling investigations (see Item 16) show that class’s\nimplementation is a performance bottleneck, you can replace its im-\nplementation with one based on lazy evaluation. The only change your\nclients will see (after recompilation or relinking) is improved perfor-\nmance. That’s the kind of software enhancement clients love, one that\ncan make you downright proud to be lazy.\nItem 18: Amortize the cost of expected computations.\nAmortizing the Cost of Expected Computations\nIn Item 17, I extolled the virtues of laziness, of putting things off as\nlong as possible, and I explained how laziness can improve the effi-\nciency of your programs. In this item, I adopt a different stance. Here,\nlaziness has no place. I now encourage you to improve the perfor-\nmance of your software by having it do more than it’s asked to do. The\n",
      "content_length": 2758,
      "extraction_method": "Direct"
    },
    {
      "page_number": 111,
      "chapter": null,
      "content": "94\nItem 18\nphilosophy of this item might be called over-eager evaluation: doing\nthings before you’re asked to do them.\nConsider, for example, a template for classes representing large collec-\ntions of numeric data:\ntemplate<class NumericalType>\nclass DataCollection {\npublic:\nNumericalType min() const;\nNumericalType max() const;\nNumericalType avg() const;\n...\n};\nAssuming the min, max, and avg functions return the current mini-\nmum, maximum, and average values of the collection, there are three\nways in which these functions can be implemented. Using eager eval-\nuation, we’d examine all the data in the collection when min, max, or\navg was called, and we’d return the appropriate value. Using lazy eval-\nuation, we’d have the functions return data structures that could be\nused to determine the appropriate value whenever the functions’ re-\nturn values were actually used. Using over-eager evaluation, we’d keep\ntrack of the running minimum, maximum, and average values of the\ncollection, so when min, max, or avg was called, we’d be able to return\nthe correct value immediately — no computation would be required. If\nmin, max, and avg were called frequently, we’d be able to amortize the\ncost of keeping track of the collection’s minimum, maximum, and av-\nerage values over all the calls to those functions, and the amortized\ncost per call would be lower than with eager or lazy evaluation.\nThe idea behind over-eager evaluation is that if you expect a computa-\ntion to be requested frequently, you can lower the average cost per re-\nquest by designing your data structures to handle the requests\nespecially efficiently. \nOne of the simplest ways to do this is by caching values that have al-\nready been computed and are likely to be needed again. For example,\nsuppose you’re writing a program to provide information about em-\nployees, and one of the pieces of information you expect to be re-\nquested frequently is an employee’s cubicle number. Further suppose\nthat employee information is stored in a database, but, for most appli-\ncations, an employee’s cubicle number is irrelevant, so the database is\nnot optimized to find it. To avoid having your specialized application\nunduly stress the database with repeated lookups of employee cubicle\nnumbers, you could write a findCubicleNumber function that caches\nthe cubicle numbers it looks up. Subsequent requests for cubicle\n",
      "content_length": 2382,
      "extraction_method": "Direct"
    },
    {
      "page_number": 112,
      "chapter": null,
      "content": "Amortizing the Cost of Expected Computations\n95\nnumbers that have already been retrieved can then be satisfied by con-\nsulting the cache instead of querying the database. \nHere’s one way to implement findCubicleNumber; it uses a map object\nfrom the Standard Template Library (the “STL” — see Item 35) as a\nlocal cache:\nint findCubicleNumber(const string& employeeName)\n{\n// define a static map to hold (employee name, cubicle number)\n// pairs. This map is the local cache.\ntypedef map<string, int> CubicleMap;\nstatic CubicleMap cubes;\n// try to find an entry for employeeName in the cache;\n// the STL iterator \"it\" will then point to the found \n// entry, if there is one (see Item 35 for details)\nCubicleMap::iterator it = cubes.find(employeeName);\n// \"it\"’s value will be cubes.end() if no entry was\n// found (this is standard STL behavior). If this is \n// the case, consult the database for the cubicle \n// number, then add it to the cache\nif (it == cubes.end()) {\nint cubicle = \nthe result of looking up employeeName’s cubicle\nnumber in the database;\ncubes[employeeName] = cubicle;\n// add the pair\n// (employeeName, cubicle)\n// to the cache\nreturn cubicle;\n}\nelse {\n// \"it\" points to the correct cache entry, which is a\n// (employee name, cubicle number) pair. We want only\n// the second component of this pair, and the member\n// \"second\" will give it to us\nreturn (*it).second;\n}\n}\nTry not to get bogged down in the details of the STL code (which will be\nclearer after you’ve read Item 35). Instead, focus on the general strat-\negy embodied by this function. That strategy is to use a local cache to\nreplace comparatively expensive database queries with comparatively\ninexpensive lookups in an in-memory data structure. Provided we’re\ncorrect in assuming that cubicle numbers will frequently be requested\nmore than once, the use of a cache in findCubicleNumber should re-\nduce the average cost of returning an employee’s cubicle number.\n",
      "content_length": 1941,
      "extraction_method": "Direct"
    },
    {
      "page_number": 113,
      "chapter": null,
      "content": "96\nItem 18\n(One detail of the code requires explanation. The final statement re-\nturns (*it).second instead of the more conventional it->second.\nWhy? The answer has to do with the conventions followed by the STL.\nIn brief, the iterator it is an object, not a pointer, so there is no guar-\nantee that “->” can be applied to it.† The STL does require that “.”\nand “*” be valid for iterators, however, so (*it).second, though syn-\ntactically clumsy, is guaranteed to work.)\nCaching is one way to amortize the cost of anticipated computations.\nPrefetching is another. You can think of prefetching as the computa-\ntional equivalent of a discount for buying in bulk. Disk controllers, for\nexample, read entire blocks or sectors of data when they read from\ndisk, even if a program asks for only a small amount of data. That’s be-\ncause it’s faster to read a big chunk once than to read two or three\nsmall chunks at different times. Furthermore, experience has shown\nthat if data in one place is requested, it’s quite common to want nearby\ndata, too. This is the infamous locality of reference phenomenon, and\nsystems designers rely on it to justify disk caches, memory caches for\nboth instructions and data, and instruction prefetches.\nExcuse me? You say you don’t worry about such low-level things as\ndisk controllers or CPU caches? No problem. Prefetching can yield div-\nidends for even one as high-level as you. Imagine, for example, you’d\nlike to implement a template for dynamic arrays, i.e., arrays that start\nwith a size of one and automatically extend themselves so that all non-\nnegative indices are valid:\ntemplate<class T>\n// template for dynamic\nclass DynArray { ... };\n// array-of-T classes\nDynArray<double> a;\n// at this point, only a[0]\n// is a legitimate array\n// element\na[22] = 3.5;\n// a is automatically\n// extended: valid indices\n// are now 0-22\na[32] = 0;\n// a extends itself again;\n// now a[0]-a[32] are valid\nHow does a DynArray object go about extending itself when it needs\nto? A straightforward strategy would be to allocate only as much addi-\ntional memory as needed, something like this:\n† In July 1995, the ISO/ANSI committee standardizing C++ added a requirement that\nmost STL iterators support the “->” operator, so it->second should now work. Some\nSTL implementations fail to satisfy this requirement, however, so (*it).second is\nstill the more portable construct.\n",
      "content_length": 2390,
      "extraction_method": "Direct"
    },
    {
      "page_number": 114,
      "chapter": null,
      "content": "Amortizing the Cost of Expected Computations\n97\ntemplate<class T>\nT& DynArray<T>::operator[](int index)\n{\nif (index < 0) {\nthrow an exception;\n// negative indices are\n}\n// still invalid\nif (index > the current maximum index value) {\ncall new to allocate enough additional memory so that \nindex is valid;\n}\nreturn the indexth element of the array;\n}\nThis approach simply calls new each time it needs to increase the size\nof the array, but calls to new invoke operator new (see Item 8), and\ncalls to operator new (and operator delete) are usually expensive.\nThat’s because they typically result in calls to the underlying operating\nsystem, and system calls are generally slower than are in-process\nfunction calls. As a result, we’d like to make as few system calls as pos-\nsible.\nAn over-eager evaluation strategy employs this reasoning: if we have to\nincrease the size of the array now to accommodate index i, the locality\nof reference principle suggests we’ll probably have to increase it in the\nfuture to accommodate some other index a bit larger than i. To avoid\nthe cost of the memory allocation for the second (anticipated) expan-\nsion, we’ll increase the size of the DynArray now by more than is re-\nquired to make i valid, and we’ll hope that future expansions occur\nwithin the range we have thereby provided for. For example, we could\nwrite DynArray::operator[] like this:\ntemplate<class T>\nT& DynArray<T>::operator[](int index)\n{\nif (index < 0) throw an exception;\nif (index > the current maximum index value) {\nint diff = index - the current maximum index value;\ncall new to allocate enough additional memory so that \nindex+diff is valid;\n}\nreturn the indexth element of the array;\n}\nThis function allocates twice as much memory as needed each time the\narray must be extended. If we look again at the usage scenario we saw\nearlier, we note that the DynArray must allocate additional memory\nonly once, even though its logical size is extended twice:\n",
      "content_length": 1958,
      "extraction_method": "Direct"
    },
    {
      "page_number": 115,
      "chapter": null,
      "content": "98\nItem 19\nDynArray<double> a;\n// only a[0] is valid\na[22] = 3.5;\n// new is called to expand\n// a’s storage through\n// index 44; a’s logical\n// size becomes 23\na[32] = 0;\n// a’s logical size is\n// changed to allow a[32],\n// but new isn’t called\nIf a needs to be extended again, that extension, too, will be inexpen-\nsive, provided the new maximum index is no greater than 44.\nThere is a common theme running through this Item, and that’s that\ngreater speed can often be purchased at a cost of increased memory\nusage. Keeping track of running minima, maxima, and averages re-\nquires extra space, but it saves time. Caching results necessitates\ngreater memory usage but reduces the time needed to regenerate the\nresults once they’ve been cached. Prefetching demands a place to put\nthe things that are prefetched, but it reduces the time needed to access\nthose things. The story is as old as Computer Science: you can often\ntrade space for time. (Not always, however. Using larger objects means\nfewer fit on a virtual memory or cache page. In rare cases, making ob-\njects bigger reduces the performance of your software, because your\npaging activity increases, your cache hit rate decreases, or both. How\ndo you find out if you’re suffering from such problems? You profile,\nprofile, profile (see Item 16).)\nThe advice I proffer in this Item — that you amortize the cost of antic-\nipated computations through over-eager strategies like caching and\nprefetching — is not contradictory to the advice on lazy evaluation I\nput forth in Item 17. Lazy evaluation is a technique for improving the\nefficiency of programs when you must support operations whose re-\nsults are not always needed. Over-eager evaluation is a technique for\nimproving the efficiency of programs when you must support opera-\ntions whose results are almost always needed or whose results are\noften needed more than once. Both are more difficult to implement\nthan run-of-the-mill eager evaluation, but both can yield significant\nperformance improvements in programs whose behavioral character-\nistics justify the extra programming effort.\nItem 19: Understand the origin of temporary objects.\nTemporary Objects\nWhen programmers speak amongst themselves, they often refer to\nvariables that are needed for only a short while as “temporaries.” For\nexample, in this swap routine,\n",
      "content_length": 2335,
      "extraction_method": "Direct"
    },
    {
      "page_number": 116,
      "chapter": null,
      "content": "Temporary Objects\n99\ntemplate<class T>\nvoid swap(T& object1, T& object2)\n{\nT temp = object1;\nobject1 = object2;\nobject2 = temp;\n}\nit’s common to call temp a “temporary.” As far as C++ is concerned,\nhowever, temp is not a temporary at all. It’s simply an object local to a\nfunction. \nTrue temporary objects in C++ are invisible — they don’t appear in\nyour source code. They arise whenever a non-heap object is created\nbut not named. Such unnamed objects usually arise in one of two sit-\nuations: when implicit type conversions are applied to make function\ncalls succeed and when functions return objects. It’s important to un-\nderstand how and why these temporary objects are created and de-\nstroyed, because the attendant costs of their construction and\ndestruction can have a noticeable impact on the performance of your\nprograms.\nConsider first the case in which temporary objects are created to make\nfunction calls succeed. This happens when the type of object passed to\na function is not the same as the type of the parameter to which it is\nbeing bound. For example, consider a function that counts the number\nof occurrences of a character in a string:\n// returns the number of occurrences of ch in str\nsize_t countChar(const string& str, char ch);\nchar buffer[MAX_STRING_LEN];\nchar c;\n// read in a char and a string; use setw to avoid \n// overflowing buffer when reading the string\ncin >> c >> setw(MAX_STRING_LEN) >> buffer;\ncout << \"There are \" << countChar(buffer, c) \n<< \" occurrences of the character \" << c\n<< \" in \" << buffer << endl;\nLook at the call to countChar. The first argument passed is a char ar-\nray, but the corresponding function parameter is of type const\nstring&. This call can succeed only if the type mismatch can be elim-\ninated, and your compilers will be happy to eliminate it by creating a\ntemporary object of type string. That temporary object is initialized\nby calling the string constructor with buffer as its argument. The\nstr parameter of countChar is then bound to this temporary string\nobject. When the statement containing the call to countChar finishes\nexecuting, the temporary object is automatically destroyed.\n",
      "content_length": 2154,
      "extraction_method": "Direct"
    },
    {
      "page_number": 117,
      "chapter": null,
      "content": "100\nItem 19\nConversions such as these are convenient (though dangerous — see\nItem 5), but from an efficiency point of view, the construction and de-\nstruction of a temporary string object is an unnecessary expense.\nThere are two general ways to eliminate it. One is to redesign your code\nso conversions like these can’t take place. That strategy is examined in\nItem 5. An alternative tack is to modify your software so that the con-\nversions are unnecessary. Item 21 describes how you can do that.\nThese conversions occur only when passing objects by value or when\npassing to a reference-to-const parameter. They do not occur when\npassing an object to a reference-to-non-const parameter. Consider\nthis function:\nvoid uppercasify(string& str);\n// changes all chars in\n// str to upper case\nIn the character-counting example, a char array could be successfully\npassed to countChar, but here, trying to call uppercasify with a\nchar array fails:\nchar subtleBookPlug[] = \"Effective C++\";\nuppercasify(subtleBookPlug);\n// error!\nNo temporary is created to make the call succeed. Why not?\nSuppose a temporary were created. Then the temporary would be\npassed to uppercasify, which would modify the temporary so its\ncharacters were in upper case. But the actual argument to the func-\ntion call — subtleBookPlug — would not be affected; only the tempo-\nrary string object generated from subtleBookPlug would be\nchanged. Surely this is not what the programmer intended. That pro-\ngrammer passed subtleBookPlug to uppercasify, and that pro-\ngrammer expected subtleBookPlug to be modified. Implicit type\nconversion for references-to-non-const objects, then, would allow\ntemporary objects to be changed when programmers expected non-\ntemporary objects to be modified. That’s why the language prohibits\nthe generation of temporaries for non-const reference parameters.\nReference-to-const parameters don’t suffer from this problem, be-\ncause such parameters, by virtue of being const, can’t be changed.\nThe second set of circumstances under which temporary objects are\ncreated is when a function returns an object. For instance, operator+\nmust return an object that represents the sum of its operands. Given\na type Number, for example, operator+ for that type would be declared\nlike this:\nconst Number operator+(const Number& lhs,\nconst Number& rhs);\n",
      "content_length": 2333,
      "extraction_method": "Direct"
    },
    {
      "page_number": 118,
      "chapter": null,
      "content": "The Return Value Optimization\n101\nThe return value of this function is a temporary, because it has no\nname: it’s just the function’s return value. You must pay to construct\nand destruct this object each time you call operator+. (For an expla-\nnation of why the return value is const, see Item 6.)\nAs usual, you don’t want to incur this cost. For this particular func-\ntion, you can avoid paying by switching to a similar function, opera-\ntor+=; Item 22 tells you about this transformation. For most functions\nthat return objects, however, switching to a different function is not an\noption and there is no way to avoid the construction and destruction\nof the return value. At least, there’s no way to avoid it conceptually. Be-\ntween concept and reality, however, lies a murky zone called optimiza-\ntion, and sometimes you can write your object-returning functions in a\nway that allows your compilers to optimize temporary objects out of ex-\nistence. Of these optimizations, the most common and useful is the re-\nturn value optimization, which is the subject of Item 20. \nThe bottom line is that temporary objects can be costly, so you want to\neliminate them whenever you can. More important than this, however,\nis to train yourself to look for places where temporary objects may be\ncreated. Anytime you see a reference-to-const parameter, the possibil-\nity exists that a temporary will be created to bind to that parameter.\nAnytime you see a function returning an object, a temporary will be\ncreated (and later destroyed). Learn to look for such constructs, and\nyour insight into the cost of “behind the scenes” compiler actions will\nmarkedly improve.\nItem 20: Facilitate the return value optimization.\nThe Return Value Optimization\nA function that returns an object is frustrating to efficiency aficiona-\ndos, because the by-value return, including the constructor and de-\nstructor calls it implies (see Item 19), cannot be eliminated. The\nproblem is simple: a function either has to return an object in order to\noffer correct behavior or it doesn’t. If it does, there’s no way to get rid\nof the object being returned. Period.\nConsider the operator* function for rational numbers:\n",
      "content_length": 2183,
      "extraction_method": "Direct"
    },
    {
      "page_number": 119,
      "chapter": null,
      "content": "102\nItem 20\nclass Rational {\npublic:\nRational(int numerator = 0, int denominator = 1);\n...\nint numerator() const;\nint denominator() const;\n};\n// For an explanation of why the return value is const,\n// see Item 6\nconst Rational operator*(const Rational& lhs,\nconst Rational& rhs);\nWithout even looking at the code for operator*, we know it must re-\nturn an object, because it returns the product of two arbitrary num-\nbers. These are arbitrary numbers. How can operator* possibly avoid\ncreating a new object to hold their product? It can’t, so it must create\na new object and return it. C++ programmers have nevertheless ex-\npended Herculean efforts in a search for the legendary elimination of\nthe by-value return. \nSometimes people return pointers, which leads to this syntactic trav-\nesty:\n// an unreasonable way to avoid returning an object\nconst Rational * operator*(const Rational& lhs,\nconst Rational& rhs);\nRational a = 10;\nRational b(1, 2);\nRational c = *(a * b);\n// Does this look \"natural\"\n// to you?\nIt also raises a question. Should the caller delete the pointer returned\nby the function? The answer is usually yes, and that usually leads to\nresource leaks.\nOther developers return references. That yields an acceptable syntax,\n// a dangerous (and incorrect) way to avoid returning\n// an object\nconst Rational& operator*(const Rational& lhs,\nconst Rational& rhs);\nRational a = 10;\nRational b(1, 2);\nRational c = a * b;\n// looks perfectly reasonable\nbut such functions can’t be implemented in a way that behaves cor-\nrectly. A common attempt looks like this:\n",
      "content_length": 1570,
      "extraction_method": "Direct"
    },
    {
      "page_number": 120,
      "chapter": null,
      "content": "The Return Value Optimization\n103\n// another dangerous (and incorrect) way to avoid \n// returning an object\nconst Rational& operator*(const Rational& lhs,\nconst Rational& rhs)\n{\nRational result(lhs.numerator() * rhs.numerator(),\nlhs.denominator() * rhs.denominator());\nreturn result;\n}\nThis function returns a reference to an object that no longer exists. In\nparticular, it returns a reference to the local object result, but re-\nsult is automatically destroyed when operator* is exited. Returning\na reference to an object that’s been destroyed is hardly useful.\nTrust me on this: some functions (operator* among them) just have\nto return objects. That’s the way it is. Don’t fight it. You can’t win.\nThat is, you can’t win in your effort to eliminate by-value returns from\nfunctions that require them. But that’s the wrong war to wage. From\nan efficiency point of view, you shouldn’t care that a function returns\nan object, you should only care about the cost of that object. What you\nneed to do is channel your efforts into finding a way to reduce the cost\nof returned objects, not to eliminate the objects themselves (which we\nnow recognize is a futile quest). If no cost is associated with such ob-\njects, who cares how many get created?\nIt is frequently possible to write functions that return objects in such\na way that compilers can eliminate the cost of the temporaries. The\ntrick is to return constructor arguments instead of objects, and you can\ndo it like this:\n// an efficient and correct way to implement a \n// function that returns an object\nconst Rational operator*(const Rational& lhs,\nconst Rational& rhs)\n{\nreturn Rational(lhs.numerator() * rhs.numerator(),\nlhs.denominator() * rhs.denominator());\n}\nLook closely at the expression being returned. It looks like you’re call-\ning a Rational constructor, and in fact you are. You’re creating a tem-\nporary Rational object through this expression,\nRational(lhs.numerator() * rhs.numerator(),\nlhs.denominator() * rhs.denominator());\nand it is this temporary object the function is copying for its return\nvalue.\n",
      "content_length": 2074,
      "extraction_method": "Direct"
    },
    {
      "page_number": 121,
      "chapter": null,
      "content": "104\nItem 20\nThis business of returning constructor arguments instead of local ob-\njects doesn’t appear to have bought you a lot, because you still have to\npay for the construction and destruction of the temporary created in-\nside the function, and you still have to pay for the construction and de-\nstruction of the object the function returns. But you have gained\nsomething. The rules for C++ allow compilers to optimize temporary\nobjects out of existence. As a result, if you call operator* in a context\nlike this,\nRational a = 10;\nRational b(1, 2);\nRational c = a * b;\n// operator* is called here\nyour compilers are allowed to eliminate both the temporary inside op-\nerator* and the temporary returned by operator*. They can con-\nstruct the object defined by the return expression inside the memory\nallotted for the object c. If your compilers do this, the total cost of tem-\nporary objects as a result of your calling operator* is zero: no tempo-\nraries are created. Instead, you pay for only one constructor call — the\none to create c. Furthermore, you can’t do any better than this, be-\ncause c is a named object, and named objects can’t be eliminated (see\nalso Item 22).† You can, however, eliminate the overhead of the call to\noperator* by declaring that function inline:\n// the most efficient way to write a function returning\n// an object\ninline const Rational operator*(const Rational& lhs,\nconst Rational& rhs)\n{\nreturn Rational(lhs.numerator() * rhs.numerator(),\nlhs.denominator() * rhs.denominator());\n}\n“Yeah, yeah,” you mutter, “optimization, schmoptimization. Who cares\nwhat compilers can do? I want to know what they do do. Does any of\nthis nonsense work with real compilers?” It does. This particular opti-\nmization — eliminating a local temporary by using a function’s return\nlocation (and possibly replacing that with an object at the function’s\ncall site) — is both well-known and commonly implemented. It even\nhas a name: the return value optimization. In fact, the existence of a\nname for this optimization may explain why it’s so widely available.\nProgrammers looking for a C++ compiler can ask vendors whether the\nreturn value optimization is implemented. If one vendor says yes and\nanother says “The what?,” the first vendor has a notable competitive\nadvantage. Ah, capitalism. Sometimes you just gotta love it.\n† In July 1996, the ISO/ANSI standardization committee declared that both named and\nunnamed objects may be optimized away via the return value optimization.\n",
      "content_length": 2496,
      "extraction_method": "Direct"
    },
    {
      "page_number": 122,
      "chapter": null,
      "content": "Overloading to Avoid Implicit Type Conversions\n105\nItem 21: Overload to avoid implicit type conversions.\nOverloading to Avoid Implicit Type Conversions\nHere’s some code that looks nothing if not eminently reasonable:\nclass UPInt {\n// class for unlimited\npublic:\n// precision integers\nUPInt();\nUPInt(int value);\n...\n};\n// For an explanation of why the return value is const,\n// see Item 6\nconst UPInt operator+(const UPInt& lhs, const UPInt& rhs);\nUPInt upi1, upi2;\n...\nUPInt upi3 = upi1 + upi2;\nThere are no surprises here. upi1 and upi2 are both UPInt objects, so\nadding them together just calls operator+ for UPInts.\nNow consider these statements:\nupi3 = upi1 + 10;\nupi3 = 10 + upi2;\nThese statements also succeed. They do so through the creation of\ntemporary objects to convert the integer 10 into UPInts (see Item 19). \nIt is convenient to have compilers perform these kinds of conversions,\nbut the temporary objects created to make the conversions work are a\ncost we may not wish to bear. Just as most people want government\nbenefits without having to pay for them, most C++ programmers want\nimplicit type conversions without incurring any cost for temporaries.\nBut without the computational equivalent of deficit spending, how can\nwe do it?\nWe can take a step back and recognize that our goal isn’t really type\nconversion, it’s being able to make calls to operator+ with a combina-\ntion of UPInt and int arguments. Implicit type conversion happens to\nbe a means to that end, but let us not confuse means and ends. There\nis another way to make mixed-type calls to operator+ succeed, and\nthat’s to eliminate the need for type conversions in the first place. If we\nwant to be able to add UPInt and int objects, all we have to do is say\nso. We do it by declaring several functions, each with a different set of\nparameter types:\nconst UPInt operator+(const UPInt& lhs,\n// add UPInt\nconst UPInt& rhs);\n// and UPInt\n",
      "content_length": 1915,
      "extraction_method": "Direct"
    },
    {
      "page_number": 123,
      "chapter": null,
      "content": "106\nItem 21\nconst UPInt operator+(const UPInt& lhs,\n// add UPInt\nint rhs);\n// and int\nconst UPInt operator+(int lhs,\n// add int and \nconst UPInt& rhs);\n// UPInt\nUPInt upi1, upi2;\n...\nUPInt upi3 = upi1 + upi2;\n// fine, no temporary for \n// upi1 or upi2\nupi3 = upi1 + 10;\n// fine, no temporary for\n// upi1 or 10\nupi3 = 10 + upi2;\n// fine, no temporary for \n// 10 or upi2\nOnce you start overloading to eliminate type conversions, you run the\nrisk of getting swept up in the passion of the moment and declaring\nfunctions like this:\nconst UPInt operator+(int lhs, int rhs);\n// error!\nThe thinking here is reasonable enough. For the types UPInt and int,\nwe want to overload on all possible combinations for operator+. Given\nthe three overloadings above, the only one missing is operator+ tak-\ning two int arguments, so we want to add it.\nReasonable or not, there are rules to this C++ game, and one of them\nis that every overloaded operator must take at least one argument of a\nuser-defined type. int isn’t a user-defined type, so we can’t overload\nan operator taking only arguments of that type. (If this rule didn’t ex-\nist, programmers would be able to change the meaning of predefined\noperations, and that would surely lead to chaos. For example, the at-\ntempted overloading of operator+ above would change the meaning of\naddition on ints. Is that really something we want people to be able to\ndo?)\nOverloading to avoid temporaries isn’t limited to operator functions.\nFor example, in most programs, you’ll want to allow a string object\neverywhere a char* is acceptable, and vice versa. Similarly, if you’re\nusing a numerical class like complex (see Item 35), you’ll want types\nlike int and double to be valid anywhere a numerical object is. As a\nresult, any function taking arguments of type string, char*, com-\nplex, etc., is a reasonable candidate for overloading to eliminate type\nconversions.\nStill, it’s important to keep the 80-20 rule (see Item 16) in mind. There\nis no point in implementing a slew of overloaded functions unless you\n",
      "content_length": 2040,
      "extraction_method": "Direct"
    },
    {
      "page_number": 124,
      "chapter": null,
      "content": "op= Compared to Stand-Alone op\n107\nhave good reason to believe that it will make a noticeable improvement\nin the overall efficiency of the programs that use them.\nItem 22: Consider using op= instead of stand-alone op.\nop= Compared to Stand-Alone op\nMost programmers expect that if they can say things like these,\nx = x + y;\nx = x - y;\nthey can also say things like these:\nx += y;\nx -= y;\nIf x and y are of a user-defined type, there is no guarantee that this is\nso. As far as C++ is concerned, there is no relationship between oper-\nator+, operator=, and operator+=, so if you want all three operators\nto exist and to have the expected relationship, you must implement\nthat yourself. Ditto for the operators -, *, /, etc.\nA good way to ensure that the natural relationship between the assign-\nment version of an operator (e.g., operator+=) and the stand-alone\nversion (e.g., operator+) exists is to implement the latter in terms of\nthe former (see also Item 6). This is easy to do:\nclass Rational {\npublic:\n...\nRational& operator+=(const Rational& rhs);\nRational& operator-=(const Rational& rhs);\n};\n// operator+ implemented in terms of operator+=; see\n// Item 6 for an explanation of why the return value is\n// const and page 109 for a warning about implementation\nconst Rational operator+(const Rational& lhs,\nconst Rational& rhs)\n{\nreturn Rational(lhs) += rhs;\n}\n// operator- implemented in terms of operator -=\nconst Rational operator-(const Rational& lhs,\nconst Rational& rhs)\n{\nreturn Rational(lhs) -= rhs;\n}\nIn this example, operators += and -= are implemented (elsewhere)\nfrom scratch, and operator+ and operator- call them to provide\ntheir own functionality. With this design, only the assignment versions\nof these operators need to be maintained. Furthermore, assuming the\n",
      "content_length": 1783,
      "extraction_method": "Direct"
    },
    {
      "page_number": 125,
      "chapter": null,
      "content": "108\nItem 22\nassignment versions of the operators are in the class’s public interface,\nthere is never a need for the stand-alone operators to be friends of the\nclass. \nIf you don’t mind putting all stand-alone operators at global scope, you\ncan use templates to eliminate the need to write the stand-alone func-\ntions:\ntemplate<class T>\nconst T operator+(const T& lhs, const T& rhs)\n{\nreturn T(lhs) += rhs;\n// see discussion below\n}\ntemplate<class T>\nconst T operator-(const T& lhs, const T& rhs)\n{\nreturn T(lhs) -= rhs;\n// see discussion below\n}\n...\nWith these templates, as long as an assignment version of an operator\nis defined for some type T, the corresponding stand-alone operator will\nautomatically be generated if it’s needed.\nAll this is well and good, but so far we have failed to consider the issue\nof efficiency, and efficiency is, after all, the topic of this chapter. Three\naspects of efficiency are worth noting here. The first is that, in general,\nassignment versions of operators are more efficient than stand-alone\nversions, because stand-alone versions must typically return a new\nobject, and that costs us the construction and destruction of a tempo-\nrary (see Items 19 and 20). Assignment versions of operators write to\ntheir left-hand argument, so there is no need to generate a temporary\nto hold the operator’s return value.\nThe second point is that by offering assignment versions of operators\nas well as stand-alone versions, you allow clients of your classes to\nmake the difficult trade-off between efficiency and convenience. That\nis, your clients can decide whether to write their code like this,\nRational a, b, c, d, result;\n...\nresult = a + b + c + d;\n// probably uses 3 temporary\n// objects, one for each call\n// to operator+\nor like this:\nresult = a;\n// no temporary needed\nresult += b;\n// no temporary needed\nresult += c;\n// no temporary needed\nresult += d;\n// no temporary needed\n",
      "content_length": 1914,
      "extraction_method": "Direct"
    },
    {
      "page_number": 126,
      "chapter": null,
      "content": "op= Compared to Stand-Alone op\n109\nThe former is easier to write, debug, and maintain, and it offers accept-\nable performance about 80% of the time (see Item 16). The latter is\nmore efficient, and, one supposes, more intuitive for assembly lan-\nguage programmers. By offering both options, you let clients develop\nand debug code using the easier-to-read stand-alone operators while\nstill reserving the right to replace them with the more efficient assign-\nment versions of the operators. Furthermore, by implementing the\nstand-alones in terms of the assignment versions, you ensure that\nwhen clients switch from one to the other, the semantics of the opera-\ntions remain constant.\nThe final efficiency observation concerns implementing the stand-\nalone operators. Look again at the implementation for operator+:\ntemplate<class T>\nconst T operator+(const T& lhs, const T& rhs)\n{ return T(lhs) += rhs; }\nThe expression T(lhs) is a call to T’s copy constructor. It creates a\ntemporary object whose value is the same as that of lhs. This tempo-\nrary is then used to invoke operator+= with rhs, and the result of\nthat operation is returned from operator+.† This code seems unnec-\nessarily cryptic. Wouldn’t it be better to write it like this?\ntemplate<class T>\nconst T operator+(const T& lhs, const T& rhs)\n{\nT result(lhs);\n// copy lhs into result\nreturn result += rhs;\n// add rhs to it and return\n}\nThis template is almost equivalent to the one above, but there is a cru-\ncial difference. This second template contains a named object, result.\nThe fact that this object is named means that the return value optimi-\nzation (see Item 20) was, until relatively recently, unavailable for this\nimplementation of operator+ (see the footnote on page 104). The first\nimplementation has always been eligible for the return value optimi-\nzation, so the odds may be better that the compilers you use will gen-\nerate optimized code for it.\nNow, truth in advertising compels me to point out that the expression \nreturn T(lhs) += rhs;\nis more complex than most compilers are willing to subject to the re-\nturn value optimization. The first implementation above may thus cost\nyou one temporary object within the function, just as you’d pay for\nusing the named object result. However, the fact remains that un-\nnamed objects have historically been easier to eliminate than named\nobjects, so when faced with a choice between a named object and a\n† At least that’s what’s supposed to happen. Alas, some compilers treat T(lhs) as a cast\nto remove lhs’s constness, then add rhs to lhs and return a reference to the modified\nlhs! Test your compilers before relying on the behavior described above.\n",
      "content_length": 2672,
      "extraction_method": "Direct"
    },
    {
      "page_number": 127,
      "chapter": null,
      "content": "110\nItem 23\ntemporary object, you may be better off using the temporary. It should\nnever cost you more than its named colleague, and, especially with\nolder compilers, it may cost you less.\nAll this talk of named objects, unnamed objects, and compiler optimi-\nzations is interesting, but let us not forget the big picture. The big pic-\nture is that assignment versions of operators (such as operator+=)\ntend to be more efficient than stand-alone versions of those operators\n(e.g. operator+). As a library designer, you should offer both, and as\nan application developer, you should consider using assignment ver-\nsions of operators instead of stand-alone versions whenever perfor-\nmance is at a premium.\nItem 23: Consider alternative libraries.\nConsidering Alternative Libraries\nLibrary design is an exercise in compromise. The ideal library is small,\nfast, powerful, flexible, extensible, intuitive, universally available, well\nsupported, free of use restrictions, and bug-free. It is also nonexistent.\nLibraries optimized for size and speed are typically not portable. Li-\nbraries with rich functionality are rarely intuitive. Bug-free libraries\nare limited in scope. In the real world, you can’t have everything; some-\nthing always has to give.\nDifferent designers assign different priorities to these criteria. They\nthus sacrifice different things in their designs. As a result, it is not un-\ncommon for two libraries offering similar functionality to have quite\ndifferent performance profiles. \nAs an example, consider the iostream and stdio libraries, both of which\nshould be available to every C++ programmer. The iostream library has\nseveral advantages over its C counterpart. It’s type-safe, for example,\nand it’s extensible. In terms of efficiency, however, the iostream library\ngenerally suffers in comparison with stdio, because stdio usually re-\nsults in executables that are both smaller and faster than those arising\nfrom iostreams.\nConsider first the speed issue. One way to get a feel for the difference\nin performance between iostreams and stdio is to run benchmark ap-\nplications using both libraries. Now, it’s important to bear in mind that\nbenchmarks lie. Not only is it difficult to come up with a set of inputs\nthat correspond to “typical” usage of a program or library, it’s also use-\nless unless you have a reliable way of determining how “typical” you or\nyour clients are. Nevertheless, benchmarks can provide some insight\ninto the comparative performance of different approaches to a prob-\nlem, so though it would be foolish to rely on them completely, it would\nalso be foolish to ignore them.\n",
      "content_length": 2621,
      "extraction_method": "Direct"
    },
    {
      "page_number": 128,
      "chapter": null,
      "content": "Considering Alternative Libraries\n111\nLet’s examine a simple-minded benchmark program that exercises\nonly the most rudimentary I/O functionality. This program reads\n30,000 floating point numbers from standard input and writes them to\nstandard output in a fixed format. The choice between the iostream\nand stdio libraries is made during compilation and is determined by\nthe preprocessor symbol STDIO. If this symbol is defined, the stdio li-\nbrary is used, otherwise the iostream library is employed.\n#ifdef STDIO\n#include <stdio.h>\n#else\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n#endif\nconst int VALUES = 30000; \n// # of values to read/write\nint main()\n{\ndouble d;\nfor (int n = 1; n <= VALUES; ++n) {\n#ifdef STDIO\nscanf(\"%lf\", &d);\nprintf(\"%10.5f\", d);\n#else\ncin >> d;\ncout << setw(10)\n// set field width\n<< setprecision(5)\n// set decimal places\n<< setiosflags(ios::showpoint)\n// keep trailing 0s\n<< setiosflags(ios::fixed)\n// use these settings\n<< d;\n#endif\nif (n % 5 == 0) {\n#ifdef STDIO\nprintf(\"\\n\");\n#else\ncout << '\\n';\n#endif\n}\n}\nreturn 0;\n}\nWhen this program is given the natural logarithms of the positive inte-\ngers as input, it produces output like this:\n",
      "content_length": 1183,
      "extraction_method": "Direct"
    },
    {
      "page_number": 129,
      "chapter": null,
      "content": "112\nItem 23\n0.00000   0.69315   1.09861   1.38629   1.60944\n1.79176   1.94591   2.07944   2.19722   2.30259\n2.39790   2.48491   2.56495   2.63906   2.70805\n2.77259   2.83321   2.89037   2.94444   2.99573\n3.04452   3.09104   3.13549   3.17805   3.21888\nSuch output demonstrates, if nothing else, that it’s possible to produce\nfixed-format I/O using iostreams. Of course, \ncout << setw(10)\n<< setprecision(5)\n<< setiosflags(ios::showpoint)\n<< setiosflags(ios::fixed)\n<< d;\nis nowhere near as easy to type as\nprintf(\"%10.5f\", d);\nbut operator<< is both type-safe and extensible, and printf is nei-\nther.\nI have run this program on several combinations of machines, operat-\ning systems, and compilers, and in every case the stdio version has\nbeen faster. Sometimes it’s been only a little faster (about 20%), some-\ntimes it’s been substantially faster (nearly 200%), but I’ve never come\nacross an iostream implementation that was as fast as the correspond-\ning stdio implementation. In addition, the size of this trivial program’s\nexecutable using stdio tends to be smaller (sometimes much smaller)\nthan the corresponding program using iostreams. (For programs of a\nrealistic size, this difference is rarely significant.)\nBear in mind that any efficiency advantages of stdio are highly imple-\nmentation-dependent, so future implementations of systems I’ve\ntested or existing implementations of systems I haven’t tested may\nshow a negligible performance difference between iostreams and stdio.\nIn fact, one can reasonably hope to discover an iostream implementa-\ntion that’s faster than stdio, because iostreams determine the types of\ntheir operands during compilation, while stdio functions typically\nparse a format string at runtime.\nThe contrast in performance between iostreams and stdio is just an\nexample, however, it’s not the main point. The main point is that dif-\nferent libraries offering similar functionality often feature different per-\nformance trade-offs, so once you’ve identified the bottlenecks in your\nsoftware (via profiling — see Item 16), you should see if it’s possible to\nremove those bottlenecks by replacing one library with another. If your\nprogram has an I/O bottleneck, for example, you might consider re-\nplacing iostreams with stdio, but if it spends a significant portion of its\ntime on dynamic memory allocation and deallocation, you might see if\n",
      "content_length": 2376,
      "extraction_method": "Direct"
    },
    {
      "page_number": 130,
      "chapter": null,
      "content": "The Costs of Various Language Features\n113\nthere are alternative implementations of operator new and operator\ndelete available (see Item 8). Because different libraries embody dif-\nferent design decisions regarding efficiency, extensibility, portability,\ntype safety, and other issues, you can sometimes significantly improve\nthe efficiency of your software by switching to libraries whose design-\ners gave more weight to performance considerations than to other fac-\ntors.\nItem 24: Understand the costs of virtual functions, \nmultiple inheritance, virtual base classes, \nand RTTI.\nThe Costs of Various Language Features\nC++ compilers must find a way to implement each feature in the lan-\nguage. Such implementation details are, of course, compiler-depen-\ndent, and different compilers implement language features in different\nways. For the most part, you need not concern yourself with such mat-\nters. However, the implementation of some features can have a notice-\nable impact on the size of objects and the speed at which member\nfunctions execute, so for those features, it’s important to have a basic\nunderstanding of what compilers are likely to be doing under the hood.\nThe foremost example of such a feature is virtual functions.\nWhen a virtual function is called, the code executed must correspond\nto the dynamic type of the object on which the function is invoked; the\ntype of the pointer or reference to the object is immaterial. How can\ncompilers provide this behavior efficiently? Most implementations use\nvirtual tables and virtual table pointers. Virtual tables and virtual table\npointers are commonly referred to as vtbls and vptrs, respectively.\nA vtbl is usually an array of pointers to functions. (Some compilers use\na form of linked list instead of an array, but the fundamental strategy\nis the same.) Each class in a program that declares or inherits virtual\nfunctions has its own vtbl, and the entries in a class’s vtbl are pointers\nto the implementations of the virtual functions for that class. For ex-\nample, given a class definition like this,\n",
      "content_length": 2069,
      "extraction_method": "Direct"
    },
    {
      "page_number": 131,
      "chapter": null,
      "content": "114\nItem 24\nclass C1 {\npublic:\nC1();\nvirtual ~C1();\nvirtual void f1();\nvirtual int f2(char c) const;\nvirtual void f3(const string& s);\nvoid f4() const;\n...\n};\nC1’s virtual table array will look something like this:\nNote that the nonvirtual function f4 is not in the table, nor is C1’s con-\nstructor. Nonvirtual functions — including constructors, which are by\ndefinition nonvirtual — are implemented just like ordinary C func-\ntions, so there are no special performance considerations surrounding\ntheir use.\nIf a class C2 inherits from C1, redefines some of the virtual functions it\ninherits, and adds some new ones of its own,\nclass C2: public C1 {\npublic:\nC2();\n// nonvirtual function\nvirtual ~C2();\n// redefined function\nvirtual void f1();\n// redefined function\nvirtual void f5(char *str);\n// new virtual function\n...\n};\nits virtual table entries point to the functions that are appropriate for\nobjects of its type. These entries include pointers to the C1 virtual\nfunctions that C2 chose not to redefine:\nThis discussion brings out the first cost of virtual functions: you have\nto set aside space for a virtual table for each class that contains virtual\nimplementation of C1::f1\nimplementation of C1::f2\nimplementation of C1::f3\nC1’s\nvtbl\nimplementation of C1::~C1\nimplementation of C2::f1\nimplementation of C1::f2\nimplementation of C1::f3\nC2’s\nvtbl\nimplementation of C2::~C2\nimplementation of C2::f5\n",
      "content_length": 1405,
      "extraction_method": "Direct"
    },
    {
      "page_number": 132,
      "chapter": null,
      "content": "The Costs of Various Language Features\n115\nfunctions. The size of a class’s vtbl is proportional to the number of vir-\ntual functions declared for that class (including those it inherits from\nits base classes). There should be only one virtual table per class, so\nthe total amount of space required for virtual tables is not usually sig-\nnificant, but if you have a large number of classes or a large number of\nvirtual functions in each class, you may find that the vtbls take a sig-\nnificant bite out of your address space. \nBecause you need only one copy of a class’s vtbl in your programs,\ncompilers must address a tricky problem: where to put it. Most pro-\ngrams and libraries are created by linking together many object files,\nbut each object file is generated independently of the others. Which ob-\nject file should contain the vtbl for any given class? You might think to\nput it in the object file containing main, but libraries have no main,\nand at any rate the source file containing main may make no mention\nof many of the classes requiring vtbls. How could compilers then know\nwhich vtbls they were supposed to create?\nA different strategy must be adopted, and compiler vendors tend to fall\ninto two camps. For vendors who provide an integrated environment\ncontaining both compiler and linker, a brute-force strategy is to gener-\nate a copy of the vtbl in each object file that might need it. The linker\nthen strips out duplicate copies, leaving only a single instance of each\nvtbl in the final executable or library.\nA more common design is to employ a heuristic to determine which ob-\nject file should contain the vtbl for a class. Usually this heuristic is as\nfollows: a class’s vtbl is generated in the object file containing the def-\ninition (i.e., the body) of the first non-inline non-pure virtual function\nin that class. Thus, the vtbl for class C1 above would be placed in the\nobject file containing the definition of C1::~C1 (provided that function\nwasn’t inline), and the vtbl for class C2 would be placed in the object\nfile containing the definition of C2::~C2 (again, provided that function\nwasn’t inline).\nIn practice, this heuristic works well, but you can get into trouble if\nyou go overboard on declaring virtual functions inline. If all virtual\nfunctions in a class are declared inline, the heuristic fails, and most\nheuristic-based implementations then generate a copy of the class’s\nvtbl in every object file that uses it. In large systems, this can lead to\nprograms containing hundreds or thousands of copies of a class’s vtbl!\nMost compilers following this heuristic give you some way to control\nvtbl generation manually, but a better solution to this problem is to\navoid declaring virtual functions inline. As we’ll see below, there are\n",
      "content_length": 2771,
      "extraction_method": "Direct"
    },
    {
      "page_number": 133,
      "chapter": null,
      "content": "116\nItem 24\ngood reasons why present compilers typically ignore the inline direc-\ntive for virtual functions, anyway.\nVirtual tables are half the implementation machinery for virtual func-\ntions, but by themselves they are useless. They become useful only\nwhen there is some way of indicating which vtbl corresponds to each\nobject, and it is the job of the virtual table pointer to establish that cor-\nrespondence.\nEach object whose class declares virtual functions carries with it a hid-\nden data member that points to the virtual table for that class. This\nhidden data member — the vptr — is added by compilers at a location\nin the object known only to the compilers. Conceptually, we can think\nof the layout of an object that has virtual functions as looking like this:\nThis picture shows the vptr at the end of the object, but don’t be fooled:\ndifferent compilers put them in different places. In the presence of in-\nheritance, an object’s vptr is often surrounded by data members. Mul-\ntiple inheritance complicates this picture, but we’ll deal with that a bit\nlater. At this point, simply note the second cost of virtual functions:\nyou have to pay for an extra pointer inside each object that is of a class\ncontaining virtual functions.\nIf your objects are small, this can be a significant cost. If your objects\ncontain, on average, four bytes of member data, for example, the addi-\ntion of a vptr can double their size (assuming four bytes are devoted to\nthe vptr). On systems with limited memory, this means the number of\nobjects you can create is reduced. Even on systems with uncon-\nstrained memory, you may find that the performance of your software\ndecreases, because larger objects mean fewer fit on each cache or vir-\ntual memory page, and that means your paging activity will probably\nincrease.\nSuppose we have a program with several objects of types C1 and C2.\nGiven the relationships among objects, vptrs, and vtbls that we have\nData members\nfor\nthe object\nObject’s vptr\n",
      "content_length": 1988,
      "extraction_method": "Direct"
    },
    {
      "page_number": 134,
      "chapter": null,
      "content": "The Costs of Various Language Features\n117\njust seen, we can envision the objects in our program like this:\nNow consider this program fragment:\nvoid makeACall(C1 *pC1)\n{\npC1->f1();\n}\nThis is a call to the virtual function f1 through the pointer pC1. By\nlooking only at this code, there is no way to know which f1 function —\nC1::f1 or C2::f1 — should be invoked, because pC1 might point to a C1\nobject or to a C2 object. Your compilers must nevertheless generate\ncode for the call to f1 inside makeACall, and they must ensure that\nthe correct function is called, no matter what pC1 points to. They do\nthis by generating code to do the following:\n1.\nFollow the object’s vptr to its vtbl. This is a simple operation, be-\ncause the compilers know where to look inside the object for the\nvptr. (After all, they put it there.) As a result, this costs only an\noffset adjustment (to get to the vptr) and a pointer indirection (to\nget to the vtbl).\n2.\nFind the pointer in the vtbl that corresponds to the function be-\ning called (f1 in this example). This, too, is simple, because com-\npilers assign each virtual function a unique index within the\ntable. The cost of this step is just an offset into the vtbl array.\n3.\nInvoke the function pointed to by the pointer located in step 2.\nC2’s\nvtbl\nC1’s\nvtbl\nC1 Object\nvptr\nData\nMembers\nC1 Object\nvptr\nData\nMembers\nC1 Object\nvptr\nData\nMembers\nC2 Object\nvptr\nData\nMembers\nC2 Object\nvptr\nData\nMembers\nC2 Object\nvptr\nData\nMembers\nImplementations\nof C1’s virtual\nfunctions\nImplementations\nof C2’s virtual\nfunctions\n",
      "content_length": 1547,
      "extraction_method": "Direct"
    },
    {
      "page_number": 135,
      "chapter": null,
      "content": "118\nItem 24\nIf we imagine that each object has a hidden member called vptr and\nthat the vtbl index of function f1 is i, the code generated for the state-\nment\npC1->f1();\nis\n(*pC1->vptr[i])(pC1);\n// call the function pointed to by the\n// i-th entry in the vtbl pointed to \n// by pC1->vptr; pC1 is passed to the\n// function as the \"this\" pointer\nThis is almost as efficient as a non-virtual function call: on most ma-\nchines it executes only a few more instructions. The cost of calling a\nvirtual function is thus basically the same as that of calling a function\nthrough a function pointer. Virtual functions per se are not usually a\nperformance bottleneck.\nThe real runtime cost of virtual functions has to do with their interac-\ntion with inlining. For all practical purposes, virtual functions aren’t\ninlined. That’s because “inline” means “during compilation, replace the\ncall site with the body of the called function,” but “virtual” means “wait\nuntil runtime to see which function is called.” If your compilers don’t\nknow which function will be called at a particular call site, you can un-\nderstand why they won’t inline that function call. This is the third cost\nof virtual functions: you effectively give up inlining. (Virtual functions\ncan be inlined when invoked through objects, but most virtual function\ncalls are made through pointers or references to objects, and such calls\nare not inlined. Because such calls are the norm, virtual functions are\neffectively not inlined.)\nEverything we’ve seen so far applies to both single and multiple inher-\nitance, but when multiple inheritance enters the picture, things get\nmore complex. There is no point in dwelling on details, but with multi-\nple inheritance, offset calculations to find vptrs within objects become\nmore complicated; there are multiple vptrs within a single object (one\nper base class); and special vtbls must be generated for base classes in\naddition to the stand-alone vtbls we have discussed. As a result, both\nthe per-class and the per-object space overhead for virtual functions\nincreases, and the runtime invocation cost grows slightly, too.\nMultiple inheritance often leads to the need for virtual base classes.\nWithout virtual base classes, if a derived class has more than one in-\nheritance path to a base class, the data members of that base class are\nreplicated within each derived class object, one copy for each path be-\ntween the derived class and the base class. Such replication is almost\nnever what programmers want, and making base classes virtual elim-\ninates the replication. Virtual base classes may incur a cost of their\n",
      "content_length": 2616,
      "extraction_method": "Direct"
    },
    {
      "page_number": 136,
      "chapter": null,
      "content": "The Costs of Various Language Features\n119\nown, however, because implementations of virtual base classes often\nuse pointers to virtual base class parts as the means for avoiding the\nreplication, and one or more of those pointers may be stored inside\nyour objects. \nFor example, consider this, which I generally call “the dreaded multiple\ninheritance diamond:”\nHere A is a virtual base class because B and C virtually inherit from it.\nWith some compilers (especially older compilers), the layout for an ob-\nject of type D is likely to look like this:\nIt seems a little strange to place the base class data members at the\nend of the object, but that’s often how it’s done. Of course, implemen-\ntations are free to organize memory any way they like, so you should\nnever rely on this picture for anything more than a conceptual over-\nview of how virtual base classes may lead to the addition of hidden\npointers to your objects. Some implementations add fewer pointers,\nand some find ways to add none at all. (Such implementations make\nthe vptr and vtbl serve double duty).\nIf we combine this picture with the earlier one showing how virtual\ntable pointers are added to objects, we realize that if the base class A\nclass A { ... };\nclass B: virtual public A { ... };\nclass C: virtual public A { ... };\nclass D: public B, public C { ... };\nB\nD\nC\nA\nB Data Members\nC Data Members\nD Data Members\nA Data Members\nPointer to virtual base class\nPointer to virtual base class\n",
      "content_length": 1462,
      "extraction_method": "Direct"
    },
    {
      "page_number": 137,
      "chapter": null,
      "content": "120\nItem 24\nin the hierarchy on page 119 has any virtual functions, the memory\nlayout for an object of type D could look like this:\nHere I’ve shaded the parts of the object that are added by compilers.\nThe picture may be misleading, because the ratio of shaded to un-\nshaded areas is determined by the amount of data in your classes. For\nsmall classes, the relative overhead is large. For classes with more\ndata, the relative overhead is less significant, though it is typically no-\nticeable.\nAn oddity in the above diagram is that there are only three vptrs even\nthough four classes are involved. Implementations are free to generate\nfour vptrs if they like, but three suffice (it turns out that B and D can\nshare a vptr), and most implementations take advantage of this oppor-\ntunity to reduce the compiler-generated overhead.\nWe’ve now seen how virtual functions make objects larger and pre-\nclude inlining, and we’ve examined how multiple inheritance and vir-\ntual base classes can also increase the size of objects. Let us therefore\nturn to our final topic, the cost of runtime type identification (RTTI).\nRTTI lets us discover information about objects and classes at run-\ntime, so there has to be a place to store the information we’re allowed\nto query. That information is stored in an object of type type_info,\nand you can access the type_info object for a class by using the\ntypeid operator.\nThere only needs to be a single copy of the RTTI information for each\nclass, but there must be a way to get to that information for any object.\nActually, that’s not quite true. The language specification states that\nwe’re guaranteed accurate information on an object’s dynamic type\nB Data Members\nC Data Members\nD Data Members\nA Data Members\nPointer to virtual base class\nPointer to virtual base class\nvptr\nvptr\nvptr\n",
      "content_length": 1819,
      "extraction_method": "Direct"
    },
    {
      "page_number": 138,
      "chapter": null,
      "content": "The Costs of Various Language Features\n121\nonly if that type has at least one virtual function. This makes RTTI\ndata sound a lot like a virtual function table. We need only one copy of\nthe information per class, and we need a way to get to the appropriate\ninformation from any object containing a virtual function. This parallel\nbetween RTTI and virtual function tables is no accident: RTTI was de-\nsigned to be implementable in terms of a class’s vtbl.\nFor example, index 0 of a vtbl array might contain a pointer to the\ntype_info object for the class corresponding to that vtbl. The vtbl for\nclass C1 on page 114 would then look like this:\nWith this implementation, the space cost of RTTI is an additional entry\nin each class vtbl plus the cost of the storage for the type_info object\nfor each class. Just as the memory for virtual tables is unlikely to be\nnoticeable for most applications, however, you’re unlikely to run into\nproblems due to the size of type_info objects. \nThe following table summarizes the primary costs of virtual functions,\nmultiple inheritance, virtual base classes, and RTTI:\nIncreases\nIncreases\nReduces\nFeature\nSize of Objects\nPer-Class Data\nInlining\nVirtual Functions\nYes\nYes\nYes\nMultiple Inheritance\nYes\nYes\nNo\nVirtual Base Classes\nOften\nSometimes\nNo\nRTTI\nNo\nYes\nNo\nSome people look at this table and are aghast. “I’m sticking with C!”,\nthey declare. Fair enough. But remember that each of these features\noffers functionality you’d otherwise have to code by hand. In most\ncases, your manual approximation would probably be less efficient\nand less robust than the compiler-generated code. Using nested\nswitch statements or cascading if-then-elses to emulate virtual\nfunction calls, for example, yields more code than virtual function calls\ndo, and the code runs more slowly, too. Furthermore, you must man-\nually track object types yourself, which means your objects carry\naround type tags of their own; you thus often fail to gain even the ben-\nefit of smaller objects. \nimplementation of C1::f1\nimplementation of C1::f2\nimplementation of C1::f3\nimplementation of C1::~C1\nC1’s type_info object\nC1’s\nvtbl\n",
      "content_length": 2134,
      "extraction_method": "Direct"
    },
    {
      "page_number": 139,
      "chapter": null,
      "content": "122\nItem 24\nIt is important to understand the costs of virtual functions, multiple\ninheritance, virtual base classes, and RTTI, but it is equally important\nto understand that if you need the functionality these features offer,\nyou will pay for it, one way or another. Sometimes you have legitimate\nreasons for bypassing the compiler-generated services. For example,\nhidden vptrs and pointers to virtual base classes can make it difficult\nto store C++ objects in databases or to move them across process\nboundaries, so you may wish to emulate these features in a way that\nmakes it easier to accomplish these other tasks. From the point of view\nof efficiency, however, you are unlikely to do better than the compiler-\ngenerated implementations by coding these features yourself.\n",
      "content_length": 777,
      "extraction_method": "Direct"
    },
    {
      "page_number": 140,
      "chapter": null,
      "content": "Techniques\nTechniques\nMost of this book is concerned with programming guidelines. Such\nguidelines are important, but no programmer lives by guidelines alone.\nAccording to the old TV show Felix the Cat, “Whenever he gets in a fix,\nhe reaches into his bag of tricks.” Well, if a cartoon character can have\na bag of tricks, so too can C++ programmers. Think of this chapter as\na starter set for your bag of tricks. \nSome problems crop up repeatedly when designing C++ software. How\ncan you make constructors and non-member functions act like virtual\nfunctions? How can you limit the number of instances of a class? How\ncan you prevent objects from being created on the heap? How can you\nguarantee that they will be created there? How can you create objects\nthat automatically perform some actions anytime some other class’s\nmember functions are called? How can you have different objects\nshare data structures while giving clients the illusion that each has its\nown copy? How can you distinguish between read and write usage of\noperator[]? How can you create a virtual function whose behavior\ndepends on the dynamic types of more than one object?\nAll these questions (and more) are answered in this chapter, in which\nI describe proven solutions to problems commonly encountered by C++\nprogrammers. I call such solutions techniques, but they’re also known\nas idioms and, when documented in a stylized fashion, patterns. Re-\ngardless of what you call them, the information that follows will serve\nyou well as you engage in the day-to-day skirmishes of practical soft-\nware development. It should also convince you that no matter what\nyou want to do, there is almost certainly a way to do it in C++.\nItem 25: Virtualizing constructors and non-member \nfunctions.\nVirtualizing Constructors and Non-Member Functions\nOn the face of it, it doesn’t make much sense to talk about “virtual con-\nstructors.” You call a virtual function to achieve type-specific behavior\n",
      "content_length": 1955,
      "extraction_method": "Direct"
    },
    {
      "page_number": 141,
      "chapter": null,
      "content": "124\nItem 25\nwhen you have a pointer or reference to an object but you don’t know\nwhat the real type of the object is. You call a constructor only when you\ndon’t yet have an object but you know exactly what type you’d like to\nhave. How, then, can one talk of virtual constructors?\nIt’s easy. Though virtual constructors may seem nonsensical, they are\nremarkably useful. (If you think nonsensical ideas are never useful,\nhow do you explain the success of modern physics?) For example, sup-\npose you write applications for working with newsletters, where a\nnewsletter consists of components that are either textual or graphical.\nYou might organize things this way:\nclass NLComponent {\n// abstract base class for\npublic:\n// newsletter components\n...\n// contains at least one\n};\n// pure virtual function\nclass TextBlock: public NLComponent {\npublic:\n...\n// contains no pure virtual\n};\n// functions\nclass Graphic: public NLComponent {\npublic:\n...\n// contains no pure virtual\n};\n// functions\nclass NewsLetter {\n// a newsletter object\npublic:\n// consists of a list of\n...\n// NLComponent objects\nprivate:\nlist<NLComponent*> components;\n};\nThe classes relate in this way: \nThe list class used inside NewsLetter is part of the Standard Tem-\nplate Library, which is part of the standard C++ library (see Item 35).\nNLComponent\nTextBlock\nGraphic\nNewsLetter\nobject\nlist\nobject\npublic\ninheritance\npointers\n",
      "content_length": 1390,
      "extraction_method": "Direct"
    },
    {
      "page_number": 142,
      "chapter": null,
      "content": "Virtualizing Constructors and Non-Member Functions\n125\nObjects of type list behave like doubly linked lists, though they need\nnot be implemented in that way.\nNewsLetter objects, when not being worked on, would likely be stored\non disk. To support the creation of a Newsletter from its on-disk rep-\nresentation, it would be convenient to give NewsLetter a constructor\nthat takes an istream. The constructor would read information from\nthe stream as it created the necessary in-core data structures:\nclass NewsLetter {\npublic:\nNewsLetter(istream& str);\n...\n};\nPseudocode for this constructor might look like this,\nNewsLetter::NewsLetter(istream& str)\n{\nwhile (str) {\nread the next component object from str;\nadd the object to the list of this\nnewsletter’s components;\n}\n}\nor, after moving the tricky stuff into a separate function called read-\nComponent, like this:\nclass NewsLetter {\npublic:\n...\nprivate:\n// read the data for the next NLComponent from str,\n// create the component and return a pointer to it\nstatic NLComponent * readComponent(istream& str);\n...\n};\nNewsLetter::NewsLetter(istream& str)\n{\nwhile (str) {\n// add the pointer returned by readComponent to the\n// end of the components list; \"push_back\" is a list\n// member function that inserts at the end of the list\ncomponents.push_back(readComponent(str));\n}\n}\nConsider what readComponent does. It creates a new object, either a\nTextBlock or a Graphic, depending on the data it reads. Because it\n",
      "content_length": 1458,
      "extraction_method": "Direct"
    },
    {
      "page_number": 143,
      "chapter": null,
      "content": "126\nItem 25\ncreates new objects, it acts much like a constructor, but because it can\ncreate different types of objects, we call it a virtual constructor. A virtual\nconstructor is a function that creates different types of objects depend-\ning on the input it is given. Virtual constructors are useful in many\ncontexts, only one of which is reading object information from disk (or\noff a network connection or from a tape, etc.).\nA particular kind of virtual constructor — the virtual copy constructor\n— is also widely useful. A virtual copy constructor returns a pointer to\na new copy of the object invoking the function. Because of this behav-\nior, virtual copy constructors are typically given names like copySelf,\ncloneSelf, or, as shown below, just plain clone. Few functions are\nimplemented in a more straightforward manner:\nclass NLComponent {\npublic:\n// declaration of virtual copy constructor\nvirtual NLComponent * clone() const = 0;\n...\n};\nclass TextBlock: public NLComponent {\npublic:\nvirtual TextBlock * clone() const\n// virtual copy\n{ return new TextBlock(*this); }\n// constructor\n...\n};\nclass Graphic: public NLComponent {\npublic:\nvirtual Graphic * clone() const\n// virtual copy\n{ return new Graphic(*this); }\n// constructor\n...\n};\nAs you can see, a class’s virtual copy constructor just calls its real copy\nconstructor. The meaning of “copy” is hence the same for both func-\ntions. If the real copy constructor performs a shallow copy, so does the\nvirtual copy constructor. If the real copy constructor performs a deep\ncopy, so does the virtual copy constructor. If the real copy constructor\ndoes something fancy like reference counting or copy-on-write (see\nItem 29), so does the virtual copy constructor. Consistency — what a\nwonderful thing.\nNotice that the above implementation takes advantage of a relaxation\nin the rules for virtual function return types that was adopted rela-\ntively recently. No longer must a derived class’s redefinition of a base\nclass’s virtual function declare the same return type. Instead, if the\n",
      "content_length": 2041,
      "extraction_method": "Direct"
    },
    {
      "page_number": 144,
      "chapter": null,
      "content": "Virtualizing Constructors and Non-Member Functions\n127\nfunction’s return type is a pointer (or a reference) to a base class, the\nderived class’s function may return a pointer (or reference) to a class\nderived from that base class. This opens no holes in C++’s type system,\nand it makes it possible to accurately declare functions such as virtual\ncopy constructors. That’s why TextBlock’s clone can return a Text-\nBlock* and Graphic’s clone can return a Graphic*, even though the\nreturn type of NLComponent’s clone is NLComponent*.\nThe existence of a virtual copy constructor in NLComponent makes it\neasy to implement a (normal) copy constructor for NewsLetter:\nclass NewsLetter {\npublic:\nNewsLetter(const NewsLetter& rhs);\n...\nprivate:\nlist<NLComponent*> components;\n};\nNewsLetter::NewsLetter(const NewsLetter& rhs)\n{\n// iterate over rhs’s list, using each element’s\n// virtual copy constructor to copy the element into\n// the components list for this object. For details on\n// how the following code works, see Item 35.\nfor (list<NLComponent*>::const_iterator it =\nrhs.components.begin();\nit != rhs.components.end();\n++it) {\n// \"it\" points to the current element of rhs.components,\n// so call that element’s clone function to get a copy\n// of the element, and add that copy to the end of\n// this object’s list of components\ncomponents.push_back((*it)->clone());\n}\n}\nUnless you are familiar with the Standard Template Library, this code\nlooks bizarre, I know, but the idea is simple: just iterate over the list of\ncomponents for the NewsLetter object being copied, and for each\ncomponent in the list, call its virtual copy constructor. We need a vir-\ntual copy constructor here, because the list contains pointers to\nNLComponent objects, but we know each pointer really points to a\nTextBlock or a Graphic. We want to copy whatever the pointer really\npoints to, and the virtual copy constructor does that for us.\n",
      "content_length": 1912,
      "extraction_method": "Direct"
    },
    {
      "page_number": 145,
      "chapter": null,
      "content": "128\nItem 25\nMaking Non-Member Functions Act Virtual\nJust as constructors can’t really be virtual, neither can non-member\nfunctions. However, just as it makes sense to conceive of functions\nthat construct new objects of different types, it makes sense to con-\nceive of non-member functions whose behavior depends on the dy-\nnamic types of their parameters. For example, suppose you’d like to\nimplement output operators for the TextBlock and Graphic classes.\nThe obvious approach to this problem is to make the output operator\nvirtual. However, the output operator is operator<<, and that func-\ntion takes an ostream& as its left-hand argument; that effectively rules\nout the possibility of making it a member function of the TextBlock or\nGraphic classes.\n(It can be done, but then look what happens:\nclass NLComponent {\npublic:\n// unconventional declaration of output operator\nvirtual ostream& operator<<(ostream& str) const = 0;\n...\n};\nclass TextBlock: public NLComponent {\npublic:\n// virtual output operator (also unconventional)\nvirtual ostream& operator<<(ostream& str) const;\n};\nclass Graphic: public NLComponent {\npublic:\n// virtual output operator (still unconventional)\nvirtual ostream& operator<<(ostream& str) const;\n};\nTextBlock t;\nGraphic g;\n...\nt << cout;\n// print t on cout via \n// virtual operator<<; note\n// unconventional syntax\ng << cout;\n// print g on cout via\n// virtual operator<<; note\n// unconventional syntax\nClients must place the stream object on the right-hand side of the “<<”\nsymbol, and that’s contrary to the convention for output operators. To\nget back to the normal syntax, we must move operator<< out of the\nTextBlock and Graphic classes, but if we do that, we can no longer\ndeclare it virtual.) \n",
      "content_length": 1730,
      "extraction_method": "Direct"
    },
    {
      "page_number": 146,
      "chapter": null,
      "content": "Virtualizing Constructors and Non-Member Functions\n129\nAn alternate approach is to declare a virtual function for printing (e.g.,\nprint) and define it for the TextBlock and Graphic classes. But if we\ndo that, the syntax for printing TextBlock and Graphic objects is in-\nconsistent with that for the other types in the language, all of which\nrely on operator<< as their output operator.\nNeither of these solutions is very satisfying. What we want is a non-\nmember function called operator<< that exhibits the behavior of a\nvirtual function like print. This description of what we want is in fact\nvery close to a description of how to get it. We define both operator<<\nand print and have the former call the latter!\nclass NLComponent {\npublic:\nvirtual ostream& print(ostream& s) const = 0;\n...\n};\nclass TextBlock: public NLComponent {\npublic:\nvirtual ostream& print(ostream& s) const;\n...\n};\nclass Graphic: public NLComponent {\npublic:\nvirtual ostream& print(ostream& s) const;\n...\n};\ninline\nostream& operator<<(ostream& s, const NLComponent& c)\n{\nreturn c.print(s);\n}\nVirtual-acting non-member functions, then, are easy. You write virtual\nfunctions to do the work, then write a non-virtual function that does\nnothing but call the virtual function. To avoid incurring the cost of a\nfunction call for this syntactic sleight-of-hand, of course, you inline the\nnon-virtual function.\nNow that you know how to make non-member functions act virtually\non one of their arguments, you may wonder if it’s possible to make\nthem act virtually on more than one of their arguments. It is, but it’s\nnot easy. How hard is it? Turn to Item 31; it’s devoted to that question.\n",
      "content_length": 1656,
      "extraction_method": "Direct"
    },
    {
      "page_number": 147,
      "chapter": null,
      "content": "130\nItem 26\nItem 26: Limiting the number of objects of a class.\nLimiting Object Instantiations\nOkay, you’re crazy about objects, but sometimes you’d like to bound\nyour insanity. For example, you’ve got only one printer in your system,\nso you’d like to somehow limit the number of printer objects to one. Or\nyou’ve got only 16 file descriptors you can hand out, so you’ve got to\nmake sure there are never more than that many file descriptor objects\nin existence. How can you do such things? How can you limit the num-\nber of objects?\nIf this were a proof by mathematical induction, we might start with\nn = 1, then build from there. Fortunately, this is neither a proof nor an\ninduction. Moreover, it turns out to be instructive to begin with n = 0,\nso we’ll start there instead. How do you prevent objects from being in-\nstantiated at all?\nAllowing Zero or One Objects\nEach time an object is instantiated, we know one thing for sure: a con-\nstructor will be called. That being the case, the easiest way to prevent\nobjects of a particular class from being created is to declare the con-\nstructors of that class private:\nclass CantBeInstantiated {\nprivate:\nCantBeInstantiated();\nCantBeInstantiated(const CantBeInstantiated&);\n...\n};\nHaving thus removed everybody’s right to create objects, we can selec-\ntively loosen the restriction. If, for example, we want to create a class\nfor printers, but we also want to abide by the constraint that there is\nonly one printer available to us, we can encapsulate the printer object\ninside a function so that everybody has access to the printer, but only\na single printer object is created:\nclass PrintJob;\n// forward declaration\nclass Printer {\npublic:\nvoid submitJob(const PrintJob& job);\nvoid reset();\nvoid performSelfTest();\n...\nfriend Printer& thePrinter();\n",
      "content_length": 1799,
      "extraction_method": "Direct"
    },
    {
      "page_number": 148,
      "chapter": null,
      "content": "Limiting Object Instantiations\n131\nprivate:\nPrinter();\nPrinter(const Printer& rhs);\n...\n};\nPrinter& thePrinter()\n{\nstatic Printer p;\n// the single printer object\nreturn p;\n}\nThere are three separate components to this design. First, the con-\nstructors of the Printer class are private. That suppresses object cre-\nation. Second, the global function thePrinter is declared a friend of\nthe class. That lets thePrinter escape the restriction imposed by the\nprivate constructors. Finally, thePrinter contains a static Printer\nobject. That means only a single object will be created.\nClient code refers to thePrinter whenever it wishes to interact with\nthe system’s lone printer. By returning a reference to a Printer object,\nthePrinter can be used in any context where a Printer object itself\ncould be:\nclass PrintJob {\npublic:\nPrintJob(const string& whatToPrint);\n...\n};\nstring buffer;\n...\n// put stuff in buffer\nthePrinter().reset();\nthePrinter().submitJob(buffer);\nIt’s possible, of course, that thePrinter strikes you as a needless ad-\ndition to the global namespace. “Yes,” you may say, “as a global func-\ntion it looks more like a global variable, but global variables are\ngauche, and I’d prefer to localize all printer-related functionality inside\nthe Printer class.” Well, far be it from me to argue with someone who\nuses words like gauche. thePrinter can just as easily be made a\nstatic member function of Printer, and that puts it right where you\nwant it. It also eliminates the need for a friend declaration, which\nmany regard as tacky in its own right. Using a static member function,\nPrinter looks like this:\n",
      "content_length": 1618,
      "extraction_method": "Direct"
    },
    {
      "page_number": 149,
      "chapter": null,
      "content": "132\nItem 26\nclass Printer {\npublic:\nstatic Printer& thePrinter();\n...\nprivate:\nPrinter();\nPrinter(const Printer& rhs);\n...\n};\nPrinter& Printer::thePrinter()\n{\nstatic Printer p;\nreturn p;\n}\nClients must now be a bit wordier when they refer to the printer:\nPrinter::thePrinter().reset();\nPrinter::thePrinter().submitJob(buffer);\nAnother approach is to move Printer and thePrinter out of the glo-\nbal scope and into a namespace. Namespaces are a recent addition to\nC++. Anything that can be declared at global scope can also be de-\nclared in a namespace. This includes classes, structs, functions, vari-\nables, objects, typedefs, etc. The fact that something is in a namespace\ndoesn’t affect its behavior, but it does prevent name conflicts between\nentities in different namespaces. By putting the Printer class and the\nthePrinter function into a namespace, we don’t have to worry about\nwhether anybody else happened to choose the names Printer or\nthePrinter for themselves; our namespace prevents name conflicts.\nSyntactically, namespaces look much like classes, but there are no\npublic, protected, or private sections; everything is public. This is how\nwe’d put Printer and thePrinter into a namespace called Print-\ningStuff:\nnamespace PrintingStuff {\nclass Printer {\n// this class is in the\npublic:\n// PrintingStuff namespace\nvoid submitJob(const PrintJob& job);\nvoid reset();\nvoid performSelfTest();\n...\nfriend Printer& thePrinter();\n",
      "content_length": 1435,
      "extraction_method": "Direct"
    },
    {
      "page_number": 150,
      "chapter": null,
      "content": "Limiting Object Instantiations\n133\nprivate:\nPrinter();\nPrinter(const Printer& rhs);\n...\n};\nPrinter& thePrinter()\n// so is this function \n{\nstatic Printer p;\nreturn p;\n}\n} \n// this is the end of the\n// namespace\nGiven this namespace, clients can refer to thePrinter using a fully-\nqualified name (i.e., one that includes the name of the namespace),\nPrintingStuff::thePrinter().reset();\nPrintingStuff::thePrinter().submitJob(buffer);\nbut they can also employ a using declaration to save themselves key-\nstrokes:\nusing PrintingStuff::thePrinter; // import the name\n// \"thePrinter\" from the\n// namespace \"PrintingStuff\"\n// into the current scope\nthePrinter().reset();\n// now thePrinter can be\nthePrinter().submitJob(buffer);\n// used as if it were a\n// local name\nThere are two subtleties in the implementation of thePrinter that are\nworth exploring. First, it’s important that the single Printer object be\nstatic in a function and not in a class. An object that’s static in a class\nis, for all intents and purposes, always constructed (and destructed),\neven if it’s never used. In contrast, an object that’s static in a function\nis created the first time through the function, so if the function is never\ncalled, the object is never created. (You do, however, pay for a check\neach time the function is called to see whether the object needs to be\ncreated.) One of the philosophical pillars on which C++ was built is the\nidea that you shouldn’t pay for things you don’t use, and defining an\nobject like our printer as a static object in a function is one way of ad-\nhering to this philosophy. It’s a philosophy you should adhere to when-\never you can.\nThere is another drawback to making the printer a class static versus\na function static, and that has to do with its time of initialization. We\nknow exactly when a function static is initialized: the first time\nthrough the function at the point where the static is defined. The situ-\n",
      "content_length": 1931,
      "extraction_method": "Direct"
    },
    {
      "page_number": 151,
      "chapter": null,
      "content": "134\nItem 26\nation with a class static (or, for that matter, a global static, should you\nbe so gauche as to use one) is less well defined. C++ offers certain\nguarantees regarding the order of initialization of statics within a par-\nticular translation unit (i.e., a body of source code that yields a single\nobject file), but it says nothing about the initialization order of static\nobjects in different translation units. In practice, this turns out to be a\nsource of countless headaches. Function statics, when they can be\nmade to suffice, allow us to avoid these headaches. In our example\nhere, they can, so why suffer?\nThe second subtlety has to do with the interaction of inlining and static\nobjects inside functions. Look again at the code for the non-member\nversion of thePrinter:\nPrinter& thePrinter()\n{\nstatic Printer p;\nreturn p;\n}\nExcept for the first time through this function (when p must be con-\nstructed), this is a one-line function — it consists entirely of the state-\nment “return p;”. If ever there were a good candidate for inlining, this\nfunction would certainly seem to be the one. Yet it’s not declared in-\nline. Why not?\nConsider for a moment why you’d declare an object to be static. It’s\nusually because you want only a single copy of that object, right? Now\nconsider what inline means. Conceptually, it means compilers\nshould replace each call to the function with a copy of the function\nbody, but for non-member functions, it also means something else. It\nmeans the functions in question have internal linkage.\nYou don’t ordinarily need to worry about such linguistic mumbo\njumbo, but there is one thing you must remember: functions with in-\nternal linkage may be duplicated within a program (i.e., the object code\nfor the program may contain more than one copy of each function with\ninternal linkage), and this duplication includes static objects contained\nwithin the functions. The result? If you create an inline non-member\nfunction containing a local static object, you may end up with more\nthan one copy of the static object in your program! So don’t create in-\nline non-member functions that contain local static data.†\nBut maybe you think this business of creating a function to return a\nreference to a hidden object is the wrong way to go about limiting the\nnumber of objects in the first place. Perhaps you think it’s better to\nsimply count the number of objects in existence and throw an excep-\n† In July 1996, the ISO/ANSI standardization committee changed the default linkage of\ninline functions to external, so the problem I describe here has been eliminated, at\nleast on paper. Your compilers may not yet be in accord with the standard, however,\nso your best bet is still to shy away from inline functions with static data.\n",
      "content_length": 2765,
      "extraction_method": "Direct"
    },
    {
      "page_number": 152,
      "chapter": null,
      "content": "Limiting Object Instantiations\n135\ntion in a constructor if too many objects are requested. In other words,\nmaybe you think we should handle printer creation like this:\nclass Printer {\npublic:\nclass TooManyObjects{};\n// exception class for use\n// when too many objects\n// are requested\nPrinter();\n~Printer();\n...\nprivate:\nstatic size_t numObjects;\nPrinter(const Printer& rhs); // there is a limit of 1\n// printer, so never allow\n};\n// copying\nThe idea is to use numObjects to keep track of how many Printer ob-\njects are in existence. This value will be incremented in the class con-\nstructor and decremented in its destructor. If an attempt is made to\nconstruct too many Printer objects, we throw an exception of type\nTooManyObjects:\n// Obligatory definition of the class static\nsize_t Printer::numObjects = 0;\nPrinter::Printer()\n{\nif (numObjects >= 1) {\nthrow TooManyObjects();\n}\nproceed with normal construction here;\n++numObjects;\n}\nPrinter::~Printer()\n{\nperform normal destruction here;\n--numObjects;\n}\nThis approach to limiting object creation is attractive for a couple of\nreasons. For one thing, it’s straightforward — everybody should be\nable to understand what’s going on. For another, it’s easy to generalize\nso that the maximum number of objects is some number other than\none.\n",
      "content_length": 1289,
      "extraction_method": "Direct"
    },
    {
      "page_number": 153,
      "chapter": null,
      "content": "136\nItem 26\nContexts for Object Construction\nThere is also a problem with this strategy. Suppose we have a special\nkind of printer, say, a color printer. The class for such printers would\nhave much in common with our generic printer class, so of course we’d\ninherit from it:\nclass ColorPrinter: public Printer {\n...\n};\nNow suppose we have one generic printer and one color printer in our\nsystem:\nPrinter p;\nColorPrinter cp;\nHow many Printer objects result from these object definitions? The\nanswer is two: one for p and one for the Printer part of cp. At run-\ntime, a TooManyObjects exception will be thrown during the con-\nstruction of the base class part of cp. For many programmers, this is\nneither what they want nor what they expect. (Designs that avoid hav-\ning concrete classes inherit from other concrete classes do not suffer\nfrom this problem. For details on this design philosophy, see Item 33.)\nA similar problem occurs when Printer objects are contained inside\nother objects:\nclass CPFMachine {\n// for machines that can\nprivate:\n// copy, print, and fax\nPrinter p;\n// for printing capabilities\nFaxMachine f;\n// for faxing capabilities\nCopyMachine c;\n// for copying capabilities\n...\n};\nCPFMachine m1;\n// fine\nCPFMachine m2;\n// throws TooManyObjects exception\nThe problem is that Printer objects can exist in three different con-\ntexts: on their own, as base class parts of more derived objects, and\nembedded inside larger objects. The presence of these different con-\ntexts significantly muddies the waters regarding what it means to keep\ntrack of the “number of objects in existence,” because what you con-\nsider to be the existence of an object may not jibe with your compilers’.\nOften you will be interested only in allowing objects to exist on their\nown, and you will wish to limit the number of those kinds of instantia-\ntions. That restriction is easy to satisfy if you adopt the strategy exem-\n",
      "content_length": 1912,
      "extraction_method": "Direct"
    },
    {
      "page_number": 154,
      "chapter": null,
      "content": "Limiting Object Instantiations\n137\nplified by our original Printer class, because the Printer\nconstructors are private, and (in the absence of friend declarations)\nclasses with private constructors can’t be used as base classes, nor\ncan they be embedded inside other objects. \nThe fact that you can’t derive from classes with private constructors\nleads to a general scheme for preventing derivation, one that doesn’t\nnecessarily have to be coupled with limiting object instantiations. Sup-\npose, for example, you have a class, FSA, for representing finite state\nautomata. (Such state machines are useful in many contexts, among\nthem user interface design.) Further suppose you’d like to allow any\nnumber of FSA objects to be created, but you’d also like to ensure that\nno class ever inherits from FSA. (One reason for doing this might be to\njustify the presence of a nonvirtual destructor in FSA. As Item 24 ex-\nplains, classes without virtual functions yield smaller objects than do\nequivalent classes with virtual functions.) Here’s how you can design\nFSA to satisfy both criteria:\nclass FSA {\npublic:\n// pseudo-constructors\nstatic FSA * makeFSA();\nstatic FSA * makeFSA(const FSA& rhs);\n...\nprivate:\nFSA();\nFSA(const FSA& rhs);\n...\n};\nFSA * FSA::makeFSA()\n{ return new FSA(); }\nFSA * FSA::makeFSA(const FSA& rhs)\n{ return new FSA(rhs); }\nUnlike the thePrinter function that always returned a reference to a\nsingle object, each makeFSA pseudo-constructor returns a pointer to a\nunique object. That’s what allows an unlimited number of FSA objects\nto be created.\nThis is nice, but the fact that each pseudo-constructor calls new im-\nplies that callers will have to remember to call delete. Otherwise a re-\nsource leak will be introduced. Callers who wish to have delete called\nautomatically when the current scope is exited can store the pointer\nreturned from makeFSA in an auto_ptr object (see Item 9); such ob-\njects automatically delete what they point to when they themselves go\nout of scope:\n",
      "content_length": 1997,
      "extraction_method": "Direct"
    },
    {
      "page_number": 155,
      "chapter": null,
      "content": "138\nItem 26\n// indirectly call default FSA constructor\nauto_ptr<FSA> pfsa1(FSA::makeFSA());\n// indirectly call FSA copy constructor\nauto_ptr<FSA> pfsa2(FSA::makeFSA(*pfsa1));\n...\n// use pfsa1 and pfsa2 as normal pointers,\n// but don’t worry about deleting them\nAllowing Objects to Come and Go\nWe now know how to design a class that allows only a single instanti-\nation, we know that keeping track of the number of objects of a partic-\nular class is complicated by the fact that object constructors are called\nin three different contexts, and we know that we can eliminate the con-\nfusion surrounding object counts by making constructors private. It is\nworthwhile to make one final observation. Our use of the thePrinter\nfunction to encapsulate access to a single object limits the number of\nPrinter objects to one, but it also limits us to a single Printer object\nfor each run of the program. As a result, it’s not possible to write code\nlike this:\ncreate Printer object p1;\nuse p1;\ndestroy p1;\ncreate Printer object p2;\nuse p2;\ndestroy p2;\n...\nThis design never instantiates more than a single Printer object at a\ntime, but it does use different Printer objects in different parts of the\nprogram. It somehow seems unreasonable that this isn’t allowed. After\nall, at no point do we violate the constraint that only one printer may\nexist. Isn’t there a way to make this legal?\nThere is. All we have to do is combine the object-counting code we used\nearlier with the pseudo-constructors we just saw:\nclass Printer {\npublic:\nclass TooManyObjects{};\n// pseudo-constructor\nstatic Printer * makePrinter();\n~Printer();\n",
      "content_length": 1612,
      "extraction_method": "Direct"
    },
    {
      "page_number": 156,
      "chapter": null,
      "content": "Limiting Object Instantiations\n139\nvoid submitJob(const PrintJob& job);\nvoid reset();\nvoid performSelfTest();\n...\nprivate:\nstatic size_t numObjects;\nPrinter();\nPrinter(const Printer& rhs); // we don’t define this\n};\n// function, because we’ll\n// never allow copying\n// Obligatory definition of class static\nsize_t Printer::numObjects = 0;\nPrinter::Printer()\n{\nif (numObjects >= 1) {\nthrow TooManyObjects();\n}\nproceed with normal object construction here;\n++numObjects;\n}\nPrinter * Printer::makePrinter()\n{ return new Printer; }\nIf the notion of throwing an exception when too many objects are re-\nquested strikes you as unreasonably harsh, you could have the\npseudo-constructor return a null pointer instead. Clients would then\nhave to check for this before doing anything with it, of course.\nClients use this Printer class just as they would any other class, ex-\ncept they must call the pseudo-constructor function instead of the real\nconstructor:\nPrinter p1;\n// error! default ctor is\n// private\nPrinter *p2 =\nPrinter::makePrinter();\n// fine, indirectly calls\n// default ctor\nPrinter p3 = *p2;\n// error! copy ctor is \n// private\np2->performSelfTest();\n// all other functions are\np2->reset();\n// called as usual\n...\ndelete p2;\n// avoid resource leak; this\n// would be unnecessary if\n// p2 were an auto_ptr\n",
      "content_length": 1307,
      "extraction_method": "Direct"
    },
    {
      "page_number": 157,
      "chapter": null,
      "content": "140\nItem 26\nThis technique is easily generalized to any number of objects. All we\nhave to do is replace the hard-wired constant 1 with a class-specific\nvalue, then lift the restriction against copying objects. For example, the\nfollowing revised implementation of our Printer class allows up to 10\nPrinter objects to exist:\nclass Printer {\npublic:\nclass TooManyObjects{};\n// pseudo-constructors \nstatic Printer * makePrinter();\nstatic Printer * makePrinter(const Printer& rhs);\n...\nprivate:\nstatic size_t numObjects;\nstatic const size_t maxObjects = 10;\n// see below\nPrinter();\nPrinter(const Printer& rhs);\n};\n// Obligatory definitions of class statics\nsize_t Printer::numObjects = 0;\nconst size_t Printer::maxObjects;\nPrinter::Printer()\n{\nif (numObjects >= maxObjects) {\nthrow TooManyObjects();\n}\n...\n}\nPrinter::Printer(const Printer& rhs)\n{\nif (numObjects >= maxObjects) {\nthrow TooManyObjects();\n}\n...\n}\nPrinter * Printer::makePrinter()\n{ return new Printer; }\nPrinter * Printer::makePrinter(const Printer& rhs)\n{ return new Printer(rhs); }\nDon’t be surprised if your compilers get all upset about the declaration\nof Printer::maxObjects in the class definition above. In particular, be\n",
      "content_length": 1188,
      "extraction_method": "Direct"
    },
    {
      "page_number": 158,
      "chapter": null,
      "content": "Limiting Object Instantiations\n141\nprepared for them to complain about the specification of 10 as an ini-\ntial value for that variable. The ability to specify initial values for static\nconst members (of integral type, e.g., ints, chars, enums, etc.) inside\na class definition was added to C++ only relatively recently, so some\ncompilers don’t yet allow it. If your compilers are as-yet-unupdated,\npacify them by declaring maxObjects to be an enumerator inside a pri-\nvate anonymous enum,\nclass Printer {\nprivate:\nenum { maxObjects = 10 };\n// within this class,\n...\n// maxObjects is the\n};\n// constant 10\nor by initializing the constant static like a non-const static member:\nclass Printer {\nprivate:\nstatic const size_t maxObjects;\n// no initial value given\n...\n};\n// this goes in a single implementation file\nconst size_t Printer::maxObjects = 10;\nThis latter approach has the same effect as the original code above, but\nexplicitly specifying the initial value is easier for other programmers to\nunderstand. When your compilers support the specification of initial\nvalues for const static members in class definitions, you should take\nadvantage of that capability.\nAn Object-Counting Base Class\nInitialization of statics aside, the approach above works like the pro-\nverbial charm, but there is one aspect of it that continues to nag. If we\nhad a lot of classes like Printer whose instantiations needed to be\nlimited, we’d have to write this same code over and over, once per\nclass. That would be mind-numbingly dull. Given a fancy-pants lan-\nguage like C++, it somehow seems we should be able to automate the\nprocess. Isn’t there a way to encapsulate the notion of counting in-\nstances and bundle it into a class?\nWe can easily come up with a base class for counting object instances\nand have classes like Printer inherit from that, but it turns out we\ncan do even better. We can actually come up with a way to encapsulate\nthe whole counting kit and kaboodle, by which I mean not only the\nfunctions to manipulate the instance count, but also the instance\ncount itself. (We’ll see the need for a similar trick when we examine ref-\nerence counting in Item 29.) \n",
      "content_length": 2162,
      "extraction_method": "Direct"
    },
    {
      "page_number": 159,
      "chapter": null,
      "content": "142\nItem 26\nThe counter in the Printer class is the static variable numObjects, so\nwe need to move that variable into an instance-counting class. How-\never, we also need to make sure that each class for which we’re count-\ning instances has a separate counter. Use of a counting class template\nlets us automatically generate the appropriate number of counters, be-\ncause we can make the counter a static member of the classes gener-\nated from the template:\ntemplate<class BeingCounted>\nclass Counted {\npublic:\nclass TooManyObjects{};\n// for throwing exceptions\nstatic size_t objectCount() { return numObjects; }\nprotected:\nCounted();\nCounted(const Counted& rhs);\n~Counted() { --numObjects; }\nprivate:\nstatic size_t numObjects;\nstatic const size_t maxObjects;\nvoid init();\n// to avoid ctor code\n};\n// duplication\ntemplate<class BeingCounted>\nCounted<BeingCounted>::Counted()\n{ init(); }\ntemplate<class BeingCounted>\nCounted<BeingCounted>::Counted(const Counted<BeingCounted>&)\n{ init(); }\ntemplate<class BeingCounted>\nvoid Counted<BeingCounted>::init()\n{\nif (numObjects >= maxObjects) throw TooManyObjects();\n++numObjects;\n}\nThe classes generated from this template are designed to be used only\nas base classes, hence the protected constructors and destructor. Note\nthe use of the private member function init to avoid duplicating the\nstatements in the two Counted constructors.\nWe can now modify the Printer class to use the Counted template:\n",
      "content_length": 1442,
      "extraction_method": "Direct"
    },
    {
      "page_number": 160,
      "chapter": null,
      "content": "Limiting Object Instantiations\n143\nclass Printer: private Counted<Printer> {\npublic:\n// pseudo-constructors\nstatic Printer * makePrinter();\nstatic Printer * makePrinter(const Printer& rhs);\n~Printer();\nvoid submitJob(const PrintJob& job);\nvoid reset();\nvoid performSelfTest();\n...\nusing Counted<Printer>::objectCount;\n// see below\nusing Counted<Printer>::TooManyObjects;\n// see below\nprivate:\nPrinter();\nPrinter(const Printer& rhs);\n};\nThe fact that Printer uses the Counted template to keep track of how\nmany Printer objects exist is, frankly, nobody’s business but the au-\nthor of Printer’s. Such implementation details are best kept private,\nand that’s why private inheritance is used here. The alternative would\nbe to use public inheritance between Printer and\nCounted<Printer>, but then we’d be obliged to give the Counted\nclasses a virtual destructor. (Otherwise we’d risk incorrect behavior if\nsomebody deleted a Printer object through a Counted<Printer>*\npointer.) As Item 24 makes clear, the presence of a virtual function in\nCounted would almost certainly affect the size and layout of objects of\nclasses inheriting from Counted. We don’t want to absorb that over-\nhead, and the use of private inheritance lets us avoid it.\nQuite properly, most of what Counted does is hidden from Printer’s\nclients, but those clients might reasonably want to find out how many\nPrinter objects exist. The Counted template offers the objectCount\nfunction to provide this information, but that function becomes private\nin Printer due to our use of private inheritance. To restore the public\naccessibility of that function, we employ a using declaration:\nclass Printer: private Counted<Printer> {\npublic:\n...\nusing Counted<Printer>::objectCount;\n// make this function\n// public for clients\n...\n// of Printer\n};\n",
      "content_length": 1801,
      "extraction_method": "Direct"
    },
    {
      "page_number": 161,
      "chapter": null,
      "content": "144\nItem 26\nThis is perfectly legitimate, but if your compilers don’t yet support\nnamespaces, they won’t allow it. If they don’t, you can use the older ac-\ncess declaration syntax:\nclass Printer: private Counted<Printer> {\npublic:\n...\nCounted<Printer>::objectCount;\n// make objectCount\n// public in Printer\n...\n};\nThis more traditional syntax has the same meaning as the using dec-\nlaration, but it’s deprecated. The class TooManyObjects is handled in\nthe same fashion as objectCount, because clients of Printer must\nhave access to TooManyObjects if they are to be able to catch excep-\ntions of that type.\nWhen Printer inherits from Counted<Printer>, it can forget about\ncounting objects. The class can be written as if somebody else were\ndoing the counting for it, because somebody else (Counted<Printer>)\nis. A Printer constructor now looks like this:\nPrinter::Printer()\n{\nproceed with normal object construction;\n}\nWhat’s interesting here is not what you see, it’s what you don’t. No\nchecking of the number of objects to see if the limit is about to be ex-\nceeded, no incrementing the number of objects in existence once the\nconstructor is done. All that is now handled by the Counted<Printer>\nconstructors, and because Counted<Printer> is a base class of\nPrinter, we know that a Counted<Printer> constructor will always\nbe called before a Printer constructor. If too many objects are cre-\nated, a Counted<Printer> constructor throws an exception, and the\nPrinter constructor won’t even be invoked. Nifty, huh?\nNifty or not, there’s one loose end that demands to be tied, and that’s\nthe mandatory definitions of the statics inside Counted. It’s easy\nenough to take care of numObjects — we just put this in Counted’s\nimplementation file:\ntemplate<class BeingCounted>\n// defines numObjects\nsize_t Counted<BeingCounted>::numObjects;\n// and automatically\n// initializes it to 0\nThe situation with maxObjects is a bit trickier. To what value should\nwe initialize this variable? If we want to allow up to 10 printers, we\nshould initialize Counted<Printer>::maxObjects to 10. If, on the\n",
      "content_length": 2083,
      "extraction_method": "Direct"
    },
    {
      "page_number": 162,
      "chapter": null,
      "content": "Requiring or Prohibiting Heap-Based Objects\n145\nother hand, we want to allow up to 16 file descriptor objects, we should\ninitialize Counted<FileDescriptor>::maxObjects to 16. What to do?\nWe take the easy way out: we do nothing. We provide no initialization\nat all for maxObjects. Instead, we require that clients of the class pro-\nvide the appropriate initialization. The author of Printer must add\nthis to an implementation file:\nconst size_t Counted<Printer>::maxObjects = 10;\nSimilarly, the author of FileDescriptor must add this:\nconst size_t Counted<FileDescriptor>::maxObjects = 16;\nWhat will happen if these authors forget to provide a suitable definition\nfor maxObjects? Simple: they’ll get an error during linking, because\nmaxObjects will be undefined. Provided we’ve adequately documented\nthis requirement for clients of Counted, they can then say “Duh” to\nthemselves and go back and add the requisite initialization.\nItem 27: Requiring or prohibiting heap-based objects.\nRequiring or Prohibiting Heap-Based Objects\nSometimes you want to arrange things so that objects of a particular\ntype can commit suicide, i.e., can “delete this.” Such an arrange-\nment clearly requires that objects of that type be allocated on the heap.\nOther times you’ll want to bask in the certainty that there can be no\nmemory leaks for a particular class, because none of the objects could\nhave been allocated on the heap. This might be the case if you are\nworking on an embedded system, where memory leaks are especially\ntroublesome and heap space is at a premium. Is it possible to produce\ncode that requires or prohibits heap-based objects? Often it is, but it\nalso turns out that the notion of being “on the heap” is more nebulous\nthan you might think.\nRequiring Heap-Based Objects\nLet us begin with the prospect of limiting object creation to the heap.\nTo enforce such a restriction, you’ve got to find a way to prevent clients\nfrom creating objects other than by calling new. This is easy to do. Non-\nheap objects are automatically constructed at their point of definition\nand automatically destructed at the end of their lifetime, so it suffices\nto simply make these implicit constructions and destructions illegal. \nThe straightforward way to make these calls illegal is to declare the\nconstructors and the destructor private. This is overkill. There’s no\nreason why they both need to be private. Better to make the destructor\nprivate and the constructors public. Then, in a process that should be\nfamiliar from Item 26, you can introduce a privileged pseudo-destruc-\n",
      "content_length": 2563,
      "extraction_method": "Direct"
    },
    {
      "page_number": 163,
      "chapter": null,
      "content": "146\nItem 27\ntor function that has access to the real destructor. Clients then call the\npseudo-destructor to destroy the objects they’ve created.\nIf, for example, we want to ensure that objects representing unlimited\nprecision numbers are created only on the heap, we can do it like this:\nclass UPNumber {\npublic:\nUPNumber();\nUPNumber(int initValue);\nUPNumber(double initValue);\nUPNumber(const UPNumber& rhs);\n// pseudo-destructor (a const member function, because\n// even const objects may be destroyed)\nvoid destroy() const { delete this; }\n...\nprivate:\n~UPNumber();\n};\nClients would then program like this:\nUPNumber n;\n// error! (legal here, but\n// illegal when n’s dtor is\n// later implicitly invoked)\nUPNumber *p = new UPNumber;\n// fine\n...\ndelete p;\n// error! attempt to call\n// private destructor\np->destroy();\n// fine\nAn alternative is to declare all the constructors private. The drawback\nto that idea is that a class often has many constructors, and the class’s\nauthor must remember to declare each of them private. This includes\nthe copy constructor, and it may include a default constructor, too, if\nthese functions would otherwise be generated by compilers; compiler-\ngenerated functions are always public. As a result, it’s easier to declare\nonly the destructor private, because a class can have only one of those.\nRestricting access to a class’s destructor or its constructors prevents\nthe creation of non-heap objects, but, in a story that is told in Item 26,\nit also prevents both inheritance and containment:\nclass UPNumber { ... };\n// declares dtor or ctors\n// private\nclass NonNegativeUPNumber:\npublic UPNumber { ... };\n// error! dtor or ctors\n// won’t compile\n",
      "content_length": 1680,
      "extraction_method": "Direct"
    },
    {
      "page_number": 164,
      "chapter": null,
      "content": "Requiring or Prohibiting Heap-Based Objects\n147\nclass Asset {\nprivate:\nUPNumber value;\n...\n// error! dtor or ctors\n// won’t compile\n};\nNeither of these difficulties is insurmountable. The inheritance prob-\nlem can be solved by making UPNumber’s destructor protected (while\nkeeping its constructors public), and classes that need to contain ob-\njects of type UPNumber can be modified to contain pointers to UPNumber\nobjects instead:\nclass UPNumber { ... };\n// declares dtor protected\nclass NonNegativeUPNumber:\npublic UPNumber { ... };\n// now okay; derived \n// classes have access to \n// protected members\nclass Asset {\npublic:\nAsset(int initValue);\n~Asset();\n...\nprivate:\nUPNumber *value;\n};\nAsset::Asset(int initValue)\n: value(new UPNumber(initValue))\n// fine\n{ ... }\nAsset::~Asset()\n{ value->destroy(); }\n// also fine\nDetermining Whether an Object is On The Heap\nIf we adopt this strategy, we must reexamine what it means to be “on\nthe heap.” Given the class definition sketched above, it’s legal to define\na non-heap NonNegativeUPNumber object:\nNonNegativeUPNumber n;\n// fine \nNow, the UPNumber part of the NonNegativeUPNumber object n is not\non the heap. Is that okay? The answer depends on the details of the\nclass’s design and implementation, but let us suppose it is not okay,\nthat all UPNumber objects — even base class parts of more derived ob-\njects — must be on the heap. How can we enforce this restriction?\nThere is no easy way. It is not possible for a UPNumber constructor to\ndetermine whether it’s being invoked as the base class part of a heap-\n",
      "content_length": 1562,
      "extraction_method": "Direct"
    },
    {
      "page_number": 165,
      "chapter": null,
      "content": "148\nItem 27\nbased object. That is, there is no way for the UPNumber constructor to\ndetect that the following contexts are different:\nNonNegativeUPNumber *n1 =\nnew NonNegativeUPNumber;\n// on heap\nNonNegativeUPNumber n2;\n// not on heap\nBut perhaps you don’t believe me. Perhaps you think you can play\ngames with the interaction among the new operator, operator new and\nthe constructor that the new operator calls (see Item 8). Perhaps you\nthink you can outsmart them all by modifying UPNumber as follows:\nclass UPNumber {\npublic:\n// exception to throw if a non-heap object is created\nclass HeapConstraintViolation {};\nstatic void * operator new(size_t size);\nUPNumber();\n...\nprivate:\nstatic bool onTheHeap;\n// inside ctors, whether\n// the object being\n...\n// constructed is on heap\n};\n// obligatory definition of class static\nbool UPNumber::onTheHeap = false;\nvoid *UPNumber::operator new(size_t size)\n{\nonTheHeap = true;\nreturn ::operator new(size);\n}\nUPNumber::UPNumber()\n{\nif (!onTheHeap) {\nthrow HeapConstraintViolation();\n}\nproceed with normal construction here;\nonTheHeap = false;\n// clear flag for next obj.\n}\nThere’s nothing deep going on here. The idea is to take advantage of\nthe fact that when an object is allocated on the heap, operator new is\ncalled to allocate the raw memory, then a constructor is called to ini-\ntialize an object in that memory. In particular, operator new sets\nonTheHeap to true, and each constructor checks onTheHeap to see if\nthe raw memory of the object being constructed was allocated by op-\n",
      "content_length": 1529,
      "extraction_method": "Direct"
    },
    {
      "page_number": 166,
      "chapter": null,
      "content": "Requiring or Prohibiting Heap-Based Objects\n149\nerator new. If not, an exception of type HeapConstraintViolation is\nthrown. Otherwise, construction proceeds as usual, and when con-\nstruction is finished, onTheHeap is set to false, thus resetting the de-\nfault value for the next object to be constructed.\nThis is a nice enough idea, but it won’t work. Consider this potential\nclient code:\nUPNumber *numberArray = new UPNumber[100];\nThe first problem is that the memory for the array is allocated by op-\nerator new[], not operator new, but (provided your compilers sup-\nport it) you can write the former function as easily as the latter. What\nis more troublesome is the fact that numberArray has 100 elements,\nso there will be 100 constructor calls. But there is only one call to al-\nlocate memory, so onTheHeap will be set to true for only the first of\nthose 100 constructors. When the second constructor is called, an ex-\nception is thrown, and woe is you.\nEven without arrays, this bit-setting business may fail. Consider this\nstatement:\nUPNumber *pn = new UPNumber(*new UPNumber);\nHere we create two UPNumbers on the heap and make pn point to one\nof them; it’s initialized with the value of the second one. This code has\na resource leak, but let us ignore that in favor of an examination of\nwhat happens during execution of this expression:\nnew UPNumber(*new UPNumber)\nThis contains two calls to the new operator, hence two calls to opera-\ntor new and two calls to UPNumber constructors (see Item 8). Program-\nmers typically expect these function calls to be executed in this order,\n1.\nCall operator new for first object (the leftmost one above)\n2.\nCall constructor for first object\n3.\nCall operator new for second object (the one used as an argu-\nment to the first UPNumber’s constructor)\n4.\nCall constructor for second object\nbut the language makes no guarantee that this is how it will be done.\nSome compilers generate the function calls in this order instead:\n1.\nCall operator new for first object\n2.\nCall operator new for second object\n3.\nCall constructor for second object\n4.\nCall constructor for first object\n",
      "content_length": 2119,
      "extraction_method": "Direct"
    },
    {
      "page_number": 167,
      "chapter": null,
      "content": "150\nItem 27\nThere is nothing wrong with compilers that generate this kind of code,\nbut the set-a-bit-in-operator-new trick fails with such compilers.\nThat’s because the bit set in steps 1 and 2 is cleared in step 3, thus\nmaking the object constructed in step 3 think it’s not on the heap, even\nthough it is.\nThese difficulties don’t invalidate the basic idea of having each con-\nstructor check to see if *this is on the heap. Rather, they indicate that\nchecking a bit set inside operator new (or operator new[]) is not a\nreliable way to determine this information. What we need is a better\nway to figure it out.\nIf you’re desperate enough, you might be tempted to descend into the\nrealm of the unportable. For example, you might decide to take advan-\ntage of the fact that on many systems, a program’s address space is or-\nganized as a linear sequence of addresses, with the program’s stack\ngrowing down from the top of the address space and the heap rising up\nfrom the bottom:\nOn systems that organize a program’s memory in this way (many do,\nbut many do not), you might think you could use the following func-\ntion to determine whether a particular address is on the heap:\n// incorrect attempt to determine whether an address\n// is on the heap\nbool onHeap(const void *address)\n{\nchar onTheStack;\n// local stack variable\nreturn address < &onTheStack;\n}\nThe thinking behind this function is interesting. Inside onHeap,\nonTheStack is a local variable. As such, it is, well, it’s on the stack.\nHigh\nAddresses\nLow\nAddresses\nHeap\nStack\n(Grows Down)\n(Grows Up)\nProgram’s\nAddress\nSpace\n(Incomplete\nPicture)\n",
      "content_length": 1601,
      "extraction_method": "Direct"
    },
    {
      "page_number": 168,
      "chapter": null,
      "content": "Requiring or Prohibiting Heap-Based Objects\n151\nWhen onHeap is called, its stack frame (i.e., its activation record) will\nbe placed at the top of the program’s stack, and because the stack\ngrows down (toward lower addresses) in this architecture, the address\nof onTheStack must be less than the address of any other stack-based\nvariable or object. If the parameter address is less than the location of\nonTheStack, it can’t be on the stack, so it must be on the heap.\nSuch logic is fine, as far as it goes, but it doesn’t go far enough. The\nfundamental problem is that there are three places where objects may\nbe allocated, not two. Yes, the stack and the heap hold objects, but let\nus not forget about static objects. Static objects are those that are ini-\ntialized only once during a program run. Static objects comprise not\nonly those objects explicitly declared static, but also objects at global\nand namespace scope. Such objects have to go somewhere, and that\nsomewhere is neither the stack nor the heap.\nWhere they go is system-dependent, but on many of the systems that\nhave the stack and heap grow toward one another, they go below the\nheap. The earlier picture of memory organization, while telling the\ntruth and nothing but the truth for many systems, failed to tell the\nwhole truth for those systems. With static objects added to the picture,\nit looks like this:\nSuddenly it becomes clear why onHeap won’t work, not even on sys-\ntems where it’s purported to: it fails to distinguish between heap ob-\njects and static objects:\nvoid allocateSomeObjects()\n{\nchar *pc = new char;\n// heap object: onHeap(pc)\n// will return true\nHigh\nAddresses\nLow\nAddresses\nHeap\nStack\nStatic\nObjects\n(Grows Down)\n(Grows Up)\nProgram’s\nAddress\nSpace\n(Complete\nPicture)\n",
      "content_length": 1756,
      "extraction_method": "Direct"
    },
    {
      "page_number": 169,
      "chapter": null,
      "content": "152\nItem 27\nchar c;\n// stack object: onHeap(&c)\n// will return false\nstatic char sc;\n// static object: onHeap(&sc)\n// will return true\n...\n}\nNow, you may be desperate for a way to tell heap objects from stack ob-\njects, and in your desperation you may be willing to strike a deal with\nthe portability Devil, but are you so desperate that you’ll strike a deal\nthat fails to guarantee you the right answers? Surely not, so I know\nyou’ll reject this seductive but unreliable compare-the-addresses trick.\nThe sad fact is there’s not only no portable way to determine whether\nan object is on the heap, there isn’t even a semi-portable way that\nworks most of the time.† If you absolutely, positively have to tell\nwhether an address is on the heap, you’re going to have to turn to un-\nportable, implementation-dependent system calls, and that’s that.\nThat being the case, you’re better off trying to redesign your software\nso you don’t need to determine whether an object is on the heap in the\nfirst place.\nIf you find yourself obsessing over whether an object is on the heap,\nthe likely cause is that you want to know if it’s safe to invoke delete\non it. Often such deletion will take the form of the infamous “delete\nthis.” Knowing whether it’s safe to delete a pointer, however, is not the\nsame as simply knowing whether that pointer points to something on\nthe heap, because not all pointers to things on the heap can be safely\ndeleted. Consider again an Asset object that contains a UPNumber\nobject:\nclass Asset {\nprivate:\nUPNumber value;\n...\n};\nAsset *pa = new Asset;\nClearly *pa (including its member value) is on the heap. Equally\nclearly, it’s not safe to invoke delete on a pointer to pa->value, be-\ncause no such pointer was ever returned from new.\nAs luck would have it, it’s easier to determine whether it’s safe to delete\na pointer than to determine whether a pointer points to something on\nthe heap, because all we need to answer the former question is a col-\nlection of addresses that have been returned by operator new. Since\nwe can write operator new ourselves, it’s easy to construct such a col-\nlection. Here’s how we might approach the problem:\n† I have since become convinced that signature-based techniques are all but foolproof.\nFor details, consult http://www.aristeia.com/BookErrata/M27Comments.html.\n",
      "content_length": 2319,
      "extraction_method": "Direct"
    },
    {
      "page_number": 170,
      "chapter": null,
      "content": "Requiring or Prohibiting Heap-Based Objects\n153\nvoid *operator new(size_t size)\n{\nvoid *p = getMemory(size);\n// call some function to\n// allocate memory and\n// handle out-of-memory\n// conditions\nadd p to the collection of allocated addresses;\nreturn p;\n}\nvoid operator delete(void *ptr)\n{\nreleaseMemory(ptr);\n// return memory to\n// free store\nremove ptr from the collection of allocated addresses;\n}\nbool isSafeToDelete(const void *address)\n{\nreturn whether address is in collection of \nallocated addresses;\n}\nThis is about as simple as it gets. operator new adds entries to a col-\nlection of allocated addresses, operator delete removes entries, and\nisSafeToDelete does a lookup in the collection to see if a particular\naddress is there. If the operator new and operator delete functions\nare at global scope, this should work for all types, even the built-ins.\nIn practice, three things are likely to dampen our enthusiasm for this\ndesign. The first is our extreme reluctance to define anything at global\nscope, especially functions with predefined meanings like operator\nnew and operator delete. Knowing as we do that there is but one glo-\nbal scope and but a single version of operator new and operator de-\nlete with the “normal” signatures (i.e., sets of parameter types) within\nthat scope, the last thing we want to do is seize those function signa-\ntures for ourselves. Doing so would render our software incompatible\nwith any other software that also implements global versions of oper-\nator new and operator delete (such as many object-oriented data-\nbase systems).\nOur second consideration is one of efficiency: why burden all heap al-\nlocations with the bookkeeping overhead necessary to keep track of re-\nturned addresses if we don’t need to?\nOur final concern is pedestrian, but important. It turns out to be es-\nsentially impossible to implement isSafeToDelete so that it always\nworks. The difficulty has to do with the fact that objects with multiple\n",
      "content_length": 1965,
      "extraction_method": "Direct"
    },
    {
      "page_number": 171,
      "chapter": null,
      "content": "154\nItem 27\nor virtual base classes have multiple addresses, so there’s no guaran-\ntee that the address passed to isSafeToDelete is the same as the one\nreturned from operator new, even if the object in question was allo-\ncated on the heap. For details, see Items 24 and 31.\nWhat we’d like is the functionality provided by these functions without\nthe concomitant pollution of the global namespace, the mandatory\noverhead, and the correctness problems. Fortunately, C++ gives us ex-\nactly what we need in the form of an abstract mixin base class. \nAn abstract base class is a base class that can’t be instantiated, i.e.,\none with at least one pure virtual function. A mixin (“mix in”) class is\none that provides a single well-defined capability and is designed to be\ncompatible with any other capabilities an inheriting class might pro-\nvide. Such classes are nearly always abstract. We can therefore come\nup with an abstract mixin base class that offers derived classes the\nability to determine whether a pointer was allocated from operator\nnew. Here’s such a class:\nclass HeapTracked {\n// mixin class; keeps track of \npublic:\n// ptrs returned from op. new\nclass MissingAddress{};\n// exception class; see below\nvirtual ~HeapTracked() = 0;\nstatic void *operator new(size_t size);\nstatic void operator delete(void *ptr);\nbool isOnHeap() const;\nprivate:\ntypedef const void* RawAddress;\nstatic list<RawAddress> addresses;\n};\nThis class uses the list data structure that’s part of the standard C++\nlibrary (see Item 35) to keep track of all pointers returned from oper-\nator new. That function allocates memory and adds entries to the list;\noperator delete deallocates memory and removes entries from the\nlist; and isOnHeap returns whether an object’s address is in the list.\nImplementation of the HeapTracked class is simple, because the glo-\nbal operator new and operator delete functions are called to per-\nform the real memory allocation and deallocation, and the list class\nhas functions to make insertion, removal, and lookup single-statement\noperations. Here’s the full implementation of HeapTracked:\n// mandatory definition of static class member\nlist<RawAddress> HeapTracked::addresses;\n",
      "content_length": 2190,
      "extraction_method": "Direct"
    },
    {
      "page_number": 172,
      "chapter": null,
      "content": "Requiring or Prohibiting Heap-Based Objects\n155\n// HeapTracked’s destructor is pure virtual to make the \n// class abstract. The destructor must still be \n// defined, however, so we provide this empty definition.\nHeapTracked::~HeapTracked() {}\nvoid * HeapTracked::operator new(size_t size)\n{\nvoid *memPtr = ::operator new(size);// get the memory\naddresses.push_front(memPtr);\n// put its address at\n// the front of the list\nreturn memPtr;\n}\nvoid HeapTracked::operator delete(void *ptr)\n{\n// gracefully hande null pointers\nif (ptr == 0) return;\n// get an \"iterator\" that identifies the list\n// entry containing ptr; see Item 35 for details\nlist<RawAddress>::iterator it =\nfind(addresses.begin(), addresses.end(), ptr);\n  if (it != addresses.end()) {\n// if an entry was found\naddresses.erase(it);\n// remove the entry \n::operator delete(ptr);\n// deallocate the memory\n} else {\n// otherwise\nthrow MissingAddress();\n// ptr wasn’t allocated by\n}\n// op. new, so throw an\n}\n// exception\nbool HeapTracked::isOnHeap() const\n{\n// get a pointer to the beginning of the memory\n// occupied by *this; see below for details\nconst void *rawAddress = dynamic_cast<const void*>(this);\n// look up the pointer in the list of addresses \n// returned by operator new\nlist<RawAddress>::iterator it =\nfind(addresses.begin(), addresses.end(), rawAddress);\n  return it != addresses.end();\n// return whether it was\n}\n// found\nThis code is straightforward, though it may not look that way if you are\nunfamiliar with the list class and the other components of the Stan-\ndard Template Library. Item 35 explains everything, but the comments\nin the code above should be sufficient to explain what’s happening in\nthis example. \nThe only other thing that may confound you is this statement (in\nisOnHeap):\nconst void *rawAddress = dynamic_cast<const void*>(this);\n",
      "content_length": 1825,
      "extraction_method": "Direct"
    },
    {
      "page_number": 173,
      "chapter": null,
      "content": "156\nItem 27\nI mentioned earlier that writing the global function isSafeToDelete is\ncomplicated by the fact that objects with multiple or virtual base\nclasses have several addresses. That problem plagues us in isOnHeap,\ntoo, but because isOnHeap applies only to HeapTracked objects, we\ncan exploit a special feature of the dynamic_cast operator (see Item 2)\nto eliminate the problem. Simply put, dynamic_casting a pointer to\nvoid* (or const void* or volatile void* or, for those who can’t get\nenough modifiers in their usual diet, const volatile void*) yields a\npointer to the beginning of the memory for the object pointed to by the\npointer. But dynamic_cast is applicable only to pointers to objects\nthat have at least one virtual function. Our ill-fated isSafeToDelete\nfunction had to work with any type of pointer, so dynamic_cast\nwouldn’t help it. isOnHeap is more selective (it tests only pointers to\nHeapTracked objects), so dynamic_casting this to const void*\ngives us a pointer to the beginning of the memory for the current ob-\nject. That’s the pointer that HeapTracked::operator new must have\nreturned if the memory for the current object was allocated by Heap-\nTracked::operator new in the first place. Provided your compilers\nsupport the dynamic_cast operator, this technique is completely por-\ntable.\nGiven this class, even BASIC programmers could add to a class the\nability to track pointers to heap allocations. All they’d need to do is\nhave the class inherit from HeapTracked. If, for example, we want to\nbe able to determine whether a pointer to an Asset object points to a\nheap-based object, we’d modify Asset’s class definition to specify\nHeapTracked as a base class:\nclass Asset: public HeapTracked {\nprivate:\nUPNumber value;\n...\n};\nWe could then query Asset* pointers as follows:\nvoid inventoryAsset(const Asset *ap)\n{\nif (ap->isOnHeap()) {\nap is a heap-based asset — inventory it as such;\n}\nelse {\nap is a non-heap-based asset — record it that way;\n}\n}\nA disadvantage of a mixin class like HeapTracked is that it can’t be\nused with the built-in types, because types like int and char can’t in-\n",
      "content_length": 2116,
      "extraction_method": "Direct"
    },
    {
      "page_number": 174,
      "chapter": null,
      "content": "Requiring or Prohibiting Heap-Based Objects\n157\nherit from anything. Still, the most common reason for wanting to use\na class like HeapTracked is to determine whether it’s okay to “delete\nthis,” and you’ll never want to do that with a built-in type because\nsuch types have no this pointer.\nProhibiting Heap-Based Objects\nThus ends our examination of determining whether an object is on the\nheap. At the opposite end of the spectrum is preventing objects from\nbeing allocated on the heap. Here the outlook is a bit brighter. There\nare, as usual, three cases: objects that are directly instantiated, ob-\njects instantiated as base class parts of derived class objects, and ob-\njects embedded inside other objects. We’ll consider each in turn.\nPreventing clients from directly instantiating objects on the heap is\neasy, because such objects are always created by calls to new and you\ncan make it impossible for clients to call new. Now, you can’t affect the\navailability of the new operator (that’s built into the language), but you\ncan take advantage of the fact that the new operator always calls op-\nerator new (see Item 8), and that function is one you can declare your-\nself. In particular, it is one you can declare private. If, for example,\nyou want to keep clients from creating UPNumber objects on the heap,\nyou could do it this way:\nclass UPNumber {\nprivate:\nstatic void *operator new(size_t size);\nstatic void operator delete(void *ptr);\n...\n};\nClients can now do only what they’re supposed to be able to do:\nUPNumber n1;\n// okay\nstatic UPNumber n2;\n// also okay\nUPNumber *p = new UPNumber;\n// error! attempt to call \n// private operator new\nIt suffices to declare operator new private, but it looks strange to have\noperator new be private and operator delete be public, so unless\nthere’s a compelling reason to split up the pair, it’s best to declare\nthem in the same part of a class. If you’d like to prohibit heap-based\narrays of UPNumber objects, too, you could declare operator new[]\nand operator delete[] (see Item 8) private as well.\nInterestingly, declaring operator new private often also prevents UP-\nNumber objects from being instantiated as base class parts of heap-\n",
      "content_length": 2187,
      "extraction_method": "Direct"
    },
    {
      "page_number": 175,
      "chapter": null,
      "content": "158\nItem 27\nbased derived class objects. That’s because operator new and oper-\nator delete are inherited, so if these functions aren’t declared public\nin a derived class, that class inherits the private versions declared in\nits base(s):\nclass UPNumber { ... };\n// as above\nclass NonNegativeUPNumber:\n// assume this class\npublic UPNumber {\n// declares no operator new\n...\n};\nNonNegativeUPNumber n1;\n// okay\nstatic NonNegativeUPNumber n2; // also okay\nNonNegativeUPNumber *p =\n// error! attempt to call\nnew NonNegativeUPNumber;\n// private operator new\nIf the derived class declares an operator new of its own, that function\nwill be called when allocating derived class objects on the heap, and a\ndifferent way will have to be found to prevent UPNumber base class\nparts from winding up there. Similarly, the fact that UPNumber’s oper-\nator new is private has no effect on attempts to allocate objects con-\ntaining UPNumber objects as members:\nclass Asset {\npublic:\nAsset(int initValue);\n...\nprivate:\nUPNumber value;\n};\nAsset *pa = new Asset(100);\n// fine, calls \n// Asset::operator new or\n// ::operator new, not\n// UPNumber::operator new\nFor all practical purposes, this brings us back to where we were when\nwe wanted to throw an exception in the UPNumber constructors if a UP-\nNumber object was being constructed in memory that wasn’t on the\nheap. This time, of course, we want to throw an exception if the object\nin question is on the heap. Just as there is no portable way to deter-\nmine if an address is on the heap, however, there is no portable way to\ndetermine that it is not on the heap, so we’re out of luck. This should\nbe no surprise. After all, if we could tell when an address is on the\nheap, we could surely tell when an address is not on the heap. But we\ncan’t, so we can’t. Oh well.\n",
      "content_length": 1796,
      "extraction_method": "Direct"
    },
    {
      "page_number": 176,
      "chapter": null,
      "content": "Smart Pointers\n159\nItem 28: Smart pointers.\nSmart Pointers\nSmart pointers are objects that are designed to look, act, and feel like\nbuilt-in pointers, but to offer greater functionality. They have a variety\nof applications, including resource management (see Items 9, 10, 25,\nand 31) and the automation of repetitive coding tasks (see Items 17\nand 29).\nWhen you use smart pointers in place of C++’s built-in pointers (i.e.,\ndumb pointers), you gain control over the following aspects of pointer\nbehavior:\n■Construction and destruction. You determine what happens\nwhen a smart pointer is created and destroyed. It is common to\ngive smart pointers a default value of 0 to avoid the headaches as-\nsociated with uninitialized pointers. Some smart pointers are\nmade responsible for deleting the object they point to when the\nlast smart pointer pointing to the object is destroyed. This can go a\nlong way toward eliminating resource leaks.\n■Copying and assignment. You control what happens when a\nsmart pointer is copied or is involved in an assignment. For some\nsmart pointer types, the desired behavior is to automatically copy\nor make an assignment to what is pointed to, i.e., to perform a\ndeep copy. For others, only the pointer itself should be copied or\nassigned. For still others, these operations should not be allowed\nat all. Regardless of what behavior you consider “right,” the use of\nsmart pointers lets you call the shots.\n■Dereferencing. What should happen when a client refers to the\nobject pointed to by a smart pointer? You get to decide. You could,\nfor example, use smart pointers to help implement the lazy fetch-\ning strategy outlined in Item 17. \nSmart pointers are generated from templates because, like built-in\npointers, they must be strongly typed; the template parameter speci-\nfies the type of object pointed to. Most smart pointer templates look\nsomething like this:\n",
      "content_length": 1890,
      "extraction_method": "Direct"
    },
    {
      "page_number": 177,
      "chapter": null,
      "content": "160\nItem 28\ntemplate<class T>\n// template for smart\nclass SmartPtr {\n// pointer objects\npublic:\nSmartPtr(T* realPtr = 0);\n// create a smart ptr to an\n// obj given a dumb ptr to\n// it; uninitialized ptrs\n// default to 0 (null)\nSmartPtr(const SmartPtr& rhs); // copy a smart ptr \n~SmartPtr();\n// destroy a smart ptr\n// make an assignment to a smart ptr\nSmartPtr& operator=(const SmartPtr& rhs);\nT* operator->() const;\n// dereference a smart ptr\n// to get at a member of\n// what it points to\nT& operator*() const;\n// dereference a smart ptr\nprivate:\nT *pointee;\n// what the smart ptr\n};\n// points to\nThe copy constructor and assignment operator are both shown public\nhere. For smart pointer classes where copying and assignment are not\nallowed, they would typically be declared private. The two dereferenc-\ning operators are declared const, because dereferencing a pointer\ndoesn’t modify it (though it may lead to modification of what the\npointer points to). Finally, each smart pointer-to-T object is imple-\nmented by containing a dumb pointer-to-T within it. It is this dumb\npointer that does the actual pointing.\nBefore going into the details of smart pointer implementation, it’s\nworth seeing how clients might use smart pointers. Consider a distrib-\nuted system in which some objects are local and some are remote. Ac-\ncess to local objects is generally simpler and faster than access to\nremote objects, because remote access may require remote procedure\ncalls or some other way of communicating with a distant machine. \nFor clients writing application code, the need to handle local and re-\nmote objects differently is a nuisance. It is more convenient to have all\nobjects appear to be located in the same place. Smart pointers allow a\nlibrary to offer this illusion:\ntemplate<class T>\n// template for smart ptrs\nclass DBPtr {\n// to objects in a\npublic:\n// distributed DB\nDBPtr(T *realPtr = 0);\n// create a smart ptr to a \n// DB object given a local\n// dumb pointer to it\n",
      "content_length": 1975,
      "extraction_method": "Direct"
    },
    {
      "page_number": 178,
      "chapter": null,
      "content": "Smart Pointers\n161\nDBPtr(DataBaseID id);\n// create a smart ptr to a\n// DB object given its\n// unique DB identifier\n...\n// other smart ptr\n};\n// functions as above\nclass Tuple {\n// class for database\npublic:\n// tuples\n...\nvoid displayEditDialog();\n// present a graphical \n// dialog box allowing a\n// user to edit the tuple\nbool isValid() const;\n// return whether *this\n};\n// passes validity check\n// class template for making log entries whenever a T\n// object is modified; see below for details\ntemplate<class T>\nclass LogEntry {\npublic:\nLogEntry(const T& objectToBeModified);\n~LogEntry();\n};\nvoid editTuple(DBPtr<Tuple>& pt)\n{\nLogEntry<Tuple> entry(*pt);\n// make log entry for this\n// editing operation; see \n// below for details\n// repeatedly display edit dialog until valid values\n// are provided\ndo {\npt->displayEditDialog();\n} while (pt->isValid() == false);\n}\nThe tuple to be edited inside editTuple may be physically located on\na remote machine, but the programmer writing editTuple need not be\nconcerned with such matters; the smart pointer class hides that as-\npect of the system. As far as the programmer is concerned, all tuples\nare accessed through objects that, except for how they’re declared, act\njust like run-of-the-mill built-in pointers.\nNotice the use of a LogEntry object in editTuple. A more conven-\ntional design would have been to surround the call to displayEdit-\nDialog with calls to begin and end the log entry. In the approach\nshown here, the LogEntry’s constructor begins the log entry and its\ndestructor ends the log entry. As Item 9 explains, using an object to\nbegin and end logging is more robust in the face of exceptions than ex-\nplicitly calling functions, so you should accustom yourself to using\n",
      "content_length": 1734,
      "extraction_method": "Direct"
    },
    {
      "page_number": 179,
      "chapter": null,
      "content": "162\nItem 28\nclasses like LogEntry. Besides, it’s easier to create a single LogEntry\nobject than to add separate calls to start and stop an entry.\nAs you can see, using a smart pointer isn’t much different from using\nthe dumb pointer it replaces. That’s testimony to the effectiveness of\nencapsulation. Clients of smart pointers are supposed to be able to\ntreat them as dumb pointers. As we shall see, sometimes the substitu-\ntion is more transparent than others.\nConstruction, Assignment, and Destruction of Smart Pointers\nConstruction of a smart pointer is usually straightforward: locate an\nobject to point to (typically by using the smart pointer’s constructor ar-\nguments), then make the smart pointer’s internal dumb pointer point\nthere. If no object can be located, set the internal pointer to 0 or signal\nan error (possibly by throwing an exception).\nImplementing a smart pointer’s copy constructor, assignment opera-\ntor(s) and destructor is complicated somewhat by the issue of owner-\nship. If a smart pointer owns the object it points to, it is responsible for\ndeleting that object when it (the smart pointer) is destroyed. This as-\nsumes the object pointed to by the smart pointer is dynamically allo-\ncated. Such an assumption is common when working with smart\npointers. (For ideas on how to make sure the assumption is true, see\nItem 27.)\nConsider the auto_ptr template from the standard C++ library. As\nItem 9 explains, an auto_ptr object is a smart pointer that points to a\nheap-based object until it (the auto_ptr) is destroyed. When that hap-\npens, the auto_ptr’s destructor deletes the pointed-to object. The\nauto_ptr template might be implemented like this:\ntemplate<class T>\nclass auto_ptr {\npublic:\nauto_ptr(T *ptr = 0): pointee(ptr) {}\n~auto_ptr() { delete pointee; }\n...\nprivate:\nT *pointee;\n};\nThis works fine provided only one auto_ptr owns an object. But what\nshould happen when an auto_ptr is copied or assigned?\nauto_ptr<TreeNode> ptn1(new TreeNode);\nauto_ptr<TreeNode> ptn2 = ptn1;\n// call to copy ctor;\n// what should happen?\n",
      "content_length": 2056,
      "extraction_method": "Direct"
    },
    {
      "page_number": 180,
      "chapter": null,
      "content": "Smart Pointers\n163\nauto_ptr<TreeNode> ptn3;\nptn3 = ptn2;\n// call to operator=;\n// what should happen?\nIf we just copied the internal dumb pointer, we’d end up with two\nauto_ptrs pointing to the same object. This would lead to grief, be-\ncause each auto_ptr would delete what it pointed to when the\nauto_ptr was destroyed. That would mean we’d delete an object more\nthan once. The results of such double-deletes are undefined (and are\nfrequently disastrous).\nAn alternative would be to create a new copy of what was pointed to by\ncalling new. That would guarantee we didn’t have too many auto_ptrs\npointing to a single object, but it might engender an unacceptable per-\nformance hit for the creation (and later destruction) of the new object.\nFurthermore, we wouldn’t necessarily know what type of object to cre-\nate, because an auto_ptr<T> object need not point to an object of type\nT; it might point to an object of a type derived from T. Virtual construc-\ntors (see Item 25) can help solve this problem, but it seems inappropri-\nate to require their use in a general-purpose class like auto_ptr.\nThe problems would vanish if auto_ptr prohibited copying and assign-\nment, but a more flexible solution was adopted for the auto_ptr classes:\nobject ownership is transferred when an auto_ptr is copied or assigned:\ntemplate<class T>\nclass auto_ptr {\npublic:\n...\nauto_ptr(auto_ptr<T>& rhs);\n// copy constructor\nauto_ptr<T>&\n// assignment\noperator=(auto_ptr<T>& rhs);\n// operator\n...\n};\ntemplate<class T>\nauto_ptr<T>::auto_ptr(auto_ptr<T>& rhs)\n{\npointee = rhs.pointee;\n// transfer ownership of\n// *pointee to *this\nrhs.pointee = 0;\n// rhs no longer owns\n}\n// anything\n",
      "content_length": 1664,
      "extraction_method": "Direct"
    },
    {
      "page_number": 181,
      "chapter": null,
      "content": "164\nItem 28\ntemplate<class T>\nauto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<T>& rhs)\n{\nif (this == &rhs)\n// do nothing if this\nreturn *this;\n// object is being assigned\n// to itself\ndelete pointee;\n// delete currently owned\n// object\npointee = rhs.pointee;\n// transfer ownership of\nrhs.pointee = 0;\n// *pointee from rhs to *this\nreturn *this;\n}\nNotice that the assignment operator must delete the object it owns be-\nfore assuming ownership of a new object. If it failed to do this, the ob-\nject would never be deleted. Remember, nobody but the auto_ptr\nobject owns the object the auto_ptr points to.\nBecause object ownership is transferred when auto_ptr’s copy con-\nstructor is called, passing auto_ptrs by value is often a very bad idea.\nHere’s why:\n// this function will often lead to disaster\nvoid printTreeNode(ostream& s, auto_ptr<TreeNode> p)\n{ s << *p; }\nint main()\n{\nauto_ptr<TreeNode> ptn(new TreeNode);\n...\nprintTreeNode(cout, ptn);\n// pass auto_ptr by value\n...\n}\nWhen printTreeNode’s parameter p is initialized (by calling\nauto_ptr’s copy constructor), ownership of the object pointed to by\nptn is transferred to p. When printTreeNode finishes executing, p\ngoes out of scope and its destructor deletes what it points to (which is\nwhat ptn used to point to). ptn, however, no longer points to anything\n(its underlying dumb pointer is null), so just about any attempt to use\nit after the call to printTreeNode will yield undefined behavior. Pass-\ning auto_ptrs by value, then, is something to be done only if you’re\nsure you want to transfer ownership of an object to a (transient) func-\ntion parameter. Only rarely will you want to do this.\n",
      "content_length": 1651,
      "extraction_method": "Direct"
    },
    {
      "page_number": 182,
      "chapter": null,
      "content": "Smart Pointers\n165\nThis doesn’t mean you can’t pass auto_ptrs as parameters, it just\nmeans that pass-by-value is not the way to do it. Pass-by-reference-to-\nconst is:\n// this function behaves much more intuitively\nvoid printTreeNode(ostream& s, \nconst auto_ptr<TreeNode>& p)\n{ s << *p; }\nIn this function, p is a reference, not an object, so no constructor is\ncalled to initialize p. When ptn is passed to this version of print-\nTreeNode, it retains ownership of the object it points to, and ptn can\nsafely be used after the call to printTreeNode. Thus, passing\nauto_ptrs by reference-to-const avoids the hazards arising from\npass-by-value.\nThe notion of transferring ownership from one smart pointer to an-\nother during copying and assignment is interesting, but you may have\nbeen at least as interested in the unconventional declarations of the\ncopy constructor and assignment operator. These functions normally\ntake const parameters, but above they do not. In fact, the code above\nchanges these parameters during the copy or the assignment. In other\nwords, auto_ptr objects are modified if they are copied or are the\nsource of an assignment!\nYes, that’s exactly what’s happening. Isn’t it nice that C++ is flexible\nenough to let you do this? If the language required that copy construc-\ntors and assignment operators take const parameters, you’d probably\nhave to cast away the parameters’ constness or play other games to\nimplement ownership transferral. Instead, you get to say exactly what\nyou want to say: when an object is copied or is the source of an assign-\nment, that object is changed. This may not seem intuitive, but it’s sim-\nple, direct, and, in this case, accurate.\nIf you find this examination of auto_ptr member functions interest-\ning, you may wish to see a complete implementation. You’ll find one on\npages 291-294, where you’ll also see that the auto_ptr template in\nthe standard C++ library has copy constructors and assignment oper-\nators that are more flexible than those described here. In the standard\nauto_ptr template, those functions are member function templates,\nnot just member functions. (Member function templates are described\nlater in this Item.)\nA smart pointer’s destructor often looks like this:\n",
      "content_length": 2236,
      "extraction_method": "Direct"
    },
    {
      "page_number": 183,
      "chapter": null,
      "content": "166\nItem 28\ntemplate<class T>\nSmartPtr<T>::~SmartPtr()\n{\nif (*this owns *pointee) {\ndelete pointee;\n}\n}\nSometimes there is no need for the test. An auto_ptr always owns\nwhat it points to, for example. At other times the test is a bit more com-\nplicated. A smart pointer that employs reference counting (see Item 29)\nmust adjust a reference count before determining whether it has the\nright to delete what it points to. Of course, some smart pointers are like\ndumb pointers: they have no effect on the object they point to when\nthey themselves are destroyed.\nImplementing the Dereferencing Operators\nLet us now turn our attention to the very heart of smart pointers, the\noperator* and operator-> functions. The former returns the object\npointed to. Conceptually, this is simple:\ntemplate<class T>\nT& SmartPtr<T>::operator*() const \n{\nperform \"smart pointer\" processing;\nreturn *pointee;\n}\nFirst the function does whatever processing is needed to initialize or\notherwise make pointee valid. For example, if lazy fetching is being\nused (see Item 17), the function may have to conjure up a new object\nfor pointee to point to. Once pointee is valid, the operator* func-\ntion just returns a reference to the pointed-to object.\nNote that the return type is a reference. It would be disastrous to re-\nturn an object instead, though compilers will let you do it. Bear in\nmind that pointee need not point to an object of type T; it may point\nto an object of a class derived from T. If that is the case and your op-\nerator* function returns a T object instead of a reference to the ac-\ntual derived class object, your function will return an object of the\nwrong type! (This is the slicing problem — see Item 13.) Virtual func-\ntions invoked on the object returned from your star-crossed opera-\ntor* will not invoke the function corresponding to the dynamic type of\nthe pointed-to object. In essence, your smart pointer will not properly\nsupport virtual functions, and how smart is a pointer like that? Be-\nsides, returning a reference is more efficient anyway, because there is\nno need to construct a temporary object (see Item 19). This is one of\n",
      "content_length": 2137,
      "extraction_method": "Direct"
    },
    {
      "page_number": 184,
      "chapter": null,
      "content": "Smart Pointers\n167\nthose happy occasions when correctness and efficiency go hand in\nhand.\nIf you’re the kind who likes to worry, you may wonder what you should\ndo if somebody invokes operator* on a null smart pointer, i.e., one\nwhose embedded dumb pointer is null. Relax. You can do anything you\nwant. The result of dereferencing a null pointer is undefined, so there\nis no “wrong” behavior. Wanna throw an exception? Go ahead, throw it.\nWanna call abort (possibly by having an assert call fail)? Fine, call it.\nWanna walk through memory setting every byte to your birth date\nmodulo 256? That’s okay, too. It’s not nice, but as far as the language\nis concerned, you are completely unfettered.\nThe story with operator-> is similar to that for operator*, but before\nexamining operator->, let us remind ourselves of the unusual mean-\ning of a call to this function. Consider again the editTuple function\nthat uses a smart pointer-to-Tuple object:\nvoid editTuple(DBPtr<Tuple>& pt)\n{\nLogEntry<Tuple> entry(*pt);\ndo {\npt->displayEditDialog();\n} while (pt->isValid() == false);\n}\nThe statement\npt->displayEditDialog();\nis interpreted by compilers as:\n(pt.operator->())->displayEditDialog();\nThat means that whatever operator-> returns, it must be legal to\napply the member-selection operator (->) to it. There are thus only two\nthings operator-> can return: a dumb pointer to an object or another\nsmart pointer object. Most of the time, you’ll want to return an ordi-\nnary dumb pointer. In those cases, you implement operator-> as fol-\nlows:\ntemplate<class T>\nT* SmartPtr<T>::operator->() const\n{\nperform \"smart pointer\" processing;\nreturn pointee;\n}\nThis will work fine. Because this function returns a pointer, virtual\nfunction calls via operator-> will behave the way they’re supposed to.\n",
      "content_length": 1785,
      "extraction_method": "Direct"
    },
    {
      "page_number": 185,
      "chapter": null,
      "content": "168\nItem 28\nFor many applications, this is all you need to know about smart point-\ners. The reference-counting code of Item 29, for example, draws on no\nmore functionality than we’ve discussed here. If you want to push your\nsmart pointers further, however, you must know more about dumb\npointer behavior and how smart pointers can and cannot emulate it. If\nyour motto is “Most people stop at the Z — but not me!”, the material\nthat follows is for you.\nTesting Smart Pointers for Nullness\nWith the functions we have discussed so far, we can create, destroy,\ncopy, assign, and dereference smart pointers. One of the things we\ncannot do, however, is find out if a smart pointer is null:\nSmartPtr<TreeNode> ptn;\n...\nif (ptn == 0) ...\n// error!\nif (ptn) ...\n// error!\nif (!ptn) ...\n// error!\nThis is a serious limitation. \nIt would be easy to add an isNull member function to our smart\npointer classes, but that wouldn’t address the problem that smart\npointers don’t act like dumb pointers when testing for nullness. A dif-\nferent approach is to provide an implicit conversion operator that al-\nlows the tests above to compile. The conversion traditionally employed\nfor this purpose is to void*:\ntemplate<class T>\nclass SmartPtr {\npublic:\n...\noperator void*();\n// returns 0 if the smart\n...\n// ptr is null, nonzero\n};\n// otherwise\nSmartPtr<TreeNode> ptn;\n...\nif (ptn == 0) ...\n// now fine\nif (ptn) ...\n// also fine\nif (!ptn) ...\n// fine\nThis is similar to a conversion provided by the iostream classes, and it\nexplains why it’s possible to write code like this:\nifstream inputFile(\"datafile.dat\");\n",
      "content_length": 1593,
      "extraction_method": "Direct"
    },
    {
      "page_number": 186,
      "chapter": null,
      "content": "Smart Pointers\n169\nif (inputFile) ...\n// test to see if inputFile\n// was successfully \n// opened\nLike all type conversion functions, this one has the drawback of letting\nfunction calls succeed that most programmers would expect to fail (see\nItem 5). In particular, it allows comparisons of smart pointers of com-\npletely different types:\nSmartPtr<Apple> pa;\nSmartPtr<Orange> po;\n...\nif (pa == po) ...\n// this compiles!\nEven if there is no operator== taking a SmartPtr<Apple> and a\nSmartPtr<Orange>, this compiles, because both smart pointers can\nbe implicitly converted into void* pointers, and there is a built-in\ncomparison function for built-in pointers. This kind of behavior makes\nimplicit conversion functions dangerous. (Again, see Item 5, and keep\nseeing it over and over until you can see it in the dark.)\nThere are variations on the conversion-to-void* motif. Some designers\nadvocate conversion to const void*, others embrace conversion to\nbool. Neither of these variations eliminates the problem of allowing\nmixed-type comparisons.\nThere is a middle ground that allows you to offer a reasonable syntac-\ntic form for testing for nullness while minimizing the chances of acci-\ndentally comparing smart pointers of different types. It is to overload\noperator! for your smart pointer classes so that operator! returns\ntrue if and only if the smart pointer on which it’s invoked is null:\ntemplate<class T>\nclass SmartPtr {\npublic:\n...\nbool operator!() const;\n// returns true if and only\n...\n// if the smart ptr is null\n};\nThis lets your clients program like this,\n",
      "content_length": 1570,
      "extraction_method": "Direct"
    },
    {
      "page_number": 187,
      "chapter": null,
      "content": "170\nItem 28\nSmartPtr<TreeNode> ptn;\n...\nif (!ptn) {\n// fine\n...\n// ptn is null \n}\nelse {\n...\n// ptn is not null\n}\nbut not like this:\nif (ptn == 0) ...\n// still an error\nif (ptn) ...\n// also an error\nThe only risk for mixed-type comparisons is statements such as these:\nSmartPtr<Apple> pa;\nSmartPtr<Orange> po;\n...\nif (!pa == !po) ...\n// alas, this compiles\nFortunately, programmers don’t write code like this very often. Inter-\nestingly, iostream library implementations provide an operator! in\naddition to the implicit conversion to void*, but these two functions\ntypically test for slightly different stream states. (In the C++ library\nstandard (see Item 35), the implicit conversion to void* has been re-\nplaced by an implicit conversion to bool, and operator bool always\nreturns the negation of operator!.)\nConverting Smart Pointers to Dumb Pointers\nSometimes you’d like to add smart pointers to an application or library\nthat already uses dumb pointers. For example, your distributed data-\nbase system may not originally have been distributed, so you may have\nsome old library functions that aren’t designed to use smart pointers:\nclass Tuple { ... };\n// as before\nvoid normalize(Tuple *pt);\n// put *pt into canonical\n// form; note use of dumb\n// pointer\nConsider what will happen if you try to call normalize with a smart\npointer-to-Tuple:\nDBPtr<Tuple> pt;\n...\nnormalize(pt);\n// error!\n",
      "content_length": 1392,
      "extraction_method": "Direct"
    },
    {
      "page_number": 188,
      "chapter": null,
      "content": "Smart Pointers\n171\nThe call will fail to compile, because there is no way to convert a\nDBPtr<Tuple> to a Tuple*. You can make it work by doing this,\nnormalize(&*pt);\n// gross, but legal\nbut I hope you’ll agree this is repugnant.\nThe call can be made to succeed by adding to the smart pointer-to-T\ntemplate an implicit conversion operator to a dumb pointer-to-T:\ntemplate<class T>\n// as before \nclass DBPtr {\npublic:\n...\noperator T*() { return pointee; }\n...\n};\nDBPtr<Tuple> pt;\n...\nnormalize(pt);\n// this now works\nAddition of this function also eliminates the problem of testing for\nnullness:\nif (pt == 0) ...\n// fine, converts pt to a\n// Tuple*\nif (pt) ...\n// ditto\nif (!pt) ...\n// ditto (reprise)\nHowever, there is a dark side to such conversion functions. (There al-\nmost always is. Have you been seeing Item 5?) They make it easy for\nclients to program directly with dumb pointers, thus bypassing the\nsmarts your pointer-like objects are designed to provide:\nvoid processTuple(DBPtr<Tuple>& pt)\n{\nTuple *rawTuplePtr = pt;\n// converts DBPtr<Tuple> to\n// Tuple*\nuse rawTuplePtr to modify the tuple;\n}\nUsually, the “smart” behavior provided by a smart pointer is an essen-\ntial component of your design, so allowing clients to use dumb pointers\ntypically leads to disaster. For example, if DBPtr implements the refer-\nence-counting strategy of Item 29, allowing clients to manipulate\ndumb pointers directly will almost certainly lead to bookkeeping errors\nthat corrupt the reference-counting data structures.\n",
      "content_length": 1511,
      "extraction_method": "Direct"
    },
    {
      "page_number": 189,
      "chapter": null,
      "content": "172\nItem 28\nEven if you provide an implicit conversion operator to go from a smart\npointer to the dumb pointer it’s built on, your smart pointer will never\nbe truly interchangeable with the dumb pointer. That’s because the\nconversion from a smart pointer to a dumb pointer is a user-defined\nconversion, and compilers are forbidden from applying more than one\nsuch conversion at a time. For example, suppose you have a class rep-\nresenting all the clients who have accessed a particular tuple:\nclass TupleAccessors {\npublic:\nTupleAccessors(const Tuple *pt);\n// pt identifies the\n...\n// tuple whose accessors\n};\n// we care about\nAs usual, TupleAccessors’ single-argument constructor also acts as\na type-conversion operator from Tuple* to TupleAccessors (see Item\n5). Now consider a function for merging the information in two Tuple-\nAccessors objects:\nTupleAccessors merge(const TupleAccessors& ta1,\nconst TupleAccessors& ta2);\nBecause a Tuple* may be implicitly converted to a TupleAccessors,\ncalling merge with two dumb Tuple* pointers is fine:\nTuple *pt1, *pt2;\n...\nmerge(pt1, pt2);\n// fine, both pointers are converted\n// to TupleAccessors objects\nThe corresponding call with smart DBPtr<Tuple> pointers, however,\nfails to compile:\nDBPtr<Tuple> pt1, pt2;\n...\nmerge(pt1, pt2);\n// error! No way to convert pt1 and\n// pt2 to TupleAccessors objects\nThat’s because a conversion from DBPtr<Tuple> to TupleAccessors\ncalls for two user-defined conversions (one from DBPtr<Tuple> to Tu-\nple* and one from Tuple* to TupleAccessors), and such sequences\nof conversions are prohibited by the language.\nSmart pointer classes that provide an implicit conversion to a dumb\npointer open the door to a particularly nasty bug. Consider this code:\nDBPtr<Tuple> pt = new Tuple;\n...\ndelete pt;\n",
      "content_length": 1774,
      "extraction_method": "Direct"
    },
    {
      "page_number": 190,
      "chapter": null,
      "content": "Smart Pointers\n173\nThis should not compile. After all, pt is not a pointer, it’s an object,\nand you can’t delete an object. Only pointers can be deleted, right? \nRight. But remember from Item 5 that compilers use implicit type con-\nversions to make function calls succeed whenever they can, and recall\nfrom Item 8 that use of the delete operator leads to calls to a destruc-\ntor and to operator delete, both of which are functions. Compilers\nwant these function calls to succeed, so in the delete statement\nabove, they implicitly convert pt to a Tuple*, then they delete that.\nThis will almost certainly break your program. \nIf pt owns the object it points to, that object is now deleted twice, once\nat the point where delete is called, a second time when pt’s destruc-\ntor is invoked. If pt doesn’t own the object, somebody else does. That\nsomebody may be the person who deleted pt, in which case all is well.\nIf, however, the owner of the object pointed to by pt is not the person\nwho deleted pt, we can expect the rightful owner to delete that object\nagain later. The first and last of these scenarios leads to an object\nbeing deleted twice, and deleting an object more than once yields un-\ndefined behavior.\nThis bug is especially pernicious because the whole idea behind smart\npointers is to make them look and feel as much like dumb pointers as\npossible. The closer you get to this ideal, the more likely your clients\nare to forget they are using smart pointers. If they do, who can blame\nthem if they continue to think that in order to avoid resource leaks,\nthey must call delete if they called new?\nThe bottom line is simple: don’t provide implicit conversion operators\nto dumb pointers unless there is a compelling reason to do so. \nSmart Pointers and Inheritance-Based Type Conversions\nSuppose we have a public inheritance hierarchy modeling consumer\nproducts for storing music:\nclass MusicProduct {\npublic:\nMusicProduct(const string& title);\nvirtual void play() const = 0;\nvirtual void displayTitle() const = 0;\n...\n};\nMusicProduct\nCD\nCassette\n",
      "content_length": 2055,
      "extraction_method": "Direct"
    },
    {
      "page_number": 191,
      "chapter": null,
      "content": "174\nItem 28\nclass Cassette: public MusicProduct {\npublic:\nCassette(const string& title);\nvirtual void play() const;\nvirtual void displayTitle() const;\n...\n};\nclass CD: public MusicProduct {\npublic:\nCD(const string& title);\nvirtual void play() const;\nvirtual void displayTitle() const;\n...\n};\nFurther suppose we have a function that, given a MusicProduct ob-\nject, displays the title of the product and then plays it:\nvoid displayAndPlay(const MusicProduct* pmp, int numTimes)\n{\nfor (int i = 1; i <= numTimes; ++i) {\npmp->displayTitle();\npmp->play();\n}\n}\nSuch a function might be used like this:\nCassette *funMusic = new Cassette(\"Alapalooza\");\nCD *nightmareMusic = new CD(\"Disco Hits of the 70s\");\ndisplayAndPlay(funMusic, 10);\ndisplayAndPlay(nightmareMusic, 0);\nThere are no surprises here, but look what happens if we replace the\ndumb pointers with their allegedly smart counterparts:\nvoid displayAndPlay(const SmartPtr<MusicProduct>& pmp,\nint numTimes);\nSmartPtr<Cassette> funMusic(new Cassette(\"Alapalooza\"));\nSmartPtr<CD> nightmareMusic(new CD(\"Disco Hits of the 70s\"));\ndisplayAndPlay(funMusic, 10);\n// error!\ndisplayAndPlay(nightmareMusic, 0);\n// error!\nIf smart pointers are so brainy, why won’t these compile?\nThey won’t compile because there is no conversion from a SmartPtr<CD>\nor a SmartPtr<Cassette> to a SmartPtr<MusicProduct>. As far as\ncompilers are concerned, these are three separate classes — they have\nno relationship to one another. Why should compilers think otherwise?\nAfter all, it’s not like SmartPtr<CD> or SmartPtr<Cassette> inherits\nfrom SmartPtr<MusicProduct>. With no inheritance relationship be-\n",
      "content_length": 1627,
      "extraction_method": "Direct"
    },
    {
      "page_number": 192,
      "chapter": null,
      "content": "Smart Pointers\n175\ntween these classes, we can hardly expect compilers to run around\nconverting objects of one type to objects of other types. \nFortunately, there is a way to get around this limitation, and the idea\n(if not the practice) is simple: give each smart pointer class an implicit\ntype conversion operator (see Item 5) for each smart pointer class to\nwhich it should be implicitly convertible. For example, in the music hi-\nerarchy, you’d add an operator SmartPtr<MusicProduct> to the\nsmart pointer classes for Cassette and CD:\nclass SmartPtr<Cassette> {\npublic:\noperator SmartPtr<MusicProduct>()\n{ return SmartPtr<MusicProduct>(pointee); }\n...\nprivate:\nCassette *pointee;\n};\nclass SmartPtr<CD> {\npublic:\noperator SmartPtr<MusicProduct>()\n{ return SmartPtr<MusicProduct>(pointee); }\n...\nprivate:\nCD *pointee;\n};\nThe drawbacks to this approach are twofold. First, you must manually\nspecialize the SmartPtr class instantiations so you can add the neces-\nsary implicit type conversion operators, but that pretty much defeats\nthe purpose of templates. Second, you may have to add many such\nconversion operators, because your pointed-to object may be deep in\nan inheritance hierarchy, and you must provide a conversion operator\nfor each base class from which that object directly or indirectly inher-\nits. (If you think you can get around this by providing only an implicit\ntype conversion operator for each direct base class, think again. Be-\ncause compilers are prohibited from employing more than one user-\ndefined type conversion function at a time, they can’t convert a smart\npointer-to-T to a smart pointer-to-indirect-base-class-of-T unless they\ncan do it in a single step.)\nIt would be quite the time-saver if you could somehow get compilers to\nwrite all these implicit type conversion functions for you. Thanks to a\nrecent language extension, you can. The extension in question is the\nability to declare (nonvirtual) member function templates (usually just\n",
      "content_length": 1971,
      "extraction_method": "Direct"
    },
    {
      "page_number": 193,
      "chapter": null,
      "content": "176\nItem 28\ncalled member templates), and you use it to generate smart pointer\nconversion functions like this:\ntemplate<class T>\n// template class for smart\nclass SmartPtr {\n// pointers-to-T objects\npublic:\nSmartPtr(T* realPtr = 0);\nT* operator->() const;\nT& operator*() const;\ntemplate<class newType>\n// template function for\noperator SmartPtr<newType>() // implicit conversion ops.\n{\nreturn SmartPtr<newType>(pointee);\n}\n...\n};\nNow hold on to your headlights, this isn’t magic — but it’s close. It\nworks as follows. (I’ll give a specific example in a moment, so don’t de-\nspair if the remainder of this paragraph reads like so much gobbledy-\ngook. After you’ve seen the example, it’ll make more sense, I promise.)\nSuppose a compiler has a smart pointer-to-T object, and it’s faced with\nthe need to convert that object into a smart pointer-to-base-class-of-T.\nThe compiler checks the class definition for SmartPtr<T> to see if the\nrequisite conversion operator is declared, but it is not. (It can’t be: no\nconversion operators are declared in the template above.) The compiler\nthen checks to see if there’s a member function template it can instan-\ntiate that would let it perform the conversion it’s looking for. It finds\nsuch a template (the one taking the formal type parameter newType),\nso it instantiates the template with newType bound to the base class of\nT that’s the target of the conversion. At that point, the only question is\nwhether the code for the instantiated member function will compile. In\norder for it to compile, it must be legal to pass the (dumb) pointer\npointee to the constructor for the smart pointer-to-base-of-T. poin-\ntee is of type T, so it is certainly legal to convert it into a pointer to its\n(public or protected) base classes. Hence, the code for the type conver-\nsion operator will compile, and the implicit conversion from smart\npointer-to-T to smart pointer-to-base-of-T will succeed. \nAn example will help. Let us return to the music hierarchy of CDs, cas-\nsettes, and music products. We saw earlier that the following code\nwouldn’t compile, because there was no way for compilers to convert\nthe smart pointers to CDs or cassettes into smart pointers to music\nproducts:\n",
      "content_length": 2210,
      "extraction_method": "Direct"
    },
    {
      "page_number": 194,
      "chapter": null,
      "content": "Smart Pointers\n177\nvoid displayAndPlay(const SmartPtr<MusicProduct>& pmp,\nint howMany);\nSmartPtr<Cassette> funMusic(new Cassette(\"Alapalooza\"));\nSmartPtr<CD> nightmareMusic(new CD(\"Disco Hits of the 70s\"));\ndisplayAndPlay(funMusic, 10);\n// used to be an error\ndisplayAndPlay(nightmareMusic, 0);\n// used to be an error\nWith the revised smart pointer class containing the member function\ntemplate for implicit type conversion operators, this code will succeed.\nTo see why, look at this call:\ndisplayAndPlay(funMusic, 10);\nThe object funMusic is of type SmartPtr<Cassette>. The function\ndisplayAndPlay expects a SmartPtr<MusicProduct> object. Com-\npilers detect the type mismatch and seek a way to convert funMusic\ninto a SmartPtr<MusicProduct> object. They look for a single-argu-\nment constructor (see Item 5) in the SmartPtr<MusicProduct> class\nthat takes a SmartPtr<Cassette>, but they find none. They look for\nan implicit type conversion operator in the SmartPtr<Cassette> class\nthat yields a SmartPtr<MusicProduct> class, but that search also\nfails. They then look for a member function template they can instan-\ntiate to yield one of these functions. They discover that the template in-\nside SmartPtr<Cassette>, when instantiated with newType bound to\nMusicProduct, generates the necessary function. They instantiate the\nfunction, yielding the following code:\nSmartPtr<Cassette>::operator SmartPtr<MusicProduct>()\n{\nreturn SmartPtr<MusicProduct>(pointee);\n}\nWill this compile? For all intents and purposes, nothing is happening\nhere except the calling of the SmartPtr<MusicProduct> constructor\nwith pointee as its argument, so the real question is whether one can\nconstruct a SmartPtr<MusicProduct> object with a Cassette*\npointer. The SmartPtr<MusicProduct> constructor expects a Mu-\nsicProduct* pointer, but now we’re on the familiar ground of conver-\nsions between dumb pointer types, and it’s clear that Cassette* can\nbe passed in where a MusicProduct* is expected. The construction of\nthe SmartPtr<MusicProduct> is therefore successful, and the con-\nversion of the SmartPtr<Cassette> to SmartPtr<MusicProduct> is\nequally successful. Voilà! Implicit conversion of smart pointer types.\nWhat could be simpler?\nFurthermore, what could be more powerful? Don’t be misled by this\nexample into assuming that this works only for pointer conversions up\nan inheritance hierarchy. The method shown succeeds for any legal\n",
      "content_length": 2418,
      "extraction_method": "Direct"
    },
    {
      "page_number": 195,
      "chapter": null,
      "content": "178\nItem 28\nimplicit conversion between pointer types. If you’ve got a dumb pointer\ntype T1* and another dumb pointer type T2*, you can implicitly con-\nvert a smart pointer-to-T1 to a smart pointer-to-T2 if and only if you\ncan implicitly convert a T1* to a T2*.\nThis technique gives you exactly the behavior you want — almost. Sup-\npose we augment our MusicProduct hierarchy with a new class,\nCasSingle, for representing cassette singles. The revised hierarchy\nlooks like this:\nNow consider this code:\ntemplate<class T>\n// as above, including member tem-\nclass SmartPtr { ... };\n// plate for conversion operators\nvoid displayAndPlay(const SmartPtr<MusicProduct>& pmp,\nint howMany);\nvoid displayAndPlay(const SmartPtr<Cassette>& pc,\nint howMany);\nSmartPtr<CasSingle> dumbMusic(new CasSingle(\"Achy Breaky Heart\"));\ndisplayAndPlay(dumbMusic, 1);\n// error!\nIn this example, displayAndPlay is overloaded, with one function\ntaking a SmartPtr<MusicProduct> object and the other taking a\nSmartPtr<Cassette> object. When we invoke displayAndPlay with\na SmartPtr<CasSingle>, we expect the SmartPtr<Cassette> func-\ntion to be chosen, because CasSingle inherits directly from Cassette\nand only indirectly from MusicProduct. Certainly that’s how it would\nwork with dumb pointers. Alas, our smart pointers aren’t that smart.\nThey employ member functions as conversion operators, and as far as\nC++ compilers are concerned, all calls to conversion functions are\nequally good. As a result, the call to displayAndPlay is ambiguous,\nbecause the conversion from SmartPtr<CasSingle> to\nMusicProduct\nCasSingle\nCD\nCassette\n",
      "content_length": 1600,
      "extraction_method": "Direct"
    },
    {
      "page_number": 196,
      "chapter": null,
      "content": "Smart Pointers\n179\nSmartPtr<Cassette> is no better than the conversion to\nSmartPtr<MusicProduct>.\nImplementing smart pointer conversions through member templates\nhas two additional drawbacks. First, support for member templates is\nrare, so this technique is currently anything but portable. In the fu-\nture, that will change, but nobody knows just how far in the future\nthat will be. Second, the mechanics of why this works are far from\ntransparent, relying as they do on a detailed understanding of argu-\nment-matching rules for function calls, implicit type conversion func-\ntions, implicit instantiation of template functions, and the existence of\nmember function templates. Pity the poor programmer who has never\nseen this trick before and is then asked to maintain or enhance code\nthat relies on it. The technique is clever, that’s for sure, but too much\ncleverness can be a dangerous thing.\nLet’s stop beating around the bush. What we really want to know is\nhow we can make smart pointer classes behave just like dumb point-\ners for purposes of inheritance-based type conversions. The answer is\nsimple: we can’t. As Daniel Edelson has noted, smart pointers are\nsmart, but they’re not pointers. The best we can do is to use member\ntemplates to generate conversion functions, then use casts (see Item 2)\nin those cases where ambiguity results. This isn’t a perfect state of af-\nfairs, but it’s pretty good, and having to cast away ambiguity in a few\ncases is a small price to pay for the sophisticated functionality smart\npointers can provide.\nSmart Pointers and const\nRecall that for dumb pointers, const can refer to the thing pointed to,\nto the pointer itself, or both:\nCD goodCD(\"Flood\");\nconst CD *p;\n// p is a non-const pointer\n// to a const CD object\nCD * const p = &goodCD;\n// p is a const pointer to \n// a non-const CD object;\n// because p is const, it\n// must be initialized\nconst CD * const p = &goodCD;\n// p is a const pointer to\n// a const CD object\nNaturally, we’d like to have the same flexibility with smart pointers.\nUnfortunately, there’s only one place to put the const, and there it ap-\nplies to the pointer, not to the object pointed to:\nconst SmartPtr<CD> p =\n// p is a const smart ptr\n&goodCD;\n// to a non-const CD object\n",
      "content_length": 2249,
      "extraction_method": "Direct"
    },
    {
      "page_number": 197,
      "chapter": null,
      "content": "180\nItem 28\nThis seems simple enough to remedy — just create a smart pointer to\na const CD:\nSmartPtr<const CD> p =\n// p is a non-const smart ptr\n&goodCD;\n// to a const CD object\nNow we can create the four combinations of const and non-const ob-\njects and pointers we seek:\nSmartPtr<CD> p;\n// non-const object, \n// non-const pointer\nSmartPtr<const CD> p;\n// const object,\n// non-const pointer\nconst SmartPtr<CD> p = &goodCD;\n// non-const object,\n// const pointer\nconst SmartPtr<const CD> p = &goodCD; // const object,\n// const pointer\nAlas, this ointment has a fly in it. Using dumb pointers, we can initial-\nize const pointers with non-const pointers and we can initialize\npointers to const objects with pointers to non-consts; the rules for\nassignments are analogous. For example:\nCD *pCD = new CD(\"Famous Movie Themes\");\nconst CD * pConstCD = pCD;\n// fine\nBut look what happens if we try the same thing with smart pointers:\nSmartPtr<CD> pCD = new CD(\"Famous Movie Themes\");\nSmartPtr<const CD> pConstCD = pCD;\n// fine?\nSmartPtr<CD> and SmartPtr<const CD> are completely different\ntypes. As far as your compilers know, they are unrelated, so they have\nno reason to believe they are assignment-compatible. In what must be\nan old story by now, the only way these two types will be considered\nassignment-compatible is if you’ve provided a function to convert ob-\njects of type SmartPtr<CD> to objects of type SmartPtr<const CD>. If\nyou’ve got a compiler that supports member templates, you can use\nthe technique shown above for automatically generating the implicit\ntype conversion operators you need. (I remarked earlier that the tech-\nnique worked anytime the corresponding conversion for dumb pointers\nwould work, and I wasn’t kidding. Conversions involving const are no\nexception.) If you don’t have such a compiler, you have to jump\nthrough one more hoop.\nConversions involving const are a one-way street: it’s safe to go from\nnon-const to const, but it’s not safe to go from const to non-const.\nFurthermore, anything you can do with a const pointer you can do\nwith a non-const pointer, but with non-const pointers you can do\n",
      "content_length": 2128,
      "extraction_method": "Direct"
    },
    {
      "page_number": 198,
      "chapter": null,
      "content": "Smart Pointers\n181\nother things, too (for example, assignment). Similarly, anything you\ncan do with a pointer-to-const is legal for a pointer-to-non-const, but\nyou can do some things (such as assignment) with pointers-to-non-\nconsts that you can’t do with pointers-to-consts.\nThese rules sound like the rules for public inheritance. You can con-\nvert from a derived class object to a base class object, but not vice\nversa, and you can do anything to a derived class object you can do to\na base class object, but you can typically do additional things to a de-\nrived class object, as well. We can take advantage of this similarity\nwhen implementing smart pointers by having each smart pointer-to-T\nclass publicly inherit from a corresponding smart pointer-to-const-T\nclass:\ntemplate<class T>\n// smart pointers to const\nclass SmartPtrToConst {\n// objects\n...\n// the usual smart pointer\n// member functions\nprotected:\nunion {\nconst T* constPointee;\n// for SmartPtrToConst access\nT* pointee;\n// for SmartPtr access\n};\n};\ntemplate<class T>\n// smart pointers to\nclass SmartPtr:\n// non-const objects\npublic SmartPtrToConst<T> {\n...\n// no data members\n};\nWith this design, the smart pointer-to-non-const-T object needs to\ncontain a dumb pointer-to-non-const-T, and the smart pointer-to-\nconst-T needs to contain a dumb pointer-to-const-T. The naive way\nto handle this would be to put a dumb pointer-to-const-T in the base\nSmart\nSmart\npointer-to-const-T\npointer-to-non-const-T\n",
      "content_length": 1468,
      "extraction_method": "Direct"
    },
    {
      "page_number": 199,
      "chapter": null,
      "content": "182\nItem 28\nclass and a dumb pointer-to-non-const-T in the derived class. That\nwould be wasteful, however, because SmartPtr objects would contain\ntwo dumb pointers: the one they inherited from SmartPtrToConst and\nthe one in SmartPtr itself. \nThis problem is resolved by employing that old battle axe of the C\nworld, a union, which can be as useful in C++ as it is in C. The union\nis protected, so both classes have access to it, and it contains both of\nthe necessary dumb pointer types. SmartPtrToConst<T> objects use\nthe constPointee pointer, SmartPtr<T> objects use the pointee\npointer. We therefore get the advantages of two different pointers with-\nout having to allocate space for more than one. Such is the beauty of a\nunion. Of course, the member functions of the two classes must con-\nstrain themselves to using only the appropriate pointer, and you’ll get\nno help from compilers in enforcing that constraint. Such is the risk of\na union.\nWith this new design, we get the behavior we want:\nSmartPtr<CD> pCD = new CD(\"Famous Movie Themes\");\nSmartPtrToConst<CD> pConstCD = pCD;\n// fine\nEvaluation\nThat wraps up the subject of smart pointers, but before we leave the\ntopic, we should ask this question: are they worth the trouble, espe-\ncially if your compilers lack support for member function templates?\nOften they are. The reference-counting code of Item 29, for example, is\ngreatly simplified by using smart pointers. Furthermore, as that exam-\nple demonstrates, some uses of smart pointers are sufficiently limited\nin scope that things like testing for nullness, conversion to dumb\npointers, inheritance-based conversions, and support for pointers-to-\nconsts are irrelevant. At the same time, smart pointers can be tricky\nto implement, understand, and maintain. Debugging code using smart\npointers is more difficult than debugging code using dumb pointers.\nTry as you may, you will never succeed in designing a general-purpose\nsmart pointer that can seamlessly replace its dumb pointer counter-\npart.\nSmart pointers nevertheless make it possible to achieve effects in your\ncode that would otherwise be difficult to implement. Smart pointers\nshould be used judiciously, but every C++ programmer will find them\nuseful at one time or another.\n",
      "content_length": 2250,
      "extraction_method": "Direct"
    },
    {
      "page_number": 200,
      "chapter": null,
      "content": "Reference Counting\n183\nItem 29: Reference counting.\nReference Counting\nReference counting is a technique that allows multiple objects with the\nsame value to share a single representation of that value. There are\ntwo common motivations for the technique. The first is to simplify the\nbookkeeping surrounding heap objects. Once an object is allocated by\ncalling new, it’s crucial to keep track of who owns that object, because\nthe owner — and only the owner — is responsible for calling delete on\nit. But ownership can be transferred from object to object as a program\nruns (by passing pointers as parameters, for example), so keeping\ntrack of an object’s ownership is hard work. Classes like auto_ptr (see\nItem 9) can help with this task, but experience has shown that most\nprograms still fail to get it right. Reference counting eliminates the\nburden of tracking object ownership, because when an object employs\nreference counting, it owns itself. When nobody is using it any longer,\nit destroys itself automatically. Thus, reference counting constitutes a\nsimple form of garbage collection.\nThe second motivation for reference counting is simple common sense.\nIf many objects have the same value, it’s silly to store that value more\nthan once. Instead, it’s better to let all the objects with that value share\nits representation. Doing so not only saves memory, it also leads to\nfaster-running programs, because there’s no need to construct and de-\nstruct redundant copies of the same object value. \nLike most simple ideas, this one hovers above a sea of interesting de-\ntails. God may or may not be in the details, but successful implemen-\ntations of reference counting certainly are. Before delving into details,\nhowever, let us master basics. A good way to begin is by seeing how we\nmight come to have many objects with the same value in the first\nplace. Here’s one way:\nclass String {\n// the standard string type may\npublic:\n// employ the techniques in this\n// Item, but that is not required\nString(const char *value = \"\");\nString& operator=(const String& rhs);\n...\nprivate:\nchar *data;\n};\nString a, b, c, d, e;\na = b = c = d = e = \"Hello\";\nIt should be apparent that objects a through e all have the same value,\nnamely “Hello”. How that value is represented depends on how the\n",
      "content_length": 2283,
      "extraction_method": "Direct"
    },
    {
      "page_number": 201,
      "chapter": null,
      "content": "184\nItem 29\nString class is implemented, but a common implementation would\nhave each String object carry its own copy of the value. For example,\nString’s assignment operator might be implemented like this:\nString& String::operator=(const String& rhs)\n{\nif (this == &rhs) return *this;\ndelete [] data;\ndata = new char[strlen(rhs.data) + 1];\nstrcpy(data, rhs.data);\nreturn *this;\n}\nGiven this implementation, we can envision the five objects and their\nvalues as follows:\nThe redundancy in this approach is clear. In an ideal world, we’d like\nto change the picture to look like this:\nHere only one copy of the value “Hello” is stored, and all the String\nobjects with that value share its representation. \nIn practice, it isn’t possible to achieve this ideal, because we need to\nkeep track of how many objects are sharing a value. If object a above\nis assigned a different value from “Hello”, we can’t destroy the value\n“Hello”, because four other objects still need it. On the other hand, if\nonly a single object had the value “Hello” and that object went out of\nscope, no object would have that value and we’d have to destroy the\nvalue to avoid a resource leak.\nHello\na\nHello\nb\nHello\nc\nHello\nd\nHello\ne\na\nb\nHello\nc\nd\ne\n",
      "content_length": 1216,
      "extraction_method": "Direct"
    },
    {
      "page_number": 202,
      "chapter": null,
      "content": "Reference Counting\n185\nThe need to store information on the number of objects currently shar-\ning — referring to — a value means our ideal picture must be modified\nsomewhat to take into account the existence of a reference count:\n(Some people call this number a use count, but I am not one of them.\nC++ has enough idiosyncrasies of its own; the last thing it needs is ter-\nminological factionalism.)\nImplementing Reference Counting\nCreating a reference-counted String class isn’t difficult, but it does\nrequire attention to detail, so we’ll walk through the implementation of\nthe most common member functions of such a class. Before we do\nthat, however, it’s important to recognize that we need a place to store\nthe reference count for each String value. That place cannot be in a\nString object, because we need one reference count per string value,\nnot one reference count per string object. That implies a coupling be-\ntween values and reference counts, so we’ll create a class to store ref-\nerence counts and the values they track. We’ll call this class\nStringValue, and because its only raison d’être is to help implement\nthe String class, we’ll nest it inside String’s private section. Further-\nmore, it will be convenient to give all the member functions of String\nfull access to the StringValue data structure, so we’ll declare\nStringValue to be a struct. This is a trick worth knowing: nesting a\nstruct in the private part of a class is a convenient way to give access\nto the struct to all the members of the class, but to deny access to ev-\nerybody else (except, of course, friends of the class).\nOur basic design looks like this:\n5\na\nb\nHello\nc\nd\ne\n",
      "content_length": 1658,
      "extraction_method": "Direct"
    },
    {
      "page_number": 203,
      "chapter": null,
      "content": "186\nItem 29\nclass String {\npublic:\n...\n// the usual String member\n// functions go here\nprivate:\nstruct StringValue { ... };\n// holds a reference count\n// and a string value\nStringValue *value;\n// value of this String\n};\nWe could give this class a different name (RCString, perhaps) to em-\nphasize that it’s implemented using reference counting, but the imple-\nmentation of a class shouldn’t be of concern to clients of that class.\nRather, clients should interest themselves only in a class’s public in-\nterface. Our reference-counting implementation of the String inter-\nface supports exactly the same operations as a non-reference-counted\nversion, so why muddy the conceptual waters by embedding imple-\nmentation decisions in the names of classes that correspond to ab-\nstract concepts? Why indeed? So we don’t.\nHere’s StringValue:\nclass String {\nprivate:\nstruct StringValue {\nsize_t refCount;\nchar *data;\nStringValue(const char *initValue);\n~StringValue();\n};\n...\n};\nString::StringValue::StringValue(const char *initValue)\n: refCount(1)\n{\ndata = new char[strlen(initValue) + 1];\nstrcpy(data, initValue);\n}\nString::StringValue::~StringValue()\n{\ndelete [] data;\n}\nThat’s all there is to it, and it should be clear that’s nowhere near\nenough to implement the full functionality of a reference-counted\nstring. For one thing, there’s neither a copy constructor nor an assign-\n",
      "content_length": 1373,
      "extraction_method": "Direct"
    },
    {
      "page_number": 204,
      "chapter": null,
      "content": "Reference Counting\n187\nment operator, and for another, there’s no manipulation of the ref-\nCount field. Worry not — the missing functionality will be provided by\nthe String class. The primary purpose of StringValue is to give us a\nplace to associate a particular value with a count of the number of\nString objects sharing that value. StringValue gives us that, and\nthat’s enough.\nWe’re now ready to walk our way through String’s member functions.\nWe’ll begin with the constructors:\nclass String {\npublic:\nString(const char *initValue = \"\");\nString(const String& rhs);\n...\n};\nThe first constructor is implemented about as simply as possible. We\nuse the passed-in char* string to create a new StringValue object,\nthen we make the String object we’re constructing point to the newly-\nminted StringValue:\nString::String(const char *initValue)\n: value(new StringValue(initValue))\n{}\nFor client code that looks like this,\nString s(\"More Effective C++\");\nwe end up with a data structure that looks like this:\nString objects constructed separately, but with the same initial value\ndo not share a data structure, so client code of this form,\nString s1(\"More Effective C++\");\nString s2(\"More Effective C++\");\nyields this data structure:\nIt is possible to eliminate such duplication by having String (or\nStringValue) keep track of existing StringValue objects and create\nnew ones only for truly unique strings, but such refinements on refer-\nMore Effective C++\ns\n1\nMore Effective C++\ns1\n1\nMore Effective C++\ns2\n1\n",
      "content_length": 1502,
      "extraction_method": "Direct"
    },
    {
      "page_number": 205,
      "chapter": null,
      "content": "188\nItem 29\nence counting are somewhat off the beaten path. As a result, I’ll leave\nthem in the form of the feared and hated exercise for the reader.\nThe String copy constructor is not only unfeared and unhated, it’s\nalso efficient: the newly created String object shares the same\nStringValue object as the String object that’s being copied:\nString::String(const String& rhs)\n: value(rhs.value)\n{\n++value->refCount;\n}\nGraphically, code like this,\nString s1(\"More Effective C++\");\nString s2 = s1;\nresults in this data structure:\nThis is substantially more efficient than a conventional (non-reference-\ncounted) String class, because there is no need to allocate memory\nfor the second copy of the string value, no need to deallocate that mem-\nory later, and no need to copy the value that would go in that memory.\nInstead, we merely copy a pointer and increment a reference count. \nThe String destructor is also easy to implement, because most of the\ntime it doesn’t do anything. As long as the reference count for a\nStringValue is non-zero, at least one String object is using the\nvalue; it must therefore not be destroyed. Only when the String being\ndestructed is the sole user of the value — i.e., when the value’s refer-\nence count is 1 — should the String destructor destroy the\nStringValue object:\nclass String {\npublic:\n~String();\n...\n};\nString::~String()\n{\nif (--value->refCount == 0) delete value;\n}\nMore Effective C++\ns1\n2\ns2\n",
      "content_length": 1434,
      "extraction_method": "Direct"
    },
    {
      "page_number": 206,
      "chapter": null,
      "content": "Reference Counting\n189\nCompare the efficiency of this function with that of the destructor for\na non-reference-counted implementation. Such a function would al-\nways call delete and would almost certainly have a nontrivial runtime\ncost. Provided that different String objects do in fact sometimes have\nthe same values, the implementation above will sometimes do nothing\nmore than decrement a counter and compare it to zero.\nIf, at this point, the appeal of reference counting is not becoming ap-\nparent, you’re just not paying attention.\nThat’s all there is to String construction and destruction, so we’ll\nmove on to consideration of the String assignment operator:\nclass String {\npublic:\nString& operator=(const String& rhs);\n...\n};\nWhen a client writes code like this,\ns1 = s2;\n// s1 and s2 are both String objects\nthe result of the assignment should be that s1 and s2 both point to the\nsame StringValue object. That object’s reference count should there-\nfore be incremented during the assignment. Furthermore, the\nStringValue object that s1 pointed to prior to the assignment should\nhave its reference count decremented, because s1 will no longer have\nthat value. If s1 was the only String with that value, the value should\nbe destroyed. In C++, all that looks like this:\nString& String::operator=(const String& rhs)\n{\nif (value == rhs.value) {\n// do nothing if the values\nreturn *this;\n// are already the same; this\n}\n// subsumes the usual test of\n// this against &rhs\nif (--value->refCount == 0) {\n// destroy *this’s value if\ndelete value;\n// no one else is using it\n}\nvalue = rhs.value;\n// have *this share rhs’s\n++value->refCount;\n// value\nreturn *this;\n}\n",
      "content_length": 1665,
      "extraction_method": "Direct"
    },
    {
      "page_number": 207,
      "chapter": null,
      "content": "190\nItem 29\nCopy-on-Write\nTo round out our examination of reference-counted strings, consider\nan array-bracket operator ([]), which allows individual characters\nwithin strings to be read and written:\nclass String {\npublic:\nconst char&\noperator[](int index) const;\n// for const Strings\nchar& operator[](int index);\n// for non-const Strings\n...\n};\nImplementation of the const version of this function is straightfor-\nward, because it’s a read-only operation; the value of the string can’t\nbe affected:\nconst char& String::operator[](int index) const\n{\nreturn value->data[index];\n}\n(This function performs sanity checking on index in the grand C++\ntradition, which is to say not at all. As usual, if you’d like a greater de-\ngree of parameter validation, it’s easy to add.)\nThe non-const version of operator[] is a completely different story.\nThis function may be called to read a character, but it might be called\nto write one, too:\nString s;\n...\ncout << s[3];\n// this is a read\ns[5] = ’x’;\n// this is a write\nWe’d like to deal with reads and writes differently. A simple read can be\ndealt with in the same way as the const version of operator[] above,\nbut a write must be implemented in quite a different fashion. \nWhen we modify a String’s value, we have to be careful to avoid mod-\nifying the value of other String objects that happen to be sharing the\nsame StringValue object. Unfortunately, there is no way for C++\ncompilers to tell us whether a particular use of operator[] is for a\nread or a write, so we must be pessimistic and assume that all calls to\nthe non-const operator[] are for writes. (Proxy classes can help us\ndifferentiate reads from writes — see Item 30.)\nTo implement the non-const operator[] safely, we must ensure that\nno other String object shares the StringValue to be modified by the\n",
      "content_length": 1809,
      "extraction_method": "Direct"
    },
    {
      "page_number": 208,
      "chapter": null,
      "content": "Reference Counting\n191\npresumed write. In short, we must ensure that the reference count for\na String’s StringValue object is exactly one any time we return a ref-\nerence to a character inside that StringValue object. Here’s how we\ndo it:\nchar& String::operator[](int index)\n{\n// if we’re sharing a value with other String objects,\n// break off a separate copy of the value for ourselves\nif (value->refCount > 1) {\n--value->refCount;\n// decrement current value’s\n// refCount, because we won’t\n// be using that value any more\nvalue =\n// make a copy of the\nnew StringValue(value->data);\n// value for ourselves\n}\n// return a reference to a character inside our\n// unshared StringValue object\nreturn value->data[index];\n}\nThis idea — that of sharing a value with other objects until we have to\nwrite on our own copy of the value — has a long and distinguished his-\ntory in Computer Science, especially in operating systems, where pro-\ncesses are routinely allowed to share pages until they want to modify\ndata on their own copy of a page. The technique is common enough to\nhave a name: copy-on-write. It’s a specific example of a more general\napproach to efficiency, that of lazy evaluation (see Item 17).\nPointers, References, and Copy-on-Write\nThis implementation of copy-on-write allows us to preserve both effi-\nciency and correctness — almost. There is one lingering problem. Con-\nsider this code:\nString s1 = \"Hello\";\nchar *p = &s1[1];\nOur data structure at this point looks like this:\nNow consider an additional statement:\nString s2 = s1;\nHello\ns1\n1\np\n",
      "content_length": 1555,
      "extraction_method": "Direct"
    },
    {
      "page_number": 209,
      "chapter": null,
      "content": "192\nItem 29\nThe String copy constructor will make s2 share s1’s StringValue, so\nthe resulting data structure will be this one:\nThe implications of a statement such as the following, then, are not\npleasant to contemplate:\n*p = ’x’;\n// modifies both s1 and s2!\nThere is no way the String copy constructor can detect this problem,\nbecause it has no way to know that a pointer into s1’s StringValue\nobject exists. And this problem isn’t limited to pointers: it would exist\nif someone had saved a reference to the result of a call to String’s non-\nconst operator[].\nThere are at least three ways of dealing with this problem. The first is\nto ignore it, to pretend it doesn’t exist. This approach turns out to be\ndistressingly common in class libraries that implement reference-\ncounted strings. If you have access to a reference-counted string, try\nthe above example and see if you’re distressed, too. If you’re not sure if\nyou have access to a reference-counted string, try the example any-\nway. Through the wonder of encapsulation, you may be using such a\ntype without knowing it.\nNot all implementations ignore such problems. A slightly more sophis-\nticated way of dealing with such difficulties is to define them out of ex-\nistence. Implementations adopting this strategy typically put\nsomething in their documentation that says, more or less, “Don’t do\nthat. If you do, results are undefined.” If you then do it anyway — wit-\ntingly or no — and complain about the results, they respond, “Well, we\ntold you not to do that.” Such implementations are often efficient, but\nthey leave much to be desired in the usability department.\nThere is a third solution, and that’s to eliminate the problem. It’s not\ndifficult to implement, but it can reduce the amount of value sharing\nbetween objects. Its essence is this: add a flag to each StringValue\nobject indicating whether that object is shareable. Turn the flag on ini-\ntially (the object is shareable), but turn it off whenever the non-const\noperator[] is invoked on the value represented by that object. Once\nthe flag is set to false, it stays that way forever.†\n† The string type in the standard C++ library (see Item 35) uses a combination of so-\nlutions two and three. The reference returned from the non-const operator[] is\nguaranteed to be valid until the next function call that might modify the string. After\nthat, use of the reference (or the character to which it refers) yields undefined results.\nThis allows the string’s shareability flag to be reset to true whenever a function is\ncalled that might modify the string.\ns1\n2\ns2\nHello\np\n",
      "content_length": 2592,
      "extraction_method": "Direct"
    },
    {
      "page_number": 210,
      "chapter": null,
      "content": "Reference Counting\n193\nHere’s a modified version of StringValue that includes a shareability\nflag:\nclass String {\nprivate:\nstruct StringValue {\nsize_t refCount;\nbool shareable;\n// add this\nchar *data;\nStringValue(const char *initValue);\n~StringValue();\n};\n...\n};\nString::StringValue::StringValue(const char *initValue)\n: refCount(1),\nshareable(true)\n// add this\n{\ndata = new char[strlen(initValue) + 1];\nstrcpy(data, initValue);\n}\nString::StringValue::~StringValue()\n{\ndelete [] data;\n}\nAs you can see, not much needs to change; the two lines that require\nmodification are flagged with comments. Of course, String’s member\nfunctions must be updated to take the shareable field into account.\nHere’s how the copy constructor would do that:\nString::String(const String& rhs)\n{\nif (rhs.value->shareable) {\nvalue = rhs.value;\n++value->refCount;\n}\nelse {\nvalue = new StringValue(rhs.value->data);\n}\n}\nAll the other String member functions would have to check the\nshareable field in an analogous fashion. The non-const version of\noperator[] would be the only function to set the shareable flag to\nfalse:\n",
      "content_length": 1097,
      "extraction_method": "Direct"
    },
    {
      "page_number": 211,
      "chapter": null,
      "content": "194\nItem 29\nchar& String::operator[](int index)\n{\nif (value->refCount > 1) {\n--value->refCount;\nvalue = new StringValue(value->data);\n}\nvalue->shareable = false;\n// add this\nreturn value->data[index];\n}\nIf you use the proxy class technique of Item 30 to distinguish read\nusage from write usage in operator[], you can usually reduce the\nnumber of StringValue objects that must be marked unshareable.\nA Reference-Counting Base Class\nReference counting is useful for more than just strings. Any class in\nwhich different objects may have values in common is a legitimate can-\ndidate for reference counting. Rewriting a class to take advantage of\nreference counting can be a lot of work, however, and most of us al-\nready have more than enough to do. Wouldn’t it be nice if we could\nsomehow write (and test and document) the reference counting code in\na context-independent manner, then just graft it onto classes when\nneeded? Of course it would. In a curious twist of fate, there’s a way to\ndo it (or at least to do most of it).\nThe first step is to create a base class, RCObject, for reference-counted\nobjects. Any class wishing to take advantage of automatic reference\ncounting must inherit from this class. RCObject encapsulates the ref-\nerence count itself, as well as functions for incrementing and decre-\nmenting that count. It also contains the code for destroying a value\nwhen it is no longer in use, i.e., when its reference count becomes 0.\nFinally, it contains a field that keeps track of whether this value is\nshareable, and it provides functions to query this value and set it to\nfalse. There is no need for a function to set the shareability field to\ntrue, because all values are shareable by default. As noted above, once\nan object has been tagged unshareable, there is no way to make it\nshareable again.\nRCObject’s class definition looks like this:\nclass RCObject {\npublic:\nRCObject();\nRCObject(const RCObject& rhs);\nRCObject& operator=(const RCObject& rhs);\nvirtual ~RCObject() = 0;\n",
      "content_length": 1996,
      "extraction_method": "Direct"
    },
    {
      "page_number": 212,
      "chapter": null,
      "content": "Reference Counting\n195\nvoid addReference();\nvoid removeReference();\nvoid markUnshareable();\nbool isShareable() const;\nbool isShared() const;\nprivate:\nsize_t refCount;\nbool shareable;\n};\nRCObjects can be created (as the base class parts of more derived ob-\njects) and destroyed; they can have new references added to them and\ncan have current references removed; their shareability status can be\nqueried and can be disabled; and they can report whether they are\ncurrently being shared. That’s all they offer. As a class encapsulating\nthe notion of being reference-countable, that’s really all we have a right\nto expect them to do. Note the tell-tale virtual destructor, a sure sign\nthis class is designed for use as a base class. Note also how the de-\nstructor is a pure virtual function, a sure sign this class is designed to\nbe used only as a base class.\nThe code to implement RCObject is, if nothing else, brief:\nRCObject::RCObject()\n: refCount(0), shareable(true) {}\nRCObject::RCObject(const RCObject&)\n: refCount(0), shareable(true) {}\nRCObject& RCObject::operator=(const RCObject&)\n{ return *this; }\nRCObject::~RCObject() {}\n// virtual dtors must always\n// be implemented, even if\n// they are pure virtual\n// and do nothing (see also\n// Item 33)\nvoid RCObject::addReference() { ++refCount; }\nvoid RCObject::removeReference()\n{ if (--refCount == 0) delete this; }\nvoid RCObject::markUnshareable()\n{ shareable = false; }\nbool RCObject::isShareable() const\n{ return shareable; }\nbool RCObject::isShared() const\n{ return refCount > 1; }\n",
      "content_length": 1538,
      "extraction_method": "Direct"
    },
    {
      "page_number": 213,
      "chapter": null,
      "content": "196\nItem 29\nCuriously, we set refCount to 0 inside both constructors. This seems\ncounterintuitive. Surely at least the creator of the new RCObject is re-\nferring to it! As it turns out, it simplifies things for the creators of\nRCObjects to set refCount to 1 themselves, so we oblige them here by\nnot getting in their way. We’ll get a chance to see the resulting code\nsimplification shortly.\nAnother curious thing is that the copy constructor always sets ref-\nCount to 0, regardless of the value of refCount for the RCObject we’re\ncopying. That’s because we’re creating a new object representing a\nvalue, and new values are always unshared and referenced only by\ntheir creator. Again, the creator is responsible for setting the refCount\nto its proper value.\nThe RCObject assignment operator looks downright subversive: it\ndoes nothing. Frankly, it’s unlikely this operator will ever be called.\nRCObject is a base class for a shared value object, and in a system\nbased on reference counting, such objects are not assigned to one an-\nother, objects pointing to them are. In our case, we don’t expect\nStringValue objects to be assigned to one another, we expect only\nString objects to be involved in assignments. In such assignments, no\nchange is made to the value of a StringValue — only the\nStringValue reference count is modified.\nNevertheless, it is conceivable that some as-yet-unwritten class might\nsomeday inherit from RCObject and might wish to allow assignment of\nreference-counted values (see Item 32). If so, RCObject’s assignment\noperator should do the right thing, and the right thing is to do nothing.\nTo see why, imagine that we wished to allow assignments between\nStringValue objects. Given StringValue objects sv1 and sv2, what\nshould happen to sv1’s and sv2’s reference counts in an assignment?\nsv1 = sv2;\n// how are sv1’s and sv2’s reference\n// counts affected?\nBefore the assignment, some number of String objects are pointing to\nsv1. That number is unchanged by the assignment, because only\nsv1’s value changes. Similarly, some number of String objects are\npointing to sv2 prior to the assignment, and after the assignment, ex-\nactly the same String objects point to sv2. sv2’s reference count is\nalso unchanged. When RCObjects are involved in an assignment,\nthen, the number of objects pointing to those objects is unaffected,\nhence RCObject::operator= should change no reference counts.\nThat’s exactly what the implementation above does. Counterintuitive?\nPerhaps, but it’s still correct.\nThe code for RCObject::removeReference is responsible not only for\ndecrementing the object’s refCount, but also for destroying the object\n",
      "content_length": 2646,
      "extraction_method": "Direct"
    },
    {
      "page_number": 214,
      "chapter": null,
      "content": "Reference Counting\n197\nif the new value of refCount is 0. It accomplishes this latter task by\ndeleteing this, which, as Item 27 explains, is safe only if we know\nthat *this is a heap object. For this class to be successful, we must\nengineer things so that RCObjects can be created only on the heap.\nGeneral approaches to achieving that end are discussed in Item 27,\nbut the specific measures we’ll employ in this case are described at the\nconclusion of this Item.\nTo take advantage of our new reference-counting base class, we modify\nStringValue to inherit its reference counting capabilities from RCOb-\nject:\nclass String {\nprivate:\nstruct StringValue: public RCObject {\nchar *data;\nStringValue(const char *initValue);\n~StringValue();\n};\n...\n};\nString::StringValue::StringValue(const char *initValue)\n{\ndata = new char[strlen(initValue) + 1];\nstrcpy(data, initValue);\n}\nString::StringValue::~StringValue()\n{\ndelete [] data;\n}\nThis version of StringValue is almost identical to the one we saw ear-\nlier. The only thing that’s changed is that StringValue’s member\nfunctions no longer manipulate the refCount field. RCObject now\nhandles what they used to do. \nDon’t feel bad if you blanched at the sight of a nested class\n(StringValue) inheriting from a class (RCObject) that’s unrelated to\nthe nesting class (String). It looks weird to everybody at first, but it’s\nperfectly kosher. A nested class is just as much a class as any other,\nso it has the freedom to inherit from whatever other classes it likes. In\ntime, you won’t think twice about such inheritance relationships.\n",
      "content_length": 1575,
      "extraction_method": "Direct"
    },
    {
      "page_number": 215,
      "chapter": null,
      "content": "198\nItem 29\nAutomating Reference Count Manipulations\nThe RCObject class gives us a place to store a reference count, and it\ngives us member functions through which that reference count can be\nmanipulated, but the calls to those functions must still be manually\ninserted in other classes. It is still up to the String copy constructor\nand the String assignment operator to call addReference and re-\nmoveReference on StringValue objects. This is clumsy. We’d like to\nmove those calls out into a reusable class, too, thus freeing authors of\nclasses like String from worrying about any of the details of reference\ncounting. Can it be done? Isn’t C++ supposed to support reuse?\nIt can, and it does. There’s no easy way to arrange things so that all ref-\nerence-counting considerations can be moved out of application\nclasses, but there is a way to eliminate most of them for most classes.\n(In some application classes, you can eliminate all reference-counting\ncode, but our String class, alas, isn’t one of them. One member func-\ntion spoils the party, and I suspect you won’t be too surprised to hear\nit’s our old nemesis, the non-const version of operator[]. Take\nheart, however; we’ll tame that miscreant in the end.)\nNotice that each String object contains a pointer to the StringValue\nobject representing that String’s value:\nclass String {\nprivate:\nstruct StringValue: public RCObject { ... };\nStringValue *value;\n// value of this String\n...\n};\nWe have to manipulate the refCount field of the StringValue object\nanytime anything interesting happens to one of the pointers pointing\nto it. “Interesting happenings” include copying a pointer, reassigning\none, and destroying one. If we could somehow make the pointer itself\ndetect these happenings and automatically perform the necessary ma-\nnipulations of the refCount field, we’d be home free. Unfortunately,\npointers are rather dense creatures, and the chances of them detecting\nanything, much less automatically reacting to things they detect, are\npretty slim. Fortunately, there’s a way to smarten them up: replace\nthem with objects that act like pointers, but that do more.\nSuch objects are called smart pointers, and you can read about them\nin more detail than you probably care to in Item 28. For our purposes\nhere, it’s enough to know that smart pointer objects support the mem-\nber selection (->) and dereferencing (*) operations, just like real point-\ners (which, in this context, are generally referred to as dumb pointers),\n",
      "content_length": 2485,
      "extraction_method": "Direct"
    },
    {
      "page_number": 216,
      "chapter": null,
      "content": "Reference Counting\n199\nand, like dumb pointers, they are strongly typed: you can’t make a\nsmart pointer-to-T point to an object that isn’t of type T. \nHere’s a template for objects that act as smart pointers to reference-\ncounted objects:\n// template class for smart pointers-to-T objects. T must\n// support the RCObject interface, typically by inheriting\n// from RCObject\ntemplate<class T>\nclass RCPtr {\npublic:\nRCPtr(T* realPtr = 0);\nRCPtr(const RCPtr& rhs);\n~RCPtr();\nRCPtr& operator=(const RCPtr& rhs);\nT* operator->() const;\n// see Item 28\nT& operator*() const; \n// see Item 28\nprivate:\nT *pointee;\n// dumb pointer this\n// object is emulating\nvoid init();\n// common initialization \n};\n// code\nThis template gives smart pointer objects control over what happens\nduring their construction, assignment, and destruction. When such\nevents occur, these objects can automatically perform the appropriate\nmanipulations of the refCount field in the objects to which they point. \nFor example, when an RCPtr is created, the object it points to needs to\nhave its reference count increased. There’s no need to burden applica-\ntion developers with the requirement to tend to this irksome detail\nmanually, because RCPtr constructors can handle it themselves. The\ncode in the two constructors is all but identical — only the member ini-\ntialization lists differ — so rather than write it twice, we put it in a pri-\nvate member function called init and have both constructors call\nthat:\ntemplate<class T>\nRCPtr<T>::RCPtr(T* realPtr): pointee(realPtr)\n{\ninit();\n}\ntemplate<class T>\nRCPtr<T>::RCPtr(const RCPtr& rhs): pointee(rhs.pointee)\n{\ninit();\n}\n",
      "content_length": 1637,
      "extraction_method": "Direct"
    },
    {
      "page_number": 217,
      "chapter": null,
      "content": "200\nItem 29\ntemplate<class T>\nvoid RCPtr<T>::init()\n{\nif (pointee == 0) {\n// if the dumb pointer is\nreturn;\n// null, so is the smart one\n}\nif (pointee->isShareable() == false) {\n// if the value\npointee = new T(*pointee);\n// isn’t shareable,\n}\n// copy it\npointee->addReference();\n// note that there is now a\n}\n// new reference to the value\nMoving common code into a separate function like init is exemplary\nsoftware engineering, but its luster dims when, as in this case, the\nfunction doesn’t behave correctly. \nThe problem is this. When init needs to create a new copy of a value\n(because the existing copy isn’t shareable), it executes the following\ncode:\npointee = new T(*pointee);\nThe type of pointee is pointer-to-T, so this statement creates a new T\nobject and initializes it by calling T’s copy constructor. In the case of an\nRCPtr in the String class, T will be String::StringValue, so the\nstatement above will call String::StringValue’s copy constructor.\nWe haven’t declared a copy constructor for that class, however, so our\ncompilers will generate one for us. The copy constructor so generated\nwill, in accordance with the rules for automatically generated copy\nconstructors in C++, copy only StringValue’s data pointer; it will not\ncopy the char* string data points to. Such behavior is disastrous in\nnearly any class (not just reference-counted classes), and that’s why\nyou should get into the habit of writing a copy constructor (and an as-\nsignment operator) for all your classes that contain pointers. \n",
      "content_length": 1518,
      "extraction_method": "Direct"
    },
    {
      "page_number": 218,
      "chapter": null,
      "content": "Reference Counting\n201\nThe correct behavior of the RCPtr<T> template depends on T contain-\ning a copy constructor that makes a truly independent copy (i.e., a\ndeep copy) of the value represented by T. We must augment\nStringValue with such a constructor before we can use it with the\nRCPtr class:\nclass String {\nprivate:\nstruct StringValue: public RCObject {\nStringValue(const StringValue& rhs);\n...\n};\n...\n};\nString::StringValue::StringValue(const StringValue& rhs)\n{\ndata = new char[strlen(rhs.data) + 1];\nstrcpy(data, rhs.data);\n}\nThe existence of a deep-copying copy constructor is not the only as-\nsumption RCPtr<T> makes about T. It also requires that T inherit from\nRCObject, or at least that T provide all the functionality that RCObject\ndoes. In view of the fact that RCPtr objects are designed to point only\nto reference-counted objects, this is hardly an unreasonable assump-\ntion. Nevertheless, the assumption must be documented.\nA final assumption in RCPtr<T> is that the type of the object pointed\nto is T. This seems obvious enough. After all, pointee is declared to be\nof type T*. But pointee might really point to a class derived from T.\nFor example, if we had a class SpecialStringValue that inherited\nfrom String::StringValue,\nclass String {\nprivate:\nstruct StringValue: public RCObject { ... };\nstruct SpecialStringValue: public StringValue { ... };\n...\n};\n",
      "content_length": 1376,
      "extraction_method": "Direct"
    },
    {
      "page_number": 219,
      "chapter": null,
      "content": "202\nItem 29\nwe could end up with a String containing a RCPtr<StringValue>\npointing to a SpecialStringValue object. In that case, we’d want this\npart of init,\npointee = new T(*pointee);\n// T is StringValue, but\n// pointee really points to\n// a SpecialStringValue\nto call SpecialStringValue’s copy constructor, not StringValue’s.\nWe can arrange for this to happen by using a virtual copy constructor\n(see Item 25). In the case of our String class, we don’t expect classes\nto derive from StringValue, so we’ll disregard this issue.\nWith RCPtr’s constructors out of the way, the rest of the class’s func-\ntions can be dispatched with considerably greater alacrity. Assignment\nof an RCPtr is straightforward, though the need to test whether the\nnewly assigned value is shareable complicates matters slightly. Fortu-\nnately, such complications have already been handled by the init\nfunction that was created for RCPtr’s constructors. We take advantage\nof that fact by using it again here:\ntemplate<class T>\nRCPtr<T>& RCPtr<T>::operator=(const RCPtr& rhs)\n{\nif (pointee != rhs.pointee) {\n// skip assignments\n// where the value\n// doesn’t change\nT *oldPointee = pointee;\n// save old pointee value\npointee = rhs.pointee;\n// point to new value\ninit();\n// if possible, share it\n// else make own copy\nif (oldPointee) {\noldPointee->removeReference();// remove reference to\n}\n// current value\nreturn *this;\n}\nThe destructor is easier. When an RCPtr is destroyed, it simply re-\nmoves its reference to the reference-counted object:\ntemplate<class T>\nRCPtr<T>::~RCPtr()\n{\nif (pointee) pointee->removeReference();\n}\nIf the RCPtr that just expired was the last reference to the object, that\nobject will be destroyed inside RCObject’s removeReference member\nfunction. Hence RCPtr objects never need to worry about destroying\nthe values they point to.\n",
      "content_length": 1831,
      "extraction_method": "Direct"
    },
    {
      "page_number": 220,
      "chapter": null,
      "content": "Reference Counting\n203\nFinally, RCPtr’s pointer-emulating operators are part of the smart\npointer boilerplate you can read about in Item 28:\ntemplate<class T>\nT* RCPtr<T>::operator->() const { return pointee; }\ntemplate<class T>\nT& RCPtr<T>::operator*() const { return *pointee; }\nPutting it All Together\nEnough! Finis! At long last we are in a position to put all the pieces to-\ngether and build a reference-counted String class based on the reus-\nable RCObject and RCPtr classes. With luck, you haven’t forgotten\nthat that was our original goal. \nEach reference-counted string is implemented via this data structure:\nThe classes making up this data structure are defined like this:\ntemplate<class T>\n// template class for smart\nclass RCPtr {\n// pointers-to-T objects; T\npublic:\n// must inherit from RCObject\nRCPtr(T* realPtr = 0);\nRCPtr(const RCPtr& rhs);\n~RCPtr();\nRCPtr& operator=(const RCPtr& rhs);\nT* operator->() const;\nT& operator*() const;\nprivate:\nT *pointee;\nvoid init();\n};\nString\nobject\nRCPtr\nobject\nStringValue\nobject\nRCObject\nclass\nHeap Memory\npublic\ninheritance\npointer\npointer\n",
      "content_length": 1094,
      "extraction_method": "Direct"
    },
    {
      "page_number": 221,
      "chapter": null,
      "content": "204\nItem 29\nclass RCObject {\n// base class for reference-\npublic:\n// counted objects\nRCObject();\nRCObject(const RCObject& rhs);\nRCObject& operator=(const RCObject& rhs);\nvirtual ~RCObject() = 0;\nvoid addReference();\nvoid removeReference();\nvoid markUnshareable();\nbool isShareable() const;\nbool isShared() const;\nprivate:\nsize_t refCount;\nbool shareable;\n};\nclass String {\n// class to be used by\npublic:\n// application developers\nString(const char *value = \"\");\nconst char& operator[](int index) const;\nchar& operator[](int index);\nprivate:\n// class representing string values\nstruct StringValue: public RCObject {\nchar *data;\nStringValue(const char *initValue);\nStringValue(const StringValue& rhs);\nvoid init(const char *initValue);\n~StringValue();\n};\nRCPtr<StringValue> value;\n};\nFor the most part, this is just a recap of what we’ve already developed,\nso nothing should be much of a surprise. Close examination reveals\nwe’ve added an init function to String::StringValue, but, as we’ll\nsee below, that serves the same purpose as the corresponding function\nin RCPtr: it prevents code duplication in the constructors. \nThere is a significant difference between the public interface of this\nString class and the one we used at the beginning of this Item. Where\nis the copy constructor? Where is the assignment operator? Where is\nthe destructor? Something is definitely amiss here.\n",
      "content_length": 1381,
      "extraction_method": "Direct"
    },
    {
      "page_number": 222,
      "chapter": null,
      "content": "Reference Counting\n205\nActually, no. Nothing is amiss. In fact, some things are working per-\nfectly. If you don’t see what they are, prepare yourself for a C++ epiph-\nany. \nWe don’t need those functions anymore. Sure, copying of String ob-\njects is still supported, and yes, the copying will correctly handle the\nunderlying reference-counted StringValue objects, but the String\nclass doesn’t have to provide a single line of code to make this happen.\nThat’s because the compiler-generated copy constructor for String\nwill automatically call the copy constructor for String’s RCPtr mem-\nber, and the copy constructor for that class will perform all the neces-\nsary manipulations of the StringValue object, including its reference\ncount. An RCPtr is a smart pointer, remember? We designed it to take\ncare of the details of reference counting, so that’s what it does. It also\nhandles assignment and destruction, and that’s why String doesn’t\nneed to write those functions, either. Our original goal was to move the\nunreusable reference-counting code out of our hand-written String\nclass and into context-independent classes where it would be available\nfor use with any class. Now we’ve done it (in the form of the RCObject\nand RCPtr classes), so don’t be so surprised when it suddenly starts\nworking. It’s supposed to work.\nJust so you have everything in one place, here’s the implementation of\nRCObject:\nRCObject::RCObject()\n: refCount(0), shareable(true) {}\nRCObject::RCObject(const RCObject&)\n: refCount(0), shareable(true) {}\nRCObject& RCObject::operator=(const RCObject&)\n{ return *this; }\nRCObject::~RCObject() {}\nvoid RCObject::addReference() { ++refCount; }\nvoid RCObject::removeReference()\n{ if (--refCount == 0) delete this; }\nvoid RCObject::markUnshareable()\n{ shareable = false; }\nbool RCObject::isShareable() const\n{ return shareable; }\nbool RCObject::isShared() const\n{ return refCount > 1; }\nAnd here’s the implementation of RCPtr:\n",
      "content_length": 1944,
      "extraction_method": "Direct"
    },
    {
      "page_number": 223,
      "chapter": null,
      "content": "206\nItem 29\ntemplate<class T>\nvoid RCPtr<T>::init()\n{\nif (pointee == 0) return;\nif (pointee->isShareable() == false) {\npointee = new T(*pointee);\n}\npointee->addReference();\n}\ntemplate<class T>\nRCPtr<T>::RCPtr(T* realPtr)\n: pointee(realPtr)\n{ init(); }\ntemplate<class T>\nRCPtr<T>::RCPtr(const RCPtr& rhs)\n: pointee(rhs.pointee)\n{ init(); }\ntemplate<class T>\nRCPtr<T>::~RCPtr()\n{ if (pointee) pointee->removeReference(); }\ntemplate<class T>\nRCPtr<T>& RCPtr<T>::operator=(const RCPtr& rhs)\n{\nif (pointee != rhs.pointee) {\nT *oldPointee = pointee;\npointee = rhs.pointee;\ninit();\nif (oldPointee) oldPointee->removeReference();\n}\nreturn *this;\n}\ntemplate<class T>\nT* RCPtr<T>::operator->() const { return pointee; }\ntemplate<class T>\nT& RCPtr<T>::operator*() const { return *pointee; }\nThe implementation of String::StringValue looks like this:\nvoid String::StringValue::init(const char *initValue)\n{\ndata = new char[strlen(initValue) + 1];\nstrcpy(data, initValue);\n}\nString::StringValue::StringValue(const char *initValue)\n{ init(initValue); }\n",
      "content_length": 1039,
      "extraction_method": "Direct"
    },
    {
      "page_number": 224,
      "chapter": null,
      "content": "Reference Counting\n207\nString::StringValue::StringValue(const StringValue& rhs)\n{ init(rhs.data); }\nString::StringValue::~StringValue()\n{ delete [] data; }\nUltimately, all roads lead to String, and that class is implemented\nthis way:\nString::String(const char *initValue)\n: value(new StringValue(initValue)) {}\nconst char& String::operator[](int index) const\n{ return value->data[index]; }\nchar& String::operator[](int index)\n{\nif (value->isShared()) {\nvalue = new StringValue(value->data);\n}\nvalue->markUnshareable();\nreturn value->data[index];\n}\nIf you compare the code for this String class with that we developed\nfor the String class using dumb pointers, you’ll be struck by two\nthings. First, there’s a lot less of it here than there. That’s because\nRCPtr has assumed much of the reference-counting burden that used\nto fall on String. Second, the code that remains in String is nearly\nunchanged: the smart pointer replaced the dumb pointer essentially\nseamlessly. In fact, the only changes are in operator[], where we call\nisShared instead of checking the value of refCount directly and\nwhere our use of the smart RCPtr object eliminates the need to manu-\nally manipulate the reference count during a copy-on-write.\nThis is all very nice, of course. Who can object to less code? Who can\noppose encapsulation success stories? The bottom line, however, is de-\ntermined more by the impact of this newfangled String class on its\nclients than by any of its implementation details, and it is here that\nthings really shine. If no news is good news, the news here is very good\nindeed. The String interface has not changed. We added reference\ncounting, we added the ability to mark individual string values as un-\nshareable, we moved the notion of reference countability into a new\nbase class, we added smart pointers to automate the manipulation of\nreference counts, yet not one line of client code needs to be changed.\nSure, we changed the String class definition, so clients who want to\ntake advantage of reference-counted strings must recompile and\nrelink, but their investment in code is completely and utterly pre-\nserved. You see? Encapsulation really is a wonderful thing.\n",
      "content_length": 2177,
      "extraction_method": "Direct"
    },
    {
      "page_number": 225,
      "chapter": null,
      "content": "208\nItem 29\nAdding Reference Counting to Existing Classes\nEverything we’ve discussed so far assumes we have access to the\nsource code of the classes we’re interested in. But what if we’d like to\napply the benefits of reference counting to some class Widget that’s in\na library we can’t modify? There’s no way to make Widget inherit from\nRCObject, so we can’t use smart RCPtrs with it. Are we out of luck?\nWe’re not. With some minor modifications to our design, we can add\nreference counting to any type.\nFirst, let’s consider what our design would look like if we could have\nWidget inherit from RCObject. In that case, we’d have to add a class,\nRCWidget, for clients to use, but everything would then be analogous\nto our String/StringValue example, with RCWidget playing the role\nof String and Widget playing the role of StringValue. The design\nwould look like this:\nWe can now apply the maxim that most problems in Computer Science\ncan be solved with an additional level of indirection. We add a new\nclass, CountHolder, to hold the reference count, and we have Count-\nHolder inherit from RCObject. We also have CountHolder contain a\npointer to a Widget. We then replace the smart RCPtr template with an\nequally smart RCIPtr template that knows about the existence of the\nCountHolder class. (The “I” in RCIPtr stands for “indirect.”) The mod-\nified design looks like this:\nRCWidget\nobject\nRCPtr\nobject\nWidget\nobject\nRCObject\nclass\npublic\ninheritance\npointer\nRCWidget\nRCIPtr\nobject\nRCObject\nclass\npublic\ninheritance\npointer\npointer\nWidget\nobject\nCountHolder\nobject\nobject\n",
      "content_length": 1571,
      "extraction_method": "Direct"
    },
    {
      "page_number": 226,
      "chapter": null,
      "content": "Reference Counting\n209\nJust as StringValue was an implementation detail hidden from cli-\nents of String, CountHolder is an implementation detail hidden from\nclients of RCWidget. In fact, it’s an implementation detail of RCIPtr, so\nit’s nested inside that class. RCIPtr is implemented this way:\ntemplate<class T>\nclass RCIPtr {\npublic:\nRCIPtr(T* realPtr = 0);\nRCIPtr(const RCIPtr& rhs);\n~RCIPtr();\nRCIPtr& operator=(const RCIPtr& rhs);\nT* operator->() const;\nT& operator*() const;\nRCObject& getRCObject()\n// give clients access to\n{ return *counter; }\n// isShared, etc.\nprivate:\nstruct CountHolder: public RCObject {\n~CountHolder() { delete pointee; }\nT *pointee;\n};\nCountHolder *counter;\nvoid init();\n};\ntemplate<class T>\nvoid RCIPtr<T>::init()\n{\nif (counter->isShareable() == false) {\nT *oldValue = counter->pointee;\ncounter = new CountHolder;\ncounter->pointee = oldValue ? new T(*oldValue) : 0;\n}\ncounter->addReference();\n}\ntemplate<class T>\nRCIPtr<T>::RCIPtr(T* realPtr)\n: counter(new CountHolder)\n{\ncounter->pointee = realPtr;\ninit();\n}\ntemplate<class T>\nRCIPtr<T>::RCIPtr(const RCIPtr& rhs)\n: counter(rhs.counter)\n{ init(); }\ntemplate<class T>\nRCIPtr<T>::~RCIPtr()\n{ counter->removeReference(); }\n",
      "content_length": 1202,
      "extraction_method": "Direct"
    },
    {
      "page_number": 227,
      "chapter": null,
      "content": "210\nItem 29\ntemplate<class T>\nRCIPtr<T>& RCIPtr<T>::operator=(const RCIPtr& rhs)\n{\nif (counter != rhs.counter) {\ncounter->removeReference();\ncounter = rhs.counter;\ninit();\n}\nreturn *this;\n}\ntemplate<class T>\nT* RCIPtr<T>::operator->() const\n{ return counter->pointee; }\ntemplate<class T>\nT& RCIPtr<T>::operator*() const\n{ return *(counter->pointee); }\nIf you compare this implementation with that of RCPtr, you’ll see they\nare conceptually identical. They differ only in that RCPtr objects point\nto values directly, while RCIPtr objects point to values through an in-\ntervening CountHolder object.\nGiven RCIPtr, it’s easy to implement RCWidget, because each function\nin RCWidget is implemented by forwarding the call through the under-\nlying RCIPtr to a Widget object. For example, if Widget looks like this,\nclass Widget {\npublic:\nWidget(int size);\nWidget(const Widget& rhs);\n~Widget();\n  Widget& operator=(const Widget& rhs);\n  void doThis();\nint showThat() const;\n};\nRCWidget will be defined this way:\nclass RCWidget {\npublic:\nRCWidget(int size): value(new Widget(size)) {}\n  void doThis()\n{\nif (value.getRCObject().isShared()) { // do COW if \nvalue = new Widget(*value);\n// Widget is shared\n}\nvalue->doThis();\n}\nint showThat() const { return value->showThat(); }\nprivate:\nRCIPtr<Widget> value;\n};\n",
      "content_length": 1301,
      "extraction_method": "Direct"
    },
    {
      "page_number": 228,
      "chapter": null,
      "content": "Reference Counting\n211\nNote how the RCWidget constructor calls the Widget constructor (via\nthe new operator — see Item 8) with the argument it was passed; how\nRCWidget’s doThis calls doThis in the Widget class; and how RCWid-\nget::showThat returns whatever its Widget counterpart returns. No-\ntice also how RCWidget declares no copy constructor, no assignment\noperator, and no destructor. As with the String class, there is no need\nto write these functions. Thanks to the behavior of the RCIPtr class,\nthe default versions do the right things. \nIf the thought occurs to you that creation of RCWidget is so mechani-\ncal, it could be automated, you’re right. It would not be difficult to\nwrite a program that takes a class like Widget as input and produces\na class like RCWidget as output. If you write such a program, please\nlet me know.\nEvaluation\nLet us disentangle ourselves from the details of widgets, strings, val-\nues, smart pointers, and reference-counting base classes. That gives\nus an opportunity to step back and view reference counting in a\nbroader context. In that more general context, we must address a\nhigher-level question, namely, when is reference counting an appro-\npriate technique?\nReference-counting implementations are not without cost. Each refer-\nence-counted value carries a reference count with it, and most opera-\ntions require that this reference count be examined or manipulated in\nsome way. Object values therefore require more memory, and we\nsometimes execute more code when we work with them. Furthermore,\nthe underlying source code is considerably more complex for a refer-\nence-counted class than for a less elaborate implementation. An un-\nreference-counted string class typically stands on its own, while our\nfinal String class is useless unless it’s augmented with three auxiliary\nclasses (StringValue, RCObject, and RCPtr). True, our more compli-\ncated design holds out the promise of greater efficiency when values\ncan be shared, it eliminates the need to track object ownership, and it\npromotes reusability of the reference counting idea and implementa-\ntion. Nevertheless, that quartet of classes has to be written, tested,\ndocumented, and maintained, and that’s going to be more work than\nwriting, testing, documenting, and maintaining a single class. Even a\nmanager can see that.\nReference counting is an optimization technique predicated on the as-\nsumption that objects will commonly share values (see also Item 18). If\nthis assumption fails to hold, reference counting will use more memory\nthan a more conventional implementation and it will execute more\ncode. On the other hand, if your objects do tend to have common val-\n",
      "content_length": 2672,
      "extraction_method": "Direct"
    },
    {
      "page_number": 229,
      "chapter": null,
      "content": "212\nItem 29\nues, reference counting should save you both time and space. The big-\nger your object values and the more objects that can simultaneously\nshare values, the more memory you’ll save. The more you copy and as-\nsign values between objects, the more time you’ll save. The more ex-\npensive it is to create and destroy a value, the more time you’ll save\nthere, too. In short, reference counting is most useful for improving ef-\nficiency under the following conditions:\n■Relatively few values are shared by relatively many objects.\nSuch sharing typically arises through calls to assignment opera-\ntors and copy constructors. The higher the objects/values ratio,\nthe better the case for reference counting.\n■Object values are expensive to create or destroy, or they use\nlots of memory. Even when this is the case, reference counting\nstill buys you nothing unless these values can be shared by multi-\nple objects. \nThere is only one sure way to tell whether these conditions are satis-\nfied, and that way is not to guess or rely on your programmer’s intu-\nition (see Item 16). The reliable way to find out whether your program\ncan benefit from reference counting is to profile or instrument it. That\nway you can find out if creating and destroying values is a perfor-\nmance bottleneck, and you can measure the objects/values ratio. Only\nwhen you have such data in hand are you in a position to determine\nwhether the benefits of reference counting (of which there are many)\noutweigh the disadvantages (of which there are also many).\nEven when the conditions above are satisfied, a design employing ref-\nerence counting may still be inappropriate. Some data structures (e.g.,\ndirected graphs) lead to self-referential or circular dependency struc-\ntures. Such data structures have a tendency to spawn isolated collec-\ntions of objects, used by no one, whose reference counts never drop to\nzero. That’s because each object in the unused structure is pointed to\nby at least one other object in the same structure. Industrial-strength\ngarbage collectors use special techniques to find such structures and\neliminate them, but the simple reference-counting approach we’ve ex-\namined here is not easily extended to include such techniques.\nReference counting can be attractive even if efficiency is not your pri-\nmary concern. If you find yourself weighed down with uncertainty over\nwho’s allowed to delete what, reference counting could be just the\ntechnique you need to ease your burden. Many programmers are de-\nvoted to reference counting for this reason alone.\nLet us close this discussion on a technical note by tying up one re-\nmaining loose end. When RCObject::removeReference decrements\nan object’s reference count, it checks to see if the new count is 0. If it\n",
      "content_length": 2765,
      "extraction_method": "Direct"
    },
    {
      "page_number": 230,
      "chapter": null,
      "content": "Proxy Classes\n213\nis, removeReference destroys the object by deleteing this. This is a\nsafe operation only if the object was allocated by calling new, so we\nneed some way of ensuring that RCObjects are created only in that\nmanner.\nIn this case we do it by convention. RCObject is designed for use as a\nbase class of reference-counted value objects, and those value objects\nshould be referred to only by smart RCPtr pointers. Furthermore, the\nvalue objects should be instantiated only by application objects that\nrealize values are being shared; the classes describing the value ob-\njects should never be available for general use. In our example, the\nclass for value objects is StringValue, and we limit its use by making\nit private in String. Only String can create StringValue objects, so\nit is up to the author of the String class to ensure that all such objects\nare allocated via new.\nOur approach to the constraint that RCObjects be created only on the\nheap, then, is to assign responsibility for conformance to this con-\nstraint to a well-defined set of classes and to ensure that only that set\nof classes can create RCObjects. There is no possibility that random\nclients can accidently (or maliciously) create RCObjects in an inappro-\npriate manner. We limit the right to create reference-counted objects,\nand when we do hand out the right, we make it clear that it’s accom-\npanied by the concomitant responsibility to follow the rules governing\nobject creation.\nItem 30: Proxy classes.\nProxy Classes\nThough your in-laws may be one-dimensional, the world, in general, is\nnot. Unfortunately, C++ hasn’t yet caught on to that fact. At least,\nthere’s little evidence for it in the language’s support for arrays. You\ncan create two-dimensional, three-dimensional — heck, you can create\nn-dimensional — arrays in FORTRAN, in BASIC, even in COBOL (okay,\nFORTRAN only allows up to seven dimensions, but let’s not quibble),\nbut can you do it in C++? Only sometimes, and even then only sort of.\nThis much is legal:\nint data[10][20];\n// 2D array: 10 by 20\nThe corresponding construct using variables as dimension sizes, how-\never, is not:\nvoid processInput(int dim1, int dim2)\n{\nint data[dim1][dim2];\n// error! array dimensions\n...\n// must be known during\n}\n// compilation\n",
      "content_length": 2270,
      "extraction_method": "Direct"
    },
    {
      "page_number": 231,
      "chapter": null,
      "content": "214\nItem 30\nIt’s not even legal for a heap-based allocation:\nint *data =\nnew int[dim1][dim2];\n// error!\nImplementing Two-Dimensional Arrays\nMultidimensional arrays are as useful in C++ as they are in any other\nlanguage, so it’s important to come up with a way to get decent support\nfor them. The usual way is the standard one in C++: create a class to\nrepresent the objects we need but that are missing in the language\nproper. Hence we can define a class template for two-dimensional ar-\nrays:\ntemplate<class T>\nclass Array2D {\npublic:\nArray2D(int dim1, int dim2);\n...\n};\nNow we can define the arrays we want:\nArray2D<int> data(10, 20);\n// fine\nArray2D<float> *data =\nnew Array2D<float>(10, 20);\n// fine\nvoid processInput(int dim1, int dim2)\n{\nArray2D<int> data(dim1, dim2);\n// fine\n...\n}\nUsing these array objects, however, isn’t quite as straightforward. In\nkeeping with the grand syntactic tradition of both C and C++, we’d like\nto be able to use brackets to index into our arrays,\ncout << data[3][6];\nbut how do we declare the indexing operator in Array2D to let us do\nthis?\nOur first impulse might be to declare operator[][] functions, like\nthis:\n",
      "content_length": 1152,
      "extraction_method": "Direct"
    },
    {
      "page_number": 232,
      "chapter": null,
      "content": "Proxy Classes\n215\ntemplate<class T>\nclass Array2D {\npublic:\n// declarations that won’t compile\nT& operator[][](int index1, int index2);\nconst T& operator[][](int index1, int index2) const;\n...\n};\nWe’d quickly learn to rein in such impulses, however, because there is\nno such thing as operator[][], and don’t think your compilers will\nforget it. (For a complete list of operators, overloadable and otherwise,\nsee Item 7.) We’ll have to do something else.\nIf you can stomach the syntax, you might follow the lead of the many\nprogramming languages that use parentheses to index into arrays. To\nuse parentheses, you just overload operator():\ntemplate<class T>\nclass Array2D {\npublic:\n// declarations that will compile\nT& operator()(int index1, int index2);\nconst T& operator()(int index1, int index2) const;\n...\n};\nClients then use arrays this way:\ncout << data(3, 6);\nThis is easy to implement and easy to generalize to as many dimen-\nsions as you like. The drawback is that your Array2D objects don’t\nlook like built-in arrays any more. In fact, the above access to element\n(3, 6) of data looks, on the face of it, like a function call.\nIf you reject the thought of your arrays looking like FORTRAN refu-\ngees, you might turn again to the notion of using brackets as the in-\ndexing operator. Although there is no such thing as operator[][], it\nis nonetheless legal to write code that appears to use it:\nint data[10][20];\n...\ncout << data[3][6];\n// fine\nWhat gives? \n",
      "content_length": 1464,
      "extraction_method": "Direct"
    },
    {
      "page_number": 233,
      "chapter": null,
      "content": "216\nItem 30\nWhat gives is that the variable data is not really a two-dimensional\narray at all, it’s a 10-element one-dimensional array. Each of those 10\nelements is itself a 20-element array, so the expression data[3][6]\nreally means (data[3])[6], i.e., the seventh element of the array that\nis the fourth element of data. In short, the value yielded by the first ap-\nplication of the brackets is another array, so the second application of\nthe brackets gets an element from that secondary array.\nWe can play the same game with our Array2D class by overloading op-\nerator[] to return an object of a new class, Array1D. We can then\noverload operator[] again in Array1D to return an element in our\noriginal two-dimensional array:\ntemplate<class T>\nclass Array2D {\npublic:\nclass Array1D {\npublic:\nT& operator[](int index);\nconst T& operator[](int index) const;\n...\n};\nArray1D operator[](int index);\nconst Array1D operator[](int index) const;\n...\n};\nThe following then becomes legal:\nArray2D<float> data(10, 20);\n...\ncout << data[3][6];\n// fine\nHere, data[3] yields an Array1D object and the operator[] invoca-\ntion on that object yields the float in position (3, 6) of the original two-\ndimensional array.\nClients of the Array2D class need not be aware of the presence of the\nArray1D class. Objects of this latter class stand for one-dimensional\narray objects that, conceptually, do not exist for clients of Array2D.\nSuch clients program as if they were using real, live, honest-to-Allah\ntwo-dimensional arrays. It is of no concern to Array2D clients that\nthose objects must, in order to satisfy the vagaries of C++, be syntacti-\ncally compatible with one-dimensional arrays of other one-dimen-\nsional arrays.\n",
      "content_length": 1707,
      "extraction_method": "Direct"
    },
    {
      "page_number": 234,
      "chapter": null,
      "content": "Proxy Classes\n217\nEach Array1D object stands for a one-dimensional array that is absent\nfrom the conceptual model used by clients of Array2D. Objects that\nstand for other objects are often called proxy objects, and the classes\nthat give rise to proxy objects are often called proxy classes. In this ex-\nample, Array1D is a proxy class. Its instances stand for one-dimen-\nsional arrays that, conceptually, do not exist. (The terminology for\nproxy objects and classes is far from universal; objects of such classes\nare also sometimes known as surrogates.)\nDistinguishing Reads from Writes via operator[]\nThe use of proxies to implement classes whose instances act like mul-\ntidimensional arrays is common, but proxy classes are more flexible\nthan that. Item 5, for example, shows how proxy classes can be em-\nployed to prevent single-argument constructors from being used to\nperform unwanted type conversions. Of the varied uses of proxy\nclasses, however, the most heralded is that of helping distinguish\nreads from writes through operator[].\nConsider a reference-counted string type that supports operator[].\nSuch a type is examined in detail in Item 29. If the concepts behind ref-\nerence counting have slipped your mind, it would be a good idea to fa-\nmiliarize yourself with the material in that Item now.\nA string type supporting operator[] allows clients to write code like\nthis:\nString s1, s2;\n// a string-like class; the\n// use of proxies keeps this\n// class from conforming to\n// the standard string\n...\n// interface\ncout << s1[5];\n// read s1\ns2[5] = ’x’;\n// write s2\ns1[3] = s2[8];\n// write s1, read s2\nNote that operator[] can be called in two different contexts: to read\na character or to write a character. Reads are known as rvalue usages;\nwrites are known as lvalue usages. (The terms come from the field of\ncompilers, where an lvalue goes on the left-hand side of an assignment\nand an rvalue goes on the right-hand side.) In general, using an object\nas an lvalue means using it such that it might be modified, and using\nit as an rvalue means using it such that it cannot be modified.\nWe’d like to distinguish between lvalue and rvalue usage of opera-\ntor[] because, especially for reference-counted data structures, reads\ncan be much less expensive to implement than writes. As Item 29 ex-\n",
      "content_length": 2304,
      "extraction_method": "Direct"
    },
    {
      "page_number": 235,
      "chapter": null,
      "content": "218\nItem 30\nplains, writes of reference-counted objects may involve copying an en-\ntire data structure, but reads never require more than the simple\nreturning of a value. Unfortunately, inside operator[], there is no\nway to determine the context in which the function was called; it is not\npossible to distinguish lvalue usage from rvalue usage within opera-\ntor[].\n“But wait,” you say, “we don’t need to. We can overload operator[] on\nthe basis of its constness, and that will allow us to distinguish reads\nfrom writes.” In other words, you suggest we solve our problem this\nway:\nclass String {\npublic:\nconst char& operator[](int index) const;\n// for reads\nchar& operator[](int index);\n// for writes\n...\n};\nAlas, this won’t work. Compilers choose between const and non-\nconst member functions by looking only at whether the object invok-\ning a function is const. No consideration is given to the context in\nwhich a call is made. Hence:\nString s1, s2;\n...\ncout << s1[5];\n// calls non-const operator[],\n// because s1 isn’t const\ns2[5] = ’x’;\n// also calls non-const\n// operator[]: s2 isn’t const\ns1[3] = s2[8];\n// both calls are to non-const\n// operator[], because both s1\n// and s2 are non-const objects\nOverloading operator[], then, fails to distinguish reads from writes.\nIn Item 29, we resigned ourselves to this unsatisfactory state of affairs\nand made the conservative assumption that all calls to operator[]\nwere for writes. This time we shall not give up so easily. It may be im-\npossible to distinguish lvalue from rvalue usage inside operator[],\nbut we still want to do it. We will therefore find a way. What fun is life\nif you allow yourself to be limited by the possible?\nOur approach is based on the fact that though it may be impossible to\ntell whether operator[] is being invoked in an lvalue or an rvalue\ncontext from within operator[], we can still treat reads differently\nfrom writes if we delay our lvalue-versus-rvalue actions until we see\n",
      "content_length": 1959,
      "extraction_method": "Direct"
    },
    {
      "page_number": 236,
      "chapter": null,
      "content": "Proxy Classes\n219\nhow the result of operator[] is used. All we need is a way to postpone\nour decision on whether our object is being read or written until after\noperator[] has returned. (This is an example of lazy evaluation — see\nItem 17.)\nA proxy class allows us to buy the time we need, because we can mod-\nify operator[] to return a proxy for a string character instead of a\nstring character itself. We can then wait to see how the proxy is used.\nIf it’s read, we can belatedly treat the call to operator[] as a read. If\nit’s written, we must treat the call to operator[] as a write.\nWe will see the code for this in a moment, but first it is important to\nunderstand the proxies we’ll be using. There are only three things you\ncan do with a proxy:\n■Create it, i.e., specify which string character it stands for.\n■Use it as the target of an assignment, in which case you are really\nmaking an assignment to the string character it stands for. When\nused in this way, a proxy represents an lvalue use of the string on\nwhich operator[] was invoked.\n■Use it in any other way. When used like this, a proxy represents\nan rvalue use of the string on which operator[] was invoked.\nHere are the class definitions for a reference-counted String class\nusing a proxy class to distinguish between lvalue and rvalue usages of\noperator[]:\nclass String {\n// reference-counted strings;\npublic:\n// see Item 29 for details\nclass CharProxy {\n// proxies for string chars\npublic:\nCharProxy(String& str, int index);\n// creation\nCharProxy& operator=(const CharProxy& rhs); // lvalue\nCharProxy& operator=(char c);\n// uses\noperator char() const;\n// rvalue\n// use\nprivate:\nString& theString;\n// string this proxy pertains to\nint charIndex;\n// char within that string\n// this proxy stands for\n};\n// continuation of String class \nconst CharProxy\noperator[](int index) const;\n// for const Strings\n",
      "content_length": 1869,
      "extraction_method": "Direct"
    },
    {
      "page_number": 237,
      "chapter": null,
      "content": "220\nItem 30\nCharProxy operator[](int index);\n// for non-const Strings\n...\nfriend class CharProxy;\nprivate:\nRCPtr<StringValue> value;\n};\nOther than the addition of the CharProxy class (which we’ll examine\nbelow), the only difference between this String class and the final\nString class in Item 29 is that both operator[] functions now return\nCharProxy objects. Clients of String can generally ignore this, how-\never, and program as if the operator[] functions returned characters\n(or references to characters — see Item 1) in the usual manner:\nString s1, s2;\n// reference-counted strings\n// using proxies\n...\ncout << s1[5];\n// still legal, still works\ns2[5] = ’x’;\n// also legal, also works\ns1[3] = s2[8];\n// of course it’s legal,\n// of course it works\nWhat’s interesting is not that this works. What’s interesting is how it\nworks.\nConsider first this statement:\ncout << s1[5];\nThe expression s1[5] yields a CharProxy object. No output operator\nis defined for such objects, so your compilers labor to find an implicit\ntype conversion they can apply to make the call to operator<< suc-\nceed (see Item 5). They find one: the implicit conversion from Char-\nProxy to char declared in the CharProxy class. They automatically\ninvoke this conversion operator, and the result is that the string char-\nacter represented by the CharProxy is printed. This is representative\nof the CharProxy-to-char conversion that takes place for all Char-\nProxy objects used as rvalues.\nLvalue usage is handled differently. Look again at\ns2[5] = ’x’;\nAs before, the expression s2[5] yields a CharProxy object, but this\ntime that object is the target of an assignment. Which assignment op-\nerator is invoked? The target of the assignment is a CharProxy, so the\nassignment operator that’s called is in the CharProxy class. This is\ncrucial, because inside a CharProxy assignment operator, we know\n",
      "content_length": 1867,
      "extraction_method": "Direct"
    },
    {
      "page_number": 238,
      "chapter": null,
      "content": "Proxy Classes\n221\nthat the CharProxy object being assigned to is being used as an lvalue.\nWe therefore know that the string character for which the proxy stands\nis being used as an lvalue, and we must take whatever actions are nec-\nessary to implement lvalue access for that character.\nSimilarly, the statement\ns1[3] = s2[8];\ncalls the assignment operator for two CharProxy objects, and inside\nthat operator we know the object on the left is being used as an lvalue\nand the object on the right as an rvalue.\n“Yeah, yeah, yeah,” you grumble, “show me.” Okay. Here’s the code for\nString’s operator[] functions:\nconst String::CharProxy String::operator[](int index) const\n{\nreturn CharProxy(const_cast<String&>(*this), index); \n}\nString::CharProxy String::operator[](int index)\n{\nreturn CharProxy(*this, index); \n}\nEach function just creates and returns a proxy for the requested char-\nacter. No action is taken on the character itself: we defer such action\nuntil we know whether the access is for a read or a write. \nNote that the const version of operator[] returns a const proxy. Be-\ncause CharProxy::operator= isn’t a const member function, such\nproxies can’t be used as the target of assignments. Hence neither the\nproxy returned from the const version of operator[] nor the charac-\nter for which it stands may be used as an lvalue. Conveniently enough,\nthat’s exactly the behavior we want for the const version of opera-\ntor[].\nNote also the use of a const_cast (see Item 2) on *this when creating\nthe CharProxy object that the const operator[] returns. That’s nec-\nessary to satisfy the constraints of the CharProxy constructor, which\naccepts only a non-const String. Casts are usually worrisome, but in\nthis case the CharProxy object returned by operator[] is itself\nconst, so there is no risk the String containing the character to\nwhich the proxy refers will be modified.\nEach proxy returned by an operator[] function remembers which\nstring it pertains to and, within that string, the index of the character\nit represents:\n",
      "content_length": 2030,
      "extraction_method": "Direct"
    },
    {
      "page_number": 239,
      "chapter": null,
      "content": "222\nItem 30\nString::CharProxy::CharProxy(String& str, int index)\n: theString(str), charIndex(index) {}\nConversion of a proxy to an rvalue is straightforward — we just return\na copy of the character represented by the proxy:\nString::CharProxy::operator char() const\n{\nreturn theString.value->data[charIndex];\n}\nIf you’ve forgotten the relationship among a String object, its value\nmember, and the data member it points to, you can refresh your mem-\nory by turning to Item 29. Because this function returns a character\nby value, and because C++ limits the use of such by-value returns to\nrvalue contexts only, this conversion function can be used only in\nplaces where an rvalue is legal.\nWe thus turn to implementation of CharProxy’s assignment operators,\nwhich is where we must deal with the fact that a character represented\nby a proxy is being used as the target of an assignment, i.e., as an\nlvalue. We can implement CharProxy’s conventional assignment oper-\nator as follows:\nString::CharProxy&\nString::CharProxy::operator=(const CharProxy& rhs)\n{\n// if the string is sharing a value with other String objects,\n// break off a separate copy of the value for this string only\nif (theString.value->isShared()) {\ntheString.value = new StringValue(theString.value->data);\n}\n// now make the assignment: assign the value of the char\n// represented by rhs to the char represented by *this\ntheString.value->data[charIndex] = \nrhs.theString.value->data[rhs.charIndex];\nreturn *this;\n}\nIf you compare this with the implementation of the non-const\nString::operator[] in Item 29 on page 207, you’ll see that they are\nstrikingly similar. This is to be expected. In Item 29, we pessimistically\nassumed that all invocations of the non-const operator[] were\nwrites, so we treated them as such. Here, we moved the code imple-\nmenting a write into CharProxy’s assignment operators, and that al-\nlows us to avoid paying for a write when the non-const operator[] is\nused only in an rvalue context. Note, by the way, that this function re-\nquires access to String’s private data member value. That’s why\n",
      "content_length": 2084,
      "extraction_method": "Direct"
    },
    {
      "page_number": 240,
      "chapter": null,
      "content": "Proxy Classes\n223\nCharProxy is declared a friend in the earlier class definition for\nString.\nThe second CharProxy assignment operator is almost identical:\nString::CharProxy& String::CharProxy::operator=(char c)\n{\nif (theString.value->isShared()) {\ntheString.value = new StringValue(theString.value->data);\n}\ntheString.value->data[charIndex] = c;\nreturn *this;\n}\nAs an accomplished software engineer, you would, of course, banish\nthe code duplication present in these two assignment operators to a\nprivate CharProxy member function that both would call. Aren’t you\nthe modular one?\nLimitations\nThe use of a proxy class is a nice way to distinguish lvalue and rvalue\nusage of operator[], but the technique is not without its drawbacks.\nWe’d like proxy objects to seamlessly replace the objects they stand for,\nbut this ideal is difficult to achieve. That’s because objects are used as\nlvalues in contexts other than just assignment, and using proxies in\nsuch contexts usually yields behavior different from using real objects. \nConsider again the code fragment from Item 29 that motivated our de-\ncision to add a shareability flag to each StringValue object. If\nString::operator[] returns a CharProxy instead of a char&, that\ncode will no longer compile:\nString s1 = \"Hello\";\nchar *p = &s1[1];\n// error!\nThe expression s1[1] returns a CharProxy, so the type of the expres-\nsion on the right-hand side of the “=” is CharProxy*. There is no con-\nversion from a CharProxy* to a char*, so the initialization of p fails to\ncompile. In general, taking the address of a proxy yields a different\ntype of pointer than does taking the address of a real object. \nTo eliminate this difficulty, you’ll need to overload the address-of oper-\nators for the CharProxy class:\n",
      "content_length": 1756,
      "extraction_method": "Direct"
    },
    {
      "page_number": 241,
      "chapter": null,
      "content": "224\nItem 30\nclass String {\npublic:\nclass CharProxy {\npublic:\n...\nchar * operator&();\nconst char * operator&() const;\n...\n};\n...\n};\nThese functions are easy to implement. The const function just re-\nturns a pointer to a const version of the character represented by the\nproxy:\nconst char * String::CharProxy::operator&() const\n{\nreturn &(theString.value->data[charIndex]);\n}\nThe non-const function is a bit more work, because it returns a\npointer to a character that may be modified. This is analogous to the\nbehavior of the non-const version of String::operator[] in Item 29,\nand the implementation is equally analogous:\nchar * String::CharProxy::operator&()\n{\n// make sure the character to which this function returns\n// a pointer isn’t shared by any other String objects\nif (theString.value->isShared()) {\ntheString.value = new StringValue(theString.value->data);\n}\n// we don’t know how long the pointer this function \n// returns will be kept by clients, so the StringValue\n// object can never be shared\ntheString.value->markUnshareable();\nreturn &(theString.value->data[charIndex]);\n}\nMuch of this code is common to other CharProxy member functions,\nso I know you’d encapsulate it in a private member function that all\nwould call.\nA second difference between chars and the CharProxys that stand for\nthem becomes apparent if we have a template for reference-counted\narrays that use proxy classes to distinguish lvalue and rvalue invoca-\ntions of operator[]:\n",
      "content_length": 1460,
      "extraction_method": "Direct"
    },
    {
      "page_number": 242,
      "chapter": null,
      "content": "Proxy Classes\n225\ntemplate<class T>\n// reference-counted array\nclass Array {\n// using proxies\npublic:\nclass Proxy {\npublic:\nProxy(Array<T>& array, int index);\nProxy& operator=(const T& rhs);\noperator T() const;\n...\n};\nconst Proxy operator[](int index) const;\nProxy operator[](int index);\n...\n};\nConsider how these arrays might be used:\nArray<int> intArray;\n...\nintArray[5] = 22;\n// fine\nintArray[5] += 5;\n// error!\n++intArray[5];\n// error!\nAs expected, use of operator[] as the target of a simple assignment\nsucceeds, but use of operator[] on the left-hand side of a call to op-\nerator+= or operator++ fails. That’s because operator[] returns a\nproxy, and there is no operator+= or operator++ for Proxy objects.\nA similar situation exists for other operators that require lvalues, in-\ncluding operator*=, operator<<=, operator--, etc. If you want\nthese operators to work with operator[] functions that return prox-\nies, you must define each of these functions for the Array<T>::Proxy\nclass. That’s a lot of work, and you probably don’t want to do it. Unfor-\ntunately, you either do the work or you do without. Them’s the breaks.\nA related problem has to do with invoking member functions on real\nobjects through proxies. To be blunt about it, you can’t. For example,\nsuppose we’d like to work with reference-counted arrays of rational\nnumbers. We could define a class Rational and then use the Array\ntemplate we just saw:\nclass Rational {\npublic:\nRational(int numerator = 0, int denominator = 1);\nint numerator() const;\nint denominator() const;\n...\n};\nArray<Rational> array;\n",
      "content_length": 1575,
      "extraction_method": "Direct"
    },
    {
      "page_number": 243,
      "chapter": null,
      "content": "226\nItem 30\nThis is how we’d expect to be able to use such arrays, but, alas, we’d\nbe disappointed:\ncout << array[4].numerator();\n// error!\nint denom = array[22].denominator(); \n// error!\nBy now the difficulty is predictable; operator[] returns a proxy for a\nrational number, not an actual Rational object. But the numerator\nand denominator member functions exist only for Rationals, not\ntheir proxies. Hence the complaints by your compilers. To make prox-\nies behave like the objects they stand for, you must overload each\nfunction applicable to the real objects so it applies to proxies, too. \nYet another situation in which proxies fail to replace real objects is\nwhen being passed to functions that take references to non-const ob-\njects:\nvoid swap(char& a, char& b);\n// swaps the value of a and b\nString s = \"+C+\";\n// oops, should be \"C++\"\nswap(s[0], s[1]);\n// this should fix the\n// problem, but it won’t\n// compile\nString::operator[] returns a CharProxy, but swap demands that its\narguments be of type char&. A CharProxy may be implicitly converted\ninto a char, but there is no conversion function to a char&. Further-\nmore, the char to which it may be converted can’t be bound to swap’s\nchar& parameters, because that char is a temporary object (it’s oper-\nator char’s return value) and, as Item 19 explains, there are good rea-\nsons for refusing to bind temporary objects to non-const reference\nparameters.\nA final way in which proxies fail to seamlessly replace real objects has\nto do with implicit type conversions. When a proxy object is implicitly\nconverted into the real object it stands for, a user-defined conversion\nfunction is invoked. For instance, a CharProxy can be converted into\nthe char it stands for by calling operator char. As Item 5 explains,\ncompilers may use only one user-defined conversion function when\nconverting a parameter at a call site into the type needed by the corre-\nsponding function parameter. As a result, it is possible for function\ncalls that succeed when passed real objects to fail when passed prox-\nies. For example, suppose we have a TVStation class and a function,\nwatchTV:\nclass TVStation {\npublic:\nTVStation(int channel);\n...\n};\n",
      "content_length": 2183,
      "extraction_method": "Direct"
    },
    {
      "page_number": 244,
      "chapter": null,
      "content": "Proxy Classes\n227\nvoid watchTV(const TVStation& station, float hoursToWatch);\nThanks to implicit type conversion from int to TVStation (see Item 5),\nwe could then do this:\nwatchTV(10, 2.5);\n// watch channel 10 for\n// 2.5 hours\nUsing the template for reference-counted arrays that use proxy classes\nto distinguish lvalue and rvalue invocations of operator[], however,\nwe could not do this:\nArray<int> intArray;\nintArray[4] = 10;\nwatchTV(intArray[4], 2.5);\n// error! no conversion\n// from Proxy<int> to\n// TVStation\nGiven the problems that accompany implicit type conversions, it’s\nhard to get too choked up about this. In fact, a better design for the\nTVStation class would declare its constructor explicit, in which\ncase even the first call to watchTV would fail to compile. For all the de-\ntails on implicit type conversions and how explicit affects them, see\nItem 5.\nEvaluation\nProxy classes allow you to achieve some types of behavior that are oth-\nerwise difficult or impossible to implement. Multidimensional arrays\nare one example, lvalue/rvalue differentiation is a second, suppression\nof implicit conversions (see Item 5) is a third. \nAt the same time, proxy classes have disadvantages. As function re-\nturn values, proxy objects are temporaries (see Item 19), so they must\nbe created and destroyed. That’s not free, though the cost may be more\nthan recouped through their ability to distinguish write operations\nfrom read operations. The very existence of proxy classes increases the\ncomplexity of software systems that employ them, because additional\nclasses make things harder to design, implement, understand, and\nmaintain, not easier. \nFinally, shifting from a class that works with real objects to a class that\nworks with proxies often changes the semantics of the class, because\nproxy objects usually exhibit behavior that is subtly different from that\nof the real objects they represent. Sometimes this makes proxies a\npoor choice when designing a system, but in many cases there is little\nneed for the operations that would make the presence of proxies ap-\nparent to clients. For instance, few clients will want to take the address\n",
      "content_length": 2149,
      "extraction_method": "Direct"
    },
    {
      "page_number": 245,
      "chapter": null,
      "content": "228\nItem 31\nof an Array1D object in the two-dimensional array example we saw at\nthe beginning of this Item, and there isn’t much chance that an Ar-\nraySize object (see Item 5) would be passed to a function expecting a\ndifferent type. In many cases, proxies can stand in for real objects per-\nfectly acceptably. When they can, it is often the case that nothing else\nwill do.\nItem 31: Making functions virtual with respect to \nmore than one object.\nImplementing Multiple Dispatch\nSometimes, to borrow a phrase from Jacqueline Susann, once is not\nenough. Suppose, for example, you’re bucking for one of those high-\nprofile, high-prestige, high-paying programming jobs at that famous\nsoftware company in Redmond, Washington — by which of course I\nmean Nintendo. To bring yourself to the attention of Nintendo’s man-\nagement, you might decide to write a video game. Such a game might\ntake place in outer space and involve space ships, space stations, and\nasteroids.\nAs the ships, stations, and asteroids whiz around in your artificial\nworld, they naturally run the risk of colliding with one another. Let’s\nassume the rules for such collisions are as follows:\n■If a ship and a station collide at low velocity, the ship docks at the\nstation. Otherwise the ship and the station sustain damage that’s\nproportional to the speed at which they collide.\n■If a ship and a ship or a station and a station collide, both partici-\npants in the collision sustain damage that’s proportional to the\nspeed at which they hit.\n■If a small asteroid collides with a ship or a station, the asteroid is\ndestroyed. If it’s a big asteroid, the ship or the station is destroyed.\n■If an asteroid collides with another asteroid, both break into\npieces and scatter little baby asteroids in all directions.\nThis may sound like a dull game, but it suffices for our purpose here,\nwhich is to consider how to structure the C++ code that handles colli-\nsions between objects.\nWe begin by noting that ships, stations, and asteroids share some\ncommon features. If nothing else, they’re all in motion, so they all have\na velocity that describes that motion. Given this commonality, it is nat-\nural to define a base class from which they all inherit. In practice, such\na class is almost invariably an abstract base class, and, if you heed the\n",
      "content_length": 2301,
      "extraction_method": "Direct"
    },
    {
      "page_number": 246,
      "chapter": null,
      "content": "Implementing Multiple Dispatch\n229\nwarning I give in Item 33, base classes are always abstract. The hier-\narchy might therefore look like this:\nclass GameObject { ... };\nclass SpaceShip: public GameObject { ... };\nclass SpaceStation: public GameObject { ... };\nclass Asteroid: public GameObject { ... };\nNow, suppose you’re deep in the bowels of your program, writing the\ncode to check for and handle object collisions. You might come up with\na function that looks something like this:\nvoid checkForCollision(GameObject& object1,\nGameObject& object2)\n{\nif (theyJustCollided(object1, object2)) {\nprocessCollision(object1, object2);\n}\nelse {\n...\n}\n}\nThis is where the programming challenge becomes apparent. When\nyou call processCollision, you know that object1 and object2\njust collided, and you know that what happens in that collision de-\npends on what object1 really is and what object2 really is, but you\ndon’t know what kinds of objects they really are; all you know is that\nthey’re both GameObjects. If the collision processing depended only on\nthe dynamic type of object1, you could make processCollision vir-\ntual in GameObject and call object1.processCollision(object2).\nYou could do the same thing with object2 if the details of the collision\ndepended only on its dynamic type. What happens in the collision,\nhowever, depends on both their dynamic types. A function call that’s\nvirtual on only one object, you see, is not enough.\nWhat you need is a kind of function whose behavior is somehow virtual\non the types of more than one object. C++ offers no such function. Nev-\nGameObject\nSpaceShip\nSpaceStation\nAsteroid\n",
      "content_length": 1624,
      "extraction_method": "Direct"
    },
    {
      "page_number": 247,
      "chapter": null,
      "content": "230\nItem 31\nertheless, you still have to implement the behavior required above. The\nquestion, then, is how you are going to do it.\nOne possibility is to scrap the use of C++ and choose another program-\nming language. You could turn to CLOS, for example, the Common\nLisp Object System. CLOS supports what is possibly the most general\nobject-oriented function-invocation mechanism one can imagine:\nmulti-methods. A multi-method is a function that’s virtual on as many\nparameters as you’d like, and CLOS goes even further by giving you\nsubstantial control over how calls to overloaded multi-methods are re-\nsolved. \nLet us assume, however, that you must implement your game in C++\n— that you must come up with your own way of implementing what is\ncommonly referred to as double-dispatching. (The name comes from\nthe object-oriented programming community, where what C++ pro-\ngrammers know as a virtual function call is termed a “message dis-\npatch.” A call that’s virtual on two parameters is implemented through\na “double dispatch.” The generalization of this — a function acting vir-\ntual on several parameters — is called multiple dispatch.) There are\nseveral approaches you might consider. None is without its disadvan-\ntages, but that shouldn’t surprise you. C++ offers no direct support for\ndouble-dispatching, so you must yourself do the work compilers do\nwhen they implement virtual functions (see Item 24). If that were easy\nto do, we’d probably all be doing it ourselves and simply programming\nin C. We aren’t and we don’t, so fasten your seat belts, it’s going to be\na bumpy ride.\nUsing Virtual Functions and RTTI\nVirtual functions implement a single dispatch; that’s half of what we\nneed; and compilers do virtual functions for us, so we begin by declar-\ning a virtual function collide in GameObject. This function is over-\nridden in the derived classes in the usual manner:\nclass GameObject {\npublic:\nvirtual void collide(GameObject& otherObject) = 0;\n...\n};\nclass SpaceShip: public GameObject {\npublic:\nvirtual void collide(GameObject& otherObject);\n...\n};\nHere I’m showing only the derived class SpaceShip, but SpaceSta-\ntion and Asteroid are handled in exactly the same manner.\n",
      "content_length": 2191,
      "extraction_method": "Direct"
    },
    {
      "page_number": 248,
      "chapter": null,
      "content": "Implementing Multiple Dispatch\n231\nThe most common approach to double-dispatching returns us to the\nunforgiving world of virtual function emulation via chains of if-then-\nelses. In this harsh world, we first discover the real type of otherOb-\nject, then we test it against all the possibilities:\n// if we collide with an object of unknown type, we\n// throw an exception of this type:\nclass CollisionWithUnknownObject {\npublic:\nCollisionWithUnknownObject(GameObject& whatWeHit);\n...\n};\nvoid SpaceShip::collide(GameObject& otherObject)\n{\nconst type_info& objectType = typeid(otherObject);\nif (objectType == typeid(SpaceShip)) {\nSpaceShip& ss = static_cast<SpaceShip&>(otherObject);\nprocess a SpaceShip-SpaceShip collision;\n}\nelse if (objectType == typeid(SpaceStation)) {\nSpaceStation& ss =\nstatic_cast<SpaceStation&>(otherObject);\nprocess a SpaceShip-SpaceStation collision;\n}\nelse if (objectType == typeid(Asteroid)) {\nAsteroid& a = static_cast<Asteroid&>(otherObject);\nprocess a SpaceShip-Asteroid collision;\n}\nelse {\nthrow CollisionWithUnknownObject(otherObject);\n}\n}\nNotice how we need to determine the type of only one of the objects in-\nvolved in the collision. The other object is *this, and its type is deter-\nmined by the virtual function mechanism. We’re inside a SpaceShip\nmember function, so *this must be a SpaceShip object. Thus we only\nhave to figure out the real type of otherObject.\nThere’s nothing complicated about this code. It’s easy to write. It’s even\neasy to make work. That’s one of the reasons RTTI is worrisome: it\nlooks harmless. The true danger in this code is hinted at only by the\nfinal else clause and the exception that’s thrown there. \n",
      "content_length": 1669,
      "extraction_method": "Direct"
    },
    {
      "page_number": 249,
      "chapter": null,
      "content": "232\nItem 31\nWe’ve pretty much bidden adios to encapsulation, because each col-\nlide function must be aware of each of its sibling classes, i.e., those\nclasses that inherit from GameObject. In particular, if a new type of\nobject — a new class — is added to the game, we must update each\nRTTI-based if-then-else chain in the program that might encounter\nthe new object type. If we forget even a single one, the program will\nhave a bug, and the bug will not be obvious. Furthermore, compilers\nare in no position to help us detect such an oversight, because they\nhave no idea what we’re doing.\nThis kind of type-based programming has a long history in C, and one\nof the things we know about it is that it yields programs that are essen-\ntially unmaintainable. Enhancement of such programs eventually be-\ncomes unthinkable. This is the primary reason why virtual functions\nwere invented in the first place: to shift the burden of generating and\nmaintaining type-based function calls from programmers to compilers.\nWhen we employ RTTI to implement double-dispatching, we are hark-\ning back to the bad old days. \nThe techniques of the bad old days led to errors in C, and they’ll lead\nto errors in C++, too. In recognition of our human frailty, we’ve in-\ncluded a final else clause in the collide function, a clause where\ncontrol winds up if we hit an object we don’t know about. Such a situ-\nation is, in principle, impossible, but where were our principles when\nwe decided to use RTTI? There are various ways to handle such unan-\nticipated interactions, but none is very satisfying. In this case, we’ve\nchosen to throw an exception, but it’s not clear how our callers can\nhope to handle the error any better than we can, since we’ve just run\ninto something we didn’t know existed.\nUsing Virtual Functions Only\nThere is a way to minimize the risks inherent in an RTTI approach to\nimplementing double-dispatching, but before we look at that, it’s con-\nvenient to see how to attack the problem using nothing but virtual\nfunctions. That strategy begins with the same basic structure as the\nRTTI approach. The collide function is declared virtual in GameOb-\nject and is redefined in each derived class. In addition, collide is\noverloaded in each class, one overloading for each derived class in the\nhierarchy:\nclass SpaceShip;\n// forward declarations\nclass SpaceStation;\nclass Asteroid;\n",
      "content_length": 2377,
      "extraction_method": "Direct"
    },
    {
      "page_number": 250,
      "chapter": null,
      "content": "Implementing Multiple Dispatch\n233\nclass GameObject {\npublic:\nvirtual void collide(GameObject&\notherObject) = 0;\nvirtual void collide(SpaceShip&\notherObject) = 0;\nvirtual void collide(SpaceStation& otherObject) = 0;\nvirtual void collide(Asteroid&\notherobject) = 0;\n...\n};\nclass SpaceShip: public GameObject {\npublic:\nvirtual void collide(GameObject&\notherObject);\nvirtual void collide(SpaceShip&\notherObject);\nvirtual void collide(SpaceStation& otherObject);\nvirtual void collide(Asteroid&\notherobject);\n...\n};\nThe basic idea is to implement double-dispatching as two single dis-\npatches, i.e., as two separate virtual function calls: the first deter-\nmines the dynamic type of the first object, the second determines that\nof the second object. As before, the first virtual call is to the collide\nfunction taking a GameObject& parameter. That function’s implemen-\ntation now becomes startlingly simple:\nvoid SpaceShip::collide(GameObject& otherObject)\n{\notherObject.collide(*this);\n}\nAt first glance, this appears to be nothing more than a recursive call to\ncollide with the order of the parameters reversed, i.e., with other-\nObject becoming the object calling the member function and *this\nbecoming the function’s parameter. Glance again, however, because\nthis is not a recursive call. As you know, compilers figure out which of\na set of functions to call on the basis of the static types of the argu-\nments passed to the function. In this case, four different collide\nfunctions could be called, but the one chosen is based on the static\ntype of *this. What is that static type? Being inside a member func-\ntion of the class SpaceShip, *this must be of type SpaceShip. The\ncall is therefore to the collide function taking a SpaceShip&, not the\ncollide function taking a GameObject&.\nAll the collide functions are virtual, so the call inside Space-\nShip::collide resolves to the implementation of collide correspond-\ning to the real type of otherObject. Inside that implementation of\ncollide, the real types of both objects are known, because the left-\nhand object is *this (and therefore has as its type the class imple-\n",
      "content_length": 2123,
      "extraction_method": "Direct"
    },
    {
      "page_number": 251,
      "chapter": null,
      "content": "234\nItem 31\nmenting the member function) and the right-hand object’s real type is\nSpaceShip, the same as the declared type of the parameter.\nAll this may be clearer when you see the implementations of the other\ncollide functions in SpaceShip:\nvoid SpaceShip::collide(SpaceShip& otherObject)\n{\nprocess a SpaceShip-SpaceShip collision;\n}\nvoid SpaceShip::collide(SpaceStation& otherObject)\n{\nprocess a SpaceShip-SpaceStation collision;\n}\nvoid SpaceShip::collide(Asteroid& otherObject)\n{\nprocess a SpaceShip-Asteroid collision;\n}\nAs you can see, there’s no muss, no fuss, no RTTI, no need to throw\nexceptions for unexpected object types. There can be no unexpected\nobject types — that’s the whole point of using virtual functions. In fact,\nwere it not for its fatal flaw, this would be the perfect solution to the\ndouble-dispatching problem.\nThe flaw is one it shares with the RTTI approach we saw earlier: each\nclass must know about its siblings. As new classes are added, the code\nmust be updated. However, the way in which the code must be up-\ndated is different in this case. True, there are no if-then-elses to\nmodify, but there is something that is often worse: each class defini-\ntion must be amended to include a new virtual function. If, for exam-\nple, you decide to add a new class Satellite (inheriting from\nGameObject) to your game, you’d have to add a new collide function\nto each of the existing classes in the program.\nModifying existing classes is something you are frequently in no posi-\ntion to do. If, instead of writing the entire video game yourself, you\nstarted with an off-the-shelf class library comprising a video game ap-\nplication framework, you might not have write access to the GameOb-\nject class or the framework classes derived from it. In that case,\nadding new member functions, virtual or otherwise, is not an option.\nAlternatively, you may have physical access to the classes requiring\nmodification, but you may not have practical access. For example, sup-\npose you were hired by Nintendo and were put to work on programs\nusing a library containing GameObject and other useful classes.\nSurely you wouldn’t be the only one using that library, and Nintendo\nwould probably be less than thrilled about recompiling every applica-\ntion using that library each time you decided to add a new type of ob-\n",
      "content_length": 2327,
      "extraction_method": "Direct"
    },
    {
      "page_number": 252,
      "chapter": null,
      "content": "Implementing Multiple Dispatch\n235\nject to your program. In practice, libraries in wide use are modified\nonly rarely, because the cost of recompiling everything using those li-\nbraries is too great.\nThe long and short of it is if you need to implement double-dispatching\nin your program, your best recourse is to modify your design to elimi-\nnate the need. Failing that, the virtual function approach is safer than\nthe RTTI strategy, but it constrains the extensibility of your system to\nmatch that of your ability to edit header files. The RTTI approach, on\nthe other hand, makes no recompilation demands, but, if implemented\nas shown above, it generally leads to software that is unmaintainable.\nYou pays your money and you takes your chances.\nEmulating Virtual Function Tables\nThere is a way to improve those chances. You may recall from Item 24\nthat compilers typically implement virtual functions by creating an\narray of function pointers (the vtbl) and then indexing into that array\nwhen a virtual function is called. Using a vtbl eliminates the need for\ncompilers to perform chains of if-then-else-like computations, and\nit allows compilers to generate the same code at all virtual function call\nsites: determine the correct vtbl index, then call the function pointed\nto at that position in the vtbl. \nThere is no reason you can’t do this yourself. If you do, you not only\nmake your RTTI-based code more efficient (indexing into an array and\nfollowing a function pointer is almost always more efficient than run-\nning through a series of if-then-else tests, and it generates less\ncode, too), you also isolate the use of RTTI to a single location: the\nplace where your array of function pointers is initialized. I should men-\ntion that the meek may inherit the earth, but the meek of heart may\nwish to take a few deep breaths before reading what follows.\nWe begin by making some modifications to the functions in the\nGameObject hierarchy:\nclass GameObject {\npublic:\nvirtual void collide(GameObject& otherObject) = 0;\n...\n};\nclass SpaceShip: public GameObject {\npublic:\nvirtual void collide(GameObject& otherObject);\nvirtual void hitSpaceShip(SpaceShip& otherObject);\nvirtual void hitSpaceStation(SpaceStation& otherObject);\nvirtual void hitAsteroid(Asteroid& otherobject);\n...\n};\n",
      "content_length": 2286,
      "extraction_method": "Direct"
    },
    {
      "page_number": 253,
      "chapter": null,
      "content": "236\nItem 31\nvoid SpaceShip::hitSpaceShip(SpaceShip& otherObject)\n{\nprocess a SpaceShip-SpaceShip collision;\n}\nvoid SpaceShip::hitSpaceStation(SpaceStation& otherObject)\n{\nprocess a SpaceShip-SpaceStation collision;\n}\nvoid SpaceShip::hitAsteroid(Asteroid& otherObject)\n{\nprocess a SpaceShip-Asteroid collision;\n}\nLike the RTTI-based hierarchy we started out with, the GameObject\nclass contains only one function for processing collisions, the one that\nperforms the first of the two necessary dispatches. Like the virtual-\nfunction-based hierarchy we saw later, each kind of interaction is en-\ncapsulated in a separate function, though in this case the functions\nhave different names instead of sharing the name collide. There is a\nreason for this abandonment of overloading, and we shall see it soon.\nFor the time being, note that the design above contains everything we\nneed except an implementation for SpaceShip::collide; that’s where\nthe various hit functions will be invoked. As before, once we success-\nfully implement the SpaceShip class, the SpaceStation and Aster-\noid classes will follow suit.\nInside SpaceShip::collide, we need a way to map the dynamic type\nof the parameter otherObject to a member function pointer that\npoints to the appropriate collision-handling function. An easy way to\ndo this is to create an associative array that, given a class name, yields\nthe appropriate member function pointer. It’s possible to implement\ncollide using such an associative array directly, but it’s a bit easier\nto understand what’s going on if we add an intervening function,\nlookup, that takes a GameObject and returns the appropriate mem-\nber function pointer. That is, you pass lookup a GameObject, and it\nreturns a pointer to the member function to call when you collide with\nsomething of that GameObject’s type.\nHere’s the declaration of lookup:\nclass SpaceShip: public GameObject {\nprivate:\ntypedef void (SpaceShip::*HitFunctionPtr)(GameObject&);\nstatic HitFunctionPtr lookup(const GameObject& whatWeHit);\n...\n};\n",
      "content_length": 2024,
      "extraction_method": "Direct"
    },
    {
      "page_number": 254,
      "chapter": null,
      "content": "Implementing Multiple Dispatch\n237\nThe syntax of function pointers is never very pretty, and for member\nfunction pointers it’s worse than usual, so we’ve typedefed HitFunc-\ntionPtr to be shorthand for a pointer to a member function of Space-\nShip that takes a GameObject& and returns nothing.\nOnce we’ve got lookup, implementation of collide becomes the pro-\nverbial piece of cake:\nvoid SpaceShip::collide(GameObject& otherObject)\n{\nHitFunctionPtr hfp =\nlookup(otherObject);\n// find the function to call\nif (hfp) {\n// if a function was found\n(this->*hfp)(otherObject);\n// call it\n}\nelse {\nthrow CollisionWithUnknownObject(otherObject);\n}\n}\nProvided we’ve kept the contents of our associative array in sync with\nthe class hierarchy under GameObject, lookup must always find a\nvalid function pointer for the object we pass it. People are people, how-\never, and mistakes have been known to creep into even the most care-\nfully crafted software systems. That’s why we still check to make sure\na valid pointer was returned from lookup, and that’s why we still\nthrow an exception if the impossible occurs and the lookup fails.\nAll that remains now is the implementation of lookup. Given an asso-\nciative array that maps from object types to member function pointers,\nthe lookup itself is easy, but creating, initializing, and destroying the\nassociative array is an interesting problem of its own.\nSuch an array should be created and initialized before it’s used, and it\nshould be destroyed when it’s no longer needed. We could use new and\ndelete to create and destroy the array manually, but that would be\nerror-prone: how could we guarantee the array wasn’t used before we\ngot around to initializing it? A better solution is to have compilers au-\ntomate the process, and we can do that by making the associative\narray static in lookup. That way it will be created and initialized the\nfirst time lookup is called, and it will be automatically destroyed some-\ntime after main is exited. \nFurthermore, we can use the map template from the Standard Tem-\nplate Library (see Item 35) as the associative array, because that’s\nwhat a map is:\n",
      "content_length": 2129,
      "extraction_method": "Direct"
    },
    {
      "page_number": 255,
      "chapter": null,
      "content": "238\nItem 31\nclass SpaceShip: public GameObject {\nprivate:\ntypedef void (SpaceShip::*HitFunctionPtr)(GameObject&);\ntypedef map<string, HitFunctionPtr> HitMap;\n...\n};\nSpaceShip::HitFunctionPtr\nSpaceShip::lookup(const GameObject& whatWeHit)\n{\nstatic HitMap collisionMap;\n...\n}\nHere, collisionMap is our associative array. It maps the name of a\nclass (as a string object) to a SpaceShip member function pointer.\nBecause map<string, HitFunctionPtr> is quite a mouthful, we use\na typedef to make it easier to swallow. (For fun, try writing the declara-\ntion of collisionMap without using the HitMap and HitFunctionPtr\ntypedefs. Most people will want to do this only once.)\nGiven collisionMap, the implementation of lookup is rather anticli-\nmactic. That’s because searching for something is an operation di-\nrectly supported by the map class, and the one member function we\ncan always (portably) call on the result of a typeid invocation is name\n(which, predictably†, yields the name of the object’s dynamic type). To\nimplement lookup, then, we just find the entry in collisionMap cor-\nresponding to the dynamic type of lookup’s argument. \nThe code for lookup is straightforward, but if you’re not familiar with\nthe Standard Template Library (again, see Item 35), it may not seem\nthat way. Don’t worry. The comments in the function explain what’s\ngoing on.\nSpaceShip::HitFunctionPtr\nSpaceShip::lookup(const GameObject& whatWeHit)\n{\nstatic HitMap collisionMap;\n// we’ll see how to\n// initialize this below\n// look up the collision-processing function for the type\n// of whatWeHit. The value returned is a pointer-like \n// object called an \"iterator\" (see Item 35).\nHitMap::iterator mapEntry=\ncollisionMap.find(typeid(whatWeHit).name());\n// mapEntry == collisionMap.end() if the lookup failed;\n// this is standard map behavior. Again, see Item 35.\nif (mapEntry == collisionMap.end()) return 0;\n† It turns out that it’s not so predictable after all. The C++ standard doesn’t specify the\nreturn value of type_info::name, and different implementations do behave different-\nly. A preferable design is to use a container-friendly class that wraps type_info ob-\njects, such as Andrei Alexandrescu’s TypeInfo class, which is described in section 2.8\nof his Modern C++ Design (Addison Wesley, 2001).\n",
      "content_length": 2284,
      "extraction_method": "Direct"
    },
    {
      "page_number": 256,
      "chapter": null,
      "content": "Implementing Multiple Dispatch\n239\n// If we get here, the search succeeded. mapEntry \n// points to a complete map entry, which is a \n// (string, HitFunctionPtr) pair. We want only the\n// second part of the pair, so that’s what we return.\nreturn (*mapEntry).second;\n}\nThe final statement in the function returns (*mapEntry).second in-\nstead of the more conventional mapEntry->second in order to satisfy\nthe vagaries of the STL. For details, see page 96.\nInitializing Emulated Virtual Function Tables\nWhich brings us to the initialization of collisionMap. We’d like to say\nsomething like this,\n// An incorrect implementation\nSpaceShip::HitFunctionPtr\nSpaceShip::lookup(const GameObject& whatWeHit)\n{\nstatic HitMap collisionMap;\ncollisionMap[\"SpaceShip\"] = &hitSpaceShip;\ncollisionMap[\"SpaceStation\"] = &hitSpaceStation;\ncollisionMap[\"Asteroid\"] = &hitAsteroid;\n...\n}\nbut this inserts the member function pointers into collisionMap each\ntime lookup is called, and that’s needlessly inefficient. In addition, this\nwon’t compile, but that’s a secondary problem we’ll address shortly.\nWhat we need now is a way to put the member function pointers into\ncollisionMap only once — when collisionMap is created. That’s\neasy enough to accomplish; we just write a private static member func-\ntion called initializeCollisionMap to create and initialize our map,\nthen we initialize collisionMap with initializeCollisionMap’s re-\nturn value:\nclass SpaceShip: public GameObject {\nprivate:\nstatic HitMap initializeCollisionMap();\n...\n};\nSpaceShip::HitFunctionPtr\nSpaceShip::lookup(const GameObject& whatWeHit)\n{\nstatic HitMap collisionMap = initializeCollisionMap();\n...\n}\n",
      "content_length": 1655,
      "extraction_method": "Direct"
    },
    {
      "page_number": 257,
      "chapter": null,
      "content": "240\nItem 31\nBut this means we may have to pay the cost of copying the map object\nreturned from initializeCollisionMap into collisionMap (see\nItems 19 and 20). We’d prefer not to do that. We wouldn’t have to pay\nif initializeCollisionMap returned a pointer, but then we’d have to\nworry about making sure the map object the pointer pointed to was de-\nstroyed at an appropriate time. \nFortunately, there’s a way for us to have it all. We can turn colli-\nsionMap into a smart pointer (see Item 28) that automatically deletes\nwhat it points to when the pointer itself is destroyed. In fact, the stan-\ndard C++ library contains a template, auto_ptr, for just such a smart\npointer (see Item 9). By making collisionMap a static auto_ptr in\nlookup, we can have initializeCollisionMap return a pointer to\nan initialized map object, yet never have to worry about a resource leak;\nthe map to which collisionMap points will be automatically destroyed\nwhen collisionMap is. Thus:\nclass SpaceShip: public GameObject {\nprivate:\nstatic HitMap * initializeCollisionMap();\n...\n};\nSpaceShip::HitFunctionPtr\nSpaceShip::lookup(const GameObject& whatWeHit)\n{\nstatic auto_ptr<HitMap> \ncollisionMap(initializeCollisionMap());\n...\n}\nThe clearest way to implement initializeCollisionMap would seem\nto be this, \nSpaceShip::HitMap * SpaceShip::initializeCollisionMap()\n{\nHitMap *phm = new HitMap;\n(*phm)[\"SpaceShip\"] = &hitSpaceShip;\n(*phm)[\"SpaceStation\"] = &hitSpaceStation;\n(*phm)[\"Asteroid\"] = &hitAsteroid;\nreturn phm;\n}\nbut as I noted earlier, this won’t compile. That’s because a HitMap is\ndeclared to hold pointers to member functions that all take the same\n",
      "content_length": 1637,
      "extraction_method": "Direct"
    },
    {
      "page_number": 258,
      "chapter": null,
      "content": "Implementing Multiple Dispatch\n241\ntype of argument, namely GameObject. But hitSpaceShip takes a\nSpaceShip, hitSpaceStation takes a SpaceStation, and, hitAst-\neroid takes an Asteroid. Even though SpaceShip, SpaceStation,\nand Asteroid can all be implicitly converted to GameObject, there is\nno such conversion for pointers to functions taking these argument\ntypes.\nTo placate your compilers, you might be tempted to employ\nreinterpret_casts (see Item 2), which are generally the casts of\nchoice when converting between function pointer types:\n// A bad idea...\nSpaceShip::HitMap * SpaceShip::initializeCollisionMap()\n{\nHitMap *phm = new HitMap;\n(*phm)[\"SpaceShip\"] =\nreinterpret_cast<HitFunctionPtr>(&hitSpaceShip);\n(*phm)[\"SpaceStation\"] =\nreinterpret_cast<HitFunctionPtr>(&hitSpaceStation);\n(*phm)[\"Asteroid\"] =\nreinterpret_cast<HitFunctionPtr>(&hitAsteroid);\nreturn phm;\n}\nThis will compile, but it’s a bad idea. It entails doing something you\nshould never do: lying to your compilers. Telling them that hitSpace-\nShip, hitSpaceStation, and hitAsteroid are functions expecting a\nGameObject argument is simply not true. hitSpaceShip expects a\nSpaceShip, hitSpaceStation expects a SpaceStation, and hitAs-\nteroid expects an Asteroid. The casts say otherwise. The casts lie.\nMore than morality is on the line here. Compilers don’t like to be lied\nto, and they often find a way to exact revenge when they discover\nthey’ve been deceived. In this case, they’re likely to get back at you by\ngenerating bad code for functions you call through *phm in cases\nwhere GameObject’s derived classes employ multiple inheritance or\nhave virtual base classes. In other words, if SpaceStation, Space-\nShip, or Asteroid had other base classes (in addition to GameObject),\nyou’d probably find that your calls to collision-processing functions in\ncollide would behave quite rudely. \n",
      "content_length": 1862,
      "extraction_method": "Direct"
    },
    {
      "page_number": 259,
      "chapter": null,
      "content": "242\nItem 31\nConsider again the A-B-C-D inheritance hierarchy and the possible ob-\nject layout for a D object that is described in Item 24:\nEach of the four class parts in a D object has a different address. This\nis important, because even though pointers and references behave dif-\nferently (see Item 1), compilers typically implement references by using\npointers in the generated code. Thus, pass-by-reference is typically im-\nplemented by passing a pointer to an object. When an object with mul-\ntiple base classes (such as a D object) is passed by reference, it is\ncrucial that compilers pass the correct address — the one correspond-\ning to the declared type of the parameter in the function being called.\nBut what if you’ve lied to your compilers and told them your function\nexpects a GameObject when it really expects a SpaceShip or a\nSpaceStation? Then they’ll pass the wrong address when you call the\nfunction, and the resulting runtime carnage will probably be grue-\nsome. It will also be very difficult to determine the cause of the prob-\nlem. There are good reasons why casting is discouraged. This is one of\nthem.\nOkay, so casting is out. Fine. But the type mismatch between the func-\ntion pointers a HitMap is willing to contain and the pointers to the\nhitSpaceShip, hitSpaceStation, and hitAsteroid functions re-\nmains. There is only one way to resolve the conflict: change the types\nof the functions so they all take GameObject arguments:\nclass GameObject {\n// this is unchanged\npublic:\nvirtual void collide(GameObject& otherObject) = 0;\n...\n};\nB Data Members\nC Data Members\nD Data Members\nA Data Members\nPointer to virtual base class\nPointer to virtual base class\nvptr\nvptr\nB\nD\nC\nA\nvptr\n",
      "content_length": 1703,
      "extraction_method": "Direct"
    },
    {
      "page_number": 260,
      "chapter": null,
      "content": "Implementing Multiple Dispatch\n243\nclass SpaceShip: public GameObject {\npublic:\nvirtual void collide(GameObject& otherObject);\n// these functions now all take a GameObject parameter\nvirtual void hitSpaceShip(GameObject& spaceShip);\nvirtual void hitSpaceStation(GameObject& spaceStation);\nvirtual void hitAsteroid(GameObject& asteroid);\n...\n};\nOur solution to the double-dispatching problem that was based on vir-\ntual functions overloaded the function name collide. Now we are in a\nposition to understand why we didn’t follow suit here — why we de-\ncided to use an associative array of member function pointers instead.\nAll the hit functions take the same parameter type, so we must give\nthem different names.\nNow we can write initializeCollisionMap the way we always\nwanted to:\nSpaceShip::HitMap * SpaceShip::initializeCollisionMap()\n{\nHitMap *phm = new HitMap;\n(*phm)[\"SpaceShip\"] = &hitSpaceShip;\n(*phm)[\"SpaceStation\"] = &hitSpaceStation;\n(*phm)[\"Asteroid\"] = &hitAsteroid;\nreturn phm;\n}\nRegrettably, our hit functions now get a general GameObject param-\neter instead of the derived class parameters they expect. To bring real-\nity into accord with expectation, we must resort to a dynamic_cast\n(see Item 2) at the top of each function:\nvoid SpaceShip::hitSpaceShip(GameObject& spaceShip)\n{\nSpaceShip& otherShip=\ndynamic_cast<SpaceShip&>(spaceShip);\nprocess a SpaceShip-SpaceShip collision;\n}\nvoid SpaceShip::hitSpaceStation(GameObject& spaceStation)\n{\nSpaceStation& station=\ndynamic_cast<SpaceStation&>(spaceStation);\nprocess a SpaceShip-SpaceStation collision;\n}\n",
      "content_length": 1569,
      "extraction_method": "Direct"
    },
    {
      "page_number": 261,
      "chapter": null,
      "content": "244\nItem 31\nvoid SpaceShip::hitAsteroid(GameObject& asteroid)\n{\nAsteroid& theAsteroid =\ndynamic_cast<Asteroid&>(asteroid);\nprocess a SpaceShip-Asteroid collision;\n}\nEach of the dynamic_casts will throw a bad_cast exception if the\ncast fails. They should never fail, of course, because the hit functions\nshould never be called with incorrect parameter types. Still, we’re bet-\nter off safe than sorry.\nUsing Non-Member Collision-Processing Functions\nWe now know how to build a vtbl-like associative array that lets us im-\nplement the second half of a double-dispatch, and we know how to en-\ncapsulate the details of the associative array inside a lookup function.\nBecause this array contains pointers to member functions, however,\nwe still have to modify class definitions if a new type of GameObject is\nadded to the game, and that means everybody has to recompile, even\npeople who don’t care about the new type of object. For example, if\nSatellite were added to our game, we’d have to augment the Space-\nShip class with a declaration of a function to handle collisions between\nsatellites and spaceships. All SpaceShip clients would then have to re-\ncompile, even if they couldn’t care less about the existence of satellites.\nThis is the problem that led us to reject the implementation of double-\ndispatching based purely on virtual functions, and that solution was a\nlot less work than the one we’ve just seen.\nThe recompilation problem would go away if our associative array con-\ntained pointers to non-member functions. Furthermore, switching to\nnon-member collision-processing functions would let us address a de-\nsign question we have so far ignored, namely, in which class should\ncollisions between objects of different types be handled? With the im-\nplementation we just developed, if object 1 and object 2 collide and ob-\nject 1 happens to be the left-hand argument to processCollision,\nthe collision will be handled inside the class for object 1. If object 2\nhappens to be the left-hand argument to processCollision, how-\never, the collision will be handled inside the class for object 2. Does\nthis make sense? Wouldn’t it be better to design things so that colli-\nsions between objects of types A and B are handled by neither A nor B\nbut instead in some neutral location outside both classes?\nIf we move the collision-processing functions out of our classes, we can\ngive clients header files that contain class definitions without any hit\nor collide functions. We can then structure our implementation file\nfor processCollision as follows:\n",
      "content_length": 2550,
      "extraction_method": "Direct"
    },
    {
      "page_number": 262,
      "chapter": null,
      "content": "Implementing Multiple Dispatch\n245\n#include \"SpaceShip.h\"\n#include \"SpaceStation.h\"\n#include \"Asteroid.h\"\nnamespace {\n// unnamed namespace — see below\n// primary collision-processing functions\nvoid shipAsteroid(GameObject& spaceShip,\nGameObject& asteroid);\nvoid shipStation(GameObject& spaceShip,\nGameObject& spaceStation);\nvoid asteroidStation(GameObject& asteroid,\nGameObject& spaceStation);\n...\n// secondary collision-processing functions that just\n// implement symmetry: swap the parameters and call a\n// primary function\nvoid asteroidShip(GameObject& asteroid,\nGameObject& spaceShip)\n{ shipAsteroid(spaceShip, asteroid); }\nvoid stationShip(GameObject& spaceStation,\nGameObject& spaceShip)\n{ shipStation(spaceShip, spaceStation); }\nvoid stationAsteroid(GameObject& spaceStation,\nGameObject& asteroid)\n{ asteroidStation(asteroid, spaceStation); }\n...\n// see below for a description of these types/functions\ntypedef void (*HitFunctionPtr)(GameObject&, GameObject&);\ntypedef map< pair<string,string>, HitFunctionPtr > HitMap;\npair<string,string> makeStringPair(const char *s1,\nconst char *s2);\nHitMap * initializeCollisionMap();\nHitFunctionPtr lookup(const string& class1,\nconst string& class2);\n} // end namespace\nvoid processCollision(GameObject& object1,\nGameObject& object2)\n{\nHitFunctionPtr phf = lookup(typeid(object1).name(),\ntypeid(object2).name());\nif (phf) phf(object1, object2);\nelse throw UnknownCollision(object1, object2);\n}\n",
      "content_length": 1440,
      "extraction_method": "Direct"
    },
    {
      "page_number": 263,
      "chapter": null,
      "content": "246\nItem 31\nNote the use of the unnamed namespace to contain the functions used\nto implement processCollision. Everything in such an unnamed\nnamespace is private to the current translation unit (essentially the\ncurrent file) — it’s just like the functions were declared static at file\nscope. With the advent of namespaces, however, statics at file scope\nhave been deprecated, so you should accustom yourself to using un-\nnamed namespaces as soon as your compilers support them.\nConceptually, this implementation is the same as the one that used\nmember functions, but there are some minor differences. First, Hit-\nFunctionPtr is now a typedef for a pointer to a non-member function.\nSecond, the exception class CollisionWithUnknownObject has been\nrenamed UnknownCollision and modified to take two objects instead\nof one. Finally, lookup must now take two type names and perform\nboth parts of the double-dispatch. This means our collision map must\nnow hold three pieces of information: two types names and a HitFunc-\ntionPtr.\nAs fate would have it, the standard map class is defined to hold only\ntwo pieces of information. We can finesse that problem by using the\nstandard pair template, which lets us bundle the two type names to-\ngether as a single object. initializeCollisionMap, along with its\nmakeStringPair helper function, then looks like this:\n// we use this function to create pair<string,string>\n// objects from two char* literals. It’s used in\n// initializeCollisionMap below. Note how this function\n// enables the return value optimization (see Item 20).\nnamespace {\n// unnamed namespace again — see below\npair<string,string> makeStringPair(const char *s1,\nconst char *s2)\n{ return pair<string,string>(s1, s2); }\n} // end namespace\nnamespace {\n// still the unnamed namespace — see below\nHitMap * initializeCollisionMap()\n{\nHitMap *phm = new HitMap;\n(*phm)[makeStringPair(\"SpaceShip\",\"Asteroid\")] =\n&shipAsteroid;\n(*phm)[makeStringPair(\"SpaceShip\", \"SpaceStation\")] =\n&shipStation;\n...\nreturn phm;\n}\n} // end namespace\n",
      "content_length": 2028,
      "extraction_method": "Direct"
    },
    {
      "page_number": 264,
      "chapter": null,
      "content": "Implementing Multiple Dispatch\n247\nlookup must also be modified to work with the pair<string,\nstring> objects that now comprise the first component of the collision\nmap:\nnamespace {\n// I explain this below — trust me\nHitFunctionPtr lookup(const string& class1,\nconst string& class2)\n{\nstatic auto_ptr<HitMap> \ncollisionMap(initializeCollisionMap());\n// see below for a description of make_pair\nHitMap::iterator mapEntry=\ncollisionMap->find(make_pair(class1, class2));\nif (mapEntry == collisionMap->end()) return 0;\nreturn (*mapEntry).second;\n}\n} // end namespace\nThis is almost exactly what we had before. The only real difference is\nthe use of the make_pair function in this statement:\nHitMap::iterator mapEntry=\ncollisionMap->find(make_pair(class1, class2));\nmake_pair is just a convenience function (template) in the standard li-\nbrary (see Item 35) that saves us the trouble of specifying the types\nwhen constructing a pair object. We could just as well have written\nthe statement like this:\nHitMap::iterator mapEntry=\ncollisionMap->find(pair<string,string>(class1, class2));\nThis calls for more typing, however, and specifying the types for the\npair is redundant (they’re the same as the types of class1 and\nclass2), so the make_pair form is more commonly used.\nBecause makeStringPair, initializeCollisionMap, and lookup\nwere declared inside an unnamed namespace, each must be imple-\nmented within the same namespace. That’s why the implementations\nof the functions above are in the unnamed namespace (for the same\ntranslation unit as their declarations): so the linker will correctly asso-\nciate their definitions (i.e., their implementations) with their earlier\ndeclarations.\nWe have finally achieved our goals. If new subclasses of GameObject\nare added to our hierarchy, existing classes need not recompile (unless\nthey wish to use the new classes). We have no tangle of RTTI-based\nswitch or if-then-else conditionals to maintain. The addition of new\nclasses to the hierarchy requires only well-defined and localized\n",
      "content_length": 2025,
      "extraction_method": "Direct"
    },
    {
      "page_number": 265,
      "chapter": null,
      "content": "248\nItem 31\nchanges to our system: the addition of one or more map insertions in\ninitializeCollisionMap and the declarations of the new collision-\nprocessing functions in the unnamed namespace associated with the\nimplementation of processCollision. It may have been a lot of work\nto get here, but at least the trip was worthwhile. Yes? Yes?\nMaybe.\nInheritance and Emulated Virtual Function Tables\nThere is one final problem we must confront. (If, at this point, you are\nwondering if there will always be one final problem to confront, you\nhave truly come to appreciate the difficulty of designing an implemen-\ntation mechanism for virtual functions.) Everything we’ve done will\nwork fine as long as we never need to allow inheritance-based type\nconversions when calling collision-processing functions. But suppose\nwe develop a game in which we must sometimes distinguish between\ncommercial space ships and military space ships. We could modify our\nhierarchy as follows, where we’ve heeded the guidance of Item 33 and\nmade the concrete classes CommercialShip and MilitaryShip in-\nherit from the newly abstract class SpaceShip:\nSuppose commercial and military ships behave identically when they\ncollide with something. Then we’d expect to be able to use the same\ncollision-processing functions we had before CommercialShip and\nMilitaryShip were added. In particular, if a MilitaryShip object\nand an Asteroid collided, we’d expect\nvoid shipAsteroid(GameObject& spaceShip,\nGameObject& asteroid);\nto be called. It would not be. Instead, an UnknownCollision exception\nwould be thrown. That’s because lookup would be asked to find a\nfunction corresponding to the type names “MilitaryShip” and “Aster-\noid,” and no such function would be found in collisionMap. Even\nMilitary\nShip\nCommercial\nShip\nSpaceStation\nGameObject\nSpaceShip\nAsteroid\n",
      "content_length": 1831,
      "extraction_method": "Direct"
    },
    {
      "page_number": 266,
      "chapter": null,
      "content": "Implementing Multiple Dispatch\n249\nthough a MilitaryShip can be treated like a SpaceShip, lookup has\nno way of knowing that.\nFurthermore, there is no easy way of telling it. If you need to imple-\nment double-dispatching and you need to support inheritance-based\nparameter conversions such as these, your only practical recourse is\nto fall back on the double-virtual-function-call mechanism we exam-\nined earlier. That implies you’ll also have to put up with everybody re-\ncompiling when you add to your inheritance hierarchy, but that’s just\nthe way life is sometimes.\nInitializing Emulated Virtual Function Tables (Reprise)\nThat’s really all there is to say about double-dispatching, but it would\nbe unpleasant to end the discussion on such a downbeat note, and un-\npleasantness is, well, unpleasant. Instead, let’s conclude by outlining\nan alternative approach to initializing collisionMap.\nAs things stand now, our design is entirely static. Once we’ve regis-\ntered a function for processing collisions between two types of objects,\nthat’s it; we’re stuck with that function forever. What if we’d like to add,\nremove, or change collision-processing functions as the game pro-\nceeds? There’s no way to do it.\nBut there can be. We can turn the concept of a map for storing colli-\nsion-processing functions into a class that offers member functions al-\nlowing us to modify the contents of the map dynamically. For example:\nclass CollisionMap {\npublic:\ntypedef void (*HitFunctionPtr)(GameObject&, GameObject&);\nvoid addEntry(const string& type1,\nconst string& type2,\nHitFunctionPtr collisionFunction,\nbool symmetric = true);\n// see below\nvoid removeEntry(const string& type1,\nconst string& type2);\nHitFunctionPtr lookup(const string& type1,\nconst string& type2);\n// this function returns a reference to the one and only\n// map — see Item 26\nstatic CollisionMap& theCollisionMap();\nprivate:\n// these functions are private to prevent the creation\n// of multiple maps — see Item 26\nCollisionMap();\nCollisionMap(const CollisionMap&);\n};\n",
      "content_length": 2032,
      "extraction_method": "Direct"
    },
    {
      "page_number": 267,
      "chapter": null,
      "content": "250\nItem 31\nThis class lets us add entries to the map, remove them from it, and\nlook up the collision-processing function associated with a particular\npair of type names. It also uses the techniques of Item 26 to limit the\nnumber of CollisionMap objects to one, because there is only one\nmap in our system. (More complex games with multiple maps are easy\nto imagine.) Finally, it allows us to simplify the addition of symmetric\ncollisions to the map (i.e., collisions in which the effect of an object of\ntype T1 hitting an object of type T2 is the same as that of an object of\ntype T2 hitting an object of type T1) by automatically adding the im-\nplied map entry when addEntry is called with the optional parameter\nsymmetric set to true.\nWith the CollisionMap class, each client wishing to add an entry to\nthe map does so directly:\nvoid shipAsteroid(GameObject& spaceShip,\nGameObject& asteroid);\nCollisionMap::theCollisionMap().addEntry(\"SpaceShip\",\n\"Asteroid\",\n&shipAsteroid);\nvoid shipStation(GameObject& spaceShip,\nGameObject& spaceStation);\nCollisionMap::theCollisionMap().addEntry(\"SpaceShip\",\n\"SpaceStation\",\n&shipStation);\nvoid asteroidStation(GameObject& asteroid,\nGameObject& spaceStation);\nCollisionMap::theCollisionMap().addEntry(\"Asteroid\",\n\"SpaceStation\",\n&asteroidStation);\n...\nCare must be taken to ensure that these map entries are added to the\nmap before any collisions occur that would call the associated func-\ntions. One way to do this would be to have constructors in GameObject\nsubclasses check to make sure the appropriate mappings had been\nadded each time an object was created. Such an approach would exact\na small performance penalty at runtime. An alternative would be to\ncreate a RegisterCollisionFunction class:\nclass RegisterCollisionFunction {\npublic:\nRegisterCollisionFunction(\nconst string& type1,\nconst string& type2,\nCollisionMap::HitFunctionPtr collisionFunction,\nbool symmetric = true)\n{\nCollisionMap::theCollisionMap().addEntry(type1, type2,\ncollisionFunction,\nsymmetric);\n}\n};\n",
      "content_length": 2016,
      "extraction_method": "Direct"
    },
    {
      "page_number": 268,
      "chapter": null,
      "content": "Implementing Multiple Dispatch\n251\nClients could then use global objects of this type to automatically reg-\nister the functions they need:\nRegisterCollisionFunction cf1(\"SpaceShip\", \"Asteroid\",\n&shipAsteroid);\nRegisterCollisionFunction cf2(\"SpaceShip\", \"SpaceStation\",\n&shipStation);\nRegisterCollisionFunction cf3(\"Asteroid\", \"SpaceStation\",\n&asteroidStation);\n...\nint main(int argc, char * argv[])\n{\n...\n}\nBecause these objects are created before main is invoked, the func-\ntions their constructors register are also added to the map before main\nis called. If, later, a new derived class is added\nclass Satellite: public GameObject { ... };\nand one or more new collision-processing functions are written,\nvoid satelliteShip(GameObject& satellite, \nGameObject& spaceShip);\nvoid satelliteAsteroid(GameObject& satellite,\nGameObject& asteroid);\nthese new functions can be similarly added to the map without dis-\nturbing existing code:\nRegisterCollisionFunction cf4(\"Satellite\", \"SpaceShip\",\n&satelliteShip);\nRegisterCollisionFunction cf5(\"Satellite\", \"Asteroid\",\n&satelliteAsteroid);\nThis doesn’t change the fact that there’s no perfect way to implement\nmultiple dispatch, but it does make it easy to provide data for a map-\nbased implementation if we decide such an approach is the best match\nfor our needs.\n",
      "content_length": 1306,
      "extraction_method": "Direct"
    },
    {
      "page_number": 269,
      "chapter": null,
      "content": "Miscellany\nMiscellany\nWe thus arrive at the organizational back of the bus, the chapter con-\ntaining the guidelines no one else would have. We begin with two Items\non C++ software development that describe how to design systems that\naccommodate change. One of the strengths of the object-oriented ap-\nproach to systems building is its support for change, and these Items\ndescribe specific steps you can take to fortify your software against the\nslings and arrows of a world that refuses to stand still.\nWe then examine how to combine C and C++ in the same program.\nThis necessarily leads to consideration of extralinguistic issues, but\nC++ exists in the real world, so sometimes we must confront such\nthings.\nFinally, I summarize changes to the C++ language standard since pub-\nlication of the de facto reference. I especially cover the sweeping\nchanges that have been made in the standard library. If you have not\nbeen following the standardization process closely, you are probably in\nfor some surprises — many of them quite pleasant.\nItem 32: Program in the future tense.\nProgramming in the Future Tense\nThings change.\nAs software developers, we may not know much, but we do know that\nthings will change. We don’t necessarily know what will change, how\nthe changes will be brought about, when the changes will occur, or\nwhy they will take place, but we do know this: things will change.\nGood software adapts well to change. It accommodates new features, it\nports to new platforms, it adjusts to new demands, it handles new in-\nputs. Software this flexible, this robust, and this reliable does not\ncome about by accident. It is designed and implemented by program-\nmers who conform to the constraints of today while keeping in mind\nthe probable needs of tomorrow. This kind of software — software that\n",
      "content_length": 1804,
      "extraction_method": "Direct"
    },
    {
      "page_number": 270,
      "chapter": null,
      "content": "Programming in the Future Tense\n253\naccepts change gracefully — is written by people who program in the fu-\nture tense.\nTo program in the future tense is to accept that things will change and\nto be prepared for it. It is to recognize that new functions will be added\nto libraries, that new overloadings will occur, and to watch for the po-\ntentially ambiguous function calls that might result. It is to acknowl-\nedge that new classes will be added to hierarchies, that present-day\nderived classes may be tomorrow’s base classes, and to prepare for\nthat possibility. It is to accept that new applications will be written,\nthat functions will be called in new contexts, and to write those func-\ntions so they continue to perform correctly. It is to remember that the\nprogrammers charged with software maintenance are typically not the\ncode’s original developers, hence to design and implement in a fashion\nthat facilitates comprehension, modification, and enhancement by\nothers.\nOne way to do this is to express design constraints in C++ instead of\n(or in addition to) comments or other documentation. For example, if a\nclass is designed to never have derived classes, don’t just put a com-\nment in the header file above the class, use C++ to prevent derivation;\nItem 26 shows you how. If a class requires that all instances be on the\nheap, don’t just tell clients that, enforce the restriction by applying the\napproach of Item 27. If copying and assignment make no sense for a\nclass, prevent those operations by declaring the copy constructor and\nthe assignment operator private. C++ offers great power, flexibility, and\nexpressiveness. Use these characteristics of the language to enforce\nthe design decisions in your programs.\nGiven that things will change, write classes that can withstand the\nrough-and-tumble world of software evolution. Avoid “demand-paged”\nvirtual functions, whereby you make no functions virtual unless some-\nbody comes along and demands that you do it. Instead, determine the\nmeaning of a function and whether it makes sense to let it be redefined\nin derived classes. If it does, declare it virtual, even if nobody redefines\nit right away. If it doesn’t, declare it nonvirtual, and don’t change it\nlater just because it would be convenient for someone; make sure the\nchange makes sense in the context of the entire class and the abstrac-\ntion it represents.\nHandle assignment and copy construction in every class, even if “no-\nbody ever does those things.” Just because they don’t do them now\ndoesn’t mean they won’t do them in the future. If these functions are\ndifficult to implement, declare them private. That way no one will in-\nadvertently call compiler-generated functions that do the wrong thing\n(as often happens with default assignment operators and copy con-\nstructors). \n",
      "content_length": 2808,
      "extraction_method": "Direct"
    },
    {
      "page_number": 271,
      "chapter": null,
      "content": "254\nItem 32\nAdhere to the principle of least astonishment: strive to provide classes\nwhose operators and functions have a natural syntax and an intuitive\nsemantics. Preserve consistency with the behavior of the built-in\ntypes: when in doubt, do as the ints do.\nRecognize that anything somebody can do, they will do. They’ll throw\nexceptions, they’ll assign objects to themselves, they’ll use objects be-\nfore giving them values, they’ll give objects values and never use them,\nthey’ll give them huge values, they’ll give them tiny values, they’ll give\nthem null values. In general, if it will compile, somebody will do it. As\na result, make your classes easy to use correctly and hard to use in-\ncorrectly. Accept that clients will make mistakes, and design your\nclasses so you can prevent, detect, or correct such errors (see, for ex-\nample, Item 33). \nStrive for portable code. It’s not much harder to write portable pro-\ngrams than to write unportable ones, and only rarely will the difference\nin performance be significant enough to justify unportable constructs\n(see Item 16). Even programs designed for custom hardware often end\nup being ported, because stock hardware generally achieves an equiv-\nalent level of performance within a few years. Writing portable code al-\nlows you to switch platforms easily, to enlarge your client base, and to\nbrag about supporting open systems. It also makes it easier to recover\nif you bet wrong in the operating system sweepstakes.\nDesign your code so that when changes are necessary, the impact is\nlocalized. Encapsulate as much as you can; make implementation de-\ntails private. Where applicable, use unnamed namespaces or file-\nstatic objects and functions (see Item 31). Try to avoid designs that\nlead to virtual base classes, because such classes must be initialized\nby every class derived from them — even those derived indirectly (see\nItem 4). Avoid RTTI-based designs that make use of cascading if-\nthen-else statements (see Item 31 again). Every time the class hierar-\nchy changes, each set of statements must be updated, and if you forget\none, you’ll receive no warning from your compilers.\nThese are well known and oft-repeated exhortations, but most pro-\ngrammers are still stuck in the present tense. As are many authors,\nunfortunately. Consider this advice by a well-regarded C++ expert:\nYou need a virtual destructor whenever someone deletes a B*\nthat actually points to a D.\nHere B is a base class and D is a derived class. In other words, this au-\nthor suggests that if your program looks like this, you don’t need a vir-\ntual destructor in B:\n",
      "content_length": 2604,
      "extraction_method": "Direct"
    },
    {
      "page_number": 272,
      "chapter": null,
      "content": "Programming in the Future Tense\n255\nclass B { ... };\n// no virtual dtor needed\nclass D: public B { ... };\nB *pb = new D;\nHowever, the situation changes if you add this statement:\ndelete pb;\n// NOW you need the virtual\n// destructor in B\nThe implication is that a minor change to client code — the addition of\na delete statement — can result in the need to change the class defi-\nnition for B. When that happens, all B’s clients must recompile. Follow-\ning this author’s advice, then, the addition of a single statement in one\nfunction can lead to extensive code recompilation and relinking for all\nclients of a library. This is anything but effective software design.\nOn the same topic, a different author writes:\nIf a public base class does not have a virtual destructor, no de-\nrived class nor members of a derived class should have a de-\nstructor.\nIn other words, this is okay,\nclass string {\n// from the standard C++ library\npublic:\n~string();\n};\nclass B { ... };\n// no data members with dtors,\n// no virtual dtor needed\nbut if a new class is derived from B, things change:\nclass D: public B {\nstring name;\n// NOW ~B needs to be virtual\n};\nAgain, a small change to the way B is used (here, the addition of a de-\nrived class that contains a member with a destructor) may necessitate\nextensive recompilation and relinking by clients. But small changes in\nsoftware should have small impacts on systems. This design fails that\ntest.\nThe same author writes:\nIf a multiple inheritance hierarchy has any destructors, every\nbase class should have a virtual destructor.\nIn all these quotations, note the present-tense thinking. How do clients\nmanipulate pointers now? What class members have destructors now?\nWhat classes in the hierarchy have destructors now?\n",
      "content_length": 1756,
      "extraction_method": "Direct"
    },
    {
      "page_number": 273,
      "chapter": null,
      "content": "256\nItem 32\nFuture-tense thinking is quite different. Instead of asking how a class\nis used now, it asks how the class is designed to be used. Future-tense\nthinking says, if a class is designed to be used as a base class (even if\nit’s not used as one now), it should have a virtual destructor. Such\nclasses behave correctly both now and in the future, and they don’t af-\nfect other library clients when new classes derive from them. (At least,\nthey have no effect as far as their destructor is concerned. If additional\nchanges to the class are required, other clients may be affected.)\nA commercial class library (one that predates the string specification\nin the C++ library standard) contains a string class with no virtual de-\nstructor. The vendor’s explanation?\nWe didn’t make the destructor virtual, because we didn’t want\nString to have a vtbl. We have no intention of ever having a\nString*, so this is not a problem. We are well aware of the dif-\nficulties this could cause.\nIs this present-tense or future-tense thinking?\nCertainly the vtbl issue is a legitimate technical concern (see Item 24).\nThe implementation of most String classes contains only a single\nchar* pointer inside each String object, so adding a vptr to each\nString would double the size of those objects. It is easy to understand\nwhy a vendor would be unwilling to do that, especially for a highly vis-\nible, heavily used class like String. The performance of such a class\nmight easily fall within the 20% of a program that makes a difference\n(see Item 16).\nStill, the total memory devoted to a string object — the memory for the\nobject itself plus the heap memory needed to hold the string’s value —\nis typically much greater than just the space needed to hold a char*\npointer. From this perspective, the overhead imposed by a vptr is less\nsignificant. Nevertheless, it is a legitimate technical consideration.\n(Certainly the ISO/ANSI standardization committee seems to think so:\nthe standard string type has a nonvirtual destructor.)\nSomewhat more troubling is the vendor’s remark, “We have no inten-\ntion of ever having a String*, so this is not a problem.” That may be\ntrue, but their String class is part of a library they make available to\nthousands of developers. That’s a lot of developers, each with a differ-\nent level of experience with C++, each doing something unique. Do\nthose developers understand the consequences of there being no vir-\ntual destructor in String? Are they likely to know that because\nString has no virtual destructor, deriving new classes from String is\na high-risk venture? Is this vendor confident their clients will under-\nstand that in the absence of a virtual destructor, deleting objects\nthrough String* pointers will not work properly and RTTI operations\n",
      "content_length": 2772,
      "extraction_method": "Direct"
    },
    {
      "page_number": 274,
      "chapter": null,
      "content": "Programming in the Future Tense\n257\non pointers and references to Strings may return incorrect informa-\ntion? Is this class easy to use correctly and hard to use incorrectly?\nThis vendor should provide documentation for its String class that\nmakes clear the class is not designed for derivation, but what if pro-\ngrammers overlook the caveat or flat-out fail to read the documenta-\ntion?\nAn alternative would be to use C++ itself to prohibit derivation. Item 26\ndescribes how to do this by limiting object creation to the heap and\nthen using auto_ptr objects to manipulate the heap objects. The in-\nterface for String creation would then be both unconventional and in-\nconvenient, requiring this,\nauto_ptr<String> ps(String::makeString(\"Future tense C++\"));\n...\n// treat ps as a pointer to\n// a String object, but don’t\n// worry about deleting it\ninstead of this,\nString s(\"Future tense C++\");\nbut perhaps the reduction in the risk of improperly behaving derived\nclasses would be worth the syntactic inconvenience. (For String, this\nis unlikely to be the case, but for other classes, the trade-off might well\nbe worth it.)\nThere is a need, of course, for present-tense thinking. The software\nyou’re developing has to work with current compilers; you can’t afford\nto wait until the latest language features are implemented. It has to\nrun on the hardware you currently support and it must do so under\nconfigurations your clients have available; you can’t force your cus-\ntomers to upgrade their systems or modify their operating environ-\nment. It has to offer acceptable performance now; promises of smaller,\nfaster programs some years down the line don’t generally warm the\ncockles of potential customers’ hearts. And the software you’re work-\ning on must be available “soon,” which often means some time in the\nrecent past. These are important constraints. You cannot ignore them.\nFuture-tense thinking simply adds a few additional considerations: \n■Provide complete classes, even if some parts aren’t currently used.\nWhen new demands are made on your classes, you’re less likely to\nhave to go back and modify them. \n",
      "content_length": 2117,
      "extraction_method": "Direct"
    },
    {
      "page_number": 275,
      "chapter": null,
      "content": "258\nItem 33\n■Design your interfaces to facilitate common operations and pre-\nvent common errors. Make the classes easy to use correctly, hard\nto use incorrectly. For example, prohibit copying and assignment\nfor classes where those operations make no sense. Prevent partial\nassignments (see Item 33).\n■If there is no great penalty for generalizing your code, generalize it.\nFor example, if you are writing an algorithm for tree traversal, con-\nsider generalizing it to handle any kind of directed acyclic graph.\nFuture tense thinking increases the reusability of the code you write,\nenhances its maintainability, makes it more robust, and facilitates\ngraceful change in an environment where change is a certainty. It\nmust be balanced against present-tense constraints. Too many pro-\ngrammers focus exclusively on current needs, however, and in doing\nso they sacrifice the long-term viability of the software they design and\nimplement. Be different. Be a renegade. Program in the future tense.\nItem 33: Make non-leaf classes abstract.\nMaking Non-Leaf Classes Abstract\nSuppose you’re working on a project whose software deals with ani-\nmals. Within this software, most animals can be treated pretty much\nthe same, but two kinds of animals — lizards and chickens — require\nspecial handling. That being the case, the obvious way to relate the\nclasses for animals, lizards, and chickens is like this:\nThe Animal class embodies the features shared by all the creatures\nyou deal with, and the Lizard and Chicken classes specialize Animal\nin ways appropriate for lizards and chickens, respectively.\nHere’s a sketch of the definitions for these classes:\nclass Animal {\npublic:\nAnimal& operator=(const Animal& rhs);\n...\n};\nAnimal\nLizard\nChicken\n",
      "content_length": 1734,
      "extraction_method": "Direct"
    },
    {
      "page_number": 276,
      "chapter": null,
      "content": "Making Non-Leaf Classes Abstract\n259\nclass Lizard: public Animal {\npublic:\nLizard& operator=(const Lizard& rhs);\n...\n};\nclass Chicken: public Animal {\npublic:\nChicken& operator=(const Chicken& rhs);\n...\n};\nOnly the assignment operators are shown here, but that’s more than\nenough to keep us busy for a while. Consider this code:\nLizard liz1;\nLizard liz2;\nAnimal *pAnimal1 = &liz1;\nAnimal *pAnimal2 = &liz2;\n...\n*pAnimal1 = *pAnimal2;\nThere are two problems here. First, the assignment operator invoked\non the last line is that of the Animal class, even though the objects in-\nvolved are of type Lizard. As a result, only the Animal part of liz1\nwill be modified. This is a partial assignment. After the assignment,\nliz1’s Animal members have the values they got from liz2, but\nliz1’s Lizard members remain unchanged.\nThe second problem is that real programmers write code like this. It’s\nnot uncommon to make assignments to objects through pointers, es-\npecially for experienced C programmers who have moved to C++. That\nbeing the case, we’d like to make the assignment behave in a more rea-\nsonable fashion. As Item 32 points out, our classes should be easy to\nuse correctly and difficult to use incorrectly, and the classes in the hi-\nerarchy above are easy to use incorrectly.\nOne approach to the problem is to make the assignment operators vir-\ntual. If Animal::operator= were virtual, the assignment would invoke\nthe Lizard assignment operator, which is certainly the correct one to\ncall. However, look what happens if we declare the assignment opera-\ntors virtual:\nclass Animal {\npublic:\nvirtual Animal& operator=(const Animal& rhs);\n...\n};\n",
      "content_length": 1647,
      "extraction_method": "Direct"
    },
    {
      "page_number": 277,
      "chapter": null,
      "content": "260\nItem 33\nclass Lizard: public Animal {\npublic:\nvirtual Lizard& operator=(const Animal& rhs);\n...\n};\nclass Chicken: public Animal {\npublic:\nvirtual Chicken& operator=(const Animal& rhs);\n...\n};\nDue to relatively recent changes to the language, we can customize the\nreturn value of the assignment operators so that each returns a refer-\nence to the correct class, but the rules of C++ force us to declare iden-\ntical parameter types for a virtual function in every class in which it is\ndeclared. That means the assignment operator for the Lizard and\nChicken classes must be prepared to accept any kind of Animal object\non the right-hand side of an assignment. That, in turn, means we have\nto confront the fact that code like the following is legal:\nLizard liz;\nChicken chick;\nAnimal *pAnimal1 = &liz;\nAnimal *pAnimal2 = &chick;\n...\n*pAnimal1 = *pAnimal2;\n// assign a chicken to\n// a lizard!\nThis is a mixed-type assignment: a Lizard is on the left and a Chicken\nis on the right. Mixed-type assignments aren’t usually a problem in\nC++, because the language’s strong typing generally renders them ille-\ngal. By making Animal’s assignment operator virtual, however, we\nopened the door to such mixed-type operations.\nThis puts us in a difficult position. We’d like to allow same-type assign-\nments through pointers, but we’d like to forbid mixed-type assign-\nments through those same pointers. In other words, we want to allow\nthis,\nAnimal *pAnimal1 = &liz1;\nAnimal *pAnimal2 = &liz2;\n...\n*pAnimal1 = *pAnimal2;\n// assign a lizard to a lizard\n",
      "content_length": 1540,
      "extraction_method": "Direct"
    },
    {
      "page_number": 278,
      "chapter": null,
      "content": "Making Non-Leaf Classes Abstract\n261\nbut we want to prohibit this:\nAnimal *pAnimal1 = &liz;\nAnimal *pAnimal2 = &chick;\n...\n*pAnimal1 = *pAnimal2;\n// assign a chicken to a lizard\nDistinctions such as these can be made only at runtime, because\nsometimes assigning *pAnimal2 to *pAnimal1 is valid, sometimes it’s\nnot. We thus enter the murky world of type-based runtime errors. In\nparticular, we need to signal an error inside operator= if we’re faced\nwith a mixed-type assignment, but if the types are the same, we want\nto perform the assignment in the usual fashion. \nWe can use a dynamic_cast (see Item 2) to implement this behavior.\nHere’s how to do it for Lizard’s assignment operator:\nLizard& Lizard::operator=(const Animal& rhs)\n{\n// make sure rhs is really a lizard\nconst Lizard& rhs_liz = dynamic_cast<const Lizard&>(rhs);\nproceed with a normal assignment of rhs_liz to *this;\n}\nThis function assigns rhs to *this only if rhs is really a Lizard. If it’s\nnot, the function propagates the bad_cast exception that\ndynamic_cast throws when the cast to a reference fails. (Actually, the\ntype of the exception is std::bad_cast, because the components of the\nstandard library, including the exceptions thrown by the standard\ncomponents, are in the namespace std. For an overview of the stan-\ndard library, see Item 35.)\nEven without worrying about exceptions, this function seems need-\nlessly complicated and expensive — the dynamic_cast must consult a\ntype_info structure; see Item 24 — in the common case where one\nLizard object is assigned to another:\nLizard liz1, liz2;\n...\nliz1 = liz2;\n// no need to perform a\n// dynamic_cast: this\n// assignment must be valid\nWe can handle this case without paying for the complexity or cost of a\ndynamic_cast by adding to Lizard the conventional assignment op-\nerator:\n",
      "content_length": 1808,
      "extraction_method": "Direct"
    },
    {
      "page_number": 279,
      "chapter": null,
      "content": "262\nItem 33\nclass Lizard: public Animal {\npublic:\nvirtual Lizard& operator=(const Animal& rhs);\nLizard& operator=(const Lizard& rhs);\n// add this\n...\n};\nLizard liz1, liz2;\n...\nliz1 = liz2;\n// calls operator= taking\n// a const Lizard&\nAnimal *pAnimal1 = &liz1;\nAnimal *pAnimal2 = &liz2;\n...\n*pAnimal1 = *pAnimal2;\n// calls operator= taking\n// a const Animal&\nIn fact, given this latter operator=, it’s simplicity itself to implement\nthe former one in terms of it:\nLizard& Lizard::operator=(const Animal& rhs)\n{\nreturn operator=(dynamic_cast<const Lizard&>(rhs));\n}\nThis function attempts to cast rhs to be a Lizard. If the cast succeeds,\nthe normal class assignment operator is called. Otherwise, a bad_cast\nexception is thrown.\nFrankly, all this business of checking types at runtime and using\ndynamic_casts makes me nervous. For one thing, some compilers\nstill lack support for dynamic_cast, so code that uses it, though the-\noretically portable, is not necessarily portable in practice. More impor-\ntantly, it requires that clients of Lizard and Chicken be prepared to\ncatch bad_cast exceptions and do something sensible with them each\ntime they perform an assignment. In my experience, there just aren’t\nthat many programmers who are willing to program that way. If they\ndon’t, it’s not clear we’ve gained a whole lot over our original situation\nwhere we were trying to guard against partial assignments.\nGiven this rather unsatisfactory state of affairs regarding virtual as-\nsignment operators, it makes sense to regroup and try to find a way to\nprevent clients from making problematic assignments in the first\nplace. If such assignments are rejected during compilation, we don’t\nhave to worry about them doing the wrong thing.\n",
      "content_length": 1733,
      "extraction_method": "Direct"
    },
    {
      "page_number": 280,
      "chapter": null,
      "content": "Making Non-Leaf Classes Abstract\n263\nThe easiest way to prevent such assignments is to make operator=\nprivate in Animal. That way, lizards can be assigned to lizards and\nchickens can be assigned to chickens, but partial and mixed-type as-\nsignments are forbidden:\nclass Animal {\nprivate:\nAnimal& operator=(const Animal& rhs);\n// this is now\n...\n// private\n};\nclass Lizard: public Animal {\npublic:\nLizard& operator=(const Lizard& rhs);\n...\n};\nclass Chicken: public Animal {\npublic:\nChicken& operator=(const Chicken& rhs);\n...\n};\nLizard liz1, liz2;\n...\nliz1 = liz2;\n// fine\nChicken chick1, chick2;\n...\nchick1 = chick2;\n// also fine\nAnimal *pAnimal1 = &liz1;\nAnimal *pAnimal2 = &chick1;\n...\n*pAnimal1 = *pAnimal2;\n// error! attempt to call\n// private Animal::operator=\nUnfortunately, Animal is a concrete class, and this approach also\nmakes assignments between Animal objects illegal:\nAnimal animal1, animal2;\n...\nanimal1 = animal2;\n// error! attempt to call\n// private Animal::operator=\nMoreover, it makes it impossible to implement the Lizard and\nChicken assignment operators correctly, because assignment opera-\ntors in derived classes are responsible for calling assignment operators\nin their base classes:\n",
      "content_length": 1208,
      "extraction_method": "Direct"
    },
    {
      "page_number": 281,
      "chapter": null,
      "content": "264\nItem 33\nLizard& Lizard::operator=(const Lizard& rhs)\n{\nif (this == &rhs) return *this;\nAnimal::operator=(rhs);\n// error! attempt to call \n// private function. But\n// Lizard::operator= must\n// call this function to\n...\n// assign the Animal parts\n}\n// of *this!\nWe can solve this latter problem by declaring Animal::operator= pro-\ntected, but the conundrum of allowing assignments between Animal\nobjects while preventing partial assignments of Lizard and Chicken\nobjects through Animal pointers remains. What’s a poor programmer\nto do?\nThe easiest thing is to eliminate the need to allow assignments be-\ntween Animal objects, and the easiest way to do that is to make Ani-\nmal an abstract class. As an abstract class, Animal can’t be\ninstantiated, so there will be no need to allow assignments between\nAnimals. Of course, this leads to a new problem, because our original\ndesign for this system presupposed that Animal objects were neces-\nsary. There is an easy way around this difficulty. Instead of making\nAnimal itself abstract, we create a new class — AbstractAnimal, say\n— consisting of the common features of Animal, Lizard, and Chicken\nobjects, and we make that class abstract. Then we have each of our\nconcrete classes inherit from AbstractAnimal. The revised hierarchy\nlooks like this,\nand the class definitions are as follows:\nclass AbstractAnimal {\nprotected:\nAbstractAnimal& operator=(const AbstractAnimal& rhs);\npublic:\nvirtual ~AbstractAnimal() = 0;\n// see below\n...\n};\nAbstractAnimal\nLizard\nAnimal\nChicken\n",
      "content_length": 1523,
      "extraction_method": "Direct"
    },
    {
      "page_number": 282,
      "chapter": null,
      "content": "Making Non-Leaf Classes Abstract\n265\nclass Animal: public AbstractAnimal {\npublic:\nAnimal& operator=(const Animal& rhs);\n...\n};\nclass Lizard: public AbstractAnimal {\npublic:\nLizard& operator=(const Lizard& rhs);\n...\n};\nclass Chicken: public AbstractAnimal {\npublic:\nChicken& operator=(const Chicken& rhs);\n...\n};\nThis design gives you everything you need. Homogeneous assignments\nare allowed for lizards, chickens, and animals; partial assignments\nand heterogeneous assignments are prohibited; and derived class as-\nsignment operators may call the assignment operator in the base\nclass. Furthermore, none of the code written in terms of the Animal,\nLizard, or Chicken classes requires modification, because these\nclasses continue to exist and to behave as they did before Abstract-\nAnimal was introduced. Sure, such code has to be recompiled, but\nthat’s a small price to pay for the security of knowing that assignments\nthat compile will behave intuitively and assignments that would be-\nhave unintuitively won’t compile.\nFor all this to work, AbstractAnimal must be abstract — it must con-\ntain at least one pure virtual function. In most cases, coming up with\na suitable function is not a problem, but on rare occasions you may\nfind yourself facing the need to create a class like AbstractAnimal in\nwhich none of the member functions would naturally be declared pure\nvirtual. In such cases, the conventional technique is to make the de-\nstructor a pure virtual function; that’s what’s shown above. In order to\nsupport polymorphism through pointers correctly, base classes need\nvirtual destructors anyway, so the only cost associated with making\nsuch destructors pure virtual is the inconvenience of having to imple-\nment them outside their class definitions. (For an example, see page\n195.)\n(If the notion of implementing a pure virtual function strikes you as\nodd, you just haven’t been getting out enough. Declaring a function\npure virtual doesn’t mean it has no implementation, it means \n■the current class is abstract, and \n■any concrete class inheriting from the current class must declare\nthe function as a “normal” virtual function (i.e., without the “=0”).\n",
      "content_length": 2167,
      "extraction_method": "Direct"
    },
    {
      "page_number": 283,
      "chapter": null,
      "content": "266\nItem 33\nTrue, most pure virtual functions are never implemented, but pure vir-\ntual destructors are a special case. They must be implemented, be-\ncause they are called whenever a derived class destructor is invoked.\nFurthermore, they often perform useful tasks, such as releasing re-\nsources (see Item 9) or logging messages. Implementing pure virtual\nfunctions may be uncommon in general, but for pure virtual destruc-\ntors, it’s not just common, it’s mandatory.)\nYou may have noticed that this discussion of assignment through base\nclass pointers is based on the assumption that concrete derived\nclasses like Lizard contain data members. If there are no data mem-\nbers in a derived class, you might point out, there is no problem, and\nit would be safe to have a dataless concrete class inherit from another\nconcrete class. However, just because a class has no data now is no\nreason to conclude that it will have no data in the future. If it might\nhave data members in the future, all you’re doing is postponing the\nproblem until the data members are added, in which case you’re\nmerely trading short-term convenience for long-term grief (see also\nItem 32). \nReplacement of a concrete base class like Animal with an abstract\nbase class like AbstractAnimal yields benefits far beyond simply\nmaking the behavior of operator= easier to understand. It also re-\nduces the chances that you’ll try to treat arrays polymorphically, the\nunpleasant consequences of which are examined in Item 3. The most\nsignificant benefit of the technique, however, occurs at the design level,\nbecause replacing concrete base classes with abstract base classes\nforces you to explicitly recognize the existence of useful abstractions.\nThat is, it makes you create new abstract classes for useful concepts,\neven if you aren’t aware of the fact that the useful concepts exist.\nIf you have two concrete classes C1 and C2 and you’d like C2 to pub-\nlicly inherit from C1, you should transform that two-class hierarchy\ninto a three-class hierarchy by creating a new abstract class A and\nhaving both C1 and C2 publicly inherit from it:\nA\nC2\nC1\nC2\nYour initial idea\nYour transformed hierarchy\nC1\n",
      "content_length": 2166,
      "extraction_method": "Direct"
    },
    {
      "page_number": 284,
      "chapter": null,
      "content": "Making Non-Leaf Classes Abstract\n267\nThe primary value of this transformation is that it forces you to identify\nthe abstract class A. Clearly, C1 and C2 have something in common;\nthat’s why they’re related by public inheritance. With this transforma-\ntion, you must identify what that something is. Furthermore, you must\nformalize the something as a class in C++, at which point it becomes\nmore than just a vague something, it achieves the status of a formal\nabstraction, one with well-defined member functions and well-defined\nsemantics.\nAll of which leads to some worrisome thinking. After all, every class\nrepresents some kind of abstraction, so shouldn’t we create two\nclasses for every concept in our hierarchy, one being abstract (to em-\nbody the abstract part of the abstraction) and one being concrete (to\nembody the object-generation part of the abstraction)? No. If you do,\nyou’ll end up with a hierarchy with too many classes. Such a hierarchy\nis difficult to understand, hard to maintain, and expensive to compile.\nThat is not the goal of object-oriented design.\nThe goal is to identify useful abstractions and to force them — and only\nthem — into existence as abstract classes. But how do you identify\nuseful abstractions? Who knows what abstractions might prove useful\nin the future? Who can predict who’s going to want to inherit from\nwhat?\nWell, I don’t know how to predict the future uses of an inheritance hi-\nerarchy, but I do know one thing: the need for an abstraction in one\ncontext may be coincidental, but the need for an abstraction in more\nthan one context is usually meaningful. Useful abstractions, then, are\nthose that are needed in more than one context. That is, they corre-\nspond to classes that are useful in their own right (i.e., it is useful to\nhave objects of that type) and that are also useful for purposes of one\nor more derived classes. \nThis is precisely why the transformation from concrete base class to\nabstract base class is useful: it forces the introduction of a new ab-\nstract class only when an existing concrete class is about to be used as\na base class, i.e., when the class is about to be (re)used in a new con-\ntext. Such abstractions are useful, because they have, through demon-\nstrated need, shown themselves to be so. \nThe first time a concept is needed, we can’t justify the creation of both\nan abstract class (for the concept) and a concrete class (for the objects\ncorresponding to that concept), but the second time that concept is\nneeded, we can justify the creation of both the abstract and the con-\ncrete classes. The transformation I’ve described simply mechanizes\nthis process, and in so doing it forces designers and programmers to\nrepresent explicitly those abstractions that are useful, even if the de-\n",
      "content_length": 2772,
      "extraction_method": "Direct"
    },
    {
      "page_number": 285,
      "chapter": null,
      "content": "268\nItem 33\nsigners and programmers are not consciously aware of the useful con-\ncepts. It also happens to make it a lot easier to bring sanity to the\nbehavior of assignment operators.\nLet’s consider a brief example. Suppose you’re working on an applica-\ntion that deals with moving information between computers on a net-\nwork by breaking it into packets and transmitting them according to\nsome protocol. All we’ll consider here is the class or classes for repre-\nsenting packets. We’ll assume such classes make sense for this appli-\ncation. \nSuppose you deal with only a single kind of transfer protocol and only\na single kind of packet. Perhaps you’ve heard that other protocols and\npacket types exist, but you’ve never supported them, nor do you have\nany plans to support them in the future. Should you make an abstract\nclass for packets (for the concept that a packet represents) as well as a\nconcrete class for the packets you’ll actually be using? If you do, you\ncould hope to add new packet types later without changing the base\nclass for packets. That would save you from having to recompile\npacket-using applications if you add new packet types. But that design\nrequires two classes, and right now you need only one (for the particu-\nlar type of packets you use). Is it worth complicating your design now\nto allow for future extension that may never take place?\nThere is no unequivocally correct choice to be made here, but experi-\nence has shown it is nearly impossible to design good classes for con-\ncepts we do not understand well. If you create an abstract class for\npackets, how likely are you to get it right, especially since your experi-\nence is limited to only a single packet type? Remember that you gain\nthe benefit of an abstract class for packets only if you can design that\nclass so that future classes can inherit from it without its being\nchanged in any way. (If it needs to be changed, you have to recompile\nall packet clients, and you’ve gained nothing.)\nIt is unlikely you could design a satisfactory abstract packet class un-\nless you were well versed in many different kinds of packets and in the\nvaried contexts in which they are used. Given your limited experience\nin this case, my advice would be not to define an abstract class for\npackets, adding one later only if you find a need to inherit from the\nconcrete packet class.\nThe transformation I’ve described here is a way to identify the need for\nabstract classes, not the way. There are many other ways to identify\ngood candidates for abstract classes; books on object-oriented analysis\nare filled with them. It’s not the case that the only time you should in-\ntroduce abstract classes is when you find yourself wanting to have a\nconcrete class inherit from another concrete class. However, the desire\n",
      "content_length": 2790,
      "extraction_method": "Direct"
    },
    {
      "page_number": 286,
      "chapter": null,
      "content": "Making Non-Leaf Classes Abstract\n269\nto relate two concrete classes by public inheritance is usually indica-\ntive of a need for a new abstract class.\nAs is often the case in such matters, brash reality sometimes intrudes\non the peaceful ruminations of theory. Third-party C++ class libraries\nare proliferating with gusto, and what are you to do if you find yourself\nwanting to create a concrete class that inherits from a concrete class\nin a library to which you have only read access?\nYou can’t modify the library to insert a new abstract class, so your\nchoices are both limited and unappealing:\n■Derive your concrete class from the existing concrete class, and\nput up with the assignment-related problems we examined at the\nbeginning of this Item. You’ll also have to watch out for the array-\nrelated pitfalls described in Item 3.\n■Try to find an abstract class higher in the library hierarchy that\ndoes most of what you need, then inherit from that class. Of\ncourse, there may not be a suitable class, and even if there is, you\nmay have to duplicate a lot of effort that has already been put into\nthe implementation of the concrete class whose functionality you’d\nlike to extend.\n■Implement your new class in terms of the library class you’d like\nto inherit from. For example, you could have an object of the li-\nbrary class as a data member, then reimplement the library class’s\ninterface in your new class:\nclass Window {\n// this is the library class\npublic:\nvirtual void resize(int newWidth, int newHeight);\nvirtual void repaint() const;\nint width() const;\nint height() const;\n};\nclass SpecialWindow {\n// this is the class you\npublic:\n// wanted to have inherit\n...\n// from Window\n// pass-through implementations of nonvirtual functions\nint width() const { return w.width(); }\nint height() const { return w.height(); }\n// new implementations of \"inherited\" virtual functions\nvirtual void resize(int newWidth, int newHeight);\nvirtual void repaint() const;\nprivate:\nWindow w;\n};\n",
      "content_length": 1982,
      "extraction_method": "Direct"
    },
    {
      "page_number": 287,
      "chapter": null,
      "content": "270\nItem 34\nThis strategy requires that you be prepared to update your class\neach time the library vendor updates the class on which you’re de-\npendent. It also requires that you be willing to forgo the ability to\nredefine virtual functions declared in the library class, because\nyou can’t redefine virtual functions unless you inherit them.\n■Make do with what you’ve got. Use the concrete class that’s in the\nlibrary and modify your software so that the class suffices. Write\nnon-member functions to provide the functionality you’d like to\nadd to the class, but can’t. The resulting software may not be as\nclear, as efficient, as maintainable, or as extensible as you’d like,\nbut at least it will get the job done.\nNone of these choices is particularly attractive, so you have to apply\nsome engineering judgment and choose the poison you find least un-\nappealing. It’s not much fun, but life’s like that sometimes. To make\nthings easier for yourself (and the rest of us) in the future, complain to\nthe vendors of libraries whose designs you find wanting. With luck\n(and a lot of comments from clients), those designs will improve as time\ngoes on.\nStill, the general rule remains: non-leaf classes should be abstract.\nYou may need to bend the rule when working with outside libraries,\nbut in code over which you have control, adherence to it will yield div-\nidends in the form of increased reliability, robustness, comprehensibil-\nity, and extensibility throughout your software.\nItem 34: Understand how to combine C++ and C in the \nsame program.\nCombining C++ and C in the Same Program\nIn many ways, the things you have to worry about when making a pro-\ngram out of some components in C++ and some in C are the same as\nthose you have to worry about when cobbling together a C program out\nof object files produced by more than one C compiler. There is no way\nto combine such files unless the different compilers agree on imple-\nmentation-dependent features like the size of ints and doubles, the\nmechanism by which parameters are passed from caller to callee, and\nwhether the caller or the callee orchestrates the passing. These prag-\nmatic aspects of mixed-compiler software development are quite prop-\nerly ignored by language standardization efforts, so the only reliable\nway to know that object files from compiler A and compiler B can be\nsafely combined in a program is to obtain assurances from the vendors\nof A and B that their products produce compatible output. This is as\ntrue for programs made up of C++ and C as it is for all-C++ or all-C\nprograms, so before you try to mix C++ and C in the same program,\nmake sure your C++ and C compilers generate compatible object files.\n",
      "content_length": 2686,
      "extraction_method": "Direct"
    },
    {
      "page_number": 288,
      "chapter": null,
      "content": "Combining C++ and C in the Same Program\n271\nHaving done that, there are four other things you need to consider:\nname mangling, initialization of statics, dynamic memory allocation,\nand data structure compatibility.\nName Mangling\nName mangling, as you may know, is the process through which your\nC++ compilers give each function in your program a unique name. In\nC, this process is unnecessary, because you can’t overload function\nnames, but nearly all C++ programs have at least a few functions with\nthe same name. (Consider, for example, the iostream library, which de-\nclares several versions of operator<< and operator>>.) Overloading\nis incompatible with most linkers, because linkers generally take a dim\nview of multiple functions with the same name. Name mangling is a\nconcession to the realities of linkers; in particular, to the fact that link-\ners usually insist on all function names being unique.\nAs long as you stay within the confines of C++, name mangling is not\nlikely to concern you. If you have a function name drawLine that a\ncompiler mangles into xyzzy, you’ll always use the name drawLine,\nand you’ll have little reason to care that the underlying object files\nhappen to refer to xyzzy.\nIt’s a different story if drawLine is in a C library. In that case, your C++\nsource file probably includes a header file that contains a declaration\nlike this,\nvoid drawLine(int x1, int y1, int x2, int y2);\nand your code contains calls to drawLine in the usual fashion. Each\nsuch call is translated by your compilers into a call to the mangled\nname of that function, so when you write this,\ndrawLine(a, b, c, d);\n// call to unmangled function name\nyour object files contain a function call that corresponds to this:\nxyzzy(a, b, c, d);\n// call to mangled function mame\nBut if drawLine is a C function, the object file (or archive or dynami-\ncally linked library, etc.) that contains the compiled version of draw-\nLine contains a function called drawLine; no name mangling has\ntaken place. When you try to link the object files comprising your pro-\ngram together, you’ll get an error, because the linker is looking for a\nfunction called xyzzy, and there is no such function.\nTo solve this problem, you need a way to tell your C++ compilers not to\nmangle certain function names. You never want to mangle the names\nof functions written in other languages, whether they be in C, assem-\nbler, FORTRAN, Lisp, Forth, or what-have-you. (Yes, what-have-you\n",
      "content_length": 2455,
      "extraction_method": "Direct"
    },
    {
      "page_number": 289,
      "chapter": null,
      "content": "272\nItem 34\nwould include COBOL, but then what would you have?) After all, if you\ncall a C function named drawLine, it’s really called drawLine, and\nyour object code should contain a reference to that name, not to some\nmangled version of that name.\nTo suppress name mangling, use C++’s extern \"C\" directive:\n// declare a function called drawLine; don’t mangle\n// its name\nextern \"C\" \nvoid drawLine(int x1, int y1, int x2, int y2);\nDon’t be drawn into the trap of assuming that where there’s an extern\n\"C\", there must be an extern \"Pascal\" and an extern \"FORTRAN\" as\nwell. There’s not, at least not in the standard. The best way to view ex-\ntern \"C\" is not as an assertion that the associated function is written\nin C, but as a statement that the function should be called as if it were\nwritten in C. (Technically, extern \"C\" means the function has C link-\nage, but what that means is far from clear. One thing it always means,\nhowever, is that name mangling is suppressed.) \nFor example, if you were so unfortunate as to have to write a function\nin assembler, you could declare it extern \"C\", too:\n// this function is in assembler — don’t mangle its name\nextern \"C\" void twiddleBits(unsigned char bits);\nYou can even declare C++ functions extern \"C\". This can be useful if\nyou’re writing a library in C++ that you’d like to provide to clients using\nother programming languages. By suppressing the name mangling of\nyour C++ function names, your clients can use the natural and intui-\ntive names you choose instead of the mangled names your compilers\nwould otherwise generate:\n// the following C++ function is designed for use outside\n// C++ and should not have its name mangled\nextern \"C\" void simulate(int iterations);\nOften you’ll have a slew of functions whose names you don’t want\nmangled, and it would be a pain to precede each with extern \"C\". For-\ntunately, you don’t have to. extern \"C\" can also be made to apply to\na whole set of functions. Just enclose them all in curly braces:\nextern \"C\" {\n// disable name mangling for\n// all the following functions\nvoid drawLine(int x1, int y1, int x2, int y2);\nvoid twiddleBits(unsigned char bits);\nvoid simulate(int iterations);\n...\n}\n",
      "content_length": 2183,
      "extraction_method": "Direct"
    },
    {
      "page_number": 290,
      "chapter": null,
      "content": "Combining C++ and C in the Same Program\n273\nThis use of extern \"C\" simplifies the maintenance of header files that\nmust be used with both C++ and C. When compiling for C++, you’ll\nwant to include extern \"C\", but when compiling for C, you won’t. By\ntaking advantage of the fact that the preprocessor symbol\n__cplusplus is defined only for C++ compilations, you can structure\nyour polyglot header files as follows:\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nvoid drawLine(int x1, int y1, int x2, int y2);\nvoid twiddleBits(unsigned char bits);\nvoid simulate(int iterations);\n...\n#ifdef __cplusplus\n}\n#endif\nThere is, by the way, no such thing as a “standard” name mangling al-\ngorithm. Different compilers are free to mangle names in different\nways, and different compilers do. This is a good thing. If all compilers\nmangled names the same way, you might be lulled into thinking they\nall generated compatible code. The way things are now, if you try to\nmix object code from incompatible C++ compilers, there’s a good\nchance you’ll get an error during linking, because the mangled names\nwon’t match up. This implies you’ll probably have other compatibility\nproblems, too, and it’s better to find out about such incompatibilities\nsooner than later,\nInitialization of Statics\nOnce you’ve mastered name mangling, you need to deal with the fact\nthat in C++, lots of code can get executed before and after main. In par-\nticular, the constructors of static class objects and objects at global,\nnamespace, and file scope are usually called before the body of main is\nexecuted. This process is known as static initialization. This is in direct\nopposition to the way we normally think about C++ and C programs,\nin which we view main as the entry point to execution of the program.\nSimilarly, objects that are created through static initialization must\nhave their destructors called during static destruction; that process\ntypically takes place after main has finished executing.\nTo resolve the dilemma that main is supposed to be invoked first, yet\nobjects need to be constructed before main is executed, many compil-\ners insert a call to a special compiler-written function at the beginning\n",
      "content_length": 2175,
      "extraction_method": "Direct"
    },
    {
      "page_number": 291,
      "chapter": null,
      "content": "274\nItem 34\nof main, and it is this special function that takes care of static initial-\nization. Similarly, compilers often insert a call to another special func-\ntion at the end of main to take care of the destruction of static objects.\nCode generated for main often looks as if main had been written like\nthis:\nint main(int argc, char *argv[])\n{\nperformStaticInitialization();\n// generated by the \n// implementation\nthe statements you put in main go here;\nperformStaticDestruction();\n// generated by the\n// implementation\n}\nNow don’t take this too literally. The functions performStaticIni-\ntialization and performStaticDestruction usually have much\nmore cryptic names, and they may even be generated inline, in which\ncase you won’t see any functions for them in your object files. The im-\nportant point is this: if a C++ compiler adopts this approach to the ini-\ntialization and destruction of static objects, such objects will be\nneither initialized nor destroyed unless main is written in C++. Be-\ncause this approach to static initialization and destruction is common,\nyou should try to write main in C++ if you write any part of a software\nsystem in C++.\nSometimes it would seem to make more sense to write main in C — say\nif most of a program is in C and C++ is just a support library. Never-\ntheless, there’s a good chance the C++ library contains static objects (if\nit doesn’t now, it probably will in the future — see Item 32), so it’s still\na good idea to write main in C++ if you possibly can. That doesn’t mean\nyou need to rewrite your C code, however. Just rename the main you\nwrote in C to be realMain, then have the C++ version of main call\nrealMain:\nextern \"C\"\n// implement this\nint realMain(int argc, char *argv[]);\n// function in C\nint main(int argc, char *argv[])\n// write this in C++\n{\nreturn realMain(argc, argv);\n}\nIf you do this, it’s a good idea to put a comment above main explaining\nwhat is going on.\nIf you cannot write main in C++, you’ve got a problem, because there is\nno other portable way to ensure that constructors and destructors for\nstatic objects are called. This doesn’t mean all is lost, it just means\n",
      "content_length": 2143,
      "extraction_method": "Direct"
    },
    {
      "page_number": 292,
      "chapter": null,
      "content": "Combining C++ and C in the Same Program\n275\nyou’ll have to work a little harder. Compiler vendors are well ac-\nquainted with this problem, so almost all provide some extralinguistic\nmechanism for initiating the process of static initialization and static\ndestruction. For information on how this works with your compilers,\ndig into your compilers’ documentation or contact their vendors.\nDynamic Memory Allocation\nThat brings us to dynamic memory allocation. The general rule is sim-\nple: the C++ parts of a program use new and delete (see Item 8), and\nthe C parts of a program use malloc (and its variants) and free. As\nlong as memory that came from new is deallocated via delete and\nmemory that came from malloc is deallocated via free, all is well.\nCalling free on a newed pointer yields undefined behavior, however, as\ndoes deleteing a malloced pointer. The only thing to remember, then,\nis to segregate rigorously your news and deletes from your mallocs\nand frees.\nSometimes this is easier said than done. Consider the humble (but\nhandy) strdup function, which, though standard in neither C nor C++,\nis nevertheless widely available:\nchar * strdup(const char *ps);\n// return a copy of the\n// string pointed to by ps\nIf a memory leak is to be avoided, the memory allocated inside strdup\nmust be deallocated by strdup’s caller. But how is the memory to be\ndeallocated? By using delete? By calling free? If the strdup you’re\ncalling is from a C library, it’s the latter. If it was written for a C++ li-\nbrary, it’s probably the former. What you need to do after calling str-\ndup, then, varies not only from system to system, but also from\ncompiler to compiler. To reduce such portability headaches, try to\navoid calling functions that are neither in the standard library (see\nItem 35) nor available in a stable form on most computing platforms.\nData Structure Compatibility\nWhich brings us at long last to passing data between C++ and C pro-\ngrams. There’s no hope of making C functions understand C++ fea-\ntures, so the level of discourse between the two languages must be\nlimited to those concepts that C can express. Thus, it should be clear\nthere’s no portable way to pass objects or to pass pointers to member\nfunctions to routines written in C. C does understand normal pointers,\nhowever, so, provided your C++ and C compilers produce compatible\noutput, functions in the two languages can safely exchange pointers to\nobjects and pointers to non-member or static functions. Naturally,\n",
      "content_length": 2492,
      "extraction_method": "Direct"
    },
    {
      "page_number": 293,
      "chapter": null,
      "content": "276\nItem 34\nstructs and variables of built-in types (e.g., ints, chars, etc.) can also\nfreely cross the C++/C border.\nBecause the rules governing the layout of a struct in C++ are consis-\ntent with those of C, it is safe to assume that a structure definition that\ncompiles in both languages is laid out the same way by both compilers.\nSuch structs can be safely passed back and forth between C++ and C.\nIf you add nonvirtual functions to the C++ version of the struct, its\nmemory layout should not change, so objects of a struct (or class) con-\ntaining only non-virtual functions should be compatible with their C\nbrethren whose structure definition lacks only the member function\ndeclarations. Adding virtual functions ends the game, because the ad-\ndition of virtual functions to a class causes objects of that type to use\na different memory layout (see Item 24). Having a struct inherit from\nanother struct (or class) usually changes its layout, too, so structs with\nbase structs (or classes) are also poor candidates for exchange with C\nfunctions.\nFrom a data structure perspective, it boils down to this: it is safe to\npass data structures from C++ to C and from C to C++ provided the\ndefinition of those structures compiles in both C++ and C. Adding non-\nvirtual member functions to the C++ version of a struct that’s other-\nwise compatible with C will probably not affect its compatibility, but\nalmost any other change to the struct will.\nSummary\nIf you want to mix C++ and C in the same program, remember the fol-\nlowing simple guidelines:\n■Make sure the C++ and C compilers produce compatible object\nfiles.\n■Declare functions to be used by both languages extern \"C\".\n■If at all possible, write main in C++.\n■Always use delete with memory from new; always use free with\nmemory from malloc.\n■Limit what you pass between the two languages to data structures\nthat compile under C; the C++ version of structs may contain non-\nvirtual member functions.\n",
      "content_length": 1956,
      "extraction_method": "Direct"
    },
    {
      "page_number": 294,
      "chapter": null,
      "content": "The C++ Language and Library Standard\n277\nItem 35: Familiarize yourself with the language \nstandard.\nThe C++ Language and Library Standard\nSince its publication in 1990, The Annotated C++ Reference Manual\n(see page 285) has been the definitive reference for working program-\nmers needing to know what is in C++ and what is not. In the years\nsince the ARM (as it’s fondly known) came out, the ISO/ANSI commit-\ntee standardizing the language has changed (primarily extended) the\nlanguage in ways both big and small. As a definitive reference, the\nARM no longer suffices. \nThe post-ARM changes to C++ significantly affect how good programs\nare written. As a result, it is important for C++ programmers to be fa-\nmiliar with the primary ways in which the C++ specified by the stan-\ndard differs from that described by the ARM.\nThe ISO/ANSI standard for C++ is what vendors will consult when im-\nplementing compilers, what authors will examine when preparing\nbooks, and what programmers will look to for definitive answers to\nquestions about C++. Among the most important changes to C++ since\nthe ARM are the following:\n■New features have been added: RTTI, namespaces, bool, the mu-\ntable and explicit keywords, the ability to overload operators\nfor enums, and the ability to initialize constant integral static\nclass members within a class definition.\n■Templates have been extended: member templates are now al-\nlowed, there is a standard syntax for forcing template instantia-\ntions, non-type arguments are now allowed in function templates,\nand class templates may themselves be used as template argu-\nments.\n■Exception handling has been refined: exception specifications\nare now more rigorously checked during compilation, and the un-\nexpected function may now throw a bad_exception object.\n■Memory allocation routines have been modified: operator\nnew[] and operator delete[] have been added, the operators\nnew/new[] now throw an exception if memory can’t be allocated,\nand there are now alternative versions of the operators new/new[]\nthat return 0 when an allocation fails.\n",
      "content_length": 2075,
      "extraction_method": "Direct"
    },
    {
      "page_number": 295,
      "chapter": null,
      "content": "278\nItem 35\n■New casting forms have been added: static_cast, dynamic_cast,\nconst_cast, and reinterpret_cast.\n■Language rules have been refined: redefinitions of virtual func-\ntions need no longer have a return type that exactly matches that\nof the function they redefine, and the lifetime of temporary objects\nhas been defined precisely.\nAlmost all these changes are described in The Design and Evolution of\nC++ (see page 285). Current C++ textbooks (those written after 1994)\nshould include them, too. (If you find one that doesn’t, reject it.) In ad-\ndition, More Effective C++ (that’s this book) contains examples of how\nto use most of these new features. If you’re curious about something\non this list, try looking it up in the index.\nThe changes to C++ proper pale in comparison to what’s happened to\nthe standard library. Furthermore, the evolution of the standard li-\nbrary has not been as well publicized as that of the language. The De-\nsign and Evolution of C++, for example, makes almost no mention of\nthe standard library. The books that do discuss the library are some-\ntimes out of date, because the library changed quite substantially in\n1994.\nThe capabilities of the standard library can be broken down into the\nfollowing general categories:\n■Support for the standard C library. Fear not, C++ still remem-\nbers its roots. Some minor tweaks have brought the C++ version of\nthe C library into conformance with C++’s stricter type checking,\nbut for all intents and purposes, everything you know and love (or\nhate) about the C library continues to be knowable and lovable (or\nhateable) in C++, too.\n■Support for strings. As Chair of the working group for the stan-\ndard C++ library, Mike Vilot was told, “If there isn’t a standard\nstring type, there will be blood in the streets!” (Some people get\nso emotional.) Calm yourself and put away those hatchets and\ntruncheons — the standard C++ library has strings. \n■Support for localization. Different cultures use different charac-\nter sets and follow different conventions when displaying dates\nand times, sorting strings, printing monetary values, etc. Localiza-\ntion support within the standard library facilitates the develop-\nment of programs that accommodate such cultural differences. \n■Support for I/O. The iostream library remains part of the C++\nstandard, but the committee has tinkered with it a bit. Though\nsome classes have been eliminated (notably iostream and\nfstream) and some have been replaced (e.g., string-based\n",
      "content_length": 2491,
      "extraction_method": "Direct"
    },
    {
      "page_number": 296,
      "chapter": null,
      "content": "The C++ Language and Library Standard\n279\nstringstreams replace char*-based strstreams, which are now\ndeprecated), the basic capabilities of the standard iostream\nclasses mirror those of the implementations that have existed for\nseveral years.\n■Support for numeric applications. Complex numbers, long a\nmainstay of examples in C++ texts, have finally been enshrined in\nthe standard library. In addition, the library contains special array\nclasses (valarrays) that restrict aliasing. These arrays are eligible\nfor more aggressive optimization than are built-in arrays, espe-\ncially on multiprocessing architectures. The library also provides a\nfew commonly useful numeric functions, including partial sum\nand adjacent difference.\n■Support for general-purpose containers and algorithms. Con-\ntained within the standard C++ library is a set of class and func-\ntion templates collectively known as the Standard Template\nLibrary (STL). The STL is the most revolutionary part of the stan-\ndard C++ library. I summarize its features below.\nBefore I describe the STL, though, I must dispense with two idiosyn-\ncrasies of the standard C++ library you need to know about.\nFirst, almost everything in the library is a template. In this book, I may\nhave referred to the standard string class, but in fact there is no such\nclass. Instead, there is a class template called basic_string that rep-\nresents sequences of characters, and this template takes as a param-\neter the type of the characters making up the sequences. This allows\nfor strings to be made up of chars, wide chars, Unicode chars, what-\never.\nWhat we normally think of as the string class is really the template\ninstantiation basic_string<char>. Because its use is so common,\nthe standard library provides a typedef:\ntypedef basic_string<char> string;\nEven this glosses over many details, because the basic_string tem-\nplate takes three arguments; all but the first have default values. To re-\nally understand the string type, you must face this full, unexpurgated\ndeclaration of basic_string:\ntemplate<class charT, \nclass traits = char_traits<charT>,\nclass Allocator = allocator<charT> >\nclass basic_string;\nYou don’t need to understand this gobbledygook to use the string\ntype, because even though string is a typedef for The Template In-\nstantiation from Hell, it behaves as if it were the unassuming non-tem-\n",
      "content_length": 2365,
      "extraction_method": "Direct"
    },
    {
      "page_number": 297,
      "chapter": null,
      "content": "280\nItem 35\nplate class the typedef makes it appear to be. Just tuck away in the\nback of your mind the fact that if you ever need to customize the types\nof characters that go into strings, or if you want to fine-tune the behav-\nior of those characters, or if you want to seize control over the way\nmemory for strings is allocated, the basic_string template allows\nyou to do these things. \nThe approach taken in the design of the string type — generalize it\nand make the generalization a template — is repeated throughout the\nstandard C++ library. IOstreams? They’re templates; a type parameter\ndefines the type of character making up the streams. Complex num-\nbers? Also templates; a type parameter defines how the components of\nthe numbers should be stored. Valarrays? Templates; a type parame-\nter specifies what’s in each array. And of course the STL consists al-\nmost entirely of templates. If you are not comfortable with templates,\nnow would be an excellent time to start making serious headway to-\nward that goal.\nThe other thing to know about the standard library is that virtually ev-\nerything it contains is inside the namespace std. To use things in the\nstandard library without explicitly qualifying their names, you’ll have\nto employ a using directive or (preferably) using declarations. Fortu-\nnately, this syntactic administrivia is automatically taken care of when\nyou #include the appropriate headers. \nThe Standard Template Library\nThe biggest news in the standard C++ library is the STL, the Standard\nTemplate Library. (Since almost everything in the C++ library is a tem-\nplate, the name STL is not particularly descriptive. Nevertheless, this\nis the name of the containers and algorithms portion of the library, so\ngood name or bad, this is what we use.)\nThe STL is likely to influence the organization of many — perhaps most\n— C++ libraries, so it’s important that you be familiar with its general\nprinciples. They are not difficult to understand. The STL is based on\nthree fundamental concepts: containers, iterators, and algorithms.\nContainers hold collections of objects. Iterators are pointer-like objects\nthat let you walk through STL containers just as you’d use pointers to\nwalk through built-in arrays. Algorithms are functions that work on\nSTL containers and that use iterators to help them do their work.\nIt is easiest to understand the STL view of the world if we remind our-\nselves of the C++ (and C) rules for arrays. There is really only one rule\nwe need to know: a pointer to an array can legitimately point to any el-\nement of the array or to one element beyond the end of the array. If the\npointer points to the element beyond the end of the array, it can be\n",
      "content_length": 2698,
      "extraction_method": "Direct"
    },
    {
      "page_number": 298,
      "chapter": null,
      "content": "The C++ Language and Library Standard\n281\ncompared only to other pointers to the array; the results of dereferenc-\ning it are undefined. \nWe can take advantage of this rule to write a function to find a partic-\nular value in an array. For an array of integers, our function might look\nlike this:\nint * find(int *begin, int *end, int value)\n{\nwhile (begin != end && *begin != value) ++begin;\nreturn begin;\n}\nThis function looks for value in the range between begin and end (ex-\ncluding end — end points to one beyond the end of the array) and re-\nturns a pointer to the first occurrence of value in the array; if none is\nfound, it returns end.\nReturning end seems like a funny way to signal a fruitless search.\nWouldn’t 0 (the null pointer) be better? Certainly null seems more nat-\nural, but that doesn’t make it “better.” The find function must return\nsome distinctive pointer value to indicate the search failed, and for this\npurpose, the end pointer is as good as the null pointer. In addition, as\nwe’ll soon see, the end pointer generalizes to other types of containers\nbetter than the null pointer.\nFrankly, this is probably not the way you’d write the find function,\nbut it’s not unreasonable, and it generalizes astonishingly well. If you\nfollowed this simple example, you have mastered most of the ideas on\nwhich the STL is founded.\nYou could use the find function like this:\nint values[50];\n...\nint *firstFive = find(values, \n// search the range\nvalues+50,\n// values[0] - values[49]\n5);\n// for the value 5\nif (firstFive != values+50) {\n// did the search succeed?\n...\n// yes\n}\nelse {\n...\n// no, the search failed\n}\nYou can also use find to search subranges of the array:\n",
      "content_length": 1679,
      "extraction_method": "Direct"
    },
    {
      "page_number": 299,
      "chapter": null,
      "content": "282\nItem 35\nint *firstFive = find(values, \n// search the range\nvalues+10,\n// values[0] - values[9]\n5);\n// for the value 5\nint age = 36;\n...\nint *firstValue = find(values+10, // search the range\nvalues+20, // values[10] - values[19]\nage);\n// for the value in age\nThere’s nothing inherent in the find function that limits its applicabil-\nity to arrays of ints, so it should really be a template:\ntemplate<class T>\nT * find(T *begin, T *end, const T& value)\n{\nwhile (begin != end && *begin != value) ++begin;\nreturn begin;\n}\nIn the transformation to a template, notice how we switched from\npass-by-value for value to pass-by-reference-to-const. That’s be-\ncause now that we’re passing arbitrary types around, we have to worry\nabout the cost of pass-by-value. Each by-value parameter costs us a\ncall to the parameter’s constructor and destructor every time the func-\ntion is invoked. We avoid these costs by using pass-by-reference,\nwhich involves no object construction or destruction.\nThis template is nice, but it can be generalized further. Look at the op-\nerations on begin and end. The only ones used are comparison for in-\nequality, dereferencing, prefix increment (see Item 6), and copying (for\nthe function’s return value — see Item 19). These are all operations we\ncan overload, so why limit find to using pointers? Why not allow any\nobject that supports these operations to be used in addition to point-\ners? Doing so would free the find function from the built-in meaning\nof pointer operations. For example, we could define a pointer-like ob-\nject for a linked list whose prefix increment operator moved us to the\nnext element in the list.\nThis is the concept behind STL iterators. Iterators are pointer-like ob-\njects designed for use with STL containers. They are first cousins to\nthe smart pointers of Item 28, but smart pointers tend to be more am-\nbitious in what they do than do STL iterators. From a technical view-\npoint, however, they are implemented using the same techniques.\nEmbracing the notion of iterators as pointer-like objects, we can re-\nplace the pointers in find with iterators, thus rewriting find like this:\n",
      "content_length": 2139,
      "extraction_method": "Direct"
    },
    {
      "page_number": 300,
      "chapter": null,
      "content": "The C++ Language and Library Standard\n283\ntemplate<class Iterator, class T>\nIterator find(Iterator begin, Iterator end, const T& value)\n{\nwhile (begin != end && *begin != value) ++begin;\nreturn begin;\n}\nCongratulations! You have just written part of the Standard Template\nLibrary. The STL contains dozens of algorithms that work with con-\ntainers and iterators, and find is one of them. \nContainers in STL include bitset, vector, list, deque, queue,\npriority_queue, stack, set, and map, and you can apply find to\nany of these container types:\nlist<char> charList;\n// create STL list object\n// for holding chars\n...\n// find the first occurrence of ’x’ in charList\nlist<char>::iterator it = find(charList.begin(),\ncharList.end(),\n’x’);\n“Whoa!”, I hear you cry, “This doesn’t look anything like it did in the\narray examples above!” Ah, but it does; you just have to know what to\nlook for. \nTo call find for a list object, you need to come up with iterators that\npoint to the first element of the list and to one past the last element of\nthe list. Without some help from the list class, this is a difficult task,\nbecause you have no idea how a list is implemented. Fortunately,\nlist (like all STL containers) obliges by providing the member func-\ntions begin and end. These member functions return the iterators you\nneed, and it is those iterators that are passed into the first two param-\neters of find above.\nWhen find is finished, it returns an iterator object that points to the\nfound element (if there is one) or to charList.end() (if there’s not).\nBecause you know nothing about how list is implemented, you also\nknow nothing about how iterators into lists are implemented. How,\nthen, are you to know what type of object is returned by find? Again,\nthe list class, like all STL containers, comes to the rescue: it provides\na typedef, iterator, that is the type of iterators into lists. Since\ncharList is a list of chars, the type of an iterator into such a list is\nlist<char>::iterator, and that’s what’s used in the example above.\n(Each STL container class actually defines two iterator types, itera-\ntor and const_iterator. The former acts like a normal pointer, the\nlatter like a pointer-to-const.)\n",
      "content_length": 2204,
      "extraction_method": "Direct"
    },
    {
      "page_number": 301,
      "chapter": null,
      "content": "284\nItem 35\nExactly the same approach can be used with the other STL containers.\nFurthermore, C++ pointers are STL iterators, so the original array ex-\namples work with the STL find function, too:\nint values[50];\n...\nint *firstFive = find(values, values+50, 5);\n// fine, calls\n// STL find\nAt its core, STL is very simple. It is just a collection of class and func-\ntion templates that adhere to a set of conventions. The STL collection\nclasses provide functions like begin and end that return iterator ob-\njects of types defined by the classes. The STL algorithm functions move\nthrough collections of objects by using iterator objects over STL collec-\ntions. STL iterators act like pointers. That’s really all there is to it.\nThere’s no big inheritance hierarchy, no virtual functions, none of that\nstuff. Just some class and function templates and a set of conventions\nto which they all subscribe.\nWhich leads to another revelation: STL is extensible. You can add your\nown collections, algorithms, and iterators to the STL family. As long as\nyou follow the STL conventions, the standard STL collections will work\nwith your algorithms and your collections will work with the standard\nSTL algorithms. Of course, your templates won’t be part of the stan-\ndard C++ library, but they’ll be built on the same principles and will be\njust as reusable.\nThere is much more to the C++ library than I’ve described here. Before\nyou can use the library effectively, you must learn more about it than\nI’ve had room to summarize, and before you can write your own STL-\ncompliant templates, you must learn more about the conventions of\nthe STL. The standard C++ library is far richer than the C library, and\nthe time you take to familiarize yourself with it is time well spent. Fur-\nthermore, the design principles embodied by the library — those of\ngenerality, extensibility, customizability, efficiency, and reusability —\nare well worth learning in their own right. By studying the standard\nC++ library, you not only increase your knowledge of the ready-made\ncomponents available for use in your software, you learn how to apply\nthe features of C++ more effectively, and you gain insight into how to\ndesign better libraries of your own.\n",
      "content_length": 2223,
      "extraction_method": "Direct"
    },
    {
      "page_number": 302,
      "chapter": null,
      "content": "Recommended Reading\nSo your appetite for information on C++ remains unsated. Fear not,\nthere’s more — much more. In the sections that follow, I put forth my\nrecommendations for further reading on C++. It goes without saying\nthat such recommendations are both subjective and selective, but in\nview of the litigious age in which we live, it’s probably a good idea to\nsay it anyway.\nBooks\nThere are hundreds — possibly thousands — of books on C++, and\nnew contenders join the fray with great frequency. I haven’t seen all\nthese books, much less read them, but my experience has been that\nwhile some books are very good, some of them, well, some of them\naren’t.\nWhat follows is the list of books I find myself consulting when I have\nquestions about software development in C++. Other good books are\navailable, I’m sure, but these are the ones I use, the ones I can truly\nrecommend.\nA good place to begin is with the books that describe the language it-\nself. Unless you are crucially dependent on the nuances of the official\nstandards documents, I suggest you do, too.\nThe Annotated C++ Reference Manual, Margaret A. Ellis and\nBjarne Stroustrup, Addison-Wesley, 1990, ISBN 0-201-51459-1.\nThe Design and Evolution of C++, Bjarne Stroustrup, Addison-\nWesley, 1994, ISBN 0-201-54330-3.\nThese books contain not just a description of what’s in the language,\nthey also explain the rationale behind the design decisions — some-\nthing you won’t find in the official standard documents. The Anno-\n",
      "content_length": 1484,
      "extraction_method": "Direct"
    },
    {
      "page_number": 303,
      "chapter": null,
      "content": "286\nRecommended Reading\ntated C++ Reference Manual is now incomplete (several language fea-\ntures have been added since it was published — see Item 35) and is in\nsome cases out of date, but it is still the best reference for the core\nparts of the language, including templates and exceptions. The Design\nand Evolution of C++ covers most of what’s missing in The Annotated\nC++ Reference Manual; the only thing it lacks is a discussion of the\nStandard Template Library (again, see Item 35). These books are not\ntutorials, they’re references, but you can’t truly understand C++ un-\nless you understand the material in these books.\nFor a more general reference on the language, the standard library,\nand how to apply it, there is no better place to look than the book by\nthe man responsible for C++ in the first place:\nThe C++ Programming Language (Third Edition), Bjarne Strous-\ntrup, Addison-Wesley, 1997, ISBN 0-201-88954-4.\nStroustrup has been intimately involved in the language’s design, im-\nplementation, application, and standardization since its inception,\nand he probably knows more about it than anybody else does. His de-\nscriptions of language features make for dense reading, but that’s pri-\nmarily because they contain so much information. The chapters on\nthe standard C++ library provide a good introduction to this crucial\naspect of modern C++.\nIf you’re ready to move beyond the language itself and are interested\nin how to apply it effectively, you might consider my other book on the\nsubject:\nEffective C++, Second Edition: 50 Specific Ways to Improve Your\nPrograms and Designs, Scott Meyers, Addison-Wesley, 1998,\nISBN 0-201-92488-9.\nThat book is organized similarly to this one, but it covers different (ar-\nguably more fundamental) material.\nA book pitched at roughly the same level as my Effective C++ books,\nbut covering different topics, is\nC++ Strategies and Tactics, Robert Murray, Addison-Wesley,\n1993, ISBN 0-201-56382-7.\nMurray’s book is especially strong on the fundamentals of template\ndesign, a topic to which he devotes two chapters. He also includes a\nchapter on the important topic of migrating from C development to\nC++ development. Much of my discussion on reference counting (see\nItem 29) is based on the ideas in C++ Strategies and Tactics.\nIf you’re the kind of person who likes to learn proper programming\ntechnique by reading code, the book for you is\n",
      "content_length": 2392,
      "extraction_method": "Direct"
    },
    {
      "page_number": 304,
      "chapter": null,
      "content": "Recommended Reading\n287\nC++ Programming Style, Tom Cargill, Addison-Wesley, 1992, \nISBN 0-201-56365-7.\nEach chapter in this book starts with some C++ software that has\nbeen published as an example of how to do something correctly.\nCargill then proceeds to dissect — nay, vivisect — each program, iden-\ntifying likely trouble spots, poor design choices, brittle implementation\ndecisions, and things that are just plain wrong. He then iteratively re-\nwrites each example to eliminate the weaknesses, and by the time he’s\ndone, he’s produced code that is more robust, more maintainable,\nmore efficient, and more portable, and it still fulfills the original prob-\nlem specification. Anybody programming in C++ would do well to heed\nthe lessons of this book, but it is especially important for those in-\nvolved in code inspections.\n(One topic Cargill does not discuss in C++ Programming Style is excep-\ntions. He turns his critical eye to this language feature in the following\narticle, however, which demonstrates why writing exception-safe code\nis more difficult than most programmers realize:\n“Exception Handling: A False Sense of Security,” C++ Report,\nVolume 6, Number 9, November-December 1994, pages 21-24.\nIf you are contemplating the use of exceptions, read this article before\nyou proceed. If you don’t have access to back issues of the C++ Report,\nyou can find the article at the Addison-Wesley Internet site. The World\nWide Web URL is http://www.awl.com/cp/mec++.html. If you pre-\nfer anonymous FTP, you can get the article from ftp.awl.com in the\ndirectory cp/mec++.)\nOnce you’ve mastered the basics of C++ and are ready to start push-\ning the envelope, you must familiarize yourself with\nAdvanced C++: Programming Styles and Idioms, James Coplien,\nAddison-Wesley, 1992, ISBN 0-201-54855-0.\nI generally refer to this as “the LSD book,” because it’s purple and it\nwill expand your mind. Coplien covers some straightforward material,\nbut his focus is really on showing you how to do things in C++ you’re\nnot supposed to be able to do. You want to construct objects on top of\none another? He shows you how. You want to bypass strong typing?\nHe gives you a way. You want to add data and functions to classes as\nyour programs are running? He explains how to do it. Most of the\ntime, you’ll want to steer clear of the techniques he describes, but\nsometimes they provide just the solution you need for a tricky prob-\nlem you’re facing. Furthermore, it’s illuminating just to see what\n",
      "content_length": 2485,
      "extraction_method": "Direct"
    },
    {
      "page_number": 305,
      "chapter": null,
      "content": "288\nRecommended Reading\nkinds of things can be done with C++. This book may frighten you, it\nmay dazzle you, but when you’ve read it, you’ll never look at C++ the\nsame way again.\nIf you have anything to do with the design and implementation of C++\nlibraries, you would be foolhardy to overlook\nDesigning and Coding Reusable C++, Martin D. Carroll and\nMargaret A. Ellis, Addison-Wesley, 1995, ISBN 0-201-51284-X.\nCarroll and Ellis discuss many practical aspects of library design and\nimplementation that are simply ignored by everybody else. Good li-\nbraries are small, fast, extensible, easily upgraded, graceful during\ntemplate instantiation, powerful, and robust. It is not possible to opti-\nmize for each of these attributes, so one must make trade-offs that\nimprove some aspects of a library at the expense of others. Designing\nand Coding Reusable C++ examines these trade-offs and offers down-\nto-earth advice on how to go about making them.\nRegardless of whether you write software for scientific and engineering\napplications, you owe yourself a look at\nScientific and Engineering C++, John J. Barton and Lee R.\nNackman, Addison-Wesley, 1994, ISBN 0-201-53393-6.\nThe first part of the book explains C++ for FORTRAN programmers\n(now there’s an unenviable task), but the latter parts cover techniques\nthat are relevant in virtually any domain. The extensive material on\ntemplates is close to revolutionary; it’s probably the most advanced\nthat’s currently available, and I suspect that when you’ve seen the\nmiracles these authors perform with templates, you’ll never again\nthink of them as little more than souped-up macros.\nFinally, the emerging discipline of patterns in object-oriented software\ndevelopment (see page 123) is described in\nDesign Patterns: Elements of Reusable Object-Oriented Soft-\nware, Erich Gamma, Richard Helm, Ralph Johnson, and John\nVlissides, Addison-Wesley, 1995, ISBN 0-201-63361-2.\nThis book provides an overview of the ideas behind patterns, but its\nprimary contribution is a catalogue of 23 fundamental patterns that\nare useful in many application areas. A stroll through these pages will\nalmost surely reveal a pattern you’ve had to invent yourself at one\ntime or another, and when you find one, you’re almost certain to dis-\ncover that the design in the book is superior to the ad-hoc approach\nyou came up with. The names of the patterns here have already be-\ncome part of an emerging vocabulary for object-oriented design; fail-\nure to know these names may soon be hazardous to your ability to\n",
      "content_length": 2532,
      "extraction_method": "Direct"
    },
    {
      "page_number": 306,
      "chapter": null,
      "content": "Recommended Reading\n289\ncommunicate with your colleagues. A particular strength of the book\nis its emphasis on designing and implementing software so that future\nevolution is gracefully accommodated (see Items 32 and 33).\nDesign Patterns is also available as a CD-ROM:\nDesign Patterns CD: Elements of Reusable Object-Oriented Soft-\nware, Erich Gamma, Richard Helm, Ralph Johnson, and John\nVlissides, Addison-Wesley, 1998, ISBN 0-201-63498-8.\nMagazines\nFor hard-core C++ programmers, there’s really only one game in town:\nC++ Report, SIGS Publications, New York, NY.\nThe magazine has made a conscious decision to move away from its\n“C++ only” roots, but the increased coverage of domain- and system-\nspecific programming issues is worthwhile in its own right, and the\nmaterial on C++, if occasionally a bit off the deep end, continues to be\nthe best available.\nIf you’re more comfortable with C than with C++, or if you find the C++\nReport’s material too extreme to be useful, you may find the articles in\nthis magazine more to your taste:\nC/C++ Users Journal, Miller Freeman, Inc., Lawrence, KS.\nAs the name suggests, this covers both C and C++. The articles on\nC++ tend to assume a weaker background than those in the C++ Re-\nport. In addition, the editorial staff keeps a tighter rein on its authors\nthan does the Report, so the material in the magazine tends to be rela-\ntively mainstream. This helps filter out ideas on the lunatic fringe, but\nit also limits your exposure to techniques that are truly cutting-edge.\nUsenet Newsgroups\nThree Usenet newsgroups are devoted to C++. The general-purpose\nanything-goes newsgroup is comp.lang.c++. The postings there run\nthe gamut from detailed explanations of advanced programming tech-\nniques to rants and raves by those who love or hate C++ to undergrad-\nuates the world over asking for help with the homework assignments\nthey neglected until too late. Volume in the newsgroup is extremely\nhigh. Unless you have hours of free time on your hands, you’ll want to\nemploy a filter to help separate the wheat from the chaff. Get a good\nfilter — there’s a lot of chaff.\nIn November 1995, a moderated version of comp.lang.c++ was cre-\nated. Named comp.lang.c++.moderated, this newsgroup is also de-\nsigned for general discussion of C++ and related issues, but the\nmoderators aim to weed out implementation-specific questions and\n",
      "content_length": 2371,
      "extraction_method": "Direct"
    },
    {
      "page_number": 307,
      "chapter": null,
      "content": "290\nRecommended Reading\ncomments, questions covered in the extensive on-line FAQ (“Fre-\nquently Asked Questions” list), flame wars, and other matters of little\ninterest to most C++ practitioners. \nA more narrowly focused newsgroup is comp.std.c++, which is de-\nvoted to a discussion of the C++ standard itself. Language lawyers\nabound in this group, but it’s a good place to turn if your picky ques-\ntions about C++ go unanswered in the references otherwise available\nto you. The newsgroup is moderated, so the signal-to-noise ratio is\nquite good; you won’t see any pleas for homework assistance here.\n",
      "content_length": 602,
      "extraction_method": "Direct"
    },
    {
      "page_number": 308,
      "chapter": null,
      "content": "An auto_ptr Implementation\nItems 9, 10, 26, 31 and 32 attest to the remarkable utility of the\nauto_ptr template. Unfortunately, few compilers currently ship with\na “correct” implementation.† Items 9 and 28 sketch how you might\nwrite one yourself, but it’s nice to have more than a sketch when em-\nbarking on real-world projects. \nBelow are two presentations of an implementation for auto_ptr. The\nfirst presentation documents the class interface and implements all\nthe member functions outside the class definition. The second imple-\nments each member function within the class definition. Stylistically,\nthe second presentation is inferior to the first, because it fails to sepa-\nrate the class interface from its implementation. However, auto_ptr\nyields simple classes, and the second presentation brings that out\nmuch more clearly than does the first.\nHere is auto_ptr with its interface documented:\ntemplate<class T>\nclass auto_ptr {\npublic:\nexplicit auto_ptr(T *p = 0); // see Item 5 for a \n// description of \"explicit\"\ntemplate<class U>\n// copy constructor member\nauto_ptr(auto_ptr<U>& rhs);\n// template (see Item 28):\n// initialize a new auto_ptr\n// with any compatible \n// auto_ptr\n~auto_ptr();\ntemplate<class U>\n// assignment operator \nauto_ptr<T>&\n// member template (see\noperator=(auto_ptr<U>& rhs); // Item 28): assign from any\n// compatible auto_ptr \n† This is primarily because the specification for auto_ptr has for years been a moving\ntarget. The final specification was adopted only in November 1997. For details, consult\nthe auto_ptr information at this book’s WWW and FTP sites (see page 8). Note that\nthe auto_ptr described here omits a few details present in the official version, such\nas the fact that auto_ptr is in the std namespace (see Item 35) and that its member\nfunctions promise not to throw exceptions.\n",
      "content_length": 1834,
      "extraction_method": "Direct"
    },
    {
      "page_number": 309,
      "chapter": null,
      "content": "292\nAn auto_ptr Implementation\nT& operator*() const;\n// see Item 28\nT* operator->() const;\n// see Item 28\nT* get() const;\n// return value of current\n// dumb pointer\nT* release();\n// relinquish ownership of\n// current dumb pointer and\n// return its value\nvoid reset(T *p = 0);\n// delete owned pointer;\n// assume ownership of p\nprivate:\nT *pointee;\ntemplate<class U>\n// make all auto_ptr classes\nfriend class auto_ptr<U>;\n// friends of one another\n};\ntemplate<class T>\ninline auto_ptr<T>::auto_ptr(T *p)\n: pointee(p)\n{}\ntemplate<class T>\ntemplate<class U>\ninline auto_ptr<T>::auto_ptr(auto_ptr<U>& rhs)\n: pointee(rhs.release())\n{}\ntemplate<class T>\ninline auto_ptr<T>::~auto_ptr()\n{ delete pointee; }\ntemplate<class T>\ntemplate<class U>\ninline auto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<U>& rhs)\n{\nif (this != &rhs) reset(rhs.release());\nreturn *this;\n}\ntemplate<class T>\ninline T& auto_ptr<T>::operator*() const\n{ return *pointee; }\ntemplate<class T>\ninline T* auto_ptr<T>::operator->() const\n{ return pointee; }\ntemplate<class T>\ninline T* auto_ptr<T>::get() const\n{ return pointee; }\n",
      "content_length": 1087,
      "extraction_method": "Direct"
    },
    {
      "page_number": 310,
      "chapter": null,
      "content": "An auto_ptr Implementation\n293\ntemplate<class T>\ninline T* auto_ptr<T>::release()\n{\nT *oldPointee = pointee;\npointee = 0;\nreturn oldPointee;\n}\ntemplate<class T>\ninline void auto_ptr<T>::reset(T *p)\n{\nif (pointee != p) {\ndelete pointee;\npointee = p;\n}\n}\nHere is auto_ptr with all the functions defined in the class definition.\nAs you can see, there’s no brain surgery going on here:\ntemplate<class T>\nclass auto_ptr {\npublic:\nexplicit auto_ptr(T *p = 0): pointee(p) {}\ntemplate<class U>\nauto_ptr(auto_ptr<U>& rhs): pointee(rhs.release()) {}\n~auto_ptr() { delete pointee; }\ntemplate<class U>\nauto_ptr<T>& operator=(auto_ptr<U>& rhs)\n{\nif (this != &rhs) reset(rhs.release());\nreturn *this;\n}\nT& operator*() const { return *pointee; }\nT* operator->() const { return pointee; }\nT* get() const { return pointee; }\nT* release()\n{\nT *oldPointee = pointee;\npointee = 0;\nreturn oldPointee;\n}\nvoid reset(T *p = 0)\n{\nif (pointee != p) {\ndelete pointee;\npointee = p;\n}\n}\n",
      "content_length": 958,
      "extraction_method": "Direct"
    },
    {
      "page_number": 311,
      "chapter": null,
      "content": "294\nAn auto_ptr Implementation\nprivate:\nT *pointee;\ntemplate<class U> friend class auto_ptr<U>;\n};\nIf your compilers don’t yet support explicit, you may safely #define\nit out of existence:\n#define explicit\nThis won’t make auto_ptr any less functional, but it will render it\nslightly less safe. For details, see Item 5.\nIf your compilers lack support for member templates, you can use the\nnon-template auto_ptr copy constructor and assignment operator de-\nscribed in Item 28. This will make your auto_ptrs less convenient to\nuse, but there is, alas, no way to approximate the behavior of member\ntemplates. If member templates (or other language features, for that\nmatter) are important to you, let your compiler vendors know. The\nmore customers ask for new language features, the sooner vendors will\nimplement them.\n",
      "content_length": 815,
      "extraction_method": "Direct"
    },
    {
      "page_number": 312,
      "chapter": null,
      "content": "General Index\nThis index is for everything in this book except the classes, functions,\nand templates I use as examples. If you’re looking for a reference to a\nparticular class, function, or template I use as an example, please\nturn to the index beginning on page 313. For everything else, this is\nthe place to be. In particular, classes, functions, and templates in the\nstandard C++ library (e.g., string, auto_ptr, list, vector, etc.) are\nindexed here.\nFor the most part, operators are listed under operator. For example,\noperator<< is listed under operator<<, not under <<, etc. However,\noperators whose names are words or are word-like (e.g., new, delete,\nsizeof, const_cast, etc.) are listed under the appropriate words\n(e.g., new, delete, sizeof, const_cast, etc.).\nExample uses of new and lesser-known language features are indexed\nunder example uses.\nBefore A\n#define 294\n?:, vs. if/then 56\n__cplusplus 273\n“>>”, vs. “> >” 29\n80-20 rule 79, 82–85, 106\n90-10 rule xi, 82\nA\nabort\nand assert 167\nand object destruction 72\nrelationship to terminate 72\nabstract classes\nand inheritance 258–270\nand vtbls 115\ndrawing 5\nidentifying 267, 268\ntransforming from concrete 266–\n269\nabstract mixin base classes 154\nabstractions\nidentifying 267, 268\nuseful 267\naccess-declarations 144\nadding data and functions to \nclasses at runtime 287\nAddison-Wesley Internet site 8, 287\naddress comparisons to determine \nobject locations 150–152\naddress-of operator —\nsee operator&\n",
      "content_length": 1462,
      "extraction_method": "Direct"
    },
    {
      "page_number": 313,
      "chapter": null,
      "content": "296\n General Index\nAdvanced C++: Programming Styles \nand Idioms 287\nAdventure, allusion to 271\nallocation of memory — see memory \nallocation\namortizing computational \ncosts 93–98\nAnnotated C++ Reference Manual, \nThe 277, 285\nANSI/ISO standardization \ncommittee 2, 59, 96, 256, 277\nAPL 92\napplication framework 234\napproximating\nbool 3–4\nC++-style casts 15–16\nconst static data \nmembers 141\nexplicit 29–31\nin-class using declarations 144\nmember templates 294\nmutable 89–90\nvirtual functions 121\nvtbls 235–251\nARM, the 277\narray new 42\narrays\nand auto_ptr 48\nand default constructors 19–21\nand inheritance 17–18\nand pointer arithmetic 17\nassociative 236, 237\ndynamic 96–98\nmemory allocation for 42–43\nmulti-dimensional 213–217\nof pointers to functions 15, 113\nof pointers, as substitute for \narrays of objects 20\npointers into 280\nusing placement new to \ninitialize 20–21\nassert, and abort 167\nassignment operators —\nsee operator=\nassignments\nin reference-counted value \nclasses 196\nmixed-type 260, 261, 263–265\nof pointers and references 11\npartial 259, 263–265\nthrough pointers 259, 260\nassociative arrays 236, 237\nauto_ptr 49, 53, 57, 58, 137, 139,\n162, 240, 257\nand heap arrays 48\nand object ownership 183\nand pass-by-reference 165\nand pass-by-value 164\nand preventing resource \nleaks 48, 58\nassignment of 162–165\ncopying of 162–165\nimplementation 291–294\nB\nbad_alloc class 70, 75\nbad_cast class 70, 261, 262\nbad_exception class 70, 77\nbad_typeid class 70\nBarton, John J. 288\nbase classes\nand catch clauses 67\nand delete 18\nfor counting objects 141–145\nBASIC 156, 213\nbasic_string class 279, 280\nbegin function 283\nbenchmarks 80, 110, 111\nbest fit 67\nBible, allusion to 235\nbitset template 4, 283\nbooks, recommended 285–289\nbool 3, 4\nbugs in this book, reporting 8\nbypassing\nconstructors 21\nexception-related costs 79\nRTTI information 122\nsmart pointer smartness 171\nstrong typing 287\nvirtual base classes 122\nvirtual functions 122\nC\nC\ndynamic memory allocation 275\n",
      "content_length": 1968,
      "extraction_method": "Direct"
    },
    {
      "page_number": 314,
      "chapter": null,
      "content": "General Index\n297\nfunctions and name \nmangling 271\nlinkage 272\nmigrating to C++ 286\nmixing with C++ 270–276\nstandard library 278\nC Programming Language, The 36\nC-style casts 12, 90\nC++\ndynamic memory allocation 275\nmigrating from C 286\nmixing with C 270–276\nstandard library — see stan-\ndard C++ library\nC++ Programming Language, \nThe 286\nC++ Programming Style 287\nC++ Report 287, 289\nC++-style casts 12–16\napproximating 15–16\nC/C++ Users Journal 289\nc_str 27\ncaching 94–95, 98\ncallback functions 74–75, 79\nCandide, allusion to 19\nCargill, Tom 44, 287\nCarroll, Martin D. 288\ncasts\nC++-style 12–16\nC-style 12, 90\nof function pointers 15, 242\nsafe 14\nto remove constness or \nvolatileness 13, 221\ncatch 56\nand inheritance 67\nand temporary objects 65\nby pointer 70\nby reference 71\nby value 70\nclauses, order of \nexamination 67–68\nclauses, vs. virtual functions 67\nsee also pass-by-value, pass-by-\nreference, and pass-by-\npointer\nchange, designing for 252–270\nchar*s, vs. string objects 4\ncharacters\nUnicode 279\nwide 279\nClancy — see Urbano, Nancy L.\nclasses\nabstract mixin bases 154\nabstract, drawing 5\nadding members at runtime 287\nbase — see base classes\nconcrete, drawing 5\nderived — see derived classes\ndesigning — see design\ndiagnostic, in the standard \nlibrary 66\nfor registering things 250\nmixin 154\nmodifying, and \nrecompilation 234, 249\nnested, and inheritance 197\nproxy — see proxy classes\ntemplates for, specializing 175\ntransforming concrete into \nabstract 266–269\ncleaning your room 85\nclient, definition 7\nCLOS 230\nCOBOL 213, 272\ncode duplication 47, 54, 142, 204,\n223, 224\ncode reuse\nvia smart pointer templates and \nbase classes 211\nvia the standard library 5\ncode, generalizing 258\ncomma operator —\nsee operator,\ncommittee for C++ standardization \n— see ANSI/ISO standardiza-\ntion committee\ncomp.lang.c++ 289\ncomp.lang.c++.moderated 289\ncomp.std.c++ 290\ncomparing addresses to determine \nobject location 150–152\ncompilers, lying to 241\ncomplex numbers 279, 280\n",
      "content_length": 1974,
      "extraction_method": "Direct"
    },
    {
      "page_number": 315,
      "chapter": null,
      "content": "298\n General Index\nconcrete classes\nand inheritance 258–270\ndrawing 5\ntransforming into abstract 266–\n269\nconsistency\namong +, =, and +=, etc. 107\nbetween built-in and user-\ndefined types 254\nbetween prefix and postfix oper-\nator++ and operator-- 34\nbetween real and virtual copy \nconstructors 126\nconst member functions 89, 160,\n218\nconst return types 33–34, 101\nconst static data members, \ninitialization 140\nconst_cast 13, 14, 15, 37, 90\nconst_iterator type 127, 283\nconstant pointers 55–56\nconstness, casting away 13, 221\nconstructing objects on top of one \nanother 287\nconstructors\nand fully constructed objects 52\nand malloc 39\nand memory leaks 6\nand operator new 39, 149–150\nand operator new[] 43\nand references 165\nand static initialization 273\nas type conversion functions 27–\n31\nbypassing 21\ncalling directly 39\ncopy — see copy constructors\ndefault — see default construc-\ntors\nlazy 88–90\npreventing exception-related \nresource leaks 50–58\nprivate 130, 137, 146\nprotected 142\npseudo — see pseudo-construc-\ntors\npurpose 21\nrelationship to new operator and \noperator new 40\nsingle-argument 25, 27–31, 177\nvirtual — see virtual constructors\ncontacting this book’s author 8\ncontainers —\nsee Standard Template Library\ncontexts for object \nconstruction 136\nconventions\nand the STL 284\nfor I/O operators 128\nused in this book 5–8\nconversion functions —\nsee type conversion functions\nconversions — see type conversions\nCoplien, James 287\ncopy constructors 146\nand classes with pointers 200\nand exceptions 63, 68\nand non-const parameters 165\nand smart pointers 205\nfor strings 86\nvirtual — see virtual copy con-\nstructors\ncopying objects\nand exceptions 68\nstatic type vs. dynamic type 63\nwhen throwing an exception 62–\n63\ncopy-on-write 190–194\ncounting object instantiations 141–\n145\nC-style casts 12\nctor, definition 6\ncustomizing memory \nmanagement 38–43\nD\ndata members\nadding at runtime 287\nauto_ptr 58\ninitialization when const 55–56\ninitialization when static 140\nreplication, under multiple \ninheritance 118–120\nstatic, in templates 144\ndataflow languages 93\nDavis, Bette, allusion to 230\ndecrement operator —\nsee operator--\n",
      "content_length": 2132,
      "extraction_method": "Direct"
    },
    {
      "page_number": 316,
      "chapter": null,
      "content": "General Index\n299\ndefault constructors\nand arrays 19–21\nand templates 22\nand virtual base classes 22\ndefinition 19\nmeaningless 23\nrestrictions from 19–22\nwhen to/not to declare 19\ndelete\nand inheritance 18\nand memory not from new 21\nand nonvirtual destructors 256\nand null pointers 52\nand objects 173\nand smart pointers 173\nand this 145, 152, 157, 197, 213\ndetermining when valid 152–157\nsee also delete operator and \nownership\ndelete operator 37, 41, 173\nand operator delete[] and \ndestructors 43\nand placement new 42\nand this 145, 152, 157, 197, 213\ndeprecated features 7\naccess declarators 144\nstatics at file scope 246\nstrstream class 279\ndeque template 283\nderived classes\nand catch clauses 67\nand delete 18\nand operator= 263\nprohibiting 137\ndesign\nand multiple dispatch 235\nfor change 252–270\nof classes 33, 133, 186, 227, 258,\n268\nof function locations 244\nof libraries 110, 113, 284, 286,\n288\nof templates 286\nof virtual function \nimplementation 248\npatterns 123, 288\nDesign and Evolution of C++, \nThe 278, 285\nDesign Patterns: Elements of Reus-\nable Object-Oriented \nSoftware 288\nDesigning and Coding Reusable \nC++ 288\ndestruction, static 273–275\ndestructors\nand delete 256\nand exceptions 45\nand fully constructed objects 52\nand longjmp 47\nand memory leaks 6\nand operator delete[] 43\nand partially constructed \nobjects 53\nand smart pointers 205\nprivate 145\nprotected 142, 147\npseudo 145, 146\npure virtual 195, 265\nvirtual 143, 254–257\ndetermining whether a pointer can \nbe deleted 152–157\ndetermining whether an object is on \nthe heap 147–157\ndiagnostics classes of the standard \nlibrary 66\ndispatching — see multiple dispatch\ndistinguishing lvalue and rvalue \nuse of operator[] 87, 217–\n223\ndomain_error class 66\ndouble application of increment \nand decrement 33\ndouble-dispatch —\nsee multiple dispatch\ndtor, definition 6\ndumb pointers 159, 207\nduplication of code 47, 54, 142,\n204, 223, 224\ndynamic arrays 96–98\ndynamic type\nvs. static type 5–6\nvs. static type, when copying 63\ndynamic_cast 6, 37, 261–262\nand null pointer 70\nand virtual functions 14, 156\napproximating 16\nmeaning 14\n",
      "content_length": 2095,
      "extraction_method": "Direct"
    },
    {
      "page_number": 317,
      "chapter": null,
      "content": "300\n General Index\nto get a pointer to the beginning of \nan object 155\nto reference, failed 70\nto void* 156\nE\neager evaluation 86, 91, 92, 94, 98\nconverting to lazy evaluation 93\nEdelson, Daniel 179\nEffective C++ 5, 100, 286\nefficiency\nand assigning smart \npointers 163\nand benchmarks 110\nand cache hit rate 98\nand constructors and \ndestructors 53\nand copying smart pointers 163\nand encapsulation 82\nand function return values 101\nand inlining 129\nand libraries 110, 113\nand maintenance 91\nand multiple inheritance 118–\n120\nand object size 98\nand operators new and \ndelete 97, 113\nand paging behavior 98\nand pass-by-pointer 65\nand pass-by-reference 65\nand pass-by-value 65\nand profiling 84–85, 93\nand reference counting 183, 211\nand system calls 97\nand temporary objects 99–101\nand tracking heap \nallocations 153\nand virtual functions 113–118\nand vptrs 116, 256\nand vtbls 114, 256\ncaching 94–95, 98\nclass statics vs. function \nstatics 133\ncost amortization 93–98\nimplications of meaningless \ndefault constructors 23\niostreams vs. stdio 110–112\nlocating bottlenecks 83\nmanual methods vs. language \nfeatures 122\nof exception-related features 64,\n70, 78–80\nof prefix vs. postfix increment and \ndecrement 34\nof stand-alone operators vs. \nassignment versions 108\nprefetching 96–98\nreading vs. writing reference-\ncounted objects 87, 217\nspace vs. time 98\nsummary of costs of various lan-\nguage features 121\nvirtual functions vs. manual \nmethods 121, 235\nvs. syntactic convenience 108\nsee also optimization\nEllis, Margaret A. 285, 288\nemulating features —\nsee approximating\nencapsulation\nallowing class implementations \nto change 207\nand efficiency 82\nend function 283\nenums\nand overloading operators 277\nas class constants 141\nevaluation\nconverting eager to lazy 93\neager 86, 91, 92, 94, 98\nlazy 85–93, 94, 98, 191, 219\nover-eager 94–98\nshort-circuit 35, 36\nexample uses\n__cplusplus 273\nauto_ptr 48, 57, 138, 164, 165,\n240, 247, 257\nconst pointers 55\nconst_cast 13, 90, 221\ndynamic_cast 14, 155, 243,\n244, 261, 262\nexception specifications 70, 73,\n74, 75, 77\nexplicit 29, 291, 293\nfind function 283\n",
      "content_length": 2093,
      "extraction_method": "Direct"
    },
    {
      "page_number": 318,
      "chapter": null,
      "content": "General Index\n301\nimplicit type conversion \noperators 25, 26, 49, 171,\n175, 219, 225\nin-class initialization of const\nstatic members 140\nlist template 51, 124, 154, 283\nmake_pair template 247\nmap template 95, 238, 245\nmember templates 176, 291, 292,\n293\nmutable 88\nnamespace 132, 245, 246, 247\nnested class using \ninheritance 197\noperator delete 41, 155\noperator delete[] 21\noperator new 41, 155\noperator new[] 21\noperator& 224\noperator->* (built-in) 237\npair template 246\nplacement new 21, 40\npointers to member \nfunctions 236, 238\npure virtual destructors 154, 194\nreference data member 219\nrefined return type of virtual \nfunctions 126, 260\nreinterpret_cast 15\nsetiosflags 111\nsetprecision 111\nsetw 99, 111\nStandard Template Library 95,\n125, 127, 155, 238, 247, 283,\n284\nstatic_cast 12, 18, 21, 28, 29,\n231\ntypeid 231, 238, 245\nusing declarations 133, 143\nvector template 11\nexception class 66, 77\nexception specifications 72–78\nadvantages 72\nand callback functions 74–75\nand layered designs 77\nand libraries 76, 79\nand templates 73–74\nchecking for consistency 72\ncost of 79\nmixing code with and without 73,\n75\nexception::what 70, 71\nexceptions 287\nand destructors 45\nand operator new 52\nand type conversions 66–67\nand virtual functions 79\ncausing resource leaks in \nconstructors 52\nchoices for passing 68\ndisadvantages 44\nefficiency 63, 65, 78–80\nmandatory copying 62–63\nmodifying throw expressions 63\nmotivation 44\noptimization 64\nrecent revisions to 277\nrethrowing 64\nspecifications — see exception\nspecifications\nstandard 66, 70\nunexpected — see unexpected \nexceptions\nuse of copy constructor 63\nuse to indicate common \nconditions 80\nvs. setjmp and longjmp 45\nsee also catch, throw\nexplicit 28–31, 227, 294\nextern \"C\" 272–273\nF\nfake this 89\nfalse 3\nFelix the Cat 123\nfetch and increment 32\nfetching, lazy 87–90\nfind function 283\nfirst fit 67\nfixed-format I/O 112\nForth 271\nFORTRAN 213, 215, 271, 288\nfree 42, 275\nFrench, gratuitous use of 177, 185\nfriends, avoiding 108, 131\nfstream class 278\n",
      "content_length": 2000,
      "extraction_method": "Direct"
    },
    {
      "page_number": 319,
      "chapter": null,
      "content": "302\n General Index\nFTP site\nfor this book 8, 287\nfully constructed objects 52\nfunction call semantics 35–36\nfunctions\nadding at runtime 287\nC, and name mangling 271\ncallback 74–75, 79\nfor type conversions 25–31\ninline, in this book 7\nmember — see member functions\nmember template — see mem-\nber templates\nreturn types — see return types\nvirtual — see virtual functions\nfuture tense programming 252–258\nG\nGamma, Erich 288\ngarbage collection 183, 212\ngeneralizing code 258\nGerman, gratuitous use of 31\nglobal overloading of operator\nnew/delete 43, 153\nGUI systems 49, 74–75\nH\nHamlet, allusion to 22, 70, 252\nheap objects — see objects\nHelm, Richard 288\nheuristic for vtbl generation 115\nI\nidentifying abstractions 267, 268\nidioms 123\nIliad, Homer’s 87\nimplementation\nof + in terms of +=, etc. 107\nof libraries 288\nof multiple dispatch 230–251\nof operators ++ and -- 34\nof pass-by-reference 242\nof pure virtual functions 265\nof references 242\nof RTTI 120–121\nof virtual base classes 118–120\nof virtual functions 113–118\nimplicit type conversion operators \n— see type conversion operators\nimplicit type conversions —\nsee type conversions\nincrement and fetch 32\nincrement operator —\nsee operator++\nindexing, array\nand inheritance 17–18\nand pointer arithmetic 17\ninheritance\nand abstract classes 258–270\nand catch clauses 67\nand concrete classes 258–270\nand delete 18\nand emulated vtbls 248–249\nand libraries 269–270\nand nested classes 197\nand operator delete 158\nand operator new 158\nand private constructors and \ndestructors 137, 146\nand smart pointers 163, 173–179\nand type conversions of \nexceptions 66\nmultiple — see multiple inherit-\nance\nprivate 143\ninitialization\ndemand-paged 88\nof arrays via placement new 20–\n21\nof const pointer members 55–56\nof const static members 140\nof emulated vtbls 239–244, 249–\n251\nof function statics 133\nof objects 39, 237\nof pointers 10\nof references 10\norder, in different translation \nunits 133\nstatic 273–275\ninlining\nand “virtual” non-member \nfunctions 129\n",
      "content_length": 1994,
      "extraction_method": "Direct"
    },
    {
      "page_number": 320,
      "chapter": null,
      "content": "General Index\n303\nand function statics 134\nand the return value \noptimization 104\nand vtbl generation 115\nin this book 7\ninstantiations, of templates 7\ninternal linkage 134\nInternet site\nfor free STL implementation 4\nfor this book 8, 287\ninvalid_argument class 66\niostream class 278\niostreams 280\nand fixed-format I/O 112\nand operator! 170\nconversion to void* 168\nvs. stdio 110–112\nISO standardization committee — \nsee ANSI/ISO standardization \ncommittee\niterators 283\nand operator-> 96\nvs. pointers 282, 284\nsee also Standard Template \nLibrary\nJ\nJapanese, gratuitous use of 45\nJohnson, Ralph 288\nK\nKernighan, Brian W. 36\nKirk, Captain, allusion to 79\nL\nlanguage lawyers 276, 290\nLatin, gratuitous use of 203, 252\nlazy construction 88–90\nlazy evaluation 85–93, 94, 191, 219\nand object dependencies 92\nconversion from eager 93\nwhen appropriate 93, 98\nlazy fetching 87–90\nleaks, memory — see memory leaks\nleaks, resource —\nsee resource leaks\nlength_error class 66\nlhs, definition 6\nlibraries\nand exception specifications 75,\n76, 79\ndesign and implementation 110,\n113, 284, 286, 288\nimpact of modification 235\ninheriting from 269–270\nlibrary, C++ standard — see stan-\ndard C++ library\nlifetime of temporary objects 278\nlimitations on type conversion \nsequences 29, 31, 172, 175, 226\nlimiting object instantiations 130–\n145\nlinkage\nC 272\ninternal 134\nlinkers, and overloading 271\nLisp 93, 230, 271\nlist template 4, 51, 124, 125, 154,\n283\nlocality of reference 96, 97\nlocalization, support in standard \nC++ library 278\nlogic_error class 66\nlongjmp\nand destructors 47\nand setjmp, vs. exceptions 45\nLSD 287\nlvalue, definition 217\nlying to compilers 241\nM\nmagazines, recommended 289\nmain 251, 273, 274\nmaintenance 57, 91, 107, 179, 211,\n227, 253, 267, 270, 273\nand RTTI 232\nmake_pair template 247\nmalloc 39, 42, 275\nand constructors 39\nand operator new 39\nmap template 4, 95, 237, 246, 283\nmember data —\nsee data members\n",
      "content_length": 1913,
      "extraction_method": "Direct"
    },
    {
      "page_number": 321,
      "chapter": null,
      "content": "304\n General Index\nmember functions\nand compatibility of C++ and C \nstructs 276\nconst 89, 160, 218\ninvocation through proxies 226\npointers to 240\nmember initialization lists 58\nand ?: vs. if/then 56\nand try and catch 56\nmember templates 165\nand assigning smart \npointers 180\nand copying smart pointers 180\napproximating 294\nfor type conversions 175–179\nportability of 179\nmemory allocation 112\nfor basic_string class 280\nfor heap arrays 42–43\nfor heap objects 38\nin C++ vs. C 275\nmemory leaks 6, 7, 42, 145\nsee also resource leaks\nmemory management, \ncustomizing 38–43\nmemory values, after calling oper-\nator new 38\nmemory, shared 40\nmemory-mapped I/O 40\nmessage dispatch —\nsee multiple dispatch\nmigrating from C to C++ 286\nmixed-type assignments 260, 261\nprohibiting 263–265\nmixed-type comparisons 169\nmixin classes 154\nmixing code\nC++ and C 270–276\nwith and without exception \nspecifications 75\nmulti-dimensional arrays 213–217\nmulti-methods 230\nmultiple dispatch 230–251\nmultiple inheritance 153\nand object addresses 241\nand vptrs and vtbls 118–120\nmutable 88–90\nN\nNackman, Lee R. 288\nname function 238\nname mangling 271–273\nnamed objects 109\nand optimization 104\nvs. temporary objects 109\nnamespaces 132, 144\nand the standard C++ library 280\nstd 261\nunnamed 246, 247\nnested classes, and \ninheritance 197\nnew language features, \nsummary 277\nnew operator 37, 38, 42\nand bad_alloc 75\nand operator new and \nconstructors 39, 40\nand operator new[] and \nconstructors 43\nnew, placement —\nsee placement new\nnewsgroups, recommended 289\nNewton, allusion to 41\nnon-member functions, acting \nvirtual 128–129\nnull pointers\nand dynamic_cast 70\nand strlen 35\nand the STL 281\ndeleting 52\ndereferencing 10\nin smart pointers 167\ntesting for 10\nnull references 9–10\nnumeric applications 90, 279\nO\nobjects\naddresses 241\nallowing exactly one 130–134\nand virtual functions 118\nas function return type 99\nassignments through \npointers 259, 260\n",
      "content_length": 1924,
      "extraction_method": "Direct"
    },
    {
      "page_number": 322,
      "chapter": null,
      "content": "General Index\n305\nconstructing on top of one \nanother 287\nconstruction, lazy 88–90\ncontexts for construction 136\ncopying, and exceptions 62–63,\n68\ncounting instantiations 141–145\ndeleting 173\ndetermining location via address \ncomparisons 150–152\ndetermining whether on the \nheap 147–157\ninitialization 39, 88, 237\nlimiting the number of 130–145\nlocations 151\nmemory layout diagrams 116,\n119, 120, 242\nmodifying when thrown 63\nnamed — see named objects\nownership 162, 163–165, 183\npartially constructed 53\npreventing instantiations 130\nprohibiting from heap 157–158\nproxy — see proxy objects\nrestricting to heap 145–157\nsize, and cache hit rate 98\nsize, and paging behavior 98\nstatic — see static objects\nsurrogate 217\ntemporary — see temporary \nobjects\nunnamed — see temporary \nobjects\nusing dynamic_cast to find the \nbeginning 155\nusing to prevent resource \nleaks 47–50, 161\nvs. pointers, in classes 147\nOn Beyond Zebra, allusion to 168\noperatordelete 37, 41, 84, 113,\n173\nand efficiency 97\nand inheritance 158\noperator delete[] 37, 84\nand delete operator and \ndestructors 43\nprivate 157\noperator new 37, 38, 69, 70, 84,\n113, 149\nand bad_alloc 75\nand constructors 39, 149–150\nand efficiency 97\nand exceptions 52\nand inheritance 158\nand malloc 39\nand new operator and \nconstructors 40\ncalling directly 39\noverloading at global scope 43,\n153\nprivate 157\nvalues in memory returned \nfrom 38\noperator new[] 37, 42, 84, 149\nand bad_alloc 75\nand new operator and \nconstructors 43\nprivate 157\noperator overloading, purpose 38\noperator void* 168–169\noperator! 37\nin iostream classes 170\nin smart pointers classes 169\noperator!= 37\noperator% 37\noperator%= 37\noperator& 37, 74, 223\noperator&& 35–36, 37\noperator&= 37\noperator() 37, 215\noperator* 37, 101, 103, 104, 107\nand null smart pointers 167\nand STL iterators 96\nas const member function 160\noperator*= 37, 107, 225\noperator+ 37, 91, 100, 107, 109\ntemplate for 108\noperator++ 31–34, 37, 225\ndouble application of 33\nprefix vs. postfix 34\noperator+= 37, 107, 109, 225\noperator, 36–37\noperator- 37, 107\ntemplate for 108\noperator-= 37, 107\n",
      "content_length": 2082,
      "extraction_method": "Direct"
    },
    {
      "page_number": 323,
      "chapter": null,
      "content": "306\n General Index\noperator-> 37\nand STL iterators 96\nas const member function 160\noperator->* 37\noperator-- 31–34, 37, 225\ndouble application of 33\nprefix vs. postfix 34\noperator. 37\nand proxy objects 226\noperator.* 37\noperator/ 37, 107\noperator/= 37, 107\noperator:: 37\noperator< 37\noperator<< 37, 112, 129\nwhy a member function 128\noperator<<= 37, 225\noperator<= 37\noperator= 37, 107, 268\nand classes with pointers 200\nand derived classes 263\nand inheritance 259–265\nand mixed-type \nassignments 260, 261, 263–\n265\nand non-const parameters 165\nand partial assignments 259,\n263–265\nand smart pointers 205\nvirtual 259–262\noperator== 37\noperator> 37\noperator>= 37\noperator>> 37\noperator>>= 37\noperator?: 37, 56\noperator[] 11, 37, 216\nconst vs. non-const 218\ndistinguishing lvalue and rvalue \nuse 87, 217–223\noperator[][] 214\noperator^ 37\noperator^= 37\noperator| 37\noperator|= 37\noperator|| 35–36, 37\noperator~ 37\noperators\nimplicit type conversion — see \ntype conversion operators\nnot overloadable 37\noverloadable 37\nreturning pointers 102\nreturning references 102\nstand-alone vs. assignment \nversions 107–110\noptimization\nand profiling data 84\nand return expressions 104\nand temporary objects 104\nof exceptions 64\nof reference counting 187\nof vptrs under multiple \ninheritance 120\nreturn value — see return value \noptimization\nvia valarray objects 279\nsee also efficiency\norder of examination of catch\nclauses 67–68\nOuija boards 83\nout_of_range class 66\nover-eager evaluation 94–98\noverflow_error class 66\noverloadable operators 37\noverloading\nand enums 277\nand function pointers 243\nand linkers 271\nand user-defined types 106\noperatornew/delete at global \nscope 43, 153\nresolution of function calls 233\nrestrictions 106\nto avoid type conversions 105–\n107\nownership of objects 162, 183\ntransferring 163–165\nP\npair template 246\nparameters\npassing, vs. throwing \nexceptions 62–67\nunused 33, 40\n",
      "content_length": 1891,
      "extraction_method": "Direct"
    },
    {
      "page_number": 324,
      "chapter": null,
      "content": "General Index\n307\npartial assignments 259, 263–265\npartial computation 91\npartially constructed objects, and \ndestructors 53\npass-by-pointer 65\npass-by-reference\nand auto_ptrs 165\nand const 100\nand temporary objects 100\nand the STL 282\nand type conversions 100\nefficiency, and exceptions 65\nimplementation 242\npass-by-value\nand auto_ptrs 164\nand the STL 282\nand virtual functions 70\nefficiency, and exceptions 65\npassing exceptions, choices 68\npatterns 123, 288\nPavlov, allusion to 81\nperformance — see efficiency\nplacement new 39–40\nand array initialization 20–21\nand delete operator 42\npointer arithmetic\nand array indexing 17\nand inheritance 17–18\npointers\nand object assignments 259, 260\nand proxy objects 223\nand virtual functions 118\nas parameters — see pass-by-\npointer\nassignment 11\nconstant 55\ndereferencing when null 10\ndetermining whether they can be \ndeleted 152–157\ndumb 159\nimplications for copy construc-\ntors and assignment \noperators 200\ninitialization 10, 55–56\ninto arrays 280\nnull — see null pointers\nreplacing dumb with smart 207\nreturning from operators 102\nsmart — see smart pointers\ntesting for nullness 10\nto functions 15, 241, 243\nto member functions 240\nvs. iterators 284\nvs. objects, in classes 147\nvs. references 9–11\nwhen to use 11\npolymorphism, definition 16\nPoor Richard’s Almanac, allusion \nto 75\nportability\nand non-standard functions 275\nof casting function pointers 15\nof determining object \nlocations 152, 158\nof dynamic_cast to void* 156\nof member templates 179\nof passing data between C++ and \nC 275\nof reinterpret_cast 14\nof static initialization and \ndestruction 274\nprefetching 96–98\npreventing object instantiation 130\nprinciple of least astonishment 254\nprintf 112\npriority_queue template 283\nprivate inheritance 143\nprofiling — see program profiling\nprogram profiling 84–85, 93, 98,\n112, 212\nprogramming in the future \ntense 252–258\nprotected constructors and \ndestructors 142\nproxy classes 31, 87, 190, 194, 213–\n228\ndefinition 217\nlimitations 223–227\nsee also proxy objects\nproxy objects\nand ++, --, +=, etc. 225\nand member function \ninvocations 226\nand operator. 226\nand pointers 223\nas temporary objects 227\npassing to non-const reference \nparameters 226\nsee also proxy classes\n",
      "content_length": 2227,
      "extraction_method": "Direct"
    },
    {
      "page_number": 325,
      "chapter": null,
      "content": "308\n General Index\npseudo-constructors 138, 139, 140\npseudo-destructors 145, 146\npure virtual destructors 195, 265\npure virtual functions —\nsee virtual functions\nPython, Monty, allusion to 62\nQ\nqueue template 4, 283\nR\nrange_error class 66\nrecommended reading\nbooks 285–289\nmagazines 289\non exceptions 287\nUsenet newsgroups 289\nrecompilation, impact of 234, 249\nreference counting 85–87, 171,\n183–213, 286\nand efficiency 211\nand read-only types 208–211\nand shareability 192–194\nassignments 189\nautomating 194–203\nbase class for 194–197\nconstructors 187–188\ncost of reads vs. writes 87, 217\ndesign diagrams 203, 208\ndestruction 188\nimplementation of String\nclass 203–207\noperator[] 190–194\noptimization 187\npros and cons 211–212\nsmart pointer for 198–203\nwhen appropriate 212\nreferences\nand constructors 165\nand virtual functions 118\nas operator[] return type 11\nas parameters — see pass-by-\nreference\nassignment 11\nimplementation 242\nmandatory initialization 10\nnull 9–10\nreturning from operators 102\nto locals, returning 103\nvs. pointers 9–11\nwhen to use 11\nrefined return type of virtual \nfunctions 126\nreinterpret_cast 14–15, 37,\n241\nrelationships\namong delete operator, opera-\ntor delete, and \ndestructors 41\namong delete operator, opera-\ntor delete[], and \ndestructors 43\namong new operator, operator\nnew, and constructors 40\namong new operator, operator\nnew[], and constructors 43\namong operator+, operator=,\nand operator+= 107\nbetween operator new and \nbad_alloc 75\nbetween operator new[] and \nbad_alloc 75\nbetween terminate and \nabort 72\nbetween the new operator and \nbad_alloc 75\nbetween unexpected and \nterminate 72\nreplication of code 47, 54, 142, 204,\n223, 224\nreplication of data under multiple \ninheritance 118–120\nreporting bugs in this book 8\nresolution of calls to overloaded \nfunctions 233\nresource leaks 46, 52, 69, 102, 137,\n149, 173, 240\nand exceptions 45–58\nand smart pointers 159\ndefinition 7\nin constructors 52, 53\npreventing via use of objects 47–\n50, 58, 161\nvs. memory leaks 7\nrestrictions on classes with default \nconstructors 19–22\n",
      "content_length": 2060,
      "extraction_method": "Direct"
    },
    {
      "page_number": 326,
      "chapter": null,
      "content": "General Index\n309\nrethrowing exceptions 64\nreturn expression, and \noptimization 104\nreturn types\nand temporary objects 100–104\nconst 33–34, 101\nobjects 99\nof operator-- 32\nof operator++ 32\nof operator[] 11\nof smart pointer dereferencing \noperators 166\nof virtual functions 126\nreferences 103\nreturn value optimization 101–104,\n109\nreuse — see code reuse\nrhs, definition 6\nrights and responsibilities 213\nRitchie, Dennis M. 36\nRomeo and Juliet, allusion to 166\nRTTI 6, 261–262\nand maintenance 232\nand virtual functions 120, 256\nand vtbls 120\nimplementation 120–121\nvs. virtual functions 231–232\nruntime type identification —\nsee RTTI\nruntime_error class 66\nrvalue, definition 217\nS\nsafe casts 14\nScarlet Letter, The, allusion to 232\nScientific and Engineering C++ 288\nsemantics of function calls 35–36\nsequences of type conversions 29,\n31, 172, 175, 226\nset template 4, 283\nset_unexpected function 76\nsetiosflags, example use 111\nsetjmp and longjmp, vs. \nexceptions 45\nsetprecision, example use 111\nsetw, example uses 99, 111\nshared memory 40\nsharing values 86\nsee also reference counting\nshort-circuit evaluation 35, 36\nsingle-argument constructors — \nsee constructors\nsizeof 37\nslicing problem 70, 71\nsmart pointers 47, 90, 159–182,\n240, 282\nand const 179–182\nand distributed systems 160–162\nand inheritance 163, 173–179\nand member templates 175–182\nand resource leaks 159, 173\nand virtual constructors 163\nand virtual copy \nconstructors 202\nand virtual functions 166\nassignments 162–165, 180\nconstruction 162\nconversion to dumb \npointers 170–173\ncopying 162–165, 180\ndebugging 182\ndeleting 173\ndestruction 165–166\nfor reference counting 198–203\noperator* 166–167\noperator-> 166–167\nreplacing dumb pointers 207\ntesting for nullness 168–170, 171\nSpanish, gratuitous use of 232\nsqrt function 65\nstack objects — see objects\nstack template 4, 283\nstandard C library 278\nstandard C++ library 1, 4–5, 11, 48,\n51, 280\nand code reuse 5\ndiagnostics classes 66\nsummary of features 278–279\nuse of templates 279–280\nsee also Standard Template \nLibrary\nStandard Template Library 4–5,\n95–96, 280–284\nand pass-by-reference 282\nand pass-by-value 282\nconventions 284\n",
      "content_length": 2151,
      "extraction_method": "Direct"
    },
    {
      "page_number": 327,
      "chapter": null,
      "content": "310\n General Index\nexample uses — see example\nuses\nextensibility 284\nfree implementation 4\niterators and operator-> 96\nstandardization committee —\nsee ANSI/ISO standardization \ncommittee\nStar Wars, allusion to 31\nstatic destruction 273–275\nstatic initialization 273–275\nstatic objects 151\nand inlining 134\nat file scope 246\nin classes vs. in functions 133–\n134\nin functions 133, 237\nwhen initialized 133\nstatic type vs. dynamic type 5–6\nwhen copying 63\nstatic_cast 13, 14, 15, 37\nstd namespace 261\nand standard C++ library 280\nstdio, vs. iostreams 110–112\nSTL — see Standard Template \nLibrary\nstrdup 275\nstring class 27, 279–280\nc_str member function 27\ndestructor 256\nString class —\nsee reference counting\nstring objects, vs. char*s 4\nstringstream class 278\nstrlen, and null pointer 35\nstrong typing, bypassing 287\nStroustrup, Bjarne 285, 286\nstrstream class 278\nstructs\ncompatibility between C++ and \nC 276\nprivate 185\nsummaries\nof efficiency costs of various lan-\nguage features 121\nof new language features 277\nof standard C++ library 278–279\nsuppressing\ntype conversions 26, 28–29\nwarnings for unused \nparameters 33, 40\nSurgeon General’s tobacco warn-\ning, allusion to 288\nsurrogates 217\nSusann, Jacqueline 228\nsystem calls 97\nT\ntemplates 286, 288\nand “>>”, vs. “> >” 29\nand default constructors 22\nand exception specifications 73–\n74\nand pass-by-reference 282\nand pass-by-value 282\nand static data members 144\nfor operator+ and operator-\n108\nin standard C++ library 279–280\nmember — see member tem-\nplates\nrecent extensions 277\nspecializing 175\nvs. template instantiations 7\ntemporary objects 34, 64, 98–101,\n105, 108, 109\nand efficiency 99–101\nand exceptions 68\nand function return types 100–\n104\nand optimization 104\nand pass-by-reference 100\nand type conversions 99–100\ncatching vs. parameter \npassing 65\neliminating 100, 103–104\nlifetime of 278\nvs. named objects 109\nterminate 72, 76\nterminology used in this book 5–8\nthis, deleting 145, 152, 157, 197,\n213\nthrow\nby pointer 70\ncost of executing 63, 79\nmodifying objects thrown 63\nto rethrow current exception 64\n",
      "content_length": 2072,
      "extraction_method": "Direct"
    },
    {
      "page_number": 328,
      "chapter": null,
      "content": "General Index\n311\nvs. parameter passing 62–67\nsee also catch\ntransforming concrete classes into \nabstract 266–269\ntrue 3\ntry blocks 56, 79\ntype conversion functions 25–31\nvalid sequences of 29, 31, 172,\n175, 226\ntype conversion operators 25, 26–\n27, 49, 168\nand smart pointers 175\nvia member templates 175–179\ntype conversions 66, 220, 226\nand exceptions 66–67\nand function pointers 241\nand pass-by-reference 100\nand temporary objects 99–100\navoiding via overloading 105–107\nimplicit 66, 99\nsuppressing 26, 28–29\nvia implicit conversion \noperators 25, 26–27, 49\nvia single-argument \nconstructors 27–31\ntype errors, detecting at \nruntime 261–262\ntype system, bypassing 287\ntype_info class 120, 121, 261\nname member function 238\ntypeid 37, 120, 238\ntypes, static vs. dynamic 5–6\nwhen copying 63\nU\nundefined behavior\ncalling strlen with null \npointer 35\ndeleting memory not returned by \nnew 21\ndeleting objects twice 163, 173\ndereferencing null pointers 10,\n167\ndereferencing pointers beyond \narrays 281\nmixing new/free or malloc/\ndelete 275\nunexpected 72, 74, 76, 77, 78\nunexpected exceptions 70\nhandling 75–77\nreplacing with other \nexceptions 76\nsee also unexpected\nUnicode 279\nunion, using to avoid unnecessary \ndata 182\nunnamed namespaces 246, 247\nunnamed objects —\nsee temporary objects\nunused parameters, suppressing \nwarnings about 33, 40\nUrbano, Nancy L. — see Clancy\nURL for this book 8, 287\nuse counting 185\nsee also reference counting\nuseful abstractions 267\nUsenet newsgroups, \nrecommended 289\nuser-defined conversion functions \n— see type conversion functions\nuser-defined types\nand overloaded operators 106\nconsistency with built-ins 254\nusing declarations 133, 143\nV\nvalarray class 279, 280\nvalues, as parameters —\nsee pass-by-value\nvector template 4, 11, 22, 283\nvirtual base classes 118–120, 154\nand default constructors 22\nand object addresses 241\nvirtual constructors 46, 123–127\nand smart pointers 163\ndefinition 126\nexample uses 46, 125\nvirtual copy constructors 126–127\nand smart pointers 202\nvirtual destructors 143, 254–257\nand delete 256\nsee also pure virtual destructors\nvirtual functions\n“demand-paged” 253\nand dynamic_cast 14, 156\nand efficiency 113–118\n",
      "content_length": 2179,
      "extraction_method": "Direct"
    },
    {
      "page_number": 329,
      "chapter": null,
      "content": "312\n General Index\nand exceptions 79\nand mixed-type \nassignments 260, 261\nand pass/catch-by-reference 72\nand pass/catch-by-value 70\nand RTTI 120, 256\nand smart pointers 166\ndesign challenges 248\nefficiency 118\nimplementation 113–118\npure 154, 265\nrefined return type 126, 260\nvs. catch clauses 67\nvs. RTTI 231–232\nvtbl index 117\n“virtual” non-member \nfunctions 128–129\nvirtual table pointers — see vptrs\nvirtual tables — see vtbls\nVlissides, John 288\nvoid*, dynamic_cast to 156\nvolatileness, casting away 13\nvptrs 113, 116, 117, 256\nand efficiency 116\neffective overhead of 256\noptimization under multiple \ninheritance 120\nvtbls 113–116, 117, 121, 256\nand abstract classes 115\nand inline virtual \nfunctions 115\nand RTTI 120\nemulating 235–251\nheuristic for generating 115\nW\nwarnings, suppressing\nfor unused parameters 33, 40\nwhat function 70, 71\nwide characters 279\nWorld Wide Web URL for this \nbook 8, 287\nY\nYiddish, gratuitous use of 32\n",
      "content_length": 938,
      "extraction_method": "Direct"
    },
    {
      "page_number": 330,
      "chapter": null,
      "content": "Index of Example Classes,\nFunctions, and Templates\nClasses and Class Templates\nAbstractAnimal 264\nALA 46\nAnimal 258, 259, 263, 265\nArray 22, 27, 29, 30, 225\nArray::ArraySize 30\nArray::Proxy 225\nArray2D 214, 215, 216\nArray2D::Array1D 216\nAsset 147, 152, 156, 158\nAsteroid 229\nAudioClip 50\nB 255\nBalancedBST 16\nBookEntry 51, 54, 55, 56, 57\nBST 16\nC1 114\nC2 114\nCallBack 74\nCantBeInstantiated 130\nCassette 174\nCasSingle 178\nCD 174\nChicken 259, 260, 263, 265\nCollisionMap 249\nCollisionWithUnknownObject\n231\nColorPrinter 136\nCounted 142\nCPFMachine 136\nD 255\nDataCollection 94\nDBPtr 160, 171\nDynArray 96\nEquipmentPiece 19, 23\nFSA 137\nGameObject 229, 230, 233, 235,\n242\nGraphic 124, 126, 128, 129\nHeapTracked 154\nHeapTracked::MissingAddress\n154\nImage 50\nKitten 46\nLargeObject 87, 88, 89\nLizard 259, 260, 262, 263, 265\nLogEntry 161\nMatrix 90\nMusicProduct 173\nName 25\nNewsLetter 124, 125, 127\nNLComponent 124, 126, 128, 129\nNonNegativeUPNumber 146,\n147, 158\nPhoneNumber 50\nPrinter 130, 132, 135, 138,\n140, 141, 143, 144\nPrinter::TooManyObjects\n135, 138, 140\nPrintingStuff::Printer 132\nPrintJob 130, 131\nPuppy 46\nRational 6, 25, 26, 102, 107,\n225\nRCIPtr 209\nRCObject 194, 204\n",
      "content_length": 1166,
      "extraction_method": "Direct"
    },
    {
      "page_number": 331,
      "chapter": null,
      "content": "314\n Examples Index\nRCPtr 199, 203\nRCWidget 210\nRegisterCollisionFunction\n250\nSatellite 251\nSession 59, 77\nSmartPtr 160, 168, 169, 176,\n178, 181\nSmartPtr<Cassette> 175\nSmartPtr<CD> 175\nSmartPtrToConst 181\nSpaceShip 229, 230, 233, 235,\n236, 238, 239, 240, 243\nSpaceStation 229\nSpecialWidget 13, 63\nSpecialWindow 269\nString 85, 183, 186, 187, 188,\n189, 190, 193, 197, 198, 200,\n201, 204, 218, 219, 224\nString::CharProxy 219, 224\nString::SpecialStringValue\n201\nString::StringValue 186,\n193, 197, 200, 201, 204\nTextBlock 124, 126, 128, 129\nTuple 161, 170\nTupleAccessors 172\nTVStation 226\nUnexpectedException 76\nUPInt 32, 105\nUPNumber 146, 147, 148, 157,\n158\nUPNumber::\nHeapConstraintViolation\n148\nValidation_error 70\nWidget 6, 13, 40, 61, 63, 210\nWindow 269\nWindowHandle 49\nFunctions and Function \nTemplates\nAbstractAnimal::\n~AbstractAnimal 264\noperator= 264\nALA::processAdoption 46\nallocateSomeObjects 151\nAnimal::operator= 258, 259,\n263, 265\nArray::\nArray 22, 27, 29, 30\noperator[] 27\nArray::ArraySize::\nArraySize 30\nsize 30\nArray<T>::Proxy::\noperator T 225\noperator= 225\nProxy 225\nArray2D::\nArray2D 214\noperator() 215\noperator[] 216\nAsset::\n~Asset 147\nAsset 147, 158\nasteroidShip 245\nasteroidStation 245, 250\nAudioClip::AudioClip 50\nBookEntry::\n~BookEntry 51, 55, 58\nBookEntry 51, 54, 55, 56, 58\ncleanup 54, 55\ninitAudioClip 57\ninitImage 57\nC1::\n~C1 114\nC1 114\nf1 114\nf2 114\nf3 114\nf4 114\nC2::\n~C2 114\nC2 114\nf1 114\nf5 114\nCallBack::\nCallBack 74\nmakeCallBack 74\ncallBackFcn1 75\ncallBackFcn2 75\n",
      "content_length": 1493,
      "extraction_method": "Direct"
    },
    {
      "page_number": 332,
      "chapter": null,
      "content": "Examples Index\n315\nCantBeInstantiated::\nCantBeInstantiated 130\nCassette::\nCassette 174\ndisplayTitle 174\nplay 174\nCD::\nCD 174\ndisplayTitle 174\nplay 174\ncheckForCollision 229\nChicken::operator= 259,\n260, 263, 265\nCollisionMap::\naddEntry 249\nCollisionMap 249\nlookup 249\nremoveEntry 249\ntheCollisionMap 249\nCollisionWithUnknownObject::\nCollisionWithUnknownObject\n231\nconstructWidgetInBuffer 40\nconvertUnexpected 76\ncountChar 99\nCounted::\n~Counted 142\nCounted 142\ninit 142\nobjectCount 142\nDataCollection::\navg 94\nmax 94\nmin 94\nDBPtr<T>::\nDBPtr 160, 161\noperator T* 171\ndeleteArray 18\ndisplayAndPlay 174, 177, 178\ndisplayInfo 49, 50\ndoSomething 69, 71, 72\ndrawLine 271, 272, 273\nDynArray::operator[] 97\neditTuple 161, 167\nEquipmentPiece::\nEquipmentPiece 19\nf 3, 66\nf1 61, 73\nf2 61, 73\nf3 61\nf4 61\nf5 61\nfind 281, 282, 283\nfindCubicleNumber 95\nfreeShared 42\nFSA::\nFSA 137\nmakeFSA 137\nGameObject::collide 230,\n233, 235, 242\nGraphic::\nclone 126\noperator<< 128\nprint 129\nHeapTracked::\n~HeapTracked 154, 155\nisOnHeap 154, 155\noperator delete 154, 155\noperator new 154, 155\nImage::Image 50\ninitializeCollisionMap\n245, 246\ninventoryAsset 156\nisSafeToDelete 153\nKitten::processAdoption 46\nLargeObject::\nfield1 87, 88, 89, 90\nfield2 87, 88\nfield3 87, 88\nfield4 87, 88\nfield5 87\nLargeObject 87, 88, 89\nLizard::operator= 259, 260,\n261, 262, 263, 264, 265\nLogEntry::\n~LogEntry 161\nLogEntry 161\nlookup 245, 247\nmain 111, 251, 274\nmakeStringPair 245, 246\nmallocShared 42\nmerge 172\n",
      "content_length": 1461,
      "extraction_method": "Direct"
    },
    {
      "page_number": 333,
      "chapter": null,
      "content": "316\n Examples Index\nMusicProduct::\ndisplayTitle 173\nMusicProduct 173\nplay 173\nName::Name 25\nNewsLetter::\nNewsLetter 125, 127\nreadComponent 125\nNLComponent::\nclone 126\noperator<< 128\nprint 129\nnormalize 170\nonHeap 150\noperator delete 41, 153\noperator new 38, 40, 153\noperator* 102, 103, 104\noperator+ 100, 105, 106, 107,\n108, 109\noperator- 107, 108\noperator<< 129\noperator= 6\noperator== 27, 31, 73\noperator>> 62\npassAndThrowWidget 62, 63\nprintBSTArray 17\nprintDouble 10\nPrinter::\n~Printer 135, 138, 143\nmakePrinter 138, 139, 140,\n143\nperformSelfTest 130, 139,\n143\nPrinter 131, 132, 135, 139,\n140, 143\nreset 130, 139, 143\nsubmitJob 130, 139, 143\nthePrinter 132\nPrintingStuff::Printer::\nperformSelfTest 132\nPrinter 133\nreset 132\nsubmitJob 132\nPrintingStuff::thePrinter\n132, 133\nPrintJob::PrintJob 131\nprintTreeNode 164, 165\nprocessAdoptions 46, 47, 48\nprocessCollision 245\nprocessInput 213, 214\nprocessTuple 171\nPuppy::processAdoption 46\nrangeCheck 35\nRational::\nasDouble 26\ndenominator 102, 225\nnumerator 102, 225\noperator double 25\noperator+= 107\noperator-= 107\nRational 25, 102, 225\nRCIPtr::\n~RCIPtr 209\nCountHolder 209\ninit 209\noperator* 209, 210\noperator= 209, 210\noperator-> 209, 210\nRCIPtr 209\nRCIPtr::CountHolder::\n~CountHolder 209\nRCObject::\n~RCObject 194, 204, 205\naddReference 195, 204, 205\nisShareable 195, 204, 205\nisShared 195, 204, 205\nmarkUnshareable 195, 204,\n205\noperator= 194, 195, 204, 205\nRCObject 194, 195, 204, 205\nremoveReference 195, 204,\n205\nRCPtr::\n~RCPtr 199, 202, 203, 206\ninit 199, 200, 203, 206\noperator* 199, 203, 206\noperator= 199, 202, 203, 206\noperator-> 199, 203, 206\nRCPtr 199, 203, 206\n",
      "content_length": 1621,
      "extraction_method": "Direct"
    },
    {
      "page_number": 334,
      "chapter": null,
      "content": "Examples Index\n317\nRCWidget::\ndoThis 210\nRCWidget 210\nshowThat 210\nrealMain 274\nRegisterCollisionFunction::\nRegisterCollisionFunction\n250\nrestoreAndProcessObject 88\nreverse 36\nsatelliteAsteroid 251\nsatelliteShip 251\nSession::\n~Session 59, 60, 61, 77\nlogCreation 59\nlogDestruction 59, 77\nSession 59, 61\nshipAsteroid 245, 248, 250\nshipStation 245, 250\nsimulate 272, 273\nSmartPtr<Cassette>::\noperator\nSmartPtr<MusicProduct>\n175\nSmartPtr<CD>::\noperator\nSmartPtr<MusicProduct>\n175\nSmartPtr<T>::\n~SmartPtr 160, 166\noperator SmartPtr<U> 176\noperator void* 168\noperator! 169\noperator* 160, 166, 176\noperator= 160\noperator-> 160, 167, 176\nSmartPtr 160, 176\nsomeFunction 68, 69, 71\nSpaceShip::\ncollide 230, 231, 233, 234,\n235, 237, 243\nhitAsteroid 235, 236, 243,\n244\nhitSpaceShip 235, 236, 243\nhitSpaceStation 235, 236,\n243\ninitializeCollisionMap\n239, 240, 241, 243\nlookup 236, 238, 239, 240\nSpecialWindow::\nheight 269\nrepaint 269\nresize 269\nwidth 269\nstationAsteroid 245\nstationShip 245\nString::\n~String 188\nmarkUnshareable 207\noperator= 183, 184, 189\noperator[]\n190,\n191,\n194,\n204, 207, 218, 219, 220,\n221\nString 183, 187, 188, 193,\n204, 207\nString::CharProxy::\nCharProxy 219, 222\noperator char 219, 222\noperator& 224\noperator= 219, 222, 223\nString::StringValue::\n~StringValue 186, 193, 197,\n204, 207\ninit 204, 206\nStringValue 186, 193, 197,\n201, 204, 206, 207\nswap 99, 226\ntestBookEntryClass 52, 53\nTextBlock::\nclone 126\noperator<< 128\nprint 129\nthePrinter 130, 131, 134\nTuple::\ndisplayEditDialog 161\nisValid 161\nTupleAccessors::\nTupleAccessors 172\nTVStation::TVStation 226\ntwiddleBits 272, 273\nupdate 13\nupdateViaRef 14\n",
      "content_length": 1614,
      "extraction_method": "Direct"
    },
    {
      "page_number": 335,
      "chapter": null,
      "content": "318\n Examples Index\nUPInt::\noperator-- 32\noperator++ 32, 33\noperator+= 32\nUPInt 105\nUPNumber::\n~UPNumber 146\ndestroy 146\noperator delete 157\noperator new 148, 157\nUPNumber 146, 148\nuppercasify 100\nValidation_error::what 70\nwatchTV 227\nWidget::\n~Widget 210\ndoThis 210\noperator= 210\nshowThat 210\nWidget 40, 210\nWindow::\nheight 269\nrepaint 269\nresize 269\nwidth 269\nWindowHandle::\n~WindowHandle 49\noperator WINDOW_HANDLE 49\noperator= 49\nWindowHandle 49\n",
      "content_length": 449,
      "extraction_method": "Direct"
    }
  ],
  "enrichment": {
    "version": "1.0.0",
    "generated_by": "generate_chapter_metadata.py",
    "contains": [
      "keywords",
      "concepts",
      "summary"
    ]
  }
}