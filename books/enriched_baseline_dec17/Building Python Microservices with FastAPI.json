{
  "metadata": {
    "title": "Building Python Microservices with FastAPI",
    "source_file": "Building Python Microservices with FastAPI_metadata.json"
  },
  "chapters": [
    {
      "chapter_number": 1,
      "title": "Setting Up FastAPI for Starters",
      "start_page": 3,
      "end_page": 24,
      "summary": "Building Python Microservices with FastAPI\t\nproducts mentioned in this book by the appropriate use of capitals.\nbuild various applications related to manufacturing and fixed assets, document management, records \nHe has authored books such as Spring \ncurrently manages a team of Java developers assigned to different projects in one of the country’s \nHe is often involved in systems analysis and design, source code review, testing, implementation, \nthe author of Practical Docker with Python and a co-author of The CDK Book.\nConcepts for FastAPI microservice development\nSetting Up FastAPI for Starters\t\nSetting up the development \nDesigning and implementing \nManaging user requests and server \nImplementing the API services\b\nManaging API-related \nManaging API responses\b\nCreating background \nThe REST API and the service layer\b\nBuilding the Microservice Application\t\nCreating the sub-applications\b\nCreating a common gateway\b\nCreating the layers\b\nManaging a microservice’s \nCreating CRUD transactions \nSetting up the database connection\b\nBuilding the model layer\b\nImplementing the repository layer\b\nCreating tables \b\nImplementing async \nSetting up the database’s \nCreating the session factory\b\nCreating the Base class and the \nBuilding the repository layer\b\nBuilding the model layer\b\nImplementing the CRUD \nCreating the tables\b\nCreating the database’s \nImplementing the CRUD \nCreating the tables\b\nCreating the database connection\b\nCreating the tables and the \nImplementing the CRUD \nCreating the command and query \nCreating the command and query \nSetting up the database \nSetting up the database connectivity\b\nBuilding the model layer\b\nImplementing the repository layer\b\nCreating async CRUD \nSetting up the database \nCreating the model layer\b\nImplementing CRUD \nBuilding the model layer\b\nImplementing the CRUD \nImplementing async \nCreating the database connection\b\nImplementing the CRUD \nCreating the database connection\b\nCreating the model layer\b\nImplementing the CRUD \nCreating CRUD transactions \nCreating the database connection\b\nBuilding the model layer\b\nCreating the repository layer\b\nApplying the repository layer\b\nCreating the access_token\b\nCreating the login transaction\b\nCreating scope-based \nImplementing the login transaction\b\nImplementing the authorization \nImplementing the authorization \nCreating users and user roles\b\nCreating user permissions through \nCreating Coroutines, Events, and Message-Driven Transactions\t\nImplementing coroutines\b\nCreating asynchronous \nCreating multiple tasks\b\nCreating and configuring the \nCreating the task\b\nCreating the Celery instance\b\nCreating the topic\b\nImplementing asynchronous \nImplementing the asynchronous \nImplementing the WebSocket \nCreating the Observable data \nCreating background process\b\nCreating user sessions\b\nImplementing symbolic \nCreating symbolic expressions\b\nCreating arrays and \nImplementing the workflow\b\nCreating the record insertion, \nImplementing the query \nCreating the CRUD transactions\b\nImplementing client-side service \nCreating the Docker image \b\nCreating the containers\b\nThis book teaches you about the components of the FastAPI framework and how to apply these \ncomponents with some third-party tools to build microservices applications.\nin Python programming, knowledge of the principles of API development, and an understanding \nof the principles behind creating an enterprise-grade microservice application.\nreference book: it provides some code blueprints that will help you solve real-world applications while \nWho this book is for\nThis book is for Python web developers, advanced Python users, and backend developers using Flask \nor Django who want to learn how to use the FastAPI framework to implement microservices.\nknowledgeable about REST API and microservices will also benefit from this book.\nbook contain general concepts, processes, and instructions that intermediate-level developers and \nChapter 1, Setting Up FastAPI for Starters, introduces how to create FastAPI endpoints using the \ncore module classes and decorators and how the framework manages incoming API requests and \nChapter 2, Exploring the Core Features, introduces FastAPI’s asynchronous endpoints, exception \nutilized by FastAPI to manage instances and project structure using its Depends() directive and \nChapter 4, Building the Microservice Application, is on the principles and design patterns that support \nthe building of microservices, such as decomposition, property configuration, logging, and domain \nChapter 5, Connecting to a Relational Database, focuses on Python Object Relational Mappers (ORMs), \nwhich can integrate seamlessly with FastAPI to persist and manage data using a PostgreSQL database.\nsome popular Python Object Document Mapper (ODMs), which can connect FastAPI applications \nChapter 7, Securing the REST APIs, highlights FastAPI’s built-in security module classes and explores \nsome third-party tools such as JWT, Keycloak, Okta, and Auth0 and how they are applied to implement \nChapter 8, Creating Coroutines, Events, and Message-Driven Transactions, focuses on the details of \nChapter 9, Utilizing Other Advanced Features, contains other features that FastAPI can provide, such \nChapter 10, Solving Numerical, Symbolic, and Graphical Problems, highlights the integration of FastAPI \nwith the numpy, pandas, matplotlib, sympy, and scipy modules to implement API services \nservice discovery, managing repository modules, deployment, and creating monorepo architectures \nTo get the most out of this book\nThis book requires some experience with Python programming using Python 3.8 or 3.9, as well as \nsome API development experience with any Python framework.\npractices of coding Python, including some advanced topics such as creating decorators, generators, \ndatabase connectivity, request-response transactions, HTTP status codes, and API endpoints, is required.\nIf you are using the digital version of this book, we advise you to type the code yourself or access \nthe code from the book’s GitHub repository (a link is available in the next section).\nYou can download the example code files for this book from GitHub at https://github.com/\nPacktPublishing/Building-Python-Microservices-with-FastAPI.\ndelete_user() service is a DELETE API method that uses a username path parameter to \npacktpub.com and mention the book title in the subject of your message.\nare interested in either writing or contributing to a book, please visit authors.packtpub.com.\nOnce you’ve read Building Python Microservices with FastAPI, we’d love to hear your thoughts!\nfor FastAPI microservice \nto pursue microservices implementation.\n•\t Chapter 1, Setting Up FastAPI for Starters \n•\t Chapter 4, Building the Microservice Application",
      "keywords": [
        "CRUD transactions",
        "Creating",
        "Creating CRUD transactions",
        "Database",
        "transactions",
        "CRUD",
        "book",
        "implementing",
        "Packt Publishing",
        "FastAPI",
        "Building Python Microservices",
        "Building",
        "API",
        "Implementing CRUD transactions",
        "Python"
      ],
      "concepts": [
        "creating",
        "create",
        "implementation",
        "implement",
        "manager",
        "manages",
        "database",
        "chapters",
        "applying",
        "apply"
      ],
      "similar_chapters": [
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 3,
          "title": "",
          "score": 0.829,
          "base_score": 0.679,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 11,
          "title": "",
          "score": 0.624,
          "base_score": 0.474,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 10,
          "title": "",
          "score": 0.618,
          "base_score": 0.468,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 4,
          "title": "",
          "score": 0.483,
          "base_score": 0.483,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 5,
          "title": "",
          "score": 0.475,
          "base_score": 0.475,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "creating",
          "book",
          "implementing",
          "implementing crud",
          "building"
        ],
        "semantic": [],
        "merged": [
          "creating",
          "book",
          "implementing",
          "implementing crud",
          "building"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4851601186160158,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:22.900674+00:00"
      }
    },
    {
      "chapter_number": 3,
      "title": "Investigating Dependency Injection",
      "start_page": 47,
      "end_page": 76,
      "summary": "the service method as str types, since cookie values are always strings.\nthe fastapi module also provides a Cookie function that is needed to initialize each declared \nparameters optionally, ensuring that the API method executes without problems whenever the headers \nto build different REST APIs associated with HTTP methods using the FastAPI module class and \nusing the local parameters of the API methods and how these API methods should return a response \nfunction, the FastAPI module also has the Cookie function to help us create and retrieve cookies \nthese essential core features, which will provide our application with the needed response encoder and \ngenerator, exception handlers, middleware, and other components related to asynchronous transactions.\nwith FastAPI, as was building the different HTTP path operations.\nAPIs by adding some essential FastAPI features to the implementation.\nresponses, background jobs that can create audit trails and logs, and multiple threads to run some API \n•\t Managing API-related exceptions\n•\t Managing API responses\nIt also allows users or tourists to comment on tours and rate them.\nan administrator account for adding and removing all the tour details, managing users, and providing \nIn FastAPI, big projects are organized and structured by adding packages and modules without \nIn this prototypical intelligent tourist system, the application has several modules such as the login, \nEach package in Figure 2.1 contains all the modules where the API services and some dependencies \ntasks, custom exception handlers, middleware, and the main.py file.\nFor these module packages to function, the main.py file must call and register all their API \nFastAPI object.\nsetup, handling of form data, generation of responses, and parameter injection of model objects.\nfrom login.user import Signup, User, Tourist, \nThe list_all_tourists() API method operation here is part of the manager.py module in \nuser.py module in the login package.\nfrom fastapi import APIRouter, status\nModule scripts can also import components from the main project folder when needed by the \nmodule script, a.py, accesses components from b.py that import resource objects from \nmain.py, just as the other project-level scripts do, uses FastAPI and not \nThe FastAPI class \nother attributes and components to the router such as URL prefixes, tags, dependencies such as exception \nfrom fastapi import FastAPI, Request\nfrom login import user\nThis code is the main.py implementation of the intelligent tourist system prototype tasked to import \nWhat happens to the application when API services encounter runtime problems during execution?\nimplementing API services with exception-handling mechanisms further.\nManaging API-related exceptions\nThe FastAPI framework has a built-in exception handler derived from its Starlette toolkit that always \nreturns default JSON responses whenever HTTPException is encountered during the execution of \nuser/login without providing the username and password will give us the default JSON \nIn some rare cases, the framework sometimes chooses to return the HTTP response status instead \nwhich responses to return whenever a specific exception cause happens.\nA single status code response\nblock to manage the return responses of your API when it encounters an exception or none.\nThe path operation of FastAPI and APIRouter has a status_code parameter \nthat we can use to indicate the type of status code we want to raise.\nIn FastAPI, status codes are integer constants that are found in the status module.\nManaging API-related exceptions\nHTTP response of a REST API operation.\nfrom fastapi import APIRouter, status\nreturn tours\nThe list_all_tours() method shown here is the kind of REST API service that should emit Status \nboth blocks return a custom JSON response.\nusing the status_code parameter of the path operations and use JSONResponse instead.\nJSONResponse is one of the FastAPI classes used to render a JSON response to the client.\ninstantiated, constructor-injected with values for its content and status_code parameters, \nBy default, the framework uses this API to help path operations \nrender responses as JSON types.\nIts content parameter should be a JSON-type object, while the \nfrom fastapi.responses import JSONResponse\nManaging API-related exceptions\ntour_json = jsonable_encoder(tour)\nreturn JSONResponse(content=tour_json, \nreturns the tour details and SC 201, while its catch block returns an error message inside a JSON-\nHTTPException is a FastAPI class that has required constructor parameters: detail, \nwhich needs an error message in the str type, and status_code, which asks for a valid integer \nThe detail part is converted to JSON-type and returned to the user as a response after the \nthe whole operation will halt and send the HTTP error message in JSON-type to the client with the \nfrom fastapi import APIRouter, HTTPException, status\n@router.post(\"/ch02/tourist/tour/booking/add\")\ndef create_booking(tour: TourBasicInfo, touristId: UUID):\nThis custom exception requires a custom handler needed to manage its response to the client \nIn our application, there are two custom exceptions created in handler_exceptions.py, the \nrelated to posting feedback and ratings on a particular tour:\nfrom fastapi import FastAPI, Request, status, HTTPException\ndef __init__(self, detail: str, status_code: int):\ndef __init__(self, detail: str, status_code: int):\nA valid FastAPI exception is a subclass of an HTTPException object inheriting the essential \nManaging API-related exceptions\nThe FastAPI @app decorator in main.py has an exception_handler() method, used to define a \nwith two local parameters, Request and the custom exception that it manages.\nRequest object is to retrieve cookies, payloads, headers, query parameters, and path parameters from \nraised, the handler is set to generate a JSON-type response to the client containing the detail and \nthe status_code attributes provided by the path operation that raised the exception:\nfrom fastapi.responses import JSONResponse\nfrom fastapi import FastAPI, Request, status, HTTPException\ndef feedback_exception_handler(req: Request, \ndef rating_exception_handler(req: Request, \nWhen an operation in post.py raises PostFeedbackException, the feedback_exception_\ndef post_tourist_feedback(touristId: UUID, tid: UUID,\ntour details invalid', status_code=403)\ntour_id= tid, tourist_id=touristId) \nstr(touristId), message=\"post_tourist_feedback\")\ndetail='tour assessment invalid', status_code=403)\ntour_json = jsonable_encoder(tours[tid])\nreturn JSONResponse(content=tour_json, status_code=200)\npost_tourist_feedback() and update_tour_rating() here are the API operations that \ninjected into the constructor are passed to the handlers to create the response.\nManaging API-related exceptions\nglobal exception handler of the FastAPI framework that manages its core Starlette’s HTTPException \nraise from JSON-type to plain text, we can create custom handlers for each of the aforementioned \nfrom fastapi.responses import PlainTextResponse \nfrom fastapi.exceptions import RequestValidationError\ndef global_exception_handler(req: Request, \nhandler() handlers are implemented to change the framework’s JSON-type exception response \nPostRatingException are both implemented in the handler_exceptions.py module.\nJSON objects are all over the FastAPI framework’s REST API implementation, from the incoming \nFastAPI JSON-compatible type?\nIt is easier for FastAPI to process JSON-compatible types such as dict, list, and BaseModel \nWhen it comes to the direct handling of the API operation’s responses, FastAPI has a built-in method \nthat can encode typical model objects to convert them to JSON-compatible types before persisting \njsonable_encoder(), returns a dict type with all the keys and values compatible with JSON:\nfrom fastapi.responses import JSONResponse\npending_users[userid] = tourist_json\nreturn JSONResponse(content=tourist_json, \nManaging API responses\nHaving model objects with non-JSON-friendly components in FastAPI-related operations \nManaging API responses\nThe use of jsonable_encoder() can help an API method not only with data persistency \nmethod, JSONResponse returns the encoded Tourist model instead of the original object to \nerror messages, JSONResponse can also do some tricks in handling the API responses to the client.\nfrom fastapi.responses import JSONResponse\ndef check_tour_profile(id: UUID):\ntour_info_json = jsonable_encoder(tours[id])\nreturn JSONResponse(content=tour_info_json)\ncheck_tour_profile() here uses JSONResponse to ensure that its response is JSON-\nto return headers together with the JSON-type response:\ntours_json = jsonable_encoder(tours)\nreturn JSONResponse(content=tours_json, \nThe application’s list_tour_destinations() here returns three cookies: AppName, Max-Age, \nBesides JSONResponse, the fastapi module also has a Response class \nfrom fastapi import APIRouter, Response\ndef check_recommended_tour(resp: Response):\nOur prototype’s check_recommend_tour() uses Response to create two custom response \n@router.get(\"/ch02/tourist/tour/booked\")\nreturn approved_users[touristId].tours\nHTTPException, as shown in the show_booked_tours() service method here, not only \ncontains the status code and error message but also some headers in case the operation needs to leave \nLet us now explore the capability of FastAPI to create and manage transactions that are designed to \nThe FastAPI framework is also capable of running background jobs as part of an API service execution.\nThe class responsible for this is BackgroundTasks, which is part of the fastapi \nConventionally, we declare this at the end of the parameter list of the API service method \nIn our application, the task is to create audit logs of all API service executions and store them in an \nfrom fastapi import APIRouter, status, BackgroundTasks\n@router.post(\"/ch02/user/login/\")\nasync def login(login: User, bg_task:BackgroundTasks):\njsonable_encoder(approved_users[login.id])\n@router.get(\"/ch02/user/login/{username}/{password}\")\ntour_json = jsonable_encoder(tourist)\ntouristId=str(tourist['login']['id']), \nreturn JSONResponse(content=tour_json, \nThe login() service method is just one of the services of our application that logs its details.\nClients will always get their response from the REST API method despite the execution time \ntourist_posts = [assess for assess in feedback_tour.\ntourist_posts_json = jsonable_encoder(tourist_posts) \nreturn JSONResponse(content=tourist_posts_json,\nOur application has a show_tourist_post() service that can retrieve all the feedback posted \ntour details invalid', status_code=403)    post_\nposts of {touristId}\"}, status_code=200)\ndelete_tourist_feedback() here is an asynchronous REST API endpoint that calls an \ntwo components to have a handshake, the API service invokes check_post_owner(), using an \nAnd now, the last, most important core feature that FastAPI can provide is the middleware or the \nIt is an asynchronous function that acts as a filter for the REST API services.\ndetails of the request body before it reaches the API service method.\nTo implement middleware, first, create an async function that has two local parameters: the \nRequest parameter as its argument to return the response.\nThe tourist application has one middleware implemented by the asynchronous add_transaction_\nfilter() here that logs the necessary request data of a particular API method before its execution \nThe FastAPI framework has some built-in middleware that is ready to be injected into the application \nform data, request parameters, query parameters, cookies, request headers, and authentication details \ninto the Request object, and the outgoing cookies, response headers, and response data are carried \nbuilt-in jsonable_encoder() function that can convert the model into JSON types to be rendered \ncustomize it to handle the Request object before it reaches the API execution and the Response \nStarlette global exception handler and Pydantic model validator, FastAPI allows exception-handling \nFastAPI follows Python’s AsyncIO principles and standards for creating async REST endpoints, which \nIn the next chapter, we will be discussing FastAPI dependency injection and how this design pattern \nFastAPI REST services and was apparent in some of our sample APIs that required BaseModel, \ncontainer that can provide the objects of these classes for the API services.\nFastAPI has a container where the DI policy is applied to instantiate module classes and even functions.\nWe only need to specify and declare these module APIs to the services, middleware, authenticator, \nFor FastAPI, DI is not only a principle but a mechanism to integrate an object into a component that \nsome JSON objects once they are injected into an API service – injectable and callable components \nA dependency function is a typical Python function that has parameters such as a path operation or an \nAPI service and a return value of a JSON type too.\nas shown in the following code, which is in the project’s /api/users.py module:\ndef create_login(id:UUID, username: str, password:str, \nThe function requires the id, username, and password parameters and type to continue its \nprocess and return a valid JSON account object, derived from these parameters.\nCommon to dependency functions are method parameters that serve as placeholders to a REST \nThe Depends() function from the fastapi \nfrom fastapi import APIRouter, Depends\nuser_account=Depends(create_login)):\ninjects create_login()into the framework’s container and fetches its instance for wiring to the \nmany APIs in converting these injectables to JSON-compatible types such as dict, which are essential \nFastAPI also allows classes to be injected into any components, since they can also be considered \nThe Login class, located in /model/users.py, needs id, username, password, and type passed \nshows how Depends() injects Login to the service.\nuser_account=Depends(Login)):\nas sub-dependencies into JSON-compatible types by FastAPI:\nasync def create_user_details(id: UUID, firstname: str,\nlogin=Depends(create_login)):\nThe preceding asynchronous create_user_details() function shows that even a dependency \nThis function is dependent on create_\nlogin(), which is another dependable component.\ncreate_user_details() into an API service also includes the injection of create_login() \n@router.post(\"/users/add/profile\")\nprofile=Depends(create_user_details)): \nThe preceding add_profile_login() service provides a clear picture of its dependency on \ncreate_user_details(), including its underlying login details.\nhere, which is dependent on UserDetails and Login classes:\nlogin=Depends(Login), user=Depends(UserDetails)): \n@router.post(\"/users/add/model/profile\")\nCreating explicit dependencies between function and class will be discussed later, but for now, let \nAll dependencies are cacheable, and FastAPI caches all these dependencies during a request transaction.\nIf a dependable is common to all services, FastAPI will not allow you to fetch these objects from its \n@router.post(\"/users/add/model/profile\")",
      "keywords": [
        "REST API",
        "API",
        "REST API service",
        "login",
        "FastAPI",
        "tour",
        "API service",
        "JSON",
        "status",
        "code",
        "REST API operation",
        "Managing API responses",
        "status code",
        "REST APIs",
        "response"
      ],
      "concepts": [
        "fastapi",
        "response",
        "responsible",
        "responsibility",
        "important",
        "importing",
        "tours",
        "user",
        "returns",
        "dependencies"
      ],
      "similar_chapters": [
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 1,
          "title": "",
          "score": 0.829,
          "base_score": 0.679,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 10,
          "title": "",
          "score": 0.637,
          "base_score": 0.487,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 8,
          "title": "",
          "score": 0.527,
          "base_score": 0.527,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 11,
          "title": "",
          "score": 0.526,
          "base_score": 0.376,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 4,
          "title": "",
          "score": 0.512,
          "base_score": 0.512,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "json",
          "jsonresponse",
          "response",
          "exception",
          "tour"
        ],
        "semantic": [],
        "merged": [
          "json",
          "jsonresponse",
          "response",
          "exception",
          "tour"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.47742444295538655,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:22.900699+00:00"
      }
    },
    {
      "chapter_number": 4,
      "title": "Building the Microservice Application",
      "start_page": 77,
      "end_page": 106,
      "summary": "Investigating Dependency Injection\nDeclaring Depends() parameter types\nGenerally, we do not declare types of the local parameters that will reference the injected dependencies.\nuser_account:Login=Depends(create_login)):\nThis scenario happens very rarely, since create_login() is a dependency function, and we usually \ndependables, declaring the appropriate class type to the wired object is feasible, as in the following \nadd_profile_login_models() service, which declares the profile parameter as Profile:\nthe statement with a shorthand version by omitting the class name inside the Depends() function.\nInjecting asynchronous dependencies\nA FastAPI built-in container does not only manage synchronous function dependables but also \nThe following create_user_details() is an asynchronous dependency, \nasync def create_user_details(id: UUID, firstname: str, \nlogin=Depends(create_login)):\nThe container can manage both synchronous and asynchronous function dependency.\nthe wiring of asynchronous dependables on an asynchronous API service or some asynchronous ones \nIn cases where the dependency and the services are both asynchronous, \nuser_details(), which is dependent on a synchronous create_login(), is wired on \nInvestigating Dependency Injection\nof strategy for applying Depends() in our application.\nExploring ways of injecting dependencies\nare injectables are those so-called dependables, injectables, or dependencies.\nDependency injection on services\nWhen it comes to complex query parameters or request bodies, API services can take more than \none injectable as long as there are no similar instance variable names among these dependables.\nBoth function and class dependencies can work with the GET, POST, PUT, and \nWe must plan which HTTP method is applicable for some dependable(s) first, before \n•\t Third, not all dependables are placeholders of request data.\nUnlike the class dependables, \ndependency functions are not specifically used for returning objects or dict.\nThe following get_all_recipes() service is dependent on a get_recipe_service() \ninjectable that will query all the recipes from the dict repository of the application:\ndef get_all_recipes(handler=Depends(get_recipe_service)):\nExploring ways of injecting dependencies\nThe dependency function provides the needed transactions such as saving and retrieving records of \nInstead of the usual instantiation or method call, a better strategy is to inject these dependable \nservices into the API implementation.\nDependency injection on path operators\nSince these dependables work like filters to the incoming request, their injection happens \nthe check_feedback_length() validator, found in /dependencies/posts.py, which \nchecks whether the feedback posted by a user regarding a recipe should be at least 20 characters, \nCompared to the create_post() and post_service() dependables, the following script \nasync def create_post(id:UUID, feedback: str, \nInvestigating Dependency Injection\ndependencies=[Depends(check_feedback_length)])\nasync def insert_post_feedback(post=Depends(create_post), \nhandler=Depends(post_service)): \ninjectables, post and handler, are part of the API’s transactions.\ndependencies parameter always needs a List value ([]).\nDependency injection on routers\nThere are dependency \nfunctions created to work with a certain group of REST API services within an application, such as the \nthat are designed to manage incoming requests of REST APIs under the user.router group.\nExploring ways of injecting dependencies\nUserType of the new record, the API service pauses briefly and resumes after the function dependency \nInjecting these two dependables through APIRouter means that all the REST API services registered \nThe dependencies can \nonly work with API services designed to persist the like of the user and login details, as shown here:\nfrom fastapi import APIRouter, Depends\nrouter = APIRouter(dependencies=[\nDepends(count_user_by_type), \nDepends(check_credential_error)])\nuser_account:Login=Depends(create_login)):\nInvestigating Dependency Injection\nusername and password derived from the create_login() injectable function.\nfilters the create_user_details() injectable of the add_profile_login() service, as \nprofile=Depends(create_user_details)): \nuser_account=Depends(Login)):\nIt also contains the username and password parameters that the injectable function can filter.\nConversely, the injectable Profile of the following add_profile_login_models() service is \nnot excluded from the error-checking mechanism because it has a Login dependency in its constructor.\nHaving the Login dependable means check_cedential_error() will also filter Profile.\nthe number of users that access the API service:\nExploring ways of injecting dependencies\nA dependency function wired into APIRouter should apply defensive programming and a proper \ncredential_error() with a list_all_user() service, for instance, expect some runtime \nbecause its dependencies parameter will allow a List ([]) of valid ones.\nDependency injection on main.py\nfrom fastapi import FastAPI, Depends\nfrom api import recipes, users, posts, login, admin,\nInvestigating Dependency Injection\nfrom dependencies.global_transactions import    \napp = FastAPI(dependencies=[Depends(log_transaction)])\nDependencies auto-wired to the FastAPI constructor are known as global dependencies because they \nin the preceding script, will execute every time the APIs from the recipes, users, posts, or \nLike APIRouter, the constructor of FastAPI allows more than function dependency.\nIt is feasible to use a repository-service pattern in some complex FastAPI applications through DI.\nrepository-service pattern is responsible for the creation of the repository layer of the application, \nSome model classes are dependable on other models, \nInvestigating Dependency Injection\nThis layer is composed of class dependencies, which have access to the data store or improvised dict \nclasses build the CRUD transactions needed by the REST API.\nfrom model.recipes import Ingredient\nInvestigating Dependency Injection\ndependency if there is any.\ndef get_recipe_repo(repo=Depends(RecipeRepository)):\ndef get_post_repo(repo=Depends(PostRepository)): \ndef get_users_repo(repo=Depends(AdminRepository)): \ndef get_keywords(keywords=Depends(KeywordRepository)): \ndef get_bad_recipes(repo=Depends(BadRecipeRepository)): \nWe can see from the preceding script that RecipeRepository is a dependable object of the \nfactory methods, which are also injectable components but of the service layer.\nrecipe_repo() will be wired to a service class to pursue the implementation of native services \nrepository class to the service layer.\nThe injection strategy used here is the function of class dependency, which is depicted in the \nfrom repository.factory import get_recipe_repo\ndef __init__(self, repo=Depends(get_recipe_repo)):\neither be a function or class dependable.\nThe REST API and the service layer\nThe REST API methods can directly inject the service class or factory method if it needs to access the \nIn our application, there is a factory method associated with each service class to apply \nthe get_recipe_service() method is wired to the REST API instead of RecipeService:\nInvestigating Dependency Injection\nhandler=Depends(get_recipe_service)): \ndef get_all_recipes(handler=Depends(get_recipe_service)):\nThe insert_recipe() is a REST API that accepts a recipe and its ingredients from a client for \nDI has a lot to offer to improve our application, but it still depends on the framework we use to get \nthese popular external modules that integrate seamlessly with FastAPI, the Dependency Injector and \nUsing configurable containers – Dependency Injector\nWhen it comes to configurable containers, the Dependency Injector has several module APIs that can \nbe used to build variations of custom containers that can manage, assemble, and inject objects.\nInvestigating Dependency Injection\nThe containers and providers module\nAmong all the API types, Dependency Injector is popular with its containers and providers.\nIts providers can be Factory, Dict, List, Callable, Singleton, or other containers.\nA Factory provider, conversely, instantiates any class, such as a repository, service, \nThe Callable provider manages function dependencies, \nAside from these container APIs, the Dependency Injector allows us to customize a container based \nOur online recipe system prototype owns a single declarative container, which is \nfrom dependency_injector import containers, providers\nfrom repository.users import login_details\nfrom service.recipe_utilities import get_recipe_names \nAdminRepository is an injected singleton object, get_recipe_names() is an injected \nfunction dependable, and login_details is an injected dictionary containing login credentials.\nFastAPI and Dependency Injector integration\nTo wire the dependencies to a component through the Dependency Injector, the @inject decorator \n@inject is imported from the dependency_injector.wiring module and is \nmarkers search for the Provider object that references the injectable in the container, and if it \nBoth @inject and Provide belong to the same API module:\nfrom dependency_injector.wiring import inject, Provide\nDepends(Provide[Container.keywordservice])): \nThe integration happens when the Depends() function directive is invoked to register the wiring \nthe injectables into FastAPI.\nThe preceding script imports Container from its module to wire \nProvider of Dependency Injector.\nInvestigating Dependency Injection\nFor large applications, the number of repository transactions and services increases based on the \nDependency Injector allows us to create a separate container for each group of services.\nfrom dependency_injector import containers, providers\nThe injection of the dependencies to the API is like the single declarative style, except that the container \nwire dependencies to REST services:\nfrom dependency_injector.wiring import inject, Provide\nDepends(\nbefore it fetches the adminservice provider that references the service dependable.\nInvestigating Dependency Injection\nWhat is highlighted here about Dependency Injector is just basic configurations for simple applications.\ndependables.\nContainers in Lagom are created instantly using the Container class from its module.\nDependency Injector, Lagom’s containers are created before the injection happens inside the module \nAll dependables are injected into the container through typical instantiation.\nan object, the container needs its class name as its key and the instance as its value.\nScoping of dependables\nThe dependables\nThe instance of FastAPIIntegration has a depends() method, which we will use to perform \nThus, wiring the dependencies will not need FastAPI’s Depends() function anymore:\nThe preceding report_recipe() utilizes BadRecipeRepository as an injectable service.\nit is part of the container, Lagom’s depends() function will search for the object in the container, \nIn FastAPI, the scope of dependables can be either a new instance or a singleton.\ndependencies, FastAPI always fetches a new instance of each wired dependable, which can be proven \nsince it is not easy to create a singleton with FastAPI, we can use either Dependency Injector or Lagom.\nInvestigating Dependency Injection\nThere is a Singleton provider in Dependency Injector that is responsible for the creation \nof singleton dependencies.\nThe Singleton class wraps the instance of the dependency before injecting it into the container.\nThe other way is to declare the dependency in the request_singletons parameter of the \nFastAPI has a built-in container that we can utilize to establish dependency among components.\nFrom simple injection using Depends(), we can extend \nThis chapter also introduced some third-party modules such as Dependency Injector and Lagom that \nPreviously, we spent a lot of time building API services for various applications using the core features \nDependency Injection (DI), which are essential for managing FastAPI container objects.\npackages were installed and used to provide options on what containers to use in managing objects.\nThese design patterns can help not only with managed objects in container but also when building \nFastAPI microservice applications.\nDependency Injection, gave us the foundation to build a FastAPI microservice:\nEach application can have a separate logging mechanism, dependency environment, \nBut FastAPI has another way of designing microservices using a mount sub-application.\nFastAPI allows you to build independent sub-applications inside the main application.\nspecifying the context path mapped to the FastAPI instance of each sub-application.\nhas a main.py component, such as library_mgt, which has its FastAPI instance created in its \nThe student sub-application has a student_main.py setup that creates its FastAPI instance, as \nThese sub-applications are typical FastAPI microservice applications containing all of the essential \nAll the FastAPI decorators of each sub-application must be mounted in the main.py component \nby the FastAPI decorator object of the top-level application, which adds all FastAPI instances of the \nWith this setup, the mounted /ch04/student URL will be used to access all the API services of \napply another design strategy that can help manage the requests to these applications just by using the \nIt will be easier if we use the URL of the main application to manage the requests and redirect users \nis having a simple REST API service in the top-level application with an integer path parameter that \nThe portal_id parameter will automatically be fetched and evaluated using a dependable function \nthat is injected into the APIRouter instance where the API endpoint is implemented.\nin Chapter 3, Investigating Dependency Injection, a dependable function or object can serve as a filter \nor validator of all incoming requests of any services once injected into an APIRouter or FastAPI \nThe dependable function used in this ERP prototype, as shown in the following script, ",
      "keywords": [
        "Investigating Dependency Injection",
        "Dependency Injection",
        "Dependency",
        "REST API",
        "REST API services",
        "Dependency Injector",
        "container",
        "login",
        "API",
        "recipe",
        "Depends",
        "FastAPI",
        "API services",
        "profile",
        "service"
      ],
      "concepts": [
        "dependency",
        "depends",
        "dependencies",
        "dependent",
        "important",
        "imported",
        "container",
        "application",
        "applications",
        "injection"
      ],
      "similar_chapters": [
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 8,
          "title": "",
          "score": 0.523,
          "base_score": 0.523,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 3,
          "title": "",
          "score": 0.512,
          "base_score": 0.512,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 1,
          "title": "",
          "score": 0.483,
          "base_score": 0.483,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 5,
          "title": "",
          "score": 0.448,
          "base_score": 0.448,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 10,
          "title": "",
          "score": 0.403,
          "base_score": 0.403,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "dependency",
          "dependency injection",
          "injection",
          "dependencies",
          "depends"
        ],
        "semantic": [],
        "merged": [
          "dependency",
          "dependency injection",
          "injection",
          "dependencies",
          "depends"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4688804075567563,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:22.900714+00:00"
      }
    },
    {
      "chapter_number": 5,
      "title": "Connecting to a Relational Database",
      "start_page": 107,
      "end_page": 160,
      "summary": "from fastapi import FastAPI, Depends, Request, Response\ndef exception_handler_faculty(request: Request, \nWe have created an audit trail mechanism with middleware and Python file transactions in Chapter 2, \nFastAPI decorator of the top-level application, can manage incoming Request and outgoing Response of \nthat will log all service transactions of the top-level application alongside its independent mounted \nin a single server, logging means letting service transactions write their log messages to a single file.\nFor FastAPI instances that support both asynchronous and synchronous API services that run on an \nASGI server, using Python’s logging module always generates the following error log:\nneeds to place all messages in a log file, we need to add the following lines to the main.py component \ngenerated log_id parameter and then the time the logging happened, the level, and the message.\nAll the logging features we need to set up our unified application log are in \nNow that we have configured our Loguru in the top-level application, we need to let its logging \nThe core component of this centralized application log is the custom middleware that we must implement \nasync def log_middleware(request:Request, call_next):\nFirst, log_middleware() will generate a log_id parameter every time it intercepts any API \nThen, the log_id parameter is injected into \nthe dict of context information through Loguru’s contextualize() method since log_id is \nwe access any API services anywhere from the ERP prototype, the following log messages will be \nfilters all API service execution and performs the logging transaction.\nfrom accessing the gateway down to executing the API services from the faculty, student, and library \nto pursue its GET request from an asynchronous /ch04/faculty/assignments/list API \nsubmit an assignment to the Faculty module through a POST request.\nrequirement of the client service as to what response type to use for the application.\nThe requests module has a Session() instance, which is equivalent to Client() in the httpx \nFrom the preceding code, we can see that sessions are created to implement the list_all_request \nFigure 4.5 shows the models, repositories, services, and controllers of the sub-applications: \nThe most crucial layer is the models layer, which consists of the domain model classes that describe \nThe domain model layer is the initial artifact of the application because it provides the contextual \nFor instance, the faculty module has the following data models:\nclass Assignment: \ndef __init__(self, assgn_id:int, title:str, \nreturn ' '.join([str(self.assgn_id), self.title,\nreturn ' '.join([str(self.assgn_id), self.title, \ndef __init__(self, bin_id:int, stud_id:int, \nself.faculty_id:int = faculty_id \nreturn ' '.join([str(self.bin_id), \nstr(self.stud_id), str(self.faculty_id)])\nreturn ' '.join([str(self.bin_id), \nstr(self.stud_id), str(self.faculty_id)])\nThese data model classes always have their constructors implemented if constructor injection is needed \nAdditionally, the faculty module has the following request models:\ndetails on how to create BaseModel classes, Chapter 1, Setting Up FastAPI for Starters, provides \nguidelines for creating different kinds of BaseModel classes to capture different requests from clients.\nbut oftentimes, repository's goal is to interact with the Object Relational Model (ORM) framework \nThe following is a repository class of the faculty module, which manages \nfrom faculty_mgt.models.data.facultydb import \nfrom faculty_mgt.models.data.faculty import Assignment\ndef insert_assignment(self, \ndef update_assignment(self, assgn_id:int, \ndef delete_assignment(self, assgn_id:int) -> bool: \ndef get_all_assignment(self):\nTo retrieve all the created assignments, the repository class has get_all_\ncontrols for the other components of the application, such as the API services or controllers.\none service caters to one repository class or more depending on the specification of the project.\nfrom faculty_mgt.models.data.faculty import Assignment\ndef create_workbin(self, stud_id:int, faculty_id:int): \nresult = self.repo.create_bin(stud_id, bin_id, \ndef add_assigment(self, bin_id:int, \nresult = self.repo.insert_submission(bin_id, \ndef remove_assignment(self, bin_id:int, \nresult = self.repo.insert_submission(bin_id, \ndef list_assignments(self, bin_id:int): \nreturn self.repo.get_submissions(bin_id)\nThe factory method design pattern is always a good approach for managing injectable classes and functions \nNow, let us look at how the top-level application can manage the different configuration details of \nconfiguration details to mounted microservice applications such as database credentials, networking \nconfiguration data, application server information, and deployment details.\nAll of these settings are values that are external to the implementation of the microservice applications.\nStoring settings as class attributes\nThe following are classes \napplication:str = 'Faculty Management System' \napplication:str = 'Library Management System' \napplication:str = 'Student Management System' \nTo fetch the values, first, a component in a module must import the BaseSettings class from the \nfound in the /configuration folder, and it contains the following application server details in \nTo fetch these details, the application needs another BaseSettings class implementation that declares \nThe following class shows how production_server, \nof a microservice, such as having independence, configuration files, logging systems, code bases, port \ncreated a pseudo-API Gateway pattern that serves as a façade to the independent sub-applications.\nIn the next chapter, we will focus on integrating our microservice applications with a relational database \nThe focus is to establish database connectivity and utilize our data models to implement \nclients’ data using objects and a relational database.\nbe mapped to their corresponding entity or model classes to avoid tightly coupled connections to \nAnd these model classes are the ones that are used to connect to the database.\npopular ORMs to provide applications with backend database access, which it does by using popular \nrelational database management systems, and apply optimization to CRUD transactions using the \n•\t Creating synchronous CRUD transactions using SQLAlchemy\n•\t Implementing asynchronous CRUD transactions using SQLAlchemy\nThe application prototype that’s been created for this chapter is called fitness club management system; \nclass management, and attendance modules that utilize a PostgreSQL database as their data storage.\nMoreover, this uncommon application has four pieces of database connectivity that have been configured \nis just a simple FastAPI application that’s been created to help you focus on the data modeling features, \nLet us consider some application-related concerns before we start discussing database connectivity \nwith six tables, namely signup, login, profile_members, profile_trainers, \nattendance_member, and gym_class.\nCreating CRUD transactions using SQLAlchemy\nbased application and database platform.\nThis ORM is a boilerplated interface that aims to create a database-agnostic data layer that can connect \nCRUD transactions for our application.\nTo connect to any database, SQLAlchemy requires an engine that manages the connection pooling \nThe create_engine() function from the sqlalchemy module is the \nfrom sqlalchemy import create_engine\nCreating CRUD transactions using SQLAlchemy\nengine is a global object and must be created only once in the entire application.\nconnection happens right after the first SQL transaction of the application because it follows the lazy \nMoreover, engine in the previous script is essential for creating the ORM session that will be used \nby SQLAlchemy to execute CRUD transactions.\nAll CRUD transactions in SQLAlchemy are driven by sessions.\ncoordinates with the SQLAlchemy core to pursue the changes to the database if all transactions have \nBut before we create a session, the data layer needs a session factory that is bound to the derived engine.\nThe ORM has a sessionmaker()directive from the sqlalchemy.orm module, which requires \nfrom sqlalchemy.orm import sessionmaker\nApart from engine binding, we also need to set the session’s autocommit property to False to \nchanges to the database, so we need to set its autoflush feature to False as well.\nApplications can create more than one session through the SessionFactory() call, but having \nNext, we need to set up the Base class, which is crucial in mapping model classes to database tables.\nAlthough SQLAlchemy can create tables at runtime, we opted to utilize an existing schema definition \nNow, this Base class must be subclassed by the model classes so that the mapping \nInvoking the declarative_base() function is the easiest way of creating the Base class rather than \ncreating registry() to call generate_base(), which can also provide us with the Base class.\nNote that all these configurations are part of the /db_config/sqlalchemy_connect.py \nBut before we implement the CRUD transactions, we need to create the \nmodel layer using the Base class.\nThe model classes of SQLAlchemy have all been placed in the /models/data/sqlalchemy_\nIf BaseModel is important to API request models, \nthe Base class is essential in building the data layer.\nSQLAlchemy entities or models.\ncan create model class definitions in SQLAlchemy ORM:\nfrom sqlalchemy import Time, Boolean, Column, Integer, \nfrom sqlalchemy.orm import relationship\nfrom db_config.sqlalchemy_connect import Base\nclass Signup(Base):\nid = Column(Integer, primary_key=True, index=True)\nCreating CRUD transactions using SQLAlchemy\nThe Signup class is a sample of a SQLAlchemy model because it inherits the Base class’s properties.\nIt is a mapped class because all its attributes are reflections of the column metadata of its physical table \nThe model has a primary_key property set to True because SQLAlchemy \nEach model class \nMost importantly, we need to ensure that the data type of the class attribute matches the column type \nthe Column class, as shown in the username and password columns of Signup.\nSQLAlchemy strongly supports different types of parent-child or associative table relationships.\nclasses involved in the relationship require the relationship() directive from the sqlalchemy.\norm module to be utilized to establish one-to-many or one-to-one relationships among model classes.\nThis directive creates a reference from the parent to the child class using some foreign key indicated \nA child model class uses the ForeignKey construct in its foreign key column object to link the \nmodel class to its parent’s reference key column object.\nThe following model class \nid = Column(Integer, primary_key=True, index=True)\nThis Login model is linked to two children, Profile_Trainers and Profile_Members, \nBoth child models have the ForeignKey directive in their id column \nobjects, as shown in the following model definitions:\nclass Profile_Trainers(Base):\nclass Profile_Members(Base): \ntrainer_id = Column(Integer, \nForeignKey('profile_trainers.id'), unique=False, \nCreating CRUD transactions using SQLAlchemy\nto specify some of its parameters, such as the name of the child model class and the backreference \nthe related model classes.\nIf it is a one-to-one type, the parent class should set the useList parameter to False \nThe previous Login class definition shows that Profile_Trainers and Profile_Members \nother hand, the model relationship between Profile_Members and Attendance_Member is a \nclass Attendance_Member(Base):\nid = Column(Integer, primary_key=True, index=True)\nmember_id = Column(Integer, \nForeignKey('profile_members.id'), unique=False, \ndate_log = Column(Date, unique=False, index=False)\nrelated model classes will be using during the join query transactions.\nSQLAlchemy uses a lazy loading technique by default in retrieving join queries.\nIn the SQLAlchemy ORM, creating the repository layer requires the model classes and a Session \nthe communication to the database and manages all the model objects before the commit() or \nthe model objects for insert, update, and delete transactions when the database issues a commit() \nWe import the Session class from the sqlalchemy.orm module.\nclass is the blueprint that will show us how to insert, update, delete, and retrieve record(s) to/from \nfrom sqlalchemy.orm import Session\nfrom models.data.sqlalchemy_models import Signup\ndef __init__(self, sess:Session):\nCreating CRUD transactions using SQLAlchemy\nSession has an add() method, which we can invoke to add all record objects \nto the table, and a commit() transaction to finally flush all the new records into the database.\ndef update_signup(self, id:int, \nself.sess.query(Signup).\nfilter(Signup.id == id).update(details)     \nAnother possible solution is to query the record through self.sess.\nquery(Signup).filter(Signup.id == id).first(), replace the attribute values of the \ndef delete_signup(self, id:int) -> bool: \nsignup = self.sess.query(Signup).\nNow, the following script shows how to implement the query transactions:\ndef get_all_signup(self):\nreturn self.sess.query(Signup).all() \ndef get_all_signup_where(self, username:str):\ndef get_signup(self, id:int): \nreturn self.sess.query(Signup).\nThe Session object has a query() method, which requires model class(es) or model \nOn the other hand, the Session object has an order_by() method that takes column names as \nCreating CRUD transactions using SQLAlchemy\nThe last portion of the query() builder returns the result of the transactions, whether it is a list \nFor SQLAlchemy’s query transactions, all these functions can close the Session object.\nThe repository classes for SQLAlchemy are in the ch05a folder’s /repository/sqlalchemy/\nFor all the ORMs supported by FastAPI, only SQLAlchemy implements join queries pragmatically \nof the methods we need to create joins previously except for join().\nin SQLAlchemy with model classes in one-to-one relationships:\ndef __init__(self, sess:Session):\ndef join_login_members(self):\nfilter(Login.id == Profile_Members.id).all()\njoin_login_members() shows the conventional way of creating JOIN queries.\nrequires passing the parent and child classes as query parameters and overriding the ON condition \nThe parent model class must come first in the column projection \nbefore the child class in the query() builder to extract the preferred result.\nclass from the child.\nbetween the Profile_Members and Attendance_Member model classes:\ndef __init__(self, sess:Session):\ndef join_member_attendance(self):\nquery(Profile_Members, Attendance_Member).\ndef outer_join_member(self):\nquery(Profile_Members, Attendance_Member).\njoin_member_attendance() shows the use of the join() method in building the INNER \nJOIN queries between Profile_Members and Attendance_Member.\nThe outer_join_member() repository method implements an OUTER JOIN query from the \nNow, let us apply these repository transactions to the administration-related API services of our \nthe repository, such as SessionFactory, the repository class, and the Signup model class.\nThe following script shows a portion of the administrator’s API services highlighting the insertion \nfrom sqlalchemy.orm import Session\nfrom db_config.sqlalchemy_connect import SessionFactory\nfrom repository.sqlalchemy.signup import SignupRepository,\nCreating CRUD transactions using SQLAlchemy\nFirst, we need to create the Session instance through SessionFactory(), which we derived \nAPI service methods to tell the Session instance to proceed with instantiating SignupRepository: \n@router.get(\"/signup/list\", response_model=List[SignupReq])\ndef list_signup(sess:Session = Depends(sess_db)):\n@router.get(\"/signup/list/{id}\", response_model=SignupReq)\ndef get_signup(id:int, sess:Session = Depends(create_db)):\nBoth the get_signup() and list_signup() services have a request_model of the \nIf request_model is used to capture the query result of the SQLAlchemy \nquery transactions, the BaseModel class or request model must include a nested Config class \nBaseModel for the SQLAlchemy model types used by the repository, before all the record objects are \nSignupReq, which is used by the query services of our application, is defined as follows:\nand synchronize the model classes with the schema definitions.\nthe model classes is handy and predictable.\nenough to guide developers regarding the different API classes and methods.\nCreating CRUD transactions using SQLAlchemy\nUsually, SQLAlchemy works with the table schemas that have already been generated by the database \nIn this project, the ORM setup started with designing the domain model classes before \nBut SQLAlchemy can auto-create table schemas at runtime for \nThe sqlalchemy module has a Table() directive that can create a table object with the essential \nsample script that shows how the ORM creates the signup table at the application level:\nfrom sqlalchemy import Table, Column, Integer, String, \nfrom db_config.sqlalchemy_connect import engine\nNow, let us explore how SQLAlchemy can be used to create asynchronous CRUD transactions for \nfor asynchronous connections, sessions, transactions, and database drivers.\nthe non-direct access that the CRUD commands have with the asynchronous Session object.\nBefore we begin setting up the database configuration, we need to install the following asyncio-\ninstead of the database API specification for synchronous database transactions.\nAfter installing the necessary drivers, we can derive the database engine through the application’s \ncreate_async_engine() method, which creates an asynchronous version of SQLAlchemy’s \nenable a variety of asynchronous features during CRUD transactions when set to True.\nfrom sqlalchemy.ext.asyncio import create_async_engine\nImplementing async CRUD transactions using SQLAlchemy\nparameter is set to False to make that model instances and its attribute values accessible for the \nall entity classes and their column objects are still accessible by other processes, even after transaction \nfrom sqlalchemy.orm import sessionmaker\nThe full configuration for the asynchronous SQLAlchemy database connection can be found in the \n/db_config/sqlalchemy_async_connect.py module script file.\nCreating the Base class and the model layer\nCreating the Base class using declarative_base() and creating the model classes using Base \nthe data layer for the asynchronous repository transactions.\nThe ORM supports the use of the execute() method of the AsyncConnection API to run \ncomes to query transactions, the new select() directive from the sqlalchemy.future module \nrequires that all repository transactions are async too to apply the Async/Await design pattern.\nfollowing AttendanceRepository uses the asynchronous type of SQLAlchemy:\nfrom sqlalchemy import update, delete, insert\nfrom sqlalchemy.orm import Session\nfrom models.data.sqlalchemy_async_models import \ndef __init__(self, sess:Session):\nasync def insert_attendance(self, attendance: \nImplementing async CRUD transactions using SQLAlchemy\nThe given asynchronous insert_attendance() method in the preceding script shows the use \nof the insert() directive in creating an attendance log for a gym member.\nthe model class name to insert() to let the session know what table to access for the transaction.\nthe model attribute values and the updated values from the database using the fetch method.\nasync def update_attendance(self, id:int, \nAttendance_Member.id == id).values(**details)\nasync def delete_attendance(self, id:int) -> bool: \nAttendance_Member.id == id)\nWhen it comes to queries, the repository class contains get_all_attendance(), which retrieves \nThen, it needs the execute() method to run the query asynchronously and extract the Query \nThe resulting Query object has a scalars() method, which we can call to retrieve the list \ncheck_attendance(), on the other hand, uses the scalar() method of the Query object to \nasync def get_all_attendance(self):\nasync def get_attendance(self, id:int): \nasync def check_attendance(self, id:int): \nwhere(Attendance_Member.id == id))\nThe repository classes for the asynchronous SQLAlchemy can be found in the /repository/\nsqlalchemy/attendance.py module script file.\nto pursue some attendance monitoring services for our fitness gym application.\nImplementing async CRUD transactions using SQLAlchemy\nThere two big differences between AsyncIO-driven SQLAlchemy and the database API-compliant \nfrom db_config.sqlalchemy_async_connect import \nfrom repository.sqlalchemy.attendance import \nfrom models.requests.attendance import AttendanceMemberReq\nfrom models.data.sqlalchemy_async_models import \nasync def update_attendance(id:int, \nreturn await repo.update_attendance(id, \nasync def delete_attendance(id:int): \nThe preceding script shows no direct parameter passing between the repository class and the \nOther ORM platforms that have been created for asynchronous transactions are easier to use.\nbuild contextual database connections and transactions.\nNo other APIs are needed to open a connection to the database except for the Gino directive.\nneed to instantiate the class to start building the domain layer.\nThe Gino class can be imported from \nGINO database connectivity script can be found in the /db_config/gino_connect.py script \nThe model class definition in GINO has similarities with SQLAlchemy when it comes to structuring, \nthe superclass type because GINO uses the Model class from the database reference instance’s db.\nThe following script shows how the Signup domain model is mapped to the signup table:\nclass Signup(db.Model):\nid = db.Column(db.Integer, primary_key=True, \nLike in SQLAlchemy, the __tablename__ property is mandatory for all model classes to indicate \ndirective has its first parameter register the name of the actual column and maps it to the model \nThe username and password columns are example cases of mapping the class attributes \nSetting the ForeignKey property in the Column object of the child model class is \nfetch the child records of the parent model class.\njoin query is the relationship configuration between the Profile_Trainers and Gym_Class \nmodel classes, as shown in the following script:\nclass Profile_Trainers(db.Model):\nclass Gym_Class(db.Model): \nid = db.Column(db.Integer, primary_key=True,\nmember_id = db.Column(db.Integer, \ndb.ForeignKey('profile_members.id'), unique=False, \ntrainer_id = db.Column(db.Integer, \ndb.ForeignKey('profile_trainers.id'), unique=False,\nFor the LEFT OUTER JOIN query to work, the parent model class must have \nFor a one-to-one relationship, the parent only needs to instantiate the child model:\nclass Login(db.Model): \nid = db.Column(db.Integer, primary_key=True, \nclass Profile_Members(db.Model): \ntrainer_id = db.Column(db.Integer, \ndb.ForeignKey('profile_trainers.id'), unique=False, \nProfile_Members and Gym_Class, and between Login and Profile_Members/Profile_\nYou can find the domain models of GINO in the /models/data/gino_models.py script.\ntrainer() method shows the conventional way of implementing insert transactions.\nits model class to call create(), an inherited method from the db reference object.\ncalled create() that inserts the record object without requiring any parameters:\nfrom models.data.gino_models import Profile_Members, \nProfile_Trainers, Gym_Class\nasync def insert_trainer(self, \n•\t First, it requires the get() class method of the model class to retrieve the record object with \nasync def update_trainer(self, id:int, \nIts delete_trainer() also follows the same approach as the GINO update transaction.\ntransaction is a two-step process, and the last step requires calling the delete() instance method \nasync def delete_trainer(self, id:int) -> bool: \n•\t The former retrieves a specific record object using its primary key through the get() class \nmethod of the model class \n•\t The latter uses the gino extension of query to utilize the all() method, which retrieves \nasync def get_all_member(self):\nreturn await Profile_Trainers.query.gino.all()\nasync def get_member(self, id:int): \nreturn await Profile_Trainers.get(id)\nBut what translates database rows into model objects in a query’s execution is the built-in loader of \nIn the GINO ORM, all queries utilize ModelLoader to load each database record into a model object:\nasync def join_classes_trainer(self):\nquery = Gym_Class.join(Profile_Trainers).select()\nresult = await query.gino.load(Gym_Class.\ndistinct(Gym_Class.id).\nasync def join_member_classes(self):\nquery = Gym_Class.join(Profile_Members).select()\nresult = await query.gino.load(Profile_Members.\nIf the normal query requires ModelLoader, what is needed for the JOIN query transactions?\nGINO has no automated support for table relationships, and creating JOIN queries is impossible \nThe join_classes_trainer() method implements a one-to-\nmany query for Profile_Trainers and Gym_Class.\nThe distinct(Gym_Class.id).\nload(parent=Profile_Trainers) clause in the query creates a ModelLoader for GymClass, \nwhich will merge and load the Profile_Trainers parent record into its child Gym_Class.\njoin_member_classes() creates one-to-many joins, while distinct(Profile_Members.\nid).load(add_child=Gym_Class) creates a ModelLoader to build the set of Gym_Class ",
      "keywords": [
        "False return True",
        "CRUD transactions",
        "return False",
        "database",
        "relational database",
        "profile",
        "Creating CRUD transactions",
        "Column",
        "model class",
        "session",
        "attendance",
        "model",
        "api",
        "signup",
        "Application"
      ],
      "concepts": [
        "importance",
        "important",
        "importing",
        "classes",
        "application",
        "applications",
        "database",
        "data",
        "creating",
        "create"
      ],
      "similar_chapters": [
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 10,
          "title": "",
          "score": 0.528,
          "base_score": 0.528,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 8,
          "title": "",
          "score": 0.525,
          "base_score": 0.525,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 11,
          "title": "",
          "score": 0.481,
          "base_score": 0.481,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 1,
          "title": "",
          "score": 0.475,
          "base_score": 0.475,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 9,
          "title": "",
          "score": 0.469,
          "base_score": 0.469,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "sqlalchemy",
          "self",
          "model",
          "column",
          "database"
        ],
        "semantic": [],
        "merged": [
          "sqlalchemy",
          "self",
          "model",
          "column",
          "database"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5097924179674594,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:22.900729+00:00"
      }
    },
    {
      "chapter_number": 6,
      "title": "Using a Non-Relational Database",
      "start_page": 161,
      "end_page": 212,
      "summary": "On the other hand, the many-to-one relationship of Gym_Class and Profile_Members uses the \nload() function of Profile_Member, which is a different approach to matching the Gym_Class \nsetup because the Gym_Class records here are on the left-hand side while the profiles are on the right:\nasync def join_classes_member(self):\nProfile_Members.load(add_child=Gym_Class)\nAll the repository classes for GINO can be found in the /repository/gino/trainers.py script.\nFor our repositories to run in the APIRouter module, we need to open the database connection by \nbinding the db reference object to the actual database through DB_URL.\nThe following script shows how to set up this database binding:\nfrom db_config.gino_connect import db\nasync def update_trainer(id:int, req: ProfileTrainersReq): \nasync def db_create_tbl():\nPony ORM relies on Python syntax for building the model classes and repository transactions.\nORM only uses Python data types such as int, str, and float, as well as class types to implement \nSince Pony is an ORM designed to build synchronous transactions, we will need the psycopg2 \nCreating the database’s connectivity\nthe Database directive from the pony.orm module to be instantiated to connect to the database \nfrom pony.orm import  Database\n/db_config/pony_connect.py script file.\nNow, let us create Pony's model classes.\nDefining the model classes\nThe created database object, db, is the only component needed to define a Pony entity, a term that refers \nto a model class.\nIt has an Entity attribute, which is used to subclass each model class to provide \nThe following script shows how the Signup class becomes \nfrom pony.orm import  Database, PrimaryKey, Required, \nfrom db_config.pony_connect import db\nclass Signup(db.Entity):\nIf the class has no primary key, Pony ORM will implicitly \nexample, int, str, float, date, or time) or any class type.\nrelationship between model classes:\nclass Login(db.Entity): \ntrainers = Optional(\"Profile_Trainers\", reverse=\"id\")\nmembers = Optional(\"Profile_Members\", reverse=\"id\")\nThe given Login class has two additional attributes, trainers and members, which serve as \nreference keys to the Profile_Trainers and Profile_Members models, respectively.\nturn, these child entities have their respective class attributes pointing back at the Login model, \nThe following code shows examples of Pony’s child model classes:\nclass Profile_Trainers(db.Entity):\ngclass = Set(\"Gym_Class\", reverse=\"trainer_id\")\nclass Profile_Members(db.Entity): \ntrainer_id = Required(\"Profile_Trainers\", \nOptional attribute to point to the id key of Profile_Members.\nMembers, which explains why the trainer_id attribute of the former uses the Required \nscenario between the Profile_Members and Gym_Class models, where the gclass attribute \nof Profile_Members is declared as a Set collection that contains all the enrolled gym classes of \nThe reference key can be a primary key or just a typical class attribute in this relationship.\nThe following snippet shows the blueprint of the Gym_Class model:\nclass Gym_Class(db.Entity): \n_table_ = \"gym_class\"\nmember_id = Required(\"Profile_Members\", \ntrainer_id = Required(\"Profile_Trainers\", \nPony model class to be defined.\nAll the Pony model classes can be found in the /models/data/\nThe following code shows a repository class that implements all the \ntransactions needed to manage a list of gym members:\nfrom pony.orm import db_session, left_join\nfrom models.data.pony_models import Profile_Members, \nGym_Class, Profile_Trainers\nIn Pony, inserting a record means instantiating the model class with the injected record values.\ndef update_member(self, id:int, \nprofile = Profile_Members[id]\nprofile.trainer_id = details[\"trainer_id\"]\nUpdating a record in Pony, which is implemented in the update_member() script, means retrieving \nOn the other hand, delete_member() of the repository class shows the same approach with \nUPDATE, except that a delete() class method is invoked right after retrieving the object record.\ndef delete_member(self, id:int) -> bool: \nProfile_Members[id].delete()\nThe following code shows Pony’s implementation for query transactions:\ndef get_member(self, id:int): \nget_member() retrieves a single record using the get() class method, which requires a lambda \nPony model classes have the get() and select() methods, which both return Query objects that \nclass is required to retrieve the records from the Query object.\nand validate the Query objects into JSON-able components such as List or entity objects.\nfollowing code shows the request model that’s used to extract the records from select() through \n@validator('trainer_id', pre=True, \nclass Config:\nThe following code shows another repository class that showcases the use of left_join():\ndef join_member_class(self): \nAll the repository classes can be found in the /repository/pony/members.py script file.\nThe repository classes are directly \nIf the tables are non-existent yet, Pony can generate those tables through its entity classes.\ntransaction is enabled when the create_tables parameter of the generate_mapping() \nmethod of db is set to True.\nCreating the database connection\nwhich can be created using the ContextVar class, bridges Peewee to the FastAPI platform.\nThe following code shows how db_state and a custom \nTo apply the new db_state and _ConnectionState classes, cited in the preceding code as \nclass.\nPeewee has several variations of the Database class, depending on the type of database the \nthe correct class to initialize with all the necessary database details.\nThe following snippet shows how to connect to our fitness gym database’s fcms using the \nin the /db_config/peewee_connect.py script file.\nPeewee prefers auto-generating tables based on its model classes, unlike other ORMs. Peewee recommends \nThe following script shows how Peewee model classes are defined:\nfrom db_config.peewee_connect import db\nclass Signup(Model):\ndatabase = db\nWe can’t see any primary keys in the model classes presented because the Peewee engine will create them \nWe must let Peewee create the physical tables from the model classes to avoid this mishap.\nAll model classes inherit properties from the Model directive of the ORM.\nattributes of the model classes.\nthe references to database and db_table, which is mapped to the model class.\nforeign key attributes of the child classes to the non-existent primary keys of the parent classes is \nFor instance, the following Profile_Trainers model implies a \nmany-to-one relationship with the Login class, which is only defined by the ForeignKeyField \ndirective with the trainer backreference attribute and not by the login_id foreign key:\nclass Profile_Trainers(Model):\ndatabase = db\ndb_table = 'profile_trainers'\nAfter defining all the models, including their relationships, we need to call the following methods \n•\t create_tables() to pursue the schema generation based on its list of model classes\nThe following script shows a snapshot of the class definitions, including the call to the two db methods:\nclass Login(Model): \ndatabase = db\nclass Gym_Class(Model): \ndatabase = db\ndb_table = 'gym_class'\ndb.create_tables([Signup, Login, Profile_Members, \nProfile_Trainers, Attendance_Member, Gym_Class],\nAs we can see, we need to set the safe parameter of create_tables() to True so that Peewee \nthe model classes for the Peewee ORM can be found in the /models/data/peewee_models.\nCreating the asynchronous connection and building the model layer for the application in the Peewee \nare entirely derived from its model classes.\nthe following snippet, shows how the create() static method of Login takes the login details for \nfrom models.data.peewee_models import Login, \nProfile_Trainers, Gym_Class, Profile_Members\ndef insert_login(self, id:int, user:str, passwd:str, \nLogin.create(id=id, username=user, \npursue multiple insertions through its insert_many() class method.\nSimilarly, the update() class method requires the execute() method after filtering the record \ndef update_login(self, id:int, \nget() class method – for example, Login.get(Login.id == id) – and eventually delete \ndelete_login() transaction shows how to utilize the delete_by_id() class method:\ndef delete_login(self, id:int) -> bool: \nPeewee uses its get() class method to retrieve a single record \nusing the primary key; the same method was applied to its UPDATE transaction in the previous code \nSimilarly, Peewee uses a class method to extract multiple records, but this time, it uses the \ndef get_login(self, id:int): \nOn the other hand, the following repository classes show how to create JOIN queries using its \ndef join_login_trainers(self): \nselect(Profile_Members,Gym_Class).join(Gym_Class, \nof the Profile_Trainers object’s select() directive is the parent model type, followed by its \nchild model class in a one-to-one relationship.\nwith the model class type, which indicates the type of records that belong to the right-hand side of the \na LEFT OUTER JOIN of Profile_Members and Gym_Class using the LEFT_OUTER option \nJoins in Peewee also need the list() collection to serialize the retrieved records.\nclasses for Peewee can be found in the /repository/peewee/login.py script.\nSince Peewee’s database connection is set at the model layer, no additional requirements are required \nrepository classes without calling methods or directives from the db instance.\nTo pursue CQRS, we need to create the two interfaces that define the query and the command \nCreating the command and query classes\nNext, we need to implement the command and query classes.\nthe other hand, the query instructs the read transaction to retrieve record(s) from the database and \nThe details property will store all the column values of the trainer’s profile record that need to \nThe following script implements a sample query class:\nclass ProfileTrainerListQuery: \nself._records:List[Profile_Trainers] = list()\nall the retrieved records after the query transaction has been executed.\ncommand handler accesses and executes the repository to execute the write transactions, while the query \nwhich manages the INSERT transaction for the trainer’s profile:\nself.query.records = data\nfrom cqrs.trainers.command.create_handlers import \ntricky composition for the asynchronous database connection and CRUD transactions.\nIf FastAPI uses ORM for relational databases, it uses Object Document Mapping (ODM) to manage \nDifferent NoSQL databases vary in the storage model type that’s used to store data.\ndatabases utilize schema-free document structures easily mapped to objects.\nand the different ODM we can apply to pursue data management with a document-based database.\n•\t Creating asynchronous CRUD transactions using Motor\nautomatically create a database directory called /data/db in the C:/ drive (Windows).\nOnce the server and utility have been installed, we need to design the data collections for our database \nvisualizing the associations and structures of the model classes involved in a system.\nis one of the solutions that’s used to design the document structure of the MongoDB database since \nDesigning a NoSQL database always requires an equal balance between the data retrieval methods \ndiagram shows the class diagram for our application’s MongoDB database, obrs:\nFigure 6.2 – The class diagram for the obrs database\nestablishing a connection from our FastAPI microservice application to its MongoDB database.\nbuilds the database connectivity, models, and CRUD transactions.\nSetting up the database connectivity\nPyMongo uses its MongoClient module class to connect to any MongoDB database.\nOur application uses the latter to connect to its database.\ndatabase, where the collated records, known as documents, are stored.\ndef create_db_collections():\nA generator function such as create_db_collections() is preferred because the yield \nA BSON document offers more data types than the JSON structure.\nCommon Python data types such as str, int, and float are supported by the BSON specification, \nObjectId is an essential data type in a MongoDB document because it serves as a unique identifier for \nConventionally, the declared field of the document, _id, always refers to the \nobject for the document or create an instance of the object type during persistence.\nThe previous purchase BSON document shows a sample of the principal buyer document with a \nembedded documents have no separate collection because they have no respective _id field to make \nUsing the BaseModel classes for transactions\nSince PyMongo has no predefined model classes, the Pydantic models of FastAPI can be used to \nBaseModel classes to contain document details and pursue insert, update, and delete transactions \nsince the Pydantic models are compatible with MongoDB documents.\nfrom typing import List, Optional, Dict\ndef date_purchased_datetime(cls, value):\nclass Config:\nclass Config:\nBuyer_id: int\ndef date_purchased_datetime(cls, value):\nclass Config:\nFor these request models to recognize the BSON data types, we should make some modifications to \noption, there is also a need to add a nested Config class to the BaseModel blueprint with the \nautomatically convert a MongoDB datetime into a Python date type, we need to create a custom \nalso use custom validators and parsers in the FastAPI services to convert all incoming Python date \n@validator creates a class method that accepts class name as the first parameter, not the \nthe field name or class attribute that needs to be converted into another data type, such as date_\npre attribute of @validator tells FastAPI to process the class methods before any built-in validation \nWrapping the queried BSON documents using the BaseModel model classes is still the best approach \ndate fields, we cannot always utilize the request model classes that are used for the CRUD transaction \nformat (type=value_error.date)\" error because all the models have the Python datetime.\nThe following data classes are defined for \nclass Config:\ndef date_purchased_datetime(cls, value):\nclass Buyer:\nbuyer_id: int\ndef date_purchased_datetime(cls, value):\nPurchaseStatus, and Buyer custom classes shown in the preceding code are typical classes that \ncan be converted into request model classes.\nFastAPI supports both BaseModel and data classes when \ncreating model classes.\nreplacement for using BaseModel when creating model classes.\nIf a data class requires some additional details, a custom class is needed to \nclass in the preceding code, which sets arbitrary_types_allowed to True, has been added \nto the three model classes.\nIn the data classes shown previously, all the validators focus on BSON datetime \nto Python datetime.date conversion during the document retrieval process.\nWhen dealing with default values, BaseModel classes can use typical type hints such as Optional \ntype hints are applied to set default values of complex field types such as list, dict, and ObjectId.\nIt requires the field() specifier from Python’s dataclasses module to set the default values of \ndata classes but with some additional features, such as the config parameter and the inclusion of \nfield(), especially for embedded documents and for models with the date or datetime types, \nalso create embedded structures in the BaseModel classes, for example, by defining attributes with \nthe class types.\nAll these model classes have been placed in the /models/data/pymongo.py script.\napply these data models to create the repository layer.\nPyMongo needs collection to build the repository layer of the application.\nobject, the insert, delete, and update transactions will also need the BaseModel classes to contain all \nthe details from the client and convert them into BSON documents after the transaction.\nour query transactions will require the data classes to convert all BSON documents into JSON-\nThe repository class in the following code block implements the CRUD transactions that aim to \ndef __init__(self, buyers): \ndef insert_buyer(self, users,\nself.buyers.insert_one(details)\nfor processing CRUD transactions, such as insert_one(), which adds a single main document \nfield of the BSON document during the insertion process.\nNext, update_buyer() shows how to update a specific document in the buyer collection:\ndef update_buyer(self, id:int, \nself.buyers.update_one({\"buyer_id\": id},\ndef delete_buyer(self, id:int) -> bool: \nself.buyers.delete_one({\"buyer_id\": id})\nThe collection has an update_one() method that requires two parameters: a unique and valid \ndelete_buyer() is the transaction that deletes a buyer document using a unique and valid field/\nvalue pair such as {\"buyer_id\": id}.\nscript shows how to implement query transactions in PyMongo\nfrom models.data.pymongo import Buyer\ndef get_all_buyer(self):\ndef get_buyer(self, id:int): \nbuyer = self.buyers.find_one({\"buyer_id\": id})\nWhen querying documents, PyMongo has a find() method, which retrieves all the documents in \nshows how to retrieve a buyer document through the unique buyer_id field.\nretrieves all the buyer documents without constraints.\nFor instance, retrieving buyer documents with user_id greater than 5 requires the buyers.\nRetrieving buyer documents with buyer_id less than 50 and buyer_id greater than 10 will require the \nfind({'and': [{'buyer_id': {'$lt': 50}}, {'user_id':{'$gt':10}}]}) query.\nBoth methods return BSON documents that are not JSON-able components of the FastAPI framework.\nTo convert the documents into JSON, the bson.json_util extension has a dumps() method that \nand get_buyer()convert every single document retrieved into JSON so that each can be mapped \nto the Buyer data class.\nPython datetime.date while utilizing the validators of the Buyer data class.\nAfter generating the list of Buyer data classes, the asdict() method of \nPython’s dataclasses module is needed to transform the list of Buyer data classes into a list of \nuse the DBRef class of the bison.dbref module to link the parent and child documents.\nonly prerequisite is for both documents to have an _id value of the ObjectId type and have their \ninsert one purchase record into the list through the following query: \nthe other hand, to find a specific purchase_history document from the buyer collection using \nThe second way is to add the whole BSON document structure to the list field of buyer through \nThis solution applies to embedded documents that do not have _id and \nfollowing code shows how this approach is applied to create a many-to-one association between the \npurchase_history and buyer documents:\ndef add_purchase_history(self, id:int, \nbuyer = self.buyers.find_one({\"buyer_id\": id})\nself.buyers.update_one({\"buyer_id\": id},\ndef add_customer_status(self, id:int, \nbuyer = self.buyers.find_one({\"buyer_id\": id})\nself.buyers.update_one({\"buyer_id\": id},\nbuilding a one-to-one association between the buyer and purchase_status documents.\nThe complete repository class can be found in the /repository/pymongo/buyer.py script \nBefore executing the BuyerRepository transactions, the create_db_collections() \nprocessing Python types that are not BSON-supported, such as datettime.date, custom validations \noutgoing BSON datetime parameters into Python date during query retrieval.\nthe JSON encoder validation in this API layer converts incoming Python date values into \nFor instance, the add_buyer(), update_buyer(), and add_purchase_history() transaction \nmethods in the following code require a custom serializer such as json_serialize_date() to \nfrom models.request.buyer import BuyerReq, \nfrom repository.pymongo.buyer import BuyerRepository\nfrom db_config.pymongo_config import create_db_collections\nresult = repo.insert_buyer(db[\"users\"], \ndef update_buyer(id:int, req:BuyerReq, \nresult = repo.update_buyer(id, loads(buyer_json))  \ndef add_purchase_history(id:int, req:PurchaseHistoryReq, \nNow, another custom converter is applied in the data retrievals of the list_all_buyer() and \ndef list_all_buyer(db=Depends(create_db_collections)): \n@router.get(\"/buyer/get/{id}\")\ndef get_buyer(id:int, db=Depends(create_db_collections)):\nThe data models involved in our query transactions are data classes, so the results of the two preceding \nIt also converts BSON datetime values into Python date values following \nCreating async CRUD transactions using Motor\nPyMongo to produce non-blocking and coroutine-based classes and methods needed to create \nexcept for the database connectivity and repository implementation.\nSetting up the database connectivity\ndatabase through its AsyncIOMotorClient class.\ndef create_async_db():\nCreating async CRUD transactions using Motor\ndef create_db_collections():\nneeds the following Motor methods to start the database transactions: \n•\t create_async_db(): A method for establishing the database connection and loading \n•\t close_async_db(): A method for closing the connection\nOn the other hand, the create_db_collections() method creates some \nreferences to the login and buyer collections, which will be needed by the repository transactions later.\nIn general, creating the database connection and getting the reference to the document collections do \nPyMongo and Motor share the same approaches in creating both the request and data models.\nmodels, data classes, validators, and serializers used by PyMongo also apply to Motor connectivity.\nmethods for inserting, updating, and deleting documents, including the necessary method parameters, \ndef __init__(self, buyers): \nasync def insert_buyer(self, users, \nawait self.buyers.insert_one(details)\nasync def add_purchase_history(self, id:int, \nawait self.buyers.update_one({\"buyer_id\": id},\nasync def get_all_buyer(self):\nasync def get_buyer(self, id:int):\nCreating async CRUD transactions using Motor\nThe get_all_buyer() transaction in the \nThis repository class can be found in the /repository/\nFor the repository to work with APIRouter, we need to create two event handlers to manage \nthe database connection and document collection retrieval.\nfollowing is a portion of the APIRouter script that shows how to prepare the database connection \nfrom db_config.motor_config import create_async_db,\ncreate_db_collections, close_async_db\ncreate_async_db)\nAfter setting these events handlers, the API services can now invoke the repository transactions \nwill be available to the API services upon injecting create_db_collections() into the API \nresult = await repo.insert_buyer(db[\"users\"], \nconnection to MongoDB to create CRUD transactions, such as using an ODM.\nIt offers API classes that can help generate model classes using \nmodule has a connect() helper method that connects to the MongoDB database when it’s given \nreference to the database connection and close this created connection after the transactions expire.\nThe following script showcases the MongoEngine database connectivity:\ndef create_db():\nThe connect() method has a mandatory first parameter, named db, which indicates the name \nLet us now create data models for \nMongoEngine provides a convenient and declarative way of mapping BSON documents to the model \nclasses through its Document API class.\nA model class must subclass Document to inherit the \ndefinition that’s been created using the Document API class:\nclass Login(Document): \nUnlike PyMongo and the Motor drivers, MongoEngine can define class attributes using its Field \nclasses and their properties.\nbool, and datetime.date class attributes, respectively.\nThe id field of a model class should be declared as SequenceField so \nOther than the field types, field classes can also provide field arguments to attributes such as choices, \nbe applied when specifying another document field name instead of the class attribute name.\nLogin class also has username and password fields defined to hold string values, an id primary \nkey defined as SequenceField, and an embedded document field to establish document association.\nCreating document association\nThe profile field of Login creates a one-to-one association between the Login document and \nstatus = BooleanField(db_field=\"status\", required=True)\nlogin_id = IntField(db_field=\"login_id\", required=True)",
      "keywords": [
        "False return True",
        "Database",
        "CRUD transactions",
        "buyer",
        "Profile",
        "Relational Database",
        "Pony ORM",
        "return True",
        "model classes",
        "model",
        "date",
        "CRUD",
        "transactions",
        "Pony",
        "Document"
      ],
      "concepts": [
        "classes",
        "important",
        "database",
        "document",
        "documents",
        "transactions",
        "transaction",
        "buyers",
        "require",
        "required"
      ],
      "similar_chapters": [
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 7,
          "title": "",
          "score": 0.376,
          "base_score": 0.376,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 5,
          "title": "",
          "score": 0.318,
          "base_score": 0.318,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 4,
          "title": "",
          "score": 0.312,
          "base_score": 0.312,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 8,
          "title": "",
          "score": 0.31,
          "base_score": 0.31,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "buyer",
          "classes",
          "database",
          "model",
          "pony"
        ],
        "semantic": [],
        "merged": [
          "buyer",
          "classes",
          "database",
          "model",
          "pony"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3202810341466277,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:22.900741+00:00"
      }
    },
    {
      "chapter_number": 7,
      "title": "Securing the REST APIs",
      "start_page": 213,
      "end_page": 252,
      "summary": "\"login_id\": self.login_id,\nThe EmbeddedDocument API is a Document without an id and has no collection of its own.\nSubclasses of this API are model classes that have been created to be part of a core document structure, \nbook reselling application has implemented a from_json() class method that converts JSON details \nWhen converting the BSON document into a JSON object, model \nclasses must have the custom to_json() instance method, which builds the JSON structure and \nLet us now create the repository layer using the model classes.\nAll its operations come from the Document model class and they are easy \nLoginRepository uses the ODM to implement its CRUD transactions:\nfrom models.data.mongoengine import Login\ndef insert_login(self, details:Dict[str, Any]) -> bool: \ndef update_password(self, id:int, newpass:str) -> bool: \nlogin.update(password=newpass)\ndef delete_login(self, id:int) -> bool: \nIt only takes two lines for the insert_login() method to save the Login document.\nthe Login instance with the necessary document details, we simply call the save() method of the \nDocument instance to pursue the insert transaction.\nvalues, the Document API class has an update() method that manages changes in state for every \nBut first, we need to find the document using the objects() utility method, which \nThis objects() method can fetch a document \nby providing its parameter with an id field value or extracting a list of document records by supplying \nupdate_password() method updates the password field of Login, which gives us a good template \nOn the other hand, delete_login() shows how to delete a Login document from its collection \ndef get_all_login(self):\nreturn login_list\ndef get_login(self, id:int): \nreturn login.to_json()\nThe only way to perform single- or multiple-document retrieval is to utilize the objects() method.\nThere is no need to implement JSON converters for the query results because every Document model \nclass has a to_json() method to provide the JSON-able equivalent of the instance.\nget_all_login() transaction uses list comprehension to create a list of JSON documents from \nthe result of objects(), while the get_login() method invokes to_json() after extracting \nIt is easier to implement document associations with an ODM than the core PyMongo and Motor \ninsert_profile() shows how adding a UserProfile detail to the Login document can be \nfrom models.data.mongoengine import Login, UserProfile, \ndef insert_profile(self, login_id:int, \ndef add_book_sale(self, login_id:int, \nLikewise, the given add_book_sale() transaction creates a many-to-one association between \nmethod that uses field lookup syntax to refer to a specific document structure or list of embedded \ncode, get_all_profile()uses the profile__login_id__exists=True field lookup \nto filter all user_profile embedded documents that have valid login structures.\nget_profile() transaction does not need to use filter() and field lookups because it can \nsimply access the specific login document to fetch its profile details:\nprofile__login_id__exists=True)\nprofile__login_id__exists=True)))\ndef get_profile(self, login_id:int): \nLet us now apply the CRUD transactions to our API services.\nCRUD will not work without passing our create_db() method to the startup event and disconnect_\nThe following script shows the application’s profile router with a create_profile() REST \nservice that asks clients for a profile detail, given a specific login record, and pursues the insert \nfrom db_config.mongoengine_config import create_db\ndef create_profile(login_id:int, req:UserProfileReq): \nresult = repo.insert_profile(login_id, profile_dict)\ncreate_profile() is a standard API service that deals with MongoEngine’s synchronous \nTo use Beanie, we need to install it using the following pip command:\nhelper method that initiates the model class initialization using the database name.\nmethod will also set up the collection-domain mapping, where all the model classes are registered in \nthe document_models parameter of init_beanie().\nfrom models.data.beanie import Cart, Order, Receipt\ndocument_models=[Cart, Order, Receipt])\nHere, db_connect() uses an async/await expression because its method invocation to init_\nLet us now create the model classes.\nDefining the model classes\nThe Beanie ODM has a Document API class that’s responsible for defining its model classes, mapping \nfollowing script shows how to define Beanie model classes while it’s being configured:\nfrom beanie import Document\nclass Cart(Document):\nclass Order(Document):\nclass Receipt(Document): \nThe id attribute of the given Document classes automatically translates into an _id value.\nA document in Beanie can be configured by adding the Collection and Settings nested classes.\nIt can also provide indexes to document fields if needed.\nCreating the document associations\nPython syntax, Pydantic rules, and API classes are used to establish links between documents in this \nneed a list field that will contain all the Order embedded documents.\nHowever, the ODM has a Link type, which can be used to define class fields to generate these \ntransactions, the find() method can include the Link documents during document fetching, \nusing the model classes.\ndelete(), provided by the Document API class.\nrepository layer because all the API methods that are inherited by the model classes are non-blocking.\nThe following code for the CartRepository class shows a sample implementation of an asynchronous \nrepository class using this Beanie ODM:\nfrom models.data.beanie import Cart\nasync def update_qty(self, id:int, qty:int) -> bool: \nasync def delete_item(self, id:int) -> bool: \nThe Document API also has a create() method that works like \nAnother option is to use the insert_one() class method instead of the instance \nUpdating a document can be initiated using two methods, namely set() and replace().\nWhen it comes to document removal, the ODM only has the delete() method to pursue the \nthe mapper provides the get() method if the fetching process only requires the _id field; it provides \nasync def get_items_user(self, user_id:int): \nasync def get_item(self, id:int): \nobject that has a to_list() utility that returns a list of JSON-able documents.\nfrom db_config.beanie_config import db_connect\ndef create_db_connection():\ndef create_db_engine():\nWe need to create event handlers in APIRouter to run create_db_connection() and \nODMantic has a Model API class that provides properties to model classes when subclassed.\nyou to add custom @validator methods into the model classes to implement the appropriate object \nThe following is a standard ODMantic model class definition:\nclass Purchase(Model): \nFor advanced configurations, we can add a nested Config class to the model class to set these additional \nan embedded document(s) is still applicable in this ODM.\nEmbeddedModel API class to create a model with no _id field; this can be linked to another \nThe Model classes, on the other hand, can define a field attribute that will refer to an \nCreating the repository layer using ODMantic always requires the engine object that was created in \nneed to create CRUD transactions:\nfrom models.data.odmantic import Purchase\nThis insert_purchase() method shows the standard way to insert a record into the database \nThrough the engine’s save() method, we can persist one document at a time using \nthe model class.\nasync def update_purchase(self, id:int, \nAfter accessing and changing the field values, the fetched document object will be re-saved using the \nasync def delete_purchase(self, id:int) -> bool: \nfetched document object to the delete() method of the engine to pursue the removal process.\none() method that requires two arguments: the model class name and the conditional expression, \nThe following get_purchase() method retrieves a Purchase document \nasync def get_purchase(self, id:int): \nThe engine has a find() operation to retrieve all Purchase documents, for instance, from the \nIt only needs an argument – the name of the model class.\nFor the repository classes to run, all the router services must be asynchronous.\nthe repository class to work, create_db_engine() must be injected into each API service to \nfrom db_config.odmantic_config import create_db_engine, \nrouter.add_event_handler(\"startup\", create_db_connection)\nCreating CRUD transactions using MongoFrames\nBut this mapper can only create synchronous and standard types of CRUD transactions.\nTo create the database connection, it uses the MongoClient API class from the \ncreate a client variable, in this mapper, we access the variable _client class from the Frame \nAPI class to refer to the client connection object.\nThe following code shows create_db_client(), \ndef create_db_client():\nCreating CRUD transactions using MongoFrames\nThe process of creating model classes in MongoFrames is called framing because it uses the Frame \nAPI class to define the model classes.\nOnce inherited, Frame does not require a model class to define \nThe following model classes are defined by the Frame API class:\nA Frame model class can wrap a document in dictionary form or in a kwargs that contains the \nAll the fields of the model class can be accessed through dot (.) \nCreating the document association\nWe need to define the SubFrame model before creating associations among these documents.\nSubFrame model class is mapped to an embedded document structure and has no collection table \nassociation among documents since the field references of Frame do not have specific field types.\nA Book document, on the other \nhand, will refer to a Category child document through its category field because a transaction \nThe Frame API class provides the model classes and the necessary helper methods to implement the \nclass that uses MongoFrames to create its CRUD transactions:\nfrom models.data.mongoframe import Book, Category\nCreating CRUD transactions using MongoFrames\nFrame API provides an insert() method that saves the given model object into the database.\nIt also has insert_many(), which inserts a list of multiple BSON documents or a list of model \nThe following script shows how to create an UPDATE transaction in MongoFrames:\ndef update_book(self, id:int, \nThe given update_book() transaction shows that the Frame model class also has an update() \nmethod, which recognizes and saves the changes reflected in the field values of a document object \ndef delete_book(self, id:int) -> bool: \nWhen creating query transactions, the Frame API provides two class methods – the many() method, \nwhich extracts all BSON documents, and the one() method, which returns a single document object.\ndef get_book(self, id:int): \nThe get_book() method shows how to extract a single Book document with a Q expression that \ndef add_category(self, id:int, \nNow, it is time to apply these CRUD transactions to our API services.\nCreating CRUD transactions using MongoFrames\nOur repository classes will not work if we do not inject the create_db_client() injectable into \nfrom db_config.mongoframe_config import create_db_client\nThe create_book() service uses BookRepository to insert book details into the MongoDB \nfor creating the database connection, building the model layer, and implementing the repository \n•\t Implementing Basic and Digest authentication\n•\t Implementing password-based authentication\nImplementing Basic and Digest authentication\nThe Basic and Digest authentication schemes are the easiest authentication solutions that we can use \nThe most straightforward way to secure the API endpoint is the Basic authentication approach.\nthis authentication mechanism must not be applied to high-risk applications because the credentials, \ncommonly a username and password, sent from the client to the security scheme provider are in the \nThe prototype, ch07a, uses the Basic authentication mode to secure its administration and bidding \nfrom models.data.sqlalchemy_models import Login\nImplementing Basic and Digest authentication\nthe HTTPBasic class of the module and inject it into each API service to secure the endpoint access.\nThe http_basic instance, once injected into the API services, causes the browser to pop up a login \nform, through which we type the username and password credentials.\nOn the other hand, the /ch07/login service will call the authentication()method to verify \nThe authenticate() method checks the credentials against the Login database \nLastly, always use the compare_digest() from the secret module when comparing credentials \nfrom the browser with the Login credentials stored in the database.\ndef authenticate(credentials: HTTPBasicCredentials, \nOur authenticate() method has all the needed requirements to help reduce attacks from outside \nNow, we need to implement a /ch07/login endpoint to apply the Basic authentication scheme.\none that calls the authenticate() method to check the user credentials.\nfrom security.secure import authenticate, \ndef login(credentials: HTTPBasicCredentials = \nif authenticate(credentials, account) and \nImplementing Basic and Digest authentication\n@router.get(\"/login/users/list\")\ndef list_all_login(credentials: HTTPBasicCredentials = \nFor instance, the cited list_all_login() service can only return a list of \nExecuting the login transaction\nWe can use either the curl command or the browser to perform the /ch07/login transaction.\nlogin.\nlogin GET transaction and click the Try it out button.\nAfter the Username and Password input, click the Sign in button on the login form to check whether \nauthentication process finds that the user credentials are valid:\nNow that the user is authenticated, run /ch07/login/users/list through the OpenAPI \nINFO: 127.0.0.1:53150 - \"GET /ch07/login/users/list HTTP/1.1\" \nDigest authentication is more secure than the Basic scheme because the former needs to hash the \nIt is an authentication scheme that stores credentials in a .env or .config property \nfile and creates a hashed string value for these credentials before the authentication.\nproject applies the Digest authentication scheme to secure the bidding and auctioning transactions.\nImplementing Basic and Digest authentication\nSo, before we start the implementation, we first need to create a custom utility script, generate_\nAside from the digest, we also need to save the user credentials for the Digest scheme provider later.\nFastAPI requires storing the user credentials in a.env or .config file inside our application to be \na Digest authentication scheme with a different approach to managing user credentials and generating \nWe inject the following authenticate()dependable into the API services \nthrough the HTTP operator, including /login, where the authentication starts:\ndef authenticate(credentials: \nImplementing Basic and Digest authentication\nThe authenticate() method is where the http_digest is injected to extract the \nExecuting the login transaction\nAfter implementing the authenticate() method, we inject it into the API services, not in the \ndirectly into the API services, unlike in the Basic authentication scheme.\nshows how the authenticate() dependable is applied to secure all the crucial endpoints of the \nfrom security.secure import authenticate\n@router.get(\"/login\", dependencies=[Depends(authenticate)])\ndef login(sess:Session = Depends(sess_db)):\n@router.get(\"/login/users/list\",   \ndef list_all_login(sess:Session = Depends(sess_db)):\nAuthorization header with the value containing the Base64-encoded username:password digest \nis the correct way of logging into our FastAPI application that uses the Digest authentication scheme:\nWe also use the same command to run the rest of the secured API services.\nMost enterprise applications nowadays seldom use Basic and Digest authentication schemes because \ncredentials to the secured API services, which is also another risk.\nImplementing password-based authentication\nclient credentials, authorization code, and resource password flows.\nwith third-party authentication providers, which will authorize the access of the API endpoints.\nas the provider for password-based authentication.\nThis class is \ndirectly injected into the /ch07/login API endpoint to extract all the parameter values from the \nfrom fastapi.security import OAuth2PasswordBearer\nfrom repository.login import LoginRepository\nImplementing password-based authentication\ndef get_current_user(token: str = Depends(oauth2_scheme), \nuser = loginrepo.get_all_login_username(token)\nFor the resource password flow, injecting oauth2_scheme will return a username as a token.\nExecuting the login transaction\nIn this authentication scheme, /ch07/login/token is also the tokenUrl parameter of \nauthentication because this is the endpoint service that will capture the user credentials from the \nThese three parameters are the essential requirements to invoke /ch07/login/token for token \nThis dependency is shown in the following implementation of the login API service:\nfrom repository.login import LoginRepository\nfrom security.secure import get_current_user, authenticate\ndef login(form_data: OAuth2PasswordRequestForm = Depends(),\nif authenticate(username, password, account) and \nreturn {\"access_token\": form_data.username, \nAside from verifying from the database, the login() service will also check whether the password \nch07/login/token must return a JSON object with the required properties, access_token and \nInstead of creating a custom frontend for the login form, we will be utilizing the OAuth2 form provided \nImplementing password-based authentication\nlogin form must be \"password\".\nThe confidential clients utilize authentication servers for security, such as in this online auction \nto provide the client_id and client_secret values to the login form since the server will \nduring login.\nTo secure the API endpoints, we need to inject the get_current_user() method into each API \nThe following is an implementation of a secured add_auction() service that \nImplementing password-based authentication\nThe get_current_user() injectable will return a valid Login account if the access is allowed.\nBut before we start building the authentication scheme, we first need to generate a secret key, which is \ndef create_access_token(data: dict, \nSo now, the /ch07/login/token endpoint will invoke the create_access_token() method \nThe login service will provide the data, usually username, to comprise the payload \nCreating the login transaction\nThe implementation of the login service is similar to the previous password-based OAuth2 authentication, \nexcept that this version has a create_access_token() call for the JWT generation to replace \nThe following script shows the /ch07/login/token service of the \ndef login(form_data: OAuth2PasswordRequestForm = Depends(),\nif authenticate(username, password, account):",
      "keywords": [
        "False return True",
        "login",
        "Document API class",
        "Frame API class",
        "CRUD transactions",
        "Document",
        "API",
        "return True",
        "API class",
        "return False",
        "Digest authentication",
        "REST APIs",
        "API services",
        "Frame API",
        "Digest"
      ],
      "concepts": [
        "important",
        "classes",
        "authentic",
        "authenticate",
        "authenticated",
        "document",
        "documents",
        "returns",
        "method",
        "created"
      ],
      "similar_chapters": [
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 8,
          "title": "",
          "score": 0.624,
          "base_score": 0.474,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 5,
          "title": "",
          "score": 0.394,
          "base_score": 0.394,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 6,
          "title": "",
          "score": 0.376,
          "base_score": 0.376,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 4,
          "title": "",
          "score": 0.354,
          "base_score": 0.354,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 3,
          "title": "",
          "score": 0.345,
          "base_score": 0.345,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "document",
          "authentication",
          "model",
          "digest",
          "def"
        ],
        "semantic": [],
        "merged": [
          "document",
          "authentication",
          "model",
          "digest",
          "def"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3947441663793925,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:22.900753+00:00"
      }
    },
    {
      "chapter_number": 8,
      "title": "Creating Coroutines, Events, and Message-Driven Transactions",
      "start_page": 253,
      "end_page": 286,
      "summary": "The endpoint should still return access_token and token_type since this is still a password-based \nOAuth2 authentication, which retrieves the user credentials from OAuth2PasswordRequestForm.\nAs with the previous OAuth2 schemes, we need to inject get_current_user()into every API \ndef get_current_user(token: str = Depends(oauth2_scheme),\nCreating scope-based authorization\nuser = \nloginrepo.get_all_login_username(token_data.username)\nif user is None:\nreturn user\nget_current_user() must be injected into each service implementation to restrict access from \nusers.\nThe next step is adding user authorization to the OAuth2 solution.\nCreating scope-based authorization\nFastAPI fully supports scope-based authentication, which uses the scopes parameter of the OAuth2 \nuser authorization.\nFirst, we need to create a custom class that inherits the properties of the OAuth2 API class from \nthe fastapi.security module to include the scopes parameter or \"role\" options in the user \nthat will implement the authentication flow with authorization:\nof the user credentials for authentication using the Authorization header.\nBefore we proceed with the auth implementation, we need to first build the scopes parameters \nThe following script shows how all the custom-defined user scopes are saved in a dictionary, \nCreating scope-based authorization\nAll the scopes will be added to the OAuth2 form login as an option and will be part of the user’s login \nThe following implementation of /ch07/login/token in this new ch07e project shows \nThe selected scopes are stored in a list, such as ['user', 'admin_read', 'admin_write', \ncreate_access_token() will include this list of scopes or \"roles\" \nas part of the payload, which will be decoded and extracted by get_current_valid_user() \nsecures every API from the user access by applying the authentication scheme.\nThe Security API from the fastapi module replaces the Depends class in injecting the get_\ncurrent_valid_user() because of its capability to assign scopes to each API service, aside from \nis accessible only to users whose scopes contain the bidder_write and buyer_write roles:   \ncurrent_user: Login = Security(get_current_valid_user, \nNow, the following code snippet shows the implementation of the get_current_valid_user() \nLogin = Security(get_current_user, scopes=[\"user\"])):\nreturn current_user\nCreating scope-based authorization\nThis method relies on get_current_user() when it comes to JWT payload decoding, credential \nvalidation, and user scope verification.\nThe user must at least have the user scope for the authorization \nThe Security class is responsible for injecting get_current_user() into \nget_current_valid_user() together with the default user scope.\ndef get_current_user(security_scopes: SecurityScopes, \ntoken: str = Depends(oauth2_scheme), \ntoken_scopes = payload.get(\"scopes\", [])\ntoken_data = TokenData(scopes=token_scopes, \nif scope not in token_data.scopes:\nreturn user\nThe SecurityScopes class of the given get_current_user() extracts the scopes assigned \nto the API service that the user is trying to access.\nthese scope parameters of the API.\n\"roles\" of the user extracted from the decoded JWT payload.\nAPI scopes in SecurityScopes to check whether all of them appear in the token_scopes of \nthe user.\nIf True, get_current_user() authenticates and authorizes the user to access the API \nscope parameters from the token_scopes payload value and the username.\nThe next type of OAuth2 authentication scheme that FastAPI can support is the authorization code \nIf the application is a public type and there is no authorization server to process the client_id \nIn this scheme, the client creates an authorization request \ntoken from tokenUrl in exchange for the generated code.\nanother version of our online auction system that will use the OAuth2 authorization code flow scheme.\nclass is created before its injection into the get_current_user() method:\nauthentication and authorization process of this scheme.\nrely on the authorization server when generating access_token.\ncomprise the authorization request for access_token generation.\nIn the previous schemes, the /ch07/login/ token or the tokenUrl endpoint is always the \n/ch07/oauth2/authorize or the authorizationUrl endpoint for auth code generation.\nQuery parameters such as response_type, client_id, redirect_uri, scope, and \naccount = loginrepo.get_all_login_username(client_id)\n•\t response_type: Custom-generated authorization code \n•\t redirect_uri: The server default URI or a custom endpoint designed to redirect the user \nThe redirect_uri parameter is the destination point where the authentication and authorization \nThe generation of auth_code is one of the crucial tasks of the authorizationUrl transaction, \nThe auth code indicates an ID for the authentication process \nencrypted because it comprises the user credentials, scope, and other request-related details.\nIf the user is valid, the authorizationUrl transaction will redirect the user to the redirect_uri \nparameter, back to the FastAPI layer, with the auth_code, grant_type, and state parameters, \nauthentication process with scoped-based authorization.\nThe /ch07/login/token service, or tokenUrl, must have the Form(…) parameter to capture the \ncode, grant_type, and redirect_uri parameters from the authorizationUrl transaction \ndef access_token(code: str = Form(...), \nscopes = code_data[2].split(\"+\")\nthe service, which the API authentication requires.\ncredentials but parsing auth_code is a possible way to derive the username, password, and scopes.\nIf the user is valid, tokenUrl must submit the JSON data containing access_token, expires_in, \ntoken_type, userid, and state to proceed with the authentication scheme.\nThis authorization code flow scheme provides the baseline protocol for the OpenID Connect authentication.\nin authenticating client access to the API services.\nthe other OAuth2 schemes, this requires the generation of an access_token on the Keycloak side \naccessing the credentials and the access_token from Keycloak’s identity provider.\naccount to set up the realm, clients, users, and scopes.\nA Keycloak realm is an object that encompasses all the clients together with their credentials, scopes, \nThe first step before creating the user profiles is to build a realm, as shown in Figure 7.7:\nAfter the realm, the Keycloak client, which manages the user profiles and credentials, is the next \nAfter creating the clients, we need to edit each Client profile to input the following details:\nAfter the setup, we can now assign users to the clients.\nCreating users and user roles\nFirst, we create roles on the Configure | Roles panel, in preparation for user assignment later.\nshows three user roles that will handle the application’s administration, auctioning, and bidding tasks:\nFigure 7.9 – Creating user roles\nAfter creating the roles, we need to build the list of users on the Manage | Users panel.\nshows the three created users, each with the mapped roles: \nFigure 7.10 – Creating client users\nFigure 7.11 shows that the user joey_admin has the auc_admin_role role, \nauthorizing the user to do the administrative tasks for the app.\nAside from user roles, clients can also have assigned roles.\nA client role defines the type of users a client \nIt also provides the client’s boundary when accessing the API services.\nFigure 7.12 – Creating client roles\nThen, we need to return to the Manage | Users panel and assign the user its role(s) through the client.\nAll users with the auc_admin client added to their setup have admin \nFigure 7.13 – Mapping client roles to users\nCreating user permissions through scopes\nTo assign permission to each client, we need to create client scopes on the Configure | Client Scopes panel.\nEach client scope must have an Audience-type token mapper.\nand admin:write scopes for the auc_admin client, auction:read and auction:write \nFigure 7.14 – Creating the client scopes\nThese client scopes are essential details within the Security injection for each API service if scope-\nSince the FastAPI application cannot directly access the Keycloak client credentials for authentication, \nthe application has a login_keycloak() service to redirect the user to the AuctionRealm URI, \nrealms/AuctionRealm/account/ to log in using the authorized user credentials, such as \njoey_admin, before invoking the login_keycloak() service.\nThe following code shows the implementation of the login_keycloak() service:\nA state is part of login_keycloak()’s response for the callback method to verify the authentication, \nb9c56a56\",\"scope\":\"admin:write admin:read user\"}\nThis contains the essential credentials, such as access_token, expires_in, session_state, \nThe application’s HTTPBearer needs access_token to pursue the client-side authentication.\nby Keycloak’s authorizationUrl. After the successful authentication, get_current_user() \nwill verify the access to each API endpoint based on the credentials extracted from access_token.\nThe following code highlights the get_current_user(), which builds the user credentials from \ndef get_current_user(security_scopes: SecurityScopes, \ntoken: str = Depends(token_auth_scheme)):\nAuth0 can also be a third-party authentication provider that can authenticate and authorize access to \nAfter signing up for an account, create an Auth0 application to derive Domain, Client ID, and Client \nThe Auth0 application also has the generated Audience API URI that the client-side authentication \nservice that generates the auth_token once requested, similar to the Keycloak’s realm.\nch07g has its own version of get_current_user() that processes the payload for API \nauthentication and authorization from the Auth0 details in the .config file.\nHTTPBearer class needs the auth_token value and gets it by running the following tokenURL \nhttps://dev-fastapi1.us.auth0.com/oauth/token   --header\nBut then again, the HTTPBearer class needs an auth_token \nokta.com/oauth2/default/v1/token?grant_type=client_\nAside from the Basic, Digest, OAuth2, and OpenID Connect authentication schemes, FastAPI can \nthe Authorization credential is a Bearer class and verifies whether the username token is \nInjecting FastAPI’s Request is the first step in applying the authentication scheme.\nauthentication schemes and is even open to further customization of its security APIs.\nwith different popular identities and user management systems, such as Auth0, Okta, and Keycloak.\nCreating Coroutines, \nframework uses the async keyword to create asynchronous processes that will run on top of other \n•\t Creating asynchronous background tasks\nCreating Coroutines, Events, and Message-Driven Transactions\nmanage the newspaper content, subscription, billing, user profiles, customers, and other business-related \nIn FastAPI, there are two ways of implementing coroutines: \n(a) applying the @asyncio.coroutine decorator, and (b) using the async/await construct.\nthreaded and single-process model and provides API classes and methods for running and managing \nand native services into generator-based coroutines.\nThe following is a login service transaction of our \ndef build_user_list(query_list):\nuser_list = []\nuser_list.append(\" \".join([str(record.id), \nreturn user_list\nbuild_user_list() is a native service that converts all login records into the str format.\nasynchronous task or coroutine.\nOn the other hand, the following code is an API service implemented \nThe list_login() API service retrieves all the login details of the application’s users through a \nfrom clause to run and execute the get_all_login() coroutine function.\nCreating Coroutines, Events, and Message-Driven Transactions\nThis asyncio method manages a list of coroutines and waits until all its \nThe following code is an API that retrieves login records through an asynchronous CRUD \ntransaction and then invokes count_login() and build_user_list() concurrently to \nbuild_user_list(login_data))\nreturn {'num_rec': result[0], 'user_list': data}\nlist_login_records() uses asyncio.gather() to run the count_login() and \nbuild_user_list() tasks and later extract their corresponding returned values for processing.\nAnother way of implementing a coroutine is using async/await constructs.\nThe following code is the count_login() task previously invoked in the generator-based \ncoroutine service, list_login_records():\nThe count_login() native service is a native coroutine because of the async keyword placed \nThe following is an API service implemented as a \nnative coroutine that manages data entry for the new administrator profiles:\nEach task, pre-generated or manually created, executes one coroutine.\nprevious add_admin() API service invokes the insert_admin() coroutine transaction, the event \nassign a task to run the insert_admin() transaction.\nCreating Coroutines, Events, and Message-Driven Transactions\nThere are a few programming paradigms that we can follow when creating coroutines for our application.\nour newsstand application, there is an endpoint, /admin/login/list/enc, in the admin.py \nrouter that returns a list of encrypted user details.\nIn its API service, shown in the following code, each \nrecord is managed by an extract_enc_admin_profile() transaction call instead of passing \nresult = await repo.join_login_admin()\nNow, the extract_enc_admin_profile() coroutine, shown in the following code, implements \nenc_admin_profile() creates three context switches in a chain, better than thread switches:\nasync def extract_profile(admin_details):\nAnother programming approach to utilizing the coroutine switching is the use of pipelines created by \nThe following code highlights the process_billing() native service that builds a producer/\nThe extract_billing() coroutine is the producer that retrieves \nasync def process_billing(query_list):\nCreating Coroutines, Events, and Message-Driven Transactions\nasync def build_billing_sheet(q: Queue):\nIn this programming design, the build_billing() coroutine will explicitly wait for the record \nutility, which directly assigns and schedules a task to each coroutine.\ncreate asyncio.Queue and schedule a task for execution:\nbuild_sheet = asyncio.create_task(\nawait asyncio.gather(asyncio.create_task(\nCreating asynchronous background tasks\nreturn billing_list\nBy the way, always pass cancel()to the task right after its coroutine has completed the process.\nNow, let us explore other FastAPI tasks that can also use coroutines.\nCreating asynchronous background tasks\nAPI class, but we didn’t mention creating asynchronous background tasks.\nbe focusing on creating asynchronous background tasks using the asyncio module and coroutines.\nThe following native service is an asynchronous transaction that generates \nasync def generate_billing_sheet(billing_date, query_list):\nCreating Coroutines, Events, and Message-Driven Transactions\nThis generate_billing_sheet() coroutine service will be executed as a background task in \nthe following API service, save_vendor_billing():\ntasks.add_task(generate_billing_sheet, \nBackgroundTasks into the API service method and apply add_task() to provide task schedules, \ncoroutine API service has already returned a response to the client.\nIn the save_vendor_billing() service, there is another task ",
      "keywords": [
        "user",
        "REST APIs",
        "API service",
        "API",
        "token",
        "scopes",
        "client",
        "authorization code flow",
        "Login",
        "code",
        "billing",
        "admin",
        "coroutine",
        "authorization",
        "Keycloak"
      ],
      "concepts": [
        "returned",
        "tasks",
        "creating",
        "create",
        "securing",
        "secures",
        "users",
        "apis",
        "authentication",
        "authenticate"
      ],
      "similar_chapters": [
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 7,
          "title": "",
          "score": 0.624,
          "base_score": 0.474,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 3,
          "title": "",
          "score": 0.527,
          "base_score": 0.527,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 5,
          "title": "",
          "score": 0.525,
          "base_score": 0.525,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 4,
          "title": "",
          "score": 0.523,
          "base_score": 0.523,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 1,
          "title": "",
          "score": 0.473,
          "base_score": 0.473,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "scopes",
          "user",
          "authorization",
          "authentication",
          "coroutine"
        ],
        "semantic": [],
        "merged": [
          "scopes",
          "user",
          "authorization",
          "authentication",
          "coroutine"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4900297610168948,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:22.900767+00:00"
      }
    },
    {
      "chapter_number": 9,
      "title": "Utilizing Other Advanced Features",
      "start_page": 287,
      "end_page": 324,
      "summary": "Creating Coroutines, Events, and Message-Driven Transactions\nCreating and configuring the Celery instance\nBefore creating Celery tasks, we need a Celery instance placed in a dedicated module of our application.\nThe newsstand prototype has the Celery instance in the /services/billing.py module, and \nfrom celery.utils.log import get_task_logger \ntask_create_missing_queues = True\nresult_accept_content = [\"pickle\", \"application/json\",\nTo create the Celery instance, we need the following details:\n•\t The list of other modules used in the message body or by the Celery task (include)\nand outgoing message body of the tasks involved, if there are any.\ndeclare a default task and result serializer to the object stream.\nApart from the serialization options, other important properties such as task_create_missing_\nAdditionally, we can create a Celery logger through its get_task_logger()with the name of \nCreating Coroutines, Events, and Message-Driven Transactions\nCreating the task\nThe main goal of the Celery instance is to annotate Python methods to become tasks.\ndefine tasks from non-coroutine methods.\nThe services.billing.tasks.create_total_payables_year_celery task shown \n@celery.task(\nname=\"services.billing.tasks\n.create_total_payables_year_celery\", \ndef create_total_payables_year_celery(billing_date,\ncelery_log.info('computed result: ' + str(total))\nAlso, it is a function that returns a computed amount, which is impossible to create when \nAll functional tasks use the Redis database as the temporary storage \nFastAPI services can call these tasks using the apply_async()or delay()function.\nobject, which returns resources such as the task’s state, the wait() function to help the task finish \nits operation, and the get() function to return its computed value or an exception.\ncode is a coroutine API service that calls the services.billing.tasks.create_total_\npayables_year_celery task using the apply_async method:\nasync def compute_payables_yearly(billing_date:date):\ntotal_result = create_total_payables_year_celery\nSetting task_create_missing_queues to True at the CeleryConfig setup is always \nrecommended because it automatically creates the task queue, default or not, once the worker server \nThus, we should always define a task queue in the apply_async() function’s \nThe AsyncResult object has a get() method that releases the returned value of the task from \nLet us now deploy and run our tasks using the Celery server\nRunning the Celery worker creates a single process that handles and manages all the queued tasks.\nThe worker needs to know in which module the Celery instance is created, together with the tasks to \nCreating Coroutines, Events, and Message-Driven Transactions\nHere, -A specifies the module of our Celery object and tasks.\nBut first, we need to set task_create_missing_\nNow, there are also ways to monitor our running tasks and one of those options is to use the Flower tool.\nFlower is Celery’s monitoring tool that observes and monitors all tasks executions by generating a \nAnd then, we run the following celery command with the flower option:\nTo view the audit, we run http://localhost:5555/tasks on a browser.\na Flower snapshot of an execution log incurred by the services.billing.tasks.create_\ntotal_payables_year_celery task:\nSo far, we have used Redis as our in-memory backend database for task results and a message broker.\nLet us now use another asynchronous message broker that can replace Redis, RabbitMQ.\nCreating the Celery instance\nmediate messages between the client and the Celery worker threads.\ncan command the Celery worker to work on these tasks one at a time.\nTo start, we need to set up a new Celery instance that will utilize the RabbitMQ message broker using \nto create and manage message-driven transactions.\nservices.billing.tasks.create_total_payables_year_celery task several times:\nCreating Coroutines, Events, and Message-Driven Transactions\nAs with RabbitMQ, Apache Kafka is an asynchronous messaging tool used by applications to send and \nThere are three Python extensions that we can use to integrate the FastAPI services with Kafka, namely \nKafka has a ZooKeeper server that manages and synchronizes the exchange of messages within Kafka’s \nNow, we can start the Kafka server by running the following console command:\nWhen the two servers have started, we can now create a topic called newstopic through the \nC:\\..\\kafka-topics.bat --create --bootstrap-server             \nAfter creating the topic, we can now implement a producer that publishes messages to the Kafka cluster.\nThe following is an API service that sends a newspaper \nmessenger record to the Kafka newstopic topic for the consumer to access and process:\nCreating Coroutines, Events, and Message-Driven Transactions\nThe coroutine API service, send_messenger_details(), asks for details about a newspaper \nNow, one of the options to consume Kafka tasks is to run its built-in \nRunning the following command from the console is one way to consume the current messages from \nThis command creates a consumer that will connect to the Kafka cluster to read in real time the current \nthe Kafka server and broker began running, we need to add the --from-beginning option to \nAnother way of implementing a consumer using the FastAPI framework is through SSE.\nAPI service implementation will not work with the Kafka consumer requirement since we need a \ncontinuously running service that subscribes to newstopic for real-time data.\nhow we create SSE in the FastAPI framework and how it will consume Kafka messages.\nSSE is a server push mechanism that sends data to the browser without reloading the page.\nCreating SSE in the FastAPI framework only requires the following:\nThe following is a coroutine API service \nasync def send_message_stream(request: Request):\nCreating Coroutines, Events, and Message-Driven Transactions\nsend_message_stream() is a coroutine API service that implements the whole SSE.\nOn the other hand, event generator functions create internal events, which can also be asynchronous.\nsend_message_stream(), for instance, has a nested generator function, event_provider(), \nwhich consumes the last message sent by the producer service using the consumer.poll() method.\ndata streams generated by send_message_stream()rendered from the browser:\nAnother way to implement a Kafka consumer is through WebSocket.\non the general procedure of how to create an asynchronous WebSocket application using the \nThe FastAPI framework allows the implementation of an asynchronous WebSocket that can also run \nThe following is an example of an asynchronous WebSocket created using \nfrom fastapi import WebSocket\n@router.websocket(\"/customer/list/ws\")\nasync def customer_list_ws(websocket: WebSocket):\nCreating Coroutines, Events, and Message-Driven Transactions\nresult = await repo.get_all_customer()\nawait websocket.send_json(json.dumps(data, \nclient_resp = await websocket.receive_json()\nFirst, we decorate a coroutine function with @router.websocket() when using APIRouter, or \nThe previous customer_list_ws()coroutine is a WebSocket that sends \nour customer_list_ws() endpoint expects a JSON reply from a client because it invokes the \nreceive_json() method after its send message operation.\nThere are many ways to create a WebSocket client but this chapter will focus on utilizing a coroutine \nAPI service that will perform a handshake with the asynchronous customer_list_ws() endpoint \nasync def customer_list_ws_client():\nawait websocket.send(json.dumps(client_resp))\nreturn {\"message\": \"done\"}\nAfter a successful handshake is created by the websockets.connect() method, customer_\nlist_ws_client() will have a loop running continuously to fetch all incoming consumer details \nWebSocket coroutine with JSON data containing the customer ID of the profile.\nseveral methods that we can apply to these streams asynchronously to extract the terminal result as \nCreating Coroutines, Events, and Message-Driven Transactions\nCreating the Observable data using coroutines\nIt all starts with the implementation of a coroutine function that will emit these streams of data based \nThe following is an Observable function that emits publication details in \nasync def process_list(observer):\nThe coroutine function should have the following callback methods \nThen, we create \nan asyncio task for the call of the process_list() coroutine.\nevaluate_profit(), which returns the Disposable task required by RxPY’s create() \nexecution of the asynchronous Observable function and the use of the create() method to \ngenerate streams of data from this Observable function:\ndef create_observable(loop):\nreturn rx.create(evaluate_profit)\nThe subscriber created by create_observable()is our application’s list_sales_by_quota() \nIt needs to get the current event loop running for the method to generate the observable.\nobserver = create_observable(loop)\nCreating Coroutines, Events, and Message-Driven Transactions\nThe list_sales_by_quote() coroutine service shows us how to subscribe to an Observable.\n•\t An on_next() method to consume all the items from the stream\nAnd since the Observable processes run asynchronously, the scheduler is an optional argument \nto generating Observables that do not use a custom function.\nAs when we create continuously running Observables, we use the interval() function instead of \nusing a custom Observable function.\nresult = await repo.join_customer_subscription_total()\ndef fetch_records(rate, loop) -> rx.Observable:\nloop.create_task(compute_subscriptions()))),\nThe interval() method creates a stream of data periodically in seconds.\nAnother way of creating an Observable is using the from_() method, which extracts resources from \nThe Observable function retrieves its data from a JSON document \ncreates an Observable that emits streams of str data from the https://localhost:8000/\nCreating Coroutines, Events, and Message-Driven Transactions\nops.map(lambda a: rx.from_future(loop.create_task(\nreturn observable\nOn the other hand, the following convert_str() is a coroutine function executed by the map() \noperator to generate a concise profile detail of the newspaper subscribers derived from the JSON data: \nRunning these two functions modifies the original emitted data stream from JSON to a date-filtered \nThe coroutine list_dated_subscription()API service, on the other \nasync def list_dated_subscription(min_date:date, \nobservable = await fetch_subscription(min_date, \nAlthough the FastAPI framework does not yet fully support reactive programming, we can still create \nThe FastAPI framework has special functions called event handlers that execute before the application \nfunction with the @app.on_event(\"startup\") decorator to create a startup event.\nCreating Coroutines, Events, and Message-Driven Transactions\nThis chapter used Celery and Redis for creating and managing asynchronous background tasks \ncreate these asynchronous and non-blocking background processes and message-passing solutions \napplication that has a reliable, asynchronous, message-driven, real-time message-passing, and distributed \napplied to the application, such as its session handling mechanism, which can function well using a \ncustomizing request and response filters other than applying the @app.middleware decorator.\nus on managing incoming byte body, form, or JSON data.\n•\t Applying session management\n•\t Customizing APIRoute and Request\nAlthough not data analysis-related, our application prototype for this chapter is the online restaurant \nSession management is a feature used for managing requests and responses created by a user’s access \nIt is also about creating and sharing data across a user session.\nusually include session handling features in their security plugins but not FastAPI.\nCreating user \nsessions and storing session data are two separate programming concerns in FastAPI.\nto establish a user session and Starlette’s SessionMiddleware to create and retrieve session data.\nCreating user sessions and storing session data are two entirely different programming solutions in \nWe use JWT to establish a user session and Starlette’s SessionMiddleware to create \nand retrieve session data.\nCreating user sessions\napplications in Chapter 7, Securing the REST APIs. However, here, the JWT is applied to create a session \nimplemented to create a user session for an authenticated user.\nuser sessions utilizing the browser cookies.\nfrom util.auth_session import secret_key\nIf the user is a certified one, it will use a JWT to create a \nTo ensure that session has been applied, all subsequent requests must undergo authentication by the \ncookie-based session through the APIKeyCookie class, an API class of the fastapi.security \nThe following dependable function in util/auth_session.py \nasync def get_current_user(session: str = \nThe preceding function is injected into every API endpoint to impose user session verification.\nWhen an endpoint is requested, this function will decode the token and extract the username \nfrom util.auth_session import get_current_user\nManaging session data\nUnfortunately, adding and retrieving session data is not part of APIKeyCookie-based session \nThe JWT payload must only include the username but not all credentials and body of data.\nTo manage session data, we need to create a separate session using Starlette’s SessionMiddleware.\nmiddleware parameter of the FastAPI constructor and add to that List-type parameter the built-in \nfrom starlette.middleware.sessions import SessionMiddleware\nAnother way of adding middleware is to utilize the add_middleware() function of the FastAPI \nInitially, adding SessionMiddleware will create another cookie-based session that \nwill handle session-scoped data.\nregarding session handling mechanisms where a user session is created not only for security but also \nTo add session data to our newly created session, session_vars, we need to inject Request into \neach endpoint service and utilize its session dictionary to store the session-scoped objects.\nrestaurant names, and shares the list of names across the session through request.session[]:\nasync def list_restaurants(request: Request, \nasync def list_restaurant_names(request: Request, \nsession data through request.session[] and returns it as its response.\nall the sessions created.\nSince the easiest and most direct way of creating sessions is through browser \nThe delete_cookie() method of the Response class removes any existing browser session \nThe default approach in managing FastAPI sessions is through cookies, and it does not offer any other \nbased strategies for managing user sessions and session data is to customize BaseHTTPMiddleware.\nThe following custom middleware is a prototype that creates user sessions for authenticated users:\nasync def dispatch(self, request: Request, call_next):\nsess_record['session_key'] = \nsess_record['session_name'] = \nawait repo_session.\na filter for all requests and responses of the applications.\nAfterward, endpoints can validate all their requests from the session stored in the database.\nAnother type of middleware that can help FastAPI applications resolve issues regarding the CORS \nThis time, we used FastAPI’s add_middleware() function to add CORS support to our application.\nBy the way, it is not only the middleware that we can subclass and use to create custom implementations \nof but also the Request data and API routes.\nMiddleware can process incoming Request data and outgoing Response objects of all API \nmethods in a FastAPI application, except that it cannot manipulate the message body, attach state \nobjects from the Request data, or modify the response object before the client consumes it.\nManaging body, form, or JSON data\nUnlike in middleware, customizing APIRoute does not apply to all the API endpoints.\nwhile the other services can pursue the default request and response process.\nfollowing customization is responsible for data extraction that only applies to the endpoints of api.\nfrom fastapi import Request, Response\nasync def custom_route_handler(request: Request) \nand processes each type of incoming request data separately.\nasync def body(self):\nself.session[\"user_details\"] = user_details\nasync def json(self):\nThere are three methods of choice to override when managing various request bodies:\n•\t body(): This manages incoming request data that is in bytes\n•\t json(): This manages incoming parsed JSON data\nAll of these methods return the original request body in bytes back to the service.\nfilter and process all incoming requests of the API endpoints defined in the /api/route_extract.\nThe following create_profile() service accepts profile data from the client and implements \nasync def create_profile(req: Request, \nuser_details = req.session[\"user_details\"]\nasync def set_ratings(req: Request, data : \nAnd lastly, the preceding compute_data() service will have an incoming list of ratings as \n@router.post(\"/rating/data/list\")\nasync def compute_data(req: Request, data: List[float], \nThe following custom request decrypts an encrypted body \nasync def body(self):\nself.state.dec_data = json.loads(\nDecryptRequest will decrypt the message and return the list of login records as a request state \nThe following service provides the encrypted message body and key and returns the decrypted \nasync def send_decrypt_login(enc_data: EncLoginReq, \nencrypted message body and the encryption key from the client.\ntransactions, especially those API endpoints that require heavy loads on message body conversions, ",
      "keywords": [
        "Celery",
        "session",
        "coroutine API service",
        "request",
        "data",
        "API",
        "async def",
        "task",
        "Celery task",
        "user",
        "API service",
        "Celery instance",
        "Kafka",
        "Observable",
        "session data"
      ],
      "concepts": [
        "tasks",
        "message",
        "messaging",
        "data",
        "returns",
        "request",
        "requests",
        "important",
        "importance",
        "creating"
      ],
      "similar_chapters": [
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 10,
          "title": "",
          "score": 0.566,
          "base_score": 0.416,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 11,
          "title": "",
          "score": 0.554,
          "base_score": 0.404,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 5,
          "title": "",
          "score": 0.469,
          "base_score": 0.469,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 1,
          "title": "",
          "score": 0.469,
          "base_score": 0.319,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 3,
          "title": "",
          "score": 0.405,
          "base_score": 0.255,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "session",
          "celery",
          "kafka",
          "message",
          "request"
        ],
        "semantic": [],
        "merged": [
          "session",
          "celery",
          "kafka",
          "message",
          "request"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.36980781187162715,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:22.900779+00:00"
      }
    },
    {
      "chapter_number": 10,
      "title": "Solving Numerical, Symbolic, and Graphical Problems",
      "start_page": 325,
      "end_page": 360,
      "summary": "The FastAPI framework offers other options for rendering API endpoint responses other than the \nHere is a list of some of the response types supported by \n•\t The API endpoints can utilize the PlainTextResponse type if their response is text-based \nThe following intro_list_restaurants() service returns a text-based message \ndef intro_list_restaurants():\nreturn PlainTextResponse(content=\"The Restaurants\")\n•\t Services can use RedirectResponse if they need to pursue navigation to another entirely \n•\t A FileResponse type can help services render some content of a file, preferably text-based \nThe following load_questions() service shows the list of questions saved in the \nasync def load_questions(user: str = \n•\t StreamingResponse is another response type that can provide us with another approach to \nasync def list_questions(req:Request, \n•\t Services that render images can also use the StreamingResponse type.\nThe following service reads a file inside the application named sample.mp4 and \nasync def signup(engine=Depends(create_db_engine), \n•\t If the API endpoints have other rendition types needed to be published, the Response \nconverts JSON data into XML content by setting the media_type property of Response \nconvert_to_xml(engine=Depends(create_db_engine), \nreturn Response(content=xml_str, \nAlthough FastAPI is not a web framework, it can support Jinja2 templating for rare cases where API \nservices require rendering their response as an HTML page.\nLet us highlight how API services utilize \nJinja2 templates as part of the response.\nFirst, we need to install the jinja2 module using pip: \nThen, we need to create a folder that will hold all the Jinja2 templates.\nusually named templates, by creating the Jinja2Templates instance in FastAPI or any \nThe following snippet is part of the /api/login.py router that shows the setup \nfrom fastapi.templating import Jinja2Templates\nAfter the templates folder, the Jinja2 engine requires the application to have a folder named \nFor the FastAPI components to access these static files, the engine needs the aiofiles \nThe following template is the base or parent template for the application that can now access the \nBootstrap resources from the static folder due to the template engine and aiofiles module:\nusers.html that generates a table of profiles from the context data:\n{% for login in data %} \nFor the API to render the templates, the service must use the Jinja2 engine’s TemplateResponse \nThe following is the API service that renders the previous \n@router.get(\"/login/html/list\")\nasync def list_login_html(req: Request,\nresult = await repo.get_all_login()\nreturn templates.TemplateResponse(\"users.html\", \nhumongous listing of dictionary objects into a JSON string as a response.\nUUID, numpy, data classes, and datetime objects faster than the common JSONResponse.\nThe following are the two API services that use these two fast alternatives for a JSON serializer:\n@router.get(\"/login/list/all\")\nasync def list_all_login(engine=Depends(create_db_engine), \nresult = await repo.get_all_login()\nreturn ORJSONResponse(content=jsonable_encoder(result),\nasync def get_login(id:int, \nresult = await repo.get_login_id(id)\nthe result into str before the two responses pursue their serialization processes.\non how we provide internal API documentation using the OpenAPI 3.0 specification.\nthat can describe the API services without knowing its sources, reading its documentation, and \ngenerate the default internal documentation of the API based on OpenAPI standards.\nThere are three ways to document our API services using the specification:\n•\t By using the Query, Body, Form, and Path functions\nFastAPI has a get_openapi() method from its fastapi.openapi.utils extension that \ndetails of the OpenAPI schema definition of the application.\nThe default OpenAPI schema documentation is always set up in the main.py module because it is \ndef update_api_schema():\nDOC_TITLE = \"The Online Restaurant Rating System API\"\nreturn openapi_schema\nthe API implementation, and routes contains a list of registered API services.\nline before the return statement updates FastAPI’s built-in openapi_schema defaults.\ntogether with the update on the documentation of each registered API service.\nincludeAPI service's description and summary, the POST endpoint's description of its requestBody \nand GET endpoint's details about its parameters, and the API tags.\nopenapi_schema[\"paths\"][\"/ch09/login/authenticate\"][\"post\"]\nopenapi_schema[\"paths\"][\"/ch09/login/authenticate\"][\"post\"]\nopenapi_schema[\"paths\"][\"/ch09/login/authenticate\"][\"post\"]\nopenapi_schema[\"paths\"][\"/ch09/login/add\"][\"post\"]\n[\"description\"] = \"Adding Login User\"\nopenapi_schema[\"paths\"][\"/ch09/login/add\"][\"post\"]\n[\"summary\"] = \"This is an API adds new user.\"\nopenapi_schema[\"paths\"][\"/ch09/login/add\"][\"post\"]\nopenapi_schema[\"paths\"][\"/ch09/login/add\"][\"post\"]\nopenapi_schema[\"paths\"][\"/ch09/login/profile/add\"]\n[\"description\"] = \"Updating Login User\"\nopenapi_schema[\"paths\"][\"/ch09/login/profile/add\"]\n[\"post\"][\"summary\"] = \"This is an API updating existing user \nopenapi_schema[\"paths\"][\"/ch09/login/profile/add\"]\nopenapi_schema[\"paths\"][\"/ch09/login/profile/add\"]\nopenapi_schema[\"paths\"][\"/ch09/login/html/list\"][\"get\"]\nopenapi_schema[\"paths\"][\"/ch09/login/html/list\"][\"get\"]\n[\"summary\"] = \"Uses Jinja2 template engine for rendition.\"\nopenapi_schema[\"paths\"][\"/ch09/login/html/list\"][\"get\"][\"tags\"] \nopenapi_schema[\"paths\"][\"/ch09/login/list/all\"][\"get\"]\n[\"description\"] = \"List all the login records.\"\nopenapi_schema[\"paths\"][\"/ch09/login/list/all\"][\"get\"]\nopenapi_schema[\"paths\"][\"/ch09/login/list/all\"][\"get\"][\"tags\"] \nTags are essential variables of the OpenAPI documentation because they organize the API endpoints \nOnce all the updates have been set, replace FastAPI’s openapi() function with the new update_\napi_schema() function.\non the title, description, version, and servers details of the OpenAPI documentation:\n\"description\": \"Testing Server\",\nWhen adding documentation to the API endpoints, the path operators of FastAPI and APIRouter \nfollowing is a sample service that updates its summary, description, response_description, \nand other response details through the post() path operator:\nsummary=\"This API adds new restaurant details.\",\nresponse_description=\"The message body.\",\nfunctions can also be used to add some metadata to the API endpoints.\n@router.post(\"/login/authenticate\")\nasync def authenticate(response: Response, \nThe following get_login() uses the Path() directive to insert a description of the id parameter:\n@router.get(\"/login/account/{id}\")\nasync def get_login(id:int = Path(..., \nasync def create_profile(req: Request, \nreturn {'profile' : user_details}\nMoreover, it is also possible to document all types of HTTP responses or status codes that the API \nservice can throw through the path operator’s responses parameter.\nfrom models.documentation.response import Error500Model\n@router.get(\"/restaurant/upload/video\",responses={\nFigure 9.4 – The documentation for API responses\nTesting the API endpoints\nFastAPI uses the pytest framework to run its test classes.\nSo, before we create our test classes, first, \nFastAPI has a module called fastapi.testclient where all components are Request-based, \nTo access all the API endpoints, we need the TestClient \nBut first, we need to create a folder such as test, which will contain test modules where we \nWe place our test methods outside main.py or the router modules to \nTesting the API endpoints\nIt is a best practice to write one test module per router component, except for cases where there is a \npursue the automated testing, we need to import the APIRouter instance or the FastAPI instance \ninto the test module to set up TestClient.\nrequests, when it comes to the helper methods used to consume APIs. The method names of the test cases must start with a test_ prefix, which is a pytest requirement.\ntest method in test/test_restaurants.py that checks whether the endpoint returns the \nfrom api import restaurant\nclient = TestClient(restaurant.router)\ndef test_restaurant_index():\nassert response.text == \"The Restaurants\"\npost(), put(), and delete() the status code and response body of the API.\nrestaurant_index(), for instance, uses the get() method of the TestClient API to run /\nrestaurant/index GET service and extract its response.\nso the test module is router-based.\nTesting API endpoints with dependencies is not as straightforward as the previous example.\ndependencies, we need to use the FastAPI instance to set up TestClient.\nbe unit tested if the routers are part of the FastAPI configuration through include_router():\nfrom models.data.orrs import Login\nreturn Login(**{\"username\": \"sjctrags\", \nThe /rating/top/three API from the /api/route_extract.py router requires a dict \nhave JSON and data parameters, where we can pass test data to the API.\nTesting the API endpoints\nRunning the test method will result in some APIKeyCookie exceptions due to the dependency \nfollowing test case, we are performing a unit test in /ch09/login/list/all, which needs \nMongoDB connectivity to access the list of login profiles.\nFor the test to work, we need to create a \ntest_list_login() test, which implements this database mocking:\nreturn Login(**{\"username\": \"sjctrags\", \"login_id\": 101,\napp.dependency_overrides[create_db_engine] = db_connect\ndef test_list_login():\nresponse = client.get(\"/ch09/login/list/all\")\ncompile and run all TestClient apps in the test folder, thus running all the test methods.\nAPI endpoints gave us a clear understanding of the potential of FastAPI to create cutting-edge and \nAlso, this chapter introduced different API responses supported \ncovered in the previous chapters, such as symbolic computations using sympy, solving linear systems \nprovides FastAPI implementations that highlight important topics of this chapter, such as creating \ncreating workflow templates, and utilizing a graph database.\nThe PCCS project has two versions: ch10-relational, which uses a PostgreSQL database with \nPiccolo ORM as the data mapper, and ch10-mongo, which saves data as MongoDB documents \nch10-relational uses a fast Piccolo ORM that can support both sync and async CRUD transactions.\nBut before creating the project, we need to install the piccolo module \nAfterward, install the piccolo-admin module, which provides helper classes for the GUI \nNow, we can create a project inside a newly created root project folder by running piccolo asgi \nNow, we can add Piccolo applications inside the project by running the piccolo app new \nwe execute the CLI command to create a Piccolo application:\nto the project by running the piccolo app new command inside the project folder, as shown \nA Piccolo application contains the ORM models, BaseModel, services, \nrepository classes, and API methods.\nEach application has an auto-generated piccolo_app.py \nmodule where we need to configure an APP_CONFIG variable to register all the ORM details.\nfollowing is the configuration of our project’s survey application:\nFor the ORM platform to recognize the new Piccolo application, its piccolo_app.py must be \nadded to APP_REGISTRY of the main project’s piccolo_conf.py module.\ncontent of the piccolo_conf.py file of our ch10-piccolo project:\nThe piccolo_conf.py file is also the module where we establish the PostgreSQL database \nCreating the data models\nLike in Django ORM, Piccolo ORM has migration commands to generate the database tables based \nBut first, we need to create model classes by utilizing its Table API class.\ndata model classes that comprise our database pccs:\nclass Login(Table):\nAfter creating the model classes, we can update the database by creating the migrations files.\nmigrations new <app_name> command to generate files in the piccolo_migrations \nfiles and auto-generate the migration script containing the newly reflected schema updates.\nthe newly created migration file first before running the piccolo migrations forward \ntables in the database based on the model classes.\nfrom typing import Dict, List, Any\nLike Peewee, Piccolo’s model classes can persist records, as shown by insert_respondent(), which \nThe remaining Peewee-like DELETE and UPDATE respondent transactions are created in the project’s \nIt uses mathematical equations or expressions formulated using symbolic variables to solve \nTo perform symbolic computation in Python, you must install the sympy module \nOne way of implementing the FastAPI endpoint that performs symbolic computation is to create \nBefore converting a string equation into a sympy expression, we need to define the x and y variables \nneeded Symbols() objects, we can convert our equation into sympy expressions by using any of \n•\t sympify(): This uses eval() to convert the string equation into a valid sympy expression \nIts resulting object must be converted into str format for Response to render the \nThe sympy module allows you to implement services that solve multivariate systems of linear equations.\nThe following API service highlights an implementation that accepts two bivariate linear models in \nasync def solve_linear_bivar_eqns(eqn1:str, \nThe solve_linear_bivar_eqns() service accepts two bivariate linear equations and their \nthe x and y variables as sympy objects and then uses the parser_expr() method to transform \nThen, the API service passes all these linear equations to the solve() method to derive the x and y \nAside from the solve() method, the API also uses the Poly() utility to create a polynomial object \nasync def solve_nonlinear_bivar_eqns(eqn1:str, sol1: int, \nThe sympy module supports solving solutions for both linear and non-linear inequalities but on \nThe following is an API service that accepts a univariate string expression \nasync def solve_univar_inequality(eqn:str, sol:int):\nfirst, we need to convert the str expression into a Symbols() object using the parser_expr() \nMost applications designed and developed for mathematical modeling and data science use sympy \nto create complex mathematical models symbolically, plot data directly from the sympy equation, or \nWhen numerical algorithms require some arrays to store data, a module called NumPy, short for \nNumerical Python, is a good resource for utility functions, objects, and classes that are used to create, \nBut before we start our NumPy-FastAPI service implementation, we need to install the numpy module \nOur first API service will process some survey data and return it in ndarray form.\nget_respondent_answers() API retrieves a list of survey data from PostgreSQL through \nPiccolo and transforms the list of data into an ndarray:\nasync def get_respondent_answers(qid:int):\nserializers and de-serializers to convert ndarray into JSON data.\nEven though numpy has data types \nAside from NumPy, pandas is another popular module that’s used in data analysis, manipulation, \nBut to use pandas, we need to install NumPy, followed by the pandas, \nThe following API service shows how the product between a scalar gradient and an array \nof survey data is derived using the numpy module:\nfollowing API service retrieves all survey results from all survey locations and creates a DataFrame \nThe DataFrame object has a to_json() utility method, which returns a JSON object with an \nThe scipy module uses numpy as its base module, which is why installing scipy requires numpy \nWe can use the pip command to install the module:\nOur application uses the module to derive the declarative statistics of the survey data.\nget_respondent_answers_stats() API service computes the mean, variance, skewness, ",
      "keywords": [
        "API",
        "API service",
        "API endpoints",
        "Login",
        "data",
        "OpenAPI",
        "Advanced Features",
        "Piccolo",
        "async def",
        "user",
        "list",
        "Piccolo ORM",
        "Depends",
        "response",
        "engine"
      ],
      "concepts": [
        "data",
        "services",
        "important",
        "responses",
        "tested",
        "api",
        "apis",
        "fastapi",
        "routers",
        "user"
      ],
      "similar_chapters": [
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 11,
          "title": "",
          "score": 0.709,
          "base_score": 0.559,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 3,
          "title": "",
          "score": 0.637,
          "base_score": 0.487,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 1,
          "title": "",
          "score": 0.618,
          "base_score": 0.468,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 9,
          "title": "",
          "score": 0.566,
          "base_score": 0.416,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 5,
          "title": "",
          "score": 0.528,
          "base_score": 0.528,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "ch09 login",
          "openapi_schema",
          "test",
          "ch09",
          "piccolo"
        ],
        "semantic": [],
        "merged": [
          "ch09 login",
          "openapi_schema",
          "test",
          "ch09",
          "piccolo"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4833031945953401,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:22.900792+00:00"
      }
    },
    {
      "chapter_number": 11,
      "title": "Adding Other Microservice Features",
      "start_page": 361,
      "end_page": 420,
      "summary": "Our API sample also uses additional utilities such as the chain() method from itertools to \nNow, let us explore how to save data to CSV and XLSX files using the \nThe DataFrame object has built-in to_csv() and to_excel() methods that save its data in \nBut the main goal is to create an API service that will return these \nThe following implementation shows how a FastAPI service can return a CSV file \nfrom fastapi.responses import StreamingResponse\nfrom survey.repository.respondent import \nasync def create_respondent_report_csv():\nWe need to create a dict() containing columns of data from the repository to create a DataFrame \nAfter creating the DataFrame object, invoke the to_csv() method to convert its columnar dataset \nThis module has a Workbook class, which \ncreates a workbook containing worksheets where we can plot all column data per row.\nAPI service uses this module to render XLSX content:\nasync def create_respondent_report_xlsx():\nThe given create_respondent_report_xlsx() service retrieves all the respondent records \nfrom the database and plots each profile record per row in the worksheet from the newly created \nThe pandas module can also help FastAPI services read CSV and XLSX files for rendition or data \nIt has a read_csv() that reads data from a CSV file and converts it into JSON content.\nfollowing service retrieves the content of a valid CSV file and returns JSON data:\nasync def upload_csv(file: UploadFile = File(...)):\nThere are two ways to handle multipart file uploads in FastAPI:\n•\t Use bytes to contain the file\nThus, the given read-csv() service uses UploadFile to capture any CSV files for data analysis \nThe following service reads a CSV file using read_csv() and serializes it into HTML \nthat can help FastAPI render various content types, including to_latex(), to_excel(), \nNow, let us explore how FastAPI services can plot charts and graphs and output their graphical result \nWith the help of the numpy and pandas modules, FastAPI services can generate and render different \nutilize an io.ByteIO stream and StreamResponse to generate graphical results for the API \nThe following API service retrieves survey data from the repository, computes the mean \nThe plot_answers_mean() service utilizes the plot() method of the matplotlib module \nto plot the app’s mean survey results per location on a line graph.\nfilesystem, the service stores the image in the io.ByteIO stream using the module’s savefig() \nThe other API services of our app, such as plot_sparse_data(), create a bar chart image in \ncreates a pie chart that shows the percentage of male and female respondents that were surveyed:\nThe responses generated by the plot_sparse_data() and plot_pie_gender() services \nThis section will introduce an approach to creating API endpoints that produce graphical results using \ncan create in less time using numpy, pandas, matplotlib, and the FastAPI framework.\nGraphQL, and Neo4j graph database transactions and how FastAPI can utilize them.\nAlthough the FastAPI framework has no built-in utilities to support its workflows, it is flexible and \nThe ch10-mongo project has implemented the following BPMN workflow design using Celery:\n•\t A sequence of service tasks that derives the percentage of the survey data result, as shown in \n•\t A group of batch operations that saves data to CSV and XLSX files, as shown in the \nFigure 10.6 – Data archiving workflow design\n•\t A group of chained tasks that operates on each location's data independently, as shown in the \nFigure 10.7 – Workflow design for stratified survey data analysis\nCelery’s chain() method implements a workflow of linked task executions, as depicted in Figure 10.5, \nis the API service in /api/survey_workflow.py that implements the chained workflow:\n.s(survey_dict['results']).set(queue='default'), \ncompute_avg_results.s(len(survey_dict))\nprefers bound tasks when applying workflow primitive signatures to create workflows.\nThe following API shows the \n.s(survey_dict['results']).set(queue='default'), \nsave_result_csv.s(len(survey_dict))\n.s(survey['results']).set(queue='default'), \ndiscussed in Chapter 7, Securing the REST APIs, apply_async() triggers the whole workflow \nAside from workflows, the FastAPI framework can also use the GraphQL platform to build CRUD \nGraphQL is an API standard that implements REST and CRUD transactions at the same time.\nhigh-performing platform that’s used in building REST API endpoints that only need a few steps to \nIts objective is to create endpoints for data manipulation and query transactions.\nThis chapter introduces the use of the new Ariadne 3.x to build CRUD transactions for \nFirst, we need to install the latest graphene extension using the pip command:\nIt easily integrates with the FastAPI framework without requiring additional middleware \nCreating the record insertion, update, and deletion\nfeature that modifies the server-side state of the application and returns arbitrary data as a sign of a \nCreateLoginData is a mutation that adds a new login record to the data store.\nThis method will also call the ORM, which will persist the newly created record.\nAfter a successful insert transaction, mutate() must return the class variables defined inside a \nThe following is a mutation class that updates the password field of a login \nSimilarly, the delete mutation class retrieves a record through an id and deletes it from the data store:\nresult = await repo.delete_login(id)\ncreate_login = CreateLoginData.Field()\nImplementing the query transactions\nGraphQL query transactions are implementations of the ObjectType base class.\nRunning the CRUD transactions\nquery classes for the FastAPI framework before running the GraphQL transactions.\nAfterward, we use the schema instance to create the GraphQLApp() instance.\nequivalent to an application that needs mounting to the FastAPI framework.\nutility of FastAPI to integrate the GraphQLApp() instance with its URL pattern and the chosen \nGraphQL browser tool to run the API transactions.\nGraphQL applications with Playground as the browser tool to run the APIs:\napp = FastAPI()\napp.mount(\"/ch10/graphql/login\", \nname of the CreateLoginData mutation, which is create_login, along with passing the \nFigure 10.8 – Running the create_login mutation\nTo perform query transactions, we must create a JSON script with a field name of LoginQuery, \nshows how to run the LoginQuery transaction:\nFigure 10.9 – Running the get_login query transaction\nare mounted to create a single façade application.\nNow, let us integrate FastAPI into a graph database.\nFor an application that requires storage that emphasizes relationships among data records, a graph \nFastAPI can easily integrate with Neo4j, but we need to install the Neo4j module using the \nNeo4j is a NoSQL database with a flexible and powerful data model that can manage and connect \nThe following script shows how to create Neo4j database connectivity:\nCreating the CRUD transactions\nThe following API service adds a new database record to the graph database:\ndef create_survey_loc(node_name: str, \nquery = f\"CREATE ({node_name}:Location  \n\"add node location successful\"}, status_code=201)\nreturn JSONResponse(content={\"message\": \"add node \ncreate_survey_loc() adds new survey location details to the Neo4j database.\nconsidered a node in the graph database with a name and attributes equivalent to the record fields in \nWe use the connection object to create a session that has a run() method \nThe command to add a new node is CREATE, while the syntax to update, delete, and retrieve nodes \nThe following update_node_loc() service searches for \na particular node based on the node’s name and performs the SET command to update the given fields:\nasync def update_node_loc(id:int, \nSET location += {node_attributes}\"\"\"\nLikewise, the delete transaction uses the MATCH command to search for the node to be deleted.\nfollowing service implements Location node deletion:\nWhen retrieving nodes, the following service retrieves all the nodes from the database:\nasync def list_all_nodes():\nresult = session.run(query=query)\nnodes = result.data()\nThe following service only retrieves a single node based on the node’s id:\nresult = session.run(query=query)\nnodes = result.data()\nOur implementation will not be complete if we have no API endpoint that will link nodes based on \nThe following API endpoint creates a node relationship between the Location \nThe FastAPI framework can easily integrate into any database platform.\nproven that FastAPI can deal with relational database transactions with ORM and document-based \nThis chapter introduced the scientific side of FastAPI by showing that API services can provide \nintegrate FastAPI with new technology and design strategies to provide new ideas for the microservice \narchitecture, such as using GraphQL to manage CRUD transactions and Neo4j for real-time and \nnode-based data management.\nflexibility of the framework in building microservice applications.\nThe next chapter will cover the last set of topics to complete our deep dive into FastAPI.\nsome deployment strategies, Django and Flask integrations, and other microservice design patterns \nOur long journey of exploring FastAPI’s extensibility in building microservice applications will \nThe service registry and client-side discovery design \npatterns are included likewise in the detailed discussions on how to manage access to the API endpoints \nFastAPI application’s deployment, which might lead to other design strategies and network setups.\nThe main goal of this chapter is to complete the design architecture of a FastAPI application before its \nHere are the topics that will complete our FastAPI application development venture:\n•\t Setting up service registry and client-side service discovery\n•\t Deploying and running applications using Docker\n•\t Integrating Django and Flask sub-applications\nThe application \ncom/PacktPublishing/Building-Python-Microservices-with-FastAPI under \nLet us start with the proper way of setting up the development environment of our FastAPI \napplication.\nIn Python development, it is common to manage the libraries and extension modules \nA virtual environment is a way of creating multiple \napplication(s) to be compiled and run.\nrequirements of its application(s).\n•\t To avoid broken installed module files due to namespace collisions\napplications are very dependent\n•\t To create a template or baseline copy of the set of modules to be replicated on some \nAfter the installation, we need to run the python -m virtualenv command to create an instance.\nFigure 11.1 shows how the ch01-env virtual environment for the ch01 project is created:\nFigure 11.1 – Creating a Python virtual environment\nTo use the virtual environment, we need to configure our VS Code editor to utilize the Python \ninterpreter of the virtual environment instead of the global interpreter to install modules, compile, \nand run the application.\ndifferent set of installed module dependencies, as shown in Figure 11.5:\nFigure 11.5 – Creating multiple virtual environments\nPython microservice application.\ndeployment of the application in terms of identifying what modules to install in the cloud servers.\nHowever, before we discuss FastAPI deployment approaches, first, let us discuss what microservice \nPrometheus is a popular monitoring total that can monitor and check API services in any microservice \napplication.\napplications, first, we need to install the following module:\nThe following script shows the application setup with the Prometheus \napp = FastAPI()\nThe data in Figure 11.6 displays the time duration, in seconds, used by each API in processing requests, \nproviding response to clients, and emitting the status code of each API transaction.\nAnother way of monitoring a FastAPI microservice application is by adding an open tracing tool.\nprototype, we will be using the Jaeger tool to manage the application’s API traces and logs.\nThe current way to integrate an OpenTracing tool into FastAPI microservices is through the OpenTelemetry \nthe tracing service, OpenTelemetry has an OpenTelemetry Jaeger Thrift Exporter utility, which allows \nyou to export traces to the Jaeger client applications.\nBut first, we need to install the following \nAfterward, add the following configuration to the main.py file:\nfrom opentelemetry.instrumentation.fastapi import \napp = FastAPI()\nThe first step in the preceding setup is to create a tracing service with a name using OpenTelemetry’s \ndetails to manage all of the traces and logs using a Jaeger client.\nabout the exchange of requests and responses among all API services and other components across \nwithin an application.\nAfter the completed Jaeger tracer setup, we integrate the tracer client with FastAPI through \nTo utilize this class, first, we need to install the following extension:\npip install opentelemetry-instrumentation-fastapi\nBefore we can run our application, first, we need to download a Jaeger client from \nFigure 11.7 – Monitoring microservices through a Jaeger client\nsports-tracer, after running our microservice application.\nand monitored, thus creating traces and visual analyses regarding all requests and response transactions \nFigure 11.8 shows the traces and graphical plots generated by Jaeger:\nFigure 11.8 – Searching the traces of every API transaction\nSetting up service registry and client-side service discovery\ntrace for the /ch11/login/list/all endpoint, as shown in Figure 11.8, can provide us with \nAside from the traces shown in Figure 11.9, the Jaeger client can also collect the uvicorn logs through \nNow, let us add the service registry and client-side service discovery mechanisms to our application.\nSetting up service registry and client-side service \nA service registry tool such as Netflix Eureka enables the registration of microservice applications \nThis service registration is helpful to microservice applications deployed to servers with \nFor FastAPI, we need to utilize the py_eureka_client \nmodule to implement the service discovery design pattern.\nImplementing client-side service discovery\nCreating a FastAPI microservice application to discover and register to a service registry server such \nFirst, we need to install py_eureka_client through pip:\nthe client instance must have the appropriate app_name parameter for the FastAPI microservice \napplication (or client app), with the instance_port parameter set to 8000 and the instance_\napp = FastAPI()\ncreate_async_db() \nSetting up service registry and client-side service discovery\nThe client discovery happens in the startup event of the application.\nThe EurekaClient component class can handle asynchronous or synchronous FastAPI \nNow, let us build our Netflix Eureka server registry before running \nSetting up the Netflix Eureka service registry\nLet us utilize the Spring Boot platform to create our Eureka server.\nWe can create an application through \napplication.\nIn this case, application.properties must have server.port set to 8761, server.\nNow, run the Eureka Server application before the FastAPI client application.\nFigure 11.10 – Discovering the FastAPI microservice application\nThe result of the client-side service discovery is also evident on the Eureka server’s dashboard at \nFigure 11.11 – Creating the service registry\nOur SPORTS_SERVICE being part of the Eureka server registry, as depicted in Figure 11.11, means \nwe successfully implemented the client-side service discovery design pattern, and it is time to deploy \nour application to a Docker container.\nDeploying and running applications using Docker\nDockerization is a process of packaging, deploying, and running applications using Docker \nContainerizing FastAPI microservices saves installation and setup time, space, and \nThis chapter mainly focuses on how to run CLI commands rather than the Docker Hub GUI \nNow, let us generate the list of modules to be installed in the docker image.\nSince we are using a virtual environment instance for module management, it is easy to identify what \nextension modules to install in the Docker image.\nWe can run the following command to generate a \ncomplete list of modules and their versions to the requirements.txt file:\nThen, we can create a command to copy this file to the image through the Dockerfile.\nDeploying and running applications using Docker\nCreating the Docker image \nThe next step is to build a container image from any available Linux-based container images in Docker \nPython image from Docker Hub, creating a working directory, and copying project files from the \nThe following is a Dockerfile set of instructions we use to deploy our prototype \nThe command after that creates an arbitrary folder, /code, which \ntxt file to the /code folder, and then the RUN instruction installs the updated modules from the \nrequirements.txt list using the following command:\nAfterward, the second COPY command copies our ch11 application to the working directory.\napplication.\nFigure 11.12 shows the organization of the files and folders that needed to be Dockerized \nFigure 11.12 – Setting up the Docker folder structure\nOnce all the files and folders are complete, we run the following CLI command within the folder \ndocker build -t ch11-app .\nTo check the image, run the docker image ls CLI command.\nThe backend of our application is MongoDB, so we need to pull the latest mongo image from Docker \nAnd before we run both the ch11-app application and the mongo:latest images, first, we need \nto create a ch11-network by running the following command:\ndocker network create ch11-network\nThis network becomes a bridge between mongo and ch11-app once they are deployed as containers.\nCreating the containers\nA container is a running instance of a container image.\nWe use the docker run command to start \nand run a pulled or created image.\nSo, running the Mongo image using the ch11-network routes \nInspect the mongo:latest container using the docker inspect command to derive and use its \nwhich is found in the config/db.py module of ch11-app with the “inspected” IP address.\nsure to re-build the ch11-app Docker image after the update.\nNow, run the ch11-app image with ch11-network using the following command:\ndocker run --name=ch11-app --rm -p 8000:8000-\nAccess the application through http://localhost:8000/docs to check all the API endpoints \nHowever, you need to install the Docker Compose utility in your operating system, which requires \nAfter the installation, the next step is to create the \ndocker-decompose.yaml file containing all the services needed to build the images, process the \nDockerfile, build the Docker network, and create and run the containers.\nthe content of our configuration file that sets up the mongo and ch11-app containers: \nInstead of running separate Docker CLI commands, Docker Compose creates services, such as ch11-\nmongo and ch11-app, to manage the containerization and only uses one CLI command to execute \nThe command not only creates the network of images but \nthe IP address of the mongo container varies for every instance created.\ndef create_async_db():\nNow, let us implement an API Gateway design pattern for the containerized applications using the \nIn Chapter 4, Building the Microservice Application, we implemented the API Gateway design pattern \nIPs will redirect client requests to the actual microservices running on their respective containers.\nIP address to the actual container address of each microservice application.\nIntegrating Flask and Django sub-applications\nThe Dockerization of NGINX must come after deploying applications to the containers.\nOr we can create another service in the docker-decompose.yaml file to \nbuild and run the NGINX image.\nAnd for the last time, let us explore the power of FastAPI in its integration with other popular Python \nIntegrating Flask and Django sub-applications\napplies the scaffolding of files and folders to build projects and applications.\nDjango applications can \nWe can create, deploy, and run Flask and Django projects inside a FastAPI microservice application.\nThe framework has WSGIMiddleware to wrap both Flask and Django applications and integrate \nRunning the FastAPI application through uvicorn will also run both \napplications.\nOf the two, it is easier to integrate the Flask application with a project than Django.\nimport the Flask app object into the main.py file, wrap it with WSGIMiddleware, and mount \nit into the FastAPI app object.\nAll API endpoints implemented in ch11_flask will be accessed using the URL prefix, /ch11/\nFigure 11.13 shows the location of ch11_flask \nFigure 11.13 – Creating a Flask application inside the FastAPI project\nOn the other hand, the following main.py script integrates our ch11_django application into \nos.environ.setdefault(‘DJANGO_SETTINGS_MODULE’, \ndjango_app = get_wsgi_application()\napp = FastAPI()\nIntegrating Flask and Django sub-applications\nThe Django framework has a get_wsgi_application() method that is uses to retrieve its \nFastAPI app object.\nMoreover, we need to load the settings.py module of the ch11_django \nAll views and endpoints created by the sports application of the ch11_django project must be \ndjango project within the ch11 app:\nFigure 11.14 – Creating a Django project and application inside a FastAPI object\nThe last chapter has given us the avenue on how to start, deploy, and run a FastAPI microservice application \ncontrol and manage the installation of modules from the start of the development until the deployment \nof our applications to Docker containers.\nto package, deploy, and run containerized applications.\nNGINX reverse proxy server for the application to build the API Gateway for our specimen.\nframework, from creating background processes to rendering data using HTML templates.\nAPI services\napplication deployment, with Docker\ncontainers, creating  374\nDocker image, creating  373\napplication settings\ncreating  334, 335\nasync CRUD transactions, creating with Motor\ncreating  183-185\nCRUD transactions, running  185, 186\nmodel layer, creating  183\nasync CRUD transactions, implementing \nBase class, creating  125\nCRUD transactions, running  129, 130\nmodel layer, creating  125\ncreating  261\nmultiple tasks, creating  263\nasync repository, for FastAPI\nasync transactions implementation, \ndatabase connectivity, creating  195, 196\nrepository transactions, running  200\ncreating  41, 42\nasync transactions, implementing with  195\ncreating  264-269\ncreating  266\ncreating  82\nused, for creating Observable  278-280\ncommand and query classes, \ncreating  156, 157\ncreating  157, 158\nCRUD transactions, creating \ndatabase connection, creating  206\nmodel layer, creating  207, 208\nrepository layer, creating  208-210\nCRUD transactions, creating \nJOIN queries, creating  119, 120\ntransactions, running  120-122\nCRUD transactions, running  194, 195\ncreating  334, 335\nFastAPI integration  71, 72\nDjango applications\nFastAPI\nCRUD transactions, running  138, 139\nCRUD transactions, running  353-355\nquery transactions, implementing  353\naccess_token, creating  228\nlogin transaction, creating  229, 230\nFastAPI integration  74\ncreating  94\nCRUD transactions, creating with  206\nasync CRUD transactions, creating with  182\nCRUD transactions, creating  356-360\ncreating, with coroutines  278-280\nCRUD transactions, running  205, 206\ndatabase connection, creating  201\nmodel layer, creating  201, 202\nusers, creating  242\nCRUD transactions, running  155\ndatabase connection, creating  149, 150\ndomain layer, creating  150-153\ndata models, creating  329, 330\nrepository transactions, running  148\ntransactions, running  179-182\nCelery instance, creating  269\nObservable, creating with coroutines  278\ncreating  231\nlogin transaction, implementing  233, 234\nCRUD transactions, creating  110, 116-118\ncreating  80, 81\ncreating  331, 332\nBuilding Python Web APIs with FastAPI\n•\t Set up a FastAPI application that is fully functional and secure\n•\t Manage concurrency in FastAPI applications\n•\t Implement authentication in a FastAPI application\n•\t Deploy a FastAPI application to any platform\n•\t Implement best practices for building reliable, performant, and secure web apps\n•\t Create effective solutions for the modern web, including task management, bot integration, \nNow you’ve finished Building Python Microservices with FastAPI, we’d love to hear your thoughts!",
      "keywords": [
        "CRUD transactions",
        "FastAPI microservice application",
        "API",
        "FastAPI",
        "application",
        "creating",
        "Docker",
        "service",
        "async CRUD transactions",
        "microservice application",
        "API services",
        "transactions",
        "data",
        "CRUD",
        "node"
      ],
      "concepts": [
        "create",
        "creating",
        "implementation",
        "implement",
        "implementations",
        "importing",
        "important",
        "module",
        "data",
        "applying"
      ],
      "similar_chapters": [
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 10,
          "title": "",
          "score": 0.709,
          "base_score": 0.559,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 1,
          "title": "",
          "score": 0.624,
          "base_score": 0.474,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 9,
          "title": "",
          "score": 0.554,
          "base_score": 0.404,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 3,
          "title": "",
          "score": 0.526,
          "base_score": 0.376,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 5,
          "title": "",
          "score": 0.481,
          "base_score": 0.481,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "docker",
          "creating",
          "ch11",
          "11",
          "service"
        ],
        "semantic": [],
        "merged": [
          "docker",
          "creating",
          "ch11",
          "11",
          "service"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.44849088547787436,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:22.900804+00:00"
      }
    }
  ],
  "total_chapters": 10,
  "enrichment_provenance": {
    "taxonomy_id": "none",
    "taxonomy_version": "none",
    "taxonomy_path": "none",
    "taxonomy_checksum": "sha256:none",
    "source_metadata_file": "Building Python Microservices with FastAPI_metadata.json",
    "enrichment_date": "2025-12-17T23:01:22.903726+00:00",
    "enrichment_method": "msep",
    "model_version": "ai-agents-msep-v1",
    "processing_time_ms": 3283.0701259990747,
    "total_similar_chapters": 49
  }
}