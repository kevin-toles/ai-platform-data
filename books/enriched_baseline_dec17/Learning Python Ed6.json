{
  "metadata": {
    "title": "Learning Python Ed6",
    "source_file": "Learning Python Ed6_metadata.json"
  },
  "chapters": [
    {
      "chapter_number": 1,
      "title": "A Python Q&A Session",
      "start_page": 1,
      "end_page": 44,
      "summary": "Python\nLearning Python\nLearning Python\nPython is one of the most widely used programming languages in the\nThis book is a tutorial that teaches Python language fundamentals in\nThis edition updates this book for a decade of changes in Python and its\ntools added to Python through version 3.12, and applies to other\nPythons past and future.\nPython\nBy most metrics you’ll find on the web today, Python is now either the most-\nAs this edition is being written in 2024, it lists Python at #1\ndynamically typed scripting languages, Python ushered in changes that were at\nwithout tools like Python.\nbecause this is now a post-revolution Python world, this edition does much less\nThis edition still summarizes Python’s\nSecond, Python’s popularity means that by reading this book, you’ll be adding a\nLearning Python will both make entire domains accessible to you\nPython itself, after all, is just a C\nEven so, Python is a great place to start, and enough for many a task.\ntoday, a multitude of developers still find Python a lot more fun to use than other\nPython, in sharp\nThis book is a tutorial on the Python language and a classic in its domain.\nback to the mid-1990s, when Python was still at version 1.X, and the web was\nIt’s also worth noting up front that this book sometimes critiques Python changes\nOn some levels, Python remains a constantly morphing\nworth of Python changes for yourself in whatever world you’ve been cast.\nThis edition completely drops coverage of Python 2.X, the earlier version of the\nlanguage, and adds new coverage of recent changes in Python 3.X, the newer and\nWhen the prior edition was published in 2013, Python 2.X\nPython learners.\nFormally, this edition has been updated to be current with Python 3.12 and its\nThe former is an optional and academic tool wholly unused by Python\nsacked because you’ve bought this book to learn Python, not an author’s\non Python and programming.\nSecond, Python error messages are often shortened in this book to conserve\nspeculative “Did you..?” help in the latest Python that might be useful for\npromoters, who made Python what it is today; and the subject of this book’s\nA Python Q&A Session\nIf you’re reading this book, you may already know what Python is and why it’s\nWhy Do People Use Python?\npeople use Python today, there really is no way to answer this question with\nFor many, Python’s focus on readability, coherence, and software quality in\nPython code is\nThe uniformity of Python code makes\nPython has deep support for more advanced software reuse mechanisms,\nPython boosts developer productivity many times beyond compiled or\nAs one measure of this, Python code is typically\nPython programs also run immediately, without the lengthy compile and link\nPython programs generally run unchanged on all major computer platforms.\nPorting a Python program between Linux and Windows, for example, is\nMoreover, Python\nportable in Python as they can possibly be.\nAs covered ahead, Python’s third-party\nPython scripts can communicate with other parts of an application using a\nSuch integrations allow Python to be used\nFor instance, Python code can\nIn fact, many Python core tools, including files, ultimately use\nprecoded interfaces to system libraries; even if your program is all Python,\nBecause of Python’s ease of use and built-in toolset, it can make the act of\npaid for coding Python, but many use it just for fun—a testimonial rare in the\nIn practice, Python programmers do not need to constantly refer\nMoreover, Python usually doesn’t make\nBeyond such design themes, Python includes tools such as modules and object-\nAnd because Python is focused on\nadvantage when it’s time to use someone else’s Python code.\nIn both of these scenarios, Python has shined as a tool that allows programmers\nThe net effect is that Python typically increases developer productivity many\nIs Python a “Scripting Language”?\nPython is often applied in scripting roles, but not always.\nscope of today’s Python.\nNevertheless, the term scripting seems to have stuck to Python like glue, perhaps\nsome people use the word “script” instead of “program” to describe a Python\nmultifile application, both of which are common in Python.\nPython labeled as such, some of which are more useful than others:\nSometimes when people hear Python described as a scripting language, they\nthink it means that Python is a tool for coding operating-system-oriented\nAs you’ll learn ahead, Python programs can and do serve such roles, but this\nis just one of dozens of common Python application domains.\nAs noted earlier, Python programs are\ntest hardware devices, Python programs may call out to components that give\nPython code at strategic points to support end-user product customization\nPython’s simplicity makes it a naturally flexible control tool.\nthough, this is also just a common Python role; many (and perhaps most)\nPython programmers code standalone scripts without ever using or knowing\nthe term is applied to Python, which allows much faster program\nPython has an\nSo, is Python a scripting language or not?\nthe rapid and flexible mode of development that Python supports, rather than a\nOn a related note, people also sometimes call Python an interpreted language to\nof Python today, spanning the spectrum from traditional interpreters to\nbe that Python is dynamically typed, not statically typed like languages that are\nthat Python brings to development tasks.\nuse: Python’s execution speed may not always be as fast as that of fully compiled\nused versions of Python today compile (i.e., translate) source code statements to\nbecause Python is not commonly compiled all the way down to binary machine\nprograms will run more slowly in Python than in a fully compiled language like\nwhenever you do something “real” in a Python script, like processing a file or\ninside the Python interpreter.\ncoded in Python nevertheless.\nallows you to code in a C-and-Python hybrid that’s compiled in full; and crucial\ncode can be split off to compiled extensions linked into Python for use in scripts.\nand optimized libraries with the Python language, and in the process turns\nPython into a numeric programming tool that is simultaneously efficient and\nIndeed, NumPy Python code regularly achieves speed parity with\nPython’s speed-of-development gain is often far more\nNaturally, Python has other potential\nWho Uses Python Today?\nBecause Python is a free and open source software (FOSS) tool, an accurate\nIn general, though, Python enjoys a very large user base and an active developer\nBecause Python has been broadly used for over three decades,\nand known companies using Python today reads like a who’s who of the\nMore broadly, Python is deployed by most organizations developing software\nup to date than a book can ever be, try the following pages at Python’s site:\nWhat Can I Do with Python?\nCommercial applications may be compelling, but people also use Python for all\nIn fact, as a general-purpose language, Python’s roles are virtually unlimited:\nsections survey some of Python’s most common application domains today, as\nlength topics on their own, and our goal in this book is to learn the Python code\nPython\nPython’s standard library comes with Portable Operating System Interface\nIn addition, the bulk of Python’s system interfaces are designed to be\nFor instance, Python comes with a\ntkinter in code), which allows Python programs to implement portable GUIs\nPython/Tkinter GUIs run unchanged on Windows,\nmost, must interact with users, Python has multiple ways to write once and run\nPython comes with standard internet modules that allow programs to perform a\ndoing internet programming in Python.\nof full-featured and production-quality websites with Python.\nPython’s ability to be\nFor instance, integrating a C library into Python allows Python to\ntest and launch the library’s tools, and embedding Python in a product enables\nneeded to link compiled components with Python scripts, and the Cython system\nallows coders to mix Python and C-like code to create compiled extensions.\nmost software components are in scope to Python code.\nFor traditional database demands, there are Python interfaces to all commonly\nThe Python world has also defined a portable\ndatabase API for accessing SQL database systems from Python scripts, which\nprogram-storage needs, Python comes with built-in support for its own pickle\nTo Python programs, components written in Python and C look the same.\nBecause of this, it’s possible to prototype systems in Python initially, and then\ncompiled language can remain coded in Python for ease of maintenance and use.\nhas grown to become one of Python’s most compelling use cases.\nhere, the NumPy high-performance numeric-programming extension for Python\nBy integrating Python with\nnumeric routines coded in a compiled language for speed, NumPy turns Python\nand ahead-of-time (AOT) compilers for Python numeric code, respectively; and\nPython is commonly applied in far more domains and with far more tools than\nthat many are largely just instances of Python’s component integration role in\ncompiled language like C makes Python useful for scripting in a wide variety of\nAs a general-purpose language that supports integration, Python is\nWhat Are Python’s Technical Strengths?\nPython is an object-oriented language, from the ground up.\nunderstand these terms, you’ll find they are much easier to learn with Python\nMuch like C++, Python supports\n(class-based) paradigms, Python today has built-in support for functional\nPython is completely free to use and distribute.\nPython comes with complete source code, it empowers developers in ways that\nThe standard implementation of Python is\nFor example, Python programs run today on\nAs a partial list, Python is\nLike the language itself, the standard-library modules that ship with Python are\nFurthermore, Python programs are automatically compiled to portable bytecode,\nwhich runs the same on any platform with a compatible version of Python\nportable user interfaces in Python with traditional GUIs and web-based options\nThis means that programs that use the Python language, its standard libraries,\nand portable extensions run the same on most systems that host a Python\nPython provides all\nscripting languages, this combination makes Python useful for large-scale\nin Python’s toolbox:\nPython keeps track of the kinds of objects your program uses when it runs,\nBecause Python code does not constrain data types, it is\nAs you’ll learn, Python keeps track of\nFor building larger systems, Python includes tools such as modules, classes,\nPython’s functional programming tools, described earlier, meet\nTo process all those object types, Python comes with powerful and standard\nFor more specific tasks, Python also comes with a large collection of\nPython’s library tools are where much of the application-level action occurs.\nBecause Python is open source, developers are encouraged to contribute\nmuch more (see “What Can I Do with Python?”).\nDespite the array of tools in Python, it retains a noticeably simple syntax and\nAs noted earlier, Python programs can easily be “glued” to components written\nmeans you can add functionality to the Python system as needed and use Python\nMixing Python into systems coded in more demanding languages, for instance,\nmay be coded in Python first for development speed and later moved to\nCompared to alternatives like C++, Java, and C#, Python programming seems\nTo run Python code in most contexts,\nPython executes programs\neliminates much of the complexity of its contemporaries, Python programs are\nWhich is not to say that Python makes programming a no-brainer.\nPython also\nother widely used programming languages, the core Python language is\nyou can expect to be coding small-scale Python programs in a matter of days—\nmaster Python is worthwhile: in the end, you’ll gain programming skills that\nPython’s learning curve to be much gentler than that of other programming tools,\nenough Python to use the system with little or no support.\nMoreover, Python has\nAlthough Python has\nexplored some of the reasons that people pick Python for their programming\nThis book’s goal is to teach Python, though, not to sell it.\nthem, you’ll study ways to run Python programs, peek at Python’s execution\neach part of the book, designed to help you start coding Python on your own,\n1. What are the six main reasons that people choose to use Python?\n3. Why might you not want to use Python in an application?\n4. What can you do with Python?\nchoose to use Python, but enjoyment counts, too, in a field that can be\n3. Python’s main downside is performance: in its currently most-common\nand typical Python code runs at close to C speed anyhow because it\n4. You can use Python for nearly anything you can do with a computer,\nHow Python Runs\nhow Python runs it.\nIn this chapter, we’ll begin by studying how the Python\ntwo chapters may not apply to the ways you’ll be using Python, so you should\nthe rest of us, let’s take a brief look at the way that Python will run our code,\nIntroducing the Python Interpreter\nSo far, we’ve mostly been talking about Python as a programming language.\nWhen you write a Python program, the Python interpreter reads your program\nDepending on how you use it, the Python\nDepending on which flavor of Python you run, the\nWhatever form it takes, the Python code you write must always\nAnd to enable that, you usually must install a Python\nYou don’t need to install Python at this point unless you want to work along with\nPython ready to go until the next chapter.\nWhen you’re ready, Python installation\nWhat it means to run a Python script depends on whether you look at this task as\na programmer, or as a Python interpreter.\nperspectives on Python programming.\nIn its simplest but most common form, a Python program is just a text file\ncontaining Python statements.\nup, but it passes for a fully functional Python program.\nThis file contains two Python print statements, which simply print a string (the\nso easily in Python, in its later chapters.\nBy convention, Python program files are given\nAfter you’ve typed these statements into a text file, you must tell Python to\nlaunch Python program files by typing command lines, by clicking their icons,\nFor our purposes here, we’ve just run a Python script that prints a string\nPython’s View\nlanguages, and it’s usually all that most new Python programmers need to know.\nprogramming, having a basic understanding of Python’s runtime structure up\nWhen you instruct Python to run your script, there are a few steps that Python\nPython first compiles your source code (the statements in your text file) into a\nIf the Python program has write access on your machine, it will save\nPython saves its bytecode files in a subdirectory named __pycache__ located in\nbytecode files prevents different Python versions installed on the same computer\nPython programs and is free to vary among the alternative Python\nIn short, Python saves bytecode like this as a startup-\nThe next time you run your program, Python will load the\naren’t running with a different Python than the one that created the bytecode.\nPython versions\nPython also adds a version-information suffix to bytecode filenames to know\nwhen it must recompile—if you run your program on a different Python\nPython too.\nThe result is that both source code changes and differing Python versions will\nIf Python cannot write the bytecode\nBytecode files are also one way to ship Python\nSee Python’s compileall module to\nThat is, the PVM is the runtime engine in Python.\npresent as part of the Python system, is the component that truly runs your\ncompilation is automatic, and the PVM is just part of the Python system that you\nof statements, and Python handles the logistics of running them behind the\nPython’s traditional execution model: the PVM runs compiled bytecode\nis usually no build or “make” step in Python work: code runs immediately after\nFor another, Python bytecode is not binary machine code (e.g.,\nThese differences explain why some Python code may not run as fast as C or\nThe net effect is that pure Python code runs at\nAnother ramification of Python’s execution model is that there is really no\ntraditional compiled languages, but in Python, the compiler is always present at\noften very convenient, for Python programs to construct and execute other\nPython programs at runtime.\nand run strings containing Python program code.\nPython lends itself to product customization—because Python code can be\nAt a more fundamental level, keep in mind that all we really have in Python is\nexecution in more static languages, but happen during execution in Python.\nWHY DOES PYTHON USE BYTECODE?\nThe short answer is that Python uses bytecode for the sake of\nPython instead defines an easy-to-use language that’s too far removed from\nimplementations you’ll meet ahead do compile some Python code to\nmachine code, and Python is quick enough for many roles even with its\nPython today and is not a requirement of the Python language itself.\nPython Implementation Alternatives",
      "keywords": [
        "Python",
        "Python programs",
        "Python code",
        "Python code runs",
        "Python language",
        "Python program files",
        "Python today",
        "Python interpreter",
        "code",
        "Python program code",
        "book",
        "Python programs run",
        "Python system",
        "run Python code",
        "Python users"
      ],
      "concepts": [
        "python",
        "programming",
        "program",
        "code",
        "coded",
        "development",
        "tools",
        "languages",
        "useful",
        "uses"
      ],
      "similar_chapters": [
        {
          "book": "Learning Python Ed6",
          "chapter": 2,
          "title": "",
          "score": 0.698,
          "base_score": 0.698,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 3,
          "title": "",
          "score": 0.622,
          "base_score": 0.472,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 10,
          "title": "",
          "score": 0.501,
          "base_score": 0.501,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 4,
          "title": "",
          "score": 0.484,
          "base_score": 0.484,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 9,
          "title": "",
          "score": 0.438,
          "base_score": 0.438,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "language",
          "python programs",
          "compiled",
          "programming",
          "bytecode"
        ],
        "semantic": [],
        "merged": [
          "language",
          "python programs",
          "compiled",
          "programming",
          "bytecode"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4963068781451286,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:10.090531+00:00"
      }
    },
    {
      "chapter_number": 2,
      "title": "How Python Runs Programs",
      "start_page": 45,
      "end_page": 76,
      "summary": "help demystify what it means to run code in general.\nIt’s the usual Python on PCs and\nmay or may not implement the full Python language defined by CPython, but\nThis is the Python that you fetch from\nJython: Python for Java\nThe Jython system is an alternative implementation of the Python language.\nclasses that compile Python source code to Java bytecode, which is then\nProgrammers still code Python\nPython 2.X not used in this book but is working toward 3.X. IronPython: Python for .NET\nIronPython is another alternative implementation of Python.\nis designed to allow Python programs to integrate with applications written\nWith it, Python code can gain accessibility both to and from\nsystems to employ a just-in-time (JIT) compiler for normal Python code.\nPython programs may also take up less memory under PyPy. Numba: a JIT compiler for numeric speed\nThe Numba extension for Python adds a JIT compiler that optimizes\nPython code can be sped up by Numba, it works well for code that uses\nPython code to C++ code, which is then compiled to machine code before it\nPyThran implements another AOT compiler for a subset of the Python\ntranslates Python code to C++, using static type declarations provided in\nused by other Python code.\nPython code with the ability to call C functions and use C type declarations\ncompiled to C code that uses the Python/C API, which may then be compiled\nof its standard library, in order to optimize Python to run in constrained\nsupport Python programs in web browsers without the full heft of CPython.\noptimizing AOT compiler that translates standard Python code to C, and is\nused by the emerging py2wasm to translate Python code to WebAssembly for\npossible to turn your Python programs into true self-contained executables,\ncalled, these programs can be run without requiring a Python installation or\nalong with the PVM (interpreter) and any Python support files and libraries your\nBecause Python is embedded in the\nof the current implementation of Python, not of the language itself.\nPython source code to machine code may appear during the shelf life of this\nspirit of Python coding we’re about to explore.\nPython’s type hinting, also\nway to machine code as your program is running.\nPython programs.\nThis chapter introduced the execution model of Python—how Python runs your\nprograms run once you start coding them, as you will in the next chapter.\n1. What is the Python interpreter?\n6. Name two or more variations on Python’s standard execution model.\n1. The Python interpreter is a program that runs the Python programs you\n3. Bytecode is the lower-level form of your program after Python compiles\nPython automatically stores bytecode in files with a .pyc extension\nprogram ultimately runs, Python code must be translated to this by a\nIn addition, the alternative implementations of Python\nJython and IronPython process Python programs for use in Java and\nPython.\nPyPy speeds normal Python programs by using runtime type\ninformation and a JIT compiler to replace some Python bytecode with\nmachine code as the program runs.\nwhich it can be fully compiled to machine code to be run as a program\nOK, it’s time to start running some code.\nPython’s purpose and execution model, you’re finally ready to start some real\nPython programming.\nThere are multiple ways to tell Python to execute the code you type, and this\nAlong the way, you’ll learn both how to run code interactively, and how to save\nit in files to be run using a variety of techniques—with command lines, icon\nlook at module imports—a topic essential to understanding Python’s program\nInstalling Python\nPython installation is not required for\nthis book, and isn’t necessary in some contexts, but you’ll need a Python to work\nWindows and macOS users fetch and run a self-installing executable file\nAndroid and iOS users install an app that allows them to run Python\nUnix (and some Linux) users often compile Python from its full source\nFor example, smartphone users fetch a Python app at an app store, and Windows\nPython coding modes covered ahead, such as Jupyter notebooks, have unique\ncontexts, but this book uses Python 3.12, so closer to that is better.\nBefore you install, you should generally check to see if Python is already\nrunning a Python command line as described both in Appendix A and this\nlearning the many ways to run Python code.\nThis section gets us started with the basics of interactive Python coding.\nit’s our first look at running code, we also cover some startup logistics here, such\nBy most measures, the simplest way to run Python code is to type it at Python’s\nAssuming Python is\nneutral way to start an interactive interpreter session is to simply type a Python\nDespite this scheme’s generality, both the Python command you’ll type and\n$ python3\n$ python\nThis book uses python3 in platform-neutral\nWindows, instead use py (or py -3 to ensure Python 3.X); python3 works on\nTyping a Python command at your system prompt like this begins an interactive\nPython session (i.e., REPL).\nPython being used (e.g., “3.12.3” is Python 3.12) and the platform it’s running\nand Android in Python 3.12), followed by a line with tips for more info.\nPython command is generic, but exactly how you access it varies by platform.\nAnywhere you see the >>> prompt, though, you’re in an interactive Python\nsession and REPL—you can type any Python statement or expression here and\nWhere to Run: Code Folders\nNow that you’re starting to learn how to run code, you’ll also need to know\nwhere to run code.\nYou can save and run code anywhere you can make files, but\nbook runs all its code in a folder nested in the user account (or “home”)\nbook will implicitly be run in a per-chapter subfolder of a dedicated code\npackage to avoid typing code or copying from emedia, simply run its examples\nstarted and where script files will be run.\nsystem’s file explorer, or run a command line: mkdir folder works on\na GUI like IDLE, opening and running a file may go to its folder.\nlines in interpreter interaction listings and used by this book to denote code run\nPython’s standard REPL displays automatically as visual guides for interactive\nsystem and Python prompts are meant to be run immediately and are not\nOther Python REPLs\nexample, provides an alternative, separately installed, and enhanced Python\n(it’s sys.ps1 to your code, and can be set in a startup file, per Python docs).\nAll of which means that your Python interactive session may differ from the\ninteractive Python code into a web browser, GUI, or app instead of the system\nscientific work, which is just one of many Python roles.\nRunning Code Interactively\ncode.\nHowever it’s started, the Python interactive session begins by printing\nwith >>> (or similar) when it’s waiting for you to type a new Python statement or\nresults of two Python print statements:\n$ python3\nThere it is—we’ve just run some Python code (it’s not much, but it proves the\nyou’re working; because it’s a function call in Python, the parentheses in this\nWhen coding interactively like this, you can type as many Python commands as\n>>> language = 'Python'\n'Python'\nIn fact, much like system $ and Python >>>\nNow, we didn’t do much in this session’s code—just typed some Python print\ncreate a source code file, and no need to run the code through a compiler and\nStrictly speaking, interactive code is compiled to bytecode in memory and run\n(and are ignored) in code files, but are needed to let some REPLs know your\nruns just one statement at a time—don’t paste large code blocks at its prompt!\nThe interactive prompt runs code and echoes results as you go, but it doesn’t\nsave your code in a file.\nhow a piece of Python code works, fire up the interactive command line and try\nFor instance, suppose you’re reading a Python program’s code and you come\nweb to try to figure out what the code does, or you can simply run it\n$ python3\nStraight Python code, though, is\nYou can import your module files interactively and run tests on the tools\nPython files, type calls to linked-in C functions, exercise Java classes under\nPartly because of its interactive nature, Python supports an\nAlthough Python programmers also test with in-file code (and you’ll learn ways\nbig disadvantage: programs you type there go away as soon as the Python\nBecause the code you type interactively is never\nsession, you would have to edit out Python prompts, program outputs, and so on\nTo save programs permanently, you need to write your code in files, which are\nModules are simply text files containing Python\nOnce they are coded, you can ask the Python interpreter to execute\nRegardless of how it is run, Python executes all the code in a module\nWhatever you call them, the next few sections explore ways to run code typed\nportable way: by listing their names in a Python command line entered at your\n# A first Python script\nThis file is our first official Python script (not counting the two-liner in\nImports a Python module (libraries of additional tools) to fetch the\nyou’re working on; it lives in a Python module called sys (part of its standard\nFor color, this file adds some Python comments—the text after the # characters.\nAgain, don’t focus on the syntax of the code in this file for now; you’ll learn\nfunctional Python script.\n(i.e., files run directly), it could also be named simply script1, but files of code\nsuffixes for most Python files that you code.\nexplorers detect Python files by their .py suffix; if the suffix is not present, you\nRunning Files with Command Lines\nOnce you’ve saved the preceding section’s text file, you can ask Python to run it\nthis at a Python REPL prompt, and read on to the next paragraph if this doesn’t\n$ python3 script1.py\n(e.g., use py instead of python3 on Windows, usually), and you can type such a\nYou might also run this code file with a dedicated run\nBe sure to run your Python command in the same working directory where\nprompt, not Python’s >>> prompt.\nreplace the command’s first word with a full directory path if Python isn’t on\nAppendix A for more on Python installs and PATH).\nIf all works as planned, this shell command (or similar) makes Python run the\ncode in this file line by line, and you will see the output of the script’s three\nWhen you type a command to run a Python code file, the command you type is\nprinted output of a Python script to a file to save it for later use or inspection, by\nIt also has little to do with Python,\nof Python itself.\ncommand, for example, will automatically be run by Python on Windows\n(technically, by Python’s py Windows launcher described in Appendix A):\nFor example, the py Python\ncommand in the following, run in PowerShell on Windows, assumes Python is in\nPS D:\\temp\\savecode> py C:\\Users\\me\\code\\script1.py    # Run a script elsewhere\n$ /usr/local/bin/python3 /Users/me/code/script1.py > /Users/me/data/saveit.py\nPython scripts with file icon clicks, development GUIs, and other schemes that\nportable, and powerful way to run code.\nWhile the Python\nOn most PC platforms, Python program files can be run by simply clicking or\nup during Python’s install.\nClicks also run code files on macOS in Finder, if\nthe Python Launcher app when available work the same as clicks.\nfirst line to name Python.\nfile in an associated Python app, but this may work only for some explorer/app\nSo far, we’ve seen how to run Python code with interactive sessions, system\nvisual, IDLE provides a GUI for Python programming, and it’s a standard and\nfree part of the Python system.\nIn short, IDLE lets you edit, run, browse, and debug Python programs, all from\nBecause it’s coded in Python with the tkinter GUI toolkit, it\nruns portably on all Python PC platforms—Windows, macOS, and Linux.\nnewcomers to get started editing and running code.\nIn brief, it’s standard with the python.org Python installers for\nTip: because IDLE is just a Python script on the module search path in the\ndirectory by typing the following Python command in a system console window\n(use py instead of python3 on Windows, as usual).\n$ python3 -m idlelib.idle         # Find and run idle.py in a package folder\na file of code.\nEdit windows’ Run→Run Module runs code in the window where it’s\nOther IDEs for Python\nBecause IDLE is free, portable, and a standard part of Python, it’s a nice first\nStill, you may wish to file this away for later in your Python career when you’ve\nIn others, though, you’ll launch code files with devices in the app’s user\nmuch different in spirit from running code in IDLE or other IDEs, but because\nAlthough an emerging technology, it’s also possible to run Python code in web\nportable bytecode format that is run by web browsers, much as the Python PVM\nBy compiling the Python interpreter’s\nweb browsers are able to run Python, and hence your Python programs.\nPython beginners), but the Pyodide system has already done most of the work\nrun many Python programs in web browsers, with no local installs required.\ncompiled CPython interpreter to run a Python script in a browser is not quick,\nand the speed of Python scripts in this context may vary.\ncomes with a fixed set of Python tools, and Python scripts run by browsers live\nfor Python on the web, it’s not as useful for general software development as\nsmaller than CPython but implements a constrained Python subset per Chapter 2,\nand the py2wasm Python-to-Wasm compiler, announced just as this book was\nthat allow Python code to be run in web browsers, with a focus on supporting\nseparately installed and launched to run the code you enter in a web page, but it\nusage details if Jupyter notebooks may be a part of your Python coding future.\nShed Skin, compile Python programs all the way to machine code, much like C\nfile of Python code first, and then run the resulting program like any other\nadvantage of using Python.\nRunning Code in Code",
      "keywords": [
        "Python",
        "Python code",
        "run Python code",
        "code",
        "Python programs",
        "Python command",
        "run Python",
        "Python code file",
        "run",
        "file",
        "Python source code",
        "Python language",
        "Debugging Python Code",
        "Python command line",
        "Python REPL prompt"
      ],
      "concepts": [
        "python",
        "coded",
        "coding",
        "programs",
        "programming",
        "files",
        "runs",
        "running",
        "likely",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "Learning Python Ed6",
          "chapter": 1,
          "title": "",
          "score": 0.698,
          "base_score": 0.698,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 3,
          "title": "",
          "score": 0.541,
          "base_score": 0.541,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 10,
          "title": "",
          "score": 0.495,
          "base_score": 0.495,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 4,
          "title": "",
          "score": 0.494,
          "base_score": 0.494,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 9,
          "title": "",
          "score": 0.424,
          "base_score": 0.424,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "python code",
          "command",
          "run python",
          "python command",
          "file"
        ],
        "semantic": [],
        "merged": [
          "python code",
          "command",
          "run python",
          "python command",
          "file"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4750795496695203,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:06:10.090585+00:00"
      }
    },
    {
      "chapter_number": 3,
      "title": "How You Run Programs",
      "start_page": 77,
      "end_page": 108,
      "summary": "Like imports, the Python exec built-in can be used to launch files in code too,\nand tools in standard-library modules let you launch programs with command\nImporting modules\nIn simple terms, every file of Python source code whose name ends in a .py\nNo special code or syntax is required to make a file a\nmodule: any such file will do.\nOther files can access the items a module defines\nin Python.\nLarger programs usually take the form of multiple module files,\nwhich import tools from other module files.\nchapter is mostly interested in the fact that import operations run the code in a\nBecause of this, importing a file is yet\nsystem command line or otherwise), you can run the script1.py file we wrote\nearlier in Example 3-1 with a simple import statement—which is really Python\ncode running other Python code:\n$ python3\nWhere to run imports: Be sure to run this Python command in the directory (i.e., folder)\nsave module files and run imports in a per-chapter folder for the chapter you’re working in.\nLater in this book, you’ll learn that imports in a REPL search for a module in the current\nImports work to run a file, but only once per session (really, process—a program\nchange and save the module’s source file again in another window:\nonce per file in a given program run.\nfind files, compile them to bytecode, and run the code line by line, and importers\nIf you really want to force Python to run the file again in the same session\n<module 'script1' from '/Users/me/Code/script1.py'>\nThis allows you to edit and use new code on the fly in the current Python\nmodule object, so you have to have successfully imported a module before you\nNotice that reload also expects parentheses around the module object name,\ncall’s return value, a Python module object.\nattributes—variable names that are attached to a specific object (like a module).\nIn more concrete terms, all the names assigned at the top level of a module’s file\nExternally, a module file’s names can be fetched with two Python\nTo illustrate, use a text editor to create a one-line Python module file called\nThis may be one of the world’s simplest Python modules (it contains a single\nimported, its code is run to generate the module’s attribute.\nassignment statement creates a variable and module attribute named title.\nFirst, you can load the module as a whole with an import\n$ python3                          # Start Python REPL\n>>> import myfile                  # Run file, load module as a whole\nPython code.\n>>> from myfile import title         # Run file, copy its names\nassignment to names in the importing code.\nThis code file, threenames.py, assigns three variables, and so generates three\n$ python3 threenames.py\nAll of this file’s code also runs as usual the first time it is imported elsewhere, by\nClients of this file that use import get a module with\n$ python3\n>>> import threenames                    # Grab the whole module: it runs here\nFrom a grander perspective, modules form the highest layer of Python program\nrun your code files, though probably a secondary option: due to complicated\nfrom), tools like command lines and IDEs are generally better bets for running\nPython code.\nPython also provides a way to launch files with code that does not rely on the\nand runs whatever Python source code statements are in the string you pass to it.\nBy passing a code file’s loaded contents to exec, though, this yields another way\nto launch code files from a REPL or other file without having to import and later\nEach such exec runs the current version of the code read from a file,\n$ python3\ninside it run first, and left to right, and load the file’s entire contents as a string.\nexec/open combo this way it runs the file’s code anew and unconditionally—as\nthough you had pasted the file’s code at the place where exec is called.\nconsequence, this exec/open scheme does not require module reloads after file\n>>> exec(open('script1.py').read())    # Code run in this namespace by default\nBy contrast, the basic import statement makes the file a separate\nFinally, Python code can also be run by Python code that uses standard-library\n$ python3\n>>> os.system('python3 script1.py')\nThis os module’s popen call does similar but returns a file object from which\nspawning code; and Python’s subprocess.run call can be used to launch\ngetting-started chapter, so consult Python’s library manuals for the full story if\nYou’ve already seen a blizzard of code-launching options for Python, but this\nFor example, Python code can also be run today\nPython code\nText editors that aren’t full IDEs, but know how to run Python code\nExcel spreadsheets, when calculating a sheet’s cells coded in Python\nare just getting started with Python, unless you’ll be working in smartphone apps\nsystem console interface in another for launching edited programs via Python\nIn this chapter, we’ve explored common ways to launch Python programs: by\nrunning code typed interactively and by running code stored in files with system\nThere, we will start exploring the Python\n1. How can you start a Python interactive interpreter session (REPL)?\n2. Where do you type a system command line to launch a script file?\n3. Name four or more ways to run the code saved in a script file.\n1. A Python interactive session can be started by typing a Python\nand python3 everywhere else and type it into a Command Prompt or\n3. Code in a script (really, module) file can be run with system command\nlines, file icon clicks, imports and reloads, the exec built-in function, os\nPython code, some Python programs are provided and run as standalone\nexecutables, and some systems use Python code in embedded mode,\n5. Python imports (i.e., loads) a module only once per process, by default,\nso if you’ve changed its source code and want to run the new version\nwithout stopping and restarting Python, you’ll have to reload it.\nmust import a module at least once before you can reload it.\nfiles of code from a system shell command line, via an icon click, or in\nschemes usually run the current version of the source code file each\nsource code as a top-level script file in IDLE and displays its output\nback in the interactive Python “Shell” window.\nNamespaces help avoid name collisions in Python programs:\nexplicitly import other files in order to use their names.\nthat works on your device, start the Python interactive command line\nto run Python.\nfile containing the single statement print('Hello module world!')\nNow, run this file by using any launch option\nit by command line in a console (e.g., python3 module1.py),\nexecuting it in code with tools like exec and imports/reloads, or by\n3. Modules: Start the Python interactive command line (>>> prompt) and\n(i.e., run Python in the original directory when you import).\n4. Scripts: If your platform supports it, copy your module1.py module file\non Windows, also try running your file by listing just its name in a\nand-drop to the Python Launcher app in Applications (or elsewhere).\nexpressions and assignments at the Python interactive command line\nWhen you’re first starting out, Python’s default error messages on\n6. Breaks and cycles: In any Python REPL, type:\nIn all but the most ancient of Python versions, you’ll see\nWhy do you think your version of Python responds the way\npython.org’s About and Search, for example, may be useful when\nDEBUGGING PYTHON CODE\nBut when you make a mistake in a Python\npinpoints the location of the error in your code by file and line and\nIn many cases, this is debugging in Python.\nProbably the main way that Python\nprogrammers debug their code is to insert print statements and run\nBecause most Python code runs immediately after changes,\nprior point may also use Python’s logging module instead of\nbeginners who want to trace code in more detail, most Python\nFor full control, Python\nmodule in Python’s standard library.\neither importing it and calling pdb.run('code') or running it as a\ntop-level script with the command python3 -m pdb file.py.\nrevisit pdb in Chapter 36, but see Python’s library manual and pdb’s\nUse Python’s –i command-line argument.\nbetween Python and the name of your script (e.g., python3 –i\nscript.py), Python will automatically open its interactive mode\nIntroducing Python\nObjects\nThis chapter begins our tour of the Python language.\nin objects that Python provides, such as strings and lists, or add-on objects we\ncreate with Python classes or external-language tools.\nMoreover, everything is an object in a Python script.\nBecause objects are also the most fundamental notion in Python programming,\nthis chapter gets us started with a survey that previews Python’s built-in object\nprograms can be decomposed into modules, statements, expressions, and objects,\nobjects and the expressions you can code to use them.\nBecause of all this, built-in objects are a\nIn Python, the more strongly unifying principle is objects and what we can do with them.\nWhy Use Built-in Objects?\nBecause Python\nusually no need to code object implementations before you start solving\nBuilt-in objects make programs easy to write.\nYou can get a lot of work done with Python’s built-in\nobject types alone.\ntasks, you may need to provide your own objects using Python classes\nPython’s built-in objects employ algorithms that have\nperformance that built-in object types provide.\nPython borrows both from languages that rely on built-in tools (e.g.,\nunique object types in Python, you don’t need to do so just to get\nIn other words, not only do built-in object types make programming easier,\nRegardless of whether you implement new object types, built-in objects\nform the core of every Python program.\nPython’s Core Object Types\nTable 4-1 previews Python’s built-in objects, and some of the syntax used to\ncode their literals—that is, the expressions that generate these objects.\nand file objects provide an interface for processing real files stored on your\nPython built-in (core) objects\nObject type\n—which you’ll meet in later parts of this book—are objects in Python too; they\nPython also provides a set of implementation-related objects such as\ncompiled-code objects, which are generally of interest to tool builders more than\nPython programs is a kind of object.\nmatching in Python, we create pattern objects, and when we do network\nscripting, we use socket objects.\nare effectively built into the Python language itself—that is, there is specific\nfollowing code with characters surrounded by quotes in a REPL or program file:\n>>> 'Python'\nreturns a new string object.\nThere is Python language syntax to make this object.\nEven though, as you’ll see, Python\ndetermines the types of objects you create and use.\nPython language.\nJust as importantly, once you create an object, you bind its operation set for all\nIn formal terms, this means that Python is dynamically typed, a model that\nobject only operations that are valid for its type.\nquicker look at Python’s core objects in action.\nstarted is to get started, so let’s jump right into some real object-wrangling code.\nIf you’ve done any programming or scripting in the past, some of the object\nPython’s core objects set includes the usual suspects:\nAlthough they offer fancier options, Python’s basic number objects are, well,\nNumbers in Python support the normal mathematical operations.\n$ python3                        # Start up a REPL\nNotice the last result here: Python’s integer object automatically provides extra\nstr and len both work on many object types, and we’ll\n(here, from a Python list coded in square brackets—an ordered collection of\nother objects to be introduced later in this chapter):\njustice to its built-in objects catalog, let’s move on to explore strings.\nset_int_max_str_digits; call this to count digits in larger numbers, and see Python’s docs\ngeneral sequence objects include lists and tuples, covered later.\n>>> S = 'Code'           # Make a 4-character string, and assign it to a name\nIn Python, indexes are coded in square brackets as offsets from the front, so start\non how this works later (especially in Chapter 6), but Python variables never\nwe need to assign an object to a variable in order to save it for later use.\nhardcoded number literal—anywhere that Python expects a value, we can use a\nThis is a general property of Python\naccounts for much of the conciseness and flexibility of Python code.\nobject types aren’t constrained, a Python-coded operation can normally work on\nin Python; you’ll learn more about it later on this tour.\nBecause Python\n>>> S = 'Z' + S[1:]        # But we can run expressions to make new objects\nEvery object in Python is classified as either immutable (unchangeable) or not.\nIn terms of the core objects, numbers, strings, and tuples are immutable; but\nmost new objects you’ll code with classes.\nin Python work, in ways that we can’t yet fully explore.\n>>> S = 'Python'\nis, these operations will work on other sequences in Python as well, including\ntext-processing tools in Python.\nNotice the last command here—it strips before it splits because Python runs it\nStrings methods are also one way to run an advanced substitution operation\n>>> tool  = 'Python'\n'Using Python version 3.12'\n'Using Python version 3.12'\n'Using Python version 3.12'",
      "keywords": [
        "Python",
        "Python code",
        "code",
        "Python code runs",
        "run Python code",
        "module",
        "Python module object",
        "Python module file",
        "objects",
        "file",
        "Python programs",
        "Hack",
        "Debugging Python Code",
        "Python REPL",
        "run"
      ],
      "concepts": [
        "python",
        "object",
        "code",
        "coded",
        "coding",
        "modules",
        "imports",
        "important",
        "file",
        "string"
      ],
      "similar_chapters": [
        {
          "book": "Learning Python Ed6",
          "chapter": 1,
          "title": "",
          "score": 0.622,
          "base_score": 0.472,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 2,
          "title": "",
          "score": 0.541,
          "base_score": 0.541,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 10,
          "title": "",
          "score": 0.387,
          "base_score": 0.387,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 9,
          "title": "",
          "score": 0.385,
          "base_score": 0.385,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 4,
          "title": "",
          "score": 0.353,
          "base_score": 0.353,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "file",
          "module",
          "objects",
          "object",
          "command"
        ],
        "semantic": [],
        "merged": [
          "file",
          "module",
          "objects",
          "object",
          "command"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.39024681882730555,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:10.090600+00:00"
      }
    },
    {
      "chapter_number": 4,
      "title": "Introducing Python Object Types",
      "start_page": 109,
      "end_page": 180,
      "summary": "Although sequence operations are generic, methods are not—while some objects\nshare some method names, string method operations generally work only on\noperations that span multiple object types show up as built-in functions or\nexpressions (e.g., len(X), X[0]), but type-specific operations are method calls\nwill become more natural as you use Python, but the next section gives a few\nsample of what is available for string objects.\nAssuming S is still the string 'Code',\nRun this live for the full list; its middle was cut at …etc… for space here (strings\nthis list are all the callable methods on string objects.\nThe __add__ method of strings, for example,\nis how concatenation ultimately works; Python maps the first of the following to\nhandful of interfaces to a system of code that ships with Python known as Pydoc\nbetter, you need to know either the name of the string type, or that the type\nbuilt-in returns any object’s type as another object: help(str) and\nhelp(type(S)) both give help for strings but may be more than you want—\nOther Ways to Code Strings\nSo far, we’ve looked at the string object’s sequence operations and type-specific\nPython also provides a variety of ways for us to code strings, which\n>>> S = 'A\\0B\\0C'            # \\0, a binary zero byte, does not terminate string\nAs hinted earlier, Python allows strings to be enclosed in single or double quote\nHTML, YAML, or JSON code in a Python script, as well as stubbing out lines of\nPython also supports a raw string literal that turns off the backslash escape\nSuch literals start with the letter r and are useful for strings like\nPython’s strings also come with full Unicode support required for processing\nPython’s string objects let you process such text\n>>> b'a\\x01c'                # bytes strings are byte-based data\nFormally, Python’s byte strings are sequences of 8-bit bytes that print with\ncode points—identifying numbers for characters, which print as the usual glyphs\nb'Code'\nThis is especially true for richer text (ord gives a character’s code point, and hex\nTo code non-ASCII characters in text strings, use \\x hexadecimal escapes; short\ncharacter Ä coded four ways in Python:\nIn text strings, all these forms specify Unicode code points that stand for\nBy contrast, byte strings use only \\x hexadecimal escapes to embed\nform of text, not its decoded code points, and encoded bytes are the same as\ncode points only for simple text and encodings:\nApart from these string types, Unicode processing often reduces to transferring\nstored in a file and decode it to characters (a.k.a. code points) when read back\ntext strings, but binary files instead deal in bytes strings for raw data.\nIn addition to its built-in string objects, Python’s standard toolset includes\nThe Python list object is the most general sequence provided by the language.\nLists are positionally ordered collections of arbitrarily typed objects, and they\nBecause they are sequences, lists support all the sequence operations we\ndiscussed for strings; the only difference is that most of them return lists instead\n>>> L = [123, 'text', 1.23]            # A list of three different-type objects\n>>> len(L)                             # Number of items in the list\nType-Specific Operations\nPython’s lists may be reminiscent of arrays in other languages, but they tend to\nFor one thing, they have no fixed type constraint—the list we\njust looked at, for example, contains three objects of completely different types\n(an integer, a string, and a floating-point number).\n>>> L.append('Py')                     # Growing: add object at end of list\nlist methods also change the list object in place, instead of making a new one:\nAlthough lists have no fixed size, Python still doesn’t allow us to reference items\nchecking as Python).\nRather than silently growing the list in response, Python\nOne nice feature of Python’s core object types is that they support arbitrary\nmatter in this, Python expressions with unclosed brackets can span multiple lines\nthird item within that row (it runs left to right, like the earlier string strip and\nIn addition to sequence operations and list methods, Python includes a more\nadvanced operation known as a list comprehension expression, which turns out\nList comprehensions are a way to build a new list by running an expression on\nwhich produces results on demand per Python’s iteration protocol—in the\nBut to grasp concepts like the iteration protocol and objects like sets and\nUnlike strings and lists, Python dictionaries are not sequences at all but are\nalso collections of other objects, but they store objects by key instead of by\nThe dictionary index operation uses the same syntax as that used for\nway to code a search in Python.\nAs you’ll learn later, we can also make dictionaries by passing to the dict type\nprior example and its equivalent {} literal form; the first requires string keys but\nthe norm until Python 3.7, and prior to this, key order was scrambled and\nPython.\nThis leads to another application of Python’s object nesting in action.\nfollowing dictionary, coded all at once as a literal, captures more-structured\ndictionary keys, not list offsets:\nlanguages, but is natural in Python.\nMore fundamentally, this example demos the flexibility of Python’s core object\ntypes.\nIn Python, this is all automatic—running the expression creates the entire\nlanguages like Python.\nIn Python, this is all automatic: object memory is allotted as needed and\nTechnically speaking, Python uses a scheme called garbage collection that\nIn standard Python (a.k.a. CPython) this uses\nknow that you can use objects freely, while Python handles their memory.\nand 27, where we’ll use it to compare and contrast lists, dictionaries, tuples,\nhere can be saved in a file with a variety of techniques in Python, including its\nstrikingly similar to Python dictionary objects); more on such tools later in this\nDictionary methods also play parts in common key use cases.\nwith a Python if statement.\nEnter key twice to run the if interactively after typing its code (an empty line\n>>> if not 'e' in D:                  # Python's main selection statement\nresult is interpreted as true or false, followed by a block of code to run if the\nFunctionally, the if is the main selection tool in Python, and how we code most\nPython’s syntax rules in depth in later chapters, but in short, if you have more\nnumber of characters you have to type.\n>>> list(D.keys())                     # Keys, values, and key/value pairs\n>>> list(D.values())                   # list forces results genertion\nAs shown, a dictionary’s keys, values, and items methods return its keys,\nthough, these methods all return an object that produces results one at a time,\n>>> D.keys()                           # Get an iterable object\non all sorts of objects in Python, but you can usually forget its details if you use\nthe Python for loop, which runs the iteration protocol automatically to step\nthrough items one at a time—both for physical collections like strings and lists,\nTo code a for, provide a variable (e.g., key) and an iterable object (e.g.,\nD.keys()); for each item in the object, the for assigns the item to the variable\n>>> for (key, value) in D.items():     # Key/value-pair tuples iteration\nand support arbitrary object types, arbitrary nesting, and the usual sequence\noperations that we used on strings and lists earlier:\nAs usual, tuples also have type-specific callable methods, but not nearly as many\nTypeError: 'tuple' object does not support item assignment\nLike lists and dictionaries, tuples support mixed types and nesting, but they don’t\nSo, why have a kind of object that is like a list, but supports fewer operations?\nIf you pass a collection of objects around your program as a list,\nFile objects are the main way your Python code will access the content of files\nFiles are a core object type, but they’re something of an oddball—there\nRather, you create a file object by\nmode string to write text data; Python automatically makes the newline character\nstring in your script, regardless of the type of data the file contains:\n>>> text.split()                   # File content is always a string\nOther file object methods support additional features we don’t have time to\nFor instance, file objects provide more ways of reading and writing\nYou’ll meet the full set of file methods later in this book, but if you want a quick\nPython text files always use a Unicode encoding to encode strings\nAs hinted when we studied Unicode strings earlier, Python draws a sharp\nFor example, binary files are useful for processing media, accessing data created\nPython also supports non-ASCII file names (not just content), but it’s largely\nFor the whole story on Unicode in Python, stay tuned for Chapter 37.\nPython.\nFor more advanced tasks, though, Python comes with additional file-like\ntools: pipes, FIFOs, sockets, keyed-access files, persistent object shelves,\nthem useful once you start programming Python in earnest.\nOther Object Types\nBeyond the core object types we’ve seen so far, there are others that get less\nPython sets are neither mappings nor sequences; rather, they are unordered\nobject just once.\nsequence or other iterable, or by using a set literal expression, and sets support\nPython also comes with Booleans, with predefined True and False objects that\nobjects and designate an absence of a result in functions:\n>>> bool('hack')                    # All objects have a Boolean value\nTypes\nThe type object, returned by the type\nbuilt-in function, is an object that gives the type of another object.\n>>> type(L)                         # The type of a list object\n>>> type(type(L))                   # Even types are objects!\nBesides allowing you to explore your objects interactively, the type object in its\nmost practical application allows code to check the types of the objects it\nIn fact, there are at least three ways to do so in a Python script:\n>>> type(L) == list                 # Using a type name\n>>> isinstance(L, list)             # The object-oriented way\nBut now that this book has shown you all these ways to do type testing, it’s\nstarting to use Python!).\nthe book when we start writing larger code units like functions, but it’s a—and\nBy checking for specific types in your code,\nWithout such checks, your code may be able to work on a whole range of types\nfunctions and classes, in Python, we code to object interfaces (operations\ncaring about specific types means that code can be applied to many of them: any\nobject with a compatible interface will work, regardless of its specific type.\nprobably find that polymorphism is the key to using Python well.\nThat being said, Python has slowly accumulated a type-declaration facility\nextensions, it is possible to name expected object types of function arguments\nand results, attributes in class-based objects, and even simple variables in Python\ncode, and these hints may be used by external type checkers like mypy:\nImportantly, though, Python type hinting is meant only for documentation and\nThe Python language does not itself mandate or use type\nTo be sure, type hinting does not mean that Python is no longer dynamically\ntyped.\nIndeed, a statically typed Python that requires type declarations would not\nbe a Python at all!\nregrettably code Python type hints anyhow as a hard-to-break habit (or\nAs you’ll find, it’s how to code Python in Python.\nWe won’t study object-oriented programming (OOP) in Python and its class\ntypes of objects that extend the core set, so they merit a passing glance here.\nAlthough there is no such specific core object type in\nPython (it’s not an HR language, after all), a user-defined class might fit the bill:\ngenerate objects that are instances of our new type, and the class’s methods\nClass-based objects ultimately use built-in objects\ninternally, and we can always describe things like workers with Python’s built-in\nobjects instead, as we did with dictionaries and lists earlier.\nimplement operations with meaningful names, add structure to your code, and\nFor full disclosure on user-defined object types coded with\nBecause classes build upon other tools in Python,\nAs mentioned earlier, everything you can process in a Python script is a type of\nobject, so our object-type tour is necessarily incomplete.\nOther object types in Python either are related to program\nnecessarily object-oriented—a concept that usually requires the Python class\nStill, Python’s core objects\nare the workhorses of all Python scripts you’re likely to meet and are often the\nThis chapter has previewed Python’s core\nobject types and the sorts of operations we can apply to them.\ngeneric operations that work on many object types (sequence operations such as\nindexing and slicing, for example), as well as type-specific operations available\nas method calls (string splits and list appends, for instance).\nAlong the way, we’ve learned that Python’s core object types are more flexible\nPython’s lists and dictionaries can nest, grow and shrink, and contain objects of\nchapters, we’ll start to dig deeper, taking a second pass over Python’s object\nWe’ll start off the next chapter with an in-depth look at Python numbers.\n1. Name four of Python’s core object types.\n2. Why are they called “core” object types?\n3. What does “immutable” mean, and which three of Python’s object types\n5. What does “mapping” mean, and which core object type is a mapping?\n1. Numbers, strings, lists, dictionaries, tuples, files, and sets are generally\nconsidered to be the core object types.\nSome of these types are\nreally categories: there are multiple number types (integer, floating\npoint, complex, fraction, and decimal) and multiple string types (text\n2. They are known as “core” object types because they are part of the\nPython language itself and are always available.\nTo create other objects,\nexample, is an expression that makes a string and determines the set of\nopen function to create a file object, even though this is usually\nconsidered a core object type too.\nNumbers, strings, and tuples in Python fall into this category.\nlists, and tuples are all sequences in Python.\nalso have type-specific method calls.\nfunctions like range, and the dictionary object (which produces its keys\nPython’s dictionary is the only mapping among its core object\ntypes.\nMappings retain insertion order (as of Python 3.7), and support\naccess to data stored by key, plus type-specific method calls that enable\ndepends on the objects being operated on.\nconstraining code to specific types makes that code automatically\nfunctions and classes in Python.\nWhile Python today has type hinting,\nit’s not used by Python itself and is meant only for documentation and\nThis chapter begins our in-depth tour of the Python language.\nIn Python, data\ntakes the form of objects—either built-in objects that Python provides or objects\nwe create using Python tools and other languages like C.\nbasis of every Python program you will ever write.\nfundamental notion in Python programming, objects are also our first focus in\nIn the preceding chapter, we took a quick first pass over Python’s core object\ntypes.\nLet’s get started by exploring our first category: Python’s numeric objects and\nMost of Python’s numeric support is fairly typical and will probably seem\nIn Python, numbers are not really a single object type, but a category of similar\ntypes.\nPython supports the usual numeric types (integers and floating points), as\nwell as literals for creating numbers and expressions for processing them.\naddition, Python provides more advanced numeric programming support and\nInteger and floating-point objects\nComplex number objects\nFraction rational number objects\nSet objects and operations\nBecause the object types in this list’s first bullet item tend to see the most action\nin Python code, this chapter starts with basic numbers and fundamentals, then\nmoves on to explore other types on this list, which serve specialized roles.\nAmong its basic object types, Python provides integers, which are positive and\nPython also allows\ncomplex number type; and allows integers to have unlimited precision—they can\nwhat Python’s numeric types look like when written out in a program as literals\nIn general, Python’s numeric type literals are straightforward to write, but a few\nwrite a number with a decimal point or exponent, Python makes it a floating-\npoint object and uses floating-point (not integer) math when the object is\nAll of these literals produce integer objects in program code; they are just\nThough used more rarely, Python complex literals are written as\nfloating-point numbers, but all numeric operations perform complex math\nCoding other numeric types\nAs you’ll see later in this chapter, there are additional numeric types near the\nPython provides a set of tools for processing number objects:\nExpression operators\nmodules, they also have a handful of type-specific methods today, which you’ll\nas_integer_ratio method useful for the fraction number type, and an\nobject’s value, and as part collection and part number, sets support both\nSince expressions are the most essential tool for most number types, though, let’s\nPython Expression Operators\ncombination of numbers (or other objects) and operators that computes a value\nwhen executed by Python.\nIn Python, you write expressions using the usual\nand Y you would say X + Y, which tells Python to apply the + operator to the\nThe result of the expression is the sum of X and Y,\nanother number object.\nTable 5-2 lists all the operator expressions available in Python, abstractly.\nOthers are more Python specific, and\nnot all are numeric in nature: for example, the is operator tests object identity\nPython expression operators, by increasing precedence (binding)\nMatrix multiplication (unused by Python)\nPython defines an @ operator meant for matrix multiplication but does\nthis early point in your Python career.\nThis book will defer to Python’s manuals for other minutiae, but you’ll see most\nMeet the Python no-ops: The @ character is used by Python to introduce function decorators\nunused by Python itself.\nAs in most languages, in Python, you code more complex expressions by\nstringing together the operator expressions in Table 5-2.\nWhich raises the question: how does Python know which operation to perform\nan expression with more than one operator, Python groups its parts according to\nSo, for example, if you write X + Y * Z, Python evaluates the multiplication\nyou override Python’s precedence rules; Python always evaluates expressions in\nFor instance, instead of coding X + Y * Z, you could write one of the following\nto force Python to evaluate the expression in either desired order:\nBesides mixing operators in expressions, you can also mix numeric types.\ninstance, you can add an integer to a floating-point number:\nbefore: in mixed-type numeric expressions, operands (the parts of the expression\nthat aren’t operators) are first converted up to the type of the most complicated\nFor this, Python ranks the complexity of numeric types like so: integers are\nthe integer is converted up to a floating-point value first, and floating-point math\nSee for yourself in your local Python REPL:\nSimilarly, any mixed-type expression where one operand is a complex number\nYou can force the issue by calling built-in functions to convert types manually:\nHowever, you won’t usually need to do this: because Python automatically\nconverts up to the more complex type within an expression, the results are\noperators, keep in mind that they apply only when mixing numeric objects (e.g.,\nIn general, Python does not convert\nEquality tests do work on mixed types (e.g., a string is never equal to any\nAlthough we’re focusing on built-in numbers right now, all Python operators\nmay be overloaded (i.e., implemented) by Python classes and C extension types\nto work on objects you create.\nFor instance, you’ll see later that objects coded\nwith classes may be added or concatenated with x+y expressions, indexed with\nx[i] expressions, and so on.\nFurthermore, Python itself automatically overloads some operators, such that\nthey perform different actions depending on the type of built-in objects being\nnumbers but performs concatenation when applied to sequence objects like\nstrings and lists.\nterm indicating that the meaning of an operation depends on the type of the\nobjects being processed.\nwe first assign two variables (a and b) to integers so we can use them later in a\nin the next chapter, but in Python:\n$ python3                  # Fire up a REPL\nRecall from Chapter 3 that in Python code, text\nAgain, though, because code you type interactively is temporary, you won’t\nNow, let’s use our new integer objects in expressions.\nPython reports an error rather than filling in some default value:\nPython, but they must have been assigned at least once before you can use them.\nIn the first expression, there are no parentheses, so Python automatically groups\n+ part to force Python to evaluate it first (i.e., before the /).\nPython’s\nYou can also opt to use floor division by coding these examples with //\ninstead of /, and Python will discard decimal digits in the result; because results\nreflect the types of operands, you’ll get back truncated floating-point for floats:\nOnce you start playing with Python numbers in earnest, the results of some\nPython floating-point numbers map to the underling chips on\nbest it can, and neither it nor Python is in error here.\n>>> '%e' % num                   # String-formatting expression\nIts results are strings that\nBoth of these convert arbitrary objects to their string representations: repr\nwere code; str (and the print operation) converts to a typically more user-\nSome objects have both—a str for general use,\nboth strings and operator overloading in classes.\nBesides providing print strings for arbitrary objects, the str built-in is also\nthe name of the string object type, which can be called with an encoding\nmultiplication), but numbers, like all Python objects, can also be compared.\nNotice again how mixed types are allowed in numeric expressions (only); in the\nsecond test here, Python compares values in terms of the more complex type,\nInterestingly, Python also allows us to chain multiple comparisons together to\nIn short, Python lets us string together magnitude\ntype, and it may run slightly faster since Python needs to evaluate Y only once—\nYou can use other comparisons in chained tests, but the resulting expressions can\nPython does not compare the 1 == 2 expression’s False result to 3—this would\nabout the True and False objects later in this chapter and explore the rarely used\nthe fact that floating-point numbers cannot represent some values exactly due to\nunique to Python.\ntruncate, round, use floors, or, as of Python 3.5, import and call the math\nPython’s manuals):\nPython’s core numeric operations, with a deeper look at division.\nPython has two division operators introduced earlier, as well as one that’s\nCalled true division, this always keeps remainders in floating-point results,\nCalled modulus, this returns a division’s remainder, with a result type that\nNotice that the object type of the result for // is dependent on its operand’s\ntypes: if either is a float, the result is a float; otherwise, it is an integer.\nwant to ensure an integer result, simply wrap the expression in int to convert:\ncan see the difference for yourself with the Python math module (as you’ve\nWhen running division operators, you only really truncate for positive results,\nwriting larger Python programs later in this book, but it’s an essential tool in\nPython division may come in multiple flavors, but it’s still fairly standard as\nearlier, Python integers support unlimited size:\nuse them to count your country’s national debt in Python without numeric-value\nBecause Python must do extra work to support the extended precision, integer\ncomplex numbers are a distinct core object type in Python.\nPython’s language reference manual for additional details.\nAs previewed near the start of this chapter, Python integers can be coded in\nspecifying the value of an integer object.\nPython prints integer values in decimal (base 10) by default, but it also provides\nbuilt-in functions that convert integers to other bases’ digit strings formatted per\nPython-literal syntax—useful when programs or users expect to see values in a\nthe numeric base—useful for numbers read from files as strings instead of coded\n>>> 64, 0o100, 0x40, 0b1000000              # Digits=>numbers in scripts and strings\nThe eval function can also be used to convert digit strings to numbers, because\nit treats strings as though they were Python code.\nPython’s three string-formatting tools, though you’ll have to take this partly on\nIn this code, o, b, and x format as octal, binary, and hex, respectively, and #X\nBesides the normal numeric operations (addition, subtraction, and so on), Python\nincludes operators that treat integers as strings of binary bits and can come in\nhandy if your Python code must deal with things like network packets, serial\nsome of Python’s bitwise expression operators at work performing bitwise shift",
      "keywords": [
        "Python",
        "object types",
        "object",
        "Python code",
        "Python list object",
        "list",
        "core object types",
        "type",
        "Code",
        "Python Expression Operators",
        "code Python type",
        "strings",
        "string",
        "numbers",
        "Python dictionary objects"
      ],
      "concepts": [
        "python",
        "pythonic",
        "objects",
        "type",
        "typed",
        "typing",
        "lists",
        "string",
        "strings",
        "operator"
      ],
      "similar_chapters": [
        {
          "book": "Learning Python Ed6",
          "chapter": 10,
          "title": "",
          "score": 0.747,
          "base_score": 0.597,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 5,
          "title": "",
          "score": 0.701,
          "base_score": 0.551,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 9,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 7,
          "title": "",
          "score": 0.65,
          "base_score": 0.5,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 6,
          "title": "",
          "score": 0.604,
          "base_score": 0.454,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "object",
          "type",
          "objects",
          "types",
          "floating"
        ],
        "semantic": [],
        "merged": [
          "object",
          "type",
          "objects",
          "types",
          "floating"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5127316496698706,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:10.090615+00:00"
      }
    },
    {
      "chapter_number": 5,
      "title": "Numeric Types",
      "start_page": 181,
      "end_page": 220,
      "summary": "For more details on set operations, see Python’s library manual.\ncoded manually in Python with other types like lists and dictionaries (and often\nwere in the past), Python’s built-in sets use efficient algorithms and\nSets are powerful and flexible objects, but they do have one constraint that you\nonly immutable object types (Python refers to this as “hashable,” which is close\n>>> S.add([1, 2, 3])                   # Only immutable objects work in a set\ncontain modules, type objects, and more.\nin a list.” Comprehensions can also iterate across other kinds of objects, such as\nSets can be used to isolate differences in lists, strings, and other iterable objects\nlike database query results—the intersection of two sets contains objects\nYou can find more details on set operations in the Python library manual and\nset operations we’ve seen here, in the context of dictionary view objects.\nwe have time for just one last numeric object type.\nBoolean Objects\nThough somewhat gray, the Python Boolean type, bool, is arguably numeric in\nTo represent truth values, Python has an explicit Boolean type called bool, from\nwhich the objects preassigned to built-in names True and False are made.\nobject-oriented sense) of the built-in integer type int.\nearlier in this chapter) for its two objects, and all logical tests yield True or\n>>> True is 1                # But a different object: see the next chapter!\nFinally, although Python’s core numeric objects offer plenty of power for most\nway to use the language (Python web development, for example, is similarly\nThis chapter has toured Python’s numeric object types and the operations we can\nobjects, as well as some more exotic and less commonly used types such as\ndetails about the next object type—the string.\nPython, so make sure you check out the next chapter before moving on.\n1. What is the value of the expression 2 * (3 + 4) in Python, and why?\n2. What is the value of the expression 2 * 3 + 4 in Python, and why?\n3. What is the value of the expression 2 + 3 * 4 in Python, and why?\nIn the prior chapter, we began exploring Python’s core object types in depth by\nWe’ll resume our object type tour\nAs you’ll see here and throughout this book, in Python, we do not need to\ndeclare the specific types of the objects our scripts use.\nPython’s dynamic typing model.\nIn Python, types are determined automatically\nvariables, objects, and the links between them, as the next section explains.\nVariables, Objects, and References\nan assignment statement such as a = 3 in Python, it works even if you’ve never\ntold Python to use the name a as a variable, or that a should stand for an integer-\ntype object.\nA variable (also known in Python as a name), like a, is created when your\nIn Python, the notion of type lives with objects, not names.\nare generic in nature; they always simply refer to a particular object at a\nobject that it currently refers to, whatever that may be.\nIn sum, variables are created when assigned, can reference any type of object,\nexample, when we say this to assign a variable a value in a Python REPL or\n>>> a = 3                # Assign a name to an object\nThese steps reflect the operation of all assignments in the Python\n1. Create an object to represent the value 3.\n3. Link the variable a to the new object 3.\nsketched, variables and objects are stored in different parts of memory and are\nother objects (for instance, a list object has links to the objects it contains).\nNames (a.k.a. variables) and objects after running the assignment a = 3\nThese links from variables to objects are called references in Python—a kind of\nare later used (i.e., referenced), Python automatically follows the variable-to-\nobject links.\nobjects.\nobjects.\nrunning an expression, Python creates a new object (i.e., a chunk of memory) to\ncertain kinds of unchangeable objects, such as small integers and strings (each 0\nEach object also has two standard header fields: a type\ndesignator used to mark the type of the object, and a reference counter used to\nPYTHON REFERENCES FOR C PROGRAMMERS\nReaders with a background in C may find Python references similar to C\nespecially with objects that can be changed in place (more on this later).\ncan think of Python references as C “void*” pointers that are automatically\nTypes Live with Objects, Not Variables\nTo see how object types come into play, watch what happens if we assign a\nThis isn’t typical Python code, but it does work—a starts out as an integer, then\ntype of a changes from integer to string when we say a = 'hack'.\nNames have no types; as stated earlier, types live with objects, not\nobjects.\nthe variable a; we’ve simply made the variable reference a different type of\nobject.\nIn fact, again, all we can ever say about a variable in Python is that it\nreferences a particular object at a particular point in time.\nObjects, on the other hand, know what type they are—each object contains a\nheader field that tags the object with its type.\nThe integer object 3, for example,\nwill contain the value 3, plus a designator that tells Python that the object is an\nThe type designator of the 'hack' string object points to the string\nBecause objects know their\nTo recap, types are associated with objects in Python, not with variables.\ntypical code, a given variable usually will reference just one kind of object.\nBecause this isn’t a requirement, though, you’ll find that Python code tends to be\nyour code might work on many types automatically.\nAs mentioned, objects have two header fields, a type designator and a reference\nObjects Are Garbage-Collected\nIn the prior section’s listings, we assigned the variable a to different types of\nobjects in each assignment.\nstatements, what happens to the object 3?\nThe answer is that in Python, whenever a name is assigned to a new object, the\nname or object.\nlike Python that support it.\ndifferent object on each assignment:\nFirst, notice that x is set to a different type of object each time.\nRemember, in Python types live with objects, not names.\ngeneric references to objects, this sort of code works naturally.\nSecond, notice that references to objects are discarded along the way.\nx is assigned to a new object, Python reclaims the prior object’s space.\ninstance, when it is assigned the string 'Python', the object 99 is immediately\nfuture object.\nInternally, Python accomplishes this feat by keeping a counter in every object\nthat keeps track of the number of references currently pointing to that object.\neach time x is assigned to a new object, the prior object’s reference counter\ncan use objects liberally without ever needing to allocate or free up space in your\nPython will make objects clean up their unused space for you as your\ndetects and reclaims objects with cyclic references in time.\nBecause references are implemented as pointers, it’s possible for an object to\nreference itself, or reference another object that does.\nrare, because the reference counts for such objects never drop to zero, they\nSo far, we’ve explored what happens as a single variable is assigned references\nto objects.\nwhat happens to its names and objects:\nsecond command causes Python to create the variable b; the variable a is being\nused and not assigned here, so it is replaced with the object it references (3), and\nb is made to reference that object.\nNames and objects after next running the assignment b = a\nshared object).\nvariable in Python.\nRather, both variables point to the same object via their\nAs with all Python assignments, this statement simply makes a new object to\nrepresent the string value 'hack' and sets a to reference this new object.\nnot, however, change the value of b; b still references the original object, the\nNames and objects after finally running the assignment a = 'hack'\nPython makes the variable a\nreference the object 3 and makes b reference the same object as a, as in Figure 6-\n2; as before, the last assignment then sets a to a completely different object (in\nthe object 3—as introduced in Chapter 4, integers are immutable and thus can\nmake a new integer object.\nOne way to think of this is that, unlike in some languages, variables in Python\nare always pointers to objects, not labels of changeable memory areas: setting a\nvariable to a new value does not alter the original object, but rather causes the\nvariable to reference an entirely different object.\nchange objects in place, but they’re only supported by Python’s mutable types—\na list actually changes the list object itself in place, rather than generating a\nbrand-new list object.\nFor objects that support such in-\nOtherwise, your objects may seem to change\nTo illustrate, let’s take another look at the list objects introduced in Chapter 4.\ncollections of other objects, coded in square brackets:\nL1 here is a list containing the objects 2, 3, and 4.\nby their positional offsets, so L1[0] refers to object 2, the first item in the list L1.\nOf course, lists are also objects in their own right, just like integers and strings.\nobject, just like a and b in the prior example (see Figure 6-2).\nThis assignment simply sets L1 to a different object; L2 still references the\n>>> L1 = [2, 3, 4]         # A mutable object\n>>> L2 = L1                # Make a reference to the same object\ncomponent of the object that L1 references.\nof the list object’s value in place.\nBecause the list object is shared by (referenced\nbecause it references the same object as L1.\nL2, either, but its value will appear different because it refers to an object that has\nThis behavior occurs only for mutable objects that support in-place changes and\nrequest that Python copy objects instead of making references.\n>>> L2                     # L2 is not changed this time: different objects\ncopy of the object L1 references, not the original; that is, the two variables point\npass the original object to their type names, dict and set.\nstandard-library copy module has a call for copying any object type generically,\nlists, dictionaries, sets, and some objects defined with class statements.\n>>> x = 'Python'          # Reclaim 99 now?\nBecause Python caches and reuses small integers and small strings, as mentioned\nFor instance, because of Python’s reference model, there are two different ways\n>>> M = L                 # Make M and L reference the same object\n>>> L is M                # Same objects\nobjects have the same values; this is the method almost always used for equality\nThe second method, the is operator, instead tests for object\nidentity—it returns True only if both names point to the exact same object, so it\nprograms (except for single-instance objects like None, True, and False, as in\nthe names point to equivalent but different objects, as is the case when we run\n>>> M = [1, 2, 3]         # Make M and L reference different objects\n>>> L is M                # Different objects\nimmutable object like an integer:\n>>> Y = 99                # Should be two different objects\n>>> X is Y                # Same object anyhow: caching at work!\nIn this interaction, X and Y should be == (same value), but not is (same object)\nobject.\nthe getrefcount function in the standard sys module returns the passed object’s\nThis object caching and reuse is irrelevant to your code (unless you run the is\nthe same cached object.\nIf a mutable object changes out from under you when passed around\nassignment and references in Python, a basic understanding of this model is\nPython; once you get a handle on dynamic typing, you’ll find that it works the\nJust as importantly, though, dynamic typing is also the root of Python’s\nBecause we do not constrain types in Python code, it is both concise\ndynamically typed language like Python, and at first glance contradictory to\nthe form of a colon and object type, between a variable and an optional\nThe object type can be a name or an expression to denote collections\nAs of Python 3.12, a new type statement can\nPython does not require them and does not use them in any way and\nthe following function hints that it accepts an integer and list of strings and\nof hosting objects:\nThat is, type hinting is a conceptually heavy tool adopted by Python but\noptimized Pythons introduced in Chapter 2 do not use type hints today, and in\nMore to the point, though, type hinting is also completely at odds with Python’s\nthey are comfortable with Python’s dynamic-typing paradigm.\nPython is statically typed.\nPython still uses only dynamic typing, and hopefully\nThis chapter took a deeper look at Python’s dynamic typing model—that is, the\nway that Python keeps track of object types for us automatically, rather than\nAlong the way, we learned how variables and objects are associated by\nreferences in Python that enable type flexibility.\ngarbage collection, learned how shared references to mutable objects can affect\nPython.\nBecause there is just one assignment model in Python, and because assignment\nchapter, with strings.\nB = 'Python'\nB[0] = 'Python'\nB[0] = 'Python'\nWhen B is assigned to the string 'Python',\nall that happens is that the variable B is reset to point to the new string\nobject.\nstring object 'code', but two names are never linked together in\nPython.\nThus, setting B to a different object has no effect on A.\nby the way—the concatenation would make a new object for its result,\nchanged either A or B; instead, we’ve changed part of the object they\nboth reference (point to) by overwriting that object in place through the\nBecause A references the same object as B, the update is\nobject before it was assigned to B.\nstatement, there are two different list objects that have the same value—\nthe value of the list object pointed to by B, but not that pointed to by A.\nmodule, is a reference to an object that does not by itself prevent the\nreferenced object from being garbage-collected.\nreferences to an object are all weak references, the object can be reclaimed.\nWhen this happens, the weak references to it will be notified that the object\nobjects primarily used elsewhere.\ncache’s references alone would keep the objects in memory indefinitely.\nusing weak references, the object’s space may be reclaimed when it’s no\nNot all object types can be weakly referenced, though support can be added\nFor more details on weak references, see Python’s library-manual\nSo far, we’ve studied numbers and explored Python’s dynamic typing model.\nThe next major type on our in-depth object tour is the Python string—an ordered\nand their extension to Unicode and byte strings in Chapter 37 of its advanced\nUnicode and bytes processing, too, because Python text strings are Unicode,\nString Object Basics\nmemory, internet addresses, Python source code, and so on.\nPython’s strings serve the\nUnlike in C, strings in Python come with a\nPython has no distinct type for individual characters; instead, you just use one-\nStrictly speaking, Python strings are categorized as immutable sequences,\nBesides expressions, Python also provides a set\nPython 2.X compatibility (Chapter 37)\nBeyond the core set of string tools in Table 7-1, Python also supports more\nPython comes with many string tools, and we won’t\nBy and large, strings are fairly easy to use in Python.\nAround Python strings, single- and double-quote characters are interchangeable,\nand return the same type of object.\n$ python3\nThis is a purely subjective style choice, but Python displays strings\nWithout it, Python\nnotice in all of these outputs that Python prints strings in single quotes unless\ninserted into a string literal or typed on a keyboard.\nmore characters following it in the string literal, are replaced with a single\ncharacter in the resulting string object, which has the value specified by the\nFor one thing, the Python string object\nFor another, string content and length both reflect code points (identifying numbers) assigned\nIn fact, Python defines str strings formally as sequences of Unicode code points, not bytes, to\ncharacter values to be stored in the string.\nPython recognizes a full set of escape code sequences, listed for reference in\nwhere they give a character’s Unicode code-point value.\n\\x and \\o escapes work in both bytes byte-string literals (b'…'), where\nthey give a byte’s absolute value; and in str text-string literals, where\nthey give a character’s Unicode code-point value.\ncharacter string that embeds two characters with zero values (coded as octal",
      "keywords": [
        "Python",
        "object",
        "Python string object",
        "Python code",
        "type",
        "string",
        "References",
        "strings",
        "PYTHON REFERENCES",
        "code",
        "sets",
        "Python language",
        "string object",
        "Python Boolean type",
        "object types"
      ],
      "concepts": [
        "python",
        "objects",
        "strings",
        "string",
        "type",
        "typed",
        "typing",
        "sets",
        "setting",
        "coded"
      ],
      "similar_chapters": [
        {
          "book": "Learning Python Ed6",
          "chapter": 4,
          "title": "",
          "score": 0.701,
          "base_score": 0.551,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 10,
          "title": "",
          "score": 0.695,
          "base_score": 0.545,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 9,
          "title": "",
          "score": 0.645,
          "base_score": 0.495,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 8,
          "title": "",
          "score": 0.535,
          "base_score": 0.385,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 7,
          "title": "",
          "score": 0.528,
          "base_score": 0.378,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "object",
          "objects",
          "references",
          "type",
          "reference"
        ],
        "semantic": [],
        "merged": [
          "object",
          "objects",
          "references",
          "type",
          "reference"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4730804194375855,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:10.090628+00:00"
      }
    },
    {
      "chapter_number": 6,
      "title": "The Dynamic Typing Interlude",
      "start_page": 221,
      "end_page": 260,
      "summary": "Importantly, in Python, a character like this does not terminate a string\nInstead, Python keeps both the string’s\nIn fact, no character terminates a string in Python.\nHere’s a string that is all absolute escape codes—an absolute 1 and 2 (coded in\nfollowing string contains the characters “HACK”, a tab and newline, and an\nBecause their contents are represented as strings in your scripts, it’s OK\ndespite the fact that these escapes in text strings denote code points, not bytes:\nEven without this backward-incompatible Python change, though, strings that\nretained in your strings in all Pythons, by either doubling them with \\\\ (an\nRaw Strings Suppress Escapes\ncharacters in strings.\nquote of any string literal covered in this chapter, it turns off the escape\nas they appear in the string.\nIn fact, Python itself sometimes uses this doubling scheme when it prints strings\n>>> path = r'C:\\new\\text.dat'                  # Raw string: keep \\s\n>>> len(path)                                  # String length: \\s\nthe string, independent of display formats.\nBesides directory paths on Windows, raw strings are also commonly used for\nRaw strings are useful for paths using native Windows backslashes,\nThey also work for triple-quoted strings to suppress escapes (and future\nRaw-string quirk: Despite its role, even a raw string cannot end in a single backslash, because\nThat is, r'…\\' is not a valid string literal:\nyou still must escape the surrounding quote character to embed it in the string, and Python\nThe upshot is that a raw string cannot end in an odd number of\nIf you need to end a raw string with a single backslash, you can\nthe raw string syntax and just double up the backslashes in a normal string ('…\\\\').\nof these forms create the same two-character string with a Unicode ellipsis and one backslash.\nTriple Quotes and Multiline Strings\nSo far, you’ve seen single quotes, double quotes, escapes, and raw strings in\nPython also has a triple-quoted string literal format, sometimes called a\nblock string, that is a syntactic convenience for coding multiline data.\nSingle and double quotes embedded in the string’s text may be,\nbut do not have to be, escaped—the string does not end until Python sees three\n>>> quip = \"\"\"Python strings\n'Python strings\\n  sure have\\na lot of options'\nThis string spans three lines.\nsingle multiline string, with embedded newline characters (\\n) at the places\nTo see the string with the newlines interpreted, print it\nPython strings\nIn fact, triple-quoted strings will retain all the enclosed text, including any to the\nconcatenation of adjacent strings mentioned earlier, with explicit newlines if\nOpen           # Comments here added to string!\nSo why use triple-quoted strings?\nTriple-quoted strings are also commonly used for docstrings (documentation\nstrings), which are string literals that are taken as comments when they appear at\ncomments and may need to be triple-quoted raw strings (e.g., r''') to avoid\nFinally, triple-quoted strings are also sometimes used as a “horribly hackish”\nThis was tagged as “hackish” because Python really might make a string out of\nStrings in Action\nOnce you’ve created a string with the literal expressions we just met, you will\ndemonstrate string expressions, methods, and formatting—the first line of text-\nLet’s begin by interacting with the Python interpreter to illustrate the basic string\nYou can concatenate strings using the +\n>>> 'abc' + 'def'         # Concatenation: a new string\nThe len built-in function here returns the length of a string (or any other object\nFormally, adding two string objects with + creates a new string\nadding a string to itself a given number of times (minus one).\nPython lets you create arbitrarily sized strings; there’s no need to predeclare\nstring objects as needed and let Python manage the underlying memory space\nFor instance, Python doesn’t allow you to mix numbers and strings in +\nstring (we’ll fix this ahead).\nAs shown near the end of Table 7-1, you can also iterate over strings in loops\nsequence (here, a string) and executes one or more statements (normally\nacross the string’s characters.\nBecause strings are ordered collections (a.k.a. sequences) of characters, we can\nstring are fetched by indexing—providing the numeric offset of the desired\ncomponent in square brackets after the string.\nstring at the specified position.\nAs in most C-like languages, Python offsets start at 0 and end at one less than the\nitems from sequences such as strings using negative offsets.\nnegative offset is added to the length of a string to derive a positive offset, but\nIn this code, the first line defines a four-character string and assigns it to the\nfrom the left—the one-character string 'c' at the front; and S[−2] gets the item\napplied to strings, because it’s an easy way to extract substrings.\nSlicing works like this: when you index a sequence object such as a string on a\nnot specified, defaults to the length of the string, which is off the end.\none step by assigning to a slice (though not for immutables like the strings we’re\nThis isn’t very useful for immutable objects like strings, but it comes in handy\nIndexError: string index out of range\nString Conversion Tools\nprime example, you cannot add a number and a string together in Python, even if\nthe string looks like a number (i.e., is all digits):\nWhat to do, then, if your script obtains a number as a text string from a file or\nyou can treat a string like a number, or vice versa.\n>>> int('62'), str(62)          # Convert from/to string\nThe int function converts a string to a number, and the str function converts a\nnumber to its string representation (essentially, what it looks like when printed).\nNow, although you can’t mix strings and number types around operators such as\nstrings, if you need to mix the two in expressions:\nThe built-in eval function introduced in Chapter 5 runs a string containing\nPython expression code, and so can also convert a string to any kind of object.\nAs we also saw briefly in Chapter 5, string formatting provides\nother ways to convert numbers to strings; more on it ahead.\n>>> chr(104)               # ID => character (string)\n>>> for c in 'hack':       # All code points in a string\nYou can use a loop to apply ord to all characters in a string as shown, but these\ntools can also be used to perform a simple sort of string-based math.\nAt least for single-character strings, this provides an alternative to using the\nbuilt-in int function to convert from string to integer (though this only makes\nString comparisons\ncomparisons: when we compare two text strings, Python automatically compares\nend of either string.\nthan that of k, and the longer string at the end wins:\nThe same holds true for the byte strings you’ll meet in Chapter 37 (they are\n“Changing” Strings Part 1: Sequence Operations\nmeans that strings support operations like concatenation, repetition, indexing,\nThe immutable part means that you cannot change a string in place\nTo change a string, you\ngenerally need to build a new string using tools such as concatenation and\nslicing, and assign the result back to the string’s original name if desired:\n>>> S = S + 'ual!'           # To change a string, make a new one\nmakes a new string and assigns it back to S to save it, but you can think of this as\n“changing” the original string.\nsection, you can achieve similar effects with string methods like replace:\nLike every operation that yields a new string value, string methods generate new\nstring objects.\nstring object for each string change is not as inefficient as it may sound—\ncollects (reclaims the space of) old unused string objects as you go, so newer\nBut string methods can do much more, as the next section will explain.\na string type known as bytearray, which is mutable and so may be changed in place.\nbytearray objects aren’t really text strings; they’re sequences of small, 8-bit integers.\nHowever, they support most of the same operations as normal strings and print as ASCII\nRicher Unicode text and str strings in\nString Methods\nIn addition to all the string operations already introduced, strings provide a set of\nwork only on string objects.\n>>> result = S.find('ac')     # Call the find method to look for 'ac' in string S\nAll String Methods (Today)\nTable 7-3 summarizes the methods and call patterns for built-in string objects in\non any string or the str type name, as shown in Chapter 4.\nIn this table, S is a string object; optional arguments are enclosed in [] brackets;\nString method calls in Python 3.12\nAs you can see, strings have many methods, and we don’t have space to cover\n“Changing” Strings, Part 2: String Methods\nAs we’ve seen, most strings cannot be changed in place directly because they are\nWe explored changing strings with sequence operations in the\nBy way of review, to make a new text value from an existing string, you can\nconstruct a new string with sequence operations such as slicing and\nFor example, to replace two characters in the middle of a string,\n>>> S[:4] + 'ful' + S[-1]             # Make a new string with sequence ops\nBut, if you’re really just out to replace a substring, you can use the string\nIf you need to replace one fixed-size string\nsubstring with the string find method and then slice:\nAs a reminder, replace returns a new string object each time (which is why two\nBecause strings are immutable, methods, like\nsequence operations, never really change the subject string in place—even if\nTo save the new string object produced by a method\nstring objects each time they are run is a potential downside of using them to\nchange strings: each interim result must create a full-fledged object with a fresh\nIf you have to apply many changes to a very large string, you\nmight be able to improve your script’s performance by converting the string to\n>>> L = list(S)                       # Explode string into a list\ncharacters of a string into a list.\nOnce the string is in this form, you can make\n>>> L[0] = 'h'                        # Works for lists, not strings\nAfter your changes, you can convert back to a string if needed (e.g., to write to a\nfile) by using the string join method to “implode” the list back into a string:\n>>> S = ''.join(L)                    # Implode back to a string\nmethod of strings (not of lists), it is called through the desired delimiter string.\njoin puts the strings in a list (or other iterable) together, with the delimiter\nbetween list items; in this case, it uses an empty string delimiter to convert from\na list back to a string.\nMore generally, any string delimiter and iterable of strings\nThe mutable bytearray string\nMore String Methods: Parsing Text\nAnother common role for string methods is as a simple form of text parsing—\noriginal string.\nmay show up at arbitrary positions within the string:\nThe string split method chops up a string into a list of substrings, around a\ndelimiter string.\nwhitespace—the string is split at groups of one or more spaces, tabs, and\nroles (string conversion tools covered earlier can change substrings here into\n['you', 'are', 'a', 'string', 'coder']\nOther Common String Methods\nOther string methods have more focused purposes—for example, to strip off\n>>> line = \"Python's strings are awesome!\\n\"\n\"Python's strings are awesome!\"\n\"PYTHON'S STRINGS ARE AWESOME!\\n\"\nstring methods—the in membership operator can be used to test for the presence\n>>> line.endswith(sub)                  # End test via method call or slice\nNote that none of the string methods accepts patterns—for pattern-based text\nBecause of their limitations, though, string methods may run more\nAgain, because there are so many methods available for strings, we won’t look at\nYou’ll see some additional string examples later in this book, but\nChapter 4, help(S.method) gives info for a method of any string object S; use\nformat performs string formatting, which combines many operations in a single\nString Formatting: The Triathlon\nAlthough you can get a lot done with the string methods and sequence\ncombine string processing tasks: string formatting allows us to perform multiple\ntype-specific substitutions on a string in a single step.\nWe’ve used string formatting informally in this book already, but it’s finally time\nconvoluted by Python’s history: there are today three different string-formatting\nString-Formatting Options\nentries in the string-formatting race:\nThe very latest (so far) added in Python 3.6, this form is known as f-strings.\nstring interpolation—substituting inline expressions with their results.\nYou can also format strings manually with string methods, though it’s too\nAnd technically, an additional tool, string.Template,\n(e.g., f-strings use the method’s format specifier and assume its earlier\nThe String-Formatting Expression\nSince string-formatting expressions are the original in this department, we’ll start\nPython defines the % binary operator to work on strings.\nWhen applied to strings, the % operator provides a simple way to\nformat values as strings according to a format definition.\nTo format strings with an expression:\n1. On the left of the % operator, provide a format string containing one or\nto insert into the format string on the left in place of the conversion\nin the format string on the left, and the string 'format' replaces the %s.\nresult is a new string that reflects these two substitutions, which may be printed\nTechnically speaking, string formatting in any flavor is usually optional—you\n>>> 'Meet the formatting %s!' % option              # String substitution\nThe first example here plugs a string into the target on the left, replacing the %s\nIn the second example, three values are inserted into the target string.\nstands for conversion to string.\nstring (the one used when printing), every object type works with the %s\noften the only code you need to remember for the formatting expression.\nAgain, keep in mind that formatting always makes a new string, rather than\nchanging the string on the left; because strings are immutable, it must work this\ntype codes listed in Table 7-4 in formatting expressions; they appear after the %\nbecause Python string formatting supports all the usual C printf format codes\ncodes in the table provide alternative ways to format the same type; for instance,\nFormatting-expression type codes\nString (or any object’s str(X) string)\nCharacter (integer code or string)\nAll told, conversion targets in the format string on the expression’s left side\nend of this target string’s format, at typecode.\nthese extra tools, a simple %s in the format string will be replaced by the\ncorresponding value’s default print string, regardless of its type.\nwith simply converting to strings with a %s type code or the str built-in function\nwidth and precision by specifying them with a * in the format string to force\nAs a more advanced extension, % string formatting also allows conversion targets\nHere, the (qty) and (tool) in the format string on the left refer to keys in the\nexpression, using key references and a template string either loaded from a file\ncomment is above the triple quote to keep it out of the string, and “…” prompts\nWhen used on the right side of a format operation, this allows the format string\nBinary” for examples that convert to hexadecimal and octal number strings with\nthe %x and %o formatting expression target codes, which we won’t repeat here.\nthe formatting method and f-string—the first of which is this chapter’s next\nThe String-Formatting Method\nAs noted, Python 3.0 added a second way to format strings that some see as\nThe string object’s format method at the heart of this option is based on function\nSpecifically, it uses the call’s subject string\nWithin the subject string, curly braces designate substitution\nfor value sources in the template string itself (which may be an asset or liability,\nNaturally, the subject string in the format\nmethod call can also be a literal that creates a temporary string, and arbitrary\nobject types can be substituted at targets much like the expression’s %s code:\nJust as with the % expression and other string methods, format creates and\nreturns a new string object, which can be printed immediately or saved for\nfurther work (as another reminder, strings are immutable, so format really must\nString formatting in any of its forms is not just for display:\nFor instance, format strings can name object\nSquare brackets in format strings can also name offsets to index lists (and other\nexpressions outside the format string itself, just as you would for % expressions\nIf you simply cannot do without full generality inside format strings, stay tuned\nfor the f-string and its arbitrary nested expressions (albeit in a code literal instead\nspecific layouts with extra format-string syntax.\nFor the formatting method, we\nhere, which aren’t coded in the format string) and must appear without\nIs a string of zero or more .name or [index] (brackets required!) references,",
      "keywords": [
        "string",
        "Python",
        "strings",
        "string methods",
        "Python strings",
        "format string",
        "method",
        "code",
        "Python string formatting",
        "string formatting",
        "string object",
        "format",
        "formatting",
        "object",
        "expression"
      ],
      "concepts": [
        "string",
        "strings",
        "python",
        "format",
        "formatting",
        "codes",
        "coded",
        "coding",
        "methods",
        "lines"
      ],
      "similar_chapters": [
        {
          "book": "Learning Python Ed6",
          "chapter": 4,
          "title": "",
          "score": 0.604,
          "base_score": 0.454,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 7,
          "title": "",
          "score": 0.56,
          "base_score": 0.41,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 10,
          "title": "",
          "score": 0.554,
          "base_score": 0.404,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 9,
          "title": "",
          "score": 0.534,
          "base_score": 0.384,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 5,
          "title": "",
          "score": 0.416,
          "base_score": 0.266,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "string",
          "strings",
          "format",
          "formatting",
          "string methods"
        ],
        "semantic": [],
        "merged": [
          "string",
          "strings",
          "format",
          "formatting",
          "string methods"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.41034928397181936,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:10.090641+00:00"
      }
    },
    {
      "chapter_number": 7,
      "title": "String Fundamentals",
      "start_page": 261,
      "end_page": 320,
      "summary": "list\nparts, to use argument-list values dynamically (much like the * in formatting\nNesting may be only one level deep, and f-strings (ahead) use an arbitrary\nand listed earlier in Table 7-4, but the formatting method adds a b to display\nIn addition to the string’s format method, a single object may also be formatted\nwith the format(object, formatspec) built-in function (which the method\ncharacter-wide field (notice again the use of dict() to make a dictionary from\nformats, and absolute argument numbers let you reuse values passed in (% uses\ndictionaries to do the same):\nthe arguments list dynamically by nested format syntax—much like the * syntax\n>>> '{0:.{1}f}'.format(1 / 3.0, 4)                   # Take value from arguments\n>>> '{:.2f}'.format(1.2345)                          # String method\nThe F-String Formatting Literal\nThe f-string is a text-\nstring literal that embeds substitution values in the format string itself, rather\nF-strings, added in Python 3.6, perform what’s generally called string\nstring and can be arbitrary Python expression code.\ndifferent from listing replacement values after a % in the expression, or as\nThe f prefix may be combined with r in any order to code formatted raw strings\nadjacent text-string literal of any kind (but use the f prefix on other concatenated\nAs a preview of Chapter 37, the f cannot be combined with byte-string prefix b\n(which means that the f-string, like the format method but unlike the %\nF-string formatting basics\n'Learning coding in Python'\nF-strings\nsometimes more often than they should: there’s no reason to use an f-string for\nIn its simplest form like this, an f-string’s expressions enclosed in {} are\nname-scoping details you’ll meet later in this book) and when the f-string is run\nto make a string (not when your code is first read by Python).\nformatting expression and method, it’s a runtime operation that uses the current\n>>> what = 'f-strings'\n'Learning F-STRINGS!\nkeep in mind that f-strings are runtime code, more like the % expression and\nWhen coded in a function, for example, an f-string won’t\nAlso new as of Python 3.12, a backslash can be used in an f-string’s {} part and\n'Learning F-STRINGS!\nIn other words, if you like f-strings, you’ll like them best in Python 3.12+.\nuse 3.12’s f-string rules; mod examples’ quotes for older Pythons if needed.\nF-string custom formats\nAs noted, f-strings use the same custom-format syntax as string methods, so\nIn the abstract, f-strings are coded with a\nbrackets are not part of the f-string’s code, but spaces are generally allowed\nexpression part is any Python expression code (including nested f-strings) and\nhere; see “Formatting method custom formats” for the options that f-strings\nthough they contain expressions in the f-string, not argument identifiers.\nUsage tip: because f-strings run expressions that reference variables, they may\ndictionary keys to keyword arguments, as you’ll learn later in this book:\n>>> values = dict(tool='Python', role='scripting')     # Collected values\n>>> 'Use %(tool)s for %(role)s.' % values              # Expression: keys\n>>> 'Use {tool} for {role}.'.format(**values)          # Method: keywords\n>>> 'Use {0[tool]} for {0[role]}.'.format(values)      # Method: reused-arg keys\n>>> f'Use {values['tool']} for {values['role']}.'      # F-string: expressions\nFor more impressive f-string results, assign substitution values to same-scope\nexpression and method can treat such templates as simple text data, f-strings are\nF-strings are a powerful tool, but their nested expressions make them geared\nthe f-string, see its full disclosure in Python’s language reference manual.\nsection, f-strings may be best in most new code, on logistical grounds alone:\ncode and may have to use them in roles that f-strings don’t address (e.g., for\nThe expression, method, and f-string can all be used as templating\ntools, referring to substitution values by name using dictionary keys,\nprefixed by a $, as either dictionary keys or keywords, but does not support\nNow that we’ve explored the first of Python’s collection objects, the string, let’s\nSequences (strings, lists, tuples)\nmap keys to values and are not positionally ordered sequences); and we haven’t\nincluding strings, lists, tuples, and some user-defined object types.\noperands X and Y—if you concatenate lists, you get back a new list, not a string.\ncode to make a new object containing the new value.\nMutables (lists, dictionaries, sets, bytearray)\nhow lists, dictionaries, and tuples participate in type categories, we need to move\nIn this chapter, we took an in-depth, second-pass tour of the string object type.\nWe learned about coding string literals, and we explored string operations,\nincluding sequence expressions, string method calls, and string formatting in its\n1. Can the string find method be used to search a list?\n2. Can a string slice expression be used on a list?\n4. How might you go about changing a string in Python?\n5. Given a string S with the value 'c,od,e', name two ways to extract the\n7. Write an expression, method call, and f-string to format 'Python' and\nthe string find, but it can be used to search both strings and lists.\nworks on any type of sequence object, including strings, lists, and\nThe only difference is that when you slice a list, you get back a\nnew list.\nThere’s almost no reason to use an f-string if all parts\nare known and formatted per defaults (f'{'Python'} is {3.12}'\nseems silly), but f-strings are more useful if values are first assigned to\nLists and Dictionaries\nfull story on Python’s list and dictionary objects—collections of other objects,\nLists\nThe first stop on this chapter’s tour is the Python list.\nLists are Python’s most\nUnlike strings, lists can contain any sort\nof object: numbers, strings, and even other lists.\nAlso, unlike strings, lists may be\nchanged in place by assignment to offsets and slices, list method calls, deletion\nPython lists do the work of many of the collection data structures you might\nPython lists are:\nFrom a functional view, lists are just places to collect other objects so you\nJust as with strings, you can fetch a component object from a list by indexing\nthe list on the object’s offset.\nBecause items in lists are ordered by their\nUnlike strings, lists can grow and shrink in place (their lengths can vary),\ncollection objects, they also support arbitrary nesting; you can create lists of\nIn terms of our type category qualifiers, lists are mutable (i.e., can be\noperations work the same on lists as they do on strings; the only difference is\nthat sequence operations such as concatenation and slicing return new lists\ninstead of new strings when applied to lists.\ndeletion, expansion, and index assignment operations, which change the lists\nTechnically, Python lists contain zero or more references to other objects.\nbackground in some other languages, and fetching an item from a Python list\nChapter 6, though, Python always follows a reference to an object whenever\nlist object operations.\nCommon list literals and operations\nAn empty list\nL = list('code')\nL = list(range(-4, 4))\nList of an iterable’s items, list of successive\nlist(map(ord, 'python'))\nWhen written down as a literal expression, a list is coded as a series of objects\nlist.\nA nested list is coded as a nested square-bracketed series (row 3), and the\nLists also respond to list-specific method calls (which\nas in-place change operations (deleting items, assignment to indexes and slices,\nAgain, lists have these tools for change operations because they\nBasic List Operations\nBecause they are sequences, lists support many of the same operations as strings,\nAlthough the + operator works the same for lists and strings, it’s important to\nstring unless you first convert the list to a string (using tools such as str or\nformatting) or convert the string to a list (the list built-in function does the\n>>> [1, 2] + list('34')                      # Same as [1, 2] + ['3', '4']\nfollowing, for instance, a nested 3 is greater than a nested 2, and the one-item list\nBecause lists are sequences, indexing and slicing also work the same way for\nlists as they do for strings.\nFor lists, though, the result of indexing is whatever\ntype of object lives at the offset you specify (not a one-character string), and\nslicing a list always returns a new list (not a string):\nNew here: because you can nest lists and other object types within lists, you will\n(multidimensional arrays) in Python is as lists with nested sublists.\nChanging Lists in Place\nBecause lists are mutable, they support operations that change a list object in\nThat is, list operations in this section and others all modify the list object\nWhen using a list, you can change its contents by assigning to either a\n>>> L[0:2] = ['write', 'Python']      # Slice assignment: \"delete+insert\"\nlist directly, rather than generating a new list object for the result.\nthe = are inserted into the list on the left, at the place where the old slice\nlist L of two or more items, an assignment L[1:2]=[4,5] replaces one item with\nconcatenation expressions, and the insert, pop, and remove list methods\nList method calls\nLike strings, Python list objects also support type-specific method calls, most of\n>>> L.sort()                               # Sort: order list items ('P' < 'c')\nprovide type-specific tools; the list methods presented here, for instance, are\nDemoed in the preceding code, append is perhaps the most commonly used list\nUnlike concatenation, append expects you to pass in one object, not a list, and\nformer changes L in place, while the latter makes a new list.3\nBy contrast, the extend method adds multiple items at the end of the list, again\nThe sort method orders the list’s items but merits a section of its own.\nSorting lists\nAs we’ve just witnessed, sort orders a list in place.\nreturns the value to be used in sorting—the string object’s standard lower case\n>>> L.sort(key=str.lower, reverse=True)     # And change sort order\nThe sort key argument can also be useful when sorting lists of dictionaries, to\nselect a sort value by indexing each dictionary on a field along the way.\nTo work around this limitation, use the key\nconverts all items to strings with the str built-in, but key can be an arbitrary\n>>> L.sort(key=str)\nSecond, beware that append, extend, and sort change the associated list object\nyou won’t get the modified value of L; in fact, you’ll lose the reference to the list\nWhen you use methods like these, objects are changed as a side\nsorted built-in function, which sorts any collection (not just lists) and returns a\nnew list for the result (instead of changing the collection in place):\n>>> sorted(L, key=str.lower, reverse=True)         # Same arguments as list.sort\nresult does not contain the original list’s values as it does with the key argument.\nMore List Methods\nLike strings, lists have other methods that perform other specialized operations.\nFor instance, reverse reverses the list in place, and pop deletes one item at the\ndoes not change the list in place.\na new list like sorted; it instead returns an iterable object that produces results\n>>> list(reversed(L))                # Reversal built-in with a result (iterable)\nIn some types of programs, the list pop method is used in conjunction with\nOther list methods remove an\n>>> L.remove('code')                 # Delete by value\nNote that unlike other list methods, count and index do not change the list\ninteractively on your own to learn more about list methods.\nLists also respond to other sequence operations we used on strings in the prior\nloops (and coerced by list to surrender its values for display here).\nThe last items in Table 8-1, list comprehensions and map calls, were also\nloops, and build a new list by applying an expression to each item in a sequence\n>>> res = [x * 4 for x in 'code']            # List comprehension\nchapters, list comprehensions are simpler to code and may run faster:\nList-literal unpacking\nAs of Python 3.5, list literals also support a * syntax that unpacks the contents of\nany iterable (including sequences like lists and strings) at the top level of the list\nThe effect flattens the starred item in the new list:\n>>> [*L, 2, 3, *L]                           # Iterable unpacking in list literal\n>>> L + [2, 3] + L                           # What * unpacking does, for lists     \nOther List Operations\nBecause lists are mutable, you can also use the del statement to delete an item or\ncan also delete a section of a list by assigning an empty list to a slice (L[i:j]=\nAssigning an empty list to an index, on the other hand, just stores a reference to\nthe empty list object in the specified slot, rather than deleting an item:\nlist methods and operations not illustrated here.\ncopy of the list, much like L[:] and list(L), but is symmetric with copy\nmethods in sets and dictionaries.\nFor a comprehensive and up-to-date list of type\nmutable objects: they won’t work on strings (or tuples, coming up in Chapter 9),\nDictionaries\nAlong with lists, dictionaries are one of the most flexible built-in object types in\nIf you think of lists as order-based collections of objects, you can think\nof dictionaries as key-based collections; the chief distinction is that in\ndictionaries, items are stored and fetched by key, instead of by positional offset.\nWhile lists can serve roles similar to arrays in other languages, dictionaries can\ndictionaries are:\ncorresponding keys, so you can fetch an item out of a dictionary using the\noperation to get components in a dictionary as you do in a list, but the index\nUnlike in a list, keys in a dictionary are ordered only by the order in which\nlike lists: items added to dictionaries later always show up at the end of the\nkeys list (even if they appeared earlier in the past), and there is no way to\ninsert a key into the middle of the keys list.\nof Python 3.7, before which keys’ left-to-right order was pseudo random.\nLike lists, dictionaries can grow and shrink in place (without new copies\nto any depth (they can be freely mixed with lists, other dictionaries, and so\nYou can change dictionaries in place by assigning to indexes (they are\nand lists.\nBecause dictionaries are key-based collections, operations that\nIf lists are arrays of object references that support access by position,\ndictionaries are tables of object references that support access by key.\nLike lists, though, dictionaries store object references (not\nhelp(dict) call for a complete list (dict is the built-in name of the dictionary\nEmpty dictionary\nTwo-item dictionary\nkey/value pairs, zipped key/value lists, key lists\nkey])\nD.keys()\nMethods: all keys,\nall key+value tuples,\nD.get(key, default?)\nD.pop(key, default?)\nremove/return any (key, value) pair; etc.\nD[key] = 62\nAdding keys, changing key values\ndel D[key]\nlist(D.keys())\nPer Table 8-2, when coded as a literal expression, a dictionary is written as a\ndictionaries by simply coding one as a value inside another dictionary, or within\nAs Table 8-2 summarizes, dictionaries are indexed by key, and nested dictionary\nPython creates a dictionary, it stores its items in a way that associates values with\nitems by key with indexing:\n>>> D = {'hack': 1, 'Py': 2, 'code': 3}       # Make a dictionary\n>>> D['Py']                                   # Fetch a value by key\nHere, the dictionary is assigned to the variable D; the value of the key 'Py' is the\nby key as we did to index lists by offset, but here it means access by key, not by\nstudied in Chapter 5, dictionary keys retain their insertion order today, but we\nvalues stored in the dictionary or, equivalently, the number of its keys.\ndictionary in membership operator allows you to test for key existence, and the\nkeys method returns all the keys in the dictionary.\nuseful for processing dictionaries in full, by fetching corresponding values in\nBecause the keys result can be treated like a normal list, it can also be\n>>> len(D)                                    # Number of entries in dictionary\n>>> 'code' in D                               # Key membership test\n>>> list(D.keys())                            # Create a new list of D's keys\nstrings and lists also works on dictionaries, where it checks whether a key is\nIt uses list for similar\nreasons—the dictionary keys method returns an iterable “view” object that\nDictionaries, like lists, are mutable,\ndictionaries: simply assign a value to a key to change or create an entry.\nNotice also the nesting of a list inside a dictionary in this example\n(the value of the key 'Py'); all collection data types in Python can nest inside\n>>> D['Py'] = ['app', 'dev']                      # Change entry (value=list)\n>>> D['Py'][0] = 'program'                        # Change a nested list in place\nLike lists, assigning to an existing index in a dictionary changes its associated\nUnlike lists, however, whenever you assign a new dictionary key (one that\nlist, you need to use tools such as the append method or slice assignment\nMore Dictionary Methods\nDictionary methods provide a variety of type-specific tools.\ndictionary values and items methods return all of the dictionary’s values and\n(key,value) pair tuples, respectively; along with keys, these are useful in loops\nthat need to step through dictionary entries one by one (we’ll start coding such\nAs with keys, these two methods also return iterable\nobjects, and wrapping them in a list call collects their values all at once for\n>>> list(D.keys())                                 # All keys\n>>> list(D.values())                               # All values\n>>> list(D.items())                                # All (key, value) tuples \n>>> print(D.get('code'))                   # A key that is missing\n(though it works in the realm of keys and values, not just values).\nkeys and values of one dictionary into another, both adding new entries for new\n>>> D2 = {'code':4, 'hack':5, 'app': 6}    # New keys added, app:6 wins        \nFinally, the dictionary pop method deletes a key from a dictionary and returns\nIt’s similar to the list pop method, but it takes a key instead of\n>>> D.pop('app')                           # Pop a dictionary key\n>>> D.pop('hack')                          # Delete key and return its value\n>>> L = ['aa', 'bb', 'cc', 'dd']           # Pop a list by position\nbeyond those listed in Table 8-2; again, see the Python library manual, dir and\nliteral and key-assignment forms listed above them:\nD = {}                                  # 2) Assign by keys dynamically\ndict([('name', 'Pat'), ('age', 40)])    # 4) dict key/value tuples form\nAll four of these forms create the same two-key dictionary, but they are useful in\nThe last is useful if you need to build up keys and values as sequences\nWe met name=value keyword arguments earlier when sorting lists; the dict\nfunction, to combine separate lists of keys and values obtained dynamically at\ndict(zip(keyslist, valueslist))        # Zipped key/value tuples form (ahead)\nThere is more on zipping dictionary keys in the next section.\nkey’s values are the same initially, you can also create a dictionary with the\nfollowing special form—simply pass in a list of keys and an initial value for all\nyour Python career, you’ll probably find uses for all of these dictionary-creation\nAs of Python 3.5, dictionary literals also support a special ** syntax that\nunpacks the contents of another dictionary in its top level, similar to the * in list\nnumber of dictionaries, and the rightmost’s value wins when keys collide:\n>>> {'a': 1, 'b': 2, **D}                     # Dictionary-literal unpacking\nLike the set and list comprehensions we met in previous coverage, dictionary\ncomprehensions run an implied loop, collecting the key/value results of\nexpressions on each iteration and using them to fill out a new dictionary.\nThe net effect lets us create new dictionaries with small bits of code that are\nits keys and values with zip, and pass the result to the dict call, per the last\ndictionary from key and value lists this way—if you cannot predict the set of\nkeys and values in your code, you may be able to build them up as lists and zip\n>>> list(zip(['a', 'b', 'c'], [1, 2, 3]))        # Zip together keys and values\nnet effect builds a new dictionary with a key/value pair for every such pair in the\ncollected keys can be computed with expressions just like collected values:\nDictionary comprehensions are also useful for initializing dictionaries from keys\nlists, in much the same way as the fromkeys method we met at the end of the\n>>> D = dict.fromkeys(['a', 'b', 'c'], 0)        # Initialize dict from keys\n>>> D = dict.fromkeys('code')                    # Other iterables, default value\nLike its list and set relatives, dictionary comprehensions support additional\nBy now, you’ve probably noticed that dictionaries remember their keys’ order—\nand in Chapter 4, as of Python 3.7 (and CPython 3.6), dictionaries have shed\nsame as a list (e.g., there’s no way to add a key in the “middle”) and doesn’t\n>>> D = dict(a=1, b=2)              # Literal keys stored left-to-right\n>>> D['c'] = 3                      # New keys always added at the end\n>>> D.pop('b')                      # Method pop removes any key by name\n>>> D                               # Other keys still in insertion order\n>>> D['b'] = 2                      # Earlier key goes at the end too\n>>> D['c'] = 0                      # Changing values doesn't impact order\ndictionaries is much like the LIFO stack ordering we coded with list append and\nkey/value pair (really, tuple) for the key added most recently (i.e., at the end):\ndictionary keys manually, using techniques we’ll study ahead.\nfilenames for display, for example, will often warrant string-value sorts instead\nIt’s a positionally sensitive, key-based merge of dictionaries, that works the same\nas the dictionary update method but returns its result as a new dictionary instead\nThe Python 3.5 dictionary-literal unpacking we explored earlier can have the\n(the keys) to titles (the values).\n>>> table['2024']                                          # Key => Value\nseparated list of keys and their values (recall from Chapter 7 that \\t in a Python\nDictionaries aren’t sequences like lists and strings, but if you need to step\nthrough the items in a dictionary, it’s easy—either call the dictionary keys\nmethod or use the dictionary itself.\nGiven a dictionary D, saying for key in D\nworks the same as saying for key in D.keys(), and both use the iteration\nkey to value inside the for loop as you go, as this code does.\nMapping values to keys\n>>> table['Learning Python']                               # Key => value\nOr use other dictionary methods like items that give searchable sequences (the\nlist call is required in the following because items returns an iterable view, a\n>>> list(table.items())[:2]\n>>> [title for (title, year) in table.items() if year == 1999]     # Value => key\nThe last command here uses the list comprehension we explored earlier, as well\npairs returned by the dictionary’s items method, selecting keys for values\nThe net effect of all this is to index backward—from value to key, instead of key\nslower than a direct key-to-value index, though not all programs need to care).\nIn fact, although dictionaries by nature map keys to values unidirectionally, there\n>>> table[K]              # Key = >Value (normal usage)\n>>> [key for (key, value) in table.items() if value == V]         # Value => Key\nNote that both of the last two commands return a list of titles: in dictionaries,\nrepresent many values per key.\nSharp-eyed readers may notice that this yields a dictionary with integer keys,\nvalues) simply don’t apply—and Python raises an error if your code tries to\nuse them on dictionaries.\nKeys can be created when you write a dictionary literal (embedded in the\ncode of the literal itself), or when you assign values to new keys of an\nKeys need not always be strings\nOur examples so far have used strings as keys, but any other immutable\nmakes the dictionary look much like a list (when indexing, at least).\nmay be used as dictionary keys too, allowing compound key values—such as\nMutable objects such as lists, sets, and other\ndictionaries don’t work as keys because they may change, but are allowed as\nUsing dictionaries to simulate flexible lists: Integer keys\nWhen you use lists, it is illegal to assign to an offset that is off the\nend of the list:\nIndexError: list assignment index out of range\nkeys, dictionaries can emulate lists that seem to grow on offset assignment:\nHere, it looks as if D is a 100-item list, but it’s really a dictionary with a single\nentry; the value of the key 99 is the string 'hack'.\nwith offsets much like a list, catching nonexistent keys with get or in tests if\n>>> table = {2024: 'Learning Python, 6th Edition',      # Integers work as keys\nUsing dictionaries for sparse data structures: Tuple keys\nIn a similar way, dictionary keys are also commonly leveraged to implement\ntwo-item dictionary.\nmessage—you can use the dictionary get method shown earlier to provide a\nfor example, fills out a dictionary describing a book, by assigning to new keys:\nThe following again uses a dictionary to\nkey separately, and nests a dictionary and list to represent structured property\nTo fetch components of nested objects, simply string together indexing\ndatabase collection coded as a list or dictionary, though an external file or",
      "keywords": [
        "Python",
        "Learning Python",
        "list",
        "key",
        "keys",
        "dictionary",
        "code",
        "method",
        "Python expression code",
        "Python list objects",
        "Python list",
        "dictionaries",
        "object",
        "list methods",
        "dictionary keys"
      ],
      "concepts": [
        "dictionary",
        "dictionaries",
        "list",
        "keys",
        "key",
        "python",
        "value",
        "strings",
        "coded",
        "codes"
      ],
      "similar_chapters": [
        {
          "book": "Learning Python Ed6",
          "chapter": 4,
          "title": "",
          "score": 0.65,
          "base_score": 0.5,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 10,
          "title": "",
          "score": 0.639,
          "base_score": 0.489,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 9,
          "title": "",
          "score": 0.629,
          "base_score": 0.479,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 6,
          "title": "",
          "score": 0.56,
          "base_score": 0.41,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 5,
          "title": "",
          "score": 0.528,
          "base_score": 0.378,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "list",
          "key",
          "keys",
          "dictionary",
          "lists"
        ],
        "semantic": [],
        "merged": [
          "list",
          "key",
          "keys",
          "dictionary",
          "lists"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.41668849284589804,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:10.090654+00:00"
      }
    },
    {
      "chapter_number": 8,
      "title": "Lists and Dictionaries",
      "start_page": 321,
      "end_page": 380,
      "summary": ">>> list(D.items())\nTypeError: 'dict_keys' object is not subscriptable\nAttributeError: 'dict_keys' object has no attribute 'sort'\nUnlike lists, though, dictionary views don’t take up space for their full results,\nchanges made to the dictionary after the view object has been created:\n>>> del D['b']                    # Change the dictionary in place\n>>> list(K), list(V)              # Reflected in any current view objects\nby the keys method are set-like, values views are not, and items views are if\nlogical symmetry: set items are unique and immutable just like dictionary keys,\nprior section’s session); as also shown, dictionary value views are never set-like,\n>>> K | {'x': 4}                   # Keys (and some items) views are set-like\ncontain only immutable objects:\n>>> D.items() | {('c', 3), ('d', 4)}           # Set of key/value pairs\ncollection in sorted order won’t work, because keys does not return a list:\n>>> Ks = D.keys()                            # Sorting a view object doesn't work!\nAttributeError: 'dict_keys' object has no attribute 'sort'\nTo work around this, you can either convert keys to a list manually, or use the\nsorted call, applied to lists earlier in this chapter, on either a keys view or the\n>>> Ks = list(D.keys())                      # Convert keys to a list\nIn this chapter, we explored the list and dictionary types—probably the two most\ncommon, flexible, and powerful collection types you will see and use in Python\nWe learned that the list type supports positionally ordered collections of\nThe dictionary type is similar, but it stores items by key instead of by\nBoth lists and dictionaries are\nstrings: for example, lists can be grown by slice assignment and append calls,\nIn the next chapter, we will wrap up our in-depth core object-type tour by\nlooking at tuples and files.\n3. Name four operations that change a list object in place.\n4. Name four operations that change a dictionary object in place.\n5. Why might you use a dictionary instead of a list?\nWith all the objects in Python’s core types arsenal, some readers may be\nboth are flexible collections of other objects, lists assign items to positions,\nFor some types of data, the list’s access-by-position makes sense—a list of\ncommon to see code that processes lists constructed dynamically (at runtime), from user inputs, file\nFor instance, L.insert(0, X) can also append an item to the front of a list, and\nL.insert(len(L), X) inserts one object at the end too, but\nunless you like typing, you might as well use L.append(X)!\n4  As for lists, you might not see dictionaries coded in full using literals very often—programs rarely\nLists and dictionaries are grown in different ways, though.\nthat you often build up dictionaries by assigning to new keys at runtime; this approach fails for lists,\nTuples, Files, and\nThis chapter rounds out our in-depth tour of the core object types in Python by\nexploring the tuple, a collection of other objects that cannot be changed, and the\nrelatively simple object that largely performs operations you’ve already learned\nabout for strings and lists.\nThe file object is a commonly used and full-featured\ncommon to all the core object types we’ve met—the notions of equality,\ncomparisons, object copies, and so on.\nobject story in Python is broader than implied thus far.\npart of the book by taking a look at a set of common object type pitfalls and\nOne logistics note up front: as for strings in Chapter 7, our exploration of files\nfiles in this chapter as well as their extensions in Chapter 37.\nThe last collection type in our survey is the Python tuple.\nThey work much like lists, except that tuples can’t be\nmethods, tuples share most of their properties with lists.\nLike strings and lists, tuples are positionally ordered collections of objects\ndictionaries, they can embed any kind of object.\nLike strings and lists, items in a tuple are accessed by offset (not by key);\nLike strings and lists, tuples are sequences; they support many of the same\nHowever, like strings, tuples are immutable; they don’t support\nany of the in-place change operations applied to lists.\nOn the other hand, tuples may contain any type of object,\nincluding other collection objects (e.g., lists, dictionaries, and other tuples),\nArrays of object references\nLike lists, tuples are best thought of as object reference arrays: tuples store\naccess points to other objects (references), and indexing a tuple is relatively\na tuple is written as a series of objects (technically, expressions that generate\nTable 9-1 that tuples do not have most of the methods that lists have (e.g., an\noperations that we explored for both strings and lists, compare recursively as\nsomething special to tell Python when a single object in parentheses is a tuple\nseparated items we’ve typed at the REPL print with parentheses—it’s a tuple:\nlarger object like a list or dictionary\nTable 9-1) are identical to string and list operations.\ntuples, and that tuples don’t provide the same methods you saw for strings, lists,\neither first convert it to a list to gain access to a sorting method call and make it a\nmutable object, or use the newer sorted built-in that accepts any sequence\nobject (and other iterables—a term introduced in Chapter 4 that we’ll be more\n>>> tmp = list(T)                  # Make a list from a tuple's items\n>>> T = tuple(tmp)                 # Make a tuple from the list's items\nHere, the list and tuple built-in functions are used to convert the object to a\nlist and then back to a tuple.\nReally, both calls make new objects from any sort\nIn some sense, list comprehensions can also be used to convert tuples.\nfollowing, for example, makes a list from a tuple, adding 20 to each item along\n>>> L = [x + 20 for x in T]        # Like list(T) + expression logic\nlists, but they may be used to iterate over any sequence objects, including tuples,\nstrings, and other lists.\nincluding files, which are automatically read line by line.\nNotice that you’d have to convert the prior example’s list result back to a tuple if\nThere is no tuple comprehension in Python (as explored\nAlthough tuples don’t have the same methods as lists and strings, they do have\ndefined for tuple objects:\nA list inside a tuple, for instance, can be\nTypeError: 'tuple' object does not support item assignment\nWhy Lists and Tuples?\nbeginners about tuples: why do we need tuples if we have lists?\nreason is philosophical: a tuple is meant to be a simple association of objects,\nTuples can also be used in places that lists cannot—for example, as dictionary\nalso require or imply tuples instead of lists (e.g., the substitution values in the %\nchapter’s sidebar “Why You Will Care: List Versus Dictionary Versus Set”, we\nsaw how to represent record-like information with both a list and a dictionary\nAs for lists, though, field numbers in tuples generally carry less information than\nIn fact, we can convert parts of the dictionary to tuples if needed:\n>>> list(pat.items())                                      # Items to tuple list\nBut really, this is a false dichotomy: with extra code, we can implement objects\ncode to use (the two startup lines in the preceding examples that import the type\nbuilt-in types like tuples when extra utility is desired.\nFiles\nThe last major built-in object type that we’ll examine on our\nobject-types tour provides a way to access those files inside Python programs.\nIn short, the built-in open function creates a Python file object, which serves as a\nobject’s methods.\nCompared to the types you’ve seen so far, file objects are outliers.\nexpression operators; they export only methods for common file-processing\nthe external file associated with a file object, but other file methods allow us to\nCommon file operations\nRead entire file into a single string\nRead entire file into a list of line strings (with \nfile\nWrite all line strings in a list into a file\nChange file position to offset N for next\nFile iterators read line by line\nUnicode text files (using str strings)\nBytes files (using bytes strings)\nOpening Files\nTo open a file, a program calls the built-in open function, with the external\ncall returns a file object, which in turn has methods for data transfer:\nA filename a/b/file.txt,\nfor example, includes the path prefix a/b that leads to a file on Unix (e.g.,\nAs you’ll see in Chapter 37’s expanded file coverage, the filename may also\nfile content.\nAdding a + to the mode (e.g., 'r+') opens the file for both input and\nYou can read and write to the same file object, often in\nBoth of the first two arguments to open must be Python strings.\ntypes of files (e.g., the string name of a Unicode encoding for text files).\nalso use name=value keywords to pass open arguments (e.g., file=name,\nwon’t go into all file-processing mode options; run help(open) in a REPL or\nUsing Files\nOnce you make a file object with open, you can call its methods to read from or\nstrings in Python programs; reading a file returns its content in strings, and\nFile iterators may be best for reading text lines\nmind that probably the best way to read lines from a text file today is to not\nread the file at all—as you’ll see in Chapter 14, files also have an iterator\nContent is strings, not objects\nNotice in Table 9-2 that content read from a file always comes back to your\nscript as a string, so you’ll have to convert it to a different type of object if a\nSimilarly, file write operations do not add any\nsort of formatting and do not convert objects to strings automatically, so you\nhave already met to convert objects from and to strings (e.g., int, float,\nstr, and string formatting) come in handy when dealing with files.\ntext from file reads is sent to print to avoid double spacing.\nobject storage (the pickle module), for dealing with packed binary data in\nfiles (the struct module), and for processing special types of content such\nBy default, output files are always buffered, which means that text you write\nAs discussed in Chapter 6, an object’s memory space is\nWhen file objects are reclaimed, Python also\nmanually close your files in Python, especially those in simple scripts with\nIn fact, when many files are opened within\nClose calls may sometimes also be required to flush buffered output of file\nobjects not yet reclaimed.\ncloses, watch for the file object’s context manager ahead.\nLet’s work through an example that demonstrates file-processing basics.\nfollowing code begins by opening a new text file for output, writing two lines\n(strings terminated with a newline marker, \\n), and closing the file.\nexample opens the same file again in input mode and reads the lines back one at\n>>> myfile.write('hello text file\\n')       # Write a line of text: string\n>>> myfile.write('goodbye text file\\n')\n'hello text file\\n'\n'goodbye text file\\n'\n>>> myfile.readline()                       # Empty string: end-of-file\nfile read methods tell you that you’ve reached the end of the file (and as you’ll\nfile instead come back as strings containing just a newline character ('\\n'), not\nAlso notice that file write calls return the number of characters written; this is\nIf you want to display the file’s content with newline characters interpreted, read\nthe entire file into a string all at once with the file object’s read method and\nprint it (stringing together the open and read like this runs left to right and\nhello text file\ngoodbye text file\nAnd if you want to scan a text file line by line, file iterators are often your best\n>>> for line in open('myfile.txt'):         # Use file iterators, not reads\nhello text file\ngoodbye text file\nWhen coded this way, the temporary file object created by open will\nAs noted, files content is always strings, so other kinds of objects must be\nthis book, where you’ll learn how to route its display to a file you make first\n>>> myfile = open('myfile2.txt', 'w')       # Nonstring objects fail\nis and get a listing of the files there, with the os standard-library module:\n>>> os.listdir()                  # List files here (or in a passed path)\nequivalent to /Users/me/code/Chapter09/myfile.txt in open and other tools.\nStrictly speaking, the examples in the prior section use text files.\nfile type is determined by the second argument to open, the mode string—\nText files represent content as a normal str string, perform Unicode\nBinary files represent content as a special bytes string and allow\ntext-file interface used in the prior examples, and normal strings.\nto match object types to file modes—bytes strings for binary files, and normal\nstr strings for text files.\nBecause text files implement Unicode encodings, you\nalso should not open a binary data file in text mode: decoding its content to\nWhen you write and read a binary file, you send\n>>> myfile = open('myfile3.bin', 'wb')        # Make binary file: wb=write binary\n>>> data = open('myfile3.bin', 'rb').read()   # Read binary file: rb=read binary\ntext files by default map all forms to and from \\n when read and written.\nUnicode text and binary data files here, and just enough to understand upcoming\nFor this chapter, let’s move on to a handful of more substantial file examples that\ndemonstrate common ways to store Python object values in files.\nStoring Objects with Conversions\nOur next example writes a variety of Python objects to a text file on multiple\nAgain, file content is strings in our code, and\n>>> X, Y, Z = 62, 63, 64                       # Native Python objects\n>>> S = 'Text'                                 # Must be strings to store in file\n>>> F = open('datafile.txt', 'w')              # Create output text file\nOnce we have created our file, we can inspect its contents by opening it and\ntext file to real Python objects.\nAs Python never converts strings to numbers (or\nother types of objects) automatically, this is required if we need to gain access to\nnormal object tools like indexing, addition, and so on:\nwhich contains numbers, and parse out (that is, extract) the objects on that line:\nAs we have learned, int translates a string of digits into an integer object, and\nFinally, to convert the stored list and dictionary in the third line of the file, we\n>>> eval(parts[0])                             # Convert to any object type\n>>> objects = [eval(P) for P in parts]         # Do same for all in list\n>>> objects\nPython objects instead of strings, we can now apply list and dictionary\nStoring Objects with pickle\nUsing eval to convert from strings to objects, as demonstrated in the preceding\nrun any Python expression—even one that might delete all the files on your\nPython objects, but you don’t want to run file content as program code, Python’s\nPython object in a file directly, with no to- or from-string conversion\nTo store a dictionary in a file, for instance, we pickle it directly after\nusing binary mode to open the file:\n>>> pickle.dump(D, F)                          # Pickle almost any object to file\n>>> E = pickle.load(F)                         # Load almost any object from file\nWe get back an equivalent dictionary object, with no manual splitting or\nserialization—converting objects to and from strings of bytes—but requires very\npickle to store Python objects in an access-by-key filesystem, which is beyond\nStoring Objects with JSON\nThe prior section’s pickle module translates nearly arbitrary Python objects to a\nJSON does not support as broad a range of Python object types as pickle, but\nserialize a specific category of Python objects for storage and transmission.\nMoreover, because JSON is so close to Python dictionaries and lists in syntax,\nthe translation to and from Python objects is trivial, and is automated by the\nFor example, a Python dictionary with nested structures is very similar to JSON\nThe final dictionary format displayed here is a valid literal in Python code, and\ntranslation official—here translating Python objects to and from a JSON\nIt’s similarly straightforward to translate Python objects to and from JSON data\nstrings in files.\nPrior to being stored in a file, your data is simply Python objects;\nIn both cases, we use text files, because JSON is text:\n>>> json.dump(rec, fp=file, indent=4)         # Python => JSON\n>>> file.close()\n>>> print(open('testjson.txt').read())        # Human-readable file content\nPython object operations in your script.\nreal Python dictionaries and lists in an imported Python .py module file, and the\nwhen transferring text to and from files.\nencodings to JSON (and other) files and data in Chapter 37.\nStoring Objects with Other Tools\nFor other common ways to deal with formatted data files, see the standard\n>>> file = open('data.bin', 'wb')               # Write/read file, and unpack\n>>> file.close() \nfiles and strings; it doesn’t map as directly to Python objects (and requires post-\nparse conversions), but is another way to map value to and from files:\nYou’ll also want to watch for Chapter 34’s in-depth discussion of the file’s\nwith open('data.txt') as myfile:              # File closed on \"with\" exit \nprecise (though we can often avoid both options and let Python close files for us\nPythons and may be more useful for output files to guarantee buffer flushes;\nOther File Tools\nwritelines process file content in line lists.\ninteractively, passing in open or a file object made with it.\nAnd for more file-\nAlso, note that although the open function and the file objects it returns are your\nmain interface to external files in a Python script, there are additional file-related\nPreopened file objects in the sys module, such as sys.stdout, connected by\nInteger file handles that support lower-level tools such as read-only access\nFile-like objects used to synchronize processes or communicate over\nUsed to store unaltered and pickled Python objects directly, by key (see\nThe third-party open source domain offers even more file-like tools, including\nadditional information on file-like tools.\nFor code spelunkers, it’s also worth noting that Python’s open function is really\nNow that we’ve seen all of Python’s built-in objects in action, let’s wrap up our\nobject-types tour by reviewing some of the properties they share.\nObjects share operations according to their category.\nYou cannot change numbers, strings, or tuples in place, but can\nthe same as Python object mutability.\nIn addition to type category operations, all the objects types in Table 9-3\nObject classifications\nObject type\nFiles\nIn Part VI of this book, you’ll learn that objects implemented with classes\nObject Flexibility\nLists, dictionaries, and tuples can hold any kind of object.\nSets can contain any type of immutable object.\nLists, dictionaries, and tuples can be arbitrarily nested.\nBecause they support arbitrary structures, Python’s compound object types are\ndictionaries may be lists, which may contain tuples, which may contain\nChapter 6 mentioned that assignments always store references to objects, not\ncopies of those objects.\nassignments can generate multiple references to the same object, though, it’s\nimportant to be aware that changing a mutable object in place may affect other\nreferences to the same object elsewhere in your program.\nbehavior, you’ll need to tell Python to copy the object explicitly.\nthe following example creates a list assigned to X, and another list assigned to L\nanother reference back to list X:\n>>> L = ['a', X, 'b']            # Embed references to X's object in two others\nAt this point, there are three references to the first list created: from the name X,\nfrom inside the list assigned to L, and from inside the dictionary assigned to D.\nShared objects: changing from X makes it look different from L and D too\nBecause lists are mutable, changing the shared list object from any of the three\nThe dictionary, set, and list copy method (X.copy()) copies a\ndictionary, set, or list.\nSome built-in functions, such as list and dict make copies (list(L),\nFor example, say you have a list and a dictionary, and you don’t want their\nsame objects:\n>>> L = ['a', X[:], 'b']           # Embed copies of X's object\nX = copy.deepcopy(Y)               # Fully copy an arbitrarily nested object Y\nAll Python objects also respond to comparisons: tests for equality, relative\nWe’ve seen comparison at work on specific objects in\nIn short, Python comparisons always inspect all parts of compound objects until\nWhen nested objects are present, Python\neach of their nested objects, and so on, until a result is found.\nof list objects compares all their components automatically until a mismatch is\n>>> L1 = [1, ('a', 3)]           # Same value, but different objects\nSame object?\nHere, L1 and L2 are assigned lists that are equivalent but distinct objects.\nequivalence test, comparing all nested objects recursively.\nThe is operator tests object identity.\nOf course, because strings are immutable, the object caching mechanism is\nMore broadly, Python compares its core object types as follows:\nDictionaries compare as equal if their sorted (key, value) lists are\nIn later chapters, you’ll also see that class-based objects can change the way they\nAs noted in Chapter 8, magnitude comparisons don’t work for dictionaries\nthat doesn’t compare sorted key/value lists:\nas also shown in Chapter 8, simply compare sorted key/value lists manually by\n>>> list(D1.items())\nCollection objects are false if empty, and true otherwise.\nThe None placeholder object is always false.\nTable 9-4 gives examples of true and false values of various objects in Python.\nExample object truth\nObject\nAs one application of this, because objects are true or false themselves, it’s\ncommon to see Python programmers code tests like if X:, which, assuming X is\nIn other words, you can test the object\nThe None object\nAs shown in the last row in Table 9-4, Python also provides a special object\nin Chapter 4; it is the only value of a special data type in Python and typically\noffsets, you can fill it with None objects:\nthis special object later in the book; as you’ll learn in Part IV, it is also the\nvalue of an object.\nOther objects in Figure 9-3 are\nan object type.\nobjects are on equal footing with respect to your code.\na class to a function, assign it to a variable, stuff it in a list or dictionary, and so\nType Objects\nIn fact, even types themselves are an object type in Python: the type of an object\nis an object of type type (and not just because it’s a decent tongue twister!).\nSeriously, a call to the built-in function type(X) returns the type object of object\nX. The practical application of this is that type objects can be used for manual\ntype comparisons in Python if statements.\nroles, including type customization through object-oriented subclassing: dict,\nlist, str, tuple, int, float, complex, bytes, type, set, and more.\nPython’s major built-in object types, organized by categories\nOther Types in Python\nobjects such as functions, modules, and classes that you’ll meet later, a typical\nPython installation has dozens of additional object types available as linked-in C\nextensions or imported Python classes—regular expression objects, GUI\nwidgets, network sockets, and so on.\n(e.g., 4 for an integer, [1,2] for a list, the open function for files, and def and\nsequence type, along with lists and tuples, but this is an academic sleight of hand that we won’t\nAs you’ll see later, range returns an iterable object that produces\none more time: shared references to mutable objects can matter.\nfor instance, the list object assigned to the name L is referenced both from L and\nIf objects change out from under you\nreferences back to the original list assigned to L, and so is open to the same sorts\nas this is really just another way to create the shared mutable object reference\nlevel of their operand objects, these sorts of cases make much more sense.\ncollection object contains a reference to itself, it’s called a cyclic object.\n>>> L = ['stuff']                # Append reference to same object\n>>> L.append(L)                  # Makes a cycle back to the same object: [...]\nhave code that knows how to handle them, objects that reference themselves\nAnd just once more for completeness: you cannot change an immutable object in\nobjects like tuples and strings; because they can’t be changed in place, they are\nnot generally open to the sorts of side effects that can imperil mutable objects\nlike lists and dictionaries.\nThis chapter explored the last two major core object types—the tuple and the\nfile.\nAlong the way we explored how to translate Python objects to and from strings\nfor storing in files, and we looked at pickle, json, and other modules for\nadvanced roles (object serialization and binary data).\nreviewing some properties common to all object types (e.g., shared references)\nand went through a list of common mistakes (“gotchas”) in the object-type\nobjects, so make sure you’ve mastered this domain by working through all the\n3. What is the default for the processing mode argument in a file open",
      "keywords": [
        "Python",
        "Python objects",
        "file",
        "object",
        "list",
        "Python file object",
        "file object",
        "tuple",
        "text file",
        "object types",
        "Python object types",
        "type",
        "open",
        "Pat",
        "text"
      ],
      "concepts": [
        "files",
        "object",
        "python",
        "type",
        "typing",
        "typed",
        "list",
        "dictionary",
        "dictionaries",
        "strings"
      ],
      "similar_chapters": [
        {
          "book": "Learning Python Ed6",
          "chapter": 5,
          "title": "",
          "score": 0.535,
          "base_score": 0.385,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 9,
          "title": "",
          "score": 0.532,
          "base_score": 0.382,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 7,
          "title": "",
          "score": 0.4,
          "base_score": 0.25,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 10,
          "title": "",
          "score": 0.364,
          "base_score": 0.214,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 4,
          "title": "",
          "score": 0.336,
          "base_score": 0.186,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "file",
          "object",
          "objects",
          "list",
          "files"
        ],
        "semantic": [],
        "merged": [
          "file",
          "object",
          "objects",
          "list",
          "files"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.301215122148044,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:10.090682+00:00"
      }
    },
    {
      "chapter_number": 9,
      "title": "Tuples, Files, and Everything Else",
      "start_page": 381,
      "end_page": 440,
      "summary": "4. What module might you use to store Python objects in a file without\n6. When does Python consider an object to be true?\nfor any container object in Python, including tuples.\n4. The pickle module can be used to store Python objects in a file without\nset of Python objects to and from strings per the JSON format.\nonto a single line: for example, X=1;X assigns and then prints a variable\n(more on statement syntax in the next part of the book).\nare no enclosing parentheses: X,Y,Z is a three-item tuple, which Python\nS = 'Python'\n'coding %s is %s!' % (S, how)\nc. Finally, how does Python handle it if you try to extract a\nHint: try assigning to this slice\nassign an empty list to one of its offsets (e.g., L[2]=[]).\nThen, assign an empty list to a slice (L[2:3]=[]).\nWhat happens when you assign a\n4. Tuple assignment: Type the following lines:\n>>> X = 'code'\nWhat does Python do if you try to assign to a nonexistent\nbounds assignments and references for lists?\ndifferent/mixed types (e.g., string + list, list + tuple)?\nc. Does the append method work for both lists and strings?\nWrite an assignment that changes the string to 'heck', using\ncombination of built-in object types you like (lists, tuples, dictionaries,\nStatements\nNow that you’re familiar with Python’s built-in objects, this chapter begins our\nfollow up with more details about specific statements in the next few chapters.\nIn simple terms, statements are the code we write to tell Python what our\nLess informally, Python is a procedural, statement-based language; by\ncombining statements, we specify a procedure that Python performs to satisfy a\n3. Statements contain expressions.\nstatements and expressions.\nstatements.\nStatements code the larger logic of a program’s operation—they use\nMoreover, statements are where objects spring into existence (e.g., in\nexpressions within assignment statements), and some statements create entirely\nAt the top, statements\nPython’s Statements\nTable 10-1 summarizes Python’s statement set.\nEach statement in Python has its\nTable 10-1 also gives examples of each statement,\nearlier, introduce the rest of Python’s procedural statement set, and cover the\nstatements (like del, which deletes various components) are covered elsewhere\nPython statements\nStatement\nAssignment\na, b = 'python', 3.12\nprint(hack, code, file=log)\nAssignment statements come in a wide variety of syntax flavors,\nnamed assignment (:=) is used as an expression, not a statement.\nstatement.\nstatement, though, and usually on a line by itself, it’s generally thought\nof as a statement type, and will be treated separately in Chapter 11.\nyield and await are also expressions instead of statements.\nprint, they’re often used as expression statements and so are included\nin this table, but scripts may also assign or otherwise use their result, as\nMost of the words used in statements and expressions are reserved and\nthis book wishes to begin our look at Python statement syntax by showing you\nwhat you are not going to type in Python code.\nConsider the following if statement, coded in a C-like language:\nthe equivalent statement in the Python language:\nThe first thing that may pop out at you is that the equivalent Python statement is\nThe one new syntax component in Python is the colon character (:).\nAll Python\nfollowed by a nested block of code usually indented underneath the header line,\nNested statement block\nyou may start typing colons in your C-like language code, too (generating reams\ncode in Python.\nstatements:\nThe parentheses here are required by the syntax of many C-like languages.\nPython, though, they are not—we simply omit the parentheses, and the statement\nincluding them will not hurt in this Python code, and they are not treated as an\nEnd-of-line is end of statement\nin Python the way you do in C-like languages:\nIn Python, the general rule is that the end of a line automatically terminates the\nstatement that appears on that line.\ninstance, wrapping code in a bracketed structure allows it to span lines).\ngeneral, you write one statement per line for the vast majority of Python code,\nyou can continue to use semicolons at the end of each statement—the Python\nPython coding.\nand end of a nested block of code.\nthen/endif, or {/} around the nested block, as you do in C-like languages:\nInstead, in Python, we consistently indent all the statements in a given single\nnested block the same distance to the right, and Python uses the statements’\nnested statements here.\nPython doesn’t care how you indent (you may use either\nits statements must be indented the same distance to the right.\ncase, you will get a syntax error, and your code will not run until you repair its\naccustomed to C-like languages, but it is an intentional feature of Python: it’s\nIn fact, even if you never use Python after reading this book,\nFor example, a while loop coded in the C++ language may have begun its\nperson who worked on the code indented the loop four spaces:\nstructured language, Python or otherwise, if nested blocks are not indented\nConsider the following statement in C:\nstatement1;\nstatement2;\nnested if statement (if (y)) in C, even though it looks visually as though it is\ncode looks is the way it will work.\nConsider an equivalent Python statement:\nstatement1\nstatement2\nIn the IDLE GUI, for example, lines of code\nto the right IDLE indents statements in a nested block.\nblock in Python, unless you do so consistently; use tabs or spaces in a given\nblock, but not both (in fact, Python issues an error for inconsistent use of tabs\npractice for tools that must output Python code, and the page breaks that can\nobscure code nesting in the print versions of books (including this one!) will not\nrid of the braces, your code will satisfy Python’s syntax rules.\nThe end of a line terminates the statement on that line (without\nNested statements are blocked and associated by their physical\nThose rules cover almost all Python code you’ll write or see in practice.\nflexibility in both statements and nested statement blocks.\nStatement rule special cases\nappear one per line, it is possible to squeeze more than one statement onto a\nsingle line in Python by separating them with semicolons:\na = 1; b = 2; print(a + b)               # Three statements on one line\nThis is the only place in Python where semicolons are required: as statement\nThis only works, though, if the statements thus combined are not\nsimple statements, like assignments, and calls to print and other functions and\nCompound statements like if tests and while loops must still appear\nsingle statement span across multiple lines.\ncross multiple lines: your statement doesn’t end until Python reaches the line\n2222,           # Any code in (), [], {} \nBecause this code is enclosed in a square brackets pair, Python simply keeps\nand continue your statement:\nThis technique works within compound statements, too, by the way.\nyou need to code a large expression, simply wrap it in parentheses to continue it\nAs mentioned previously, statements in a nested block of code are normally\ncan instead appear on the same line as the header in Python, after the colon:\nThis allows us to code single-line if statements, single-line while and for\nLarger statements must still appear on lines by\nstatements on individual lines and indent your nested blocks as a norm, your\nMoreover, some code\nstatements squeezed onto a single line, or the header and body of a one-line\nin Python.\nYou can use the special-case exceptions to write Python code that’s\n(the use of a single-line if statement to break out of a loop), and to introduce\ncode.\nYou’ll see all these syntax rules in action when we tour Python’s specific\ncompound statements in the next few chapters, but they work the same\neverywhere in the Python language.\nrealistic example that demos the way that statement syntax and nesting come\ntogether and introduces a few statements along the way.\nread/evaluate/print loop program, similar to Python’s standard REPL.\nIn Python, typical boilerplate code for such an interactive loop might look like\nThe code leverages the Python while loop, Python’s most general\nlooping statement.\nA single-line if statement that makes use of the special rule for nested\nThis would work either way, but as it’s coded, we’ve saved an extra\nFinally, the Python break statement is used to exit the loop immediately\nIn effect, this combination of statements essentially means “read a line from the\nother ways to code such a loop (e.g., see the note ahead), but the form used here\nis very common in Python code and serves to illustrate syntax basics.\nindented statement or the end of the source file (as here) will suffice to terminate\nPYTHON\nthe := named-assignment expression added in Python 3.8 and covered in the next chapter.\nexpression assigns a name to another expression’s result, but also returns the assigned value as\nWe might try statements like these to achieve the desired effect:\nrequires a blank line after the while, and runs just one statement at a time—the\nThis script uses a single-line if statement to exit on “stop” as before, but it also\nBecause the print statement in the last line is not\nindented as much as the nested block of code, it is not considered part of the\nThis also gives us an excuse to further nest the statements in our example.\nfollowing new version of our interactive script uses a full-blown if statement to\nWe’ll study the if statement in more detail in Chapter 12, but it’s a fairly\nword if followed by a test and an associated block of code; one or more\nPython runs the block of code\nthe same statement because their opening words all line up vertically (i.e., share\nbefore the print statement on the last line of the script.\nStatement nesting like this is natural once you start using it.\nWhen we run our new script, its code catches errors before they occur and prints\nHandling Errors with try Statements\ncompletely using the Python try statement.\nIn terms of statement nesting, because the words try, except, and else are all\nstatement.\nAs we’ve seen, else can appear in if statements in Python, but it can also\nIn this case, the try statement spans from the word try through the\nThe if statement in this code is a one-liner and ends after the break, so the\nPython’s exec, used in Chapter 3 to run code read from a file, is similar to eval (but assumes\nthe string is a statement instead of an expression and has no result), and its compile call\nstatement, which is in turn nested in the while loop.\nThat concludes our first look at Python statement syntax.\nintroduced the general rules for coding statements and blocks of code.\nlearned, in Python we normally code one statement per line and indent all the\nstatements in a nested block the same amount (indentation is part of Python’s\nAs you’ll see, though, all statements follow the\nPython?\n2. How is a statement normally terminated in Python?\n3. How are the statements in a nested block of code normally associated in\nPython?\n4. How can you make a single statement span multiple lines?\n5. How can you code a compound statement on a single line?\n6. Is there any valid reason to type a semicolon at the end of a statement in\nPython?\n7. What is a try statement for?\n8. What is the most common coding mistake among Python beginners?\n1. C-like languages require parentheses around the tests in some\na nested block of code.\n2. The end of a line terminates the statement that appears on that line.\nAlternatively, if more than one statement appears on the same line, they\n3. The statements (code lines) in a nested block are all indented the same\n4. You can make a statement span many lines by enclosing part of it in\n5. The body of a compound statement can be moved to the header line\nstatements.\nline of code.\nEven then, this works only if all the statements are\n7. The try statement is used to catch and recover from exceptions (errors)\nAssignments,\nNow that we’ve had a first introduction to Python statement syntax, this chapter\nbegins our in-depth tour of specific Python statements.\nbasics: assignment statements, expression statements, and print operations.\nAssignments\nWe’ve been using the Python assignment statement for a while to retain objects\nIn its basic form, you write the target of an assignment on the left\nof an equals sign, and the object to be assigned on the right.\nFor the most part, assignments are\nAssignments create object references.\nPython assignments store references to objects in names or data\nBecause of that, Python variables are more like\nNames are created when first assigned.\nname the first time you assign it a value (i.e., an object reference), so\nwe’re concerned with the = statement and its := expression relative, but\nassignment occurs in many contexts in Python.\nsimply bind (i.e., assign) names and object components to object\nAssignment Syntax Forms\nAlthough assignment is a general and pervasive concept in Python, in this\nchapter we are primarily interested in assignment statements, plus one limited\nassignments in Python.\nAssignment statement and expression forms\nTuple assignment\nList assignment\nSequence assignment\ncode = hack = 'python'\nMultiple-target assignment\n(python := 3.12) + 0.01\nNamed assignment expression\ntarget (a name or data structure component) to a single object (an expression\nTuple and list assignments\nWhen you code a tuple or\nlist on the left side of the =, Python pairs objects on the right side with\ntargets on the left by position and assigns them from left to right.\nparentheses), and the names code and hack are assigned 'py' and 'PY',\nSequence assignment\nTuple and list assignments were later generalized into instances of what we\nnow call sequence assignment—any sequence of targets can be assigned to\nany sequence (really, iterable) of values, and Python assigns the items one at\nwith a string of characters: a is assigned 'h', b is assigned 'a', and so on.\nassignment targets.\nstring on the right, and the starred name b with the rest: a is assigned 'h',\nand b is assigned ['a', 'c', 'k'].\nassigning the results of slicing operations.\nMultiple-target assignment\nThe sixth line in Table 11-1 shows the multiple-target form of assignment.\nthis form, Python assigns a reference to the same object (the object farthest\nhack are both assigned references to the same string object, 'python'.\neffect is the same as if we had run hack = 'python' followed by code =\nThe second-to-last line in Table 11-1 is an example of augmented assignment\nstatement for most binary expression operators in Python (even the unused\nNamed assignment expression\nNew in Python 3.8, the := operator allows you to code assignment as an\nexpression, which returns the value it assigns to a name.\nbe nested in places where assignment statements don’t work syntactically,\nand in common roles allows you to both assign a name and use its value in\n$ python3\nof assignment targets can be used in any form of assignment, except where noted\nahead (named assignment expressions, for example, allow only names).\nName annotations: Basic assignment statements can also have an annotation expression\nThis statement form allows only\nSequence Assignments\nassignment (a.k.a. sequence assignment) in action, unpacking items into\n>>> A, B = first, second            # Tuple assignment\n>>> [C, D] = [first, second]        # List assignment\nNotice that we really are coding two tuples in the third line in this interaction—\ntuple on the right side of the assignment operator with the variables in the tuple\non the left side and assigns the values one at a time.\nTuple assignment leads to a common coding trick in Python that was introduced\nthe statement runs, unpacking assignments are also an easy way to swap two\nAs already noted, the original tuple and list assignment forms in Python were\nassign a tuple of values to a list of variables, a string of characters to a tuple of\nIn all cases, Python assigns items in the sequence on the\n>>> [a, b, c] = (1, 2, 3)          # Assign tuple of values to list of names\n>>> (a, b, c) = 'ABC'              # Assign string of characters to tuple names\ntuple or list of targets), the right side may be any iterable object, not just any\n>>> a, b, c, d = string                            # Same number on both sides\n>>> a, b, c = string                               # Error if not\n>>> a, b, c = list(string[:2]) + [string[2:]]      # Slice and concatenate\n>>> (a, b), c = string[:2], string[2:]             # Nested sequences\nAs the last example in this interaction demonstrates, we can even assign nested\nIn this case, we are assigning a tuple of two items, where the first item is a\nnested sequence (a string), exactly as though we had coded it this way:\nPython pairs the first string on the right ('TE') with the first tuple on the left\n((a, b)) and assigns one character at a time, before assigning the entire second\nsequence assignment like this is somewhat rare to see, but it can be convenient\nloops, because loop items are assigned to the target given in the loop header just\nas if an = statement had been run:\nfor (a, b, c) in [(1, 2, 3), (4, 5, 6)]: …          # Simple tuple assignment\nfor ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: …    # Nested tuple assignment\nSuch nested sequence assignments can also be achieved with the match\nstatement of the next chapter, but we’ll hold back the details until then.\nSequence-unpacking assignments also give rise to another common coding\ntuple assignment at work is for splitting a sequence into its front and the rest, in\nThe tuple assignment in the loop here could be coded as the following two lines\nfront = L.pop(0) would have much the same effect as the tuple assignment\nstatement, but it would be an in-place change.\nassignments more general.\nIn later Pythons, sequence assignment was further\n—the starred target is assigned a list, which collects all items in the iterable not\nassigned to other targets.\nsequence assignments normally require exactly as many targets on the left as\nWhen a starred target is used (like name b here), the number of items on the left\nThus, in the following interaction, a and c are assigned the\nMore generally, wherever the starred target shows up, it will be assigned a list\nNaturally, like normal sequence assignment, extended-unpacking syntax works\nunpacking assignment always returns a list for matched items, whereas slicing\n>>> a, b, c = S[0], S[1:-1], S[-1]      # Slices are type specific\n>>> a, *b, c = S                        # But * always returns a list\nassigned a list:\n>>> print(a, b, c, d)\nSecond, if there is nothing left to match the starred target, it is assigned an empty\nIn the following, names a, b, c, and d have\nmatched every item in the sequence, but Python assigns e an empty list instead\n>>> print(a, b, c, d, e)\n>>> print(a, b, c, d, e)\nSyntaxError: multiple starred expressions in assignment\nSyntaxError: starred assignment target must be in a list or tuple\n>>> [(a, *b, *x), (c, *d)] = [(1, 2, 3, 4), (5, 6, 7, 8)]\nSyntaxError: multiple starred expressions in assignment\nalso common in Python code.\nBecause the loop variable in the for loop statement can be any assignment\nWhen used in this context, on each iteration Python simply assigns the next tuple\nthe following assignment statement:\nThe names a, b, and c can be used within the loop’s code to reference the\ninstance of general assignment at work.\nexample, we can do similar in loops with simple sequence (tuple) assignment:\nTHE MANY STARS OF PYTHON\nAssignments, where a single *X starred assignment target of any\nAs of Python 3.5, function calls (the latter listed item) support any number of\nAs of Python 3.10, both *X and **X starred names can also show up in the\nroles similar to that in sequence assignment, though only *X overlaps\nAnd as of Python 3.11, an except* can appear in try statements, where it\nMultiple-Target Assignments\nsimply assigns all the given targets to the same object all the way to the right.\nThe following, for example, assigns the three names (variables) a, b, and c to the\nstring 'code':\n>>> a = b = c = 'code'\nthese three assignments:\n>>> c = 'code'\nMultiple-target assignment and shared references\nAs long as the object assigned is immutable, it’s irrelevant if more than\nthe issue, initialize mutable objects in separate statements instead, so that each\nA tuple assignment like the following has the same effect with more brevity—by\nrunning two list-literal expressions, it creates two distinct objects:\nforms already covered, Python gained all the assignment statement formats listed\nAugmented assignment statements\nAugmented assignment works on any type that supports the implied binary\nother Python binary expression operators (i.e., operators with values on their left\nright and assigns, and so on (though per Chapter 5, the form X @= Y is unused\nWhen we use augmented assignment to extend a list, we can largely forget these\nAs suggested in Chapter 6, we can also use slice assignment (e.g., L[len(L):]\nmnemonic list extend method or the += statement.\nMoreover, using index and slice targets in augmented assignment may change\nNamed Assignment Expressions\nFor most of Python’s three-decade tenure, it resisted emulating the assignment-\napply, Python 3.8 gained a flavor of this, known as named assignment.\nImportantly, this flavor does not make normal = assignment statements nestable\nPython’s = assignment statements already assign values to names (in fact, you’ll\nget a syntax error if you try using := as a statement sans parentheses).\n:= is an expression that returns the value assigned, though, it can be nested in\nand then use the assigned name.\nAs an artificial first example, the following nested := both assigns 2 to b, and\nreturns it to be used in the * string-repetition result assigned to a:\nname (variable) on the left, so neither other assignment-statement forms nor\n>>> (python := 3.12) + 0.01         # Just a name on the left\n>>> python\n>>> (python[0] := 3.12) + 0.01\nSyntaxError: cannot use assignment expressions with subscript\nSyntaxError: cannot use assignment expressions with attribute\nthe middle, not a two-target named sequence assignment.\nearlier: there is no :+=, for instance, and coding statement X += 1 may actually\nWhen to use named assignment\nassign a variable before the statement, test it in the statement header, and then\nuse it in the statement body.\nFor example, code that reads lines from files and must detect the end of the file\nTo avoid redundant calls, it’s also common to code the latter like this in Python\nstatement headers themselves:\nvalue can be tested in the statement header itself.\nAnd because := also assigns\nthe result to line, it can be used in the statement’s body if it is run.\nNow that we’ve explored assignment statements and expressions, it’s time to get\nexistence when you assign values to them, but there are a few rules to follow\nnames, but such characters may make your code difficult to use in some\nPython always pays attention to case in programs, both in names you create\nthe Python language.\nFor instance, Python will raise a syntax error if you try",
      "keywords": [
        "Python",
        "Python statement syntax",
        "statement",
        "Python code",
        "code",
        "statements",
        "assignment",
        "Python statement",
        "Python assignment statement",
        "assignment statements",
        "line",
        "equivalent Python statement",
        "Python language",
        "list",
        "object"
      ],
      "concepts": [
        "pythonic",
        "pythons",
        "statement",
        "statements",
        "coding",
        "code",
        "coded",
        "assigns",
        "assignments",
        "object"
      ],
      "similar_chapters": [
        {
          "book": "Learning Python Ed6",
          "chapter": 4,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 5,
          "title": "",
          "score": 0.645,
          "base_score": 0.495,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 10,
          "title": "",
          "score": 0.643,
          "base_score": 0.493,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 7,
          "title": "",
          "score": 0.629,
          "base_score": 0.479,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 6,
          "title": "",
          "score": 0.534,
          "base_score": 0.384,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "statement",
          "assignment",
          "statements",
          "line",
          "tuple"
        ],
        "semantic": [],
        "merged": [
          "statement",
          "assignment",
          "statements",
          "line",
          "tuple"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.49889376272721214,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:10.090720+00:00"
      }
    },
    {
      "chapter_number": 10,
      "title": "Introducing Python Statements",
      "start_page": 441,
      "end_page": 480,
      "summary": "choice match statement; the latter is used by a type statement that creates type\nchange might impact existing code, Python often makes it an option and\nExpression Statements\nIn Python, you can use any expression as a statement, too—which usually means\nwith expression statements.\nFor printing values at the interactive prompt\nexpression statements, too; they serve as a shorthand for typing print\nstatements.\nTable 11-4 lists some common expression statement forms in Python.\nCommon Python expression statements\nPrinting operations (a special function call)\nlater in this chapter, printing in Python is a function call usually coded as a\nregularly coded as statements as well.\nFor instance, though you normally run a print call on a line by itself as an\nexpression statement, it actually returns a value like any other function call—the\n>>> x = print('code')         # print is a function-call expression\n>>> print(x)                  # But is usually coded as an expression statement\nAlso keep in mind that although expressions can appear as statements in Python,\nA statement\nFor example, Python doesn’t allow you to embed basic assignment statements\nExpression Statements and In-Place Changes\nstatements are often used to run list methods that change a list in place:\nIt’s not unusual, though, for Python newcomers to code this as an assignment\n>>> print(L)                  # So we lose our list!\nPrint Operations\nIn Python, print prints things—it’s simply a programmer-friendly interface to\nhere because it’s so pervasive and is usually coded as a statement.\nTechnically, printing converts one or more objects to their textual\nIn a bit more detail, print is\nIn Chapter 9, we explored file object methods that write text (e.g.,\nwhereas file write methods write strings to arbitrary files, print writes\nobjects to strings when using print operations.\nBecause the standard output stream is available in Python as the stdout file\nprint with file write method calls.\nuse in most roles and makes it easy to print text to other files and streams.\nBlast from the past: Printing is also one of the most visible places where Python 3.X and 2.X\n(and in the muscle memory of Python coders who still type print x unconsciously!).\nThe print Function\nStrictly speaking, printing is not a separate statement form.\nprint built-in function is normally called on a line of its own, because it doesn’t\nSyntactically, calls to the print function have the following form:\nprint([object, …][, sep=' '][, end='\\n'][, file=sys.stdout][, flush=False])\nbuilt-in function prints the textual representation of one or more objects,\nthis call may appear in any left-to-right order following the objects to be printed,\nand they control the print operation:\nend is a string added at the end of the printed text, which defaults to a\ndropping down to the next output line at the end of the printed text—the\nnext print will keep adding to the end of the current output line.\noutput stream if not passed, but any object with a file-like\nThe print function in action\nThe following prints a variety of object types\n>>> print()                                      # Display a blank line\n>>> print(x, y, z)                               # Print objects per defaults\nBy default, print calls add a space between the objects printed.\n>>> print(x, y, z, sep='')                       # Suppress separator\n>>> print(x, y, z, sep=', ')                     # Custom separator\nAlso by default, print adds an end-of-line character to terminate the output line.\nsecond of the following is two statements on one line, separated by a semicolon\n>>> print(x, y, z, end='')                        # Suppress line break (see >>>)\n>>> print(x, y, z, end=''); print(x, y, z)        # Two prints, same output line\n>>> print(x, y, z, end='...\\n')                   # Custom line end\nbeing printed:\n>>> print(x, y, z, sep='...', end='!\\n')          # Multiple keywords\n>>> print(x, y, z, end='!\\n', sep='...')          # Order doesn't matter\nHere is how the file keyword argument is used—it directs the printed text to an\nopen output file or other compatible object for the duration of the single print\n>>> print(x, y, z, sep='...', file=open('data.txt', 'w'))      # Print to a file\n>>> print(x, y, z)                                             # Back to stdout\n>>> print(open('data.txt').read())                             # Display file text\nFinally, keep in mind that the separator and end-of-line options provided by print\nformatting, don’t print this way.\nahead of time or within the print itself, using the string tools we mastered in\nChapter 7—and print the string all at once.\n>>> print(text)\n>>> print(f'{x}: {y:-0.4f}, {int(z[0][-2]):05d}')\nyou’re simply trying to print objects separated by spaces:\n>>> print(f'{a} {b} {c}')\n>>> print(a, b, c)\nPrint Stream Redirection\nAs we’ve seen, print sends text to the standard output stream by default.\n> file, per “Command-Line Usage Variations”), this is not a Python tool, and\nit’s just as easy to redirect a script’s streams from Python code.\nTo print a “hello world” message in Python, simply print\nthe string with print:\n>>> print('hello world')               # Print a string object\nyou often don’t even need to use a print statement there—simply type the\nexpressions you’d like to have printed, and their results are echoed back:\nTechnically, though, the print operation is just an\nyou must (or are pining for your Java coding days) you can also code print\n>>> import sys                         # Printing the hard way\nwhen Python starts up to an open file object connected to the output stream.\nprinting tasks.\nprint turns out to be the basis of a common technique in Python.\nprint and sys.stdout are directly related as follows.\nThis statement:\nprint(X, Y)\nthe print does.\nuseful to know that this is exactly what print operations do because it is\nIn other words, this equivalence provides a way of making your print\nsys.stdout = open('log.txt', 'a')       # Redirects prints to a file\nprint(x, y, x)                          # Now printed text shows up in log.txt\nAfter the reset, every print operation anywhere in\nThe print operations are happy to keep calling\nassigning sys.stdout this way will redirect every print anywhere in your\nexpected interface: a method named write to receive the printed text-string\nWhen that object is a class, printed text can be routed and processed\noriginally coded with print statements.\noutput of a print-based program, though, resetting sys.stdout provides a\nconvenient alternative to changing every print statement or using system shell-\nAlthough redirecting printed text by assigning sys.stdout is a useful tool, a\nrestore the original output stream should you need to switch back after printing\n>>> sys.stdout = open('log.txt', 'a')   # Redirect prints to a file\n>>> print('lp6e was here')              # Prints go to file, not here\n>>> print(1, 2, 3)\nAs introduced earlier, the file keyword allows a single print call to send its\nprinting to the original output stream.\nsnippet again sends printed text to a file named log.txt:\nprint(x, y, z, file=log)                # Print to a file-like object\nprint(a, b, c)                          # Print to original stdout\nThese redirected forms of print are handy if you need to print to both files and\n>>> print(1, 2, 3, file=log)\n>>> print(4, 5, 6, file=log)\n>>> print(7, 8, 9)\nmanually, or print with redirection syntax:\n>>> print('Bad!' * 8, file=sys.stderr)\nThe following demo prints both ways,\nthen redirects the output to an external file to verify that the same text is printed\n>>> print(X, Y)                                            # Print: the easy way\n>>> sys.stdout.write(str(X) + ' ' + str(Y) + '\\n')         # Print: the hard way\n>>> print(X, Y, file=open('temp1', 'w'))                   # Redirect text to file\nprints and file writes, watch for a print function emulation example in\nChapter 18; it uses the coding patterns here to provide a print equivalent that\nIn this chapter, we began our in-depth look at Python statements by exploring\nassignments, expressions, and print operations.\nwell as the redirection form of print operations, allow us to avoid some manual\nthe if statement, Python’s main selection tool; there, we’ll also revisit Python’s\nwell as the match multiple-choice statement.\n4. How might you use the print operation to send text to an external file?\nassignment (A, B, C = 0, 0, 0), or multiple assignment statements\nseparate statements together on the same line by separating them with\n4. To print to a file for a single print operation, you can use the print(X,\nredirect all of a program’s printed text to a file with special syntax in the\nWHY YOU WILL CARE: PRINT AND STDOUT\nThe equivalence between the print operation and writing to sys.stdout\nBecause the print statement just\nsends text to the sys.stdout.write method, you can capture printed text in\nyour programs by assigning sys.stdout to an object whose write method\n# Do something with the printed text in string\nprint(someObjects)              # Sends text to class write method\nThis works because print is what we will call in the next part of this book a\neven simpler with the file keyword argument of print, because we don’t\nneed to reset sys.stdout explicitly—normal prints will still be routed to the\nmyobj = FileFaker()             # Redirect to object for one print\nprint(someObjects, file=myobj)  # Does not reset sys.stdout\nPython’s built-in input function reads from the sys.stdin file, so you can\nNotice that because printed text goes to the stdout stream, it’s also the way\nPython’s print operation redirection tools are essentially pure-Python\n1  C/C++ programmers also take note: although Python now supports statements like X += Y, it still\n4  Technically, printing uses the equivalent of str in the internal implementation of Python, but the\nThis chapter presents Python’s two statements used for selecting from alternative\nPython statement syntax model here in more detail than we did in the\nif Statements\nIn simple terms, the Python if statement selects actions to perform.\nThe Python if is typical of if statements in most procedural languages.\nan associated block of nested statements, indented under a header line.\nif statement runs, Python executes the block of code associated with the first\nprint('true')\nprint('true')\nprint('false')\nprint('macOS')\nprint('Linux')\nprint('unknown?')\nThis multiline statement extends from the if line through the block nested under\nWhen it’s run, Python executes the statements nested under the first\nThe if statement\nprint('Linux')\nprint('macOS')\nUntil Python’s version 3.10, it had no multiple-choice selection statement similar\nAs you’ll learn ahead, Python today has sprouted a match statement that\nAn almost equivalent but more verbose Python if statement might\nprint(2001)\nprint(1991)\nprint(1985)\nprint('Bad choice')\nhere to code a default action in a dictionary-based multiple choice.\n>>> print(branch.get('Windows', 'Bad choice'))\nprint(branch[choice])\nprint('Bad choice')\nAnd the try statement is a general way to handle dictionary-based defaults by\nprint(branch[choice])\nprint('Bad choice')\nabout the more complicated actions you can code in the statement blocks\nAnd the punch line here, of course, is that the match statement may handle basic\nmatch Statements\nselection statement, in large part because of all the options for coding such logic\nto use in Python code written today.\nstatement to Python.\nform, match works the same as both an if statement and a dictionary index—\nprint('green')\nprint('red')\nprint('yellow')\nThe equivalent match statement provides explicit syntax for such multiple-\nprint('green')                       # match-based multiple choice: 3.10+\nprint('red')\nprint('yellow')\nThis statement works like this: match first evaluates the expression given in its\nstatement either runs the block under the case with value _ (which provides a\nAs usual, case blocks can contain multiple statements and nesting, and match\nmatches (and hence ends the statement, much like the anonymous _):\nprint('green')                    # First left-to-right match wins\nprint('means go')\nprint('red')                      # what outlives match if assigned\nprint('means', what)\nprint('catchall', other)          # other outlives match if assigned\nheaders and assigned during a successful match outlive the match statement\nAs a live match example, the following maps statements to categories and\nprint('logic')\nprint('loop')\nprint('tbd')\nprint('logic')\nprint('loop')\nprint('tbd')\nWatch for more basic match statements to show up later in this book (e.g., in\nCapture patterns: variable X matches anything, and will be assigned to it\nprint('or', what)\nprint('list', what)\nprint('list', what)\nprint('dict', what)\nprint('dict', what)\nprint('tuple', what)\nprint('tuple', what)\nprint('other', what)\nprint('attr', what)\nprint('instance', what)\nprint(f'case1 {a=} {b=}')        \nprint(f'case2 {a=} {what=}')\nprint(f'case3 {a=} {what=}')\nmatch, including all the gory details of its special-case patterns, consult Python’s\nlanguages heap without a match statement.\nchoose between if, dictionaries fetches, and match when coding multiple-choice\nup to larger statements like if and match, this section reviews and expands on\nIn general, Python has a simple, statement-\nPython normally runs statements in a file or nested block in order from\nof code in Python; instead, Python uses the indentation of statements\nPython statements are not normally terminated with semicolons; rather,\nthe end of a line usually marks the end of the statement coded on that\nAs special cases you’ll meet later, statements can both span lines\nor more nested statements, usually indented under the header.\nindented statements are called a block (or sometimes, a suite).\ntop of program files and some statements.\nIn other words, the statements within a block line up vertically, as\nprint('block2')\nprint('block1')\nprint('block0')\nspaces, and the third (the print statement under the nested if) is indented eight\nprint(x * 8)\nprint(x)                # Error: inconsistent indentation\nprint(x * 8)                    # Prints 8 Hack\nPython syntax, not just a stylistic suggestion: all the statements within any given\nas Pythoneers do and use consistent indentation instead of block delimiters.\nStatement Delimiters: Lines and Continuations\nWhile blocks are indented, a statement in Python normally ends at the end of the\nStatements may span multiple lines if you’re continuing an “open\npair.” The code of a statement can always be continued on the next line\nStatements may span multiple lines if they end in a backslash.\nsometimes used to squeeze more than one statement onto a single line\nstatement by itself).\nstatement per line for most of your work:\nx = 1; y = 2; print(x)           # More than one simple statement\nFinally, and also as a review, Python lets you move a compound statement’s",
      "keywords": [
        "Python",
        "statement",
        "statements",
        "match",
        "File",
        "code",
        "match statement",
        "line",
        "Python code",
        "Python expression statements",
        "Bad",
        "Print Operations",
        "print statement",
        "object",
        "Python statements"
      ],
      "concepts": [
        "printing",
        "python",
        "pythonic",
        "statement",
        "statements",
        "coded",
        "coding",
        "match",
        "matches",
        "line"
      ],
      "similar_chapters": [
        {
          "book": "Learning Python Ed6",
          "chapter": 4,
          "title": "",
          "score": 0.747,
          "base_score": 0.597,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 5,
          "title": "",
          "score": 0.695,
          "base_score": 0.545,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 9,
          "title": "",
          "score": 0.643,
          "base_score": 0.493,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 7,
          "title": "",
          "score": 0.639,
          "base_score": 0.489,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 6,
          "title": "",
          "score": 0.554,
          "base_score": 0.404,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "print",
          "statement",
          "statements",
          "match",
          "stdout"
        ],
        "semantic": [],
        "merged": [
          "print",
          "statement",
          "statements",
          "match",
          "stdout"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.512378860080194,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:10.090736+00:00"
      }
    }
  ],
  "total_chapters": 10,
  "enrichment_provenance": {
    "taxonomy_id": "none",
    "taxonomy_version": "none",
    "taxonomy_path": "none",
    "taxonomy_checksum": "sha256:none",
    "source_metadata_file": "Learning Python Ed6_metadata.json",
    "enrichment_date": "2025-12-17T23:06:10.095720+00:00",
    "enrichment_method": "msep",
    "model_version": "ai-agents-msep-v1",
    "processing_time_ms": 3440.5107100010355,
    "total_similar_chapters": 50
  }
}