{
  "metadata": {
    "title": "Game Programming Gems 7",
    "source_file": "Game Programming Gems 7_metadata.json"
  },
  "chapters": [
    {
      "chapter_number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "summary": "GAME\nEdited by Scott Jacobs\nGame\nAustralia • Brazil • Japan • Korea • Mexico • Singapore • Spain • United Kingdom • United States\nA part of Course Technology, Cengage Learning\n© 2008 Course Technology, a part of Cengage Learning.\nas permitted under Section 107 or 108 of the 1976 United States Copyright\nCourse Technology PTR: Stacy L.\nManager of Editorial Services: Heather\nProject/Copy Editor: Kezia Endsley\nCover Designer: Tyler Creative Services\nCD-ROM Producer: Brandon Penticuff\nPrinted in the United States of America\nCengage Learning Customer & Sales Support, 1-800-354-9706\nsubmit all requests online at cengage.com/permissions\npermissionrequest@cengage.com\nCourse Technology\nCengage Learning products are represented in Canada by \nVisit our corporate website at cengage.com\nSECTION 1 GENERAL PROGRAMMING .\nA Sketch-Based Interface to Real-Time Strategy Games Based on a\nFoot Navigation Technique for First-Person Shooting Games.\nFast Generic Ray Queries for Games.\nRahul Sathe, Advanced Visual Computing, SSG, Intel Corp.\nKrzysztof Kluczek, Gda´nsk University of Technology\nSteve Rabin, Nintendo of America Inc. SECTION 3 AI .\nDesigning a Realistic and Unified Agent-Sensing Model.\nSteve Rabin, Nintendo of America Inc. Michael Delp, WXP Inc. 3.3\nManaging AI Algorithmic Complexity: Generic Programming \nLynch, Ph.D., Rensselaer Polytechnic Institute, Troy, NY\nUnderstanding Intelligence in Games Using Player Traces and\nG. Michael Youngblood, UNC Charlotte\nSECTION 4 AUDIO .\nMultiStream—The Art of Writing a Next-Gen Audio Engine.\nReal-Time Audio Effects Applied .\nSECTION 5 GRAPHICS.\nRoden, Angelo State University\nAnimating Relief Impostors Using Radial Basis Functions Textures .\nLuciana Porcher Nedel, Instituto de Informática: UFRGS\nDoss, Advanced Visual Computing, Intel Corporation\nRoden, Angelo State University\nSECTION 6 NETWORKING AND MULTIPLAYER .\nHigh-Level Abstraction of Game World Synchronization .\nAuthentication for Online Games.\nGame Network Debugging with Smart Packet Sniffers .\nKoenig, The Whole Experience, Inc. SECTION 7 SCRIPTING AND DATA-DRIVEN SYSTEMS .",
      "keywords": [
        "Scott Jacobs",
        "Cengage Learning",
        "United States",
        "University",
        "Angelo State University",
        "Technology",
        "Section",
        "Learning",
        "United States Copyright",
        "State University",
        "United",
        "Introduction",
        "Nintendo of America",
        "Edited by Scott",
        "Jacobs"
      ],
      "concepts": [
        "game",
        "introduction",
        "section",
        "contents",
        "michael",
        "university",
        "advanced",
        "graphic",
        "audio",
        "technology"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "",
          "score": 0.742,
          "base_score": 0.592,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 3,
          "title": "",
          "score": 0.708,
          "base_score": 0.558,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 4,
          "title": "",
          "score": 0.696,
          "base_score": 0.546,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 10,
          "title": "",
          "score": 0.564,
          "base_score": 0.414,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "cengage",
          "united",
          "university",
          "learning",
          "united states"
        ],
        "semantic": [],
        "merged": [
          "cengage",
          "united",
          "university",
          "learning",
          "united states"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23644096385481764,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074143+00:00"
      }
    },
    {
      "chapter_number": 2,
      "title": "Segment 2 (pages 9-16)",
      "start_page": 9,
      "end_page": 16,
      "summary": "ix volumes of Game Programming Gems have preceded the edition now in your\nand consulted by both amateur and professional game developers, I believe the previ-\nous editions have contributed toward making the games we all play more innovative,\nPassion for Game Development\nGame development is a fantastic endeavor of which to be a part.\nexcitement of game development and I imagine is one of the motivations that inspired\nthe authors of the following gems to share their ideas and experiences.\nThe necessity of domain expertise requirements means that often game develop-\nwith a passion for all areas of game development.\nWanting to Make Games\nEnthusiasm for game development from industry insiders may help explain why so\nmany seem so eager to join up as game developers.\nthose trying to enter game development as a first career choice.\nadvanced publications, specialized game development degrees and courses are avail-\nA wide variety of game\nAdditionally, for most genres of games you can\nThe opportunity to contribute to gaming also looks good for those passionate\namateurs with significant non-game-related software development experience.\nAs game designs, target hardware, and development teams themselves\nWe have a networking gem that applies tools to multiplayer development that\nfrom the general experience of our colleagues outside of game development.\ngames isn’t like making word processors, but good solutions for managing ever\nGames are appealing because of their ability to challenge, amuse, and entertain.\nto making a game fun.\ngame that produces the fun.\ngems that contribute directly to a player’s experience of the game, including audio\nproduction gems and human-game interactions.\ntry new ways to interact with their games.\nexperiences as well as tempted those not normally enticed by electronic games to give\nin human-game interaction and greatly look forward to what will come in the future\nknow when your game is released.\nhristopher Scot Roby created the Game Programming Gems 7 cover.\nmust start by thanking Jenifer Niles and the Game Programming Gems 6 editor",
      "keywords": [
        "Game Development",
        "Game",
        "Game Programming Gems",
        "Development",
        "Gems",
        "Game Programming",
        "Programming Gems",
        "experience",
        "game development degrees",
        "software development",
        "specialized game development",
        "enter game development",
        "fun",
        "ideas",
        "development teams"
      ],
      "concepts": [
        "game",
        "gaming",
        "developers",
        "gems",
        "gem",
        "volumes",
        "teams",
        "work",
        "useful",
        "preface"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 3,
          "title": "",
          "score": 0.609,
          "base_score": 0.459,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 4,
          "title": "",
          "score": 0.599,
          "base_score": 0.449,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 1,
          "title": "",
          "score": 0.496,
          "base_score": 0.346,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 33,
          "title": "",
          "score": 0.449,
          "base_score": 0.299,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 31,
          "title": "",
          "score": 0.437,
          "base_score": 0.287,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "development",
          "game",
          "game development",
          "gems",
          "programming gems"
        ],
        "semantic": [],
        "merged": [
          "development",
          "game",
          "game development",
          "gems",
          "programming gems"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.12922173498642053,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074220+00:00"
      }
    },
    {
      "chapter_number": 3,
      "title": "Segment 3 (pages 17-25)",
      "start_page": 17,
      "end_page": 25,
      "summary": "Dmitry is a software engineer specializing in 3D graphics and tools at 10Tacle Studios,\nfounder of the X-Tend gaming technology used in numerous releases, including the\nAfter Hyun-jik Bae developed the Speed Game (see his Bio in Game Programming\nWho Are You?” (from a love story of a gamer and a game developer).\ntor with Dyson Interactive Inc. and developing another online game title.\ninterests include designing and implementing high-performance game servers, scal-\nHe has worked as a consultant for several companies in computer graphics and related\nCurrently, he is developing computationally efficient basic graphics algorithms\nAnatoli Beliaev (beliaev@trusoft.com) is a software engineer with more than 15 years\nUniversity with an M.S. in Computer Science.\ngame industry for 10 years, for companies such as Lost Boys Interactive, Davilex,\nand game development for developer Websites such as Flipcode.com and Gamasutra.\nAmong these have been Bill Budge’s 3D Game Toolkit and Pinball\nConstruction Set. He is currently building game editors in the Tools and Technology\nhis Ph.D. in Civil Engineering from the Pontifical Catholic University of Rio de\nWhile pursuing his Ph.D., he spent a year work-\ning with Computer Graphics/Civil Engineering at Cornell University.\nboth his Ph.D. and post-doc, he worked with applied computer graphics.\nand the coordinator of the graduate program (master’s and Ph.D. programs) in com-\nMichael’s route to joining the games industry after college included three years in the\nCurrently, he works as\nan AI, physics, and gameplay software engineer throughout his career, including work\nHe has also lectured at the Game Developers Conference and\nHis research interests include graphics, visualization,\nHe is currently a third-year Ph.D. student working in the Computer Graphics Group at the Federal University of Rio\nsity of Rio Grande do Sul, Brazil, and an M.S. in Computer Science from the Federal\nHis current projects include the development of algorithms for large-scale scientific\nDixit is a games researcher in the Department of Computer Science at The\nUniversity of North Carolina at Charlotte and part of the Game Intelligence Group\nhis master’s degree in Spring 2008 with the Game Design and Development certifi-\ntools to support interactive artificial intelligence, and working on all types of com-\nputer games.\nseveral tools and samples for the professional graphics developer community.\nworking with the Advanced Visual Computing team to create world-class graphics\ntools and samples for game developers.\nNathan is a veteran hobbyist game developer, with 12 years’ experience working\nHe’s often thought about joining the game\nHe has tinkered with various game\nmaster’s degree in Computer Science at the University of New Mexico.\nter’s degree in Computer Science (Computer Graphics) from Universidade Federal do\nLast year, he worked in developing new\nHe has experience in the development of new interaction modalities for games,\nCurrently, he is working at\nMark recently graduated with a B.S. in Computer Games Technology.\nfounder of the independent game development studio “Raccoon Games.”\nHe sat in the hallway and documented the Torque Game Engine.\nthen, he’s done a lot with the Torque family of engines, working on graphics, net-\nJulien started programming a text game on his Commodore 64 at the age of eight.\nthe Game Programming Gems and AI Game Programming Wisdom series.\nAnders Hast has been a lecturer in computer science at the University of Gävle since\nIn 2004, he received his Ph.D. from Uppsala University based on a thesis about\nHe is currently working part time as\nJeremy Hayes is a software engineer in the Advanced Visual Computing group at\nScott Jacobs has been working in the games industry since 1995.\nPrior to this he worked as a software engineer at\nthe serious games company Virtual Heroes, two Ubisoft studios including Redstorm\nEntertainment, and began in the game development industry at Interactive Magic.\nalso served as the Network & Multiplayer section editor for Game Programming Gems\nin 2005, where he contributed to the development of a turn-based strategy game.\nrently working on the adventure game Black Mirror 2.\ncomputer science at the University of La Coruña, he was developing 3D medical\nsoftware engineer and researcher at the computer graphics group VideaLAB, taking\nAngeles writing many games, tools, and engines for systems like the N64, Game Boy\nKrzysztof was interested in game programming since he was 10.\ngames began evolving, he became more and more interested in the graphical aspect of\n3D games.\nHe received his master’s degree in Computer Science at Gdansk University\nDavid is a returning author to the Game Programming Gems series.\nHis work has contributed to many titles, including SceneIt?\ndevelopment of a Graphics SDK at Intel.\ncomputer graphics at UNC-Chapel Hill and worked in the Computational Science\nHe has more than 10 years of experience in the game industry and has worked\nyears of experience in the games industry and has worked on many titles, including\nphysics, and computer science, he spent several years programming in Chicago.\neventually left the video game company in Chicago for graduate school at Purdue,\nwork in computer science.\nGems, Shader X3, Shader X5, and Game Programming Gems 6.\nauthored and co-authored a number of works on computer graphics and interactive\nLynch, Ph.D. Dr. Lynch’s background is in Electrical Engineering where he worked in various tech\nGames and Simulations Arts and Sciences (GSAS) major at Rensselaer Polytechnic",
      "keywords": [
        "Computer Science",
        "computer graphics",
        "computer",
        "Game",
        "Science",
        "Game Programming Gems",
        "graphics",
        "Game Programming",
        "Computer Graphics Group",
        "University",
        "Computer Games Technology",
        "Federal University",
        "software engineer",
        "programming",
        "applied computer graphics"
      ],
      "concepts": [
        "game",
        "developed",
        "programs",
        "including",
        "include",
        "graphical",
        "computationally",
        "computing",
        "worked"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 4,
          "title": "",
          "score": 0.773,
          "base_score": 0.623,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 1,
          "title": "",
          "score": 0.708,
          "base_score": 0.558,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 2,
          "title": "",
          "score": 0.609,
          "base_score": 0.459,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "",
          "score": 0.549,
          "base_score": 0.399,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.518,
          "base_score": 0.368,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "computer",
          "science",
          "graphics",
          "university",
          "computer science"
        ],
        "semantic": [],
        "merged": [
          "computer",
          "science",
          "graphics",
          "university",
          "computer science"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.25369523004493233,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074275+00:00"
      }
    },
    {
      "chapter_number": 4,
      "title": "Segment 4 (pages 26-33)",
      "start_page": 26,
      "end_page": 33,
      "summary": "a forthcoming course in AI for games.\nComputer Science from the Department of Computing at the Federal University of\ngame technologies, specially rendering and collision detection.\ninterests are computer graphics, computer games, and computer vision.\nworking on research projects at the Federal University of Ceará (UFC).\nas a developer in the demo-scene allowed him to start working in the games industry\nAdditionally, he is working on the development of a mixed-reality\nprofessor at SMU’s Guildhall school of game development where he teaches advanced\nCurtiss Murphy has been developing and managing software projects for 15 years.\nproject engineer, he leads the design and development of several Serious Game efforts\nlow-cost, game-based technologies to enhance training.\nRecent game efforts include a\ndozen projects based on the Open Source gaming engine, Delta3D (www.delta3d.org)\nand a public affairs game for the Office of Naval Research based on America’s Army.\ncurrently works for Alion Science and Technology in Norfolk, Virginia.\nLuciana Porcher Nedel received a Ph.D. in Computer Science from the Swiss Federal\neral University of Rio Grande do Sul, Brazil, and a B.S. in Computer Science from the\nnal projects that extend the technology and the infrastructure of the proprietary game\nHe’s been involved in the games industry\nJason Page has worked in the computer games industry since 1988 and has held job\npositions of games programmer, audio programmer, “musician” (audio engineer/\ngraphics, agile development, and free software.\nSteve is a Principal Software Engineer at Nintendo of America, where he researches\nBefore Nintendo, Steve worked primarily as an AI engineer at\nseveral Seattle start-ups including Gas Powered Games, WizBang Software Produc-\nHe managed and edited the AI Game Programming Wis-\ndom series of books, the book Introduction to Game Development, and has over a dozen\narticles published in the Game Programming Gems series.\nDevelopers Conference and currently moderates the AI roundtables.\ninstructor for the Game Development Certificate Program through the University of\nSteve earned a B.S. in Computer Engineering and an M.S. in Computer Science,\nAutònoma de Barcelona and is now working on a Ph.D. in Computer Vision and\ncourse, video games.\ngames, including Men of Valor (Xbox and PC), Master of the Empire, and several Zoo\nGame Programming Gems and AI Wisdom series.\nfor a variety of Serious Games projects, including a series of sponsored educational\nmini-games for the World Book Multimedia Encyclopedia; and more recently,\ncontributed articles to several books in the Game Programming Gems series, and\nauthored the section on real-time physics for Introduction to Game Development.\ngamedev.net, has presented at the annual Game Developer’s Conference (GDC) and\nHe teaches courses in game\ndevelopment, computer graphics, and programming.\nHis research interests include\nConference on Entertainment Computing and Microsoft Academic Days on Game\nHe also contributed to Game Programming Gems 5.\njoining academia, Roden spent 10 years as a graphics software developer in the simu-\nSathe is working as a software engineer in the Advanced Visual Computing\nfor game developers.\ncurrent interests include graphics, mathematics, and computer architecture.\nHe has been working for 10 years in the research and devel-\non games and 3D graphics.\nThis is Robert’s seventh year programming audio in the games industry.\nOnline services and multiplayer game system support have become her development\nPrior to games, her network background included telecommunications, IP\nJavier Taibo graduated in computer science at the University of Coruña in 1998.\nhas worked on computer graphics R&D projects in the “Visualization for Engineer-\nbeen working on include real-time 3D terrain rendering and GIS visualization, virtual\nmation and 3D interaction at the University of A Coruña.\nComputer Science (Computer Graphics) from Universidade Federal do Rio Grande do\nHer research interest topics are focused on the development and\nsolutions for computer and video games and simulation applications on PC, PlaySta-\nvides behavior-capture AI agents for games and simulation applications.\nfor managing development of TruSoft’s AI solutions and leads TruSoft’s R&D efforts,\nrecently received a master’s degree in Video Games Creation at Pompeu Fabra Univer-\nof Computing at the Federal University of Ceará in Brazil.\nHis current research interests are computer graphics, vir-\nSystems, Jon is a regular contributor to the independent game development commu-\nworking forum on the independent games site GameDev.Net, he enjoys sharing\nputer Science at The University of North Carolina at Charlotte, co-director of the Games\nwork studies how artificial agents and real people interact in virtual environments,\nincluding computer games and high-fidelity simulations in order to understand the ele-\nworked with real-time computer games, intelligent environments, and robotics since\nHis research interests are in interactive artificial intelligence, entertainment com-",
      "keywords": [
        "Computer Science",
        "Computer",
        "computer graphics",
        "computer games",
        "Games",
        "Game Programming Gems",
        "University",
        "Federal University",
        "Computer Science department",
        "Science",
        "game development",
        "Gilvan Rodrigues Maia",
        "computer vision",
        "Game Programming",
        "computer game technologies"
      ],
      "concepts": [
        "games",
        "gaming",
        "include",
        "including",
        "graphics",
        "engineer",
        "engineering",
        "developer",
        "university",
        "working"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 3,
          "title": "",
          "score": 0.773,
          "base_score": 0.623,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 1,
          "title": "",
          "score": 0.696,
          "base_score": 0.546,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 2,
          "title": "",
          "score": 0.599,
          "base_score": 0.449,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "",
          "score": 0.499,
          "base_score": 0.349,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 25,
          "title": "",
          "score": 0.473,
          "base_score": 0.323,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "computer",
          "science",
          "games",
          "university",
          "development"
        ],
        "semantic": [],
        "merged": [
          "computer",
          "science",
          "games",
          "university",
          "development"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20401253769775804,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074324+00:00"
      }
    },
    {
      "chapter_number": 5,
      "title": "Segment 5 (pages 34-47)",
      "start_page": 34,
      "end_page": 47,
      "summary": "Replacement Using the Age and Cost Metrics by Colt McAnlis.\nEfficient Cache Replacement\ntem is identifying the proper victim page to vacate when the cache fills to its upper\nAs cache misses occur, the choice of page-replacement algorithm is essential—\nPopular cache-replacement algorithms,\nthat require more data to make accurate victim page identifications.\nthe Age and Cost metrics to be used as values in constructing the cache-replacement\nof memory called pages.\nwhich time the operating system must choose a page from the cache in which to\nreplace with the incoming page data.\namount of needed pages exceeds the size of the cache by a significant amount (usually\nof cache replacements.\nSo, in determining which page to dump from memory when a cache miss\ncache.\ncreate an algorithm that best describes which page is ideal to remove from the cache\nThese types of algorithms, called victim page determination or page-replacement\nReplacement Cache (ARC) is an algorithm developed by IBM used both in hardware\nThis gem describes two cache page metrics that can be interweaved together\nCache-Replacement Algorithms\nSince their creation, cache-replacement systems have been an active area of research,\nThe most efficient replacement algorithm would always replace the page that would\nThe LRU algorithm replaces the page that hasn’t been used for the longest amount of\nWhen a new page is loaded into the cache, data is kept per page that represents\nUpon a cache miss, the victim page is\nMRU replaces the page that was just replaced.\nThat is, the youngest page in the cache.\nMRU will not replace the entire cache; rather, during heavy thrashing it will always\nchoose to replace the same page.\nMRU for texture cache page replacement.\nthe cache creates a scratch pad in memory for one page, leaving most of the cache\nWhen you’re dealing with a situation in which the extra pages needed\nThe not frequently used (NFU) page-replacement algorithm changes the access heuristic\nto keep a running counter of accesses for every page in the cache.\npage accessed during the current time interval will increase their counter by one.\nTo replace a page,\nbeen used since then can have the same count as a page used every other frame for the\nEfficient Cache Replacement Using the Age and Cost Metrics\ngames in the current generation of hardware: the design of a custom texture cache.\ndo this, you will reserve a static one-dimensional array of cache pages into which data\ninto a single cache page.\nFor example, if the cache page size fits a 256 \u0002 256 texture,\ncache where you need to insert a new 256 \u0002 256 page into the cache when it is\nthe required data available to properly calculate which full cache page is the optimal\none to replace and which group of 32 \u0002 32 textures needs to be dumped as the access\npatterns depend greatly on more than the time at which the page was last replaced.\nthe best pages to replace when in such a situation.\nThe OPT algorithm knows the amount of usage for a page in the cache and replaces\na page has been accessed in a window of time.\npage first enters the cache.\nEvery frame, all active pages in the cache are bit-shifted left by one bit, signifying\nIf an active page is used in this frame, the least significant\nFor example, a page that is accessed every other frame would have an Age variable\nTo show how the Age variable evolves over time, consider a page that is used in the\nYou average the number of frames a page has been used versus\nthat have not been used in a certain time, as well as pages that are not frequently used\nFor example, a page that has been accessed every frame in the window will\nhave a 100% APC and will be almost impossible to replace, whereas a page with an\npages in the cache can have radically different access patterns but have the same APC\nEfficient Cache Replacement Using the Age and Cost Metrics\nhelp separate those pages with similar APC values (such as analyzing sub-windows for\nthe memory required to deduce page information fairly low; hence storing a used/\nin situations where the required page amount is larger by a significant factor, the Age\nthat were used every frame, and only 12 cache pages in which to put them, there\nEvery frame would thrash the entire cache, replacing each page.\nIn this situation, the constant loading/reloading of pages and textures would cause\nevery page to have an Age counter set to 1, and thus would lack any additional infor-\nstoring how often that page was used in the frame.\nFor example, consider two pages (TextureA and TextureB) loaded into the cache \nAt this point, both pages would have the same APC\noperations to help identify the best page to evict from the cache:\n• Finding the page with the MIN usages in a given frame window will identify the\nleast used page in general, which is helpful to identify victims.\nMost victim page identification algorithms use only a single heuristic.\namount of cache page misses.\npage.\ninvolved with a cache miss—the cost of filling the page of the cache with the new data.\nFor most hardware caches this is a constant cost associated with the time it takes the\nFor your software needs, however, this cost can often fluctuate between pages\nof filling the page.\nConsider that in the previous example, an incoming texture page is generated by\npotentially replacing a page in memory during victim page determination.\nin the next few frames if that page is required.\nIn a nutshell, factoring in cost as a page-replacement variable allows you\na victim page identification function to be more concerned about performance cost of\nBy itself, cost contains the same problems that other cache replacement algorithms\nBecause there’s always a cheaper page available, the entire cache could potentially\nhighly expensive pages in the cache indefinitely.\nEfficient Cache Replacement Using the Age and Cost Metrics\nallow your cache to find a nice medium between page-replacement requirements and\nThe previous example assumed that each page in the texture cache had an associative\ncache by streaming them from disk, the RC may be a result of the texture size divided\nThis page is highly expensive to replace, thus will be a hard candidate\nWith the APC of 1.0, this identifies that the page has been\npage can be replaced is if it’s forced by a full cache dump, which might\nThis page has a relatively high RC, but its APC shows that it’s rarely\nreplace, however its APC says that it will be needed next frame.\nReplacing this page would be no problem, but due to the high APC, \nThis page has an extremely low APC, which points to the fact that it\nAs seen in this table, using the simplistic RC*APC value can result in pages with\ncost, but has an APC value of 100%, so there’s a high probability that this page will be\ncache to find a page with a higher ThrashCost, but with a lower APC value.\nisn’t found, it’s safe to assume that this page may need to be replaced for the sake of\nthe cache.\nHowever, depending on your system, the better page to replace may vary.\nIf too many of these pages are introduced into the cache, the available working\nBecause cache replacement needs change over the\nEfficient Cache Replacement Using the Age and Cost Metrics\ncache-page replacement performance, resulting in a lower overhead of thrashes and\n“The LRU-K Page-Replacement Algo-",
      "keywords": [
        "cache",
        "Age",
        "APC",
        "cache page",
        "Age Algorithm",
        "Cost",
        "Cache Replacement",
        "Efficient Cache Replacement",
        "victim page",
        "pages",
        "cache page replacement",
        "Cost Metrics",
        "Age variable",
        "Expanded Age Algorithm",
        "cache page metrics"
      ],
      "concepts": [
        "pages",
        "cache",
        "caching",
        "texture",
        "replacement",
        "replace",
        "replacements",
        "cost",
        "algorithm",
        "memory"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 62,
          "title": "",
          "score": 0.425,
          "base_score": 0.425,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 61,
          "title": "",
          "score": 0.39,
          "base_score": 0.39,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 9,
          "title": "",
          "score": 0.344,
          "base_score": 0.344,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 22,
          "title": "",
          "score": 0.341,
          "base_score": 0.341,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "",
          "score": 0.335,
          "base_score": 0.335,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "page",
          "cache",
          "replacement",
          "apc",
          "cache page"
        ],
        "semantic": [],
        "merged": [
          "page",
          "cache",
          "replacement",
          "apc",
          "cache page"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18104246779417071,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:44.074373+00:00"
      }
    },
    {
      "chapter_number": 6,
      "title": "Segment 6 (pages 48-56)",
      "start_page": 48,
      "end_page": 56,
      "summary": "Allocator\nallocator with debugging features and additional interface functions to achieve better\nheap allocation support.\nallocation, or go as far as outright banning its use in runtime components of the game\nset out to create a heap allocator that can give the programmer the performance charac-\ntion, uses a hybrid approach, where allocations are handled by two separate methods,\nbased on the requested allocation size.\nSmall allocations are handled by bins of linked\nlists of similarly sized chunks, whereas large allocations are handled by bins of “trie”\nIn both cases, a “header” structure is allocated together with\nduring a free operation, and also for coalescing with other neighboring blocks.\ntions with non-default alignment are handled by over-allocating and shifting the start\nBoth of these factors, header structure and over-allocating, contribute unfavorably\nA pool-style allocator uses a large chunk of memory, divided into smaller chunks\nof equally sized blocks that are managed by a single linked list of free blocks, com-\nOur solution uses a hybrid approach, whereby we split our allocator in two parts—\none handling small allocations and the other handling the rest.\nSmall Allocator\nSelection of the appropriate bin based upon allocation size.\nNotice that since the small allocations are arranged into bins of specific sizes, you\nevery allocation.\nTo explain this, we need to establish how the small allocator would deal with\nYou might want to allocate large blocks of memory from the OS,\nHigh Performance Heap Allocator\nneed to check the very first page’s free-list to see whether you have a free element avail-\nexample, when the allocation size is known in advance, as is the case with “new”-ing\npool-style allocator.\nLarge Allocator\nThe small allocator is simple and fast; however, as allocation sizes grow, the benefits of\nbinning and pool allocations quickly disappear.\nto a different allocator that uses a header structure and an embedded red-black tree to\nLayout of memory use in the large allocator.\nIn addition to this, you need to store information about whether a block is\nfield, because the requested sizes for large allocations are rounded up to the size of the\nHigh Performance Heap Allocator\nThis allocator uses\nblack tree that uses the so-called “nil” node, because the essential “rotate” operation can\nWith all this setup done, during an allocation you search the red-black tree for the\nThe more interesting use of the red-black tree happens when you need to allocate\nThis allocator uses the fact that you can iterate a binary\ntree in sorted order, and notice that you need to check nodes with sizes equal or larger\nating through a red-black tree is an O(log(N)) operation, so obviously larger align-\nCombining the Allocators\nNow that you have two allocators, there is another problem.\nThe small allocator relies\nWith two allocators\nthough, you need a way to distinguish which allocator a given address comes from.\nsure the large allocator always uses pages that are at least as large as the small allocator’s\naccept the address as originating from the small allocator; otherwise, you forward it to\nthe large allocator.\nA third solution is to use a reserved virtual address range for all small allocations,\nHigh Performance Heap Allocator\nIt is quite important these days to have robust multithreading, and the allocator is\nthe small allocator can have a mutex per bin because once the bin is selected there is no\nThis means that allocations that go to different bins can\nOn the other hand, the large allocator is more complicated and\nyou need to lock it as soon as an operation needs access to the red-black tree.\nSo far, we have a high-performance allocator that can easily be used as a malloc/free\nspecifically we use an embedded red-black tree to quickly search debug records and also\nspecific structure arises from the fact that you need to use large memory chunks\nsimilar to how dynamic arrays over-allocate and then fill in elements one at a time.\nallocation request, which can be quite useful for tracking memory leaks.\nSo far, this allocator follows quite closely the malloc/free/realloc interface.\nalready allocated block, but without changing the address of that block.\nThis is beneficial to this allocator\nbecause it can use that size to determine whether the small or the large allocator\nshould free that block.\nThere is a reference implementation of the allocator on the included CD.\nmentation that takes advantage of our allocator’s features and extensions.\nprovide a simple synthetic benchmark to verify that the allocator has any performance\nFurthermore, we show several ways to integrate this allocator with existing or\n“Composing High-Performance Memory Allocators,”\n“The Hoard Memory Allocator,” available online at\n“A Memory Allocator,” available online at http://g.oswego.edu/\nHigh Performance Heap Allocator",
      "keywords": [
        "Performance Heap Allocator",
        "Allocator",
        "heap allocator",
        "Small Allocator",
        "red-black tree",
        "memory",
        "High Performance Heap",
        "size",
        "Large Allocator",
        "block",
        "tree",
        "Performance Heap",
        "free",
        "Small allocations",
        "bin"
      ],
      "concepts": [
        "allocator",
        "allocation",
        "allocations",
        "allocated",
        "allocate",
        "memory",
        "block",
        "size",
        "sized",
        "pages"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 9,
          "title": "",
          "score": 0.647,
          "base_score": 0.497,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 28,
          "title": "",
          "score": 0.589,
          "base_score": 0.439,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 14,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 29,
          "title": "",
          "score": 0.538,
          "base_score": 0.388,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 8,
          "title": "",
          "score": 0.524,
          "base_score": 0.374,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "allocator",
          "allocations",
          "small",
          "black tree",
          "heap"
        ],
        "semantic": [],
        "merged": [
          "allocator",
          "allocations",
          "small",
          "black tree",
          "heap"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23845842266203396,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074426+00:00"
      }
    },
    {
      "chapter_number": 7,
      "title": "Segment 7 (pages 57-65)",
      "start_page": 57,
      "end_page": 65,
      "summary": "Optical Flow for Video Games\nOptical flow is the movement between the pixels of\nature to determine the optical flow field between a pair of images [Beauchemin95].\nframes, motion history, and a more advanced technique called the Lucas and Kanade\nThe optical flow is an array of vectors that describes the movement that has\nThe optical flow\nIn computer vision games, the optical flow is used to determine if a particular\nputationally cheaper methods that compute only if a given pixel has changed with\nThis section explains the most important functions of the webcamInput class.\ncapsulated all the logic to acquire images through the camera and process them.\nthat indicates which method of the optical flow will be used.\n//to save the previous image to do optical flow\nThe function getImage() acquires a new image from the Webcam and converts it\nFinally, flowRegions() is used to count the activated pixels in the defined\nregions of interest, and the current image is copied to imageOld for using it in the next\noptical flow computation.\nFirst Method: Image Differences\none: image differences.\ncurrent camera image from the previous one:\ncvAbsDiff( imageOld, image, mask );\nThe cvAbsDiff function subtracts image from imageOld, which are the current\nand previous images of the Webcam.\nindicates similar pixels in image and imageOld) are discarded, whereas the ones with a\nOptical Flow for Video Games Played with Webcams\nnoise in the images.\nsists in smoothing the image using a Gaussian kernel of 5 \u0002 5 pixels.\nSecond Method: Motion History\nThe second method is called motion history.\nIt uses the same principle of the image\ndifferences but uses more than just the previous image, and “remembers” recently\nIn this function, buff is a cycling buffer where the last N images from the Web-\nThen the motion history image mhi is updated with this new information\nFinally, the new motion history image is\nscaled to an 8 bits per pixel mask image.\nMoreover, this motion history image can be\nThird Method: Lucas and Kanade Algorithm\nThe first two methods don’t give as output the real optical flow, they just detect pixels\noptical flow estimation method by Lucas and Kanade [Lucas81].\nThe function cvCalcOpticalFlowLK() computes the optical flow between the\ngray-level images imageOld and image using the Lucas and Kanade method.\nimage, and flowX and flowY, where the components of the optical flow vectors will be\nOptical Flow for Video Games Played with Webcams\nThe image size was 640 \u0002 480.\nImage differences\nOptical Flow Game\nIn order to see the results of the optical flow in a real application, we developed a simple\nThe point is to use the optical flow in the game, so we have encapsulated the\nfunctionality described previously in a C++ class called webcamInput, which makes it\nwebcamInput( int method=1 );\nin the previous section, you want to use in order to calculate the optical flow.\nIn order to show on the screen the color image coming from the Webcam (the player’s\nwhich informs you of the size of the image coming from the Webcam.\nthe QueryFlow() function, you can calculate the optical flow of the current frame.\nthat has taken place in a particular area of the image (the one occupied by a stain to be\nThis function creates a region with its origin at the coordinates (x, y) of the image\nthe extent of the movement in each region by using the function FlowRegions().\nOptical Flow for Video Games Played with Webcams\nthe query for optical flow in several distinct regions.\nto divide the initial image into 16 regions as a 4 \u0002 4 grid (see Figure 1.3.2).\nin order to paint the colour image coming from the Webcam.\n3. During the game updates, the function mWebCam.QueryFlow() will be called\nimages of the stains that are active at that particular moment.",
      "keywords": [
        "Optical Flow",
        "image",
        "Flow",
        "Optical",
        "motion history image",
        "method",
        "pixels",
        "Video Games Played",
        "Optical Flow Game",
        "Lucas and Kanade",
        "Game",
        "motion history",
        "Webcam",
        "function",
        "Image Differences"
      ],
      "concepts": [
        "images",
        "methods",
        "functions",
        "functionality",
        "games",
        "pixels",
        "different",
        "differences",
        "value",
        "flow"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 61,
          "title": "",
          "score": 0.449,
          "base_score": 0.449,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "",
          "score": 0.417,
          "base_score": 0.417,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "",
          "score": 0.411,
          "base_score": 0.411,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 62,
          "title": "",
          "score": 0.406,
          "base_score": 0.406,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 27,
          "title": "",
          "score": 0.401,
          "base_score": 0.401,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "optical",
          "image",
          "optical flow",
          "flow",
          "motion history"
        ],
        "semantic": [],
        "merged": [
          "optical",
          "image",
          "optical flow",
          "flow",
          "motion history"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24379803944217757,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:44.074478+00:00"
      }
    },
    {
      "chapter_number": 8,
      "title": "Segment 8 (pages 66-75)",
      "start_page": 66,
      "end_page": 75,
      "summary": "Threading Engine\nmulti-platform threading system.\nperformance requirement demands that the threading system also be lightweight.\nthat will use the threading system.\nThis gem focuses on the development of a threading engine that has been engi-\nSystem Design for a Practical Threading Architecture\nOne of the most basic, yet the most efficient, principles of threading a game system\nof intersystem communication) and thread them.\nA Pragmatic Threading Architecture\nOn the book’s CD, you’ll find the source to a complete multi-platform threading sys-\nthis context is that any thread can be suspended by the operating system to allow for\nanother thread to execute.\nis a singleton that should be available to all game systems that need access to thread-\nDesign and Implementation of a Multi-Platform Threading Engine\nThe GLR thread library.\nIn order to execute properly, the threading system needs the ability to query infor-\nThe GLRThreadFoundation is the focal point for all threading interactions.\nthreading interactions that you can execute include the ability to execute tasks from a\ngame’s objects, as well as accessing threads from the pool.\nbe a single instance of the thread foundation.\nTo access functionality inside the threading system, you use the following method\nThreads\nThreads are segments of code that can be scheduled for execution by the operating\nComparison between a single threaded and multithreaded programming\nGLRThread is the platform-agnostic implementation for a thread within the\nplatform-implemented thread:\n• Creating a thread\n• Executing a thread\n• Altering a thread’s properties\n• Resuming a thread\n• Terminating a thread\n• Temporarily suspending a thread\n• Querying the status of a thread \nThere are several variations of property management and thread execution.\nwhere and generally how a thread will execute a task.\nPreemptible and Simultaneously Executed Threads\nof the most important aspects of engineering a threading system is the consideration of\ntion of a thread to allow another thread to execute.\nexecution of a current thread, it will save the context of the currently executing thread\nThe switching of threads\nthreads (on the same core) usually share the same L1 cache, which generally means you\nThread Properties\nDesign and Implementation of a Multi-Platform Threading Engine\nOne of these costs is memory associated with the thread to store its\nIf you need to increase the size of thread stacks on a Windows-based OS (such as\nThread Execution Properties\nA thread execution property is a platform-agnostic interface that allows for more granu-\nA thread’s execution property also has the ability to define its ideal\nThis is defined inside GLRThreadExecutionProps.h. On a single physical processor with hyper-thread capabilities, the GetProcess\nAffinity requests threads to execute on a specific processor.\nyour threading libraries.\nGLRThreading library allows you to designate a thread’s priority according to the fol-\nThe default setting for newly created thread execution properties priority is nor-\nThread Allocation Strategies\nthread manager object, implemented as a singleton, that processes requests in a create-\nwell as the runtime performance of constantly allocating and deallocating a thread.\nThread Pools\nThe actual number of threads created for the pool is dependent on the system\nDesign and Implementation of a Multi-Platform Threading Engine\nThe thread pool is a subsystem that works off of the time-tested paradigm of task\nAt regular intervals, worker threads look for a task to execute.\nwork available, the execution attributes are set up and the thread is resumed.\ntask has been executed, the thread is suspended and made available for subsequent\nThread Pool Properties\nThe thread pool has properties that allow for the defining of several characteristics\nThe thread pool needs\nthe ability to change the number of created threads, the number of tasks that the\nthreads can work on, and the ability to lock the task pool at any particular time.\nthread pools for different subsystems in a game engine might be an even better idea.\nof thread properties, task scheduling, and so on), you have to introduce another layer\nObject Threading\nThe GLRThreading library provides its threading capabilities through a process of\nTo make the execution of the objects easier, the process of allowing threads to execute\ncreate tasks, submit them, and let the threading system deal with allocation, execution,",
      "keywords": [
        "thread",
        "threading system",
        "system",
        "thread pool",
        "game",
        "Threading Engine",
        "Task",
        "thread execution",
        "Thread Execution Properties",
        "Multi-Platform Threading Engine",
        "execution",
        "Engine",
        "game engine",
        "GLRThreading library",
        "multi-platform threading"
      ],
      "concepts": [
        "threading",
        "task",
        "execute",
        "executed",
        "execution",
        "game",
        "implementation",
        "implementations",
        "core",
        "performance"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 13,
          "title": "",
          "score": 0.629,
          "base_score": 0.479,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 9,
          "title": "",
          "score": 0.591,
          "base_score": 0.441,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 6,
          "title": "",
          "score": 0.524,
          "base_score": 0.374,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 28,
          "title": "",
          "score": 0.455,
          "base_score": 0.305,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 14,
          "title": "",
          "score": 0.454,
          "base_score": 0.304,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "thread",
          "threading",
          "threads",
          "execution",
          "platform"
        ],
        "semantic": [],
        "merged": [
          "thread",
          "threading",
          "threads",
          "execution",
          "platform"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20775667123588348,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074525+00:00"
      }
    },
    {
      "chapter_number": 9,
      "title": "Segment 9 (pages 76-90)",
      "start_page": 76,
      "end_page": 90,
      "summary": "Dealing with issues of designing game systems that are thread-safe and reentrant is a\ndependent on the architecture and data-access patterns of the game.\nObject alignment along cache boundaries is important for a standard single-core\nof memory being mapped, but with the number of cache lines that are being accessed.\ncache-aligned data structures.\ngame object will be defined and is called TestSystem (see Listing 1.4.1).\nThe TestSystem game object has two private data structures: a GLRThreadedTask\nThe Implementation of the Game Object’s Threadable Function\nThe sample code in Listing 1.4.3 shows how you use the TestSystem object\nto Handle Hexagonal Tiles\nThe typical choice, a square grid, is biased by the square’s simple\nhexagonal grids are awkward in software development.\nFor their space-filling efficiency, biology prefers hexagonal grids to square grids:\nEven though hexagonal grids have a number of other benefits, they require\nThe Pros and Cons of Hexagonal Tilings\nTo be able to judge whether a square or a hexagonal tiling fits the task best, you have\nbased on square tiles as an example.\nwhere a step means the transition from one tile to one of its neighbor tiles.\nHexagonal tilings offer an advantage here.\nThus, the notion of a neighbor isn’t ambiguous for hexagonal grids.\nOf all shapes that can tile the plane, regular hexagons have the smallest perimeter for\nThus, whenever a grid has to\nThanks to their compact shape, regular hexagons form the tiling with the highest\nhexagonal grid you can reach the accuracy of a square grid with about 10% fewer\ncells.\nIn games, grids are often used to represent playing fields.\nFor Bees and Gamers: How to Handle Hexagonal Tiles\nhexagonal grid is close to that of a straight line.\nHexagonal grids, however, possess 12 directions of symmetry that one could use\nnal grid with horizontally aligned tiles, where every second row is indented by half the\nwidth of a tile, and a vertically aligned grid.\nWhereas square tiles are ideal for cities (left), hexagonal tiles lend themselves\ntiles of a hexagonal appear horizontally or vertically aligned.\nFor Bees and Gamers: How to Handle Hexagonal Tiles\nA hexagonal grid allows perpendicular coordinate axes with half-integer val-\nMastering the Hexagonal Grid\nThanks to object-oriented programming, the issues of a hexagonal grid can be hidden\nEvery scheme to translate an address into a spatial location on a hexagonal grid and\nData container classes supporting random access and\nclasses representing addressing schemes that map grid addresses to container elements.\nfrom the tile’s address given in perpendicular or skewed coordinates.\ncoordinate axes are used, a rectangular section of cells can be defined through an upper\nzoidal set of cells.\nWhereas these containers access data slower than indexed containers,\nyou can use the cell addresses directly as keys.\nbuilt-in limit to the address range and that empty cells don’t consume memory.\na class that implements the addressing scheme of your choice.\nHere, the class that deals with the mapping between addresses and data is called\nschemes of hexagonal grids.\nIts instance can be set to represent any cell\nin the grid and provides an interface to read and write the target cell’s data.\nInstead of iterating through the cells in a pre-determined\nThis class provides free movement on the grid,\nonly steps through a sequence of cells that represent a specific subset of the grid—\nfor example, only the next neighbors of a given cell.\nEnumerator classes to iterate over different neighborhoods, even customized ones\nDecoupling the logic of the grid from your actual game logic\nFor Bees and Gamers: How to Handle Hexagonal Tiles\nWhereas a Walker can access any neighbor of a tile, the\nWalker base class that defines a common interface but doesn’t rely on a specific address-\nface, it’s possible to step through all the cells in the specific selection using a foreach\nAssume that a cell in the grid is of type CellData and you have a generic Enumerator\ncreated and initialized by passing a Walker instance center defining which cells neigh-\ninterface, iterating through all the neighbors of the center cell becomes as easy as this:\nforeach(CellPointer<DataType> cell\n// do something with cell\nThe core functionality of the AddressingScheme is to provide data access on a grid\nuse cases require you to find a cell based on screen or world coordinates.\ngrid into rectangular sections as shown in Figure 1.5.8.\ncells allows simple hit-test computations.\nare only three choices left and it becomes trivial to compute the correct cell address.\nTo show some practical benefits, consider three scenarios where hexagonal grids may\nInstead, a grid can be used to preselect objects within a certain radius.\nThe grid divides the game world into tiles that behave as cells; based on its location,\neach entity is registered at one of these cells.\nof a game object it suffices to consider objects registered with cells that contain points\nIf the region to be searched is circular, hexagonal grids would be the optimal\nforeach(CellPointer<List<GameObject>> cell\nforeach(GameObject obj in cell.GetData())\nEach cell consists of a list of instances of GameObject.\nthe Enumerator class is defined that allows iteration through all cells in the search\nIt yields a Walker object pointing to a specific cell.\nAs the cell’s data is a list of\nGameObjects, another foreach loop can be used to iterate through the game objects\nassociated with this cell.\nA number of games use tiles as building blocks for their game worlds.\nFor Bees and Gamers: How to Handle Hexagonal Tiles\nSix different offsets have to be applied to the current cells\naddress to access adjacent cells.\ngrid is aligned vertically).\nThe listing below performs a simple breadth-first search on a grid of cells to find\nneighbors of a cell are accessed using a matching neighborhood enumerator.\nto object-oriented abstraction, the algorithm becomes independent of a specific grid\nforeach(CellPointer<PathCell> cell\nif(cell.GetData().Moveable &&\ncell.GetData().ExpandedFrom == null)\ncell.GetData().ExpandedFrom\nopenCells.Enqueue(cell);\nIn the two-dimensional setting, the interacting components are usually cells on a grid\nwhere the next state of a cell is computed based on the current state of itself and the\nadjacent cells.\nThe direction insensitivity of hexagonal grids makes them attractive for cellular\nthe set of cells that determine a cell’s next state is itself and its six direct neighbors (see\nclosest 12 or even 18 cells.\nFor Bees and Gamers: How to Handle Hexagonal Tiles\nIf the simulation code is directly operating on cell addresses, it is hard to experiment\nwith different selections of influencing cells.\ncell data.\nplifies working on a hexagonal grid.\nnasty details that make hexagonal grids so cumbersome to work with.",
      "keywords": [
        "Handle Hexagonal Tiles",
        "hexagonal grids",
        "Hexagonal Tiles",
        "Hexagonal",
        "grid",
        "cells",
        "General Programming FIGURE",
        "Tiles",
        "Handle Hexagonal",
        "game",
        "Data",
        "game object",
        "Cache",
        "Programming FIGURE",
        "Object Synchronicity"
      ],
      "concepts": [
        "cells",
        "tiles",
        "tiling",
        "tilings",
        "object",
        "games",
        "grid",
        "direct",
        "directions",
        "direction"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 6,
          "title": "",
          "score": 0.647,
          "base_score": 0.497,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 8,
          "title": "",
          "score": 0.591,
          "base_score": 0.441,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 28,
          "title": "",
          "score": 0.538,
          "base_score": 0.388,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 14,
          "title": "",
          "score": 0.487,
          "base_score": 0.337,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 13,
          "title": "",
          "score": 0.486,
          "base_score": 0.336,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "hexagonal",
          "cell",
          "grid",
          "cells",
          "tiles"
        ],
        "semantic": [],
        "merged": [
          "hexagonal",
          "cell",
          "grid",
          "cells",
          "tiles"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23961191292345904,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074578+00:00"
      }
    },
    {
      "chapter_number": 10,
      "title": "Segment 10 (pages 91-99)",
      "start_page": 91,
      "end_page": 99,
      "summary": "A Sketch-Based Interface to\ncurrent game titles, and, despite recent improvements, common unit-based interfaces\nsketch a path or a target on the screen that units must follow or stay.\nface is very simple: using the mouse, the user draws a sketch line (or point) on the\nThis sketch creates an “influence zone” in the battlefield, and every unit inside\nthis zone must follow the sketched path or target.\nthe sketch-based interface that allows macro-management of the context, and a unit-\nbased interface to control the micro-management of the unit’s movement (see Figure\nA Sketch-Based Interface to Real-Time Strategy Games\nBy using the mouse, the user draws a sketch on the screen, which pushes the\nunits inside the sketch influence zone to the desired target.\nFocus-context interface: combination of a sketch-based interface\nthat controls the context (army disposal, at left) and unit-based interface that\nof sketches, from a far view, and turn to the unit-based interface when soldiers engage in\nThere are many ways to implement a sketch-based interface and the most important\nProcessing of user commands uses a totalistic cellular automaton, which is\nPath Sketching\nsketching curves or points directly on the battlefield.\nIn the first task, let’s assume that the player creates the sketch by simply clicking and\nunits to the sketches.\nIn this approach, each sketch is converted into forces that act\ndirectly over units by pushing them to desired positions on the battlefield.\ndiscretization of the battlefield is used here, storing at each cell a vector representing \nupdated throughout time and vary according with the user sketch.\nillustrates, forces are stronger in cells closer to the sketch, and are linearly attenuated\nA Sketch-Based Interface to Real-Time Strategy Games\nIn the first stage of the implementation, 2D coordinates of the sketch (left)\nA sketch (left) and its underlying discretization as a grid of forces on the\nThe proposed representation and sketch update can be efficiently done with a cel-\nis given by the sketch position and direction on the grid (see Figure 1.6.6).\nspread out on the battlefield, attenuated by the distance to the sketch.\nThe 3D coordinates of the sketch (see Figure 1.6.4) are converted to 2D\nEach point on the grid corresponding to a sketch\ndefine commands by sketches and to integrate the sketch-based interface with the cur-\nrent unit-based interfaces.\nthe force grid approach, and also suggest a simple way to integrate sketch-based unit\nGuiding units can be made by line sketches, which are directly\nconverted to force vectors on the grid (see Figure 1.6.7).\nto ensure that the sketch is represented by a sufficient number of points on the grid.\nThis can be accomplished by rasterizing the lines defined between the sketch points\nsketch (or even a point), which is then converted to a set of vectors around the sketch,\npointing to the sketch center, as shown in Figure 1.6.7.\nthe sketch creates a vector field pointing to the sketch center, which pushes units\nA Sketch-Based Interface to Real-Time Strategy Games\n(illustrated in the third column) is a special case, where the sketch cancels the forces of the grid.\nin long sketches (giving more time to units traveling along the battlefield) and small\nin sketches indicating target or smaller movements.\nThe integration of a sketch-based interface with an existing unit-based interface is\nThe sketch-based approach just adds a new item in the unit movement equa-\nmeans that any unit on the battlefield can query the grid for the direction in which it\nThe sketch control\nA possible integration of sketch- and unit-based interfaces.\nsketch control can be seen as a black box, which receives arrays of 2D points from\nthe application interface and can be queried for forces in any battlefield position.\nThis gem discussed a simple and efficient approach for implementing sketch-based\n(such as projection of points and grid update through a cellular automaton), thus allow-\nresults in lines of units crossing the battlefield.",
      "keywords": [
        "sketch",
        "battlefield",
        "Interface",
        "Sketch-Based Interface",
        "grid",
        "General Programming FIGURE",
        "units",
        "Strategy Games",
        "Programming FIGURE",
        "Real-Time Strategy Games",
        "cellular automaton",
        "River Media Inc.",
        "Automaton",
        "Game",
        "Charles River Media"
      ],
      "concepts": [
        "sketch",
        "sketches",
        "units",
        "commander",
        "game",
        "grid",
        "interface",
        "cell",
        "users",
        "battlefields"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "",
          "score": 0.677,
          "base_score": 0.527,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "",
          "score": 0.616,
          "base_score": 0.466,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 1,
          "title": "",
          "score": 0.564,
          "base_score": 0.414,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 3,
          "title": "",
          "score": 0.507,
          "base_score": 0.357,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "sketch",
          "based interface",
          "sketch based",
          "interface",
          "battlefield"
        ],
        "semantic": [],
        "merged": [
          "sketch",
          "based interface",
          "sketch based",
          "interface",
          "battlefield"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.26446355727312676,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074650+00:00"
      }
    },
    {
      "chapter_number": 11,
      "title": "Segment 11 (pages 100-107)",
      "start_page": 100,
      "end_page": 107,
      "summary": "Foot Navigation Technique for\nThis gem proposes a technique where the player\ncontrols navigation with the foot, keeping both hands free for other types of interac-\nThis foot-based navigation technique allows walking forward and backward,\nThe tracking of the foot can be\nWe implemented the navigation technique in two ways.\nwas used to capture foot translation and rotation (see Figure 1.7.1 for an example of\nWebcam to capture and identify the translation and orientation of a printed marker\nattached to the player’s foot (see Figure 1.7.1 for an overview of the setup).\nThe following sections present the fundamentals of the foot-based navigation\nthey were not as fast and precise with the use of the foot as a video game controller as\ndevice (left), and a square marker pattern attached to the player’s foot and a\nNavigating with the Foot\nThe navigation technique proposed allows the players to control their movement speed\nthey must move their foot forward (see Figure 1.7.2(c)).\nplayers slightly move their foot a few centimeters back (see Figure 1.7.2(a)).\nplayers want to turn left or right, they just turn their foot left or right, as can be seen in\nThe following sections explain how to implement this navigation technique using\nFoot Navigation Technique for First-Person Shooting Games\nGame navigation control using the right foot: backward (a); rest position (b);\nRequirements for an Implementation Based on Computer Vision\nIn this gem, we propose the use of a marker-based approach provided by\ning augmented reality applications we used to capture the movement of the player’s foot.\nMore details about the ARToolKit marker-recognition principle can be found at\nshould be printed and attached on the player’s foot in such a way that it remains\nright information from ARToolKit. The first step consists of checking the foot rota-\ning on whether the right or the left foot is used to control the program.\nyou detect that the player’s foot has moved farther than this threshold, the character\ntheir foot, the faster they will go.\nset up the camera and load the file that describes the pattern to be detected.\npreferred camera settings.\nconst char *cparam_name = \"Data/camera_para.dat\"; \nsetup_camera(cparam_name, vconf, &artcparam);\nvoid setup_camera(\nthrow runtime_error(\"Unable to open connection to camera.\\n\");\nthrow runtime_error(\"Unable to set up AR camera.\");\nstdout, \"Camera image size (x,y) = (%d,%d)\\n\", xsize, ysize);\n\"Error loading parameter file %s for camera.\\n\") %\nNext, parameters are transformed for the current image size, because camera\nparameters change depending on the image size, even if the same camera is used.\nFoot Navigation Technique for First-Person Shooting Games\nThe camera parameters are set to those read in and printed on the screen:\nfprintf(stdout, \"*** Camera Parameter ***\\n\");\n\"Unable to begin camera data capture.\\n\");\nLet’s now show some sample code illustrating how to get the position of the marker\nusing ARToolKit. You first detect the marker in the frame using arDetectMarker in this\nuseful if you need to detect several markers at the same time.\narGetTransMat(&marker_info[i], patt_centre, patt_width, patt_trans);",
      "keywords": [
        "Foot Navigation Technique",
        "Navigation Technique",
        "Foot",
        "marker",
        "Technique",
        "Navigation",
        "Foot Navigation",
        "camera",
        "patt",
        "First-Person Shooting Games",
        "ARToolKit",
        "Shooting Games",
        "implementation",
        "error",
        "cparam"
      ],
      "concepts": [
        "marker",
        "foot",
        "games",
        "sections",
        "section",
        "patterns",
        "based",
        "camera",
        "users",
        "easily"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "",
          "score": 0.703,
          "base_score": 0.553,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 1,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 10,
          "title": "",
          "score": 0.616,
          "base_score": 0.466,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.562,
          "base_score": 0.412,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 3,
          "title": "",
          "score": 0.475,
          "base_score": 0.325,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "foot",
          "navigation",
          "camera",
          "navigation technique",
          "marker"
        ],
        "semantic": [],
        "merged": [
          "foot",
          "navigation",
          "camera",
          "navigation technique",
          "marker"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19412743838890528,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074701+00:00"
      }
    },
    {
      "chapter_number": 12,
      "title": "Segment 12 (pages 108-115)",
      "start_page": 108,
      "end_page": 115,
      "summary": "if(m[12] > start_position_x + mov_eps){\n}else if(m[12] < start_position_x - mov_eps){\nthat it’s too hard to control rotation and walk/strafe at the same time, so choose the\ncontrols for your game wisely.\nA Sample Game\nimplemented a sample FPS game containing a simple map that the user can explore\nIn the first contact with the game, the player can interact in the training zone, the\nThe game starts only when the user passes over the cyan tile (see Figure\nback (screen changes color, as shown in Figure 1.7.6) is sent to the player each time it\nFoot Navigation Technique for First-Person Shooting Games\nThe game is over when, after passing over all checkpoints, the player attains\ntask in the shortest time with as few collisions with obstacles and walls as possible.\nSketch of the game circuit.\nGame start indicator, indicated by the lighter\nAll game events are logged in a text file, so you can detect when users have trouble\nsample game so we could measure their performance and hear their suggestions.\nasked how comfortable they felt playing the game, how easy it was to use and learn,\nFoot Navigation Technique for First-Person Shooting Games\nIn the sample game, we measured the number of collisions and the time\nwere not as fast when using their foot as a video game controller.\ncompleted the task in a reasonable time and easily avoided all obstacles.\nThis gem presented a new technique to allow navigation for FPS games using one of\nments and then transforms them into interaction controls for the game environment.\nwhole body to interact with the game gives a deeper immersion for the player, as games\nMultiplayer games are also an untapped possibility, because the marker-based\nthe controller should be attached to the user’s foot while movements should be per-\nFinally, we estimate a different game design, such as\nFoot Navigation Technique for First-Person Shooting Games\nModern video game machines are no exception to\nthe trend, with multi-core CPU designs being prevalent in many of the game machines\ntasks independently of the others, but all send along a notification to the game when the\ntask is done (usually in the form of an interrupt), so that the game can schedule other\nThe way in which a game handles these notifications can either lead to a fairly\ntiming-related issues, and provides a system to handle them gracefully.\nFrom the game’s point of view, these notifications may happen at any time, and thus\nthe game can run on the main processor at the pace it desires, while other processors do\nimproperly, these notifications can lead to timing-related bugs or system instability.\nTiming-related bugs are notoriously difficult to track down, and can happen if you try to\nuse memory before another system client is done with it, or if you change the game state\nDevelopers working on handheld gaming systems are faced not only with these\nof a vertical blanking period, which is the point in time where the graphics engine(s)\nDuring this time, you need to quickly determine what new\ndeveloper must make the changes and data uploads as quickly as possible.\nan enemy of game developers and we never seem to get enough of it.\nprobably can’t get more time in which to do work, we’ll have to settle for making\nmost work is handled by making function calls, this gem uses a system that queues up\nLet’s examine the vertical blank period where you have very limited time.\nIn essence, you’re setting up the function call earlier in the game loop, but defer-",
      "keywords": [
        "game",
        "Foot Navigation Technique",
        "navigation technique",
        "time",
        "First-Person Shooting Games",
        "technique",
        "Shooting Games",
        "Sample Game",
        "navigation",
        "foot navigation",
        "System",
        "foot",
        "work",
        "sample FPS game",
        "angle"
      ],
      "concepts": [
        "game",
        "gaming",
        "control",
        "controller",
        "time",
        "timing",
        "user",
        "foot",
        "interrupt",
        "data"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 1,
          "title": "",
          "score": 0.742,
          "base_score": 0.592,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "",
          "score": 0.703,
          "base_score": 0.553,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.69,
          "base_score": 0.54,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 10,
          "title": "",
          "score": 0.677,
          "base_score": 0.527,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 26,
          "title": "",
          "score": 0.616,
          "base_score": 0.466,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "game",
          "foot",
          "navigation",
          "navigation technique",
          "shooting games"
        ],
        "semantic": [],
        "merged": [
          "game",
          "foot",
          "navigation",
          "navigation technique",
          "shooting games"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2626065356188823,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074752+00:00"
      }
    },
    {
      "chapter_number": 13,
      "title": "Segment 13 (pages 116-124)",
      "start_page": 116,
      "end_page": 124,
      "summary": "Most functions are set up to take their arguments directly in the function parameters,\ndeferred functions (and then resetting the lists when that is done).\none function is platform-dependent, and must take into account the ABI (application\nneed only to rewrite the deferred function caller.\npurpose register are not allowed as parameters to the deferred functions.\nload any parameters stored for use with the function.\nDeferred functions are an extremely useful tool for game developers on all platforms,\nMultithread Job and\ncept of threads in the system; it is replaced by the concept of jobs, which are defined as\nThe process of creating a job is shown in the following code.\non the CD contains the job manager and the wrapper classes.\nPARALLEL_JOB_HANDLE handle;\nhandle = PARALLEL_JOB_MANAGER_CreateJob( \nPARALLEL_JOB_MANAGER_ScheduleJob( handle );\nThe synchronization of jobs is handled by a dependency system.\ncreation of synchronization points and job dependencies.\nThe Job System\nThe job system is mainly composed of four types of objects:\n• The job, which is unit of work delimited in a callback function.\n• The manager, which maintains the job list by priority and type.\n• The workers, which execute the jobs assigned to them.\nJob\nJobs are represented by the class shown in the following code.\nPARALLEL_JOB_PRIORITY is an enum containing classic\nThe handle identifies the job in the\nclass PARALLEL_JOB\nFunction( Context );\nPARALLEL_JOB_HANDLE\nPARALLEL_JOB_PRIORITY\nPARALLEL_JOB_TYPE\nPARALLEL_JOB_FUNCTION\nFunction;\nsystem’s central point, it maintains the list of jobs in a multithread-safe manner.\nmanager is responsible for worker and scheduler thread creation and initialization.\nuling of jobs is separated to allow the user to add dependencies to and on the created\njob.\ntypedef void (*PARALLEL_JOB_FUNCTION )( void* );\nPARALLEL_JOB_HANDLE CreateJob(\nPARALLEL_JOB_FUNCTION function,\nPARALLEL_JOB_HANDLE CreateAndScheduleJob(\nPARALLEL_JOB_FUNCTION function,\nPARALLEL_JOB_HANDLE job_handle\nThe PARALLEL_JOB_HANDLE is a structure that contains a unique identifier and a\none is free, it selects the next job, assigns it to the worker thread, and puts itself back\nMultithread Job and Dependency System\nPARALLEL_JOB_MANAGER_GetNextJob returns the best job to be executed next.\nif there is no new job available and some worker threads are free.\nWhen new jobs are\nif( PARALLEL_JOB_MANAGER_GetNextJob( next_job, thread_index ) )\nworker_thread_table[ thread_index ]->SetAssignedJob(next_job);\nWhen finished, it informs the dependency manager that its job is finished.\nFinally, it signals the scheduler that it is waiting for a new job.\nTo ensure code and data cache coherency, both jobs and worker threads have been\nThe type of the job can be anything you want, depending on your sys-\nThe type will be used in job selection, so choose them care-\nJob Selection \nWhen the scheduler asks for the next job to execute, the manager uses simple rules to\nthread type changes and high priority tasks.\nif( job of type current_type exists )\nnew_job = job of type current_type with highest priority\nif( priority of new_job – highest priority available > 2 )\nnew_job = job with highest priority\nworker thread type = new job type\nnew_job = job with highest priority\nworker thread type = new job type\nThe current implementation has two types of entry: jobs and groups.\nMultithread Job and Dependency System",
      "keywords": [
        "Job",
        "System",
        "PARALLEL",
        "Function",
        "priority",
        "deferred function",
        "type",
        "thread",
        "Job System",
        "jobs",
        "Dependency System",
        "Function Call",
        "Deferred Function Call",
        "Call Invocation System",
        "manager"
      ],
      "concepts": [
        "function",
        "functions",
        "job",
        "jobs",
        "void",
        "type",
        "thread",
        "depending",
        "dependency",
        "dependent"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 8,
          "title": "",
          "score": 0.629,
          "base_score": 0.479,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 14,
          "title": "",
          "score": 0.626,
          "base_score": 0.476,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 28,
          "title": "",
          "score": 0.491,
          "base_score": 0.341,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 9,
          "title": "",
          "score": 0.486,
          "base_score": 0.336,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 6,
          "title": "",
          "score": 0.449,
          "base_score": 0.299,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "job",
          "jobs",
          "parallel_job_handle",
          "function",
          "priority"
        ],
        "semantic": [],
        "merged": [
          "job",
          "jobs",
          "parallel_job_handle",
          "function",
          "priority"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19058284789852487,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074798+00:00"
      }
    },
    {
      "chapter_number": 14,
      "title": "Segment 14 (pages 125-136)",
      "start_page": 125,
      "end_page": 136,
      "summary": "The Dependency Graph\nThe dependency graph is stored inside dependency entries.\nA dependency can be in two states: met or blocked.\nIf a dependency entry\nis met, it means that every other entry that depends on it can be executed.\nof its dependencies is blocked, an entry is also blocked.\nTo prevent polling of dependencies, an entry contains a dependency count.\neach blocked dependency an entry depends upon, the counter is increased.\ncounter is zero, the dependency is met; otherwise, it is blocked.\nWhen a dependency\nenters the met state, it iterates over all its dependent objects to decrease their counts.\nThe dependency count of job 3 decreases by\n1, whereas the dependency count of PreRender group decreases by 2.\nInitial graph with dependency count.\nThe dependency table is a sparse vector of pointers to entries.\nused to allocate a free slot to the current dependencies.\nWhen an entry is created, an index is requested from the index dis-\nThis recycling means that the dependency cannot be identified by its index alone.\nThis structure contains an index to the table of dependency entries and a unique\nThe following code shows the creation of a dependency group and links.\nmation jobs will set up a dependency over the Animation group.\nPARALLEL_DEPENDENCY_IDENTIFIER\n= PARALLEL_DEPENDENCY_MANAGER_CreateEntry( \"PreRender\n= PARALLEL_DEPENDENCY_MANAGER_CreateEntry( \"Animation \nMultithread Job and Dependency System\nDependency graph created by previous example.\n• Dynamic link: As soon as the dependency is met, the link is removed.\nA group entry creates a synchronization point.\nthe dependency is met.\nJob Entry\n• To synchronize other entries with the job\nThe entry is created with a dependency count set to one.\ndependency that the execution of the job sets on the entry.\nIf the entry’s dependency count is one, there is no depen-\nthe worker thread pseudocode, it reports that the job is finished to the dependency\nThe dependency count is then set to zero, and the entry becomes met and\npropagates the information to all entries that depend on it.\n• Preemption: Low-priority tasks could be preempted if a new job is pushed into the\ninto the Dependency System\nThe dependency system supports only two types of entry: job and group.\nThe dependency\nThe PARALLEL_DEPENDENCY_ENTRY can be\nVirtual functions that inform the dependency state\nMultithread Job and Dependency System\nproviding a dependency graph system, the jobs can be chained without any other action\nthan creating a dependency link between them.\nwith the help of the PARALLEL_DEPENDENCY_ENTRY interface.\nnow be able to create and schedule a job enjoying considerably less threading-related\nare signaled to the application through exceptions, which, if you fail to handle them\n(for example, when your application is accessing an invalid memory address).\nSynchronous exceptions are expected and usually handled in an organized manner.\nException Handling\nThe C++ language offers built-in support for handling synchronous exceptions\nTheir handling depends on how the underlying platform\nMicrosoft unified the handling of both exception types on their Windows plat-\nThe most interesting part is that the function will execute a user-defined\nReporting Unhandled Exceptions\nOn Windows platforms, you can use the Microsoft Debugging Tools API that is\nyou can create a mini-dump file of the running process.\nmeans that the dump files created with this API are usually much smaller in size than\nIn order to explicitly create a core dump on UNIX platforms, you have to use a\nlibrary that provides a simple API for creating core dumps of a running process.\nWriteCoreDump function writes a dump of the current process into a specified file for\nSo far, this implementation can handle almost all cases that can cause an application\nThe only condition where the error handling fails is in case of a stack over-\nIf the stack reaches its maximum size, the allocation of a new guard page in step 3\nIn this case, a stack overflow exception is raised, which can be handled by the\nthread’s exception block.\nviolation because the functions have too large stack overhead.\ncall the CreateThread function, you can move all the exception handling into a new\nThen you can work with a clean stack and do whatever kind of reporting you\nIn the exception handler, you wait until the worker thread has finished its work\nnal handler is called, the stack is so exhausted that you can’t properly report the error.\nleak reports or even application crashes.\n• Leaks caused by allocations using malloc won’t be detected.\nso-called allocation hooks for tracking the application’s memory requests.\nhooks are provided by the C runtime library and allow you to override memory man-\nlibrary through the hook functions.\nInstalling Allocation Hooks\nThe Microsoft CRT allows you to install an allocation hook through its _CrtSetAlloc\nHook function.\nWhen or where do you install an allocation hook?\nThe GNU C library even allows you to completely replace the memory functions\nor return value that is called after the library finishes installing its default allocation\nfunctions.\noverloaded memory functions.\nImplementing Allocation Hooks\nThe leak detector manages an allocation registry that contains information about the\nallocated memory blocks.\nrequested block size, and the call stack during the allocation request.\nand report them as memory leaks.\nThe hook function passed to _CrtSetAllocHook must have the following signature:\nallocType parameter specifies what operation was triggered (_HOOK_ALLOC, _HOOK_\nWhen the function has finished its work, it returns an\nFor more information on the allocation hook function, refer to [MSDNHook07].\nThe signature of the GNU C library hooking functions is similar to the runtime\nThe hook functions all work in the following way:\n1. The original hook functions are restored.\n4. Back up the current hook functions.\n5. Install the custom hook functions.\nWindows Error Reporting (WER)\nallows vendors and developers to access crash dumps sent through WER to Microsoft.\nbucket contains crash reports caused by the same bug.\n• Application name—For example, game.exe\ninvokes WER and must be called inside the application’s exception handler.\ncute the operating system utility dwwin.exe, which creates the crash report and prompts\napplication from error reporting (this function requires write access to HKEY_LOCAL_\nWindows Vista offers a completely new API to work with WER.\nincludes several functions to create and submit error reports.\nFor a complete listing of available WER functions, refer to\nFunction\nExcludes the specified application from error reporting.\nCreates a new report.\nThis function will be\nThe CDebugHelp class contains helper functions for creating dumps and call",
      "keywords": [
        "Dependency",
        "Dependency System",
        "job",
        "dependency count",
        "System",
        "Stack",
        "entry",
        "application",
        "hook functions",
        "hook",
        "Windows",
        "memory",
        "function",
        "functions",
        "Dependency Graph"
      ],
      "concepts": [
        "function",
        "functions",
        "stack",
        "memory",
        "reports",
        "dependency",
        "depends",
        "dependencies",
        "dependent",
        "exceptions"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 13,
          "title": "",
          "score": 0.626,
          "base_score": 0.476,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 6,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 28,
          "title": "",
          "score": 0.528,
          "base_score": 0.378,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 9,
          "title": "",
          "score": 0.487,
          "base_score": 0.337,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 8,
          "title": "",
          "score": 0.454,
          "base_score": 0.304,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "dependency",
          "hook",
          "entry",
          "job",
          "dependency count"
        ],
        "semantic": [],
        "merged": [
          "dependency",
          "hook",
          "entry",
          "job",
          "dependency count"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22394978083465675,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074845+00:00"
      }
    },
    {
      "chapter_number": 15,
      "title": "Segment 15 (pages 137-144)",
      "start_page": 137,
      "end_page": 144,
      "summary": "class for Microsoft’s Debugging Tools API.\nexclude the exception handler thread that you start when handling a stack overflow\nreporter will write the leak information into the debug output window when run on\ntunately, the GNU C library provides only a single function (backtrace_symbols) for\nmethods to handle unexpected exceptions, like Windows Unhandled Exception Filters\nusing a threaded exception handler on Windows or an alternative signal handler stack\ncan report all leaks with a complete stack trace when your game exits.\ncomplete debugging framework providing unhandled exception handling with crash\nMemory leak detection is implemented in the\ngame.\n“The GNU C library,” available online\n[Google05] Google coredumper library available online at http://code.google.com/\nException Handling,” available online at http://www.microsoft.com/msj/0197/\n“New Vectored Exception Handling in Windows XP,”\navailable online at http://msdn.microsoft.com/msdnmag/issues/01/09/hood/\n[MSDNDump07] MSDN Library.\nhttp://msdn2.microsoft.com/en-us/library/ms680360.aspx, June 1, 2007.\n_CrtSetAllocHook,” available online at http://msdn2.microsoft.com/en-us/\n“WER Functions,” available online at\nhttp://msdn2.microsoft.com/en-us/library/bb513635.aspx, June 1, 2007.\nable online at http://msdn2.microsoft.com/en-us/library/aa373342.aspx, June 1,\n“Effective Mini-Dumps,” available online at\n“Signal (Computing),” available online at http://\ngame development, there is real truth in that statement.\nThe heaviest uses of math by game develop-\nability to apply advanced physically-based lighting and material models on a per-pixel\nthe realm of real-time game simulation, will rely not only on AI, but also on physically-\nbased animation techniques that enable game characters to interact with a dynamic\nand where the game world itself is subject to play-driven geometric change.\ngame worlds themselves, with which sophisticated characters must interact, are also\ngame development that is heavily math-driven.\nmodeling, otherwise known as procedural generation, generative modeling, and prob-\nOne fact of commercial game development has been that\nthe cost of content development using traditional digital content-creation tools has\nSo large studios are now beginning to pay homage, in a way, to the game develop-\nProcedural modeling, in all its\nProcedural modeling of flora for game levels is currently\nquite heavily used for commercial game development.\nubiquitous, for the procedural modeling of other game level elements, such as build-\nThere is even a highly anticipated game in development that claims to\napply procedural modeling to create cellular organisms, planets, stars, nebulae, and\n(That won’t be the case.) For this to work, of course, tools and game developers must\napply the proper mathematical or physically-based techniques.\ntion, for application toward artificial intelligence, physics techniques, and procedural\nengine procedural generation of model geometry.\npresentation of techniques that are quite useful for procedural model generation in his",
      "keywords": [
        "game",
        "library",
        "MSDN Library",
        "exception",
        "Exception Handling",
        "Techniques",
        "online",
        "Memory Leak Detector",
        "procedural modeling",
        "procedural",
        "game development",
        "UNIX",
        "Leak Detector",
        "Memory Leak",
        "Windows"
      ],
      "concepts": [
        "library",
        "game",
        "exception",
        "exceptions",
        "available",
        "function",
        "functions",
        "techniques",
        "model",
        "provides"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 54,
          "title": "",
          "score": 0.583,
          "base_score": 0.433,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 51,
          "title": "",
          "score": 0.367,
          "base_score": 0.217,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 8,
          "title": "",
          "score": 0.353,
          "base_score": 0.353,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 6,
          "title": "",
          "score": 0.302,
          "base_score": 0.302,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "procedural",
          "exception",
          "microsoft com",
          "microsoft",
          "online"
        ],
        "semantic": [],
        "merged": [
          "procedural",
          "exception",
          "microsoft com",
          "microsoft",
          "online"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15227696171629787,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074892+00:00"
      }
    },
    {
      "chapter_number": 16,
      "title": "Segment 16 (pages 145-153)",
      "start_page": 145,
      "end_page": 153,
      "summary": "Random Number Generation\nhis article is an introduction to random number generators (RNGs).\nof random number generators, providing strengths and weaknesses of each.\nBackground: Random Number Generation\nRandom number generators (RNGs) are essential to many computing applications.\nFor some problems, algorithms employing random choices perform better than any\nknown algorithm not using random choices.\nsolve a given problem if randomness is allowed.\nsolvable on a [Turing] machine equipped with a random number generator is BPP,\non a computer without random choice.)\nMost random numbers used in computing are not considered truly random, but\nare created using pseudo-random number generators (PRNGs).\nministic algorithms, and are the only type of random number that can be algorithmi-\ntion of Random Numbers Is Too Important to Be Left to Chance.” Like cryptogra-\nRandom numbers are used in many applications, including the following:\n• Random game content and level generation.\n• Until recently, primality proving used randomized algorithms.\n• Cryptography algorithms such as RSA use random numbers for key generation.\n• Optimization algorithms use random numbers significantly—simulated anneal-\nBecause an algorithm cannot create “true” random numbers, many hardware-based\nconsidered a very good source of randomness.\nOther sources of physical randomness are as follows:\nget random numbers from WiFi noise).\nthe source has, and then how many high-quality random bits can be extracted.\nHere are a few Websites offering random bits of noise and the method used to\n• http://random.org/—Atmospheric noise.\nPseudo-Random Number Generators (PRNGs)\nPRNGs generate a sequence of “random” numbers using an algorithm, operating on\nan internal state.\nOften the internal state is also the returned value.\nthe state being finite, the PRNG will repeat at some point, and the period of an RNG\nA PRNG using n bits for its state\nrandom number “quality,” there are many different RNG algorithms.\n#defined as RAND_MAX, quite often the 15-bit value, 32767.\nC/C++ rand() functions are Linear Congruential Generators, which are poor choices\npoor quality random numbers that exhibit various kinds of bias.\nequally likely random integers are needed in a range [a,b].\nC code like (rand()%(b-a+1)) + a.\nFor example, if RAND_MAX is 32767, then trying to generate numbers in the\nRandom Number Generation\nRandomness Testing\nnot behave like a random sequence should.\nMany sources of random bits have some bias or bit correlation, and methods to\n• Flip every other bit, removing uniform bias.\n• XOR with another known good source of bits, as in Blum Blum Shub.\nThese whitened streams should still not be considered a secure source of random\nfollowing methods is a PRNG with output sequence Xn. Some have a hidden internal\nLCGs’ strengths are they are relatively fast and use a small state, making them\nRepresenting an LCG as LCG(m, a, b), Table 2.1.1 shows some LCGs in use.\nThese store an internal state Si updated using an LCG, which in turn is used to generate\nusing the fast m as a power of two but avoids the poor low order bits in the LCGs. If\nreturn (seed>>16)&0x7FFF; // return bits 16-30\nmine the internal state (up to an unneeded most significant bit), and thereby know all\nA simple way to compute the state is to notice the top bit of the state\nRandom Number Generation\n15 bits of the state, leaving 17 bits unknown.\nfirst known 15 bits and test each of the possible 217 unknown bit states to see which\noutputs are not enough because they do not uniquely determine the state.\nA Linear Feedback Shift Register (LFSR, see Figure 2.1.1) generates bits from an\nNew bits are shifted into the state,\nand are a linear function of bits already in the state.\nsequences can be chosen to make an n bit LFSR have period 2n – 1.\nUse k words of state Xn = (Xn–j\nMT19937 uses an internal state of\nThe speed comes from only updating a small part of the state for each random\nnumber generated, and moving through the state over multiple calls.\na 32-bit value:\n{ /* Generates random 32 bit numbers.\nRandom Number Generation\nThese algorithms produce numbers with better equidistribution than MT19937 and\nrandom numbers.\nunlikely any video game will ever need that many random numbers, because it is far\ning states with a large number of zeros.\nsomehow falls into such a state, the generated numbers have heavy bias toward zeros\n/* initialize state to random bits  */\nstatic unsigned long state[16];\n/* return 32 bit random number      */\nunsigned long a, b, c, d;\nc  = state[(index+13)&15];",
      "keywords": [
        "Random Number Generation",
        "Random Number",
        "random number generators",
        "Random",
        "Number",
        "state",
        "Number Generation",
        "number generators",
        "random bits",
        "bits",
        "bit random number",
        "quality random numbers",
        "Mersenne Twister",
        "internal state",
        "rand"
      ],
      "concepts": [
        "random",
        "randomized",
        "generation",
        "generators",
        "generated",
        "generate",
        "algorithms",
        "state",
        "bits",
        "bit"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 17,
          "title": "",
          "score": 0.838,
          "base_score": 0.688,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 24,
          "title": "",
          "score": 0.65,
          "base_score": 0.5,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 62,
          "title": "",
          "score": 0.396,
          "base_score": 0.396,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 3,
          "title": "",
          "score": 0.315,
          "base_score": 0.315,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 9,
          "title": "",
          "score": 0.309,
          "base_score": 0.309,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "random",
          "random number",
          "bits",
          "state",
          "numbers"
        ],
        "semantic": [],
        "merged": [
          "random",
          "random number",
          "bits",
          "state",
          "numbers"
        ]
      },
      "topic_id": 8,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1866365879747837,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074940+00:00"
      }
    },
    {
      "chapter_number": 17,
      "title": "Segment 17 (pages 154-161)",
      "start_page": 154,
      "end_page": 161,
      "summary": "c  = state[(index+9)&15];\na  = state[index] = b^c; \nstate[index] = a^b^d^(a<<2)^(b<<18)^(c<<28);\nWhenever possible, use an implementation from a trusted and competent source.\n/dev/random\nAlthough not a specific algorithm, Linux and many UNIX flavors implement a source\nof randomness in /dev/random, which returns random numbers based on system\nentropy, so it is considered a true random number generator.\n/dev/random blocks,\nRandom Number Generation\nnumbers are not as secure, and use of /dev/urandom depletes system entropy, allow-\nLike /dev/random, it is considered a true random\nnumber generator.\n[Kelsey99] introduces Yarrow, which uses system entropy to generate random numbers.\nused in Mac OS X and FreeBSD to implement /dev/random.\ndom sources available to the system, and is considered a true RNG because it uses\nCommon Mistakes in Creating Random Number Generators\nhand at making a random number generator by creating a “super-random” generator.\nRandom Number Generation\nnumber generator at http://xkcd.com/c221.html, reproduced for your viewing pleasure:\nThere are many online places to obtain source code for the algorithms covered in this\nL’Ecuyer’s Web page (www.iro.umontreal.ca/~lecuyer/papers.html) is a good source of\nThis gem has provided basics of RNGs, including many common algorithms.\nLFSR258, and the WELL generators offer better choices than the Mersenne Twister for\nStrengths and weaknesses were presented for algorithms where possible.\ndictable Pseudo-Random Number Generator,” SIAM Journal on Computing, Vol. 15, pp.\n[Boost07] “The Boost C++ Library,” 2007, www.boost.org.\nNumber Test Suite Version 2.24.4,” available online at www.phy.duke.edu/~rgb/\nwww.cs.berkeley.edu/~daw/papers/ddj-netscape.html.\nof the Linux Random Number Generator,” March 2006, Black Hat 2006,\nDesign and Analysis of the Yarrow Cryptographic Pseudorandom Number Gen-\nVerlag, August 1999, www.schneier.com/paper-yarrow.html.\n“Random Numbers for Simulation,” Communications of\n85–98, www.iro.umontreal.ca/~lecuyer/papers.html.\nGenerators,” Mathematics of Computation, 68, 225 (1999), pp.\nwww.iro.umontreal.ca/~lecuyer/papers.html.\nof Random Number Generators,” May 2006, Revised November 2006, ACM\nwww.iro.umontreal.ca/~lecuyer/papers.html.\nDimensionally Equidistributed Uniform Pseudorandom Number Generator,”\nPeriod Generators Based on Linear Recurrences Modulo 2,” ACM Transactions on\nRandom Number Generation\nFast Generic Ray Queries \necently, real-time ray tracing on consumer PCs has become possible.\nray tracer traces millions of rays per second, per core, using instruction-level par-\nRay tracing is useful for more than just rendering.\nefficient spatial subdivision for ray queries in a static scene.\nIntroduction to Ray Tracing\nRay tracing is a simple algorithm.\nconstruct a ray from the camera to the pixel\nintersect the ray with each primitive in the scene\nHere, a ray is an infinite line with an origin, O, and a direction, D, as shown in\nTracing a single ray is referred to as ray casting.\nAt the intersection point, a new ray to each light source is cre-\nsection point is reflective or refractive, this will also recursively spawn new rays.\nIf you look at the process of tracing a single ray alone, you see a visibility query.\nSome of these obviously require a ray query (player visibility, bullets, and ray\none or more rays.\nMost 3D engines support ray queries in one form or another, but\nIf rays are traced using a naive search of the scene geometry,\nspatial subdivision, a ray query can be reduced to a few tree traversal steps and a lim-\nited number of ray/triangle intersections.\ncient acceleration structure for ray tracing [Havran01], and approaches to a highly",
      "keywords": [
        "random number generator",
        "random number",
        "index",
        "number generator",
        "random",
        "number",
        "Ray",
        "Blum",
        "Blum Shub",
        "Linux Random Number",
        "true random number",
        "random numbers based",
        "generator",
        "Number Generation",
        "ray tracing"
      ],
      "concepts": [
        "algorithm",
        "ray",
        "rays",
        "generator",
        "generation",
        "generate",
        "number",
        "source",
        "implementation",
        "implement"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 16,
          "title": "",
          "score": 0.838,
          "base_score": 0.688,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 24,
          "title": "",
          "score": 0.586,
          "base_score": 0.436,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 62,
          "title": "",
          "score": 0.311,
          "base_score": 0.311,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "ray",
          "random",
          "random number",
          "number",
          "generator"
        ],
        "semantic": [],
        "merged": [
          "ray",
          "random",
          "random number",
          "number",
          "generator"
        ]
      },
      "topic_id": 8,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.14101948461376163,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.074984+00:00"
      }
    },
    {
      "chapter_number": 18,
      "title": "Segment 18 (pages 162-170)",
      "start_page": 162,
      "end_page": 170,
      "summary": "The kD-tree (k-dimensional tree) is a structure that recursively splits space in two\nsplitting process.\nspace, because of the arbitrary split plane position.\nMaking the split planes axis-aligned may seem limiting.\nA kD-tree node thus contains a split plane position and an orientation.\nBesides the split\nplane, a node stores a list of primitives or as a pointer to a left and right child node.\ngeometry but is split into two child nodes) or a leaf node (which has geometry but no\nchild nodes).\nint axis;\n• By allocating child nodes at each split in pairs, the KdTreeNode that the right\nThis way, only a single child node pointer\nthe kD-tree node using an index and a count (see Figure 2.2.3).\n• If a node is a leaf, it doesn’t require the child node pointer.\ncan be used for the leaf flag (1 bit) and the split plane axis (2 bits).\nvoid SetAxis( int a_Axis ) { m_Data = (m_Data & -4) + a_Axis; }\nfloat m_Split;\nIn this structure, the m_Data member contains the leaf bit, the split plane axis,\nand either a pointer to the left child node or a pointer to an entry in the primitive\nprobably want a balanced tree with few primitives spanning split planes.\nFinding the optimal split plane position.\n• No split at all.\n• A single vertical split through the right vertex of the triangle.\n• A single horizontal split through the bottom vertex of the triangle.\neither split the triangle or will add empty space to a node.\nsome percentage of the rays, and so does a horizontal split.\nleaf node with a smaller area than the horizontal split, so it reduces the chance that a ray\nneeds to be intersected with the triangle more than the horizontal split.\nWhether or not a split is needed at all depends on the cost of intersecting a triangle,\nthe cost of not splitting at all.\nsplit_cost = traversal_cost + left_area * left_cost\nBecause you need the number of triangles to the left and right of\neach possible split plane, you must walk the list of triangles 2N times per split, per\nsplit plane positions along the horizontal axis.\nthese events (start events and end events), the left and right triangle counts can be\nof the tree, the events need to be resorted, because many triangles will no longer be in\nConsider the EventBox for the left triangle: It has two next pointers\nEventBoxSide* next( int axis ) { return (EventBoxSide*)\nOrdered traversal (front-to-back, for ray tracing) of a kD-tree is identical to BSP tree\nTraversal starts by finding the leaf node that contains the ray origin.\nnode, the side of the split plane that the origin is on is determined, and the branch for\nThe large triangle resides partially in the node that contains the ray origin.\nyou allow intersections outside the current node, intersecting the ray with this triangle\n• (Figure 2.2.7a): The intersection of the line with the split plane (tsplit) lies between\nThe left node is traversed first, with tmax = tsplit.\nThe right node is\nYou need only to traverse the left node, and\nYou need only to traverse the right node, and\nRays that hit the split plane from the right side are handled in the same manner;\nthe only difference is that the left and right child nodes are now swapped.\nint axis = node->GetAxis();\nKdTreeNode* front = node->GetLeft() + rdir[axis * 2];\nKdTreeNode* back  = node->GetLeft() + rdir[axis * 2 + 1];\nfloat tsplit = (node->m_Split - O.cell[axis]) * R.cell[axis];\nnode = back;\nnode = front;\nstack[stackptr++].node = back;\n// leaf node found, process triangles\nint start = node->GetObjOffset();\nint count = node->GetObjCount();\nfor (int i = 0; i < count; i++ ) // intersect triangles\nThe array raydir is used to swap the left and right child nodes efficiently.\noffset of the near and far nodes (with respect to the ray direction) for an axis, for an",
      "keywords": [
        "split",
        "node",
        "split plane",
        "data",
        "axis",
        "Generic Ray Queries",
        "Ray",
        "left",
        "int",
        "Ray Queries",
        "cost",
        "triangle",
        "split plane axis",
        "split plane position",
        "Fast Generic Ray"
      ],
      "concepts": [
        "node",
        "axis",
        "splits",
        "triangles",
        "tree",
        "ray",
        "rays",
        "left",
        "bits",
        "bit"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 21,
          "title": "",
          "score": 0.541,
          "base_score": 0.391,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 23,
          "title": "",
          "score": 0.428,
          "base_score": 0.278,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 19,
          "title": "",
          "score": 0.414,
          "base_score": 0.414,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 34,
          "title": "",
          "score": 0.396,
          "base_score": 0.396,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 20,
          "title": "",
          "score": 0.355,
          "base_score": 0.205,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "node",
          "split",
          "split plane",
          "plane",
          "axis"
        ],
        "semantic": [],
        "merged": [
          "node",
          "split",
          "split plane",
          "plane",
          "axis"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1729146644782898,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075031+00:00"
      }
    },
    {
      "chapter_number": 19,
      "title": "Segment 19 (pages 171-180)",
      "start_page": 171,
      "end_page": 180,
      "summary": "kD-tree traversal cases.\nDynamic Objects\nRay tracing dynamic scenes is an area of active research.\nThe first tree contains the static geometry,\nTracing rays in a mixed\nFirst, the ray traverses the tree for the static scenery; then, the ray\ntraverses the tree that contains the dynamic triangles.\nfirst, but in practice, most rays will miss the dynamic geometry, because this geometry\nIn the proposed scheme, the tree containing the dynamic triangles is rebuilt each\nBy fixing plane positions, a tree for the dynamic triangles can be built in\nUsing a separate tree for dynamic triangles\nstructures yield reasonable results, but can be built in less time than a kD-tree.\nPer frame, the dynamic object is rotated,\nThese rays are traced through the static kD-tree and the dynamic kD-tree to\nthe ray queries.\nFast Generic Ray Queries for Games\nDynamic geometry is\nImplemented well, the presented approach lets you trace 1 million rays per sec-\nYou might even want to explore the fascinating world of real-time ray traced\n“Heuristic Ray Shooting Algorithms,” PhD thesis, Czech\n“Heuristics for Ray Tracing using Space\n“Instant Ray Tracing: The Bounding Inter-\n“Realtime Ray Tracing and Interactive Global Illumination,” PhD\n“On Building Fast kD-trees for Ray Tracing, and\nInteractive Ray Tracing (2006), pp.\nmated Scenes Using Coherent Grid Traversal,” ACM Transactions on Graphics,\nDynamic Bounding Volume Hierarchies,” ACM Transactions on Graphics (2007),\nFast Generic Ray Queries for Games\nmost computationally intensive tasks is collision detection of objects in gameplay.\ncube-maps, works only with convex rigid bodies and has a preprocessing step and a\nOne technical approach to discrete collision detection tries to find intersecting\nroom for improvement and optimization, which the new farthest feature map concept\nThis approach uses a data structure that is similar to a cube-map; that is, it is a directional\nimagine an axis-aligned cube centered at the origin and then shoot rays from the origin\nject the line segment from the centroid to the vertices on this ray.\nWe call this data structure a farthest feature in that sampled direction.\nAn intuitive way to visualize a farthest feature map is to think of a perpendicular\nplane for a given sampled direction.\nsect with the convex object to yield some polygon in that plane.\nAt this point, the distance to the perpendicular plane is the farthest dis-\ntance in that direction and any vertices from geometry that lay on the plane just prior\nthe convex geometry of the game object being processed.\nresent the directions that they are being moved in order to find the farthest features\nFast Rigid-Body Collision Detection Using Farthest Feature Maps\nPlanes perpendicular to the sampled directions\nPlanes perpendicular to the sampled\ndirections dir1 and dir2 in their farthest positions.\nand V1 form the farthest features in dir2 direction and\nV2 is the farthest feature in dir1 direction.\nFigures 2.3.4 and 2.3.5 illustrate the construction of the farthest feature map in\n3D, showing the farthest features in two different sampled directions.\nFast Rigid-Body Collision Detection Using Farthest Feature Maps\nThe plane that is perpendicular to dir1 moving\nThe plane that is perpendicular to dir2 moving away",
      "keywords": [
        "Ray tracing",
        "ray",
        "farthest feature map",
        "farthest feature",
        "Generic Ray Queries",
        "Ray tracing dynamic",
        "ray queries",
        "collision detection",
        "Farthest",
        "Dynamic",
        "rays",
        "plane",
        "tracing",
        "Fast Generic Ray",
        "Generic Ray"
      ],
      "concepts": [
        "ray",
        "rays",
        "dynamic",
        "traverses",
        "traversing",
        "planes",
        "fast",
        "maps",
        "map",
        "triangles"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 1,
          "title": "",
          "score": 0.444,
          "base_score": 0.444,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "",
          "score": 0.42,
          "base_score": 0.42,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 18,
          "title": "",
          "score": 0.414,
          "base_score": 0.414,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 61,
          "title": "",
          "score": 0.402,
          "base_score": 0.402,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 7,
          "title": "",
          "score": 0.398,
          "base_score": 0.398,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "ray",
          "farthest",
          "dynamic",
          "tracing",
          "farthest feature"
        ],
        "semantic": [],
        "merged": [
          "ray",
          "farthest",
          "dynamic",
          "tracing",
          "farthest feature"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24325903207345956,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:44.075084+00:00"
      }
    },
    {
      "chapter_number": 20,
      "title": "Segment 20 (pages 181-193)",
      "start_page": 181,
      "end_page": 193,
      "summary": "point.\nturns out that you can approximate these objects with point masses so long as their\ndirection connecting two centroids, find the farthest features of the two objects using\nobjects as point masses located at their centroids and you have to perform a more\nof best fitting spheres at farthest features of the two objects.\nFind the farthest features along the line joining these\nAt this point, you\ndepend on point-line and, in case of three-dimensional space, point-plane tests.\noperations on floating-point numbers).\nrepresentation of points using integer Cartesian coordinates isn’t the solution because\nthe intersection of a pair of lines with endpoints with integer coordinates doesn’t\nRP2 projective space can be described as a space of all lines in R3 space passing\nby a point in R3/[0,0,0], which lies on the line, and so you can use an [x,y,z] coordi-\nnate vector to identify each element in this space, where [x,y,z] \u0004 [0,0,0].\nyou have to keep in mind that any pair of vectors P and Q identifies the same line if\nelements of RP2 can be understood as lines crossing the origin of R3, let’s define a \nz = 1 plane in this R3 space.\nEvery line crosses the z = 1 plane exactly once, unless it’s\nThe intersection point can be calculated from the line equation\nand in the case of lines crossing the origin it is located at [x/z,y/z,1] where [x,y,z] is any\npoint on the line other than [0,0,0].\nAny point [s,t] in R2 can be represented by element [s,t,1] in RP2 or\nsenting an element of RP2 space will represent point [x/z,y/z] in R2 space.\nRP2 projective space as a space of lines\nidentified by a point in R3/[0,0,0] and each line crosses\nThis gem focuses on the representation of R2 space by RP2 projective space and\noperations in R2 space using RP2 projective space.\nBecause a point in RP2 space can\nIn two-dimensional space R2, you will focus on two types of objects, points and\nline in R2 space as a line with specified running direction, which allows us to define\nof convex polygons, which can be represented by an ordered list of directed lines\nas segments and rays (half-lines) can be represented using points and directed lines, so\nPoints and Directed Lines in RP2\nAs it was defined at the beginning of this chapter, a point [s,t] in R2 can be represented\nBecause scaling vectors in RP2 space doesn’t affect their meaning, point [s,t] can be rep-\nRecall that vectors with z = 0 don’t represent valid points in R2.\nfor conversion of vectors from RP2 projective space to points in R2 space, you can use\nEvery vector [x,y,z] in RP2 space represents the point [x/z,y/z] in R2\nprojection onto the z = 1 plane, which results in the vector [x/z,y/z,1] representing\npoint [x/z,y/z] in R2 space.\npoints in RP2 using rational coordinates with a common denominator (in this case z),\nbut defining it as a vector in RP2 space will give you efficient tools for performing com-\ntor in R3 referring to one of the elements (lines passing through the origin) of RP2 pro-\nThe other object in R2 space of particular interest is a directed line.\nJust as points\nare perspective projections of vectors onto the z = 1 plane, lines in RP2 are perspective\nof a plane results in a line is when the plane passes through the center of the projec-\ntion, so every plane you use to define a line has to pass through point [0,0,0].\nthat does not pass through the origin, because RP2 space elements are lines passing\nthrough the origin and every plane you define in RP2 must contain entire lines.\ndefinition of a line as projection of a plane in RP2 onto z = 1 plane can be simplified.\nThe defined line is simply the intersection of the given plane and the z = 1 plane.\nvectors for which the dot product with the normal of this plane results in a positive\nnormal vector is pointing at.\nBecause a line represented with a plane is an intersection of this plane with the z = 1\nside the right side of the directed line and the other half-plane the left side.\nrepresentation of a directed line with a plane in RP2 space.\nexample representation of a directed line with a plane in RP3 projective space.\nPoints and lines in RP2 projective space: (a) a line passing through a\npair of points; vectors u and v represent points u’ and v’ and the line is represented\nby a plane with normal N, (b) intersection of a pair of lines; N and M are normals\nof planes representing the lines and their cross product results in a vector represent-\nThere are three basic operations on points and directed lines.\npoints, you can find a directed line passing through them in the given order.\npoint and a directed line, you can determine which side of the line the point lies on or\nGiven a pair of vectors representing two points in RP2 space, you can look for a\ndirected line passing through the points.\nvectors representing the points have to lie on the plane representing the line you are\nAn example of a line led through a pair of points is\nin RP2 space representing the directed line you are looking for.\nline depends on the ordering of points used to compute the line, because swapping\ndirection from first point to the second one, so you have to make sure that computed\npositive side of the plane in RP2 space.\nAnother operation of particular interest is a point-line test, where you can find\nwhere a given point lies with respect to a given directed line.\nwhen a point lies on the line, the vector in RP2 space representing the point will lie on\nthe plane representing this line and therefore it will be perpendicular to the plane’s\nproduct of vector representing the point and the normal of the plane is zero we can be\nsure that the point lies on the line.\nside and the right side of the directed line, if the point doesn’t lie on the line, you can\nuse the sign of the dot product to determine the side of the line the point lies on.\npoint, the result of the dot product will always be positive when the point lies on the\nThe last important basic operation on points and directed lines is finding the\nintersection point of a pair of lines.\nAgain, the vector representing the point you are\ngiven directed lines, as shown on Figure 2.4.2b.\nthese normals, you can find the vector in RP2 space representing the point you are\nIf the given directed lines are parallel, the resulting vector will have\nthe coordinate z = 0, which indicates that intersection point of these lines doesn’t exist.\ndetermined whether or not a point lies on a line.\nBecause consecutive operations on points result in consecutive multiplications\nThe first class is a point being a part of\nSuch a point has its coordinates in R2 space given explicitly (for example,\nrange of coordinates of input points because it allows for larger game levels and/or\nThe second class of objects is directed lines computed as lines passing through a\npair of points from input data.\nInput point coordinates are given explicitly, so the nor-\nmal vectors of planes representing directed lines of this class are obtained using a sin-\nof normal vectors of planes representing such lines.\nThe last class of objects being used is a class of points obtained as a result of inter-\nVectors representing such points in RP2\nspace are the results of cross products on normal vectors of planes representing the\nlines, which make these vectors the results of two consecutive cross products.\nof objects, you should aim to use only these three classes of objects (points from input\ndata, lines led through such points, and intersection points of these lines).\nresulting in objects outside these three classes, like defining a directed line passing\nthrough an intersection point, should be avoided because they can make resulting\nintroduce new classes of objects, such as lines passing through a pair of intersection\npoints.\nTable 2.4.2 shows the maximum ranges of input point coor-\nEven with 64-bit integers, the allowed input point\nNumerical Ranges of Results in Used Projective Space Operations for\nInput point check versus line\nIntersection point check versus line\npoint coordinates and required precision is 0.01, after scaling the point data during\nthe import, the required range of input coordinates of points used in further opera-",
      "keywords": [
        "Space",
        "line",
        "point",
        "directed line",
        "Projective Space",
        "Plane",
        "farthest feature",
        "Vector",
        "Range",
        "objects",
        "farthest",
        "directed",
        "operations",
        "intersection point",
        "point lies"
      ],
      "concepts": [
        "points",
        "vector",
        "line",
        "space",
        "operate",
        "operations",
        "operating",
        "operation",
        "computing",
        "computations"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 21,
          "title": "",
          "score": 0.569,
          "base_score": 0.419,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 22,
          "title": "",
          "score": 0.566,
          "base_score": 0.416,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 23,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 18,
          "title": "",
          "score": 0.355,
          "base_score": 0.205,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "",
          "score": 0.318,
          "base_score": 0.318,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "line",
          "rp2",
          "lines",
          "space",
          "plane"
        ],
        "semantic": [],
        "merged": [
          "line",
          "rp2",
          "lines",
          "space",
          "plane"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1252571459622546,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075129+00:00"
      }
    },
    {
      "chapter_number": 21,
      "title": "Segment 21 (pages 194-209)",
      "start_page": 194,
      "end_page": 209,
      "summary": "To prove the usefulness of geometric operations in RP2 space, a simple algorithm per-\nis defined by its points and a directed line running along the edge in such a direction\nthat the interior of the polygon lies on the right side of this line.\nThe basic operation useful during Boolean operations on convex polygons is\n3. Split each edge for which starting and ending points lie on opposite sides of\n4. Create the first of resulting polygons from edges lying on the right side of\ncutting line between vertices lying on this line (if the initial polygon was\n5. Similarly, create the second resulting polygon from edges lying on the left\nIn step 3, new intersection points are introduced to the poly-\ngon and in steps 3, 4, and 5, existing directed lines are used to define polygon edges.\nThe algorithm doesn’t create new lines using existing points, so it isn’t important whether\nthe vertices in the initial polygon are points from input data or intersection points.\nnote that in step 3, the splitting point of the edge has to be computed as an intersec-\nRP2 space, you don’t have an operation computing point-line distance defined.\nAlthough cutting polygons with lines can be a useful operation by itself, you can\nuse this operation to implement Boolean set operations on polygons.\nalgorithm describes the initial steps required to perform such operations, which is\nvertex lies on (steps 1 and 2), (b) finding intersection vertices and splitting edges (step 3), \n(c) separating edges and closing resulting polygons (steps 4 and 5).\npolygons after each cut done during step 3 of the algorithm.\n3. For each edge of polygon B, cut polygon C using directed line associated\nline to set outA and replace polygon C with the part of this polygon lying\nthe line, stop, as polygons A and B don’t intersect.\nWhen this algorithm finishes, providing that initial polygons A and B intersected\n(indicating that the algorithm didn’t stop early), the polygon C after all operations\ninitial polygon A lying outside polygon B.\nBecause this algorithm is based entirely on integer operations in RP2 space, it can\nbut resulting robustness of the algorithms based on operations in projective space may\nconvex shapes, including boxes, spheres, ellipsoids, capsules, cylinders, cones,\nThe algorithm detects overlap and can also provide contact normals, points of\nThe algorithm reduces to a series of point-plane clipping checks, so the math\nThis gem proceeds by introducing support mappings and Minkowski differences.\nRepresenting Shapes with Support Mappings\nAlgorithms that work on a large number of shapes need a uniform way to represent\nSupport map-\ndirection vector as input and returns the point on a convex shape that lies farthest in\n(Support mappings are frequently defined as returning the point farthest\nVisualization of a support mapping as a moving plane.\nAt the moment they touch, the shape is being supported by the plane and the\npoint on the shape that is touching the plane is the support point for that plane.\nIf an entire edge or face touches the plane, any one of the points on the edge or\nface can be chosen as the support point for that normal, as shown in Figure 2.5.2.\nChoosing a support point\nwhen an entire edge supports the plane.\nMany common shapes have simple support mappings.\nIf you slide a plane from any direction, n, the first point you\nSupport mapping of a sphere.\nTable 2.5.1 lists the support mappings for several other common shapes.\nSupport Mappings for Simple Basic Shapes\nSupport Mapping\nPoint\nThe support mappings in Table 2.5.1 represent shapes that are axis-aligned and cen-\nTo support shapes in world space, you need to rotate and translate\nsupport mappings.\ntransforming n into the object’s local space, and then finding the support point in local\nspace, and finally transforming the resulting support point back into world space:\nSupport mappings provide an efficient and compact way to represent basic shapes.\nYou can “shrink-wrap” a set of shapes by finding the support points for each\nshape and returning the point that is farthest along the direction vector.\na disc centered at the origin can be shrink-wrapped with a translated point to create a\nEvery support mapping requires a normal, so you can assume it’s\nSupport Mappings for Compound Shapes\nSupport Mapping\npoint\npoint\nSupport Mapping\nEvery convex shape can be treated as a convex set of points in world space.\nIf the two shapes overlap, there will be at least one point within\nshape A that shares the same position in world space as a point within shape B.\nSimilarly, if the two shapes do not overlap, no point from\nthe first shape will be equal to any point in the second shape and the new shape will\nTherefore, if you can detect whether the origin is in the new shape, you have\nfrom every point in the other.\nping of the Minkowski difference B–A if you’re given the support mappings of A and\ntwo convex shapes, A and B to that of determining whether the origin lies within a\nif (origin inside portal) return hit;\nfind_support_in_direction_of_portal();\nif (origin outside support plane) return miss;\nif (support plane close to portal) return miss;\nStart by finding a point known to be in the interior of the Minkowski difference B–A.\nThe point that\nresults from the subtraction is the interior point of B–A.\nThe interior point is important because it lies on the inside of B–A.\ndrawn from the interior point through the origin, called the origin ray, passes through\nThis step of the algorithm uses the support mapping of B–A to find three non-collinear\npoints on the surface of B–A that form a triangular portal through which the origin ray\nuses the following support points:\n// Find support in the direction of the origin ray\n// origin, interior point, and first support\n// interior point and first two supports\nThe while ( origin ray does not intersect candidate ) Step\nYou do this by testing whether the origin lies on the inside of each of the three planes\nIf the origin lies within all three planes, you’ve found a valid portal and\nIf the origin lies outside one of the planes, use that plane’s outer-facing normal to find\na new support point, as illustrated in Figure 2.5.6.\nStep 3 involves finding a new candidate portal.\nThis new support point is used to replace the triangle vertex that lies on the inside\nThe resulting support points provide you with a new portal candidate\nThe if (origin inside portal) return hit; Step\nbecause the origin ray starts at V0 and passes through the portal, which forms the\nIf the origin lies within the portal, it lies within the\nThe find_support_in_direction_of_portal(); Step\nIf you make it here, the origin lies on the far side of the portal.\nnew support point that lies outside of the portal’s plane.\nThe if (origin outside support plane) return miss; Step\nIf the origin lies outside of the new support plane formed by the support normal and\nthe new support point, the origin lies outside B–A and the algorithm reports a miss.\nThe origin lies between the portal and the support plane, so you need to refine your\nhedron formed by the support point and the portal.\nport point and the three edges of the portal.\nThe origin will lie on the same side of two of these planes.\nthese two planes becomes the new portal, as illustrated in Figure 2.5.9.\nThe if (support plane close to portal) return miss; Step\nAs the algorithm iterates, the refined portals will rapidly approach the surface of B–A;\ndistance between the portal and its parallel support plane), you terminate the algo-\nStep 5 involves finding a new support point\n• The origin lies on the inside of a portal (hit)\n• The origin lies on the outside of a support plane (miss)\n• The distance between the portal and its parallel support plane drops below a small",
      "keywords": [
        "support mappings",
        "support",
        "point",
        "support point",
        "origin",
        "Portal",
        "origin lies",
        "Collision Made Simple",
        "polygon",
        "shapes",
        "support plane",
        "algorithm",
        "Complex Collision Made",
        "step",
        "lies"
      ],
      "concepts": [
        "point",
        "supported",
        "polygons",
        "algorithms",
        "shapes",
        "collision",
        "step",
        "operations",
        "operation",
        "operating"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 20,
          "title": "",
          "score": 0.569,
          "base_score": 0.419,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 18,
          "title": "",
          "score": 0.541,
          "base_score": 0.391,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 23,
          "title": "",
          "score": 0.496,
          "base_score": 0.346,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 22,
          "title": "",
          "score": 0.442,
          "base_score": 0.292,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 44,
          "title": "",
          "score": 0.415,
          "base_score": 0.415,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "support",
          "origin",
          "portal",
          "lies",
          "plane"
        ],
        "semantic": [],
        "merged": [
          "support",
          "origin",
          "portal",
          "lies",
          "plane"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.17264896135434385,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075174+00:00"
      }
    },
    {
      "chapter_number": 22,
      "title": "Segment 22 (pages 210-218)",
      "start_page": 210,
      "end_page": 218,
      "summary": "Another important optimization is caching the results of each collision test to\nThe support mapping functions are called multiple times during each collision\nto check a segment using dot(n, d) in world space than it is to transform n to local\nspace, test only the x component, and then transform the result back again.\n• MPR can be used both to detect collision and to identify collision details that are\nThis gem introduced a simple algorithm for detecting collision among shapes chosen\nEfficient Collision Detection\nUsing Transformation\nthere are many possible ways for solving these problems, collision detection (CD) is a\nby means of transformation matrices.\ndetection methods must consider not only the shape of objects but also their corre-\nThis gem shows you a method for inverting transformation matrices used for\nplacing models in games and for extracting useful semantic information from them.\nalso explains how this information can be used for implementing efficient collision\nAffine Transforms and Games\nAffine transforms are\nused to map between two vector spaces by means of a linear transformation (that is, a\nmatrix multiplication) followed by an origin shift vector that is added to the result.\naffine transform (also called affine mapping) is defined as follows:\nmatrices, we define the mapping in Equation 2.6.1 using block matrix form:\nObserve that in Equation 2.6.2 the affine mapping, A, is a 3 \u0002 3 matrix and the\nvertices to be transformed have their homogeneous w component set to 1 before the\nFrom the game programming perspective, the problem is to detect collisions\nRecall that each model has a corresponding matrix\nthat places it in world coordinates; hence, this matrix must be considered for collision\ndetection against a given model.\nObserve that typical matrices placing models in world space are affine mappings\nbasic transformations, each in itself an affine mapping—scaling, rotation, and trans-\nThese basic transformations can be used to “explain” matrices and answer some\nand translation are called transformation semantics.\ncollision detection process.\nmethod for both inverting and obtaining semantics from a transformation matrix.\nExtracting Semantics from Matrices\nSome semantics information can be obtained in the general case, as shown briefly\nHowever, in game development, you are not usually interested in a method that\nThe General Affine Mapping Case\nCan you extract some semantics from any affine mapping?\nrepresent the new x, y, and z axes, respectively, after a point gets transformed.\nmeans you can use columns from your affine transform for solving problems consider-\nThe inverse of an affine matrix is well-known, and can be written as:\nReaders interested in inverting a general affine mapping Equation 2.6.2 are\nEfficient Collision Detection Using Transformation Semantics\nOur Specific Case: Model Matrices\nConsider a transformation matrix M that transforms a model from its local space into\nscaling matrix, followed by as many rotations and translations as needed, in this order.\nsimple and efficient method for inverting either matrices that preserve angles between\nOur matrix representation is more general (considers non-uniform\nto compute the first row of the 3 \u0002 3 part of M-1 (Equation 2.6.8) by simple division:\nEquation 2.6.2; and divide its resulting rows by the corresponding squared scale factors.\nThis inversion method offers the flexibility of supporting non-uniform scale, and\naffine mappings [Wu91], and with Wu’s method for angle-preserving matrices\nComparison of Matrix Inversion Methods in Terms of Required Operations\nTransformation semantics extraction requires a slight modification of the method\nSquare root computation over Equations 2.6.9, 2.6.10, and 2.6.11 gives you the scale\nEfficient Collision Detection Using Transformation Semantics\nWhen only uniform scaling is considered, it is evident that the inversion method\nis reduced to Wu’s method for angle-preserving matrices [Wu94].\nNow you can invert and extract semantics efficiently from a typical matrix that\nused when performing collision detection tasks.\nUsing Semantics for Collision Detection Tasks\nCollision detection methods for real-world applications must consider a given set of\nbroad phase or collision culling, is responsible for finding all object pairs that are in prox-\ntask, known as narrow phase or pair processing, consists of effective intersection tests\nTransformation semantics can be\nused in these collision detection tasks.\nGiven N objects, potentially O(N2) pairs have to be checked for collision.\npairs can be discarded quickly—this explains why this phase is also known as collision\nScene representations usually maintain a local AABB per geometric model; for\nexample, an AABB in the model’s own local space.\nthe model’s matrix, so that it becomes an oriented bounding box (OBB) in world\nThe problem at this point is the following: how can you efficiently compute the\nmodel’s global AABB from its local AABB and a transformation matrix M?\nforce approach transforms all eight corner vertices from the AABB first and then com-\nputes the AABB of the transformed vertices—this requires 21 branches.\nAABBs. First, the minimum extreme vertex is transformed using the model’s matrix,\nnew axes in world coordinates after the model gets transformed by M.\nEfficient Collision Detection Using Transformation Semantics\nA local AABB fitting a given model (a) is transformed into world coordinates\nfits the transformed AABB.\nThe final step for collision detection is to process all pairs reported from broad phase.\nintersect after they are transformed?",
      "keywords": [
        "Collision Detection",
        "Efficient Collision Detection",
        "collision",
        "collision detection tasks",
        "collision detection methods",
        "matrix",
        "Semantics",
        "transformation semantics",
        "affine mapping",
        "Equation",
        "Detection",
        "Affine",
        "model",
        "method",
        "Transformation"
      ],
      "concepts": [
        "transform",
        "transformations",
        "collisions",
        "matrix",
        "matrices",
        "efficient",
        "points",
        "game",
        "methods",
        "semantics"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 23,
          "title": "",
          "score": 0.725,
          "base_score": 0.575,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 20,
          "title": "",
          "score": 0.566,
          "base_score": 0.416,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 21,
          "title": "",
          "score": 0.442,
          "base_score": 0.292,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "",
          "score": 0.44,
          "base_score": 0.44,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "",
          "score": 0.409,
          "base_score": 0.409,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "collision",
          "affine",
          "matrix",
          "transformation",
          "detection"
        ],
        "semantic": [],
        "merged": [
          "collision",
          "affine",
          "matrix",
          "transformation",
          "detection"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24607285017360692,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075241+00:00"
      }
    },
    {
      "chapter_number": 23,
      "title": "Segment 23 (pages 219-228)",
      "start_page": 219,
      "end_page": 228,
      "summary": "MAB maps geometry from A’s local space into B’s local space.\nmaps geometry from B’s local space into A’s local space.\ning support for direct intersection tests.\nActually, transformation semantics provides flexibility for processing geometry\ncoming from a given space (A, B, or world spaces) in a common space where compu-\nprocessing geometry coming from different local spaces.\nIn Figure 2.6.2, arrows show how geometry coming from a given space (A, B, or\nworld) is transformed into a common space, which is more adequate for processing.\nFollowing this scheme, it can be seen that a mapping from B to A’ space corresponds\nThe box-box overlap test is also necessary in order to perform collision detection\nintersecting box pair avoids many triangle-triangle tests because entire subtrees cannot\noverlap test also allows for computing collision detection between a model and an ori-\nThe box-box test is usually implemented using the Separating Axis Theorem\nThe given boxes are intersecting only when there is no separation\nmate intersection test between boxes (SAT-lite) that checks only this kind of separating\nAlthough all separation cases cannot be handled, this test provides faster collision\nUsing transformation semantics, the box-box test using SAT can be performed as\nmodel’s transformation matrix; after this, the intersection method can be carried out\nthe test to be performed as boxes are coming from A’ and B’ spaces (see Figure 2.6.2).\nin order to provide support for scaling models.\nIn this example, only AABB-trees are considered in collision tests.\nuseful intersection tests can be performed against a model using volumes, rays, or\nBasically, support for testing a given primitive against an AABB-tree requires two\nThe first method checks whether the primitive intersects a box\ncoming from the transformed AABB-tree, providing means for fast collision culling of\ngles using the model’s matrix before carrying out the intersection test.\nAs shown in Figure 2.6.2, transformation semantics extraction allows for choosing\ncomplexity and efficiency of intersection tests.\nsphere from world coordinates into the local space of a model (A, for example) may\nrise to a more complicated intersection tests.\ntransformed into the A’ space, allowing for simpler intersection tests: just scale triangles\nEfficient Collision Detection Using Transformation Semantics\nYou might deduce from this that avoiding the local model space during intersection\ntests provides simpler and faster intersection tests.\nTransforming a ray into the model’s local space can\nworld space may not be unit after they are transformed into the model’s local space.\nthis, any parametric point reported in this local space is still mapped at the same posi-\nobtained by using an intersection test that does not rely on unit direction vectors and\npre-computing the ray in A space.\nOur tests on a Pentium D processor using different\nmodels in a ray-casting algorithm pointed out that performing intersection computa-\ntions in the model’s local space (A) is about 57% faster when compared to an imple-\nThis gem covered how to use semantics information in order to speed up and simplify\nDeformable Models Using AABB Trees,” Journal of Graphics Tools, Vol. 2, No. 4,\nEnvironments,” Symposium on Interactive 3D Graphics, pp.\nCharles River Media, 2007.\nEfficient Collision Detection Using Transformation Semantics\nTrigonometric Splines\nthe trigonometric spline will make it possible to create new forms for 3D models.\nFurthermore, this gem will show you that the trigonometric functions involved can\nbe computed without the use of the sine and cosine functions in the inner loop,\nCubic splines cannot be used to create perfect circle arcs but trigonometric splines can\nTrigonometric splines were introduced by Schoenberg\ngraphics as a modelling tool, because it is possible to construct everything from straight\nTrigonometric Splines\nA trigonometric spline [Alba04] can be constructed from a truncated Fourier series\nIt should also be noted that the trigonometric Hermite spline can also be written\nTrigonometric Splines\nBut you can also use Equation 2.7.8.\nwill be useful when you evaluate the function, as shown in the next section.\n[Barrera04] illustrated a technique for efficiently interpolating between vectors or\ndouble tp1[2];\nconstruct a perfect circle/elliptical arc with the trigonometric splines.\nthe curve is parametric, it is possible to construct straight lines using the trigonometric\nThe coefficients are vectors and the function produces a point in space.\nTherefore, it is no problem to construct a straight line even though trigonometric func-\nshows a perfect arc drawn using the trigonometric spline.\nTrigonometric Splines",
      "keywords": [
        "local space",
        "space",
        "collision detection",
        "Trigonometric Splines",
        "Trigonometric",
        "intersection tests",
        "cos",
        "cos sin",
        "collision",
        "transformation semantics",
        "intersection",
        "Splines",
        "model",
        "Efficient Collision Detection",
        "sin"
      ],
      "concepts": [
        "intersection",
        "intersecting",
        "space",
        "trigonometric",
        "box",
        "boxes",
        "computations",
        "computing",
        "compute",
        "model"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 22,
          "title": "",
          "score": 0.725,
          "base_score": 0.575,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 20,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 21,
          "title": "",
          "score": 0.496,
          "base_score": 0.346,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 18,
          "title": "",
          "score": 0.428,
          "base_score": 0.278,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 9,
          "title": "",
          "score": 0.358,
          "base_score": 0.358,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "trigonometric",
          "space",
          "intersection",
          "local space",
          "local"
        ],
        "semantic": [],
        "merged": [
          "trigonometric",
          "space",
          "intersection",
          "local space",
          "local"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19411992708263712,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075287+00:00"
      }
    },
    {
      "chapter_number": 24,
      "title": "Segment 24 (pages 229-237)",
      "start_page": 229,
      "end_page": 237,
      "summary": "We envision a technique, for example, using trigonometric splines to\nUsing Gaussian Randomness\ndistribution generated from rand(), but rather a special kind of randomness com-\nFortunately, there are random number generators\nthat are capable of generating this type of Gaussian randomness.\nvery efficient Gaussian random number generator, detailing how it should be applied\nGaussian Distribution\nPseudo-random number generators (PRNGs) like rand() produce uniform distribu-\nA Gaussian distribution, which is sometimes known as a normal\ndistribution, favors positive and negative numbers centered near zero.\ndard deviation of this distribution is 1.0, it is called a standard normal distribution, as\nNow that you have a better feel for what a Gaussian distribution looks like, let’s\nlook at a few random number generators that can create such distributions.\nGenerating Gaussian Randomness\nGaussian random number generators (GRNGs) are useful for statistical analysis and\nbecause large simulations require billions of normally distributed random numbers.\nGaussian Random Number Generators\nGaussian distribution (normal distribution) with a mean of zero and a \nThe horizontal axis represents the value of the random numbers\nthis distribution are the seldom-seen values beyond three standard deviations (less than –3.0\nrandom numbers, such as those generated by a PRNG like rand(), and adds them.\nAccording to the central limit theorem, the sum of these uniform random numbers will\nresult in a single Gaussian distributed random number.\ndom numbers in the range [–1, 1] will approach a Gaussian distribution with mean\n. For example, if you add three uniform random\nstandard normal distribution).\nThe following code generates a Gaussian distribution\nby adding three 32-bit signed uniform random numbers (generated by a very fast xor-\nUsing Gaussian Randomness to Realistically Vary Projectile Paths\ntails beyond three standard deviations, by summing more numbers (increased K ).\nAn ideal application for a GRNG in games is adding random variation to projectile\nsome variation that follows a Gaussian distribution (probably due to many random\nHowever, this Gaussian distribution needs to be expanded\nThe left target shows a Gaussian probability distribution in 2D.\nbe visualized as the middle figure, which is a Gaussian distribution revolved around the center.\nThe right target is an example of 30 bullets perturbed by the revolved Gaussian distribution.\nThe distribution in Figure 2.8.2 was created with the help of polar coordinates.\nThis requires two random numbers for each 2D point: an angle and a distance.\nbullets in Figure 2.8.2 were computed by generating a uniform random angle in the\nrange [0, 2\b], along with the absolute value of a Gaussian random distance in the range\nBy using a uniform random number for the angle, you guarantee that the bul-\nBy using a Gaussian random\nThe 2D distribution in Figure 2.8.2 is not technically a 2D Gaussian distribution\nA true 2D Gaussian distribution\nis constructed with two Gaussian random numbers plotted against each other in\nIf x is a Gaussian random number and y is a Gaussian random num-\n2D Gaussian distribution will favor the coordinate axes over the diagonals, which is\nundesirable for a 2D projectile distribution.\nGaussian randomness is useful for many game applications other than projectiles.\nage will likely benefit from a Gaussian distribution.\nGaussian Distributions in Nature\nWhy do many distributions in nature follow a Gaussian distribution (or bell curve),\nroughly display a Gaussian distribution.\nvariables is not likely to be uniform, but rather the sum of other random variables,\nnormal distribution.\nUsing Gaussian Randomness to Realistically Vary Projectile Paths\nGenerating Gaussian randomness for games is embarrassingly simple and efficient\nof this type of random number generator.\ncan be modeled using Gaussian randomness.\nwith Gaussian randomness in polar coordinates, applications like adding realistic vari-\n“Remark on Algorithm 334 [g5]: Normal Random Deviates,”\nGenerating Random Variables,” Journal of Statistical Software, Vol. 5, 2000, paper\n“Gaussian Random Number Generators,” ACM Computing Surveys 39,",
      "keywords": [
        "Gaussian random number",
        "Gaussian Distribution",
        "Gaussian random",
        "Gaussian",
        "random number",
        "distribution",
        "random number generators",
        "random",
        "uniform random numbers",
        "normal distribution",
        "trigonometric splines",
        "number",
        "uniform random",
        "standard deviations",
        "Generating Gaussian Randomness"
      ],
      "concepts": [
        "game",
        "distribution",
        "distributions",
        "likely",
        "algorithm",
        "algorithmic",
        "randomness",
        "randomized",
        "generation",
        "generated"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 16,
          "title": "",
          "score": 0.65,
          "base_score": 0.5,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 17,
          "title": "",
          "score": 0.586,
          "base_score": 0.436,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "gaussian",
          "distribution",
          "random",
          "gaussian distribution",
          "gaussian random"
        ],
        "semantic": [],
        "merged": [
          "gaussian",
          "distribution",
          "random",
          "gaussian distribution",
          "gaussian random"
        ]
      },
      "topic_id": 8,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.11598756322255464,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075332+00:00"
      }
    },
    {
      "chapter_number": 25,
      "title": "Segment 25 (pages 238-245)",
      "start_page": 238,
      "end_page": 245,
      "summary": "very year, new games come out.\nfurther our ideas of what a game can accomplish.\nFinally, and most importantly to this section of Game Programming Gems\nObviously, we can’t model that kind of standstill in games.\nthe corner in a shooter and pretty much everybody froze, players would likely think\nthe game was broken.\nHowever, if everybody ran, the game would get monotonous\nquick (although this still might work for some games).\nThe point is, you can’t always base your game’s AI behaviors on realism.\ncan’t base your AI on what any one of us might think is the correct behavior, because\nJohn Harger and Nathan Fabian have written a gem in which you’ll learn how to\nuse a supervised learning technique called behavior cloning, which can be used to\nconcerning modeling attitudes within your AI agents.\nThe popularity of gaming online may have\ngem explains how to use a machine-learning technique called behavior cloning \n[Sammut92] to borrow from styles and strategies of humans playing the game and\nplace them into game agents.\nBehavior cloning is essentially a version of supervised learning.\nIn supervised learn-\ning, the idea is that the human trainer provides a set of labels for particular objects and\nthe algorithm learns to recognize, or predict, labels based on the attributes of those\nIn behavior cloning, the trainer acts in response to a stimulus.\nThe algorithm then learns to\nThis extends very nicely into games where it’s easy to find the response a person\nwill make to a stimulus, that is, the game state.\n(In the game nearly all interaction takes\nBecause there is so much similarity between supervised learning and behavior\ncloning, this technique can be done with any off-the-shelf supervised learning algo-\nThis gem uses a decision tree because the output is easier to edit than, say, the\nEven better, the game playing trainers don’t even need\nyou how well the tried-and-true decision tree learning algorithm works when borrow-\ning human characteristics to create interesting, playable game agents.\nExample: The Demo Game\nThroughout this gem, the examples refer to a game design that resembles the classic\ncomputer game Space War. That is, two ships face off on an infinite 2D playing field;\nthe goal of the game is to destroy the other ship.\nto-understand game environment in which you can train an agent.\nThe feature space is the most important thing in instance-based machine learning,\nto record instances of the game state for learning (see Figure 3.1.1).\nconsider the design of the features to be able to train interesting agents, and perhaps to\nThe features must provide enough information to make decisions.\ngoal is to train an agent to behave like a particular human.\nIt might take the learning algorithm 30\nminutes to train an agent with detailed features, but it will likely produce a richer one.\nIf the agent is trained to accelerate based on an absolute\nIf this is what the agent learns, it will always turn right when its opponent is located\n15° to the left (\t2.5°), the agent will turn right when the opponent is just to the left,\nChange in distance between ships\nlearning technique available.\nIf you are interested in machine learn-\nCreating Interesting Agents with Behavior Cloning\naddition, the states of the player’s controls are also recorded, such as turning left or\nOnce you have a game session recorded, shown in Table 3.1.2, you can use that infor-\neach value the feature can take on.\nSample Recorded Game State Data\nfeature, if so.",
      "keywords": [
        "Game",
        "behavior cloning",
        "agent",
        "learning",
        "behavior",
        "left",
        "game agents",
        "Feature",
        "tree",
        "Feature Space",
        "game state",
        "distance",
        "Interesting Agents",
        "cloning",
        "decision tree"
      ],
      "concepts": [
        "game",
        "gaming",
        "learned",
        "likely",
        "tree",
        "humans",
        "michael",
        "behaviors",
        "players",
        "agents"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 31,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 33,
          "title": "",
          "score": 0.643,
          "base_score": 0.493,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 30,
          "title": "",
          "score": 0.558,
          "base_score": 0.408,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.533,
          "base_score": 0.383,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "",
          "score": 0.531,
          "base_score": 0.381,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "learning",
          "cloning",
          "behavior cloning",
          "game",
          "behavior"
        ],
        "semantic": [],
        "merged": [
          "learning",
          "cloning",
          "behavior cloning",
          "game",
          "behavior"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15114350147800562,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075383+00:00"
      }
    },
    {
      "chapter_number": 26,
      "title": "Segment 26 (pages 246-254)",
      "start_page": 246,
      "end_page": 254,
      "summary": "deciding whether to turn, and your feature space defines distance on three intervals: 0\nFirst, look at Equation 3.1.1 for computing the information in a set of\nfour Right labels, giving an information of Info([3,4,4]) = (–3 log2 3 – 4 log2 4 – 4 log2\nIf you look at only those labels where Distance is “1 to 2,” you have only two\nreally helps the gain when you use distance.\nthat value of distance and recurse using only that.\nThere is no reason to use distance\nNotice again for distance “1 to 2” that since the set\nFor example, the turning tree in\nif GameState.Distance == \"0 to 1\" then --Left branch\nelseif GameState.Distance == \"1 to 2\" then --Center branch\nelseif GameState.Distance == \"2 to inf\" then --Right branch\ntion after setting the current game state, and the decision tree does its work.\nThe agent\nThis gem illustrates a very concise and convenient way to make agents that learn\nconsider needing to add the distance and direction from an ally to an opponent.\na large mass with a single distance and direction.\nUnified Agent-Sensing Model\nith increased visual realism, players expect agents to sense the game world with\nHowever, agent vision models in games have tradi-\ntionally been very simplistic, using a combination of view distance, view cone, and\nfairly simple, usually testing against some cutoff distance to verify whether a sound is\nAlthough these basic agent-sensing models are efficient and simple\nwhen agents use a discrete distance check for vision, it results in an absolute blind\nOnce the developer realizes that current agent-sensing models are rather primi-\nbecause all senses should collaboratively inform an agent’s awareness of the world.\nThe final model may then be used in any game genre as a core part of the AI.\nThe Basic Vision Model\nthe core vision model used in the majority of games today.\nculations are view distance, view cone, and line-of-sight.\nThe computation for the view distance check is a simple distance test.\nit is more efficient to test against the distance squared instead of the actual distance,\nFor example, if the agent can see up to 10\nthe view distance.\nCompare this against the view distance squared (102 = 100) and you find that the\nagent can see the player, because 89 is less than 100.\nThe distance squared optimiza-\ndistance.\npoints from the agent to the player (refer to the two vectors in Figure 3.2.1).\nresult is greater than zero, the player is within the agent’s 180° view cone.\nis greater than 0.5, the player is within the agent’s 120° view cone (cos 60° = 0.5).\nan optimization, if only the 180° view cone test is required, there is no need to nor-\nExample of view distance check, view cone check, and line-of-sight\nThese three tests lay the groundwork for a vision model, but as you’ll see later,\nparticular distance.\nevent that gets delivered only to agents within a particular distance from the player.\nproblem as the vision model, namely that there is an absolute and arbitrary distance\nsensing model.\nAugmenting the Vision Model Toolbox with Ellipses\nThe simple vision tests discussed previously don’t model human vision well.\n• Visual acuity is highest in the center of vision and degrades with distance.\n• To avoid overly large fields of vision far away, designers tend to make view dis-\ncones to model human vision [Leonard03].\nin the agent’s vision.\nThe left portion of Figure 3.2.2 shows a vision model that uses\ntwo cones and a circle to model vision.\nshort distances.\nlarge gaps in the vision model outside the intersection of the two cones.\nDesigning a Realistic and Unified Agent-Sensing Model\nAs you see in the right side of Figure 3.2.3, an ellipse gracefully deals with the\ndegradation of visual acuity with distance without leaving holes in the vision.\nellipse “starts” a few feet behind the agent to model the sixth sense humans have about\nThe left figure illustrates a vision model using two view angles\nvarious view angles to give a more accurate model of vision.\nmiddle figure shows how an example point on the ellipse is calculated.\nfigure shows an example view from an agent where [\nhalf the maximum view distance.\nIn order to model vision with an ellipse, it is important to understand its components.\nabout ellipses: the distance from the two foci to any point on the outside of the ellipse\nTo model human vision, you place one end of the ellipse at the agent’s eyes.\nview angle will make a triangle with the agent’s eyes and the endpoints of the center\naxis of the ellipse as in the right side of Figure 3.2.3.\nmaximum viewing distance; half of which will be the distance from the agent to the\nfor the focal points, you can use the following equations given the agents’ eyes are sit-\nDesigning a Realistic and Unified Agent-Sensing Model",
      "keywords": [
        "distance",
        "Vision Model",
        "Model",
        "view",
        "view distance",
        "vision",
        "agent",
        "model human vision",
        "view cone",
        "agent vision models",
        "view distance check",
        "ellipse",
        "player",
        "tree",
        "view cone check"
      ],
      "concepts": [
        "distance",
        "model",
        "agents",
        "players",
        "cone",
        "game",
        "time",
        "view",
        "node",
        "script"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "",
          "score": 0.616,
          "base_score": 0.466,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.556,
          "base_score": 0.406,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 1,
          "title": "",
          "score": 0.539,
          "base_score": 0.389,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 33,
          "title": "",
          "score": 0.51,
          "base_score": 0.36,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 25,
          "title": "",
          "score": 0.5,
          "base_score": 0.35,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "distance",
          "view",
          "vision",
          "agent",
          "model"
        ],
        "semantic": [],
        "merged": [
          "distance",
          "view",
          "vision",
          "agent",
          "model"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2014698314019279,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075431+00:00"
      }
    },
    {
      "chapter_number": 27,
      "title": "Segment 27 (pages 255-262)",
      "start_page": 255,
      "end_page": 262,
      "summary": "Using an ellipse to model vision is easy to calculate and is not much more expen-\nhuman-sensing model.\nModeling Human Vision with Certainty\nvision in which objects are sometimes only partially recognized.\ncan be modeled in this artificial vision system.\nUsing the discrete tests in the toolbox, a vision model can be created that scores\nages represent the certainty that a particular object is identified.\nof vision are fully identified, whereas objects in the near-peripheral, mid-peripheral,\nAn important feature of this model is that moving objects get a score increase of\nDesigning a Realistic and Unified Agent-Sensing Model\nCertainty in vision as a collection of dis-\nIn this model, objects are fully identified at\nThe percentages of certainty can be interpreted in whatever way makes sense within\nFor example, at 100% certainty the object in question is\nfully identified and the agent might shoot at the object.\nFigure 3.2.5 shows a vision model in which the inner circle falls off with\nThe arbitrary models depicted in Figures 3.2.4 and 3.2.5 are only examples and\nof real human vision based on the particular features identified here.\nment in terms of subtlety and sensitivity compared with typical game vision models.\nAnother important feature of this vision model is to take into account the mental\nModeling Human Hearing with Certainty\nAs demonstrated with the vision model, calculating sensory identification as a per-\ncentage can be an effective way to introduce subtlety into a sensing model.\nit’s worth constructing a hearing model that produces percentages of certainty.\nsound and hearing.\nVision model with gradient zones of certainty.\nWhen constructing a hearing model, a simple radius check for whether an agent\nhears a particular sound could be augmented in several ways.\nFigure 3.2.6 demonstrates sound falloff coupled with the zone approach.\nDesigning a Realistic and Unified Agent-Sensing Model\nHearing model demonstrating sound inten-\nAn agent can hear a sound\nonly if the sound was made in the same or an adjacent zone.\nIn this example, the sound does not propagate to Zone C\nIn the way that walls can block vision, other sounds can drown out a particular\nsound and make it hard to hear.\nSimilar to how a sixth sense was added to the vision model, the hearing model\nthat can add to the identification of an object when vision isn’t sufficient, thus open-\nUnified Sensing Model\nHaving created sensing models for vision, hearing, smell, and a sixth sense, the final\ntask is to combine them into a single unified sensing model.\nsenses should together inform the agents of their surroundings, combining their clues\nfirst is to take the maximum certainty between the vision, hearing, and smell senses,\nFor example, if a vision zone has 30%\ncertainty and hearing is 50% certainty, that zone would have max(30%, 50%) = 50%\nThe second option is to add the certainty of all senses, as shown in the mid-\nFor example, if a vision zone has 30% certainty and hear-\ning is 50%, that zone would have 30% + 50% = 80% certainty.\ntake the vision model certainties and add half of the remaining headroom for hear-\nvision zone had 30% certainty, hearing a sound in that zone would add (100 – 30) /\nTo understand the repercussions of this unified sensing model, consider the white\nwould go completely undetected by the agent with a certainty of only 30%.\nAdding Memory to the Unified Sensing Model\ntheir sensing model.\nperipheral vision of the agent, the player will be identified at 100%.\nruns the agent, moving into the far-peripheral vision area and stops, the memory of the\nthe agent identified the player and still has visual contact, making it reasonable to\nDesigning a Realistic and Unified Agent-Sensing Model\nThree examples of the unified sensing model combining vision with\ntakes the max sense (vision, hearing) from each zone.\nmaking a loud sound, which results in 50%, 80%, and 75% certainty respectively in each\nThe unified sensing model brings together vision, hearing, smell, and even a sixth\nsense to give game agents a coherent and detailed view of the game world.\nAs players better understand the underlying sensing model, they can devise innovative\nAs presented, the unified sensing model is intended to bring subtlety and added\nrealism to game agents.\ning model that matches and enhances your particular game design.\ngies allow a new type of AI game agent to be created that can learn and adapt in the\nThe system allows game designers to train behavior-capture AI agents directly, by",
      "keywords": [
        "vision",
        "Unified Sensing Model",
        "model",
        "vision model",
        "sensing model",
        "Certainty",
        "sound",
        "agent",
        "hearing model",
        "Human Vision",
        "game vision models",
        "zone",
        "game",
        "Hearing",
        "object"
      ],
      "concepts": [
        "sound",
        "modeling",
        "game",
        "certainty",
        "certainties",
        "agent",
        "zones",
        "make",
        "sense",
        "sensing"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 7,
          "title": "",
          "score": 0.401,
          "base_score": 0.401,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.394,
          "base_score": 0.394,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 1,
          "title": "",
          "score": 0.362,
          "base_score": 0.362,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 61,
          "title": "",
          "score": 0.355,
          "base_score": 0.355,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 22,
          "title": "",
          "score": 0.335,
          "base_score": 0.335,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "vision",
          "model",
          "certainty",
          "sensing",
          "sensing model"
        ],
        "semantic": [],
        "merged": [
          "vision",
          "model",
          "certainty",
          "sensing",
          "sensing model"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1704327633710629,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:44.075480+00:00"
      }
    },
    {
      "chapter_number": 28,
      "title": "Segment 28 (pages 263-270)",
      "start_page": 263,
      "end_page": 270,
      "summary": "• Each part of the algorithm increases the complexity of the implementation.\n• It also becomes increasingly difficult to optimize the performance of this algo-\n• The pieces of code are tightly coupled, which makes it impossible to reuse them.\n• The risk of introducing bugs while making changes is high and unit testing does\n• We want to construct workflows out of separate blocks.\n• Each block should be responsible for exactly one aspect of the algorithm.\n• Each block should have well-defined inputs and outputs.\n• The structure of the workflow should be homogeneous, so that we can connect\nblocks in different ways, unless the nature of the implemented aspects does not\n• We want to be able to create non-linear workflow configurations, containing\n• We want to be able to change workflow configurations with minimum effort.\nEvery processing task is encapsulated by a separate block, which can\nto change inputs and check outputs, each block can be treated as a black box.\nsame set of blocks.\nthat can be, in turn, treated as more complex blocks.\nBlocks can have alternative replaceable implementations,\nAvoiding extra dependencies makes blocks more adaptable.\nBlocks performing incremental processing do not have to wait until\nthe surrounding blocks complete their calculations; they can continue working\nYou can create alternative implementations of blocks\n• Performance profiling.\n• Partial results.\nArtificial Contender decision-making algorithms operate on sequences of data describing\nThe lowest blocks (sources) generate action data sequences, usually\nIn most cases the complete action data sequences are not really needed.\nIt is possible to implement the workflow in a way that the higher blocks control the\npossible, the lower blocks should not pre-calculate the results until they are asked.\nIt is possible to arrange the blocks of the workflow in such a way that\n• Communication and data transformation overhead.\nBlocks have to exchange data,\n• Parallel processing disappointments.\ning, like when a block consumes all input data before emitting any output data.\nThis block can become a performance bottleneck of the entire workflow.\norder to avoid this problem, you should make processing incremental when-\n• Complex flow control logic.\n• Complexity, increased maintainability efforts.\nLet’s take a closer look at the Artificial Contender decision-making workflows\nAny workflow can have a visual representation, for instance a block diagram.\nArtificial Contender decision-making workflow example.\nworkflow diagrams make the answers obvious.\nthe details of data and execution flows is what makes the diagrams compact and expres-\nBlocks work with sequences of separate objects representing some knowledge\nBlocks\nconsume, process, and emit sequences of ActionInfo objects.\nActionInfo objects, they can be filtered out, they can be split into sets of separate\nHow and in what order do blocks process ActionInfo objects?\n• Source generates ActionInfo objects (based on, for example, the Artificial Con-\n• Modifier changes ActionInfo objects, adjusting them to the current game situation.\n• Filter checks whether ActionInfo objects are good enough and lets them through\n• Acceptor accepts the first ActionInfo that is emitted by Filter.\nYou could make it work in exactly that sequence, implementing the “push”\nThis is how many implementations of the “Pipes and Filters” pattern work.\nexample may accept the first ActionInfo generated by Source if it makes it through\nlower blocks to query and when to stop.\n• Acceptor asks for one ActionInfo from Filter.\n• Filter asks for ActionInfo from Modifier and checks them one by one, looking for\n• Modifier queries Source retrieving ActionInfo one by one, modifies them, and\n• Source answers Modifier’s requests, emitting ActionInfo objects one by one.\n• As soon as the top block (Acceptor) stops asking for more ActionInfo, the work-\nThere are a few categories of blocks that you usually need for AC decision-making\n• Sources generate ActionInfo objects based on data external relative to the decision-\nmaking workflow: from AC knowledge database, from heuristic algorithms, from\n• Filters determine whether consumed ActionInfo satisfy specific conditions, and\n• Modifiers change consumed ActionInfo objects and output the changed objects.\n• Sorters consume sequences of ActionInfo objects and output the same objects in a\n• Splitters divide the incoming flow of ActionInfo objects into multiple flows and\nActionInfo objects for special processing.\n• Mergers have multiple inputs and redirect the flows of ActionInfo objects from all\nThey are often used to query a set of ActionInfo sources\n• Selectors have multiple inputs and redirect the flow of ActionInfo objects from\nallow treating the ActionInfo objects from each source as a separate group.\n• Repeaters consume and output all available ActionInfo objects, and then perform\na specified action, and then consume and output all available ActionInfo objects\nment loops that are querying and processing actions from different sources.",
      "keywords": [
        "blocks",
        "ActionInfo objects",
        "ActionInfo",
        "Workflow",
        "objects",
        "Pipes and Filters",
        "Filters",
        "Artificial Contender",
        "actions",
        "data",
        "processing",
        "Pipes",
        "make",
        "Generic Programming Approach",
        "lower blocks"
      ],
      "concepts": [
        "block",
        "processes",
        "processing",
        "process",
        "workflow",
        "actions",
        "data",
        "sources",
        "complexity",
        "filters"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 29,
          "title": "",
          "score": 0.847,
          "base_score": 0.697,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 6,
          "title": "",
          "score": 0.589,
          "base_score": 0.439,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 9,
          "title": "",
          "score": 0.538,
          "base_score": 0.388,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 14,
          "title": "",
          "score": 0.528,
          "base_score": 0.378,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 13,
          "title": "",
          "score": 0.491,
          "base_score": 0.341,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "actioninfo",
          "actioninfo objects",
          "blocks",
          "objects",
          "workflow"
        ],
        "semantic": [],
        "merged": [
          "actioninfo",
          "actioninfo objects",
          "blocks",
          "objects",
          "workflow"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24726910781039388,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075532+00:00"
      }
    },
    {
      "chapter_number": 29,
      "title": "Segment 29 (pages 271-279)",
      "start_page": 271,
      "end_page": 279,
      "summary": "Generic implementations of the frequently used blocks are included in the Artifi-\nHowever, this is not an exhaustive list of block types.\nCombining these blocks into\nBlocks can be connected in many different ways.\nSome combinations do not make sense, because the nature of the blocks\nFor example, if you want a block to perform a weighted random\nchoice of an action, you have to make sure that the inputted ActionInfo objects have\nassociate them with blocks.\nIn order to make the workflow flexible enough, we apply generic programming\nprinciples while designing workflow blocks.\nBlock implementation should make min-\ntation details, such as concrete data types, the more adaptable the implementation is.\nblock does not depend on a particular data type, do not even mention this data type\nPolymorphic Workflow Blocks\nThe most common requirements to workflow blocks is that they should process and\nIf necessary, blocks can also consume data generated by other blocks.\nthe same time, it must be possible to connect blocks in different ways.\nIn this case, changing one block does not require changing other\nblocks, as long as all the blocks satisfy the requirements.\nthat the developers of the blocks have enough information to really satisfy the require-\nAlthough the nature of blocks can be absolutely different, they still have a common\nsimilarly in all blocks, it will give you an opportunity to build different configurations\nfrom the same blocks.\nBecause we’re implementing the “pull” model, blocks should only provide a com-\nIf the blocks know how other blocks output data, they auto-\nHow do you make the blocks polymorphic?\nA block that requires input can hold a reference to an object implementing the\nThe block does not need to know the concrete type of other blocks; it\nIf you follow the Single Responsibility Principle [Martin02] and make the blocks\nmorphic, because the blocks should process data objects that are acquired from other\nblocks.\nEvery block can\nexpect different properties from input data objects.\nMost of the requirements are block specific, and do not make any sense\nin the context of other blocks.\nmeta-programming capabilities, analyze block requirements dynamically, and build\nThe more fine-grained the blocks are, the more visible the performance hit becomes.\nobjects of different types at runtime, but they make you pay for this ability with per-\nblocks, but you do not have to pay for that with processing time or memory.\nLet’s use this idea to implement the Modifier block\nblock implementation, you just need a simple adapter that converts the statically\nthat is generic enough to satisfy the requirements of every block in the workflow.\nHow do you pass them between blocks?\nShould the called block allocate memory\nfor all data, you tell the block what to do with the data and when to stop.\nReplace the block-interface requirements with the following:\n• The block should implement a function with a fixed name (called forEach).\n• The forEach function should apply the received function to every ActionInfo\nso the blocks are free to implement the forEach function and the callback function in\nBlock Implementation Examples\nThis next listing shows what source blocks (blocks that do not require input) look like:\nActionInfo objects, unless it is required by the nature of the block (for example, sort-\ning blocks usually must collect all input ActionInfo before emitting the first output\nIf all the blocks satisfy these requirements, the blocks that require input can\nexpect that the other blocks implement a similar forEach function.\ncode listing shows a typical modifier’s forEach function implementation:\nThe input_.forEach call ensures that ActionInfo objects are retrieved from the\ninput block.\nobject received from input_ and apply the original F function to the modified Action-\nby the input block are checked in place, and the original function may be applied.\nblock purposes, which means that the performance overhead is completely eliminated.\ntion passed to forEach return a Boolean value, indicating whether the block is allowed\nplace,” even for blocks that are located very far from each other in the workflow, so\nActionInfo Type\nEach block has its\nown requirements to the incoming ActionInfo flow, and each block can emit ActionInfo\nthe lowest blocks (sources), and add or remove properties moving up the workflow, in\n• All other blocks make ActionInfo a template parameter.\noutput ActionInfo type from input ActionInfo types, using inheritance or aggre-\nAs a result, each block’s output Action-\n• All blocks use ActionInfo properties that are directly related to a block’s responsi-\nThis makes the blocks very adaptable:\nthey accept different input ActionInfo types, but any unknown properties are just\npropagated to the output and can be used by higher blocks.\nAlternative Block Implementations\nblock, optimized for different platforms.\ncustomize generic block implementations partially, without re-implementing entire\nblocks and duplicating code.\nHow do you connect the developed blocks to each other and make the workflow run?\nIn C++, creating and connecting blocks looks as simple as the following listing:\nBecause all blocks follow the\nThanks to static polymorphism, you still can take advantage of C++ compile-time type\n• A set of labels is attached to block inputs.\n• Another set of labels is attached to block outputs.\n• When blocks are about to be connected, first of all the label should be analyzed.\nThe requirements of the higher block should be satisfied by the output of the\nlower block.",
      "keywords": [
        "blocks",
        "input",
        "ActionInfo",
        "function",
        "data",
        "ActionInfo objects",
        "Generic Programming",
        "cial Contender SDK",
        "Generic Programming Approach",
        "workflow",
        "make",
        "type",
        "input ActionInfo types",
        "objects",
        "Implementation"
      ],
      "concepts": [
        "blocks",
        "functionality",
        "functions",
        "function",
        "implementation",
        "implement",
        "data",
        "types",
        "typed",
        "input"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 28,
          "title": "",
          "score": 0.847,
          "base_score": 0.697,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 6,
          "title": "",
          "score": 0.538,
          "base_score": 0.388,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 9,
          "title": "",
          "score": 0.476,
          "base_score": 0.326,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 14,
          "title": "",
          "score": 0.419,
          "base_score": 0.269,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 61,
          "title": "",
          "score": 0.392,
          "base_score": 0.392,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "blocks",
          "block",
          "actioninfo",
          "input",
          "workflow"
        ],
        "semantic": [],
        "merged": [
          "blocks",
          "block",
          "actioninfo",
          "input",
          "workflow"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19267979143549577,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075588+00:00"
      }
    },
    {
      "chapter_number": 30,
      "title": "Segment 30 (pages 280-291)",
      "start_page": 280,
      "end_page": 291,
      "summary": "All About Attitude: \nhe concept of attitude, a positive or negative evaluation about some attitude\nopinion and reputation systems, but the concept of attitude is more general than that.\nAttitude systems can be used to enrich NPC behavior in other ways besides opinion\nAttitude systems are more appropriate for games where NPCs need to exhibit\ndeveloping games with NPCs that behave something like real human (or maybe alien)\nEmotions and attitudes are a large part of what makes us human, and if we are to\ndevelop human-like behaviors in our game characters, developers need to tackle these\nThis gem presents the psychological construct called attitude that can become\nAttitude\nWhat is this thing called attitude?\nAttitude, as defined by social psychologists, has a\nmeaning much like popular usage, as in “having a positive attitude about something,”\nent for attitude.\nCentral to the attitude construct is the evaluative dimension.\nbarest essentials, it simply means that the person holding the attitude has made a judg-\nment about the degree to which the holder likes or dislikes the attitude object; that is,\nthe person has judged how appealing or unappealing the target of the attitude is.\nAttitudes can be held for just about anything that can be evaluated; the “target” of\nan attitude is usually termed the attitude object.\nAttitude objects can be concrete, like\nAttitudes about abstract entities that imply a moral dimension\nThe attitude object can be a singular item or an entire category or class of related\nHumans use the tendency to have attitudes about classes of objects, rightly or\neven attitudes about one’s reactions to having an attitude, and so on.\nwith human attitudes, it can get complicated very quickly.\nAttitudes are also the basis for other forms of human cognitions.\na belief, for example, is that it is an attitude about a proposition, that is, a logical state-\nAttitudes demonstrate what is sometimes called dispositional liking.\nliking (the basis of attitude) is not the same thing as momentary liking, which is an\nAttitudes are evaluative beliefs about\nattitude objects; they are formed though a process sometimes called ABC, for affect,\nSome attitudes are formed because of an emotion-\nally involving experience with an attitude object.\nof pleasant dining experiences in fine restaurants can lead to a positive attitude toward\nlead to the formation of attitudes; by thinking about what effect freedom has in\nhuman affairs may lead to positive attitudes about freedoms, and in turn, about the\nAttitudes\nform about attitude objects as you experience them, use them, or think about them.\nby doing so, attitudes form and harden.\nhold these attitudes based on what we can observe.\nHow exposure to an attitude\nobject (observable) leads to the activation of an internally held attitude (not observ-\nthe felt attitude (observable).\nThe expression of an attitude can be through many\nAll About Attitude: Building Blocks for Opinion, Reputation, and NPC Personalities\nComplex attitude objects, like people, historical events, and organizations, can be\nevaluated along as many attributes about the attitude object that are of interest.\nAlso, because an attitude represents an evaluation held by an individual about\nsomething, it is entirely subjective, and because it is, an attitude is not actually a state-\nAttitudes often (although not always) carry an emotional “charge.” Some atti-\nexperience, and these can become among the most enduring of attitudes.\nWhat’s in an Attitude?\ncan produce a reasonably lightweight model of attitude that can be used by AI game\nIn fact, something very much like attitude has been used in a number\nCalculations to update values in the attitude system need not be performed every\nframe; in fact, one nice thing about an attitude system is that attitudes need to be\nrefreshed only when an event in the game that can affect attitudes occurs.\nAn attitude\nof attitudes.\nhold a collection of attitudes for as many attitude objects as the game requires.\nlikely, the chief attitude object will be the human player or player character (PC), which\nAgents that represent other forms of organizations can also hold attitudes.\nthat evaluative dimension of liking/disliking, a value commonly called the valence.\nto start, each attitude needs to carry at least a single integer or floating point value to\nthe game requires the ability to model small shifts in attitude taking place over time\nanticipated need for storing a large number of attitudes for a large number of NPCs,\nAll About Attitude: Building Blocks for Opinion, Reputation, and NPC Personalities\nan intense entanglement with the attitude object, and simply is a different emotion\nA second value that can be stored in the Attitude class is potency.\nhow strongly held the attitude is.\nThis occurs because an attitude represents the\naccumulation of a lifetime of exposures to the attitude object, yet it is expressed as a\nAs exposures to the attitude object accumulate, the attitude\nnot depart too much from where the attitude is now.\neating Brussels sprouts pile up, the dispositional liking (the attitude) may settle down\nAll at once, her lifetime of accumulated feelings and attitudes about\nIf your game has moments of serious betrayal or treachery, any practical attitude\nFor this, the Attitude class needs to implement a method that\nthat method to forcibly reset all the affected attitudes held by anyone who needs to be\nOver time, people forget things, and extreme attitudes and bad memories usually soften\nthe game spans only a short time frame, attitudes and memories will remain fresh,\ntwo game years, by game’s end, attitudes first picked up near the start of the game will\nlittle (or even no) decay in their negative attitudes occurs.\nFrom these factors, the Attitude construct can be implemented with a lightweight\nEntity* target;   // attitude object; \nAll About Attitude: Building Blocks for Opinion, Reputation, and NPC Personalities\nComplex Attitude Objects\nOne useful metric often required from the Attitude class is an overall or aggregate\nevaluation when dealing with complex attitude objects (like the PC) that get evalu-\nthe normalized sum of the products of each attitude’s valence times that attitude’s\nIf there is no opinion or attitude system in use, you could set up an FSM much\nYou can still use this but now add the attitude system.\nsome extent) because the attitude system has in some fashion supplied each warrior\nwith hate and fear values about the player to hold as attitudes.\nrior will now strengthen his hate attitude toward the player, and possibly also change\nifying A, R, and H with attitude values that modify the initial settings upward or\nAll About Attitude: Building Blocks for Opinion, Reputation, and NPC Personalities\nAttitude and Behavior\nA human, of course, holds literally millions of attitudes about just about\nYou want to use attitude data structures only where they are useful, and this\nAn extended FSM where attitude influences transitions",
      "keywords": [
        "Attitude",
        "attitude object",
        "attitude system",
        "game",
        "Complex attitude objects",
        "NPCs",
        "NPC",
        "generic programming",
        "object",
        "NPC Personalities",
        "Complex attitude",
        "FSM",
        "Valence",
        "Attitude class",
        "player"
      ],
      "concepts": [
        "attitude",
        "games",
        "emotions",
        "emotional",
        "emotion",
        "emotive",
        "values",
        "likes",
        "liking",
        "personalities"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 31,
          "title": "",
          "score": 0.7,
          "base_score": 0.55,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 25,
          "title": "",
          "score": 0.558,
          "base_score": 0.408,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 33,
          "title": "",
          "score": 0.432,
          "base_score": 0.282,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.422,
          "base_score": 0.272,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "",
          "score": 0.349,
          "base_score": 0.199,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "attitude",
          "attitudes",
          "attitude object",
          "attitude objects",
          "opinion"
        ],
        "semantic": [],
        "merged": [
          "attitude",
          "attitudes",
          "attitude object",
          "attitude objects",
          "opinion"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.10023556080574059,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075645+00:00"
      }
    },
    {
      "chapter_number": 31,
      "title": "Segment 31 (pages 292-300)",
      "start_page": 292,
      "end_page": 300,
      "summary": "an attitude toward a behavior.\nIn a social game, murder may be possible,\nthat lends itself for use in behavior trees or other models of NPC behavior.\nLet’s say an NPC has developed a positive enough attitude toward the player that\nenough attitude toward the PC, the NPC can form a BI to help the PC.\nHow much paring is required depends on the kind of game you are building.\nSerious games that need to model political struggles, or advertising or propaganda\ncampaigns, may need more of the model than games that don’t.\nAll About Attitude: Building Blocks for Opinion, Reputation, and NPC Personalities\nIn a game, you can do away with a lot of this.\ncommunications in a game are important, that receivers will always find them impor-\ncourse of the game.\nIf this is too complex for the game, and such attitudes are not\nduring the game.\nin-game cutscene haranguing his fellow warriors as to why it’s now important to make\nIn many games, all that is important is for the various NPCs to hold attitudes\ntoward the player only, and not hold attitudes about each other.\nin the design of the game to keep information about inter-NPC attitudes, leaving\nHowever, some game designs benefit by having such a system if the gameplay\nConsider how this can be used in a hypothetical open-world action-adventure game\nThe object of the game is to compete against the NPCs by doing dirty deeds,\nare fair game, as is anyone who crosses you.\nAssume the game features several different competing crime organizations, each\nEach capo is likely to value a different pattern of attributes of the player or any\nAs the player continues to work up the ranks, different bosses will tend to value\nAll About Attitude: Building Blocks for Opinion, Reputation, and NPC Personalities\nJust a handful of attribute/attitude dimensions are needed to make this sort of\nAt this point you may be thinking, “Why not just make games that need NPCs like\nthis be multiplayer games and let real human players handle all this complexity?” To\nsome extent a multiplayer approach will work and already does in many games, but\nIt seems like it will be the fate of game designers and\nother talented folk to create the rich game worlds and believable characters that play-\nof a single attitude can be quite lightweight, although in a game with any complexity\nAs more and more CPU and RAM budgets are allocated to game AI, game devel-\nthat game developers need to build caricatures and not real humans, and the challenge\nKnowledge.” AI Game Programming Wisdom, Charles River Media, 2002: pp.\n“Opinion Systems,” AI Game Programming Wisdom 3,\nAI Game Engine Programming, Charles River Media,\nAll About Attitude: Building Blocks for Opinion, Reputation, and NPC Personalities\nin Games Using Player\nPlayer Graphs\ns the field of game AI has grown, the ability to create characters and game reactions\ngence in games.\nThis gem shows how logging player-centric game data can be used to\nbetter understand both natural and artificial player behavior through the use of visual\nThe game AI developer is focused on the creation of an entity, multiple entities, or\npossibly just a system which the engaged human player must perceive as a challenge in\nSatisfying the cognitive needs of human players is what makes\nthe game interesting, fun, and challenging, and it is what ultimately makes the game\nThe interesting problem is that not every human player perceives the same, or\ngame AI development very difficult, and it leads to discussions about the tradeoffs\nbetween focusing on games that pit human versus human or human versus machine\nhuman-level AI.\nIs a game AI turing test [Russell03] a valid way to determine whether an entity is\nWhat is needed is a method for objective evaluation of game AI to a human\nThe current trend in modern computer games is to leave out detailed logging in\nto enhance the interactive game experience by providing insight into the behaviors of\nboth human and machine players.\nLogging in games is often tied to the game’s save features because these subsystems\nHowever, most games do not log player\ngames that now use a checkpoint system for saving rather than being able to save the\ngame at any point.\nThis means that the game will only save when a player reaches a\ners [Eilers05], this is fine for the first few times that a player plays the level; however,\nIt also hinders the ability for real logging because there is now no in-game\nLogging is very useful during the play-testing phase because it can make the\ngames from non-interactive forms of entertainment [Consalvo06].\nslow down the game.\ncations of commercial games.\ntime), and we have captured hundreds of players interacting in our game scenarios.\nthe reader is interested in being a study participant for our game studies, please visit\nUnderstanding Intelligence in Games Using Player Traces and Interactive Player Graphs\nPlayer trace from UCT (Urban Combat Testbed) player data showing player",
      "keywords": [
        "game",
        "player",
        "NPC",
        "attitude",
        "human",
        "behavior",
        "NPCs",
        "NPC Personalities",
        "group",
        "Game Programming Wisdom",
        "human players",
        "Interactive Player Graphs",
        "logging",
        "Opinion",
        "Game Programming"
      ],
      "concepts": [
        "game",
        "player",
        "human",
        "attitude",
        "behavior",
        "behavioral",
        "interacted",
        "interaction",
        "logging",
        "log"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 30,
          "title": "",
          "score": 0.7,
          "base_score": 0.55,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 25,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.507,
          "base_score": 0.357,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 33,
          "title": "",
          "score": 0.493,
          "base_score": 0.343,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "",
          "score": 0.463,
          "base_score": 0.313,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "game",
          "player",
          "npc",
          "human",
          "attitude"
        ],
        "semantic": [],
        "merged": [
          "game",
          "player",
          "npc",
          "human",
          "attitude"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.12751344813095894,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075705+00:00"
      }
    },
    {
      "chapter_number": 32,
      "title": "Segment 32 (pages 301-308)",
      "start_page": 301,
      "end_page": 308,
      "summary": "However, even if you log once per second it is enough to do some analysis on player\nSo, you log player interactions with the inter-\nInteractive feature points are\ncontain other game elements or even the player (for example, a courtyard, inside a\nplayer can interact in any fashion can be considered an interactive feature point.\nIn the real world, the number of interactive feature points is infinite, but in a\nAll of the interactive feature points in a game or game scenario can be\ndescribed in a interaction possibilities graph, as shown for a simple example FPS envi-\nThe vertices represent interactive feature points and the\nissues when analyzing player traces from logged data.\nUnderstanding Intelligence in Games Using Player Traces and Interactive Player Graphs\nThe interaction feature points of a game can be used to generate an interac-\nof games and the desired interaction in games, which largely consists of the human\nizing single or multiple player traces.\nThe information gathered from in-game logging of player actions can easily become\ntime, position, orientation, and interaction.\nresented visually with a player trace.\nA player trace shows the actions of the player from\nalization of player trace data from one or more players.\nAs seen in Figure 3.5.3, a player\nspheres represents the position of the player, and the player’s orientation at that time is\nA player trace provides\nPlayerViz can also be used to examine multiple player traces at once, which can\nFor example, if the players were playing together,\nYou could also take the average of their player\nIf the players are adver-\nPlayer traces can also be utilized to show AI agent behavior and compare it\nIn order to provide context for the player traces, the world geometry must also be visual-\ncoherence between the player trace and the world.\nLooking at the player trace for such an agent can be useful in machine learning studies.\nUnderstanding Intelligence in Games Using Player Traces and Interactive Player Graphs\nEven with the help of player trace visualization, it can still be a difficult task to examine\nall of the player traces if there are several hundred players.\npages showing a table of thumbnails of each player trace from different angles.\ndata mining of player traces, as follows—(a) jumper, (b) fluster, \nIn our own work using these player trace images, as shown in Figure 3.5.4, we can\ntrace where the player seemingly loses control of his or her cursor.\nFigure 3.5.4c shows two player traces of the same player.\nYou can also find emergent behaviors using this technique, such as the player\nleast visited) by the players.\na clue in an area of the map that very few players ever go to, the designer will know\nthat most players are not likely to find it.\nthe average player trace using a set of several player traces.\nmight be to generate a congestion map using a set of several player traces to highlight\nwhere future players are more likely to explore, so that they can place interactive feature\nInteractive Player Graphs\nA representation of interaction that could be used for comparison with other players\nThe trajectory of interaction in the context of a game is a\nUnderstanding Intelligence in Games Using Player Traces and Interactive Player Graphs\nof an interactive player graph for each player in a game.\nAn interactive player graph (IPG) is built either during play or in post-play pro-\ncapture the desired interactions to make the graph.\nments through environmental regions and player interactions with specific objects in\ncapture time by weighting the edges between interaction feature points with the time\nit had taken the player between interactions.\nIPGs abstract a player’s performance in a\n3.5.5 shows a player trace converted to an IPG using the associated spatial decompo-\ntion with an interaction feature point representing each as a separate vertex.\nyou’ll evaluate, time performance is the major differentiator between players.\nIf you cluster player performance, you\nUnderstanding Intelligence in Games Using Player Traces and Interactive Player Graphs\nThe interactive player graph in (a) was created from logged data from the\nplayer whose same player trace is shown in (b) using PlayerViz. The vertices represent inter-\nweighted by the time between interactions.",
      "keywords": [
        "player",
        "player traces",
        "Interactive Player Graphs",
        "Interactive Player",
        "game",
        "Player Graphs",
        "Interactive feature points",
        "trace",
        "interaction",
        "feature points",
        "interactive",
        "player trace data",
        "graph",
        "multiple player traces",
        "Interactive feature"
      ],
      "concepts": [
        "interactive",
        "interactions",
        "player",
        "spatial",
        "game",
        "graph",
        "traces",
        "visualize",
        "visual",
        "visually"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 33,
          "title": "",
          "score": 0.699,
          "base_score": 0.549,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "",
          "score": 0.69,
          "base_score": 0.54,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 10,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "",
          "score": 0.562,
          "base_score": 0.412,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 26,
          "title": "",
          "score": 0.556,
          "base_score": 0.406,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "player",
          "player traces",
          "traces",
          "interactive",
          "trace"
        ],
        "semantic": [],
        "merged": [
          "player",
          "player traces",
          "traces",
          "interactive",
          "trace"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2660082438770113,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075760+00:00"
      }
    },
    {
      "chapter_number": 33,
      "title": "Segment 33 (pages 309-320)",
      "start_page": 309,
      "end_page": 320,
      "summary": "agent data with human data and the agents cluster into groups with human players,\nClustering human players and agents can be\nclustering of the current human player could be used to determine the actions of the\nhuman and agent intelligence in games.\nData collected from logging human players and AI interacting in a game envi-\nactions in the game.\nplayer/agent interactions that are analyzed with clustering and knowledge discovery\ntion: Interactive Computer Games,” AI Magazine, Vol. 22, No. 2 (2001), pp.\nGoal-Oriented Plan Merging\nsing goal-oriented action planning systems to create and manage behavior in\nIn game development, planning systems are a relatively new\ncan use to improve their planning systems.\nOne way planners can be improved is through the use of plan merging, a tech-\nUsing plan merging can allow a broader range of behaviors for automated agents and\nof implementing a plan-merging system in the context of a real-time game and dis-\nReview of Goal-Oriented Planning Systems\nGoal-oriented action planning systems are decision-making algorithms designed to\nsystems is the reduced complexity of designing individual actions for artificial agents\nGoal-oriented planning lets particular agents decide their own actions through\nOnce this goal is picked, an agent can create a plan by stringing together a\nFor example, if your agent has decided on the DestroyTarget goal, an action it\nplan by listing a sequence of actions an agent can use to achieve the desired goal.\nOrkin describes how to use the A* algorithm for planning purposes in [Orkin04].\nThe completed plan is then just that sequence of actions the agent executes to accom-\nSome final terminology is needed before discussing plan merging.\nplans are plans in which the order of each action is completely specified, such that one\nPartially-ordered plans may\nTotally-ordered plans can\nbe made from partially-ordered plans by giving a specific order to the actions in the plan.\nFigure 3.6.1 shows an example of some partially- and totally-ordered plans for\nActions\nPartially- and totally-ordered plans.\nthe partially-ordered plan are given.\nAlthough the vast majority of academic-based planning algorithms produce\npartially-ordered plans, these types of planners have not yet found widespread use in\nThere are a few reasons why totally-ordered plans are of more immediate use\n• First, given a partially-ordered plan, an agent will at some point have to define,\neither explicitly or implicitly, a totally-ordered plan in order to execute the actions\nof the plan.\nIn other words, the agent still needs to choose one action to perform\nfor which the agent might put one action first could easily be abstracted into the\nimplementing an A* planning system for games.\nPlan Merging for Goal-Oriented Plans\nPlan merging refers to the process of taking several independently generated plans and\nTo demonstrate the power of plan merging, let’s look at an\nThere are several ways you could accomplish this behavior utilizing a planning\nAn agent executing the GatherItems action would look for the nearest items, gather as\nwithin one action works to defeat the purpose of having a flexible planning system.\nGoal-Oriented Plan Merging\naccomplish the desired behavior through plan merging.\nThe general idea is to take two plans with some overlapping actions and combine\nIn the current example, the agent could plan to gather each\nA possible result from a merge of those two plans\nwould combine as many actions as possible together, producing the single plan shown\nWhen the agent executes this plan, it collects both items\nTwo totally-ordered plans and the result of a possible merge between them.\nImplementing a Plan-Merging Algorithm\nAcademically, the interest in plan merging centers mostly on plan optimization.\n[Foulser92] points out two major components to optimizing a plan: finding actions\nkinds of actions can be merged.\nPut simply, any number of actions can be merged if\nthe plan, or a precondition of the goal itself.\nFor example, suppose an agent has a plan\nbecause it accomplishes a precondition of another action in the plan.\nSearching plans for mergeable actions would be incredibly expensive without\nspecific action that can be merged with itself, or looking for a known combination of\nactions that could be merged.\nthe agent is likely to have multiple plans, each with an instance of the ReturnItems\naction.\nto merge two ReturnItems actions.\nat the end of the plan, because it is likely to be the last action in each of the plans that\nThe second challenge is creating an optimal plan once a possible merge has been\nplans together, as was shown in Figure 3.6.2.\nmerged actions, so you could write a critic to make sure the agent goes to the closest\nAt its simplest, then, the plan-merging algorithm accepts two plans generated\nFor every action in the first plan, the algorithm checks to see\nwhether it can be merged with an action in the second.\nthose two actions are put together into a single plan, being careful to put preceding\nactions from both plans before the merged action, and likewise putting any actions\na complete plan-merging algorithm should examine the net effects of every possible\nGoal-Oriented Plan Merging\ngroup of actions in each plan, looking for situations where a sequence of actions could\nAlthough merging two plans for a single agent certainly offers opportunities for\nimproved behavior, plan merging also offers remarkable benefits in the areas of squad-\nbased planning.\nFor instance, an agent utilizing plan merging could merge an individ-\nUtilizing plan merging in these situations allows an agent to maintain its\nSearching two or more plans for actions with similar effects is expensive, especially if\nlook for mergeable actions only when specific actions are present in the plan, some-\nlong plans, hooks direct to possibly-mergeable actions could be included in the plan\nit might even be worth only looking for a specific action to merge in each plan.\nSimilarly, you might attempt a merge only when the goals being planned for are\nIndeed, even making a plan for a secondary goal\nthrough every action of each plan before reporting that no mergeable actions exist.\nPlan merging offers a way to improve the perceived intelligence of an agent acting\nIt should be noted that this is only one way of performing plan merging.\nforming plan merging that may be more appropriate for agents acting over a longer\nFor example, the plan-merging algorithm\nEven if plan merging is not useful in a given situation, the ideas it suggests\nPlan Merging.” Artificial Intelligence, 57(2–3): pp.\n“Applying Goal-Oriented Action Planning to Games,” AI\nReal-Time Planning in Games.” AAAI Challenges in Game AI Workshop Technical\ning & Exploiting Positive Goal Interaction in Intelligent Agents,” AAMAS ’03,\nGoal-Oriented Plan Merging",
      "keywords": [
        "Plan Merging",
        "Plan",
        "actions",
        "agent",
        "game",
        "Interactive player graphs",
        "Goal-Oriented Plan Merging",
        "Totally-ordered plans",
        "Merging",
        "player",
        "planning",
        "data",
        "action planning systems",
        "goal-oriented action planning",
        "clustering"
      ],
      "concepts": [
        "plan",
        "planning",
        "actions",
        "game",
        "goal",
        "clustering",
        "clusters",
        "based",
        "base",
        "merging"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.699,
          "base_score": 0.549,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 25,
          "title": "",
          "score": 0.643,
          "base_score": 0.493,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "",
          "score": 0.554,
          "base_score": 0.404,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 1,
          "title": "",
          "score": 0.54,
          "base_score": 0.39,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 3,
          "title": "",
          "score": 0.517,
          "base_score": 0.367,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "plan",
          "actions",
          "merging",
          "plans",
          "plan merging"
        ],
        "semantic": [],
        "merged": [
          "plan",
          "actions",
          "merging",
          "plans",
          "plan merging"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20892155455060238,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075809+00:00"
      }
    },
    {
      "chapter_number": 34,
      "title": "Segment 34 (pages 321-328)",
      "start_page": 321,
      "end_page": 328,
      "summary": "The root node can then be expanded into a number of child nodes that represent\nFor example, if the four cardinal directions are allowed, the root node expands into\nChild nodes can be further expanded as\npossible turn of a cube face corresponds to a child of that root node.\nA* has emerged as the most common search algorithm for pathfinding within game\nroot node are expanded and evaluated before moving on to the next level of tree\n• Each node keeps track of the cost of the path to that point, and the open list can\n• Together, the open and closed lists act as a catalog of previously evaluated nodes,\nThe resulting overall cost of any particular node becomes f() = g() + h(), and it\ncost from the node to the goal.\nIf h() ever overestimates the cost to the goal, searching\neral algorithm as Dijkstra’s, but the cost associated with any particular search node now\nopen – priority queue of search nodes\nclosed – searchable container of search nodes (such as an associative\nroot = start node\nsort open by f() of each search node\nremove top of open and set to current node\nif current node = goal\nfor each child of current node\ntop of the list being the node with the lowest cost.\nopen and closed lists are continuously polled to determine whether a node has already\nBeyond A*: IDA* and Fringe Search\nmany as 18 child nodes for any particular search node.\nroot = start node\ndepth-first search(node):\nif node = goal\nif node’s f() > threshold\nfor each child of node, while goal not found, depth-first\nAll nodes are expanded below this threshold and if the goal node is not\ntiate the search from the original start node and expand all nodes allowed given the\nnon-goal nodes, but the cost of expanding and evaluating a node is typically much\nnodes, those at the edge of the search that were not explored before, will always be\ngreater in number than the number of expanded nodes below the threshold.\nThe Fringe Search Algorithm\nBetween A* and IDA* is an algorithm called Fringe Search (see Algorithm 3.7.3), in\nwhich nodes are expanded given a cost threshold as in IDA*, but in this case the fron-\nRather, the frontier nodes are maintained in now and later lists.\nnow – linked list of search nodes, list order determines order of\nlater – linked list of search nodes\nroot = start node\nfor each node in now\nif node = goal\nif node’s f() > threshold\nBeyond A*: IDA* and Fringe Search\nThe node at the top of the now list is evaluated and if its f () value is greater than\nexpanded child nodes are added to the top of the now list and are thus next in line for\nevaluated nodes.\nvisits to nodes in the search tree.\nThe cost for fringe search’s perfor-\nThere is no paucity of algorithms for graph search and pathfinding.\nIDA* and fringe search represent useful modifications of the A* family of algorithms",
      "keywords": [
        "Search",
        "Fringe Search",
        "node",
        "IDA",
        "search nodes",
        "cost",
        "child nodes",
        "algorithm",
        "goal",
        "list",
        "search nodes root",
        "open",
        "root node",
        "Fringe Search Algorithm",
        "threshold"
      ],
      "concepts": [
        "search",
        "node",
        "cost",
        "algorithms",
        "threshold",
        "expanded",
        "game",
        "allowed",
        "push"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 26,
          "title": "",
          "score": 0.419,
          "base_score": 0.419,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 18,
          "title": "",
          "score": 0.396,
          "base_score": 0.396,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 19,
          "title": "",
          "score": 0.362,
          "base_score": 0.362,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 14,
          "title": "",
          "score": 0.35,
          "base_score": 0.35,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 6,
          "title": "",
          "score": 0.342,
          "base_score": 0.342,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "node",
          "nodes",
          "search",
          "root",
          "fringe"
        ],
        "semantic": [],
        "merged": [
          "node",
          "nodes",
          "search",
          "root",
          "fringe"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19443229908102752,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:44.075858+00:00"
      }
    },
    {
      "chapter_number": 35,
      "title": "Segment 35 (pages 329-336)",
      "start_page": 329,
      "end_page": 336,
      "summary": "ame audio programming is becoming more complex than ever.\nAs game audio is\nnext game the next award-winning title for audio.\nAudio Signal Processing\nGraphics Hardware\neal-time modern audio processing can sometimes be very compute-intensive, as\nGPU’s relatively huge SIMD (Single Instruction Multiple Data) parallel stream process-\nAudio \nputation on a Graphics Processing Unit) programming and has been successfully used\nGPU Audio Optimization\nare similar to those of professional audio DSP hardware [Gallo04], therefore it can be\nTherefore, audio sample data is often stored in one of these components\nDoes using the GPU for audio calculations significantly optimize performance?\narray of DSP effects on both graphics hardware and CPU.\nhad a significant decrease in execution times when processed on the GPU; others such\nsame code in parallel—therefore, not all audio programming techniques may be opti-\nAudio Effects\nThis section concentrates on describing algorithms for chorus and compression audio\nprocessing effects.\neffect requires two texture lookups; interpolation between them is shown here:\nAudio compression effects that are unrelated to data compression reduce the\ndynamic range of audio signals and are useful for balancing the game’s overall audio\nMany other audio effects, such as delay and normalization, can be optimized\nAudio Signal Processing Using Programmable Graphics Hardware\nAnother type of audio-processing technique that could be made more efficient using\nGPU is calculating real-time room acoustics, as demonstrated by [Jedrzejewski06].\nent from graphical ray tracing because the scenes that are computed don’t need to be\nFragment shaders are executed that first compute intersections in the current leaf for\nAudio \nSet new leaf for ray\nof the render target texture and final ray data.\nNot all audio algorithms can take advantage of the GPU’s parallel computation; how-\never, certain tasks such as some audio effect algorithms and acoustical ray tracing excel\nwhen executed on graphics hardware.\nOther than the audio techniques described in\nsuch as FFT (Fast Fourier Transforms), which are ubiquitous in audio processing.\nthat the GPU can be utilized as a practical optimization for many audio algorithms\nand even a feasible replacement for specialized audio DSP hardware.\n“GPGPU: General Purpose Computation on Graphics\n“Efficient 3D Audio Processing\n[GPGPU07] “General Purpose Computing Using Graphics Hardware,” available\nComputation on Graphics Hardware,” Computer Graphics Forum, 26(1), pp.\nHardware,” Game Programming Gems 4, Charles River Media, 2004.\nAudio Signal Processing Using Programmable Graphics Hardware",
      "keywords": [
        "audio",
        "Graphics Hardware",
        "GPU",
        "Programmable Graphics Hardware",
        "Audio Signal Processing",
        "Graphics",
        "hardware",
        "ray",
        "processing",
        "audio DSP hardware",
        "audio processing",
        "Programmable Graphics",
        "general purpose",
        "Audio Signal",
        "GPUs"
      ],
      "concepts": [
        "effects",
        "ray",
        "rays",
        "hardware",
        "processing",
        "process",
        "graphics",
        "graphical",
        "leaf",
        "data"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 37,
          "title": "",
          "score": 0.744,
          "base_score": 0.594,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 50,
          "title": "",
          "score": 0.712,
          "base_score": 0.562,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 36,
          "title": "",
          "score": 0.653,
          "base_score": 0.503,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 38,
          "title": "",
          "score": 0.639,
          "base_score": 0.489,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 39,
          "title": "",
          "score": 0.637,
          "base_score": 0.487,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "audio",
          "graphics hardware",
          "hardware",
          "graphics",
          "processing"
        ],
        "semantic": [],
        "merged": [
          "audio",
          "graphics hardware",
          "hardware",
          "graphics",
          "processing"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24109502138548683,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075909+00:00"
      }
    },
    {
      "chapter_number": 36,
      "title": "Segment 36 (pages 337-344)",
      "start_page": 337,
      "end_page": 344,
      "summary": "Audio \ngen” audio engine for the Playstation 3 that was to be part of the official SDK.\nof the work involved in designing and creating your own audio engine.\ninformation may be useful in allowing you to create your own audio engine, or by\nproblems that might also need resolving due to the expectations of next-gen audio.\naudio engines around known hardware or game requirements can mean that the final\nA “stream” in MultiStream consists of audio data to play (up to eight channels),\nApart from the technical aspects of creating an audio engine, we also had to decide on\nyour own audio engine might be appealing, but such a project could end up taking years\nHaving a team working on an audio engine for three years does not come cheap.\nAlthough it should seem simple, creating an audio engine that makes games sound\nquality audio tracks has been available to game developers for over a decade.\nIf you are thinking of writing your own audio engine, first ask yourself what it\nFor MultiStream, one purpose was to allow game audio to sound better\nthe same audio capabilities as previous audio engines—this might make a game sound\nbecame obvious that next-gen audio means gaining expertise in a number of areas we’d\nto take is to make a wish list of what kind of audio processing they require.\ntime of writing, it seems like just about any type of audio process is not only possible,\nis no processing left for any audio channels!\nAudio \nHow Many Audio Channels?\nIt is presumed that for any audio engine, it must be able to process enough audio chan-\nselves.” Even so, today’s (and tomorrow’s) game requirements mean more audio channels\nthat a car engine sound might be created with at least 25–30 audio channels:\nor “grains”—of a car engine sample, create a far more realistic engine sound than loops\nPlayback of an audio file must also take into consideration the format of the sample\nFor game audio, one of the main issues is accessibility.\nplay back audio approximately +/–1000 samples from where is required.\nMultiStream—The Art of Writing a Next-Gen Audio Engine\nThe file formats your audio engine accepts also have to be considered, as shown\nAudio Engine File Formats\nBest quality audio\nAudio \na standard game audio format.\nIt also has to be noted that codecs such as MP3 require data buffers per audio\nchannel too, where decoded data and other information needs to be stored.\ning that MultiStream can play 512 MP3s at once, even if each audio channel only\nHandling looping of audio is not as simple as it may seem.\nIf you are streaming audio content, care needs to be taken so the\nMost audio systems need to be aware that data may be streamed.\nHere, your audio\nPCM data obtained from a decoded .MP3 via a codec outside of your audio engine).\nwithin your audio engine.\nIf the audio engine requires more data for a streaming\nIf you start handling data loading in your audio engine, expect a world of pain later\n• You need to sync other game data-loading with your audio engine loading.\n• You need to handle all cases of corrupt data loads (disk removed during loading or\nmust also be noted though, that any audio streaming needs to take priority over any\nSimply due to the fact that if audio is not streamed in time,\nEven if your audio system is not going to handle streaming of data from disk\nMultiStream—The Art of Writing a Next-Gen Audio Engine\nUsing this method, if a player keeps requesting more audio to be streamed, say,\nsuch audio is, as far as I am concerned, more important than game data loading.\nstreaming engine (note that the streaming engine and the audio engine are separate\nThis method can also help with prioritizing audio data streaming.\naudio channels need more data, you need to choose which should be the first to be\nIf multiple streams require more data, then\nload the data in time, a simple solution is to either increase the stream buffer sizes or\nreduce the sample rate of the audio.\ntake twice as long as playing 48000 samples at 48kHz. The method of reducing the playback frequency of a stream is also very useful for\ndue to the restrictions set by other non-audio game requirements.\nFor streaming audio with loop markers, depending on the sample data format,\nthe only time you might know that you need to loop the data is when you’ve reached\nmarkers within the audio engine.\nAudio \nSetting volume levels of an audio channel, along with setting its frequency, are the\noutput audio up to 7.1, you needed to allow any audio channel to be routed to any\nThis means that any single audio channel\ntaining up to eight audio channels, there are a total of 64 volume parameters available\ncan make the rest of the audio engine quicker in general.\nalgorithm need to be considered, but also the fact that playing back audio at high fre-\naudio channels may only be able to do so at a maximum playback sample rate of, say,\n48kHz. To explain a little more, if you need to create one second worth of audio data for\nplayback at 48kHz, you need to process 48000 samples to do so.\nback at 96kHz, you need to process 96000 samples.\nput it at 48kHz. Simply put, by halving your audio files sample rate, you can cut the\nMultiStream—The Art of Writing a Next-Gen Audio Engine",
      "keywords": [
        "Audio",
        "audio engine",
        "Engine",
        "data",
        "audio channels",
        "Next-Gen Audio Engine",
        "sample",
        "Next-Gen Audio",
        "game",
        "RAM",
        "audio data",
        "channels",
        "Graphics Processing Unit",
        "MultiStream",
        "time"
      ],
      "concepts": [
        "audio",
        "engine",
        "data",
        "sample",
        "stream",
        "processing",
        "process",
        "games",
        "channel",
        "require"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 35,
          "title": "",
          "score": 0.653,
          "base_score": 0.503,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 38,
          "title": "",
          "score": 0.636,
          "base_score": 0.486,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 37,
          "title": "",
          "score": 0.628,
          "base_score": 0.478,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 39,
          "title": "",
          "score": 0.623,
          "base_score": 0.473,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 40,
          "title": "",
          "score": 0.57,
          "base_score": 0.42,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "audio",
          "audio engine",
          "engine",
          "channels",
          "audio channels"
        ],
        "semantic": [],
        "merged": [
          "audio",
          "audio engine",
          "engine",
          "channels",
          "audio channels"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1277919884686967,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.075953+00:00"
      }
    },
    {
      "chapter_number": 37,
      "title": "Segment 37 (pages 345-352)",
      "start_page": 345,
      "end_page": 352,
      "summary": "For any frequency domain processing, you are looking at requiring a FFT/iFFT rou-\nThe main problem with frequency domain processing is choosing the correct win-\nEven then, different effects may require different window sizes.\nAudio \nthat it should generate 512 samples per channel each time the update routine is\nsamples requires 1024 input samples due to windowing functions (see the section\n• 512 bands (where MultiStream requires 1024 samples as input data) gives enough\n256 bands (512 samples as input data), you would find the audio quality to be too\nProcessing of 512 samples means that the update routine will need to be called\n48000 / 512 = 93.75 Hz (Number of audio updates required per second)\n1000/93.75 = Audio engine will be called every 10.66 milliseconds\nAt least four passes of the data are required when processing in 1024 sample\nplaying, it will not actually start until the next audio update.\nnot notice this, but those who have very good hearing (such as the audio engineers who\nare going to be listening to their work played through your audio engine) will notice.\na lower latency than 512 samples is required, FFT processing may not be the one for you.\nFor MultiStream, we have both frequency and time domain processing modes.\nif you do not require frequency domain effects, it is possible to process totally in time\neach audio update.\nhas required for each audio channel, such as what frequency and volume with which to\nis clicking or popping, which is noticeable on audio such as car engines where multiple\naudio channels would be cross-faded depending on the motor rev required.\nFor time-domain processing, a filter process is required so that volume changes\ntechniques are used when processing frequency data.\nEach packet of data is then processed and mixed with\nsound fine when using window techniques, if for any reason you need to move your\nAudio \naudio engine to a pure “time domain” mode, where no such windowing or filtering\nProcessing multi-channel audio in surround sound must also be considered.\nAgain, MultiStream will fold multi-channel audio down to a single point source\naudio is to play each channel as mono (for example, channel 0 = front-left and chan-\nnel 1 = front-right for a stereo channel), and set the surround sound X, Y, Z position\nFigure 4.2.4 shows six channels of audio.\nSix channels of audio.\nposition from behind to inside a player’s car means all the audio playback works cor-\nFor certain types of games, a common approach for game audio is to keep non-\nplayer audio as mono (point source) and player-specific audio can be multi-channel if\nsound processing of their audio is required and just playing their audio as stereo will be\nAudio \nChannels can become out of sync if the audio engine updates between play\naudio commands.\nIn Figure 4.2.6, you can see that two audio channels have been requested to play,\nbut due to the audio engine’s update routine firing in between the initialization of\nthese two audio channels, the output of “Audio 1” is now one data packet ahead of\npitch of multiple channels, except that in both of these cases it is possible for the audio\nfunctions (the Play or Pitch Change functions) are not split by the audio update rou-\nand are processed in the next audio update function after Sync_Off, as illustrated in\nthe same audio engine update.\nfunction has processed, which means both channels are now playing in sync as desired.\nprocess audio in real-time, and using a minimal amount CPU at the quality normally\nto audio engineers about what effects they would like to see in real-time and why.\nOf course, processing DSP effects in real-time also means that there is less pre-\nprocessing required for audio samples.\nof thousands of samples, it can make sense to process these in-game, allowing the\nthe audio engineer and ask for changes or just put up with an effect that’s close\neffects without the need to waste time pre-processing data not only speeds up devel-\nThe number of busses an audio channel can be mixed to cannot be underestimated.\nset the volumes for these busses, scaling all audio playing through them.\nToday, with the number of audio channels required for creating things like car\nInstead of processing low-pass filters for 30 or more audio channels,\nAudio \nPutting DSP effects into the buss can reduce the amount of processing\nIf there is a long silence in the commentary audio sample,\nall other audio volume will still be reduced.\nPriority systems can also be used to make sure that you hear audio that’s more impor-\ning sure your audio routes to the selected buss, it should be possible that volume lev-\nselect the buss for audio to route to in the same way as you select the sound’s priority.",
      "keywords": [
        "Audio",
        "Audio engine",
        "samples",
        "Next-Gen Audio Engine",
        "audio channels",
        "DSP effects",
        "FFT",
        "Audio FIGURE",
        "Frequency Domain Processing",
        "Processing",
        "Frequency Domain",
        "channels",
        "audio update",
        "effects",
        "Domain Processing"
      ],
      "concepts": [
        "audio",
        "processing",
        "process",
        "processes",
        "requiring",
        "requires",
        "requirements",
        "sample",
        "sounds",
        "game"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 35,
          "title": "",
          "score": 0.744,
          "base_score": 0.594,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 36,
          "title": "",
          "score": 0.628,
          "base_score": 0.478,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 39,
          "title": "",
          "score": 0.622,
          "base_score": 0.472,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 40,
          "title": "",
          "score": 0.508,
          "base_score": 0.358,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 50,
          "title": "",
          "score": 0.507,
          "base_score": 0.357,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "audio",
          "channels",
          "processing",
          "samples",
          "domain"
        ],
        "semantic": [],
        "merged": [
          "audio",
          "channels",
          "processing",
          "samples",
          "domain"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15031878660660553,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076013+00:00"
      }
    },
    {
      "chapter_number": 38,
      "title": "Segment 38 (pages 353-360)",
      "start_page": 353,
      "end_page": 360,
      "summary": "Sound Design\nSounds used in most games, however, are generally static or limited in their\nsame sound effect repeat with little or no change not only reduces the realism of a game\nThe technology to create real-time variable in-game sound effects has been avail-\ninteractive sound and music.\nAt last developers can achieve a level of sound design\nAlthough this may be inefficient on a sound-by-\nsound basis, when implemented for the entire audio environment it often actually\nIt also provides the sound\ndesigner with a much bigger selection of possibilities for sounds in-game.\nactually have more sounds in-game with no repetition and for less memory.\nTo begin with, it is useful to think of the sounds we record and add to the engine as\nbeing the core building blocks from which we will create all in-game sounds.\nthat creating the actual sound happens in-game each time a sound is needed.\nExplosions are common sounds required in a great many games.\nactual explosion effect is very similar in structure to a literal “pop” sound or many of the\nSound designers will often combine several raw sounds together to create a single\nnew sound.\nticular sound to stand out from the rest of the audio environment.\n• An initial sharp attack sound/surge of energy.\ndrop-off sound.\n• A drop-off and fade sound.\nThis is actually part of the initial sound, but it is useful to think of it as\nThese are the sounds of everything that are affected by the\nThis example deconstructs a traditional explosion into its basic sound elements.\nsound in a children’s platform game.\n• An initial sharp attack sound/surge of energy.\n• A drop-off and fade sound.\n• Affected elements often occur in a cascade of sounds.\nSo, let’s actually make a sound effect.\nPreviously, I deconstructed a sound so that\nyou can understand the elements you need to construct the same type of sound effect.\ncreated using only the seven base sounds.\nSeven wav files totalling 629KB were combined to create seven new in-game sounds\nAll the new sounds were created and recorded directly out of the\nseven base sounds.\nIngame_Sound03 was\nsound-editing program to create an explosion sound effect.\nto position the sounds relative to each other in time.\nThe sounds themselves can be\nany combination that produces the desired final sound effect.\ndesigner is happy with the result the sounds are combined by rendering them together\nrepresentation of how you would like the sounds to be combined in real-time by the\nThe sound events are also not limited to\nan individual sound file.\nsound.\nSound tool layout.\nEach time a sound\nis played, each of the tracks will count its time offset before the sound is triggered.\nFor example, sound\nSound 03 combines a set wait time with a further randomized wait time.\nThe main tools used to create sound effects are amplitude, pitch, and time manip-\nSound designers in all media\nuse these tools to create the sounds they want to use and render out a new altered sound\nFigure 4.3.3 shows the FMOD sound designer interface.\nFMOD’s use of sound events rather than actual wave files in the design\ntool allows for a sound event to include multiple sound files as described in Figure\nIn Figure 4.3.3, the sound events overlap to allow for a cross-fade between them.\nAs any of these parameters are affected, the sounds change as\nthan FMOD’s Sound Designer, but many of the same features and strengths.\nmultiple sound files in the same way as FMOD.",
      "keywords": [
        "Sound",
        "sound effect",
        "Audio",
        "time",
        "sound event",
        "effect",
        "sound designers",
        "game",
        "base sounds",
        "create",
        "FMOD sound designer",
        "in-game sounds",
        "sound files",
        "FMOD",
        "attack sound"
      ],
      "concepts": [
        "sound",
        "audio",
        "games",
        "explosions",
        "explosion",
        "time",
        "effect",
        "pops",
        "pop",
        "tool"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 39,
          "title": "",
          "score": 0.869,
          "base_score": 0.719,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 40,
          "title": "",
          "score": 0.681,
          "base_score": 0.531,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 35,
          "title": "",
          "score": 0.639,
          "base_score": 0.489,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 36,
          "title": "",
          "score": 0.636,
          "base_score": 0.486,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 50,
          "title": "",
          "score": 0.539,
          "base_score": 0.389,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "sound",
          "sounds",
          "fmod",
          "sound effect",
          "effect"
        ],
        "semantic": [],
        "merged": [
          "sound",
          "sounds",
          "fmod",
          "sound effect",
          "effect"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15896868965704777,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076058+00:00"
      }
    },
    {
      "chapter_number": 39,
      "title": "Segment 39 (pages 361-371)",
      "start_page": 361,
      "end_page": 371,
      "summary": "By dividing sounds into their smaller components, you increase their usefulness to the\noverall sound environment.\nclunk), not only do you have two new source sounds that can be combined into other\nsound by subtle pitch shifting or varying slightly the time between the click and the\napproach sound design for greater realism.\ndozen times and see how different the sounds are each time.\nThe ultimate goal with this system is to have every sound rendered in-game and to\nously spending a lot of time on very minor sounds may not be cost effective, but the\nin creating sounds.\neven sound real.\nThe designer creates the sounds by choosing the raw material and setting the vari-\nables that will control how the sound is created in real-time.\nnature of the sounds, it is important that the designer audition a considerable selection\nmight be necessary as more sounds are added to the audio environment and they need\nOne of the best aspects of this method is that once a sound\nThis means often drastic changes can be made to the sound environment with\nAs a result, the sound department should be able to work\ntent, as new sounds could be included in game updates without the need to download\nalready have installed and creates new sound assets by making new definitions only.\nThis gem has focused on the most basic tools for sound production and manipulation:\nEven though I refer to this method as rendering or creating the sounds in real-\ntime, these ideas will not reduce or replace the work of a sound designer.\nmakes the role even more critical and requires the sound designer to work far beyond\nsimply using library sounds.\nmethods of game sound design.\napproaches to sound construction, these new methods can allow for incredible flexibil-\nSound is perceived as a\nmuch more accurate way to deal with clearing a sound buffer is covered in the follow-\nswitch between the two different sound APIs depending on the card and drivers they\nSound is going to be very straightforward.\nOverview of a Sound System\nsound system—the primary buffer, the listener, the sound, and any effects applied to\nthe sound or the listener.\nmost sound systems you won’t be filling the primary buffer directly, but you will be\nsounds and applies any special transformations and effects such as panning and falloff,\nSimply transform all sounds to the listener and\nrecord things such as velocity in the sound properties so that effects, such as Doppler\nThe Sound Sources\nThe sound sources themselves are typically mono channel signals coming from within\nSound sources typically have properties such as position, falloff, and veloc-\nThose properties are then used by the listener and the effects to process the sound.\nUnder any sound system, you should differentiate between sound sources and the\nactual sound data.\nSound sources contain a reference to the sound data as well as the\nposition and orientation of the particular sound and the current play position within\nthe actual sound data.\nThe actual sound data is merely the container for the PCM\nof the sound itself.\nThe Sound Effects\nSound sources also contain effects.\nSome of those effects are inherited from the sound\nfrom the listener, the listener then goes out and determines what sounds to play and\nrequests the samples from the sound sources.\nUpon getting that request, the sound\nthen runs a digital signal peak limiter on the sound effects and collapses its own\nOne thing to note in this entire example of a sound system is that it uses a model-\nThe data is encapsulated in the sound data (the model)\nand is requested by the sound source (the controller), which then applies the individ-\nual sound effects (more controllers), which in turn is requested by the listener and\nSound Buffers\nOn almost all machines you are limited to the amount of sounds the hardware can\navailable sound buffers to something within the range of your performance targets.\nof writing this gem, the maximum available hardware accelerated sounds on the aver-\nIn most cases, you will want to allocate enough sound samples in your sound buffers\ntypically create my buffers with enough room for one second’s worth of sound data at\nto stop and start sound buffers than to let them play beyond the duration of their\nsound (making sure to clear the sound buffer so that they are not heard!).\nFor instance, using the previous example, where you have 128 sound\nAs soon as all eight sounds are occu-\npied by sound data, you start playing eight more.\nthreshold and the sound buffers haven’t been accessed in a while, you go ahead and\nOnce you get a request to play a sound, populate as much of the sound buffer as\nknowledge, you can request 22050 samples (1/2 buffer size) from the sound source on\nNow that you’ve got those samples from the sound source, you need to\nBecause sound is generally\n128 sounds in total that you can play at any given time.\nplaying sound buffer then the lowest ranking sound is booted out and the new sound\nfalloff, effects, and other items associated with the sound so you can get a clear idea of\nthe sound rank.\ntle echo effect, as another lower priority, but potentially more noticeable, sound is get-\nparticular sound or sound category can be played.\nof sounds.\nOne thing I did was to allow the sound data to figure out its rank given its\nto the sound, like its position relative to the listener and the general world data.\nfollow that up with another sound.\nIf you stop playing one sound abruptly, you’ll hear\nprevious sound.\nThings get even more complex when the previous sound has effects applied to it.\nBecause of the way audio drivers handle the effects applied to the sound buffer, you\nprevious sound has finished fading and then you can switch the effects properties\nyou can apply the new effects and start copying over the new sound.\nRemember previously when you copied half a second of sound samples into the\nKeep in mind that once you send the data to the sound buffer, it’s up to\nyou copy over to the sound buffer so that you can go back in time and fade out at the\nproperty of the sound data so the audio designer can adjust this value.\nyour individual sound system API, so that hardware processing is possible, and then\nattached to the sound source or listener so that they can be collapsed when requested.\ngenerate sound data or perhaps contain a wrapper for a hardware accelerated feature.\nIn any case, think of the effect as the middleman between the sound source and, if the\n• Infinite impulse response (IIR) filters, which recursively work on the sound samples.\n• Finite impulse response (FIR) filters, which just deal with transforming the sound\ntransform the sound in the effect object to the frequency domain, run all of the filters\nsounds combined with effects that elongate a sound beyond the original sound\na sound is finished when no samples are returned via the listener.\nSimply waiting for the request to return no samples on a looping sound\nsource with an IIR filter will result in a sound that never loops.\nwhen an effect reaches the end of reading the sound data, it should loop back to the\nmation on the acoustical makeup of the sound signal in transformed frequency\ndon’t want to dedicate 300MB or more of memory just to your sound track.\nown sound system, tailored to your game’s needs and performance requirements,",
      "keywords": [
        "sound",
        "sound data",
        "sound buffer",
        "effects",
        "buffer",
        "audio",
        "Sound Sources",
        "sound system",
        "Sound Effects",
        "Audio Effects Applied",
        "data",
        "samples",
        "sound samples",
        "Real-Time Audio Effects",
        "Audio Effects"
      ],
      "concepts": [
        "sounds",
        "audio",
        "effective",
        "buffer",
        "design",
        "samples",
        "sampling",
        "data",
        "available",
        "game"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 38,
          "title": "",
          "score": 0.869,
          "base_score": 0.719,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 40,
          "title": "",
          "score": 0.763,
          "base_score": 0.613,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 35,
          "title": "",
          "score": 0.637,
          "base_score": 0.487,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 36,
          "title": "",
          "score": 0.623,
          "base_score": 0.473,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 37,
          "title": "",
          "score": 0.622,
          "base_score": 0.472,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "sound",
          "sounds",
          "effects",
          "sound data",
          "listener"
        ],
        "semantic": [],
        "merged": [
          "sound",
          "sounds",
          "effects",
          "sound data",
          "listener"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1629475049136764,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076105+00:00"
      }
    },
    {
      "chapter_number": 40,
      "title": "Segment 40 (pages 372-380)",
      "start_page": 372,
      "end_page": 380,
      "summary": "Audio Library Used for 3D and 2D Sound,” available online at http://www.\nLayered Mixing\nConsider the process of sound mixing.\nA game is mixed with much less control.\nThis gem presents a mixing system that brings the overall sound of a game under\nThis mixing system takes for granted the idea that game parameters can be tuned in\nAssociating a set of mixing parameters with each logical scene allows precise con-\nIt also allows each scene to be mixed inde-\nthat scenes can overlap and modify each other, making it also a layered mixing system.\nMixing System\nThe mixing system provides a central mixing interface to other systems in the game.\nMixing Categories\nThe mixing system groups related sounds into mixing categories.\nWhen a sound plays in the game, it is assigned a mixing category.\nThe Central Mix\nThe mixing system centralizes the mixing (or tuning) parameters for all sounds into a\nmix provides a set of parameters for each mixing category.\nConceptually, the central mix is like a mixing board through which all sounds in\nContext-Driven, Layered Mixing\nThe central mix acts as a mixing board for the game,\nMixing Snapshots\nThe sound designer works with the central mix in terms of sets of parameter values\nknown as mixing snapshots.\nMixing snapshots are like mixing board presets or fader\nautomation controls for the central mix.\nThe mixing system calculates the central mix using mixing snapshots pro-\nThe sound designer defines a mixing snapshot for each logical scene of the game.\nWhen the scene begins, a mixing event triggers, adding the associated snapshot to the\ncentral mix calculations.\nMixing snapshots give the designer complete control over each scene.\nity of this control depends on the number of scenes and the number of mixing categories.\n4.5.1 defines some example mixing snapshots and scenes.\nExample Mixing Snapshots\nremoved from the mix except \nMixing Layers\nMixing layers organize the mixing snapshots that are active.\nThe mixing snapshots are\n• The pre-mix layer contains one snapshot that is always present and never changes.\nFigure 4.5.4 illustrates the three mixing layers.\nThree mixing layers organize the active mixing snapshots.\ndisplay both the active mixing snapshots and the state of the central mix.\nmixing snapshots for each scene to be selected and tuned individually.\nmixing snapshot in the remote tuning application, and then mixing the scene while\nLive mixing through a\nTypically there may be four active mixing snapshots and 20 sound categories\nMemory requirements grow with the number of mixing snapshots and the num-\nLarge games may require several hundred mixing snapshots\nAn un-optimized mixing snapshot may require 512\nThe most effective optimization reduces the number of mixing snapshots held in\nAnother optimization stores mixing snapshot parameters as shorts instead of\nfloats, which halves the size of a mixing snapshot.\nCombining these optimizations, a 512 byte mixing snapshot becomes 256 bytes;\ntrigger sound effects and mixing events.\nUse the mixing board and related controls to\nselect and tune mixing snapshots and experience context-driven, layered mixing.\nThis gem discussed a powerful approach to sound mixing that has proven itself prac-",
      "keywords": [
        "Mixing",
        "Mixing Snapshots",
        "mixing system",
        "Snapshots",
        "Sound",
        "active mixing snapshots",
        "Central Mix",
        "Layered Mixing",
        "mixing board",
        "Mixing Layers",
        "Game",
        "system",
        "active mixing",
        "Mix",
        "central"
      ],
      "concepts": [
        "mixing",
        "mixed",
        "sound",
        "snapshots",
        "control",
        "controlling",
        "game",
        "gaming",
        "scene",
        "effects"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 39,
          "title": "",
          "score": 0.763,
          "base_score": 0.613,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 38,
          "title": "",
          "score": 0.681,
          "base_score": 0.531,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 35,
          "title": "",
          "score": 0.614,
          "base_score": 0.464,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 36,
          "title": "",
          "score": 0.57,
          "base_score": 0.42,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 50,
          "title": "",
          "score": 0.542,
          "base_score": 0.392,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "mixing",
          "snapshots",
          "mixing snapshots",
          "mix",
          "central mix"
        ],
        "semantic": [],
        "merged": [
          "mixing",
          "snapshots",
          "mixing snapshots",
          "mix",
          "central mix"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2572400999098147,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076157+00:00"
      }
    },
    {
      "chapter_number": 41,
      "title": "Segment 41 (pages 381-391)",
      "start_page": 381,
      "end_page": 391,
      "summary": "methods of procedural terrain generation using a method called particle deposition.\nAdvanced Particle\nbeauty of particle deposition lies within its versatility.\nadvancements to particle deposition that allow the creation of new types of terrain\nThese advances to particle\nWhy Particles?\nParticles can be used to naturally simulate the deformation of terrain by plate tec-\nParticle Deposition\nShankel proposed the original particle deposition algorithm as a way to generate terrain\nParticle deposition traverses\nThe random walker drops at least one particle at\nThe particle must check the height of the adjacent positions after\nIf a lower adjacent position is found, the particle moves to\nFigure 5.1.1 demonstrates a single particle descending a\nnumber of particles have been dropped or when the user is content with the results.\nure 5.1.2 shows an example of terrain created with particle deposition.\nDepositing a single particle.\nImproving Particle Deposition\nAlthough particle deposition does create interesting topography for volcanic moun-\nA screenshot of terrain generated with the original particle deposition algorithm.\nused to settle the particles on the terrain.\nParticles are not allowed to stack if there is a\nAdvanced Particle Deposition\nAnother limitation of particle deposition is there is no control over the placement of\nto particle deposition is that it only creates topography that is suitable for a volcanic\nthese limitations can be overcome with simple modifications to particle deposition.\nNotice that particle deposition can be broken into two main steps.\ndefines where to initially drop the particles.\nof particle deposition, you need to improve both particle placement and particle\nImproving Particle Dynamics\nAfter a particle is\ndetermine if the particle can move to a lower elevation.\nold of the particles placed on the slope.\nFigure 5.1.4.b shows how particles can accumulate to form a very steep\nIn (a), particles that search a large radius form a gentle slope.\nIn (b), particles with elevation thresholds larger than 1 form very steep slopes.\nThe search radius and elevation threshold of each particle can be chosen randomly,\nall of the particles were dropped at the same location to emphasize the change in slope\nfor each dropped particle:\nAdvanced Particle Deposition\nImproving Particle Placement\nThe particle placement heuristic defines where particles are initially dropped on the\nThis is a very important step in particle deposition.\nIf particle placement\nDifferent particle placement\ndifferent particle placement heuristics—each one designed to create a specific type of\nBefore you consider a suitable particle placement heuristic for volcanoes, it helps to\nOne possible particle placement heuristic for volcanoes would be to dump a lot of\nparticles at a single location until the stopping criteria are met.\nmore interesting particle placement heuristic, as demonstrated in Figure 5.1.6, is to\nThe pseudocode for this particle placement heuristic follows:\nthe total amount of particles dropped.\nnumber of particles have been dropped or when the peak of the volcano has reached a\nIf you implement particle deposition in a way that allows users to\npreview the size and general shape without dropping a single particle.\nParticle deposition can also create realistic mountains by using a clever particle place-\nimportant because it provides ideal locations where particles should be dropped, hence\nthe particle placement heuristic to generate mountains.",
      "keywords": [
        "particle deposition",
        "particle",
        "particle placement",
        "particle placement heuristic",
        "terrain",
        "deposition",
        "particle dynamics",
        "Advanced Particle Deposition",
        "particle deposition algorithm",
        "placement",
        "original particle deposition",
        "search radius",
        "slope",
        "search",
        "Advanced Particle"
      ],
      "concepts": [
        "particle",
        "random",
        "deposition",
        "depositing",
        "slope",
        "animation",
        "animating",
        "position",
        "positions",
        "graphics"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 42,
          "title": "",
          "score": 0.726,
          "base_score": 0.726,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "",
          "score": 0.391,
          "base_score": 0.391,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 49,
          "title": "",
          "score": 0.334,
          "base_score": 0.334,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 48,
          "title": "",
          "score": 0.326,
          "base_score": 0.326,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 44,
          "title": "",
          "score": 0.319,
          "base_score": 0.319,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "particle",
          "deposition",
          "particle deposition",
          "placement",
          "particles"
        ],
        "semantic": [],
        "merged": [
          "particle",
          "deposition",
          "particle deposition",
          "placement",
          "particles"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.17388629338320197,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:44.076205+00:00"
      }
    },
    {
      "chapter_number": 42,
      "title": "Segment 42 (pages 392-403)",
      "start_page": 392,
      "end_page": 403,
      "summary": "shows a Brownian tree that was created using DLA on a two-dimensional lattice.\nAdvanced Particle Deposition\nA volcano created using advanced particle deposition.\nber of particles have been dropped or when the Brownian tree covers a desired area or\nThen traverse the entire height field and drop a particle at every\nrange, like the lava streams of volcanoes, without needing to drop a single particle.\nsystems can be used to generate a tree-like structure suitable for the particle placement\nis formed as the wind rolls and tosses particles up the windward slope, and deposits\nthe particles on the leeward slope.\nOne obvious solution is to randomly pick particles off the height field and dis-\nThe missing key is that particles are more likely to be deposited\nAdvanced Particle Deposition\nMountains created using advanced particle deposition.\nchoose a random position and remove a particle\nmove the particle one position in the direction of the wind\nDunes are formed as particles are carried up the windward\nDunes created using advanced particle deposition.\nParticle deposition can create this type of terrain with some minor modifica-\ndropped on the terrain, and look at the path a particle takes as it falls toward the\nthe terrain, the stickiness of the falling particle will determine if the particle stops or\nAs shown in Figure 5.1.13, when very sticky particles brush the face\nfor each dropped particle:\ncheck the particle’s path as it falls toward the height field\nleave the particle at this position\nuse the heuristic discussed in the particle dynamics section\nAdvanced Particle Deposition\ncomplexity of particle deposition.\nParticle deposition is a powerful tool for creating various types of realistic terrain.\nparticle deposition.\nare just a few other examples of what might be possible using particle deposition.\nReducing Cumulative Errors\nTo deform the mesh into a new pose, you first use the inverses of the rest transforms\nbone transforms to move the vertices to their final positions.\nblend bone transforms than meshes.\nall but the root transform relative to its parent transform.\nPlayback of the parent-relative transforms is straightforward.\nthe root transform from the root translation and rotation tracks.\nof the root, you construct the child transform by concatenating the child rotation\nwith the parent transform.\non, until you have reconstructed the transform for every bone in the hierarchy.\ning the transforms parent-relative.\nFirst, any error at a transform higher\nAn error at the root transform,\nassume that the error at each transform behaves like a random variable (otherwise,\nFor parent-relative animations, you should be mostly concerned with rotation\nerror.\ncan be stored, and the animation data reduced to a series of angles.\nerrors at each rotation.\nsome possible reconstructed poses, given the same random error at each transform.\nThe parent transform is shown with its error range as a gray region.\nforms are shown with their error ranges, one aligned with the actual child transform,\nand the other two where the parent has the greatest error.\nEliminating Cumulative Rotation Errors\nNext, all child transforms are made parent-relative by concatenating with the parent’s\nReducing Cumulative Errors in Skeletal Animations\nstruction algorithm to get the parent transform with error, and make the child trans-\nforms parent-relative to that transform rather than the original.\n1. Compress and format the root transform data.\n3. For each child of the root, make its transform data relative to the decompressed\nroot transform data.\nCompress and format the parent-relative rotation data.\ntransform data and replace the original child data with the result.\nThis completely eliminates the accumulation of rotational error because for each\nchild transform, Step 3 subtracts the rotational error of the parent transform.\nthe parent’s rotation error does more than just rotate the child.\nrelative transform resulting from Step 3 will generally have a translation that is differ-\nSo translation error is still\nrotation error is less.\nlocal error), and how they are offset by the translation error as a result of the rotational\nerror of the parent bone.\nCumulative error increases from parent to child.\nIt is possible to reduce this translation error, but to do this you have to rotate the\nfixed point on the bone where you would like to minimize the translation error.\nbone from Algorithm 1 so as to move the significant point closest to its true position.\nReducing Cumulative Errors in Skeletal Animations\nRemoving cumulative rotational error.\nReducing translation error at\n1. Compress and format the root transform data.\na. Make its transform data relative to the decompressed root transform data.\nreconstructed transform, without error.\nd. Compress and format the parent-relative rotation data.\ntransform data and replace the original child data with the result.\nthe child bones now have slight rotation errors (although they don’t accumulate, as\neach step still corrects for the parent’s error) and how the translation error has been\nReducing cumulative translational error.\nAlgorithm 2 does not completely eliminate translational error.",
      "keywords": [
        "Particle",
        "Particle Deposition",
        "error",
        "Brownian tree",
        "transform",
        "Advanced Particle Deposition",
        "Brownian",
        "transform data",
        "child",
        "algorithm",
        "data",
        "root transform",
        "translation error",
        "rotation",
        "root transform data"
      ],
      "concepts": [
        "particle",
        "errors",
        "transform",
        "animations",
        "animation",
        "animated",
        "animate",
        "bone",
        "rotation",
        "rotations"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 41,
          "title": "",
          "score": 0.726,
          "base_score": 0.726,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "",
          "score": 0.344,
          "base_score": 0.344,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 19,
          "title": "",
          "score": 0.33,
          "base_score": 0.33,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "transform",
          "error",
          "particle",
          "parent",
          "child"
        ],
        "semantic": [],
        "merged": [
          "transform",
          "error",
          "particle",
          "parent",
          "child"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.143492977797684,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:44.076251+00:00"
      }
    },
    {
      "chapter_number": 43,
      "title": "Segment 43 (pages 404-412)",
      "start_page": 404,
      "end_page": 412,
      "summary": "“Trends of Character Animation in Games,” available\n“Quaternion Compression,” Game Program-\nShading of Diffuse Light \nhis gem shows how it is possible to improve the shading of rough materials with\na rather simple shading model.\nbackscattering effect.\nUsually Lambert’s model (cosine law) [Foley97] is used to compute the diffuse light,\nin the sense that the surface scatters light equally in all directions.\nThese models assume that the surface consists of small v-\nOren and Nayar proposed a model for diffuse light suitable for rough\nThis model can be used for rough surfaces,\nmore accurate diffuse light for rough surfaces.\nThe Lambert model will produce shadings which drop off gradually and this is\nThis effect is shown in Figures 5.3.1 and 5.3.2.\nthe intensity is not scaled down for the Lambert shaded teapot in Figure 5.3.1 and\ntherefore it appears brighter than the teapot rendered with the Oren-Nayar model in\nover the surface for the Oren-Nayar model.\nThe Flattening Effect\nOne of the main differences between Lambert’s model and the Oren-Nayar model is\nthat the Oren-Nayar model produces diffuse light that is almost equally bright over the\nsurface.\nThis flattening effect can be modeled by forcing the diffuse light to be closer to\nwhere cosθ= n·l is the Lambert’s law, ρ is the surface roughness property that tells how\nAn Alternative Model for Shading of Diffuse Light for Rough Materials\nnew model with ρ = {0.75, 1.5, 3.0, and 6.0}.\nIn Figures 5.3.4 through 5.3.7, the effect of using the method is shown for a\nNotice how the surface appears flatter when ρ increases.\nThe backscattering effect is visible in many materials and it is a contributing reason to\nsubtle effect and it is quite hard to notice it in real life and it should therefore be used\nBecause it is visible only when the light source is in the same direction as\nthe viewer, it could be modeled using l·v.\nAn Alternative Model for Shading of Diffuse Light for Rough Materials\nρ is the surface roughness property\nHere the surface roughness prop-\nsurface appears flatter when ρ increases.\nThis function determines how the effect will be distributed over the surface in a\nThe constant b will determine how much impact the backscattering effect should\nIn Figure 5.3.9, it is clear that the backscattering effect vanishes as the viewer is\nmodel.\nThe constant Kks determines how much the effect will be visible and once again\nthe function f determines how the effect will be distributed over the surface.\nAn Alternative Model for Shading of Diffuse Light for Rough Materials\nThe Oren-Nayar model is rather complex while the proposed model is quite simple\nYou saw two possible ways of computing the backscattering effect and it is hard to",
      "keywords": [
        "Diffuse Light",
        "Model",
        "Light",
        "Rough Materials",
        "effect",
        "surface",
        "Alternative Model",
        "Oren-Nayar model",
        "Diffuse",
        "light source",
        "backscattering effect",
        "Rough",
        "rough surfaces",
        "Materials",
        "backscattering"
      ],
      "concepts": [
        "model",
        "game",
        "surface",
        "float",
        "figures",
        "light",
        "curve",
        "shading",
        "differences",
        "different"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 47,
          "title": "",
          "score": 0.495,
          "base_score": 0.495,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 46,
          "title": "",
          "score": 0.302,
          "base_score": 0.302,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "light",
          "diffuse light",
          "effect",
          "model",
          "diffuse"
        ],
        "semantic": [],
        "merged": [
          "light",
          "diffuse light",
          "effect",
          "model",
          "diffuse"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.13154750668653842,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:44.076295+00:00"
      }
    },
    {
      "chapter_number": 44,
      "title": "Segment 44 (pages 413-428)",
      "start_page": 413,
      "end_page": 428,
      "summary": "Subdivision Surfaces\nVertex\nVertex\nVertex\nsubdivision surfaces have many other uses, including:\nMost 3D animation and rendering packages support subdivision surfaces as a\n• Creases—Allow sharp edges and surface ridges.\nHigh-Performance Subdivision Surfaces\nmesh, users can work on any level of the subdivision, making many editing fea-\nFeatures are added to the mesh by tagging vertices, faces, and edges with parame-\nTo implement boundaries, creases, corners, and semi-smooth features, each vertex\nand edge is tagged with a floating-point weight 0 ≤w < ∞.\ndard Loop subdivision, and ∞denotes an infinitely sharp crease or boundary.\nLoop subdivision takes a mesh and creates a new mesh by splitting each old trian-\nfirst step inserts a new vertex on each existing edge, and the second step modifies old\nvertices (not those inserted on the edges).\nEdges\nThe first step inserts a new vertex on each edge using a weighted sum of nearby vertices.\nThe edge weights and the types of vertices at each endpoint of the edge serve to catego-\nEach (non-boundary) edge has two adjacent triangles; the new vertex has the posi-\ntion (v0 + v1), where v0 and v1 are the vertices on the edge to split, and the other two \nFigure 5.4.1, where the circle denotes the new vertex on the edge between the triangles.\nHigh-Performance Subdivision Surfaces\nThe weights used to create a new edge depend on the edge weight and the vertex\ntypes of the two vertices that define the edge: v0 and v1.\nedge, Table 5.4.2 shows which type of weights to use to create the new edge vertex.\nweight goes with the corner edge.\nAn edge is smooth if it has weight w = 0.\nAn edge is sharp if its weight is w ≥0.\nan edge has weight 0 < w < 1, the new vertex is linearly interpolated between the two\nWhen an edge is split, each new edge gets weight ˜w = max{w–1,0}.\ncontrol is to tag each end of an edge with a weight, giving two weights per edge, to\ninterpolate the new edges, and then to make the corresponding changes throughout.\nThe type of a vertex depends on the vertex weight and the types of incident edges.\nsmooth vertex is one with zero incident sharp edges and weight 0.\nsharp incident edge and weight 0.\nA crease vertex has two sharp incident edges and\nA corner vertex has > 2 sharp incident edges or has weight w ≥1.\ncrease vertex is regular if it has six neighbors and exactly two non-sharp edges on each\nside of the crease; a boundary crease vertex is regular if it has four neighbors.\nIf an edge has weight 0 < w < 1, it suffices\nThe second step of Loop subdivision modifies all the original vertices (not the\nvertices inserted on each edge in step one) using a weighted sum of the original vertex\ncurvature for a few valences.) The old vertex is given weight 1 – b(n)  and each old\nneighbor (not the vertices created in step one!) is given weight b(n)/n to determine\nthe new vertex position, which is then the weighted sum of all these vertices: \nFor corner vertices, the vertex position does not move, so vnew = vold.\nFor crease vertices, the new vertex is the sum of \nIf a vertex has weight 0 < w < 1, the new vertex is linearly interpolated between\nA new vertex also has a new weight ˜w = max{w–1,0}.\nThe final case is when a vertex has weight 0 < wv < 1 and some neighboring edge\nLimit positions v∞are computed from a weighted sum of the current vertex v0\nHigh-Performance Subdivision Surfaces\nVertex and Crease Normals\nat each vertex.\nvertex for corners, and must be done for each face.\nBesides geometry, a full solution needs colors, textures, and other per-vertex or per-face\nsame subdivision methods when new vertices are added.\nHowever, all internal points on a subdivided face become per-vertex parameters.\ndisplaced subdivision surfaces (which add geometry by using a “texture” map to offset\nand displaced subdivision surfaces are covered in [Bunnell05] and [Lee00].\nHigh-Performance Subdivision Surfaces\nmanipulate subdivision surfaces including half-edge, winged-edge, hybrid, and grids\nFor Loop subdivision, the data structure should allow finding neighbor\nvertices and incident edges easily, and preserve this ability on each level of subdivision.\nitems are arranged into vertex arrays, normal arrays, and so on, using indices to render\n• Vertices array VA—Each vertex is a three-tuple x, y, z of floats, and a float sharp-\nness weight 0 ≤w < ∞, with 0 being smooth, and a half-edge index vh of a half-\nedge ending on this vertex (for fast lookup later).\nthe boundary half-edge index ending on the vertex.\n• Faces array FA—Each face represents a triangle, stored as three indices v0,v1,v2\ninto the vertex array.\ncolor, texture, and other rendering information, per face or per vertex as desired.\n• Half-edge array HA—Each face has three (half) edges in the half-edge array,\nThus, a face with index f and (ordered) vertex indices\n{v0,v1,v2} has ordered half-edges with indices 3f, 3f+1, and 3f+2, denoting half-\nedges from vertex v0 to v1, v1 to v2, and v2 to v0, respectively.\nNote that half-edges\nhalf-edge entry is two values: an integer marking the pair half-edge index or a –1\ning half-edge pair must have the same crease values to avoid ambiguity.\na half-edge index determines the corresponding face index, which in turn deter-\nmines a start and end vertex for the directed half-edge.\nfeatures cleanly, you need one normal per vertex per face, but for many vertices\nBesides storing the size of each array, the number of edges E (where a matching\npair of half-edges or a boundary edge constitutes a single edge) is stored.\ntoo costly to compute if the mesh has no boundary (E=# half-edges/2 = #faces*3/2),\nand can be computed otherwise by scanning the half-edge array and setting E=(size of\nInformation about vertex types (smooth, crease, and so on) may also be stored on\nIf a half-edge is not paired (it is on a\nboundary), it has pair index –1, and must have infinite crease weight.\nEach half-edge of the same edge must have the same weight; other-\nHigh-Performance Subdivision Surfaces\nof data are stored to speed up loading so all items such as paired edges do not need to\nOptional subdivision info giving number of vertices, faces, edges,\nOne entry per face with one-based vertex indices, oriented.\nHalf-edge data, one entry for each half-edge, in the order de-\nscribed by the faces, in half-edge order v0 →v1, v1 →v2, v2 →v0.\nEach entry is a one-based integer edge pair index j (or –1 for a\nOptional face colors, one per vertex, RGBA, [0,1] floats.\nper vertex.\nfaces, H = 3F = # of half-edges, and #E = number of edges = (H + # boundary edges)/2.\n1. Compute new edge vertices.\n4. Create new half-edge information.\nComputing New Edge Vertices\nFollow these steps to compute the new edge vertices:\nadded per edge, you allocate an array NV for all new vertices of size (# old\nvertices + # edges).\nWhen creating new edge vertices, the first V positions in\n2. Allocate an array EM (edge map) of integers of size (# half-edges) to store\nindices mapping half-edges to new vertex indices.\ncate half-edges not yet mapped.\n3. For each half-edge h, if EM[h] = –1, insert a vertex on the edge using the\nhas a paired half-edge h2, so store the NV index in EM[h2] also.\nNow you must move each original vertex to a new position, placing the new vertex in\nthe new vertex array NV, in the same order and position as before to make splitting\nNew vertices have weight 0.\ntex stores a half-edge index vh ending on the vertex, which is used to quickly walk\nneighboring vertices and determine edge types, as shown in Figure 5.4.4.\nedge index h ending at the vertex, the joined neighbor vertex is VA[FA[Floor[h/3]].ver-\n. With this information, the edges and neighboring vertices\nThe reason for requiring a boundary vertex to be tagged with an incoming crease\nAfter all updates, change all vertices (new and old) to have a half-edge index of\n–1, which denotes no incoming matching half-edge.\nshows the original triangle with edge and face orientations, and how this maps to new\nedge and face orientations, along with the order (0, 1, 2, 3) in which the new faces are\nHigh-Performance Subdivision Surfaces\n2. For each face f, with vertex indices v0,v1,v2, look up the three edge vertex\n4. During the face split, tag each vertex (which still has a –1 tag from the pre-\nvious steps) with an incident half-edge index ending on the vertex, giving\nCreating the New Half-Edge Information\nof half-edges is needed, correctly paired and weighted.\nCreate a new half-edge array NE\nDefine a function nIndex(j,type) to compute new half-edge pair indices, where\nj is the old half-edge index, and type is 0=A or 1=B, denoting which part of the new\nhalf-edge is being matched.\n/* data table for index offsets - matches new half-edges */\n/* original half-edge pair index */\nreturn –1   /* boundary edge */\n/* new position of the split-edges for the face with pair op */\nThe {3,1,6,4,0,7} array comes from matching half-edges to neighboring half-\n1. Let b=12*f be the base half-edge index for a set of new half-edges, which will\n2. Store the 12 new half-edge pair indices at b,b+1,…,b+11 in the following\n3. In the previous 12 entries, update the half-edge weights, with descendent\nhalf-edges getting the parent half-edge weights –1, clamped at 0.\nedges with no parent get weight 0.\nPer-vertex colors and per-vertex texture coordinates can be updated during the edge\nface per vertex colors and textures coordinates can be interpolated in the previous\nHigh-Performance Subdivision Surfaces",
      "keywords": [
        "Vertex",
        "Subdivision Surfaces",
        "Subdivision",
        "edge",
        "vertices",
        "Loop subdivision",
        "High-Performance Subdivision Surfaces",
        "Face",
        "half-edge",
        "Surfaces",
        "weight",
        "crease",
        "mesh",
        "normals",
        "half-edge index"
      ],
      "concepts": [
        "vertex",
        "edge",
        "subdivision",
        "subdivisions",
        "faces",
        "surfaces",
        "mesh",
        "meshes",
        "weight",
        "vertices"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 45,
          "title": "",
          "score": 0.608,
          "base_score": 0.608,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "",
          "score": 0.442,
          "base_score": 0.442,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "",
          "score": 0.441,
          "base_score": 0.441,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 21,
          "title": "",
          "score": 0.415,
          "base_score": 0.415,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 49,
          "title": "",
          "score": 0.393,
          "base_score": 0.393,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "edge",
          "vertex",
          "half",
          "half edge",
          "edges"
        ],
        "semantic": [],
        "merged": [
          "edge",
          "vertex",
          "half",
          "half edge",
          "edges"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2256241984569033,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:44.076343+00:00"
      }
    },
    {
      "chapter_number": 45,
      "title": "Segment 45 (pages 429-442)",
      "start_page": 429,
      "end_page": 442,
      "summary": "If the surface is about to be rendered, temporary normals can be computed using\nappropriate on a surface with vertices at limit points.\n• Tag edges and vertices for whether they are smooth or need special case code,\n• Pre-compute one level of subdivision to isolate the special case vertices, and then\n• A pointer-based data structure like a half-edge structure can speed up subdivision\nsmooth new vertices can (and should) use per-vertex normals.\n• Do multiple subdivision steps at once if desired, storing only the resulting triangles,\n• Implement adaptive subdivision.\nGPU Subdivision and Rendering\nI dropped my original plan to present a state-of-the art GPU subdivision renderer\n1-neighborhood to a rendering function, which then renders the two triangles to\n• [Bolz02] implements Catmull-Clark subdivision, using a static array to hold the\n• [Bolz03] implements Catmull-Clark subdivision on a GPU, with special attention\n• [Boubekeur05] presents a general method useful for rendering many types of\nsubdivision surfaces.\n• [Bunnell05] and [Shiue05] both implement Catmull-Clark subdivision on a\nHigh-Performance Subdivision Surfaces\nFast Subdivision Surface Rendering\nrender time, a subdivision level is selected, and each patch is passed to a GPU kernel.\nneighboring triangles may be evaluated using floating point operations in different\nThis article showed details of how to implement Loop subdivision surfaces with addi-\ntional features and provides a starting point for the literature on subdivision surfaces.\ncovered, as well as surface tags like colors and textures.\nadd displaced subdivision surfaces and adaptive subdivision to the algorithm.\nSubdivision Surfaces with Normal Control,” Proceedings of the 27th Annual Con-\nHardware Implementation of Loop Subdivision,” Eurographics SIGGRAPH\nSubdivision Surfaces,” Web3d 2002 Symposium, available online at http://\n“Evaluation of Subdivision Surfaces on\nment on GPU,” ACM SIGGRAPH/Eurographics Graphics Hardware, 2005.\nDisplacement Mapping,” GPU Gems 2, 2005, pp.\nSmooth Surface Reconstruction,” Computer Graphics, SIGGRAPH 94 Proceed-\nSurfaces,” SIGGRAPH 2000, pp.\n“Subdivision Surfaces for Character Animation,” Game\nHigh-Performance Subdivision Surfaces\n“Smooth Subdivision Surfaces Based on Triangles,” Master’s\n“Fast Rendering of Subdivision Surfaces,” Pro-\n“Analysis and Application of Subdivision Surfaces,”\n“Evaluation of Loop Subdivision Surfaces,” SIGGRAPH 99\nAnimating Relief Impostors\nTextures\nnormal maps and carefully crafted textures are used to produce impressive scenarios\nrelief textures [Oliveira00] (textures containing depth and normal data on a per-texel\nRelief rendering simulates the appearance of geometric surface detail by using the\nRelief impostors are obtained by mapping relief textures containing multiple layers of\nTextures in general can be used to represent both static and animated objects, and\ntexture-based animation traditionally uses techniques such as image warping or a set\napproach requires as many textures as frames in the animation sequence, which, in\nThis gem describes a new technique for animating relief impostors based on a sin-\ngle multilayer relief texture using radial basis functions (RBF).\nframes of a dog walking animation sequence created from a dog relief impostor.\nThree frames of a dog walking animation created by warping a relief impos-\nifies a set of control points over the texture of the relief impostor.\npoints in 2D warps the texture, thus bringing the represented objects into new poses.\nposes are only implicitly represented by the control points and by a single texture.\nthese control points for the desired number of frames in the animation and, for each\nThe control points\nand their corresponding RBF coefficients define a series of warping functions that\nThe proposed technique can be used to animate essentially any kind of texture-\nbased representations, such as relief textures [Oliveira00], billboards with normal\nAnimating Relief Impostors Using Radial Basis Functions Textures\nControl points (dark dots) placed over the texture of the relief impostor (top\nrow) warp the texture, changing the pose of the rendered dog (bottom row).\nimplicitly represented by a single texture and the sets of control points.\nWarping-based texture animation evaluates a function over the source image in order\nGiven a source image, a warping function\ngenerate the mapping function from a set of corresponding points [Ruprecht95].\nthe RBF representation, ci is the i-th center, and x is a point for which the function\nIn the case of image warping, ci represents the pixel coordinates of\nthe control points, and x represents the pixel coordinates of any pixel in the image.\ndinates, fkx and fky are, respectively, the x and y image coordinates of control point ck.\nobtained by interpolating the coordinates of the corresponding pairs of control points\nWhen using normal maps, the same warping approach has to be applied to the nor-\nThus, both textures must be evaluated using the same RBF for each\nAnimating Relief Impostors Using Radial Basis Functions Textures\nEvaluating the Warping Function Using Shaders\nAs the warping function needs to\nfragment f, you must be able to obtain the texture coordinates that were mapped to f\n• Compute φij using the coordinates of the control points of the current (desired)\n• Use the x and y coordinates of the unmodified (before moving) control points as\nFor the example shown in Figure 5.5.2, the RBF coefficients used for rendering\ncoordinates of the k-th control point shown in the top left.\npoints and lambda values) into a texture for access by the shader during runtime.\nj-th row of this a texture represents the j-th frame of the animation.\nWe used a float32 non-normalized texture, because\nThe animation data is stored in single texture.\nthe texture represents a frame of the animation.\nstores the (x,y) coordinates of the control point ci as well as its λix and λiy\nThe shader for evaluating the RBF-based warping function is shown next.\ntexture coordinates of the current fragment (obtained after rendering a texture-mapped\nEvaluating the RBF-Based Warping Function\n// of control points, the actual time and smoothness.\nAnimating Relief Maps\nYou can produce RBF-based animations of relief maps by adding a couple of extra\nsearch, you should clamp the original texture coordinates to the [0,1] range.\n// s is the texture coordinate used in the relief mapping shader\nfloat2 sRBFEval = evaluateRBF(sZeroOne.xy, points, keyTime,\nAnimating Relief Impostors\nFigure 5.5.5 (right) shows a dog impostor modeled as a quad-layer relief texture,\nFor the case of relief impostors, the warping\nAnimating Relief Impostors Using Radial Basis Functions Textures\nexample, however, the animation was created using a single warping function by\nThese parameters represent the warped texture coordinates\ndepth and normal maps from different layers.\ncase of the x-component of the normal map, where the retrieved values are combined in\n(The x and y components of the normal map are\nstored in separate textures, normal_map_x and normal_map_y, respectively.\nA dog impostor modeled as a quad-layer relief texture.\nUsing a Single Warping Function to Produce the Walking Motion Shown\nUsing Texture Coordinates sFront and sBack\nfloat4 normal_x;\nnormal_x.xy=tex2D(normal_map_x,sFront.xy).xy;\nnormal_x.zw=tex2D(normal_map_x,sBack.xy).zw;\nThe following code fragment uses sFront and sBack to sample the color texture.\nSampling the Color Texture Using Texture Coordinates sFront and sBack\nfloat4 cFront = tex2D(texture,sFront.xy);\nfloat4 cBack  = tex2D(texture,sBack.xy);\nanimate several textures and relief impostors.\nand 500fps, when rendering animations of textures with normal maps, relief maps,\nuser moves a control point, the underlying texture is automatically warped, providing\nAnimating Relief Impostors Using Radial Basis Functions Textures",
      "keywords": [
        "subdivision surfaces",
        "subdivision",
        "Radial Basis Functions",
        "control points",
        "Loop subdivision surfaces",
        "Basis Functions Textures",
        "Relief Impostors",
        "texture",
        "Relief",
        "warping function",
        "surfaces",
        "Animating Relief Impostors",
        "points",
        "GPU Subdivision",
        "Subdivision Surface Rendering"
      ],
      "concepts": [
        "textures",
        "subdivision",
        "points",
        "float",
        "animation",
        "animating",
        "animations",
        "animate",
        "surface",
        "warps"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 44,
          "title": "",
          "score": 0.608,
          "base_score": 0.608,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 60,
          "title": "",
          "score": 0.561,
          "base_score": 0.411,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 46,
          "title": "",
          "score": 0.531,
          "base_score": 0.381,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 47,
          "title": "",
          "score": 0.519,
          "base_score": 0.369,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 49,
          "title": "",
          "score": 0.511,
          "base_score": 0.361,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "subdivision",
          "relief",
          "texture",
          "subdivision surfaces",
          "surfaces"
        ],
        "semantic": [],
        "merged": [
          "subdivision",
          "relief",
          "texture",
          "subdivision surfaces",
          "surfaces"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21980490042365308,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076392+00:00"
      }
    },
    {
      "chapter_number": 46,
      "title": "Segment 46 (pages 443-452)",
      "start_page": 443,
      "end_page": 452,
      "summary": "Control points (dark dots) used to define the RBF-based warping functions\npoints, four extra control points were positioned at the corners of the texture to anchor it.\nused to produce this animation, including 4 anchors at the corners of the texture.\nanimate essentially any kind of texture representation.\ninto a texture with the 2D coordinates of the control points.\nthen read during runtime by a shader that performs the actual animation via texture\nof a relief texture.\ntexture animation.\nAnimating Relief Impostors Using Radial Basis Functions Textures\nTexture Mapping,” Proceedings of  SIGGRAPH 2000, New Orleans, LA, July\nClipmapping on SM1.1 \nBasic Concepts of Clipmaps\nRegardless of how much detail its texture\nthe texture (see [Forsyth07]).\nWhat can be done to deal with terrain textures efficiently?\nClipmaps are a generalization of mipmapping that allow you to only load subsec-\nAlthough clipmaps aren’t directly supported by current\nImplementation of Clipmaps\njected into texture space, and based on its size, a mipmap is selected and from it a\nClipmaps take the same basic idea, but the more detailed levels of the mip pyra-\nThis means that a 32KB px texture, which\nclipmap with a maximum level size of 512px, would only use six 512px textures’\nworth of memory, plus a “cap” 512px texture with a full mip chain.\nlevels, checked to see if the cached clipmap region in memory covered the area of the\nin each layer of the clipmap by purging old data and uploading new data from a data-\nAdvantages of Clipmaps\n• Clipmaps are straightforward to implement on any hardware with programmable\nClipmapping on SM1.1 and Higher\nUpdating clipmaps affect which areas are\nbounded—just the new texels that need to be uploaded for a single clipmap level,\nDrawbacks of Clipmaps\nThe major drawback of clipmapping is that it cannot deal with varying detail levels.\nDetail simply falls off linearly in texture space from the focal point.\nin texture space may need to be high detail (for instance, the floor and walls may have\nThe full un-optimized shader for clipmapping is also expensive and requires at\nSM3 and higher to write a more efficient clipmapping shader.\nDetails of Clipmaps\nThe following sections explain and describe the details related to clipmaps, including\nclipstack size, the focus point, and methods for updating clipmaps.\nThe size of the textures in the clipmap stack is the main variable when working with\ndata needed for an optimal renderer; the most demanding situation possible, texture-\nmuch as possible without magnification of the original texture.\nIn this case, a texture\nSelecting the focus point, which is the location in UV space of the clipmap where detail\nThere are three broad paths for getting data into the style of clipmap discussed here.\nThey all do roughly the same thing: updated regions are identified by the clipmap\ndata is in system memory, you only need to directly upload it to the GPU.\nFinally, you can perform synthesis on GPU by doing render to texture operations.\nThis requires allocating the clipstack textures as render targets to begin with, but oth-\nImplementing Clipmaps\nThe following sections cover the details related to implementing your clipmaps.\nFor simplicity’s sake, this gem discusses only the SM2.0 clipmap path in-depth.\nThis is the core pixel shader code that drives the clipmap effect in the demo app\nIn the SM2.0 path, you do all the clipmap level selection calculations per-pixel.\nvia uniform shader constants, produce a texture coordinate for each clipstack entry by\nstack entry based on distance in texture space from its focal point.\nClipmapping on SM1.1 and Higher\nA major optimization in the clipmap scheme is to treat the clipstack textures as\nyou only do work to upload new data.\nthat’s contained in the clipstack’s texture.\nized texture.\nThe size of the clipstack texture is only 1/16th the size of the full source level.\nSuppose you’re on the third level of the clipmap from the top.\nthe size of the clipstack texture is only 1/16th the size of the full source level.\nThe grid shows how the texture is mapped to the\nBy uploading the texture data in the pattern shown to the right, you end\nthe clipstack textures.\nbasic idea of what’s going on and how uploaded data has to map into the texture to be\nClipMap::fillWithTextureData implements this to refill the clip-\nClipmapping on SM1.1 and Higher\nThe inverted L-shaped region is what you need to upload.\nlar regions in the texture where data is to be uploaded.\nclipmap updates—moving the focus point one pixel means a rectangle only one pixel\nSee ClipMap::recent for the implementation of this.\ngled to 1 to enable a simple CPU synthesis that chooses a random color for each clipmap\nBy default, the example app loads data into the clipmap from a large image stored in\nAdvanced Clipmapping\nThe following sections cover some advanced issues related to clipmaps, including",
      "keywords": [
        "texture",
        "clipmap",
        "Data",
        "Control points",
        "Radial Basis Functions",
        "level",
        "Graphics",
        "point",
        "relief",
        "mip levels",
        "Basis Functions Textures",
        "Graphics FIGURE",
        "clipmap level",
        "GPU",
        "size"
      ],
      "concepts": [
        "texture",
        "data",
        "animation",
        "animations",
        "animating",
        "animate",
        "updating",
        "update",
        "functions",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 48,
          "title": "",
          "score": 0.714,
          "base_score": 0.564,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 49,
          "title": "",
          "score": 0.6,
          "base_score": 0.45,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 47,
          "title": "",
          "score": 0.565,
          "base_score": 0.415,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 60,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 45,
          "title": "",
          "score": 0.531,
          "base_score": 0.381,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "clipmap",
          "texture",
          "clipmaps",
          "clipmapping",
          "clipstack"
        ],
        "semantic": [],
        "merged": [
          "clipmap",
          "texture",
          "clipmaps",
          "clipmapping",
          "clipstack"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22207728498369733,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076442+00:00"
      }
    },
    {
      "chapter_number": 47,
      "title": "Segment 47 (pages 453-467)",
      "start_page": 453,
      "end_page": 467,
      "summary": "An Advanced Decal System\nmapping in your decals.\nWhen rendering a bump mapped decal on top of existing\nbump mapped geometry, the lighting is not correct, because the pixels underneath \nthe decal should also have been lit using a combination of the decal bump map and the\ngeometry bump map.\nThis gem explains how to render decals that actually replace the\nbump and the diffuse map of the geometry (this can be extended to any kind of tex-\nture map you use), thereby giving correct lighting results and a higher image quality.\nfrom at least two different maps (if you only want to use it for diffuse textures), or\nNormal Decals Method\nIn a traditional engine using a decal system, you first render all the geometry in the\nframe buffer, and on top of that you render polygons containing the decals, usually\nAdvanced Decals Method\nsary tools in the runtime to accomplish the decal renderer.\nor any other format of render target if your bump maps are stored in higher precision.\nIn our demo, we use DXT5 compressed bump maps so 32-bit RGBA will suffice.\nFirst, you generate the decal\nbuffers, and next you render the scene with the decals applied.\nTo generate the decal\n• Render all depth values of the geometry in the main z buffer (excluding the decals).\n• Render all decal geometry into that render target, using the same depth compare\nas you would in the normal decal case.\nRender the decal geometry,\nthis time using the bump map texture value in world space as output.\ngeometry is change the code that makes the diffuse texture lookup and the bump tex-\nbe used as texture coordinates to read out the values of the render targets.\n• Use the texture coordinates to read the diffuse RGB value from the decal diffuse\nAn Advanced Decal System\nThe DiffuseRenderTarget used by the decal system.\nThe BumpRenderTarget used by the decal system.\ning formula, where dt is the diffuse texture of the object, drt is the render target\ntexture containing the decal diffuse value, and d is the resulting diffuse value:\n• Read the value stored in the decal bump map; store it in the variable brt.\ndrt is the render target texture containing the decal diffuse value, brt is the render\ntarget texture containing the decal bump value in world space, and b is the result-\nDecals using the traditional technique.\nrender target with 8bits per component and store the bump maps as color values,\nthe pixel shader, all values are normalized floats, where 0 maps to 0 and 255 maps to\nAn Advanced Decal System\nDecals using this technique.\nThis allows you to store bump maps in a compressed format, while still maintain-\nAdvantages of This Advanced Decal System\nnormal bump maps.\nIt also allows decals to be used in different ways.\nimagine using decals that only contain bump maps to influence the look of a repetitive\nInstead of only using decals in the\nCreating the same diversity in an engine supporting standard decals would require\ndecals, you would have to actually create bump maps for each part of the scene where\nrequires more work from artists to create and place those bump maps on the geometry.\nfectly blend in an erosion bump map by playing with the opacity value of the decal.\nBecause you use the depth buffer in the decal system, it supports non-planar\ndecals.\nThe only constraint is that the decals have to follow the geometry underneath\nAn example of decals on non-planar geometry is shown in Figure 5.7.6.\nAn Advanced Decal System\nUses of decals for erosion over time.\navailable, you can add the render to the two decal render targets right after that pre-\nmap textures when rendering the scene in order to read from the decal buffers.\nengines, without using decals.\n• Normal decals—Regular decals rendered on top of the geometry rendered using\nA decal consists of a diffuse texture and a bump texture.\n• Advanced (Original)—Renders the decals into the decal buffers, but uses the shader\nof the original to render the objects on the scene, so no decals are shown.\nallows you to see the cost of filling the two decal buffers.\nDecals on non-planar geometry.\nadvanced decals.\ntextures of the same sizes assigned to decals.\nAn Advanced Decal System\nthat almost all decals were visible covering both close and distant scene objects.\nBut how does that difference depend on the complexity of decals?\ndecal multiple times on our scene to see how this would influence performance.\nThe second test shows the cost of actually rendering the decals themselves.\nAs you can see in Figures 5.7.9 and 5.7.10, when only using one decal the stan-\ndering multiple standard decals on top of each other, the complex shader, which does\nthe lighting and bump mapping, is executed once for each decal being rendered, while\nin the advanced decal’s case, the complex shader is only executed once, even when\nIf your rendering pipeline is memory or API-call bound, all decal buffers (tex-\ndecals only one time.\nmuch more rendering than just rendering objects with decals.\nSomething else to consider is that by using these decals,\nSo the cost of using those decals ends up being less than 12%,\nOn the CD-ROM, you can find a demo of this decal system.\ntional decals, and tweak certain rendering settings.\nand bump maps are combined with the decal maps, to get a better understanding of\nThis gem covered a way of rendering decals that has several advantages over the tradi-\ninstance, decals can be applied that only contain a bump map and no diffuse texture.\nAn Advanced Decal System\nMoreover, when pushing this further, you can use decals\nAnother possibility is to add decals\n“A Post-Processing Decal Texture Mapping Algorithm",
      "keywords": [
        "Advanced Decal System",
        "decals",
        "Decal System",
        "Advanced Decal",
        "bump maps",
        "bump",
        "decal bump map",
        "bump map",
        "render",
        "decal buffers",
        "render target",
        "maps",
        "Advanced",
        "decal bump",
        "texture"
      ],
      "concepts": [
        "rendering",
        "render",
        "textures",
        "decal",
        "values",
        "performance",
        "performed",
        "levels",
        "color",
        "support"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 48,
          "title": "",
          "score": 0.624,
          "base_score": 0.474,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 46,
          "title": "",
          "score": 0.565,
          "base_score": 0.415,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 45,
          "title": "",
          "score": 0.519,
          "base_score": 0.369,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 43,
          "title": "",
          "score": 0.495,
          "base_score": 0.495,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 49,
          "title": "",
          "score": 0.473,
          "base_score": 0.323,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "decal",
          "decals",
          "bump",
          "render",
          "maps"
        ],
        "semantic": [],
        "merged": [
          "decal",
          "decals",
          "bump",
          "render",
          "maps"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1711105533132825,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076489+00:00"
      }
    },
    {
      "chapter_number": 48,
      "title": "Segment 48 (pages 468-478)",
      "start_page": 468,
      "end_page": 478,
      "summary": "Mapping Large Textures for\n(antonio.seoane@videalab.udc.es), (jtaibo@udc.es),\nClassical techniques are based on the tiling of large textures or blending\ndetail textures.\nThis technique decouples the handling of texture\nlarge means larger than the texture size limit and/or the available video memory),\nThe levels\ntiles that are not used directly as textures.\nThese tiles are combined in a texture stack\nusing texture details of 0.25 m/texel in geographical areas of about 60,000km2[Santi07].\n• Texture aliasing is avoided using trilinear and anisotropic filtering hardware\n• It allows the use of several independent large textures that can be combined to\ntexture.\nsquare texture), with l being the number of levels in the pyramid.\nMapping Large Textures for Outdoor Terrain Rendering\nVirtual texture.\nThis virtual texture is structured in the persistent\nis those levels of the pyramid in which the texture size is smaller than the tile size.\nThe pre-filtered mipmap levels of the virtual texture increase by a third the stor-\nTexture Cache\nFollowing the clipmap concept, a subset of the full pyramid is cached in texture mem-\nThis virtual texture\nThe first-level cache is a subset of the virtual texture levels that is resident in tex-\nThe virtual pyramid is fully stored in texture memory from the apex to\ncorresponding virtual texture levels.\nYou’ll use l–lb+1 independent textures in texture memory, as shown in Figure\nTexture stack.\nmipmap levels for every texture are needed.\nLet tij be the mipmap level j of the texture\ni; it caches level lb+i–j of the virtual texture.\nOur experience proves that about four or five mipmap levels in the textures of the\nTexture Memory Usage\nFor an l level virtual texture with a clipsize c, m mipmap levels for the stack textures\nand a texel depth of b bytes, the usage of texture memory for the cache can be com-\ntexture\nMapping Large Textures for Outdoor Terrain Rendering\nTexture stack with mipmap levels correspondence.\nRings of detail and an example of a virtual texture applied to the terrain,\nData stored on the texture cache corresponds to a zone of the terrain covered by the\nvirtual texture around the center of detail.\nTexture Stack Update\nWhatever strategy is used, once the center of detail is placed, stack texture levels must\nTextures corresponding to these levels are considered divided in square blocks\nThe subtile is the texture updating atomic\nFor each texture, there is a sub-\ntile state matrix indicating the validity of each subtile in the texture.\nAfter the state matrices are updated, each texture is processed, from coarser to\nsubtile data is uploaded to the texture memory; otherwise, the asynchronous load of\nThe virtual texture window cached in each stack level is accessed toroidally in the\nA subtile update of a texture implies updating the related area in each mipmap\nlevel of this texture.\nIn the mipmap level updating process, consider that subtile size\ntextures, because mipmap levels data is replicated, as shown in Figure 5.8.3.\nThe render time plus the texture update time must not exceed the\nBecause of the previously mentioned update time limit, textures in the stack are not\nIt is necessary to decide when a texture is updated with\npartial area of the full texture is loaded.\nYou update the subtiles of each texture in concentric rings, innermost to outer-\nway, the texture is useful from the moment it begins to have some valid subtiles.\nMapping Large Textures for Outdoor Terrain Rendering\nThe virtual texture update is summarized in the following pseudocode:\nFor each texture level of the stack\nFor each texture level of the stack from coarser to finer detail\nUpdate the subtile in all mipmap levels\nThere are two possible ways to map a virtual texture to a geometry model.\nfinest available texture that covers each geometry patch.\nApply the finest texture level that covers the patch\nThe second way is to select each texture level, asking for its coverage and drawing\nFor each texture level\nNo matter which way is used, texture coordinates must be computed for every\ntual texture.\nBecause each texture level from the stack covers half the virtual space of\nthe coarser one, you need to scale the texture coordinates computed to translate it to\nthe virtual texture level applied.\nMapping Large Textures for Outdoor Terrain Rendering\nThe texture coordinate computation just described can be done in several ways.\nThis way, all the computation can be done with the texture matrix\nIn the case of dynamic geometry, texture coordinates must be computed every\nfollowing pseudocode shows how to calculate texture coordinates:\n(x,y,z): vertex position, i: virtual texture level selected\nthere are different coordinate systems for the texture database and the geometry data-\nwith a data set containing a virtual texture of aerial terrain photographs covering an\nVirtual texture size\nVirtual texture color depth\ntexture subtiles to VRAM.\nThe second graph shows the completeness of the texture stack which can be used\ndirectly as textures.\nThese tiles are combined in a texture stack that caches the region of\nmake the patches match the texture tile boundaries, as occurs in many terrain visualiza-\nWhatever the geometry algorithm, there will always be a texture to map\nThe implementation of this texturing technique has\nMapping Large Textures for Outdoor Terrain Rendering",
      "keywords": [
        "texture",
        "virtual texture",
        "Large Textures",
        "texture level",
        "Mapping Large Textures",
        "level",
        "virtual texture levels",
        "Texture coordinates",
        "texture memory",
        "texture stack",
        "Outdoor Terrain Rendering",
        "detail",
        "Virtual",
        "Large",
        "Terrain"
      ],
      "concepts": [
        "textures",
        "level",
        "updates",
        "updated",
        "terrain",
        "geometry",
        "tiling",
        "tiles",
        "tiled",
        "large"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 46,
          "title": "",
          "score": 0.714,
          "base_score": 0.564,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 49,
          "title": "",
          "score": 0.666,
          "base_score": 0.516,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 47,
          "title": "",
          "score": 0.624,
          "base_score": 0.474,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "",
          "score": 0.541,
          "base_score": 0.541,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 60,
          "title": "",
          "score": 0.492,
          "base_score": 0.342,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "texture",
          "virtual texture",
          "virtual",
          "textures",
          "levels"
        ],
        "semantic": [],
        "merged": [
          "texture",
          "virtual texture",
          "virtual",
          "textures",
          "levels"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20915997371891107,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076542+00:00"
      }
    },
    {
      "chapter_number": 49,
      "title": "Segment 49 (pages 479-486)",
      "start_page": 479,
      "end_page": 486,
      "summary": "[VTerrain07] The Virtual Terrain Project Website, http://vterrain.org.\nGraftal Imposters\nGraftal\nAn artist will provide sketches of graftal imposters along with a set of textures that\nCreating graftal imposters requires a set of assets in addition to the geometry—a tex-\ntypes of graftal imposters along with several variations of each type.\nprovides information about what type of graftal imposter should be placed at a certain\nThe vector field gives a direction and the color texture provides\ninformation on the coloring of the landscape mesh as well as the graftal imposters.\nThe texture atlas contains the graftal imposter itself.\ndifferent types of graftal imposter types, in different rows.\nthe soft edge of the graftal imposter, the alpha value should go smoothly from zero to\nThe inside of graftal imposters will be blended with\nThe control texture enables the designer to specify where a graftal imposter may \nbe placed and the type of graftal imposter to be drawn.\nindicate areas where no graftal imposters can be drawn.\ndesigner wants graftal imposters from the first row of the texture atlas, green for \nIt is often desirable to indicate a direction, or flow of the graftal imposters.\nThe texture atlas uses red as a color key inside of the graftal\nimposter and the alpha channel to smoothly blend the graftal imposter with\nthe designer manipulates the normals to indicate which direction the graftal imposters\nArt-Based Rendering with Graftal Imposters\ndirection of the graftal imposters.\nColor Texture and Mesh\ning of the graftal imposters.\nFigure 5.9.4 is the color texture for the scene.\nnique creates the graftal imposters along the edges.\nresult in visible irregularities in the width of the graftal imposters; therefore, the mesh\nto omit the creation of graftal imposters.\nbase mesh and the graftal imposters.\nThis implementation of graftal imposters requires the use of a\nwhere to place the graftal imposters as well as which type of graftal imposter to place.\nFinally, you use the pixel shader to give the final color to the graftal imposters and\nThe control texture was created earlier to dictate where you can create graftal\nimposters as well as what type of graftal imposter to draw in a given area.\ntest the triangle to determine whether the primitive is eligible for a graftal imposter\nNow that you know the triangle is eligible for graftal imposter(s), you need to test\nin a direction D obtained from the vector field sampled using the texture coordinates\nArt-Based Rendering with Graftal Imposters\nalong the edge where graftal imposters are desired.\nThis pseudocode shows how to create the graftal imposter surface as well as sam-\npling the color texture in order to shade the graftal imposter.\nper incoming vertex allows you to have a graftal imposter that crosses a color bound-\ngraftal imposter on the newly created surface by indexing into the texture atlas.\nuse the graftal imposter type G to index into the correct row of the texture and a\nimposter’s black outline to the internal color passed in by the vertex shader.\n//coloring the graftal imposter\nYou blend the graftal imposter’s soft edge by doing a linear inter-\nPlate 12 for a full-color example of rendering with graftal imposters.\nCurrently, we are applying graftal imposters only to the silhouette edges.\nAdapting the introduction and removal of graftal imposters to\nprovide for inter-frame coherence by scaling or “fading” in the graftal imposters is one\nArt-Based Rendering with Graftal Imposters",
      "keywords": [
        "Graftal Imposters",
        "Graftal",
        "Imposters",
        "texture",
        "color texture",
        "create graftal imposters",
        "Color",
        "texture atlas",
        "graftal imposters requires",
        "control texture",
        "graftal imposter types",
        "Annual Conference",
        "Creating graftal imposters",
        "Graphics System",
        "graftal imposter surface"
      ],
      "concepts": [
        "color",
        "textures",
        "imposters",
        "creating",
        "create",
        "edges",
        "vertex",
        "channels",
        "direction",
        "direct"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 48,
          "title": "",
          "score": 0.666,
          "base_score": 0.516,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 46,
          "title": "",
          "score": 0.6,
          "base_score": 0.45,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 60,
          "title": "",
          "score": 0.516,
          "base_score": 0.366,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 45,
          "title": "",
          "score": 0.511,
          "base_score": 0.361,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 47,
          "title": "",
          "score": 0.473,
          "base_score": 0.323,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "graftal",
          "graftal imposters",
          "imposters",
          "imposter",
          "graftal imposter"
        ],
        "semantic": [],
        "merged": [
          "graftal",
          "graftal imposters",
          "imposters",
          "imposter",
          "graftal imposter"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18617752673300808,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076590+00:00"
      }
    },
    {
      "chapter_number": 50,
      "title": "Segment 50 (pages 487-494)",
      "start_page": 487,
      "end_page": 494,
      "summary": "“Stylized Rendering Techniques for Real-Time 3D Ani-\nReal-Time Lipsync\name developers are increasingly using lipsyncing for in-game 3D characters.\nIn order to use this method, several general requirements need to be met.\nThis gem’s examples use a head generated with Singular\nfor visemes, which are visual representations of speech such as “aah” and “ee.” Watt\nand Policarpo describe visemes as the basic units of visual speech that are described by\nextreme lip shapes, which correspond to basic auditory speech units [Watt03].\nof visemes constitutes a minimally distinct set representing the sounds in a language.\nThe 16 visemes used here, each\nCheap Talk: Dynamic Real-Time Lipsync\nFor audio, you can use pre-recorded speech or audio generated speech at runtime,\nUsing a text-to-speech engine works nicely because the audio is gener-\nated at runtime based on a text string, so you get the text and audio at the same time.\nFor each lipsynced audio sample, the general runtime procedure is as follows:\n1. Translate each word of the text into its corresponding set of phonemes.\n2. Translate each phoneme into its corresponding viseme.\n3. Generate animation data based on the set of visemes.\n5. Use the animation data to drive the 3D model during audio playback.\nWord to Phoneme Mapping\nPhonemes are different from visemes.\nvisemes.\nThere are typically more phonemes in a language than visemes.\nFor example, the word “hello” translates to the four phonemes HH, AH, L, and\nlists each phoneme and an example word found in the dictionary that uses the\nphoneme.\nbinary search to look up words and retrieve their corresponding phonemes.\nPhoneme\nB IY\nD IY\nDH IY\nF IY\nHH IY\nIY\nIY T\nJH IY\nK IY\nM IY\nPhoneme\nP IY\nR IY D\nS IY\nSH IY\nT IY\nV IY\nY IY L D\nS IY ZH ER\nPhoneme to Viseme Mapping\nTranslating phonemes to visemes is a direct lookup based on a table you need to cre-\nThe dictionary contains 39 separate phonemes and the 3D model\nused here has 16 visemes.\nviseme for each of the phonemes.\nyour lips as you sound out the particular phoneme in the word.\ntion with the closest viseme in Figure 5.10.2.\nPhoneme to Viseme Mapping\nPhoneme\nViseme\nPhoneme\nViseme\nPhoneme\nViseme\nD,S,T\nIY\nCheap Talk: Dynamic Real-Time Lipsync\nReal-Time Lipsyncing\ncontaining the text into phonemes and then into visemes.\ntion is then called to translate the visemes into lipsync animation data that can be\nused to animate the 3D model during playback of the audio.\nidea is to divide the duration of the spoken audio by the number of visemes and\nassign each viseme a time slot to become active during audio playback.\nFor example, Figure 5.10.4 illustrates the word “hello.” The word consists of four\nvisemes.\nAt time 0, you begin to morph the viseme “eh” from 0 to 1 and then back to\nThe idea is to overlap the visemes slightly from one to the next.\nThe word “hello” and its corresponding visemes animated over time.\nA few details of word timing need to be addressed in any solution.\nspeech engine, one trick is to save a few text-to-speech audio files that contain multi-\nCreating a dynamic real-time system for lipsync animation using the method pre-\n[Lever02] Lever, Nik. Real-Time 3D Character Animation with Visual C++, Focal\nCheap Talk: Dynamic Real-Time Lipsync",
      "keywords": [
        "visemes",
        "phonemes",
        "Lipsync",
        "Dynamic Real-Time Lipsync",
        "audio",
        "word",
        "speech",
        "Inking the Cube",
        "Edge Detection",
        "Animation",
        "Rendering",
        "Dictionary",
        "aah",
        "Dynamic Real-Time",
        "lipsync animation"
      ],
      "concepts": [
        "lipsync",
        "phonemes",
        "word",
        "audio",
        "time",
        "timing",
        "speech",
        "contains",
        "animation",
        "animate"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 35,
          "title": "",
          "score": 0.712,
          "base_score": 0.562,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 39,
          "title": "",
          "score": 0.564,
          "base_score": 0.414,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 40,
          "title": "",
          "score": 0.542,
          "base_score": 0.392,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 38,
          "title": "",
          "score": 0.539,
          "base_score": 0.389,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 36,
          "title": "",
          "score": 0.538,
          "base_score": 0.388,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "iy",
          "visemes",
          "iy iy",
          "phoneme",
          "viseme"
        ],
        "semantic": [],
        "merged": [
          "iy",
          "visemes",
          "iy iy",
          "phoneme",
          "viseme"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21246589419577863,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076647+00:00"
      }
    },
    {
      "chapter_number": 51,
      "title": "Segment 51 (pages 495-502)",
      "start_page": 495,
      "end_page": 502,
      "summary": "networking means there is a growing need for network programming, and all these\ngenres and services mean there are more game programmers who need to interface\nGame World Synchronization\nne of the important roles of networked gaming hosts is communicating with\nother hosts to maintain game world synchronization, which involves keeping the\ngame worlds in the same states on all hosts around the world.\ngame world across multiple hosts requires that game programmers write code that:\n• Transmits the messages to remote hosts\n• Applies the messages to the game world states of the remote hosts\nmanually write routines that manage the game world state, gather information to syn-\nThis gem introduces another meta-programming technique that synchronizes the\ngame worlds using High Level Abstraction (HLA).\nnizing the game world state, which is why it’s called high-level abstraction.\nRaw memory synchronization techniques also allow game world synchronization.\n• Actual working multiplayer gaming requires latency hiding techniques such as dead\n• Raw memory synchronization requires game world data to be stored in a block.\ngaming worlds.\nIn an HLA world, game world synchronization can be done by declaring object\ngame world synchronization, and then constructs an HLA system.\nThe goal of HLA is to offer a feasible method for abstracting game world synchro-\nAnatomy of Game World Synchronization\ntion when you adopt the HLA technique to your game project.\n• The game hosts are composed of one server and the other clients.\nall game world objects and takes control of them.\n• One or more messages are sent from the clients to the server when a change of\ngame world occurs in a client.\nThen they are applied to server’s game world and\n• Messages are sent from a server to the clients when a change of game world occurs\nYou can categorize the changes in the game world state.\nIn many actual game products, not every object is synchronized for every remote\ntiplayer game, where every client holds only a very small area of the game world state,\n(The server-side game world is even incomplete on\nviewport gets the message “a new object has appeared” and the host creates an object\nin its game world state.\nviewport or the object, the “disappear” message arrives to the appropriate host.\nChanges that cause corruption of the game world must be prohibited.\nHigh-Level Abstraction of Game World Synchronization",
      "keywords": [
        "Game World",
        "Game World Synchronization",
        "game world state",
        "game",
        "World",
        "World Synchronization",
        "world state",
        "HLA",
        "Synchronization",
        "game world objects",
        "object",
        "game world occurs",
        "messages",
        "server",
        "hosts"
      ],
      "concepts": [
        "game",
        "gaming",
        "networking",
        "synchronization",
        "synchronizes",
        "synchronized",
        "hosts",
        "messages",
        "object",
        "world"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 54,
          "title": "",
          "score": 0.569,
          "base_score": 0.419,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 52,
          "title": "",
          "score": 0.515,
          "base_score": 0.515,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.492,
          "base_score": 0.492,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 8,
          "title": "",
          "score": 0.454,
          "base_score": 0.454,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 40,
          "title": "",
          "score": 0.445,
          "base_score": 0.445,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "game world",
          "world",
          "game",
          "synchronization",
          "world synchronization"
        ],
        "semantic": [],
        "merged": [
          "game world",
          "world",
          "game",
          "synchronization",
          "world synchronization"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2527754455166676,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076703+00:00"
      }
    },
    {
      "chapter_number": 52,
      "title": "Segment 52 (pages 503-511)",
      "start_page": 503,
      "end_page": 511,
      "summary": "The HLA system consists of an SWD compiler and an HLA runtime, as well as the\n• The classes have, of course, member variables\n• The variables have synchronization behaviors\n• Manages the synchronized objects and collects any changes to them (creation and\ndestruction of objects or member variable changes)\n• Converts the changes to messages and sends them to the networking layer\nworld, when a small change to the HLA source code is needed.\nLet’s call the synchronized object SynchEntity for avoiding ambiguity with the term\nA SynchEntity is one of the classes defined in an SWD file.\nA SynchEntity is an ordinary class in practice; however, it has more attributes and\nA SynchEntity exists as the original or the replica, depending on which host has\nSynchEntity instance will have a unique identifier value, which is issued by the server.\nEvery member variable in a SynchEntity is actually a property member.\nThe synchronization behavior for each member variable can be defined in an\nwhich behavior is defined for each member variable.\nto see if any changes are made to the variable.\nFlagging a Variable as Changed While Assigning a Value\nThe synchronization behavior to be bound to a SynchEntity member variable is\nyou should define a class derived from the SynchEntity just for adding member vari-\nConditional behavior means that the value is synchronized when its value changes.\nvalue changes are too frequent.\nThis behavior needs send interval value and\nIf the value of a periodic behavior member variable changes, it will be\nsent to remote hosts in the interval of send interval value until the send duration time\nduration to 1 second for a periodic behavioral variable, the value will be sent to\nListing 6.1.6 is an example of a conditional behavioral member variable that is\nused in the SWD file, whereas Listing 6.1.7 shows its compiled code.\nAn Example Conditional Behavioral Member Variable Used in an SWD File\nGenerated Code for the Conditional Behavioral Member Variable\nbool m_private_life_changed;\ninline void set_life(int value)\nif(value!=m_private_life)\n// A variable whose *_changed \nm_private_life_changed=true;\nm_private_life=value;\nSo the SWD compiler should generate these three variables for each dead\nThe flag that indicates whether the value is changed (m_private_life_changed in\nOne simple model is to iterate over each SynchEntity and gather the changed ones by\nBecause the HLA runtime itself cannot know what the flag values\n// generated enumeration value from the SWD compiler.\nif(typedEntity->m_private_life_changed)\ntypedEntity->m_private_life_changed=false;\nAlmost all SynchEntities are created only after the server decides that a creation is\nThen the received client creates the replica of the new SynchEntity\nits ID and its initial member variable values.\nand then sent to the clients that need to know about the newly created SynchEntity.\nThe identifier value of a SynchEntity that’s created client\nside always exists in a value range that has been issued by the server when the client\nthat the message type has only the ID of the destructed SynchEntity.\nA SynchEntity is\nSynchEntity is a client-side decision to destroy the entity, at which point the server is\nAll changes in the SynchEntity variables are collected and sent to the clients that\nMessages containing these changes have the SynchEntity ID and a list\nof changed values with their variable ID numbers.\nifications or the subject of the SynchEntity is the client.\nThe visibility of every SynchEntity can be changed as time goes on because its\nthe client that owns the viewport creates the replica of the SynchEntity after the server\nsends the appearance message with the SynchEntity ID and its serialized values.\ncontrast, the disappearance message with the SynchEntity ID is received at the client\nas a network host identifier for sending or receiving messages for synchronization.\nSynchEntity and the base class of viewport\nHlaServer has every instance of SynchEntity_S-derived objects and SynchView-\nthe state of every SynchEntity_C synchronized with the server.\nclasses help HlaClient and HlaServer determine whether these member variables\n• The SynchEntity types discussed so far have no member functions.\nadded to the HLA system by sending event messages to the remote host.\nThe HLA in this gem checks visibility for every SynchEntity and every\nSynchEntity and SynchViewport classes and use it before the actual comparison.",
      "keywords": [
        "SWD file",
        "HLA",
        "SynchEntity",
        "SWD",
        "HLA runtime",
        "member variable",
        "SWD compiler",
        "Listing",
        "HLA system",
        "Game World Synchronization",
        "variable",
        "SWD File world",
        "member",
        "game world",
        "world synchronization"
      ],
      "concepts": [
        "classes",
        "values",
        "listing",
        "behaviors",
        "behavioral",
        "change",
        "changed",
        "messages",
        "messaging",
        "members"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 51,
          "title": "",
          "score": 0.515,
          "base_score": 0.515,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 56,
          "title": "",
          "score": 0.472,
          "base_score": 0.322,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 55,
          "title": "",
          "score": 0.45,
          "base_score": 0.3,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 59,
          "title": "",
          "score": 0.407,
          "base_score": 0.257,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 57,
          "title": "",
          "score": 0.371,
          "base_score": 0.221,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "synchentity",
          "member",
          "variable",
          "member variable",
          "swd"
        ],
        "semantic": [],
        "merged": [
          "synchentity",
          "member",
          "variable",
          "member variable",
          "swd"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1435087527838262,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076748+00:00"
      }
    },
    {
      "chapter_number": 53,
      "title": "Segment 53 (pages 512-521)",
      "start_page": 512,
      "end_page": 521,
      "summary": "• Game login—Given credentials (a user name and password) match the informa-\n• Game session—A network packet was sent by the logged in player it says it came\nTo secure game logins, you need to worry about a few kinds of problems: \n• Insecure password storage—Are your servers secure?\nIf they can read the password in clear text at that point, that’s a problem.\nread a password sent in clear text, and then impersonate the user in question.\n• Uneducated users—In many online games, there are users who will try to get the\nThe main point of this gem is to examine authentication in your client/server\n• Recoverable passwords—If the password is recoverable, you can use the Challenge\nHowever, the passwords are more\n• One-way hash passwords—When setting a password, you calculate a one-way hash\nusers log in the next time, they give you a password, and you calculate an SHA256\nRSA or SSL, you can publish the public key of the game servers, and even hard-\ncode it into the game client executable.\nThe user’s password is then transmitted\nauthentic server can decrypt the message, so the client has a reasonable assurance\nIn Challenge Hash Authentication, the server issues some random number, called a\nand the client-side entered password, and sends the hash value back to the server.\nserver then computes a hash of the remembered challenge value and the stored (plain-\ntext) password, and compares it to what the client submitted.\n• The server has the clear-text password—This is a security problem if the server side\nbecomes compromised, but the clear-text password, which is a secret shared by\nA common-sense precaution is to use a hash of the clear-text password as a key\nAuthentication for Online Games\nIn Secret Exchange Authentication, the server stores a hash of the password.\nsubmits a plain-text password, and the server hashes this plain-text password, and com-\n• The server doesn’t store the plain-text password—If someone breaks in and steals the\n• The server has the clear-text password—Because the client sends the clear-text pass-\nword, the server has at least temporary access to the clear-text password, and can\nthe memory of your server process, they can still recover plain-text passwords,\npublic key of the game servers, or even hard-code it into the game client executable.\nthe account, storing the matching public key on the server side, and encrypting the pri-\nvate key locally with the user’s password (known as a pass phrase).\n• The user has a good assurance against server impersonation—As long as the server\n• The user credentials are not portable—If the user accesses your game from more\nor her game account, so that the client can authenticate itself on logon.\nYou clearly can’t just let the client claim any identity, and have the server blindly\noff between servers, the port part of the client’s address will not necessarily stay the\nWhen the player logs in, the server determines the duration for which the connection\ndata: the client ID, the expiration time of the login session, and a secret number that\nonly the game server knows.\nThe server then sends a token to the client, which con-\ntains the client ID, the expiration time, and the hash of the three pieces of data.\nAuthentication for Online Games\nIf the hash matches the hash in the supplied token, the server knows\nthat the packet comes from the player who initially authenticated with the server, or\nIf game sessions last more than an hour, the server that the player is cur-\ntime, and a hash of those entities and the server secret number.\nIf you use a shared secret between the server and the client, such as a plain-text pass-\nword, you can use that secret as a key, or perhaps better, a hash of that password and\nWhen the server receives a packet, it looks up the client password in an internal\nthe data was not encrypted with the right password, and thus the packet did not come\n• Insecure passwords—When the player generates or changes a password, you should\n• Insecure password storage—To protect server secrets against malicious internal opera-\nservers.\nStore any plain-text password data in a scrambled format, using some key\ninformation or user home addresses, in a server separate from the main game\n• At setup, all servers in the cluster share a large random number, known as the\n• Client connects to login server using unencrypted TCP or UDP.\n• The server issues a challenge to the client, consisting of a 256-bit random num-\n• Client calculates a hash of this number concatenated with the password the user\nenters, and supplies the hash to the server.\nAuthentication for Online Games\n• Server verifies that the hash of the challenge and stored password matches what\nthe client supplied, and issues an authentication ticket consisting of a user ID,\n• Login server also generates a random key for use by this client during this session,\nThe key is encrypted by a key generated by hashing the user password\n• Client connects to any server that is part of the game server cluster.\n• Client starts the connection to a new server within the cluster by sending the\n• The new server verifies that the ticket has not expired, and that the hash is cor-\nUsing the user ID in the ticket, the new server retrieves the encryption key\nfor the client from the login server.\n• The new server and the client also negotiate sequence numbers for future com-\n• Once authenticated, the new server and client exchange data encrypted with the\n• Periodically, the server that the client is currently connected to checks whether\nthe login server to get a new ticket and forwards it to the client.\nties getting hold of secret information, not the two first parties (the client and server).",
      "keywords": [
        "server",
        "password",
        "client",
        "game",
        "Hash",
        "Authentication",
        "key",
        "Challenge Hash Authentication",
        "game servers",
        "Online Games",
        "user",
        "Secret Exchange Authentication",
        "Hash Authentication",
        "login server",
        "game client"
      ],
      "concepts": [
        "servers",
        "client",
        "password",
        "authentication",
        "authenticate",
        "authenticated",
        "user",
        "game",
        "hash",
        "hashes"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 51,
          "title": "",
          "score": 0.422,
          "base_score": 0.422,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 2,
          "title": "",
          "score": 0.349,
          "base_score": 0.349,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.327,
          "base_score": 0.327,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 25,
          "title": "",
          "score": 0.304,
          "base_score": 0.304,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "server",
          "password",
          "client",
          "hash",
          "text"
        ],
        "semantic": [],
        "merged": [
          "server",
          "password",
          "client",
          "hash",
          "text"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.10896531051365269,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:44.076896+00:00"
      }
    },
    {
      "chapter_number": 54,
      "title": "Segment 54 (pages 522-529)",
      "start_page": 522,
      "end_page": 529,
      "summary": "Information Processing Standard hash/digest function, available online at\nGame Network Debugging\nwith Smart Packet Sniffers\ngame packets.\nThis can be problematic when attempting to debug network code in\nThe standard practice is to use a packet sniffer application that collects net-\nPacket\nsniffers give easy access to information about packet source and destination, and other\nnetwork protocol stack information.\nyour game protocol when that data goes out over the network.\nThe Smart Packet Sniffer Concept\nThe concept of a smart packet sniffer or, perhaps better-named, game message sniffer,\nIn its most basic description, this is a packet sniffer that has specific\nThis smart packet sniffer application was developed while working on Greg Hast-\nmessage system and network code.\nThis is where a smart packet\nthat consisting of Ethernet frame, IP, and UDP header information, our packet\nlescing our packet data and greatly reducing our overall overhead.\npacket sniffer, we probably could have examined the binary data of a number of pack-\ning with network code.\nnetwork code is that you are only stopping one side of the simulation.\nheartbeat packets are being sent to the server, or which messages are coming out of\nwhen using the debug output pipeline to debug time sensitive code.\nThe base implementation for a smart packet sniffer is simple.\nThe basics of a smart packet sniffer require that you expose internal game protocol\nboth the game and the sniffer.\ncode that is common between the game and sniffer.\nPacket Acquisition\nYou can write the code for capturing packets yourself.\nThe benefit of using pcap is that the code has been\nPacket Decoding\nprotocol codec and what differentiates the smart sniffer from a standard packet sniffing\nkeep the specifics of your protocol out of the packet sniffer core code.\nGame Network Debugging with Smart Packet Sniffers\nThe pcap library is used in the Wireshark Open Source packet sniffer among many\nallows developers to easily capture packets being sent across the network.\nlook at the sample code on the CD-ROM for a working example of the functions cov-\nIn order to start capturing packets, you need to define which local network device you\nPcap provides the following two functions for obtaining device information and for\nA view of the user interface of our smart packet sniffer.\nBefore you can start capturing packets, you have to initialize pcap.\nnetwork device you would like to use for capturing packets.\nOur packet sniffer sample assumes this to be true.\npcap_t\n//Set the packet filter.\nAcquiring Packets\nThe next step is to set up the pipeline for handling the packets.\nIn the sample code included on the CD-ROM, after initial-\ndler, we call the pcap_dispatch function to access the captured packet data.\nThe packet handler callback is where your code gains access to the packet data.\nThis is where your protocol codec will handle the raw network data and turn it into\nA tool that can decode and display all of the internals of your network code is a great\nGame Network Debugging with Smart Packet Sniffers\nPerhaps your packet sniffer is only able to evaluate packets that are sent out across\nSomeone could analyze the sniffer assembly code to reverse-engineer your internal\nnetwork code structures.\nThe Wireshark packet sniffer has a plug-in architecture that allows you to\nYou could, for example, write a packet dissector for your\nprogrammer, you should make sure to have a full-featured packet sniffer available.\nsimulation application set, as well as a simple smart packet sniffer application.\nsource code is included to all applications.",
      "keywords": [
        "Smart Packet Sniffer",
        "packet sniffer",
        "Packet",
        "Smart Packet",
        "pcap",
        "sniffer",
        "Code",
        "Network",
        "network code",
        "packet sniffer application",
        "Game Network Debugging",
        "protocol",
        "Game",
        "standard packet sniffer",
        "Wireshark packet sniffer"
      ],
      "concepts": [
        "packet",
        "code",
        "network",
        "sniffers",
        "protocols",
        "games",
        "data",
        "debugging",
        "debug",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 15,
          "title": "",
          "score": 0.583,
          "base_score": 0.433,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 51,
          "title": "",
          "score": 0.569,
          "base_score": 0.419,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "",
          "score": 0.353,
          "base_score": 0.353,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "",
          "score": 0.336,
          "base_score": 0.336,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "packet",
          "sniffer",
          "packet sniffer",
          "smart",
          "network"
        ],
        "semantic": [],
        "merged": [
          "packet",
          "sniffer",
          "packet sniffer",
          "smart",
          "network"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.16710965367910466,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076944+00:00"
      }
    },
    {
      "chapter_number": 55,
      "title": "Segment 55 (pages 530-540)",
      "start_page": 530,
      "end_page": 540,
      "summary": "First, Julien Hamaide provides a method for automatically binding C++ classes to\nthe popular game scripting language Lua. His implementation is particularly focused\nAutomatic Lua Binding\nfocuses on an implementation of a Lua binding.\nto expose their C++ classes to Lua without any knowledge about the system.\nThe binding explained in this gem allows creation, access, and use of C++ objects\ngrammers to expose a C++ class and its methods to the Lua binding very simply.\nBinding of C Functions\nTo bind a function, Lua requires a specific interface.\nLua binding is stack-based, the lua_State contains all\nmation on binding of C functions can be found in the Lua manual [Ierusalimschy06].\nThe C function binding is the only way you can bind Lua to C/C++, and will be the\nint binding_method( lua_State * state )\nObject-Oriented in Lua\nThis gem explains how Lua can become object-oriented.\nobject is accessed as an array with the name of the method and returns the function to\nto table and userdata objects.) Metatables are Lua tables that are assigned to an object\ntest_return = object[ \"Test\" ] -- call the __index function in\nLua native types are number (double or float), string, table, nil, function (Lua or\nWe use the latter to store the object in Lua. Light\nThe second is a complete Lua object that can\nBinding C++ Objects in Lua\nThe binding requires several mechanisms: the representation of the C++ object in\nLua, the storage of bound functions, and finally the registering of each C++ object in\nthe binding data.\nIn existing implementations [Celes05], the binding is directly stored in Lua. Binding\nbinding data in C++ in a class called SCRIPTABLE_BINDING_DATA.\nSCRIPTABLE_BINDING_DATA contains a map between the class name\nin scriptable_binding_data.h. class SCRIPTABLE_BINDING_DATA\ntypedef int (* BINDING_FUNCTION) (lua_State *);\nAutomatic Lua Binding System\nstd::vector<std::map<std::string, BINDING_FUNCTION>*>\nstd::vector<BINDING_FUNCTION>\nA pointer to this binding data and the index of the class is stored inside lua_State.\nC++ Objects as Lua Objects\nA bound C++ object needs to store its class index—the result of looking up its class\nThis class index is used to search for bound functions in\nthe binding data.\nAs previously said, we represent C++ objects as user data in Lua. This user data contains the pointer to the bound object and its class index.\nSCRIPTABLE_BINDING_HELPER structure helps the readability of the code.\nright now is that it stores the index of the class, making the storage of C++ objects in\na Lua object simpler.\nThe following functions are used by C++ code when reading the arguments of a\ncall made from Lua, and returning the results to Lua. template< typename _VALUE_>\nlua_State * state, _VALUE_ & object, _VALUE_ * dummy )\nSCRIPTABLE_BINDING_HELPER\n= lua_createuserdata( state, sizeof(SCRIPTABLE_BINDING_\n_VALUE_& SCRIPTABLE_GetValue( lua_State * state, int index, _VALUE_\nSCRIPTABLE_BINDING_HELPER\nhelper = lua_touserdata( state, index );\ndefined for each C++ type that can convert to a Lua primitive: string, integer, and float.\nlua_State * state, int index, std::string * dummy )\nreturn lua_tostring( state, index );\nAs all binding data is stored in SCRIPTABLE_BINDING_DATA, only one instance per\nscript of this metatable is needed and it can be assigned to all C++ objects.\nThe binding function recovers the arguments from the Lua stack and performs the\nAutomatic Lua Binding System",
      "keywords": [
        "Lua",
        "binding",
        "Lua Binding",
        "Lua Binding System",
        "SCRIPTABLE",
        "binding data",
        "object",
        "State",
        "Automatic Lua Binding",
        "data",
        "function",
        "binding function",
        "index",
        "Lua object",
        "helper"
      ],
      "concepts": [
        "functionality",
        "functions",
        "function",
        "classes",
        "binding",
        "objects",
        "objectives",
        "game",
        "state",
        "string"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 56,
          "title": "",
          "score": 0.764,
          "base_score": 0.614,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 57,
          "title": "",
          "score": 0.62,
          "base_score": 0.47,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 58,
          "title": "",
          "score": 0.53,
          "base_score": 0.38,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 52,
          "title": "",
          "score": 0.45,
          "base_score": 0.3,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 59,
          "title": "",
          "score": 0.424,
          "base_score": 0.274,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "lua",
          "binding",
          "lua binding",
          "object",
          "index"
        ],
        "semantic": [],
        "merged": [
          "lua",
          "binding",
          "lua binding",
          "object",
          "index"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1746335793275633,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.076990+00:00"
      }
    },
    {
      "chapter_number": 56,
      "title": "Segment 56 (pages 541-548)",
      "start_page": 541,
      "end_page": 548,
      "summary": "int _RETURN_##_METHOD_##_PARAMETER_0_( lua_State * state ) \\\nCLASS \\\n&self = SCRIPTABLE_GetValue( state, 1, (CLASS *) 0 ); \\\nThis macro only creates the binding function.\ntion inner class with a static method, you can create and register the method at the\n#define SCRIPTABLE_Class( _CLASS_ ) \\\nvoid register_##_CLASS_ ( BINDING_DATA & binding_data )\\\n#define SCRIPTABLE_End( _CLASS_ ) \\\nclass _RETURN_##_METHOD_##_PARAMETER_0_ \\\nbinding_data.Register( class_name, #_METHOD_, \\\ncreated in Lua. The demo on the CD-ROM contains a definition of this macro and\nAs shown, the creation of the binding and registration function for each class is\nsulate the registration function into a class.\ninner class derived from SCRIPTABLE_TYPE.\nclass SCRIPTABLE_TYPE\nSCRIPTABLE_TYPE()\nThen, in the bound class, the following code is inserted: \nclass CLASS_SCRIPT_TYPE;\nfriend class CLASS_SCRIPT_TYPE;\nclass CLASS_SCRIPT_TYPE :\nCLASS_SCRIPT_TYPE( void );\nvirtual void Register( SCRIPTABLE_BINDING_DATA & binding ); \nThe inner class contains the Register function, the Delete function, the bound\nclass name, and its index.\nvoid SCRIPTABLE_TYPE_TABLE::Register( BINDING_DATA & binding_data )\nTypeTable[ type_index ]->Register( binding_data );\navailable—SCRIPTABLE_Class for counted objects and SCRIPTABLE_UncountedClass\nThese macros must be placed in the class definition.\nIf a method cannot be found in the current class binding, it searches in its parent bind-\nThe function BINDING_DATA::GetFunction does this search, and can be found on\nSCRIPTABLE_Class is used for baseless classes, otherwise\nThe SCRIPTABLE_PushValue macro has the class index hard-coded.\nTo bypass this issue, the binding function is put in a virtual function of the class.\nfunctions is done by prefixing the class name with the method name, as if the class\nclass.\nnot using a class function, or if a class does not have any static functions, a variable\nable name matches a class name, a new object with a null pointer is created and\ninserted into the global table with the class name.\nThis way, only class variables that are\nTemplate Classes\nThe binding is also able to handle template classes.\na bound class, but in this case, it should define its name in Lua by using\nThe name of the class in Lua is the name of the template class suffixed by the name of\nFor exampe, SCRIPTABLE_Class becomes SCRIPTABLE_TemplateClass.\nThe demo shows a dummy template class to show how the binding works.\nThe binding has only been implemented for a single-parameter template class,\nBinding Overloaded Functions\nThe other solution is to rename the function in Lua. The\nSCRIPTABLE_Renamed* macros allow methods to be renamed in Lua so that SetValue\nBecause the binding functions are being created by macro instances, adding debug-\nment count and the class type.\nTo bind a class, this macro SCRIPTABLE_DefineClass( MY_CLASS ) must be put in the\nclass definition.\nSCRIPTABLE_DefineTemplateClass : template class, LuaPushValue is \nSCRIPTABLE_DefineRawTemplateClass : template class, LuaPushValue \ncpp file, the class binding implementation must be set up as follows:\nSCRIPTABLE_Class( MY_CLASS )\nThe options are SCRIPTABLE_(Uncounted)(Inherited)(Template)Class.\nstores the Lua function into a table as a replacement of the C function.\nfunction table first, and then searches the C++ binding data.\nEvery time a call to SCRIPTABLE_PushValue is made, the Lua version of the object is\nThe presented system allows the binding of objects to Lua. But you may want to\nlevel scripts can only access a selected set of classes.\nIn the following code, the class WORLD is declared\nSCRIPT_TYPE_TABLE::Register with its binding data and its access level.\ndata contains only classes that are available for its access level.\nSCRIPTABLE_Class( WORLD, ACCESS_LEVEL_User )\nTypeTable[ type_index ]->Register( binding_data );\nThe technique presented here creates a binding function for all bound methods.\nThe binding data can be a class",
      "keywords": [
        "SCRIPTABLE",
        "Lua Binding System",
        "lua",
        "binding",
        "Type",
        "Automatic Lua Binding",
        "Lua Binding",
        "function",
        "Binding System",
        "DATA",
        "define SCRIPTABLE",
        "binding data",
        "object",
        "State",
        "METHOD"
      ],
      "concepts": [
        "classes",
        "binding",
        "function",
        "functions",
        "object",
        "template",
        "access",
        "accesses",
        "accessing",
        "returns"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 55,
          "title": "",
          "score": 0.764,
          "base_score": 0.614,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 59,
          "title": "",
          "score": 0.483,
          "base_score": 0.333,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 52,
          "title": "",
          "score": 0.472,
          "base_score": 0.322,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 57,
          "title": "",
          "score": 0.442,
          "base_score": 0.292,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 58,
          "title": "",
          "score": 0.42,
          "base_score": 0.27,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "class",
          "binding",
          "lua",
          "binding_data",
          "function"
        ],
        "semantic": [],
        "merged": [
          "class",
          "binding",
          "lua",
          "binding_data",
          "function"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.13208404495333395,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.077034+00:00"
      }
    },
    {
      "chapter_number": 57,
      "title": "Segment 57 (pages 549-558)",
      "start_page": 549,
      "end_page": 558,
      "summary": "Serializing C++ Objects \ngem presents a system that allows storage of C++ objects into an SQL database, and\nclass:\n• Size of an instance of the object in bytes\nThis class allows you to manipulate objects of arbitrary types without having to\nFor every attribute in the class you want to serialize, you add its information to the\n• Memory offset in bytes from the start of the object\nThis way you can manipulate arrays without having to know what type of object is\nstored inside them, an ability that you’ll need when manipulating objects in the data-\nvoid * object, \nThese functions have support for reading and writing objects of scalar types and\nobjects.\nWhat do those objects contain?\n• One or more parent classes, if present\n• Instances of other C++ classes\n• One parent class, if present\n• Instances of other C++ classes\n• Arrays of pointers, instances of other C++ classes or scalars, using our own array\nBecause you’ll store the objects in a relational SQL database, you need to define the\ntables used to store those objects.\nEach table corresponds to one class.\nan object you want to serialize.)\nSerializing C++ Objects into a Database Using Introspection\nEach scalar member is stored as a scalar field of type integer or real in the database.\nYou can use any table in a database as the type of a field of another table.\nple creates a field called _Parent that will be of the type of the table created to store\nthis class:\nclass Base\nThere are several ways to store a pointer to an object in the database.\nprimary key of the table containing the object pointed to.\nclass Base\nStoreInDatabase * store_object = new StoreInDatabase;\nbase_object->a = 10;\nstore_object->basePointer = base_object;\nTable Base:\nRetrieving the object from the database seems straightforward.\ncontents of table StoreInDatabase, use the value found in the field basePointer, and\nSerializing C++ Objects into a Database Using Introspection\nclass Base\nStoreInDatabase * store_object = new StoreInDatabase;\nsubclass_object->a = 10;\nsubclass_object->b = 20;\nstore_object->basePointer = subclass_object;\nWhen you’re trying to get the object from the database, you have an issue.\nare not storing a pointer to an object of type Base but an object of type Subclass.\ndo not know which table corresponds to the key stored in basePointer.\nmary key of the object pointed to, let’s try storing a string with the following layout:\nStoring the same objects will result in these table values:\nmary key part and the tablename part of the field value stored in basePointer, and\nuse the corresponding table to receive the contents of the pointed to object.\nAnother solution is to store a table containing all names of the classes stored in\nto store a pointer, the field will contain ( primaryKeyValue, classNamePrimary\ncorresponding classname stored in the table.\nSerializing C++ Objects into a Database Using Introspection\nInstances of Other C++ Classes\nYou could store instances of classes in the same way that you store the parent class, by\nadding a field with an attribute type corresponding to the table of the associated class.\nclass Base\nThis will work, unless you have objects containing pointers to members of other\nobjects.\nclass Base\nbecause it references part of another object and not an entire row in a database table.\nA solution to this issue is to store instances of C++ objects the same way you store\nYou store the instance in the table corresponding to its class, make a varchar\nfield in the table corresponding to the object containing the instance, and write the\nAnd the result of storing the objects will look like this:\nTable Base:\nrules used for the previous types, but store them in an array in the field.\nSerializing C++ Objects into a Database Using Introspection",
      "keywords": [
        "CREATE TABLE",
        "base",
        "Identifier",
        "object",
        "Database",
        "class Base",
        "store",
        "create",
        "table called Base",
        "Subclass",
        "StoreInDatabase",
        "system",
        "Identifier basePointer",
        "Table StoreInDatabase",
        "Table Base"
      ],
      "concepts": [
        "classes",
        "base",
        "type",
        "stored",
        "store",
        "tables",
        "containing",
        "database",
        "created",
        "create"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 58,
          "title": "",
          "score": 0.746,
          "base_score": 0.596,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 55,
          "title": "",
          "score": 0.62,
          "base_score": 0.47,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 59,
          "title": "",
          "score": 0.469,
          "base_score": 0.319,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 56,
          "title": "",
          "score": 0.442,
          "base_score": 0.292,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 52,
          "title": "",
          "score": 0.371,
          "base_score": 0.221,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "table",
          "database",
          "store",
          "objects",
          "class"
        ],
        "semantic": [],
        "merged": [
          "table",
          "database",
          "store",
          "objects",
          "class"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1934897651572048,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.077083+00:00"
      }
    },
    {
      "chapter_number": 58,
      "title": "Segment 58 (pages 559-566)",
      "start_page": 559,
      "end_page": 566,
      "summary": "By using the MetaType instance of each class, you can generate the tables in the data-\nYou generate a string containing the SQL statement to create the table using the\nsql_statement =  \"CREATE TABLE\" + meta_type.className\nSQL statement needed to create the field corresponding to the kind of attribute.\nStoring an Object\nNext, you insert the object in the table, which is completely\nFinally, you update the object in the table, fill-\nWhy not just insert the object in the table, have\nRemember that each instance of an object in a database table is uniquely identi-\nand having one object in a table in your database.\nyou that object.\nfields, construct a new instance in memory of the C++ object, and return you its\ninstance in memory of an object that exists only once in the database.\ndatabase manager should return the pointer to the same instance created before.\nA way to solve this issue is by having an instance table inside the database man-\nan instance of an object.\nThe system will instantiate the C++ object, fill in its values, and store\nthe pointer to the object, its tablename, and its primary key value in the cache.\nnext time you ask for a certain object, the database system will take the primary keys\nobject already exists in the cache, it will return the stored pointer instead of creating a\nThe program inserts an object in the database, and somewhere later on tries to\nbase system should return the pointer to the original object, and not create a new\nneed the primary key value to store the object, you need to retrieve this up front.\nyou were to insert the object there is no way of retrieving its primary key value by any\nSerializing C++ Objects into a Database Using Introspection\nobjects.\nTo store an object in the database, you execute the following pseudocode:\nprocedure StoreObjectInDatabase(object, meta_type )\nInsertObjectAndAttributePrimaryKeys( object, meta_type );\nUpdateObject( object, meta_type );\nright after inserting the empty object only containing a primary key value.\nthe object.\n• If the object already exists in the instance table, or if it is a native database type\n• Iterate over all attributes of the object and its ancestors and call InsertObject\n• Check if the table corresponding to the class of the object actually exists in the\n• Finally, at this point in the function, all the attributes of the object and its ances-\nfor the object itself and insert the object in the database with this value.\n• If the object is a native database type, return.\n• Iterate over all attributes of the object and its ancestors and call UpdateObject on\n• Create and execute the SQL statement to update the object’s contents.\nthe same name as the classname stored in the metatype of the object.\nsponding to the object pointer.\nSerializing C++ Objects into a Database Using Introspection\nattribute and depending on what type of attribute it is, generate the field value in a\nattribute to a string, which you can use in the SQL statement.\nto know when retrieving the object later on is the number of items in the array.\ngenerate the rest of the string, you take the metatype of the object stored in the array,\nIf the array contains pointers to objects, you can iterate over those using the fol-\nIf the array contains instances of objects, the code looks like this:\ncontents of the objects in the database.\nRetrieving an Object\nvalue, you check whether the object already exists in the instance table.\nThe result of this query is used to fill in the attributes of the object you want\nprocedure GetObjectsFromDatabase( object_table, meta_type, predicate )\nobject_table.Add( GetObjectFromInstanceTable( key, \nobject_table.Add( CreateNewObject( key, meta_type ) )\nthe class you want to retrieve instances from, and object_table is the table that will\nIn the case of creating a new object, you use its metatype to construct a new\nPointer to an Object\ncode to retrieve that object’s contents from the database, and store the new instance’s\nSerializing C++ Objects into a Database Using Introspection\nObject\nthe address in the instance table, together with its primary key value and metatype,\nexecute a SELECT statement to retrieve its attribute’s values, and fill in its contents.\ntake the pointer to the attribute, cast it into a pointer to an object of type BaseArray,\negorize the elements in the array (native database type, pointer to an object, or\nobject).\nobjects are created, inserted in, and retrieved from the database.\nUsing pgAdmin, you can look at the tables created and the way the objects are\nCurrently, the system supports pointers to objects stored as attributes in a class\nan object stored in the database instance table, but the application has already deleted\nthis object, creating a dangling pointer.\nThis gem presents a way of storing C++ objects in a database using a metadata system.\nwhose objects need to be stored.\nYou can store many small objects in a database and quickly retrieve the ones you’re\nSerializing C++ Objects into a Database Using Introspection",
      "keywords": [
        "Object",
        "database",
        "primary key",
        "SQL",
        "instance table",
        "key",
        "database type",
        "native database type",
        "SQL statement",
        "pointer",
        "attribute",
        "type",
        "instance",
        "primary",
        "statement"
      ],
      "concepts": [
        "object",
        "database",
        "attribute",
        "parent",
        "classes",
        "pointer",
        "array",
        "strings",
        "values",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 57,
          "title": "",
          "score": 0.746,
          "base_score": 0.596,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 55,
          "title": "",
          "score": 0.53,
          "base_score": 0.38,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 59,
          "title": "",
          "score": 0.502,
          "base_score": 0.352,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 56,
          "title": "",
          "score": 0.42,
          "base_score": 0.27,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 52,
          "title": "",
          "score": 0.333,
          "base_score": 0.183,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "object",
          "database",
          "table",
          "instance",
          "pointer"
        ],
        "semantic": [],
        "merged": [
          "object",
          "database",
          "table",
          "instance",
          "pointer"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1258685221857909,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.077132+00:00"
      }
    },
    {
      "chapter_number": 59,
      "title": "Segment 59 (pages 567-580)",
      "start_page": 567,
      "end_page": 580,
      "summary": "Dataports\nDataports are a\nmaking the runtime behavior more flexible and data-driven.\nyou either code it up, binding pointers to data explicitly in the source code, or you\nDataports are a\ntool to help you create a more dynamic and data-driven flow in your programs.\nA dataport is a piece of data that has a unique\nThis data can be a structure, a class, or a simple C++ data type.\nthey are created, dataports register their identity with a manager class.\nin the program can then get access to the dataport by creating a dataport pointer and\nasking the manager class to bind it to the desired dataport.\nThe Dataport\nThe dataport itself is just a template wrapper for a programmer-defined piece of data.\nOnce created, the dataport needs to register its identity.\nThe Dataport Pointer\nthe actual binding of pointer to data is done by the Dataport Manager, rather than\ndataport pointers are as follows:\nThis call asks the Dataport Manager to attach your dataport pointer to your\nThis call returns the pointer to the dataport object, so the actual\nTo detach a dataport pointer from the data it points to, you need to call the\nAfter you have attached a dataport pointer to a dataport, you access the data con-\nThe Dataport Manager\nThe Dataport Manager deals with pointer binding and\nthe Dataport Manager because you need to optimize the internal algorithms to suit\ndelete dataports infrequently and bind pointers often, you might need a representa-\nThe Dataport Manager is a singleton class, meaning that there is always only one\nmultiple Dataport Managers in parallel.\nThe first time I implemented a dataport system, I didn’t have any form of type check-\nbecause it was entirely possible to bind one type of data to a pointer of a different\nThis ID is used by the Dataport Manager to prevent name collisions\nDataports use reference counting to help debug problems like these.\n• When the dataport is registered, this reference count is set to zero.\n• When dataport pointers attach to a dataport, its reference count is incremented\nDataports \n• When dataport pointers detach from a dataport, its reference count is decremented\n• When a dataport is de-registered, its reference count is checked.\nDataport reference counting is a great help with debugging, but it does incur a\ncreated as dataports.\ndataport pointer was simply detached and reattached to a different tripod.\nOne of the most infuriating things when coding game logic is getting hold of data\nDrilling into game class data while maintaining object-\nCommonly accessed game object data can be wrapped in a dataport and exposed\nrize how you navigate through your class hierarchy to get at data, you just need to\nknow its type and its ID, and then let the Dataport Manager find it for you.\nlike game object positional information can be wrapped in dataports for easy access by\nOnce you have your dataport\nDataports are certainly not the silver bullet that will make your code easy to use and\nIf you use any form of hashing in your Dataport Manager, it is entirely possible\nthe dataport type into your storage, but you will have to deal with hash clashes in a\nhead needed to create, delete, and bind dataports with dataport pointers.\nMy personal choice is to use dataports for commonly accessed game elements that\nDataports \nAdding Shaders to Your\nHow are you going to integrate shaders into your engine?\noper, it is tempting to just code the shaders directly into your actors.\nthat approach leads to a dangerous coupling of code, art assets, and shader parameters\nFollowing is a data-driven design to help you incorporate shaders into your\nThis design presents good techniques for isolating most shader parameters\nshaders and parameters in XML with little programmer involvement.\nShader Terminology\nAfter all, shaders can process all sorts of data and are used\nHowever, the term shader has become the standard\nAnother source of confusion is use of the terms fragment shader and pixel shader.\nfragment means that the shader is only computing a “potential” pixel.\nState refers to the entire rendering pipeline, including bound shaders,\nPrograms and Parameters and Managers, Oh My!\npeople mean when they refer to a shader.\nthe vertex and fragment shaders.\nA program can have a vertex shader, a fragment shader, or both.\nshader parameters.\ntype of value that you want to pass into the shader.\nMost parameters are simple data types such as float, int, vec3, and\nloading shader prototypes from the XML definition file, assigning and unassigning\nthe parameters to a state, tracking the assigned shaders, and managing a cache of com-\nThe manager is what you use to find a shader program and assign it\nSupport Your Local Artist: Adding Shaders to Your Engine\nyour actor, why not just add the shader code directly?\nable to test models and shader effects without having to involve a programmer.\nShader\ndevelopers need to be able to edit the parameters of a shader, or even add an entirely\nnew shader without having to edit or recompile code.\nanother, and shader code in yet a third.\nBecause the shaders are easy to\nit easy to reload all the shaders in the system at any time.\nwhenever a new shader is created, keeps a list of all active programs, and has access to\nIt has everything it needs to reload the shader definition XML and\nsystematically replace existing programs and parameters with the updated values.\nWith a single key press, the new shader is loaded and the artist can\nother shader system, engine programmers should do everything in their power to\nintroduce an in-game test system that will allow artists and designers to reload shaders\nloads the shader source code and parameter variables for each instance.\nit precompiles the shaders into a program and adds it to a cache.\nThat way there is no spike in CPU work when applying a shader to a new object\nThis design is further optimized so that any unique shader\nsource code and only differ by the values of the assigned parameters, they both use the\nactual instance instead of a prototype—first, when assigning a prototype shader to a\nmesh and second, when unassigning (that is, destroying) a shader instance from a\nclones the prototype to create a unique shader instance.\nTo support this, both Shader-\nFinally, the manager adds the new program instance to a list called\nand then removes the shader instance from the active list.\nassigning and unassigning results in a unique program instance whose parameters are\nDuring the draw phase, a shader program is composed from both the compiled\nshader code and the associated parameters.\nscene graph, the shader program and the parameters are tracked as independent state\nSupport Your Local Artist: Adding Shaders to Your Engine\nIn other words, you can assign the executable shader program to a mesh\nlevel shader program to cascade down from the top of the scene to any child that\ndoesn’t have its own shader.\nues for common render effects and result in less overall management of your shader\nShader Parameters\nthe way a shader receives data.\nthat are sent to the vertex or fragment shader.\nferent value for each attribute used by a shader.\n• Varying parameters are computed in the vertex shader and sent down to the frag-\nment shader.\nWhich of these types of data should be supported by the ShaderParameter class?\nBecause varying parameters are defined entirely in the vertex and fragment shader and\nattribute, it is likely that the artist is going to use a 3D modeling tool to set values\nThere are many types of parameters supported by shader languages, including inte-\nThe base class provides base data members such as the actual uniform variable,\nparent program, and whether the shader is currently dirty.\nbinds itself to the state and what type of value it manages.\ntor as an example of a complex data type.\nIn order to support the prototype design pattern, each parameter type needs to be able\nSupport Your Local Artist: Adding Shaders to Your Engine",
      "keywords": [
        "dataport",
        "Dataport Manager",
        "shader",
        "dataport pointer",
        "dataport system",
        "data",
        "parameters",
        "shader parameters",
        "manager",
        "code",
        "shader program",
        "tripod dataport pointer",
        "system",
        "program",
        "type"
      ],
      "concepts": [
        "data",
        "code",
        "coding",
        "classed",
        "classes",
        "value",
        "parameters",
        "type",
        "games",
        "programs"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 58,
          "title": "",
          "score": 0.502,
          "base_score": 0.352,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 56,
          "title": "",
          "score": 0.483,
          "base_score": 0.333,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 57,
          "title": "",
          "score": 0.469,
          "base_score": 0.319,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 55,
          "title": "",
          "score": 0.424,
          "base_score": 0.274,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 52,
          "title": "",
          "score": 0.407,
          "base_score": 0.257,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "dataport",
          "shader",
          "dataports",
          "parameters",
          "manager"
        ],
        "semantic": [],
        "merged": [
          "dataport",
          "shader",
          "dataports",
          "parameters",
          "manager"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1718668830453578,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.077187+00:00"
      }
    },
    {
      "chapter_number": 60,
      "title": "Segment 60 (pages 581-592)",
      "start_page": 581,
      "end_page": 592,
      "summary": "essentially acts like a global value for all instances of a shader prototype.\ntype’s parameter instance is returned instead.\nshader program.\nand defines the following shaders.\nBlimp Vertex Shader\nThe vertex shader is extremely simple.\n// Vertex - Simple blimp shader for 'Hover' and 'Highlight' \nNow, let’s take a look at the fragment shader.\nBlimp Fragment Shader\nThe fragment shader is a bit more complex.\nSupport Your Local Artist: Adding Shaders to Your Engine\nThis processor takes in one float uniform and two texture uniforms (Shader-\nTo integrate the new shaders into the engine, the artist adds the following snippet\nto the shader definition XML file:\n<shader name=\"Green\">\n<source type=\"Vertex\">Shaders/green_vert.glsl</source>\n<source type=\"Fragment\">Shaders/green_frag.glsl</source>\n</parameter>\n</parameter>\n</parameter>\n</shader>\nThis entry defines a shader program called Green.\nand fragment shader files.\nand fragment shaders and then added an entry to the definition XML file.\nShader Groups\nShader groups allows several related shaders to be lumped together into one group.\nThis allows the definition of separate shaders for each type of actor, such as damaged\nAlternatively, you could define a shader\nTo implement this, add a new class called ShaderGroup that sits between Shader-\nyou have to look up the group by name before you can find the shader within the\nSupport Your Local Artist: Adding Shaders to Your Engine\nNote that each group tags one of its shaders as the default; there is always one\n<shadergroup name=\"Target Shaders\">\n<shader name=\"Normal\" default=\"yes\">\n</shader>\n<shader name=\"Green\" default=\"no\">\n</shader>\n<shadergroup name=\"Tank Shader\">\n<shader name=\"Normal\" default=\"yes\">\n</shader>\nCombining Shaders with Actors and Properties\nartist or level designer to specify which shader to use for an object by setting the shader\nshaders, the actor property system allows the artists to easily define which shader\nFor fun, the artist used this feature to add a new shader to the\nThe following snippet shows all the code necessary to change the shader applied\nThis method is automatically called whenever the string property for the\nshader gets set.\nThe shader property is just a string that can easily be defined in a map\nTo apply the shader to the\nto only two calls if shader groups are not supported.\n// Set the Actor Property for Shader Group\n// Get the shader group & the default shader \nconst Shader *defaultShader = shaderGroup->GetDefaultShader();\n// Make a new cloned instance of the shader from the prototype\n• XML editor tool—Add a tool that helps the artist create the XML shader defini-\n• Generated shader source—Some engines support the ability to generate shader\nsource code at runtime.\nnique by inserting the generated shader code into the program prototype instead\ncode while still allowing the artist to test new uniforms.\n• Enhanced cache—Maintain separate caches for vertex and fragment shaders.\nThis gem presents a ready-to-use shader architecture that can be integrated directly\nIt makes a case for building a data-driven shader system that can be\nSupport Your Local Artist: Adding Shaders to Your Engine\nBy visiting the nodes in the AST in order, code generation can be\nEach node in the AST has special meaning and information, including whether it\nthat is, to change the meaning of source code.\nthe game is assigned an ID, and the ID is looked up in a table of strings each time it\ndown later and replaced by string ID lookups, and the code needs to be changed to\nIt is useful to have a way to examine existing code to find all the strings, enter\nstrings, it is just as easy to edit code and change strings.\ncompile and compileFile both compile the source code; however, compileFile\ngenerates a .pyc file and compile returns a code object.\nparse/parseFile returns an AST for the Python source code in the buffer or in\nThe walk function does an ordered walk over the AST and calls the appropriate\nthe node information in AST can be extracted.\ncode, assign an ID to each string const found, and save the relationship between the\nstring and the ID to a file called stringres.txt.\nformed again, the string is replaced with the ID, and the new .pyc file is generated.\nfunction was called in source code.\nUse the walk function to walk through the AST of the previous source code, and\nif isinstance(node, compiler.ast.Name):\nreturn node.name\nelif isinstance(node, compiler.ast.Getattr):\nif isinstance( arg, ast.Const ) :\nif node.star_args is not None:\nself.visit(node.star_args)\nif node.dstar_args is not None:\nself.visit(node.dstar_args)\nwill be added to the ID-string map by the utils.helper.append function.\nIn the second phase, the bytecode will be generated by calling compile/compileFile.\nif isinstance( arg, ast.Const ) :\nif node.star_args is not None:\nself.visit(node.star_args)\nif node.dstar_args is not None:\nself.visit(node.dstar_args)\nPlease refer to the full source code on the CD-ROM for more details.",
      "keywords": [
        "shader",
        "AST",
        "code",
        "parameter",
        "shader group",
        "source",
        "fragment shader",
        "source code",
        "artist",
        "shader group actor",
        "shader source code",
        "Python",
        "Adding Shaders",
        "actor",
        "string"
      ],
      "concepts": [
        "nodes",
        "code",
        "string",
        "strings",
        "source",
        "texture",
        "parameters",
        "called",
        "section",
        "sections"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 45,
          "title": "",
          "score": 0.561,
          "base_score": 0.411,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 46,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 49,
          "title": "",
          "score": 0.516,
          "base_score": 0.366,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 48,
          "title": "",
          "score": 0.492,
          "base_score": 0.342,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 47,
          "title": "",
          "score": 0.417,
          "base_score": 0.267,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "shader",
          "shaders",
          "node",
          "ast",
          "code"
        ],
        "semantic": [],
        "merged": [
          "shader",
          "shaders",
          "node",
          "ast",
          "code"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20076988659895523,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.077234+00:00"
      }
    },
    {
      "chapter_number": 61,
      "title": "Segment 61 (pages 593-600)",
      "start_page": 593,
      "end_page": 600,
      "summary": "308–309\n12–13\nuse of, 290–292\nweaknesses of, 291–292\nwith numbers, 555–559\nAC decision-making algorithms, blocks for, 236–238\nActionInfo flow, use in Artificial Contender, 241–242\nactors, combining with shaders, 552–553\nexpansion of, 10–11\nusing in cache replacement, 8–13\n12–13\nattitudes held by, 252–253\ncreating with behavior cloning, 210–216\ntraining, 211–212\nvision model for, 217–219\n215–216\nA* search algorithm, 290–292\nblocks for AC decision-making algorithms, 236–238\ncache replacement, 6–8\nLoop subdivision, 383–390\nLucas and Kanade algorithm in optical flow, 29–30\nparticle deposition, 353–354\nplan-merging algorithm, 284–286\nWELL algorithm, 120–121\nworkflow for Artificial Contender, 230–232\nimplementing, 101–102\nrelief imposters, 407–409\nanimation systems, overview of, 365–366\narrays, use with subdivision data structures, 390–391\nexecution flow in, 235–236\n230–232\nworkflow algorithms for, 230–232\nworkflow diagram for, 234–235\nActionInfo flow, 241–242\nalternative block implementations, 245–246\nconstraints, 246–247\npolymorphic workflow blocks, 238–241\nsample programs in, 72–73\nwith numbers, 555–559\nAtlas terrain system, availability of, 421–422\npotency, 254–255\nvalence, 253–254\nattitude objects, example of, 252, 256–258\nexample of, 261–262\nfeatures of, 250–252\nmodel for, 255–256\ntoward behavior, 258–259\nsurround sound, 315–318\naudio files, playback of, 307–309\n300–301\ncompression and streaming, 337–338\neffects and filters in, 336–337\nsound buffers in, 333–334\naudio tools, using, 326–328\nimplementation of, 487–488\n377–379\nbehavior, attitudes toward, 258–259\ndemo game for, 210–216\nBelady’s Min (OPT) algorithm, use of, 6–13\nbin, selecting based on heap-allocation size, 16–17\nbinding function, creating for Lua, 507–509\nblimp fragment shader code sample, 549–550\nalternative implementations of, 245–246\nimplementation examples, 242–243\npolymorphic workflow blocks, 238–241\n185–188\n184–185\nBrownian trees, use in particle deposition, 359–360\n427–428\nbinding in Lua, 505–510\nstoring, 527–530\nupdating contents of, 529–530\nC++ STL, using with hexagonal grids, 51–52\ncache, function of, 5–6\nA&C (age and cost) considerations, 12–13\ncost of, 11–12\nfeatures of, 382, 388–389\nraytracing demo, 139–140\nusing hexagonal grids with, 56–57\ncentral limit theorem, use with GRNGs, 201–202\nadvantages of, 415–416\nbudgeting updates, 420–421\nimplementing, 417–419\nattitude system, 255–256\nbackscattering, 378–379\nbinding function for Lua, 507–509\nblimp fragment shader, 549–550\nC++ objects as Lua objects, 506–507\n88–89\nkD-tree traversal, 136–137\nLFSR113, 119–120\nLua binding and automatic type registering, 509–510\nLua binding data structure, 505–506\nPython’s AST, 556–557\n552–553\nshaders integrated into engine, 550–551",
      "keywords": [
        "Artificial Contender",
        "Lua binding",
        "Lua",
        "audio",
        "Adaptive Replacement Cache",
        "cache replacement",
        "binding",
        "cache",
        "Artificial",
        "System",
        "Contender",
        "algorithm",
        "function",
        "Lua binding data",
        "dependency system"
      ],
      "concepts": [
        "audio",
        "algorithm",
        "functions",
        "examples",
        "mappings",
        "map",
        "maps",
        "block",
        "effects",
        "attitudes"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "",
          "score": 0.748,
          "base_score": 0.598,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "",
          "score": 0.721,
          "base_score": 0.571,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 62,
          "title": "",
          "score": 0.721,
          "base_score": 0.571,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 7,
          "title": "",
          "score": 0.449,
          "base_score": 0.449,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 28,
          "title": "",
          "score": 0.437,
          "base_score": 0.437,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "lua",
          "binding",
          "workflow",
          "241",
          "13"
        ],
        "semantic": [],
        "merged": [
          "lua",
          "binding",
          "workflow",
          "241",
          "13"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2771063150779791,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.077288+00:00"
      }
    },
    {
      "chapter_number": 62,
      "title": "Segment 62 (pages 601-608)",
      "start_page": 601,
      "end_page": 608,
      "summary": "trigonometric functions, 194–195\nvariables allocated memory for OpenCV, 26–27\nWELL algorithm, 120–121\nand Loop subdivision, 389–390\ncollision detection tasks, using semantics for, 184–188\ncommand lifetime, use with RTS games, 65–66\ncompression, considering in audio processing, 337–338\n71–72\ninterpolating for relief imposters, 404–405\nfor walking dog animation, 409–410\n/dev/random, 121–122\n144–145\ncustom texture cache, design of, 8–13\n390–392\nmetadata for, 517–518\ninstances of classes, 523–525\npointers, 520–523\nusing, 536–537\nuse of, 535–536\n492–493\nadvantages of, 428–430\nDecodeBump function used in, 427–428\nusing, 424–428\n211–215\nsystems, 281–286\ndeferred functions, use of, 82–85\ndependency storage in, 93–94\n/dev/random RNG method, description of, 121–122\nbackscattering, 377–379\nflattening effect of, 375–377\nstructures with, 359–360\n290–292\noperations on, 157–158\nstructures with, 359–360\nDSP effects, considering in surround sound, 317–318\nechoes, calculating, 302–303\nedges, manipulating in Loop subdivision, 384–386\n336–337\naugmenting vision model toolbox with, 219–222\nimplementing for vision model, 221–222\nbackscattering, 377–378\ngraftal-imposter texture coordinates, 452–453\nHermite spline, 192–194\n378–379\nerosion, simulating effects of, 355–356, 429\napplication crashes, 97–100\nmemory leaks, 100–102\nEventBox, use with kD-tree, 134–135\nexception handling, 97–98, 104\n390–391\nuse of attitude in, 252–253\nfading, use with FFT, 312–313\n2D case of, 145–146\nand preprocessing, 144–148\nand runtime queries, 148–150\nrelationship to audio engines, 312–313\n210–211\nrelationship to audio engines, 312–313\n2D case of farthest feature map, 145–146\nbackscattering, 378–379\ndecal techniques, 426–427\nfeature space, 210–211\nflattening effect of diffuse-light shading, 376–377\ngraftal imposters, 449–450\nhead model for lipsyncing, 456–457\nhexagonal tiles with axes of symmetry, 50–51\nIPGs (interactive player graphs), 275–276\nportal for XenoCollide and MPR, 173–174, \n336–337\n256–257\nprocessing, 336–337\n375–377\nof, 308–309\nfeatures of, 326–328\ngoals of, 328–329\n123–124\ncapabilities of, 69–71\nimplementation of, 69–70, 72–75\nrequirements for use with computer vision, 71–72\nsample game, 75–77\ntests with users, 77–78\nfootsteps, randomizing, 328–329\nfragment shaders, use with room acoustics, 302–303\nFringe Search algorithm, using, 293–294\n256–257\n83–84\nContender, 244–245\ngame animation systems, overview of, 365–366\ngame logins, securing, 481–485\ngame sessions, securing, 485–487\ncategorizing changes in, 468–469\nuse of, 200–203\nalternative block implementations in, 245–246\nedges, 384–386\nlimit positions, 387–388\nvertices, 386–387\n442–443\n177–178\nGLRCachePad macro, using in threaded systems, 43–44\ncomponents of, 36–38\ncreating cache-aligned data structures with, 43–44\nusing, 44–45\nsystems, 39–40\noverview of, 281–283\nplan merging for, 283–286\n397–398\nassigning texture coordinates to, 452–453\nusing assets during runtime, 450–453\ntexture atlas, 447–448\nvector fields, 448–450\nuse of, 200–203\nhybrid approach toward, 15–23\nwith large allocator, 18–21\nwith small allocator, 16–18\nwith certainty, 224–226\naddress layer in, 51–53\nimplementing, 54–55\naxes of symmetry, 50–51\ncellular automata, 56–57\npathfinding, 55–56\ncomponents of, 470–476\ncommunication between, 475–476\nconstruction of, 477–478\nviewports in, 476–478\nhook function, use with memory leaks, 101–102\nclosed lists with, 292–293\nby authentication method, 485–486\nprocessing, 336–337\nsystems, 259–260\nArtificial Contender example of, 229–230\nfeature space in, 210–211\nbuilding, 274–278\nclustering, 275–277\njob, 88–89\nscheduler, 89–90\nconstruction of, 132–135\nEventBox used with, 134–135\ntraversal of, 135–138\nfunction in heap allocation, 18–21\nlatency, relationship to audio engines, 313–314\n293–294\ndescription of, 116–117\nleak detector, allocation registry managed by, 101–102\nLFSR113, LFSR258, use of, 119–120\nliking/disliking, evaluating in attitude systems, 253–254\ndescription of, 116–117\nLFSR113, LFSR258, 119–120\nWELL algorithm, 120–121\n218–219",
      "keywords": [
        "Loop subdivision",
        "RNG method",
        "support mapping",
        "model",
        "vision model",
        "subdivision",
        "Artificial Contender",
        "support",
        "Loop",
        "method",
        "systems",
        "attitude systems",
        "game",
        "hexagonal grids",
        "texture"
      ],
      "concepts": [
        "games",
        "gaming",
        "texture",
        "modeling",
        "functions",
        "function",
        "algorithm",
        "systems",
        "allocated",
        "allocation"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "",
          "score": 0.838,
          "base_score": 0.688,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "",
          "score": 0.817,
          "base_score": 0.667,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 61,
          "title": "",
          "score": 0.721,
          "base_score": 0.571,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 35,
          "title": "",
          "score": 0.525,
          "base_score": 0.525,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 6,
          "title": "",
          "score": 0.436,
          "base_score": 0.436,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "377",
          "135",
          "337",
          "systems",
          "use"
        ],
        "semantic": [],
        "merged": [
          "377",
          "135",
          "337",
          "systems",
          "use"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.30644750623913186,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.077345+00:00"
      }
    },
    {
      "chapter_number": 63,
      "title": "Segment 63 (pages 609-616)",
      "start_page": 609,
      "end_page": 616,
      "summary": "finding intersection points of, 157–158\nrequirements for, 455–457\nword to phoneme mapping for, 457–459\nRBF-based warping function, 406–407\ndata structure for, 390–392\nfeature implementation, 388–389\nGPU subdivision and rendering, 397–398\ntoolset for, 383–384\nupdating features, 395–396\nWELL algorithm, 120–121\nattributes, 511–512\nof C++ objects, 505–510\ncreating binding function for, 507–509\nmaking object-oriented, 504–505\nsingletons, 511–512\nstatic functions, 511–512\nuse of, 503–504\nuse in optical flow, 29–30\nuse with optical flow, 31–33\nMA and MB matrices, use in narrow phase, 185–186\nmesh, storing for subdivision data structures, 390–391\nfeatures of, 341–342\nimplementation of, 342–345\nperformance of, 346–347\n358–361\nplaying back audio in, 307–308\n177–178\n171–176\nusing for contact information, 176–178\n185–188\n492–493\nand latency, 313–314\npacket smoothing, 314–315\nsample formats for, 307–309\nstreaming, 309–310\nNFU (Not Frequently Used) algorithm, use of, 7–8\nnodes, managing with large allocators, 19–20\nnoise functions, using with particles, 356–357\nNot Frequently Used (NFU) algorithm, use of, 7–8\n81–83\n293–294\ngrids, 51–53\n337–338\nfunctions of webcamInput class in, 26–27\nuse with optical flow, 25–26\nimage differences, 27–28\nOPT (Belady’s Min) algorithm, use of, 6–13\ngame sample, 30–33\nand image differences, 27–28\ninstantiating objects in, 31–33\nand OpenCV library, 25–26\n362–364\nparent side index, use with large allocators, 19–20\n282–283\nimproving, 354–355\ndunes, 361–362\nmountains, 358–361\noverhanging terrain, 362–364\nvolcanoes, 357–358\nusing noise functions with, 356–357\n482–483\ninsecurity of, 486–487\nA* search algorithm, 290–292\nusing hexagonal grids in, 55–56\nsystems, 259–260\nmapping words to, 457–459\nversus visemes, 457–458\n378–379\nliabilities of, 232–233\n283–286\nplan-merging algorithm, implementing, 284–286\ndesign of, 270–271\noperations on, 157–158\n163–164\nContender, 238–241\ndeconstructing, 323–324\n114–115\nmemory leaks, 100–102\nuse of, 153–154\n547–548\n114–115\n555–559\n114–115\nuses of, 113–114\nrandom walker, use in particle deposition, 353–354\nrank buffers, role in audio processing, 334–336\nshaders, 405–406\n12–13\n12–13\nanimating, 407–409\ninterpolating warping functions for, 404–405\nconsidering in Loop subdivision, 397–398\nof large terrain areas, 442–444\n/dev/random, 121–122\n117–118\nmistakes associated with, 122–124\n114–115\nuses of, 113–114\neliminating, 367–370\nrough surfaces, model for, 374–376\npath sketching in, 62–63\n148–150\nsystem, 89–90\nsearch algorithms, A*, 290–292\ngame logins, 481–485\ngame sessions, 485–487\ncomponents of, 226–227\nshader groups, using, 551–552\n302–303\ntypes of data supported by, 546–547\nusing, 542–543\nevaluating warping functions with, 405–407\nprototypes for, 544–546\nterminology for, 541–542\nrepresenting with support mappings, 166–170\nsupport mappings for, 167–168\nfunctionality of, 365–366\n417–418\nfunction in heap allocation, 16–18\nexample of, 491–492, 496\nvision, 385–386\n63–64\nsound buffers, role in audio processing, 333–334\nsphere, support mapping for, 167–168\nsplines, use of, 192–194\nstreaming audio, 309–310, 337–338\nsubdivision data structure, file format for, 391–392\nproperties of, 381–382\nusage of, 382–383\n201–202\ncombining, 169–170\nusing with shapes, 167–168\nusing with XenoCollide algorithm, 166–170\napproaches toward, 315–316\nuse in HLA systems, 470–471\ncreation of, 475–476\nsynchronization bound to, 473–474\nuse in HLA (High Level Abstraction), 471–472\noverview of, 468–470\nsynchronized objects in, 471–475\ntechniques for, 467–468\nphonemes, 458–459\noverhanging terrain, 362–364\napplying textures to, 435–437\nmanaging virtual textures for, 437–440\ntexture cache for, 437–438\ntexture memory usage for, 439–440\nterrain navigation system, results of, 444–445\nwith, 44–45\ndesign of, 8–13\nusing with large terrains, 437–438\nareas, 439–440",
      "keywords": [
        "algorithm",
        "audio",
        "subdivision",
        "support mapping",
        "functions",
        "function",
        "Linear Recurrence Generators",
        "Loop subdivision algorithm",
        "Linear Congruential Generator",
        "optical flow",
        "terrain",
        "support",
        "number generators",
        "decision-making algorithms",
        "system"
      ],
      "concepts": [
        "usefulness",
        "uses",
        "algorithm",
        "function",
        "functions",
        "functionality",
        "objects",
        "game",
        "classes",
        "model"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 62,
          "title": "",
          "score": 0.838,
          "base_score": 0.688,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "",
          "score": 0.75,
          "base_score": 0.6,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 61,
          "title": "",
          "score": 0.748,
          "base_score": 0.598,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 35,
          "title": "",
          "score": 0.541,
          "base_score": 0.541,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 50,
          "title": "",
          "score": 0.5,
          "base_score": 0.5,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "114",
          "use",
          "subdivision",
          "algorithm",
          "362"
        ],
        "semantic": [],
        "merged": [
          "114",
          "use",
          "subdivision",
          "algorithm",
          "362"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3128955457819708,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.077407+00:00"
      }
    },
    {
      "chapter_number": 64,
      "title": "Segment 64 (pages 617-624)",
      "start_page": 617,
      "end_page": 624,
      "summary": "10–11\ntexture stack, updating for large terrains, 440–441\nthread pools, 41–42\nthread handles, storage of, 39–40\nthread pools, use of, 41–42\nthread stack size, altering default for, 39–40\nGLRThreading library sample, 44–45\nand cache coherency, 43–44\nproperties of, 39–40\nuse of, 38–39\nuse with textures for large terrains, 438\nT-intersections, generation in polygon meshes, 163–164\ndescription of, 117–118\ntotally-ordered plans, use in plan merging, 282–283\nexample of, 182–184\nextracting from matrices, 181–184\nusing for collision detection tasks, 184–188\ntrigonometric functions, fast evaluation of, 194–195\ntrigonometric splines, use of, 192–194\n438–439\ndescription of, 117–118\ntuning application, using with mixing system, 345–346\nunhandled exceptions, reporting, 98–99\ncomponents of, 226–227\n62–63\nvalence, purpose in attitude systems, 253–254\nvariables, allocation in OpenCV, 26–27\nvector of C++ STL, use with hexagonal grids, 51–52\nuse in projective space, 157–158\nwith limited time, 82–83\nrelationship to handheld gaming systems, 82–83\nin Loop subdivision, 384, 386–387\nmanaging for large terrains, 437–440\nmapping to geometry models, 442–443\nversus phonemes, 457–458\nuse with head model for lipsyncing, 455–457\nvision, modeling with certainty, 222–224\naugmenting with ellipses, 219–222\nconsidering in agent-sensing model, 217–219\ncreating, 222–224\nvisitCallFunc, using with AST, 557–558\nwalk function, using with AST, 557–558\nWalker class, using with hexagonal grids, 53–54\nwalking dog animation, control points for, 409–410\nwalking motions, producing, 408–409\nevaluating using shaders, 405–407\ninterpolating for relief imposters, 404–405\nwarrior attitudes, FSM for, 257–258\ncvAbsDiff function in, 27–28\nfunctions in OpenCV, 26–27\nWELL algorithm, use of, 120–121\nWER (Windows Error Reporting), 102–103\nusing with FFT, 312–314\nWindows Error Reporting (WER), 102–103\nwords, mapping to phonemes for lipsyncing, 457–459\n230–232\nusing with Artificial Contender, 234–235\nprocess of, 235–236\nsupport mappings used with, 166–170\nuse of, 171–176\nzone approach, applying to hearing model, 225–226\nl-i»2DO-i9:i-fl • 139.99\nOrder online at www.courseptr.com\n1-59363-290-6 • S29.99\n1-592 WW93-3 • S39.99\n1-598G3n476-3 • S 2 9.99\n1-59863-289-2 • S49.99\nOrder online at www.courseptr.com\n1r-:m rhe indiisirv 4th ucadBmc r«sarc.h in orderln advincB ihs luid ni game dauBbpnant snri hi pnamnla rhe Bccaplanca ed lha study of\nLicense Agreement/Notice of Limited Warranty\nfollowing license agreement and notice of limited warranty, you cannot agree to the terms and conditions set forth, return\nlimited warranty, Course Technology will provide a replacement disc upon the return of a defective disc.\ntutes the entire agreement between you and Course Technology regarding use of the software.",
      "keywords": [
        "large terrain areas",
        "Urban Combat Testbed",
        "Linear Congruential Generator",
        "large terrains",
        "Truncated Linear Congruential",
        "terrain areas",
        "textures texturing terrains",
        "thread",
        "Game",
        "Combat Testbed",
        "texture upload time",
        "thread local storage",
        "Urban Combat",
        "Limited Warranty",
        "model"
      ],
      "concepts": [
        "games",
        "gaming",
        "model",
        "disc",
        "thread",
        "texture",
        "functions",
        "function",
        "functionality",
        "animating"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 62,
          "title": "",
          "score": 0.817,
          "base_score": 0.667,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "",
          "score": 0.75,
          "base_score": 0.6,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 61,
          "title": "",
          "score": 0.721,
          "base_score": 0.571,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 48,
          "title": "",
          "score": 0.541,
          "base_score": 0.541,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 49,
          "title": "",
          "score": 0.471,
          "base_score": 0.471,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "99",
          "terrains",
          "thread",
          "warranty",
          "limited warranty"
        ],
        "semantic": [],
        "merged": [
          "99",
          "terrains",
          "thread",
          "warranty",
          "limited warranty"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.27942848670905973,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:44.077463+00:00"
      }
    },
    {
      "chapter_number": 65,
      "title": "Segment 65 (pages 625-632)",
      "start_page": 625,
      "end_page": 632,
      "summary": "COLOR PLATE 1\nCOLOR PLATE 2\nCOLOR PLATE 3\nCOLOR PLATE 4\nCOLOR PLATE 5\nCOLOR PLATE 6\nCOLOR PLATE 7\nusing color codes.",
      "keywords": [
        "COLOR PLATE",
        "Gem",
        "PLATE",
        "COLOR",
        "command from Gem",
        "force vectors",
        "vectors are illustrated",
        "command",
        "Screenshot",
        "battlefield",
        "created",
        "highlighted",
        "force",
        "vectors",
        "illustrated"
      ],
      "concepts": [
        "gem",
        "color",
        "plate",
        "geometry",
        "manager",
        "dunes",
        "mountains",
        "erosion",
        "non",
        "left"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 49,
          "title": "",
          "score": 0.401,
          "base_score": 0.401,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 10,
          "title": "",
          "score": 0.371,
          "base_score": 0.371,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "",
          "score": 0.342,
          "base_score": 0.342,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "",
          "score": 0.32,
          "base_score": 0.32,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 61,
          "title": "",
          "score": 0.315,
          "base_score": 0.315,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "color plate",
          "plate",
          "plate color",
          "color",
          "vectors"
        ],
        "semantic": [],
        "merged": [
          "color plate",
          "plate",
          "plate color",
          "color",
          "vectors"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1761711300589579,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:44.077510+00:00"
      }
    }
  ],
  "total_chapters": 65,
  "enrichment_provenance": {
    "taxonomy_id": "none",
    "taxonomy_version": "none",
    "taxonomy_path": "none",
    "taxonomy_checksum": "sha256:none",
    "source_metadata_file": "Game Programming Gems 7_metadata.json",
    "enrichment_date": "2025-12-17T23:05:44.091316+00:00",
    "enrichment_method": "msep",
    "model_version": "ai-agents-msep-v1",
    "processing_time_ms": 5170.07046100116,
    "total_similar_chapters": 312
  }
}