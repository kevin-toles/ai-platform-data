{
  "metadata": {
    "title": "More Effective C++",
    "source_file": "More Effective C++_metadata.json"
  },
  "chapters": [
    {
      "chapter_number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "summary": "More Effective C+\nPrograms@inig Designs\nPraise for More Effective C++: 35 New Ways \nto Improve Your Programs and Designs\n“This is an enlightening book on many aspects of C++: both the regions of the \nprograms that use C++ well.\nread Effective C++.” \n— Eric Nagler, C++ Instructor and Author, \n“More Effective C++ is a thorough and valuable follow-up to Scott's first book, \nEffective C++.\nI believe that every professional C++ developer should read and \nMore Effective C++\nAustern, Generic Programming and the STL: Using and Extending the C++ Standard Template Library\nTom Cargill, C++ Programming Style\nStephen C.\nDewhurst, C++ Gotchas: Avoiding Common Problems in Coding and Design\nHanson, C Interfaces and Implementations: Techniques for Creating Reusable Software\nMichi Henning/Steve Vinoski, Advanced CORBA® Programming with C++\nJohn Lakos, Large-Scale C++ Software Design\nScott Meyers, Effective C++ CD: 85 Specific Ways to Improve Your Programs and Designs\nScott Meyers, Effective C++, Third Edition: 55 Specific Ways to Improve Your Programs and Designs\nScott Meyers, More Effective C++: 35 New Ways to Improve Your Programs and Designs\nScott Meyers, Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library\nC++ Programming with the Standard Template Library\nRago, UNIX® System V Network Programming\nW. Richard Stevens, TCP/IP Illustrated, Volume 1: The Protocols\nW. Richard Stevens, TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX®\nRudoff,  UNIX Network Programming Volume 1, Third Edition: The \nW. Richard Stevens/Stephen A.\nRago, Advanced Programming in the UNIX® Environment, Second Edition\nW. Richard Stevens/Gary R.\nMore Effective C++\n35 New Ways to Improve Your Programs and Designs\nMore effective C++: 35 new ways to improve your programs and \n— (Addison-Wesley professional computing series)\nISBN 0-201-63371-X (paperback: alk.\n1. C++ (Computer program language)  I.",
      "keywords": [
        "Effective",
        "Richard Stevens",
        "Programming",
        "Designs Scott MGVGTS",
        "Scott Meyers",
        "Improve Your Programs",
        "UNIX Network Programming",
        "Programs",
        "Standard Template Library",
        "Improve",
        "Designs",
        "Richard",
        "Advanced UNIX Programming",
        "Scott",
        "Programs and Designs"
      ],
      "concepts": [
        "programs",
        "programming",
        "software",
        "networking",
        "unix",
        "john",
        "designs",
        "designations",
        "effective",
        "sales"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 30,
          "title": "",
          "score": 0.894,
          "base_score": 0.744,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 3,
          "title": "",
          "score": 0.863,
          "base_score": 0.713,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 10,
          "title": "",
          "score": 0.59,
          "base_score": 0.44,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "",
          "score": 0.555,
          "base_score": 0.405,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 8,
          "title": "",
          "score": 0.552,
          "base_score": 0.402,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "effective",
          "designs",
          "improve",
          "scott",
          "programs"
        ],
        "semantic": [],
        "merged": [
          "effective",
          "designs",
          "improve",
          "scott",
          "programs"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3790224942349961,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970422+00:00"
      }
    },
    {
      "chapter_number": 2,
      "title": "Segment 2 (pages 9-16)",
      "start_page": 9,
      "end_page": 16,
      "summary": "Item 1:\nItem 2:\nItem 3:\nItem 4:\nItem 5:\nItem 6:\nItem 7:\nItem 8:\nItem 9:\nItem 10:\nItem 11:\nItem 12:\nItem 13:\nItem 14:\nItem 15:\nItem 16:\nItem 17:\nItem 18:\nItem 19:\nItem 20:\nItem 21:\nUnderstand how to combine C++ and C in the\nA great number of people helped bring this book into existence.\nhensive acknowledgments that follow, their book provides hard data\ntax of the new C++ casting operators I describe in Item 2.\nIn Item 3, my warning about deleting an array of derived class objects\nthrough a base class pointer is based on material in Dan Saks’ “Got-\nIn Item 5, the proxy class technique for preventing unwanted applica-\nKoenig's column in the January 1994 C++ Report.\nJames Kanze made a posting to comp.lang.c++ on implementing\nfix functions; I use his technique in Item 6.\nDavid Cok, writing me about material I covered in Effective C++,\nnew operator that is the crux of Item 8.\ntrup’s The Annotated C++ Reference Manual (see page 285).\nin Item 18 is based on Tom Cargill’s article, “A Dynamic vector is\nup column in the January 1994 C++ Report.\nItem 21 was inspired by Brian Kernighan’s paper, “An AWK to C++\nIn Item 26, my design of a template class for counting objects is based\nThe idea of a mixin class to keep track of pointers from operator new\n(see Item 27) is based on a suggestion by Don Box. Steve Clamage\nThe discussion of smart pointers in Item 28 is based in part on Steven\nUSENIX C++ Conference; on section 15.9.1 of Bjarne Stroustrup’s The\nDesign and Evolution of C++ (see page 285); on Gregory Colvin’s “C++\nMemory Management” class notes from C/C++ Solutions ’95; and on\nCay Horstmann’s column in the March-April 1993 issue of the C++ Re-\nIn Item 29, the use of a base class to store reference counts and of\nCay Horstmann in his March-April 1993 column in the C++ Report.\nDan Saks’ column in the C User’s Journal (now the C/C++ Users Jour-\ntion pointers (in Item 31) is based on ideas put forward by Bjarne\nStroustrup in postings to comp.lang.c++ and in section 13.8.1 of his\nThe Design and Evolution of C++ (see page 285).\nThe material in Item 33 is based on several of my C++ Report columns\nMuch of the material in Item 34 was motivated by Steve Clamage’s ar-\nThe Book\nemerging ISO/ANSI standard for C++, and I am grateful to Steve\nthe draft ANSI C++ standard before it was widely available.\ncopy of the internal engineering version of the MetaWare C++ compiler\nChris Guzikowski helped draft the back cover copy for this book, and\nTom Cargill graciously agreed to make his C++ Report article on excep-\nworked on the book.\nNow the book is\nWithout her, this book would have been",
      "keywords": [
        "Item",
        "book",
        "intentionally left blank",
        "John",
        "based",
        "Report",
        "Steve",
        "pointers",
        "Tom Cargill",
        "Acknowledgments",
        "Cay Horstmann",
        "material",
        "left blank Contents",
        "David",
        "page intentionally left"
      ],
      "concepts": [
        "item",
        "classes",
        "john",
        "david",
        "acknowledgments",
        "acknowledge",
        "provides",
        "provided",
        "functions",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 31,
          "title": "",
          "score": 0.778,
          "base_score": 0.628,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 25,
          "title": "",
          "score": 0.705,
          "base_score": 0.555,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 5,
          "title": "",
          "score": 0.66,
          "base_score": 0.51,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 27,
          "title": "",
          "score": 0.627,
          "base_score": 0.477,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 33,
          "title": "",
          "score": 0.578,
          "base_score": 0.428,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "item",
          "item item",
          "report",
          "book",
          "column"
        ],
        "semantic": [],
        "merged": [
          "item",
          "item item",
          "report",
          "book",
          "column"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.46370007487379045,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970492+00:00"
      }
    },
    {
      "chapter_number": 3,
      "title": "Segment 3 (pages 17-24)",
      "start_page": 17,
      "end_page": 24,
      "summary": "less than a decade, C++ has nevertheless emerged as the language of\nby those who do not use C++ is often when they will start, not if.\ncompanying library — which both dwarfs and subsumes that of C —\nC++ compilers continue to proliferate, the features they\nwanted to know what C++ was.\nNow C++ programmers ask higher-level questions: How\nfunctionality not directly supported by the language?\nThis book shows how to design and implement C++ software that is\nof exceptions; more efficient; more portable; makes better use of lan-\nmixed-language environment; is easier to use correctly; is harder to\nThe material in this book is divided into 35 Items.\nFor example, Items 9 through 15 are devoted to exceptions.\nOther Items explain how to combine the features of the language to\nfunctions that act “virtual” on the type of more than one object, how to\nIn More Effective C++, you learn how to use C++ more effec-\nThe descriptions of language features that make up the bulk of\nmost C++ texts are in this book mere background information.\nThe C++ in More Effective C++\nThe C++ I describe in this book is the language specified by the 1998\nInternational Standard for C++.\nThis means I may use a few features\nyour compilers don’t yet support.\ndon’t have access to a compiler offering exceptions, that’s okay.\neven if you don’t have support for exceptions, because those items ex-\nproximate language features your compilers don’t yet support, and it\nsupported features.\ndevelop your code under at least two compilers.\nfeatures supported by only one vendor.\napproximate them with features you do have.\nThe first construct is the bool type, which has as its values the key-\nIf your compilers haven’t implemented bool,\nchanges when you submit it to a compiler that truly supports bool.\nAn alternative is to use a typedef for bool and constant objects for\nthey’re ported to bool-supporting compilers.\ncan’t differentiate between bool and int when overloading functions.\nNot only do they do more than the C-style casts\nI use these new casting forms whenever\nThere is more to C++ than the language itself.\nWhere possible, I employ the standard string type in-\ncould be, see Item 29.) If you don’t have access to an implementation\nof the standard string type, you almost certainly have access to some\nstring-like class.\nUse it.\nI use data structures from the standard library whenever I can.\nIf you currently use a library of algorithms and data structures and are\nmost C++ practitioners draw inheritance arrows from derived to base\nThe static type of a pointer or\nThe dynamic type is determined by the\ntype of object it actually refers to.\nthe classes above:\n// static type of pgo is\n// type is SpaceShip*\n// static type of pa is\n// dynamic type\n// static type of pgo is\n// dynamic type is now\n// type is Asteroid\n“destructor,” and RTTI for C++’s support for runtime type identification\nThat’s because C++ automatically calls con-\nclass Widget { ...\nThis code leaks memory, because the Widget pointed to by pw is never\nthat memory leaks in C++ often leak other resources, too, I usually\nYou won’t see many inline functions in this book.\nportant feature of C++.\nA few C++ features have been deprecated by the standardization com-\nlikely to support deprecated features for many years.\nA client is somebody (a programmer) or something (a class or function,\ntypically) that uses the code you write.\nsections of code that use the Date class are your clients as well.\nuses the software you write, why write it?\nuse the classes or functions you write?\nWhen discussing class or function templates and the classes or func-\nple, if Array is a class template taking a type parameter T, I may refer",
      "keywords": [
        "type",
        "Items",
        "features",
        "n’t",
        "book",
        "code",
        "compilers",
        "language",
        "static type",
        "bool",
        "page intentionally left",
        "intentionally left blank",
        "STL",
        "Standard",
        "language features"
      ],
      "concepts": [
        "classes",
        "compilers",
        "features",
        "language",
        "items",
        "uses",
        "inheritance",
        "type",
        "functionality",
        "functions"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 1,
          "title": "",
          "score": 0.863,
          "base_score": 0.713,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 30,
          "title": "",
          "score": 0.837,
          "base_score": 0.687,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 8,
          "title": "",
          "score": 0.63,
          "base_score": 0.48,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "",
          "score": 0.567,
          "base_score": 0.417,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 10,
          "title": "",
          "score": 0.559,
          "base_score": 0.409,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "features",
          "language",
          "type",
          "bool",
          "items"
        ],
        "semantic": [],
        "merged": [
          "features",
          "language",
          "type",
          "bool",
          "items"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3773553413979999,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970532+00:00"
      }
    },
    {
      "chapter_number": 4,
      "title": "Segment 4 (pages 25-32)",
      "start_page": 25,
      "end_page": 32,
      "summary": "Pointers, references, casts, arrays, constructors — you\nences, dynamic casts, default constructors, and other non-C features\nsyntax for casts and explains why the new casts are superior to the C-\nDistinguish between pointers and references.\nPointers versus References\nPointers and references look different enough (pointers use the “*” and\nBoth pointers and references let you refer to other objects indirectly.\nA refer-\nReferences must\ncan be more efficient to use references than to use pointers.\nPointers versus References\npointers may be reassigned to refer to different objects.\nA reference,\nyou can set the pointer to null) or whenever you need to be able to refer\nYou should use a reference whenever you\nPrefer C++-style casts.\nNew Casting Operators\nStill, C-style casts are not all they might be.\nbetween a cast that changes a pointer-to-const-object into a pointer-\nto-non-const-object (i.e., a cast that changes only the constness of an\nobject) and a cast that changes a pointer-to-base-class-object into a\npointer-to-derived-class-object (i.e., a cast that completely changes an\nTraditional C-style casts make no such distinctions.\nC-style casts were designed for C, not C++.)\nC++ addresses the shortcomings of C-style casts by introducing four\nnew cast operators, static_cast, const_cast, dynamic_cast, and\nreinterpret_cast.\nstatic_cast<type>(expression)\nFor example, suppose you’d like to cast an int to a double to force an\ncasts, you could do it like this:\nWith the new casts, you’d write it this way:\nNew Casting Operators\neral-purpose C-style cast.\nexample, you can’t cast a struct into an int or a double into a\npointer using static_cast any more than you can with a C-style cast.\nFurthermore, static_cast can’t remove constness from an expres-\nsion, because another new cast, const_cast, is designed specifically\nThe other new C++ casts are used for more restricted purposes.\nconst_cast is used to cast away the constness or volatileness of\nBy using a const_cast, you emphasize (to both hu-\nthe cast is the constness or volatileness of something.\nIf you try to employ const_cast for any-\nexpression, your cast will be rejected.\nupdate(const_cast<SpecialWidget*>(&csw));\n// harder-to-recognize C-style cast\nupdate(const_cast<SpecialWidget*>(pw));\nconst_cast can be used only\n// never to cast down the inheritance\nBy far the most common use of const_cast is to cast away the const-\ndynamic_cast to cast pointers or references to base class objects into\npointers or references to derived or sibling base class objects in such a\ncasts are indicated by a null pointer (when casting pointers) or an ex-\nception (when casting references):\nupdate(dynamic_cast<SpecialWidget*>(pw));\nupdateViaRef(dynamic_cast<SpecialWidget&>(*pw));\n(see also Item 24), nor can they cast away constness:\nupdate(dynamic_cast<SpecialWidget*>(&sw));\nIf you want to perform a cast on a type where inheritance is not in-\nTo cast constness away,\nyou always want a const_cast.\nAs a result, reinterpret_casts are\nNew Casting Operators\nThe most common use of reinterpret_cast is to cast between func-\nYou can’t do what you want without a cast, because doSomething has\nA reinterpret_cast lets you force compilers to see things your way:\nreinterpret_cast<FuncPtr>(&doSomething);\nCasting function pointers is not portable (C++ offers no guarantee that\ncasting function pointers unless your back’s to the wall and a knife’s\nIf your compilers lack support for the new casting forms, you can use\ntraditional casts in place of static_cast, const_cast, and\nreinterpret_cast.\n#define static_cast(TYPE,EXPR) \n#define const_cast(TYPE,EXPR) \n#define reinterpret_cast(TYPE,EXPR) ((TYPE)(EXPR))\nupdate(const_cast(SpecialWidget*, &sw));\nfuncPtrArray[0] = reinterpret_cast(FuncPtr, &doSomething);\ncompilers support the new casts.",
      "keywords": [
        "cast",
        "Pointers",
        "refer",
        "C-style casts",
        "references",
        "const",
        "SpecialWidget",
        "type",
        "object",
        "Item",
        "C-style",
        "double",
        "update",
        "null",
        "null pointer"
      ],
      "concepts": [
        "casts",
        "pointers",
        "type",
        "refer",
        "referring",
        "references",
        "making",
        "make",
        "likely",
        "updates"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 12,
          "title": "",
          "score": 0.682,
          "base_score": 0.532,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 22,
          "title": "",
          "score": 0.678,
          "base_score": 0.528,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 23,
          "title": "",
          "score": 0.669,
          "base_score": 0.519,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 20,
          "title": "",
          "score": 0.642,
          "base_score": 0.492,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 24,
          "title": "",
          "score": 0.641,
          "base_score": 0.491,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "cast",
          "casts",
          "const_cast",
          "references",
          "style"
        ],
        "semantic": [],
        "merged": [
          "cast",
          "casts",
          "const_cast",
          "references",
          "style"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.418603675047943,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970572+00:00"
      }
    },
    {
      "chapter_number": 5,
      "title": "Segment 5 (pages 33-40)",
      "start_page": 33,
      "end_page": 40,
      "summary": "Arrays and Polymorphism\nnipulate derived class objects through pointers and references to base\nclass objects.\nulate arrays of derived class objects through base class pointers and\nclass BST { ...\nclass BalancedBST: public BST { ...\nArrays and Polymorphism\nconst BST array[],\ns << array[i];\n// for BST objects\nThis will work fine when you pass it an array of BST objects:\narray of BalancedBST objects:\ns << array[i];\nWe know that array is a\narray+i?\narray), because there are i objects between array[0] and array[i].\narray of BalancedBST objects to printBSTArray, your compilers are\nIn that case, they’d assume each object in the array is\nbase classes, so derived class objects are usually larger than base\nclass objects.\nBST object.\nwill be wrong for arrays of BalancedBST objects, and there’s no telling\narray.\nderived class objects through a base class pointer.\ndelete [] array;\n// array\ndelete [] array;\n// destruct the objects in *array in the inverse order\nfor (int i = the number of elements in the array - 1;\narray[i].BST::~BST();\nsays the result of deleting an array of derived class objects through a\nArray operations almost always\nConstructors initialize objects, so default constructors initialize ob-\nObjects that act like pointers (see Item 28) may reason-\nIn a perfect world, classes in which objects could reasonably be cre-\nated from nothing would contain default constructors and classes in\nconstructor, there are restrictions on how you can use that class.\nclass EquipmentPiece {\nBecause EquipmentPiece lacks a default constructor, its use may be\nis, in general, no way to specify constructor arguments for objects in\nthe array is defined:\nA more general approach is to use an array of pointers instead of an\narray of objects:\nEach pointer in the array can then be made to point to a different\nEquipmentPiece object:\nbestPieces[i] = new EquipmentPiece( ID Number );\nmember to delete all the objects pointed to by the array.\nthe space for the EquipmentPiece objects.\narray, then use “placement new” (see Item 8) to construct the Equip-\n// EquipmentPiece objects; see Item 8 for details on\n// EquipmentPiece array\n// construct the EquipmentPiece objects in the memory \nnew (bestPieces+i) EquipmentPiece( ID Number );\nEquipmentPiece object.\ners idea) allows you to create arrays of objects when a class lacks a de-\nIf you forget this requirement and use the normal array-deletion syn-\nThe second problem with classes lacking default constructors is that\ntemplate, an array of the template parameter type is being created.\nexample, a template for an Array class might look something like this:\ntemplate<class T>\nclass Array {\nArray(int size);\ntemplate<class T>\n// element of the array\ngenerates classes that act like extensible arrays) has no requirement\nThat being the case, classes without default constructors will be in-\nclasses.\nVirtual base classes lacking default constructors are a pain to\nstructors must be provided by the most derived class of the object\nand provide for the virtual base class’s constructors’ arguments.\nobjects of that class.\nclass EquipmentPiece {\nThis allows EquipmentPiece objects to be created like this:\nthe fields of an EquipmentPiece object have been meaningfully initial-\nbeen improved by including a default constructor in a class where\nclasses, too.\nuse such classes, you can expect that the objects they generate are",
      "keywords": [
        "array",
        "objects",
        "BST",
        "EquipmentPiece",
        "Default Constructors",
        "class objects",
        "Default",
        "Item",
        "derived class objects",
        "Constructors",
        "BST array",
        "classes",
        "base class",
        "BST objects",
        "EquipmentPiece objects"
      ],
      "concepts": [
        "arrays",
        "classes",
        "constructors",
        "object",
        "initialize",
        "initialized",
        "initial",
        "casts",
        "templates",
        "delete"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 2,
          "title": "",
          "score": 0.66,
          "base_score": 0.51,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 27,
          "title": "",
          "score": 0.565,
          "base_score": 0.415,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 25,
          "title": "",
          "score": 0.548,
          "base_score": 0.398,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 31,
          "title": "",
          "score": 0.545,
          "base_score": 0.395,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 16,
          "title": "",
          "score": 0.497,
          "base_score": 0.347,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "array",
          "equipmentpiece",
          "bst",
          "objects",
          "array array"
        ],
        "semantic": [],
        "merged": [
          "array",
          "equipmentpiece",
          "bst",
          "objects",
          "array array"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.33604839297493483,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970605+00:00"
      }
    },
    {
      "chapter_number": 6,
      "title": "Segment 6 (pages 41-51)",
      "start_page": 41,
      "end_page": 51,
      "summary": "Operators\nOperators\na measure of power into the functions behind the operators that’s un-\ntors and implicit type conversion operators are particularly trouble-\nConversion Functions\nC++ allows compilers to perform implicit conversions between types.\nConversion Functions\ninformation — are also present in C++, including conversion of int to\nfunctions compilers are allowed to use for implicit type conversions.\nTwo kinds of functions allow compilers to perform such conversions:\nsingle-argument constructors and implicit type conversion operators.\nAn implicit type conversion operator is simply a member function with\na strange-looking name: the word operator followed by a type specifi-\nYou aren’t allowed to specify a type for the function’s return\nFor example, to allow Rational objects to be implicitly\noperator double() const;\nplain is why you usually don’t want to provide type conversion func-\nLet us deal first with implicit type conversion operators, as they are the\nRational::operator double.\nconversion operators: their presence can lead to the wrong function\nversion of a Rational object to a double, replace operator double\nNo operator<<\nConversion Functions\nconversion operators.\nfunction, c_str, that performs that conversion.\nImplicit conversions via single-argument constructors are more diffi-\nin many cases worse than those arising from implicit type conversion\noperators.\nAs an example, consider a class template for array objects.\nArray(int size);\nT& operator[](int index);\ntor, this function is ineligible for use as a type-conversion function.\nsecond constructor, which allows clients to define Array objects by\ntype conversion function, and that can lead to endless anguish.\nray<int> objects and some code that uses such objects:\nbool operator==( const Array<int>& lhs, \nconst Array<int>& rhs);\nArray<int> a(10);\nArray<int> b(10);\nfor (int i = 0; i < 10; ++i)\nThat’s because they see a call to operator== with arguments of type\ntor== function taking those types, our compilers notice they can con-\nvert the int into an Array<int> object by calling the Array<int>\nconstructor that takes a single int as an argument.\nfor (int i = 0; i < 10; ++i)\nThe drawbacks to implicit type conversion operators can be avoided by\nthe problem of implicit type conversion, and its use is about as\nConversion Functions\nposes of implicit type conversion.\nexplicit Array(int size);\nArray<int> a(10);\nArray<int> b(10);\n// int to Array<int>\nif (a == Array<int>(b[i])) ...\nif (a == (Array<int>)b[i]) ...\nconstructors as implicit type conversion functions.\nsequences of implicit type conversions are legitimate and which are\nargument constructor or an implicit type conversion operator).\nObjects of this type have only one\nConsider what happens when an Array object is defined via the class’s\nArray<int> a(10);\nYour compilers are asked to call a constructor in the Array<int> class\nject, and that ArraySize object is just what the Array<int> construc-\nThis allows the function call (and the attendant object construction) to\nThe fact that you can still construct Array objects with an int argu-\nIncrement and Decrement Operators\nbool operator==( const Array<int>& lhs, \nconst Array<int>& rhs);\nArray<int> a(10);\nArray<int> b(10);\nfor (int i = 0; i < 10; ++i)\nCompilers need an object of type Array<int> on the right-hand side of\nthe “==” in order to call operator== for Array<int> objects, but there\nmore, compilers cannot consider converting the int into a temporary\nArraySize object and then creating the necessary Array<int> object\nAn ArraySize object is really just a stand-in for the inte-\ncase implicit type conversions — that is otherwise beyond your grasp,\nof increment and decrement operators.\nIncrement and Decrement Operators\noverloading both forms of increment and decrement operators.\npostfix forms take an int argument, and compilers silently pass 0 as\nthat int when those functions are called:\nUPInt& operator++();\nconst UPInt operator++(int);\nUPInt& operator--();\nconst UPInt operator--(int); // postfix --\nUPInt& operator+=(int);\n// a += operator for UPInts\n// and ints\n// calls i.operator++();\n// calls i.operator++(0);\n// calls i.operator--();\n// calls i.operator--(0);\nof these operators return different types.\nturn a reference, postfix forms return a const object.\non the prefix and postfix ++ operators, but the story for the -- operators\nform of the increment operator is sometimes called “increment and\nIncrement and Decrement Operators\nconst UPInt UPInt::operator++(int)\nNote how the postfix operator makes no use of its parameter.\nIt’s clear why postfix increment must return an object (it’s returning\nint i;\napplication of operator++ in a double increment changes the value of\noperator++, how-\nthose returned from postfix operator++ — can’t call it.† If you’ve ever\nwondered if it makes sense to have functions return const objects,",
      "keywords": [
        "array",
        "int",
        "type conversion operators",
        "implicit type conversion",
        "type conversion",
        "operator",
        "conversion",
        "Rational",
        "Increment",
        "type",
        "implicit type",
        "conversion operators",
        "postfix increment",
        "postfix",
        "conversion functions"
      ],
      "concepts": [
        "functions",
        "operators",
        "array",
        "conversions",
        "classes",
        "increment",
        "objects",
        "rational",
        "types",
        "typed"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 13,
          "title": "",
          "score": 0.507,
          "base_score": 0.507,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 29,
          "title": "",
          "score": 0.452,
          "base_score": 0.452,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 20,
          "title": "",
          "score": 0.437,
          "base_score": 0.437,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 12,
          "title": "",
          "score": 0.42,
          "base_score": 0.42,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 22,
          "title": "",
          "score": 0.408,
          "base_score": 0.408,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "int",
          "array int",
          "conversion",
          "array",
          "type conversion"
        ],
        "semantic": [],
        "merged": [
          "int",
          "array int",
          "conversion",
          "array",
          "type conversion"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.32741441730061643,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:49.970636+00:00"
      }
    },
    {
      "chapter_number": 7,
      "title": "Segment 7 (pages 52-60)",
      "start_page": 52,
      "end_page": 60,
      "summary": "That is, if you overload operator&&,\n// when operator&& is a\n// when operator&& is a\nthe comma operator!\nguments in a function call (to operator,).\ncomma operator being evaluated first, because compilers are not con-\nAfter all, if you can overload the comma operator, what can’t you over-\noperators:\nnew\noperator new\noperator delete\noperator new[]\noperator delete[]\n(For information on the new and delete operators, as well as opera-\ntor new, operator delete, operator new[], and operator de-\ntween the new operator and operator new.\nstring *ps = new string(\"Memory Management\");\nthe new you are using is the new operator.\nit allocates enough memory to hold a string object.\nconstructor to initialize an object in the memory that was allocated.\nThe new operator always does those two things; you can’t change its\nWhat you can change is how the memory for an object is allocated.\nnew operator calls a function to perform the requisite memory alloca-\nThe name of the function the new operator calls to allocate memory\nis operator new.\nThe operator new function is usually declared like this:\nvoid * operator new(size_t size);\nerator new that initializes the memory to some value before returning\nYou can overload operator\nYou’ll probably never want to call operator new directly, but on the off\nvoid *rawMemory = operator new(sizeof(string));\nHere operator new will return a pointer to a chunk of memory large\nLike malloc, operator new’s only responsibility is to allocate memory.\nAll operator new understands is\nIt is the job of the new operator to take the raw\nmemory that operator new returns and transform it into an object.\nstring *ps = new string(\"Memory Management\");\noperator new(sizeof(string));\n// the new object\nThat’s why you must use the new operator if you\nA special version of operator new called\nThis looks a little strange at first, but it’s just a use of the new operator\nplicit call that the new operator makes to operator new.\nThe operator\nThat operator new is placement new, and it\nvoid * operator new(size_t, void *location)\nAfter all, the purpose of operator new is to find mem-\nlationship between the new operator and operator new, though per-\nyou want to create an object on the heap, use the new operator.\nallocates memory and calls a constructor for the object.\nwant to allocate memory, call operator new; no constructor will be\nnew and use the new operator; it will automatically invoke your custom\nversion of operator new.\nThe function operator delete is\nto the built-in delete operator as operator new is to the new operator.\nThe memory deallocation is performed by the operator delete func-\noperator delete(ps);\ntialized memory, you should bypass the new and delete operators en-\nInstead, you should call operator new to get the memory and\noperator delete to return it to the system:\noperator new(50*sizeof(char));\noperator delete(buffer);\nIf you use placement new to create an object in some memory, you\nshould avoid using the delete operator on that memory.\n// functions for allocating and deallocating memory in\n// new is used\n// mallocShared, not operator new\nThe new being used is still the new operator, but because an array is\nbeing created, the new operator behaves slightly differently from the\ncated by operator new.\nequivalent, a function called operator new[] (often referred to as “ar-\nray new.”) Like operator new, operator new[] can be overloaded.\nsame way you can control memory allocation for single objects.\n(operator new[] is a relatively recent addition to C++, so your compil-\nnew will be used to allocate memory for every array, regardless of the\nthe global operator new.\nBy default, the global operator new handles all dynamic memory allo-\nFurthermore, there is only one global operator new\ncompilers lacking support for operator new[].)\nThe second way in which the new operator behaves differently for ar-\n// call operator new[] to allocate\n// memory for 10 string objects,\nSimilarly, when the delete operator is used on an array, it calls a de-\nstructor for each array element and then calls operator delete[] to\n// operator delete[] to \nor overload operator delete[].\nThe new and delete operators are built-in and\nof the new and delete operators, remember that you can’t really do it.",
      "keywords": [
        "operator",
        "Memory",
        "operator delete",
        "comma operator",
        "delete",
        "object",
        "call",
        "calls operator delete",
        "function",
        "string",
        "call operator",
        "overload operator delete",
        "n’t",
        "comma",
        "overload operator"
      ],
      "concepts": [
        "memory",
        "operators",
        "object",
        "void",
        "likely",
        "string",
        "functions",
        "function",
        "expressions",
        "expression"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 24,
          "title": "",
          "score": 0.685,
          "base_score": 0.535,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 21,
          "title": "",
          "score": 0.663,
          "base_score": 0.513,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 12,
          "title": "",
          "score": 0.628,
          "base_score": 0.478,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 13,
          "title": "",
          "score": 0.612,
          "base_score": 0.462,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 22,
          "title": "",
          "score": 0.569,
          "base_score": 0.419,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "operator",
          "new",
          "operator new",
          "new operator",
          "delete"
        ],
        "semantic": [],
        "merged": [
          "operator",
          "new",
          "operator new",
          "new operator",
          "delete"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.37798143855284005,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970673+00:00"
      }
    },
    {
      "chapter_number": 8,
      "title": "Segment 8 (pages 61-75)",
      "start_page": 61,
      "end_page": 75,
      "summary": "Exceptions\nExceptions\nThe addition of exceptions to C++ changes things.\nnity does not know about writing programs using exceptions, includ-\nThat being the case, why use exceptions?\nIf a function signals an exceptional\nused with C++: it fails to call destructors for local objects when it ad-\nIf you need a way of signaling exceptional conditions that cannot\nwhen searching the stack for code that can handle exceptional condi-\ntions, you need C++ exceptions.\nBecause we have much to learn about programming with exceptions,\nations for anyone using exceptions in C++.\nUse destructors to prevent resource leaks.\n// delete object that\nbecause readALA creates a new heap object each time it’s called.\nout the call to delete, the loop would contain a resource leak.\nexception.\nprocessAdoptions fails to catch exceptions, so the excep-\na result, anytime pa->processAdoption throws an exception, pro-\n// catch all exceptions\n// exception is thrown\n// propagate exception to caller\n// exception is thrown\nthrowing an exception, we need to delete pa, so why should we have to\nalways be executed into the destructor for an object local to process-\nThat’s because local objects are always destroyed when\nprocessAdoptions into a destructor for an object local to processA-\nThe solution is to replace the pointer pa with an object that acts like a\nThat way, when the pointer-like object is (automatically) de-\nObjects that act like\nplains, you can make pointer-like objects very smart indeed.\npointer-like object that knows enough to delete what it points to when\nthe pointer-like object goes out of scope.\nIt’s not difficult to write a class for such objects, but we don’t need to.\nThe standard C++ library contains a class template called auto_ptr\nEach auto_ptr class takes a pointer to a\nheap object in its constructor and deletes that object in its destructor.\nBoiled down to these essential functions, auto_ptr looks like this:\nclass auto_ptr {\n// save ptr to object\n// delete ptr to object\n// raw ptr to object\nclear: use auto_ptr objects instead of raw pointers, and you won’t\nhave to worry about heap objects not being deleted, not even when ex-\n(Because the auto_ptr destructor uses the sin-\ngle-object form of delete, auto_ptr is not suitable for use with\npointers to arrays of objects.\nUsing an auto_ptr object instead of a raw pointer, processAdop-\nFirst, pa is declared to be an auto_ptr<ALA> object, not a\nstruction, auto_ptr objects act just like normal pointers.\nThe idea behind auto_ptr — using an object to store a resource that\n// this function may leak resources if an exception\nIf an exception is thrown during the process of displaying\ntion of a WindowHandle object, because it means you can use a Win-\n// exception is thrown\nEven if an exception is thrown within displayInfo, the window cre-\nobjects, you can usually avoid resource leaks in the presence of excep-\nBut what happens if an exception is thrown while you’re in the\nWhat happens if an exception is thrown\nItem 10: Prevent resource leaks in constructors.\ncase, there is no guarantee that local objects (such as w in the example) will have their\nclass BookEntry {\nBookEntry(const string& name,\nA straightforward way to write the BookEntry constructor and de-\nBookEntry::BookEntry(const string& name, \nThe constructor initializes the pointers theImage and theAudioClip\nThe destructor deletes both pointers,\nthus ensuring that a BookEntry object doesn’t give rise to a resource\nBecause C++ guarantees it’s safe to delete null pointers, BookEn-\ntry’s destructor need not check to see if the pointers actually point to\nConsider what will happen if an exception is thrown during execution\nof this part of the BookEntry constructor:\nAn exception might arise because operator new (see Item 8) is unable\narise because the AudioClip constructor itself throws an exception.\nBookEntry object is being created.\nNow, if an exception is thrown during creation of the object theAudio-\nBookEntry constructor), who deletes the object that theImage already\nThe obvious answer is that BookEntry’s destructor does,\nBookEntry’s destructor will never be\nC++ destroys only fully constructed objects, and an object isn’t fully\nBookEntry object b is created as a local object,\nand an exception is thrown during construction of b, b’s destructor will\n// catch all exceptions\n// exception is thrown\n// propagate exception to\nyou’ll find that the Image object allocated inside BookEntry’s con-\nIf BookEntry’s constructor throws an excep-\ntion, pb will be the null pointer, so deleting it in the catch block does\npointer class auto_ptr<BookEntry> (see Item 9) instead of a raw\nThere is a reason why C++ refuses to call destructors for objects that\non an object that wasn’t fully constructed, how would the destructor\nadded to each object indicating how much of the constructor had been\nBecause C++ won’t clean up after objects that throw exceptions during\nceptions, executing some cleanup code, then rethrowing the exception\nBookEntry constructor like this:\n// catch any exception\n// propagate the exception\nThere is no need to worry about BookEntry’s non-pointer data mem-\nexception arises in the BookEntry constructor†.\njects’ constructors call functions that might throw exceptions, those\nconstructors have to worry about catching the exceptions and per-\nare almost the same as those in BookEntry’s destructor.\nhelper function and have both the constructor and the destructor call\nclass BookEntry {\n// propagate exception\nsign our BookEntry class slightly differently so that theImage and\nclass BookEntry {\nBookEntry’s constructors, because there is no other way to give const\n// exception is thrown\nexception is thrown during initialization of theAudioClip, the object\ntions propagate out of a constructor is to catch those exceptions, so if\nfunctions that return pointers with which theImage and theAudio-\nclass BookEntry {\nThis function therefore handles no exceptions\nImage * BookEntry::initImage(const string& imageFileName)\n// sure theImage’s resources are released if an exception\nAudioClip * BookEntry::initAudioClip(const string&\ncated objects and that those objects should be deleted when the point-\nwhich the auto_ptr classes (see Item 9) were designed.\nclass BookEntry {\nconst auto_ptr<Image> theImage;\nconst auto_ptr<AudioClip> theAudioClip; // auto_ptr objects\nDoing this makes BookEntry’s constructor leak-safe in the presence of\nexceptions, and it lets us initialize theImage and theAudioClip using\nIn this design, if an exception is thrown during initialization of the-\nAudioClip, theImage is already a fully constructed object, so it will\nobjects, they’ll be destroyed automatically when the BookEntry object\ncorresponding auto_ptr objects, you fortify your constructors against\nresource leaks in the presence of exceptions, you eliminate the need to\nconst pointers.\nDealing with the possibility of exceptions during construction can be\ntricky, but auto_ptr (and auto_ptr-like classes) can eliminate most\nItem 11: Prevent exceptions from leaving destructors.\nExceptions and Destructors\nis destroyed by the exception-handling mechanism during the stack-",
      "keywords": [
        "const string",
        "Prevent Resource Leaks",
        "BookEntry",
        "resource leaks",
        "exception",
        "const",
        "object",
        "Exceptions",
        "resource",
        "string",
        "Avoiding Resource Leaks",
        "Item",
        "ptr",
        "delete",
        "theImage"
      ],
      "concepts": [
        "objects",
        "pointers",
        "classes",
        "exceptions",
        "exception",
        "exceptional",
        "liked",
        "likely",
        "delete",
        "deleted"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 9,
          "title": "",
          "score": 0.779,
          "base_score": 0.629,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 3,
          "title": "",
          "score": 0.63,
          "base_score": 0.48,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 18,
          "title": "",
          "score": 0.623,
          "base_score": 0.473,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 17,
          "title": "",
          "score": 0.614,
          "base_score": 0.464,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "",
          "score": 0.602,
          "base_score": 0.452,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "bookentry",
          "exception",
          "exceptions",
          "auto_ptr",
          "exception thrown"
        ],
        "semantic": [],
        "merged": [
          "bookentry",
          "exception",
          "exceptions",
          "auto_ptr",
          "exception thrown"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.35979639310872324,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970725+00:00"
      }
    },
    {
      "chapter_number": 9,
      "title": "Segment 9 (pages 76-97)",
      "start_page": 76,
      "end_page": 97,
      "summary": "Exceptions and Destructors\nThat being the case, an exception may or may not be active when a de-\nwhile another exception is active, C++ calls the terminate function.\nthrows an exception.\nThe exception would not be caught in Session’s\nfunction, uncaught_exception, that returns true if an exception is active and has\nprevent the exception thrown by logDestruction from propagating\nto operator<< in the catch block results in an exception being\ndestructions if logDestruction throws an exception:\nThat block prevents exceptions thrown from logDestruction\nIf an exception is thrown from a destruc-\nwill stop at the point where the exception is thrown.) If the destructor\nThrowing Exceptions Compared to Calling Functions\n// exceptions\nHere, if logDestruction throws an exception, the transaction started\nnate the problem, but if endTransaction might throw an exception,\nItem 12: Understand how throwing an exception \nThrowing Exceptions Compared to Calling Functions\n// catch exceptions of\nYou might therefore assume that passing an exception from a throw\nand exceptions by value, by reference, or by pointer.\nwhen you pass parameters and exceptions, however, is quite different.\nturn), but when you throw an exception, control does not return to the\nthrows a Widget as an exception:\n// throw localWidget as an exception\na different story when localWidget is thrown as an exception.\ngardless of whether the exception is caught by value or by reference (it\nthat’s why C++ specifies that an object thrown as an exception is cop-\nThrowing Exceptions Compared to Calling Functions\na copy of localWidget would still be made when the exception was\nThis means that even if the exception is caught by reference,\ning and throwing an exception: the latter is typically much slower than\nWhen an object is copied for use as an exception, the copying is per-\n// exception of type\nHere a Widget exception is thrown, even though rw refers to a Spe-\nThe fact that exceptions are copies of other objects has an impact on\nhow you propagate exceptions from a catch block.\n// catch Widget exceptions\n// handle the exception\n// rethrow the exception so it\n// catch Widget exceptions\n// handle the exception\n// caught exception\nthe current exception, while the second one throws a new copy of the\ncurrent exception.\nIn particular, if the exception originally thrown was of type\nis made when the exception is rethrown.\nthrows a new exception, which will always be of type Widget, because\nthat that will change the type of the exception being propagated.\nexception object.\n(Incidentally, the copy made for an exception is a temporary object.\nWidget exception thrown by passAndThrowWidget.\n// catch exception by value\n// catch exception by\n// catch exception by\nand exception propagation.\nThrowing Exceptions Compared to Calling Functions\n(see Item 19), but it is for exceptions.\ntion of copying exception objects.\nwe pass an exception by value.\nSimilarly, when we catch an exception by\nwe still expect to pay for the creation of a copy of the exception: the\nWe have not yet discussed throwing exceptions by pointer, but throw\nwhen the exception leaves the local object’s scope.\nfrom exception propagation.\nsuch conversions are not applied when matching exceptions to catch\n// handle exceptions of \nthe int exception thrown inside the try block will never be caught by\nAs a result, if the int exception is to be caught, it will have to be by\nclause for base class exceptions is allowed to handle exceptions of (pub-\ntion of the hierarchy of exceptions defined by the standard C++ library:\nexception\nThrowing Exceptions Compared to Calling Functions\nA catch clause for runtime_errors can catch exceptions of type\ncatch clause accepting an object of the root class exception can\ncatch any kind of exception derived from this hierarchy.\nexception of any pointer type:\n// catches any exception \nexception is that catch clauses are always tried in the order of their ap-\n// exceptions, even those\n// exceptions will be caught\n// exceptions here\nthrowing the object as an exception.\nFirst, exception objects are always\nItem 13: Catch exceptions by reference.\nCatching Exceptions\nWhen you write a catch clause, you must specify how exception ob-\ning an exception from throw site to catch clause (see Item 15).\nbecause throw by pointer is the only way of moving exception informa-\nclass exception { ...\n// library exception \nstatic exception ex;\n// exception object\nCatching Exceptions\n// may throw an exception*\ncatch (exception *ex) {\n// catches the exception*;\nFor this to work, programmers must define exception objects in a way\nexception ex;\n// local exception object; \nthrow new exception;\n// exception!)\nIf the exception object was allo-\nthe exception object wasn’t allocated on the heap, they mustn’t, other-\nbal or static object, others might pass the address of an exception on\nThe four standard exceptions —\npected exceptions; see Item 14) — are all objects, not pointers to ob-\nCatch-by-value eliminates questions about exception deletion and\nworks with the standard exception types.\nclass exception objects caught as base class exceptions have their de-\nclass exception {\n// standard exception class\n// of the exception (see\npublic exception { ...\n// C++ exception hierarchy\n// in class exception above\nCatching Exceptions\n// exception\n// exception\ncatch (exception ex) {\n// catches all exceptions\n// calls exception::what(),\nthe thrown exception is of type Validation_error and\ncatching the standard exception types.\nno slicing problem, and exception objects are copied only once.\ncatch (exception& ex) {\n// not exception::what()\nthey redefine those in exception.\nmodify the exception object in the handler, you’d catch not just by ref-\nand damned if you don’t; you avoid slicing exception objects; you re-\ntain the ability to catch standard exceptions; and you limit the number\nof times exception objects need to be copied.\nCatch exceptions by reference!\nItem 14: Use exception specifications judiciously.\nException Specifications\nwith a violated exception specification is to halt.\nA violated exception\nException Specifications\nwith exception specifications.\nConsider a declaration for a function f1 that has no exception specifi-\nSuch a function may throw any kind of exception:\nNow consider a function f2 that claims, through its exception specifi-\ncation, it will throw only exceptions of type int:\nan exception that would violate f2’s exception specification:\ncertainly looks as if it couldn’t throw any exceptions:\nfunctions generated from the template will throw no exceptions.\nerator& may throw an exception when called from inside opera-\nIf it does, our exception specification is violated, and off to\nthere is no way to know anything about the exceptions thrown by a\nexception specification for a template, because templates almost in-\nexception specifications on functions making calls to functions that\nthemselves lack exception specifications.\nException Specifications\n// a callback function without an exception specification\n// might throw an exception\n// a callback function with an exception specification\nThis checking of exception specifications when passing function point-\nexceptions “the system” may throw.\nOf these exceptions, the most com-\nthe possibility that the function will encounter a bad_alloc exception.\ncall functions in libraries that don’t use exception specifications, it’s\nimpractical to prevent unexpected exceptions from arising, because\nfact that C++ allows you to replace unexpected exceptions with excep-\npected exceptions to be replaced by UnexpectedException objects.\n// all unexpected exception\n// an unexpected exception\nOnce you’ve done this, any unexpected exception results in convert-\nThe unexpected exception is then replaced\nby a new exception of type UnexpectedException.\n(If the exception specification\nAnother way to translate unexpected exceptions into a well known type\nthrows the current exception, that exception will be replaced by a new\nexception of the standard type bad_exception.\n// an unexpected exception\n// the current exception\nException Specifications\nIf you do this and you include bad_exception (or its base class, the\nstandard class exception) in all your exception specifications, you’ll\nBy now you understand that exception specifications can be a lot of\nException specifications have another drawback, too,\nthrows no exceptions.\nstruction throws an exception that logDestruction fails to catch.\nwrite code that leads to the violation of exception specifications.\nIf logDestruction had no exception specification,\nprovide excellent documentation on the kinds of exceptions a function\nis expected to throw, and for situations in which violating an exception\ndealing with unexpected exceptions, even when they know how to.\nItem 15: Understand the costs of exception handling.\nThe Costs of Exception Handling\nTo handle exceptions at runtime, programs must do a fair amount of\nidentify the objects that require destruction if an exception is thrown;\nclauses and the types of exceptions those clauses can handle.\nensure that exception specifications are satisfied.\nclause when an exception is thrown.\nNo, exception handling has costs,\ntheless, programs compiled without support for exceptions are typi-\nsupport for exceptions.\nIn theory, you don’t have a choice about these costs: exceptions are\nobject file doesn’t do anything with exceptions doesn’t mean others\nThe Costs of Exception Handling\nexception-handling behavior at runtime.\ncompile without exception-handling support and save yourself the size\nyou have already decided not to use exceptions.\nthey can guarantee that exceptions thrown from client code never\nA second cost of exception-handling arises from try blocks, and you\nable to catch exceptions.\nCompilers tend to generate code for exception specifications much as\nthey do for try blocks, so an exception specification generally incurs\nthat are exceptional.\nhit you’ll take if you throw an exception, and the answer is it’s proba-\nfunction by throwing an exception may be as much as three orders of\nan exception, and that should be almost never.\nIf support for exceptions is a rel-\nslower if lots of exceptions are thrown?\ncost of exception handling, you don’t want to pay any more than you\nTo minimize your exception-related costs, compile without\nblocks and exception specifications to those locations where you hon-\nestly need them; and throw exceptions only under conditions that are\ntruly exceptional.",
      "keywords": [
        "exception",
        "Exceptions",
        "exception specifications",
        "catch",
        "Widget",
        "catch Widget exceptions",
        "Session",
        "function",
        "Item",
        "throw",
        "catch clause",
        "object",
        "exception objects",
        "catch exceptions",
        "Throwing Exceptions Compared"
      ],
      "concepts": [
        "exceptions",
        "exception",
        "exceptional",
        "objects",
        "throws",
        "function",
        "functions",
        "catch",
        "catches",
        "void"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 8,
          "title": "",
          "score": 0.779,
          "base_score": 0.629,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 3,
          "title": "",
          "score": 0.537,
          "base_score": 0.387,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 18,
          "title": "",
          "score": 0.517,
          "base_score": 0.367,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "",
          "score": 0.515,
          "base_score": 0.365,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 17,
          "title": "",
          "score": 0.512,
          "base_score": 0.362,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "exception",
          "exceptions",
          "catch",
          "throw",
          "specifications"
        ],
        "semantic": [],
        "merged": [
          "exception",
          "exceptions",
          "catch",
          "throw",
          "specifications"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3105402124290068,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970757+00:00"
      }
    },
    {
      "chapter_number": 10,
      "title": "Segment 10 (pages 98-107)",
      "start_page": 98,
      "end_page": 107,
      "summary": "Furthermore, though some programs take longer and use\nWriting efficient programs in C++ starts with the recognition that C++\nIf you want to write an efficient C++ program, you must\nfirst be able to write an efficient program.\nin any programming language.\nmany objects.\nlike a hemorrhage on your program’s performance, with precious\nPrograms don’t get big and slow only by creating too many objects.\nThe 80-20 rule states that 80 percent of a program’s resources are\ncesses are performed for about 20 percent of the code; 80 percent of\nthe time its efficiency doesn’t affect the overall performance of the sys-\nplies that if your software has a performance problem, you’ve got a\nacteristics of their programs, because program performance charac-\npoured into improving the efficiency of parts of programs that will\nThe fact that programs tend to have unintuitive performance charac-\nof your program.\nWhat will work is to empirically identify the 20 percent of your program\npercent is to use a program profiler.\nFor example, if your program is too slow, you want a profiler\nprogram.\nfor example, you think you’re creating about a hundred objects of a\nOf course, even the best of profilers is hostage to the data it’s given to\nIf you profile your program while it’s processing unrepresen-\nticular run (or set of runs), so if you profile a program using input data\nprofile your software using as many data sets as possible.\nare happy to let you use their data when profiling.\nnever perform at all.\nwhy would you put code in your program to do it in the first place?\nlazy evaluation, you write your classes in such a way that they defer\nclass String { ...\nString s2 = s1;\nA common implementation for the String copy constructor would re-\nexpense, because it would have to make a copy of s1’s value to give to\noperator (see Item 8) and calling strcpy to copy the data in s1 into the\nthey only read values, they don’t write them:\n// read s1’s value\nIn fact, the only time the sharing of values makes a difference is when\none or the other string is modified; then it’s important that only one\nTo handle statements like this, we have to implement String’s con-\nvertToUpperCase function so that it makes a copy of s2’s value and\nToUpperCase, we can be lazy no longer: we have to make a copy of s2’s\n(shared) value for s2’s private use.\nmodified, we never have to make a private copy of its value.\nThe details on making this kind of value sharing work (including all the\ncode) are provided in Item 29, but the idea is lazy evaluation: don’t\nbe lazy — use someone else’s copy as long as you can get away with it.\ncome upon a second way in which lazy evaluation can help us.\nThe first call to operator[] is to read part of a string, but the second\ncall is to perform a write.\ncall from the write, because reading a reference-counted string is\ncheap, but writing to such a string may require splitting off a new copy\nof the string’s value prior to the write.\nwhether it’s being called to perform a read or a write).\ntermine whether operator[] has been called in a read or a write con-\nAs a third example of lazy evaluation, imagine you’ve got a program\nthat uses large objects containing many constituent fields.\njects must persist across program runs, so they’re stored in a data-\nconst string& field1() const;\n// value of field 1\n// value of field 2\nconst string& field4() const;\nconst string& field5() const;\nLargeObject object(id);\nan object might be a costly database operation, especially if the data\nLargeObject object(id);\nif (object.field2() == 0) {\ncout << \"Object \" << id << \": null field2.\\n\";\nThe lazy approach to this problem is to read no data from disk when a\nLargeObject object is created.\nular data is needed inside the object.\nconst string& field1() const;\nconst string& field4() const;\nmutable string *field1Value;\nmutable string *field4Value;\nconst string& LargeObject::field1() const\nread the data for field 1 from the database and make\nEach field in the object is represented as a pointer to the necessary\ndata, and the LargeObject constructor initializes each pointer to null.\nSuch null pointers signify fields that have not yet been read from the\nof a field’s pointer before accessing the data it points to.\nis null, the corresponding data must be read from the database before\nperforming any operations on that data.\nnull pointers may need to be initialized to point to real data from inside\nany member function, including const member functions like field1.\ninside const member functions, so you’ve got to find a way to say, “It’s\npointer fields mutable, which means they can be modified inside any\nthe fields inside LargeObject above are declared mutable.\nother way to convince your compilers to let you modify data members\npoints to the same object as this does.\ndata member, you access it through the “fake this” pointer:\nconst string& field1() const;\nstring *field1Value;\nconst string& LargeObject::field1() const\n// does, but where the constness of the object has been\nThis function employs a const_cast (see Item 2) to cast away the\nconst string& LargeObject::field1() const\nIf you use smart pointers inside LargeObject, you’ll also",
      "keywords": [
        "const",
        "Lazy Evaluation",
        "String",
        "const string",
        "data",
        "program",
        "LargeObject",
        "Lazy",
        "object",
        "Item",
        "Evaluation",
        "80-20 rule",
        "performance",
        "copy",
        "const member functions"
      ],
      "concepts": [
        "performed",
        "performance",
        "objects",
        "fields",
        "program",
        "programming",
        "data",
        "string",
        "strings",
        "lazy"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 1,
          "title": "",
          "score": 0.59,
          "base_score": 0.44,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "",
          "score": 0.587,
          "base_score": 0.437,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 3,
          "title": "",
          "score": 0.559,
          "base_score": 0.409,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 11,
          "title": "",
          "score": 0.557,
          "base_score": 0.407,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 8,
          "title": "",
          "score": 0.515,
          "base_score": 0.365,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "string",
          "largeobject",
          "data",
          "program",
          "const"
        ],
        "semantic": [],
        "merged": [
          "string",
          "largeobject",
          "data",
          "program",
          "const"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3070120680986644,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970814+00:00"
      }
    },
    {
      "chapter_number": 11,
      "title": "Segment 11 (pages 108-115)",
      "start_page": 108,
      "end_page": 115,
      "summary": "Lazy Evaluation\nThe usual implementation of operator+ would use eager evaluation;\nin this case it would compute and return the sum of m1 and m2.\nthere’s the cost of allocating the memory to hold all those values, too.\nThe lazy evaluation strategy says that’s way too much work, so it\nInstead, it sets up a data structure inside m3 that indi-\ncates that m3’s value is the sum of m1 and m2.\ngoing to be faster to set up this data structure than to add m1 and m2,\nSuppose that later in the program, before m3 has been used, this code\nMatrix<int> m4(1000, 1000);\n// give m4 some values\nwrite a program that computed the sum of two matrices and failed to\ndeliberately compute a value that’s not needed, but during mainte-\nthrough a program in such a way that a formerly useful computation\nNevertheless, if that were the only time lazy evaluation paid off, it\nneed only part of a computation.\nFor example, suppose we use m3 as\nClearly we can be completely lazy no longer — we’ve got to compute the\nvalues in the fourth row of m3.\nIts trick was lazy evaluation.\nAPL employed lazy evaluation to\ntrix was needed, then it computed only that part.\nquate for an implementation employing eager evaluation.\nIf m3 is used in this way,\nthe jig is up and we’ve got to compute a complete value for m3.\n// and the OLD value of m1!\ndoesn’t change m3.\nmight compute m3’s value prior to changing m1 or we might make a\ncopy of the old value of m1 and make m3 dependent on that, but we\nhave to do something to guarantee that m3 has the value it’s supposed\ndition, lazy evaluation in a numerical domain is a lot of work.\nthat easily justifies the significant effort lazy evaluation requires.\nAmortizing the Cost of Expected Computations\nThese four examples show that lazy evaluation can be useful in a vari-\ndatabases, and to avoid unnecessary numerical computations.\nup on you, lazy evaluation won’t save your program any work if all your\nsential, lazy evaluation may slow you down and increase your use of\nmemory, because, in addition to having to do all the computations you\nstructures needed to make lazy evaluation possible in the first place.\nLazy evaluation is only useful when there’s a reasonable chance your\nsoftware will be asked to perform computations that can be avoided.\nThere’s nothing about lazy evaluation that’s specific to C++.\nMainstream programming languages employ eager evaluation, how-\nhicle for user-implemented lazy evaluation, because its support for\nencapsulation makes it possible to add lazy evaluation to a class with-\nor lazy evaluation is used by the classes.\nimplement a class using a straightforward eager evaluation strategy,\nplementation with one based on lazy evaluation.\nItem 18: Amortize the cost of expected computations.\nAmortizing the Cost of Expected Computations\nIn Item 17, I extolled the virtues of laziness, of putting things off as\nphilosophy of this item might be called over-eager evaluation: doing\navg was called, and we’d return the appropriate value.\nuation, we’d have the functions return data structures that could be\nUsing over-eager evaluation, we’d keep\nthe correct value immediately — no computation would be required.\nerage values over all the calls to those functions, and the amortized\ncost per call would be lower than with eager or lazy evaluation.\nOne of the simplest ways to do this is by caching values that have al-\nready been computed and are likely to be needed again.\nnumbers, you could write a findCubicleNumber function that caches\nAmortizing the Cost of Expected Computations\nduce the average cost of returning an employee’s cubicle number.\nCaching is one way to amortize the cost of anticipated computations.\nthat if data in one place is requested, it’s quite common to want nearby\nHow does a DynArray object go about extending itself when it needs\ntional memory as needed, something like this:\nmost STL iterators support the “->” operator, so it->second should now work.\nAmortizing the Cost of Expected Computations\nT& DynArray<T>::operator[](int index)\nThis approach simply calls new each time it needs to increase the size\nof the array, but calls to new invoke operator new (see Item 8), and\nThat’s because they typically result in calls to the underlying operating\nT& DynArray<T>::operator[](int index)\nint diff = index - the current maximum index value;\nThis function allocates twice as much memory as needed each time the\ngreater memory usage but reduces the time needed to regenerate the\nthe things that are prefetched, but it reduces the time needed to access\nipated computations through over-eager strategies like caching and\nprefetching — is not contradictory to the advice on lazy evaluation I\nLazy evaluation is a technique for improving the",
      "keywords": [
        "Lazy Evaluation",
        "Evaluation",
        "Lazy",
        "Item",
        "cost",
        "computations",
        "Expected Computations",
        "data",
        "index",
        "needed",
        "cubicle",
        "eager evaluation",
        "Cost of Expected",
        "over-eager evaluation",
        "cubicle number"
      ],
      "concepts": [
        "caching",
        "caches",
        "compute",
        "computation",
        "computations",
        "lazy",
        "laziness",
        "values",
        "item",
        "operator"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "",
          "score": 0.596,
          "base_score": 0.446,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 10,
          "title": "",
          "score": 0.557,
          "base_score": 0.407,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 18,
          "title": "",
          "score": 0.516,
          "base_score": 0.366,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 8,
          "title": "",
          "score": 0.42,
          "base_score": 0.27,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 31,
          "title": "",
          "score": 0.394,
          "base_score": 0.394,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "evaluation",
          "lazy evaluation",
          "lazy",
          "computations",
          "m3"
        ],
        "semantic": [],
        "merged": [
          "evaluation",
          "lazy evaluation",
          "lazy",
          "computations",
          "m3"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.26635627966907377,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970844+00:00"
      }
    },
    {
      "chapter_number": 12,
      "title": "Segment 12 (pages 116-123)",
      "start_page": 116,
      "end_page": 123,
      "summary": "Temporary Objects\nT temp = object1;\nobject2 = temp;\nTrue temporary objects in C++ are invisible — they don’t appear in\ncalls succeed and when functions return objects.\nderstand how and why these temporary objects are created and de-\nConsider first the case in which temporary objects are created to make\nThis happens when the type of object passed to\nray, but the corresponding function parameter is of type const\ntemporary object of type string.\nThat temporary object is initialized\nobject.\nexecuting, the temporary object is automatically destroyed.\nstruction of a temporary string object is an unnecessary expense.\nThese conversions occur only when passing objects by value or when\npassing an object to a reference-to-non-const parameter.\nrary string object generated from subtleBookPlug would be\nconversion for references-to-non-const objects, then, would allow\ntemporary objects to be changed when programmers expected non-\ntemporary objects to be modified.\nThe second set of circumstances under which temporary objects are\ncreated is when a function returns an object.\nmust return an object that represents the sum of its operands.\nThe return value of this function is a temporary, because it has no\nname: it’s just the function’s return value.\nand destruct this object each time you call operator+.\nnation of why the return value is const, see Item 6.)\nthat return objects, however, switching to a different function is not an\ntion, and sometimes you can write your object-returning functions in a\nway that allows your compilers to optimize temporary objects out of ex-\nThe bottom line is that temporary objects can be costly, so you want to\nis to train yourself to look for places where temporary objects may be\nAnytime you see a function returning an object, a temporary will be\nA function that returns an object is frustrating to efficiency aficiona-\nproblem is simple: a function either has to return an object in order to\nof the object being returned.\nConsider the operator* function for rational numbers:\n// For an explanation of why the return value is const,\nturn an object, because it returns the product of two arbitrary num-\na new object and return it.\n// an unreasonable way to avoid returning an object\n// an object\n// returning an object\nThis function returns a reference to an object that no longer exists.\nparticular, it returns a reference to the local object result, but re-\nReturning\nto return objects.\nThat is, you can’t win in your effort to eliminate by-value returns from\nan object, you should only care about the cost of that object.\nof returned objects, not to eliminate the objects themselves (which we\nIt is frequently possible to write functions that return objects in such\na way that compilers can eliminate the cost of the temporaries.\ntrick is to return constructor arguments instead of objects, and you can\n// function that returns an object\nand it is this temporary object the function is copying for its return\nstruction of the object the function returns.\nobjects out of existence.\nerator* and the temporary returned by operator*.\nstruct the object defined by the return expression inside the memory\nallotted for the object c.\nporary objects as a result of your calling operator* is zero: no tempo-\ncause c is a named object, and named objects can’t be eliminated (see\n// the most efficient way to write a function returning\n// an object\nmization — eliminating a local temporary by using a function’s return\nlocation (and possibly replacing that with an object at the function’s\nunnamed objects may be optimized away via the return value optimization.\n// For an explanation of why the return value is const,\nupi1 and upi2 are both UPInt objects, so\ntemporary objects to convert the integer 10 into UPInts (see Item 19).\nbut the temporary objects created to make the conversions work are a\nimplicit type conversions without incurring any cost for temporaries.\nis another way to make mixed-type calls to operator+ succeed, and\nwant to be able to add UPInt and int objects, all we have to do is say\nconst UPInt operator+(int lhs,\nconst UPInt operator+(int lhs, int rhs);\nOverloading to avoid temporaries isn’t limited to operator functions.\nFor example, in most programs, you’ll want to allow a string object\nlike int and double to be valid anywhere a numerical object is.\nresult, any function taking arguments of type string, char*, com-",
      "keywords": [
        "const Rational",
        "rational",
        "object const Rational",
        "object",
        "Temporary Objects",
        "const",
        "Temporary",
        "const Rational operator",
        "Item",
        "function",
        "operator",
        "const UPInt",
        "UPInt",
        "type",
        "const UPInt operator"
      ],
      "concepts": [
        "objects",
        "returns",
        "function",
        "operator",
        "operations",
        "item",
        "types",
        "rational",
        "char",
        "temporary"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 21,
          "title": "",
          "score": 0.704,
          "base_score": 0.554,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 4,
          "title": "",
          "score": 0.682,
          "base_score": 0.532,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 22,
          "title": "",
          "score": 0.667,
          "base_score": 0.517,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 24,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 15,
          "title": "",
          "score": 0.645,
          "base_score": 0.495,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "temporary",
          "object",
          "temporary objects",
          "objects",
          "return"
        ],
        "semantic": [],
        "merged": [
          "temporary",
          "object",
          "temporary objects",
          "objects",
          "return"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4156018118385698,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970883+00:00"
      }
    },
    {
      "chapter_number": 13,
      "title": "Segment 13 (pages 124-132)",
      "start_page": 124,
      "end_page": 132,
      "summary": "As far as C++ is concerned, there is no relationship between oper-\nversion (e.g., operator+) exists is to implement the latter in terms of\n// operator+ implemented in terms of operator+=; see\n// operator- implemented in terms of operator -=\nIn this example, operators += and -= are implemented (elsewhere)\nassignment versions of the operators are in the class’s public interface,\nthere is never a need for the stand-alone operators to be friends of the\nclass.\nWith these templates, as long as an assignment version of an operator\nis defined for some type T, the corresponding stand-alone operator will\nassignment versions of operators are more efficient than stand-alone\nAssignment versions of operators write to\nto hold the operator’s return value.\nThe second point is that by offering assignment versions of operators\nas well as stand-alone versions, you allow clients of your classes to\n// to operator+\nalone operators.\nLook again at the implementation for operator+:\nimplementation of operator+ (see the footnote on page 104).\ntend to be more efficient than stand-alone versions of those operators\nsions of operators instead of stand-alone versions whenever perfor-\ncommon for two libraries offering similar functionality to have quite\nAs an example, consider the iostream and stdio libraries, both of which\nThe iostream library has\nIn terms of efficiency, however, the iostream library\nthat correspond to “typical” usage of a program or library, it’s also use-\nand stdio libraries is made during compilation and is determined by\ning systems, and compilers, and in every case the stdio version has\nshow a negligible performance difference between iostreams and stdio.\ntion that’s faster than stdio, because iostreams determine the types of\ntheir operands during compilation, while stdio functions typically\nferent libraries offering similar functionality often feature different per-\nthere are alternative implementations of operator new and operator\nItem 24: Understand the costs of virtual functions, \nC++ compilers must find a way to implement each feature in the lan-\ndent, and different compilers implement language features in different\nThe foremost example of such a feature is virtual functions.\nWhen a virtual function is called, the code executed must correspond\nto the dynamic type of the object on which the function is invoked; the\nMost implementations use\nis the same.) Each class in a program that declares or inherits virtual\nfunctions has its own vtbl, and the entries in a class’s vtbl are pointers\nto the implementations of the virtual functions for that class.\nclass C1 {\nvirtual ~C1();\nvirtual int f2(char c) const;\nC1’s virtual table array will look something like this:\nNote that the nonvirtual function f4 is not in the table, nor is C1’s con-\ndefinition nonvirtual — are implemented just like ordinary C func-\nIf a class C2 inherits from C1, redefines some of the virtual functions it\nclass C2: public C1 {\nvirtual ~C2();\n// new virtual function\nits virtual table entries point to the functions that are appropriate for\nThese entries include pointers to the C1 virtual\nThis discussion brings out the first cost of virtual functions: you have\nto set aside space for a virtual table for each class that contains virtual\nimplementation of C1::f1\nimplementation of C1::f2\nimplementation of C1::f3\nimplementation of C1::~C1\nimplementation of C2::f1\nimplementation of C1::f2\nimplementation of C1::f3\nimplementation of C2::~C2\nimplementation of C2::f5\ntual functions declared for that class (including those it inherits from\nThere should be only one virtual table per class, so\nvirtual functions in each class, you may find that the vtbls take a sig-\nBecause you need only one copy of a class’s vtbl in your programs,\ngrams and libraries are created by linking together many object files,\nput it in the object file containing main, but libraries have no main,\nate a copy of the vtbl in each object file that might need it.\nject file should contain the vtbl for a class.\nfollows: a class’s vtbl is generated in the object file containing the def-\nin that class.\nThus, the vtbl for class C1 above would be placed in the\nobject file containing the definition of C1::~C1 (provided that function\nwasn’t inline), and the vtbl for class C2 would be placed in the object\nfile containing the definition of C2::~C2 (again, provided that function\nyou go overboard on declaring virtual functions inline.\nfunctions in a class are declared inline, the heuristic fails, and most\nheuristic-based implementations then generate a copy of the class’s\nvtbl in every object file that uses it.\nprograms containing hundreds or thousands of copies of a class’s vtbl!\navoid declaring virtual functions inline.",
      "keywords": [
        "const Rational",
        "operator",
        "const Rational operator",
        "virtual",
        "virtual functions",
        "Rational",
        "const",
        "stdio",
        "functions",
        "object",
        "Item",
        "lhs",
        "implementation",
        "Rational operator",
        "rhs"
      ],
      "concepts": [
        "functionality",
        "function",
        "functions",
        "operator",
        "operation",
        "implement",
        "implemented",
        "implementations",
        "library",
        "libraries"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 24,
          "title": "",
          "score": 0.698,
          "base_score": 0.548,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 7,
          "title": "",
          "score": 0.612,
          "base_score": 0.462,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 22,
          "title": "",
          "score": 0.572,
          "base_score": 0.422,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 29,
          "title": "",
          "score": 0.559,
          "base_score": 0.409,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 21,
          "title": "",
          "score": 0.54,
          "base_score": 0.39,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "c1",
          "virtual",
          "vtbl",
          "c2",
          "versions"
        ],
        "semantic": [],
        "merged": [
          "c1",
          "virtual",
          "vtbl",
          "c2",
          "versions"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.38056506478432883,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970918+00:00"
      }
    },
    {
      "chapter_number": 14,
      "title": "Segment 14 (pages 133-140)",
      "start_page": 133,
      "end_page": 140,
      "summary": "tive for virtual functions, anyway.\nobject, and it is the job of the virtual table pointer to establish that cor-\nEach object whose class declares virtual functions carries with it a hid-\nden data member that points to the virtual table for that class.\nof the layout of an object that has virtual functions as looking like this:\nAt this point, simply note the second cost of virtual functions:\nyou have to pay for an extra pointer inside each object that is of a class\ncontaining virtual functions.\nIf your objects\nthe object\nObject’s vptr\nThis is a call to the virtual function f1 through the pointer pC1.\nC1 Object\nC1 Object\nC1 Object\nC2 Object\nC2 Object\nC2 Object\nof C1’s virtual\nof C2’s virtual\nvirtual function is thus basically the same as that of calling a function\nThe real runtime cost of virtual functions has to do with their interac-\nof virtual functions: you effectively give up inlining.\n(Virtual functions\ncan be inlined when invoked through objects, but most virtual function\nBecause such calls are the norm, virtual functions are\nthe per-class and the per-object space overhead for virtual functions\nMultiple inheritance often leads to the need for virtual base classes.\nWithout virtual base classes, if a derived class has more than one in-\nreplicated within each derived class object, one copy for each path be-\nnever what programmers want, and making base classes virtual elim-\nVirtual base classes may incur a cost of their\nown, however, because implementations of virtual base classes often\nuse pointers to virtual base class parts as the means for avoiding the\nyour objects.\nHere A is a virtual base class because B and C virtually inherit from it.\nview of how virtual base classes may lead to the addition of hidden\ntable pointers are added to objects, we realize that if the base class A\nclass B: virtual public A { ...\nclass C: virtual public A { ...\nPointer to virtual base class\nPointer to virtual base class\nin the hierarchy on page 119 has any virtual functions, the memory\nWe’ve now seen how virtual functions make objects larger and pre-\ntual base classes can also increase the size of objects.\nRTTI lets us discover information about objects and classes at run-\nand you can access the type_info object for a class by using the\nclass, but there must be a way to get to that information for any object.\nPointer to virtual base class\nPointer to virtual base class\nonly if that type has at least one virtual function.\ndata sound a lot like a virtual function table.\ninformation from any object containing a virtual function.\nbetween RTTI and virtual function tables is no accident: RTTI was de-\ntype_info object for the class corresponding to that vtbl.\nin each class vtbl plus the cost of the storage for the type_info object\nThe following table summarizes the primary costs of virtual functions,\nmultiple inheritance, virtual base classes, and RTTI:\nVirtual Functions\nVirtual Base Classes\nfunction calls, for example, yields more code than virtual function calls\nC1’s type_info object\nIt is important to understand the costs of virtual functions, multiple\ninheritance, virtual base classes, and RTTI, but it is equally important\nhidden vptrs and pointers to virtual base classes can make it difficult\ncan you make constructors and non-member functions act like virtual\nHow can you create a virtual function whose behavior\nVirtualizing Constructors and Non-Member Functions\nstructors.” You call a virtual function to achieve type-specific behavior",
      "keywords": [
        "virtual functions",
        "virtual",
        "virtual base classes",
        "virtual base",
        "data members",
        "object",
        "virtual base class",
        "data",
        "function",
        "functions",
        "base class",
        "base",
        "virtual function calls",
        "members",
        "vptr"
      ],
      "concepts": [
        "object",
        "virtual",
        "functions",
        "function",
        "functionality",
        "classes",
        "compilers",
        "pointer",
        "types",
        "inheritance"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 29,
          "title": "",
          "score": 0.726,
          "base_score": 0.576,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 15,
          "title": "",
          "score": 0.653,
          "base_score": 0.503,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 28,
          "title": "",
          "score": 0.636,
          "base_score": 0.486,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 12,
          "title": "",
          "score": 0.614,
          "base_score": 0.464,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 4,
          "title": "",
          "score": 0.61,
          "base_score": 0.46,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "virtual",
          "virtual base",
          "base",
          "virtual functions",
          "virtual function"
        ],
        "semantic": [],
        "merged": [
          "virtual",
          "virtual base",
          "base",
          "virtual functions",
          "virtual function"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.38913057619888486,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970954+00:00"
      }
    },
    {
      "chapter_number": 15,
      "title": "Segment 15 (pages 141-151)",
      "start_page": 141,
      "end_page": 151,
      "summary": "don’t yet have an object but you know exactly what type you’d like to\n// pure virtual function\n// functions\n// functions\n// a newsletter object\n// NLComponent objects\nobject\nobject\nVirtualizing Constructors and Non-Member Functions\nObjects of type list behave like doubly linked lists, though they need\nNewsLetter objects, when not being worked on, would likely be stored\nread the next component object from str;\nadd the object to the list of this\nIt creates a new object, either a\ncreates new objects, it acts much like a constructor, but because it can\ncreate different types of objects, we call it a virtual constructor.\nconstructor is a function that creates different types of objects depend-\nVirtual constructors are useful in many\nA virtual copy constructor returns a pointer to\na new copy of the object invoking the function.\nior, virtual copy constructors are typically given names like copySelf,\nFew functions are\n// declaration of virtual copy constructor\n// virtual copy\n// virtual copy\nAs you can see, a class’s virtual copy constructor just calls its real copy\nvirtual copy constructor.\ncopy, so does the virtual copy constructor.\nItem 29), so does the virtual copy constructor.\nin the rules for virtual function return types that was adopted rela-\nclass’s virtual function declare the same return type.\nVirtualizing Constructors and Non-Member Functions\nfunction’s return type is a pointer (or a reference) to a base class, the\nderived class’s function may return a pointer (or reference) to a class\nand it makes it possible to accurately declare functions such as virtual\nThe existence of a virtual copy constructor in NLComponent makes it\n// virtual copy constructor to copy the element into\n// the components list for this object.\n// so call that element’s clone function to get a copy\n// this object’s list of components\ncomponents for the NewsLetter object being copied, and for each\ncomponent in the list, call its virtual copy constructor.\npoints to, and the virtual copy constructor does that for us.\nMaking Non-Member Functions Act Virtual\nJust as constructors can’t really be virtual, neither can non-member\nfunctions.\nimplement output operators for the TextBlock and Graphic classes.\nVirtualizing Constructors and Non-Member Functions\nAn alternate approach is to declare a virtual function for printing (e.g.,\ndo that, the syntax for printing TextBlock and Graphic objects is in-\nvirtual function like print.\nVirtual-acting non-member functions, then, are easy.\nfunctions to do the work, then write a non-virtual function that does\nnothing but call the virtual function.\nnon-virtual function.\nNow that you know how to make non-member functions act virtually\nItem 26: Limiting the number of objects of a class.\nso you’d like to somehow limit the number of printer objects to one.\nIf this were a proof by mathematical induction, we might start with\nobjects of a particular class from being created is to declare the con-\nonly one printer available to us, we can encapsulate the printer object\na single printer object is created:\nclass Printer {\nPrinter& thePrinter()\n// the single printer object\nSecond, the global function thePrinter is declared a friend of\nFinally, thePrinter contains a static Printer\nobject.\nThat means only a single object will be created.\nBy returning a reference to a Printer object,\nthePrinter can be used in any context where a Printer object itself\nstatic member function of Printer, and that puts it right where you\nUsing a static member function,\nclass Printer {\nstatic Printer& thePrinter();\nPrinter::thePrinter().reset();\nthePrinter function into a namespace, we don’t have to worry about\nwe’d put Printer and thePrinter into a namespace called Print-\nclass Printer {\nPrinter& thePrinter()\n// so is this function \nFirst, it’s important that the single Printer object be\nstatic in a function and not in a class.\nAn object that’s static in a class\nIn contrast, an object that’s static in a function\ncalled, the object is never created.\neach time the function is called to see whether the object needs to be\nobject like our printer as a static object in a function is one way of ad-\nThere is another drawback to making the printer a class static versus\nFunction statics, when they can be\nobjects inside functions.\nPrinter& thePrinter()\nConsider for a moment why you’d declare an object to be static.\nusually because you want only a single copy of that object, right?\nfor the program may contain more than one copy of each function with\nwithin the functions.\nfunction containing a local static object, you may end up with more\nthan one copy of the static object in your program!\nline non-member functions that contain local static data.†",
      "keywords": [
        "virtual copy constructor",
        "printer",
        "virtual",
        "function",
        "object",
        "copy constructor",
        "virtual copy",
        "printer object",
        "copy",
        "constructor",
        "functions",
        "public",
        "Graphic",
        "virtual function",
        "static Printer"
      ],
      "concepts": [
        "object",
        "classes",
        "function",
        "functions",
        "functionality",
        "virtual",
        "virtually",
        "printer",
        "likely",
        "public"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 22,
          "title": "",
          "score": 0.672,
          "base_score": 0.522,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 14,
          "title": "",
          "score": 0.653,
          "base_score": 0.503,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 12,
          "title": "",
          "score": 0.645,
          "base_score": 0.495,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 19,
          "title": "",
          "score": 0.593,
          "base_score": 0.443,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 26,
          "title": "",
          "score": 0.562,
          "base_score": 0.412,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "printer",
          "virtual",
          "virtual copy",
          "copy",
          "theprinter"
        ],
        "semantic": [],
        "merged": [
          "printer",
          "virtual",
          "virtual copy",
          "copy",
          "theprinter"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.37398323142242973,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.970989+00:00"
      }
    },
    {
      "chapter_number": 16,
      "title": "Segment 16 (pages 152-161)",
      "start_page": 152,
      "end_page": 161,
      "summary": "class Printer {\nPrinter();\n~Printer();\n// printer, so never allow\nconstruct too many Printer objects, we throw an exception of type\nsize_t Printer::numObjects = 0;\nThe class for such printers would\nhave much in common with our generic printer class, so of course we’d\nclass ColorPrinter: public Printer {\nPrinter p;\nHow many Printer objects result from these object definitions?\nA similar problem occurs when Printer objects are contained inside\nPrinter p;\nThe problem is that Printer objects can exist in three different con-\ntexts: on their own, as base class parts of more derived objects, and\nplified by our original Printer class, because the Printer\nplains, classes without virtual functions yield smaller objects than do\nclass FSA {\nular class is complicated by the fact that object constructors are called\nfusion surrounding object counts by making constructors private.\nPrinter objects to one, but it also limits us to a single Printer object\ncreate Printer object p1;\ncreate Printer object p2;\nThis design never instantiates more than a single Printer object at a\ntime, but it does use different Printer objects in different parts of the\nAll we have to do is combine the object-counting code we used\nclass Printer {\n~Printer();\nPrinter();\nPrinter(const Printer& rhs); // we don’t define this\nsize_t Printer::numObjects = 0;\nClients use this Printer class just as they would any other class, ex-\nPrinter p1;\nPrinter *p2 =\nfollowing revised implementation of our Printer class allows up to 10\nPrinter objects to exist:\nclass Printer {\nstatic Printer * makePrinter(const Printer& rhs);\nPrinter();\nsize_t Printer::numObjects = 0;\nconst size_t Printer::maxObjects;\nof Printer::maxObjects in the class definition above.\nclass Printer {\n// within this class,\nclass Printer {\nconst size_t Printer::maxObjects = 10;\nAn Object-Counting Base Class\nhad a lot of classes like Printer whose instantiations needed to be\nclass.\nWe can easily come up with a base class for counting object instances\nand have classes like Printer inherit from that, but it turns out we\nThe counter in the Printer class is the static variable numObjects, so\nwe need to move that variable into an instance-counting class.\nUse of a counting class template\nclass Counted {\nWe can now modify the Printer class to use the Counted template:\nclass Printer: private Counted<Printer> {\nstatic Printer * makePrinter(const Printer& rhs);\n~Printer();\nusing Counted<Printer>::objectCount;\nusing Counted<Printer>::TooManyObjects;\nPrinter();\nThe fact that Printer uses the Counted template to keep track of how\nmany Printer objects exist is, frankly, nobody’s business but the au-\nbe to use public inheritance between Printer and\nCounted<Printer>, but then we’d be obliged to give the Counted\nsomebody deleted a Printer object through a Counted<Printer>*\nclasses inheriting from Counted.\nQuite properly, most of what Counted does is hidden from Printer’s\nPrinter objects exist.\nin Printer due to our use of private inheritance.\nclass Printer: private Counted<Printer> {\nusing Counted<Printer>::objectCount;\n// of Printer\nclass Printer: private Counted<Printer> {\nCounted<Printer>::objectCount;\n// public in Printer\nWhen Printer inherits from Counted<Printer>, it can forget about\ncounting objects.\ndoing the counting for it, because somebody else (Counted<Printer>)\nA Printer constructor now looks like this:\nAll that is now handled by the Counted<Printer>\nconstructors, and because Counted<Printer> is a base class of\nPrinter, we know that a Counted<Printer> constructor will always\nbe called before a Printer constructor.\nated, a Counted<Printer> constructor throws an exception, and the\nIf we want to allow up to 10 printers, we\nshould initialize Counted<Printer>::maxObjects to 10.",
      "keywords": [
        "printer",
        "Printer objects",
        "class Printer",
        "Counted",
        "FSA",
        "const Printer",
        "objects",
        "static Printer",
        "Limiting Object Instantiations",
        "single Printer object",
        "Printer objects exist",
        "Limiting Object",
        "create Printer object",
        "static",
        "Object Instantiations"
      ],
      "concepts": [
        "classes",
        "printer",
        "object",
        "counts",
        "constructor",
        "statics",
        "instantiations",
        "instantiates",
        "public",
        "functions"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 31,
          "title": "",
          "score": 0.631,
          "base_score": 0.481,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 25,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 2,
          "title": "",
          "score": 0.533,
          "base_score": 0.383,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 27,
          "title": "",
          "score": 0.523,
          "base_score": 0.373,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 5,
          "title": "",
          "score": 0.497,
          "base_score": 0.347,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "printer",
          "counted printer",
          "counted",
          "printer objects",
          "printer printer"
        ],
        "semantic": [],
        "merged": [
          "printer",
          "counted printer",
          "counted",
          "printer objects",
          "printer printer"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.33361614517756666,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971022+00:00"
      }
    },
    {
      "chapter_number": 17,
      "title": "Segment 17 (pages 162-169)",
      "start_page": 162,
      "end_page": 169,
      "summary": "Requiring or Prohibiting Heap-Based Objects\nItem 27: Requiring or prohibiting heap-based objects.\nRequiring or Prohibiting Heap-Based Objects\nment clearly requires that objects of that type be allocated on the heap.\nmemory leaks for a particular class, because none of the objects could\ncode that requires or prohibits heap-based objects?\nRequiring Heap-Based Objects\nLet us begin with the prospect of limiting object creation to the heap.\nfrom creating objects other than by calling new.\nheap objects are automatically constructed at their point of definition\nclass UPNumber {\n// even const objects may be destroyed)\nthe creation of non-heap objects, but, in a story that is told in Item 26,\nclass UPNumber { ...\nRequiring or Prohibiting Heap-Based Objects\nobjects instead:\nclass UPNumber { ...\n: value(new UPNumber(initValue))\nDetermining Whether an Object is On The Heap\nthe heap.” Given the class definition sketched above, it’s legal to define\na non-heap NonNegativeUPNumber object:\nNow, the UPNumber part of the NonNegativeUPNumber object n is not\non the heap.\nthat all UPNumber objects — even base class parts of more derived ob-\nIt is not possible for a UPNumber constructor to\ndetermine whether it’s being invoked as the base class part of a heap-\nbased object.\nThat is, there is no way for the UPNumber constructor to\n// on heap\n// not on heap\nthe constructor that the new operator calls (see Item 8).\nclass UPNumber {\n// exception to throw if a non-heap object is created\n// the object being\nvoid *UPNumber::operator new(size_t size)\nthe fact that when an object is allocated on the heap, operator new is\ntialize an object in that memory.\nthe raw memory of the object being constructed was allocated by op-\nRequiring or Prohibiting Heap-Based Objects\nHere we create two UPNumbers on the heap and make pn point to one\ntor new and two calls to UPNumber constructors (see Item 8).\nCall operator new for first object (the leftmost one above)\nCall constructor for first object\nCall operator new for second object (the one used as an argu-\nCall constructor for second object\nCall operator new for first object\nCall operator new for second object\nCall constructor for second object\nCall constructor for first object\nmaking the object constructed in step 3 think it’s not on the heap, even\n// is on the heap\nHeap\nRequiring or Prohibiting Heap-Based Objects\nvariable or object.\nYes, the stack and the heap hold objects, but let\nus not forget about static objects.\nStatic objects are those that are ini-\nStatic objects comprise not\nSuch objects have to go somewhere, and that\nsomewhere is neither the stack nor the heap.\nhave the stack and heap grow toward one another, they go below the\nheap.\nWith static objects added to the picture,\njects and static objects:\n// heap object: onHeap(pc)\nHeap\nObjects\n// stack object: onHeap(&c)\n// static object: onHeap(&sc)\nNow, you may be desperate for a way to tell heap objects from stack ob-\nan object is on the heap, there isn’t even a semi-portable way that\nwhether an address is on the heap, you’re going to have to turn to un-\nso you don’t need to determine whether an object is on the heap in the\nIf you find yourself obsessing over whether an object is on the heap,\nConsider again an Asset object that contains a UPNumber\nobject:\nlection of addresses that have been returned by operator new.",
      "keywords": [
        "UPNumber",
        "Objects",
        "heap",
        "Prohibiting Heap-Based Objects",
        "Heap-Based Objects",
        "operator",
        "Asset",
        "Requiring or Prohibiting",
        "constructor",
        "static objects",
        "Prohibiting Heap-Based",
        "class UPNumber",
        "stack",
        "private",
        "call"
      ],
      "concepts": [
        "objects",
        "heap",
        "classes",
        "address",
        "addresses",
        "static",
        "stack",
        "item",
        "constructors",
        "asset"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "",
          "score": 0.714,
          "base_score": 0.564,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 18,
          "title": "",
          "score": 0.68,
          "base_score": 0.53,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 8,
          "title": "",
          "score": 0.614,
          "base_score": 0.464,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 9,
          "title": "",
          "score": 0.512,
          "base_score": 0.362,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 2,
          "title": "",
          "score": 0.454,
          "base_score": 0.454,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "heap",
          "upnumber",
          "heap based",
          "based objects",
          "objects"
        ],
        "semantic": [],
        "merged": [
          "heap",
          "upnumber",
          "heap based",
          "based objects",
          "objects"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3389341907427053,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971057+00:00"
      }
    },
    {
      "chapter_number": 18,
      "title": "Segment 18 (pages 170-177)",
      "start_page": 170,
      "end_page": 177,
      "summary": "void *operator new(size_t size)\noperator new adds entries to a col-\nlection of allocated addresses, operator delete removes entries, and\nIf the operator new and operator delete functions\nnew and operator delete.\nator new and operator delete (such as many object-oriented data-\nor virtual base classes have multiple addresses, so there’s no guaran-\nreturned from operator new, even if the object in question was allo-\nability to determine whether a pointer was allocated from operator\nclass HeapTracked {\nstatic void *operator new(size_t size);\nstatic void operator delete(void *ptr);\nlibrary (see Item 35) to keep track of all pointers returned from oper-\nlist; and isOnHeap returns whether an object’s address is in the list.\nImplementation of the HeapTracked class is simple, because the glo-\nbal operator new and operator delete functions are called to per-\noperations.\nvoid * HeapTracked::operator new(size_t size)\nvoid *memPtr = ::operator new(size);// get the memory\nvoid HeapTracked::operator delete(void *ptr)\n// look up the pointer in the list of addresses \n// returned by operator new\nclasses have several addresses.\npointer to the beginning of the memory for the object pointed to by the\npointer.\nBut dynamic_cast is applicable only to pointers to objects\nfunction had to work with any type of pointer, so dynamic_cast\nHeapTracked objects), so dynamic_casting this to const void*\nThat’s the pointer that HeapTracked::operator new must have\nreturned if the memory for the current object was allocated by Heap-\nTracked::operator new in the first place.\nability to track pointers to heap allocations.\nbe able to determine whether a pointer to an Asset object points to a\nheap-based object, we’d modify Asset’s class definition to specify\nHeapTracked as a base class:\nclass Asset: public HeapTracked {\nProhibiting Heap-Based Objects\njects instantiated as base class parts of derived class objects, and ob-\ncan take advantage of the fact that the new operator always calls op-\nyou want to keep clients from creating UPNumber objects on the heap,\nclass UPNumber {\nstatic void *operator new(size_t size);\nstatic void operator delete(void *ptr);\n// private operator new\nIt suffices to declare operator new private, but it looks strange to have\noperator new be private and operator delete be public, so unless\nthem in the same part of a class.\narrays of UPNumber objects, too, you could declare operator new[]\nand operator delete[] (see Item 8) private as well.\nInterestingly, declaring operator new private often also prevents UP-\nNumber objects from being instantiated as base class parts of heap-\nbased derived class objects.\nclass UPNumber { ...\n// declares no operator new\n// private operator new\nIf the derived class declares an operator new of its own, that function\nwill be called when allocating derived class objects on the heap, and a\ndifferent way will have to be found to prevent UPNumber base class\nator new is private has no effect on attempts to allocate objects con-\n// Asset::operator new or\n// ::operator new, not\n// UPNumber::operator new\nSmart Pointers\nItem 28: Smart pointers.\nSmart Pointers\nSmart pointers are objects that are designed to look, act, and feel like\nSome smart pointers are\nlast smart pointer pointing to the object is destroyed.\nsmart pointer is copied or is involved in an assignment.\nsmart pointer types, the desired behavior is to automatically copy\nobject pointed to by a smart pointer?\nfor example, use smart pointers to help implement the lazy fetch-\nSmart pointers are generated from templates because, like built-in\nMost smart pointer templates look\n// pointer objects\nFor smart pointer classes where copying and assignment are not\ning operators are declared const, because dereferencing a pointer\nFinally, each smart pointer-to-T object is imple-\nSmart pointers allow a",
      "keywords": [
        "operator",
        "Smart Pointers",
        "Objects",
        "Smart",
        "operator delete",
        "pointer",
        "void",
        "Item",
        "void operator delete",
        "smart ptr",
        "ptr",
        "HeapTracked",
        "base class",
        "const void",
        "Asset"
      ],
      "concepts": [
        "classes",
        "objects",
        "operator",
        "operations",
        "pointer",
        "asset",
        "address",
        "void",
        "base",
        "based"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "",
          "score": 0.73,
          "base_score": 0.58,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 17,
          "title": "",
          "score": 0.68,
          "base_score": 0.53,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 8,
          "title": "",
          "score": 0.623,
          "base_score": 0.473,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 2,
          "title": "",
          "score": 0.531,
          "base_score": 0.531,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 9,
          "title": "",
          "score": 0.517,
          "base_score": 0.367,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "operator",
          "operator new",
          "smart",
          "heaptracked",
          "operator delete"
        ],
        "semantic": [],
        "merged": [
          "operator",
          "operator new",
          "smart",
          "heaptracked",
          "operator delete"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.39813478150300347,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971094+00:00"
      }
    },
    {
      "chapter_number": 19,
      "title": "Segment 19 (pages 178-189)",
      "start_page": 178,
      "end_page": 189,
      "summary": "Smart Pointers\n// other smart ptr\nvoid editTuple(DBPtr<Tuple>& pt)\nconcerned with such matters; the smart pointer class hides that as-\nAs you can see, using a smart pointer isn’t much different from using\nClients of smart pointers are supposed to be able to\nConstruction, Assignment, and Destruction of Smart Pointers\nConstruction of a smart pointer is usually straightforward: locate an\nobject to point to (typically by using the smart pointer’s constructor ar-\nguments), then make the smart pointer’s internal dumb pointer point\nIf no object can be located, set the internal pointer to 0 or signal\nImplementing a smart pointer’s copy constructor, assignment opera-\nIf a smart pointer owns the object it points to, it is responsible for\ndeleting that object when it (the smart pointer) is destroyed.\nsumes the object pointed to by the smart pointer is dynamically allo-\npointers.\nItem 9 explains, an auto_ptr object is a smart pointer that points to a\nheap-based object until it (the auto_ptr) is destroyed.\npens, the auto_ptr’s destructor deletes the pointed-to object.\nauto_ptr template might be implemented like this:\nclass auto_ptr {\n~auto_ptr() { delete pointee; }\nThis works fine provided only one auto_ptr owns an object.\nshould happen when an auto_ptr is copied or assigned?\nSmart Pointers\nauto_ptr<TreeNode> ptn3;\nauto_ptrs pointing to the same object.\ncause each auto_ptr would delete what it pointed to when the\nate, because an auto_ptr<T> object need not point to an object of type\nT; it might point to an object of a type derived from T.\nate to require their use in a general-purpose class like auto_ptr.\nThe problems would vanish if auto_ptr prohibited copying and assign-\nobject ownership is transferred when an auto_ptr is copied or assigned:\nclass auto_ptr {\nauto_ptr<T>&\noperator=(auto_ptr<T>& rhs);\nauto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<T>& rhs)\n// object\nNotice that the assignment operator must delete the object it owns be-\nobject owns the object the auto_ptr points to.\nBecause object ownership is transferred when auto_ptr’s copy con-\nvoid printTreeNode(ostream& s, auto_ptr<TreeNode> p)\n// pass auto_ptr by value\nauto_ptr’s copy constructor), ownership of the object pointed to by\nSmart Pointers\nconst auto_ptr<TreeNode>& p)\nIn this function, p is a reference, not an object, so no constructor is\nTreeNode, it retains ownership of the object it points to, and ptn can\nThe notion of transferring ownership from one smart pointer to an-\nwords, auto_ptr objects are modified if they are copied or are the\nyou want to say: when an object is copied or is the source of an assign-\nIf you find this examination of auto_ptr member functions interest-\nauto_ptr template, those functions are member function templates,\nA smart pointer’s destructor often looks like this:\nA smart pointer that employs reference counting (see Item 29)\nOf course, some smart pointers are like\ndumb pointers: they have no effect on the object they point to when\nLet us now turn our attention to the very heart of smart pointers, the\nThe former returns the object\nperform \"smart pointer\" processing;\nused (see Item 17), the function may have to conjure up a new object\ntion just returns a reference to the pointed-to object.\nmind that pointee need not point to an object of type T; it may point\nerator* function returns a T object instead of a reference to the ac-\ntual derived class object, your function will return an object of the\nthe pointed-to object.\nIn essence, your smart pointer will not properly\nsupport virtual functions, and how smart is a pointer like that?\nSmart Pointers\ndo if somebody invokes operator* on a null smart pointer, i.e., one\nthat uses a smart pointer-to-Tuple object:\nthings operator-> can return: a dumb pointer to an object or another\nsmart pointer object.\nperform \"smart pointer\" processing;\nBecause this function returns a pointer, virtual\nsmart pointers further, however, you must know more about dumb\npointer behavior and how smart pointers can and cannot emulate it.\nTesting Smart Pointers for Nullness\ncopy, assign, and dereference smart pointers.\ncannot do, however, is find out if a smart pointer is null:\npointer classes, but that wouldn’t address the problem that smart\npointers don’t act like dumb pointers when testing for nullness.\nSmart Pointers\nIn particular, it allows comparisons of smart pointers of com-\nSmartPtr<Orange>, this compiles, because both smart pointers can\ncomparison function for built-in pointers.\ndentally comparing smart pointers of different types.\nfor your smart pointer classes so that operator!\ntrue if and only if the smart pointer on which it’s invoked is null:\n// if the smart ptr is null\nConverting Smart Pointers to Dumb Pointers\nSometimes you’d like to add smart pointers to an application or library\nsome old library functions that aren’t designed to use smart pointers:\n// pointer\npointer-to-Tuple:\nSmart Pointers\nThe call can be made to succeed by adding to the smart pointer-to-T\ntemplate an implicit conversion operator to a dumb pointer-to-T:\nsmarts your pointer-like objects are designed to provide:\nUsually, the “smart” behavior provided by a smart pointer is an essen-\nEven if you provide an implicit conversion operator to go from a smart\npointer to the dumb pointer it’s built on, your smart pointer will never\nconversion from a smart pointer to a dumb pointer is a user-defined\nTupleAccessors(const Tuple *pt);\na type-conversion operator from Tuple* to TupleAccessors (see Item\ncalling merge with two dumb Tuple* pointers is fine:\nThe corresponding call with smart DBPtr<Tuple> pointers, however,\n// pt2 to TupleAccessors objects\nThat’s because a conversion from DBPtr<Tuple> to TupleAccessors\nSmart pointer classes that provide an implicit conversion to a dumb",
      "keywords": [
        "smart pointer",
        "Smart",
        "pointer",
        "auto",
        "ptr",
        "object",
        "Tuple",
        "dumb pointer",
        "Item",
        "operator",
        "smart pointer classes",
        "smart pointer object",
        "dumb",
        "function",
        "ptn"
      ],
      "concepts": [
        "operation",
        "operator",
        "object",
        "pointers",
        "functions",
        "function",
        "functionality",
        "smart",
        "classes",
        "void"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 22,
          "title": "",
          "score": 0.814,
          "base_score": 0.664,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 20,
          "title": "",
          "score": 0.764,
          "base_score": 0.614,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 4,
          "title": "",
          "score": 0.613,
          "base_score": 0.463,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 15,
          "title": "",
          "score": 0.593,
          "base_score": 0.443,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 23,
          "title": "",
          "score": 0.587,
          "base_score": 0.437,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "smart",
          "auto_ptr",
          "smart pointer",
          "pointer",
          "smart pointers"
        ],
        "semantic": [],
        "merged": [
          "smart",
          "auto_ptr",
          "smart pointer",
          "pointer",
          "smart pointers"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.36760965961071856,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971128+00:00"
      }
    },
    {
      "chapter_number": 20,
      "title": "Segment 20 (pages 190-199)",
      "start_page": 190,
      "end_page": 199,
      "summary": "Smart Pointers\nAfter all, pt is not a pointer, it’s an object,\nare to forget they are using smart pointers.\nSmart Pointers and Inheritance-Based Type Conversions\ndumb pointers with their allegedly smart counterparts:\nvoid displayAndPlay(const SmartPtr<MusicProduct>& pmp,\nIf smart pointers are so brainy, why won’t these compile?\nThey won’t compile because there is no conversion from a SmartPtr<CD>\nAfter all, it’s not like SmartPtr<CD> or SmartPtr<Cassette> inherits\nSmart Pointers\n(if not the practice) is simple: give each smart pointer class an implicit\ntype conversion operator (see Item 5) for each smart pointer class to\nsmart pointer classes for Cassette and CD:\nclass SmartPtr<Cassette> {\nclass SmartPtr<CD> {\ntype conversion operator for each direct base class, think again.\ndefined type conversion function at a time, they can’t convert a smart\npointer-to-T to a smart pointer-to-indirect-base-class-of-T unless they\ncalled member templates), and you use it to generate smart pointer\nclass SmartPtr {\n// pointers-to-T objects\nSuppose a compiler has a smart pointer-to-T object, and it’s faced with\nthe need to convert that object into a smart pointer-to-base-class-of-T.\npointee to the constructor for the smart pointer-to-base-of-T.\nsion operator will compile, and the implicit conversion from smart\npointer-to-T to smart pointer-to-base-of-T will succeed.\nthe smart pointers to CDs or cassettes into smart pointers to music\nSmart Pointers\nvoid displayAndPlay(const SmartPtr<MusicProduct>& pmp,\nWith the revised smart pointer class containing the member function\ntemplate for implicit type conversion operators, this code will succeed.\nThe object funMusic is of type SmartPtr<Cassette>.\ndisplayAndPlay expects a SmartPtr<MusicProduct> object.\ninto a SmartPtr<MusicProduct> object.\nan implicit type conversion operator in the SmartPtr<Cassette> class\nconstruct a SmartPtr<MusicProduct> object with a Cassette*\npointer.\nsions between dumb pointer types, and it’s clear that Cassette* can\nImplicit conversion of smart pointer types.\nexample into assuming that this works only for pointer conversions up\nimplicit conversion between pointer types.\ntype T1* and another dumb pointer type T2*, you can implicitly con-\nclass SmartPtr { ...\nvoid displayAndPlay(const SmartPtr<MusicProduct>& pmp,\nvoid displayAndPlay(const SmartPtr<Cassette>& pc,\nSmartPtr<Cassette> object.\nThey employ member functions as conversion operators, and as far as\nSmart Pointers\nImplementing smart pointer conversions through member templates\nhow we can make smart pointer classes behave just like dumb point-\nsmart, but they’re not pointers.\nSmart Pointers and const\nRecall that for dumb pointers, const can refer to the thing pointed to,\nto the pointer itself, or both:\n// p is a non-const pointer\n// to a const CD object\n// p is a const pointer to \n// a non-const CD object;\n// p is a const pointer to\n// a const CD object\nplies to the pointer, not to the object pointed to:\nconst SmartPtr<CD> p =\n// to a non-const CD object\nSmartPtr<const CD> p =\n// to a const CD object\n// non-const pointer\nSmartPtr<const CD> p;\n// non-const pointer\nconst SmartPtr<CD> p = &goodCD;\n// const pointer\nconst SmartPtr<const CD> p = &goodCD; // const object,\n// const pointer\npointers to const objects with pointers to non-consts; the rules for\nBut look what happens if we try the same thing with smart pointers:\nSmartPtr<const CD> pConstCD = pCD;\njects of type SmartPtr<CD> to objects of type SmartPtr<const CD>.\nFurthermore, anything you can do with a const pointer you can do\nSmart Pointers\ncan do with a pointer-to-const is legal for a pointer-to-non-const, but\nconsts that you can’t do with pointers-to-consts.\nclass publicly inherit from a corresponding smart pointer-to-const-T\n// smart pointers to const\n// the usual smart pointer\n// smart pointers to\nclass SmartPtr:\nWith this design, the smart pointer-to-non-const-T object needs to\ncontain a dumb pointer-to-non-const-T, and the smart pointer-to-\nconst-T needs to contain a dumb pointer-to-const-T.\nto handle this would be to put a dumb pointer-to-const-T in the base\npointer-to-const-T\npointer-to-non-const-T\nclass and a dumb pointer-to-non-const-T in the derived class.\nthe constPointee pointer, SmartPtr<T> objects use the pointee\npointer.\npointers, inheritance-based conversions, and support for pointers-to-\nSmart pointers",
      "keywords": [
        "Smart Pointers",
        "Smart",
        "Pointers",
        "SmartPtr",
        "const",
        "Cassette",
        "object",
        "conversion",
        "smart pointer class",
        "dumb pointers",
        "MusicProduct",
        "implicit type conversion",
        "type",
        "Cassette Smart Pointers",
        "type conversion"
      ],
      "concepts": [
        "pointers",
        "classes",
        "smart",
        "object",
        "cassette",
        "conversions",
        "functions",
        "functionality",
        "types",
        "member"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 22,
          "title": "",
          "score": 0.805,
          "base_score": 0.655,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 19,
          "title": "",
          "score": 0.764,
          "base_score": 0.614,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 4,
          "title": "",
          "score": 0.642,
          "base_score": 0.492,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 14,
          "title": "",
          "score": 0.552,
          "base_score": 0.402,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 13,
          "title": "",
          "score": 0.528,
          "base_score": 0.378,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "smartptr",
          "smart",
          "pointer",
          "const",
          "cd"
        ],
        "semantic": [],
        "merged": [
          "smartptr",
          "smart",
          "pointer",
          "const",
          "cd"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3952818357910308,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971164+00:00"
      }
    },
    {
      "chapter_number": 21,
      "title": "Segment 21 (pages 200-215)",
      "start_page": 200,
      "end_page": 215,
      "summary": "Reference Counting\nItem 29: Reference counting.\nReference Counting\nReference counting is a technique that allows multiple objects with the\nInstead, it’s better to let all the objects with that value share\nstruct redundant copies of the same object value.\nmight come to have many objects with the same value in the first\nclass String {\nString(const char *value = \"\");\nString& operator=(const String& rhs);\nString class is implemented, but a common implementation would\nhave each String object carry its own copy of the value.\nString’s assignment operator might be implemented like this:\nString& String::operator=(const String& rhs)\nHere only one copy of the value “Hello” is stored, and all the String\nobjects with that value share its representation.\nkeep track of how many objects are sharing a value.\nscope, no object would have that value and we’d have to destroy the\nReference Counting\nImplementing Reference Counting\nCreating a reference-counted String class isn’t difficult, but it does\nthe reference count for each String value.\nString object, because we need one reference count per string value,\nnot one reference count per string object.\ntween values and reference counts, so we’ll create a class to store ref-\nclass String {\n// and a string value\nStringValue *value;\n// value of this String\nphasize that it’s implemented using reference counting, but the imple-\nOur reference-counting implementation of the String inter-\nclass String {\nString::StringValue::StringValue(const char *initValue)\nString::StringValue::~StringValue()\nenough to implement the full functionality of a reference-counted\nstring.\nReference Counting\nthe String class.\nString objects sharing that value.\nWe’re now ready to walk our way through String’s member functions.\nclass String {\nuse the passed-in char* string to create a new StringValue object,\nthen we make the String object we’re constructing point to the newly-\nString objects constructed separately, but with the same initial value\nalso efficient: the newly created String object shares the same\nStringValue object as the String object that’s being copied:\nString s2 = s1;\ncounted) String class, because there is no need to allocate memory\nfor the second copy of the string value, no need to deallocate that mem-\nStringValue is non-zero, at least one String object is using the\nOnly when the String being\nence count is 1 — should the String destructor destroy the\nStringValue object:\nclass String {\n~String();\nReference Counting\na non-reference-counted implementation.\nProvided that different String objects do in fact sometimes have\nclass String {\nString& operator=(const String& rhs);\n// s1 and s2 are both String objects\nsame StringValue object.\nThat object’s reference count should there-\nthat value.\nIf s1 was the only String with that value, the value should\nString& String::operator=(const String& rhs)\n// do nothing if the values\n// value\nTo round out our examination of reference-counted strings, consider\nclass String {\n// for const Strings\nward, because it’s a read-only operation; the value of the string can’t\nconst char& String::operator[](int index) const\nString s;\nWhen we modify a String’s value, we have to be careful to avoid mod-\nifying the value of other String objects that happen to be sharing the\nsame StringValue object.\nno other String object shares the StringValue to be modified by the\nReference Counting\na String’s StringValue object is exactly one any time we return a ref-\n// if we’re sharing a value with other String objects,\n// be using that value any more\nvalue =\nnew StringValue(value->data);\n// value for ourselves\nThis idea — that of sharing a value with other objects until we have to\nString s2 = s1;\nThe String copy constructor will make s2 share s1’s StringValue, so\nThere is no way the String copy constructor can detect this problem,\nif someone had saved a reference to the result of a call to String’s non-\ncounted strings.\nIf you have access to a reference-counted string, try\nyou have access to a reference-counted string, try the example any-\noperator[] is invoked on the value represented by that object.\nReference Counting\nclass String {\nString::StringValue::StringValue(const char *initValue)\nString::StringValue::~StringValue()\nvalue = new StringValue(rhs.value->data);\nA Reference-Counting Base Class\nReference counting is useful for more than just strings.\nsomehow write (and test and document) the reference counting code in\nThe first step is to create a base class, RCObject, for reference-counted\nReference Counting\nCount to 0, regardless of the value of refCount for the RCObject we’re\nRCObject is a base class for a shared value object, and in a system\nbased on reference counting, such objects are not assigned to one an-\nStringValue objects to be assigned to one another, we expect only\nString objects to be involved in assignments.\nStringValue reference count is modified.\nreference-counted values (see Item 32).\nStringValue objects.\nBefore the assignment, some number of String objects are pointing to\nSimilarly, some number of String objects are\nactly the same String objects point to sv2.\nsv2’s reference count is\nhence RCObject::operator= should change no reference counts.\nReference Counting\nTo take advantage of our new reference-counting base class, we modify\nStringValue to inherit its reference counting capabilities from RCOb-\nclass String {\nString::StringValue::StringValue(const char *initValue)\nString::StringValue::~StringValue()\n(StringValue) inheriting from a class (RCObject) that’s unrelated to\nthe nesting class (String).\nThe RCObject class gives us a place to store a reference count, and it\ngives us member functions through which that reference count can be\nand the String assignment operator to call addReference and re-\nclasses like String from worrying about any of the details of reference\n(In some application classes, you can eliminate all reference-counting\ncode, but our String class, alas, isn’t one of them.\nNotice that each String object contains a pointer to the StringValue\nobject representing that String’s value:\nclass String {\nStringValue *value;\n// value of this String",
      "keywords": [
        "String",
        "Reference Counting",
        "String objects",
        "class String",
        "Reference",
        "StringValue",
        "const String",
        "object",
        "StringValue object",
        "Counting",
        "RCObject",
        "String object shares",
        "Item",
        "const",
        "strings"
      ],
      "concepts": [
        "string",
        "strings",
        "objects",
        "counting",
        "reference",
        "referring",
        "refer",
        "value",
        "item",
        "operator"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 23,
          "title": "",
          "score": 0.851,
          "base_score": 0.701,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 24,
          "title": "",
          "score": 0.743,
          "base_score": 0.593,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 12,
          "title": "",
          "score": 0.704,
          "base_score": 0.554,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 7,
          "title": "",
          "score": 0.663,
          "base_score": 0.513,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 22,
          "title": "",
          "score": 0.634,
          "base_score": 0.484,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "string",
          "stringvalue",
          "reference",
          "value",
          "reference counting"
        ],
        "semantic": [],
        "merged": [
          "string",
          "stringvalue",
          "reference",
          "value",
          "reference counting"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3823408598164278,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971200+00:00"
      }
    },
    {
      "chapter_number": 22,
      "title": "Segment 22 (pages 216-223)",
      "start_page": 216,
      "end_page": 223,
      "summary": "smart pointer-to-T point to an object that isn’t of type T.\nHere’s a template for objects that act as smart pointers to reference-\n// template class for smart pointers-to-T objects.\nclass RCPtr {\nRCPtr(const RCPtr& rhs);\n~RCPtr();\nRCPtr& operator=(const RCPtr& rhs);\nFor example, when an RCPtr is created, the object it points to needs to\nmanually, because RCPtr constructors can handle it themselves.\nRCPtr<T>::RCPtr(const RCPtr& rhs): pointee(rhs.pointee)\nvoid RCPtr<T>::init()\nWhen init needs to create a new copy of a value\nobject and initializes it by calling T’s copy constructor.\nRCPtr in the String class, T will be String::StringValue, so the\nstatement above will call String::StringValue’s copy constructor.\nWe haven’t declared a copy constructor for that class, however, so our\nconstructors in C++, copy only StringValue’s data pointer; it will not\ncopy the char* string data points to.\nRCPtr class:\nclass String {\nString::StringValue::StringValue(const StringValue& rhs)\nIn view of the fact that RCPtr objects are designed to point only\nA final assumption in RCPtr<T> is that the type of the object pointed\nBut pointee might really point to a class derived from T.\nfrom String::StringValue,\nclass String {\nwe could end up with a String containing a RCPtr<StringValue>\nto call SpecialStringValue’s copy constructor, not StringValue’s.\nIn the case of our String class, we don’t expect classes\nWith RCPtr’s constructors out of the way, the rest of the class’s func-\nfunction that was created for RCPtr’s constructors.\nRCPtr<T>& RCPtr<T>::operator=(const RCPtr& rhs)\nIf the RCPtr that just expired was the last reference to the object, that\nHence RCPtr objects never need to worry about destroying\nFinally, RCPtr’s pointer-emulating operators are part of the smart\nT* RCPtr<T>::operator->() const { return pointee; }\nT& RCPtr<T>::operator*() const { return *pointee; }\ngether and build a reference-counted String class based on the reus-\nable RCObject and RCPtr classes.\nclass RCPtr {\nRCPtr(const RCPtr& rhs);\n~RCPtr();\nRCPtr& operator=(const RCPtr& rhs);\nRCPtr\nclass\nclass RCObject {\nRCObject& operator=(const RCObject& rhs);\nclass String {\n// class to be used by\nString(const char *value = \"\");\n// class representing string values\nvoid init(const char *initValue);\nRCPtr<StringValue> value;\nwe’ve added an init function to String::StringValue, but, as we’ll\nin RCPtr: it prevents code duplication in the constructors.\nunderlying reference-counted StringValue objects, but the String\nThat’s because the compiler-generated copy constructor for String\nwill automatically call the copy constructor for String’s RCPtr mem-\nber, and the copy constructor for that class will perform all the neces-\nAn RCPtr is a smart pointer, remember?\nand RCPtr classes), so don’t be so surprised when it suddenly starts\nvoid RCPtr<T>::init()\nRCPtr<T>::RCPtr(const RCPtr& rhs)\nRCPtr<T>& RCPtr<T>::operator=(const RCPtr& rhs)\nT* RCPtr<T>::operator->() const { return pointee; }\nT& RCPtr<T>::operator*() const { return *pointee; }\nvoid String::StringValue::init(const char *initValue)\nString::StringValue::StringValue(const char *initValue)",
      "keywords": [
        "RCPtr",
        "String",
        "const",
        "pointee",
        "RCObject",
        "StringValue",
        "const RCPtr",
        "String class",
        "copy",
        "copy constructor",
        "template",
        "init",
        "constructor",
        "operator",
        "rhs"
      ],
      "concepts": [
        "classes",
        "string",
        "copy",
        "pointers",
        "value",
        "counting",
        "object",
        "assignment",
        "assignments",
        "public"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 19,
          "title": "",
          "score": 0.814,
          "base_score": 0.664,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 20,
          "title": "",
          "score": 0.805,
          "base_score": 0.655,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 23,
          "title": "",
          "score": 0.747,
          "base_score": 0.597,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 4,
          "title": "",
          "score": 0.678,
          "base_score": 0.528,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 15,
          "title": "",
          "score": 0.672,
          "base_score": 0.522,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "rcptr",
          "stringvalue",
          "string",
          "const rcptr",
          "rcptr rhs"
        ],
        "semantic": [],
        "merged": [
          "rcptr",
          "stringvalue",
          "string",
          "const rcptr",
          "rcptr rhs"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.43358574555861257,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971237+00:00"
      }
    },
    {
      "chapter_number": 23,
      "title": "Segment 23 (pages 224-233)",
      "start_page": 224,
      "end_page": 233,
      "summary": "Reference Counting\nUltimately, all roads lead to String, and that class is implemented\nconst char& String::operator[](int index) const\n{ return value->data[index]; }\nchar& String::operator[](int index)\nvalue = new StringValue(value->data);\nreturn value->data[index];\nIf you compare the code for this String class with that we developed\nfor the String class using dumb pointers, you’ll be struck by two\nRCPtr has assumed much of the reference-counting burden that used\nwhere our use of the smart RCPtr object eliminates the need to manu-\nally manipulate the reference count during a copy-on-write.\nWho can object to less code?\ncounting, we added the ability to mark individual string values as un-\nreference counts, yet not one line of client code needs to be changed.\nSure, we changed the String class definition, so clients who want to\ntake advantage of reference-counted strings must recompile and\nAdding Reference Counting to Existing Classes\napply the benefits of reference counting to some class Widget that’s in\nreference counting to any type.\nclass, CountHolder, to hold the reference count, and we have Count-\nCountHolder class.\nobject\nobject\nobject\nclass\nobject\nclass\nobject\nobject\nobject\nReference Counting\nclass RCIPtr {\nRCIPtr& operator=(const RCIPtr& rhs);\nT* RCIPtr<T>::operator->() const\nT& RCIPtr<T>::operator*() const\nto values directly, while RCIPtr objects point to values through an in-\nlying RCIPtr to a Widget object.\nclass Widget {\nWidget& operator=(const Widget& rhs);\nclass RCWidget {\nRCWidget(int size): value(new Widget(size)) {}\nvalue = new Widget(*value);\nint showThat() const { return value->showThat(); }\nRCIPtr<Widget> value;\nReference Counting\nRCWidget’s doThis calls doThis in the Widget class; and how RCWid-\nAs with the String class, there is no need\nThanks to the behavior of the RCIPtr class,\nwrite a program that takes a class like Widget as input and produces\na class like RCWidget as output.\nues, smart pointers, and reference-counting base classes.\nReference-counting implementations are not without cost.\nence-counted value carries a reference count with it, and most opera-\nObject values therefore require more memory, and we\nence-counted class than for a less elaborate implementation.\nreference-counted string class typically stands on its own, while our\nclasses (StringValue, RCObject, and RCPtr).\nReference counting is an optimization technique predicated on the as-\nsumption that objects will commonly share values (see also Item 18).\nthis assumption fails to hold, reference counting will use more memory\nIn short, reference counting is most useful for improving ef-\n■Relatively few values are shared by relatively many objects.\nThe higher the objects/values ratio,\nEven when this is the case, reference counting\nwhether the benefits of reference counting (of which there are many)\ntions of objects, used by no one, whose reference counts never drop to\nan object’s reference count, it checks to see if the new count is 0.\nsafe operation only if the object was allocated by calling new, so we\nbase class of reference-counted value objects, and those value objects\nrealize values are being shared; the classes describing the value ob-\nclass for value objects is StringValue, and we limit its use by making\nOnly String can create StringValue objects, so\nit is up to the author of the String class to ensure that all such objects\nof classes can create RCObjects.\nWe limit the right to create reference-counted objects,\nThe usual way is the standard one in C++: create a class to\nclass Array2D {\nbut how do we declare the indexing operator in Array2D to let us do\nclass Array2D {\nclass Array2D {\nClients then use arrays this way:\nerator[] to return an object of a new class, Array1D.\nclass Array2D {\nclass Array1D {\nconst T& operator[](int index) const;\nArray1D operator[](int index);\nconst Array1D operator[](int index) const;\nHere, data[3] yields an Array1D object and the operator[] invoca-\nClients of the Array2D class need not be aware of the presence of the\nArray1D class.\nObjects of this latter class stand for one-dimensional\narray objects that, conceptually, do not exist for clients of Array2D.",
      "keywords": [
        "Reference Counting",
        "String class",
        "String",
        "Widget",
        "Reference",
        "int",
        "RCIPtr",
        "objects",
        "const",
        "Counting",
        "operator",
        "data",
        "Widget object",
        "arrays",
        "Classes"
      ],
      "concepts": [
        "value",
        "classes",
        "object",
        "arrays",
        "reference",
        "refer",
        "referred",
        "data",
        "widget",
        "counting"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 21,
          "title": "",
          "score": 0.851,
          "base_score": 0.701,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 22,
          "title": "",
          "score": 0.747,
          "base_score": 0.597,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 24,
          "title": "",
          "score": 0.704,
          "base_score": 0.554,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 4,
          "title": "",
          "score": 0.669,
          "base_score": 0.519,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 12,
          "title": "",
          "score": 0.604,
          "base_score": 0.454,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "reference",
          "reference counting",
          "counting",
          "widget",
          "class"
        ],
        "semantic": [],
        "merged": [
          "reference",
          "reference counting",
          "counting",
          "widget",
          "class"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3958165648165019,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971272+00:00"
      }
    },
    {
      "chapter_number": 24,
      "title": "Segment 24 (pages 234-241)",
      "start_page": 234,
      "end_page": 241,
      "summary": "stand for other objects are often called proxy objects, and the classes\nDistinguishing Reads from Writes via operator[]\nreads from writes through operator[].\nConsider a reference-counted string type that supports operator[].\nA string type supporting operator[] allows clients to write code like\nString s1, s2;\nconst char& operator[](int index) const;\nconst member functions by looking only at whether the object invok-\nString s1, s2;\n// calls non-const operator[],\n// operator[]: s2 isn’t const\n// operator[], because both s1\npossible to distinguish lvalue from rvalue usage inside operator[],\ntell whether operator[] is being invoked in an lvalue or an rvalue\noperator[] has returned.\nify operator[] to return a proxy for a string character instead of a\nused in this way, a proxy represents an lvalue use of the string on\nan rvalue use of the string on which operator[] was invoked.\nusing a proxy class to distinguish between lvalue and rvalue usages of\noperator[]:\n// proxies for string chars\nCharProxy(String& str, int index);\nCharProxy& operator=(const CharProxy& rhs); // lvalue\nCharProxy& operator=(char c);\noperator char() const;\nconst CharProxy\noperator[](int index) const;\n// for const Strings\nCharProxy operator[](int index);\n// for non-const Strings\nString class in Item 29 is that both operator[] functions now return\never, and program as if the operator[] functions returned characters\nString s1, s2;\nProxy to char declared in the CharProxy class.\ninvoke this conversion operator, and the result is that the string char-\nProxy objects used as rvalues.\nassignment operator that’s called is in the CharProxy class.\ncrucial, because inside a CharProxy assignment operator, we know\nthat the CharProxy object being assigned to is being used as an lvalue.\nWe therefore know that the string character for which the proxy stands\ncalls the assignment operator for two CharProxy objects, and inside\nthat operator we know the object on the left is being used as an lvalue\nString’s operator[] functions:\nconst String::CharProxy String::operator[](int index) const\nreturn CharProxy(const_cast<String&>(*this), index); \nString::CharProxy String::operator[](int index)\nNote that the const version of operator[] returns a const proxy.\ncause CharProxy::operator= isn’t a const member function, such\nproxy returned from the const version of operator[] nor the charac-\nthe CharProxy object that the const operator[] returns.\nthis case the CharProxy object returned by operator[] is itself\nEach proxy returned by an operator[] function remembers which\nString::CharProxy::operator char() const\nWe thus turn to implementation of CharProxy’s assignment operators,\nWe can implement CharProxy’s conventional assignment oper-\nString::CharProxy&\nString::CharProxy::operator=(const CharProxy& rhs)\nString::operator[] in Item 29 on page 207, you’ll see that they are\nmenting a write into CharProxy’s assignment operators, and that al-\nlows us to avoid paying for a write when the non-const operator[] is\nString.\nThe second CharProxy assignment operator is almost identical:\nString::CharProxy& String::CharProxy::operator=(char c)\nThe use of a proxy class is a nice way to distinguish lvalue and rvalue\nString::operator[] returns a CharProxy instead of a char&, that\nchar * operator&();\nconst char * operator&() const;\nconst char * String::CharProxy::operator&() const\nThe non-const function is a bit more work, because it returns a\nbehavior of the non-const version of String::operator[] in Item 29,\nchar * String::CharProxy::operator&()\narrays that use proxy classes to distinguish lvalue and rvalue invoca-",
      "keywords": [
        "string",
        "operator",
        "CharProxy",
        "Proxy",
        "Item",
        "Proxy Classes",
        "const",
        "string character",
        "char",
        "Classes",
        "Objects",
        "String class",
        "lvalue",
        "rvalue",
        "character"
      ],
      "concepts": [
        "string",
        "strings",
        "operator",
        "proxy",
        "proxies",
        "char",
        "objects",
        "classes",
        "returning",
        "different"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 21,
          "title": "",
          "score": 0.743,
          "base_score": 0.593,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 23,
          "title": "",
          "score": 0.704,
          "base_score": 0.554,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 13,
          "title": "",
          "score": 0.698,
          "base_score": 0.548,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 7,
          "title": "",
          "score": 0.685,
          "base_score": 0.535,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 12,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "charproxy",
          "operator",
          "string",
          "const",
          "lvalue"
        ],
        "semantic": [],
        "merged": [
          "charproxy",
          "operator",
          "string",
          "const",
          "lvalue"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.41453775947237614,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971323+00:00"
      }
    },
    {
      "chapter_number": 25,
      "title": "Segment 25 (pages 242-261)",
      "start_page": 242,
      "end_page": 261,
      "summary": "Proxy Classes\nclass Array {\nclass Proxy {\nthese operators to work with operator[] functions that return prox-\nies, you must define each of these functions for the Array<T>::Proxy\nclass.\nA related problem has to do with invoking member functions on real\nand denominator member functions exist only for Rationals, not\nfunction applicable to the real objects so it applies to proxies, too.\nfunction is invoked.\ncompilers may use only one user-defined conversion function when\nFor example, suppose we have a TVStation class and a function,\nProxy Classes\nUsing the template for reference-counted arrays that use proxy classes\nAs function re-\nFinally, shifting from a class that works with real objects to a class that\nraySize object (see Item 5) would be passed to a function expecting a\nItem 31: Making functions virtual with respect to \nmore than one object.\nclass GameObject { ...\nclass SpaceShip: public GameObject { ...\nclass SpaceStation: public GameObject { ...\nclass Asteroid: public GameObject { ...\na function that looks something like this:\nvoid checkForCollision(GameObject& object1,\nGameObject& object2)\nthe dynamic type of object1, you could make processCollision vir-\nA function call that’s\nvirtual on only one object, you see, is not enough.\nWhat you need is a kind of function whose behavior is somehow virtual\non the types of more than one object.\nC++ offers no such function.\nobject-oriented function-invocation mechanism one can imagine:\nA multi-method is a function that’s virtual on as many\nwhen they implement virtual functions (see Item 24).\nUsing Virtual Functions and RTTI\nVirtual functions implement a single dispatch; that’s half of what we\nneed; and compilers do virtual functions for us, so we begin by declar-\ning a virtual function collide in GameObject.\nThis function is over-\nclass GameObject {\nvirtual void collide(GameObject& otherObject) = 0;\nclass SpaceShip: public GameObject {\nvirtual void collide(GameObject& otherObject);\n// if we collide with an object of unknown type, we\nvoid SpaceShip::collide(GameObject& otherObject)\nNotice how we need to determine the type of only one of the objects in-\nThe other object is *this, and its type is deter-\nmined by the virtual function mechanism.\nmember function, so *this must be a SpaceShip object.\nlide function must be aware of each of its sibling classes, i.e., those\nclasses that inherit from GameObject.\nobject — a new class — is added to the game, we must update each\nthe new object type.\nThis is the primary reason why virtual functions\nmaintaining type-based function calls from programmers to compilers.\nUsing Virtual Functions Only\nfunctions.\nThe collide function is declared virtual in GameOb-\nclass SpaceShip;\nclass SpaceStation;\nclass Asteroid;\nclass GameObject {\nvirtual void collide(GameObject&\nvirtual void collide(SpaceShip&\nvirtual void collide(SpaceStation& otherObject) = 0;\nvirtual void collide(Asteroid&\nclass SpaceShip: public GameObject {\nvirtual void collide(GameObject&\nvirtual void collide(SpaceShip&\nvirtual void collide(SpaceStation& otherObject);\nvirtual void collide(Asteroid&\npatches, i.e., as two separate virtual function calls: the first deter-\nfunction taking a GameObject& parameter.\nvoid SpaceShip::collide(GameObject& otherObject)\nObject becoming the object calling the member function and *this\nbecoming the function’s parameter.\na set of functions to call on the basis of the static types of the argu-\nfunctions could be called, but the one chosen is based on the static\ntion of the class SpaceShip, *this must be of type SpaceShip.\ncall is therefore to the collide function taking a SpaceShip&, not the\ncollide function taking a GameObject&.\nAll the collide functions are virtual, so the call inside Space-\ncollide, the real types of both objects are known, because the left-\nhand object is *this (and therefore has as its type the class imple-\nmenting the member function) and the right-hand object’s real type is\ncollide functions in SpaceShip:\nvoid SpaceShip::collide(SpaceStation& otherObject)\nvoid SpaceShip::collide(Asteroid& otherObject)\nexceptions for unexpected object types.\nobject types — that’s the whole point of using virtual functions.\ntion must be amended to include a new virtual function.\nGameObject) to your game, you’d have to add a new collide function\nadding new member functions, virtual or otherwise, is not an option.\nusing a library containing GameObject and other useful classes.\nFailing that, the virtual function approach is safer than\nEmulating Virtual Function Tables\nthat compilers typically implement virtual functions by creating an\narray of function pointers (the vtbl) and then indexing into that array\nwhen a virtual function is called.\nit allows compilers to generate the same code at all virtual function call\nfollowing a function pointer is almost always more efficient than run-\nplace where your array of function pointers is initialized.\nclass GameObject {\nvirtual void collide(GameObject& otherObject) = 0;\nclass SpaceShip: public GameObject {\nvirtual void collide(GameObject& otherObject);\nvirtual void hitSpaceShip(SpaceShip& otherObject);\nclass contains only one function for processing collisions, the one that\nneed except an implementation for SpaceShip::collide; that’s where\nfully implement the SpaceShip class, the SpaceStation and Aster-\nInside SpaceShip::collide, we need a way to map the dynamic type\nof the parameter otherObject to a member function pointer that\npoints to the appropriate collision-handling function.\nthe appropriate member function pointer.\nber function pointer.\nreturns a pointer to the member function to call when you collide with\nclass SpaceShip: public GameObject {\nThe syntax of function pointers is never very pretty, and for member\nfunction pointers it’s worse than usual, so we’ve typedefed HitFunc-\ntionPtr to be shorthand for a pointer to a member function of Space-\nvoid SpaceShip::collide(GameObject& otherObject)\n// find the function to call\n// if a function was found\nthe class hierarchy under GameObject, lookup must always find a\nvalid function pointer for the object we pass it.\nciative array that maps from object types to member function pointers,\nclass SpaceShip: public GameObject {\nclass (as a string object) to a SpaceShip member function pointer.\nrectly supported by the map class, and the one member function we\n// look up the collision-processing function for the type\nA preferable design is to use a container-friendly class that wraps type_info ob-\nThe final statement in the function returns (*mapEntry).second in-\nInitializing Emulated Virtual Function Tables\nbut this inserts the member function pointers into collisionMap each\nWhat we need now is a way to put the member function pointers into\nclass SpaceShip: public GameObject {\nclass SpaceShip: public GameObject {\ndeclared to hold pointers to member functions that all take the same\nno such conversion for pointers to functions taking these argument\nchoice when converting between function pointer types:\nShip, hitSpaceStation, and hitAsteroid are functions expecting a\ngenerating bad code for functions you call through *phm in cases\nhave virtual base classes.\nShip, or Asteroid had other base classes (in addition to GameObject),\nyou’d probably find that your calls to collision-processing functions in\nEach of the four class parts in a D object has a different address.\ntiple base classes (such as a D object) is passed by reference, it is\ning to the declared type of the parameter in the function being called.\nof the functions so they all take GameObject arguments:\nclass GameObject {\nvirtual void collide(GameObject& otherObject) = 0;\nPointer to virtual base class\nPointer to virtual base class\nclass SpaceShip: public GameObject {\nvirtual void collide(GameObject& otherObject);\n// these functions now all take a GameObject parameter\nvirtual void hitSpaceShip(GameObject& spaceShip);\nvirtual void hitSpaceStation(GameObject& spaceStation);\nvirtual void hitAsteroid(GameObject& asteroid);\ntual functions overloaded the function name collide.\ncided to use an associative array of member function pointers instead.\nAll the hit functions take the same parameter type, so we must give\nRegrettably, our hit functions now get a general GameObject param-\n(see Item 2) at the top of each function:\nvoid SpaceShip::hitSpaceStation(GameObject& spaceStation)\nvoid SpaceShip::hitAsteroid(GameObject& asteroid)\nUsing Non-Member Collision-Processing Functions\ncapsulate the details of the associative array inside a lookup function.\nBecause this array contains pointers to member functions, however,\nwe still have to modify class definitions if a new type of GameObject is\npeople who don’t care about the new type of object.\nShip class with a declaration of a function to handle collisions between\ndispatching based purely on virtual functions, and that solution was a\ntained pointers to non-member functions.\nnon-member collision-processing functions would let us address a de-\ncollisions between objects of different types be handled?\nthe collision will be handled inside the class for object 1.\nIf object 2\never, the collision will be handled inside the class for object 2.\nIf we move the collision-processing functions out of our classes, we can\nor collide functions.",
      "keywords": [
        "function",
        "virtual void collide",
        "SpaceShip",
        "GameObject",
        "functions",
        "virtual",
        "virtual function",
        "virtual void",
        "member function",
        "Implementing Multiple Dispatch",
        "Item",
        "object",
        "collide",
        "asteroid",
        "type"
      ],
      "concepts": [
        "classes",
        "functions",
        "function",
        "objects",
        "spaceship",
        "arrays",
        "implement",
        "implementing",
        "implementations",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 2,
          "title": "",
          "score": 0.705,
          "base_score": 0.555,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 31,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 33,
          "title": "",
          "score": 0.603,
          "base_score": 0.453,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 5,
          "title": "",
          "score": 0.548,
          "base_score": 0.398,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 16,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "gameobject",
          "collide",
          "spaceship",
          "virtual",
          "function"
        ],
        "semantic": [],
        "merged": [
          "gameobject",
          "collide",
          "spaceship",
          "virtual",
          "function"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.355989268083748,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971357+00:00"
      }
    },
    {
      "chapter_number": 26,
      "title": "Segment 26 (pages 262-270)",
      "start_page": 262,
      "end_page": 270,
      "summary": "// primary collision-processing functions\nvoid shipAsteroid(GameObject& spaceShip,\nGameObject& asteroid);\nvoid shipStation(GameObject& spaceShip,\nvoid asteroidStation(GameObject& asteroid,\n// secondary collision-processing functions that just\n// primary function\nGameObject& spaceShip)\nGameObject& spaceShip)\nGameObject& asteroid)\n// see below for a description of these types/functions\ntypedef map< pair<string,string>, HitFunctionPtr > HitMap;\nHitFunctionPtr lookup(const string& class1,\nconst string& class2);\nvoid processCollision(GameObject& object1,\nGameObject& object2)\nNote the use of the unnamed namespace to contain the functions used\ncurrent file) — it’s just like the functions were declared static at file\nFinally, lookup must now take two type names and perform\ntionPtr. As fate would have it, the standard map class is defined to hold only\n// we use this function to create pair<string,string>\nNote how this function\nHitFunctionPtr lookup(const string& class1,\nconst string& class2)\ncollisionMap->find(make_pair(class1, class2));\nthe use of the make_pair function in this statement:\ncollisionMap->find(make_pair(class1, class2));\nmake_pair is just a convenience function (template) in the standard li-\ncollisionMap->find(pair<string,string>(class1, class2));\npair is redundant (they’re the same as the types of class1 and\nclass2), so the make_pair form is more commonly used.\nof the functions above are in the unnamed namespace (for the same\nare added to our hierarchy, existing classes need not recompile (unless\nthey wish to use the new classes).\nchanges to our system: the addition of one or more map insertions in\nprocessing functions in the unnamed namespace associated with the\nconversions when calling collision-processing functions.\ncommercial space ships and military space ships.\nSuppose commercial and military ships behave identically when they\ncollision-processing functions we had before CommercialShip and\nvoid shipAsteroid(GameObject& spaceShip,\nGameObject& asteroid);\nfunction corresponding to the type names “MilitaryShip” and “Aster-\noid,” and no such function would be found in collisionMap. Even\nan alternative approach to initializing collisionMap. As things stand now, our design is entirely static.\ntered a function for processing collisions between two types of objects,\nremove, or change collision-processing functions as the game pro-\nsion-processing functions into a class that offers member functions al-\nclass CollisionMap {\nvoid addEntry(const string& type1,\nHitFunctionPtr lookup(const string& type1,\n// this function returns a reference to the one and only\n// map — see Item 26\n// of multiple maps — see Item 26\nThis class lets us add entries to the map, remove them from it, and\nlook up the collision-processing function associated with a particular\ncollisions to the map (i.e., collisions in which the effect of an object of\nWith the CollisionMap class, each client wishing to add an entry to\nvoid shipAsteroid(GameObject& spaceShip,\nGameObject& asteroid);\nvoid shipStation(GameObject& spaceShip,\nvoid asteroidStation(GameObject& asteroid,\nclass RegisterCollisionFunction {\nister the functions they need:\nIf, later, a new derived class is added\nclass Satellite: public GameObject { ...\nand one or more new collision-processing functions are written,\nGameObject& spaceShip);\nGameObject& asteroid);\nthese new functions can be similarly added to the map without dis-\nThis doesn’t change the fact that there’s no perfect way to implement\nTo program in the future tense is to accept that things will change and\nIt is to recognize that new functions will be added\nedge that new classes will be added to hierarchies, that present-day\nthat functions will be called in new contexts, and to write those func-\nOne way to do this is to express design constraints in C++ instead of\nment in the header file above the class, use C++ to prevent derivation;\nGiven that things will change, write classes that can withstand the\nvirtual functions, whereby you make no functions virtual unless some-\nmeaning of a function and whether it makes sense to let it be redefined\nchange makes sense in the context of the entire class and the abstrac-\nIf these functions are",
      "keywords": [
        "GameObject",
        "functions",
        "const string",
        "function",
        "asteroid",
        "void",
        "spaceShip",
        "const",
        "namespace",
        "map",
        "Item",
        "collisionMap",
        "pair",
        "Implementing Multiple Dispatch",
        "unnamed namespace"
      ],
      "concepts": [
        "classes",
        "function",
        "map",
        "maps",
        "mappings",
        "changes",
        "object",
        "item",
        "spaceship",
        "collisions"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 14,
          "title": "",
          "score": 0.576,
          "base_score": 0.426,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 22,
          "title": "",
          "score": 0.57,
          "base_score": 0.42,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 15,
          "title": "",
          "score": 0.562,
          "base_score": 0.412,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 28,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 12,
          "title": "",
          "score": 0.539,
          "base_score": 0.389,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "gameobject",
          "processing",
          "spaceship",
          "processing functions",
          "map"
        ],
        "semantic": [],
        "merged": [
          "gameobject",
          "processing",
          "spaceship",
          "processing functions",
          "map"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3492828293966167,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971393+00:00"
      }
    },
    {
      "chapter_number": 27,
      "title": "Segment 27 (pages 271-284)",
      "start_page": 271,
      "end_page": 284,
      "summary": "a result, make your classes easy to use correctly and hard to use in-\nlead to virtual base classes, because such classes must be initialized\nHere B is a base class and D is a derived class.\nclass B { ...\nclass D: public B { ...\na delete statement — can result in the need to change the class defi-\nIf a public base class does not have a virtual destructor, no de-\nclass string {\nclass B { ...\nbut if a new class is derived from B, things change:\nclass D: public B {\nbase class should have a virtual destructor.\nWhat class members have destructors now?\nWhat classes in the hierarchy have destructors now?\nis used now, it asks how the class is designed to be used.\nthinking says, if a class is designed to be used as a base class (even if\nclasses behave correctly both now and in the future, and they don’t af-\nfect other library clients when new classes derive from them.\nchanges to the class are required, other clients may be affected.)\nA commercial class library (one that predates the string specification\nin the C++ library standard) contains a string class with no virtual de-\nThe implementation of most String classes contains only a single\nible, heavily used class like String.\nThe performance of such a class\ntrue, but their String class is part of a library they make available to\nString has no virtual destructor, deriving new classes from String is\nIs this class easy to use correctly and hard to use incorrectly?\nThis vendor should provide documentation for its String class that\nmakes clear the class is not designed for derivation, but what if pro-\nWhen new demands are made on your classes, you’re less likely to\nMake the classes easy to use correctly, hard\nfor classes where those operations make no sense.\nItem 33: Make non-leaf classes abstract.\nMaking Non-Leaf Classes Abstract\nclasses for animals, lizards, and chickens is like this:\nThe Animal class embodies the features shared by all the creatures\nyou deal with, and the Lizard and Chicken classes specialize Animal\nclass Animal {\nMaking Non-Leaf Classes Abstract\nclass Lizard: public Animal {\nclass Chicken: public Animal {\non the last line is that of the Animal class, even though the objects in-\nAfter the assignment,\nnot uncommon to make assignments to objects through pointers, es-\nAs Item 32 points out, our classes should be easy to\nuse correctly and difficult to use incorrectly, and the classes in the hi-\nOne approach to the problem is to make the assignment operators vir-\nIf Animal::operator= were virtual, the assignment would invoke\nthe Lizard assignment operator, which is certainly the correct one to\nclass Animal {\nvirtual Animal& operator=(const Animal& rhs);\nclass Lizard: public Animal {\nvirtual Lizard& operator=(const Animal& rhs);\nclass Chicken: public Animal {\nvirtual Chicken& operator=(const Animal& rhs);\nence to the correct class, but the rules of C++ force us to declare iden-\ntical parameter types for a virtual function in every class in which it is\nThat means the assignment operator for the Lizard and\nChicken classes must be prepared to accept any kind of Animal object\nThis is a mixed-type assignment: a Lizard is on the left and a Chicken\nBy making Animal’s assignment operator virtual, however, we\nMaking Non-Leaf Classes Abstract\n// assign a chicken to a lizard\nHere’s how to do it for Lizard’s assignment operator:\nLizard& Lizard::operator=(const Animal& rhs)\nThis function assigns rhs to *this only if rhs is really a Lizard.\nLizard object is assigned to another:\nclass Lizard: public Animal {\nvirtual Lizard& operator=(const Animal& rhs);\nLizard& Lizard::operator=(const Animal& rhs)\nreturn operator=(dynamic_cast<const Lizard&>(rhs));\nthe normal class assignment operator is called.\nMaking Non-Leaf Classes Abstract\nThe easiest way to prevent such assignments is to make operator=\nclass Animal {\nclass Lizard: public Animal {\nclass Chicken: public Animal {\nUnfortunately, Animal is a concrete class, and this approach also\nmakes assignments between Animal objects illegal:\ntors in derived classes are responsible for calling assignment operators\nin their base classes:\n// assign the Animal parts\nobjects while preventing partial assignments of Lizard and Chicken\nmal an abstract class.\nAs an abstract class, Animal can’t be\nAnimal itself abstract, we create a new class — AbstractAnimal, say\nobjects, and we make that class abstract.\nconcrete classes inherit from AbstractAnimal.\nand the class definitions are as follows:\nclass AbstractAnimal {\nMaking Non-Leaf Classes Abstract\nclass Animal: public AbstractAnimal {\nclass Lizard: public AbstractAnimal {\nclass Chicken: public AbstractAnimal {\nare allowed for lizards, chickens, and animals; partial assignments\nand heterogeneous assignments are prohibited; and derived class as-\nclass.\nLizard, or Chicken classes requires modification, because these\nclasses continue to exist and to behave as they did before Abstract-\nfind yourself facing the need to create a class like AbstractAnimal in\nsupport polymorphism through pointers correctly, base classes need\n■the current class is abstract, and \ncause they are called whenever a derived class destructor is invoked.\nclass pointers is based on the assumption that concrete derived\nclasses like Lizard contain data members.\nbers in a derived class, you might point out, there is no problem, and\nconcrete class.\nHowever, just because a class has no data now is no\nReplacement of a concrete base class like Animal with an abstract\nbase class like AbstractAnimal yields benefits far beyond simply\nbecause replacing concrete base classes with abstract base classes\nThat is, it makes you create new abstract classes for useful concepts,\nIf you have two concrete classes C1 and C2 and you’d like C2 to pub-\nlicly inherit from C1, you should transform that two-class hierarchy\ninto a three-class hierarchy by creating a new abstract class A and\nMaking Non-Leaf Classes Abstract\nthe abstract class A.\nformalize the something as a class in C++, at which point it becomes\nAfter all, every class\nclasses for every concept in our hierarchy, one being abstract (to em-\nthem — into existence as abstract classes.\nspond to classes that are useful in their own right (i.e., it is useful to\nor more derived classes.\nThis is precisely why the transformation from concrete base class to\nabstract base class is useful: it forces the introduction of a new ab-\nan abstract class (for the concept) and a concrete class (for the objects\ncrete classes.",
      "keywords": [
        "Animal",
        "Lizard",
        "classes",
        "const Animal",
        "class Lizard",
        "const Lizard",
        "string",
        "Item",
        "public Animal",
        "class Animal",
        "operator",
        "Chicken",
        "virtual",
        "assignment",
        "abstract"
      ],
      "concepts": [
        "classes",
        "operators",
        "operating",
        "operations",
        "make",
        "making",
        "assignment",
        "assignments",
        "animals",
        "lizards"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 2,
          "title": "",
          "score": 0.627,
          "base_score": 0.477,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 5,
          "title": "",
          "score": 0.565,
          "base_score": 0.415,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 16,
          "title": "",
          "score": 0.523,
          "base_score": 0.373,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 31,
          "title": "",
          "score": 0.515,
          "base_score": 0.365,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 25,
          "title": "",
          "score": 0.471,
          "base_score": 0.321,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "animal",
          "lizard",
          "class",
          "abstract",
          "classes"
        ],
        "semantic": [],
        "merged": [
          "animal",
          "lizard",
          "class",
          "abstract",
          "classes"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.36476420196175924,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971428+00:00"
      }
    },
    {
      "chapter_number": 28,
      "title": "Segment 28 (pages 285-292)",
      "start_page": 285,
      "end_page": 292,
      "summary": "concrete class for the packets you’ll actually be using?\nclass for packets.\nthe benefit of an abstract class for packets only if you can design that\nIt is unlikely you could design a satisfactory abstract packet class un-\nconcrete packet class.\nabstract classes, not the way.\nThird-party C++ class libraries\ndoes most of what you need, then inherit from that class.\nthe implementation of the concrete class whose functionality you’d\n// this is the library class\n// this is the class you\nredefine virtual functions declared in the library class, because\nItem 34: Understand how to combine C++ and C in the \nCombining C++ and C in the Same Program\nof object files produced by more than one C compiler.\nmake sure your C++ and C compilers generate compatible object files.\nCombining C++ and C in the Same Program\nC++ compilers give each function in your program a unique name.\nC, this process is unnecessary, because you can’t overload function\nnames, but nearly all C++ programs have at least a few functions with\nAs long as you stay within the confines of C++, name mangling is not\ncompiler mangles into xyzzy, you’ll always use the name drawLine,\nIt’s a different story if drawLine is in a C library.\nIn that case, your C++\nBut if drawLine is a C function, the object file (or archive or dynami-\nLine contains a function called drawLine; no name mangling has\nTo solve this problem, you need a way to tell your C++ compilers not to\nmangle certain function names.\nof functions written in other languages, whether they be in C, assem-\ncall a C function named drawLine, it’s really called drawLine, and\nTo suppress name mangling, use C++’s extern \"C\" directive:\n// declare a function called drawLine; don’t mangle\nextern \"C\" \ntern \"C\" is not as an assertion that the associated function is written\nin C, but as a statement that the function should be called as if it were\nwritten in C.\n(Technically, extern \"C\" means the function has C link-\nextern \"C\" void twiddleBits(unsigned char bits);\nYou can even declare C++ functions extern \"C\".\nyou’re writing a library in C++ that you’d like to provide to clients using\nyour C++ function names, your clients can use the natural and intui-\n// the following C++ function is designed for use outside\n// C++ and should not have its name mangled\nextern \"C\" void simulate(int iterations);\nmangled, and it would be a pain to precede each with extern \"C\".\nextern \"C\" can also be made to apply to\nextern \"C\" {\nCombining C++ and C in the Same Program\nThis use of extern \"C\" simplifies the maintenance of header files that\nmust be used with both C++ and C.\nWhen compiling for C++, you’ll\nwant to include extern \"C\", but when compiling for C, you won’t.\n__cplusplus is defined only for C++ compilations, you can structure\nextern \"C\" {\nmix object code from incompatible C++ compilers, there’s a good\nthat in C++, lots of code can get executed before and after main.\nopposition to the way we normally think about C++ and C programs,\nof main, and it is this special function that takes care of static initial-\ncase you won’t see any functions for them in your object files.\nportant point is this: if a C++ compiler adopts this approach to the ini-\nneither initialized nor destroyed unless main is written in C++.\nyou should try to write main in C++ if you write any part of a software\nsystem in C++.\nSometimes it would seem to make more sense to write main in C — say\nif most of a program is in C and C++ is just a support library.\ntheless, there’s a good chance the C++ library contains static objects (if\na good idea to write main in C++ if you possibly can.\nyou need to rewrite your C code, however.\nwrote in C to be realMain, then have the C++ version of main call\nextern \"C\"\n// function in C\n// write this in C++\nIf you cannot write main in C++, you’ve got a problem, because there is\nCombining C++ and C in the Same Program\nple: the C++ parts of a program use new and delete (see Item 8), and\nthe C parts of a program use malloc (and its variants) and free.\nhandy) strdup function, which, though standard in neither C nor C++,\ncalling is from a C library, it’s the latter.\nThere’s no hope of making C functions understand C++ fea-\nfunctions to routines written in C.\nhowever, so, provided your C++ and C compilers produce compatible",
      "keywords": [
        "int",
        "function",
        "concrete class",
        "abstract class",
        "functions",
        "main",
        "library",
        "extern",
        "program",
        "n’t",
        "library class",
        "abstract",
        "object files",
        "packets",
        "compilers"
      ],
      "concepts": [
        "functionality",
        "functions",
        "function",
        "classes",
        "compiler",
        "compilations",
        "packets",
        "files",
        "object",
        "calls"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 29,
          "title": "",
          "score": 0.711,
          "base_score": 0.561,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 14,
          "title": "",
          "score": 0.636,
          "base_score": 0.486,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 26,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 13,
          "title": "",
          "score": 0.528,
          "base_score": 0.378,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 15,
          "title": "",
          "score": 0.527,
          "base_score": 0.377,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "extern",
          "main",
          "drawline",
          "function",
          "program"
        ],
        "semantic": [],
        "merged": [
          "extern",
          "main",
          "drawline",
          "function",
          "program"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.36002712432020906,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971493+00:00"
      }
    },
    {
      "chapter_number": 29,
      "title": "Segment 29 (pages 293-301)",
      "start_page": 293,
      "end_page": 301,
      "summary": "If you add nonvirtual functions to the C++ version of the struct, its\ntaining only non-virtual functions should be compatible with their C\ndition of virtual functions to a class causes objects of that type to use\nbase structs (or classes) are also poor candidates for exchange with C\nvirtual member functions to the C++ version of a struct that’s other-\n■Declare functions to be used by both languages extern \"C\".\nthat compile under C; the C++ version of structs may contain non-\nThe C++ Language and Library Standard\nThe C++ Language and Library Standard\ntions, non-type arguments are now allowed in function templates,\ndition, More Effective C++ (that’s this book) contains examples of how\nthe standard library.\nthe standard library.\n■Support for the standard C library.\nthe C library into conformance with C++’s stricter type checking,\nhate) about the C library continues to be knowable and lovable (or\ndard C++ library, Mike Vilot was told, “If there isn’t a standard\ntruncheons — the standard C++ library has strings.\nThe iostream library remains part of the C++\nThe C++ Language and Library Standard\nComplex numbers, long a\nthe standard library.\nIn addition, the library contains special array\ntained within the standard C++ library is a set of class and func-\nLibrary (STL).\ndard C++ library.\ncrasies of the standard C++ library you need to know about.\nFirst, almost everything in the library is a template.\nhave referred to the standard string class, but in fact there is no such\nInstead, there is a class template called basic_string that rep-\nWhat we normally think of as the string class is really the template\nthe standard library provides a typedef:\ntemplate<class charT, \ntype, because even though string is a typedef for The Template In-\nmemory for strings is allocated, the basic_string template allows\nstandard C++ library.\nThe other thing to know about the standard library is that virtually ev-\nThe Standard Template Library\nThe biggest news in the standard C++ library is the STL, the Standard\nTemplate Library.\n(Since almost everything in the C++ library is a tem-\n— C++ libraries, so it’s important that you be familiar with its general\nIterators are pointer-like objects\nthat let you walk through STL containers just as you’d use pointers to\nSTL containers and that use iterators to help them do their work.\npointer points to the element beyond the end of the array, it can be\nThe C++ Language and Library Standard\nThis function looks for value in the range between begin and end (ex-\nturns a pointer to the first occurrence of value in the array; if none is\nwe’ll soon see, the end pointer generalizes to other types of containers\nYou could use the find function like this:\ntemplate<class T>\nthe function’s return value — see Item 19).\nThis is the concept behind STL iterators.\njects designed for use with STL containers.\nEmbracing the notion of iterators as pointer-like objects, we can re-\nThe C++ Language and Library Standard\ntemplate<class Iterator, class T>\nIterator find(Iterator begin, Iterator end, const T& value)\nYou have just written part of the Standard Template\nLibrary.\nContainers in STL include bitset, vector, list, deque, queue,\n// create STL list object\nlist<char>::iterator it = find(charList.begin(),\nlist (like all STL containers) obliges by providing the member func-\nThese member functions return the iterators you\nthe list class, like all STL containers, comes to the rescue: it provides\na typedef, iterator, that is the type of iterators into lists.\ncharList is a list of chars, the type of an iterator into such a list is\n(Each STL container class actually defines two iterator types, itera-\nFurthermore, C++ pointers are STL iterators, so the original array ex-\namples work with the STL find function, too:\n// STL find\nclasses provide functions like begin and end that return iterator ob-\nThe STL algorithm functions move\nthrough collections of objects by using iterator objects over STL collec-\nSTL iterators act like pointers.\nJust some class and function templates and a set of conventions\nown collections, algorithms, and iterators to the STL family.\nyou follow the STL conventions, the standard STL collections will work\ndard C++ library, but they’ll be built on the same principles and will be\nThere is much more to the C++ library than I’ve described here.\nthe STL.\nThe standard C++ library is far richer than the C library, and\nC++ library, you not only increase your knowledge of the ready-made",
      "keywords": [
        "STL",
        "standard library",
        "Library",
        "Standard",
        "STL iterators",
        "Standard Template Library",
        "STL containers",
        "find",
        "template",
        "STL find function",
        "Standard Template",
        "standard STL collections",
        "iterators",
        "find function",
        "end"
      ],
      "concepts": [
        "classes",
        "templates",
        "contain",
        "library",
        "libraries",
        "types",
        "pointer",
        "standard",
        "functions",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 14,
          "title": "",
          "score": 0.726,
          "base_score": 0.576,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 28,
          "title": "",
          "score": 0.711,
          "base_score": 0.561,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 12,
          "title": "",
          "score": 0.63,
          "base_score": 0.48,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 4,
          "title": "",
          "score": 0.613,
          "base_score": 0.463,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 15,
          "title": "",
          "score": 0.559,
          "base_score": 0.409,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "stl",
          "library",
          "standard",
          "iterator",
          "iterators"
        ],
        "semantic": [],
        "merged": [
          "stl",
          "library",
          "standard",
          "iterator",
          "iterators"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.38827468823904543,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971530+00:00"
      }
    },
    {
      "chapter_number": 30,
      "title": "Segment 30 (pages 302-311)",
      "start_page": 302,
      "end_page": 311,
      "summary": "recommendations for further reading on C++.\nBooks\nThere are hundreds — possibly thousands — of books on C++, and\nwhile some books are very good, some of them, well, some of them\nquestions about software development in C++.\nOther good books are\nThe Annotated C++ Reference Manual, Margaret A.\nThe Design and Evolution of C++, Bjarne Stroustrup, Addison-\ntated C++ Reference Manual is now incomplete (several language fea-\nand Evolution of C++ covers most of what’s missing in The Annotated\nC++ Reference Manual; the only thing it lacks is a discussion of the\nThese books are not\nThe C++ Programming Language (Third Edition), Bjarne Strous-\nthe standard C++ library provide a good introduction to this crucial\naspect of modern C++.\nEffective C++, Second Edition: 50 Specific Ways to Improve Your\nA book pitched at roughly the same level as my Effective C++ books,\nC++ Strategies and Tactics, Robert Murray, Addison-Wesley,\nchapter on the important topic of migrating from C development to\nC++ development.\nItem 29) is based on the ideas in C++ Strategies and Tactics.\nC++ Programming Style, Tom Cargill, Addison-Wesley, 1992, \nEach chapter in this book starts with some C++ software that has\nAnybody programming in C++ would do well to heed\n(One topic Cargill does not discuss in C++ Programming Style is excep-\nAdvanced C++: Programming Styles and Idioms, James Coplien,\nbut his focus is really on showing you how to do things in C++ you’re\nkinds of things can be done with C++.\nmay dazzle you, but when you’ve read it, you’ll never look at C++ the\nIf you have anything to do with the design and implementation of C++\nDesigning and Coding Reusable C++, Martin D.\nThe first part of the book explains C++ for FORTRAN programmers\nC++ Report, SIGS Publications, New York, NY.\nAs the name suggests, this covers both C and C++.\nThree Usenet newsgroups are devoted to C++.\nanything-goes newsgroup is comp.lang.c++.\nNamed comp.lang.c++.moderated, this newsgroup is also de-\nsigned for general discussion of C++ and related issues, but the\ninterest to most C++ practitioners.\nA more narrowly focused newsgroup is comp.std.c++, which is de-\nvoted to a discussion of the C++ standard itself.\ntions about C++ go unanswered in the references otherwise available\nAn auto_ptr Implementation\nauto_ptr template.\nBelow are two presentations of an implementation for auto_ptr.\nHowever, auto_ptr\nHere is auto_ptr with its interface documented:\nclass auto_ptr {\nexplicit auto_ptr(T *p = 0); // see Item 5 for a \n// auto_ptr\n~auto_ptr();\nauto_ptr<T>&\noperator=(auto_ptr<U>& rhs); // Item 28): assign from any\n// compatible auto_ptr \nthe auto_ptr information at this book’s WWW and FTP sites (see page 8).\nthe auto_ptr described here omits a few details present in the official version, such\nas the fact that auto_ptr is in the std namespace (see Item 35) and that its member\nAn auto_ptr Implementation\n// make all auto_ptr classes\nfriend class auto_ptr<U>;\ninline auto_ptr<T>::auto_ptr(T *p)\ninline auto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<U>& rhs)\ninline T& auto_ptr<T>::operator*() const\ninline T* auto_ptr<T>::operator->() const\ninline T* auto_ptr<T>::get() const\nAn auto_ptr Implementation\ninline T* auto_ptr<T>::release()\ninline void auto_ptr<T>::reset(T *p)\nHere is auto_ptr with all the functions defined in the class definition.\nclass auto_ptr {\nexplicit auto_ptr(T *p = 0): pointee(p) {}\nauto_ptr(auto_ptr<U>& rhs): pointee(rhs.release()) {}\n~auto_ptr() { delete pointee; }\nauto_ptr<T>& operator=(auto_ptr<U>& rhs)\nAn auto_ptr Implementation\ntemplate<class U> friend class auto_ptr<U>;\nThis won’t make auto_ptr any less functional, but it will render it\nnon-template auto_ptr copy constructor and assignment operator de-",
      "keywords": [
        "auto",
        "ptr",
        "pointee",
        "Template",
        "class auto",
        "ISBN",
        "Item",
        "book",
        "ptr Implementation",
        "Design",
        "Recommended Reading",
        "language",
        "inline auto",
        "Reading",
        "friend class auto"
      ],
      "concepts": [
        "templates",
        "design",
        "programming",
        "programs",
        "reading",
        "books",
        "specific",
        "good",
        "implementation",
        "implement"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 1,
          "title": "",
          "score": 0.894,
          "base_score": 0.744,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 3,
          "title": "",
          "score": 0.837,
          "base_score": 0.687,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 10,
          "title": "",
          "score": 0.479,
          "base_score": 0.329,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 8,
          "title": "",
          "score": 0.451,
          "base_score": 0.301,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "",
          "score": 0.441,
          "base_score": 0.291,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "auto_ptr",
          "inline",
          "auto_ptr auto_ptr",
          "inline auto_ptr",
          "books"
        ],
        "semantic": [],
        "merged": [
          "auto_ptr",
          "inline",
          "auto_ptr auto_ptr",
          "inline auto_ptr",
          "books"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3110278977378729,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971561+00:00"
      }
    },
    {
      "chapter_number": 31,
      "title": "Segment 31 (pages 312-319)",
      "start_page": 312,
      "end_page": 319,
      "summary": "This index is for everything in this book except the classes, functions,\nparticular class, function, or template I use as an example, please\nIn particular, classes, functions, and templates in the\n80-20 rule 79, 82–85, 106\nabstract classes\nand inheritance 258–270\ntransforming from concrete 266–\nobject locations 150–152\naddress-of operator —\nsee operator&\ncosts 93–98\nbool 3–4\nC++-style casts 15–16\nexplicit 29–31\nin-class using declarations 144\nmutable 89–90\nvtbls 235–251\nand default constructors 19–21\nand inheritance 17–18\ndynamic 96–98\nmemory allocation for 42–43\nmulti-dimensional 213–217\nof pointers to functions 15, 113\ninitialize 20–21\nassert, and abort 167\nassignment operators —\nsee operator=\nclasses 196\nmixed-type 260, 261, 263–265\npartial 259, 263–265\nassignment of 162–165\ncopying of 162–165\nimplementation 291–294\nfor counting objects 141–145\nbooks, recommended 285–289\nmixing with C++ 270–276\nC++\nmixing with C 270–276\nC++-style casts 12–16\napproximating 15–16\ncaching 94–95, 98\ncallback functions 74–75, 79\nC++-style 12–16\nof function pointers 15, 242\nexamination 67–68\nchange, designing for 252–270\nclasses\nbase — see base classes\nderived — see derived classes\nproxy — see proxy classes\nabstract 266–269\ncomma operator —\nsee operator,\nobject location 150–152\nand inheritance 258–270\ntransforming into abstract 266–\nconst return types 33–34, 101\nconstant pointers 55–56\nand operator new 39, 149–150\nas type conversion functions 27–\nlazy 88–90\nresource leaks 50–58\nsingle-argument 25, 27–31, 177\nused in this book 5–8\nconversion functions —\nand classes with pointers 200\nstatic type vs.\nwhen throwing an exception 62–\ncopy-on-write 190–194\ncounting object instantiations 141–\nmanagement 38–43\ninitialization when const 55–56\ninheritance 118–120\ndecrement operator —\nsee operator--\nand arrays 19–21\nrestrictions from 19–22\ndetermining when valid 152–157\nand operator= 263\nfor change 252–270\nof classes 33, 133, 186, 227, 258,\nC++ 288\ndestruction, static 273–275\nvirtual 143, 254–257\nbe deleted 152–157\nthe heap 147–157\nuse of operator[] 87, 217–\ndynamic arrays 96–98\nstatic type 5–6\ndynamic_cast 6, 37, 261–262\nand multiple inheritance 118–\nand profiling 84–85, 93\nand temporary objects 99–101\nand virtual functions 113–118\ncaching 94–95, 98\nclass statics vs.\ncost amortization 93–98\nstdio 110–112\n70, 78–80\nprefetching 96–98\nvirtual functions vs.\nlazy 85–93, 94, 98, 191, 219\nover-eager 94–98\noperators 25, 26, 49, 171,\nexception class 66, 77\nexception specifications 72–78\nand callback functions 74–75\nand templates 73–74\nand type conversions 66–67\nefficiency 63, 65, 78–80\nmandatory copying 62–63\nexplicit 28–31, 227, 294\nextern \"C\" 272–273\nfetching, lazy 87–90\nfunction call semantics 35–36\ncallback 74–75, 79\nfor type conversions 25–31\nmember — see member functions\nmember template — see mem-\nvirtual — see virtual functions\nfuture tense programming 252–258\nGUI systems 49, 74–75\nof multiple dispatch 230–251\nof RTTI 120–121\nof virtual base classes 118–120\nof virtual functions 113–118\n— see type conversion operators\nincrement operator —\nand inheritance 17–18\nand abstract classes 258–270\nand concrete classes 258–270\nand emulated vtbls 248–249\nand libraries 269–270\nand smart pointers 163, 173–179\nof arrays via placement new 20–\nof const pointer members 55–56\nof emulated vtbls 239–244, 249–\nstatic 273–275",
      "keywords": [
        "operator",
        "virtual functions",
        "functions",
        "virtual",
        "General Index",
        "classes",
        "type conversion operators",
        "pointers",
        "type",
        "operator delete",
        "objects",
        "function",
        "delete",
        "Index",
        "virtual base classes"
      ],
      "concepts": [
        "classes",
        "functions",
        "function",
        "templates",
        "object",
        "operators",
        "pointer",
        "statics",
        "virtual",
        "members"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 2,
          "title": "",
          "score": 0.778,
          "base_score": 0.628,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 33,
          "title": "",
          "score": 0.712,
          "base_score": 0.562,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "",
          "score": 0.692,
          "base_score": 0.692,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 25,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 16,
          "title": "",
          "score": 0.631,
          "base_score": 0.481,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "270",
          "98",
          "74",
          "classes",
          "258"
        ],
        "semantic": [],
        "merged": [
          "270",
          "98",
          "74",
          "classes",
          "258"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4664237128363815,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971611+00:00"
      }
    },
    {
      "chapter_number": 32,
      "title": "Segment 32 (pages 320-329)",
      "start_page": 320,
      "end_page": 329,
      "summary": "internal linkage 134\nstdio 110–112\nlazy construction 88–90\nlazy evaluation 85–93, 94, 191, 219\nlazy fetching 87–90\ninheriting from 269–270\nlimiting object instantiations 130–\nfor type conversions 175–179\nfor heap arrays 42–43\ncustomizing 38–43\nprohibiting 263–265\nC++ and C 270–276\nmulti-dimensional arrays 213–217\nmultiple dispatch 230–251\nand vptrs and vtbls 118–120\nmutable 88–90\nname mangling 271–273\nvirtual 128–129\nnull references 9–10\nobjects\nallowing exactly one 130–134\nas function return type 99\nconstruction, lazy 88–90\ncopying, and exceptions 62–63,\ncounting instantiations 141–145\ncomparisons 150–152\nheap 147–157\nlimiting the number of 130–145\nownership 162, 163–165, 183\nprohibiting from heap 157–158\nproxy — see proxy objects\nrestricting to heap 145–157\nsize, and paging behavior 98\nstatic — see static objects\nobjects\nobjects\nleaks 47–50, 161\npointers, in classes 147\nand constructors 39, 149–150\noperator void* 168–169\nin smart pointers classes 169\noperator&& 35–36, 37\noperator++ 31–34, 37, 225\noperator, 36–37\noperator-- 31–34, 37, 225\nand classes with pointers 200\nand inheritance 259–265\nassignments 260, 261, 263–\n263–265\nvirtual 259–262\nuse 87, 217–223\noperator|| 35–36, 37\nimplicit type conversion — see \ntype conversion operators\nversions 107–110\nclauses 67–68\nover-eager evaluation 94–98\nto avoid type conversions 105–\ntransferring 163–165\nexceptions 62–67\npartial assignments 259, 263–265\nplacement new 39–40\nand array initialization 20–21\nand inheritance 17–18\nas parameters — see pass-by-\ndeleted 152–157\ninitialization 10, 55–56\nnull — see null pointers\nsmart — see smart pointers\nobjects, in classes 147\nreferences 9–11\nprefetching 96–98\nprogram profiling 84–85, 93, 98,\ntense 252–258\nproxy classes 31, 87, 190, 194, 213–\ndefinition 217\nlimitations 223–227\npure virtual functions —\nbooks 285–289\nreference counting 85–87, 171,\n183–213, 286\nand read-only types 208–211\nand shareability 192–194\nautomating 194–203\nbase class for 194–197\nconstructors 187–188\nclass 203–207\noperator[] 190–194\npros and cons 211–212\nsmart pointer for 198–203\nas operator[] return type 11\nas parameters — see pass-by-\nnull 9–10\npointers 9–11\nreinterpret_cast 14–15, 37,\ninheritance 118–120\nand exceptions 45–58\ndefinition 7\npreventing via use of objects 47–\nconstructors 19–22\nand temporary objects 100–104\nconst 33–34, 101\nobjects 99\nreturn value optimization 101–104,\nRTTI 6, 261–262\nimplementation 120–121\nvirtual functions 231–232\nsemantics of function calls 35–36\nsmart pointers 47, 90, 159–182,\nand const 179–182\nand distributed systems 160–162\nand inheritance 163, 173–179\nand member templates 175–182\nassignments 162–165, 180\npointers 170–173\ncopying 162–165, 180\ndestruction 165–166\nfor reference counting 198–203\noperator* 166–167\noperator-> 166–167\ntesting for nullness 168–170, 171\nstandard C++ library 1, 4–5, 11, 48,\nsummary of features 278–279\nuse of templates 279–280\nStandard Template Library 4–5,\n95–96, 280–284\nstatic destruction 273–275\nstatic initialization 273–275\nin classes vs.\nin functions 133–\nstatic type vs.\ndynamic type 5–6\niostreams 110–112\nSTL — see Standard Template \nstring class 27, 279–280\nString class —\nstring objects, vs.\nof standard C++ library 278–279\ntype conversions 26, 28–29\nand exception specifications 73–\nin standard C++ library 279–280\ntemporary objects 34, 64, 98–101,\nand efficiency 99–101\nand function return types 100–\nand type conversions 99–100\neliminating 100, 103–104\nterminology used in this book 5–8\nparameter passing 62–67\nabstract 266–269\ntype conversion functions 25–31\ntype conversion operators 25, 26–\nvia member templates 175–179\nand exceptions 66–67\nand temporary objects 99–100\navoiding via overloading 105–107\nsuppressing 26, 28–29\noperators 25, 26–27, 49\nconstructors 27–31\nruntime 261–262\ntypes, static vs.\ndynamic 5–6\nhandling 75–77\nunnamed objects —\n— see type conversion functions\nvirtual base classes 118–120, 154\nvirtual constructors 46, 123–127\ndefinition 126\nvirtual copy constructors 126–127\nvirtual destructors 143, 254–257\nand efficiency 113–118\nimplementation 113–118\nRTTI 231–232\nfunctions 128–129\nvirtual table pointers — see vptrs\nvtbls 113–116, 117, 121, 256\nemulating 235–251",
      "keywords": [
        "operator",
        "virtual functions",
        "objects",
        "General Index",
        "pointers",
        "functions",
        "smart pointers",
        "virtual",
        "Standard Template Library",
        "type",
        "function",
        "temporary objects",
        "type conversion operators",
        "General Index operator",
        "Template"
      ],
      "concepts": [
        "classes",
        "object",
        "operator",
        "function",
        "functions",
        "pointers",
        "templates",
        "type",
        "typing",
        "virtual"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 18,
          "title": "",
          "score": 0.73,
          "base_score": 0.58,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 17,
          "title": "",
          "score": 0.714,
          "base_score": 0.564,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 31,
          "title": "",
          "score": 0.692,
          "base_score": 0.692,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 8,
          "title": "",
          "score": 0.602,
          "base_score": 0.452,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 11,
          "title": "",
          "score": 0.596,
          "base_score": 0.446,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "37",
          "type",
          "virtual",
          "279",
          "pointers"
        ],
        "semantic": [],
        "merged": [
          "37",
          "type",
          "virtual",
          "279",
          "pointers"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4630920127213315,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971651+00:00"
      }
    },
    {
      "chapter_number": 33,
      "title": "Segment 33 (pages 330-335)",
      "start_page": 330,
      "end_page": 335,
      "summary": "Functions, and Templates\nArray::ArraySize 30\nArray::Proxy 225\nPrintingStuff::Printer 132\nSmartPtr<Cassette> 175\nSmartPtr<CD> 175\nString 85, 183, 186, 187, 188,\nString::CharProxy 219, 224\nString::StringValue 186,\nTemplates\noperator= 264\nALA::processAdoption 46\nAnimal::operator= 258, 259,\noperator[] 27\nArray::ArraySize::\nArray<T>::Proxy::\noperator T 225\noperator= 225\noperator() 215\noperator[] 216\nChicken::operator= 259,\noperator T* 171\nDynArray::operator[] 97\nGameObject::collide 230,\noperator<< 128\noperator delete 154, 155\noperator new 154, 155\nKitten::processAdoption 46\nLizard::operator= 259, 260,\noperator<< 128\noperator delete 41, 153\noperator new 38, 40, 153\noperator* 102, 103, 104\noperator+ 100, 105, 106, 107,\noperator- 107, 108\noperator<< 129\noperator= 6\noperator== 27, 31, 73\noperator>> 62\nPrintingStuff::Printer::\nprocessAdoptions 46, 47, 48\nPuppy::processAdoption 46\noperator double 25\noperator+= 107\noperator-= 107\noperator* 209, 210\noperator= 209, 210\noperator-> 209, 210\nRCIPtr::CountHolder::\noperator= 194, 195, 204, 205\noperator* 199, 203, 206\noperator= 199, 202, 203, 206\noperator-> 199, 203, 206\nSmartPtr<Cassette>::\noperator\nSmartPtr<MusicProduct>\nSmartPtr<CD>::\noperator\nSmartPtr<MusicProduct>\noperator SmartPtr<U> 176\noperator void* 168\noperator!\noperator* 160, 166, 176\noperator= 160\noperator-> 160, 167, 176\nString::\n~String 188\noperator= 183, 184, 189\noperator[]\nString 183, 187, 188, 193,\nString::CharProxy::\noperator char 219, 222\noperator& 224\noperator= 219, 222, 223\nString::StringValue::\noperator<< 128\noperator-- 32\noperator++ 32, 33\noperator+= 32\noperator delete 157\noperator new 148, 157\noperator= 210\noperator WINDOW_HANDLE 49\noperator= 49",
      "keywords": [
        "operator",
        "SmartPtr",
        "Printer",
        "String",
        "Class Templates",
        "Index",
        "Templates",
        "Array",
        "Cassette",
        "operator delete",
        "MusicProduct",
        "UPNumber",
        "RCIPtr",
        "Classes",
        "Asset"
      ],
      "concepts": [
        "operator",
        "printer",
        "processadoptions",
        "session",
        "lookup",
        "string",
        "examples",
        "widget",
        "array",
        "rational"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 31,
          "title": "",
          "score": 0.712,
          "base_score": 0.562,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 25,
          "title": "",
          "score": 0.603,
          "base_score": 0.453,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 2,
          "title": "",
          "score": 0.578,
          "base_score": 0.428,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 24,
          "title": "",
          "score": 0.521,
          "base_score": 0.521,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "More Effective C++",
          "chapter": 16,
          "title": "",
          "score": 0.493,
          "base_score": 0.343,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "operator",
          "smartptr",
          "string",
          "210",
          "operator smartptr"
        ],
        "semantic": [],
        "merged": [
          "operator",
          "smartptr",
          "string",
          "210",
          "operator smartptr"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3275642743095695,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:49.971683+00:00"
      }
    }
  ],
  "total_chapters": 33,
  "enrichment_provenance": {
    "taxonomy_id": "none",
    "taxonomy_version": "none",
    "taxonomy_path": "none",
    "taxonomy_checksum": "sha256:none",
    "source_metadata_file": "More Effective C++_metadata.json",
    "enrichment_date": "2025-12-17T23:07:49.976989+00:00",
    "enrichment_method": "msep",
    "model_version": "ai-agents-msep-v1",
    "processing_time_ms": 3729.858543001683,
    "total_similar_chapters": 165
  }
}