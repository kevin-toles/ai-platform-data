{
  "metadata": {
    "title": "Game Programming Gems 1",
    "source_file": "Game Programming Gems 1_metadata.json"
  },
  "chapters": [
    {
      "chapter_number": 1,
      "title": "Segment 1 (pages 1-10)",
      "start_page": 1,
      "end_page": 10,
      "summary": "Design\nGames are made up of ewo things: dagic and data.\ndefines the core rules and algorithms of the game engine, while the dara provides che\nObviously, game data should be loaded from files, not embedded inside the code\ngives seven ideas that will revolutionize the way you make your games, of at least con-\ntial to putting data-driven design to work.\nEvery game needs a clean way to read in\nThe game should eventually be read in binary files, but the abil-\nincluding testers and game designers, can cry out new things and experiment with dif-\n[f this is done properly, the game designer,\nGame designers and producers are often at\nLf che game calls for a splic\nIn isn’t even any more work if ir’s designed right.\nthe magic of text files, you could define whether the game is single-screen, split-\nThe best part is chat your game designers\nWhen core design decisions are flexible, the game is allowed to evolve co its full\nIn fact, che process of abstracting a game co ins core helps renvendously in\nthe design.\nyou should really be building instead of che limited behavior outlined in the design\nFar example, if the game calls for only four types af WRapoits, you could progeua\nthe functionality of cach weapon, using dara oo define its behavior, you'll allow for che\nfew changes in a text file in onder to experiment with new ideas and game-play\nYour game should be able to deal with changing rules, characters,\ndesign.\nThe game will simply not live up to its full potential,\ndefining sequential steps that need co occur in a game of game evens thar need to be\nFor example, an in-game cur-scene should be scripted.\n1.0 The Magic of Data-Driven Design 5\nWhen designing a scripting language, branching instructions require some\ngame designer will have a much casier time dealing with evaluation functions chan\ndency is to make the scripting language coo powerful, The next idea explains some\nUsing scripts to data-drive behavior is a natural consequence of the data-driven\nThe problem arises when the desire to data-drive the game goes too far.\ndesigner) has the job of programming.\nWhy is it so important to keep complicated logic inside the code?\nSince scripts are not directly in the code, they\nneeded to figure our why the scripts are filing.\nThere is no doubr thar the line berween code and scripts is furry.\nidea to put artificial intelligence (AT) behavior in scripts, whereas it’s generally a good\nidea wo have a scripted trigger system for making the world interactive.\nneed to be kept simple, so they don't consume your game (and all of your program-\nHowever, some games are designed to ler players write their own AL Most com-\nmonly, these games are first-person shooters thar allow the creation of bots.\nis the goal, it’s inevitable thar the scripting language will resemble a real programming\nment of the design, resources and energy had to be put into maki ng the scripting lan-\nAbove all, remember that you dont want your game designers or scriptwriters\nprogramming the game.\nwhen they create scripting languages.\nIrs all too easy to lure game designers into pro-\ngramming the game, Ideally, programmers should be boiling down che problem and\nIts standard programming practice to never duplicate code, If you need the same\ngame has goblins thar live inside dungeons.\n1.0 The Magic of Data-Driven Design Tt\nIdea #7: Make the Tool That Makes the Data\nWith any large game, text files eventually become unruly and hard to work with.\nlevel editor, or a script editor, but you'll speed up the game development process by\nHaving a tool doesn't change dhe data-driven methodology; it\nlor, pushed data-driven design to the limit.\nAlthough the entire game was\ncentered on these two factions, they were never hard-coded into the game.\ngame shipped.\ncreated their own units with functionality thar shocked even the game's developers,\nThe data-driven design helped Toral Annihilation maintain a committed follaw-\nand Design Techniques\nIris easy to understand the popularity of C++ among game programming professian-\noffers the design benefits of an object-oriented language.\nthough, is the requirement thar C++ code be properly designed and implemented.\nprogram design, portability, and maintainability, the brutal fact of the marter is chat\npoorly designed C++ programs can he worse than poorly written © programs.\nMany books and articles give good advice on general object-oriented design prac-\nhuman and hardware constraincs wo che limit, game developers tend to be much more\nAs games grow more and more complex, companies are looking to reuse more\nwas previously known in the game development world.\ncompletely scrap your previous code with each new game.\nThis article obviously can't even begin to cover all thar a game programmer needs\nInstead, ir identifies key areas in which a game programmer, and a company,\n1.1 Object-Oriented Programming and Design Techniques 5\nfunction, and variable naming conventions as well.\nunnecesary in a type-safe language such as C++ and creates more work when chang-\ning data types (since it requires changing the variable prefix), but others appreciate the\nidentifier describing the rype of data che variable represents.\ncrally not given any prefix, with che exception of a few common classes such as those\nto look up how a variable should be named, they'll be far less likely to use che stan-\n(Class names should also be designed for ease of maintenance and readability.\nof class prefices ro indicate general design intent.\nare designated as Conerete clases, or classes with a specific use and implementation.\n1.1 Object-Oriented Programming and Design Techniques 41\nIn addition to or instead of these class prefixes, it can also be helpful to prefix\nclasses by functionality.\nClass Design\n(C++ classes offer an unlimited amount of design flexibility, which can be both a good\ning classes this way isa good idea for 4 number of reasons.\nallows you to clear the class variables at any time.\nAt times, you won't want to “activate” a class che moment it is created.\nGame programming often means programming a real-time system instead of the\nWe might want co recognize chis difference in our class designs.\ntion of the class is the Update() function.\nClass Hierarchy Design\nKnowing how to make the most of class reuse through inheritance is a key factor in\nis a single design rule chat is of such importance thar it bears brief mention.",
      "keywords": [
        "game",
        "Design",
        "Steve Rabin Games",
        "Programming",
        "Design Steve Rabin",
        "game designers",
        "code",
        "data",
        "Programming Techniques",
        "Idea",
        "che",
        "game programming",
        "thar",
        "Scripts",
        "data-driven design"
      ],
      "concepts": [
        "classes",
        "games",
        "design",
        "designated",
        "programming",
        "program",
        "code",
        "coding",
        "variables",
        "variable"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 24,
          "title": "",
          "score": 0.483,
          "base_score": 0.333,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 34,
          "title": "",
          "score": 0.483,
          "base_score": 0.333,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 10,
          "title": "",
          "score": 0.462,
          "base_score": 0.462,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 35,
          "title": "",
          "score": 0.437,
          "base_score": 0.287,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 25,
          "title": "",
          "score": 0.393,
          "base_score": 0.243,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "design",
          "game",
          "programming",
          "data driven",
          "data"
        ],
        "semantic": [],
        "merged": [
          "design",
          "game",
          "programming",
          "data driven",
          "data"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20191636132189741,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602104+00:00"
      }
    },
    {
      "chapter_number": 2,
      "title": "Segment 2 (pages 11-18)",
      "start_page": 11,
      "end_page": 18,
      "summary": "1.1 Object-Oriented Programming and Design Techniques 13\nThe singleton pattern is used when a single global object must be accessed across a\nwide number of classes and/or modules.\nSimply creating a mon-local static object\nby foreing access chreugh a class, which stores a static object internally.\nClass Singleton\nderive new classes from this one, you'll be hard pressed ta come up with as elegance an\nobject creation and deletion, though, we can expand on the basic singleton concept\nand allow extensibility to our original class:\nclass SingletonBase\nff Create @ derived Singletan-type class\nclass SingletonDerived : public SingletoaBage\nii class, even though accessing it throewgh the original method.\nThis modified form of the singleton class is not quite as simple in the construc-\nthink of using a global object or pointer to reference a single instance of a class, An\nexample might be a manager-cype class, where only a single instance (thus, the mame\nbecome singleton-type classes.\n1.1 Object-Oriented Programming and Design Techniques 15\nSo, why go vo all chis bother instead of simply creating a global object or pointer?\nFirst, if you were planning on creating global objects,\naccessing an object through 2 single function is easier than having to extern a global\nobject in all your files.\nyour object is initialized.\ngain C++ control over every access of the object, meaning that you gain benefits of\nclass is accessed.\nusing the techniques described, you can extend your base class while maintaining\ncompatibility with the existing base class.\nsuch as the following: Library A utilizes a singleton class, as described previously.\nLibrary B must use Library Ain order to function, so it is dependent on those classes\nthe application is responsible for allocating the object, we can subscinute derived Class\nD for Class A.\npointer to Class D instead of Class A, we can access all of D's new functions.\never, Class B will continue to use the old accessor function thar returns a pointer to A\nIn this way, the singleton pattern allows you co create a primitive library version-\ntaNce to automate the creation of singleton classes.\nThese classes are often designed as singletons because it usu-\nyou need only a single object to manage access to pour audio or graphical user inter-\naccess to every other class, as illustrated in Figure 1.1.1.\ninterdependencies berween classes can be described as (n-1?, where nis che number of\nClasses IN a project.\nObject-oriented programming protects\nagainst implementation changes within single classes, but a new paradigm is needed\nof problem thar object-oriented programming protects against, bur on a much larger\n1.1 Object-Oriented Programming and Design Techniques 17\ncan logically share code in their base classes, and new stares can easily be derived from\nbe enumerated and created through the use of a factory object, which is explained in\nobject, for example, you gain the flexibility of allowing new behavior to be added after\nadding an object to existing code dynamically.\nThe factory pattern deals with organization in the creation of objects.\npattern is defined as a method for allowing abstract interface classes to specify when ro\ncreate concrete, derived implementation classes.\ntory objects with enumerated object creation lecated in a cencral class, usually via a\nIn Englich, this means thar a single object is responsible for creating a wide vari-\nety of other objects, usually relarecl by a common base class, This class often tales the\nform of a class with a single method that accepts some sort of class ID and returns an\nallocated object.\n* Olten, common initialization or creation methods must be called for all objects\nwithin a class hierarchy.\n* A factory allows extensibility by allowing new objects to be derived from the\nBy passing in a new class ID (which can easily be obtained from\ndata instead of code), you can provide run-time extensibility of new classes with-\npClass = new Class;\nPClase = new Class3;\n14 Object-Oriented Programming and Design Techniques 19\nFactory patterns are used whenever large numbers of different objects within an\nobject hierarchy must be dynamically created at run time.",
      "keywords": [
        "object",
        "classes",
        "singleton",
        "Pattern",
        "Object-Oriented Programming",
        "singleton pattern",
        "Programming",
        "Design Techniques",
        "Programming Techniques",
        "Techniques",
        "code",
        "access",
        "singleton class",
        "single",
        "states"
      ],
      "concepts": [
        "object",
        "classes",
        "singleton",
        "state",
        "accessed",
        "access",
        "creating",
        "create",
        "code",
        "coding"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 8,
          "title": "",
          "score": 0.487,
          "base_score": 0.337,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 9,
          "title": "",
          "score": 0.419,
          "base_score": 0.269,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 5,
          "title": "",
          "score": 0.414,
          "base_score": 0.264,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 10,
          "title": "",
          "score": 0.383,
          "base_score": 0.233,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 13,
          "title": "",
          "score": 0.37,
          "base_score": 0.22,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "class",
          "object",
          "singleton",
          "classes",
          "oriented"
        ],
        "semantic": [],
        "merged": [
          "class",
          "object",
          "singleton",
          "classes",
          "oriented"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.12673229491928834,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602194+00:00"
      }
    },
    {
      "chapter_number": 3,
      "title": "Segment 3 (pages 19-28)",
      "start_page": 19,
      "end_page": 28,
      "summary": "templates unsigned N > struct Fib\ntemplate <> struct Fibs 0 > { enum { Val =\ntemplate <> struct Fibt i» { enum { Val =\nfi Make tha template appear like a funotion\nAn example “call” co the template via the define:\n* ‘The template function is not really a function ar all—ir's an enumerated integer\ncalled Val, recursively determined at compile time.\n* ‘The template parameter WW is used to specify che function input.\nmon but perfectly acceptable use of template parameters.\nseten> uses the numeric value Wi as its template parameter to define the number of\nThis numeric parameter must be known at compile time.\nSince all inputs are known at compile time, a compiler can reduce FibT(N) ta a\nfrom eponential rr time to constant run tine, With template metaprogramming, the\ngames, execution time is usually more critical than compile time, so this technique is\nAnd the template metaprogram version:\nfl Templatized tactorial(n)\ntemplate= unsigned NW > struct Fact\nTemplate <= struct Fact< 1 >\n// Make the template appear like a function\nTemplate metaprogramming is compelling and\n12 Fast Math Using Template Motaprogramming 23\nrequired input parameters at compile time.\nthe compiler read something like x = sie(].234) and generate a single move insmruc-\nTemplate metaprogramming to the rescue!\ndifficult to convert this to a templatized version.\n1.2.1, The solution uses two template objects: Sine<A> computes A * term(G) and\nWith the template metaprogramming version:\nthe compiler can theoretically generate the same code as though we had written:\nThe actual value of stm('J.234) is 0.94381820937463370..., so the template ver-\ntime) by using the compiler as the workhorse.\nrun time or embed a table in our executable, because the compiler can pemerate the\ntable entries we need (and oaly the ones we need) ar compile time,\n‘There's potentially a big problem with template metaprogramming.\nMany compilers\nShen a compiler do that?\ndid job with the Fab and factorial templates, producing single move instructions for\nIt had more difficulty on the sine template, generating code thar is inferior even\nExamine the code produced by the compiler, and evaluate che performance before\ncompiler flags to ger the results you want.\nfocus more heavily on template optimization and templace metaprogramming itself\n1.2 Fast Math Using Template Motaprogramming 25\nas well as a compiler ssandpoint.\nThe special #pragnas are no longer required for the compiler to generate a constant.\nTemplates and Standard C++\nNot many compilers are completely compliant with the C++ standard, especially\nTemplates are so flexible and powerful, compiler wrirers\nC++, which was slow to adopt templates in the first place and slower still to conform\ntemplate parameters.\nThe sine template functions in Listing 1.2.1 and Listing 1.2.2\nuse a floating-point template parameter for the incoming radian value.\naccording to the (l++ standard, “a non-type template-parameter shall not be declared\ntemplates double A » struct Sine // compiler errer\ntemplates dowble& R > struct Sine |/ Ox\nTo use the sine template code on conforming compilers, change\nWhere template metaprogramming really comes into its own is the handling of\nmatrix operations.\nThree-dimensional games heavily use matrices, Templatizing key\nuse templates to improve initializing, transposing, and multiplying matrices.\nThe template metaprogram version is shown in Listing 1.2.3.\nthe template version include the manrix utx, the size of the matrix N (a square matrix\nThe template specialization terminates the algorithm when 1 reaches N\nThe compiler can expand che new version to:\nhave unrolled che loop ourselves, but the template version is a general solution, It will\n1.2 Fast Math Using Template Metaprogramming 2?\nmtx[ C IL R ] = static _cast< F =( Init }; s/ init matrix\nwhere F is the cype of value stored in each element and Init is 2 numeric template\nwhich the compiler will expand to:\neal non-templatized implementation looks like his:\nThe comesponding template metaprogram version is shown in Listing 1.2.5.\nMatrix multiplication has an inner loop chat becomes the additional template para-\nWe initialize the resulting matrix to be empty (zeroed) so that the += operator in\nThe multiplication template is a general solution for any square matrix.\nHow efficient are the templatized matrix operations?\nindicates whether or not the compiler was able to unrell che recursion.\nWith the exception of multiplying 4% 4 macrices, the templatized versions were\nto completely unroll the template recursion.\nTable 1.2.1 Matrix Operation Test Results\nNon-Templatized Templatized\nmatrix33-:identity 45,827 79,526 Completely\n(4° operations), the compiler only partially unrolled che recursion, and the overhead\nTemplates can be a highly elective way of generating algorithms directly in the in-",
      "keywords": [
        "Template",
        "compiler",
        "Val",
        "template metaprogramming",
        "matrix",
        "time",
        "compile time",
        "sine template",
        "Fib",
        "template parameter",
        "sine",
        "Fast Math",
        "version",
        "template metaprogram version",
        "sine template functions"
      ],
      "concepts": [
        "template",
        "matrix",
        "compile",
        "compiler",
        "function",
        "functions",
        "sine",
        "time",
        "col",
        "operations"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 4,
          "title": "",
          "score": 0.757,
          "base_score": 0.607,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 7,
          "title": "",
          "score": 0.653,
          "base_score": 0.503,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 5,
          "title": "",
          "score": 0.597,
          "base_score": 0.447,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 8,
          "title": "",
          "score": 0.574,
          "base_score": 0.424,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 9,
          "title": "",
          "score": 0.565,
          "base_score": 0.415,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "template",
          "compiler",
          "metaprogramming",
          "templates",
          "version"
        ],
        "semantic": [],
        "merged": [
          "template",
          "compiler",
          "metaprogramming",
          "templates",
          "version"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2560966787538764,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602244+00:00"
      }
    },
    {
      "chapter_number": 4,
      "title": "Segment 4 (pages 29-38)",
      "start_page": 29,
      "end_page": 38,
      "summary": "The notation for template metaprogramming is\ntemplates.\ntemplate= dowble A > struct Sine\nTemplate <= struct Series 0.60, Oo, oO >\nStatic inline double yval() { return 1.0; }\nii Make the template appear like a function\nStatic inline double sin(}\nff Make the template appear like a fumetion\nTemplate= class tx, unsigned N > struct IdMtx\nstatic inline void eval WtxA mtx i\nstatic inline void eval Mtx& mtx )\nStatic inline vold eval matrix44& } i}\nf/ Make the template appear like a function\nff Templatized transpose; W is matrix size\ntemplate Glass Ute, unsigned N > struct Transltx\nStatic inline woid eval{ Mtxh mtx }\ntemplates class Mix, unsigned N, unsigned ¢, UAisigned A,\nStatic inline void eval{ Mtx& atx }\ntemplate<> struct TransMtxInpl< matrixd, 3, 0, 1, 3*3 =\ntemplate<> struct TransMtxInpl< matrixdd, 4, 0, 1, 4°4 >\nif] Templatized multiplication; N is matrix size\ntemplate: class Mtx, uneigned N > struct Multittx\nStatic inline void eval( Mtxk r, const Mtxh a, const Mtxi b )\ntemplate< class tx, unsigned W, unsigned G, unsigned fi,\nstatic inline woid eval( Wtwk r, const Mtxk a, const Mtx& b }\ntemplate<* struct MultWtxIapl< natrixdd, 4, 0, 0, 0, 4*4*4 >\nff Make the template appaar like a function\nbra with C++ Template Metaprograms,” Dr Dobbs Journal, August 1596,\n[Veldhuizen95) Veldhuizen, Todd, “Using C++ Template Metaprograms,” C++ Report,\nAn Automatic Singleton Utility\nA singleton is an object that has only one instance in a system atany time.\nmon examples of singletons in games are managers for rexture maps, files, or che user\nThese types of subsystems are noc singletons in char they don't have their functional-\nclass and used as a singleton, but this practice isn't common.\nAn example of a singleton is a fectere map manager.\nsystem, 50 this class would naturally be used as a singleton.\nWhiar's che poinc of singletons?\nCalling a class a singleton and following a naming convention (such\nSingletons also provide notational convenience.\n13 An Automatic Singleton Utility a7\nSingletons can solve this problem because they are\nhave the convenience advantage of treating a singleton like a global object, withour\nThe textbook solution to managing a singleton usually looks something like this:\nstatic T $_Singleton:\nreturn ( 3_Singleton }:\nAll we're really after ts che ability te crack a singleton, and for chat whar we need is a\nStatic TextureMgr™ mg_Singleton;\nTextureligr( void ) { ms_Singleton = this; /*...\"/ J\nTextureligré GetGingleton( void ) { return { ‘ms Singleton }; 4\nlittle inconvenient, given that the same code (to track the singleton pointer) needs to\nbe added to every singleton class.\ntenplate <typename T> class Singleton\nStatic T* ns_Singleton;\nSingleton( void }\nms Singleton = (T*){{int}this + offset);\n{ assert{ ms_Singleton }; as_Singleton = 0; }\n{ s8eert( me_Singleton }; return [ *na_Singletan j: }\n{ return { m&_Singleton }; }\n‘To convert any class into a singleton, you only need to do these three easy steps:\nPublicly derive your class wyGlass from Singleton <MyClass>,\nand treat it exactly like a global object for notational convenience.\nclase Textureligr : public Singleton <TextureMgr>\nThe Singleton class's only purpose in life is to automatically register and unregis-\nderiving MyClass from Singleton <wyCless> purely to inherit this convenient func-\nAll che important work is done in che Singleton con-\nderiving from more than just the Singleton, in which case “this” from MyClass might\nbe different from the Singleton “this.” The solution is to take a nonexistent object sit-\nference will effectively be che distance berween Singleton <MyClass> and its derived\ntype MyClass, which it can use co calculate che singleton pointer.",
      "keywords": [
        "Singleton",
        "static inline void",
        "Static inline",
        "Template",
        "Template Metaprogramming",
        "inline void",
        "inline void eval",
        "Static",
        "inline",
        "struct",
        "Automatic Singleton Utility",
        "Static inline double",
        "void",
        "unsigned",
        "mtx"
      ],
      "concepts": [
        "template",
        "singleton",
        "object",
        "static",
        "functions",
        "function",
        "functional",
        "matrix",
        "calls",
        "unsigned"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 3,
          "title": "",
          "score": 0.757,
          "base_score": 0.607,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "",
          "score": 0.544,
          "base_score": 0.394,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 5,
          "title": "",
          "score": 0.525,
          "base_score": 0.375,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 7,
          "title": "",
          "score": 0.522,
          "base_score": 0.372,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 11,
          "title": "",
          "score": 0.517,
          "base_score": 0.367,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "singleton",
          "inline",
          "template",
          "static inline",
          "static"
        ],
        "semantic": [],
        "merged": [
          "singleton",
          "inline",
          "template",
          "static inline",
          "static"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23056485669255955,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602291+00:00"
      }
    },
    {
      "chapter_number": 5,
      "title": "Segment 5 (pages 39-47)",
      "start_page": 39,
      "end_page": 47,
      "summary": "The STL is a collection of container foollec-\nbasic containers, the STL provides a massive assortment of algorithms thar can oper-\nate on those basic containers.\ninstance, vectors do ne bounds cheeking, and iterators are never validated before\nattempting to access a container.\nThe net result is thar, for example, STL vectors can\nThe STL is a large and somewhat complex portion of the Standard C++ library.\nContainers\nSTL containers represent the classic data abstractions and organization schemes such\nbetween certain types of containers and how they are implemented.\nThe $TL containers’ vector, list, and deque (pronounced “deck”) are implicte dara\nmanner that allows amortized constant time insertion or deletion of elements ar either\nend of a randomly accessible array-type structure, Deques are also known as sequence\nvector, list, or deque inrernally.\nContainer\nThese are also known as astoctativr containers because the dara inserted inta\nSterators can be thought of as pointers to elemencs in the containers, and indeed the\nSTL even uses pointer notation for traversal and aceess to container data.\ninstance, the ++ operater moves the iterator to the mexe clement in a container, much\npointers, the actual data can be accessed by dereferencing che iterator using the *\ncome in the form of member functions of che container classes.\nSince each container has simi-\nyeu heed to perform most basic operarions on your containers,\nunderstand the methods used to determine ranges when working with a container,\nTeo methods common to all containers begin() and and(), rerurn the full range of\nthe container.\ncontainer, but end() returns the position depond ote dave nalie element.\nSecond, iterating through containers has\nWhen you use functions specifying a range, functions in STL usually take as\nend element.\ncontainers pass Information by value, not by reference.\nwith small dara types, ir is acceptable co allow the container to make a copy of the\nContainer\nVectors behave alrost identically to standard C arrays, with one major excepuion:\nVectors are implemented as arrays that periodically need to reallocate memory\nFirst, a vector\nSecond, adding an element to che end of a\namount of resources as they allocate new memory, copy the existing array inte this\ndoing so invalidates any iterators currently pointing to elements in the vector.\nexamine the functions to help more precisely manage a vector’s internal memory, alter\nif Typedeft tha container and iterator names for better\nif Fill the vector with 3 different elements\nfor(InmtVactItor itor = c.begin(}; iter |= e-end({)j +-itor)\nSTL containers.\nportions of the C++ library, che STL is part of the eta namespace and so roquires you\nNexr, we sce typedets for the type of container and iterator we want te use in the\nThe next section of code creares the vector container object v and proceeds to call\na vector-only function char reserves 10 integers’ worth of memory.\nto push_back() 3 integers onto the back of the vector.\nclement is inserted into the array, a memory allocation will rake place and all current\nthat can be allocated for a single vector, use the sax_size() function,\ncommon to all basic ordered containers (vector, list, and deque).\nobviously add and remove elements ftom the frome and back of the container.\nthe implementation of a vector, you want to aveid push front() or pop_front() on\ncomponents of STL usage: the iteration loop.\nWe use a for loop with an iterator\nEvery container with an accesible\nSince the iterator is the only item keeping track of che current position in the vec-\nwith the notion of a pointer, we simply dereference the iterator to access the data.\nAfter the standard iteration loop, we see an example of a vector in use like a nypi-\nmented as a doubly linked list, so any insertion and deletion of elements is done in\nOne beaury of using STL containers is the consistent naming conventions and\ntype of container, you csentially know how to use them all.\nUsing a list is even simpler than using a vector.\nIterating through the list\nff Create a list container of integers\nWe see in this example the same basic type of container manipulation, bur we\nSTL containers do not operate on the data you pass into chem.\nlarge data structures in memory, you'll want to pass pointers to larger, dynamically\nthe container has no idea what eype of data might be used, there is no way for the con-\nTake the list's sort {) function, for example.\ndesigned for class Foa, the list still sorts on the actual value of che pointer, mor by the\nWhen copying containers, remember that\nand algorithms that copy elemencs from container to container.\nYou should ako be wary of removing an element from a list while iterating\nreturn value, which retrieves the next valid position in the container, By assigning this\nIt is often preferable to use algorithms to crase elements from a container instead\nremoving elements from either end of the container must be performed, bur inserting\nand removing elements from the middle of the container is not required (or doesn't\nfront and back of the container in amortized constant time, and inserting or deleting\nif Typedef the container and iterator names for better\nWe see in the preceding listing the familiar code of STL usage, but with a few\nof a container (illustrated in Figure 1.4.1), we cant simply iterate backward and\nwould leave the first element in a container out of che iteration loop.\nfront or back of a container, respectively, Note thar the value of the clement is not\nthe front or back element in the container.",
      "keywords": [
        "STL",
        "STL containers",
        "container",
        "vector",
        "back",
        "STL containers pass",
        "iterator",
        "elements",
        "memory",
        "che",
        "list",
        "data",
        "STL containers represent",
        "functions",
        "element"
      ],
      "concepts": [
        "container",
        "iterating",
        "iteration",
        "iterations",
        "iterate",
        "elements",
        "element",
        "vectors",
        "functions",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 11,
          "title": "",
          "score": 0.643,
          "base_score": 0.493,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 6,
          "title": "",
          "score": 0.605,
          "base_score": 0.455,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 3,
          "title": "",
          "score": 0.597,
          "base_score": 0.447,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 9,
          "title": "",
          "score": 0.548,
          "base_score": 0.398,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 8,
          "title": "",
          "score": 0.543,
          "base_score": 0.393,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "container",
          "containers",
          "stl",
          "iterator",
          "vector"
        ],
        "semantic": [],
        "merged": [
          "container",
          "containers",
          "stl",
          "iterator",
          "vector"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.25441361810587776,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602338+00:00"
      }
    },
    {
      "chapter_number": 6,
      "title": "Segment 6 (pages 48-55)",
      "start_page": 48,
      "end_page": 55,
      "summary": "allows you to easily use che other container types, so we leave char research up to you,\npaired as a key/value structure and inserted into the container.\nLooking up che value\nff This Tunetion abject allows us to compare map containers\nI! Insert key / value pairs\n{/ display all the keys and values\nTor(isMaplter iter = c.begin(}; iter != ¢.end(); +41tor}\nfirst << \", Value = *\nSout << “Key 3 displays value * << c[S].costr() << endl;\nif Find and remove a specific element based on tha key\nff Find and remove an element based on the value\nPos = find_iffe.bepin(), c.endi), value equals\nwhich represents the key/data pair representing every element im the container.\nInserting combined key/data values uses the insert() function like any other\ncontainer, with the only difference being that you must insert type nap::value type.\nThe map sorts every entry as it is inserted, so at any given time the container is always\nWe can see this as we iterate through the map and display all the keys\nAccessing first gives you the key value; accessing\nIn addition to access through iterators, maps also provide ranclom access via their\nkey values, The map acts like an associative (or sparse) array.\nthe element is created with a default constructor and ts inserted into the map.\non, we see 2 simple method of finding an element based on the key using\nthe find() function.\nSince che keys are sorted, this function performs in O(log 1)\nIf we want to find am clement based on the value, we must do a bit more work.\nbest, this work will be performed in linear time, since the data is sorted on the key\nfunction requires three parameters: an iterator telling where to begin, am ieraror\nvalue.\nThe iterators are self-explanatory, but the function abject, or functor, requires\nIn STL, classes with overloaded function operators (did you even know you could\ndo char?) are used in place of functions.\nThe function object pro-\nvided in this example simply compares the second value in a walue_pair and returns\ncomprehensive STL book for a listing of different algorithms and function objects\na container, but if you must iterate chrough and remove elements manually ina map,\nRemoving elements while iterating\nSTL neglected to have the erase() function return the value of the next valid posi-\nsimple method of removing elements, as shown in our second code snippet.\nthan if the designers had just sacrificed a bit of speed in the erase() function, With\n“Why do you always use the pre-increment operator in your iteration loop?”\nold value, so ir might require the use af a temporary object.\nThe STL stack class provides thie primary members—pusht{ }, pop, }, and top¢}—for\nadding and removing elements from the container, These member functions respec-\nif container type.\ni! container type.\ncontainer that supports these functions can be used as the underlying implementation\nfor the stack class, Notice that in the second line of code in the preceding example, we\nIt is important to alsa lenow that the stack class, like many STL containers,\nThe quewe class works much like the stack class except that elements are pushed onto\nLike the stack class, the queue also defines size(} and empty) to manage the\nAs with the stack class, you can specify a container other than the default deque\nBecause of the sorting functionality, an addirional\noperator with your own function.\nare inserting pointers to objects instead of passing in che objects by value.\nsorting the queue based on the value of che pointers requires writing a functor class\nA Generic Function-Binding\nThis article provides a method for exporting functions and\nThe basic requirement for our scripting engine is that we can call a function and pos-\nean call a function on a remote machine and possibly pass it parameters.\ncant pass function pointers over the network and must instead convert them into a\nafter resolving to a function pointer:\nneeds is a table thar maps exported function names to memory addresses, Finally, you\nFUNCTION_FoO,\nFUNCTION BAR,\nftruot Function",
      "keywords": [
        "function",
        "STL",
        "container",
        "key",
        "stack",
        "stack class",
        "element",
        "che",
        "STL stack class",
        "elements",
        "map",
        "Programming",
        "code",
        "Programming Techniques elements",
        "Programming Techniques"
      ],
      "concepts": [
        "function",
        "functions",
        "functionality",
        "value",
        "iteration",
        "iterating",
        "iterate",
        "map",
        "work",
        "elements"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 5,
          "title": "",
          "score": 0.605,
          "base_score": 0.455,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 3,
          "title": "",
          "score": 0.521,
          "base_score": 0.371,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "",
          "score": 0.515,
          "base_score": 0.365,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 13,
          "title": "",
          "score": 0.494,
          "base_score": 0.344,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 8,
          "title": "",
          "score": 0.466,
          "base_score": 0.316,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "container",
          "stack class",
          "key",
          "function",
          "stack"
        ],
        "semantic": [],
        "merged": [
          "container",
          "stack class",
          "key",
          "function",
          "stack"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18108130796533223,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602383+00:00"
      }
    },
    {
      "chapter_number": 7,
      "title": "Segment 7 (pages 56-64)",
      "start_page": 56,
      "end_page": 64,
      "summary": "Finally, the g_Functions array is the set of all published functions in the\nOur example function exports are, of course, Foo and Bar.\nits compiling a script to resolve function calls by name and then call che procedure\nOur imaginary network-messaging system could convert function calls into\nfunctions must be the same—they must all take ne parameters and return veid.\ntheir real types to the common types required by Function::Proc.\n1.4 A Generic Function-Binding Interface\nstruct Function\naFunction m_Function;\nFunction g_Funetions|] =\nadd/extract functions, The C++ compiler cannot check the types at compile time\ntypes from the called function cach time an Extract method is called.\nCalling functions in this way is also tedious and inefficient.\nA simple function can no longer be added vo an export\nreally looking for here is a function specification table that gives us everything we\nters), jump directly co the function for the call, and then retrieve the return value co\nPor this task, we need to know the function's name,\nstruct Function\n/} the global cet of specifications for exported functions\nFunctionVec g Functions;\n14 A Generic Function-Binding Interface 61\nwe use this information to actually call functions?\nwork, On Visual C++ for x86 Win32, all function calls have certain things in com-\nrequired for variable argument functions because the called function doesn't nec-\nThis is the default calling convention for static and giobal functions in € and\nThe called function cleans up the stack.\nNow we have enough information to do generic function calls with these ovo\nWe also need a function to retrieve a floating-point value from the FFUs\nfunctions that do the dirty work:\ncall [fine] ff call thea function\ncall [func] ff call tha function\nNow, given a function's address and some parameters stored in a memory buffer,\nwe can calla function in an almost completehy generic way.\nCalling the Function\ntion structure within g Funetions that corresponds to che function it will be calling.\nFor the scripting engine, we want to verify that the function's specification matches\nLook in g Functions for the Function instance\nff FindFunction() should look in g Functions for highest “a_Proc'\nThe next step is to construct the parameter buffer ro pass to che function.\nNow thar we have the Function instance and our parameter buffer, we call either\nThar’ all there is co calling a function generically!\nUntil now we've been assuming that the g_Functions array has already been set up.\nof a function to set it up:\nFunction function;\nfunction .m_Name = \"Foo\"}\nfunction.m Prac = Fes\nfunction.\nAeturnType = Function.\nfunction.\nfunction.n_ParasTypes .\npush _back( Function, eVarType:-VAR_STAIMG };\nfunction.\nmGallType = Function.\n@ Functions.push_back( function );\nFunction tunction;\nfunction mi_Proc = Bar;\nfunction.m SarisilIp = g Functions.size();\nfunction.m_Calltype = Function.eCallType: iCALL_CDEGL;\ng Functions.push back function };\nsome helper functions and macros to make it easier to add new functions to the table.\nAdding a new function te the table\n1.4 A Generic Function-Binding Interface 65\n(Changing a function (adding 2 parameter, for example) without updating\nrequired to eenstruct a function specification!\nfunctions are for export and which aren't.\nuse that to build the Function encry co add to g Functions.\nexported a name-unmangling function called UnDecorateSymbolNane() fram borh\nand convert to a Function entry for addition to our 9 Funetions table.\nSo now our procedure for building g Functions is:\n1. Tterare over all entries in the EXE's export table, and retrieve cach function's\n3. Parse che function protorype en retrieve name, type, and calling comvencion infor-\n4. Store the results in a new entry within g Functions.\nIterating over the exports to get the function addresses and mangled names\ninterested in is binding to functions and calling them generically.\nneed to be able to do a reverse lookup and convert eip from within the called function\nto find its Function instance (required for RPCs, as described eatlier), you need vo get\nbyte offset to the actual entry point of your function.\nfor reverse lookup to find the Function instance from within g_Funetions.\nWe now have everything we need co call functions in a completely generic way.\nfunction-binding publisher iterates over the Win32 export table and extracts name,\nlool up functions by memory address, name, or serial ID and call them generically\nwork is done, adding new functions co the system is as simple as tagging them for\narguinent functions, and passing more than just strings over a network.\nIn addition, support for calling class member functions is a",
      "keywords": [
        "Function",
        "functions",
        "function calls",
        "call",
        "parameters",
        "stack",
        "generic function calls",
        "che Function",
        "Function instance",
        "call functions",
        "function specification",
        "Programming Techniques",
        "calling conventions",
        "Bar",
        "Foo"
      ],
      "concepts": [
        "functions",
        "function",
        "parameters",
        "calls",
        "void",
        "work",
        "network",
        "exports",
        "types",
        "stack"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 3,
          "title": "",
          "score": 0.653,
          "base_score": 0.503,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 4,
          "title": "",
          "score": 0.522,
          "base_score": 0.372,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 13,
          "title": "",
          "score": 0.521,
          "base_score": 0.371,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 8,
          "title": "",
          "score": 0.52,
          "base_score": 0.37,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 5,
          "title": "",
          "score": 0.513,
          "base_score": 0.363,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "function",
          "functions",
          "calling",
          "function function",
          "function instance"
        ],
        "semantic": [],
        "merged": [
          "function",
          "functions",
          "calling",
          "function function",
          "function instance"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18585487765551617,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602428+00:00"
      }
    },
    {
      "chapter_number": 8,
      "title": "Segment 8 (pages 65-77)",
      "start_page": 65,
      "end_page": 77,
      "summary": "A Generic Handle-Based\n1.6 A Generic Handle-Based Resource Manager 69\ngeneric, and efficient way to manage controlled resource objects.\ntion and use handles instead, putting the burden on the manager class.\nHandles are an\nAn example of a handle is the HANDLE type returned by the GreateFile: ) call\nA file handle, representing an open file system object, is cre-\nAttempting to call those functions with an invalid or dosed handle does not cause a\nchange withour invalidating any outstanding handles.\nover passing around pointers, Handles can also be easily saved to disk, because the\nThis facility allews che handles ta be stored directly, with no conversions Necessary,\nThe Handle Class\nA fast and safe way to represent handles is to use an unsigned integer composed of pwo\n(=_EIndex) is 2 unique identifier for fase dereferencing inte the handle manager's data-\nbase, The handle manager can use this number however it likes, bu perhaps the most\n(= Magic) is a “magic number” that can be used to validate the handle.\nencing, the handle manager can check to make sure that the magic number compo-\nnent of the handle matches up with its corresponding entry in the database.\nThe Handle class is very simple and really doesnt do much except manage the\nUpen calling Init(), the handle is given the next magic number,\nThe magic number of zero is reserved for the “null handle\" where che handle’s data is\nzero, The default Handle constructor secs itself to null, a stare that returns true on an\nates an object and retums a handle to it can simply return a null handle co indicate\nIn most ways, the Handle class acts as a read-only unsigned inceger.\nMorice that Handle is a parameterized class, raking a TAG rype co fully\ntypes of handles; an object of type TAG is never used anywhere in the system.\none type of resource could be passed to a function expecting a handle to a different\ncreate a new handle type, taking any unique symbol and using it for the parameter.\nThe TAS type can really be anything so long as ic is unique across Handle types, but it’s\nconvenient co define an empty struct and use thar in the typedef for a handle, like this\ntexture handle example:\ntypedef Handle <tagTexture> HTexture;\nNow we need a handle manager thar is responsible for acquiring, dereferencing,\nand releasing objeces (via handles) for a higher-level owner.\n1.6 A Generic Handle-Based Resource Manager Fi |\nexample, in a Handlevigr thar manages files, che DATA type would probably have only\nthe file handle and the name of the file:\nThis simple handle manager maintains a set of context objects that correspond ta\nthar handles the abstraction and knows about the problem domain (thar is, what DATA\nFor our Hendletige class, cach handle references cxactly one elemenc within the\nthe handles to ger at the actual FileEntry object is as simple as using the m_Index\ncomponent of the handle as an index into the object store (a very fast operation).\nWhen dereferencing the handle, the code also checks the m_ Magic component\nagainst the same index in the magic number store to make sure the handle is valid.\nhandles are freed and reacquired, corresponding entries in the magic number store are\nupdated with the new handle magic numbers.\n“dangling” handles on released objects won't refer to unexpected objects when the\nslors are Filled by a later handle acquisition bur instead simply fail to work and return\nAs objects are released, the handle manager adds the indices of the slots they\ncreating and destroying the objects with new and delete for each handle acquisition\nThe amount of handle validation necessary could depend on the application and\nexample, the rest for an invalid handle might be found unnecessary and could be\ntem in which error handling is important, the cade could, upon detecting an invalid\nhandle, set an error condition and chen abort the function call.\nListing 1.6.3 provides a sample texture manager class.\n1.6 A Generic Handle-Based Resource Manager 73\nFor another (larger) sample of file handle usage, see the sample code for my GDC\nMany databases, such as a font manager or texture manager, likely require indexes\nto acoess objects by name co retrieve handles.\nTake the singleton patcern a litle further and make the Tag type of Handle actu-\nThen the Handle\nThe handles can be saved our directly; just make sure\nand on restore, all handles will remain valid.\nclass Handle\nunsigned m_Index : MAX_BITS_INDES; // index inte resource\nunsigned int m_Handle;\nHandlo( void ) : m_Handle; o) { }\nunsigned int GatWagic ({ void ] const { return ( -m Magic 4}; }\nunsigned int GetHandle{ void ) const { return {| m_Handle }; }\nbood [sNull 8 { void ) const { return ( Im Handle }; }\noperator unsigned int { void } const { return { mHandle }; }\nvoid Handle <TAGe 3: Imit( unsigned int index }\ns AutoNagic = 1; ff 0 is used for “null handle\"\ninline bool operator i= ( Handle <TAG 1, Handle <TAG> r )\ninline bool operator == [ Handle <TAG= 1, Handle <TAg> r j\ntemplate <typaname DATA, typaname HANDLE>\ni/ Handle methods.\nHANDLER handle }+\nWold Release( HANDLE handle };\nDATA Dereference( HANDLE handle }:\nconst OATA\" Dereference HAWDLE handle } const:\ntemplate “typename DATA, typename HANDLE=\nDATA\" Handleligr <DATA, HANDLE> :: Acquire, HANOLES handle ]\nhandle.\nn_Wagichunbers.push_back{ handle.GetWagic,) };\nhandle.\nm_Magichiabers[ index ] = handle.GetMagic(}:\nvoid Haridletgr <DATA, HANDLE» :: Release HANDLE handle }\nungkigned int index = handle GetIndgex();\ntenplate <typaname DATA, typenene HANDLE>\n:: Dereference( HANDLE handle }\nif { handle.Tshull() ) return ¢ oO 413\nif it you can assume all handle references are always valid.\nunsigned int index = handle.GetIndex();\n|| ¢ m_Magichenbers[ index ] I= handle.GetWagic() } }\ninvalid handle == client programming error\ntemplate <typiname: DATA, Typenem HANDLE>\n1.6 A Generic Handle-Based Resource Manager TT\ninline const DATA* Handleligr <DATA, HANDLE>\n=> Derefterence, HANDLE handle } const\n[ platform-specific surface handle type hare |\ntypadat Handle <tagTexture> HTexture;\nHandlaVec m_Handles; If handles te mip surfaces\nassert({ mip =< m_Handles.sizal) };\n{ return { @Textures.Dereference( htex j->m@ Width }; 3\n1.6 A Generic Handle-Based Resource Manager Ta\nm_Handles clear);",
      "keywords": [
        "handle",
        "data",
        "Resource Manager",
        "handle manager",
        "handle manager data",
        "magic number",
        "index",
        "Generic Function-Binding Interface",
        "Manager",
        "Handle-Based Resource Manager",
        "Generic Handle-Based Resource",
        "Magic",
        "unsigned int",
        "Magic number store",
        "object"
      ],
      "concepts": [
        "handle",
        "handling",
        "data",
        "objects",
        "returns",
        "classes",
        "index",
        "indexes",
        "manager",
        "manage"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 9,
          "title": "",
          "score": 0.78,
          "base_score": 0.63,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 13,
          "title": "",
          "score": 0.595,
          "base_score": 0.445,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 3,
          "title": "",
          "score": 0.574,
          "base_score": 0.424,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 5,
          "title": "",
          "score": 0.543,
          "base_score": 0.393,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 7,
          "title": "",
          "score": 0.52,
          "base_score": 0.37,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "handle",
          "handles",
          "manager",
          "magic",
          "resource"
        ],
        "semantic": [],
        "merged": [
          "handle",
          "handles",
          "manager",
          "magic",
          "resource"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20437110886015983,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602474+00:00"
      }
    },
    {
      "chapter_number": 9,
      "title": "Segment 9 (pages 78-85)",
      "start_page": 78,
      "end_page": 85,
      "summary": "Resource and Memory\nIn this article we examine the workings of a simple resource manager and\n‘Our solution entails creating resource objects that are able to automatically load,\nte coordinate the available resources and control access wo the resource objects.\nThe Resource Class\nTo begin with, let's examine the base resource class:\n1.7 Resource and Memory Management a1\nff operator determines in what ordar resources ara\nfi The less-than operator defines how resources get\nThe Basefesource class acts as a template from which other resource container\nresource data from disk or even from another location in memory, Ir is critical for the\nposa() and Recreate() functions in order co allow the resource manager to swap the\nresource in and out of memory as it sees fit.\ncant portion of the resource (c.¢., the bitmap data, the sound buffer, and the like} ,\nbeen swapped our, the function should return a size of zero.\ntion defining the general priority of a resource (high, medium, low).\nfirst, The function m_nftefCount indicates the number of times the resource has heen\nwhich the resource was last accessed.\n‘The less-than operator ( < ) ts what determines the priority of sorting resources\n1.7 Resource and Memory Management\nif Resource 83\nThe Resource Manager Class\nThe other half of the managed resource problem is supplying a manager thar can\norganize all the stored resources, provide access on demand, and handle the dynamic\ndisposal and reallocation of resources to stay within a memory budget.\ni! General resource access\nf/ Allows the resource manager to pre-reservea an amount of\nff Tf you pass in the address of a resource handle, the\nff Resource Manager will provide a unique handle for you.\nff Locking thé resource ensures that the resqurce does mor\nff get managed by the Resource Manager.\nif Unlocking the object lets the resource manager know\n{i resource.\n1.7 Resource and Memary Management 85\nJf to highest priority, determined by tha resource class's\nThe heart of the resource manager ts che data member m_ResourceMap. This is an\nSTL map, which means that every unique resource handle (which is simply an\nunsigned int) is paired with a pointer ro a resource object.\nor dynamically assigned by che resource manager itself.\nOnce the resource manager object has called the create() function and passed in\nsource() function vo insert resources into the manager.\nthen inserts the resource object into the manager.\nIt is important to understand one ching about the resource manager.\nSW2ps OE resources until the currently used memory is lower chan che threshold spec:\nAlthough this method may be acceptable if your resources are allocating out of\nresource clases Greate() function alter loading some sort of resource header informa-\nthe entire resource.\nOnce the memory is reserved by the resource manager, the Gre-\nate() function can finish the daca loading and insert the resource into the manager.\norder te gain access to a resource, the client must call a member function and pass in\nthe handle in order to get back a pointer to the resource.\nff the resource can now be safely used before any other calls are\nonly until another call to the resource manager is made.\nAccessing another resource\ncould cause the resource manager to swap out the resource you were previously access-\nYou will most likely want to put asserts in your resource class's code to ensure that\ntheir member functions are not called if the resource has been disposed.\nisa mechaniom in place to do so: the Lock() function, Locking a resource increments\nthe reference count on the object, which prevents the resource manager from dispos-\ning of the object uncil the resource has been unlocked with, of course, che function\nthe resource manager assumes that it is noc allowed to dispose of the resource when\nSince the resource manager hus\n1.7 Resource and Memory Management ay\nThe use of a resource manager is extremely beneficial in managing large amounts of\nresources effectively.\nresources, this difficuley is offset by the simplicity of automatic memory management.\nTf your application's entire cata set is already indexed in che resource manager, a\nresource that has been determined a candidate for pre-caching, you should access che\nforces any swapped data in those resources ro be reloaded and made ready for direct\na resource that is no longer needed, simply lower che priority level in the resource, and\nbook, “A tseneric Handle-Based Resource Manager,\" by Scott Bilas.\neffective and efficient resource manager can help streamline the development process",
      "keywords": [
        "resource manager",
        "Resource",
        "manager",
        "Memory",
        "che resource manager",
        "James Boer Computer",
        "function",
        "data",
        "Resource Manager Class",
        "Resource Class",
        "PRIORITY",
        "resource manager object",
        "Management James Boer",
        "bool",
        "che resource"
      ],
      "concepts": [
        "resource",
        "functions",
        "function",
        "functionality",
        "memory",
        "returned",
        "management",
        "access",
        "accessed",
        "virtual"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 8,
          "title": "",
          "score": 0.78,
          "base_score": 0.63,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 10,
          "title": "",
          "score": 0.655,
          "base_score": 0.505,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "",
          "score": 0.576,
          "base_score": 0.426,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 11,
          "title": "",
          "score": 0.572,
          "base_score": 0.422,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 13,
          "title": "",
          "score": 0.569,
          "base_score": 0.419,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "resource",
          "resource manager",
          "manager",
          "resources",
          "memory"
        ],
        "semantic": [],
        "merged": [
          "resource",
          "resource manager",
          "manager",
          "resources",
          "memory"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22703733566523124,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602521+00:00"
      }
    },
    {
      "chapter_number": 10,
      "title": "Segment 10 (pages 86-98)",
      "start_page": 86,
      "end_page": 98,
      "summary": "dara files into memory.\nFor the ultimate in fast dara load times, you need to prepfocess your data into che\nup properly after loading, since the data saved out in the pointer member is almast\ngame data class having member Functions to perform che loading and saving, Please\nJust read che data back int the\ndynamic memory allocation shown below:\nFrame-Based Memory\nThis article presents a simple and extremely fast memory allocation system that pre-\nvents memory from heeoming fragmented between game levels.\nextremely fast at both allocating and de-allocating memory and can be used on any\nMemory Allocation\nnew is thar memory can become fragmented and result in deteriorated game perfor-\nmemory block, But this rearrangement comes at the cost of CPU cycles that the game\nmemory manager.\nIntroduction to Frame-Based Memory\nAsolution to these challenges of conventional memory allocation is framre-hased meni\nFrame-based memory eliminates memory fragmencation and is very fast.\never, it is not useful as a general-purpose memory allocation system like nallec() and\nFramte-based memory is best suited for game and level initialization modules.\nAs shown in Figure 1.9.1, frame-based memory works like a stack.\ntion time, the game allocares a single memory block from the operating system, which\n1.4 Frame-Based Memory Allocation aa\nwill be used and managed by the frame memory system.\nThis memory block is allo-\ndenoted by Memory Block is used by the frame memory system.\nFrom the memory\nblock's pointer, we compute the Base and Cap memory pointers, optionally aligning\nThe Base pointer points to the lowest aligned memory address in our\nMemory Block, and the Cap pointer points to the next higher-aligned memory\nThe Memory Block, the Base pointer, and the Cap pointer\nFinally, che Lower Heap Frame and\nUpper Heap Frame pointers are set equal co the Base and Cap pointers, respectively.\nThe following code initializes the frame memory\nff frame pointer\nif First allocate our Memory Bleck:\nTo shut down the frame memory system:\ntem(}, passing in the total number of bytes co be managed by the frame memory sys-\nAll allocations made through the fame memory systern\nparameter be a power of 2\nAt this point, che frame memory system is ready to use.\n1.9 Frame-Based Memory Allocation 85\nAllocating and Releasing Memory\nFrame memory allocation works like a stack.\nchunk of memory from one of the two heaps.\nHeap Frame pointer is bumped up by the amount allocated, and its value por vo the\nThe Lower Heap Frame pointer always points to the next\navailable byte of memory: If, on the other hand, the upper heap is specified, the Upper\nHeap Frame pointer is bumped alow by the amount allocated, and the new value is\nThis is because the Upper Heap Frame pointer always points co the last allo-\nThis function performs frame-based memory allocation very quickly, Since frame\nmemory is allocated like a stack, ic must be de-allocated the same way.\nA frame is a handle that che game retrieves from the memary\nsystem and is used to free memory.\nMemory can be freed only by using a frame.\nframe acts as a bookmark within the pages of memory allocared by the system.\na frame is freed, all memory allocated since the frame was obtained is freed.\nIn Figure 1.9.2, (b) and (c) show two individual memory allocations being made\nIn (dj, the game obtains a frame from the\nmemary system, The frame is simply a handle that the game will later wse to free\nmemory In (e) and (f), the game allocates another two blocks of memory.\nFrame\nMemory allocation and release.\n19 Frame-Based Memory Allocation a7\ngame wants to release all memory allocated since the frame was obtained, The follow-\ning function obrains a frame for either the upper or lower heaps:\nff Returns & Frame handle which can be used to\nFrame_t GetFrame( int nHeaplun ) {\nFrame.\n‘To the memory system, a frame is a copy of the specified heap number and ies\ncurrent frame pointer.\nmemory, we implement the following function:\nThe game calls AeleaseFrane() to release all memory allocated since the time\nneous frames the game can allocate, provided thar the frames are released in che order\nHowever, the memory system doesn't\nrequire that frames be released.\navailable memory is always equal eo the toral size of the free heap.\nchunk of available memory in the lower heap is always identical to che largest chunk\nof available memory in the upper heap.\nff Object couldn't be loaded.\nRelease memory:\nRelease memory:\nff Allocates memory fron HEAPNUM and loads tha specified object\nif trem disk inte the allocated memory.\n1.9 Frame-Based Memory Allocation oo\nff Insufficient memory:\nff Object loaded successfully:\nwithout issue, the frame is not released and the function recums with the memory\nfree all object memory, the higher-level function simply calls ReleasaFrame() with\nthe frame it had obtained.\nSince frame-based memory works like a stack, it is imperative that frames are released\nreplacement function for releasing a frame:\n(uint)Frame.pFrane<=(uint) apFrame[o] I;\n(uint) Frame.\ndent types of memory (main, sound, rexure, geometry, and so forth), a frame-based\ninto sound memory.\nIn this case, there would be three independent frame memory\nSystem memory Fram",
      "keywords": [
        "memory",
        "Trick John Olsen",
        "frame",
        "frame memory system",
        "frame memory",
        "Heap Frame pointer",
        "memory allocation",
        "Heap Frame",
        "Upper Heap Frame",
        "John Olsen",
        "Lower Heap Frame",
        "Load Trick John",
        "Data Load Trick",
        "Frame-Based Memory Allocation",
        "Upper Heap"
      ],
      "concepts": [
        "memory",
        "frame",
        "load",
        "returned",
        "pointers",
        "game",
        "gaming",
        "allocate",
        "allocation",
        "allocating"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 9,
          "title": "",
          "score": 0.655,
          "base_score": 0.505,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 14,
          "title": "",
          "score": 0.568,
          "base_score": 0.418,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 11,
          "title": "",
          "score": 0.562,
          "base_score": 0.412,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 5,
          "title": "",
          "score": 0.527,
          "base_score": 0.377,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 8,
          "title": "",
          "score": 0.501,
          "base_score": 0.351,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "memory",
          "frame",
          "frame memory",
          "allocation",
          "memory allocation"
        ],
        "semantic": [],
        "merged": [
          "memory",
          "frame",
          "frame memory",
          "allocation",
          "memory allocation"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2305056694544699,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602568+00:00"
      }
    },
    {
      "chapter_number": 11,
      "title": "Segment 11 (pages 99-106)",
      "start_page": 99,
      "end_page": 106,
      "summary": "Simple, Fast Bit Arrays\nThe three (C++ classes in this article implement arrays of bits.\nisa simple one-dimensional array of bits.\narray of bits, and the Teogdtarray subclass is an array of integer elements whose values\nThey also provide additional features thar are useful for game development.\nArray of Bits\nThe base class Bitarray acts just like a normal C++ array af bools, although you are of\nbits[10] = true:\nThe class implements the standard birwise operators 4, |, -, 4=, |=, “=, and -.\nThis males che class useful for even small sets of flags.\nBitArray and the other classes call assert when an array index is out of bounds.\nThe array subscripr operaror in BitArray is implemented with a useful C++ pat-\nClasses.) The proxy class 8itProxy represents a single bit in the Bitarray.\nwe merely read che value of a bit via the bool operator, The 8itProxy class allows us\narray classes.\nthe bit value is immediately read or assigned co, che compiler is able to optimize away\nOther Arrays\nbits[S)(4] = true;\n1.10 Simple, Fast Bit Arrays 103\nbits2d[S)] = bit array; ff illegal!\nBitArrayed is implemented asa single BitArray chat concains as many bits as the\n‘The final class, TwoBitarray, provides an array of rwo-bir values, (Arrays with\nEven such tradicional low-level C conseructs as bit arrays can benefit fom implemen-\nIf you use these classes in major dara senactures in a game (e.z,, state bits attached\nto each cell in a cwo-dimensional array of tiles}, ic might be useful to add operators a\nThe sample code includes a vest program thar illuscrares usage of these bit array\nserver, 26 the only trusted entity, maintains che game state and verifies all cient com-\nserver communicate by sending packets over a necwork channel, which might be reli-\nis a short number produced by combining every byte of the packet.\n‘The recipient takes the packer and recomputes its checksum: if the com-\nputed checksum doesn't match the checksum fom the sender, the packet is corrupt\nthe packet were changed to any other value.\nable, and fast enough for use in games.\nPacket Replay\nIna packet relay attack, a malicious user captures a packer from the client (prpically\npacket replay co perform commands faster chan the game allows, even if there are tim-\na client might use a timer to send a certain com-\nreplay attacks, varying network delays can make packets bunch together by the time\nTo guard apainst packer replay, cach packet should conrain some stare informa-\nthing as simple as a number that increments with each sent packer would do, although\nmachine to produce successive identifying numbers for successive packers.\nreasonably complicated method is a linear congruential random number generator of\nThe sender and recipient cach keep a linear congrucntial random number gener-\nWhen sending a packet, the sender produces a random\nnumber and adds it ta the packer, simultaneously stepping its random number gener-\n‘The receiver checks the random number in the incoming packet against its gen-\nerator, if che numbers dont match, the packer has been tampered with.\nnumbers do match, the receiver steps its random number generator to prepare for the\nmachines with the same fixed seed, bur then the initial stream of packets would\nthe server can initialize its stare machine with randomly generated seed values and\nadvanced one more step than che receiver's; subsequent packers will be rejected, even\nsent with each packer (most games include this number with messages anyway, to\nmachine will have to be stored for use when an out-of-order packer arrives later.\nbits) and its obvious choice as a source of random numbers.\npacket replay defense, che sender and receiver already have synchronized random\nThus, the sender can generate a sequence of random numbers for\ncach packet and NOK these into the packer payload; the reeciver generaces the same\nThe sender checks its stare machine to determine how much junk to gener-\nate and inserts that number of random bytes into an ourgoing packer.\npackets from one client and then use knowledge of the packet payload to help\nthar uses all the previously described techniques ..A Securetransport object encapsu-\nobject maintains four linear congruential random number gencrators as protacol state\nThe class uses the stare\nunderlying protocol provides a packet length as in UDP)\n2. A message sequence number is used to prevent packet replay.\n4. It generates random bits to XOR the payload.\nA separate random number generator is used to gemerace che actual junk dara.\nDuring debugging, it is usefiel to set che junk data to a known constant value.",
      "keywords": [
        "bits",
        "array",
        "Fast Bit Arrays",
        "packet",
        "random number",
        "Bit Arrays",
        "Bit",
        "packer",
        "number",
        "che",
        "bit array classes",
        "Bit Arrays Andrew",
        "random",
        "BitArray",
        "state"
      ],
      "concepts": [
        "packets",
        "bit",
        "bits",
        "arrays",
        "operations",
        "operators",
        "operate",
        "protocol",
        "number",
        "implement"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 5,
          "title": "",
          "score": 0.643,
          "base_score": 0.493,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 9,
          "title": "",
          "score": 0.572,
          "base_score": 0.422,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 3,
          "title": "",
          "score": 0.563,
          "base_score": 0.413,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 10,
          "title": "",
          "score": 0.562,
          "base_score": 0.412,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 12,
          "title": "",
          "score": 0.556,
          "base_score": 0.406,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "packet",
          "packer",
          "bit",
          "random",
          "bits"
        ],
        "semantic": [],
        "merged": [
          "packet",
          "packer",
          "bit",
          "random",
          "bits"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24312816280749958,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602615+00:00"
      }
    },
    {
      "chapter_number": 12,
      "title": "Segment 12 (pages 107-114)",
      "start_page": 107,
      "end_page": 114,
      "summary": "squeezing More Out of Assert\nout of assert.\nIf you're already familiar with assert, skip down to “Assert Trick #1.\"\nThe Basics of Assert\nEvery programmer should religiously use the assert macro.\nThe assert macro is a\nBy giving the assert macro a condition to evaluate, you're asserting thar this\nIfthe condition evaluares co FALSE, assert brings up a\nassert and continue executing your code, abort the program, ot break directly into\nthe code where the assert failed.\nThe assert macro lets you program defensively.\nNULL, you should assert thar it is NULL.\nBy making assert a habit in your code,\nVector normalization is an example of an important place to use asserts.\nassert( length t= 0 ); Ii!\nassert makes a lot of sense.\nThis allows you to sprinkle asserts throughout your code with-\nSince the assert macro is nor compiled under release builds, its incredibly\ncode fails to check those assumptions, the assert will be triggered inside vectermor-\nAssert Trick #1: Embed More Information\nOne of the drawbacks of che traditional assert macro is that it doesnt cell you much\n[Fassert(sre t~ 0) fails, it brings up the suring “sre f= 0\" in the assert\nFinctluda <assert.h>\nassert( length §'= 0 && “VectorNormalize: sre vector is zero length\" };\n1.12 Squeezlng More Out of Assert 411\nWhen the first assert fails in this onde, the assert box displays the sting “src\nrunning the game, they can tell you the function name where the assert failed, along\nAssert Trick #2: Embed Even More Information\nSometimes programmers simply type assert (0) if the program exceution reaches an\nAssert Trick #3: Make It Less Awkward\nassert{ are t= 0, “VectorNorm@alize: src vector pointer is NULL* li\nassert( 0, “VectorNormalize: The code should never get here\" ):;\nAssert Trick #4: Write Your Own\nEventually cveryone should use an assert macro that’s been truly customized.\nA very annoying problem of the standard C assert is thac it breaks into the\ndebugger in the file assert.c—not che line in your program where the assert appears,\nBy writing your own assert macro, the debugger breaks directly to the assert linc\nspot you're actually interested in, The following is an example of a custom assert\nMdetine Assert( exp, description }\nGustomiseertFunction should bring up a dialog box stating the assert information\nAssertFunction should retum TRUE, and the debugeer will break on the Assert\nAssert Trick #5: This One Is Priceless\nOnce you have a custom assert macro, you can add an “Ignore Always” option to\nyour assert dialog box.\nThis is an amazing fearure thar lets you ignore an assert once\nassert is failing every frame, bur you still wane to run your game without clicking\nthrough a million asserts.\nTo implement this feature, each assert keeps track of\nwithin the assert macro.\nThis boolean then remembers whether the assert is to be\nboolean before it even evaluates the assert condition.\nassert condition fails and the user selects “Ignore Always” in the assert dialog box,\nWdetine ASsert{ exp, daseription } |\n1.42 Squeezing More Out of Assert 113\n#dafine Assert({ exp, dasoription }\nIf this type of assert fails without the\ndebugger running, the assert is virtually useless, Surprisingly, this is a common situ-\n‘The simple solution is to provide stack information inside the assert dialog box!\nAssert Trick #7: Make It Easier—Copy and Paste\nIfthe assert provides cons of great debugging information such as the stack,\nIn the Windows environment, you can have a burton on the assert dialog box\nand In-Game Debugging\nBoth PC and console systems have problems with debugging full-screen, real-time\nSometimes you need ro debug a live network game",
      "keywords": [
        "Assert",
        "assert macro",
        "Assert Trick",
        "Assert Steve Rabin",
        "assert dialog box",
        "assert dialog",
        "sre",
        "code",
        "macro",
        "debugging",
        "Trick",
        "Programming Techniques assert",
        "game",
        "system",
        "custom assert macro"
      ],
      "concepts": [
        "assert",
        "debug",
        "debugging",
        "code",
        "game",
        "time",
        "char",
        "length",
        "simple",
        "line"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 11,
          "title": "",
          "score": 0.556,
          "base_score": 0.406,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 3,
          "title": "",
          "score": 0.443,
          "base_score": 0.293,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 4,
          "title": "",
          "score": 0.431,
          "base_score": 0.281,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 14,
          "title": "",
          "score": 0.42,
          "base_score": 0.27,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 5,
          "title": "",
          "score": 0.412,
          "base_score": 0.262,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "assert",
          "assert macro",
          "macro",
          "assert trick",
          "dialog"
        ],
        "semantic": [],
        "merged": [
          "assert",
          "assert macro",
          "macro",
          "assert trick",
          "dialog"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1835894151063773,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602660+00:00"
      }
    },
    {
      "chapter_number": 13,
      "title": "Segment 13 (pages 115-123)",
      "start_page": 115,
      "end_page": 123,
      "summary": "1.413 Stats: Real-Time Statistics and In-Game Debugging 117\nTo start, the full code: for each class and its member functions ean be found on the\nC++ class using a common Star base class and derived types for each displayed data\nThe system consists of a base Stat class, which is the container for everything,\npur your printing code in the derived Stat class, ic is less portable, but you can do\nfunction that calls the Print() function for the current page.\nThe Windows-based sample code also has keyboard input processing, which\nthrough the real-time loop, both the CheckInput(} and Prant() functions need ro be\nEach page in the linked list owned by the base class contains zero or more entries,\nEntries are added to pages using che common entry parent class.\nfidden in cach derived class so that the parent system can access each Stat type\nThe actual data stored ina Stat varies based on the Stat type and is included in the\nderived Stat classes.\nFach data type has its own Print() function co replace the base\nThis function is very useful because che base class can then po\nUsing the parent type as a generic Stat pointer helps keep things orga-\n- Call GStatBase::CheckInput() each pass through the real-time loop to update\nImplementation time for a new Seat type varies depending on complexity, but a\nA derived Stat type in the sample code called a cStatIatetr deserves a litle bit of\ninstead of having to set che value of the Star im each frame.\ncode by adding just one line of debug code to declare an instance of a Stat.\n‘Typical execution time for running a similarly designed implementation of Stats\n1.13 Stats: Heal-Time Statistics and In-Game Debugging ; 119\nReal-Time In-Game Profiling\nProfiling code is a routine step in most software development, but it's an even more\n‘This article shows you how to add profiling code directly inside your game.\nSome people are adamant abeut not profiling their code until they're close to\nprofiled a module in the middle of development only to discover thar the function I\nThis real-time profiler allows you t monitor any spot or segment of code you're inter-\nwant to profile, Each sample, consisting of a Profilefegin and a Profilecnd, is iden-\n1.14 Real-Time In-Game Profiling 424\nOverall, the profiler takes a negligible amount of time to keep wack of your samples,\nsimple snippets of code, especially if they are executed hundreds of times a frame.\nmonitoring takes more time than the code fragment and causes it te look worse than\ncalled hundreds of times a frame.\nThe profiler accurately rells you how many times it\nis called, bur the timing information is useless.\nIts important co note thar this real-time profiler shouldn't replace a traditional\nprofiler.\nRather, this real-time profiler should augment the profiling thar you'd nor-\n‘This profiler gives you the following information at the end of each frame.\n2. Average, minimum, and maximum percentages of frame time spent on that\nsample\n3. Number of times the sample was called per frame\nThe profiler tries to be smart about samples and keep track of parent/child rela-\nFor example, if you sample the main loop of your game and the graphics\ndraw routine that’s inside che main loop, the parent/child relationship is taken into\n3. The Graphics Draw Routine is called inside che Main Game Loop (noted by the\n4. The Main Game Loop should take 100% of che frame time, bursince the Graph-\nics Draw Routine is being profiled inside of the Main Game Loop, it’s subtracted,\nindicating that some code within the Main Game Loop is periodically hogging\nthe frame time.\nPechaps it's the Al code or physics code; add more samples to the\nprofiler to find our.\n6. The Main Game Loop and the Graphics Draw Routine are both called once per\nAfter adding more profiler samples to better identify the spiking problem, the\nAl Update sample (probably 32 game objects thar require Al).\nClearly the sample thar’s spiking, with 27.4% on some frames.\ncode inside the Al Update thar is periodically called.\nContinue to add profile samples uncil the exact segment of code is identified.\ning down problems with che profiler is thar easy.\n1.14 Real-Time In-Game Profiling 123\nAdding Profiler Calls\nAs mentioned earlier, you must wrap the code you want to profile with Profile@egin\nToButter formats the profile information into a text buffer so that you can display it\nProfiler Implementation\nOn a given frame, each profile sample needs the following information:\nTloat fAéccumulator: FP AlT samples this frame added\nOver many frames, we need to keep history information on samples taken.\nTloat TAve; ffAverage time per frame (percentage)\nTLloat Twin; {{iindmum time per frame (percentage)\nTtloat TWax; /iMaxinum time per frame (percentage)\nand destroying memory every time a sample is taken, Before any samples are taken,\n‘Two functions are used for referring to time: GetTime and GetElapsedtime.\nTame should return the amount of time passed since the last frame (calculated by\nProftilesample g_samples[NUM_PROFILE_ SAMPLES];\nWe're now ready to record a sample, so let's look at the function ProfileBegin in List-\nby ProfileEnd. In effect, it keeps track of how many profile samples have begun and\n1.14 Real-Time In-Game Profiling 125\ncount how many times the sample has been called on a frame.\nsample has never been called this frame, the code finds a sample in the array char isi't\nthe code loops chrough all samples, counting how many open samples currently exist\nparent, the sample time is noted in the immediate parent's structure (to be subtracted\nfrom its sample time larer).\nSince this sample might be opened again on this frame, chis sample time is saved\nDetails on Processing the Profiling Data\nat the very end of the main game loop in the function ProfiledumpoutputTaBetfer.",
      "keywords": [
        "Main Game Loop",
        "graphics draw routine",
        "Game Loop",
        "Stats",
        "sample",
        "code",
        "main loop",
        "frame",
        "time",
        "graphics draw",
        "Main Game",
        "loop",
        "draw routine",
        "game",
        "main"
      ],
      "concepts": [
        "profiling",
        "profile",
        "time",
        "timing",
        "sample",
        "functions",
        "calls",
        "code",
        "char",
        "frame"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 8,
          "title": "",
          "score": 0.595,
          "base_score": 0.445,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 9,
          "title": "",
          "score": 0.569,
          "base_score": 0.419,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 3,
          "title": "",
          "score": 0.561,
          "base_score": 0.411,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 14,
          "title": "",
          "score": 0.534,
          "base_score": 0.384,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "",
          "score": 0.526,
          "base_score": 0.376,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "profiler",
          "sample",
          "frame",
          "samples",
          "time"
        ],
        "semantic": [],
        "merged": [
          "profiler",
          "sample",
          "frame",
          "samples",
          "time"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21295010121248054,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602708+00:00"
      }
    },
    {
      "chapter_number": 14,
      "title": "Segment 14 (pages 124-131)",
      "start_page": 124,
      "end_page": 131,
      "summary": "Protileinstance profile ingtance{ \"Timing tha For Loop\" 1:\nIn no time, this line profiler\nwhile( a <= NUM_PROFILE SAMPLES £4 g sanples[i].bvalid =-- trug ) {\n1.14 Real-Time In-Game Profiling\nif( stromp( g_samples[i].szName, nang } == 0 } {\ng_Samples[i]-idpenrrofiless+:\ng_samples[i).iProfileinatances++;\ng_sanples[i).bvalid = TRUE:\ng_sanples[i].i0penProfiles = 1;\ng_sanples[i].iProfileinstances = 1;\ng_samples[i]-fAccumulatoer = o.of:\ng_samples[i]-fStartTine = GetTine();\ng_samples[i)-?¢hildrenSaspleTine = o.or;\nwhile( i < NUM_PROFILE SAMPLES £8 g samples(i].bvalio == true )\nif{ Stremp( g_sanples[ij].szName, name } == 0 }\nelse if( g_sanples[inner] .fStartTime ==\ng_sanples[parent).fStartTime }\nffRemenber the current number of parents of the sample\ng_sanples[parent) .tthildrenSanpleTime += fEndTime —\nuint i = g;\nwhile( i < NUM_PROFILE SAMPLES && g samples{ij]-bvalid == TRUE If\nelse if{ g_sanples[i].i0penProfiles > 0 } {\ng_Samples [4].\n1.14 Real-Time In-Gamo Profiling 129\nStoreProfilelndistory( g sanples[i].sziana, percentTime };\nSatProtilefromistory{ G_sanples[i].seNane, kaveTime,\nsprintf, mun, \"Sad\", g_sanples[i).iProtileInstances i\nBircpy( indantedNane, g_samples[i].szName hs\nfor indent=o; indent<g_samples[i].iNumParents; indente+ id\nfor( i=0; T<NUML_PROFILE SAMPLES; i++ } {\ng_sanples[i].bValid = FALSE;\nwhile( i < NUM_PROFILE SAMPLES 44 g history[i].tvalida == TRUE If\nif{ stremp( g_history[i].szNane, name } == 9 }\nif percent < g_history[i)].7Min } {\ng_history[i].TWin = parcent;\ng_histery[i]-fiin = (p_history[i].fWin*oldAatio}) +\nif{ percent > g_history[ij.fWax } {\ng_history[i]-fitax = percent;\nif(t i= MU PROFILE SAMPLES }\nstrepy( g_history[i].szMane, nama j;\nBSeert( i*Exceeded Max Available Profile Samples!*);\nuhile( i «= NUU_PAOFILE_SAMPLES &4& g hastory[i)-bValid == TAVE } {\nif({ strcemp( g history[i].szWame, mane } == oO j\n*ave = g history[i].fAve:\n\"min = g history[i].tilin:\n‘max = g history[i] .filax:\nand game.\ngame designers often run out of che\nspace needed to distribute a large and complex game, especially when the images used\nThis article is a study of'a technique that can be used co provide the depth of play\nup the perfect game.\na game universe, we need to satisfy nwo conditions of resolution.\nlution requirements we have identifed, we need to be able to generate che universe in\nalso have the same appearance each time the game is restarted or played on a different\nBy way of example, let us consider as game universe a simplified model of our\nAt game time, we would like to populace che Galaxy with Stars in a fashion char\nfirst seeds the generator with a given value, which is used to propagate che sequence.\nThe same sequence is generated every time we seed with the same value.\nated on the fly, Thus we can generate a near-infinite galaxy entirely in game time,\nence and once only per sequence of numbers; in the following case, we are seeding on\ngalaxy number 1:\nuniverse (galaxy x,galaxy y}) = star\nuniverse (galaxy_x, galaxy_y}) = no_star\nconsidering all the other operations that are being performed during game play, so we",
      "keywords": [
        "PROFILE SAMPLES",
        "SAMPLES",
        "Techniques Profiietnd funcion",
        "Programming Techniques Profiietnd",
        "profile",
        "history",
        "sanples",
        "Profiietnd funcion",
        "game",
        "Predictable Random Numbers",
        "Techniques Profiietnd",
        "time",
        "max",
        "Random Numbers",
        "Galaxy"
      ],
      "concepts": [
        "profiles",
        "samples",
        "sampled",
        "game",
        "max",
        "parent",
        "inner",
        "char",
        "stars",
        "number"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 10,
          "title": "",
          "score": 0.568,
          "base_score": 0.418,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "",
          "score": 0.565,
          "base_score": 0.415,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 3,
          "title": "",
          "score": 0.534,
          "base_score": 0.384,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 13,
          "title": "",
          "score": 0.534,
          "base_score": 0.384,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 4,
          "title": "",
          "score": 0.497,
          "base_score": 0.347,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "g_sanples",
          "samples",
          "g_samples",
          "g_history",
          "history"
        ],
        "semantic": [],
        "merged": [
          "g_sanples",
          "samples",
          "g_samples",
          "g_history",
          "history"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21724828478862668,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602771+00:00"
      }
    },
    {
      "chapter_number": 15,
      "title": "Segment 15 (pages 132-139)",
      "start_page": 132,
      "end_page": 139,
      "summary": "136 Section2 Mathematics\nThis code works by first taking a repeatable sequence of numbers, which follow a\nThe source code for this sequence follows.\nunsigned long ulSeed,\nUliewSeed = (this->ulGeni * this->yu1Seed) = this->ulgen2;\nThe largest number that can be generated using this\ntime to tum our attention to the use of pseudo-random numbers on the features and\nclass which gives the number of Planets, and calculate this.\nshows how we can calculare an atoribure of our Star class, che number of Planets:\nclass star {\nint x_position, y_position;:\nint number_of planets;\nPeeudorandom-+seed(this->x_position + (this->x position\nFirst, we are seedling on a unique value for che Star, based on the position\ngiven by the x and y coondinate propertics of the Star object, This means chat for each\nStar, we can generare values that are seeded for thar particular object.\n4 second point to note is chat we have taken the modulo of the generated num-\nber in order to limit the number of planets chat may orbit this Star.\ntechnique thar will enable us to generate a distance value for a given planer.\nthe important starting point is the seed thar is used to determine the features of the\nobject.\nSection 2 Mathematics\nWoid SeibistanceFronstar(int planet_number,\nint star_x_position, int star_y position);\nint star_x position,\npseudorandom-=seed(planat_nunber + (Star_x_pasition +\n(star_«_position * this->star_y_position) \\);\nSo, we have cHectively “zoomed in” from Universe to Star oo Planet, as far as spec-\nPlanet object and thar this map is represented by a simple gid into which we can\nThe whole code for che Universe, Galaxy, Planet, and Map\nff Plate an abject on the map for a given position x,y\nIn the preceding examples, che seeding has been omitted, As can be seen from the\nsupplicd code examples, the seed is gcncrated on an object-by-object basis ar instanti-\nerand (x_position + (x dimension * y position))\nwhere the generator is seeded on the unique reference generated for che point (x, y}\ndom class, but the following algorithm, which can be used for seeding the generator\n* = x position\ntechniques, propagated by sequences of pseudo-random numbers, seeded ona unique\nInterpolation Methods\n* Frame-rate-dependenc ease-out using floating-point mach\ninterpolation is meant simply to take you from one value to another along a smooth\nThe concept behind this method is that you want to compute a weighted average\nThe new x value equals x,, the original value,\nmaultiplied by a weighting factor, added co che final destinarion x value.\nSection 2 Mathematics\ngenerates a smooth curve, as shown in Figure 2.1.1, which shows how the value\nThe sample C++ class that can be used for floating-point ease-our interpolation is\nvalues anc a scale factor that controls how quickly che interpolation occurs.\npass through your real-time loop, you call Interpolate() to do che work, then call\nWith this floating-poine code, it could rake a very long time\n2.1 Interpolation Methods 143\ncompared with Figure 2.1.1 and the floating-point method.\nEven with the less-than-smooth curve, this method is very useful for larger values.\nIr tends ta work well with fixed-point math, where some number of bits in your inte-\nListing 2.1.2 contains a sample C++ class called CeaseQutShift Interpolation",
      "keywords": [
        "Wultiply Geni",
        "star",
        "position",
        "diwided by Max",
        "Predictable Random Numbers",
        "number",
        "Planet",
        "code",
        "int star",
        "method",
        "che",
        "seed",
        "Random Numbers",
        "object",
        "Star class"
      ],
      "concepts": [
        "value",
        "point",
        "planets",
        "code",
        "star",
        "generated",
        "generate",
        "generator",
        "generation",
        "objects"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.441,
          "base_score": 0.441,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 49,
          "title": "",
          "score": 0.396,
          "base_score": 0.396,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 45,
          "title": "",
          "score": 0.379,
          "base_score": 0.379,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 51,
          "title": "",
          "score": 0.339,
          "base_score": 0.339,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.334,
          "base_score": 0.334,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "star",
          "interpolation",
          "planets",
          "planet",
          "seed"
        ],
        "semantic": [],
        "merged": [
          "star",
          "interpolation",
          "planets",
          "planet",
          "seed"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23732479620639432,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:16.602820+00:00"
      }
    },
    {
      "chapter_number": 16,
      "title": "Segment 16 (pages 140-149)",
      "start_page": 140,
      "end_page": 149,
      "summary": "are beginning an interpolation, passing in your starting and ending values and a shift\nretrieve the current interpolared value, Interpolate() reruns TRUE when the interpo-\nthe target.\nFrame-Rate-Independent Linear Interpolation\nIn the case of a linear interpolation, you want to compute an ideal velocity at the\nbeginning of the move and simply apply thar velocity each frame.\nNext you need to apply thar velociry co each frame.\nis frame-rate independent, you need to know how long the frame took.\nhave thar time per frame, you can caleulare the change in position, using the already\ncomputed velocity, and add it co che original valuc, as shown in Equation 2.1.5.\ntake a shoreut and calculate che velocity as distance per frame instead of distance per\nsecond, you lose the frame-rate-independent fearure but can gain a litde time by\nThe sample (++ class thar can be used for linear interpolation in Listing 2.1.3 is\nthere, With each pass through your real-time loop, you call Interpolate;) with che\nInterpolate returns TAVE when the specified time has expired and you\npoint, then slow back down to be ar a zero velocity as we arrive at the destinarion\nWe need to solve this equation for acceleration.\nframe.\nyou must take the time per frame inno account.\nTo start, che velocity is zero.\nshawn in Equation 2.1.5, the same as in che lincar interpolation version buc with a\nvelocity that changes each frame.\nThis velocity should be very near zero by the time\ninterface is identical to che linear interpolation clas, which makes it convenient to\ninterpolation, passing in che starting and ending values and how long you want it to\nWith each pass through your real-time loop, you call Interpolate(}\nproper ranges before interpolating angles, quaternions, or any values for which chere\nbool Interpolate() // Note: Not time dependent.\n_target)/ divisor;\nreturn value;\nfloat value;\n_value = from;\ntarget = to;\nbol Interpolate() J / Mote: Hot time dependant.\ntarget) => shift:\nreturn {value == oldValue);\nreturn value:\nint value;\n_value = from:\nreturn value;\nvalue = from;\n_target = to;\nreturn value;\nRigid Body Motion\nbody motion.\nIn order to derive che differential cquations that describe the motion of a rigid body,\nframe, we mean three linearly independent veetors (the basis) and a reference position\nWe call this fixed frame the world frame, ar world space.\nspecified with respect to this coordinate frame by three numbers, as shown in Figure\nNo marrer how a body's mass is distributed, at any instane in time there is a point in\nspace that is the center of wna of the body, r_.\ncalculared with a weighted sum of every mass element, m,, in the body:\n2.2 Integrating the Equations of Rigid Body Motien 151\nIt is helpful to associate a focal coordinate frame with a body, For our purposes,\nbody.\nof the body (Figure 2.2.2).\nThe vectors R°, R!, Ro define the x, y, and 2 aves of the local body frame.\nThis makes it easy to transform a vector from a body's local space to world space, and\nIf at time # a body's position is r,, and at time #, its position is r, (Figure 2.2.3),\nthe body experiences per unit time is called its angular velocity (also called rotational\n22 Integrating the Equations of Rigid Body Motion 163\nA body moves from rf, toe) over a time Ar= 6-4.\nThis means that if a body were rotated abour the first axis by the\nIfa vector r is rotating ata constant angular velociry, then its time derivative with\n—= 0x r.",
      "keywords": [
        "Body",
        "time",
        "velocity",
        "frame",
        "interpolation",
        "Linear Interpolation",
        "Equation",
        "Rigid Body",
        "Rigid Body Motion",
        "float",
        "che",
        "call Interpelate",
        "acceleration",
        "target",
        "Interpolation Methods"
      ],
      "concepts": [
        "interpolation",
        "interpolate",
        "interpolated",
        "values",
        "time",
        "frame",
        "returns",
        "float",
        "velocity",
        "rotation"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 23,
          "title": "",
          "score": 0.472,
          "base_score": 0.322,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 22,
          "title": "",
          "score": 0.421,
          "base_score": 0.271,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 20,
          "title": "",
          "score": 0.419,
          "base_score": 0.269,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 21,
          "title": "",
          "score": 0.401,
          "base_score": 0.251,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 18,
          "title": "",
          "score": 0.364,
          "base_score": 0.214,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "body",
          "frame",
          "velocity",
          "interpolation",
          "time"
        ],
        "semantic": [],
        "merged": [
          "body",
          "frame",
          "velocity",
          "interpolation",
          "time"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18440687568541356,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602865+00:00"
      }
    },
    {
      "chapter_number": 17,
      "title": "Segment 17 (pages 150-158)",
      "start_page": 150,
      "end_page": 158,
      "summary": "154 Section 2 Mathematics\nNewton's first law of motion states that a body remains stationary or maintains a con-\nconservation of fincar momentum, The linear momentum vector, p, of a body is cal-\nWhen a body is moving relative to a point of reference and its motion is not\ntime derivative of the angular momentum is equal to the net torque on the body:\nAngular momencum, L, is orthogonal to both rand P-\n2.2 Integrating the Equations of Rigid Body Motion 155\nSpecial Properties of Rigid Bodies\nevery other element of macter within that body, this object is called (oddly enough) a\nand changes the inertia tensor, complicating motion even further.)\nRigid bodies have a couple properties thar make their motion easier te deal with,\nWhen a gid body is rotating, every\nlinde piece of mass, mi, within it has angular momentum with respect wo the center of\nmass, r..\nThe body's coral angular momencum {in world space) about its center of\nie vs p=) 5 x (my)\n¥, 2a x 4,\n>» FTF, Fe, ¥ SHIFT 3m, ir — 5)\nFor rigid bodies with continuously distabuted\na mel x ul 1 =P\nThe angular momentum about the center of mass can now be given in\ncoordinares implies chat the inertia tensor depends on the body's orientation and must\nbe recalculated every time the body rotates.\ninertia censor are called the principal axe of the rigid body, and the eigenvalues are\nWith respect to a body's principal axes, the\nf= if (x?\n2-2 Integrating the Equations of Rigid Body Motion : 157\nwhere x, ¥ and 2 are in the body's local frame.\nFor rigid bodies, these integrals need to\nbe calculated only once, and the inertia tensor in world space is given by:\nrigid body with those of a rectangular box of constant density, Luckily, the principal\n4, and d, are the bax dimensions in x, y, and z, respectively [Baraff7a].\namore complete discussion on calculating ineria tensors of irregularly shaped bodies,\nIn order to calculate the rotational motion of a rigid body, we need to know how\nangular velocity changes with respect co time.\n=e =, la) Pik ae a x (le) + 5 [Baraf97b]\nrotational motion of a rigid body.\n— x (a)\nIntegrating the Equations of Motion\nGiven an initial position, rp, the next position of the body, r,, can be approximated\nUnfortunately, integrating orientation in this way introduces error, and R must\nA better way te integrate orientation is to find a rotation\n“vector” by multiplying the angular velocity by the time step:\n22 Integrating the Equations of Rigid Body Motion 155\nM, =| 2y+2m 1=2x' +2\") 292 =I\nwhere s = cos($), and (x, y, z) = a sin($), $0 that R, = MLR, [Ware 2000).\nAlthough the Euler method is the simplest way to integrate differential equations,\n[f the angular velocity pets too high, the\nBody Simulation 1—Unconstrained Rigid Body Dynamics,” available online at\nSection2 Mathematics\nPolynomial Approximations to\nMeanwhile, the time it rakes a CPU to do a floating-point multiply has gone down\ntion co calculating complex functions is through polynomial approximation; we find\na polynomial that approximates che function we wane.\nIn che first part of this article, | describe in some detail how polynomial approxima-\nseries for the function, The Yaylor series is an infinite polynomial char is equivalent to\nthe function (for some range of x).\npolynomial, which we assume to be a good approximation to the function.\nThere are alternatives to the Taylor series method char are nor so well known.\nPolynomials\nThe numbers a// are called the coefficients: of the polynomial.\ndegree of che polynomial.\ntorizing the polynomial in some way, I do not recommend the alternative methods,",
      "keywords": [
        "Rigid Body Motion",
        "Rigid Body",
        "body",
        "Rigid",
        "angular",
        "angular momentum",
        "Body Motion",
        "motion",
        "Rigid Bodies",
        "Polynomial",
        "angular velocity",
        "Rigid Body Dynamics",
        "Unconstrained Rigid Body",
        "inertia",
        "Equations"
      ],
      "concepts": [
        "integrating",
        "integrals",
        "integrate",
        "integration",
        "polynomial",
        "methods",
        "body",
        "bodies",
        "motion",
        "angular"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 32,
          "title": "",
          "score": 0.426,
          "base_score": 0.276,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 33,
          "title": "",
          "score": 0.399,
          "base_score": 0.249,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "body",
          "rigid",
          "angular",
          "rigid body",
          "motion"
        ],
        "semantic": [],
        "merged": [
          "body",
          "rigid",
          "angular",
          "rigid body",
          "motion"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.12075797295751045,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602906+00:00"
      }
    },
    {
      "chapter_number": 18,
      "title": "Segment 18 (pages 159-166)",
      "start_page": 159,
      "end_page": 166,
      "summary": "23 Polynomial Approximations to Trigonometric Functions 183\nfloat Poly::Evaluate(float x)\nrange of values it returns, over its domain.\nthese polynomials is infinite.\nWhen we look at the evaluation of the polynomial, we see it is the sum of terms\nFor instance, if che degree of the polynomial is 10 and the value of all the\nThe range of a function is often well known.\nThe range of other functions is infinite; for instance, tangent gets larger\nculate sin(6000.0) with a 10th degree polynomial.From the domain analysis, we\nina better range (=pr to +7) and then apply the polynomial.\nMultiply che value of x by 65536/2\" pt.\nMultiply che value of x by 2*90/65536,\nThis method gives the correct value of x berween —pi and +p, with 16 bits of resalu-\ninstance, the sine function cakes radians, hut by pre-multiplying by 2*p2/65536, we\npolynomial coclicicnts.\nee] Polynomial Approximations to Tigonemetric Functions 1645\nreturn SinePoly::Evaluate(x * mult};\nfloat Poly: :Evaluate(float x)\ncode, and then we can use the original code to evaluate the function with the new\nmethod cannot be used to create a polynomial that directly takes signed 16-bir frac-\nchange a polynomial’s range slightly.\nIt involves substiruting the value (x + off) into the polynomial in place of x,\nPor instance, substimuing (x + 2) for x in the polynomial (‘J + x) gives (7 +\nhand before inveking the polynomial evaluation method.\nTo change the ourpur units of a polynomial, simply multiply each\nSo, you can change the range of a polynomial incrinsieally and at zero cost to the\nEven and Odd Polynomials\nWhen you come to manipulating polynomials on che computer, you will find thar\nquestion comes from the analysis of even and odd polynomials.\nAn even function is one where:\nIn crigonemetry, sine is an odd function, and\nNor all functions are cither even or odd.\nfoi Polynomial Approximations to Trigenometric Functions 167\nA polynomial is made up of swms of che functions 1, x, x\", x%x\"x, etc.\nof these basic functions is either odd or even.\nx=—(—x) & ODD\nIt should be reasonably clear that if 2 polynomial conrains all even powers of x,\nthe polynomial itself is even, and that if it contains all odd powers of x, the polyno-\nNow the important point: If a polynomial approximares an even function, the\npolynomial itself should be even.\nIt's no use if your polynomial says that sin‘) does\nvalue, and the bogus non-zero enefficient is the result of floating-point rounding\nThis implies that if the function is even, aj] is zero whenever m is odd; if the\nIF you have a supposed polynomial\napproximation to sim(x) thar has 2/2/, mot zero, you know the approximation is\nWhen we differentiate a polynomial, we get-\nNote that the derivative of the polynomial «/0/ (degree zero} is 0 (also degree\nEach time we differentiate, the degree of the polynomial goes down by one.\nEach coefficient is rotated in curn into 2/@!, and multiplied by x.\nWe can obtain a/t/ from the polynomial object by calling Evaluate (0); by calling\nIszero() ts the function that tells us if the polynomial is zero everywhere (ic.,\nEvaluate(x) = 0 for all x}:\n2.3 Polynomial Approximations te Trigonometric Functions 168\nold polynomial only through its operations IsZera(), Evaluate(), and Ditferenti-\nfractals and the Dirac delta function (which contains an infinity at x=0) give prob\nThe other chiss of functions thar give problems are those with\nFunction, which has virnual methods IsZero(), Evaluate(}, and Differentiatat }.\nThe following function cal-\na[O] = f-*Evaluate(pt);\nThis function calculates the series for ffx — pt) and then offsets the domain to\nsome functions have no well-defined value at x = ( (e.g., Jc is not defined there), so\nfunction poinrers no define the class TrigFunction thar behaves like these nwo:\nFloat Evaluate(tioat x) { return Sign * float(fptri(doubleqxy)); J\nFloat sign; if sign of function —1 or +1\n1. Specify the maximum degree of the polynomial thar wakeTaylorSeries will",
      "keywords": [
        "Polynomial",
        "function",
        "Functions",
        "float",
        "Evaluate",
        "Range",
        "Polynomial Approximations",
        "Poly",
        "Odd",
        "che",
        "Domain",
        "Odd Polynomials",
        "thar",
        "units",
        "return SLM"
      ],
      "concepts": [
        "functions",
        "function",
        "polynomial",
        "float",
        "evaluation",
        "evaluate",
        "sign",
        "returns",
        "differentiation",
        "differentiate"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 19,
          "title": "",
          "score": 0.779,
          "base_score": 0.629,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 23,
          "title": "",
          "score": 0.569,
          "base_score": 0.419,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 21,
          "title": "",
          "score": 0.528,
          "base_score": 0.378,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 20,
          "title": "",
          "score": 0.448,
          "base_score": 0.298,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 36,
          "title": "",
          "score": 0.424,
          "base_score": 0.424,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "polynomial",
          "odd",
          "evaluate",
          "functions",
          "function"
        ],
        "semantic": [],
        "merged": [
          "polynomial",
          "odd",
          "evaluate",
          "functions",
          "function"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21322534229828813,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.602964+00:00"
      }
    },
    {
      "chapter_number": 19,
      "title": "Segment 19 (pages 167-175)",
      "start_page": 167,
      "end_page": 175,
      "summary": "2.3 Polynomial Approximations to Trigonometric Functions afi\nThe Taylor series for sine was a polynomial of infinite degree.\nHoating-point error) because the terms we ignore do make a contribution wo the final\nWith the Taylor series, there is nothing we can do to fix this problem excepe\nincrease the degree of the polynomial.\nLagrange Series\nThe Lagrange series is my name for a type of approximation series derived using\nUnlike the Taylor scries, there is not one single Lagrange series for\nknown points:\nIf our approximation were exactly correct for these points, we would know that:\nA theorem proved by Lagrange states thar for any given V points there is a unique\n(NOJ)th degree polynomial that passes exacey chrough all che points.\nthis polynomial, we have an approximation thar has the properties listecl.\nSuppose we want to find a Srh-degree polynomial for sine.\n0. With one point ac x = 0, we must have an odd number of points to achieve the\n‘To get an odd number of points, we use a 10th-degree polynomial.\nwe know that sine ts odd, so we know thar 2/0] = 0, so the 10th-degree polynomial\nso we choose points ar well-\nNotice that by choosing points, we assume no prior knowledge of our function.\n23 Polynomial Approximations to Trigonometric Functions 4173\nCalculating the Lagrange Series\nThe Lagrange series is obtained as a sum of polynomials—a different polynomial for\neach point.In this exposition, our daca points are x/f/, ..., xfeff, and the desired fumc-\ntion values at these points are y/O/, —, pied].\n(@+1).This polynomial evaluates to zero at every data point, since one of its factors is\nFor instance, ic is zero at x/2) because ome of ies Factors is fe — aff).\nnomial of degree @ that ewaluanes to zero at each dara point exveps for the one we mined\nThis is because it does net have a factor (x —xj/nj) for che data point xf.\nvalue at that data point is given by substituting x/r/ for x in the product polynomial;\nThe next step is co multiply the product polynomial by y/m//c/m/, a process called\nThe result is a new polynomial thar is equal to yim ac dara point x[m/\nbut is equal to 0 at every other data point.\nThis concept gives us the bu ilding block for che Lagrange series.\nLagrange series itself, we need to generate all (@2J) of these polynomials and then add\nAr each data point «nj, all bur one of the polynomials evaluates to\nnomial that is equal ro p/n/ at each point x/i/, as desired.\nPor example, suppase we have the simple three-point case:\nThe simple polynomials are (x—x/OJ), (x —x/1)), and ( —x/2/), which are equal to (x\nLet's look at dara point x/6/, We multiply all the simple\npolynomials except (x — x/0)/) together, which gives:\nWe evaluate this at x/@!, which gives:\nSo we do indeed have zero at all the data points except the first, where the value ts 4,\nCompleting the work for the other ewo points gives the following polynomials\nxfi]:2— 2x\"\nYou can check thar each polynomial is equal to y/n/ at its own dara paint, and zero at\nYou can quickly check that this polynomial matches the dara at every point\ning-point errors, as you would expect.\nThe Lagrange series does not have chis problem.\nTaylor series exhibits a maximum error of 1 part in 150, with an average error of 1\nCompare thac with the Lagrange series, which has a maximum error af\nThe Taylor series is an exact march for a function, provided you take infinitely\n[he Lagrange series is intrinsically limited by the number of data points\nThis fact seems ro imply thar the Taylor series is the better approximation, but\nIn this case, the Lagrange series has a steiner error one-\nseventh the size of the Taylor series’ avensge error!\nunions in Print() can be used the other way around to get the floating-point num-\nDiscontinuitics arise in practice fairly often, and neither Taylor nor Lagrange series\nAr +/— 90 degrees,\nfunction to be just the range over which it is continuous—Le., from —90 to +90\nPor the Lagrange series, chis means taking points only from inside chis range.\nean be approximated using Taylor or Lagrange methods.\nFrom these methods, we discovered Taylor series.\nWe then found Taylor series to be\nLagrange series.\nfunctions.\nChoosing a method of integrating initial value problems is an important patt of writ-\ndividing the time step; however, even these methods become unstable ar some point.\nEvaluating the exponential function for every dara poinc is simple and exact, buc it\nwhere x, is the solution after a time step Az. Solving for x, we get:\nx, = xy — Axpdit = x, (1 — Ar),\nsubtraction and two multiplies, even a fixed-point processor could handle this method.\nexponential function, it must decay to zero over time, implying thar\nSo if f= 1 and Ar=2, then x, =—x,, and the solution is stable, although not very accu-\npoints.\nhand, evaluates the derivarive ar x; instead of x, (Figure 2.4.1), giving:\n= Xp & (be, Ar. Solving for x; gives:\nThe explicit Euler method evaluaces che derivative at x (a), whereas the\nimplicit Euler method evaluates the derivative ar x, (bh).",
      "keywords": [
        "Lagrange Series",
        "Truncated Taylor Series",
        "Taylor Series",
        "afi Truncated Taylor",
        "Series",
        "Functions afi Truncated",
        "Lagrange",
        "Euler method",
        "Polynomial",
        "points",
        "function",
        "Taylor",
        "method",
        "Truncated Taylor",
        "Explicit Euler Method"
      ],
      "concepts": [
        "points",
        "functions",
        "function",
        "polynomial",
        "error",
        "gives",
        "giving",
        "method",
        "series",
        "degree"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 18,
          "title": "",
          "score": 0.779,
          "base_score": 0.629,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 23,
          "title": "",
          "score": 0.508,
          "base_score": 0.358,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 20,
          "title": "",
          "score": 0.461,
          "base_score": 0.311,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 21,
          "title": "",
          "score": 0.368,
          "base_score": 0.218,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 16,
          "title": "",
          "score": 0.329,
          "base_score": 0.179,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "lagrange",
          "series",
          "lagrange series",
          "polynomial",
          "taylor"
        ],
        "semantic": [],
        "merged": [
          "lagrange",
          "series",
          "lagrange series",
          "polynomial",
          "taylor"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.16040572420408608,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603017+00:00"
      }
    },
    {
      "chapter_number": 20,
      "title": "Segment 20 (pages 176-183)",
      "start_page": 176,
      "end_page": 183,
      "summary": "Section 2 Mathematics\nae = =f)\" x — sa ae bs\n= -w'x — Ay,\nwhich is stable for all positive values of & 4, and Az (see Figure 2.4.2).\nFinding an implicit evaluator for x, ix not always easy.\nwhich it is impossible to solve for x,, numerical root finding such as Newton's method\nential Equations with Applications, third edition, West Publishing Co., 1987-\nEquations [: Nonstiff Probleme, second edition, Springer-Verlag, 1993.\n[Hairer96)] Hairer, E., and Wanner, G., Solving Ordinary Differential Equations LH:\nCompression\nWe generally associate wavelets with a compression method.\nWhatever the wavelet application (compression, analysis, etc.), the point of departure\nFrom these NV values, we build a cree such as\nthe one shown in Figure 2.5.1, At each level of the cree, we calculate che average of\ntwo values, which becomes the value of the next level, The tree obtained is a binary\ntree cam be used to factor che initial values.\nsion causes a loss of information, The basic principle of wavelets is thus a reversible\nprinciple: At any time, we can go back ro the initial values without losing informa:\nTo the tree that we've built, we add new values on the branches correspondi ng to\narate two values, linked by one branch and differing by one level.\nfrom one vector of NV values co a cree of AYfNe 22 walues for che nodes, plus\nlevel—ie., a factoring level, , between 1 and dogs.\nvalues and the lower branches that grow from it (see Figure 2.5.3).\nOnce the factoring level, p, has been chosen, we obtain the level p compressed\nvalues, with O<pelog.N, by sequentially calculating levels 1 chrough p, inclusive (sce\n2.5 Wavelets: Theory and Compression 183\na = [at +a,)/2+l4, —2,)/2 |\nChoosing factoring level.\n(Initial values) (Comprcied values)\nCompressed values.\nOnce factored, we restore the initial values by reversing che operation.\ninitial values from a level p, we must maintain this level's scale factors as well as all che\nThe initial values are thus a scalar vector of 16 val-\n‘Thus, if we choose factoring level 3, we keep the couple of scale factors (6, 10)\n[fwe now wane co return to the 16 initial values, we calculate the level 2 scale fac-\ntors by adding or subrracting level 3 coefficients, and se on, until we rerun to che\n2.5 Wavelets: Theory and Compression 165\nory behind these other wavelets closely follows the previously described principle.\nWavelets have many applications.\nCompression and decompression by wavelets requires an additional phase,\nother words, the entire image can be recomposed precisely from any level.\nof no interest to us in compression, so we can secrifice values co lose che least informa-\nHon of images or 31) models enabling one to adjust the level of details of an image\nAn comple oF image compression.\na central difference approximation of che two-dimensional wave equation, you can\nity of the surface is zero, the general solution for a square x J.",
      "keywords": [
        "level",
        "Wavelets",
        "factoring level",
        "Compression",
        "initial",
        "Solving Ordinary Differential",
        "image",
        "che",
        "implicit Euler method",
        "che inicial conditions",
        "Principle",
        "applications",
        "levels FIGURE",
        "factoring",
        "method"
      ],
      "concepts": [
        "values",
        "compression",
        "compressing",
        "wavelets",
        "level",
        "image",
        "equations",
        "difference",
        "differing",
        "differ"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 21,
          "title": "",
          "score": 0.498,
          "base_score": 0.348,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 19,
          "title": "",
          "score": 0.461,
          "base_score": 0.311,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 18,
          "title": "",
          "score": 0.448,
          "base_score": 0.298,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 16,
          "title": "",
          "score": 0.419,
          "base_score": 0.269,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 23,
          "title": "",
          "score": 0.404,
          "base_score": 0.254,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "compression",
          "level",
          "wavelets",
          "values",
          "initial values"
        ],
        "semantic": [],
        "merged": [
          "compression",
          "level",
          "wavelets",
          "values",
          "initial values"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19463830629641266,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603060+00:00"
      }
    },
    {
      "chapter_number": 21,
      "title": "Segment 21 (pages 184-194)",
      "start_page": 184,
      "end_page": 194,
      "summary": "Section 2 Mathematics.\nwhere fix, y) is che initial shape of the water surface [Trim0).\neled as an evenly spaced grid of z-values (a Acight field), as in Figure 2.6.1, the preced-\nE= A(N-f)\nWe could approximate a solution by evaluating only the significanc terms of the\nDropping all but the first three modes along x and y requires evaluating nine\nThe value 24, is the height of the #, jth grid position at time m.\n26 Interactive Simulation of Water Surfaces 1688\nvary benween cells, all coefficients can be pre-calculaned, and successive z-values can be\nvalues at times ¢), f, and 3; however, if 2°!\nconst float B = 2— 45a:\n+ B*z[i][]] — 2ifi}[i;\n7190 Section 2 Mathematics\nin nature, bodies of water are usually not square.\nthe height value without any energy loss, whereas a coefficient of 0 restricts all move-\nwees only previous and currenc values of z;; to evaluate 2\"*!\nthat evaluate several floating-point values in parallel, memory alignment requirements\n26 Interactive Simuletion of Water Surfaces 181\nSplashes can be creared by instantaneously displacing one or several z-values at a par-\nWhat good is water if things can't float on cop if ir?\ndensity is less than thar of che surrounding water.\nis equal to the weight of the water displaced by thar object.\nSection 2 Mathematics\nThe number of poincs needed depends on the shape of the object and the level of\nIf we think of and y as our paramerers, the water surface can be described by the\n2.6 Interactive Simulation of Water Surfaces 193.\nn,, =|—- ae  _\nTo keep the object from sliding over the surface like a surfboard, a drag force can\nThe velocity term v,,., is the velocity of the hull redarive to the water at x, So if, in\nWhen drawing water, you can use alphe blending to give the appearance of trans-\nWater also reflects light from its su rrourudlings, These\nEnvironment mapping a water sur-\nwith an environment map surface to calculate a texture coordinate [Figure 2.6.5].\nWith reflection only, water appears too metallic, like liquid\nAlthough environment mapping gives stunning visual results, using it on a large\n[Hairer$6) Hairer, E., and Wanner, G., Solving Ordinary Differential Equations fT:\nQuaternions for Game\nQuaternions are useful for representing and processing 3D rotations of points, Appli-\nTreat Quaternions as Matrix Replacements\nThey can describe any rotation around any axis in 3D space.\nspace, four numbers rather than nine, and many operations such as multiplication are\nSome operations such as interpolation berween quaternions are also more\ncan easily convert quaternions to rotation matrixes and back again.\nff a black-box quaternion type that can replace 3x3 matrices\nclass Quaternion\nGuaternian quaternion_from_matrix(MateLxaa mat }:\nMatrixd3 matrix _from_quaternion(Quaternion &quat):\nQuaternion interpolate(duaternion 4a, Quaternion &b, float b_amt);\nQuaternion operator *(duaternion &a, Guaternion 4b):\nVectord Quaternion: :AxisOffotation(}) sonst;\nQuaternion AotationArc(Vectors vO, Vectors v1):\nA typical use of quaternions is to store all your matrices (such as orientations of\nbones for an animating character) as quaternions.\nreplaced with quaternion calculations, and only ac the end of the pipeline, where vec-\ntors must be rotated into world space or onto the screen, de you turn the quaternions\nThree-by-chree retation matrices can be represenced directly by quaternions.\nQuaternions do not suffer from gimbal lock.\nthree values to represent a simple local rotation, You often sce this roration having\nWhat Do X, Y, Z, and W Represent?\nThe four numbers in the quaternion, often denoted (x, yz, w), have some physical\nsignificance, If we consider all rotation matrixes to represent a rotation of an angle @\n4 (A), Fy, 2), shown in Figure 2.7.1, the quaternion Q will be:\nRotation of angle 6 abour axis,\nNote that cwo quaternions represent each rotation matrix.\nIn quaternion terms, you can make the Os\nquaternions represent very similar rotations.\nextra tests inside the implementation of any quaternion library.\nThe quaternions we use here are a subset of general quatemions.\nGeneral quaternions\nsquare root of —] (which cannot be represented by a “conventional” number):\nSection 2 Mathematics\nWhar this all means is that quaternions are defined, similazly to complex mum-\ngq = ise] where s = wand p = /x y zi\nAddition and muldplication of quaternions are defined in the obvious way, Much\nanother quaternion:\n= fy €y— xp Xz— Fy Fr — Ey 5z) +\n(By Xp — 5) p+ Cy a + Cp Yad f+\nThe conjugate of a quaternion can be thought of in ewo ways:\nThe multiplicative inverse of the quaternion:\nquaternions, where [gl = J, or x?\nHow Do Quaternions Represent Rotations?\nThe rotation of a vector P [x y x] by the unit quaternion gis done by creating the\n“pure” quaternion p and the conjugate of g:",
      "keywords": [
        "quaternion",
        "water",
        "rotation",
        "Water Surfaces",
        "quaternions represent",
        "Quaternions Represent Rotations",
        "surface",
        "vector",
        "numbers",
        "coefficients",
        "che",
        "terms",
        "complex numbers",
        "represent",
        "grid"
      ],
      "concepts": [
        "quaternions",
        "mapping",
        "map",
        "grids",
        "rotations",
        "rotation",
        "rotated",
        "surfaces",
        "waves",
        "normal"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 18,
          "title": "",
          "score": 0.528,
          "base_score": 0.378,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 20,
          "title": "",
          "score": 0.498,
          "base_score": 0.348,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 51,
          "title": "",
          "score": 0.498,
          "base_score": 0.498,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 23,
          "title": "",
          "score": 0.47,
          "base_score": 0.32,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 16,
          "title": "",
          "score": 0.401,
          "base_score": 0.251,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "quaternions",
          "quaternion",
          "water",
          "rotation",
          "represent"
        ],
        "semantic": [],
        "merged": [
          "quaternions",
          "quaternion",
          "water",
          "rotation",
          "represent"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23352318089936439,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603104+00:00"
      }
    },
    {
      "chapter_number": 22,
      "title": "Segment 22 (pages 195-204)",
      "start_page": 195,
      "end_page": 204,
      "summary": "like the quaternion multiplication worked through previously [Glassner0]_\nHon matric A retion matrix can be seen as che rotation of the unit matrix by a quater-\nnion, where the unit 3% 3 matrix is che three vectors (1, 0, 0), (0, 1, 0), and (0,0, 1,\nMatrix-Quaternion\nQuaternion multiplica-\ntion is faster than matrix multiplication, and quaternion interpolation generates\nThis article demonstrates quaternion-to-matrix and Matrie-to-guatemion eon-\nresent quaternions.\nWe alto use , g and g” to designate quaternions.\nQuaternion Rotations\nLet gq = [ev] = [oos(8),usin(@)) be a quaternion where u is a unit vector.\nbe a quaternion (nor necessarily unit) representing a pointe in three-dimensional\nQuaternion-to-Matrix Conversion\nTo convert the quaternion g into an equivalent rotation mamrix, we must express\n2.6 Matrix-Quaternion Conversions\nPor a quaternion g = [wv], gq!\nSubstituting g = q7!\nMatrix-to-Quaternion Conversion\nThe relationship between a rotation matrix and the components of its corresponding\n— My, = 4we\nThe largest component of a unit quaternion has an\nThe trace of a matrix is che sum of the diagonal components.\nTr=4- ditty *ex7) = all = (x+y tee\" })\nRecall that a unit quatemion q = [w,v] = [cos(6),v'sin(0)] where v'= (x72) isa\nunit vector, We can therefore express the trace of Af as;\nTr = 4(1 — (x\"*+y\"*+27)sin(6))\nSince (xlyiz) is a unit vector, x@+y7+27 = 1,\nv,= (My + M,i(4y)\ninterpolating Quaternions\nquaternion mathematics.) This article presents four techniques (Lerp, slerp, squad,\nand spline) for interpolating between pairs or sequences of quaternions.\nQuaternion Calculus\nBefore getting into quaternion interpolation, we need to define some calculus furc-\ntions of quaternions.\nLet g@ = cos(@) + vsin() bea unit quaternion (¥ is a three-dimensional unit\nFrom this identity, we can define the power function for quaternions:\nQuaternion Interpolation\nSince quaternions can be used to represent 3D) rotations, we can use four-dimensional\nThe general formula for interpolation between q,\nLinear Interpolation\nLinear interpolation is given as:\nLinear interpolation is fast, bur it does mot generate smooth animation.\nSpherical Linear Interpolation\ninterpolating values along the great arc connecting the two points (see Figure 2.9.1).\nSpherical linear interpolation (slerp) is given ax\nslerp(rigy.gy) = [qysin(@(l — r))+q,sin(Br)]/sin (8)\nSpherical linear interpolation can alen be expresed as a power function of gy\nFrom this, we can express the derivative (slerp') as:\nslerp produces smooth animations, but it always follows a great arc connecting ro\nquaternions.\ninterpolate through a series of quaternions produces a jaeged path.\nsmoothly interpolate through a series of quaternions, use splines (see Figure 2.9.2).\nLinear Interpolation\nsquad(r:p.¢.4.0) = slerp(2e(1 — ):slerp(s-¢.¢),slerp(ica, b))\n—q tepresent the same rotation, slerp{mp.q) does mot produce the same result as\nslerp(p.q).\nSpline Interpolation\n‘To generate a sequence of smooth interpolations, {,.6,} is given as:\nSee Denvation 2.9.3 fora derivation of spline interpolation.\nlerp, slerp, squad, and spline interpolation as well as quaternion exponential and log-",
      "keywords": [
        "Linear Interpolation",
        "interpolation",
        "spherical linear interpolation",
        "quaternion",
        "slerp",
        "quaternion interpolation",
        "unit",
        "vector",
        "Linear",
        "unit vector",
        "spline interpolation",
        "matrix",
        "spherical linear",
        "Mathematics Linear Interpolation",
        "unit quaternion"
      ],
      "concepts": [
        "quaternions",
        "interpolation",
        "interpolating",
        "interpolate",
        "interpolations",
        "matrix",
        "vector",
        "unit",
        "rotations",
        "rotation"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 23,
          "title": "",
          "score": 0.658,
          "base_score": 0.508,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 16,
          "title": "",
          "score": 0.421,
          "base_score": 0.271,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 18,
          "title": "",
          "score": 0.369,
          "base_score": 0.219,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 61,
          "title": "",
          "score": 0.362,
          "base_score": 0.362,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 37,
          "title": "",
          "score": 0.331,
          "base_score": 0.331,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "quaternion",
          "interpolation",
          "slerp",
          "quaternions",
          "linear interpolation"
        ],
        "semantic": [],
        "merged": [
          "quaternion",
          "interpolation",
          "slerp",
          "quaternions",
          "linear interpolation"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1673012333097498,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603147+00:00"
      }
    },
    {
      "chapter_number": 23,
      "title": "Segment 23 (pages 205-212)",
      "start_page": 205,
      "end_page": 212,
      "summary": "unit quaternion, Given the basic ineerpolation function:\nLet g = ens (g.0q)\nSince g is a unit quarernion, x+y°+27+n7\"=1.\nwhere ¢= gy\"q, = cos(8).\na= [C+ f2+22) 2.18 — G2 — 2427/2]\nSection2 Mathematics\nsin(ens) = (4(8 — f(O)(2 — Be) \"V2\n248 = (1 — 2)\"\" = (1 — cos{O))\"?\nA748 = 1, so A = cos(yf) and # = sin(yf) for some phase angle w.\nJolt) = [sin(yfghcos( one) — ons ( yt, )sin(oae) |/sin(®)\nJil) = [sin(y,)cos(enr) + cos(y, )sin (eae) } ‘sin (®)\nfle = sini, — ce)/sin(Q)\nJoU1) = sinty, — 03)/sin(8) - 0 w= yw, = 8\nJl) = sin(BC1 — A)isin(8)\nult) = sin(Oe/sin(Q)\ndp is a unit quaternion (as is g,), 50\ndot product of g, and g,, which is the same as the cosine of the angle between g, and\nSince qo 'q, isa unit quaternion and we know thar its sealar part is cos{8), we can\nslerp(tiqyg)) = [qpsin(O(1 — 4)) + qolcos(@) + usin(@))sin(8 4))]/sin(8)\nqosin (O(1 — 4) = qyflsin(@)cos(8y) = ons(8)sin (64)\nAh, but cos(@) + usin(@) = g9\"9,, so one more rewrite yields:\n212 Section 2 Mathematics\nLet Of = slerp(s3p.q).\nV = slerp(r:2.6), W= UV\nGiven the power form of slerp, we can rewrite squad:\nApplying the product rule, we can express the derivative of squad:\nsquad (rp.g.¢.6) « UW)\" + Ue\nC(O) = plog(p-'g)\nsquad'(0;9,9.2.6) = p[log(#*g) + 2log(p-\"a)]\n[We#!—87'(1) = —2log(g 4)\nsquad'(1ip,9,4,6) = g[log(p-'g) — 2log(g-'4)]\nyg.) — 2logly,\"'é,)) = g,[log(g.\"g..1) + Zlog(g.',)]\n7, > Llogig,-‘ga.1) + log(g,y\"'g.)]/2\nqullogtg,.-'g,) — Zlog(g.'5,)] = q,lloglg.\n1g.) !2\nGullogtg.‘dy.1) + Zlogtq.*a,)] = g,[log(g\"g,,;) + logig, 77 q.1/2\n7, — b, — qoexp[(loglg, ;—'g,) at log(q.\nFor a unit quaternion ¢ = [s¥]:\nthis function returns a quaternion g where g*yg==»,.\nmee ee eee ee\nthat is important for its Al. As is the case for all rigid bodies, a quaternion g is needed\nquaternion.\nclose together, the cross product (being propartional to the sin of che angle between\nThis problem first hit us during the development of the guided missiles for the\nnasty bug, you should use the code provided in this article for generating a quaternion\nfrom two direction vectors.\nderive has the elements ¢,.q.-q..\nThe angle (unknown) between che ewo vectors (rp\nThe g.qp-4, components of a quaternion g have a length that is sin of half the\nangle (#2), As mentioned, the cross product's length is che sin of che anple ¢, There-\nsin(t / 2)\nsin{s)\nsin(s/ 2) - vil = cos(r))/2\nsin{t} 1 — cos*(e)\nya-ai2_ | et ees\nDeriving the g,, component (angle) of che quarernion is fairly straightforward\nusing the half-angle formula for cos(t2):",
      "keywords": [
        "sin",
        "quaternion",
        "cos",
        "Interpolating Quatemions",
        "Slerp",
        "che",
        "unit quaternion",
        "angle",
        "log",
        "slerp preserves magnitude",
        "vectors",
        "function",
        "product",
        "clarify che notation",
        "Shortest Arc Quaternion"
      ],
      "concepts": [
        "sin",
        "cos",
        "quaternion",
        "function",
        "functions",
        "vector",
        "angle",
        "derivation",
        "derive",
        "derivatives"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 22,
          "title": "",
          "score": 0.658,
          "base_score": 0.508,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 18,
          "title": "",
          "score": 0.569,
          "base_score": 0.419,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 19,
          "title": "",
          "score": 0.508,
          "base_score": 0.358,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 16,
          "title": "",
          "score": 0.472,
          "base_score": 0.322,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 21,
          "title": "",
          "score": 0.47,
          "base_score": 0.32,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "sin",
          "quaternion",
          "cos",
          "log",
          "angle"
        ],
        "semantic": [],
        "merged": [
          "sin",
          "quaternion",
          "cos",
          "log",
          "angle"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1904118144668715,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603189+00:00"
      }
    },
    {
      "chapter_number": 24,
      "title": "Segment 24 (pages 213-226)",
      "start_page": 213,
      "end_page": 226,
      "summary": "The first is that you need each of your game objects co update its logic every\nThe Message Concept\nSince messages have the intended receiver built in, it's easy to\nit can send a message wo itself, to be delivered at a future time, in order to stagger\nState Machines\nA state machine is a siraple Al concept thar delivers a lor of power with very litele com-\nThe basic idea is chat a game object has a different state for cach main sepment\nIn a baseball game, for example, the pitcher might have the states\ntively, if you came across a bug, you could dump toa file all che past state information\nSo, state machines not only break behavior into manageable bite-sized\nAn Event-Driven State Machine Using Messages\ngame object running a state machine doesn't preclude it fom using fuzzy logic, neural\nAlthough state machines are a simple concept, let's review some important quali-\n- The state machine can have an arbierary number of states,\nWhen a state is entered, we should be able to execute any initialization code.\nWe can easily listen for messages and execute any code in response.\n- We can transparently record state changes and the message that criggered them.\n- We can listen fora message within only cerain states or globally over all states.\nTable 3.0.1 Paeudocode for State Machines\nEedStateMachine Derminates the state machine definition\nOnExit nds to a state being exited: allows for clean-up code\nSendM Seni: message to any game abject\nSend Delayed Mse() Sends a delaped message to any game object\nWe can send messages to any game object, including ourselves,\nThe overhead for running the state machine should be minimal.\nOur state machine needs to support all these fearures.\nmachine stars out in none of these states, Instead.\nmachine is ahways active, regardless of the current state.\nfor che first time, the OnEnter response is triggered, Inside this response, che first state is\nIn chis example, it sets che starting state to Patral.\nSetState( STATE_Patral }\nSetState( STATE_Attack }\nSTATE_PATAOL }\nSince this state machine is even driven, the only way it executes is by getting a\nmessage.\nIt can get a message when a state is first entered (oninter), when a stare is\nexited (OnExit), when a game tick occurs (OnUpéate), or on any other defined message\nWhen looking at the state machine, envision a message being delivered to it.\nmessage first goes to the currenc stare, [f there is a response for that message, the mes-\nIf there is no response for the message\nin that state, the message is resent to the global responses at the top of che state\nvidual states can have message responses or thar you can have a global response to a\nmessage, regardless of the current state, Even more powerful, you can have a global\nBecause there are these global message responses, a stare change might happen\nIfa global message response changes the current state, you can rely on getting che\nOnExit message in the current state to clean up anything before the stare is actually\nstate machine within che following function:\nelse if{ a == state } { af(0} {\n!\"Invalid State\" ; \\\nPut State machine inside this funetian!\nINitiOns to COMSEMUCE a new state machine language!\nmacros to make the state machine work; it simply makes the coding more error free,\nknowing whether a message thar wasn't handled in a local stare needs to be sent to the\nglobal responses, The return value also helps log whether or nor a particular message\nwas handled by the state machine.\nThe braces are there to make che stare machine more C-like,\nThe following ix an example state\nState Machine Building Blocks\nstates.\nSince it's not required to have stares ar all, you could simply have message\nThe state names and message names are simply enumerated types—in effect,\nState Machine Message Routing\nQM course, there's a bir more support code to roure messages and make this stare\nThe only outside source of messages co the game objects comes from the player\nstate machines themselves.\nThe router then sens it through the game object and on to the state machine\nIn case a message should be delivered at some time in the\nNerte that in Figure 3.0.1, owo different game objects point to the same state\nall variables and state information are stored inside the game object and nor the state\nMultiple game objects use the same state machine, so you should always be\nIn onder to explain the message router and state changes, we need to know more\nabout some variables inside each game object and message object.\nStateWachinelD state machine id:\ngo->foree_state change = true;\ndeal with delayed messages (a concept that is explained later in this article), che func-\nSending Messages\nIn order to send a message from inside a stare machine, it would help if there were a\nThe following is an example of a send message interface:\nmeg.delivery time = GetCurTime(); //Send the message NOW\nNote thar when a message is sence, the state machine immediately roures it to the\nstate machine lets you see the stack and, consequently, who sent che message,\nSending Delayed Messages\nAs mentioned before, messages can be given a future time co be delivered.\nfunction for sending a delayed message:\nNote chat all messages contain the sender and receiver as unique [Ds, nor as\nSince messages can be delayed, it’s possible thar the sender or receiver has\nto reference the game objects by a pointer only.\nInstead, the receiver of the message is\nDelayed messages arc an incredibly useful teol for the state machine.\nthe following state machine for a heat-seeking rocket, The rocket is fired, and if it\ntask is accomplished by sending a delayed message (wSG_Se1fDestruct) when the stare\nAfter five seconds, the message is delivered to the state machine\nAc thar time, the state is set to Explode, and\nOnEnter //Triggered when state machine first starts up\nSetState{ STATE _Explode };\nDeleting a Game Object\nDeleting a game object from within the state machine takes a little thought.\ngame object owns the state machine, we cant delete ic while we're executing code\ninside the state machine.\nWhen the execution steps outside the state machine, it’s then legal\nstate.\nwrong state.\nSTATE Dead |:\nSetState( STATE_Alive };\nThe problem is that both states send and respond co w8G_Tinedut.\nstale pets a MSG_Dead before it gets back che wSG_Timedut, the Dead state then incor-\nThe solution is to mark a message as valid only within a particular state.\nstate is no longer active at the time of delivery, the message should be thrown away.\ncach message object.\nSage ‘state’ marches the current state of the game object.\nOnly then is the message\nHowever, most of the time you want messages to he delivered regardless of\nthe current state, so messages should default to not performing this checks.\nSince only delayed messages sent to yourself should ever be marked with a stare,\ntions need ro mark the message stare as invalid.)\nState Transitions\nWith the current structure, it’s wrivial to snoop the current state of each game object\nmessage activity and state transitions along with a time stamp.\nfunction calls into che macros, the task of monitoring every state machine becomes\nThe following macros log message responses and state transitions:\nLogitateChange( go, state, (intja, GetCurTime() }:\neach game object.",
      "keywords": [
        "state machine",
        "State",
        "Message",
        "game object",
        "State Machine Message",
        "machine",
        "game",
        "object",
        "current state",
        "stare",
        "che",
        "che state machine",
        "MSG",
        "message responses",
        "time"
      ],
      "concepts": [
        "state",
        "message",
        "objects",
        "machines",
        "game",
        "code",
        "coding",
        "stares",
        "msg",
        "time"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 25,
          "title": "",
          "score": 0.782,
          "base_score": 0.632,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 34,
          "title": "",
          "score": 0.61,
          "base_score": 0.46,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 35,
          "title": "",
          "score": 0.519,
          "base_score": 0.369,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 1,
          "title": "",
          "score": 0.483,
          "base_score": 0.333,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 27,
          "title": "",
          "score": 0.366,
          "base_score": 0.366,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "state",
          "message",
          "state machine",
          "machine",
          "game object"
        ],
        "semantic": [],
        "merged": [
          "state",
          "message",
          "state machine",
          "machine",
          "game object"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1334458873754757,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603232+00:00"
      }
    },
    {
      "chapter_number": 25,
      "title": "Segment 25 (pages 227-237)",
      "start_page": 227,
      "end_page": 237,
      "summary": "Enhancement: Swapping State Machines\nThe solurion is to make bite-sized state machines that are more manageable\nmachine thar best fits the situation, This function avoids overly complex state\nEnhancement: Multiple State Machines\nThere is no rule chat a game object can run only one state machine at a time.\nits quite useful for an Al character to run several state machines simultancously.\nImagine that each character has one state machine that serves as the brain and one\nbrain could even control che movement state machine by sending it commands in the\nstate machines.\nThe brain can then run the appropriace movernenc state machine that\nEnhancement: A Queue of State Machines\nAs the first state machine\nreaches its goal, it destroys itself, and the next state machine on che queue becomes\nBy employing the state machine movernent queue,\nHowever, when a state machine reaches\na state machine can be customized for a particular character.\nshould be able to use the same state machine yet have wildly differing behavior due ro\nInterestingly, the original implementation of this Al engine supported state\n‘Tracking communication and state changes over all Al objects\n- Using global responses in state machines thar are always active, regardless of rhe\n. Allowing a global response in a state machine w be overridden by the current\nstate\n8. Allowing an Al to simultaneously run multiple state machines\n9. Allowing an Al to quewe up several state machines\nture on Al objects, Because of the macro state machine pscudolanguage, it’s incredibly\ndency to put too much code inside the state machine.\nsould be held within the state machine.\nPfLOSk Up correct state machine for this Game Object\nA Finite-State Machine Class\n‘This article defines a generic finite-state machine (FSM) C++ cass.\nFSM, which affects a sate sransition from one state to another.\nsimple (or complex) stare transition function that determines what state will hecome\nThe new current stare is called the enter state of the mate transition of the FSM,\nstate and a locked state, perhaps the inpur of see bey will cause the door to transition\nto the unlocked stare (the onepur crave of the state transition and the mew current stare\nstate.\nWhen the doer is in the open state, the input of see Adama will transition the\ndoor back to the closed state, When the door is in che closed state, the input of ree dep\nWhile the door is in the locked state,\nSo, in summary, an FSM is a machine that has a Spite memder of states, one of\nLet's say that the monster can have the following states: berserk, rage, mad, annoyed,\nthings based on the state of the monster's attitude.\nmonster's attitude and the way it transitions from one state to another based an inpur\nUsing these inputs and stares, we can set up a state transition matrix that looks\nTable 3.1.1 A State Transition Matrix for the Monster Game\nA sample finire-state machine.\na1 A Finite-State Machine Class 230\nSo, depending on the current state of the monster's attitude and the input co the\nObviously, we could add more state transitions, based on more states and inputs.\nity for 2 generic finite-state machine.\neralized, able to support a variery of types of states, a variety of types of stare\ntransitions, and any number of stare transitions, as well as any number of states within\nHere is the class definition we use to representa state for our FSM:\nunsigned m_ustumberotiransitions:; ff mexi0e number of states\nint \"m_pidutputstate; /f output state array\nint m_istatelD; ff the unigue ID of this state\nff add a state transition to the array\nff remove a state transition from the array\nff get the output state and offact a transition\nSince we are creating a “finite” state machine, this value sets\nthe finite-state transition limit for chis scate.\ncontains the input values to be used during state cransition.\nthe state transition evaluation function co compare to the input received and deter-\nanother state.\nOUurpUL state arrays to this instance of the FSMstate.\nThe Feuistate::Getutput() provides the state transition function that uses che\ninput value oo determine the transition output state identifier and return it.\nState Map nmap; {/ Gap containing all states of this FSM\n2.71 A Finite-State Machine Claes P|\nint m_iturrent$tate; // the m_iStatelD of the current state\nff return the current state Io\n{/ perform state transition based on input & current state\ntypedef map< int, Filetate*, less<int> > State_Map;\nin Game Programming, The above function declares State_Map to be an STL\ntier of the state of a mew current PSMstate object for the FSM.\nstate object contained within the FSM.\nstate relationships within the FSM that are defined by FSMstate objects.\nto delete the current state from che <map>, be sure to set a new current state using\nFSilclass::SetturrentState() before deleting che old current state, See Listing 3.1.8\ntransition, using the inpur value received and returning the output state identifier.\nCreating States for the F5M\nfi create the STATE_10 UNCARING\nii now add state transitions to this state\nPFSMstate-sAddTransition( INPUT_ID_PLAYER_SEEN, STATE_ID ANNOYED }-\nprSWstate->AddTransition( INPUT_ID_PLAYER_ATTACKS, STATE_ID MAD );\nM_PFSMclass = now FSMclass(STATE_I0 UWGARIWG);\n3.1 A Finite-State Machine Class 243\ndent) and receive am ourput stare (also game dependenc), chen act on the output state.\nfy have the FSi do the transition to an output state\nfy S0M8 game AL cade tests for the output state\nadded so thar, based on the type of input received or che current state, the transition",
      "keywords": [
        "State",
        "state machine",
        "state transition",
        "current state",
        "machine",
        "Swapping State Machines",
        "movement state machine",
        "FSM",
        "Output State",
        "Multiple State Machines",
        "state machine reaches",
        "input",
        "game",
        "transition",
        "complex state machines"
      ],
      "concepts": [
        "state",
        "objects",
        "msg",
        "games",
        "classes",
        "provides",
        "provided",
        "machines",
        "stares",
        "transition"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 24,
          "title": "",
          "score": 0.782,
          "base_score": 0.632,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 34,
          "title": "",
          "score": 0.451,
          "base_score": 0.301,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 35,
          "title": "",
          "score": 0.433,
          "base_score": 0.283,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 32,
          "title": "",
          "score": 0.402,
          "base_score": 0.402,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 27,
          "title": "",
          "score": 0.4,
          "base_score": 0.4,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "state",
          "state machine",
          "machine",
          "transition",
          "state machines"
        ],
        "semantic": [],
        "merged": [
          "state",
          "state machine",
          "machine",
          "transition",
          "state machines"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18515831254488366,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603275+00:00"
      }
    },
    {
      "chapter_number": 26,
      "title": "Segment 26 (pages 238-247)",
      "start_page": 238,
      "end_page": 247,
      "summary": "m_pilnputs = new int[m_ushunberOtTransitions| +\nfor{ int is; i<m_wsNumberOitransitions; +#1 }\nM_pilnputs{ij = ao:\nm_pidutputState = new int[mushumberOtTransitions| ;\nfor{ int i=0; i<m_usNusberOfTransitions; +42 }\ndelete [] m_pilnputs;\ndelete [| m_pidutputState;\nif the s_pilnputs[] and m_pitutputstate[] are not sorted\nff 30 find tha first non-zero offset in m_pidutputState[]\n‘i within the m_pilnputs[] and m_pidutputState| ]}\nfor{ int i=0; i<m_usNunberOfTransitions; +#4 }\nm_pidutputState[i] = iduepytip;\nM_pilnputs(ij = iTaput;\nff the g_pilnpute[] and m_pitutputState|] are mot sorted\nff so find the offset of the output state ID to remove\nfor[ int 1=0; 1<m_usNumberdfTransitiongs; +44 4}\nff ramive this output 26 and ite input transition value\nif since the m_pilnputs[] and m_pidutputState[] are not\nint idutputI® = m_istatelo; i!\noutput state to be returned\nidutputio = m_pidutputstatel il; If output state id\nff returning either this m_istatelD to indicate no output\nff state was matched by the input (i.e., no state transition\nff Can aceur) or the transitioned output state ID\nff try to find this FSWstate in the map\nit = m_map.find( iStateID };\nff if the FSilstate object pointer is already in the hap, return\nff the current state of the FSM must be set to have a transition\nreturn m_iturrent$tate;\nff get the pointer to the F5Mstate object that is the current state\nreturn m_iturrentstate;\nif aff the output state returned as tha new CUrrent state of tha\nff FSM and return the qutput state to the calling process\nm_iturrentState = pState->Getdutput{ input 13\nwhich the nodes are game states, and children of each node are the positions thar are\nticular game position is for one player.\nIn a one-ply (one-level-deep) search, a player obviously simply\nIn a ewo-ply search, Player One assumes that whacever he does,\nPlayer Two will then do the described one-ply search, Mayer One, therefore, plays\nbest expected board value, looking ahead a given amount.\nthe best value should be taken.\nif (ply == 0 || gase_over()) return évaluate current _board():\nint best = -intinity;\nTor (Mowe \"m= first_available move(j; m f= NULL:\nreturn best;\nint best_value = -infinity;\nint naw_value = maximize(ply):\nif {new_value > best_valua)\nbest_walue = new_value:\nreturn best_nmove;\nthar now the evaluation function must return the qualicy of the board for the current\nplayer, rather than always returning low values, meaning a good boand for one player\nif (ply == 0 || game_over(}) return evaluate current_board(};\nint best = -infindty;\nm= next_avallable _mowe())\nmake mowe(m) ;\nint mew_value = -negamax(ply — 1):\nreturn best;\nHere, a5 so0n as we see that Player Bs move P will produce a board of value 1, we\nknow that Player A will never let B get co che point char it can make move P Player A\ning player can get a better outcome elsewhere, we know thar the current board prosi-\nwe know the other player can get based on the parts of the tree searched so far.\nSon a3 OWF current search returns something that is bemer for us (and worse for the\nether player) than this “current best,” we know chat we don't have to search here any\nif (ply == 0 || ganc_ovar()) return evaluate_current_board[};\nint new_value = -alphabeta(ply — 1, \"bata, -alpha);\nif (new_value > beta) return now_value; // prune\nalpha = méw_value; | update our ‘best se far’\nsequences of moves producc the same game state,\nIf you are pretcy sure what the return value for the alpha-beta",
      "keywords": [
        "int",
        "move",
        "state",
        "player",
        "Game",
        "output state",
        "board",
        "game tree",
        "search",
        "int ply",
        "map",
        "ply",
        "Listing",
        "pilnputs",
        "pState"
      ],
      "concepts": [
        "returns",
        "game",
        "state",
        "values",
        "ply",
        "search",
        "player",
        "listing",
        "map",
        "transitioned"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 9,
          "title": "",
          "score": 0.576,
          "base_score": 0.426,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 14,
          "title": "",
          "score": 0.565,
          "base_score": 0.415,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 4,
          "title": "",
          "score": 0.544,
          "base_score": 0.394,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 13,
          "title": "",
          "score": 0.526,
          "base_score": 0.376,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 6,
          "title": "",
          "score": 0.515,
          "base_score": 0.365,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "ply",
          "player",
          "state",
          "int",
          "m_pilnputs"
        ],
        "semantic": [],
        "merged": [
          "ply",
          "player",
          "state",
          "int",
          "m_pilnputs"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22312595543045002,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603323+00:00"
      }
    },
    {
      "chapter_number": 27,
      "title": "Segment 27 (pages 248-255)",
      "start_page": 248,
      "end_page": 255,
      "summary": "This article examines the basic solution tw the problem of planning a path for an\nauLOROMOUs agent fo move fom one location in a game world tm another, a common\npath-planning techniques) works.\nThe mast common issue involved in path planning is the avoidance of obstacles,\npath-planning problem.\nA* is an algorithm that searches in a stare space for the least costly path from a start\nstate to a goal stare by examining the neighboring or adjacent stater of particular states.\nIn the path-planning\nproblem, a state consis of the agent occupying a particular location in the game\ntion is the goal; otherwise, it makes note of all chat location's neighbors for further\n3.3 The Basics of A* for Path Planning 255\nOpen has only the starting state (the agent in its current position), In each iteration,\nstate is nor a goal, the neighboring locations are sored: If they're new, they're placed\nthis is a cheaper path co them; if they're already in Closed, they are ignored, since\nfound, it means there is no path to the goal from char start location,\nThe “most promising” stace in Open is essentially the location with che lowest\nestimated path that would go through thar locarion.\ncost of the remaining distance to the goal; and che total path estimate, defined as\nCost(X) value that it determines is the next state to examine.\nconstruct the path from start to goal.\nCestFromstart(*)} called g(X), CostToGoal(X) refernec co as h(X), and che oral path\nadjust Newlode's location in Open\nin the proofs can look in the References.) First, A* finds a path from the start vo che\ngoal, if one exists, Second, it finds an optimal path, as long as the CostToGoal(X) esti-\nGostTogoal(X) is always less than or equal to the actual cheapest path cost from X co\nthe same heuristic function CostToGoal(X) to find optimal paths examines fewer\nApplying A* to Game-Path Planning\n3.3 The Basics of A\" for Path Planning 257\nAs stated above, the principle component of a state in the path search is /ocution.\nlocations among which to search.\nas shown in Figure 3.3.1b, The locations can be cither the center poines or the\nAgain, the locations for the search can be either the centers or che corners\nup the space into convex polygons made up of uniform terrain (Figure 3.3.1d).\ndirectly in the path search, There are several methods that can be used to parti-\none way to partition the space; each vertex is connected co che nearest visible ver-\nAfter the polygons are laid out, search locations can be chosen at\nobstacle avoidance: Place a search location just a little beyond each convex vertex\ntices, as though a rubber band conmected the stare and goal locations.\npossibly extend this method to consider terrain cost by adding these points to\nlocations for the search.\n3.3 The Basics of A\" for Path Planning 259\nFor most of these schemes, when a search is done, the start and goal locations are\nusually not members of the search locations, so they need to be added to them for the\nmany, or the search will rake too long, Another issue is that most paths found from\nThe neighbors of a state are determined by che map representation and the quantiza-\nSome schemes use only their adjacent locations as their neighbors—a\nonals are excluded—whereas in other schemes, a location's neighbors are all other\nA location's neighbors are also determined by the terrain.\nimpassable, which means it is not a neighbor to its nearby locations after all.\nWe need an efficient way to compute each location's neighbors, for the sake of\nThe cost function for the path benween nwo locations (CostFreaStart above) repre-\nAgain, these terrain costs need to be quickly looked up during the search and in\nlookup can determine whether two locations are neighbors, and if so, the cost for the\nThe estimate of the path cost to the goal is the complement to the known distance\nIf you want to guarantee thar an optimal path is found, this distance\ndistance from che given location to the goal times the minimum cerrain cost per unit\ndiscussed factors concerning the cost between neighboring nodes,\nheuristic weight of | per square sends the search in a straight line to the goal.\nure 3.3.3, the start and the goal are in costly terrain (8 per square}.\noverestimate the cost to the goal in order to get a fast search, ar the risk of getting a\nstated start and goal,\n‘The goal is typically a single location, but it does mot have ro be, For example, if a\nnew node N in the search th ietitiate 1s made of che Pe Ccalrnitee distance To eich o0-\n3.43 The Basics of A* for Path Planning 261\nA* search in clear terrain, 2: With a heuristic weight of 0, 6: With a heuristic\nguarantees thar the search figures owt both the closest goal and che best route co it\nbetween the start and goal locations; in that case, it examines every possible location",
      "keywords": [
        "Path",
        "path planning",
        "Open",
        "goal",
        "search",
        "locations",
        "location",
        "che",
        "cost",
        "state",
        "Planning Bryan Stout",
        "terrain",
        "agent",
        "Closed",
        "goal locations"
      ],
      "concepts": [
        "path",
        "location",
        "locations",
        "searches",
        "search",
        "agent",
        "planning",
        "plan",
        "costly",
        "state"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 28,
          "title": "",
          "score": 0.809,
          "base_score": 0.659,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 29,
          "title": "",
          "score": 0.71,
          "base_score": 0.56,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 31,
          "title": "",
          "score": 0.481,
          "base_score": 0.481,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 33,
          "title": "",
          "score": 0.433,
          "base_score": 0.433,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 32,
          "title": "",
          "score": 0.402,
          "base_score": 0.402,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "path",
          "locations",
          "goal",
          "search",
          "location"
        ],
        "semantic": [],
        "merged": [
          "path",
          "locations",
          "goal",
          "search",
          "location"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22386420140645574,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603368+00:00"
      }
    },
    {
      "chapter_number": 28,
      "title": "Segment 28 (pages 256-265)",
      "start_page": 256,
      "end_page": 265,
      "summary": "There is much more derail thar we could eover, because there are many different path-\nSearch in a situation in which there is no path co the goal.\n2.3 The Basics of A\" for Path Planning 263\nComputing a path fora character is more than merely an exercise in search algo-\nIt also involves creating an aeschetically pleasing path and resulting execution.\nComputed paths for characters can be improved in three main ways: making the path\nThe execution of the path\nStraight Paths\nPaths calculated by A* often look like they were constructed by someone who was\nThere are two ways to deal with this issue, The first is to promote straight paths\nwithin the A* algorithm; the second is tw clean up the mess after the path has been\nThe amazing observation is thar both paths crawel che exert same distance.\nboth paths have identical costs, A* is unable to differentiate between them and simply\nchoases the first path ic stumbles upon.\nstraight path is held within dhe cost function.\nlooking at the overall straighoness of the path, just penalizing new considerarions chat\nStraightenedd A“ path,\nA word of caution: Penalizing non-straight paths results in more work being done\nStraight Paths In a Polygonal Search Space\nuniformly spaced, as a rectangular grid is, similar paths that cost che same are quite\nTherefore, there is no need co find the straighter path.\nproblem: Since triangles can vary greatly in size and proportion, paths are more\nGreg Snook's path-finding article, “Simplified 3D Movemenc and Pachfind-\nSmooth Paths\nUnfortunately, paths computed by A® are usually riddled with sharp curns.\nyou employ a technique to make straighter paths, sharp curns still have che potential\nyour paths (simply series of poincs in space) smooth for you.\nspline does the trick because it creates a curve that nails all che control points in the\nFach time you use the Carmull-Rom formula, it gives you a point roughly ws\npoints.\npath thar A” found and create a new path.\nIf the A* path has only rwo points to begin with, simply dont apply the spline to che\npath,\nSince you have a new pach with four times the number of points, you might want\nto look inte getting rid of redundant points, Running the new path through a func-\nFigure 3.4.4 shows a typical path before and after the Catmull-Rom spline has\npath is now much smoother, In the large scale of things, this path is perfectly smooth.\nImproving the Directness of Hierarchical Paths\npathing.\nresulting paths can be less than ideal.\nIn hierarchical pathing, you parthfind in two dis-\nYou first find the large-scale path, and chen you pathfind ar the local level.\nThe idea is thar you fine find the Large-scale path\npath is found, you can then path-find between each connecting mom as you encounter\nThere is a simple, clegant way co get the ideal path, bur ic rakes roughly ewice the\nThe trick is to always path-find to the door beyond the next door.\nof the path and repeat the process.\nWhile che second half of the path is always wasted,\nshows the final path.\ntakes into acoount the furure path.\nThe following is a step-by-step sample path execu-\n1. Find the best room-to-mom path using A* on the connectivity graph of the\nThe optimized path through several rooms.\nThrow away the remaining path and pachfind to subgoal 2 (Figure 3.4.7b).\nThrow away the remaining path and pathfind to che final goal (Figure 3.4.7).\nThe resulting path is not completely straight, bur it\nFIGURE 3.4.7, The computed path durtnp various steps.\nThe computed path during various steps.\nNote that every time the character enters a new room, a new local path must be com-\ndoorway, The search inself can't be sped up, bur the new path request can be ancici-\nof pathfinding and search algorithms, sometimes it can take awhile co find that path.\neo that he'll be ready to move when the final path is available, thus stalling even\ntion before the final path is ready.\nto queue the path requests and let each unit move as its request is serviecd.\nthe group of 20 and find a path for only him.\nThe goal has always been to find good, direct paths instantancously.\nto get berter-looking paths that ultimately feel better to the player.\n[Stout] Stour, Bryan Wi, “Smart Moves: Intelligent Path-Finding,” Game Devel-",
      "keywords": [
        "path",
        "point",
        "search",
        "Artificial Intelligence",
        "che",
        "Straight Paths",
        "character",
        "Artificial Intelligence accessible",
        "che path",
        "Artificial",
        "Building Artificial Intelligence",
        "Path Planning",
        "final path",
        "Aesthetic Optimizations"
      ],
      "concepts": [
        "path",
        "points",
        "figures",
        "search",
        "searches",
        "straight",
        "cost",
        "character",
        "way",
        "ways"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 27,
          "title": "",
          "score": 0.809,
          "base_score": 0.659,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 29,
          "title": "",
          "score": 0.783,
          "base_score": 0.633,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 31,
          "title": "",
          "score": 0.418,
          "base_score": 0.418,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.403,
          "base_score": 0.403,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 62,
          "title": "",
          "score": 0.381,
          "base_score": 0.381,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "path",
          "paths",
          "straight",
          "straight paths",
          "search"
        ],
        "semantic": [],
        "merged": [
          "path",
          "paths",
          "straight",
          "straight paths",
          "search"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22420255047593932,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603411+00:00"
      }
    },
    {
      "chapter_number": 29,
      "title": "Segment 29 (pages 266-278)",
      "start_page": 266,
      "end_page": 278,
      "summary": "The first ching to notice about A* is thar it is at the mercy of the search space.\nThe solution is to optimize the search space.\nOnce the search space has been optimized, it's time to look deeper into the actual\nSearch Space Optimization\nSimplifying the Search Space\nsome other pros and cons are also discussed here.\nin a grid space blocks thar space during the A* search.\nthe search space.\n* Requires algorithmic solution for choosing path points within a polygon.\nFour options for representing the search space.\n* Simall search space representation,\n* Cant represent characters within che space.\n* Requires algorithmic solution for choosing path points within a polygon.\n* Creates minimal search space representation,\n* Cant represent characters within che space.\nthat your decision in choosing a search space representation has huge repercussions in\nHierarchical pathfinding is an extremely powerful technique char speeds up che\nOnce thar room-ro-room path is known, the pathfinder then works on\nSince a path is computed every time the character enters a new room, it’s important\nDesigning an algorithm for the heuristic cost can at times seem more like voodoo\nticular node to che goal, Here's an inceresting fact: If you always knew the true cost to\nthe goal, A* would beeline a path to che goal without wasting any search time going\nresults in faster searches with reasonable paths.\nger than it should be, ir distorts the reasoning by which nodes on the Open list arc\nSince A* always picks the node with the least total cost, this distortion pro-\nmotes nodes closer to the goal to be picked.\nsec a shape that develops from the modes explored (nodes on the Closed list).\npoine, When the heuristic uses the Euclidean distance to the goal, the search looks\ngrowth of the search using various heuristic costs while trying to overcome a large\nIt means that by overestimating the heuristic, the search\novercome large obstacles chat are between the start and goal points of the search.\nheuristic slows the search.\nlarge blocking obstacles, che overestimating heuristic is faster.\nthis point as the non-overestimating heuristic explores three times more nodes than\nUnfortunately, if the search space is not on a grid, ir's probably not possible to accu-\nThe final size of the Closed List cells how many nodes were explored: the maxi-\nnode (since Open list operations take a relatively long time as the list prows big).\nWhen tuning your heuristic, you can ery cypical searches and watch che Open and\nClosed list sizes in order to identify good heuristic values, By testing searches on your\nDecoupling Pathfinding Data from the Search Space\nA® requires a large amount of memory in order to store the progress of each search.\nIf the search space is a\nIf the search space\nisa polygonal mesh, each triangle contains pathfinding node data.\nsearch almost never covers every single node in the search space, there is mo reason to\n1,000 * 1,000 tiled world has | million pachiinding nodes just sitting there unused\nThe solution is to decouple the pathfinding node dara from the search space.\nInterestingly, by decoupling the node dara from che search space, you allow for simul-\ntaneous searches, which can now occur because multiple-node data can poine to che\nsame real node in the search space.\nDecoupling the node data from the search space requires char each search use some\nWe could simply allocate node data on che fly, bur A* can\nsearch.\nPor every node explored, the algorithm needs to save the following informa-\n. A pointer to the parent node\nThe cost to get to this node\nWhether this node is on the Open list\nWhether this node is on the Closed list\n‘The idea is ta pre-allocate a ton of these nodes (call it the mode Aané).\nWhen A* explores 2 new node for the first time, it needs to ask for a frec node\norder to personalize it for this new node.\nStoring Explared Nodes In a Master Node List\nexplored nodes in this: master node lise, This hash table allows us to instantaneously\nfind our if a particular node is on the Closed list or the Open list, Remember, since\nthe node dara memory is already allocated, the hash table contains only pointers ta\nthese nodes.\nAr this point you might ask yourself, “Where is che Closed list?” The answer is\nAll explored nodes are stored inside the master\nlem, because each node is clearly marked as whether it's on the Closed or Open liss.\nwhere does che Open list live?\nnode list also contains pointers te all the same nodes that are on the Cpen list.\nmaster node list, and sometimes it's faster using che Open list.\nWhen any given node is explored during the A* algorithm, irs possible thar che\nnode was already explored during this same search.\nwant a function that gives you back a pointer co thar particular node's dasa, whether\nits been searched before or nor.\nThis function first checks che master node list to see if the node has been explored\nIf ic has, the function simply returns a pointer co thar existing node.\nnode is not in the master node list, a free node is taken from the node bank, it is ini-\ntion completely hides the details of allocating mew modes from the node bank and\nif({ node ) {\n{ /#Mot in the Master Node List — get mew one fron the Node Bank\nThe way it achieves this goal is by putting all nodes it could search next\ning nodes to search.\nThe problem ix that the Open list tends co get big, and each time\nit goes through the A* loop, the most promising node must be extracted from che list.\nThe node to extract is che one with the lowest total cost (cost fo get to the node + Bewris-\nBc entimate of the remaining cost to the goal), As it turns out, the best way to store che\nOpen list is co keep it sorted as a priority queue.\nwith the Open list.\nExtract the node with che minimum total cost (and resort the list): Ofleg 7).\nUpeate the total cost of a node already on the Open list (and resort the listh:\nfaet, it has no interface co perform operation #3 (updating a nodes total cost and\nwith the node object, the heap object, and the STL comparison object—all imple-\nA* Using the Optimized Master Mode List and Open\nthe A* algorithm are implemented in Listing 3.5.5 using the master node lise and the\nOpen list.\nSome other small wicks are also included, such as not searching the node\ndesigners and artists to be very involved in the search space representation.\nOnce the search space is finalized, it’s important to get the pathfinder working\nWhen you are ready to optimize, start by decoupling the node memory\nfrom the search space, The next step is to implement a priority queue for the Open\nlist and a hash table for the master node/Closed list.\nListing 3.5.1: Node Object\nff starting node)\nfloat cost: ff cost to get to thie node\nStd: :vector<Node*> heap;\nclass NodeTotalGreater\n‘/pap_heap will move the node at the front to the position WN\n//Pushes the node ente the back of the vector (the heap is\nifleng through the heap and find the node to be updated",
      "keywords": [
        "Open list",
        "Optimizations Steve Rabin",
        "node",
        "search space",
        "Master Node List",
        "list",
        "search",
        "Steve Rabin Traditionally",
        "Node List",
        "che Open list",
        "Open",
        "Steve Rabin",
        "Speed Optimizations Steve",
        "search space representation",
        "Closed list"
      ],
      "concepts": [
        "node",
        "list",
        "heap",
        "search",
        "searches",
        "path",
        "optimizations",
        "optimization",
        "optimized",
        "optimize"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 28,
          "title": "",
          "score": 0.783,
          "base_score": 0.633,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 27,
          "title": "",
          "score": 0.71,
          "base_score": 0.56,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 45,
          "title": "",
          "score": 0.45,
          "base_score": 0.45,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.446,
          "base_score": 0.446,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 30,
          "title": "",
          "score": 0.44,
          "base_score": 0.44,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "node",
          "search",
          "search space",
          "list",
          "open list"
        ],
        "semantic": [],
        "merged": [
          "node",
          "search",
          "search space",
          "list",
          "open list"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.25086784875579393,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603466+00:00"
      }
    },
    {
      "chapter_number": 30,
      "title": "Segment 30 (pages 279-290)",
      "start_page": 279,
      "end_page": 290,
      "summary": "path.\nMeshes\nallowing our objects to function in a pseudo-3D environment while providing a full-\nfavigation mesh, which defines the area where objects can move.\nIn a sense, this navigation mesh object can be treated like the grid systems\nrequired berween an object and its static environment, Since the navigation mesh\nobjects need collide with only the mesh edges rather than the true scene geometry.\nProjecting a control point from the object onto the mesh, we can casily track ebject\nintersection, In cases in which higher detail is needed for collision, che mesh cells can\nLinking process dara with che cells in chis manner serves as a\nThat is, any piven point within a triangular cell\nshould be exclusive to thar cell.\nHighly detailed navigation meshes might produce che\nThe mesh should be one that contains only che cells necessary to facilitate\nTo begin, we first examine using the navigation mesh to conrol object movement in\nget some objects moving around the confines of the mesh geometry.\nWeattach objects to the mesh using a.\nThis control point may never leave the mesh, but it can move\ngers resolved on the surface of the navigation mesh, The object is then moved relative\non the mesh and we know which cell of the mesh currently contains the concral\na6 Simplified 3D Movement and Pathfinding Using Navigation Meshes 254\nI. Project the object's desired motion vector onto the plane of its current cell.\ntranslares the motion into a 2D vector along che plane of the cell.\nnew vector a motion path and represent it asa 2D line segment.\nlocation, bork translated to 2D space relative to the plane of the cell,\n2. Test the motion path against the cell’s 2D triangle edges.\nangles, we know that for our path to exit the cell, ic must intersect with exactly\nSo, we cest the 2D) line segment of the motion path\nagainst the three line segments representing the cell wiangle for any possible inter-\nadjacenc cell).\nthe motion path vector and the cell wall, adjusting che motion path ro aceount\nb) Our path intersects with a shared edge.\nnew cell and resting against its walls\nrent cell.\nWe have reached the end of our process and found che cell char hosts\nWe translate our resulting 2D motion path\nendpoint back into 3D space ta find the ruc 31D location of the control point\nObviously, for complex navigation meshes, this can be a very cumbersome process,\nFor each cell encountered, we need to project an arbitrary 3D vector onto a 3D plane.\nFrom there we translate the resulting vector along with the cell edges to 2D space,\nobjects to test or your objects plan co cravel over many cells in a given frame.\nAll cell\nnormals of the floor point up, so they meer this new requirement of our mesh, That\nis to say; all cell normals have a positive y value in our environment, Note that we do\nhot require our new savigation mesh ro be flat, we simply no longer allow cells whose\nIn addition, when we have finished the Motion Path processing along che\nnavigation mesh cells, we have a new 2D (x, z) location and the cell that contains it.\n1. Create 2 motion path consisting of the concrol point and the desired location,\n2. Test the 2D motion path against the sides of the cell criangle as before until a cell\n3. Using our new (x, 2) control point location and che plane equation of the cell it\nIn the source code, an object called Navigation Cell is used to represent a sin-\nNevigetionCel defines a single cell of the mesh with the following members:\ndetermine how a path interacts with the walls of a cell.\nmember function to classify a 21D line segment to its chee cell walls and return a\nmesh use.\n2.6 Simplified 3D Movement and Pathfinding Using Navigation Meshes 293\nENDING _CELL, if the path ends in this cell\nEXITING_CELL ff the path exits this cell\nTn the case where EXITING_CELL is the result, che cell wall traversed as well as che\ncompare any 21D pach w the cell and determine what type of intersection occurs,\nmanages the entire process, testing cach cell encountered using ClassityPathTacell().\nIt takes ina 31 concrol point, a pointer co che cell is is currently occupying, and the\ncaller the true final location of the control point and the cell the new control poine will\nNow thar we have seen how to use the navigation mesh to control object movement,\nKeep in mind that our mesh consists of linked cells, which share common edges, just\nAsa mater of fact, using polygonal meshes for search algorithms is no new feat.\nSince path-finding algorithms were designed to work over databases of linked node\nUsing our navigation meshes, we do add one small wrinkle to the path-finding-\nof each cell wall.\ntion mesh oo limit object movement in the environment.\ncostly movement on a navigation mesh, since moving down che edge of a cell cxactly\npath a: generated along cell edges and 6: through cell wall midpoint:\nIf we generated a pach on the cell edges (Fig-\nUsing the cell wall midpoints (Figure 3.6.2b), we can generate a more\nyour navigation mesh and add code to avoid paths that drag along the solid edges of\nreally done is offset our mesh vertices to create a more believable path.\nalgorithm, and the venerable A* can all be applied to the cells of our navigation mesh.\ncell to the goal.\nTo run the A* algorithm, we maintain a list of cells char need to be processed.\nthe manimesh sample code, these “Open” cells are held in an ordered list called a Naw\nCells are listed in the order of best ta worst cost in terms of the distance\nTherefore, each time we pull a cell off the heap, we know\nwe are dealing with the current “best guess\" of the cell thar will provide the best path\nTo begin pathfinding, we need to stoke the heap with the first cell, our destina-\nWe then pop and process each cell on the heap until we reach our starting posi-\nTo process a cell, examine each of its neighbors.\neach of the neighboring cells.\nthings, If the neighboring cell is not currently in the Open heap, we must sore it by its\nIf the cell is already in the\nheap, we need to see if our new score is berter than the score by which the cell is cur-\nIF che new score is an improvement, we need co move the cell up within\ncell.\nIn either case, each time a cell is added to che heap or repositioned within che\nheap, we record che identiry of the cell thar has sec the current Aniual Case.\nalgorithm in the reverse search direction, starting at the destination cell and searching\nWhen the search is complere, each cell\ncontains a link co the next cell closest to the goal along the generated path.\nAs each cell is pulled from the heap, its\nAr that point, SuilgNavigationPath() iteraces through the cells\non the path, adding their wall midpoint co the final NawigurionPanh waypoint list.\npath through polygonal objects yields a very jagged result.\nthe mesh forces our path to meander from cell to cell, making many abrupt twists and\nAny object that uses this path verbatim will look very odd\nBack when we were working out how to move objects around the mesh, we\ndefined a function, ClassifyPathToGeli(), co compare a 2D line of mation to a cell.\nThe result of dhe function told us whether che path ended within the cell, encoun-\nthe path against each cell between our currenc position and the waypoint using the\nPath Toceli() function, we can test whether any cwo points on the mesh can see each\n& The same path smoothed using line-",
      "keywords": [
        "cell",
        "navigation mesh",
        "path",
        "mesh",
        "Navigation",
        "navigation mesh cells",
        "motion path",
        "point",
        "che",
        "control point",
        "che mesh cells",
        "object",
        "Open List",
        "Navigation Meshes",
        "navigation mesh object"
      ],
      "concepts": [
        "path",
        "cell",
        "meshes",
        "mesh",
        "object",
        "listing",
        "function",
        "locations",
        "edges",
        "point"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 31,
          "title": "",
          "score": 0.637,
          "base_score": 0.487,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 45,
          "title": "",
          "score": 0.602,
          "base_score": 0.452,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 40,
          "title": "",
          "score": 0.601,
          "base_score": 0.451,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.564,
          "base_score": 0.414,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.558,
          "base_score": 0.408,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "cell",
          "mesh",
          "path",
          "navigation",
          "cells"
        ],
        "semantic": [],
        "merged": [
          "cell",
          "mesh",
          "path",
          "navigation",
          "cells"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2682555210033774,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603519+00:00"
      }
    },
    {
      "chapter_number": 31,
      "title": "Segment 31 (pages 291-298)",
      "start_page": 291,
      "end_page": 298,
      "summary": "Listing 3.6.1: Intersecting a 2D Line with a Cell of\nff walle\nff Glassify the WotionPath endpoints as being either\nff QOM_LINE, or to its LEFT_SIDE or RIGHT SIDE,\nff We do this test using the ClassifyPoint function of\nff Line2n\nff If the destination endpoint of the BotionPath\nff is Not on the right side of this wall...\nff is WOt on the lett side of this wall...\nff Check to see if we intersect the wall\nff record the link to the naxt\nfi adjacent cell for NULL 4f ae\nff The destination andpeint of the MotionPath\nff is on tha right sid#.\nff InteriorGount #9 we'll know how many walls we\nff the MotionPath was on the right side of all walls im the\nff ooll.\nff and this is cur ending cell.\nreturn (ENDING CELL};\nff create a 20 motion path from our Start and End\nff these three will hold the results of our tests against\nff the cé#1l walls\nff TestOell ds the cell we are currently examining.\nff call interact\nif (Result == NavigationGell::EXITING CELL)\nff Set if we are moving to an adjacent ¢e11 or\nff moving on.\nff point of intersection with this cell\nff and continue, wsing the new cell as our\nff test cell,\nff add same friction ta the new MotionPath\nff Although theoretically we should never\nff encounter this case, we do sometimes find\nff qureelvas directly on a vertex of the cell.\nff Incramant our path finding session ID\nff This identifies each path finding session\nff in the cells from previous sessions.\nff StartCell.\nfi} process the heap until empty, or a path is found\nff if this cell is our Starttell, we are dona\n// gut of the cells on the path\nff Step thraugh each cell linked by aur A* algorithm\nff add the link point of the cell as 4 way point\nff [the exit wall's canter)\nff just te be sure\nff no path exists between the two points provided.\nff d.@.\nff This will never happen on a contiguous mesh.\nm Open = false:\nif (m_Link[i])\nff to use.\nelse if (Caller <= m Link[1]}\nelee if (Caller == m Link[2)}\nm Open = false:\nm_ArrivalWall = 0;\nff add this cell ta the Open heap\nfi] A true m_Open means we are already in the Open\nff adjust our data.\nolse if (Caller == m_Link[1})\nelse if (Caller == m_Link[2])\nfi this cell is closed\nff Longast axie delta) between our cell canter point\nff and the goal lecation",
      "keywords": [
        "Cell",
        "Navigation Meshes",
        "path",
        "link",
        "SIDE",
        "ending cell",
        "open",
        "CELL SIDES Bide",
        "Caller",
        "Navigation",
        "wall",
        "Artificial Intelligence",
        "Heap",
        "result",
        "Movement and Pathfinding"
      ],
      "concepts": [
        "cell",
        "paths",
        "line",
        "wall",
        "endpoints",
        "meshes",
        "mesh",
        "listing",
        "points",
        "goal"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.658,
          "base_score": 0.508,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 30,
          "title": "",
          "score": 0.637,
          "base_score": 0.487,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 39,
          "title": "",
          "score": 0.529,
          "base_score": 0.379,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 41,
          "title": "",
          "score": 0.524,
          "base_score": 0.374,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 42,
          "title": "",
          "score": 0.522,
          "base_score": 0.372,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "ff",
          "cell",
          "cell ff",
          "path",
          "caller"
        ],
        "semantic": [],
        "merged": [
          "ff",
          "cell",
          "cell ff",
          "path",
          "caller"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2623543721689394,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603567+00:00"
      }
    },
    {
      "chapter_number": 32,
      "title": "Segment 32 (pages 299-307)",
      "start_page": 299,
      "end_page": 307,
      "summary": "Flocking: A Simple Technique\ncalled Soids) 2 realistic form of group behavior similar to flocks of birds, schools of\nAn cxample image of the flocking demo in action.\ncach member of a flock rest how close it is to its nearby flockmates and then adjust its\nreferred to as the “fourth rule” of flocking:\nSteer to avoid running into local obstacles or enemies.\nagent maintaining knowledge of the flock, its environment, where it's headed, or the\nFlocking is a sratefer algorithm in chat no information is maintained from update\nlar behavior using approaches besides flocking, burt it also allows che flock to react in\ncmengent behavior Noa one member of the flock knows anything abour where the flock\nis going, bur the flock moves as one mass, avoids obstackes and enemies, and keeps\nFlocking provides a powerful cool for unit motion and making more realistic environ-\n4.7 Flocking: A Simple Technique for Simulating Group Behavior 207\nwhen the flock prows large enough.\nA quick overview of the mechanics of morian for the members of a flock helps in\nOur boid in this article is che classic\ndirectly up and down through the boid).\nLocal space is defined for each boid.\nupdate cycle that will adjust the boid's local X, ¥, and Z orientations to match the\navoid cutting through a flock of hawks while doing so; however, this concept doesn't\norentation changes that a given boid wanes to make to satisfy each of the four steer-\ning behaviors are summed in a changer verter before being applied to the boid’s\nbehavior to have a proportional influence on the boid’s final motion changes while\nSeveral constraints on our boids restrict how they can move and react, Possibly che\nent the flocks and the better they are at avoiding enemies and obstacles.\nrange smaller results in more erratic flocks, groups of boids splitting off more often\nIn the real world, animals in flocks are restricted in their ability to keep\nA final constraint for the purposes of our demo is the world in which our boids\nflock.\nThe effect is char flocks that stray too clase to the edge of\nFach flock is represented by an instantiation of a CAlock object.\nserve to organize and simplify access co the members of the flock.\nSimilarly, a CBefa object represents cach member of a flock.\n(Flock Flock f through 7...\nThe Box dass defines the basic world in which our flocks will fly.\nprety small flock), and, like CAteck objects, they can be created or destroyed at any\nThe CAlock class represents a basic flock of boids and serves mostly as an organiza-\nwhen handling flocks, The class definition for CFisek can be found in Listing 3.7.1.\n3.7 Flocking: A Simple Technique for Simulating Group Behavior a4\nProcedurally, flocks are first created and then have one or more boids added to\nThe class is built to allow for real-time creation and deletion of flocks, although\nAr each update cycle, the flocks’ cFlock: :Update() method is called to updace all the\nmembers of that flock, New boids can be added at any time using GFlock::AddTo(},\ninformation about a given flock, whereas the debugging method CFlock::PrintData()\nFlocks can be created at any rime, although the demo provided creates them only\nEach flock can have any number of Cid objects as members.\nthar members of a flock have no idea what flock they're a member of.\nhard ar all to add code that would allow boids te change their loyalties if so desired\nThe CBorf class implements the true “meat” of the flocking algorithms and, as such,\nFach CBoid object is updated via its Flock: :FlockIt() method, which begins by\nbuilding a list of these flockmates that a given boid can see (based on its\nperceptten_naonge valuc)_ A list of enemies (members of ocher flocks) is also built if char\nThe method then begins to implement the steering behaviors as described previ-\nbehavior) are called to determine what the boid would like to do.\nactive, avoidance behavior of members of other flocks is modeled through a call co\nmethod, CBoid: :FrintData(), provides cchaustive information on a even boid on an\nHard reality dictates char any demonstration of flocking behavior has some limirations.\nThis article docs not implement obstacle avoidance ar all, although it does allow for\navoidance in the form of “enemy flocks.” Boids remain assigned to the flocks they start\nwhe have used flocking behavior and its variations have implemented “life clocks” on\nindividual agents, making boids thar die if they stray too far from cheir mares but that\ncan “breed” new flock members if they remain with their brothers long enough, One\ntype of flock ro “feed” on another.\n3.7 Flocking: A Simple Technique for Simulating Group Behavior 313\nff number of flocks\nff list of flocks\nStatic CFlock * ListO?Flocks [WAX FLOCKS);\nfi constructors and destructors\nIf Updates all members of a flock.\nff Adds the inditated boid to the flock.\nif Returns the # of boids in @ given flock.\ni/ Dunps all data deseribing a given flock.\n(J Removes the indicated boid fram the flock.",
      "keywords": [
        "Behavior Steven Woodcock",
        "Steven Woodcock Flocking",
        "Steven Woodcock",
        "Group Behavior Steven",
        "Simulating Group Behavior",
        "flock",
        "boid",
        "Behavior",
        "Group Behavior",
        "Simulating Group",
        "Behavior Steven",
        "Woodcock Flocking",
        "Simple Technique",
        "members",
        "Technique for Simulating"
      ],
      "concepts": [
        "flocking",
        "behavior",
        "avoid",
        "avoidance",
        "object",
        "method",
        "classes",
        "changing",
        "changes",
        "article"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 33,
          "title": "",
          "score": 0.754,
          "base_score": 0.604,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 17,
          "title": "",
          "score": 0.426,
          "base_score": 0.276,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 25,
          "title": "",
          "score": 0.402,
          "base_score": 0.402,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 27,
          "title": "",
          "score": 0.402,
          "base_score": 0.402,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 30,
          "title": "",
          "score": 0.313,
          "base_score": 0.313,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "flock",
          "flocks",
          "behavior",
          "flocking",
          "boid"
        ],
        "semantic": [],
        "merged": [
          "flock",
          "flocks",
          "behavior",
          "flocking",
          "boid"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20056355889443458,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603609+00:00"
      }
    },
    {
      "chapter_number": 33,
      "title": "Segment 33 (pages 308-321)",
      "start_page": 308,
      "end_page": 321,
      "summary": "ff Dastructer\nff public flocking methods\nwold Flockit (int flock_id, CBoid *first _boid};\nff AddToVisibletist.,\nff This visibility list is regenerated for cach menber each\nff this for speed reasons, as this allows for toast inserts\nfi) Set the “next” pointer of an individual menber.\nfy Set the “prev* pointer of an individual member.\nvector m_ang; fi orientation of member\nff tesber sees\nff enemy (i?\nff meters\nff nearest eneny\nff (if any), in\nCaoid *m_hext; ff pointer to next\nff flockmate\nff previows\nff Tlocking methods\nff Gruising.\nvector CBoid::Cruising (void);\nfi Generates a vector for a fleck bedid to maintain his\nff MatchHeading.\nff Determines which enemy flock boids a given flock boid\nff Determines which flocknates a given flock boid can see.\nff!\nff boids around to the other side of the world, so {for\nff vector.\nff CantSee. ff Deterning whether a given invoking boid can see the boid\nff if question.\nReturns the distance to the boid.\nFi Computes the rall/piteh/yaw of the flock boid basad on\nff ite latest velocity vector changes.\nTraditional logic manipulates “crisp sets.” A crisp set is a set for which a\ngiven element either belongs to the set or doesn't.\nFor example, ler’s define a crisp set\nff = (5, 10]\n(for the sake of chis example, let's assume our universe of discourse is the set of all real\nThis is a crisp set because any given number in our universe is cither in sec M or\nSay we want co make a set of all call people.\ntall, so we declare our set of tall people as “all people who are at least 7 feet tall.” We\nThe rigidiry of the crisp set works\nto whet degree) something is in a set.\nFuzzy sets, however, give us that abilicy, Using\ninclude things like “just a litde bie in the set” or “almost entirely in the set.”\nin the set.\nmeans “tall,” then 0.5 cam mean “sorr of rall” (or, “halfway in the set of tall people\"),\nFigure 3.8.2 shows our fuzzy set of all call peaple.\nCompare the graph in Figure 3.8.2 to the graph of the crisp set in Figure 3.8.1,\nThe fuzzy set in Figure 3.8,2 has slopes—5—someone who's five feet is nor tall, bur\nstarting at 5 feet 3 inches, the heights gradually start belonging to the tall set, until\nfinally, at 7 feet, they belong entirely co the call set.\nRepresentation of set “tall people,”\nNow that we understand what a fuzzy set is, let's do some operarions an it,\nFigure 3.8.3 defines another fuzzy set: a set of people “sbour 6 feet tall.”\nof the fuzzy set \"people who are tall AND are about 6 feet.”\nFIGURE 3.8.3, Representation of set “abour six feet tall,”\nFinally, Figure 3.8.6 shows an example of the NEGATION operator: the set\nsets to accomplish something.\nRepresentation of set “people whe are tall OB sre fee”\nRepresentation of set “people who are NOT rll.”\ntain a reasonable distance (two car lengths) berween his or her car and the car in front.\nThis situation is easy to model with fuzzy logic, because for cach car, there are\nThe distance between this car and the one in frone of it.\n2. The distance dele between this car and the one in front of i IF the apace berween\nthe owo cars is growing, we have a positive distance delca; if the space is shrinking,\n* Waistance deles is zero and distance is about two car lengths, maintain your cur-\n* Lf distance defta is negative and ditence is less than two car lengths, slow down.\n= Uf divance dele is peosicive and distance is greater than two car lengths, speed up,\n15 furzy sets: five cach for distance, distance dele, and the action of the car (which\nDistance Label Gormesponding Furry Set\nDistance Delta Fuzzy Set Definition\n(Growing fast Roughly equal co half the car's present speed\nTable 3.6.4, Action Furry Set Definition\npicked for afsance; Figure 3.8.11 shows an actual value for distance delta,\nQue fuzzy sets tell us thata alimance delta of 0.25 is “slightly growing” (it belongs\nto the “growing” set to a degree of about 0,3), and that a distance of 1.3 is “mostly\nsay distance ts “barely perfect” (ic belongs to the “perfect” set co a degree of about 0.1),\nand thar dinenee delta is “mostly stable\" (it belongs vo che “stable* set to a degree of\nbelongs (“sraall” and “perfect\") and the two sets to which distance deltas belongs\n* Tf distance is small and distance dlefra is growing, Maintain current speed.\n* [fF distance is perfect and distance alcita is growing, speed up.\n* If distance is perfect and distance delta is stable, maintain speed.\nspeed depends on “how true” che statement “distance is small and distance delta is\nwe know thar désene dele belongs to the “growing” set to a degree of 0.3.\n* distance is small and distance delte is growing: 0.3 degree of “trueness”\nto the car's present speed.\nSince “slow down\" to a degree of 1.0 is 0.75 of the car's\nspeed, 2596 of the slow-down rule means we should multiply the car's speed by about",
      "keywords": [
        "Fuzzy Logic",
        "distance",
        "fuzzy set",
        "car",
        "Artificial Intelligence Listing",
        "Fuzzy",
        "speed",
        "Logic",
        "distance delta",
        "Definition class Choid",
        "sets",
        "tall",
        "Fuzzy Logic Works",
        "degree",
        "crisp set"
      ],
      "concepts": [
        "distance",
        "vector",
        "sets",
        "figures",
        "speed",
        "cars",
        "car",
        "lengths",
        "void",
        "logic"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 32,
          "title": "",
          "score": 0.754,
          "base_score": 0.604,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 31,
          "title": "",
          "score": 0.485,
          "base_score": 0.485,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 5,
          "title": "",
          "score": 0.433,
          "base_score": 0.433,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 27,
          "title": "",
          "score": 0.433,
          "base_score": 0.433,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 3,
          "title": "",
          "score": 0.42,
          "base_score": 0.42,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "set",
          "distance",
          "car",
          "tall",
          "ff"
        ],
        "semantic": [],
        "merged": [
          "set",
          "distance",
          "car",
          "tall",
          "ff"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2781007975258496,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603657+00:00"
      }
    },
    {
      "chapter_number": 34,
      "title": "Segment 34 (pages 322-330)",
      "start_page": 322,
      "end_page": 330,
      "summary": "well as giving you a few ideas on where to use fuzzy logic in your games,\nemphasis on creating C++ classes and code for both fuzzy logic and neural-net Al\nAnd, in general, www.gamedev.net/ is a great site for game development.\nA Neural-Net Primer\nMewnal nets, on the other hand, are based on different models\npisces and pucting the result copecher, ‘This article is a whirlwind tour of neural nets\nNeural nets were inspired by our own brains.\n2.9 A Neural-Net Primer L 331\nupon a number af Getors, but we can model it asa cransfer function that processes the\nsummed inputs and then creates an ourput if the properties of the transfer function\nmodel, lees talk fora moment about what we can use neural nets for in video games.\nNeural nets seem to be the answer for which we all are looking.\nNeural nets model the structure of neurons in a crude way,\nneural-net technology to game Al, but once you get the hang of it, you can use it in\nNeural nets can be used for such things as:\nA neural net can be fed with infor-\nA neural net can be used by game creatures as a form of memory.\nneural net can learn through experience a set of responses; then when a new expe-\nThe output of a neural netcan be used to control the actions\nnet can then control che behavior of the creature.\nNeural nets are really pood ar “association,” which is the\nResponse mapping uses a neural\nnet at the back end of output to create another layer of indirection in the control\nwhich we can teach the net.\nHowever, using a neural net on the output, we can\nneural nets are tools that we can use in whatever way we like.\nNeural Nets 104\nIn this section, we cover the basic ccrminology and concepts used in neural-ner dis-\nThis isn't easy, since neural nets are really the work of a number of different\ntion, neural-network theory is replece with research char is redundant, meaning thar\nneural-net architectures thar have different names.\nThe output y of the neurode is based on a transfer or “activation” function, which is a\nfunction of the net input to the neurode.\nThe basic operation of the neurode is as follows: The inputs X, are each multi-\nBefore we move on, we need to talk about the inputs X., che weights w;, and their\nin the set (—, +6), However, many neural nets use simpler éfnadent values (meaning\napplied to the activation function and the output y can be computed.\nnumber of activation functions, which have different uses.\nThe equations for cach function are fairly simple, bur each is derived to model or\nThe sep function is used in a number of neural nets and models as a meuron fir-\near activation function is used when we wane che output of the neurode vo more\nThis kind of activation function is used in model-\nway to create neural nets that have non-linear responses and model non-linear\nnever be able to create a net that has non-linear response, ‘Therefore, we need the\nexponential activation function to address che non-linear problems that we wane to\nsolve with neural nets, However, we are noc locked into using the exponential fune-\nfigure illustrates a single-layer ncural nerwork The neural net in Figure 3.9.3 has a\nnumber of inputs and a number of output nodes, By convention, this is a single-layer\nnet because the input layer is not counted ules it is che only layer in che nerwark.\nshows a two-layer neural net.\nThe input layer is still not counted, and che internal\nLeper, Theoretically, chere is no limit to the number of layers a neural net can have:\n3.9 A Neural-Net Primer a5.\nA four-input, chree-newrode, single-Layer neural net.\nThe best way to create multilayer neural nets is to\nA two-layer neural network.\nThis fact is also modeled by artificial neurons in the\nasking is, “What the heck do neural nets do?” This is a good question, and it’s a hard\nmake neural nets do?\" Neural nets are basically mapping devices that help map one\nNeural nets have both short-term\nremember something it just learned, whereas LTM is the ability of a neural net to\nCan a neural net learn more information and still\nIf so, does the neural net become\nwant a neural net to have a good LTM, a good STM, be plastic (in most cases), and\nOF course, some neural ners have no analog 1 memory.\nOne of the main uses for neural nets is as memories, which can produce a\nsomehow store information in the neural net so that inputs (perfect inputs as well as\nThis means char a neural net is a kind of\nWhat neural nets do in essence is partition an n-dimensional space Into regions\nNow, as the number of input values (vectors) in the inpuc data\nset (which we eall 5) increase, it logically follows that the neural ner will have a harder\ntime separating the information, As a neural net is filled wich information, the input",
      "keywords": [
        "neural nets",
        "neural",
        "Fuzzy Logic",
        "nets",
        "Games Neural nets",
        "Logic",
        "input",
        "Neural nets model",
        "Fuzzy",
        "model",
        "function",
        "create neural nets",
        "layer",
        "game",
        "number"
      ],
      "concepts": [
        "inputs",
        "neural",
        "models",
        "signals",
        "layer",
        "times",
        "logic",
        "nets",
        "game",
        "basic"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 35,
          "title": "",
          "score": 0.798,
          "base_score": 0.648,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 24,
          "title": "",
          "score": 0.61,
          "base_score": 0.46,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 1,
          "title": "",
          "score": 0.483,
          "base_score": 0.333,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 25,
          "title": "",
          "score": 0.451,
          "base_score": 0.301,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 49,
          "title": "",
          "score": 0.304,
          "base_score": 0.304,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "neural",
          "nets",
          "neural nets",
          "net",
          "neural net"
        ],
        "semantic": [],
        "merged": [
          "neural",
          "nets",
          "neural nets",
          "net",
          "neural net"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15378370458916,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603699+00:00"
      }
    },
    {
      "chapter_number": 35,
      "title": "Segment 35 (pages 331-343)",
      "start_page": 331,
      "end_page": 343,
      "summary": "OrFing to associate n-tuple input vectors with some output set.\nmuch of a concern to proper functioning as che input set is.\nthe entire input space consist of these eighe vectors:\nset will do very well in a neural net as input vectors.\nwill potentially do poorly as inputs because v, - ¥; is non-zero of, in a binary system,\ntor systems, which can help us determine whether our input vectors will have a lot of\nDetermining orthogonality with general vector inputs is harder, bur the con-\nand sec some actual neural nets chat you will be able to use in your game's Al. We\ncover neural nets used to perform logic functions, classify inputs, and associace inputs\ninputs.\nMcCulloch-Pitts neurodes do mor have biases and have the simple activation function\nThe MP (McCulloch-Pitts) neurode functions by summing the product of che\ninputs X, and weights w, and applying the result Y, co the activation function fo(x).\nLet's take a look at some examples of MP neural nets that implement basic logic\nWe can model this table with a two-input MP neural net with weights w,=1,\nw =I, and 8=2, This neural net is shown in Figure 3.9.6a.\nAs you can see, all input\n3.8 A Neural-Net Primer 39\nInputs ¥ Output\nFor ceample, if we ory inputs X,=0, ¥,=1.\nIf we input 1 to the activation function Fag) the resule is 0, which is correct.\nanother example, if we ory inputs X,=1, X)=1, the activation will be:\nIf we input 2 to the activation function Fox), the result is 1, which is comect.\nThis isa good example of che reason a neural net needs more than one layer to solve\nXOR is cue only when che inputs are different.\nInputs\nInputs\nTo segue into the following discussions on Hrbbien and Hopfield neural nets,\nwe analyze a generic neural net structure thar illustrates a number of concepts such as\nLet's begin by making a look at Figure 3.9.9, which shows the basic neural net\nAs you can sec, it is a single-node net with three inputs, including the\nThe basic neural-net model used for discussion.\nThe truth table for logical AND using bipolar inputs and ourpuss is\nEquation 3.9.6 shows the activation function £.(x) char we will use.\nThe single-neurode net in Figure 3.9.8 will perform a classification for us, In-will\nThis is the basis of most neural nets and the rea-\ncises lead us into the learning algorithms and more complex nets thar follow.\nAll right, we are trying to find weights w; and bias b thar give use the correct\nwe can infer any relationship berween the weights and the inputs thar might help us.\nGiven the inputs X, and X, with weight: w, and w, along with Bel and bias b, we\nK,\"w, + x, + B\"b=8 (3.9.7)\nis, (M,°w, + X,*w, + b), che meurode will fire and ourput 1; otherwise, che newrode\nIn the figure, You can see chat the slope of the line is -w,/w,, and the X,\nAy = XW, fw, + (G—-b)/w, (solving in terms of X,)\nWhar we want co find are weights w, and w, and bias b so thar ir separates our\nFor example, if X, + Xy—1> 0, chen fire the neurode; else output —1.\nLet's try it with our AND inputs and see what we come up with:\nInput X]1 x2 Output (X2+X1-1)\nnet.\nbased on using the input vectors co modify the weights in a way so thar the weights\nresult in correct weights for all inputs, however, it is the basis of most learning algo-\nBefore we see the algorithm, remember thar it is for a single-neurode, single-layer\nneural net.\nInstead of using a single weight vector, a multi-\n* Input vectors are in bipolar form I = (=1,1,..-1,1) and contain k elements.\n1. Initialize al your weights to 0, and let them be contained in a vector w that has n\nsion boundary based on the changes in the input and output.\nnetwork except that now we have an algorithmic method with which to teach the net,\nWith this simple learning algorithm, we can tain a neural net (consisting of a single\nneurode) to respond ro a set of inputs and cither classify che inpurtas true or false, 1 or\ninputs.\nThis is one of the foundations for the next neural-net structure, the Hopfield\nnet.\nListing 3.9.2 on the CD contains a complete Hebbian Neural Net Simulator.\ncreate networks with up to 16 inputs and 16 neurodes (ourpues).\nthree activation functions, and you can input any kind of dara.\nstick to the step activation function, and inputs/outputs would be binary or bipolar.\nall bipolar inputs and outputs, though.\nYou input a vector x and you pet x\nback (hopefully!) A Hopfield net is shown in Figure 3.9.10, It is a single-layer net-\nwork with a number of neurodes equal to the number of inputs KM.\nthe inputs are also the outputs.\nFeedback is one of the key features of the Hopfield net and che basis for\n3.9 A Neural-Net Primer 47\nInputs ( Wag Outputs\n* Inputs x, act as outputs y,\nOutput becomes input\nHopfield network takes an input and then feeds it back, and the resuling ourput\nsequence is as follows: First, we determine the weights based on our input vectors that\nWe WANT to autoassociare, then we input a vector and see what comes out of the acti-\nThe learning algorithm for Hopfield nets is based on the Hebbian rule and is\nof input neurons, the weights are no longer a single array or vector bur a collection of\n* Input vectors are in bipolar form I = (-1,1,,..-1,1) and conrain k elements.\n* There are m input vectors, and we refer to the set as T and the je element as I...\n* Outputs are referred to as y, and there are k of them, one for each input 1.\nrithm for a single neurode except that instead of multiplying the input by the output,\nFinally, che activation function f(x) is as follows.\nThis means thar the inputs must be\nbinary, but didn't we already say that che inputs are bipolar?\nWhen the weight matrix is generated, we convert all input vectors to bipolar,\nbut for normal operation we use the binary version of the inputs, and the output of\nnet and we want it co recall these vectors:\nLet's inpur our original vectors and see the\nresults, To do this, we simply multiply the input by the matrix and chen process each\noutput value with our activation function f(x).\nI, x W = (-1,-1,0,-1) and f{(-1,-1,0,-1)) = (0,0,1,0)\nonal, As a final example, let's assume thar our input (visual, auditory, ete.) is a litle\nNow let's see what happens if we input this noisy\nvector to che Hopfield net:",
      "keywords": [
        "inputs",
        "input vectors",
        "neural net",
        "vectors",
        "Hopfield net",
        "neural",
        "Hopfield",
        "che",
        "output",
        "function",
        "activation function",
        "Hopfield neural nets",
        "weights",
        "nets",
        "che inputs"
      ],
      "concepts": [
        "vector",
        "inputs",
        "nets",
        "functioning",
        "functional",
        "output",
        "weights",
        "single",
        "logic",
        "logical"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 34,
          "title": "",
          "score": 0.798,
          "base_score": 0.648,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 24,
          "title": "",
          "score": 0.519,
          "base_score": 0.369,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 1,
          "title": "",
          "score": 0.437,
          "base_score": 0.287,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 25,
          "title": "",
          "score": 0.433,
          "base_score": 0.283,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 29,
          "title": "",
          "score": 0.332,
          "base_score": 0.332,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "inputs",
          "input",
          "net",
          "neural",
          "neural net"
        ],
        "semantic": [],
        "merged": [
          "inputs",
          "input",
          "net",
          "neural",
          "neural net"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.17560496715873303,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603740+00:00"
      }
    },
    {
      "chapter_number": 36,
      "title": "Segment 36 (pages 344-351)",
      "start_page": 344,
      "end_page": 351,
      "summary": "There are a number of functions available for submining and rendering vertices in\ncated multiple vertex functions and vendor-specific extensions.\ntoward submitting a different component of the vertex: position, color, normal, tex-\nHowever, what makes che immediate mode functions so easy to\nuse (submitting a vertex component by component) also makes them the lowest per-\nFirst, several function calls are required to render a sin-\nSecond, each function must be entered, where it then performs a small\namount of work, and then exited, The time required to enter and leave a function is\nthe function does, and represents a fixed amount of time required to use the function.\nFigure 4.0.1 shows the amount of time in CPU cycles required co submit 300 col-\nored, textured, and transformed vertices using the immediate mode functions\nFIGURE 4.0.1 CPU cyeles to submit 300 vertices (100 discrete triangles} using immediate mode,\neach function, store the data, and return.\nsubmit and render all 300 vertices.\nseen in the glVertex function char rook -38238 CPU cycles the first time it was called\noverhead by reducing the number of functions called 09 submit and render che 300\nCalling one or two functions to submit and render all 300 vertices could be\nmuch higher performing than calling 900 functions as we have just done.\nIf your vertex data is already contained ina single straccure, glinterleavedarrays can\nbe used to submit all the components of the vertex in a single finction call.\nJeavedArrays is capable of submitting a number of standard interleaved vertex suruc-\nQlinterleavedarrays only submits a pointer to the vertices to be rendered.\na single function call could be used to submit all of the dara for a single vertex.\nsubmit for rendering, This allows us to make a single function call to submit all 300\nvertices, rather than three calls per vertex (00 coral) in immediate mode.\ncates the data that was submitted and rendered by the immediate mode functions.\nFigure 4.0.2 The amount of time required ro submit and render the vertex work-\nthar was required by the immediate mode functions co submit and render che same\nFIGURE 4.0.2 Submitting vertices with gilnrerlcaved/Arrays.\nAnother altemarive vertex submission interface is the gl*Pointer functions.\nglinterleavedArrays, pointers to the vertex data are submited using che gl*Pointer\nThe submitted vertex dara is then\nand lighting, a performance boost can be had just by using che g1*Pointer functions.\nTt takes on average -51,212 CPU cycles to submit and render the 300 vertex\na a a ene ee Ee ee ee eet ae\nFIGURE 4.0.4 Vertex submission time for glDrawArrays with and without Compiled Vertex\nvertex array (CVA) function allows the application to specify a range of data in the\nrendering hardware to modify the data for faster performance, or even make a local\n‘With both the immediate mode functions and the array functions when not using\nCVA reduces this copy to a single time when the vertex array is locked.\nstore vertex data.\nproves the performance when a vertex array is submiteed and then immediately ren-\nA second area of consideration is the formar thar vertices are submitted in for render-\nIn a vertex list, chree vertices define each riangle (Figure 4.0.5a).\nvertex.\nThere are also a number of general recommendations for increasing vertex submission\n2. Pre-sorting vertex data by material, shader, and texture settings can help increase\nthe number of vertices that can be submitted and/or rendered in a single function\n3. Keep the amount of information submitted per vertex as lean as possible, Don't\nFor example, don't submit a vertex\narray functions require at least 10-50 vertices no be submitted to overcome the\nof vertex data should be submitted, These amounts vary by graphics adapter.\n3. Spending too much time getting a lot of vertex data together into a single buffer\n1. Immediate mode functions may be easy to use when getting started, bur they are\nthe lowest performing functions for submitting vertices for rendering (Figure\n2. Submit and/or render as many vertices as ts feasible in a single function call.\n3. Use Compiled Vertex Arrays (CVA) for static dara, or for data that doesn't change\n4. For the best CPU transform and lighting performance, use streamed dara formats\n6. Use indexed vertex data with discrete or strip triangles to increase the number of",
      "keywords": [
        "Artificial intelligence Amazingly",
        "Vertex",
        "Optimizing Vertex Submission",
        "Vertex Submission",
        "data",
        "vertex data",
        "functions",
        "function",
        "mode functions",
        "CPU",
        "intelligence Amazingly cnough",
        "vertices",
        "Pointer functions",
        "single function call",
        "vertex array"
      ],
      "concepts": [
        "vertex",
        "function",
        "functions",
        "triangles",
        "data",
        "performs",
        "performance",
        "cpu",
        "extensions",
        "extension"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 3,
          "title": "",
          "score": 0.449,
          "base_score": 0.449,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 47,
          "title": "",
          "score": 0.445,
          "base_score": 0.445,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 18,
          "title": "",
          "score": 0.424,
          "base_score": 0.424,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 7,
          "title": "",
          "score": 0.413,
          "base_score": 0.413,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 54,
          "title": "",
          "score": 0.379,
          "base_score": 0.379,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "vertex",
          "submit",
          "functions",
          "vertices",
          "immediate mode"
        ],
        "semantic": [],
        "merged": [
          "vertex",
          "submit",
          "functions",
          "vertices",
          "immediate mode"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.27154770791631017,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:16.603797+00:00"
      }
    },
    {
      "chapter_number": 37,
      "title": "Segment 37 (pages 352-362)",
      "start_page": 352,
      "end_page": 362,
      "summary": "Projection matrix wo achieve the depth offser effect,\nLet us first examine the effect of the standard OpenGL perspective projection matrix\nview fruscum ts centered about the z-axis in eye space (i.c., che rectangle on the near\nAfter division by w, we arrive at the following value for che projected z-coordi-\n4.1 Tweaking a Vertex's Projected Depth Value 363\n4.1.4 corresponds to a larger eye space difference far from the camera than it does near\nthe camera.\nchoose an appropriate € given an eye space offset 6and a depth value P, which collec-\nexamine the result of applying the standard projection matrix from Equation 4.1.1 ra\nDividing by m, we have the following value for the projected 2-coordinate.\nf+n\\ P(r +d)\neffective value for 6 when offsetting a polygon away from the camera.\nra | Tweaking a Vertex's Projected Depth Value 365\n/? Sand the projection matrix back to OpenGL\nThe Vector Camera\nThe vector camera is a generalized form of the matrix-based camera found in many\nthey typically hold several operations concatenated together, The vector camera uses\nonly simple vectors to describe its orientation, position, field of view, and aspect ratio.\nThe vector camera uses the same information found in matrix-based cameras.\nworld-te-camera matrix (view matrix) is broken down into four vectors.\nsee in Figure 4.2.1, a view matrix is really four vectors,\nThree vectors represent the three axes that define the camera's orientation, and\none vector represents the camera's position in the world coordinare space.\nview matrix to be compatible wich the vector camera.\nthe vector camera and a cube model.\nthe limies of the camera's view.\nThe main advantage to the vector camera is that it can operate in both local and\nworld coordinate space.\nThe camera's orientation and position vectors are stored in\nworld space; however, they can be inverse transformed into local space using the\ninverse of the model’s local-to-world matrix.\nThe view matrix is composed of four vectors.\n42 The Vector Camera i687\nUlusiration of che vector camera.\nNow that the vector camera is in local space, it can project the local space\nwork, the vector camera can now cycle through each of the local space vertices in the\neode path, With both the object and the camera in world Space, no inverse matrix\nThe vector cameras position is (0), 2,—2), and has a small rorarion about the L/-axis to\nIntroduction to the Vector Camera\n‘The vector camera uses three vectors to represent its orientation.\nvectors are parallel to the A, ¥, and 2 origin vectors, respectively, if the camera has no\npoints up, and the N vector points in the direction thac the camera is facing, Figure\n4.2.3 shows the vecuor camera with its 3D screen.\ncameras Of, Vand NV vectors, and cwo field of view parameters.\n[f the camera had no rotations or translations, the vectors would be defined as fol-\nto the near plane is 1.0; thus, starting at che camera's position, add 1.0 * N vector.\ntexture to the quad defined by the Sand J vectors, Using the world space position of\nthe camera and the world space Sand vectors, any point in wodld space can be pro-\nat the world space position of the camera, which ends at che world space position of\nIf the vertex is in view of the camera, we can calculate the\n3D point where the ray intersects the 3D sereen of the vector camera.\nThe camera vector are stored in world space; however models are typically stored in\ngeous to be able to work in local space, In order to accomplish this, the camera must\nlatecl about the object, such that the camera's new orientation and position retains che\nby the camera in world space.\n42 The Vector Camera 269\nThe camera has an assumed local-to-world already applied to che cam-\nThe newly created world-to-local matrix defines how the camera's\nAlso in Figure 4.2.3, nove the camera's world position and orientation for comparison\nThe camera, however, has been rotated and\ning the camera into local space is computationally faster than moving the local data\nOnly four transforms are required to move the camera into local\nOnce the model data and the camera data are in the same coordinate space,\nNow thar the camera is in local space, some additional optimizations are possible.\nThe vector camera is a handy way of representing the camera math for use in software\nplace and manipulate the camera, The camera's abiliey to work in che local coordinate\ning speed than they do on traditional matrix-based cameras.\nThe vector camera pro-\nThe OpenGL source code to the vector camera is included with this book.",
      "keywords": [
        "Vector Camera",
        "camera",
        "Vector",
        "space",
        "local space",
        "world space",
        "matrix",
        "Projection matrix",
        "vector cameras position",
        "world space position",
        "space Sand vectors",
        "Vector Camera David",
        "local",
        "world",
        "Summary Vertex Submission"
      ],
      "concepts": [
        "vector",
        "cameras",
        "projected",
        "value",
        "world",
        "coordinate",
        "position",
        "positioned",
        "effects",
        "techniques"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 57,
          "title": "",
          "score": 0.605,
          "base_score": 0.455,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 43,
          "title": "",
          "score": 0.582,
          "base_score": 0.582,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 38,
          "title": "",
          "score": 0.54,
          "base_score": 0.54,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.512,
          "base_score": 0.512,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 39,
          "title": "",
          "score": 0.497,
          "base_score": 0.497,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "camera",
          "vector camera",
          "vector",
          "space",
          "world"
        ],
        "semantic": [],
        "merged": [
          "camera",
          "vector camera",
          "vector",
          "space",
          "world"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24053948020628624,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603844+00:00"
      }
    },
    {
      "chapter_number": 38,
      "title": "Segment 38 (pages 363-370)",
      "start_page": 363,
      "end_page": 370,
      "summary": "Camera Control Techniques\nworld through a differenc set of eyes, the game needs to have a solid camera model.\nThis is where camera control encers the picture.\ntechniques thar can be used co develop the proper camera model for your game.\nA Basic First-Person Camera\nGiven a camera position, view direction, and up veetor, this function\nThis camera model is very easy ro implement, and\ncurrent position as well as information abour che cameras X (side), F (up), and -#\nfunction that calculates these vectors, which can be used as parameters to che glu-\nLookAt() function to produce the cameras view matrix.\nfloat cosY, cos, cosh;\n4.3 Camera Control Techniques afa\nControls\nMethods for moving the camera's orientation and position through the scene are very\nFor example, the camera position of a first-person shooter will most\nthe camera control found in Quake, which allows the user to change their view\nother camera models, For example, Super Aferiodd¢ was mostly a third-person game,\nion of the camera, and should tie directly into your game engine.\nSince you have the camera's orthogonal orientation\nScripted Camera\nSeripted cameras are a crucial part of many games, from cinematic scenes in role-play-\nMost games that use this camera\ntechnique use an animation package to script the camera, then import the animation\nB-Spline Curves\nSpline curves are a flexible, easy, and efficient solution to generating a smooth curve\ngiven a set of control points, There are several ocher curve-peneraring algorithms and\nFor each element (x, y, 2) of the control points, the Build() function is applied.\nfi For each control Point (Minus the last three)\n43 Camera Control Techniques 375\nAlso note thar the last three control pointes are nor weed, since this algorithm utilizes\nnthm so chat] can preserve the continuity of che curves.\nC: 48.000000 2.000000 -48.0KM00 // Mot drawn\nThe curve provides che\nposition of the camera, but we also need a target and an up vector.\ncurves, cach control point should be associated with a target position.\ncamera will continue to focus on the target as it moves along the curve.\neRCOLNEers a new Larger position, the camera control logic can simply interpolate\nwould be ta use ewo B-Spline curves, one for camera position and the other for target\nGiven a set of control points, the game engine can either compuce the entire curve\nduring one frame, or calculate only the needed portions of the curve.\nB-Splines only require four control points for any subsection of a\ncurve, So, by continuously cycling in a new control point, whether it is a random\npoint ora carefully calculated one, a smooth curve of infinite length can be created.\nHence, moving the camera across the curve incrementally is noc a suffi-\nThe camera would visibly change velocicy between conerol points, and\nlation, you need co calculate the distance between cach subdivision at dhe curve level.\nAnother useful trick for using B-Splincs is to utilize the tangents of the curve to\nforce the orientation of the camera to the curve.\nswberacting each curve point from the one preceding it.\nsolution is to calculate the derivative of the B-Spline basis function.\nOne pitfall | should mention is normal calculations, Finding a normal co a curve\nmals at any given point of a curve, and the problem is to find the one thar produces\ncontrol point, and interpolated to the next natural (or specified) normal as | subdi-\nSince I'm on the topic of B-Splines, I should mention a variation of curve gcnicration\nfunctions called Carmull-Rom curves.\ncurves is thar Catmull-Rom curves go through the control points, whereas B-Splines\nthe curve pass through the control points.\n4.3 Camera Control Techniques STT\n-—| fF =] O\nCamera Tricks\nThis snippet of code will cause the camera\nDamping is the key to making camera controls look and feel right.\nfunction will return a vector that approaches the target vector such that as it reaches\nfriction to the camera's position will produce the desired result, and physics equations\nmore useful in situations where the camera is scripted or affected by fixed animations.\nvectors disp; ff Displacement\nThird-Person Camera\nOn the topic of cameras, | also need to mention the valuable third-person camera, As\nan example, I have added a spring-based third-person camera model co my sample\nthe first-person camera model described earlier.\nHon that is a given distance behind the actor I use the spring damping function to\ngive the camera a realistic feel,",
      "keywords": [
        "Techniques Dante Treglia",
        "Camera Control Techniques",
        "Control Techniques Dante",
        "Camera",
        "Camera Control",
        "Dante Treglia",
        "Control",
        "control points",
        "camera position",
        "curve",
        "position",
        "Control Techniques",
        "target position",
        "Camera Seripted cameras",
        "camera model"
      ],
      "concepts": [
        "curves",
        "camera",
        "control",
        "controllers",
        "function",
        "functions",
        "vectors",
        "techniques",
        "float",
        "point"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 37,
          "title": "",
          "score": 0.54,
          "base_score": 0.54,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 43,
          "title": "",
          "score": 0.464,
          "base_score": 0.464,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 39,
          "title": "",
          "score": 0.404,
          "base_score": 0.404,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 61,
          "title": "",
          "score": 0.403,
          "base_score": 0.403,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 16,
          "title": "",
          "score": 0.352,
          "base_score": 0.352,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "camera",
          "control",
          "curve",
          "camera control",
          "curves"
        ],
        "semantic": [],
        "merged": [
          "camera",
          "control",
          "curve",
          "camera control",
          "curves"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24079314185855427,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:16.603888+00:00"
      }
    },
    {
      "chapter_number": 39,
      "title": "Segment 39 (pages 371-380)",
      "start_page": 371,
      "end_page": 380,
      "summary": "float sin’ = sinf(yaw / 2.0F):\nfloat cosh = cosf(roll / 2.0F);\ncylinder potentially intersects the view frustum (and thus whether the objece is visible),\nGiven a cylinder described by a radius and two point in space representing\nthe centers of the end faces, we individually move each of che six planes af the view\nfrustum outward by the cylinder's effective radius with respect to that plane.\ncylinder is perpendicular to the plane) to the actual radius (when the cylinder is par-\nthe negative side of any one of the six planes bounding the view frustum.\ntangular bounding box could easily straddle one of the view frustum planes far out-\nside the view frustum, but the box tests would rerurn positive.\n44 A Fast Cylinder-Frustum Intersection Test 381\nAt a distance / from the camera, a plane perpendicular to the\nfrustum planes are given, in eye space coordinates, by the following formulas:\nView Fruatum Plane Normals\nPlane Normal\nLet us call the two endpoints of the cylinder's axis P, and P., and the cylinder's radius\nNow we select one of the six view frustum planes, label irs normal\nN, and call the angle between the normal and the cylinders axis of.\nradius r’of the cylinder with respect to this plane is given by the simple formula\nFor cach view frustum plane, Equation 4.4.5 can then be evaluated through\nthe actual radius may be desirable in the case when many cylinder visibility tests are co\nThe intersection test executes by visiting each of the six view fruscum planes individ-\n44 A Fast Cylinder-Frustum Intersection Test amd\nFor each plane, we first cal-\nculare the effective radius r'of the cylinder and move the plane outward by char dis-\nAfter adjusting a plane, we next test the ewo endpoints P, and P, to determine on\nwhich side of the plane they lie.\ninto the plane equarion\nwhere d=” —r'for the near plane, d = —f— 7\" for the far plane, and d= <r'for any of\nthe four side planes.\nside of the plane the point F lies.\nSince the plane's normal points toward the interior\nof the view frustum, any point lying on the negative side of the plane lies outside the\nThus, if both P, and P, lie on the negative side of the plane, then we\ninterior to the view frustum must lie on the positive side of all six planes, so whenever\neach plane has been expanded by che associared effective radius.\nplane and replace the exterior endpoint with it.\nthe cylinder thar we know to lie outside the view frustum.\nIf we visit all six planes of the view frustum and never encounter the case that\nboth endpoinrs lie on the negative side of a plane, then the cylinder is ar least partially\nplane that we visit.\npositive side of the final plane, we know thar part of the cylinder intersects the view\n44 A Fast Cylinder-Frustum Intersection Test 365\nThe sample code in Listing 4.4.1 implements the cylinder visibility test.\naspect ratio, near plane distance, and far plane distance, The components of the nor-\nradius intersects the view frustum and returns true or false.\nff Near and far plane distances\nFrustum::Frustua(tloat 1, float a, float n, float f)\ni! Précaleulate side plane normal components\nbool Frustum; iCylindervisible(vectora pl, vectord p2, float radius) const\nfloat dat) = -pl.z}\nfloat dot2 = -p2.z;\nif Galculate affective radius for near and far planes\nfloat effectiveRadius = radius * sqrt(1.0F - dp.2z * dp.z);\nif Test endpoints against adjusted near plane\nfloat t = (d + pi.z}) / dp.z;\nTloat t = {di + pi.z) f dp.zz\ni! Test endpoints against adjusted far plane\nii pl was outside, so move it to the far plane\nfloat t = (d + pi.z) J (pa.z = pi.z);\npl-x == tf * (p2.e - pi.x);\npl.z = -d;\n44° A Fast Cylinder-Frustum Intersection Test\nff p2 was outside, so move it to the far plane\nfloat t = (d + pi-z) / (p2.z - pi.z);\nPe.Ww = play - t* (p2.y = pl.yh;\nff Galculate effective radius for this plane\ni! Test endpoints against adjusted plane\nPl.w += t ™ (pe.u - pi-x);\nif Pe was outside, so move it to the plane\nPi.y + £ * (pe.y + pl-y}i\np2.y = pl-y + t * (pz.y - pi.yt;\np2.z = pl.t + t * (pe.z - pl.zy}:\nif Visit top side plane next\nPe-x = pl.x + t * (p2.x - pix};\ndot) = ny * pi.y - mz * pl.z;",
      "keywords": [
        "view frustum",
        "plane",
        "Quatemlons Asa final",
        "Quatemlons Asa",
        "view frustum planes",
        "float",
        "view",
        "cylinder",
        "frustum",
        "plane float",
        "Intersection Test",
        "Camera Contral Techniques",
        "side plane",
        "frustum planes",
        "radius"
      ],
      "concepts": [
        "float",
        "planes",
        "dot",
        "dots",
        "view",
        "radius",
        "cylinder",
        "frustum",
        "tested",
        "returns"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 43,
          "title": "",
          "score": 0.617,
          "base_score": 0.617,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.592,
          "base_score": 0.442,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.578,
          "base_score": 0.428,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 40,
          "title": "",
          "score": 0.564,
          "base_score": 0.414,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 41,
          "title": "",
          "score": 0.549,
          "base_score": 0.399,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "plane",
          "cylinder",
          "frustum",
          "view frustum",
          "pl"
        ],
        "semantic": [],
        "merged": [
          "plane",
          "cylinder",
          "frustum",
          "view frustum",
          "pl"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23162187794742428,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603934+00:00"
      }
    },
    {
      "chapter_number": 40,
      "title": "Segment 40 (pages 381-388)",
      "start_page": 381,
      "end_page": 388,
      "summary": "equations to determine collision points between one criangle and che plane of the\nother mangle, then determines whether those collision points lic inside che oppo-\nBounding Sphere Collision Detection\nCollision detection is best performed in hierarchical steps: Object Bounding Sphere\nbouncing spheres is very simple; all you need is to find che center of the object, chen\ncompute the maximum distance between the center and a vertex in the object.\nFirst, you'll need to determine the center point\nbetween diagonally opposite vertices (see Figure 4.5.1), To compute the bounding\nyou need to find the minimum and maximum x, y, and z values for the entire\nNow find the center point, given by averaging the minimum and maximum\npoints on the bounding box (these are indicated by paints A and G}.\nI? Widpeint formula; Given A{xi,yi,21) and B(x2,y2,22),\nobject's vertices and finding the distance berween the center point and the cument\nbounding boxes, bounding spheres, and center points for each object and polygon,\nTriangle-to-Triangle Collision Detection\ntriangles.\nWe need to begin by finding the plane equation of one of the triangles.\n‘if given a triangle trit with vertices a, b and ¢,\nff create vectors vi, v2 (tril.b = trii.a,\nff if point P(xd,y0,20) is a point on the polygen\nLine-Plane Intersection\ndetermine at what point that line collides with sriangfeJ's plane.\nIf the collision point\nWe solve this line-plane intersection using parametric equations from caleulus\nif = (tri1->pA*a->x) + (tril-+pe\"a->y) + (trii->plra->z);\n17 = (tril->pA‘b->x) + (trit-spa“b->y) + (trii->pt*b->z);\nff to get the point of intersection from line to plane\n‘This will give you the final point where the line intersects the plane (see Figure\nthe intersection point is to plug x and z of either point a or b inco the plane equation\nThe intersection point would then be (a.x, solved.y,\ntriangle against one of the coordinate planes, depending upon triangle orientation.\nmight lose the y coordinate and keep the x and 2 coordinates.\nnot be a “straight line” (such as a vertical triangle losing the y coordinate).\ncheck and see if the final intersection point, when flattened in a similar manner, lies\nFIGURE 4.5.4 Determining collision points.\nPoint-in-Triangle Test\nwhether the flattened intersection point lies inside the flawened rriangle or not.\nin this discussion we will seill refer wo the x and y coordinates of the flattened points.\nThe easiest point to find char fits this description is the center of the triangle,\ncomputed as the average of irs vertices: ((xexl+x2)/2, (y0+-yI+72)/2)), Now thar we\nknow what direction the inside of the triangle is, we need to see if our point is on the\n“inside” side of the lines thar are made by each pair of vertices (see Figure 4.5.6).\nand you can find # by using the computed slope and 3 known point on the line.\nwhether che factened intersection point lies on the side of the line that is the inside of\nthe triangle.\ntened intersection poin into the line yen, you will ger che y value of the line ar x.\nNext, you determine whether the center point we computed earlier is “above” or\n“below\" the line by checking y values.\nintersection point has to have a» value that is in che same “direction” from the line as\nthe center point.\nIf it docs, the intersection point is “inside” the triangle with respect to\nthe point is certainly inside the triangle.",
      "keywords": [
        "Collision Detection",
        "Sphere Collision Detection",
        "Bounding Sphere",
        "Bounding Sphere Collision",
        "Object Bounding Sphere",
        "Collision Detection Kevin",
        "Bounding",
        "Polygon Bounding Sphere",
        "Detection Kevin Kaiser",
        "point",
        "Fast Gylinder-Frustum Intersection",
        "Collision",
        "collision points",
        "intersection point",
        "Detection"
      ],
      "concepts": [
        "triangle",
        "points",
        "line",
        "intersection",
        "intersecting",
        "collision",
        "collisions",
        "bounding",
        "planes",
        "vertices"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 41,
          "title": "",
          "score": 0.72,
          "base_score": 0.57,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 45,
          "title": "",
          "score": 0.677,
          "base_score": 0.527,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 30,
          "title": "",
          "score": 0.601,
          "base_score": 0.451,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 46,
          "title": "",
          "score": 0.598,
          "base_score": 0.448,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 39,
          "title": "",
          "score": 0.564,
          "base_score": 0.414,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "collision",
          "point",
          "intersection",
          "triangle",
          "bounding"
        ],
        "semantic": [],
        "merged": [
          "collision",
          "point",
          "intersection",
          "triangle",
          "bounding"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.233218995723345,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.603998+00:00"
      }
    },
    {
      "chapter_number": 41,
      "title": "Segment 41 (pages 389-403)",
      "start_page": 389,
      "end_page": 403,
      "summary": "first determine on which side of the vertical line the inside poine is, Then, check the x\naf = tri->b.x:\nff flattened triangle; you cannot graph vertical lines in 20\nff the flattened intersection point lias on the inside of the\nff triangle with respect ta the vertical Line segment,\nff find average point of triangle (point is guarantesd\nff See whether (center_x,center_y} is above or below the line,\nff then set direction to UP if the point is above or DOWH if the\nff point is below the Line\nff @->b\ninside++; ff (line a8 above point)\naf (D4 == ((m2*a4)+bb2)) ff Ba greater than y to be insida\nif (b4 <= ((m3*a4)4bb3)} // ba less than y to be inside\ningide++: ff (1in@ is above point}\ninsicde++: ff (Line 48 below point)\nff Sorell thru 3 line segments of the other triangle\nff First iteration (a,b)\np=Line_plane_collision((vertex_ptr)&tri2.a, (vertex_ptrjatriz.b,\ntop = Point_inside_triangle((triangle_ptr)&tri1, (vertex _ptr)ép,\nff Point seeds to be checked to see if it lies between the two\nif ((tri2.a.x = tri2.b.x)Ab(triz.a.z <= tri2.b.z)) {\nff Now check for point on line segment\nif (point_inbetween vertices ((vertex_ptr)&triz.b,\ntemp = point_inside_triangle( (triangle _ptr)a&tril, (vertex_ptrjép,\nff First check for the special case of vertical line segments\nMulti-Resolution Maps for\narc of non-zero size, they may overlap into adjacent map squares.\nfor others after it in the linked list associated with its own map square, and also map\nyour map squares.\nIF you have large game objects, you could make the map squares\nIf you make the map squares smaller than some game objects, then there is a dan-\nmap squares to never check each other, though physically they do touch.\nFIGURE 4.6.1 Object 2 checks against Object 3 and map squares A, B, and C.\nmap squares that the object touches.\nMulti-Resolution Maps\nThe map square\nEach object resides in the map where the squares are the smmallest possi-\nyou not only check against your own map square but also che map squares in the\nlower-resolution maps (larger map squares) chat you touch.\nIt is simplest to have all resolutions of map squares, down to one map square cov-\nThe only cxura cost for not cutting off che map resolutions is\ndisallow larger objects, or do you just put them in the lowest-resolution map squares,\ning them to reside in the lowest-resolution map, assuming that the objects are only\ntune the map square size co suit the largest object available in the game.\nFIGURE 4.6.3 Multiple simple maps; cach object resides im che finest resolution map\nff This ie your gane object base class\nJf the map squares\nff And this is the map square that this abject is hanping off,\nff The reselution of the map the object is sitting in\nff Take the object aut of the map's linked list\nff 00 on€ resolution of map, used by ProcessCollisions( }\n4.8 Multi-Resolution Maps for Interaction Detection 40T\njj The map.\nff for efficiency’s sake, the map dimensions etc are constants, you\nfidefine MAP_HE RES SHIFT iB}\nfo and the mumber of map squares at tha lowest ras\nif snallest size of a map square\nfdefine MAP SMALLEST SQUARE SIZE_SHIFT (a)\nPietine MAP SMALLEST SQUARE SIZE {1 oc |\nMAP_SMALLEST_BOUARE SIZE SHIFT)\nfdefine MAP_BEGGEST SQUARE SIZE_SHIFT (WAP SMALLEST SQUARE SIZE SHIFT +\nMAP HI RES SHEFT \\\n- MAP_LO AES SHIFT)\nfdetine MAP_SIZE (1 << \\\n(MAP_SWALLEST SQUARE SIZE SHIFT + MAP_HI_RES SHIFT) )\nif The map,\niia array of pointers th the differeat resalutions of Tap. GamaGbject **Who[MAP_HI_RES SHIFT - MAP_LO AES SHIFT + 1];\nMap);\nff fills in the object's map-related information given its\n{/ Q@iven 4&4 map square at a certain resolution, returns the\nff Lowest res\nff We loop through several resolutions of map, starting with\nff First start with the objects in my aap square\nPracessOngLevel(my_map, naplwho, walker, CUrrenk_res);\nwhile (map_who); // until we're at the lowest resolution.\nff 06 all tha objects in the first list presented\nff Work gut if you can go to the adjacent map #quaras\nint current_offset = map eg - hy_map-Anolcurrént_ras_ shift —\n4.6 WMulti-Resolution Maps for Interaction Detection\nfor (walker = map_sq[current_ras_size + 1]; walker;\n\"Gane object couldn't find itself in map\");\nWhojres - MAP_LORES SHIFT] = MULL;\nMap: : lap i }\nvoid Map: iReset()\nff IT won't check.\nfor (int ras = MAP_LOORES SHIFT; res <= MAP_HT_RES SHIFT; res++}\nWoe[res - MAP LO RES SHIFT] = NULL;\nTor (ant res = MAP LO AES SHIFT; res <= MAP _HI RES SHIFT; res++}\nWhol Pes - MAP LO RES SHIFT) = new GameQbject*\nif (IWhe[res - MAP_LO_RES SHIFT))\nWholres - MAP_LO RES SHIFTJ[eq] - NULL:\nff fills in the object's map-related information piven its\n2 = O.f BE pos.e = MAP SIZE):\nASsertipos.y >3 0.7 £8 pos.y < MAP SIZE};\n4.6 Multi-Resolution Maps for Interaction Detection 411\nft Find which resolution level of the map the object showld\nobj .Maphes = MAP_HI RES SHIFT;\nfor (int map size = MAP SMALLEST SQUARE SIZE; map size <=\n\"object too large for map - soné collisions nay not be\nint which_level = obj.Mapaes - MAP_LO_ RES SHIFT;\nwhich why += ix >> (MAP_BIGGEST_SQUARE SIZE SHIFT - which level):\nwhich_wha += {iy >> (MAP_BIGGEST_SQUARE_SIZE_SHIFT — 5\nif Insert tha object inte the map square\nGaneObject **Map:;GetLowerWapSquare(Gamedbject **current, int who res)\nff Top of map?\nif (who res == MAP_LO_AES SHIFT) return MULL;\nint current_otfset = ¢urrent = Wholwho_res - MAP_LO RES SHIFT];\nff Extract tha y part af the current offset.\nreturn Wholwho_res - MAP_LO RES SHIFT - 1] + new offset;",
      "keywords": [
        "map",
        "RES SHIFT",
        "SQUARE SIZE SHIFT",
        "map squares",
        "RES",
        "SHIFT",
        "MAP SMALLEST SQUARE",
        "square size",
        "SMALLEST SQUARE SIZE",
        "size",
        "MAP SIZE",
        "SIZE SHIFT",
        "line",
        "map square size",
        "square"
      ],
      "concepts": [
        "maps",
        "map",
        "object",
        "sizes",
        "shift",
        "square",
        "res",
        "walker",
        "abs",
        "collision"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 40,
          "title": "",
          "score": 0.72,
          "base_score": 0.57,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.565,
          "base_score": 0.415,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 51,
          "title": "",
          "score": 0.562,
          "base_score": 0.412,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 39,
          "title": "",
          "score": 0.549,
          "base_score": 0.399,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 31,
          "title": "",
          "score": 0.524,
          "base_score": 0.374,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "map",
          "shift",
          "res",
          "map squares",
          "square"
        ],
        "semantic": [],
        "merged": [
          "map",
          "shift",
          "res",
          "map squares",
          "square"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20334717147491524,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.604042+00:00"
      }
    },
    {
      "chapter_number": 42,
      "title": "Segment 42 (pages 404-412)",
      "start_page": 404,
      "end_page": 412,
      "summary": "sector\nberween the edges of a 2D quad (or sector).\nber, where O indicares that the point lies on the leading edge, and where 1 indicates\n20) sector an object or point is.\ntrack, Using the sector data and a vehicle's AZ position within a sector, the Al system\ncould use chis algorithm to determine hew far into the current sector the vehicle is, or\npoint lies berween the leading and trailing edges.\nvalues for several points within a sector.\nAs Figure 4.7_2 shows, all points lying on the leading edge produce a value of 0,\nand all points lying on the trailing edge produce a value of 1.\n4.7 Computing the Distance inte a Sector 4413\nFigure 4.7.3 shows that, regardless of the sector's shape, the value\nFIGURE 4.7.3 Example convex sector shapes showing comesponding scalar values.\nEQUATION 4.7.1 Equation for computing a distance value across a sector,\nPis the point of interest within the sector.\n* is any point on the Leading Edge.\nis the inward-pointing unit normal of the Leading Edge.\nners, Equation 4.7.1 can be used to compute both the distance from leading edge to\ntrailing edge, as well as the distance laterally, This is because #, lies on both the lead-\n- It produces 0 if P lies on che leading edge.\ndepending on how far into the sector P lies.\n4.7 Computing the Distance inte a Sector 415\ntors vertices, and N, and My can easily be computed from che sector's vertices\npoint lies outside of the sector, the result might not be a value between 0 and 1,\nThe sectors are constructed to completely contain the crack so that the vehicle\nAr game initialization time, each sector's inward-pointing unit\nnormal for both irs leading edge and trailing edge is computed.\ntrailing edge normal is equal to its neighboring sector's negated leading edge normal.\nberween cach sector's leading and railing edges.\nAs with the other sector data, we pre-compute sfor each sector and store it in the\n} Sector_t;\n47 Computing the Distance Inte a Sector 417\nSector_t \"pSector; fi Points to the sector the\npSecter is pointed to the sector containing its origin.\nThis initial sector may be four\nby either scanning the entire list of sectors for the one sector containing the vehicle\norigin point, or by storing the initial sectors as part of the starting line data.\nOnce the race begins, we need to track which sectors the vehicles are in, since\nEquation 4.7.1 requires that che point lic within a sector.\nmove the vehicle, we use a simple point-in-sector test to see if the vehicle is still within\nsector.\nIf nor, then the vehicle is either im the next sector or the Previous sector, and\nward sectors first.\nIf the sector is still not found, this could be considered\nEquation 4.7.1 te determine how far ine its sector each vehicle is:\nSector_t *pSector j {\nff Compute vector from point on Leading Edge to P:\nif Compute vector from point on Trailing Edge to FP:\n/f Conpute unit distance into sector and return it:\nff Campute how far vehicle is inte its sector:\nff distance into our current sector:\n4.7 Computing the Distance Inte a Sector 4419\nthe leading edge of the firsc sector of the crack, returns a value of | if the vehicle is on\nthe trailing edge of the lasr sector of the crack, and returns an interpolared value\nwith leading/trailing sector edges, we can interpolate the lighting parameters as the\nConsider a sector enclosing a section of a track that begins in che sum at the sec-\ntors leading edge, and ends in a dark cave at the sector's trailing edge as in Figure\nWe can store the ambient RGB light color at each adjoining sector edge lile so:\ni} Ambient light at Leading Edge\nff Ambient light at Trailing Edge\n} Sector_t;\nthe light level when the vehicle crosses into a different sector.\nmentation, we simply store both leading and wailing ambient values with each sector,\n‘i Conpute how Tar vehicle is inte its sector:\nAs the vehicle drives through the sector, the ambient\npolate any parameter that's assoctated with a sector edge.",
      "keywords": [
        "sector Steven Ranck",
        "leading edge",
        "trailing edge",
        "sector",
        "edge",
        "Steven Ranck",
        "vehicle",
        "leading",
        "leading edge normal",
        "trailing sector edges",
        "che leading edge",
        "trailing edge normal",
        "Trailing Edge FIGURE",
        "trailing",
        "Distance"
      ],
      "concepts": [
        "sector",
        "edges",
        "floating",
        "light",
        "point",
        "vehicle",
        "ambient",
        "distance",
        "computing",
        "computationally"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.529,
          "base_score": 0.379,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 31,
          "title": "",
          "score": 0.522,
          "base_score": 0.372,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.521,
          "base_score": 0.371,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 41,
          "title": "",
          "score": 0.52,
          "base_score": 0.37,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 46,
          "title": "",
          "score": 0.509,
          "base_score": 0.359,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "sector",
          "leading",
          "edge",
          "leading edge",
          "trailing"
        ],
        "semantic": [],
        "merged": [
          "sector",
          "leading",
          "edge",
          "leading edge",
          "trailing"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2296893390799679,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.604090+00:00"
      }
    },
    {
      "chapter_number": 43,
      "title": "Segment 43 (pages 413-421)",
      "start_page": 413,
      "end_page": 421,
      "summary": "field of view culling.\nplanes and the viewing angle (see Figure 4.9.2).\nthe bounding sphere coneer point into view space (relacive to the camera) and check\nagainst the left, righe, top, and bottom clip planes.\nThe clip planes for the field of view\nBecause these clip planes are in\nview space, we can simplify the clipping test.\nDistanceFromGlipPlane = (x \" Plane.a) + (z \" Plane.c);\nDistancarronGliprlane = (y * Plane.b) + (z * Flane.c};\nBack, cp plane\nagainst all the clip planes, we can find out if the mesh lies within the field of view: this\nagainst the clip planes can be changed to mach the geomerric data; for example, a\nThe front and back planes are\n‘As you see, we can use the plane equation to describe the boundaries of the view\ning frustum, and by first transforming the bounding sphere center point into view\nspace we can simplify che point-to-plane test.\nocclusions clip planes in the same way as for field of view culling, except this time we\nThe front plane of the occlusion won't always be perpendicular with the front clip\nFIGURE 4.8.3 A four-sided occlusion is described with four planes, front, left, tight, top and\n(remember in view space this is 0.0.0) and cwo points along the edge of the occlusion\nthe points used to generate the planes.\nWe will need to test if an object's mesh falls inside the field of view before testing\n# value (the value closest to the front clip plane) in view space for each occlusion, and\nIf the bounding sphere of the mesh overlaps the edge of an occlusion, we could\nful in describing its area, bux che bounding sphere can be tested againsc a plane much\nencire viewing frustum, we can move the back clip plane closer.\nListing 4.8.1: Field of View Culling Code\n}PLANE;\nPLANE g FOVLeftPlane;\nPLANE 9 FOVRightPlane;\nPLANE 9 FOVTopPlane;\nPLANE g FOVEot tom?\nVECTOR *pP2 , PLANE \"pP lane}\npPlane->d = -( VW2.x * pPO->x + V2.y \" pPO->y + ve.z #\nf/This function calculates the planes for describing the view\nif) Galevlate left plane using 3 points\nPO.y = O.0f;\nPO.z = O.0f;\nPi.y = Backlip = { (float)tan{ Angle * O.5T ) 1;\nP2.4 = Pi.x;\nCalculate top plane using 3 points\nPO.y = O.0F;\nPi.x = -BackOlip \" [ (float)tani Angla * O.5f j / Aspect):\nPi.y = BackOlip = ( (Tloat}tan( Angle * O.5f } 4;\nP2.z = -Fi.x;\nPO.y = O.0f;\nPO.z = O.0f;\nPi.x = BackClip * { (float}tan( Angle * O.5f } / Aspect};\nPo.\" = -Pi.z;\npviewPos->z = g ViewTransform, 13 * pagpherePos->x +\nBehind front clip plane?\nBeyand the back clip plane?\nreturn FALSE;\nfi Test against Left clip plane\nreturn FALSE:\nff Test against right clip plane\nreturn FALSE;\nff Test against top clip plane\nDist = ( p¥iewPos->y * g FOVTopPlane.b ) +\nreturn FALSE;\nfi Test against bottem plane\nDist = [ p¥iewPos->y * g_FOVeottemPlane.b | +\nreturn FALSE;\nPLANE FrantPlane;\nPLANE FirstPlane;\nPLANE ThirdPlane;\nPLANE FourthPlane;",
      "keywords": [
        "Culling Tim Round",
        "Tim Round Occlusion",
        "Occlusion Culling Tim",
        "Round Occlusion culling",
        "Occlusion Culling",
        "clip planes",
        "Object Occlusion Culling",
        "plane",
        "Tim Round",
        "Occlusion",
        "view",
        "Culling",
        "field of view",
        "front clip plane",
        "view culling"
      ],
      "concepts": [
        "plane",
        "occlusion",
        "occlusions",
        "vector",
        "view",
        "culling",
        "mesh",
        "meshes",
        "tested",
        "space"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 39,
          "title": "",
          "score": 0.617,
          "base_score": 0.617,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 37,
          "title": "",
          "score": 0.582,
          "base_score": 0.582,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.527,
          "base_score": 0.527,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 40,
          "title": "",
          "score": 0.495,
          "base_score": 0.495,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 38,
          "title": "",
          "score": 0.464,
          "base_score": 0.464,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "plane",
          "clip",
          "occlusion",
          "view",
          "planes"
        ],
        "semantic": [],
        "merged": [
          "plane",
          "clip",
          "occlusion",
          "view",
          "planes"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2340253282770837,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:16.604137+00:00"
      }
    },
    {
      "chapter_number": 44,
      "title": "Segment 44 (pages 422-430)",
      "start_page": 422,
      "end_page": 430,
      "summary": "WECTOA PO , Pi , P2 , Po , Camera:\nPOcclusdon-*WinZ = P2,z;\nfi PS.z = pOcelusion->Minz)\na7{ ¢ | p¥iewPos->x * pOcclusion-*FrontPlane.aj 4\n(pViewPos->y \" pOcclusion-=FrontPlane.b) 4\n(pViewPos-z \" pOcclusion-=FrontPlane.c) 4\naft { ( pviewPos->x * pOcelusion->FirstPlane.aj +\n(pviewPos->z * pOeelusian->FirstPlane.c) +\npOcelusion-*FirstPlane.d) > BSphereRadius |\n(p¥iewPos-2z * pOcelusion->ThirdPlane.c} +\nObjects and characters are represented in computer graphics as geometric models.\nModels can be created ar different levels of detail (LODs), with more polygons and\nperformance and visual quality, Drawing fewer polygons when objects are far away\nHaving a more detailed model for use when an object is close to the camera improves\n‘To implement LOD rendering, multiple models are created at different levels of\nderail, and the model to be rendered is chosen, each frame based on distance from he\nnumber of polygons as the preceding level, The models are created to reduce “pop:\nping” as much as possible—when the character or object switches from one level of\nNote thar for objects or characters that stay a relatively constant distance from the\ncamera (such as the hero character in a thircl-person game), level of derail selection is\nThe simplest way to select which level of detail to render is to apply a threshold to the\ndistance of the object from the camera.\n300-1500 unis, and the low detail model when the object is further than 1500 units\nFirst, it doesn’t account for che field of view of the camera.\nobject may appear large on screen, and a derailed model may be appropriate.\nlarly, an object may be relarively close co che camera, bur if the field of view is very\nFigure 4.9.1 shows thar the same object at the same distance\nfrom the camera, we really want to use the projected size of the object on the screen as\nfrom the camera, but che field of view must also be accounted for.\nThe second problem with the simple distance threshold approach is that if the\nobject remains close co the threshold distance, then there may be rapid toggling back\nFIGURE 4.9.1 Varying the field of view changes the projected size of objects om the screen.\nthe field of view close to the threshold distance.\nPopping once from one level of derail\nera distance is a “magnification factor,” which is the screen size of the object relative ro\nits physical size, As chis ratio increases (i.e., as the object grows larger on screen), we\nHysteresis thresholding uses an upper and a lower threshold, and\nremains between the upper and lower threshold, che output value doesn't change, thus\nThe screen size of an object could be determined by transforming and projecting the\nobject position into view space and then calculating:\nlarger on screen and therefore should use a higher level of detail, Nore chat JM is simi-\nmakes a much better choice for determining level of detail selection chan simple cam-\nHowever, applying a simple threshold to Af will have the same popping\nproblems described previously, Hysteresis thresholding is the solution.\nHysteresis Thresholding\nHysteresis thresholding uses an upper and a lower threshold and remembers the\nwhen the input is berween the upper and lower thresholds.\nlevel of deeail selection means there is no single point at which che object will toggle\nWith the magnification faecter and hysteresis thresholding we can create a level of\ndetail selection algorithm that accounts for camera field of view and avoids rapid pop-\nAssume we have models for three levels of detail: high, medium, and\nThe hysteresis thresholds for moving between high and medium detail are ff aoe\nF eiue- In pseudocode, the level of detail selection algorithm looks like this:\nThe equivalent algorithm using a simple distance threshold would just use onc\nthreshold berween each level of detail, and would look like this\nThreshold Selection\nFor any thresholding method, hysteresis or otherwise, you meed to choose your\nthresholds.\nFor level of detail selection, choasing the thresholds is a tradeoff berween\n[f the thresholds are set too low, then the higher levels\nIf the thresholds are too high, then che\nlower quality models will be drawn more olten, and popping between levels will be\nobject toward and away from the camera, moving the thresholds until che popping is\nfocus of attention” can be used in the level of detail selection algorithm by biasing the\nmagnification factor when che user is likely to be watching an object or character.\n(such as a non-interactive rendered cue scene), the magnification faceor for all objects\ncan be biased higher in order to render objects at higher detail.\nbias the magnification lower to select more lower polygon models and improve che\nnumber of objects that can be rendered at each level of detail.\nLimits on che number of models at cach level of detail can easily be\nbuilt inte the selection algorithm—sort the objects by magnification factor, and then\ntake the M largest objects ar each level of detail, demoting any remaining object wo the\nmedified to select objects sa the total polygon count for all objects falls below some\nlevel of detail methods.\nstill be desirable to use hysteresis thresholds ro decide when to change the polygon",
      "keywords": [
        "level of detail",
        "Detail",
        "Object",
        "Level",
        "Camera",
        "Detail Selection",
        "magnification factor",
        "threshold",
        "hysteresis",
        "detail selection algorithm",
        "field of view",
        "Hysteresis thresholding",
        "view",
        "Selection",
        "low detail model"
      ],
      "concepts": [
        "threshold",
        "object",
        "camera",
        "level",
        "polygonal",
        "polygons",
        "pop",
        "popping",
        "selection",
        "select"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 45,
          "title": "",
          "score": 0.624,
          "base_score": 0.474,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 39,
          "title": "",
          "score": 0.592,
          "base_score": 0.442,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.58,
          "base_score": 0.43,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 46,
          "title": "",
          "score": 0.571,
          "base_score": 0.421,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 30,
          "title": "",
          "score": 0.564,
          "base_score": 0.414,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "threshold",
          "selection",
          "hysteresis",
          "level",
          "camera"
        ],
        "semantic": [],
        "merged": [
          "threshold",
          "selection",
          "hysteresis",
          "level",
          "camera"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.29110151261882733,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.604190+00:00"
      }
    },
    {
      "chapter_number": 45,
      "title": "Segment 45 (pages 431-441)",
      "start_page": 431,
      "end_page": 441,
      "summary": "of cipht children ar every node.\nThe rooe node of an octree\nThe children at each node\nThe bouncing cubes at cach node are the key to using an octree for spatial subdi-\nFach node contains pointers to all of the polygons that lie within ics volume.\nibility determination, the axis-aligned bounding cube of the root node of the tree will\nAta minimum, each node in the octree must contain the following data:\n* Bounding Cube—This is the cube in space thar the node of the occree encloses.\n* Geometry List—Each node encloses a number of polygons; these must be stored\nin some way at each node.\nmust be stored at every node,\nfaces), Tree craversal for collision detection requires that each node have pointers to\nThe first step to building the octree is eo get a list of all che polygons in the world.\nOnce this list has been created, the root node of the octree can be constructed.\nBy definition, the geometry list for che root node will conrain all the\nStarting with this root node, the world can now be subdivided\nIf this assumption was not made, there could be nodes without neighbors,\n1. Creates the bounding cube far the node,\n2. Determines which polygons lic within che node's cube.\nCreating the bounding cube for the node is trivial.\nDetermining which polygons lie within che bounding cube is slighrly more emt:\neach node.\npolygon ar every node in the tee.\nA polygon can exist within several nodes: a parent\nOne possible approach to storing the geometry for each node is no store a list of\npolygon rable will be stored, This requires very little data at each node and ensures\nthat polygons will not be duplicated when they span multiple nodes.\nGiven the solution for storing polygon lists at each node, the mext step is to create an\nThe primary components of each octree node are now filled in: the bou nding cube,\nof the nodes have been created.\nnode and comparing it against the cube faces of the other modes in the tree ar the same\nof nodes it is attached to, Then, to render che scene, the terrain polygons in each vis-\nible node are rendered, as well as all objects attached to the mode.\nThe collision test begins by finding che leaf node of the actree thar the scart\nnode that neighbors the cube face thar it intersected.\ncontinues, colliding with the geomerry and objects at every node until the original end\ntion, may be stored in an octree node with a very large bounding volume.\npens when an object straddles the boundary plane berween owo Large nodes.\nover an ordinary octree is that it avoids stickiness in the object partitioning, resulting\ndesired node in the tree is a simple O/) operation.\nIts main weakness is that it tends to use more partitioning nodes for a given\nIna conventional octree, the basic node bounding volume is a cube.\nciated with a node must be contained completely within the node's bounding cube.\nFach nede may also have up te eight child nodes, whose bounding cubes are formed\nThe bounding volumes of the child nodes nest perfectly within the bounding vol-\nThe child nodes can\nlength of the bounding cubes: ar the root of the tree, che cube edge length is equal to\nwhere Wis the world size, and depth is the number of levels by which a node is sepa-\nThe root node has depth 0.\nFIGURE 4.11.1 A quadtree node, shown with bounding square in bold, subdivided along\ning, but starting at depth 1, the centers of the reor's child nodes are spaced W#2 units\napart from their neighboring nodes.\nSo, for a given depth, che cube edge size and the node spacing are identical.\nscheme is to associate a given object with the mode in the octree whose bounding cube\nThis node can easily be found by a\nstruct node {\nvoid InsertObjectintotres(node* n, Object* o}\ni} child mode, so store it in this node.\nfi Object Tits in one of the child nodes.\ntitoning planes, then the object is stored in char node.\nlors of small objects, the ones located along the roor node partitioning planes can\nmethod is to allow an object to be referenced by more than one node, so an object can\nFIGURE 4.11.3 All of the objects are small, but the shaded ones are suck to higher nodes in\nbe shared by child nodes on cither side of a sticky plane, rather than being stored in\nthe parent node.\nby adjusting the node bounding volumes.\ncubes, but leaving the node hierarchy and the node centers as is.\nume of a node is still a cube, but where in the conventional ocwee the cube edpe may\nhave had length J, in che loose octree the cube edge would be £0, where & > J.\nHowever, che node spacing remains the same as in the conventional ocoree.\nthis means is that a node's bounding cube now overlaps with the bounding cubes of\nThis loosening of dhe bounding cubes increases che minimum size of objects\na sticky plane would be stored in char plane's node, with looser bounding cubes,\nsmaller objects will fir within one of the child nodes (Figure 4.11.5).\nthe plane's node, and on the value we choose for k For a node at a given depth, no\nobject with a bounding radius smaller than (k — J) *£/2 can be stuck oo chat node\ndue to straddling a partitioning plane, Instead, since the child nodes’ bounding vol-\numes have been enlarged, such objects can fic in one of the child nodes.\nFIGURE 4.71.4 Pour nodes.\nThe same four nodes in a loose quadtree have bounding squares shown in black.\nFIGURE 4.115 The crcle won't fir in any of the conventional child node bounding squares,",
      "keywords": [
        "node",
        "Construction Dan Ginsburg",
        "Dan Ginsburg Culling",
        "node bounding cube",
        "bounding cube",
        "cube",
        "Dan Ginsburg",
        "Octree",
        "bounding",
        "child nodes",
        "Octree Construction Dan",
        "node bounding",
        "objects",
        "che node cube",
        "root node"
      ],
      "concepts": [
        "node",
        "objects",
        "cubes",
        "bounding",
        "partitions",
        "partition",
        "plane",
        "loose",
        "polygons",
        "polygonal"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 46,
          "title": "",
          "score": 0.864,
          "base_score": 0.714,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 40,
          "title": "",
          "score": 0.677,
          "base_score": 0.527,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.624,
          "base_score": 0.474,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 30,
          "title": "",
          "score": 0.602,
          "base_score": 0.452,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.593,
          "base_score": 0.443,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "node",
          "bounding",
          "cube",
          "nodes",
          "octree"
        ],
        "semantic": [],
        "merged": [
          "node",
          "bounding",
          "cube",
          "nodes",
          "octree"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.26784056832108044,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.604237+00:00"
      }
    },
    {
      "chapter_number": 46,
      "title": "Segment 46 (pages 442-449)",
      "start_page": 442,
      "end_page": 449,
      "summary": "Assuming a loose octree with b=2, we can write an extremely simple object inser-\ntion procedure, The basic principle is that for a given object, che depth of the con-\ntaining node can be calculated solely based on the object's size, and chen the choice of\nthe particular node at thar depch in the tree is based solely on the object's center loca-\nTo get che formula for depth, note that a given lewel in che loose octree can\naccommodate any object whose radius is less than or equal to 1/4 of the bounding\nAny object with a radius <= L/8 of the\nbounding cube edge length should go in the next deeper level in the tree.\nple, in Figure 4.11.5, notice that no matter where the object is placed, ic will fit within\nLet Armaxfdepth) = maximum object radius thar can be accommodated at depth.\nLet depeh(R} = the first cree depth that can accommodate an object of radius R\nple—just find the closest node to the object’s center.\nnode nearest to the object to see if the object firs inside it.\nTo help in comparing loose octrees with regular octrees, | wrote a test program based\nThe objects are first partitioned using a conventional quaderee, and\nthen for each frustum, the daraset is queried for visible objects.\non the number of objects char are potentially within che frustum, and che number of\nobjects that are actually within che frustum.\nThen, the objects are re-classified using a\nloose quadtree, and che same frustum tests are run and che same staristies are col-\nfree max depth o 5 Objects Objects Objects Objects\nLOM) objects\n20h) objects\nIn my test program, I added a test in which each object is checked for\n500 objects\n1000 objects\n2000 objects\nAs you can see, for these datasets, the loose quadtree needs two do far fewer object\nto-object tests for the same query.\nThe loose quadtree docs require many more object-\nIn situations where you have a large number of interacting, dynamic objects\nThe loose octree also performs well for\nMeshing\nA progressive mesh (PM) is a criangle-based mesh that is able to vary its level of detail\nbetween che conventional mesh from which ic was created and a lowest detail “base\nA progressive mesh varying in detail,\n4.12 View-Independent Progressive Meshing 455\nProgressive Mesh Overview\nFIGURE 4.12.2 A single step of mesh refinement (vertex split) or reduction (edge collapse).\nof the original vertices that are being collapsed (Figure 4.12.3).\nThe midpoint system has the disadvantage thar convex objects become smaller as\nFIGURE 4.12.3 Choices for position of vertices produced by edge collapses.\nmesh.\nwhen, for example, collapsing the corner of a cube-like object and a vertex somewhere\nEach sequence of vertex splits, starting with a vertex im the base mesh, can be visual-\nView-independent meshes use one fixed onder for the edge collapses, which can\n4.12 View-Independent Progressive Meshing 457\nbe wed when rendering a mesh at deaail level 5.\npractical game situations, however, a Large object can be subdivided into independent",
      "keywords": [
        "objects",
        "objects obj min",
        "Polygonal Techniques Assuming",
        "loose",
        "che",
        "objects obj",
        "mesh",
        "loose octree",
        "node",
        "detail",
        "obj max radius",
        "che loose octree",
        "obj min radius",
        "Techniques Assuming",
        "obj max"
      ],
      "concepts": [
        "objects",
        "meshing",
        "meshes",
        "node",
        "edge",
        "collapse",
        "collapsed",
        "radius",
        "visibility",
        "visible"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 45,
          "title": "",
          "score": 0.864,
          "base_score": 0.714,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 40,
          "title": "",
          "score": 0.598,
          "base_score": 0.448,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.576,
          "base_score": 0.426,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.571,
          "base_score": 0.421,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 30,
          "title": "",
          "score": 0.521,
          "base_score": 0.371,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "loose",
          "objects",
          "mesh",
          "object",
          "radius"
        ],
        "semantic": [],
        "merged": [
          "loose",
          "objects",
          "mesh",
          "object",
          "radius"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23712815518040578,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.604283+00:00"
      }
    },
    {
      "chapter_number": 47,
      "title": "Segment 47 (pages 450-461)",
      "start_page": 450,
      "end_page": 461,
      "summary": "renderer thar uses fewer polygons in che distance in another way, such as the\nto have triangles pointing to shure texture coordinates and pointing to shared vertex\nvertices contain all texture coordinates, normal and position information.\nthe meth will contain multiple vertices in the same Position bur with different mater-\nIfan edge being removed contains these duplicate vertices, and therefore the tri-\nangles along the edge do not share vertices, it is handled as ewe edee collapses thar\nof the ends of a collapsed edge, and this is the one thar is ro disappear (Figure 4.12.5).\n4.12 View-Independent Progressive Meshing fs 455\ngiven contains no workarounds for multiple edges that share the same position.\ncollapses, and thar makes some edge collapses happen simultaneously: This implics\nthar all meshes must be smooth and continuously tectured, bur, as can be seen in the\nexamples on the enclosed CD, careful construction of che meshes means many more\nFor the majority of frames, a mesh will nor change in derail, so it is essential thar the\nHere we can arrange the data much like we would for a standard mesh renderer:\nIr alsa owns some triangles, which simply index into che vertex array.\nEach vertex contains position, lighting, and texcure information.\nobject because the positions of same of the vertices in different materials are the same.\nProgressive Mesh Rendering Only Affects the\nBecause an edge collapse preserves one our of the two vertices involved, this renderer\nmodifies the triangle lists only, with no effect on the vertex dara.\nsame mesh.\nThis also means thar vertex position modifiers, such as animation, can happen\nfairly independently of the progressive meshing, as long as you dont mind that the\ncollapse order wont change even as the vertices move about against each other.\n4.412 View-Independent Progressive Meshing et\nA point of note for che renderer is thac the vertices and triangles have been ordered\noffline so thar it is always the triangles and the vertices at the end of a list thar are\nInteresting|y, adjacent triangles in che list often share vertices, which in many sys-\ntriangles on either side of an edge collapse will be next co each other in the triangle list.\nThe Reversible Edge Collapse List\nthar changes the level of detail of che mesh.\nFach edge collapse loses ome Vertex, one or\nmore triangles, and changes which vertices some of the remaining triangles use.\nis one edge collapse list for the whole object, though different individual collapses\nAlternatively, there could be a collapse list per material, but\nfloat Value;\nvertex that is being lost off the end of the list.\nBecause the materials are so independent, sometimes nwo edge collapses must be\nperformed at once, to preserve the mesh seams as much as possible.\ndiscussed earlier, the two edges actually are the same edge in space, so must collapse\ncompare the value of the next edge collapse or verrex split chat could be performed\nagainst the level of detail required from the mesh based on its position and other\nderail to be lost, and removing it fem the mesh, while generating the edge collapse\ndata thar will be needed by che renderer later.\nbe removed, all triangles thar refer to it must be changed, and any triangles thar are\nend of the remaining vertex list.\nOf course, swapping triangles and vertices to the ends of their lists changes all ref\nerences to them, in other edge collapse structures as well as in the remaining mesh.\nmesh) that needs to know abour vertex reordering.\nwould be useful in the mesh.\nFor example, the code often looks for “alll triangles thar\ntriangles for the next edge to collapse, Huge performance improvements are possible\ncontinuities in the mesh less likely to collapse.\nEach mesh\nA Further Variation on Progressive Meshing\nAn advantage is char you can throw away the edge collapse list, which is actually\nbecomes much simpler—you are back to a normal mesh renderer, bur just with code\nCode for the progressive mesh generator and the renderer is contained on the CD.\nAdapting Meshes, 1997, available online: hitp://wwwlloLgov/graphics/ ROAM/\n[Hoppe96) Hoppe, H., Progressive Meshes, Siggraph 1996 Proceedings, pp.\nView-dependent refinement of Progressive Meshes, Siggraph\nEfficient implementation of progressive meshes, Compurers\nInterpolated 3D Keyframe\nKeyframing is a simple and effective way of animating a 3D object.\neach keyframe only represents the extremes of the object's motion, this can make che\ndrawn between the same position in we adjacent keyframes p, and p,, and then we\ncalculate where on this line the new position p(t) exists (Figure 4.13.1).\n(siven the desired time of the new animation position, the total number of\nkeyframes, and the coml time of che animasion, the point berween the nwo closest\nnumber of keyframes in the animacion, the total time of the animation, and the\ndesired time, the keyframes on either side of the new position and the percentage\nfloat &fPercentage)\nThis assumes thar the keyframes\nIF che keyframes are nor set at uniform intervals, this\nThen, the second keyframe is determined by incrementing che first\ntotal number of keyframes in the animation.\n4.12 Interpolated 3D Keyframe Animation 467\ninterpolating Vertices and Normals\ndemonstrates using these values to combine the vertices from the selected keyframes.\nvoid coabineVertices(long dwvertexCount, float fPercentage,\nbine the vertices from the tern keyframes irutes a single now position between them.\nThis same method of combining the vertices of bath keyframes ean also be\nface culling) and vertex normals (for lighting) are stored in each keyframe.\nnormals must always be interpolated, but interpolating the vertex normals can be\nthe frames immediately before and after chese two keyframes are also calculated.\nThese additional keyframes are used to refine the calculation for the new position.\n4.13 interpolated 3D Keyframe Animation 465\nThe positions from the four keyframes are used to calculate the new p(t) using the\nThe first and fourth keyframes are used to calculate the tangents ms; between che\nSpline Interpolating Vertices\nfloat t2 = t * t;\nfloat +9 = t2 * t;",
      "keywords": [
        "edge collapse",
        "Edge Collapse List",
        "vertex",
        "Edge",
        "vertices",
        "keyframes",
        "mesh",
        "collapse",
        "thar",
        "che",
        "triangles",
        "position",
        "float",
        "Collapse List",
        "animation"
      ],
      "concepts": [
        "float",
        "mesh",
        "meshes",
        "edge",
        "positions",
        "position",
        "collapse",
        "collapsed",
        "vertex",
        "interpolated"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.484,
          "base_score": 0.484,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 36,
          "title": "",
          "score": 0.445,
          "base_score": 0.445,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.429,
          "base_score": 0.429,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 39,
          "title": "",
          "score": 0.425,
          "base_score": 0.425,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 62,
          "title": "",
          "score": 0.424,
          "base_score": 0.424,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "collapse",
          "keyframes",
          "edge",
          "edge collapse",
          "mesh"
        ],
        "semantic": [],
        "merged": [
          "collapse",
          "keyframes",
          "edge",
          "edge collapse",
          "mesh"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2786868455299427,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:16.604330+00:00"
      }
    },
    {
      "chapter_number": 48,
      "title": "Segment 48 (pages 462-474)",
      "start_page": 462,
      "end_page": 474,
      "summary": "ee eee\nbones influencing it would be the upper and lower arms.\ntechnique only takes into account ane bone per vertex.\neven smaller bits (body pares), which are used as bones.\nAs each bone is created, it is\nognized as a bone by our program.\nOnce we have identified a skin and its bomes, we take che geometry of the bones\nand the bone this vertex is a part off\nNow foreach vertex in our skin, we find the vertex in che bene list chat is dlosest\nWe cransform the skin vertex by the inverse marrix of the bone that the vertex\nThe transformed vertex is stored in a temporary list thar we accumulate, where we\nalse store the original vertex list index and a poinrer to che bone that influences it.\nThe influencing bone has a counter char keeps track of che number of vertices it rrans-\nWhen all the vertices of the skin have a bone influencing them, we process the\nThis list is then sorted based on the order of the bones.\nFor each bone, the number of vertices it influences is stored in the original skin's ver-\nListing 4.14.1 contains sample code that solves for bone influences anc remaps\n* Askin, with each vertex transformed into the local coordinate system of the bone\nThe vertex list is somed by the order of the bones.\n* Alistof bones, with a counter for how many vertices each bone should transform.\ners for each vertex to the bones char influence them.\ninverse transform and a percentage-based roration for each bone thar influences it\n/* Make 211 the bones’ vertices into one big vertex\nList with information on what bone each point came from */\nfor(int 1-0; i<bonemesh->nvertices;i++)\n/* Find the closest bone vertex t6 @#ach skin vertex */\n/* no bone is influencing this bone yet */\n/* Sort all the vertices of the skin by bone,\nfor (i=O;i<skinmesh-*nvertices:i++)\nBone \"boneptr\n/* For Each bone in the skin, transform % amount\nof vertices with the bone’s current animation matrixt/\nStitching and Skinning\nThe bones are then animated and, consequently, the attached\nniques assume one continuwows mesh that is attached to a bone structure for a charac-\nter as opposed to many meshes attached to a single bone in traditional rigid-body\nThis continuous mesh is deformed relative wo the character's bone scruc-\nAs mentioned earlier, sucching operates on a continuows mesh attached no a bone\nIn ngid-body animation, a polygon is transformed by one matrix represene-\ning the bone to which thar polygon is attached.\ngon can be transformed by a different matrix representing the bone to which che\nmultiple bones together simply by attaching different vertices in the polygon wo dif-\nferent bones.\nWhen the bones are manipulated, this polygen should fill the gap you\nWith rigid-body animation, a bone must\nenrresponding bone then transforms that geometry.\neach vertex in the character's skin vo keep track of the hone to which iris artached.\nThe problem is this: a marrix used to transform a bone for ani-\nmation assumes thar the bone starts with its pivoc point at the origin of the ceardinate\nThis bone should start with its pivot point at the origin of its coordinare\nspace so that we can easily rorare the bone around thar point.\nThe bone is animared\nthe end of the upper arm bone.\n(Given the spatial relationship between the skin's vertices and the bones of the\ncharacter, it is necessary to transform the vertices of the skin into the local coordinate\nspace of the bones to which they are attached befare transforming them by the bone's\nTo do this, we need to keep a maurix in each bone thar tells us how\nto transform geometry back into the local space of the bone.\nthe inverse of the matrix used to transform the bone from its local space into the char-\nSee Figure 4.15.2 for a depiction of the local spaces for each bone in our arm mesh.\nTherefore, the data structure of our bones should look like the following:\nstruct Bone\nBone “child;\nFIGURE 4.15.2 A depiction of the bones in our arm.\nAll of these transformations can be done faster by processing che bone hierarchy\nand generating a final wansformation matrix for each bone concatenating a bone's\nconcatenatea(bone->orientation, orientation ,\nff take the inverse of the orientation matrix for this bone\ninverée{localorientation, bone->inversedrisntatian) |\nff COnCatanate this bone's orientation onto the Torward\nConcatenate(bone-2arientation, forward, LocalForward);\nif canéatenste this bone's animation ante the forward matrix\nconcatenate (bone->animation, lacalFoermrd, localForward);\ni# build the bone's final matrix\ncondatenate (bone->inversedrientation, lacalForward,\nbone ->final};\nif (bone->child)\nif (bone-»sibling)\nBuildMatrices(bone->sibling, forward, orientation) ;\ndegrees to the foreartn bone produces the images in Figure 4.15.3.\nprevents us from having to do an extra matrix concatenation per bone per frame of\nlimited to being affected by a single bone; it can instead be influenced by multiple\nbones.\nperson's elbow is not affected by the orientation of just one bone.\nboth the upper and lower arm bones affect ic.\n‘To enable this, cach vertex in a skinned mesh must contain a list of bones that\nEach vertex must also carry a weight per bone thar tells us how heavily\naffected the vertex is by the bone.\n» bones by which a vertex is affected, we need to store #—1 weights, since the remain-\nbone representation as shown previously.\nIn order to do full skinning, we need to transform each bone by each mato\nVectaraD TransfaraVertes ( Vertex “vert, Bone \"baneArray }\nbone] vert->bonaIndex1]->Tinal)\nfinal.z = temp.z * vert->weight:\nbone[ vert->bone Index?\nfinal,z += temp.z * (71.0F - vert->weight};\nbones.",
      "keywords": [
        "bone",
        "Vertex",
        "skin",
        "vertices",
        "animation",
        "Skinning",
        "Polygonal Techniques",
        "che",
        "matrix",
        "arm",
        "Simple Skinning Technique",
        "bone thar",
        "Technique",
        "bone animation matrix",
        "boneptr"
      ],
      "concepts": [
        "bone",
        "vertex",
        "skinning",
        "skin",
        "weight",
        "animations",
        "animation",
        "animators",
        "animated",
        "animate"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 47,
          "title": "",
          "score": 0.345,
          "base_score": 0.345,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 9,
          "title": "",
          "score": 0.343,
          "base_score": 0.343,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 36,
          "title": "",
          "score": 0.339,
          "base_score": 0.339,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 20,
          "title": "",
          "score": 0.322,
          "base_score": 0.322,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 45,
          "title": "",
          "score": 0.317,
          "base_score": 0.317,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "bone",
          "bones",
          "skin",
          "vertex",
          "vertices"
        ],
        "semantic": [],
        "merged": [
          "bone",
          "bones",
          "skin",
          "vertex",
          "vertices"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21358457054029478,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:16.604371+00:00"
      }
    },
    {
      "chapter_number": 49,
      "title": "Segment 49 (pages 475-482)",
      "start_page": 475,
      "end_page": 482,
      "summary": "Real-Time Realistic Terrain\nTerrain is the centerpiece of many games, an important backdrop in same, and just\nrealistic terrain to be created, within which the game may be played.\nrithms are presented in a manner thar leans toward using them to create terrain in\nThe first technique that ean be used to create basic terrain is fexzy danalcaping.\nx= 0;\n4.16 Real-Time Realistic Terrain Generation\nwhile x = 100 {\nAAs can be seen,.chis will simply populare a 100 x 100 grid with a series of random\nNote also that the random number generator is\nber generator to rid us of the annoying effect seen in Figure 4,16.1, which results from\nusing the ANSI srand function: srand (x + (x * y)) foreach grid square,\nGood-looking fuzzy terrain is more realistic chan chat shown in Figure 4.16.1, so\nnique that we shall use is one that can he applied to any of the terrain-generating algo-\ntotal = total 4 map (x_local, y_local);\nfor w_local = ™; x local <= x + step;\nBap (x_local, y_local) = average;\n‘The effect of applying this smoothing algorithm can be seen in Figure 4.16.2.\nThe end result is the same, modifying discrete pointes of the terrain based\nThe following code is snipped from the terrain-generation software that appears\n4.16 Foal-Time Realistic Terrain Generation 487\nFIGURE 4.16.2 A smoothed version of our tandem terrain grad.\nfor { int xi = row_offset; x1 < width; «1 += square size }\nfor { int yi = row_offset; yi < width; y1 += square_size }\nint x2 = (M1 4 square size) %& width:\nant a@ = this->terrain|x2][v1]*\nint 23 = this->terrain[xi][y2]:\nint i4 = this->terrain[x2][y2];\nInt ¥3o= (x1 + square_size/4) & width;\nthis->terrain [x3][ya] = pi;\nthis=->terrain [x2][ya] = pes\nthis->terrain [x3] [y¥2] = Aa;\nthis->terrain [x2] [yz] = pd;\nless variations that involve adding random offsets to the calculated points, amongst\nthird mechanism, known as Fault Line landscape generation.\ngeneration works by choosing nwo points at random and drawing a line at a given\nThe next step is simply to apply the subdivision technique explained previously\nTerrain\ndrawn at a2 constant “height.” That is, the value atcribured co each point along the line\nment shows the core line-drawing algorithm at work thar forms part of the terrain\nthis->terrain[ (int)_etart][(int})y start] =\n({z_start = (float) this->terrain_height) Bh\n(x_start > O.0}});3\nThe important point co note about all of the techniques discussed is chat the\nUsing these techniques along with the principle of generation, we can say that\nsince in theory every time we seed the random number generator, we will get a differ-\nent set of random numbers, the possibilities for generating terrain are infinite.\nthermore, since we can re-generate or re-calculate at will any point of any terrain, we",
      "keywords": [
        "Filling the Gaps",
        "Terrain",
        "local",
        "square",
        "Realistic Terrain Generation",
        "Realistic Terrain",
        "points",
        "Random",
        "size",
        "int",
        "Real-Time Realistic Terrain",
        "technique",
        "square size",
        "width",
        "Generation"
      ],
      "concepts": [
        "terrain",
        "square",
        "generation",
        "generated",
        "generates",
        "generator",
        "point",
        "pointes",
        "width",
        "techniques"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 51,
          "title": "",
          "score": 0.692,
          "base_score": 0.542,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.672,
          "base_score": 0.522,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.51,
          "base_score": 0.36,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 30,
          "title": "",
          "score": 0.502,
          "base_score": 0.352,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 45,
          "title": "",
          "score": 0.442,
          "base_score": 0.292,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "terrain",
          "realistic terrain",
          "realistic",
          "generation",
          "int"
        ],
        "semantic": [],
        "merged": [
          "terrain",
          "realistic terrain",
          "realistic",
          "generation",
          "int"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2738161908911337,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.604420+00:00"
      }
    },
    {
      "chapter_number": 50,
      "title": "Segment 50 (pages 483-490)",
      "start_page": 483,
      "end_page": 490,
      "summary": "This box is then subdivided by drawing horizontal lines from the left-hand side ro\nlines from the top of the box to the boom, again ar random intervals.\nImagine the black lines to be passageways, Now imagine that che play-\neasy, because all thar is required is that any space that has dimensions exceeding che\nFIGURE 4.76.6 Random limes divide our be.\nSince we know thar all the horizontal and vertical lines must meet at some junc-\nture, it follows char the smallest box is the junction of the two vertical lines with the\nsmallest horizoncal separation, and the nwo horizontal lines with the smallest vertical\nAnything larger than thar in beth directions can be considered a room;\nIncreasing the number of lines, or decreasing\nvariant for vertical lines:\n2. Count the number of squares to the right until a wall is encountered.\nFIGURE 4.16.7 a: Before line removal.\n4: After line removal,\n3. Atarandom number of squares from the left, draw a line from the top to the ber-\n3. Ata random number of squares from the cop, draw a line from the left to the\nOf course, the algorithm needs to ensure thar when counting from top to borrom\nthar the game was running on (with 16K RAM) was a limined-resource second-gener-\nWe could begin by generating a word of six letters, each one chosen ar random.\nWhat is required is some method by which we can ensure thar letters thar are next to\neach other fir naturally, The first step is w create a table of letter-frequency pairs, so\nthat fora piven letrer we can say that there are a limited number of possible letters that\nTor (fAletter = 0; nletter < (int) strlen({szWord)-iinlettere+}\nwlTable[O][nFirstLetter]*+; // Space followed by letter\nulTable[nlastlLotter][27]*4+; // Letter followed by space\nThe algorithm represenced here needs little explanation, other than te say thar for\na given word, we specify which letters are the starting and ending ones, and add them\nby the letters is incremented, cementing a relationship benween the nwo thar we will\nUsing this table, we may now generate a word, starting with the firse letter.\nthis, we should choose a random letter such thar it may begin a word; in other words,\nNext, we call che random number generator to retrieve a\nagain, sumone the frequencies as before, uncil the random number that we have is\nletter.\nint GetLetterPositLon(unsigned tong ulWordTable[ 28] [26], int\nIn order co build a word of six letters in length, the general algorithm would be:\nWard(O] = GetLetterPosation (word_table,O)\nHowever, as it stands, the word-generarion algorithm doesn't preclude strange\nnumber of letters that can form chains.\nThe random number generator may prevent this to a\nWord[O] = GetletterPosition (word_table,O)\nword[x) = ((GetLatterPosition (word_table, word[x-1] — ‘a'))\nWhere che Resovethain function returns the current letter index into word if it is the\nthird ina chain of itself This could be coded as in che following listing:\nint Removethain( char word(M4x LENGTH], int letter_position }\nif (word[nPos) == word[letter_position])\nif (NOpcurences > 2) return letter_position — 1;\nreturn letter_position + 1;\naddress the last letter, and make certain thar it is one that can commonly end a natural\nword, Some letters, for example, are commonly followed by a vowel in the English\nlanguage, such as “J.” In order thar words do not creep in that end in such letters, we\n‘The first operation is to ensure thar the letter may follow the one thar it is adja-\ncent to, and to ensure thar the chosen lecrer may end a ward (be followed by a space).\nbilities of the target leter being adjacent to the source lemrer and at the end of a word",
      "keywords": [
        "word",
        "Realistic Terrain Generation",
        "thar",
        "letter",
        "lines",
        "random",
        "Realistic Terrain",
        "Real-Time Realistic Terrain",
        "Terrain Generation",
        "int",
        "Oven WAD files",
        "random number",
        "che",
        "number",
        "vertical lines"
      ],
      "concepts": [
        "word",
        "random",
        "letters",
        "algorithm",
        "lines",
        "returns",
        "rooms",
        "techniques",
        "follow",
        "frequencies"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 51,
          "title": "",
          "score": 0.705,
          "base_score": 0.555,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 49,
          "title": "",
          "score": 0.672,
          "base_score": 0.522,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 31,
          "title": "",
          "score": 0.658,
          "base_score": 0.508,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 45,
          "title": "",
          "score": 0.593,
          "base_score": 0.443,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.58,
          "base_score": 0.43,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "word",
          "letter",
          "letters",
          "lines",
          "random"
        ],
        "semantic": [],
        "merged": [
          "word",
          "letter",
          "letters",
          "lines",
          "random"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.29826990404240744,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.604471+00:00"
      }
    },
    {
      "chapter_number": 51,
      "title": "Segment 51 (pages 491-499)",
      "start_page": 491,
      "end_page": 499,
      "summary": "valuc dAaight to cach value on one side of the line (See Figure 4.17.1):\nFigure 4.17.2 shows cerrain height fields at 4, 8, 32, and 64 iterations (higher ele-\nFIGURE 4.17.2 Terrain height fields created by thir process,\nGenerating Random Lines\nWe want our lines to intersect well with the height field, so generating purely random\n‘To generate a line, it is best to pick owe random points within the height field and\nFIGURE 4.17.3.\nLet o be a point in the height field\nin the height field.\nTo simulate erosion, pass the height field chrough a low-pass image filter,\nheight field im both directions, we will get a nicely eroded landscape (Figure 4.17.4).\nFigure 4.17.4 shows the same terrain as Figure 4.17.2 after erosion.\nd@Height for iteration 0 and iteration m, the erosion factor (4), and che number of iter-\nFIGURE 4.18.1 Line segment AB.\nTake the midpoint C and displace ir by a random value between <dHeight2 and\nFIGURE 4.16.2.\nReduce the value of dHeight and recurse co the segments AC and CA (Figure\nFIGURE 4.18.3.\nFIGURE 4.18.4.\nWhen r> 1, dHeight decreases faster chan the line segment length, so early itera-\nFigure 4.18.5 shows three terrains with varying values of r (higher elevations in\nFIGURE 4.78.5 Samples of terrain with various rvalues.\nJust as the line segment is the basic unit of one-dimensional midpoint displacement,\npoint of the rectangle irself, as well as the midpoints of each of the four line segments\nTn the diamond-square algorithm, the calculation of the rectangle’s midpoint is\ncalled the diamond step, and the calculation of the side midpoints is called the square\nStart with a rectangle (A820), seeded with height values ar the four comers (Fig-\nCalculate che height at the midpoint E by averaging the values at A, B,C, and D\nFIGURE 4.78.7 First displacement saps,\nNow, calculate che heights at the midpoine of the line sepmencs (7, G, A, and J)\n(square step) (Figure\nFIGURE 4.18.8.\nFIGURE 4.18.9 Second displacement stage.\nTo calculate a square step value on the edge of dhe terrain (4, for example), treat\nDiamond Square in Height Fields\nWhen using the diamond square algorithm to fill in a height field, it is best to pick a\nsquare height field with width 2° for some integer .\nSee Color Place 2 for a rendering of a terrain generated into a 256x256 height",
      "keywords": [
        "height field",
        "Fractal Terrain Generation",
        "height",
        "line",
        "Terrain",
        "Fractal Terrain",
        "Terrain Generation",
        "Terrain height fields",
        "Fault Formation",
        "Midpoint Displacement",
        "Displacement",
        "field",
        "Polygonal Techniques FIGURE",
        "iterations",
        "square height field"
      ],
      "concepts": [
        "value",
        "displacement",
        "displace",
        "height",
        "lines",
        "decrease",
        "decreasing",
        "terrain",
        "square",
        "let"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.705,
          "base_score": 0.555,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 49,
          "title": "",
          "score": 0.692,
          "base_score": 0.542,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 41,
          "title": "",
          "score": 0.562,
          "base_score": 0.412,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 31,
          "title": "",
          "score": 0.52,
          "base_score": 0.37,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 39,
          "title": "",
          "score": 0.499,
          "base_score": 0.349,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "height",
          "height field",
          "field",
          "figure 17",
          "terrain"
        ],
        "semantic": [],
        "merged": [
          "height",
          "height field",
          "field",
          "figure 17",
          "terrain"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24421351711731218,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.604517+00:00"
      }
    },
    {
      "chapter_number": 52,
      "title": "Segment 52 (pages 500-507)",
      "start_page": 500,
      "end_page": 507,
      "summary": "Start with an empry height field and drop a single particle ante it (Figure 4.19.1).\nFIGURE 4.19.1 A single dropped particle,\nFIGURE 4.19.2 Two dropped particles.\nWe can generate a caldera for our particle mountain by inverting the height field\nImagine a height field generated by particle deposition (Figure 4.19.5).\nFIGURE 4.19.5 A height field penerated by particle deposition.\nFIGURE 4.18.7 [nvert the height field values above che caldera line,\nthe movement of the particle drop location, and the caldera depth.\n2D Lens Flare\nLens flare is an optical effect created by interreflection between elements of a lens\nIn real life, lens flare is considered a defect, and camera manufacturers go to great\nReal lens flare is due to complex interactions of light with surfaces in the optical\nVideo game lens flare is all about appearances.\nhow to implement an attractive lens flare effeer using only asmall amoune of code and\nReal lens flares are created in the lens system of the camera and so naturally appear\nEach element of a flare is a reflection of the light\nThese observations justify che treatment of lens flare rendering as a 2D problem.\nThe flare is rendered as an overlay on the 3D scene, and the elements of the flare are\nrendered along a line intersecting the projected position of the light and the center of\nThe lens flare effect is rendered with a small collection of textures, one for\nElemencs of che lens flare are rendered\nalong a line berween the projected position of the light source and the center of the screen.\nThe lens flare effect is rendered using a small collection of gray-scale texpures.\n‘To be cruly effective, che lens flare effect must animate convincingly with camera\ntanslucency of the flare elements produces additional subrlery.\nachieved by sealing the size and alpha value of the flare elements based on the distance\n5.0 20 Lens Flare Bi?\nment of the lens flare:\n1. Determine position and size of the flare element.\nIn this implementation, a flare is a collection of elements.\nThe flare also has an overall scale factor and a maximum size, used co control the\nDuring rendering, the dynamic properties of each lens flare clement are com-\nTexture and color of the flare are unaffected, bur position, size, and alpha level\nIn pseudocode, the lens flare effect is rendered as follows:\nflara if flare object to be rendered\n(ex,ey) ff geanter of flare (nernally center of screen)\nFlare is rendered along a Line from (lx,ly) to a\nfor each element in flare\nff scaling, and overall scale of the flare itself.\nff Flare elements are square (round) so height 4s\nThe lens flare demo includes OpenGL source code and a Windows executable.\nInitialize flare elements, given a list of properties by the caller.\n* FLARE_randomize.\nGenerate a list of flare elements with random properties.\n* FLARE_ render.\nRender the flare ata piven screen position.\nThe mouse cursor is used as the screen location of the light source, Lens flares can be",
      "keywords": [
        "Lens Flare",
        "Flare",
        "lens flare effect",
        "Lens",
        "flare elements",
        "che lens flare",
        "Fractal Terrain Generation",
        "flare effect",
        "caldera line",
        "Caldera",
        "Caldera Line FIGURE",
        "line",
        "Particle",
        "Deposition Jason Shanke",
        "light"
      ],
      "concepts": [
        "flare",
        "lens",
        "distance",
        "scaling",
        "scale",
        "elements",
        "element",
        "particle",
        "caldera",
        "height"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 56,
          "title": "",
          "score": 0.481,
          "base_score": 0.331,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 51,
          "title": "",
          "score": 0.428,
          "base_score": 0.428,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 55,
          "title": "",
          "score": 0.425,
          "base_score": 0.275,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 53,
          "title": "",
          "score": 0.421,
          "base_score": 0.271,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 54,
          "title": "",
          "score": 0.412,
          "base_score": 0.262,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "flare",
          "lens",
          "lens flare",
          "elements",
          "particle"
        ],
        "semantic": [],
        "merged": [
          "flare",
          "lens",
          "lens flare",
          "elements",
          "particle"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15238001722314495,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.604561+00:00"
      }
    },
    {
      "chapter_number": 53,
      "title": "Segment 53 (pages 508-522)",
      "start_page": 508,
      "end_page": 522,
      "summary": "This article sheds some light on how to use 31) hardware co achieve 2D effects.\ninte OpenGL and then assign thar texture to a quad (rectangle) primitive.\nThe “trick” to displaying sprites using 31D hardware involves how you set up your 3D\nand position in 3D space, the secret to achieving 2D effects is vo set up our 3D scene\nDrawing the 3D Sprite\nNow that we've gor the texture set up, we're all ready co draw the sprite.\n6.1 Using 3D Hardware for 20 Sprite Effects S21\ntexture mode indicates thar the pixels we're poing to render are che source color and\nS.1 Using 20 Hardware for 2D Sprite Effect: 523\nup an OpenGL light source.\ncare of stretching the texture; all we need to de is sec up the vertices of our sprite.\ntor of two, we simply make the width of che sprite a_iwidth*2 instead of m_iwidth.\nto implement advanced 31D effects, such as alpha blending of sprite scaling.\nMotif-Based Static Lighting\nstatic lighting.\nThe approach produces stunning animated lighting at 2 computational\ncost that is only slightly greater than conventional static lighting.\nMany games employ static lighting by precomputing the light colors ar each ver-\nalso produces very staric-looking light.\ndynamic animation to static lighting bur still executes at nearly the same speed as con-\nventional static lighting.\nConventional Static Lighting\nConventional static lighting is simply precompured Gouraud RGB values stored with\nsity, radius, radial falloff, and light type (omni, directional, spot, and che like).\nwere dealing with static lighting, the lights and all their properties are constant.\naddition, their positions are fixed in the object space of the object they are lighting;\nFrom the light\npositions and properties, the effect of each light on each of the object’s vertices ean\neasily be computed using any desired lighting equation.\nFigure 5.2.1 shows an object with six vertices being statically lit by wo lights.\nVertex 3 falls within only Light A’s influence, Vertex 3 falls within only Light B's\ninfluence, Vertex 2 falls within both lights’ influences, and the remaining vertices fall\nBecause Light A and Light B are static, they are fixed\nTherefore, the RGB lighting compu-\n5.2 Motif-Based Static Lighting 525\nLight.\nFor this reason, static lighting is useful for lighting\nobjects by lights thar are attached ro the abject, Good examples of this concept are\ntex’s position and normal with Light A in a conventional lighting equation.\nis similar, bur with Light B.\nVertex 2 is influenced by both lights, so the resulting\nRGB is simply the sum of the cwo lighting equations, The remaining vertices aren't\ninfluenced by either light, so their RGB is (0,0,0), and it is then the sole responsibil-\nThe lighting equations used are completely up to the designer's preference and\nRegardless of the actual equations used, we can wire the lighting\n2 represenes the lighr’s properties (position, intensity, radius, radial Glloff, light\nAU, Wis the lighting equation.\n/is the light’s scalar incensicy at the vertex, as computed by the lighting equation.\nLy i the light’s color (red component).\nfg is the lights color (green component).\ntn is the light's color (bluc component).\nCys the final red color component, ready to be stored in the vertex structure.\n(gis the final blue color component, ready to be stored in the vertex structure.\nHere's an example of a lighting equation for a simplified omni-light:\nOv. is the unit vector from the vertex to the light.\nof the light rays diminishes (attenuates) che farther the vertex is from the omai-\nlight's position.\nIf the vertex lies on the light's position, 0 is O and (R-— D)/R\non the outer boundary of the light’s influence, D equals Rand (R— D)/ R reduces to\nO. Lf the vertex lies somewhere berween the light’s origin and its outer boundary, (R\nThe first term in our omni-light equation, (D,,*/V¥,9.\nThis is called a diffise lighting factor and is a very\nening vertices thar a lighe ray hits more at an angle, We further imply thar f(D,\"\nThar is, if a light ray is hitting our vertex from\nbehind, we prevent the ray from lighting the vertex.\nEquation 3.2.3 produces a decent looking omni-light, but higher-quality results\ncould be obrained with more complex lighting equations, In any case, Equation 5.2.3\n5.2 Moti-Based Static Lighting 527\nyields a single sealar, which is the overall intensity of the light at the vertex.\n3.2.2 then multiplies cach component (red, green, and blue) of the light’s color by\nthis intensity, producing the final three-color components to be stored in che vertex\ndirectly to Gouraud light the object.\ntypedef struct {\nColor_t StaticGolor; ff RGB to be used for this vertex\n(ne drawback to conventional static lighting is that it does produce static results.\ntional static lights cannot be used because they require the RGB values to animate from\nConventional static lighting cannot achieve this result,\nThis is where motif-based static lighting COmes In. Motif-Based Static Lighting\nThe advantage of conventional static lighting over dynamic lighting is execution\nretricved [ram the vertex structure and Plugged clirectly inco the color values for the\nThe RGB values for each vertex are precomputed, stored, and never change from\nMotif-based static lighting provides a more dynamic look than con-\nventional static lighting at a negligible performance hit.\nMotil-based staric lighting is still a form of static lighting.\nThar is, the static lights\nlighting the object are fixed in the object's coordinate space, as is the case with con-\nventional static lighting.\nHowever, with motif static lighting, we are able te animate\nthe RGB components of the lights in real time, The type of animation is completely\nSome animations, such as a light switch on the wall of a room that\ntums on the room's light, might be under che player's concrol.\nFurthermore, some lights might have constant RGB values.\nTo implement mocif-based static lighting, the game needs a motif table that con-\ntains an RGB entry for every light motif.\nRGB values stored in the motif table are full-intensiry, unattenuared light colors.\nInstead of storing RGB colors directly in the vertex structure (as we did before with\nconventional static lighting), we now simply store an index in the vertex struceure that\nFor constant motif lights for which the color remains constant from frame to\nframe, the RGB value of the light (that is, the light’s raw, unattenuated color} is sim-\nFor mot lights for which the color is controlled by the player (eg..\na light\nswitch), the RGB value is updared when the event happens (the player flips the light\nstatic lights controlled by light switches, Initially, they might both contain\ncode stores the color of the light in entry 4, For example, if the light is a bright green\nlight, wed store RGB=(0,1,0) into encry 4.\nIf the player turned the light off again,\n6.2 Motif-Based Static Lighting 529)\nLight A and Light B affect vertex V2 in Figure 5.2.1).\nWe'll see a little later how motif static light-\nflame motif and then stores che resulting RGB into dor 0 of the motif rable.\nlighting calculations that are executed once per vertex per frame!\nFor conventional static lighting, the precomputed RGB color was stored\nHowever, for motif-based static lighting, we need to\n5.2 Motif-Based Static Lighting S31\nfloat fintensity; Ji Intensity of the light motif's\nThese fields cell che rendering engine which light\nmotif from the motif table to use as well as the intensicy of the light motifs RGB ar\nChe motif index simply replaces the lighr’s color property; instead\nof the designer placing a campfire light and assigning ir an orange color, a motif is\nThe designer positions the light and assigns the light properties such\nonly the color but also the animation of the static light.\nThe fintensity Geld is simply I from Equation 5.2.1, which is the lighting equa-\ntion we used for conventional static lighting, applied to this vertex.\nthe light and the light properties thar che designer has set interace with the vertex posi-\nand the RGB color (from the motif table encry indexed by the nMotitindex field in\nvertex's final run-time RGB values.\nHere's an OpenGL code example char renders a motif statically lit triangle:\nwhen a model has a vertex under che influence of more than one static light (as in Fig-\nTo support more than one motif, we need to extend the vertex structure so\nthat it hat a mociffintensity pair for each motif light affecting it, A general solution is\nTinat fiatensity; ff Intensity of the Light motif's\ntypedef struct {\nvectors Pos; if This vertex's 3D position in model-space\n5.2 Moatif-Based Static Lighting 533)\nTo support more than one light influencing a particular vertex, we simply per-\nvoid ConputeVertexColar( const Vertex_t \"pv, Color_t “pColor j {\nff Step through all the motifs affecting this vertex",
      "keywords": [
        "Static Lighting",
        "light",
        "vertex",
        "conventional static lighting",
        "Motif-Based Static Lighting",
        "RGB",
        "light motifs RGB",
        "texture",
        "motif",
        "RGB color",
        "Static",
        "color",
        "static lights lighting",
        "Sprite",
        "motif static light"
      ],
      "concepts": [
        "light",
        "colors",
        "motif",
        "vertex",
        "sprite",
        "effects",
        "static",
        "flames",
        "texture",
        "textured"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 55,
          "title": "",
          "score": 0.711,
          "base_score": 0.561,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 54,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 60,
          "title": "",
          "score": 0.551,
          "base_score": 0.401,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 59,
          "title": "",
          "score": 0.536,
          "base_score": 0.386,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 56,
          "title": "",
          "score": 0.446,
          "base_score": 0.296,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "light",
          "lighting",
          "static lighting",
          "motif",
          "static"
        ],
        "semantic": [],
        "merged": [
          "light",
          "lighting",
          "static lighting",
          "motif",
          "static"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2072940848574355,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.604909+00:00"
      }
    },
    {
      "chapter_number": 54,
      "title": "Segment 54 (pages 523-530)",
      "start_page": 523,
      "end_page": 530,
      "summary": "Using Vertex Color\nealeulated sets of vertex colors.\nalso several special lighting effects, including the reflection of the grass color on the\npolation was used to generate the vertex color values for the given figure's rotation.\n‘Typically, the method for generaring real-time vertex lighting goes like this:\nDetermine the angle at which the light is facing the vertex normal,\n. Using the facing angle, determine the intensity of the light at that vertex.\n. Repeat for each light illuminating the vertex.\nThe vertex cobor lists represent the lighting on che abject at distinct orientations of\nWe assume that the vertex color lists are generated in a 3D content creation applica-\nOF course, it's possible no use a real-time lighting method to generate the vertex\ncolor lists, bur the artistic task of attractively lighting a 31D scene should be left to\nThe example in Listing 5.3.1 uses four vertex color lists, cach penerated 90\ndata will be lists of vertex colors.\n‘The first vertex color list is assumed to represent the lighcing when the ebject is at\nfrom the previous one, The lighting for each rotation is saved asa vertex color list, cre-\nating four lists of vertex colors char will be used in real time.\n6.3 Simulated Real-Time Lighting Using Vertex Color Interpolation Sa7\nInterpolated Lighting\nHere is an explanation of the steps necessary to gencrace the interpolated vertex light-\nThe vertex color lists represent the lighting on the object at distinct orientations rela-\nDetermine Which Two Vertex Light Sets ta\nBased on the facing angle, we must determine which owo sets of vertex colors in our\nlist), Each set of vertex colors was pre-generaced using the same delta, 90 degrees\nset of vertex colors, which becomes the base color list.\nvertex color list in our table.\nbase color list = facing angle / vertex color delta\nif {| base color liat == last vertex color list }\ntarget color list = first vertex coler list\nWe need to determine how far berween the owo vertex color lists to interpolace.\npercentage represents how close to the target color list we should interpolate.\ncentage is calculated by dividing the remainder of the base color list calculation by che\nvertex color delta, giving us a value berween 0.0 and 1.0,\npercentage = ( facing angle % wertex color delta ) / vertex colar delta\nFor Each Vertex Color, Perform the Interpolation\nWe now calculare the vertex color list representing the current lighting for the object.\nTo calculate each vertex color, each color component (RGB) must be interpolated,\nFor Each Vertex Color, Apply an Ambicnt Light AGB\nOptionally, we can apply an ambient light modifier to the calculared vertex color list.\nNote thar the precaleulated vertex color lists can be created to ensure the ambient\nlight modifier doesn't take the calculated vertex colors our of the acceptable range.\nSD game, interpolated vertex color lighting can be combined with real-time lighting\nSs. Simulated Real-Time Lighting Using Vertex Color Interpolation 539\nFor this example code, we assume there is one vertex color per vertex in the object.\n/* number of vertex color lists */\n/* pointers to vertex color lists \"/\nLinearly interpolates between two lists of vertex colors.\nARGE DEF “piraA - pointer to first source vertex color list\nvertex colors\nant nAnGE ~ number of vertex colors to interpolate\nFills pOest with the caloulated vertex colors\nARGG_DEF *pireBh,/\" pointer to seaurce vertex color data ™/\nAROB_DEF *plest,/\" pointer ta dest vertex color data */\nint nARGE, i\" number of vertex colors to interpolate \"/\n5.3 Simulated Real-Time Lighting Using Vertex Color Interpolation 544\njtett dtd he CE eee ee ne 2\nCalculates the vertex colors used to represent tha lighting at the given",
      "keywords": [
        "Vertex Color",
        "vertex color lists",
        "Color",
        "Vertex Color Interpolation",
        "color list",
        "Vertex",
        "lighting",
        "vertex color lighting",
        "target color list",
        "Real-Time Lighting",
        "base color list",
        "calculated vertex colors",
        "vertex color delta",
        "vertex color data",
        "Simulated Real-Time Lighting"
      ],
      "concepts": [
        "lighting",
        "color",
        "vertex",
        "lists",
        "interpolation",
        "interpolating",
        "interpolate",
        "index",
        "effects",
        "gaming"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 53,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 55,
          "title": "",
          "score": 0.61,
          "base_score": 0.46,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 56,
          "title": "",
          "score": 0.462,
          "base_score": 0.312,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 60,
          "title": "",
          "score": 0.437,
          "base_score": 0.287,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 59,
          "title": "",
          "score": 0.434,
          "base_score": 0.284,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "vertex",
          "vertex color",
          "color",
          "color list",
          "vertex colors"
        ],
        "semantic": [],
        "merged": [
          "vertex",
          "vertex color",
          "color",
          "color list",
          "vertex colors"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20430245329014224,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.604974+00:00"
      }
    },
    {
      "chapter_number": 55,
      "title": "Segment 55 (pages 531-541)",
      "start_page": 531,
      "end_page": 541,
      "summary": "The attenuation function for lighting is typically like se:\n3D textures provide a simple method of encoding this function.\n¥ and 2 for the three texture coordi-\nThen, simply set up texture coordinate generation to calculate dX, d¥i and di?\nrelarive to the light position, use the texture matrix to scale each dX, dV and dz by 1\nover the light’s range, and scale and bias so the center of the texture comesponds to\n((Light.% — Wertex.x) / Liaghthange}) / 2.07) + o.5f;\nEven were 31D textures available, it would be advantageous to find a\nWell, first, since we have only 2D and 1D textures available, thar means chat we\ncant compute the function with only a single texture because we can't use all three\nment it using 2D) and 1D textures?\nLet's start by breaking X and Y into a 2D texture\nand # into its own 1D texture.\nMowe break X and Finto one texture and 4 into another, thar means chart the\nWe can encode t(x,¥) ina 2D texture as (X*X + F*F) and g(Z) ina 1D rexeure\nSa, one procedure for implementing point lights with attenuation maps is as fol-\nFor each Point Light in the scene {\nLight's range {\nScale the Position by 1 / the Point Light's Aange\nfor points inside the Light's Range\nStore Position.” in the & texture coordinate of\nTexture oO\nStore Position.¥ in the T texture coordinate oat\nTexture O\nStore Position.2 in the & texture coordinate ar\nof the light range.\nAlternatively, we can use texture coordinate generation and the texture matrix to\n* Set up texture coordinate generation for the first multitexture stage to give cam-\n= Set up the texture matrix co subtract the light’s ¥ and ¥ position, chus giving us\n* Set up the second multitexture stage to use texture coordinate generation to give\n* Set up the texture matrix to rotate Z onto the X-axis, and then subtract the light’s\nalpha-texture blending modes is to factor the light color into the rexture itself, This\n‘This implies thar we need to pre-multiply the light color into both attenuation\nlights, Instead of uploading new light maps to reflect a point light changing its color,\nmap textures to blend the lighr into the scene.\nas the falloff range of a point light For each pixel thar would be drawn with a point\nand then scale the macrix by 1 over the light's range.\ntexture matrix.\nspherical range calculation using two texture maps.\nbe used for per-pixel point lights, fog, or CSG effects.\nTexture Coordinate Generation\nto use texture coondinate generation to perform animation, lighting, reflection, refrac-\nThe method of texture coordinate generation used most comfortably by most\nsome matrix to yield a set of texture coordinates, This method is fairly easy co adopr\nSimple Texture Coordinate Animation\nQuite often, games use a simple rotation or translation of texture coordinates to sim-\nThe concept is simply this: A texture coordinate can be thought of as a\nshows a rotation of the texture coordinates by 45 degrees.\nTexture Projection\nTexture projection is useful for a number of effects.\nThe result of texture projection is fairly\nstraightforward: A texture is projected onco some geometry from some point in space.\nFor example, we can define a sporlight ar some point in a scene and project a texture\nFor texture projection, instead of modeling a camera in space, we are usurally\nLight space vertices are projected back onto the near clipping plane\nof the light, and the resulting X and }valucs are used as Sand T values to map a tex-\nplane should be set to reflect the dimensions of the texture that is to be projected.\ninstance, a square near clipping plane should be used for projecting a square texture.\nNow, as mentioned, geometry chat is projected onto a texture needs to be in light\nThe geometry can then be projected by the light’s projection matrix.\nExamples of texture coordinate penerarion through texture matrix transformations.\n6.5 Advanced Texturing Using Texture Coordinate Generation 551\nTexture space, we must first scale chem by (1.5 00 pur them in the range from —0.5 to\n* M_light = the light matrix used to transform the geometry fom world space into\n* W proj =the light’s projection matrix.\nFigure 3.5.2 was generated using texture projection.\nlight that was used to project che circular highlight onto the sphere geomienry.\nTexture projection example.\nWe Project a texture onto a sphere, for instance, the texture appears on both the front\ntexture projects correctly on the front of the sphere, but it also shines through to the\nsimply set the texture\nPlace a parallel light at the location of the texture pro-\nShine-through in texture projection.",
      "keywords": [
        "texture",
        "texture coordinate",
        "texture coordinate generation",
        "light",
        "light maps",
        "point lights",
        "texture matrix",
        "Texture Projection",
        "function",
        "Attenuation Maps",
        "coordinate",
        "ARGB LISTS",
        "coordinate generation",
        "Light range",
        "range"
      ],
      "concepts": [
        "textures",
        "textured",
        "lighting",
        "maps",
        "map",
        "mapping",
        "projection",
        "projected",
        "coordinates",
        "space"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 53,
          "title": "",
          "score": 0.711,
          "base_score": 0.561,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 54,
          "title": "",
          "score": 0.61,
          "base_score": 0.46,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 56,
          "title": "",
          "score": 0.58,
          "base_score": 0.43,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 60,
          "title": "",
          "score": 0.58,
          "base_score": 0.43,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 59,
          "title": "",
          "score": 0.559,
          "base_score": 0.409,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "texture",
          "light",
          "texture coordinate",
          "coordinate",
          "coordinate generation"
        ],
        "semantic": [],
        "merged": [
          "texture",
          "light",
          "texture coordinate",
          "coordinate",
          "coordinate generation"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18121692874918022,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.605020+00:00"
      }
    },
    {
      "chapter_number": 56,
      "title": "Segment 56 (pages 542-549)",
      "start_page": 542,
      "end_page": 549,
      "summary": "Reflection Mapping\nTo perform reflection mapping, I use a simple method called sphere mapping.\nWith sphere mapping, these owe points\nThe basic definition of a sphere map is a single texture map thar conrains a full\ndrawback to using sphere mapping for reflection: The texture used as the reflection\nOnce you have an adequate sphere map, texture coordinare generation is a snap.\nmapping is a wonderful way to generate dynamic lighting and reflection effects if the\nHardware Bump Mapping\nhence the term bump mapping.\nSeveral methods of bump mapping are available in hardware today.\nSince bump mapping is actually a lighting computa-\nBump-mapping techniques either caloulate or approximate a dot product\ndiscussed can be applied ta specular bump mapping or lighting as well.\nDot product-based bump mapping and per-pixel lighting are huge subjects, so we\non how ta properly bump map or light an arbitrary model or mesh.\nHow Do | Apply a Bump Map to an Object?\nrepresenting the bump map.\nwhat effect we are trying to achieve on which platform, Various hardware bump-map-\nping techniques require different source data for the bump-map texture, from alpha-\nsurface normal maps and RGB @UWV maps can be generated from alpha-height maps,\nLet's start with a simple example of a sphere that we want to bump map in model\nWe assume for now thar the bump map is uniquely cextured across the sphere;\nin other words, that each point on the sphere maps to its own section of the texture so\non to the sphere in model space, and generate the surface normal for char location.\nfepresents tangent space at thar point on the sphere surface.\nvector from our bump map, expressed in world space, and rotare it into local tangent\nWe can now replace che world space bump vector in the texture with the ran-\n5.6 Hardware Bump Mapping 557\nspace, we can perform \"© N beoween this light vecter and the bu Mp-Map VECwors.\nconstant for an entire portion of the model being bump mapped.\nWhere Texture corresponds wo the surface normal map with RGB encoded normals\nThis technique is known as object space or model space bump mapping.\nAnother Approach: Using Tangent Space Bump\nMapping\nerating the normal maps to be relative to model space, we leave our normal maps as\nthey arc, instead generating a matrix to rotate the light vector from model space into\nOUL tangent space at every point on the surface of the sphere.\nmathematical way of translating [rom the bump-map space co the local tangent space\nmodel space bump-mapping described previously, but only ar cach vertex of the\nWhen lighting or bump mapping that vertex, we use che 3 % 3 tangent space\ntangent space macrix to convert the surface normals, as we did previously, we use the\nIn model space bump mapping described previously, the generation of a tangent\npenerate a unique bump map across che sphere.\nIn tangent space bump mapping, we\nmodel space bump mapping, £’ was constant for the whole model hierarchy level.\nTo perform tangent space bump mapping, we can set up the texture-blending\nWhere Texture is our surface normal map and DiffuseCelor is an iterated color\nbump mapping with respecc to local lights near large triangles.\n‘Tangent space bump mapping is much improved over model space bump map-\nping in that bump-map textures no longer must be unique and can be dled across a\n‘Tangent space bump mapping is less CPU-efficient than model space bump map-\nA more subtle disadvantage of tangent space bump mapping is not necessarily\nincorporating bump mapping into an actual game environment.\n5.6 Hardware Bump Mapping 558\ntangent space bump mapping requires defining a relationship berween how the bump\nthe Fact that the “out” direction of the height map corresponds to +2 in tangent space.\nThis is the same problem as in the model space bump mapping example.\nwary, implicit mapping whereby they simply choose a world or model space axis, such\ntogether to bump map our sphere using this bump map.\ncomes in the next day and rotates the bump map %) degrees on che model and\nthe mapping from tangent space to bump map space.\nThe artist knows how she wanes che bump map applied, so che program should\nto take inte account how the bump map is actually applied no a model and assumes\nTangent space bump mapping requires knowing how the texcure was applicd—\nIris this assumption thar makes tangent space bump mapping difficult to incor-\nA Solution: Texture Space Bump Mapping\nTexture space bump mapping is similar to tangent space bump mappingand primar-\nRather than generating tangent space matrices at each vertex, texture space bump\nmapping creates what I call a tecture space matrix that takes into account exactly how\nmapped.\nAt mun time, we can move the light vector into local model space using the\nNow the dot product can be computed benween the normal map and a light\nvector defined in the same space as the normal map.",
      "keywords": [
        "space bump mapping",
        "Tangent Space Bump",
        "space bump",
        "Bump Mapping",
        "bump map",
        "model space bump",
        "taNgent space",
        "space",
        "Model space",
        "Bump",
        "Texture Space Bump",
        "space bump map",
        "map",
        "Mapping",
        "Advanced Texturing"
      ],
      "concepts": [
        "mapping",
        "map",
        "maps",
        "space",
        "texture",
        "bump",
        "lighting",
        "vector",
        "normal",
        "model"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 59,
          "title": "",
          "score": 0.667,
          "base_score": 0.517,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 60,
          "title": "",
          "score": 0.612,
          "base_score": 0.462,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 55,
          "title": "",
          "score": 0.58,
          "base_score": 0.43,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 58,
          "title": "",
          "score": 0.535,
          "base_score": 0.385,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 52,
          "title": "",
          "score": 0.481,
          "base_score": 0.331,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "bump",
          "space bump",
          "bump mapping",
          "mapping",
          "bump map"
        ],
        "semantic": [],
        "merged": [
          "bump",
          "space bump",
          "bump mapping",
          "mapping",
          "bump map"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15702110281179943,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.605065+00:00"
      }
    },
    {
      "chapter_number": 57,
      "title": "Segment 57 (pages 550-561)",
      "start_page": 550,
      "end_page": 561,
      "summary": "Ground-Plane Shadows\nProjecting shadows of arbitrary objects onto other objects or arbitrary terrain is diffi.\nHowever, if you are projecting shadows onto a flat ground plane, there is a sim:\n‘This method suffers from misregistration effects between object and shadow.\narticle presents a simple technique for ground-plane shadows that performs a physi-\nsource relative to the object determine the shadow projection matrix.\nmatrix, the object is rerendered with che additional cransform to draw the shadow.\nThe object used for the shadow need noc be the same as\nThe polygons of the shadow object overlap after projection onto the\nThe technique can be extended to project shadows onto any 3D) plane, nor just a\nplane aligned with the coordinate axes, Used twice, the technique can project shadows\nShadows result when a solid object comes between a light source and a surface.\npoint on the surface is in shadow if a ray from the light to the point intersects che\noutlines the areas of the surface thar are in shadow.\nthis method gives a projected shadow polygon on the surface.\n5.7 Ground-Plane Shadows 563\nprojected shadow polygon needs to be subdivided to conform accurately co the sur-\nAn alternative to rendering the projected shadow polygons is co modify the\nvertex colors of the surface, darkening the vertices thar are in shadow, bur this has the\nDynamic shadow map textures can be used to compute\nA light ata peane 2 casts a shadow of point Fionn the ground plane at\nthe light is relatively far away from the object relative to the length of the shadow, we\ncan approximate (sx — £:) with (ax —é,), the distance from the object to the light.\nExtending this to three dimensions and projecting the shadow point S onto the x-\nBy projecting cach of the vertices of the object onto the ground plane, we get a\ncollection of projected polygons that can be rendered to create the shadow of the\n5.7 Ground-Plane Shadows 565\nare completely determined by the relative position of the object and the light.\nTo easily incorporate dhe shadow projection process into the rendering pipeline,\nc= (oxy ot, 1) is the projected shadow point in world space,\nSis the shadow projection matrix, written as\nNow to render the shadow of an object, we simply insert che shadow projection\nThis expression makes use of the shadow projection marrix to transform the\npoints of an object into the projected shadow points on the ground plane.\nshadow projection matrix $ depends only on the constant: &f and £2, which are\nIfthe shadow matrix $ is simply inserted into the pipeline and the object rerendered,\non, To render the object as a shadow, we con render cach verrex as a flar-shaded\nshadow.\nProjecting the teapot geometry onvo the ground plane renders the shadow of the teapot\ndiminated using the hardware #-buffer: After the first shadow polygon has been\nFigure 5.7.2 shows a teapot rendered with a projected shadow.\nAs presented, this article makes it easy to project shadow geometry onto a horizontal\nShadows are projected onto the arbitrary plane by roraring and traniating it back to\nhorizontal, projecting the shadow, and then transforming back the plane position.\nReal-Time Shadows on\nradiosity could produce accurate shadows, in which both the objects Cascing the shacl-\nThe Light Source, Blocker Object, and Receiver\nblecwer) blocks some of the light coming from che light source, casting a shadow an\nShadow, receiver, blacker, and lighe source.\nIf the light source is a poine light (infinitely small), the blocker object blocks the\nwane (see Figure 5.8.2), A shadow is created on a receiver object where its surface inter-\n1. Between the light source and P,\nShadow volume\nThe shadow volume.\nthe shadow velume can be accurately modeled by projecting a pwo-dimensional mask\nfrom the position of the poine light source, Consequently, using che same projection,\nwe can map this 2D mask on the receiver objects to define che shadowed areas!\n2D mask is called the shadow map, and it can be simply derived by drawing the\nblocker object's silhouere as sen from the light source,\na properly projected 2D image or mask (see Figure 5.8.3b) to define the shadow vol-\nThis method is usually referred to as projective shadow mapping.\n1. Create a shadow map for each light/blocker object pair.\n2. Calculate the shadow map (texture) coordinates to use on the receiver object's\n3. Render the receiver objeces with the shadow map applied as a 2D texture.\nCreating the Shadow Map\nThis projection projeas the blocker object onto a\nvirtual screen plane between the light source and the blocker object, yielding che\nshadow map shown in Figure §.6.4.\nshadow map\nThe shadow map projection (also Color Plate 6).\n5.8 Real-Time Shadows on Complox Objects STi\nof the screen plane on which we project the shadow map.\nobject into this Mehr coordinate system, illustrated in Figure 5.8.5., we can easily project\nblocker object is polygonal, and we have an array of all che polygon vertices that are\nvertices of the blocker) and another point: che position of the light source.\nthe light source and point to each vertex.",
      "keywords": [
        "shadow",
        "light source",
        "object",
        "light",
        "shadow map",
        "Blocker Object",
        "shadow projection",
        "shadow volume",
        "shadow projection matrix",
        "projected shadow",
        "Sei Texture Space",
        "source",
        "Mapping Sei Texture",
        "projected shadow polygon",
        "shadow polygon"
      ],
      "concepts": [
        "shadows",
        "object",
        "objectives",
        "lighting",
        "projecting",
        "projection",
        "polygons",
        "polygonal",
        "texture",
        "textured"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 37,
          "title": "",
          "score": 0.605,
          "base_score": 0.455,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 58,
          "title": "",
          "score": 0.563,
          "base_score": 0.563,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 43,
          "title": "",
          "score": 0.45,
          "base_score": 0.45,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.419,
          "base_score": 0.419,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 56,
          "title": "",
          "score": 0.39,
          "base_score": 0.39,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "shadow",
          "shadows",
          "light",
          "plane",
          "shadow map"
        ],
        "semantic": [],
        "merged": [
          "shadow",
          "shadows",
          "light",
          "plane",
          "shadow map"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2192815854685869,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.605111+00:00"
      }
    },
    {
      "chapter_number": 58,
      "title": "Segment 58 (pages 562-569)",
      "start_page": 562,
      "end_page": 569,
      "summary": "5.8 Real-Time Shadows on Complex Objects 873\nThe projection to map the shadow-map texture on the receiver object is the same as\nthe one used to draw the shadow map; therefore, the orientation of the shadow map\nmicet these criteria, 3¢ for simplicity, we use a unit vector V[x,y,<), with one coordinate\ncoordinates define the paneifel or artbogomal projection of the blocker object onto che\nshadow-map plane (which is parallel with the XY plane of the light coordinate sys-\n5.8 Real-Time Shadows on Complex Objects Ts\nblocker object's silhowette changing size in the shaclow map if we move the light\nthe blocker or if the light source looked ar ir from a different angle.\ncould result in a tiny image of the blocker in the middle of the shadow map or an\noversized image thar doesn't fit in the shadow map (see Figure 5.8.6).\n(Figure 5.8.Ga), we get a low-resolution shadow map with bad artifacts on the receiver\nThis is a waste of shadow-map merry,\nleaking” (see the section “Texture Coordinates and Shadow-Map Coordinates\").\nthis case, the shadow-map size is not large enough,\nperspective projection adaprve for boch the X and ¥ direction, meaning thar che\nblockers silhouette always properly fills the shadow map, making the best usc of all\n* On some hardware, alter drawing the shadow map image, we have to transfer it\nNow we can fill our a standard perspective projection matrix for the blocker\nshadow map in pixels, Z_,,and Z¢, are the distances of the near and far clipping planes\nforms a perspective projection from blocker local coordinares ro shadow-map coordi-\nand JM nihertscaTiShednitee INOO the MODELVIEW macrix and start drawing the shadow map\nTo decrease the time it takes to create the shadow map, we can wee owe or three differ-\n* To set up the shadow map projection, we blocker geometry with a minimum\nbecause that would draw on the one-pixel edge of the shadow map, ruining texture\n5.6 Heal-Time Shadows on Complex Objects\ncompute MDW (just use a vector from the light source to the center of the bound-\n* ‘To draw the shadow ALP, Wc blocker geometry witha Minimum or oo Surpance de\n* And, of course, to draw the blocker object, we need the geometry with all che sur\nrenderer code to draw the shadow map:\n* Wo clipping needed (the blacker’s image always firs in the shadow map!).\nProjecting the Shadow Map on a Receiver Object\nNow we have a shadow map associated with a blocker object and a light source.\nshadow map can be projected on any number of receiver ebjeces, and because it is ap-\nAs mentioned before, we use the same projection to project the shadow map on a\nreceiver as we used to create the shadow map, The only differences are the image offset\nthe marrix that we need co go from receiver local space directly to shadow-map texture\nTexture Coordinates and Shadow-Map Coordinates\nThe shadow map is an image with a finite number of pixels and integer coordinate val-\nto make sure char che rexel used on che receiver is che color used for “no shadow\" (black\nexample, in che [—1_.0] range of texture coordinates, the texture produces the same\nfect on the receiver object outside the [0.1] texture coondinare range.\nTexture clamping effectively saves us from vesting the receiver objects for intersec-\ntexture border color, we have to leave a one-pixel-thick border on the shadow map.\ndepend on the resolution of the shadow map.\nRendering the Receiver Objects\n* Single-pass rendering, If there is no other texture on the receiver object, we can\ndraw it in one pass, applying a black-on-white shadow map asa texture and using\n2. Draw the shadow pass with subtractive pixel blending, using a white-on-black\nshadow map.\nThis projective shadow-map-\nOne side effect of projective shadow mapping is that it normally maps a shadow on the\nside of the receiver facing away from the light source.\nReceiver Is Behind the Light Source\nYou have to explicitly check for this case and not map a shadow on the receiver object.\n‘This case requires multipass rendering with subtractive blending on the receiver object.\nUse a receiver rendering pass for cach shadow map.\ncrease the intensity (RGB values) in the shadowed areas on the surface of the receiver,\neffect of shadow inrersections is incorrect because the owo blockers block the light of\nis already a shadow drawn.",
      "keywords": [
        "shadow map",
        "shadow",
        "blocker object",
        "map",
        "light source",
        "receiver object",
        "texture",
        "receiver",
        "shadow map projection",
        "object",
        "blocker",
        "light",
        "Lin",
        "Texture Coordinates",
        "projection"
      ],
      "concepts": [
        "shadows",
        "map",
        "mapping",
        "maps",
        "coordinate",
        "projection",
        "projected",
        "objects",
        "vector",
        "blocker"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 57,
          "title": "",
          "score": 0.563,
          "base_score": 0.563,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 59,
          "title": "",
          "score": 0.555,
          "base_score": 0.405,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 56,
          "title": "",
          "score": 0.535,
          "base_score": 0.385,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 55,
          "title": "",
          "score": 0.437,
          "base_score": 0.287,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 53,
          "title": "",
          "score": 0.403,
          "base_score": 0.253,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "shadow",
          "shadow map",
          "map",
          "receiver",
          "blocker"
        ],
        "semantic": [],
        "merged": [
          "shadow",
          "shadow map",
          "map",
          "receiver",
          "blocker"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.17581036026039898,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.605156+00:00"
      }
    },
    {
      "chapter_number": 59,
      "title": "Segment 59 (pages 570-580)",
      "start_page": 570,
      "end_page": 580,
      "summary": "Mapped Reflection Using\nIn order co render a realistic scene, we must be able oo handle surfaces that can reflect\nEnvironment mapping [Blinn76] has been used to\nhardware} area recent enhancement to environment maps,\none or more texture maps.\nThe value of cach texel is the amount of light arriving at the map's\nthe case of cube maps, by using the vector itself as a texture coordinate.\non the environment map to allow for simulated reflections.\nThe primary faule with ceaditional environment maps is che assumption thar all sur-\nfaces thar reflect light do so perfecely—thar is, che assumption char every incoming\namount of energy reflected in a particular direction depends on properties of the sur-\nthat serves as an abstraction thar models surface reflection.\n5.9 Improving Environment-Mapped Reflection 583\nequation is used to apply the Phong BRDF to environment maps.\ntopic BRDF to prefilter environment maps.\nused for dynamic environment maps), it increases che memory requirements for tex-\nAnother assumption made when using environment maps is that the reflecting sur-\nface is metallic, When non-metallic surfaces reflect, che reflectance depends on the\nGis che angle between the incoming direction and the surface normal\nTexture memory, ic makes sense 00 use texture-mapping techniques to improve the:\n6.9 Improving Environment-Mapped Reflection 585\nIt refracts light going through it and distorts che environment that\nRasterizer, Frame Buffer, Z-Buffer, and Pixel\nTo draw a transparent object with today's 3D hardware, we usually use che fearure\ncalled pixel bienaing, or simply blending.\nPixel blending is implemented in the last\npixels with Nand screen coordinares and a depth (4) value.\nA simple pixel rendered with 2-buffering enabled will:\n= Compute the 2 (depth) value of a pixel to be drawn.\npixel color and Z value im their respective buffers; if not, it does not change the\nIn OpenGL, a smaller 2 value means that a pixel is closer to the viewer.\ndrawing a scene, the 2-buffer is initialized (cleared) vo che maximum Z value at each\nBecause the standard Z-buffer technique simply overwrites a pixel if it belongs to a\ndrawing perfectly opaque surfaces.\nTo draw a transparent surface, instead of overwrit-\ning the pixel color in the frame buffer with the incoming (source) color, we need to\nalready in the frame buffer at the corresponding pixel.\nThis gives us che following blending formula:\nTo make pixel blending work in OpenGL, we have to enable it by calling:\nFor a full description of pixel blending.\nSince we have to consider the # values, we refer to pixels as AGRZ.\nopaque object or a transparent one and:\n* Tis Z value indicates that it is closer co che viewer chan che corresponding pixel\nalready in the frame buffer (it is in front of the object or objects\nDrawing Opaque Objects\nthe viewer than GRE secure WE CAN Simply overwrite che frame buffer + Sti it.\nDrawing Transparent Objects\ndrawn pixel is.\nA,_..-0.0 means that che pixel i completely rransparenc; 1-0 means it's\nThis formula uses the presence of alpha-bivplanes in the frame buffer to keep\nupdate the alpha values of the pixels drawn.\ndifferent primitives) occupying the same screen position but with different depth values.\nAv depth complexity of 1 means char there are no primitives overlapping on che\npixel is 2_ In this case, an opaque pixel cither obscures che background or a transpar-\nent pixel or itis behind only ame_opaque of transparent pixel.\nSpecifically, we can disable # overwriting, so when a pixel is drawn, only che\nRGB values are changed in the frame buffer.\nTo draw opaque and transparent objects in the same image, we can take a nor per-\n* Draw all the opaque primitives (triangles, lines, and the like) with Z-resting and\ncomplexity between transparent pixels), <-werwnting disabled, and using Blend\nand that opaque surfaces behind transparent ones show through.\nthat two transparent surfaces always blend correctly if both surfaces have an alpha\nvalue of 0,5, because 0.5 = 1.0 — 0.5, so Blend Formula A and Blend Formula B are\nTherefore, it does not matter if che currently drawn transparent pixel is\n* Sort all transparent primitives by depth and draw chem in farthest-to-nearest\nso we need a per-pixel depth\nwhich means that if a pixel’s £ value is less chan the value in the Z-buffer, the pixel is\nWe need the presence of alpha values in the frame buffer for\n2. Clear the alpha-buffer with value 0 (transparent).\n3. Set function to prearer-ohan (draw behind), use Blend Formula A, and draw the\nalpha value of the primitive into the frame buffer so chat subsequent pixels\n4. Set 2 function to fee-than-or-equal (draw in frone), use Blend Formula A, and\nprimitive in the frame buffer so char subsequent pixels behind it are blended car-\n6. Ser 2 function to greater-than (draw behind), use Blend Formula B, and draw all\nframe buffer is 1.0 (or che maximum integer valuc),\nUnforcunarely, if more than one pixel is drawn in any given position of the frame\nstore only one depth value on a pixel, with subsequence pixels overwriting the old val-\nsurfaces drawn in the frame buffer:\nIf, the pixel being drawn, is between Surface, and Surfaces Ageccien i 0.5 (only\ncially reeardine che modification of the aloha values in the frame buffer).",
      "keywords": [
        "environment maps",
        "Frame Buffer",
        "Pixel",
        "Blend Formula",
        "che",
        "Transparent Objects",
        "Environment",
        "maps",
        "Transparent",
        "surfaces",
        "frame",
        "Environment maps map",
        "Buffer",
        "objects",
        "formula"
      ],
      "concepts": [
        "pixel",
        "surfaces",
        "reflection",
        "reflect",
        "reflections",
        "reflectance",
        "value",
        "mapped",
        "maps",
        "map"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 60,
          "title": "",
          "score": 0.728,
          "base_score": 0.578,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 56,
          "title": "",
          "score": 0.667,
          "base_score": 0.517,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 55,
          "title": "",
          "score": 0.559,
          "base_score": 0.409,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 58,
          "title": "",
          "score": 0.555,
          "base_score": 0.405,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 53,
          "title": "",
          "score": 0.536,
          "base_score": 0.386,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "pixel",
          "buffer",
          "frame buffer",
          "transparent",
          "frame"
        ],
        "semantic": [],
        "merged": [
          "pixel",
          "buffer",
          "frame buffer",
          "transparent",
          "frame"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23851429802838117,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.605202+00:00"
      }
    },
    {
      "chapter_number": 60,
      "title": "Segment 60 (pages 581-588)",
      "start_page": 581,
      "end_page": 588,
      "summary": "For simulating reflections, we can use sphere- of cube-environment mapping.\nglTexGeni (Gl §, GL_TEXTURE_GEM MODE, GL_SPHERE_MAP) ;\nglTexGeni (Gl 1, GL_TEXTURE_GEM_WODE, 6L_ SPHERE_MAP) ;\n= An environment map applied as a 2D texture, the texture coordinates computed\n2. Render the reflections on top, using additive blending (as in the single-pass case).\nRefraction Mapping for\nIn chis article, we Present a concise and practical method of refraction-mapping lige\nton, and Fresnel terms are computed for water simulations at interactive rates.\nthat it incorporates refractive, reflective, and Fresnel cerms, The Fresnel term is exsen-\ntally used asa blend factor between the refractive and reflective terms [T#'087):\nRemit = Fresnel * Refraction + (1-Fresnel) * Reflection\nRefraction Term\nSnell’s Law is chen used to refract the eye ray for each of these\n5.11 Rofraction Mapping for Liquids in Containers.\nSince the ratio of indices of refraction of water te air is 1.33, we use this value to com-\npute the refracted ray asa function of the water normal ar the given vertex, a: shown\nReferring to Figure 5.11.1, the angle berween the water normal and the eye ray\nThe angle between the refracted ray and the\nnegated water normal (@)) is known as the angle of refraction.\nFrom here it is a simple matter to compute the refracted ray from the eye ray 30\nOnce the refracted ray is computed, it i: necessary to determine the point of intersec-\ntion of the refracted ray with the container.\nThe refraction map (also see Color Plate 12).\nrefracted ry with the walls of the container, In this case, our container is made up of\nposition on the inside of che container to a texture coordinate in a single refraction\nmap, which shows all five faces of che container, as in Figure 5.11.2,\nIn Figure 5.11.1, the refracted ray intersects the bowom face of the pool.\ngenerates a texture coondinate in the corresponding region of the refraction map\n5.11 Refraction Mapping for Liquids in Containers 507\nsurrounding the water pool, but the same technique, with the pre-lit refraction map\nNow thar the reflection and refraction terms have been computed, they must be com-\ntions determine the ratio of reflected light to refracted light at a point on the water\nterm is usually treated as simply a blend factor between the refractive and reflective\nThe texture maps used are static,\nand the EXT_texgen_reflection extension, fora single paraboloid covironment map.\nThe Fresnel term serves as the blend factor between the two maps and is stored in the\nRemalt = Fresnel * Refraction + (1-Fresnel) * Reflection\nWith the reflection map in texture zero, the refraction map in texture 1, and the\nglTexEnvt (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COWBINE_EXT):\n(GL TEXTURE ENV, GL_OPERANDO RGB EXT, GL_SAC_ COLOR);\nglTexEnvt (Gl _TEXTURE_ENV, GL_SOURCE1 RGB_EXT,\nglTexEnvt (GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SAC_ALPHA);\nglTexEnvt (GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_MOOULATE};:\nglTexEnvt (GL TEXTURE ENV, GL AGS SCALE ExT, 1.0%);\n(GL TEXTURE EMV, GL_SOUACEO ALPHA ExT,\nglTexEnvt (Gl_TEXTURE_ENV, GL_OPERANDO_ALPHA_EXT, GL_SRC_ALPHA):\n(Gl TEXTURE_EMV, GL_COMBINE ALPHA EXT, GL_REPLACE);\nglTexEnvt (GL_TEXTURE_EMV, GL_TEXTURE_ENV_ MODE, GL_COMBINE EXT);\nglTexEnvt (GL_TEXTURE_EMV, GL_SOURGED_RGB_EXT, GL_TEXTURE):\nglTexEnvt (GL_TEXTURE_EMV, GL_OPERANDO_AGS EXT, GL_SAC COLOR);\nglTaxEnvt (GL_TEXTURE_EMV, GL_SOURCE1_AGS_EXT, GlL_PREVIOUS ExT);\nglTexEnvt (GL_TEXTURE_ENV, GL_OPERAND1_AGS_EXT, GL_SRC COLOR):\ng1TaxEnvt (GL_TEXTURE_ENY, GL_COMBINE_ALPHA EXT, GL_REPLACE) -\ning system is minimal; this technique is so far just a method for computing texture\nWe have outlined a simple equation for water that includes reflection, refraction, and\n5.11 Refraction Mapping for Liquids in Containers 599\nmodel the refraction of light rays from a given light source and their intersection with\nWe have presented a concise method of simulating refractive, reflective, and Fresnel\ntexture coordinates for the reflection and refraction maps and does no updates to the",
      "keywords": [
        "texture",
        "EXT",
        "ALPHA ExT",
        "container",
        "refraction map",
        "Refraction",
        "texture coordinates",
        "Fresnel term",
        "TEXTURE ENV",
        "Fresnel",
        "MAP",
        "COMBINE ALPHA EXT",
        "env",
        "water",
        "alpha"
      ],
      "concepts": [
        "texture",
        "textured",
        "mapping",
        "map",
        "refracted",
        "refraction",
        "colored",
        "light",
        "containers",
        "caustic"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 59,
          "title": "",
          "score": 0.728,
          "base_score": 0.578,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 56,
          "title": "",
          "score": 0.612,
          "base_score": 0.462,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 55,
          "title": "",
          "score": 0.58,
          "base_score": 0.43,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 53,
          "title": "",
          "score": 0.551,
          "base_score": 0.401,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 54,
          "title": "",
          "score": 0.437,
          "base_score": 0.287,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "refraction",
          "fresnel",
          "ext",
          "gltexenvt",
          "texture"
        ],
        "semantic": [],
        "merged": [
          "refraction",
          "fresnel",
          "ext",
          "gltexenvt",
          "texture"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.17903039461121184,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:16.605247+00:00"
      }
    },
    {
      "chapter_number": 61,
      "title": "Segment 61 (pages 589-596)",
      "start_page": 589,
      "end_page": 596,
      "summary": "Using Beta-Splines and Reflective and Refractive Texture Mapping,” ACS Trans-\nThe Matrix Utility Library\nMatrix libraries are an integral part of game programming, and essencial in a wide\nvariety of applications such as advanced graphics, physics, collision detection, cte.\nwas inevitable thar many of the articles would need to use some matrix operations\noutside of the OpenGL matrix functions.\nutors, a (C++ matrix library was written for all accompanying demo software to utilize.\nlibrary for your game, and optimize it for your environment.\nThe libraries contain five main classes: vactor2, vactora’, vectors, matrixa3, and\nmatrixes.\nmatrinégé is a 4x4 matrix).\nVectors have public members called x, y, 2, and mw, and\nmatrices are composed of arrays of vectors.\nThis library was designed ta provide the\nsame functionality and format as the OpenGL mamix functions; therefore, matrices\nMost of the standard matrix and vector opera-\nprovided as utility functions for a more coherent notation.\nThere are a few things to keep in mind when using these libraries.\nB02 : Appendix 6.0 The Matrix Utility Library\nThe classes provide appropriate initialization constructors and set methods.\nond, a point class is not provided.\nponent is set (usually to 1-0) for vectors that are treated as points.\nto load a marrix onto the OpenGL matrix stack, it is safe to casta pointer-to-matrix44\nThe code for the entire matrix library is on the CD.\nPlease refer to the library for\nThe Text Utility Library\nThere comes a point in every game's development when output is necessary.\nif your game uses full screen mode.\nmay find it beneficial to write such a library and incorporate it inte your game.\ntext library is a basic implementation of an ourpur text library written for OpenGL, It\neach 8x8 character is only 16K Bytes, so this library is perfect for debugging and pro-\nThe texe utility library is composed of one class named TextBox. It provides two\nmethods for drawing text to the screen.\nto draw che text in screen space.\nmatrix state.\nyou initialize an area of che screen to be the “text box.” Then, all the text printed\nUnlike che first method, the text is stored in memory until the\ngame.\nThe entire source code for the rext utility library is contained on the CD, along with\nPlease see che code for more details on how to use it.\nEnclosed with this book you will find a CD-ROM thar is filled with all of the code\nro you, you need to have the source code in a form that you can use.\n* All the source code listed in each article.\nThe Matrix Unilicy Library.\nThe Text Unilicy Library.\nmore information about the book and about game programming in general!\n2h)\nArrays\nBarefissoarce class, H-33\nBounding volumes, 380\nB-spline:\ntexture space bump mapping, 559-561\nAppendiz 6.0 The Matrix Utility Library\nexposed functionality of, 3\nfirst-person cameras, SF 1-3F3\n15—16\nfinire-arare machine class, 257-245\nin-game profiling, 120-130\nConstane, in data-driven dozen, 3-4\nmaps, 10=53\npath function cost, 259=760, Fi 265\nCoupling of clases, avoiding, 15-16\nalgorithms, 382-384\ntext files and, 3\nconsole game syecems, 115=1 15\nreal-time in-game profiling, 120-130\nStarland Templar: Library (311), 48-50\nDerail, levels of, 433-j58\nDynamic Link Libraries (IXLLs), generic friction\nin data-driven dese, F\nState sytem for data-editing, 115-119\nonline games and, 14-108\nEngines, Al\nEngines.\nEuler method\nFeet, for game objects, (4\nField-ol-view culling, 422424, 425429\nsteenng behaviors, 305—20G\nFrustara culling, 422—(23\nFunctionality, exporting, $6=67\nFunction abjeces, 52\nFunction everhead, 353-454\nFunctions\ncalling functions, 63-44\nFunctions, exporring, $6—67",
      "keywords": [
        "Matrix Utility Library",
        "Pixel Effects",
        "Utility Library",
        "Library",
        "Utility Library Dante",
        "Matrix",
        "Library Dante Treglia",
        "Text Utility Library",
        "matrix library",
        "Matrix Utility",
        "Text",
        "Text Unilicy Library",
        "Wave Theory Revis",
        "Source Code",
        "text library"
      ],
      "concepts": [
        "classes",
        "functions",
        "functionality",
        "function",
        "library",
        "libraries",
        "matrix",
        "matrixes",
        "mapping",
        "maps"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 37,
          "title": "",
          "score": 0.428,
          "base_score": 0.428,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 60,
          "title": "",
          "score": 0.426,
          "base_score": 0.426,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 4,
          "title": "",
          "score": 0.423,
          "base_score": 0.423,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 38,
          "title": "",
          "score": 0.403,
          "base_score": 0.403,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 55,
          "title": "",
          "score": 0.39,
          "base_score": 0.39,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "library",
          "text",
          "utility",
          "utility library",
          "matrix"
        ],
        "semantic": [],
        "merged": [
          "library",
          "text",
          "utility",
          "utility library",
          "matrix"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.25163389867116515,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:16.605309+00:00"
      }
    },
    {
      "chapter_number": 62,
      "title": "Segment 62 (pages 597-603)",
      "start_page": 597,
      "end_page": 603,
      "summary": "delumificaion metheds, $27—328\noperations, 321-322\nGame-path planning, 244-262\nwitd in mapping, 403\nim ftexiiamager, £5865\nbump mapping, 555-54]\nwavelers for compresiian, 185— 12\nimplicant methods, 177-178\nInteraction detection, multi-resolution maps far,\nInterpolations, 141-149\nRoaring-paine mach im, 141-142\nlinear interpolation (lerp), 2065, 209-211\nspherical cubic interpolation (sized), 207-208\napheneal line interpolation (slerp), ho—207\nspline inrerpolarians, 28, 711-215\nhermite spline, A676\napline interpolating vertices, 469-470\nrerriacs and normals, interpolating of, 467\nLandscaping, 44-10\nalgorithms for, 465-490\nStandard Tomplace Library (STL), 46-49.\nLocations, parh search states, 757299\nLogic\nLogs of messages and state transitions, 232-233\nalgorithm for selection, 435-437\nLighting\nattensstion maps, 343-548\nbump mapping for, $55-$61\night coordinate seems, 57 1—$74\nreflections, $$3-—554, $41-$85, 592\nvertex color interpolation for, 537-542\nbump maps for texmuring, 55561\nenvironmens maps, 193, 581\ngrid-based maps, 403\nbphr maps, 343-548\n,Sivironment mapped, $41-5845\nrefraction mapping, $4600\nshadow map, $67—5E0, 570\nsphenical reflection maps, 544-934\nSrandard Template Library, 50-53\nrefraction maps for, $4600\nquatermions 24 feplacemend for, 195—] es\nMemory\nAS algorithm and, 2 Zr, 278-200\nflocking and, 346\nmanagement af, 80-87\nrelraseng, 95—100)\nnavigation meshes, 288-304\nMessage objec, 222-223\nfractal terrain peneration, M3-S0\"\nMovement, navigation meshes and 3D, 288-304\nMulrieresolurion mapa, 405—41 1\nNavigation mesh\nNerworks, prococals for online games, 104-108\nNeural ners, 3M 35h\nclassification and reonpmizion, 34 1—=<244\ngame applications for, 331-332\ndesign techniques and, B-19\nneighbors, 442\nOnline games: network prococel for, 104-108\nOpen lists, 262-286\nParticle deposition, fractal terrain generation, 50—§1]\nnerd et ai, IS6—3497\nspace, 257-259\nwith navigation meshes, 294\nPath planning, 754-244\nFunction costs, 259-200\nPARitioning space for, 257-159\nB-spline cures, ST4-476\ndecoupling pachfinding data, 278279\nPlasticity, neural nets and, 336\nPolling objec, 221-222\nPolygon overlaps algorithm, 442\nTaylor series, 167-171\ncalls, adding, 123\nreal-time in-game profiling, 120-130\nspace parrimoning, 254\nQhevtermons, 195—199\nfincas interpolation {lerp), 206, 209-211\nphysical sigmifcance af numbers in, |-197\nshores are quatemion, 214—218\nsphencal cubic interpolation (squad), 207-208\nspherical linear interpolation (dep), 205-207,\nspline intcrpolations, 208, 211-213\nof sare machines, 733\nfractals, random line generatian, “M-})1\nRandom numbers\npredicrable, algorithm for generating, 135-135\nReceiver objects, shadow maps, 578979\nmapping.\nhavc object memory manager, 63\nRigid body motion\n34 Findse se machines, 5\nSearch algorithms, 254-262\nSending random peneraror, algorithm for.\nadaptive projections, 575-577\nlight coordinate srstemes fier maps, 571-574\nrendering implementation, 563-366\nSime of game objects, 403—404\nfast skinning method, 471-472\nSpace\ntoded space, D8\nneural nets as partitioning, aaG-337\nseach space optimizations, 272-27\nrangent space, 555-559\nSphere mapping, $53-554\nSpline istenpolations, MY, 211-215\nSondand Terplate Library, Ca+ (STL), 41-45\ncontuners, 41—42\nmaps, P33\nState machines, 275-735\nFinice Stare Machines (FSM), 237-248\nmultiple stare machines, 233\nSee abe Stare machines\nScaristics, real-time and in-game debugging, 115-119\nSreering belavtars, 305—\nSTL.\nSe Standard Templare Library, Cre (ST)\nTangent space, 356-399\nTemplates\nbump mapping for, $55-$61\nprojection of, 550-551\nreflection mapping, 553-554\nthadow maps and.\nshine-thorough problem, $52\nThresholds\nTraffic, furey logic for modeling, 372-528\nrendering.\nPaine trees, 249754.\nTriangle-co-nriang}e collision detection algorithm, 390,\npopping ex.\ndata loading, 90-91\nalpha blending Eng alssparency.\ninteractive simulations, 187-14\nrendering, 193-194\napecd and visual qualiry, 194\nWave equations, LAT-199\nHaar waveless, 184-186\nimage oeniproasion, 185—186",
      "keywords": [
        "319-329 delumificaion metheds",
        "Fisezy loge",
        "maps",
        "space",
        "319-329 delumificaion",
        "delumificaion metheds",
        "mapping",
        "interpolation",
        "algorithm",
        "Library",
        "Funnccors",
        "Fisezy",
        "navigation meshes",
        "rendering",
        "machines"
      ],
      "concepts": [
        "mapping",
        "maps",
        "map",
        "space",
        "objects",
        "machine",
        "interpolations",
        "interpolation",
        "interpolating",
        "game"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 49,
          "title": "",
          "score": 0.435,
          "base_score": 0.435,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 47,
          "title": "",
          "score": 0.424,
          "base_score": 0.424,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 44,
          "title": "",
          "score": 0.419,
          "base_score": 0.419,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "",
          "score": 0.399,
          "base_score": 0.399,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 28,
          "title": "",
          "score": 0.381,
          "base_score": 0.381,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "maps",
          "interpolation",
          "mapping",
          "machines",
          "41"
        ],
        "semantic": [],
        "merged": [
          "maps",
          "interpolation",
          "mapping",
          "machines",
          "41"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2773575967553231,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:16.605362+00:00"
      }
    }
  ],
  "total_chapters": 62,
  "enrichment_provenance": {
    "taxonomy_id": "none",
    "taxonomy_version": "none",
    "taxonomy_path": "none",
    "taxonomy_checksum": "sha256:none",
    "source_metadata_file": "Game Programming Gems 1_metadata.json",
    "enrichment_date": "2025-12-17T23:07:16.617365+00:00",
    "enrichment_method": "msep",
    "model_version": "ai-agents-msep-v1",
    "processing_time_ms": 5059.371459999966,
    "total_similar_chapters": 307
  }
}