{
  "metadata": {
    "title": "The Little Book Of Python-Anti-Patterns",
    "source_file": "The Little Book Of Python-Anti-Patterns_metadata.json"
  },
  "chapters": [
    {
      "chapter_number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "summary": "Python Anti-Patterns\nThe Little Book of Python Anti-Patterns and Worst Practice\n. 1.1 Assigning a lambda expression to a variable .\n2.2 Returning more than one variable type from function call .\n. Not using named tuples when returning more than one value from a function .\nPython Anti-Patterns\nThis is a small book of Python anti-patterns and worst practices.\nLearning about these anti-patterns will help you to avoid them in your own code and make you a better programmer (hopefully).\nLong answer: There is an overwhelming amount of Python books that show you how to do things by focusing on best practices and examples of good code.\nWe wanted to change that by providing you with an anti-book that teaches you things which you should never do in practice.\nPython Anti-Patterns\nThis book contains anti- and migrations pattern for Python and for popular Python frameworks, such as Django.\nCorrectness: Anti-patterns that will literally break your code or make it do the wrong things.\nMaintainability: Anti-patterns that will make your code hard to maintain or extend.\nReadability: Anti-patterns that will make your code hard to read or understand.\nPerformance: Anti-patterns that will unnecessarily slow your code down.\nSecurity: Anti-patterns that will pose a security risk to your program.\nThe only thing we ask in return is the inclusion of a link to this page on the top of your website, so that your readers will be able to ﬁnd the content in its original form and possibly even contribute to it.\nHere’s the full index of all anti-patterns in this book.\nPython Anti-Patterns\nPython Anti-Patterns\n1.1.1 Anti-pattern\n1.2 Assigning a lambda expression to a variable\nThe use of the assign- ment statement eliminates the sole beneﬁt a lambda expression can offer over an explicit def statement (i.e. that it can be embedded inside a larger expression)\nPython Anti-Patterns\n1.2.1 Anti-pattern\nThe following code assigns a lambda function which returns the double of its input to a variable.\nPython has a number of built-in functions that are always accessible in the interpreter.\nUnless you have a special reason, you should neither overwrite these functions nor assign a value to a variable that has the same name as a built-in function.\n1.3.1 Anti-pattern\nIn the code below, the list built-in is overwritten.\nThis makes it impossible, to use list to deﬁne a variable as a list.\n# Overwriting built-in 'list' by assigning values to a variable called 'list' list = [1, 2, 3] # Defining a list 'cars', will now raise an error cars = list() # Error: TypeError: 'list' object is not callable",
      "keywords": [
        "Python Anti-Patterns",
        "Anti-Patterns",
        "Python",
        "List",
        "lambda",
        "code",
        "function",
        "Book",
        "lambda expression",
        "expression",
        "variable",
        "member",
        "Correctness",
        "built-in",
        "Assigning"
      ],
      "concepts": [
        "python",
        "list",
        "code",
        "anti",
        "statement",
        "function",
        "functionally",
        "correctness",
        "type",
        "maintainers"
      ],
      "similar_chapters": [
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 7,
          "title": "",
          "score": 0.683,
          "base_score": 0.533,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 2,
          "title": "",
          "score": 0.595,
          "base_score": 0.445,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 3,
          "title": "",
          "score": 0.504,
          "base_score": 0.354,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 5,
          "title": "",
          "score": 0.415,
          "base_score": 0.415,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 4,
          "title": "",
          "score": 0.4,
          "base_score": 0.4,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "anti",
          "patterns",
          "anti patterns",
          "python",
          "book"
        ],
        "semantic": [],
        "merged": [
          "anti",
          "patterns",
          "anti patterns",
          "python",
          "book"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.46392759416860885,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:09:02.701396+00:00"
      }
    },
    {
      "chapter_number": 2,
      "title": "Segment 2 (pages 9-16)",
      "start_page": 9,
      "end_page": 16,
      "summary": "When an exception occurs, Python will search for the ﬁrst exception clause which matches the exception type that occurred.\nIf the exception clause represents a base class of the raised exception, then Python considers that exception clause to be a match.\nE.g. if a ZeroDivisionError exception is raised and the ﬁrst exception clause is Exception, then the Exception clause will execute because ZeroDivisionError is a sub class of Exception.\nWhen Python experiences an exception, it will linearly test each exception clause and execute the ﬁrst clause that matches the raised exception.\nSo long as the raised exception is a sub class of the exception listed in the exception clause, then Python will execute that clause and will skip all other clauses.\nFor a single inheritance situation the ﬁrst argument to super() should be the name of the current child class calling super(), and the second argument should be self (that is, a reference to the current object calling super()).\nNote: This anti-pattern only applies to Python versions 2.x, see “Super in Python 3” at the bottom of the page for the correct way of calling super() in Python 3.x.\nThe ﬁrst argument should be the name of the child class that is calling super().\n# bad first argument to super() super(self, Square).__init__(length, length)\nIn the modiﬁed code below the author has ﬁxed the call to super() so that the name of the child class which is calling super() (Square in this case) is the ﬁrst argument to the method.\n# super() executes fine now super(Square, self).__init__(length, length)\nThe correct way to call super() in Python 3 code is as follows.\nStack Overﬂow - Python super() inheritance and arguments needed\nIf the magic number is found then the function prints The list contains the magic number.\nIf it doesn’t then the function prints This list does NOT contain the magic number.\nWhen the code calls the function with a list of range(10) and a magic number of 5, you would expect the code to only print The list contains the magic number.\nHowever, the code also prints This list does NOT contain the magic number.\nThis is because the range(10) list eventually becomes empty, which prompts Python to execute the else clause.\nIf the else clause should not always execute at the end of a loop clause, then the code should add a break statement within the loop block.\nprint(\"This list contains the magic number.\") # added break statement here break\nA contextmanager class is any class that implements the __enter__ and __exit__ methods according to the Python Language Reference’s context management protocol.\nis equivalent to the following block of code using try and finally statements.\nIn order for __exit__ to work properly it must have exactly three arguments: exception_type, exception_value, and traceback.\nIf any exceptions occur while at- tempting to execute the block of code nested after the with statement, Python will pass information about the exception into the __exit__ method.\nThe __exit__ method deﬁned in the Rectangle class below does not conform to Python’s context management protocol.\nThe method is supposed to take four arguments: self, exception type, ex- ception value, and traceback.\nBecause the method signature does not match what Python expects, __exit__ is never called even though it should have been, because the method divide_by_zero cre- ates a ZeroDivisionError exception.\nprint(\"in __enter__\") return self def __exit__(self):\nModifying __exit__ to accept four arguments ensures that __exit__ is properly called when an excep- tion is raised in the indented block of code following the with statement.\nprint(\"in __enter__\") return self\ndef __exit__(self, exception_type, exception_value, traceback):\n# causes ZeroDivisionError exception return self.width / 0\nPython Language Reference - The with statement\nPython Language Reference - With Statement Context Managers\n__init__ is a special Python method that is automatically called when memory is allocated for a new object.\nThe __init__ method of the Rectangle class below attempts to return the area of the rectangle within the __init__ method.\nRemove the return statement from the __init__ method\nRemove the return statement in the __init__ method that is returning a value.\nself.width = width self.height = height self.area = width * height # return statement removed from here\nPython Language Reference - object.__init__(self[, ...])\nIf it was possible to place the __future__ module in the middle of a module, then that would mean that one half of the module could use the old Python functionality for a given feature, and the other half (after the __future__ import) could use the new Python functionality of the feature.\nThe code below attempts to place a __future__ import statement in the middle of the module.\nWhen Python encounters the from __future__ import division statement it raises a SyntaxError and halts execution.\nHowever, if the code were to execute, the ﬁrst print statement would print out 1 (which is how the division operator behaves in Python versions 2 and below), but the second print statement would print out a decimal value, which is how the division operator functions in Python versions 3 and later.\nAs you can see, this could create very strange behavior, so Python does not allow __future__ import statements in the middle of a module.\n# removed __future__ import statement print(8 / 7) # 1",
      "keywords": [
        "Python",
        "exception",
        "Python Language Reference",
        "exception clause",
        "Python Anti-Patterns",
        "References Python Documentation",
        "class Rectangle",
        "Rectangle",
        "ZeroDivisionError exception clause",
        "magic number",
        "super",
        "clause",
        "init",
        "ZeroDivisionError exception",
        "statement"
      ],
      "concepts": [
        "python",
        "classes",
        "exception",
        "exceptions",
        "super",
        "methods",
        "prints",
        "argument",
        "arguments",
        "statement"
      ],
      "similar_chapters": [
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 1,
          "title": "",
          "score": 0.595,
          "base_score": 0.445,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 7,
          "title": "",
          "score": 0.521,
          "base_score": 0.371,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 3,
          "title": "",
          "score": 0.438,
          "base_score": 0.288,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 5,
          "title": "",
          "score": 0.38,
          "base_score": 0.38,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 4,
          "title": "",
          "score": 0.344,
          "base_score": 0.344,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "exception",
          "clause",
          "super",
          "python",
          "statement"
        ],
        "semantic": [],
        "merged": [
          "exception",
          "clause",
          "super",
          "python",
          "statement"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4098684559409017,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:09:02.701456+00:00"
      }
    },
    {
      "chapter_number": 3,
      "title": "Segment 3 (pages 17-26)",
      "start_page": 17,
      "end_page": 26,
      "summary": "For every class member that he wants to expose publicly, he deﬁnes a get and set method for that member.\n# Java-style def get_length(self):\nIn Python it is acceptable to simply access class or object members directly.\nWhen a member needs to be slightly protected and cannot be simply exposed as a public member, use Python’s property decorator to accomplish the functionality of getters and setters.\nPer the PEP 8 Style Guide, all Python code should be consistently indented with 4 spaces, never tabs.\ndef print_hello_world(): # indented with tab\ndef print_hello_world():\nprint(\"Hello, World!\") # indented with 4 spaces\nPer the PEP 8 Style Guide, all Python code should be consistently indented with 4 spaces for each level of indentation, not tabs.\ndef print_hello_world():\n# indented with tab print(\"Hello, World!\") def print_goodbye_world(): # indented with tab print(\"Goodbye, World!\")\ndef print_hello_world():\n# indented with 4 spaces print(\"Hello, World!\") def print_goodbye_world():\nWhen a method is not preceded by the @staticmethod or @classmethod decorators and does not con- tain any references to the class or instance (via keywords like cls or self), Python raises the Method could be a function error.\nThis is not a critical error, but you should check the code in question in order to determine if this section of code really needs to be deﬁned as a method of this class.\nIn the Rectangle class below the area method calculates the area of any rectangle given a width and a height.\nIt does not reference the instance or class using the self or cls keywords and it is not preceded by the @staticmethod decorator.\nClass method is not preceded by @classmethod decorator\nIn the Rectangle class below the print_class_name method prints the name of the class.\nAgain, Python raises the Method could be a function error because the method does not reference any class members or methods and is not preceded by the @classmethod decorator.\nFurthermore, the ﬁrst argument of a class method must be a reference to the class itself.\n# should be preceded by @classmethod here # missing required first argument \"cls\" def print_class_name():\nprint(\"class name: Rectangle\")\n# clarifies that this is a static method and belongs here @staticmethod def area(width, height):\nAdd the @classmethod decorator before the class method\nAll class methods must be preceded by the @classmethod decorator.\nFurthermore, the ﬁrst argument of any class method must be cls, which is a reference to the class itself.\nclass Rectangle: @classmethod def print_class_name(cls):\n# \"class name: Rectangle\" print(\"class name: {0}\".format(cls))\nUnlike some programming languages, Python does not pass references to instance or class objects auto- matically behind the scenes.\nSo the program must explicitly pass them as arguments whenever it wants to access any members of the instance or class within a method.\nIn the Rectangle class below the area method attempts to return the value of the area instance variable.\nHowever, self.area is undeﬁned because a reference to the instance object has not been explicitly passed as an argument to the method.\n# missing first argument \"self\" def area():\nClass method is missing the cls keyword\nThe method print_class_name attempts to print the name of the class.\nHowever, to programmatically access a class name, a method needs to have a reference to the class object.\nThis is accomplished by passing the keyword cls as the ﬁrst argument to the method.\nBecause print_class_name does not do this, its reference to cls in the body of the method is undeﬁned.\nclass Rectangle: @classmethod # missing first argument \"cls\" def print_class_name():\nIt is deﬁned as a method of the Rectangle class, yet it does not reference any instance or class members.\nTo access the area member of a Rectangle instance the ﬁrst argument of the area method needs to be a reference to the instance object, signiﬁed by the keyword self.\n# instance members now accessible because of \"self\" def area(self):\nAdd the cls parameter to class methods\nTo access the name of the class the print_class_name method needs to explicitly pass an argument to the class object.\nThis is done by adding the keyword cls as the ﬁrst argument of the method.\nclass Rectangle: @classmethod # class members now accessible, thanks to \"cls\" def print_class_name(cls):\nIf the method is a static method that does not need access to any instance members, then the method should be preceded by the @staticmethod decorator.\n# clarifies that the method does not need any instance members @staticmethod def area(width, height):\nsuper() enables you to access the methods and members of a parent class without referring to the parent class by name.\nFor a single inheritance situation the ﬁrst argument to super() should be the name of the current child class calling super(), and the second argument should be self, that is, a reference to the current object calling super().\nNote: This error is only raised for Python versions 2.x which don’t support new-style classes.\nIn the modiﬁed code below the author has ﬁxed the call to super() so that the name of the child class which is calling super() (Square in this case) is the ﬁrst argument to the method, and a reference to the object calling super() is the second argument.\nThe ﬁrst time that the function is called, Python creates a persistent object for the list or dictionary.\nEvery subsequent time the function is called, Python uses that same persistent object that was created from the ﬁrst call to the function.\nIn addition to Python’s standard exceptions, you can implement your own exception classes.",
      "keywords": [
        "misplaced-future Simeon Visser",
        "class Rectangle",
        "Python",
        "Python Anti-Patterns",
        "Simeon Visser",
        "method",
        "Rectangle",
        "Python Anti-Patterns Class",
        "length",
        "class Square",
        "World",
        "def print",
        "width",
        "Class method",
        "Square"
      ],
      "concepts": [
        "prints",
        "classes",
        "python",
        "pythonic",
        "argument",
        "arguments",
        "super",
        "method",
        "length",
        "uses"
      ],
      "similar_chapters": [
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 1,
          "title": "",
          "score": 0.504,
          "base_score": 0.354,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 5,
          "title": "",
          "score": 0.486,
          "base_score": 0.486,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 7,
          "title": "",
          "score": 0.471,
          "base_score": 0.321,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 2,
          "title": "",
          "score": 0.438,
          "base_score": 0.288,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 6,
          "title": "",
          "score": 0.35,
          "base_score": 0.35,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "class",
          "method",
          "cls",
          "instance",
          "def"
        ],
        "semantic": [],
        "merged": [
          "class",
          "method",
          "cls",
          "instance",
          "def"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4092857237629558,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:09:02.701471+00:00"
      }
    },
    {
      "chapter_number": 4,
      "title": "Segment 4 (pages 27-34)",
      "start_page": 27,
      "end_page": 34,
      "summary": "When a dict is created using defaultdict(), the value for each key in the dict will default to the value provided as the ﬁrst argument of defaultdict().\nThe code below deﬁnes an empty dict and then manually initializes the keys of the dict.\nAlthough there is nothing wrong with this code, there is a more concise and less error-prone way to achieve the same idea, as explained in the solution below.\nUse defaultdict() to initialize dict keys\nThe modiﬁed code below uses defaultdict to initialize the dict.\nThis code is functionally equivalent to the previous code, but this one is more concise and less error-prone, because every key automatically initializes to 6 with no work on the part of the programmer.\nThe code below searches a list for a magic number.\nIf the magic number is found in the list, then the code prints Magic number found.\nIf the magic number is not found, then the code prints Magic number not found.\nThe code uses a ﬂag variable called found to keep track of whether or not the magic number was found in the list.\nBut the Python language has built-in language constructs for handling this exact scenario and which can express the same idea much more concisely and without the need for ﬂag variables that track the state of the code.\nIf the for loop iterates to com- pletion without being prematurely interrupted by a break or return statement, then Python executes the else clause of the loop.\nIn the modiﬁed code below, the for loop will iterate through all three items in the list.\nThe modiﬁed code below is functionally equivalent to the original code above, but this modiﬁed code is more concise than the original code and does not require any ﬂag variables for monitoring the state of the code.\nThe code below manually creates multiple variables to access the items in a list.\nThe modiﬁed code below is functionally equivalent to the original code, but this code is more concise and less prone to error.\nFrequently you will see code create a variable, assign a default value to the variable, and then check a dict for a certain key.\nWhile there is nothing wrong this, it is more concise to use the built-in method dict.get(key[, default]) from the Python Standard Library.\nIf the key exists in the dict, then the value for that key is returned.\nThe code below initializes a variable called data to an empty string.\nThen it checks if a certain key called message exists in a dict called dictionary.\nIf the key exists, then the value of that key is copied into the data variable.\nUse dict.get(key[, default]) to assign default values\nThe code below is functionally equivalent to the original code above, but this solution is more concise.\nWhen get() is called, Python checks if the speciﬁed key exists in the dict.\nIf the key does not exist, then get() returns the value speciﬁed in the second argument to get().\nWhen initializing a dictionary, it is common to see a code check for the existence of a key and then create the key if it does not exist.\nThe code below checks if a key named list exists in a dictionary called dictionary.\nIf it does not exist, then the code creates the key and then sets its value to an empty list.\nThe code then proceeds to append a value to the list.\nThe modiﬁed code below uses setdefault() to initialize the dictionary.\nIf the key does not exist, then setdefault() creates it and sets it to the value speciﬁed in the second argument.\nThe following code imports everything from the math built-in Python module.\nThe import statement should be refactored to be more speciﬁc about what functions or variables it is using from the math module.\nIn Python 2.5, the file class was equipped with special methods that are automatically called whenever a ﬁle is opened via a with statement (e.g. with open(\"file.txt\", \"r\") as file).\nThe code below does not use with to open a ﬁle.\nThe modiﬁed code below is the safest way to open a ﬁle.\nIf a function that is supposed to return a given type (e.g. list, tuple, dict) suddenly returns something else (e.g. None) the caller of that function will always need to check the type of the return value before proceeding.\nIn the code below, the function get_secret_code() returns a secret code when the code calling the If the password is incorrect, the function returns None.\nleads to hard-to-maintain code, because the caller will have to check the type of the return value before proceeding.\nIn the modiﬁed version of get_secret_code() shown below, ValueError is raised when an incorrect value is given for the password argument.",
      "keywords": [
        "code",
        "Python Anti-Patterns",
        "Python",
        "magic number",
        "References Python Standard",
        "Python Standard Library",
        "key",
        "code prints Magic",
        "magic",
        "modiﬁed code",
        "References Python",
        "Magic number found",
        "list",
        "number",
        "dictionary"
      ],
      "concepts": [
        "python",
        "code",
        "imports",
        "prints",
        "returned",
        "calling",
        "key",
        "keys",
        "anti",
        "dictionary"
      ],
      "similar_chapters": [
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 5,
          "title": "",
          "score": 0.621,
          "base_score": 0.471,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 6,
          "title": "",
          "score": 0.532,
          "base_score": 0.532,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 7,
          "title": "",
          "score": 0.488,
          "base_score": 0.488,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 1,
          "title": "",
          "score": 0.4,
          "base_score": 0.4,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 2,
          "title": "",
          "score": 0.344,
          "base_score": 0.344,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "code",
          "key",
          "dict",
          "magic",
          "magic number"
        ],
        "semantic": [],
        "merged": [
          "code",
          "key",
          "dict",
          "magic",
          "magic number"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.46200693889879196,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:09:02.701482+00:00"
      }
    },
    {
      "chapter_number": 5,
      "title": "Segment 5 (pages 35-42)",
      "start_page": 35,
      "end_page": 42,
      "summary": "Most bugs involving global variables arise from one function reading and acting on the value of a global variable before another function has the chance to set it to an appropriate value.\nThe code below uses global variables and a function to compute the area and perimeter of a rectangle.\nWIDTH = 0 # global variable HEIGHT = 0 # global variable\nOne common solution for avoiding global variables is to create a class and store related global variables as members of an instantiated object of that class.\nIn the modiﬁed code below, the author eliminates the need for the global variables WIDTH and HEIGHT by encapsulating this data into a class called Rectangle.\nfor key, value in data_dict.iteritems():\nprint(data_key, data_value)\nSometimes a programmer gets an idea to make his/her work easier by creating magically working code that uses setattr() and getattr() functions to set some variable.\nHowever, when refactoring this kind of code after several years, and you’d like to know where some variable is added to this class, you’d usually use grep or ack_grep to ﬁnd it.\ndef __init__(self, data_dict):\nfor key, value in data_dict.iteritems():\ndef __init__(self, data_list, data_dict):\nfor key, value in data_dict.iteritems():\nUse the data dict/list itself without class\nThe Python community uses an EAFP (easier to ask for forgiveness than permission) coding style.\nThis coding style assumes that needed variables, ﬁles, etc.\nThe code below uses an if statement to check if a ﬁle exists before attempting to use the ﬁle.\nThis is not the preferred coding style in the Python community.\nUnlike the original code, the modiﬁed code below simply assumes that the needed ﬁle exists, and catches any problems as exceptions.\nPer the PEP 8 Style Guide, the preferred way to compare something to None is the pattern if Cond is None.\nBut the purpose of the PEP 8 style guidelines is to improve the readability of code.\nThe statement below uses the equality operator to compare a variable to None.\nThis is not the PEP 8 preferred approach to comparing values to None.\nprint(\"This works, but is not the preferred PEP 8 pattern\")\nCompare values to None using the pattern if cond is None\nThe code below uses the PEP 8 preferred pattern of if cond is None.\nprint(\"PEP 8 Style Guide prefers this pattern\")\nPer the PEP 8 Style Guide, the preferred ways to compare something to True are the patterns if cond is True: or if cond:.\nBut the purpose of the PEP 8 Style Guide is to improve the readability of code.\nThe statement below uses the equality operator to compare a boolean variable to True.\nThis is not the PEP 8 preferred approach to comparing values to True.\n# Not PEP 8's preferred pattern if flag == True:\nprint(\"This works, but is not the preferred PEP 8 pattern\")\nThe code below uses the PEP 8 preferred pattern of if condition:.\nprint(\"PEP 8 Style Guide prefers this pattern\")\nCompare values to True using the pattern if cond is True:\nThe code below uses the pattern described in PEP 8 as worse:\nprint(\"PEP 8 Style Guide abhors this pattern\")\nThis pattern is useful, when you make actual distinction between True value and every other that could be treated as true.\nThe if statement below uses the pattern if type(OBJECT) is types.TYPE to compare a Rectangle object to a built-in type (ListType in this example).\nThis is not the preferred pattern for comparing types.\nUse isinstance to compare types\nThe preferred pattern for comparing types is the built-in function isinstance.",
      "keywords": [
        "Global variables",
        "global",
        "HEIGHT",
        "PEP",
        "WIDTH",
        "Style Guide",
        "Python Anti-Patterns",
        "statement global HEIGHT",
        "data",
        "global variable HEIGHT",
        "global statement WIDTH",
        "style",
        "global variables WIDTH",
        "variables",
        "Python"
      ],
      "concepts": [
        "code",
        "coding",
        "variables",
        "variable",
        "pattern",
        "global",
        "uses",
        "useful",
        "style",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 4,
          "title": "",
          "score": 0.621,
          "base_score": 0.471,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 3,
          "title": "",
          "score": 0.486,
          "base_score": 0.486,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 1,
          "title": "",
          "score": 0.415,
          "base_score": 0.415,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 6,
          "title": "",
          "score": 0.391,
          "base_score": 0.391,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 2,
          "title": "",
          "score": 0.38,
          "base_score": 0.38,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "global",
          "pep",
          "pattern",
          "preferred",
          "style"
        ],
        "semantic": [],
        "merged": [
          "global",
          "pep",
          "pattern",
          "preferred",
          "style"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.45207966913651637,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:09:02.701496+00:00"
      }
    },
    {
      "chapter_number": 6,
      "title": "Segment 6 (pages 43-52)",
      "start_page": 43,
      "end_page": 52,
      "summary": "print(\"object r is a list\")\nYou may encounter the old style of initializing a dict (passing an iterable of key-value pairs) in older Python code written before version 2.7.\nConsider refactoring the old-style code to use the new style (but only if you are using Python 2.7 or higher).\nThe modiﬁed code below uses the new dict comprehension syntax which was introduced in Python 2.7.\nWhen formatting a string with values from a dictionary, you can use the dictionary keys instead of explicity deﬁning all of the format parameters.\nIf we added another key-value pair to the person dictionary, we would have to change the string and the format arguments\n# Bad: we have to change the replacement fields within # our string, once we add new values print('{0} {1} is {2} years old'.format(\nBy using the dictionary keys in the string we are formatting, the code is much more readable and explicit.\nprint('{first} is {age} years old'.format(**person)) # Output: Tobin is 20 years old\n} print('{first} {last} is {age} years old'.format(**person)) # Output: Tobin Brown is 20 years old\nreturn '{first} {last} is {age} years old'.format(**self.__dict__)\nPEP 20 states “There should be one– and preferably only one –obvious way to do it.” The preferred way to iterate over the key-value pairs of a dictionary is to declare two variables in a for loop, and then call dictionary.items(), where dictionary is the name of your variable representing a dictionary.\nFor each loop iteration, Python will automatically assign the ﬁrst variable as the key and the second variable as the value for that key.\nThe code below deﬁnes a for loop that iterates over a dictionary named d.\nFor each loop iteration Python automatically assigns the value of key to the name of the next key in the dictionary.\nInside of the for loop the code uses key to access the value of each key of the dictionary.\nThe updated code below demonstrates the Pythonic style for iterating through a dictionary.\nWhen you deﬁne two variables in a for loop in conjunction with a call to items() on a dictionary, Python auto- matically assigns the ﬁrst variable as the name of a key in that dictionary, and the second variable as the corresponding value for that key.\nIn python 2.x the above examples using items would return a list with tuples containing the copied key- value pairs of the dictionary.\nIn order to not copy and with that load the whole dictionary’s keys and values inside a list to the memory you should prefer the iteritems method which simply returns an iterator instead of a list.\n3.8 Not using named tuples when returning more than one value from a function\nThis code is difﬁcult to use: the caller of the function has to know that the ﬁrst element is the ﬁrst name, the second is the middle name, and the third is the last name.\nUse named tuples to return multiple values\nThe modiﬁed code below uses named tuples to return multiple values.\nThe updates of the variables a and b are made using variable temp and three lines of code.\nPEP 20 states “There should be one– and preferably only one –obvious way to do it.” The preferred way to iterate through a pair of lists is to declare two variables in a loop expression, and then call zip(list_one, list_two), where list_one and list_two are the two lists you wish to iterate through.\nFor each loop iteration, Python will automatically assign the ﬁrst variable as the next value in the ﬁrst list, and the second variable as the next value in the second list.\nThe code below deﬁnes a variable index which serves as an index variable for iterating through two lists.\nWithin the for loop the code accesses the corresponding value for each list by using the index variable.\nThis is a common way for iterating through two lists, but it is not the preferred way in Python.\nUse zip() to iterate through a pair of lists\nThe updated code below demonstrates the Pythonic style for iterating through a pair of lists.\nWhen the code deﬁnes two variables in its for loop in conjunction with a call to zip(numbers, letters) on the pair of lists, Python automatically assigns the ﬁrst variable as the next value in the ﬁrst list, and the second variable as the next value in the second list.\nprint(numbers_value, letters_value)\nThe code below demonstrates the dangers of variables whose names include type notation.\nAlthough the modifed code below does not ﬁx the underlying problem of attempting to divide a number by a string, the code is generally less misleading, because there is no misleading description in the variable name n that n is a number.\nThis code snippet will print False even though a and b have equal values.\nPEP 20 states “There should be one– and preferably only one –obvious way to do it.” Creating a loop that uses an incrementing index to access each element of a list within the loop construct is not the preferred style for accessing each element in a list.\nThe preferred style is to use enumerate() to simultaneously retrieve the index and list element.\nThe code below uses an index variable i in a for loop to iterate through the elements of a list.\nThis is not the preferred style for iterating through a list in Python.\n# using index to access list le = l[i] print(i,le)\nThe updated code below demonstrates the Pythonic style for iterating through a list.\nWhen you deﬁne two variables in a for loop in conjunction with a call to enumerate() on a list, Python automatically assigns the ﬁrst variable as an index variable, and the second variable as the corresponding list element value for that index location in the list.\nThe code below deﬁnes a list, and then uses map() to create a second list which is just the doubles of each value from the ﬁrst list.\nIn the modiﬁed code below, the code uses a list comprehension to generate the second list containing the doubled values from the ﬁrst list.\nAlthough this is functionally equivalent to the ﬁrst code, the list compre- hension is generally agreed to be more concise and easier to read.\nprint(\"Is not the preferred PEP 8 pattern for function names\")\nThe code below uses the PEP 8 preferred pattern of function names.",
      "keywords": [
        "Python Anti-Patterns",
        "Python",
        "list",
        "code",
        "variable",
        "References Stack Overﬂow",
        "person",
        "dictionary",
        "Tobin",
        "Tobin Brown",
        "Anti-pattern",
        "list comprehension",
        "References",
        "older Python code",
        "Python code written"
      ],
      "concepts": [
        "python",
        "pythonic",
        "list",
        "code",
        "values",
        "variables",
        "variable",
        "types",
        "readable",
        "readability"
      ],
      "similar_chapters": [
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 4,
          "title": "",
          "score": 0.532,
          "base_score": 0.532,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 7,
          "title": "",
          "score": 0.437,
          "base_score": 0.437,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 5,
          "title": "",
          "score": 0.391,
          "base_score": 0.391,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 1,
          "title": "",
          "score": 0.353,
          "base_score": 0.353,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 3,
          "title": "",
          "score": 0.35,
          "base_score": 0.35,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "code",
          "list",
          "dictionary",
          "loop",
          "variable"
        ],
        "semantic": [],
        "merged": [
          "code",
          "list",
          "dictionary",
          "loop",
          "variable"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4347379608224493,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:09:02.701512+00:00"
      }
    },
    {
      "chapter_number": 7,
      "title": "Segment 7 (pages 53-61)",
      "start_page": 53,
      "end_page": 61,
      "summary": "Use the following patterns to increase the security of your code.\nProgram uses exec to execute arbitrary Python code\nIn most scenarios, you can easily refactor the code to avoid the use of exec.\nAvoid the following anti-patterns to reduce overhead and make your code more performant.\nIf possible, you should change the list to a set or dictionary instead, because Python can search for items in a set or dictionary by attempting to directly accessing them without itera- tions, which is much more efﬁcient.\nUse a set or dictionary instead of a list\nIn the modiﬁed code below, the list has been changed to a set.\nThis is much more efﬁcient behind the scenes, as Python can attempt to directly access the target number in the set, rather than iterate through every item in the list and compare every item to the target number.\n6 Django\nTo help you write great Django apps from the start, we started to compile a set of anti- and migration patterns.\nAvoid the following anti-patterns to increase maintainability of your Django code base—for you, and for others.\n6.1.1 Importing django.db.models.ﬁelds\nIn Django, models are deﬁned in django.db.models.fields.\nDjango’s standard convention is to use from django.db import models and refer to ﬁelds as models<some>Field.\nfrom django.db.models import fields\nStick to standard conventions and use from django.db import models instead.\nfrom django.db import models\nDjango documentation - Model ﬁeld reference\n6. Django\nUse the following patterns to increase the security of your code.\nIn Django, you need to properly set the ALLOWED_HOSTS setting when DEBUG = False.\nMake sure, an appropriate host is set in ALLOWED_HOSTS, whenever DEBUG = False.\nDjango documentation - Settings: The Basics\nDjango documentation - Settings: ALLOWED_HOSTS\nThis settings.py contains a SECRET_KEY.\n6. Django\nInstead of publishing your secret key, you can use an environment variable to set your secret key.\nDjango\nAccording to Django’s documentation, MEDIA_ROOT and STATIC_ROOT must have different values.\nDjango documentation - Settings: MEDIA_ROOT\n6. Django\nAccording to Django’s documentation, MEDIA_URL and STATIC_URL must have different values.\nDjango documentation - Settings: MEDIA_URL\nDjango documentation - Settings: MEDIA_ROOT\nDjango requires you to use forward slashes / whenever you indicate a path, even on Windows.\nDjango requires you to use forward slashes /, even on Windows.\nDjango documentation - Settings: TEMPLATE_DIRS\nDjango documentation - Settings: FIXTURE_DIRS\nDjango documentation - Settings: STATIC_FILES_DIRS\nDjango documentation - Settings: HOST\nDjango’s models make it easy for you, to ﬁlter the data of your application without using any SQL state- ments.\nWe import this model into one of your views to do something will make names within our database:\nUse .values()\ncars = Cars.objects.all().values('make')\nUse .values_list()\nAlternatively, you can use .value_list().\ncars = Cars.objects.all().values_list('make', flat=True)\nDjango documentation - Models: Querysets (values)\nDjango documentation - Models: Querysets (values_list)",
      "keywords": [
        "References Django documentation",
        "Django",
        "Django documentation",
        "References Django",
        "Python",
        "Python Anti-Patterns",
        "DIRS Django documentation",
        "STATIC",
        "MEDIA",
        "ROOT",
        "code",
        "key",
        "URL",
        "DIRS Django",
        "Python code"
      ],
      "concepts": [
        "django",
        "iterate",
        "iterations",
        "iteration",
        "iterative",
        "settings",
        "python",
        "models",
        "make",
        "code"
      ],
      "similar_chapters": [
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 1,
          "title": "",
          "score": 0.683,
          "base_score": 0.533,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 2,
          "title": "",
          "score": 0.521,
          "base_score": 0.371,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 4,
          "title": "",
          "score": 0.488,
          "base_score": 0.488,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 3,
          "title": "",
          "score": 0.471,
          "base_score": 0.321,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 6,
          "title": "",
          "score": 0.437,
          "base_score": 0.437,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "django",
          "django documentation",
          "documentation",
          "models",
          "settings"
        ],
        "semantic": [],
        "merged": [
          "django",
          "django documentation",
          "documentation",
          "models",
          "settings"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.49341596782561503,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:09:02.701528+00:00"
      }
    },
    {
      "chapter_number": 8,
      "title": "Segment 8 (pages 62-65)",
      "start_page": 62,
      "end_page": 65,
      "summary": "Set the DIRS option of a [DjangoTemplates back- end](https://docs.djangoproject.com/en/1.8/topics/templates/#module-django.template.backends.\nDeprecated TEMPLATE_DIRS setting used.\nAs of Django 1.8 you should set DIRS option within TEMPLATES setting.\nDjango documentation - Settings: TEMPLATES\nDjango documentation - Settings: TEMPLATE_DIRS\nDeprecated TEMPLATE_DEBUG setting used.\n'BACKEND': 'django.template.backends.django.DjangoTemplates', 'APP_DIRS': True, 'DIRS': '/path/to/my/templates', 'OPTIONS': {\nDjango documentation - Settings: TEMPLATE_DEBUG\nDjango documentation - Settings: TEMPLATES\nDeprecated TEMPLATE_LOADERS setting used.\nAs of Django 1.8 you should set loaders option in the TEMPLATES setting.\n'BACKEND': 'django.template.backends.django.DjangoTemplates', 'APP_DIRS': True, 'DIRS': '/path/to/my/templates', 'OPTIONS': {\nDjango documentation - Settings: TEMPLATES]\nDjango documentation - Settings: TEMPLATE_DIRS]\nDeprecated TEMPLATE_STRING_IF_INVALID setting used.\n'BACKEND': 'django.template.backends.django.DjangoTemplates', 'APP_DIRS': True, 'DIRS': '/path/to/my/templates', 'OPTIONS': {\nDjango documentation - Settings: TEMPLATES\nDjango documentation - Settings: TEMPLATE_STRING_IF_INVALID",
      "keywords": [
        "Django",
        "TEMPLATES Django documentation",
        "Django documentation",
        "References Django documentation",
        "TEMPLATE",
        "TEMPLATES Django",
        "DIRS",
        "References Django",
        "feature Deprecated TEMPLATE",
        "Deprecated TEMPLATE",
        "DIRS Django documentation",
        "deprecated",
        "setting",
        "Django version",
        "Built-in backends Django"
      ],
      "concepts": [
        "django",
        "setting",
        "sets",
        "templates",
        "loaders",
        "migration",
        "migrating",
        "options",
        "patterns",
        "backend"
      ],
      "similar_chapters": [
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 7,
          "title": "",
          "score": 0.421,
          "base_score": 0.421,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "django",
          "templates",
          "django documentation",
          "documentation",
          "template"
        ],
        "semantic": [],
        "merged": [
          "django",
          "templates",
          "django documentation",
          "documentation",
          "template"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.296633665393348,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:09:02.701541+00:00"
      }
    }
  ],
  "total_chapters": 8,
  "enrichment_provenance": {
    "taxonomy_id": "none",
    "taxonomy_version": "none",
    "taxonomy_path": "none",
    "taxonomy_checksum": "sha256:none",
    "source_metadata_file": "The Little Book Of Python-Anti-Patterns_metadata.json",
    "enrichment_date": "2025-12-17T23:09:02.706720+00:00",
    "enrichment_method": "msep",
    "model_version": "ai-agents-msep-v1",
    "processing_time_ms": 2847.4669179995544,
    "total_similar_chapters": 36
  }
}