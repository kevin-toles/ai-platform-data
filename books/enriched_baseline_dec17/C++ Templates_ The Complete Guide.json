{
  "metadata": {
    "title": "C++ Templates_ The Complete Guide",
    "source_file": "C++ Templates_ The Complete Guide_metadata.json"
  },
  "chapters": [
    {
      "chapter_number": 1,
      "title": "Segment 1 (pages 1-35)",
      "start_page": 1,
      "end_page": 35,
      "summary": "C++ Templates\nAbout This Book\n1 Function Templates\n1.1    A First Look at Function Templates\n1.1.1 Defining the Template\n1.1.2 Using the Template\n1.2    Template Argument Deduction\n1.3    Multiple Template Parameters\n1.3.1 Template Parameters for Return Types\n1.4    Default Template Arguments\n1.5    Overloading Function Templates\n2 Class Templates\n2.1    Implementation of Class Template Stack\n2.1.1 Declaration of Class Templates\n2.2    Use of Class Template Stack\n2.3    Partial Usage of Class Templates\n2.5    Specializations of Class Templates\n2.7    Default Class Template Arguments\n2.9    Class Template Argument Deduction\n2.10   Templatized Aggregates\n3 Nontype Template Parameters\n3.1    Nontype Class Template Parameters\n3.2    Nontype Function Template Parameters\n3.3    Restrictions for Nontype Template Parameters\n3.4    Template Parameter Type auto\n4 Variadic Templates\n4.1    Variadic Templates\n4.1.1 Variadic Templates by Example\n4.1.2 Overloading Variadic and Nonvariadic Templates\n4.3    Application of Variadic Templates\n4.4    Variadic Class Templates and Variadic Expressions\n4.4.3 Variadic Class Templates\n5.4    Templates for Raw Arrays and String Literals\n5.5    Member Templates\n5.5.1 The .template Construct\n5.5.2 Generic Lambdas and Member Templates\n5.6    Variable Templates\n5.7    Template Template Parameters\n6.2    Special Member Function Templates\n6.3    Disable Templates with enable_if<>\n7.6    Recommended Template Parameter Declarations\n8.1    Template Metaprogramming\n9 Using Templates in Practice\n9.1.2 Templates in Header Files\n9.2    Templates and inline\n10 Basic Template Terminology\n10.5  Template Arguments versus Template Parameters\n11.2.1 Type Traits\n11.4  References as Template Parameters\nPart II: Templates in Depth\n12.1.2 Linkage of Templates\n12.1.3 Primary Templates\n12.2  Template Parameters\n12.2.1 Type Parameters\n12.2.3 Template Template Parameters\n12.2.4 Template Parameter Packs\n12.2.5 Default Template Arguments\n12.3  Template Arguments\n12.3.1 Function Template Arguments\n12.3.4 Template Template Arguments\n12.4  Variadic Templates\n12.5.1 Friend Classes of Class Templates\n12.5.2 Friend Functions of Class Templates\n12.5.3 Friend Templates\n13 Names in Templates\n13.3  Parsing Templates\n13.3.3 Dependent Names of Templates\n13.3.5 ADL and Explicit Template Arguments\n13.4  Inheritance and Class Templates\n14.3  The C++ Instantiation Model\n15 Template Argument Deduction\n15.5.1 Literal Operator Templates\n15.8.2 Class Template Arguments\n15.9  Explicit Function Template Arguments\n15.11  Alias Templates\n15.12  Class Template Argument Deduction\n16.2  Overloading Function Templates\n16.2.2 Partial Ordering of Overloaded Function Templates\n16.2.4 Templates and Nontemplates\n16.2.5 Variadic Function Templates\n16.3.1 Full Class Template Specialization\n16.3.2 Full Function Template Specialization\n16.3.3 Full Variable Template Specialization\n16.4  Partial Class Template Specialization\n16.5  Partial Variable Template Specialization\n17.2  Generalized Nontype Template Parameters\n17.3  Partial Specialization of Function Templates\n17.4  Named Template Arguments\n17.5  Overloaded Class Templates\n17.8  Type Checking for Templates\nPart III: Templates and Design\n18 The Polymorphic Power of Templates\n19.2.2 Member Templates versus Template Template Parameters\n19.3  Type Functions\n20.3  Enabling/Disabling Function Templates\n20.4.1 Enabling/Disabling Class Templates\n20.4.2 Tag Dispatching for Class Templates\n20.5  Instantiation-Safe Templates\n21 Templates and Inheritance\n21.4  Named Template Arguments\n23.5  Recursive Instantiation versus Recursive Template Arguments\n27 Expression Templates\n27.2  Encoding Expressions in Template Arguments\n27.2.1 Operands of the Expression Templates\n27.2.5 Expression Templates Assignments\n27.3  Performance and Limitations of Expression Templates\n28 Debugging Templates\nB.2 Value Categories Since C++11\nB.4 Reference Types\nC.2.1 The Implied Argument for Member Functions\nC.3.1 Prefer Nontemplates or More Specialized Templates\nC.3.4 Initializer Lists\nC.3.6 Other Overloading Contexts\nD Standard Type Utilities\nD.1 Using Type Traits\nThe notion of templates in C++ is over 30 years old.\nC++ templates were already\nWith the first edition of this book,\nwe wanted to address this issue and decided to write the book about templates (with\nMuch has changed in C++ since that first edition was published in late 2002.\niterations of the C++ standard have added new features, and continued innovation in\nthe C++ community has uncovered new template-based programming techniques.\nThe second edition of this book therefore retains the same goals as the first edition,\nand active participant of the C++ Standard Committee working groups that evolve\npower (and problems) of templates.\nmember of the C++ Standard Committee Library Working Group, was interested in\nunderstanding all the techniques of templates in a way that he could use and benefit\nDoug, a template library developer turned compiler implementer and\nmyriad techniques used to build template libraries.\nexamples and detailed descriptions of the exact behavior of templates.\nthe basic principles of templates and working up to the “art of template\npolymorphism, type traits, metaprogramming, and expression templates.\nalso gain a deeper understanding of the C++ standard library, in which almost all\ncode involves templates.\nWe learned a lot and we had much fun while writing this book.\nFirst, we’d like to thank everyone in the C++ community and on the C++\nWe’d also like to thank everyone who reviewed drafts of this book and provided\nThis book presents ideas, concepts, solutions, and examples from many sources.\nSpecial thanks to Dietmar Kühl, who meticulously reviewed and edited the\nwhole book.\nduring the standardization process and the writing of this book.\nin support of this book.\nauthority regarding the core C++ language.\ndescribed in this book, and should you find an error in the description of a C++\nAbout This Book\nThe first edition of this book was published almost 15 years ago.\nwrite the definitive guide to C++ templates, with the expectation that it would be\nuseful to practicing C++ programmers.\nour book time and again being recommended as a work of reference, and to be\nprovide the definitive guide to C++ templates, including both a solid reference and\nThis time, however, we work with the “Modern C++”\nFor example, several books have\nappeared that develop specific template-based applications in great depth.\nimportant, far more information about C++ templates and template-based techniques\nWe’ve now lived over 20 years with C++ templates, but the C++ programmers’\nTo get the most from this book, you should already know C++.\nbe able to write C++ programs using components such as IOstreams and containers\nfrom the C++ standard library.\naren’t directly related to templates.\nWe deal primarily with the C++ language revisions standardized in 2011, 2014,\ntemplates.\nthe modern C++ standards nor to provide an exhaustive description of the changes\non templates as designed and used in C++, using the modern C++ standards\nwhere the modern C++ standards enable or encourage different techniques than the\nOur goal is to provide the information necessary to start using templates and benefit\n• Part I introduces the basic concepts underlying templates.\n• Part II presents the language details and is a handy reference to template-related\n• Part III explains fundamental design and coding techniques supported by C++\ntemplates.\nappendixes that cover material not exclusively related to templates (e.g., an overview\nfundamental extension to templates that has been included in the draft for a future\nstandard (C++20, presumably).\nIf you are a C++ programmer who wants to learn or review the concepts of\ntemplates, carefully read Part I, The Basics.\ntemplates already, it may help to skim through this part quickly to familiarize\nthe logistical aspects of organizing your source code when it contains templates.\ndetails of templates in Part II, or instead you could read about practical coding\nC++ programmers use different programming styles, and so do we: The usual\ncommon when dealing with templates.\nfeatures, and helper templates now appear in the C++ standard library.\nthese two, we therefore demonstrate template techniques by illustrating how they are\n<iostream> and <string> (which contain templates but are not particularly\n<functional>, and <type_traits> (which do provide building blocks for\nmore complex templates).\nIn addition, we provide a reference, Appendix D, about the major template utilities\nprovided by the C++ standard library, including a detailed description of all the\nstandard type traits.\nThese are commonly used at the core of sophisticated template\nnumber of these new features interact with templates and are described in this book,\n• Variadic templates\n• Alias templates\n• Standard type traits\nC++14 and C++17 followed, both introducing some new language features, although\nC++11.2 New features interacting with templates and described in this book include\n• Variable templates (C++14)\n• Generic Lambdas (C++14)\n• Class template argument deduction (C++17)\n• Compile-time if (C++17)\nWe even describe concepts (template interfaces), which are currently slated for\ninclusion in the forthcoming C++20 standard.\nAt the time of this writing, the C++11 and C++14 standards are broadly supported\nby the major compilers, and C++17 is largely supported also.\nEven so, the C++ programming language is likely to continue to evolve as time\nthe C++ Standardization Committee) are discussing various ways to improve the\nlanguage, and already several candidate improvements affect templates.\nYou can access all example programs and find more information about this book\n1 Note that in C++, a type definition defines a “type alias” rather than a new type\nThis part introduces the general concepts and language features of C++ templates.\nfunction templates and class templates.\nfundamental template features such as nontype template parameters, variadic\ntemplates, the keyword typename, and member templates.\nand regarding the use and application of templates in practice both as application\nWhy Templates?\nC++ requires us to declare variables, functions, and most other kinds of entities using",
      "keywords": [
        "Template Argument Deduction",
        "Class Template Argument",
        "Templates",
        "Nontype Template Parameters",
        "Class Templates",
        "Function Template Arguments",
        "Template Arguments",
        "Template Parameters",
        "Class Template Specialization",
        "Variadic Class Templates",
        "Function Templates",
        "Template Parameter Type",
        "Class Template Parameters",
        "Overloading Function Templates",
        "Function Template Parameters"
      ],
      "concepts": [
        "templates",
        "types",
        "special",
        "specializations",
        "specialized",
        "function",
        "functions",
        "functional",
        "instantiation",
        "instantiations"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 31,
          "title": "",
          "score": 0.951,
          "base_score": 0.801,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 15,
          "title": "",
          "score": 0.887,
          "base_score": 0.737,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 12,
          "title": "",
          "score": 0.859,
          "base_score": 0.709,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 2,
          "title": "",
          "score": 0.803,
          "base_score": 0.653,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 47,
          "title": "",
          "score": 0.678,
          "base_score": 0.678,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "templates",
          "book",
          "12",
          "template parameters",
          "parameters"
        ],
        "semantic": [],
        "merged": [
          "templates",
          "book",
          "12",
          "template parameters",
          "parameters"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5063402378464735,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.447089+00:00"
      }
    },
    {
      "chapter_number": 2,
      "title": "Segment 2 (pages 36-70)",
      "start_page": 36,
      "end_page": 70,
      "summary": "They are functions or classes that are written for one or more types not\nWhen you use a template, you pass the types as arguments,\ntemplates.\nFunction Templates\nThis chapter introduces function templates.\nFunction templates are functions that are\n1.1 A First Look at Function Templates\nFunction templates provide a functional behavior that can be called for different\ntypes.\n1.1.1 Defining the Template\nThe following is a function template that returns the maximum of two values:\ntemplate<typename T>\nThis template definition specifies a family of functions that return the maximum of\ntwo values, which are passed as function parameters a and b.1 The type of these\ntemplate parameter in C++ programs, but other parameters are possible, and we\nHere, the type parameter is T.\nYou can use any type\ntemplate uses.\ntypename to define a type parameter.\nHence, the template max() could be defined equivalently as follows:\ntemplate<class T>\nany type may be used for template arguments.\ndeclaring type parameters.\n1.1.2 Using the Template\nThe following program shows how to use the max() function template:\nNote that each call of the max() template is qualified with ::.\nour max() template is found in the global namespace.\nstd::max() template in the standard library, which under some circumstances\nTemplates aren’t compiled into single entities that can handle any type.\ndifferent entities are generated from the template for every type for which the\ntemplate is used.4 Thus, max() is compiled for each of these three types.\nuses the function template with int as template parameter T.\nThe process of replacing template parameters by concrete types is called\nNote that the mere use of a function template can trigger such an instantiation\nSimilarly, the other calls of max() instantiate the max template for double and\nNote also that void is a valid template argument provided the resulting code is\ntemplate<typename T>\nAn attempt to instantiate a template for a type that doesn’t support all the operations\n1. Without instantiation at definition time, the template code itself is checked for\ncorrectness ignoring the template parameters.\ntemplate parameters are discovered.\ntemplate<typename T>\npractice: When a function template is used in a way that triggers its instantiation, a\n1.2 Template Argument Deduction\nWhen we call a function template such as max() for some arguments, the template\nparameter types T, the C++ compiler has to conclude that T must be int.\ntemplate<typename T>\nTwo arguments declared with the same template parameter T\nFor two arguments declared with the same template\ntemplate<typename T>\nmax(i, c);            // OK: T is deduced as int\n3. Specify that the parameters may have different types.\nType Deduction for Default Arguments\ntemplate<typename T>\nTo support this case, you also have to declare a default argument for the template\ntemplate<typename T = std::string>\n1.3 Multiple Template Parameters\nAs we have seen so far, function templates have two distinct sets of parameters:\n1. Template parameters, which are declared in angle brackets before the function\ntemplate name:\ntemplate<typename T>        // T is template parameter\n2. Call parameters, which are declared in parentheses after the function template\nYou may have as many template parameters as you like.\ndefine the max() template for call parameters of two potentially different types:\nauto m = ::max(4, 7.2);        // OK, but type of first argument\ndefines return type\nIt may appear desirable to be able to pass parameters of different types to the max()\nparameter types as return type, the argument for the other parameter might get\nThus, the return type\n• Introduce a third template parameter for the return type.\n• Let the compiler find out the return type.\n• Declare the return type to be the “common type” of the two parameter types.\n1.3.1 Template Parameters for Return Types\nfunction templates with syntax identical to that of calling an ordinary function: We\ndo not have to explicitly specify the types corresponding to the template parameters.\nWe also mentioned, however, that we can specify the types to use for the template\ntemplate<typename T>\nIn cases when there is no connection between template and call parameters and when\ntemplate parameters cannot be determined, you must specify the template argument\nFor example, you can introduce a third template argument\ntype to define the return type of a function template:\nHowever, template argument deduction does not take return types into account,7 and\nRT does not appear in the types of the function call parameters.\nSo far, we have looked at cases in which either all or none of the function template\nour example, the caller needs to specify only the return type:\n::max<double>(4, 7.2)        //OK: return type is double, T1 and\nsections when discussing other template issues).\n1.3.2 Deducing the Return Type\nIf a return type depends on template parameters, the simplest and best approach to\ndeduce the return type is to let the compiler find out.\nIn fact, the use of auto for the return type without a corresponding trailing return\ntype must be deduced from the return statements in the function body.\ndeducing the return type from the function body has to be possible.\nBefore C++14, it is only possible to let the compiler determine the return type by\nThat is, we can declare that the return type is derived from\nparameters a and b to find out the return type of max() at compile time.\nHere, the type trait std::decay<> is used, which returns the resulting type in a\nvalues when the return type is just auto.\nthe following code, where a is declared by the decayed type of i, int:\nof two (or more) different types passed as template arguments.\nstd::common_type_t<T1,T2> max (T1 a, T2 b)\ntypename std::common_type<T1,T2>::type        //since C++11\nThe way std::common_type<> is implemented uses some tricky template\n1.4 Default Template Arguments\nYou can also define default values for template parameters.\neven refer to previous template parameters.\nthe ability to have multiple parameter types (as discussed in the section before), you\ncan introduce a template parameter RT for the return type with the common type of\ntheir types:\n2. We can also use the std::common_type<> type trait to specify the default\nvalue for the return type:\nAgain, note that std::common_type<> decays so that the return value can’t\nIn all cases, as a caller, you can now use the default value for the return type:\nor specify the return type after all other argument types explicitly:\nto specify the return type only.\ntype as the first template parameter, while still being able to deduce it from the\nargument types.\nfunction template parameters even if parameters without default arguments follow:\ntemplate parameter for return type)\ntemplate parameter.\nHere, we need the default argument for the template parameter\nreturn type as proposed in Section 1.3.2 on page 11.\n1.5 Overloading Function Templates\nLike ordinary functions, function templates can be overloaded.\nwithout templates.\nIn this section we discuss overloading when templates are\nThe following short program illustrates overloading a function template:\ntemplate<typename T>\nAs this example shows, a nontemplate function can coexist with a function template\nIf the template can generate a function with a better match, however, then the\nIt is also possible to specify explicitly an empty template argument list.\nBecause automatic type conversion is not considered for deduced template\nexplicitly specify the return type only:\ntemplate\ntemplate\nauto c = ::max<int>(4, 7.2);                // ERROR: both\nfunction templates match\nA useful example would be to overload the maximum template for pointers and\ntemplate<typename    T>\ntemplate<typename    T>\nauto m1 = ::max(a,b);         // max() for two values of type\nauto m2 = ::max(s1,s2);       // max() for two values of type\na good idea not to change more than necessary when overloading function templates.\nyou implement your max() template to pass the arguments by reference and\ntemplate<typename\ntemplate<typename T>\nreturn max (max(a,b), c);            // error if max(a,b) uses\nreturn max (max(a,b), c);\nints causes the two-argument template to be used by the three-argument version:\ntemplate<typename T>\ntemplate<typename T>\nreturn max (max(a,b), c);          // uses the template version\nProbably, even these simple function template examples might raise further\n• A template might be used for both simple and complex types, so choosing the\nIn general, function templates don’t have to be declared with inline.\ntypes, so that the resulting code is no longer generic (all template parameters are\nWith this, you can use the maximum function template in places with compile-time\n• Function templates define a family of functions for different template arguments.\n• When you pass arguments to function parameters depending on template\nparameters, function templates deduce the template parameters to be instantiated\n• You can explicitly qualify the leading template parameters.\n• You can define default arguments for template parameters.\nprevious template parameters and be followed by parameters not having default\n• You can overload function templates.\n• When overloading function templates with other function templates, you should\n• When you overload function templates, limit your changes to specifying template\n• Ensure the compiler sees all overloaded versions of function templates before you\n1 Note that the max() template according to [StepanovNotes] intentionally returns\n2 Before C++17, type T also had to be copyable to be able to pass in arguments, but\n3 For example, if one argument type is defined in namespace std (such as\nmax() template in std are found (see Appendix C).\n8 In C++, the return type also cannot be deduced from the context in which the\n9 Prior to C++11, default template arguments were only permitted in class\n10 Again, in C++11 you had to use typename std::decay<…>::type\nClass Templates\nSimilar to functions, classes can also be parameterized with one or more types.\nexample of a class template.\n2.1 Implementation of Class Template Stack\nAs we did with function templates, we declare and define class Stack<> in a\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\n2.1.1 Declaration of Class Templates\nDeclaring class templates is similar to declaring function templates: Before the\ntemplate<typename T>\ntemplate<class T>\nInside the class template, T can be used just like any other type to declare members\nIn this example, T is used to declare the type of the elements\nargument, and to declare top() as a function that returns a T:\ntemplate<\nThe type of this class is Stack<T>, with T being a template parameter.\nhave to use Stack<T> whenever you use the type of this class in a declaration\nexcept in cases where the template arguments can be deduced.\nclass template using the class name not followed by template arguments represents\nthe class with its template parameters as its arguments (see Section 13.2.3 on page\ntemplate<typename T> \ntemplate<typename T> \ntemplate<typename T> \ntemplates inside functions or block scope.\nTo define a member function of a class template, you have to specify that it is a\ntemplate, and you have to use the full type qualification of the class template.\nthe implementation of the member function push() for type Stack<T> looks like\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\nclass templates as an inline function inside the class declaration.\ntemplate<typename T> \n2.2 Use of Class Template Stack\nTo use an object of a class template, until C++17 you must always specify the\ntemplate arguments explicitly.1 The following example shows how to use the class\ntemplate Stack<>:\nBy declaring type Stack<int>, int is used as type T inside the class template.\nfor all member functions that are called, code for this type is instantiated.\nNote that code is instantiated only for template (member) functions that are called.\nFor class templates, member functions are instantiated only if they are used.\ncourse, saves time and space and allows use of class templates only partially, which\ntemplate has static members, these are also instantiated once for each type for which\nthe class template is used.\nAn instantiated class template’s type can be used just like any other type.\nSection 2.8 on page 38 for details about type definitions) or use it as a type\nparameter when building another template type.\n10 int stacks (same type)\nTemplate arguments may be any type, such as pointers to floats or even stacks of\ntype.\nA class template usually applies multiple operations on the template arguments it is\nimpression that these template arguments have to provide all operations necessary\nfor all member functions of a class template.\nBut this is not the case: Template\ntemplate<typename T> \nfor element type\ntemplate<typename T> \ntemplate definition in which the error was detected (see Section 9.4 on page 143).\ntemplate<typename T> \ntemplate, but an “ordinary” function instantiated with the class template if needed.2\n1. We can implicitly declare a new function template, which must use a different\ntemplate parameter, such as U:\ntemplate<typename T> \nNeither using T again nor skipping the template parameter declaration would work\n2. We can forward declare the output operator for a Stack<T> to be a template,\ntemplate<typename T> \ntemplate<typename T>",
      "keywords": [
        "view code image",
        "code image template",
        "template",
        "type",
        "view code",
        "code image",
        "template parameters",
        "return type",
        "image template",
        "stack",
        "Function Templates",
        "max",
        "code",
        "class template",
        "Function"
      ],
      "concepts": [
        "templates",
        "type",
        "std",
        "functions",
        "function",
        "functional",
        "max",
        "click",
        "stack",
        "uses"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 15,
          "title": "",
          "score": 0.817,
          "base_score": 0.667,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 1,
          "title": "",
          "score": 0.803,
          "base_score": 0.653,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 12,
          "title": "",
          "score": 0.795,
          "base_score": 0.645,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 14,
          "title": "",
          "score": 0.714,
          "base_score": 0.714,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 11,
          "title": "",
          "score": 0.683,
          "base_score": 0.683,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "max",
          "type",
          "function",
          "parameters",
          "return type"
        ],
        "semantic": [],
        "merged": [
          "max",
          "type",
          "function",
          "parameters",
          "return type"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.47468825858260605,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.447236+00:00"
      }
    },
    {
      "chapter_number": 3,
      "title": "Segment 3 (pages 71-100)",
      "start_page": 71,
      "end_page": 100,
      "summary": "class Stack {\n//       for element type\n2.5 Specializations of Class Templates\nYou can specialize a class template for certain template arguments.\noverloading of function templates (see Section 1.5 on page 15), specializing class\ntemplates allows you to optimize implementations for certain types or to fix a\nmisbehavior of certain types for an instantiation of the class template.\nyou specialize a class template, you must also specialize all member functions.\nAlthough it is possible to specialize a single member function of a class template,\nonce you have done so, you can no longer specialize the whole class template\nTo specialize a class template, you have to declare the class with a leading\ntemplate<> and a specification of the types for which the class template is\nThe types are used as a template argument and must be specified directly\ntemplate<> \nclass Stack<std::string> {\nvoid Stack<std::string>::push (std::string const& elem)\nHere is a complete example of a specialization of Stack<> for type\ntemplate<>\nclass Stack<std::string> {\nvoid push(std::string const&);    // push element \nstd::string const& top() const;   // return top element \nstack is empty \nvoid Stack<std::string>::push (std::string const& elem)\nvoid Stack<std::string>::pop ()\nstd::string const& Stack<std::string>::top () const\nClass templates can be partially specialized.\nclass Stack<> for pointers:\n// partial specialization of class Stack<> for pointers:\nclass Stack<T*> { \nclass Stack<T*> {\nwe define a class template, still parameterized for T but specialized for a pointer\n(Stack<T*>).\nClass templates might also specialize the relationship between multiple template\nFor example, for the following class template:\n// partial specialization: both template parameters have same\ntype \n// partial specialization: both template parameters are pointer\ntypes \nThe following examples show which template is used by which declaration:\n2.7 Default Class Template Arguments\nAs for function templates, you can define default values for class template\nFor example, in class Stack<> you can define the container that is\nused to manage the elements as a second template parameter, using\nclass Stack { \nvoid Stack<T,Cont>::push (T const& elem)\nvoid Stack<T,Cont>::push (T const& elem)\ntype:\nclass Stack {\n// stack of ints:\nStack< int> intStack;\n// stack of doubles using a std::deque<> to manage the elements\nyou declare a stack for doubles that uses a std::deque<> to manage the\nYou can make using a class template more convenient by defining a new name for\nthe whole type.\ntypedef Stack<int> IntStack;     // typedef\nstacks of ints\nusing IntStack = Stack <int>;        // alias declaration \nvoid foo (IntStack const& s);        // s is stack of ints\nstacks of ints\ntype.\ntypedef Stack <int> IntStack;\nusing IntStack = Stack <int>;\nIntStack and Stack<int> are two interchangeable notations for the same type.\ntemplate.4\nThe following alias template DequeStack, parameterized over the element type T,\nexpands to a Stack that stores its elements in a std::deque:\nThus, both class templates and alias templates can be used as a parameterized type.\nBut again, an alias template simply gives a new name to an existing type, which can\nstd::deque<int>> represent the same type.\nNote again that, in general, templates can only be declared and defined in\nAlias Templates for Member Types\nAlias templates are especially helpful to define shortcuts for types that are members\nof class templates.\ntypename std::add_const<T>::type   // since C++11\n2.9 Class Template Argument Deduction\nUntil C++17, you always had to pass all template parameter types to class templates\ndefine the templates arguments explicitly, if the constructor is able to deduce all\ntemplate parameters (that don’t have a default value),\nwithout specifying the template arguments:\nStack< int> intStack1;                 // stack of strings\ndeduction of the element type of a stack.\nclass Stack { \nBy initializing the stack with the integer 0, the template parameter T is deduced to be\nNote that, unlike for function templates, class template arguments may not be\nClass Template Arguments Deduction with String Literals\nHowever, when passing arguments of a template type T by value, the parameter\nclass Stack { \nclass Stack { \ntemplate argument deductions.\nliteral or C string is passed, the stack is instantiated for std::string:\nStack( char const*) -> Stack<std::string>;\nStack stringStack{\"bottom\"};        // OK: Stack<std::string>\ndeduces the stack to be a Stack<std::string>.\nStack stringStack = \"bottom\"; // Stack<std::string> deduced, but\nWe deduce std::string so that we instantiate a Stack<std::string>:\nclass Stack { \nStack (std::string const& elem)        // initialize stack\nStack stringStack{\"bottom\"}; // Stack<std::string> deduced and\nNote that, if in doubt, class template argument deduction copies.\nstringStack as Stack<std::string> the following initializations declare\nthe same type (thus, calling the copy constructor) instead of initializing a stack by\nelements that are string stacks:\nStack stack2{stringStack};        // Stack<std::string> deduced\nStack stack3(stringStack);        // Stack<std::string> deduced\nStack stack4 = {stringStack};     // Stack<std::string> deduced\nSee Section 15.12 on page 313 for more details about class template argument\ndeclare objects as for any other class template and still use it as aggregate:\nSince C++17, you can even define deduction guides for aggregate class templates:\nfor both the element type and the size.\n• A class template is a class that is implemented with one or more type parameters\n• To use a class template, you pass the open types as template arguments.\ntemplate is then instantiated (and compiled) for these types.\n• For class templates, only those member functions that are called are instantiated.\n• You can specialize class templates for certain types.\n• You can partially specialize class templates for certain types.\n• Since C++17, class template arguments can automatically be deduced from\n• You can define aggregate class templates.\n• Call parameters of a template type decay if declared to be called by value.\n1 C++17 introduced class argument template deduction, which allows skipping\ntemplate.\nNontype Template Parameters\nFor function and class templates, template parameters don’t have to be types.\nAs with templates using type parameters, you define\nWhen using such a template, you have\nillustrates this feature for a new version of the stack class template.\nshow an example of nontype function template parameters and discuss some\n3.1 Nontype Class Template Parameters\nthe stack will get full.\nTo do this, define the size as a template parameter:\ntemplate<typename T, std::size_t Maxsize>\nclass Stack {\ntemplate<typename T, std::size_t Maxsize>\ntemplate<typename T, std::size_t Maxsize>\nvoid Stack<T,Maxsize>::push (T const& elem)\ntemplate<typename T, std::size_t Maxsize>\ntemplate<typename T, std::size_t Maxsize>\nThe new second template parameter, Maxsize, is of type int.\ntemplate<typename T, std::size_t Maxsize>\nclass Stack {\ntemplate<typename T, std::size_t Maxsize>\nvoid Stack<T,Maxsize>::push (T const& elem)\nTo use this class template you have to specify both the element type and the\nStack<std::string,40> stringStack;     // stack of up to 40\nNote that each template instantiation is its own type.\nAgain, default arguments for the template parameters can be specified:\ntemplate<typename T = int, std::size_t Maxsize = 100>\nclass Stack {\nBut neither type int nor a\nmaximum size of 100 seems intuitive for a general stack type.\n3.2 Nontype Function Template Parameters\nYou can also define nontype parameters for function templates.\nfollowing function template defines a group of functions for which a certain value\ntemplate<int Val, typename T>\ninstantiation of this function template to add a value to each element of a collection:\nNote that you have to specify the argument int for the template parameter T of\nAgain, you can also specify that a template parameter is deduced from the\nFloating-point numbers and class-type objects are not allowed as nontype template\ntemplate<std::string name>   // ERROR: class-type objects are\nclass MyClass {              //        allowed as template\nis used as a template parameter declared with char const*.\nArguments for nontype template parameters might be any compile-time expressions.\n3.4 Template Parameter Type auto\nSince C++17, you can define a nontype template parameter to generically accept any\neven more generic stack class with fixed size:\nclass Stack {\nvoid Stack<T,Maxsize>::push (T const& elem)\nclass Stack {\nIt might be any type that is allowed to be a nontype template\nWith this class declaration the type of the number of elements is defined by the type\nused for the number of elements, when using a stack:\nStack<std::string,40> stringStack;    // stack of up to 40\nstd::cout << \"size types differ\" << ’\\n’;\nStack<std::string,40> stringStack;   // stack of up to 40\nthe internal size type is int, because 40 is passed.\nsize() for the two stacks will have different return types, so that after\nstd::cout << \"size types differ\" << ’\\n’;\nstd::cout << \"size types differ\" << ’\\n’;\nNote that other constraints on the type of nontype template parameters remain in\nEspecially, the restrictions about possible types for nontype template\n• Templates can have template parameters that are values rather than types.\n• You cannot use floating-point numbers or class-type objects as arguments for\nnontype template parameters.\n• Using auto enables templates to have nontype template parameters that are values\nSince C++11, templates can have parameters that accept a variable number of\ntemplate arguments.\ntemplate<typename T, typename… Types>",
      "keywords": [
        "view code image",
        "Stack",
        "code image template",
        "view code",
        "template",
        "code image",
        "class Stack",
        "class template",
        "image template",
        "template parameters",
        "code",
        "Click",
        "view",
        "type",
        "std"
      ],
      "concepts": [
        "types",
        "template",
        "stack",
        "click",
        "std",
        "classes",
        "size",
        "value",
        "elements",
        "parameters"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 40,
          "title": "",
          "score": 0.66,
          "base_score": 0.66,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 10,
          "title": "",
          "score": 0.641,
          "base_score": 0.641,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 21,
          "title": "",
          "score": 0.638,
          "base_score": 0.638,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 14,
          "title": "",
          "score": 0.633,
          "base_score": 0.633,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 1,
          "title": "",
          "score": 0.632,
          "base_score": 0.632,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "stack",
          "class",
          "stack std",
          "class stack",
          "string"
        ],
        "semantic": [],
        "merged": [
          "stack",
          "class",
          "stack std",
          "class stack",
          "string"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4805540295773835,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.447329+00:00"
      }
    },
    {
      "chapter_number": 4,
      "title": "Segment 4 (pages 101-135)",
      "start_page": 101,
      "end_page": 135,
      "summary": "If one or more arguments are passed, the function template is used, which by\nusing different “Types” specified by a template parameter pack:\ntemplate<typename T, typename… Types>\nprint<double, char const*, std::string> (7.5, \"hello\", s);\n• args being a variadic template argument having the values \"hello\" of type\nchar const* and \"world\" of type std::string.\nprint<char const*, std::string> (\"hello\", s);\n• firstArg having the value \"hello\" so that type T is a char const* here\n• args being a variadic template argument having the value of type\nprint<std::string> (s);\n• firstArg having the value \"world\" so that type T is a std::string now\n• args being an empty variadic template argument having no value.\ntemplate<typename T>\nstd::cout << arg << ’\\n’;  //print passed argument\ntemplate<typename T, typename… Types>\nThat is, if two function templates only differ by a trailing parameter pack, the\nfunction template without the trailing parameter pack is preferred.1 Section C.3.1 on\nC++11 also introduced a new form of the sizeof operator for variadic templates:\ntemplate<typename T, typename… Types>\nstd::cout << sizeof…(Types) << ’\\n’;  //print number of\nstd::cout << sizeof…(args) << ’\\n’;   //print number of\nAs you can see, you can call sizeof… for both template parameter\ntemplate<typename T, typename… Types>\nstatements in function templates are instantiated.\nFor this reason, if you call the print() function template for one (last)\nall the arguments of a parameter pack (with an optional initial value).\nFor example, the following function returns the sum of all passed arguments:\ntemplate<typename… T>\ntemplate<typename T, typename… TP>\nthe variadic template to print all arguments, introduced above:\ntemplate<typename… Types>\nvoid print (Types const&… args)\n(std::cout << … << args) << ’\\n’;\nTo do that, you need an additional class template, which ensures that\ntemplate<typename T>\ntemplate<typename… Args>\n( std::cout << … << AddSpace(args) ) << ’\\n’;\nNote that the expression AddSpace(args) uses class template argument\n4.3 Application of Variadic Templates\ntemplate<typename T, typename… Args> shared_ptr<T>\ntemplate<typename F, typename… Args>\ntemplate<typename… Args> reference emplace_back(Args&&…\nNote also that the same rules apply to variadic function template parameters as for\ntemplate<typename… Args> void foo (Args… args);\ntemplate<typename… Args> void bar (Args const&… args);\n4.4 Variadic Class Templates and Variadic Expressions\nincluding, for example, expressions, class templates, using declarations, and even\ntemplate<typename… T>\ntemplate<typename… T>\nCompile-time expressions can include template parameter packs in the same way.\nFor example, the following function template returns whether the types of all the\ntemplate<typename T1, typename… TN>\nreturn (std::is_same<T1,TN>::value && …);  // since C++17\nthat the argument types decay because the call arguments are passed by value).\ntemplate<typename C, typename… Idx>\nYou can also declare nontype template parameters to be parameter packs.\ntemplate<std::size_t… Idx, typename C>\n4.4.3 Variadic Class Templates\nVariadic templates can also be class templates.\nwhere an arbitrary number of template parameters specify the types of corresponding\ntemplate<typename… Elements>\ntemplate<typename… Types>\ntemplate<std::size_t…>\ntemplate<typename T, std::size_t… Idx>\nprint(std::get<Idx>(t)…);\nThis template can be used as follows:\nstd::array<std::string, 5> arr = {\"Hello\", \"my\", \"new\", \"!\",\nthe C++ standard library defines the following deduction guide for std::arrays:\ntemplate<typename T, typename… U> array(T, U…)\nstd::array<int, 3> a{42,45,77};\nThe std::enable_if<> expression for the first array parameter is a fold\nCustomer(std::string const& n) : name(n) { }\nstd::string getName() const { return name; }\nstd::size_t operator() (Customer const& c) const {\ntemplate<typename… Bases>\n• By using parameter packs, templates can be defined for an arbitrary number of\ntemplate parameters of arbitrary type.\npractical use of templates: an additional use of the typename keyword, defining\nmember functions and nested classes as templates, template template parameters,\nfunction templates.\nclarify that an identifier inside a template is a type.\ntemplate<typename T>\ntemplate parameter is a type.\ntemplate<typename T>\nIn this function template, the call parameter is an standard container of type T.\nwhich is declared as type const_iterator inside each standard container class:\nThus, to access type const_iterator of template type T, you have to qualify it\nNow if you write templates and want to have variables of a template type initialized\ntemplate<typename T>\ntemplate<typename T>\nTo ensure that a member of a class template, for which the type is parameterized,\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\nFor class templates with base classes that depend on template parameters, using a\ntemplate<typename T>\ntemplate<typename T>\na base that is somehow dependent on a template parameter with this-> or\n5.4 Templates for Raw Arrays and String Literals\nWhen passing raw arrays or string literals to templates, some care has to be taken.\nFirst, if the template parameters are declared as references, the arguments don’t\nThat is, a passed argument of \"hello\" has type char const[6].\nOnly when passing the argument by value, the types\ndecay, so that string literals are converted to type char const*.\ntemplate<typename T,\nYou can also use this template for string literals:\nIf you only want to provide a function template for string literals (and other char\ntemplate<int N, int M>\ntemplate<typename T>\ntemplate<typename T, std::size_t SZ>\ntemplate<typename T, std::size_t SZ>\ntemplate<typename T>\nstatic void print() { std::cout << \"print() for T[]\\n\"; }\ntemplate<typename T>\nstatic void print() { std::cout << \"print() for T(&)[]\\n\"; }\ntemplate<typename T>\nstatic void print() { std::cout << \"print() for T*\\n\"; }\nHere, the class template MyClass<> is specialized for various types: arrays of\nNote also that templates for arrays of unknown\nused as a template parameter.2\nSee Section 19.3.1 on page 401 for another example using the different array types\n5.5 Member Templates\nClass members can also be templates.\ndemonstrated with the Stack<> class template.\nHowever, you can’t assign a stack with elements of any other type,\nhave the same type, which is not the case if stacks have different element types.\nBy defining an assignment operator as a template, however, you can enable the\nassignment of stacks with elements for which an appropriate type conversion is\ntemplate<typename T>\n// assign stack of elements of type T2\ntemplate<typename T2>\n2. The stack now uses a std::deque<> as an internal container for the elements.\ntemplate<typename T>\ntemplate<typename T2>\nInside the template with\ntemplate<typename T>\ntemplate<typename T2>\nclass template for two different argument types, you get two different class types), so\ntemplate<typename T>\n// assign stack of elements of type T2\ntemplate<typename T2>\n// to get access to private members of Stack<T2> for any type\ntemplate<typename> friend class Stack;\nAs you can see, because the name of the template parameter is not used, you can\ntemplate<typename> friend class Stack;\nNow, the following implementation of the template assignment operator is possible:\ntemplate<typename T>\ntemplate<typename T2>\nWhatever your implementation is, having this member template, you can now assign\nOf course, this assignment does not change the type of the stack and its elements.\nassign a stack with elements of any type, but this is not the case.\ntemplate<typename T, typename Cont = std::deque<T>>\n// assign stack of elements of type T2\n// to get access to private members of Stack<T2> for any type\ntemplate<typename, typename> friend class Stack;\nThen the template assignment operator is implemented like this:\nRemember, for class templates, only those member functions that are called are\nThus, if you avoid assigning a stack with elements of a different type,\nStack<int,std::vector<int>> vStack;\nBecause the assignment operator template isn’t necessary, no error message of a\nSpecialization of Member Function Templates\nMember function templates can also be partially or fully specialized.\nstd::string value;\nBoolString (std::string const& s)\ntemplate<typename T = std::string>\nyou can provide a full specialization for the member function template as follows:\ntemplate<>\nstd::cout << s1.get() << ’\\n’;        //prints hello\nstd::cout << s1.get<bool>() << ’\\n’;  //prints false\nstd::cout << s2.get<bool>() << ’\\n’;  //prints true\nSpecial Member Function Templates\nTemplate member functions can be used wherever special member functions allow\nHowever, note that template constructors or template\nMember templates don’t count as the special member functions that copy or move\nIn this example, for assignments of stacks of the same type, the default\n• It can happen that a template constructor or assignment operator is a better match\ntemplate version is provided for initialization of other types only.\nSometimes, it is necessary to explicitly qualify template arguments when calling a\nmember template.\nthat a < is the beginning of the template argument list.\nstd::cout << bs.template to_string<char,\nFor the bitset bs we call the member function template to_string(), while\nWithout that extra use of .template,\nless-than but the beginning of a template argument list.\nexample, the parameter bs depends on the template parameter N.\nsomething that depends on a template parameter.\ntemplates.\ntemplate<typename T1, typename T2>\n5.6 Variable Templates\ncalled a variable template.4\ndefining the type of the value:\ntemplate<typename T>\nNote that, as for all templates, this declaration may not occur inside functions or\nTo use a variable template, you have to specify its type.\nYou can also declare variable templates that are used in different translation units:\ntemplate<typename T> T val{};     // zero initialized value\nVariable templates can also have default template arguments:\ntemplate<typename T = long double>\nVariable templates can also be parameterized by nontype parameters, which also\ntemplate<int N>\nstd::array<int,N> arr{};         // array with N elements,\ntemplate<auto N>\nstd::cout << dval<’c’> << ’\\n’;             // N has value ’c’\ndifferent translation units the same variable std::array<int,10> arr of\nA useful application of variable templates is to define variables that represent\nmembers of class templates.\nFor example, if a class template is defined as follows:\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T> class numeric_limits {\ntemplate<typename T>\nSince C++17, the standard library uses the technique of variable templates to define\nstd::is_const_v<T>        // since C++17\nstd::is_const<T>::value        //since C++11\ntemplate<typename T> constexpr bool is_const_v =\n5.7 Template Template Parameters\nIt can be useful to allow a template parameter itself to be a class template.\nstack class template can be used as an example.\nStack<int, std::vector<int>> vStack;  // integer stack that uses\nUsing template template parameters allows you to declare the Stack class template\ntemplate<typename T,\ntemplate<typename Elem> class Cont = std::deque>\nThe difference is that the second template parameter is declared as being a class\ntemplate:",
      "keywords": [
        "view code image",
        "code image template",
        "view code",
        "code image",
        "template",
        "code image std",
        "image template",
        "code",
        "view",
        "std",
        "image",
        "Stack",
        "Click",
        "typename",
        "code image basics"
      ],
      "concepts": [
        "templates",
        "types",
        "std",
        "click",
        "classes",
        "printing",
        "value",
        "stack",
        "operator",
        "arguments"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 37,
          "title": "",
          "score": 0.971,
          "base_score": 0.821,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 43,
          "title": "",
          "score": 0.903,
          "base_score": 0.753,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 6,
          "title": "",
          "score": 0.854,
          "base_score": 0.704,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 42,
          "title": "",
          "score": 0.825,
          "base_score": 0.675,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 45,
          "title": "",
          "score": 0.744,
          "base_score": 0.594,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "template typename",
          "templates",
          "args",
          "stack",
          "std"
        ],
        "semantic": [],
        "merged": [
          "template typename",
          "templates",
          "args",
          "stack",
          "std"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5626851550068331,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.447417+00:00"
      }
    },
    {
      "chapter_number": 5,
      "title": "Segment 5 (pages 136-166)",
      "start_page": 136,
      "end_page": 166,
      "summary": "template<typename Elem> class Cont\nparameter has to be a class template, which is instantiated for the type that is passed\nas the first template parameter:\nThis use of the first template parameter for the instantiation of the second template\ntemplate parameter with any type inside a class template.\nAs usual, instead of typename you could use the keyword class for template\ntemplate.\ntemplate<typename T,\ntemplate<class Elem> class Cont = std::deque>\nSince C++11, we can also substitute Cont with the name of an alias template, but it\nkeyword typename instead of class to declare a template template parameter:\ntemplate<typename T,\ntemplate<typename Elem> typename Cont = std::deque>\ntypename does not prevent us from specifying an alias template as the argument\ntemplate<typename T,\ntemplate<typename> class Cont = std::deque>\ntemplate<typename T, template<typename> class Cont>\nNote that while template template parameters are placeholders for class or alias\nthat the default value std::deque is not compatible with the template template\nThe problem is that prior to C++17 a template template argument\nhad to be a template with parameters that exactly match the parameters of the\ntemplate parameters (see Section 12.3.4 on page 197).\nDefault template arguments of\nThe pre-C++17 problem in this example is that the std::deque template of the\nconsidered when matching std::deque to the Cont parameter.\nCont parameter expects containers with two template parameters:\ntemplate<typename T,\ntemplate<typename Elem,\nThe final version of our Stack template (including member templates for\ntemplate<typename T,\ntemplate<typename Elem,\ntemplate<typename T2,\ntemplate<typename Elem2,\nstack instances are friends (omitting the names of the template parameters):\nStill, not all standard container templates can be used for Cont parameter.\nexample, std::array will not work because it includes a nontype template\nFor further discussion and examples of template template parameters, see Section\n• To access a type name that depends on a template parameter, you have to qualify\n• To access members of bases classes that depend on template parameters, you have\n• Nested classes and member functions can also be templates.\n• Template versions of constructors or assignment operators don’t replace predefined\nensure that variables and members of templates are initialized with a default value\n• When passing raw arrays or string literals, arguments decay (perform an array-to-\n• You can define variable templates (since C++14).\n• You can also use class templates as template parameters, as template template\n• Template template arguments must usually match their parameters exactly.\nstd::cout << \"g() for movable object\\n\";\nf(c);             // f() for constant object calls f(X const&)\ntemplate<typename T>\ntemplate<typename T>\nNote that std::move() has no template parameter and “triggers” move semantics\nfor the passed argument, while std::forward<>() “forwards” potential move\nsemantic depending on a passed template argument.\nDon’t assume that T&& for a template parameter T behaves as X&& for a specific\n• X&& for a specific type X declares a parameter to be an rvalue reference.\nxvalue, such as an object passed with std::move(); see Appendix B for\n• T&& for a template parameter T declares a forwarding reference (also called\nNote that T must really be the name of a template parameter.\ntemplate parameter is not sufficient.\nFor a template parameter T, a declaration such\nstd::cout << \"g() for movable object\\n\";\ntemplate<typename T>\ng(std::forward<T>(val));   // call the right g() for any passed\nf(std::move(v));  // f() for move-enabled variable calls f(X&&)\n6.2 Special Member Function Templates\nMember function templates can also be used as special member functions, including\nstd::string name;\nexplicit Person(std::string const& n) : name(n) {\nstd::cout << \"copying string-CONSTR for ’\" << name <<\nexplicit Person(std::string&& n) : name(std::move(n)) {\nstd::cout << \"COPY-CONSTR Person ’\" << name << \"’\\n\";\nPerson p4(std::move(p1));  // move Person => calls MOVE-CONST\ninitialized by a copy of the passed argument:\nPerson(std::string const& n) : name(n) {\nstd::cout << \"copying string-CONSTR for ’\" << name << \"’\\n\";\n• We provide a version for movable string object, for which we call std::move()\nPerson(std::string&& n) : name(std::move(n)) {\nstd::cout << \"moving string-CONSTR for ’\" << name << \"’\\n\";\nAs expected, the first is called for passed string objects that are in use (lvalues),\nforwarding the passed argument to the member name:\nstd::string name;\ntemplate<typename STR>\nstd::cout << \"COPY-CONSTR Person ’\" << name << \"’\\n\";\nparameter STR is deduced to be of type char const[4].\nstd::forward<STR> to the pointer parameter of the constructor has not much of\n16.2.4 on page 333), for a nonconstant lvalue Person p the member template\ntemplate<typename STR>\nmember template for the case that the passed argument is a Person or an\n6.3 Disable Templates with enable_if<>\nstd::enable_if<> to ignore function templates under certain compile-time\nFor example, if a function template foo<>() is defined as follows:\ntemplate<typename T>\ntypename std::enable_if<(sizeof(T) > 4)>::type\nexpression passed as its (first) template argument and behaves as follows:\n– The type is void if no second template argument is passed.\n– Otherwise, the type is the second template argument type.\ntemplate std::enable_if_t<>, which allows you to skip typename and\ntemplate<typename T>\ntemplate<typename T>\nadditional function template argument with a default value:\ntemplate<typename T,\ntemplate<typename T,\ntemplate<typename T>\ntemplate<typename T,\nWe can use enable_if<> to solve our problem with the constructor template\ntemplate<typename STR>\nif the passed argument STR has the right type (i.e., is a std::string or a type\nconvertible to std::string).\ntemplate<typename STR,\ntypename = std::enable_if_t<\nIf type STR is convertible to type std::string, the whole declaration expands to\ntemplate<typename STR,\nIf type STR is not convertible to type std::string, the whole function template\ntemplate<typename T>\ntemplate<typename T>\nstd::string name;\nstd::cout << \"COPY-CONSTR Person ’\" << name << \"’\\n\";\nPerson p4(std::move(p1));  // OK => calls MOVE-CONST\nNote again that in C++14, we have to declare the alias template as follows, because\ntemplate<typename T>\nstd::string>::value>;\nAnd in C++11, we have to declare the special member template as follows, because\ntemplate<typename T>\nstd::string>::value\ntemplate<typename T>\ntemplate<typename T>\nstd::cout << \"tmpl copy constructor\\n\";\nC y{x};  // still uses the predefined copy constructor (not the\nmember template)\nspecify or deduce its template parameter T.)\n// implement copy constructor template with better match:\ntemplate<typename T>\nstd::cout << \"tmpl copy constructor\\n\";\nNow the template constructors are used even for “normal” copying:\nC y{x};  // uses the member template\ntemplate C<> if the template parameter is an integral type, we can implement the\ntemplate<typename T>\ntemplate<typename STR>\nrequires std::is_convertible_v<STR,std::string>\ntemplate<typename T>\ntemplate<typename STR>\n• In templates, you can “perfectly” forward parameters by declaring them as\nforwarding references (declared with a type formed with the name of a template\nparameter followed by &&) and using std::forward<>() in the forwarded\n• When using perfect forwarding member function templates, they might match\n• With std::enable_if<>, you can disable a function template when a compile-\n• By using std::enable_if<> you can avoid problems when constructor\ntemplates or assignment operator templates that can be called for single arguments\ntemplates.\nThe parameter refers to the passed object, without the ability to modify it.\nThe parameter refers to the passed object, with the ability to modify it.\nThe parameter refers to the passed object, with move semantics, meaning that you\nin function templates by value unless there are good reasons, such as the following:\n• Templates just forward the parameters to somewhere else by keeping all the\nThis chapter discusses the different approaches to declare parameters in templates,\nWhen passing arguments by value, each argument must in principle be copied.\neach parameter becomes a copy of the passed argument.\nto avoid expensive copying even when passing parameters by value: In fact,\nargument is passed by value:\ntemplate<typename T>\nWhen calling this function template for an integer, the resulting code is\nParameter arg becomes a copy of any passed argument, whether it is an object or a\nIf we define a std::string and call our function template for it:\nstd::string s = \"hi\";\nthe template parameter T is instantiated as std::string so that we get\nvoid printV (std::string arg)\nAgain, when passing the string, arg becomes a copy of s.\ncreated by the copy constructor of the string class, which is a potentially expensive\nstd::string s = \"hi\";\nprintV(std::string(\"hi\"));  //copying usually optimized away (if\nprintV(std::move(s));       // move constructor\nIn the first call we pass an lvalue, which means that the copy constructor is used.\nbefore and typically still use afterwards, as we didn’t use std::move() to pass it).\narguments to a parameter by value, the type decays.\ntemplate<typename T>\nstd::string const c = \"hi\";\nstd::string\nThus, when passing the string literal \"hi\", its type char const[3] decays to\nThus, the template is\ngets created (because the parameter just refers to the passed argument).\npassing is possible, there are cases in which the resulting type of the parameter may\ntemplate<typename T>\nWith this declaration, passing an object never creates a copy (whether it’s cheap or\nstd::string s = \"hi\";\nprintR(std::string(\"hi\"));  // no copy\nprintR(std::move(s));       // no copy\nFunction templates\nWhen passing arguments to parameters by reference, they do not decay.\nconst&, the template parameter T itself is not deduced as const.\ntemplate<typename T>\nstd::string const c = \"hi\";\nprintR(c);              // T deduced as std::string, arg is\nstd::string const&\nThe parameters of the called function template just get direct\ntemplate<typename T>\nstd::string s = \"hi\";\noutR(s);                  //OK: T deduced as std::string, arg is\nstd::string&\noutR(std::string(\"hi\"));  //ERROR: not allowed to pass a\noutR(std::move(s));       // ERROR: not allowed to pass an\ntemplate<typename T>\nIf you pass a const argument, the\nstd::string const c = \"hi\";\noutR(c);                   // OK: T deduced as std::string const\noutR(std::move(c));        // OK: T deduced as std::string",
      "keywords": [
        "view code image",
        "code image template",
        "template",
        "std",
        "view code",
        "code image",
        "image template",
        "Person",
        "template parameter",
        "code",
        "STR",
        "Click",
        "view",
        "code image std",
        "image"
      ],
      "concepts": [
        "template",
        "std",
        "copy",
        "copied",
        "type",
        "click",
        "object",
        "passed",
        "passes",
        "argument"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 9,
          "title": "",
          "score": 0.827,
          "base_score": 0.677,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 11,
          "title": "",
          "score": 0.796,
          "base_score": 0.646,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 7,
          "title": "",
          "score": 0.786,
          "base_score": 0.636,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 47,
          "title": "",
          "score": 0.719,
          "base_score": 0.569,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 51,
          "title": "",
          "score": 0.701,
          "base_score": 0.551,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "std",
          "string",
          "template typename",
          "std string",
          "parameter"
        ],
        "semantic": [],
        "merged": [
          "std",
          "string",
          "template typename",
          "std string",
          "parameter"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.463509200501104,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.447500+00:00"
      }
    },
    {
      "chapter_number": 6,
      "title": "Segment 6 (pages 167-197)",
      "start_page": 167,
      "end_page": 197,
      "summary": "Of course, any attempt to modify the passed argument inside the function template is\n• Use a static assertion to trigger a compile-time error:\nstatic_assert(!std::is_const<T>::value,\n• Disable the template for this case either by using std::enable_if<> (see\ntypename = std::enable_if_t<!std::is_const<T>::value>\n7.2.3 Passing by Forwarding Reference\nOne reason to use call-by-reference is to be able to perfect forward a parameter (see\nwhich is defined as an rvalue reference of a template parameter, special rules apply.\npassR(s);                 // OK: T deduced as std::string& (also\npassR(std::string(\"hi\")); // OK: T deduced as std::string, arg\nis std::string&&\npassR(returnString());    // OK: T deduced as std::string, arg\nis std::string&&\npassR(std::move(s));      // OK: T deduced as std::string, arg\nis std::string&&\nstd::string const c = \"hi\";\npassR(c);                 //OK: T deduced as std::string const&\nIn each of these cases, inside passR() the parameter arg has a type that “knows”\nFor example, this is the only case where the template parameter T implicitly can\nbecome a reference type.\nSince C++11, you can let the caller decide, for a function template argument,\nwhether to pass it by value or by reference.\nWhen a template is declared to take\narguments by value, the caller can use std::cref() and std::ref(), declared\nin header file <functional>, to pass the argument by reference.\ntemplates.\nInstead, it uses a trick: It wraps the passed argument s by an object that\nstd::reference_wrapper<> referring to the original argument and passes\nwhenever you have a valid operator for the passed object, you can use the reference\n#include <functional>  // for std::cref()\nvoid printString(std::string const& s)\nstd::string\nThe last call passes by value an object of type\nstd::reference_wrapper<string const> to the parameter arg, which\nthen passes and therefore converts it back to its underlying type std::string.\noperator defined for std::reference_wrapper<>:\nprintV(std::cref(s));     // ERROR: no operator << for reference\nchar const* or std::string:\nif (isless(std::cref(s) < std::string(\"world\"))) …  //ERROR\nbecause then the compiler gets conflicting types when trying to deduce T for arg1\nThus, the effect of class std::reference_wrapper<> is to be able to use a\nreference as a “first class object,” which you can copy and therefore pass by value to\nfunction templates.\nSo far, we have seen the different effects for templates parameters when using string\n• Call-by-value decays so that they become pointers to the element type.\n• Any form of call-by-reference does not decay so that the arguments become\nthe other hand, when dealing with parameters where string literals may be passed,\nconst[3], while \"guy\" has type char const[4], but the template requires\nBy declaring the function template foo() to pass the argument by value the call\ncoming from another function called by value or being assigned to an object declared\nthe arguments using the type trait std::decay<>().\nstd::make_pair() in Section 7.6 on page 120 for a concrete example.\nstd::common_type<>, which yields the common type of two passed argument\n• You can declare template parameters so that they are only valid for arrays:\ntemplate<typename T, std::size_t L1, std::size_t L2>\n• You can use type traits to detect whether an array (or a pointer) was passed:\nthat the caller of a template uses std::vector or std::array.\nstd::cout << c;   //run-time ERROR\nHere, we obtained a reference to an element of a string, but by the time we use that\nstd::cout << c;   //run-time ERROR\nWe should therefore ensure that function templates return their result by value.\nEven when T is a template parameter deduced from a call-by-value call, it might\nbecome a reference type when explicitly specifying the template parameter to be a\n• Use the type trait std::remove_reference<> (see Section D.4 on page 729)\ntypename std::remove_reference<T>::type retV(T p)\nOther traits, such as std::decay<> (see Section D.4 on page 731), may also be\n• Let the compiler deduce the return type by just declaring the return type to be\nauto retV(T p)  // by-value return type deduced by compiler\n7.6 Recommended Template Parameter Declarations\n• Declare to pass the arguments by value:\n• Declare to pass the arguments by-reference:\nalso have to beware that with this approach template parameters implicitly can\ndeduce to reference types.\nWith these options in mind, for function templates we recommend the following:\n1. By default, declare parameters to be passed by value.\nand std::cref() when passing existing large objects (lvalues) to avoid\n– If a template is provided to forward an argument, use perfect forwarding.\ndeclare parameters to be forwarding references and use std::forward<>()\nstd::common_type<> to “harmonize” the different types of string literals and\nNote that, in practice, function templates often are not for arbitrary types of\nvectors of some type are passed.\nIt is a convenience function template in the C++\nstandard library to create std::pair<> objects using type deduction.\nnamespace std to use call-by-reference to avoid unnecessary copying:\n• As a consequence, with C++03 the function definition was changed to use call-by-\nreturn pair<typename decay<T1>::type,\nand std::cref(), the function also unwraps instances of\nThe C++ standard library now perfectly forwards passed arguments in many places\n• When testing templates, use string literals of different length.\n• Template parameters passed by value decay, while passing them by reference does\n• The type trait std::decay<> allows you to decay parameters in templates\npassed by reference.\n• In some cases std::cref() and std::ref() allow you to pass arguments by\nreference when function templates declare them to be passed by value.\n• Passing template parameters by value is simple but may not result in the best\n• Pass parameters to function templates by value unless there are good reasons to do\n• Ensure that return values are usually passed by value (which might mean that a\ntemplate parameter can’t be specified directly as a return type).\n6 When passing std::move(c), std::move() first converts c to\nstd::string const&&, which then has the effect that T is deduced as\nstd::string const.\n7 You can also call get() on a reference wrapper and use it as function object.\nC++ has always included some simple ways to compute values at compile time.\nbetween different template code.\nIn fact, C++ has multiple features to support compile-time programming:\n• Since before C++98, templates have provided the ability to compute at compile\n• With partial specialization we can choose at compile time between different class\ntemplate implementations for different types or different constraints.\n• In C++11 and C++14, compile-time computing became increasingly better\ntemplates.\nTemplates are instantiated at compile time (in contrast to dynamic languages, where\nThe following code finds out at compile time whether a given number is a prime\ntemplate<unsigned p>              // end recursion if divisor is\n// special cases (to avoid endless recursion with template\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<>\nThe IsPrime<> template returns in member value whether the passed template\nfunction can be evaluated at compile time.\nWhile in C++11 constexpr functions\nWith C++14, constexpr functions can make use of most control structures\nIn a context that requires a compile-time value (e.g., an\narray length or a nontype template argument), the compiler will attempt to evaluate a\ncall to a constexpr function at compile time and issue an error if that is not\nconstexpr bool b1 = isPrime(9);   // evaluated at compile time\nwill compute the value at compile time.\nconst bool b2 = isPrime(9);       // evaluated at compile time\ndecide whether to compute it at compile or run time.4 This, for example, is also the\nstd::cout << isPrime(x);           // evaluated at run time\nAn interesting application of a compile-time test such as isPrime() is to use\npartial specialization to select at compile time between different implementations.\nwhether a template argument is a prime number:\ntemplate<typename T, std::size_t SZ>\nlong foo (std::array<T,SZ> const& coll)\nHere, depending on whether the size of the std::array<> argument is a prime\nimplementations of a function template depending on properties of the arguments it’s\nInstead, we can also use the primary template for one of the alternatives\nBecause function templates do not support partial specialization, you have to use\n• Use classes with static functions,\n• Use std::enable_if, introduced in Section 6.3 on page 98,\n• Use the compile-time if feature, available since C++17, which is introduced\nIn cases where the set of candidates for a call includes function templates, the\ncompiler first has to determine what template arguments should be used for that\nreturn type, and then evaluate how well it matches (just like an ordinary function).\ntypename T::size_type len (T const& t)\nHere, we define two function templates len() taking one generic argument:5\n1. The first function template declares the parameter as T(&)[N], which means that\n2. The second function template declares the parameter simply as T, which places no\nconstraints on the parameter but returns type T::size_type, which requires\nthat the passed argument type has a corresponding member size_type.\nWhen passing a raw array or string literals, only the function template for raw arrays\nstd::cout << len(a);       // OK: only len() for array matches\nstd::cout << len(\"tmp\");   //OK: only len() for array matches\nAccording to its signature, the second function template also matches when\nsubstitutions lead to potential errors in the return type T::size_type.\nWhen passing a std::vector<>, only the second function template matches:\nstd::cout << len(v);   // OK: only len() for a type with\nWhen passing a raw pointer, neither of the templates match (without a failure).\nresult, the compiler will complain that no matching len() function is found:\nstd::cout << len(p);   // ERROR: no matching len() function\nNote that this differs from passing an object of a type having a size_type\nstd::cout << len(x);   // ERROR: len() function found, but can’t\nWhen passing an object of such a type, the compiler finds the second function\ntemplate as matching function template.\nlen() function is found, this will result in a compile-time error that calling\nsecond and third function templates match, with the second function template as the\nstd::cout << len(a);        // OK: len() for array is best match\nstd::cout << len(\"tmp\");    //OK: len() for array is best match\nstd::cout << len(v);        // OK: len() for a type with\nstd::cout << len(p);        // OK: only fallback len() matches\nstd::cout << len(x);        // ERROR: 2nd len() function matches\nstandard that a function template “shall not participate in overload resolution\nunless…” it means that SFINAE is used to “SFINAE out” that function template for\nFor example, class std::thread declares a constructor:\ndecay_t<F> is the same type as std::thread.\nstd::thread as first and only argument.\nsuch feature is std::enable_if<>, which was introduced in Section 6.3 on page\nIt allows us to disable a template just by replacing a type with a construct\nAs a consequence, the real declaration of std::thread typically is as follows:\nSee Section 20.3 on page 469 for details about how std::enable_if<> is\nfunction templates for certain conditions.\nSuppose, for example, that we want to ensure that the function template len() is\nin the function declaration, the function template is selected and its ultimate\n• Specify the return type with the trailing return type syntax (use auto at the front\n• Define the return type using decltype and the comma operator.\n• Define an object of the real return type at the end of the comma operator.\nso that the last expression T::size_type() yields a value of the desired return\nC++17 additionally introduces a compile-time if\nAs a first example, consider the variadic function template print() introduced\ntemplate<typename T, typename… Types>\ndon’t depend on template parameters (see Section 1.1.3 on page 6).\nNote that if constexpr can be used in any function, not only in templates.\nonly need a compile-time expression that yields a Boolean value.\nWith this feature, we can, for example, use our isPrime() compile-time function,\ntemplate<typename T, std::size_t SZ>\nvoid foo (std::array<T,SZ> const& coll)\n• Templates provide the ability to compute at compile time (using recursion to iterate\n• With constexpr functions, we can replace most compile-time computations with\nclass templates based on certain compile-time constraints.\n• Templates are used only if needed and substitutions in function template\n• SFINAE can be used to provide function templates only for certain types and/or\n• Since C++17, a compile-time if allows us to enable or discard statements\naccording to compile-time conditions (even outside templates).\nwith the C++ standard library, which defines a standard function template\nstd::size() since C++17.",
      "keywords": [
        "view code image",
        "code image template",
        "view code",
        "code image",
        "template",
        "std",
        "image template",
        "type",
        "code",
        "function template",
        "function",
        "Section",
        "Click",
        "view",
        "image"
      ],
      "concepts": [
        "templates",
        "std",
        "functional",
        "functions",
        "type",
        "click",
        "uses",
        "useful",
        "returning",
        "objects"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 43,
          "title": "",
          "score": 0.865,
          "base_score": 0.715,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 4,
          "title": "",
          "score": 0.854,
          "base_score": 0.704,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 37,
          "title": "",
          "score": 0.726,
          "base_score": 0.576,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 42,
          "title": "",
          "score": 0.684,
          "base_score": 0.534,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 8,
          "title": "",
          "score": 0.666,
          "base_score": 0.666,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "len",
          "std",
          "function",
          "compile",
          "time"
        ],
        "semantic": [],
        "merged": [
          "len",
          "std",
          "function",
          "compile",
          "time"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4815642493135414,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.447586+00:00"
      }
    },
    {
      "chapter_number": 7,
      "title": "Segment 7 (pages 198-230)",
      "start_page": 198,
      "end_page": 230,
      "summary": "usual for “ordinary code,” we declare the template in a header file:\n// declaration of template\nThe implementation of the function is placed in a CPP file:\n// implementation/definition of template\nThe example uses the typeid operator to print a string that describes the type of\nstd::type_info, which provides a member function name() that shows the\nFinally, we use the template in another CPP file, into which our template\n// use of the template\nprintTypeof(ice);    // call function template for type\nA C++ compiler will most likely accept this program without any problems, but the\nThe reason for this error is that the definition of the function template\nIn order for a template to be\nwhat template arguments it should be instantiated.\ndefinition in sight to instantiate this function for double, it just assumes that such a\nmyfirst.cpp, it has no indication at that point that it must instantiate the template\n9.1.2 Templates in Header Files\nwould take with macros or with inline functions: We include the definitions of a\ntemplate in the header file that declares that template.\nso that it contains all template declarations and template definitions:\n// declaration of template\n// implementation/definition of template\nThis way of organizing templates is called the inclusion model.\nthis approach has considerably increased the cost of including the header file\ndefinition itself but the result of the fact that we must also include the headers used\nlike <iostream> contain many template definitions of their own.\nsome possible ways to approach this problem, including precompiled headers (see\nSection 9.3 on page 141) and the use of explicit template instantiation (see Section\nfunction templates are distinct from inline functions and macros in an important way:\nwhen they find two distinct definitions for the same function.\nFinally, we need to point out that what applies to the ordinary function template in\nour example also applies to member functions and static data members of class\ntemplates, as well as to member function templates.\n9.2 Templates and inline\nDeclaring functions to be inline is a common tool to improve the running time of\neffect of inline is to allow a function definition to appear multiple times in a\nprogram (usually because it appears in a header file that is included in multiple\nLike inline functions, function templates can be defined in multiple translation\nThis is usually achieved by placing the definition in a header file that is\nThis doesn’t mean, however, that function templates use inline substitutions by\nfunction template body at the point of call is preferred over the usual function call\nIt’s worth pointing out at this point that full specializations of function templates\nEven without templates, C++ header files can become very large and therefore take a\nhow to create and use precompiled header files to the documentation of the various\nthe compiler may also generate code in object files.\nsake of argument that every file to be compiled starts with the same N lines of code.\nheader file named std.hpp that includes all the standard headers:2\n#include \"std.hpp\"\nchange, and hence the precompiled header for our std.hpp file can be built once.\nstd.hpp header) to headers that aren’t expected to change all the time and\nFor example, suppose that in addition to our std.hpp header (which\nwe have precompiled), we also define a core.hpp header that includes additional\n#include \"std.hpp\"\nBecause this file starts with #include \"std.hpp\", the compiler can load the\nNot so with templates.\n[] (std::string const& s){\nA version of the popular GNU C++ compiler reports the following error:\nterator<std::pair<const std::__cxx11::basic_string<char>\ninclude/bits/stl_algo.h:161:23:  required from '_Iterator std:\npair<const std::__cxx11::basic_string<char>, double> >; \ninclude/bits/stl_algo.h:3824:28:  required from '_IIter std::f\nstd::__cxx11::basic_string<char>, double> >; _Predicate \n<lambda(const string&)>) (std::pair<const std::__cxx11::basic_\n(const std::__cxx11::basic_string<char>&)} <conversion>\n16  [] (std::string const& s) {\nstd::__cxx11::basic_string<char>, double>' to 'const str\ntemplate instance deep inside an internal predefined_ops.h header, included\nlines, the compiler reports what was instantiated with which arguments.\n[] (std::string const& s) {\nThis caused the instantiation of a find_if template on line 115 of the\nstd::__cxx11::basic_string<char>,\ntemplates to be instantiated.\nimplies that a function call could not be resolved because the types of the arguments\n(main()::<lambda(const string&)>) (std::pair<const\nstd::__cxx11::basic_string<char>,\nthat there was a single candidate type expecting a const string& and that this\n(std::string const& s) combined with a reason why a possible candidate\nfrom ’std::pair<const std::__cxx11::basic_string<char>, double>’\nto ’const string& {aka const std::__cxx11::basic_string<char>&}’\ntemplate instantiation names like std::__cxx11::basic_string<char>,\nusing just std::string might be enough.\n(const std::string &) const': cannot convert argument 1 from\n'std::pair<const _Kty,_Ty>' to 'const std::string &'\n_Kty,_Ty>' to 'const std::string'\n<std::pair<const std::string,double>>>>,\n21 main.cpp(13): note: see reference to function template inst\nconst std::string,double>>>>,\nstd::string’\nstd::string name;\nCustomer (std::string const& n)\nstd::string getName() const {\nstd::size_t operator() (Customer const& c) {\nreturn std::hash<std::string>()(c.getName());\ninclude/bits/unordered_set.h:95:63:  required from 'class\nstd::\n13     std::size_t operator() (const Customer& c) {\ninclude/bits/unordered_set.h:95:63:     required from 'class\nstd::\n26 /cygdrive/p/gcc/gcc61-include/type_traits:154:38: error:\ninstantiation of 'class std::\nstd::__detail::\nstd::__detail::\nstd::size_t main()::MyCustomerHash::operator()(const Customer&)\nstd::size_t operator() (const Customer& c) {\nstd::unordered_set class template requires that the function call operator for\nthe hash object be a const member function (see also Section 11.1.1 on page 159).\nstd::size_t operator() (const Customer& c) const {\nerrornovel2.cpp:28:47: note: in instantiation of template class\n’this’ argument has type ’const\nstd::size_t operator() (const Customer& c) {\nNote that clang here mentions default template parameters such as\nThe organization of source code in header files and CPP files is a practical\nC++ compiler implementations.\ndifferent: The inclusion of template definitions was implicit, which created a certain\nmodel of template compilation via exported templates.\ntemplate declarations marked as export to be declared in headers, while their\ncorresponding definitions were placed in CPP files, much like declarations and\nremoved exported templates from C++11.\ntemplate code.\n• Only full specializations of function templates need inline when defined in\n• Debugging code with templates can be challenging.\nBasic Template Terminology\nSo far we have introduced the basic concept of templates in C++.\nIn C++, structs, classes, and unions are collectively called class types.\nadditional qualification, the word “class” in plain text type is meant to include class\nThere is some confusion about how a class that is a template is called:\n• The term class template states that the class is a template.\n• The term template class, on the other hand, has been used\n– as a synonym for class template.\n– to refer to classes generated from templates.\n– to refer to classes with a name that is a template-id (the combination of a template\nname followed by the template arguments specified between < and >).\nBecause of this imprecision, we avoid the term template class in this book.\nSimilarly, we use function template, member template, member function template,\nand variable template but avoid template function, template member, template\nmember function, and template variable.\nWhen processing source code that uses templates, a C++ compiler must at various\ntimes substitute concrete template arguments for the template parameters in the\ntemplate.\nThe process of actually creating a definition for a regular class, type alias,\nfunction, member function, or variable from a template by substituting concrete\narguments for the template parameters is called template instantiation.\ndenote the process of creating a declaration that is not a definition through template\ncase of a class template, produces an incomplete class).\nclass, function, member function, or variable) is generically called a specialization.\ndeclaration that is tied to a special substitution of template parameters.\ntemplate<>:\ntemplate<typename T1, typename T2>        // primary class\ntemplate\ntemplate<>                                // explicit\nclass MyClass<std::string,float> {\nAs described in Section 2.6 on page 33, specializations that still have template\ncalled the primary template.\nFor function\nclass C {};               // definition (and declaration) of\nBy extension, the declaration of a class template or function template is called a\n• A class type that has been declared but not yet defined.\nclass C;              // C is an incomplete type\nC const* cp;          // cp is a pointer to an incomplete type\nclass C { };          // C now is a complete type (and therefore\ntemplates.\n• Ordinary (i.e., not templates) noninline functions and member functions, as well as\n• Class types (including structs and unions), templates (including partial\nfunction or member function, a global variable or a static data member, including\n10.5 Template Arguments versus Template Parameters\nCompare the following class template:\nNote how the name of the template is followed by template arguments in angle\nRegardless of whether these arguments are themselves dependent on template\nparameters, the combination of the template name, followed by the arguments in\nIt is essential to distinguish between template parameters and template arguments.\n• Template parameters are those names that are listed after the keyword template\nin the template declaration or definition (T and N in our example).\n• Template arguments are the items that are substituted for template parameters\nThe substitution of template parameters by template arguments is explicit when\nimplicit (e.g., if template parameters are substituted by their default arguments).\nA fundamental principle is that any template argument must be a quantity or value\ntemplate parameters are eventually substituted by compile-time values, they can\nmust be a constant-expression, and the template parameter N qualifies as such.\ncompile-time entities, they can also be used to create valid template arguments.\nNote how in this example the name T is both a template parameter and a template\nfrom the mechanisms that allow us to assemble types and functions.\n• Use class template, function template, and variable template for classes, functions,\n• Template instantiation is the process of creating regular classes or functions by\nreplacing template parameters with concrete arguments.\n• According to the one-definition rule (ODR), noninline functions, member\nHowever, we prefer to use class for types that use new C++ features,\nHowever, templates are most\nreserved for entities that are passed as function call arguments (as opposed to, e.g.,\ntemplate arguments), and we maintain this tradition.\nbe passed as function call arguments and can be directly called with the syntax f(…\n• Pointer-to-function types\n• Class types with an overloaded operator() (sometimes called functors),\n• Class types with a conversion function yielding a pointer-to-function or reference-\nto-function\nCollectively, these types are called function object types, and a value of such a type\nThe C++ standard library introduces the slightly broader notion of a callable type,\nwhich is either a function object type or a pointer to member.\nThe following program demonstrates the use of this template with various function\n// a function to call:\n// a function object type (for objects that can be used as\nfunctions):\nfunction\nstd::cout << \"lambda called for:      \" << i <<\n• When we pass the name of a function as a function argument, we don’t really pass\npage 115), function arguments decay to a pointer when passed by value, and in the\ncase of a parameter whose type is a template parameter, a pointer-to-function type\nfunction types cannot really be qualified with const.\nparameter of foreach() with type Callable const&, the const would just\nfunction name.\n• When passing a functor, we pass a class type object as a callable.\nor reference to a surrogate call function (discussed in Section C.3.5 on page 694).\nwhere F is the type of the pointer-to-function or reference-to-function that the class\nOne possible entity to call was not used in the previous example: member functions.\nstd::invoke() that conveniently unifies this case with the ordinary function-call\nfollowing implementation of our foreach() template uses std::invoke():\n#include <functional>\nvoid foreach (Iter current, Iter end, Callable op, Args const&…\nstd::invoke(op,               //call passed callable with\nThe foreach() template then calls std::invoke()\n• If the callable is a pointer to member, it uses the first additional argument as the\n• Otherwise, all additional parameters are just passed as arguments to the callable.\nthe callable can be a member function.1 The following client code illustrates this:\n// a class with a member function that shall be called\n[](std::string const& prefix, int i) {  //lambda to\nmember function memfunc() as the third argument to be called for obj passed as\nA common application of std::invoke() is to wrap single function calls (e.g., to\n#include <utility>           // for std::invoke()\n#include <functional>        // for std::forward()\ntemplate<typename Callable, typename… Args>\nreturn std::invoke(std::forward<Callable>(op),        //passed\ntemplate<typename Callable, typename… Args>\nthe type of variable, return type, or template argument from the type of the\nassociated expression (initializer, return value, or template argument).",
      "keywords": [
        "view code image",
        "template",
        "std",
        "view code",
        "code image",
        "function",
        "code image template",
        "code",
        "const",
        "const std",
        "function template",
        "template parameters",
        "include",
        "type",
        "code image std"
      ],
      "concepts": [
        "template",
        "std",
        "include",
        "included",
        "function",
        "functions",
        "functionality",
        "compiler",
        "compiles",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 11,
          "title": "",
          "score": 0.896,
          "base_score": 0.746,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 9,
          "title": "",
          "score": 0.868,
          "base_score": 0.718,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 5,
          "title": "",
          "score": 0.786,
          "base_score": 0.636,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 47,
          "title": "",
          "score": 0.757,
          "base_score": 0.607,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 51,
          "title": "",
          "score": 0.753,
          "base_score": 0.603,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "function",
          "std",
          "const",
          "header",
          "class"
        ],
        "semantic": [],
        "merged": [
          "function",
          "std",
          "const",
          "header",
          "class"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5204050858059345,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.447672+00:00"
      }
    },
    {
      "chapter_number": 8,
      "title": "Segment 8 (pages 231-264)",
      "start_page": 231,
      "end_page": 264,
      "summary": "template<typename T>\ntemplate<typename V>\nThe std::addressof<>() function template yields the actual address of an\ntemplate<typename T>\nThe std::declval<>() function template can be used as a placeholder for an\nthe passed template parameters T1 and T2:\ntemplate<typename T1, typename T2,\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\n11.4 References as Template Parameters\nAlthough it is not common, template type parameters can become reference types.\ntemplate<typename T>\ntemplate parameter T is deduced to the type of the referenced type (because, for a\ntemplate<typename T, T Z = T{}>\nHere we have a class with a member of template parameter type T, initialized with a\nnontype template parameter Z that has a zero-initialized default value.\nAlso, using reference types for nontype template parameters is tricky and can be\ntemplate<typename T, int& SZ>      // Note: size is reference\nNote that changing the template parameter SZ to be of type int const& does not\ntemplate<typename T, decltype(auto) SZ>\n• In order to still have an assignment operator even if the template parameters are\ntemplate<typename T1, typename T2>\nstandard library class templates std::optional<> and std::variant<>\ntemplate<typename T>\nfollowing class template:\ntemplate<typename T>\ntemplate<typename T>\ndecision depends on whether the template parameter type T supports move\ntemplate<typename T>\ntemplate<typename D = T>\nNow, the traits depends on the template parameter D (defaulted to T, the value we\n• Use forwarding references to forward values in templates (see Section 6.1 on page\nIf the values do not depend on template parameters, use auto&& (see Section\ntemplate parameter has a reference type when passing lvalues (see Section 15.6.2\na template parameter to avoid surprises when it binds to a type with overloaded\n• For member function templates, ensure that they don’t match better than the\n• Consider using std::decay when template parameters might be string literals\n• Be prepared to deal with the side effects of template parameters being references\n• Use std::addressof() when you need the address of an object in a template.\ndepend on template parameters.\n• Be prepared to deal with the side effects of template parameters being references.\nincomplete types in class templates).\n• Fundamental template declaration issues\n• The C++ template instantiation mechanisms\nbook in depth: the declaration of templates, the restrictions on template parameters,\nC++ currently supports four fundamental kinds of templates: class templates,\nEach of these template\nbecome nested class templates, member function templates, static data member\nSuch templates are declared much like\ntemplate<parameters here>\nWe’ll come back to the actual template parameter declarations in a later section.\ntemplate<typename T>            // a namespace scope class\ntemplate\ntemplate<typename T>            // a namespace scope function\ntemplate\ntemplate<typename T>           // a namespace scope variable\ntemplate (since C++14)\ntemplate<typename T>           // a namespace scope variable\ntemplate (since C++14)\ntemplate\nparameterization of the class template Data.\nHowever, a variable template can\nstatic data member template.\nThe following example shows the four kinds of templates as class members that\ntemplate<typename T>        // an in-class member class\ntemplate definition\ntemplate<typename T>        // an in-class (and therefore\nT* alloc() {                //member function template\ntemplate<typename T>        // a member variable template\ntemplate<typename T>        // a member alias template\ntemplates can be defined out-of-class:\ntemplate<typename T>            // a namespace scope class\ntemplate\nList() = default;           // because a template constructor\ntemplate<typename U>        // another member class template,\ntemplate<typename U>        // a member function template\ntemplate<typename U>        // a member variable template\ntemplate<typename T>            // out-of-class member class\ntemplate definition\ntemplate<typename U>\ntemplate<typename T>            // out-of-class member function\ntemplate definition\ntemplate<typename T2>\ntemplate<typename T>           // out-of-class static data member\ntemplate definition\ntemplate<typename U>\nMember templates defined outside their enclosing class may need multiple\ntemplate<… > parameterization clauses: one for every enclosing class template\nand one for the member template itself.\noutermost class template.\nNote also that a constructor template (a special kind of member function template)\nUnion Templates\nUnion templates are possible too (and they are considered a kind of class template):\ntemplate<typename T>\nFunction templates can have default call arguments just like ordinary function\ntemplate<typename T>\ntemplate<typename T>\nThe latter declaration shows that a default call argument could depend on a template\ntemplate<typename T>\nNontemplate Members of Class Templates\nIn addition to the four fundamental kinds of templates declared inside a class, you\ntemplates.\nTheir parameters are entirely determined by the template of which they\ntemplate<int I>\ntemplate\ntemplate\nclass template\nin class template\nclass templates, but not for the member itself, because it is not a template (i.e., no\ntemplate<int I>         // definition of ordinary class in class\ntemplate\ntemplate<int I>         // definition of ordinary function in\nclass template\ntemplate<int I>         // definition of ordinary enumeration\ntype class in class template\ntemplate<int I>         // definition of ordinary static member\nin class template\ntemplate using inline:\ntemplate<int I>\ndefined inside a class template (see Section 2.4 on page 30) or the closure type of a\nMember function templates cannot be declared virtual.\nHence, supporting virtual member function templates would require\nIn contrast, the ordinary members of class templates can be virtual because their\ntemplate<typename T>\ntemplate<typename T2>\n12.1.2 Linkage of Templates\nthat, unlike class types, class templates cannot share a name with a different kind of\ntemplate<typename T>\ntemplate<typename T>\nextern \"C++\" template<typename T>\nextern \"C\" template<typename T>\nvoid invalid();          //ERROR: templates cannot have C\ntemplates of unnamed classes (which have no linkage).\ntemplate<typename T>     // refers to the same entity as a\ntemplate<typename T>     // redeclaration of the previous\ntemplate<typename>     // redeclaration of the previous\ntemplate declaration\ntemplate<typename T> void f(T) {}  //no linkage: cannot be\nCurrently templates cannot be declared in function scope or local class scope, but\ntypes that contain member function templates, can appear in local scopes, which\nfunction internal<void>() instantiated from the template internal declared\nvariable templates.\ntemplate<typename T> T zero = T{};\ninstantiations of the template\ntemplate<typename T> int const max_volume = 11;\nSuch template\nthe template name:\ntemplate<typename T> class Box;              // OK: primary\ntemplate\ntemplate<typename T> class Box<T>;           // ERROR: does not\ntemplate<typename T> void translate(T);      // OK: primary\ntemplate\ntemplate<typename T> void translate<T>(T);   // ERROR: not\ntemplate\ntemplate<typename T> constexpr T zero<T> = T{};  // ERROR: does\nNonprimary templates occur when declaring partial specializations of class or\nvariable templates.\nFunction templates must\nalways be primary templates (see Section 17.3 on page 356 for a discussion of a\n12.2 Template Parameters\nThere are three basic kinds of template parameters:\n3. Template template parameters\nAny of these basic kinds of template parameters can be used as the basis of a\ntemplate parameter pack (see Section 12.2.4 on page 188).\nTemplate parameters are declared in the introductory parameterization clause of a\ntemplate<typename, int>\ntemplate.\nNote also that a template parameter name can be referred to in a\ntemplate<typename T,             //the first parameter is used\ntemplate<T> class Buf>  // in the declaration of the\ntemplate argument.\nWithin a template declaration, a type parameter acts much like a type alias (see\nthe form class T when T is a template parameter, even if T were to be substituted\ntemplate<typename Allocator>\nNontype template parameters stand for constant values that can be determined at\nPerhaps surprisingly, the declaration of a nontype template parameter can in some\ntemplate<typename T,                       //a type parameter\ntemplate<class X*>    // a nontype parameter of pointer type\ntemplate<int buf[5]> class Lexer;         // buf is really an\ntemplate<int* buf> class Lexer;           // OK: this is a\ntemplate<int (*)()> struct FuncWrap;      // OK: this is a\nNontype template parameters are declared much like variables, but they cannot have\ntemplate<int const length> class Buffer; // const is useless\ntemplate<int length> class Buffer;       // same as previous\ntemplate<int& Counter>\n12.2.3 Template Template Parameters\nTemplate template parameters are placeholders for class or alias templates.\ndeclared much like class templates, but the keywords struct and union cannot\ntemplate<template<typename X> class C>          // OK\ntemplate<template<typename X> struct C>         // ERROR: struct\ntemplate<template<typename X> union C>         // ERROR: union\nby the fact that template template parameters can be substituted not only by class\ntemplates but also by alias templates (which instantiate to arbitrary types).\ntemplate<template<typename X> typename C>        // OK since\nIn the scope of their declaration, template template parameters are used just like\nother class or alias templates.\nThe parameters of template template parameters can have default template\nnot specified in uses of the template template parameter:\ntemplate<template<typename T,\nthat template template parameter.\ntemplate<template<typename T, T*> class Buf>  // OK\nstatic T* storage;  // ERROR: a template template parameter\nparameter are not needed in the declaration of other template parameters and are\ntemplate could be declared as follows:\ntemplate<template<typename,\n12.2.4 Template Parameter Packs\nSince C++11, any kind of template parameter can be turned into a template\ntemplate<typename… Types>   // declares a template parameter\nThis means that the Tuple class template declared above accepts any\nnumber of (possibly distinct) types as template arguments:\nusing IntTuple = Tuple<int>;              // OK: one template\nclass MultiArray;       // OK: declares a nontype template\nvoid testContainers();  // OK: declares a template template\nlast template parameter.\nsubsequent to a template parameter pack either has a default value (see the next\ntemplate<typename… Types, typename Last>\nclass LastType;  // ERROR: template parameter pack is not the\nlast template parameter\nvoid runTests(T value);  // OK: template parameter pack is\n//     by a deducible template\nDeclarations of partial specializations of class and variable templates (see Chapter\n12.2.5 Default Template Arguments\nA template parameter for a class template, variable template, or alias template can\narguments.) The subsequent default values are usually provided in the same template\ntemplate.\nDefault template arguments for template parameters of function templates do not\nrequire subsequent template parameters to have a default template argument:6\ntemplate<typename R = void, typename T>\nDefault template arguments cannot be repeated:\ntemplate<typename T = void>\ntemplate<typename T = void>\ntemplate<typename T>",
      "keywords": [
        "template",
        "code image template",
        "view code image",
        "template parameter",
        "image template",
        "view code",
        "code image",
        "class template",
        "template parameter pack",
        "typename",
        "Section",
        "type",
        "parameter",
        "code",
        "int"
      ],
      "concepts": [
        "template",
        "classes",
        "std",
        "type",
        "void",
        "click",
        "error",
        "declare",
        "declaring",
        "declarations"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 10,
          "title": "",
          "score": 0.778,
          "base_score": 0.778,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 53,
          "title": "",
          "score": 0.775,
          "base_score": 0.775,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 9,
          "title": "",
          "score": 0.759,
          "base_score": 0.759,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 14,
          "title": "",
          "score": 0.738,
          "base_score": 0.738,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 52,
          "title": "",
          "score": 0.726,
          "base_score": 0.726,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "template typename",
          "template template",
          "class",
          "templates",
          "parameter"
        ],
        "semantic": [],
        "merged": [
          "template typename",
          "template template",
          "class",
          "templates",
          "parameter"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5655983177983864,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.447758+00:00"
      }
    },
    {
      "chapter_number": 9,
      "title": "Segment 9 (pages 265-294)",
      "start_page": 265,
      "end_page": 294,
      "summary": "template<typename T = int>\ntemplate<typename… Ts = int> struct X;        // ERROR\n• The out-of-class definition of a member of a class template:\ntemplate<typename T> struct X\ntemplate<typename T = int> T X<T>::f() {          // ERROR\n• A friend class template declaration:\ntemplate<typename = void> friend struct F;\n• A friend function template declaration unless it is a definition and no declaration of\ntemplate<typename = void> friend void f();    // ERROR: not a\ntemplate<typename = void> friend void g() {   //OK so far\ntemplate argument\n12.3 Template Arguments\nWhen instantiating a template, template parameters are substituted by template\n• Explicit template arguments: A template name can be followed by explicit template\n• Injected class name: Within the scope of a class template X with template\nparameters P1, P2, … , the name of that template (X) can be equivalent to the\ntemplate instances if default template arguments are available.\nor alias template, even if all template parameters have a default value, the (possibly\n• Argument deduction: Function template arguments that are not explicitly specified\nmay be deduced from the types of the function call arguments in a call.\nIf all the template arguments can be deduced, no angle brackets need to be\nspecified after the name of the function template.\nto deduce class template arguments from the initializer of a variable declaration or\n12.3.1 Function Template Arguments\nTemplate arguments for a function template can be specified explicitly, deduced\nfrom the way the template is used, or provided as a default template argument.\ntemplate<typename T>\n::max(1.0, -3.0);          // template argument is implicitly\nSome template arguments can never be deduced because their corresponding\ntemplate parameter does not appear in a function parameter type or for some other\nplaced at the beginning of the list of template parameters so they can be specified\nIf we had reversed the order of the template parameters in this example (in other\ncall of implicit_cast would have to specify both template arguments explicitly.\ntemplate<typename … Ts, int N>\nBecause function templates can be overloaded, explicitly providing all the arguments\ntemplate<typename T> void single(T);\ntemplate<typename T> void multi(T);\ntemplate<typename T> void multi(T*);\nAs a result, the template argument value for the\nFurthermore, it is possible that substituting template arguments in a function\ntemplate results in an attempt to construct an invalid C++ type or expression.\ntemplates because type int has no member type X.\nTemplate type arguments are the “values” specified for template type parameters.\nused as a template argument, but their substitution for the template parameters must\ntemplate<typename T>\nNontype template arguments are the values substituted for nontype parameters.\n• Another nontype template parameter that has the right type.\ntemplate arguments match nontype parameters of a pointer type.\nwhere C is a class type and m is a nonstatic member (data or function).\nargument before conversion can have a class type.\nHere are some valid examples of nontype template arguments:\nC<void(), &templ_func<double>>* c4;  // function template\nThe requirement is that a nontype template parameter declared as reference or\n12.3.4 Template Template Arguments\nA template template argument must generally be a class template or alias template\nPrior to C++17, default template arguments of a template\ntemplate argument were ignored (but if the template template parameter has default\narguments, they are considered during the instantiation of the template).\nrelaxed the matching rule to just require that the template template parameter be at\ntemplate argument.\ntemplate<typename> class Cont>  // Cont expects one\ntemplate parameter\nThe problem in this example is that the std::list template of the standard library\nVariadic template template parameters are an exception to the pre-C++17 “exact\ngeneral matching against template template arguments.\nparameter pack can match zero or more template parameters of the same kind in the\ntemplate template argument:\nclass Rel {                                  // type parameters\ntemplate parameters\nTemplate parameter packs can only match template arguments of the same kind.\nexample, the following class template can be instantiated with any class template or\nalias template having only template type parameters, because the template type\nparameter pack passed there as TT can match zero or more template type parameters:\ntemplate<template<typename… > class TT>\nAlmostAnyTmpl<std::array> withArray;   // ERROR: a template type\nnontype template parameter\ntemplate template parameter does not indicate that only class templates declared with\nparameter (alias templates since C++11, when they were introduced).\nto the observation that any type can be used as an argument for a template type\nTwo sets of template arguments are equivalent when values of the arguments are\ntemplate<typename T, int I>\nequivalence of the template argument lists.)\ntemplate<int N> struct I {};\ntemplate<int M, int N> void f(I<M+N>);  // #1\ntemplate<int N, int M> void f(I<N+M>);  // #2\ntemplate<int M, int N> void f(I<N+M>);  // #3 ERROR\nequivalent and declare the same function template f.\nvalues of the template parameters involved, those expressions are called functionally\nIt is an error for templates to be declared in ways that differ only because\nA function generated from a function template is never equivalent to an ordinary\nat least one template parameter pack (see Section 12.2.4 on page 188).8 Variadic\nThe Tuple class template introduced in Section 12.2.4 on page 188 is\nparameter pack in the variadic template will match a sequence of zero or more\ntemplate arguments.\nWe refer to this sequence of template arguments as an argument\nThe following example illustrates how the template parameter pack Types\nmatches to different argument packs depending on the template arguments provided\ntemplate<typename… Types>\nBecause a template parameter pack represents a list of template arguments rather\nthan a single template argument, it must be used in a context where the same\ntemplate<typename… Types>\nnew class template MyTuple that derives from Tuple, passing along its\ntemplate<typename… Types>\nThe template argument Types… is a pack expansion that produces a sequence of\ntemplate arguments, one for each argument within the argument pack substituted for\nfloat> substitutes the argument pack int, float for the template type parameter\nWhen this occurs in the pack expansion Types…, we get one template\nsyntactic expansion, where template parameter packs are replaced with exactly the\nright number of (non-pack) template parameters and pack expansions are written out\nas separate arguments, once for each of the non-pack template parameters.\nEach pack expansion has a pattern, which is the type or expression that will be\ntemplate<typename… Types>\nThe pattern for the pack expansion Types*… in the example above is Types*.\nRepeated substitution into this pattern produces a sequence of template type\nsequence of template arguments.\n• In the template parameter list of a class, function, or alias template.\n• In the parameter list of a function type.\npack expansion in the base initializer list to value-initialize each of the base classes\nThe member function template visitMixins is the most interesting in that it\neach of the mixin types, the pack expansion produces call arguments that refer to\nA pack expansion can also be used within a template parameter list to create a\nnontype or template parameter pack:\nargument list for Values<…>::Holder has a fixed length; the parameter pack Vs\nValues is a nontype template parameter pack for which each of the actual\ntemplate arguments can have a different type, as specified by the types provided for\nthe template type parameter pack Types.\nValues plays a dual role, both declaring the template parameter as a template\nparameter pack and declaring the type of that template parameter pack as a pack\nWhile such template parameter packs are rare in practice, the same\n12.4.3 Function Parameter Packs\nLike a template parameter pack, a function parameter pack\nname and, also like a template parameter pack, a function parameter pack must be\nTemplate parameter packs and\nUnlike template parameter packs, function parameter packs are always pack\nexpansions, so their declared types must include at least one parameter pack.\nA function parameter pack for a function template may depend on template\nparameter packs declared in that template, which allows the function template to\ntemplate<typename… Types>\nWhen calling the function template print() with some number of arguments, the\ntemplate type parameter pack Types, while the actual argument values will be\nplaced into an argument pack to be substituted for the function parameter pack\nTypes is the type of the ith value in Values and that both of these parameter packs\nare available within the body of the function template print().\ntemplate<typename T> void c_style(int, T…);\ntemplate<typename… T> void pack(int, T…);\ntreated as a function parameter pack because T is a valid expansion pattern.\nidentifier, which makes it a named function parameter pack.\nfirst argument of each parameter pack into the pattern, followed by the second\nargument of each parameter pack, and so on.\ntemplate<typename F, typename… Types>\nThe call argument pack expansion names two parameters packs, Types and\nTypes and values parameter packs produces a series of object constructions,\ntemplate<>\nThe code as written above is ill-formed, since the template parameter list is now\ntemplate<typename T, typename… Types>\nThe variadic function template g() creates a value v that is direct-initialized from\ntemplate<typename T>\n12.5.1 Friend Classes of Class Templates\nIn the context of templates, the only new facet of friend class declarations is the\nability to name a particular instance of a class template as a friend:\ntemplate<typename T>\ntemplate<typename T>\nNote that the class template must be visible at the point where one of its instances is\nmade a friend of a class or class template.\ntemplate<typename T>\nclass template instantiations to be friends:\ntemplate<typename T>\ntemplate<typename T2>\ntemplate<typename> friend class Stack;\nC++11 also added syntax to make a template parameter a friend:\ntemplate<typename T>\n12.5.2 Friend Functions of Class Templates\nAn instance of a function template can be made a friend by making sure the name of\ntemplate arguments, but if the arguments can be deduced, the angle brackets can be\ntemplate\ndeclared function or function template.\nmatching function template.\ntemplate<typename T>\nvoid multiply(T);        // function template\ntemplate\nIn our previous examples, we declared the friend functions in an ordinary class.\nsame rules apply when we declare them in class templates, but the template\ntemplate<typename T>\ntemplate<typename T>\nA friend function may also be defined within a class template, in which case it is\nto use the class template itself in the type of the friend function, which makes it\neasier to express functions on the class template that can be called as if they were\ntemplate<typename T>\ntemplate, the functions themselves are ordinary functions, not instances of a\ntemplate.\n12.5.3 Friend Templates\nUsually when declaring a friend that is an instance of a function or a class template,\nuseful to express that all instances of a template are friends of a class.\nfriend template.\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\nJust as with ordinary friend declarations, a friend template can be a definition only if\ntemplates.\nClass templates and function templates were\nMember templates may well be the\nCuriously, only member function templates\nMember class templates became part of\nFriend templates, default template arguments, and template template parameters\nThe ability to declare template\ntemplate template parameters.\ntemplate.\ntemplate proposal for C++14 (N3651).\nVariadic templates were driven by the needs of the C++11 standard library and the\nnumber of template arguments.\n1 An exception since C++14 are the implicit template type parameters for a generic\n3 Template template parameters do not denote types either; however, they are\n6 Template arguments for subsequent template parameters can still be determined\nby template argument deduction; see Chapter 15.\nVariadic templates also borrowed from C\ndown when the template parameter packs have length zero.\n11 There is a similar restriction on members of class templates and nested classes\nwithin class templates: If a member is declared with a type that does not appear to\nNames in Templates\nWell, templates are constructs that must\nthe template arguments for which the template is instantiated.\n2. A name is a dependent name if it depends in some way on a template parameter.\nT is a template parameter, but it is a nondependent name if T is a known type alias",
      "keywords": [
        "template",
        "template parameter pack",
        "Template Arguments",
        "template parameter",
        "code image template",
        "template type parameter",
        "parameter pack",
        "function template",
        "image template",
        "function parameter pack",
        "pack",
        "Template type",
        "type parameter pack",
        "type",
        "class template"
      ],
      "concepts": [
        "template",
        "types",
        "classes",
        "function",
        "functions",
        "functionality",
        "packs",
        "void",
        "value",
        "parameter"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 11,
          "title": "",
          "score": 0.969,
          "base_score": 0.819,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 51,
          "title": "",
          "score": 0.869,
          "base_score": 0.719,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 7,
          "title": "",
          "score": 0.868,
          "base_score": 0.718,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 47,
          "title": "",
          "score": 0.833,
          "base_score": 0.683,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 5,
          "title": "",
          "score": 0.827,
          "base_score": 0.677,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "pack",
          "parameter",
          "parameter pack",
          "arguments",
          "function"
        ],
        "semantic": [],
        "merged": [
          "pack",
          "parameter",
          "parameter pack",
          "arguments",
          "function"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5430701091846328,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.447845+00:00"
      }
    },
    {
      "chapter_number": 10,
      "title": "Segment 10 (pages 295-328)",
      "start_page": 295,
      "end_page": 328,
      "summary": "Template-id\nThe name of a template followed by template arguments enclosed in\nA template-id\nby template arguments enclosed in angle brackets; for example,\nA name that depends in some way on a template parameter.\ntemplate parameter is dependent.\ndependent if the type of the expression on the left of the access\noperator is type-dependent, a concept that is discussed in Section\ndependent name when it appears in a template.\nany of the argument expressions is type-dependent.\nsometimes used to describe C++ template issues, but it is not essential to remember\ntemplate<typename T>\nSuppose now that we need to apply this template to a type defined in another\nof templates in the presence of C++ namespaces.\nFor example, if the type is a pointer to a class X, then the\n• For pointer and array types, the set of associated namespaces and classes is that of\nIf the class is a class template instance, then the types of the template\ntype arguments and the classes and namespaces in which the template template\n• For function types, the sets of associated namespaces and classes comprise the\nnamespaces and classes associated with all the parameter types and those\n• For pointer-to-member-of-class-X types, the sets of associated namespaces and\nclasses include those associated with X in addition to those associated with the type\ntemplate<typename T> void f(T);\ntemplate<typename T>\nclass C {\nclass template may make visible the declaration of ordinary functions.\nan instantiation of the class C occurred earlier in the program!\nHowever, the call f(*p) does have the associated class C<int> (because this is\nfunction declaration could be found provided the class C<int> was actually fully\nlookup for friends in associated classes actually causes the class to be instantiated (if\nclass C {\nThe member function C::f() returns the size of type C, whereas the function\nClass templates also have injected class names.\nordinary injected class names: They can be followed by template arguments (in\nwhich case they are injected class template names), but if they are not followed by\ntemplate arguments they represent the class with its parameters as its arguments (or,\ntemplate<template<typename> class TT> class X {\ntemplate<typename T> class C {\nX<C> c;     // OK: C without a template argument list denotes\nthe template C\nX<::C> d;   // OK: ::C is not the injected class name and\n//     denotes the template\nname of the template if it is not followed by a list of template arguments.\nThe injected class name for a variadic template has an additional wrinkle: If the\ninjected class name were directly formed by using the variadic template’s template\nparameters as the template arguments, the injected class name would contain\ntemplate parameter packs that have not been expanded (see Section 12.4.1 on page\ntemplate<int I, typename… T> class V {\nThe injected class name of a class or class template is effectively an alias for the type\ntemplate or a nested class within a class template, each template instantiation\nbecause it means that the injected class name refers to the same instantiation of the\nclass template rather than some other specialization of that class template (the same\nholds for nested classes of class templates).\nWithin a class template, the injected class name or any type that is equivalent to\nthe injected class name (including looking through type alias declarations) of any\nenclosing class or class template is said to refer to a current instantiation.\ndepend on a template parameter (i.e., dependent types) but do not refer to a current\ninstantiated from the same class template or some entirely different class template.\ntemplate<typename T> class Node {\nIdentifying whether a type refers to a current instantiation can be confusing in the\npresence of nested classes and class templates.\nclasses and class templates (or types equivalent to them) do refer to a current\ninstantiation, while the names of other nested classes or class templates do not:\ntemplate<typename T> class C {\nWhen a type refers to a current instantiation, the contents of that instantiated class\nare guaranteed to be instantiated from the class template or nested class thereof that\ngame-like way to determine whether a type X within the definition of a class\ntemplate refers to a current instantiation or an unknown specialization: If another\nFor example, consider the instantiation of the type C<int>::J in the context of the\nabove example: We know the definition of C<T>::J used to instantiate the concrete\nspecializing all of the enclosing templates or members, C<int> will be instantiated\nType is int) within J refer to a current instantiation.\nwrite an explicit specialization for C<int>::I as follows:\ntemplate<> struct C<int>::I {\n13.3 Parsing Templates\nHowever, if x is not found to be a type,\nIf X is the name of a class template, then the previous expression casts the integer 0\nto the type X<1> generated from that template.\nIf X is not a template, then the\nangle brackets to delimit template argument lists.\ntemplate<bool B>\ntemplate<int I> struct X {\ntemplate<> struct X<0> {\ntemplate<typename T> struct Y {\ntemplate<typename T> struct G {};\nint n = a F(<::)i];       // valid in C++98/C++03, but not in\n13.3.2 Dependent Names of Types\nThe problem with names in templates is that they cannot always be sufficiently\ntemplate<typename T>\ntemplate<typename T>\ntemplate<>\nusing x = int;       // #3 x is a type here\nIn this case, Trap<T>::x is in fact type int.\non the template parameter T.\ncompiler cannot safely look inside the template to determine whether the name\ninto the template definition because it is certain that no other specialization could\nThus, when the type preceding :: refers to the current instantiation,\nspecifying that in general a dependent qualified name does not denote a type unless\ntemplate arguments, that the name is not the name of a type, the program is invalid\nand your C++ compiler should complain at instantiation time.\ntypename differs from the use to denote template type parameters.\n4. It is dependent on a template parameter.\n5. It is a member of an unknown specialization, meaning that the type named by the\ntemplate<typename1 T>\ntypename6 X<T>::C * p;  // declaration of pointer p\ntypename7 X<int>::C * s;\nThe first, typename1, indicates a template parameter.\nNames of base classes in these two contexts\ndetermining whether a type refers to a current instantiation or an unknown\n13.3.3 Dependent Names of Templates\nname of a template is dependent.\nfollowing the name of a template as the beginning of a template argument list;\nAs is the case with type names, a compiler has to\nassume that a dependent name does not refer to a template unless the programmer\ntemplate<typename T>\ntemplate<int N>\nclass In {\ntemplate<int M>\ntemplate<typename T, int N>\np->template Deep<N>::f(); // inhibit virtual call\np.template Deep<N>::f(); // inhibit virtual call\nname (::, ->, and .) may need to be followed by the keyword template.\nthe qualifying operator is dependent on a template parameter and refers to an\nunknown specialization, and the name that follows the operator is a template-id (in\nother words, a template name followed by template arguments in angle brackets).\np.template Deep<N>::f()\nthe type of p depends on the template parameter T.\nUsing declarations can bring in names from two places: namespaces and classes.\nnamespace templates.\nUsing declarations that bring in names from classes, on the\nbase declaration, thereby allowing the members of the derived class to access the\nThe previous using declaration brings in the name f of the base class BX into the\na name from a dependent class.\nwhether it’s the name of a type, a template, or something else:\ntemplate<typename T>\ntemplate<typename U>\ntemplate<typename T>\ndependent names as templates.\ntemplate<typename T>\ntemplate\nC++11 alias templates do provide a partial workaround:\ntemplate<typename T>\ntemplate<typename U>\ntemplate\ntemplates.\n13.3.5 ADL and Explicit Template Arguments\nclass X {\ntemplate<int I> void select(X*);\nIn this example, we may expect that the template select() is found through ADL\ntemplate argument list.\nFurthermore, a compiler cannot decide that <3> is a template\nargument list until it has found select() to be a template.\nThis example may give the impression that ADL is disabled for template-ids, but\nThe code can be fixed by introducing a function template named select\ntemplate<typename T> void select();\nof this function template ensures that select<3> will be parsed as a template-id.\nADL will then find the function template N::select, and the call will succeed.\nLike names, expressions themselves can be dependent on template parameters.\nexpression that depends on a template parameter can behave differently from one\ntemplate parameter, in contrast, provide the same behavior in all instantiations.\nAn expression can be dependent on a template parameter in several different\nThe most common form of dependent expression is a type-dependent\nthe next—for example, an expression that refers to a function parameter whose type\nis that of a template parameter:\ntemplate<typename T> void typeDependent1(T x)\nx;       // the expression type-dependent, because the type of\nthemselves—for example, calling a function f() with the argument x:\ntemplate<typename T> void typeDependent2(T x)\nf(x);    // the expression is type-dependent, because x is\ntype-dependent\nHere, note that type of f(x) can vary from one instantiation to the next both\nbecause f might resolve to a template whose result type depends on the argument\nNot all expressions that involve template parameters are type-dependent.\nexample, an expression that involves template parameters can produce different\ntemplate parameter of nondependent type.\ntemplate<int N> void valueDependent1()\nN;      // the expression is value-dependent but not type-\nLike type-dependent expressions, an expression is generally value-dependent if it is\nthey can turn a type-dependent operand into a value-dependent expression that is not\ntype-dependent.\ntemplate<typename T> void valueDependent2(T x)\nsizeof(x);  // the expression is value-dependent but not type-\nwill vary from one instantiation to the next, so sizeof(x) is a value-dependent\ntemplate<typename T> void maybeDependent(T const& x)\ntemplate, despite the innermost expression (x) being type-dependent.\nexpression that involves a template parameter is an instantiation-dependent\nincomplete class type will trigger an error, because sizeof cannot be applied to\nType-, value-, and instantiation-dependence can be thought of as a series of\nAny type-dependent\nvalue varies from one instantiation to the next depends on a template parameter in\nsome way, so both type-dependent expressions and value-dependent expressions are\nAs one proceeds from the innermost context (type-dependent expressions) to the\ntemplate is parsed and therefore cannot vary from one instantiation to the next.\nexample, consider the call f(x): If x is type-dependent, then f is a dependent name\nvalue-dependent but not type-dependent, f is a nondependent name for which name\nlookup can be completely determined at the time that the template is parsed.\ntemplate is parsed when all of the instantiations of the template would produce that\ntemplate<int x> void nondependentCall()\ncompiler can produce an error when parsing the template or may wait until the first\ntemplate instantiation: Commonly used compilers differ even on this simple\ntemplate<int N> void instantiationDependentBound()\n13.4 Inheritance and Class Templates\nClass templates can inherit or be inherited from.\nthere is one important subtlety when deriving a class template from a base class\nIn a class template, a nondependent base class is one with a complete type that can\ntemplate<typename X>\nclass D1: public Base<Base<void>> {   //not a template case\ntemplate<typename T>\nT strange;        // T is Base<double>::T, not the template\nname is looked up in the templated derivation, the nondependent bases are\nexample, the member strange of the class template D2 always has the type T\nfollowing function is not valid C++ (assuming the previous declarations):\n13.4.2 Dependent Base Classes\ntemplate parameter.\nnames in those base classes as soon as the template definition is seen.\nnames until the template is instantiated.\ntemplate<typename T>\nclass DD : public Base<T> {      //dependent base\ntemplate<>  // explicit specialization\nSuppose we look it up in the template Base and bind it to the\nlooked up in dependent base classes14 (but they are still looked up as soon as they\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\nqualification works) or multiple base classes may declare the same name (in which\nNote that the name one in the call one(e) is dependent on the template\nImplicitly used default arguments with a type that depends on a template\nbring a name from a dependent base class in the derived class once and for all:\ntemplate<typename T>\nclass has any dependent bases, then the qualified name refers to a member of an\nusing Type = int;\ntemplate<typename T>\ntemplate<typename T>\nThe first compiler really to parse template definitions was developed by a company\nmost compilers treated templates as a sequence of tokens to be played back through\ntemplate diagnostics were not always delayed until instantiation time undoubtedly\nThe name lookup rule for nondependent names and dependent base classes that is\nthen large amounts of code derived class templates from dependent bases.\nclasses as follows: When a nondependent name used in the scope of a class template\nnamed template parameter (Section 13.4.1 on page 236) is an oversight, but\nIt is best to avoid code with template parameter names\nlookup model for templates and their instantiations (Chapter 14).\n13 The terms type-dependent expression and value-dependent expression are used in\nthe C++ standard to describe the semantics of templates, and they have an effect\non several aspects of template instantiation (Chapter 14).\nterm instantiation-dependent expression is mainly only used by the authors of C++\n15 However, the lookup is nonetheless repeated when the template is instantiated, and\nspecialize class templates would require nontrivial adaptation.\nTemplate instantiation is the process that generates types, functions, and variables\nfrom generic template definitions.1 The concept of instantiation of C++ templates is\nThe location of the template, the\ntemplate use.\npopular C++ compilers to handle template instantiation.\nWhen a C++ compiler encounters the use of a template specialization, it will create\nthat specialization by substituting the required arguments for the template\ncode (or from the template definition, for that matter).\nfeature sets C++ templates apart from similar facilities in other early compiled\ndefinition (in other words, not just the declaration) of the template and some of its",
      "keywords": [
        "template",
        "code image template",
        "class template",
        "type",
        "view code image",
        "image template",
        "template parameter",
        "base class",
        "base",
        "view code",
        "code image",
        "int",
        "instantiation",
        "template arguments",
        "typename"
      ],
      "concepts": [
        "template",
        "type",
        "instantiating",
        "instantiation",
        "instantiations",
        "instantiate",
        "tokenization",
        "void",
        "dependent",
        "depends"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 16,
          "title": "",
          "score": 0.912,
          "base_score": 0.762,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 17,
          "title": "",
          "score": 0.864,
          "base_score": 0.714,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 19,
          "title": "",
          "score": 0.858,
          "base_score": 0.708,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 20,
          "title": "",
          "score": 0.807,
          "base_score": 0.657,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 30,
          "title": "",
          "score": 0.802,
          "base_score": 0.652,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "dependent",
          "class",
          "type",
          "type dependent",
          "instantiation"
        ],
        "semantic": [],
        "merged": [
          "dependent",
          "class",
          "type",
          "type dependent",
          "instantiation"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5438023319565871,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.447954+00:00"
      }
    },
    {
      "chapter_number": 11,
      "title": "Segment 11 (pages 329-363)",
      "start_page": 329,
      "end_page": 363,
      "summary": "template<typename T> class C;  // #1 declaration only\ntemplate<typename T>\n};                             // #4 class template definition\nvoid g (C<int>& c)             // #5 use class template\nc.f();                      // #6 use class template\ntemplate<typename T>\nvoid C<T>::f()                 //required definition due to #6\nAt point #1 in the source code, only the declaration of the template is available, not\nthe case with ordinary classes, we do not need the definition of a class template to be\nexample, the type of the parameter of function g() does not require the full\ndefinition of the template C.\nthe entire class template definition is required to be visible.\npoint #6 in the source code, the class template definition must be seen; otherwise, the\nat point #6 requires C<int>::f() to exist.\nHere is another expression that needs the instantiation of the previous class\ntemplate because the size of C<void> is needed:\nIn this case, instantiation is needed so that the compiler can determine the size of\nYou might observe that for this particular template, the type of the\ninstantiation by analyzing the template definition (and all compilers do perform the\nFurthermore, instantiation is also needed in this example to\nThe need to access a member of a class template is not always very explicitly\ntemplate<typename T>\nHowever, the declaration at point #1 could also be instantiated to check whether it is\nNote also that the instantiation of C<double>\nFor the template case, the compiler\nwill generate this complete definition from the class template definition.\nA pertinent question now arises: How much of the template is instantiated?\ncompiler should be “lazy” when instantiating templates.\ndefinition of a class or function template.\ntemplate<typename T> T f (T p) { return 2*p; }\ncomplete instantiation of the function template f().\nSimilarly, if an instance of a class template is referred to without the need for that\ninstantiation of that class template instance.\ntemplate<typename T> class Q {\nHere, the full instantiation of Q<int> would trigger an error, because T::Type\ninstantiated\nA full instantiation of v<int> would elicit an error, but that is not needed if we\nonly need the type of the variable template instance.\nThat is, instantiation is full\nWhen a class template is implicitly (fully) instantiated, each declaration of its\nmembers is instantiated as well, but the corresponding definitions are not (i.e., the\nclass template contains an anonymous union, the members of that union’s definition\nare also instantiated.3 The other exception occurs with virtual member functions.\nTheir definitions may or may not be instantiated as a result of instantiating a class\ntemplate.\nMany implementations will, in fact, instantiate the definition because the\nDefault function call arguments are considered separately when instantiating\ntemplates.\nSpecifically, they are not instantiated unless there is a call to that function\nthen the default arguments are not instantiated.\ninstantiated unless they are needed.\ntemplate<typename T>\ntemplate<int N>\ntemplate<typename T, int N>\ninstantiated with N<=0\ninstantiated with N<=0\nA standard C++ compiler will examine these template definitions to check the syntax\nnot a problem, as long as N is an unsubstituted template parameter.\ndefinition of the member function error() is an error even when the template is\nnot instantiated, because the use of Danger<-1> requires a complete definition of\nis invalid, it also allows compilers not to diagnose the error when the template\nThis causes the compiler to (fully) instantiate Tricky<int, -1> by substituting\nint for T and -1 for N in the definition of template Tricky<>.\nAs written, when instantiating a template, in practice, the definitions of virtual\ntemplate<typename T>\ntemplate<typename T>\nerror, because it declares a return type of int for operator->.\ncertain natural class template definitions trigger these kinds of definitions,5 the\ndeclaration here triggers no error, even though int is substituted for the return type.\n14.3 The C++ Instantiation Model\nTemplate instantiation is the process of obtaining a regular type, function, or variable\ntemplates.\ninstantiation:\nsecond phase (when the template is instantiated).\n2. During the second phase, while instantiating a template at a point called the point\nof instantiation (POI), dependent qualified names are looked up (with the template\nparameters replaced with the template arguments for that specific instantiation),\ntemplate<typename> void g() {}\ntemplate<typename> void f() {}\ntemplate<typename T> void h(T P) {\ndeclaration of f, which is indeed a template, and so parsing succeeds with angle\n14.3.2 Points of Instantiation\nwhere a C++ compiler must have access to the declaration or the definition of a\nA point of instantiation (POI) is created when a code construct refers\nto a template specialization in such a way that the definition of the corresponding\ntemplate needs to be instantiated to create that specialization.\ntemplate<typename T>\nWhen a C++ compiler sees the call f<Int>(42), it knows the template f will need\nFortunately, C++ defines the POI for a reference to a function template\ntemplate<typename T>\nIn this instantiation, the key issue is the lookup of function g1.\ndefinition of the template f1 is first encountered, it is noted that the unqualified\ndependent arguments (the type of the argument x depends on the template parameter\nassociated namespaces and classes, but the only argument type is int, and it has no\nThe point of instantiation for variable templates is handled similarly to that of\nfunction templates.7 For class template specializations, the situation is different, as\ntemplate<typename T>\nnamespace scope class S<int> cannot appear there (and templates can generally\nIf we were to follow the rule for function template\nWhen a template is actually instantiated, the need for additional instantiations may\ntemplate<typename T>\ntemplate<typename T>\nThe function template f() also refers to the class specialization\nbecause this is still dependent, we cannot really instantiate it at this point.\nif we instantiate f<double>() at point #2 , we notice that we also need to\ninstantiate the definition of S<double>.\nFor function templates, the secondary POI is exactly the\ntemplate instances, only the first POI in each translation unit is retained, and the\nfunction and variable templates, all POIs are retained.\ninstantiation.\nIn practice, most compilers delay the actual instantiation of most function\nincluding cases where instantiation is needed to determine a deduced return type (see\ncompilers instantiate inline functions when they’re first used to potentially inline the\nWhenever a POI is encountered, the definition of the corresponding template must\nFor class specializations this means that the class template\nclass templates) this is also needed, and typically template definitions are simply\nThis source model for template definitions is called the\ndeclarations and explicit instantiation definitions (see Section 14.5 on page 260).\nPOIs for the same specialization of a function or variable templates (or the same\nmember function or static data member of a class template instance) across different\nWhen a class template specialization is used in multiple translation units, a\ncompiler will repeat the instantiation process in every translation unit.\nHowever, if you instantiate a (noninline) function template, the situation may be\ntemplate<typename T>\ntemplate<typename T>\ns->f();   // #1 first point of instantiation of S::f\ns.f();    // #2 second point of instantiation of S::f\nIf the linker treats instantiated member functions of class templates just like it does\ninstantiation: instantiated function templates and member function templates, as well\nas instantiated static data members and instantiated variable templates.\nThe first C++ compilers that popularized greedy instantiation were produced by a\ntemplate instantiations in particular—may in fact appear in duplicate across the\n• The compiler may be wasting time on generating and optimizing N instantiations,\nof one template specialization.\ncompiler at the instantiation times.) However, this often also results in the linker\nfile (which includes the instantiated definitions).\nThe other instantiation\nmechanisms treat inline function template instances specially to ensure they can be\n1. No specialization is available: In this case, instantiation occurs, and the resulting\nSun’s compiler now uses greedy instantiation.\nThe first compiler to support C++ templates was Cfront 3.0—a direct descendant of\ninstantiations as ordinary C functions, and therefore it had to avoid duplicate\ninstantiations.\n1. Compile the sources without instantiating any required linkable specializations.\ncompiler on sources that contain the needed template definitions, with options to\ninstantiated.\nabout a typo in a template definition.\nfew C++ compilers use iterated instantiation anymore.\n14.5 Explicit Instantiation\nIt is possible to create explicitly a point of instantiation for a template specialization.\nspecialization to be instantiated.\ntemplate<typename T>\ntemplate void f<int>(int);\ntemplate void f<>(float);\ntemplate void f(long);\ntemplate void f(char);\nTemplate arguments can be deduced\nMembers of class templates can also be explicitly instantiated in this way:\ntemplate<typename T>\ntemplate void S<int>::f();\ntemplate class S<void>;\nFurthermore, all the members of a class template specialization can be explicitly\ninstantiated by explicitly instantiating the class template specialization.\nthese explicit instantiation directives ensure that a definition of the named template\nspecialization (or member thereof) is created, the explicit instantiation directives\nabove are more accurately referred to as explicit instantiation definitions.\nA template\nMany C++ programmers have observed that automatic template instantiation has a\ntemplate specializations may be instantiated and optimized in many different\ninhibition is to not provide the template definition except in the translation unit\nwhere it is explicitly instantiated.17 For example:\ntemplate<typename T> void f(); // no definition: prevents\ninstantiation\ntemplate<typename T> void f()\ntemplate void f<int>();        // manual instantiation\nIn the first translation unit, the compiler cannot see the definition of the function\ntemplate f, so it will not (cannot) produce an instantiation of f<int>.\ntranslation unit provides the definition of f<int> via an explicit instantiation\navoided, as is the overhead of repeatedly instantiating the same templates with the\nMoreover, the source code of template\ndefinition can be kept hidden, but then no additional instantiations can be created by\ntemplate definition into a third source file, conventionally with the extension .tpp.\ntemplate<typename T> void f(); // no definition: prevents\ninstantiation\ntemplate<typename T> void f()  //definition\ntemplate void f<int>();        // manual instantiation\ndeclaration of f, with no automatic instantiation.\nExplicit instantiations can be\n14.5.2 Explicit Instantiation Declarations\nAn explicit instantiation declaration\ngenerally suppresses automatic instantiation of the named template specialization,\nbecause it declares that the named template specialization will be defined somewhere\nin the program (by an explicit instantiation definition).\ndeduced return types can still be instantiated to determine their types.\n• Variables of reference types can still be instantiated so the entity they reference can\n• Class templates and alias templates can still be instantiated to check the resulting\nUsing explicit instantiation declarations, we can provide the template definition for f\ntemplate<typename T> void f()\nextern template void f<int>();    // declared but not defined\nextern template void f<float>();  // declared but not defined\ntemplate void f<int>();           // definition\ntemplate void f<float>();         // definition\ninstantiation definition, which must follow the explicit instantiation declaration.\nExplicit instantiation declarations can be used to improve compile or link times\ninstantiation definitions each time a new specialization is required, explicit\ninstantiation declarations can be introduced as an optimization at any point.\noccur18 and because the template definitions are still parsed as part of the header.\nturns out to be remarkably useful when writing templates: compile-time if.\ntemplate<typename T> bool f(T p) {\ninterest is that during the instantiation of templates (including generic lambdas), the\nWe are instantiating f(T) with T = int, which means that the else branch is\ntemplate<bool b> struct Dispatch {  //only to be instantiated\ntemplate<typename T> bool f(T p) {\nHowever, it requires implementations to refine the unit of instantiation:\nWhereas previously function definitions were always instantiated as a whole, now it\nThe C++ standard library includes a number of templates that are only commonly\ntemplate is most commonly used with char (because std::string is a type alias\ninstantiate it with other character-like types.\nlibrary implementations to introduce explicit instantiation declarations for these\nextern template class basic_string<char>;\ncorresponding explicit instantiation definitions, so that these common\nThis chapter deals with two related but different issues: the C++ template\ncompilation model and various C++ template instantiation mechanisms.\nThe compilation model determines the meaning of a template at various stages of\nin a template mean when it is instantiated.\ntemplate compilation, which allowed a template definition to be written in a different\neffort determined that (1) implementing the separation model of C++ templates was\ntemplates.\ninstantiation mechanisms differ from one implementation to the next (and each has\nIn this book, however, it always refers to template instantiation.\n5 Typical examples are smart pointer templates (e.g., the standard\nspecializations are good candidates for explicit instantiation declarations.\nTemplate Argument Deduction\nExplicitly specifying template arguments on every call to a function template (e.g.,\nFortunately, a C++ compiler can often automatically determine the intended template\narguments using a powerful process called template argument deduction.\nIn this chapter we explain the details of the template argument deduction process.\nwith the corresponding parameterized type of a function template and attempts to\ntemplate<typename T>\nmax() template is tentatively deduced to be int.\nIf all the deduced template parameters are consistently determined, the deduction\ntemplate< typename T>\nvoid f (int* p)\ntemplate<typename T> void f(T);  // parameterized type P is\ntemplate<typename T> void g(T&); // parameterized type P is\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename\nreference, array, and function declarators; pointer-to-member declarators; template-\nto deduce a template parameter T.\ntemplate<int N>\nvoid f(int) {\ntemplate<int N>\nIn the function template fppm(), the subconstruct X<N>::I is a nondeduced\ntemplate<typename T>\nThe problem with the second call to the function template f() is that the two\ndefault constructor of the class template X.)\ntemplate.\nIn this case, P is the parameterized type of the function template declaration, and A is\ntemplate<typename T>\n• Matching an explicit specialization to a function template\n• Matching an explicit instantiation to a template\n• Matching a friend function template specialization to a template\nSome of these topics, along with the use of template argument deduction for class\nAnother special situation occurs with conversion function templates.\ntemplate<typename T> operator T&();\nvoid f(int (&)[20]);\ntemplate<typename T> void f(T p);\ntemplate<typename T> void f(std::initializer_list<T>);",
      "keywords": [
        "template",
        "code image template",
        "instantiation",
        "int",
        "class template",
        "function template",
        "class template definition",
        "template definition",
        "view code image",
        "image template",
        "explicit instantiation",
        "type",
        "function",
        "template instantiation",
        "template void"
      ],
      "concepts": [
        "template",
        "instantiation",
        "instantiated",
        "instantiate",
        "instantiations",
        "type",
        "classes",
        "function",
        "functions",
        "void"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 9,
          "title": "",
          "score": 0.969,
          "base_score": 0.819,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 51,
          "title": "",
          "score": 0.91,
          "base_score": 0.76,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 7,
          "title": "",
          "score": 0.896,
          "base_score": 0.746,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 47,
          "title": "",
          "score": 0.827,
          "base_score": 0.677,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 5,
          "title": "",
          "score": 0.796,
          "base_score": 0.646,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "instantiation",
          "definition",
          "instantiated",
          "explicit instantiation",
          "function"
        ],
        "semantic": [],
        "merged": [
          "instantiation",
          "definition",
          "instantiated",
          "explicit instantiation",
          "function"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5295154774061588,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.448041+00:00"
      }
    },
    {
      "chapter_number": 12,
      "title": "Segment 12 (pages 364-393)",
      "start_page": 364,
      "end_page": 393,
      "summary": "have the same type.\nvalues of template arguments.\nWhen performing template argument deduction for\nvariadic templates, however, the 1:1 relationship between parameters and arguments\nmatching produces additional values for any template parameter packs in P:\nfirst value in the template parameter pack Rest is deduced to double.\nwhen compared against the second such A (the type int*), the second value in the\ntemplate parameter pack Rest is deduced to int*.\nparameter yields the function type void(int, double, int*), which\nmatches the argument types at the call site.\nargument types.\nfor deduction against each argument type.\nspecializations of class template pair, the template arguments are compared.\nh1(), the first template argument (T) is not a parameter pack, so its value is\nFor the second pair template argument in both h1()\ndetermines successive values for the template parameter packs from each of the\nargument types in A.\ntemplate argument list.3 For example, consider two similar operations on a simple\ntemplate<typename… Types> class Tuple { };\ntemplate<typename… Types>\ntemplate<typename… Types1, typename… Types2>\nf1(sv, sv); // OK: Types is deduced to {short, int, long}\nf2(sv, sv); // OK: Types1 is deduced to {short, int, long},\n//     Types2 is deduced to {short, int, long}\nf1(sv, uv); // ERROR: Types is deduced to {short, int, long}\nf2(sv, uv); // OK: Types1 is deduced to {short, int, long},\nIn both f1() and f2(), the template parameter packs are deduced by comparing\nh1()) against each of the template arguments of the Tuple type provided by the\ncall argument, deducing successive values for the corresponding template parameter\nThe function f1() uses the same template parameter pack Types in both\ncall arguments have the same Tuple specialization as their type.\nf2(), on the other hand, uses different parameter packs for the Tuple types in\neach of its function parameters, so the types of the function call arguments can be\ntemplate<char…> int operator \"\" _B7(); // #1\nHowever, when composing types through the substitution of template parameters,\nHere volatile is applied on top of the reference type RCI (an alias for int\n“take precedence” in the reference collapsing rule, the overall type remains int\nAs introduced in Section 6.1 on page 91, template argument deduction behaves in a\nspecial way when a function parameter is a forwarding reference (an rvalue\nreference to a template parameter of that function template).\nargument deduction considers not just the type of the function call argument but also\nan lvalue, the type determined by template argument deduction is an lvalue reference\nto the argument type, and the reference collapsing rules (see above) ensure that the\nOtherwise, the type deduced for\nthe template parameter is simply the argument type (not a reference type), and the\nsubstituted parameter is an rvalue reference to that type.\ntemplate<typename T> void f(T&& p); // p is a forwarding\nf(i);  // argument is an lvalue; deduces Tto int&and\n// parameter phas type int&\nf(j);  // argument is an lvalue; deduces Tto int const&\n// parameter phas type int const&\nf(2);  // argument is an rvalue; deduces Tto int\n// parameter phas type int&&\nIn the call f(i) the template parameter T is deduced to int&, since the expression\ni is an lvalue of type int.\nSubstituting int& for T into the parameter type T&&\nresulting parameter type is int&, which is perfectly suited to accept an lvalue of\ntype int.\nIn contrast, in the call f(2), the argument 2 is an rvalue and the template\nparameter is therefore deduced to simply be the type of that rvalue (i.e., int).\nint&& (again, a parameter suited for its argument).\ntemplate<typename T> void f(T&&) // p is a forwarding reference\nuses the type T, or the function template itself won’t work properly with lvalue\ntemplate<typename T> void f(T&&)        // p is a forwarding\ncollapsing rules makes it possible to write a function template with a parameter that\nThe function template can then “forward” the\nexpression x will be an lvalue of the type that the reference refers to.6 The\nThe type T&&\nargument was an rvalue), so the result of the static_cast has the same type and\nfunction template std::forward<>() in header <utility> that should be\ntemplate<typename T> void forwardToG(T&& x)\nPerfect forwarding combines well with variadic templates, allowing a function\ntemplate to accept any number of function call arguments and forward each of them\nvalues for the parameter pack Ts (see Section 15.5 on page 275), so that the types\ntemplate<typename T> void forwardToG(T&& x)\narguments while maintaining their precise type and whether it is an lvalue or rvalue.\nfunction, with precisely the same type and value category, a generalization of lvalues\nthe function name and the -> to indicate the return type) so that the function\nThe use of decltype(auto) as a return type indicates that the compiler should\ndeduce the return type from the definition of the function.\ntemplates typically generalize the types in the function signature without affecting\ntype int\nany type\ntype int\napplies when the function parameter is written specifically with the form template-\nparameter &&, is part of a function template, and the named template parameter is\ndeclared by that function template.\nnot a function template\nstd::enable_if<!std::is_lvalue_reference<T>::value>::type\non page 129, is an important aspect of template argument deduction that prevents\nFor example, consider a pair of function templates that extracts the beginning\nattempts template argument deduction for both begin() function templates:\n• Template argument deduction for the array begin() fails, because a\n• Template argument deduction for the container begin() succeeds with\nContainer deduced to std::vector<int>, so that the function template is\nDuring the substitution of template arguments, SFINAE turns such errors into\ndeduction failures, and the function template is removed from consideration.\nbegin() function template is called.\nimmediate context of the function template substitution.\ncontext of a function template substitution is more easily done by defining what is\nnot in that context.8 Specifically, during function template substitution for the\nis not part of the immediate context of that function template substitution.\nSo if substituting the template parameters of a function template declaration\ncontext of the function template substitution and is therefore a real error (even if\nanother function template matches without error).\nfunction template\nfunction template begin().\nof Array<int&>, which—although it was triggered from the function template’s\nHere is a C++14 example—relying on deduced return types (see Section 15.10.1\non page 296)— that involves an error during the instantiation of a function template\ntemplate<typename T> auto f(T p) {\ntemplate<typename T> auto g(T p) -> decltype(f(p));\nint) and therefore to determine the return type of f().\ntype.\nmatches with function template overloading, as with the container begin()\nTemplate argument deduction is a powerful feature, eliminating the need to\nexplicitly specify template arguments in most calls to function templates and\nenabling both function template overloading (see Section 1.5 on page 15) and partial\nNormally, template deduction attempts to find a substitution of the function template\ntemplate parameter in a deduced context:\n• Unless deduction occurs for a conversion operator template, the substituted P type\ntemplate<typename T> void f(B<T>*);\nIf P does not contain a template parameter in a deduced context, then all implicit\ntemplate<typename T> int f(T, typename T::X);\nFor example, consider the following call to the max() function template shown in\nHere, template argument deduction from the first argument deduces T to\nchar[6], so template argument deduction fails, because both parameters use the\nsame template parameter.\n15.8.2 Class Template Arguments\nPrior to C++17, template argument deduction applied exclusively to function and\nmember function templates.\nIn particular, the arguments for a class template were\nS x(12);// ERROR before C++17: the class template parameter T\nDefault function call arguments can be specified in function templates just as they\ntemplate parameter.\ntemplate arguments.\nThis means that they do not participate in template argument deduction.\ntemplate would trigger a template argument deduction failure (SFINAE), allowing\nexception spec-ifications do not participate in template argument deduction, overload\ntypes:\n15.9 Explicit Function Template Arguments\nWhen a function template argument cannot be deduced, it may be possible to\nexplicitly specify it following the function template name.\nThis may be done also for template parameters that are deducible:\nOnce a template argument is explicitly specified, its corresponding parameter is no\nIt is possible to explicitly specify some template arguments while having others be\nwith the template parameters.\nauto x = convert<double>(42);  // the type of parameter p is\nIt is occasionally useful to specify an empty template argument list to ensure the\nselected function is a template instance while still using deduction to determine the\ntemplate arguments:\ntemplate<typename T> T f(T);   // #2\nf<>(42) the presence of a template argument list rules out the nontemplate\nfunction (even though no actual template arguments are specified).\nIn the context of friend function declarations, the presence of an explicit template\ntemplate<typename> void f();\nfriend int f<>();        // ERROR: return type conflict\ndeclaration above will find the global function template f(), but the compiler will\nExplicitly specified template arguments are substituted using SFINAE principles:\ntemplate<typename T> T f();//                          #2\nauto x = f<int*>();\nsubstitution exactly one candidate remains, then the name of the function template\nwith the explicit template arguments behaves pretty much like an ordinary function\nauto x = f<int*>;      // OK: x is a pointer to function\ntemplate<typename T> void f(T);\ntemplate<typename T> void f(T, T);\nauto x = f<int*>;        // ERROR: there are two possible\nVariadic function templates can be used with explicit template arguments also:\ntemplate<typename … Ts> void f(Ts … ps);\ntemplate<typename … Ts> void f(Ts … ps);\nf<double, int>(1, 2, 3);  // OK: the template arguments are\nC++11 includes the ability to declare a variable whose type is deduced from its\n15.10.1 The auto Type Specifier\nDeduction for auto uses the same mechanism as template argument deduction.\ntype specifier auto is replaced by an invented template type parameter T, then\nwhere T is the type to be deduced for auto.\nthis is that a variable of type auto will never be a reference type.\ndeduced type.\nIts deduction is equivalent to the following function template and call:\nis based on a function template:\ntemplate<typename t> void f(T&& fr);// auto replaced by template\ntemplate<typename Container> void g(Container c) {\nIt cannot be nested in a template argument or part of the\nauto const S::*pm = &X<int>::m;     // OK: pm has type int const\nX<auto> xa = X<int>();              // ERROR: auto in template\nDeduced Return Types\nC++14 added another situation where a deducible auto placeholder type can\nappear: function return types.\ndefines a function with return type int (the type of 42).\nauto is the placeholder type to deduce.\nexplicitly, the lambda’s return type is deduced as if it were auto:9\nauto lm = [] (int x) { return f(x); };\n// same as: [] (int x) -> auto { return f(x); };\nfunctions whose return type is deduced also:\ntype.\nMostly, the ability to forward declare a function with a deduced return type is only\nPrior to C++17, nontype template arguments had to be declared with a specific type.\nHowever, that type could be a template parameter type.\nIn this example, having to specify the type of the nontype template argument—that\nability to declare nontype template parameters whose actual types are deduced from\nthe corresponding template argument.\ntemplate<auto V> struct S;\nHere the type of V for S<42> is deduced to be int because 42 has type int.\nNote that the general constraints on the type of nontype template parameters\nA template definition with that kind of deducible nontype parameter often also needs\ntemplate<auto V> struct Value {\nauto nontype template parameters are also useful to parameterize templates on\nusing Type = C;\nmember type its “parent” class type, using class template partial specialization10\nWith an auto template parameter, we only\nhave to specify the pointer-to-member constant &S::i as a template argument.\nHowever, the template argument list cannot be empty in that particular case.\nSee Section 3.4 on page 50 for a complete example using auto as template\nparameter type.",
      "keywords": [
        "code image template",
        "template",
        "view code image",
        "type",
        "template argument deduction",
        "function template",
        "template argument",
        "image template",
        "int",
        "view code",
        "code image",
        "template parameter",
        "function",
        "type int",
        "argument"
      ],
      "concepts": [
        "type",
        "template",
        "function",
        "functions",
        "click",
        "deduction",
        "deductions",
        "parameter",
        "error",
        "argument"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 15,
          "title": "",
          "score": 0.948,
          "base_score": 0.798,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 1,
          "title": "",
          "score": 0.859,
          "base_score": 0.709,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 2,
          "title": "",
          "score": 0.795,
          "base_score": 0.645,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 31,
          "title": "",
          "score": 0.744,
          "base_score": 0.594,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 14,
          "title": "",
          "score": 0.733,
          "base_score": 0.733,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "function",
          "type",
          "argument",
          "function template",
          "parameter"
        ],
        "semantic": [],
        "merged": [
          "function",
          "type",
          "argument",
          "function template",
          "parameter"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.522533964506394,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.448128+00:00"
      }
    },
    {
      "chapter_number": 13,
      "title": "Segment 13 (pages 394-424)",
      "start_page": 394,
      "end_page": 424,
      "summary": "decltype(s)    //declared type of entity e designated by s\nwhich means that decltype produces the declared type of s, std::string&&.\nthat case, the type will reflect the value category of (s):\nThe fact that decltype computes the type of an arbitrary expression e can be\ninformation about an expression to make it possible to describe the return type of a\nfunction that returns the expression e itself “perfectly”: decltype computes the type\nThe return type of g() depends on the return type of f().\nint&, the computation of g()’s return type would first determine that the\nexpression f() has type int.\nlvalue reference, so the declared return type of g() becomes int&.\nreturn type of f() were an rvalue reference type, the call f() would be an xvalue,\nand decltype would produce an rvalue reference type that exactly matches the\ntype returned by f().\ndecltype can also be useful when the value-producing auto deduction is not\nC++14 introduces the decltype(auto) construct to address\nC++14 adds a feature that is a combination of auto and decltype:\nLike the auto type specifier, it is a placeholder type, and the\ntype of a variable, return type, or template argument is determined from the type of\nthe associated expression (initializer, return value, or template argument).\nunlike just auto, which uses the rules for template argument deduction to determine\nint i = 42;               // i has type int\nint const& ref = i;       // ref has type int const& and refers\nauto x = ref;            // x1 has type int and is a new\ndecltype(auto) y = ref;  // y has type int const& and also\nThe type of y is obtained by applying decltype to the initializer expression, here\nIn contrast, the rules for auto type deduction\nproduce type int.\nauto x = v[0];            // x denotes a new object of type int\ndecltype(auto) y = v[0]; // y is a reference (type int&)\ntemplate<typename C> class Adapt\ntype, which is exactly what decltype(auto) resolves to.\ndecltype(auto) will produce an object type (not a reference type) for that case.\ndecltype(auto) z = x;      // object of type int\ndecltype(auto) r = (x);    // reference of type int&\ndecltype(auto) f() {\nSince C++17, decltype(auto) can also be used for deducible nontype\ntemplate<decltype(auto) Val> class S\nthe type of c itself (i.e., int).\nbecome a reference type int&, which can bind to the global variable v of type int.\nThus, with this declaration the class template depends on a reference to v, and any\nerror, because decltype(v) is int, and therefore a constant argument of type\ntemplates:\ntemplate<auto N> struct S {};\ntemplate<auto N> int f(S<N> p);\nIn this example, the type of the parameter N of function template f<>() is deduced\nfrom the type of the nontype parameter of S.\nform X<…> where X is a class template is a deduced context.\ntemplate<auto V> int f(decltype(V) p);\nint r2 = deduce(42);      // ERROR: decltype(V) is a nondeduced\nthat matches the argument 42 (e.g., decltype(7) produces the same type as\ndeduction for a function call would fail, because we cannot deduce a template type\nstd::initializer_list<int>\nstd::initializer_list<int>\nBefore C++17, the corresponding direct-initialization of auto variables (i.e.,\nauto val { 2 };          // OK: val has type int in C++17\nof type initializer_list<int>.\nInterestingly, returning a braced initializer list for a function with a deducible\nwords, there is an invented template type parameter T1 for first and another\ninvented template type parameter T2 for last.\nand the deductions for T1 and T2 are the same type, are the declarations well-\nauto e = c, f = c+1;    // ERROR: deduction mismatch char vs.\ndeclarations of cp and d deduce the same type char for auto, so this is valid code.\nThe declarations of e and f, however, deduce char and int due to the promotion\ndeduced return types.\nreturn 42.0;      // deduces return type double\nIn this case, each return statement is deduced independently, but if different types are\ndeduction already determined the return type.\nauto f(int n)\nreturn n*f(n-1);    // ERROR: type of f(n-1) unknown\nauto f(int n)\nreturn 1;           // return type is deduced to be int\nreturn n*f(n-1);    // OK: type of f(n-1) is int and so is\ntype of n*f(n-1)\nDeduced return types have another special case with no counterpart in deduced\nvariable types or deduced nontype parameter types:\nauto f1() { }          // OK: return type is void\nauto f2() { return; }  // OK: return type is void\nBoth f1() and f2() are valid and have a void return type.\nauto* f3() {}      //ERROR: auto* cannot deduce as void\nAs you’d expect, any use of a function template with a deduced return type requires\nthe immediate instantiation of that template to determine the return type with\ntemplate must be fully instantiated to determine its return type.\nIt is therefore important to remember that deduced return types are not merely\na shorthand for a complex explicit return type and they should be used with care (i.e.,\nThe call to g() produces a value (in this case a simple class aggregate of type\nSyntactically, a structured binding must always have an auto type optionally\n1. The first case is the simple class type, where all the nonstatic data members are\nauto f() -> int(&)[2];  // f() returns reference to int array\nauto [ x, y ] = f();    // #1\nbe a variable of array type corresponding to the type of the initializer.\nLet E be the type\nBecause E is the type of an\nexpression, it is never a reference type.\nstd::tuple_element<i, E>::type& ni = e.get<i>();\nif e was deduced to have a reference type, or\nstd::tuple_element<i, E>::type&& ni = e.get<i>();\nstd::tuple_element<i, E>::type& ni = get<i>(e);\nstd::tuple_element<i, E>::type&& ni = get<i>(e);\nstd::tuple_element, and a function template or member function template\ntype.\ntemplate<> class std::tuple_size<M> {\ntemplate<> class std::tuple_element<0, M> {\nusing type = int;                 // the first value will\nhave type int\ntemplate<> class std::tuple_element<1, M> {\nusing type = double;              // the second value will\nhave type double\ntemplate<int> auto get(M);\ntemplate<> auto get<0>(M) { return 42; }\ntemplate<> auto get<1>(M) { return 7.0; }\nfirst two cases using simple class types and arrays).\nstd::iterator_traits<Iter>::value_type\nparameter type.\nmore of the parameter types use auto to deduce the type rather than writing it\nAn auto in a parameter of a lambda is handled similarly to an auto in the type of a\nvariable with an initializer: It is replaced by an invented template type parameter T.\nlambda itself becomes generic (if it wasn’t already), and the invented template type\nthe class is called a closure type.\nThe closure type has a function call operator, and\nhence the closure is a function object.16 For this lambda, the closure type would look\nIf you check the type category for a lambda, std::is_class<> will yield true\nA lambda expression thus results in an object of this class (the closure type).\nclosure type\nint x, y;\n[x,y](int i) {\ntype:\nint _x, _y;\nfunction, which becomes a conversion function template in the generic lambda case):\nInstead, the invoke() function template is instantiated with the closure type\nas the first parameter type and int (the type of 21) as a second and third parameter\ntype.\narguments, that alias’s definition (i.e., the type to the right of the =) is substituted\nexample, template argument deduction succeeds in the following three calls:\nIn the first call (to f1()), the use of the alias template DequeStack in the type of\nintStack has no effect on deduction: The specified type DequeStack<int> is\ntreated as its substituted type Stack<int, std::deque<int>>.\ntemplate<> using A<int> = void;  // ERROR, but suppose it were\n15.12 Class Template Argument Deduction\nC++17 introduces a new kind of deduction: Deducing the template parameters of a\nclass type from the arguments specified in an initializer of a variable declaration or a\ntemplate<typename T> S(T) -> S<T>;  // deduction guide\nS x{12};         // OK since C++17, same as: S<int> x{12};\nS y(12);         // OK since C++17, same as: S<int> y(12);\nauto z = S{12};  // OK since C++17, same as: auto z = S<int>\nreturn type.\nWe call the type it designates (S<T> in our example) as the guided\ntype.\n• There is no leading auto keyword to indicate that a trailing return type follows.\n• The “name” of a deduction guide must be the unqualified name of a class template\n• The guided type of the guide must be a template-id whose template name\nIn the declaration S x(12); the specifier S is called a placeholder class type.17\nWith the guide as written in the example, the declaration S x(12); deduces the\ntype of the variable by treating the deduction guides associated with class S as an\nT to be int and the guide’s guided type to be S<int>.18 That guided type is\ntherefore selected as the type of the declaration.\nNote that in the case of multiple declarators following a class template name\nsame type.\nThis is similar to the constraints when deducing the C++11 placeholder type auto.\naggregate class templates:\ntemplate<typename T> A(T) -> A<T>;  // deduction guide\nWithout the deduction guide, we are always required (even in C++17) to specify\nA a4 = 42;          // ERROR: can’t deduce type\nQuite often, a deduction guide is desirable for every constructor in a class template.\nThat led the designers of class template argument deduction to include an implicit\nand constructor template of the primary class template19 an implicit deduction guide\n• The template parameter list for the implicit guide consists of the template\nparameters for the class template, followed, in the constructor template case, by the\nThe template parameters of the\n• The guided type of the guide is the name of the template with arguments that are\nthe template parameters taken from the class template.\nThe template parameter list is typename T, the function-like parameter list\nbecomes just (T b), and the guided type is then S<T>.\nclass template as originally written (and no deduction guide), we can validly write S\nx(12); with the expected result that x has type S<int>.\ntemplate S and the following initializations:\nS x{12};    // x has type\nWe already saw that x has type S<int>, but what should the type of x and y be?\nThe two types that arise intuitively are S<S<int>> and S<int>.\nConsider a similar example with a vector type:\nclass template S above.\nusing Type = T;\nHowever, in C++17 they disable implicit deduction guides.\ndeduction guide construction process outlined above: The template parameter list\nand the guided type are unchanged, but the function-like parameter is now written in\ntemplate<typename> S(typename ValueArg<T>::Type) -> S<T>;\ninstance of a deducible constructor parameter of type X by something like\ntypename ValueArg<X>::Type.\ntemplate<typename T> struct X {\ntemplate<typename Iter> X(Iter b, Iter e);\ntemplate<typename Iter> auto f(Iter b, Iter e) {\nThis code is valid C++14: The X in X(b, e) is the injected class name and is\nclass template argument deduction, however, would naturally make that X equivalent\ndeduction is disabled if the name of the template is an injected class name.\nreference type if the corresponding call argument is an lvalue.\nwould normally deduce T to be a reference type std::string& and produce a\nparameter of that same type (because of the reference collapsing rule), which is a\nerrors (when the class template parameter is used in contexts that do not permit\nreference types) or, worse, silent production of misbehaving instantiations (e.g.,\nthe T was originally a class template parameter (as opposed to a constructor template\nConsider the following class template:\nThe first guide selects type\nbe of type Tuple<Tuple<int>>.\nauto e = Tuple{x};\nDeduction guides are not function templates: They are only used to deduce template\ntemplate<typename T> struct X {\ntemplate<typename T> Y(X<T>) -> Y<T>;\nGiven a value xtt of type X<TT>— lvalue or rvalue—it will select the deduced\nTemplate argument deduction for function templates was part of the original C++\nThe auto type specifier and the decltype construct were among the earliest\nauto type specifier and N2343 for decltype).\nThe ability to declare nontype template parameters with auto in C++17 was\nMike Spertus also drove the development of class template argument deduction in\n3 If a pack expansion occurs anywhere else in a function parameter list or template\nnoted that the standard pair class template would not work with reference types.\n6 Treating a parameter of rvalue reference type as an lvalue is intended as a safety\n9 Although C++14 introduced deduced return types in general, they were already\nIn C++14, that specification was updated to use the general auto\nusing Type = C; use using Type = M;.\n11 As mentioned elsewhere, treating a parameter of rvalue reference type as an\n17 Note the distinction between a placeholder type, which is auto or\ndecltype(auto) and can resolve to any kind of type, and a placeholder class\ntype, which is a template name and can only resolve to a class type that is an\n18 As with ordinary function template deduction, SFINAE could apply if, for\nexample, substituting the deduced arguments in the guided type failed.\nSuch specializations do not participate in class template argument deduction.\ntemplates.",
      "keywords": [
        "view code image",
        "code image template",
        "type",
        "view code",
        "code image",
        "template",
        "int",
        "code image auto",
        "image template",
        "auto",
        "return type",
        "template argument deduction",
        "type int",
        "code",
        "class template"
      ],
      "concepts": [
        "templates",
        "types",
        "deductions",
        "classes",
        "returns",
        "click",
        "deducible",
        "deduce",
        "std",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.769,
          "base_score": 0.619,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 79,
          "title": "",
          "score": 0.746,
          "base_score": 0.596,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 28,
          "title": "",
          "score": 0.734,
          "base_score": 0.584,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 81,
          "title": "",
          "score": 0.724,
          "base_score": 0.574,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 33,
          "title": "",
          "score": 0.664,
          "base_score": 0.514,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "type",
          "auto",
          "deduction",
          "int",
          "type int"
        ],
        "semantic": [],
        "merged": [
          "type",
          "auto",
          "deduction",
          "int",
          "type int"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.43250063537297884,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.448212+00:00"
      }
    },
    {
      "chapter_number": 14,
      "title": "Segment 14 (pages 425-455)",
      "start_page": 425,
      "end_page": 455,
      "summary": "template<typename T>\nBecause of these considerations, C++ templates provide ways to customize function\ntemplates and class templates transparently.\nFor function templates, this is achieved\nquickExchange() function templates as follows:\ntemplate<typename T>\ntemplate<typename T>\nsubstituting Array<int> for T in the first template and when substituting int in\nthe second template.\nspecialized template and hence selects the template at point #2 .\ntemplate<typename T>\n16.2 Overloading Function Templates\nIn the previous section we saw that two function templates with the same name can\ntemplate<typename T>\ntemplate<typename T>\nWhen T is substituted by int* in the first template, a function is obtained that has\nint for T in the second template.\nNot only can these templates coexist, their\nsyntax f<int*>() indicates that we want to substitute the first template parameter\nof the template f() with int* without relying on template argument deduction.\nthis case there is more than one template f(), and therefore an overload set is\ncreated containing two functions generated from templates: f<int*>(int*) (generated\nfrom the first template) and f<int*>(int**) (generated from the second template).\ngenerated from the first template, and hence that is the function that ends up being\nf<int>(int) (generated from the first template) and f<int>(int*)\nthe function (or the name of the function template from which it was generated)\n5. The types of the function parameters (before template parameters are substituted if\nthe function is generated from a function template)\n6. Its return type, if the function is generated from a function template\n7. The template parameters and the template arguments, if the function is generated\nfrom a function template\ntemplate<typename T>\ntemplate<typename T>\nf2(42) when both the templates above are declared will clearly create an\n16.2.2 Partial Ordering of Overloaded Function Templates\nHowever, a function is selected even when explicit template arguments are not\ntemplate<typename T>\ntemplate<typename T>\ntype of the parameter of the first template if we substitute T with int.\nparameter type of the second template is always a pointer and, hence, after\nsucceeds for both templates, yielding the functions f<int*>(int*) and f<int>\nspecialized template is selected.\nIn our last example, it may seem very intuitive that the second template is more\ndetermine whether one function template participating in an overload set is more\nthat given two templates, neither can be considered more specialized than the other.\ntemplates, a return type) by substituting every template parameter as follows:\nfirst template is more specialized than the second.\nargument deduction of the first template against the second synthesized list of\ntemplate is more specialized than the first.\ntemplates, we synthesize two lists of argument types by replacing the template\nmake T* of the second template match the nonpointer type A1 in the first list.\nHence, we formally conclude that the second template is more specialized than the\ntemplate<typename T>\ntemplate<typename T>\nand the last parameter of the second template is covered by its default argument,\nTemplate argument deduction of (A1*, A1 const*) versus\nby deducing template arguments for the first template from the argument type list\ntemplates, and the call is ambiguous.\ntemplates.\n16.2.4 Templates and Nontemplates\nFunction templates can be overloaded with nontemplate functions.\ntemplate<typename T>\nreturn \"Template\";\ntemplate<typename T>\nreturn \"Template\";\nstd::cout << f(x) << ’\\n’;//prints: Template\nTemplate\nNow, the function template f<>(T&) is a better match when passing a nonconstant\na template and the other is not.\nFor this reason, it’s a good idea to declare the member function template as\ntemplate<typename T>\nreturn \"Template\";\ntemplate<typename T>\nC x5{std::move(c)};  // prints: template constructor\ntemplate constructor\ntemplate constructor\nThus, the member function template is a better match for copying a C than the copy\n16.2.5 Variadic Function Templates\nVariadic function templates (see Section 12.4 on page 200) require some special\ntemplate<typename T>\nIn the first call, f(0, 0.0), each of the function templates named f is considered.\nFor the first function template, f(T*), deduction fails both because the template\nparameters for this nonvariadic function template.\nThe second function template,\nfunction template, f(Ts*…), deduction compares the pattern of the function\ninteresting: Deduction fails for the first function template because there are more\ntemplates.\nsecond template\nthird template\nby a single made-up type, class template, or value.\nsynthesized argument types for the second and third function templates are A1 and\nsecond template against the third’s list of argument types succeeds by substituting\nnonpointer type A1, so the third function template (which accepts pointer arguments)\nis considered more specialized than the second function template (which accepts any\nsucceeds for all three of the function templates, requiring partial ordering to compare\nthird function templates.\nDeduction of the first template against\npack (the first template’s parameter T *).\nHence, template deduction of the first\nspecialized than variadic templates (with a variable number of parameters).\neach of the function templates in our previous example into a variadic class template\ntemplate<typename T>\nFunction template ordering considers the pack expansions in the template arguments\nThe ability to overload function templates, combined with the partial ordering rules\nto select the “best” matching function template, allows us to add more specialized\nHowever, class templates and variable templates cannot be overloaded.\ntemplates: explicit specialization.\nClass templates, function templates, and variable\ntemplates can be fully specialized.2\nspecialization, but instead of fully substituting the template parameters, some\noverloaded templates.\n16.3.1 Full Class Template Specialization\nand >.3 In addition, the class name is followed by the template arguments for\ntemplate<typename T>\ntemplate<>\nname of the class template.\nHowever, template arguments for parameters with default template\ntemplate<typename T> class Types {\ntemplate<>\ntemplate<> class S<char, char>; // #3\ntemplate<> class S<char, 0>;    // ERROR: 0 cannot substitute U\ntemplate<>\nAs this example also shows, declarations of full specializations (and of templates) do\ndeclared, the generic definition is never used for the given set of template arguments.\nclass template specialization, it is sometimes useful to “forward declare” types so\nprevious template declaration.\nBecause it is not a template declaration, the members\nof a full class template specialization can be defined using the ordinary out-of-class\ntemplate<typename T>\ntemplate<> class S<char**> {\n// the following definition cannot be preceded by template<>\ntemplate<typename T>\ntemplate<>\n// the following definition cannot be preceded by template<>\ntemplate<typename T>\ntemplate<>\ntemplate<typename T>\ntemplate<>\nthe generic template.\nspecialization should normally follow the declaration of the template in its header\n16.3.2 Full Function Template Specialization\nThe syntax and principles behind (explicit) full function template specialization are\nmuch the same as those for full class template specialization, but overloading and\nThe full specialization declaration can omit explicit template arguments when the\ntemplate being specialized can be determined via argument deduction (using as\ntemplate<> int f(int)      // OK: specialization of #1\ntemplate<> int f(int*)    // OK: specialization of #2\nA full function template specialization cannot include default argument values.\nHowever, any default arguments that were specified for the template being\ntemplate<> int f(int, int = 35)  // ERROR\nAt the point of a call to a function template, the call is\none definition of a noninline full function template specialization should appear in a\nfollows the template to prevent attempts at using the function generated from the\ntemplate.\nThe declarations for a template g() and one full specialization would\ntemplate;\n16.3.3 Full Variable Template Specialization\nVariable templates can also be fully specialized.\nresulting from the template.\nInterestingly, a variable template specialization is not\nrequired to have a type matching that of the template being specialized:\nfunctions of class templates, can be fully specialized.\nIf a member template is\nbeing specialized, a template<> must also be added to denote that it is being\ntemplate<>\ntemplate<>\ntemplate<>\nfrom the template at point #1 .\nJust as with full function template specializations, we need a way to declare the\nspecialization of an ordinary member of a class template without specifying a\nof ordinary classes, they are fine when specializing members of class templates.\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<>\nThe member template Outer<T>::Inner can also be specialized for a given\nof Outer<T>, for which we are specializing the member template.\ntemplate<>\ntemplate<>\nThe template Outer<T>::Inner can also be fully specialized, but only for a\ntemplate:\ntemplate<>\ntemplate<>\n// template<> cannot follow a template parameter list\ntemplate<> class Outer<X>::Inner<void>;  // ERROR\nContrast this with the specialization of the member template of Outer<bool>.\nBecause the latter is already fully specialized, there is no enclosing template, and we\ntemplate<>\n16.4 Partial Class Template Specialization\nFull template specialization is often useful, but sometimes it is natural to want to\nspecialize a class template or variable template for a family of template arguments\nhave a class template implementing a linked list:\nthe latter definition is called a partial specialization (because the template arguments\nparameter list declaration (template<… >) and a set of explicitly specified\ntemplate arguments on the name of the class template (<T*> in our example).\ntemplate<>",
      "keywords": [
        "template",
        "function template",
        "code image template",
        "int",
        "function",
        "image template",
        "view code image",
        "template arguments",
        "class template",
        "Function Template Specialization",
        "Template Specialization",
        "Full Function Template",
        "typename",
        "Class Template Specialization",
        "view code"
      ],
      "concepts": [
        "template",
        "functionality",
        "functions",
        "types",
        "classes",
        "specialized",
        "special",
        "specializations",
        "specialize",
        "click"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 53,
          "title": "",
          "score": 0.781,
          "base_score": 0.781,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 10,
          "title": "",
          "score": 0.78,
          "base_score": 0.78,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 15,
          "title": "",
          "score": 0.759,
          "base_score": 0.759,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 11,
          "title": "",
          "score": 0.75,
          "base_score": 0.75,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 8,
          "title": "",
          "score": 0.738,
          "base_score": 0.738,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "function",
          "templates",
          "specialized",
          "template template",
          "template specialization"
        ],
        "semantic": [],
        "merged": [
          "function",
          "templates",
          "specialized",
          "template template",
          "template specialization"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5527404414528124,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.448296+00:00"
      }
    },
    {
      "chapter_number": 15,
      "title": "Segment 15 (pages 456-487)",
      "start_page": 456,
      "end_page": 487,
      "summary": "templates are often accused).\ntemplate) the corresponding parameters of the primary template.\ndefault arguments of the primary class template are used instead.\nvalues or plain nontype template parameters.\ndependent expressions like 2*N (where N is a template parameter).\n4. The list of template arguments of the partial specialization should not be identical\n(ignoring renaming) to the list of parameters of the primary template.\n5. If one of the template arguments is a pack expansion, it must come at the end of a\ntemplate argument list.\ntemplate<typename T, int I = 3>\nclass S;                  // primary template\ntemplate<typename T>\ntemplate<typename T = int>\ntemplate<int I>\ntemplate<typename U, int K>\nfrom primary template\ntemplate<typename… Ts>\ntemplate<typename Tail, typename… Ts>\ntemplate<typename Tail, typename… Ts>\n// nested template argument list\nprimary template.\nWhen a template is used, the primary template is always the one\nassociated specializations (using template argument deduction, as described in\nChapter 15) to determine which template implementation is picked.\nfunction template argument deduction, the SFINAE principle applies here: If, while\nIf no matching specializations is found, the primary template is selected.\ndefined for overloaded function templates) is selected; if none can be called most\nFinally, we should point out that it is entirely possible for a class template partial\nspecialization to have more or fewer parameters than the primary template.\nour generic template List, declared at point #1 , again.\ntemplate<typename C>\nclass List<void* C::*> { // #4\n// (note that this partial specialization has two template\n// whereas the primary template only has one parameter)\ntemplate<typename T, typename C>\nIn addition to our observation regarding the number of template parameters, note that\narguments can differ from the number of template parameters in the primary\ntemplate.\nThis can happen both with default template arguments and, in a far more\ntemplate<typename… Elements>\nclass Tuple; // primary template\ntemplate<typename T1>\ntemplate<typename T1, typename T2, typename… Rest>\n16.5 Partial Variable Template Specialization\nWhen variable templates were added to the draft C++11 standard, several aspects of\nto partially specialize variable templates, but it does not describe how they are\nAs one would expect, the syntax is similar to full variable template specialization,\nthe template argument list following the variable template name must depend on\ntemplate parameters.\ntemplate<typename T> constexpr std::size_t SZ = sizeof(T);\ntemplate<typename T> constexpr std::size_t SZ<T&> =\nAs with the full specialization of variable templates, the type of a partial\nspecialization is not required to match that of the primary template:\ntemplate<typename T, std::size_t N> T* null_iterator<T[N]> =\nThe rules regarding the kinds of template arguments that can be specified for a\nvariable template partial specialization are identical to those for class template\nconcrete template arguments are identical too.\nFull template specialization was part of the C++ template mechanism from the start.\nFunction template overloading and class template partial specialization, on the other\ntemplate overloading, and EDG’s C++ front end was the first to implement class\ntemplate partial specialization.\nThe ability of template specializations to terminate an otherwise infinitely\nrecursive template definition (such as the List<T*> example presented in Section\nmetaprogramming: using the template instantiation mechanism to perform nontrivial\nYou may legitimately wonder why only class templates and variable templates can\ndefine the same mechanism for function templates (see Chapter 17).\nthe effect of overloading function templates is similar, but there are also some subtle\ncontrast, all overloaded function templates must be brought into an overload set by\nConversely, it is also imaginable to allow a form of overloading of class templates\nand variable templates.\n// invalid overloading of class templates\ntemplate<typename T1, typename T2> class Pair;\ntemplate<int N1, int N2> class Pair;\n2 Alias templates are the only form of template that cannot be specialized, either by\nmake the use of template aliases transparent to the template argument deduction\n3 The same prefix is also needed to declare full function template specializations.\nmember templates required additional syntax to disambiguate complex\nC++ templates have been evolving almost continuously from their initial design in\n• Default function template arguments: C++11 allows function templates to have\ndefault template arguments.\n• Typedef templates: C++11 introduced alias templates, which are similar.\n• Initializer deduction: C++17 added class template argument deduction, which\n• The types of variable, variable template, and static data member declarations.\nAgain, similarly with variable templates.\n• The type after the = token in an alias or alias template declaration.\n• The default argument of a type parameter of a template.\n17.2 Generalized Nontype Template Parameters\nAmong the restrictions on nontype template arguments, perhaps the most surprising\nliteral as a template argument.\ntemplate<char const* msg>\nto char const* when passed as a template argument.)\nliterals as arguments to templates.\nsome C++ language commentators feel that a nontype template parameter that can be\nfollowing template declarations, and let’s assume that the language has been\nextended to accept string literals as template arguments in this case:\ntemplate<char const* str>\ntemplate<char const* str>\ntemplate<char const* str>\nfloating-point expressions) as template arguments.\nbecame desirable to allow them for nontype template parameters.\nequality criterion would then be permitted as nontype template parameter types.\n17.3 Partial Specialization of Function Templates\nIn Chapter 16 we discussed how class templates can be partially specialized, whereas\nfunction templates are simply overloaded.\nPartial specialization doesn’t introduce a completely new template: It is an\nWhen a class template is\nlooked up, only primary templates are considered at first.\nprimary template, it turns out that there is a partial specialization of that template\nwith a template argument pattern that matches that of the instantiation, its definition\ntemplate.\n(Full template specializations work exactly the same way.)\nIn contrast, overloaded function templates are separate templates that are\nWhen selecting which template to\ninstantiate, all the overloaded templates are considered together, and overload\n• It is possible to specialize member templates of a class without changing the\nallow us to add new templates to the std namespace, but it does allow us to\nspecialize templates from that namespace.\n• To overload function templates, their function parameters must differ in some\nConsider a function template R convert(T const&) where R\nand T are template parameters.\nWe may very well want to specialize this template\nSpecifically, given two function templates f(T) and g(T)\n(where T is a template parameter), the expression g(&f<int>) is valid only if f\n• Friend declarations refer to a specific function template or an instantiation of a\nspecific function template.\nAn overloaded version of a function template would not\nconstruct for function templates.\nA natural syntax for partially specializing function templates is the generalization\nof the class template notation:\ntemplate<typename T>\ntemplate\ntemplate<typename T>\napproach with function template overloading.\ntemplate<typename T>\nvoid add (T& x, int i);     // a primary template\ntemplate<typename T1, typename T2>\ntemplate\ntemplate<typename T>\nvoid add<T*> (T*&, int);    // Which primary template does this\n17.4 Named Template Arguments\nnondefault template argument for a specific parameter without having to specify\nother template arguments for which a default value is available.\nHence, providing a language mechanism to name template\npoint there is no reason to believe named template arguments will ever make it into\ntemplate<typename T,\nto a template argument by name.\nOf course, introducing named template arguments means that the template parameter\ntemplate<typename T,\n17.5 Overloaded Class Templates\nIt is entirely possible to imagine that class templates could be overloaded on their\ntemplate parameters.\ntemplates that contains both dynamically and statically sized arrays:\ntemplate<typename T>\ntemplate<typename T, unsigned Size>\nThe overloading isn’t necessarily restricted to the number of template parameters;\ntemplate<typename T1, typename T2>\ntemplate<int I1, int I2>\nTemplate argument deduction for pack expansions only works when the pack\ntemplate<typename… Types>\ntemplate<typename FrontT, typename… Types>\ntemplate<typename… Types>\ntemplate<typename BackT, typename… Types>\nusing Type = BackT;          //       template argument list\nTemplate argument deduction for variadic function templates is similarly restricted.\nIt is plausible that the rules regarding template argument deduction of pack\noccur anywhere in the template argument list, making this kind of operation far\ntemplate<typename… Types> class Tuple {\ntemplate<typename T, typename… Types>\ntemplate<typename T, typename… Before, typename… After>\nall cases, it makes our template simpler.\nthat void often complicates our templates and that there is no deep reason for void\nMost importantly, many templates would no longer need to be specialized for the\n17.8 Type Checking for Templates\nMuch of the complexity of programming with templates comes from the compiler’s\ntemplate?\ntemplate<typename T>\ntemplate specialization\ndefinition of the function template max().\nactual template definition in which the error was detected.\nof the template) is actually in error.\nThe idea behind type checking of templates is to describe the requirements of a\ntemplate within the template itself, so that the compiler can determine whether the\ntemplate definition or the template use is at fault when compilation fails.\nsolution to this problem is to describe the template’s requirements as part of the\nsignature of the template itself using a concept:\ntemplate<typename T> requires LessThanComparable<T>\nBy describing the requirements on the template parameter T, the compiler is able to\nensure that the function template max() only uses operations on T that the user is\nMoreover, when using a template, the compiler can check that the\nsupplied template argument provides all of the behavior required for the max()\nfunction template to work properly.\npoint of instantiation of a template and the definition of a template.\ntemplate, the compiler checks that no operation not permitted by the\nforms of reflection and metaprogramming (in some sense, template instantiation is a\nthe capabilities of C++17 templates are rather limited when it comes to reflection\ntemplate<typename T> void report(T p) {\nin a template, this evaluation is only done when the template is instantiated.\nOther patterns to produce types, template argument\nWith all that in place, instantiating the function template report() for a type:\ntemplate<> void report(X const& p) {\nrecursive template instantiation techniques.\ntemplate<typename Head, typename… Remainder>\nTemplates and Design\nBecause templates\nTemplates differ from more traditional language constructs in that they allow us to\n• Expression templates\nThe Polymorphic Power of Templates\nHowever, templates also allow us to\ntypes and declaring them as virtual function interfaces in a common base class.\nTemplates can also be used to implement polymorphism.\npolymorphic power is then enabled when templates are instantiated with the concrete\nPolymorphism implemented via templates\ntemplate<typename GeoObj>\nvoid myDraw (GeoObj const& obj)    // GeoObj is template\ndifference is the specification of GeoObj as a template parameter instead of a\nfunction at run time, whereas with the template we have distinct functions, such as\ntemplate<typename GeoObj>\ntemplate<typename GeoObj1, typename GeoObj2>\ntemplate<typename GeoObj>\nInstead, we provide for two template parameters, GeoObj1 and\n• Polymorphism implemented via templates is unbounded and static:",
      "keywords": [
        "template",
        "code image template",
        "view code image",
        "template argument",
        "image template",
        "function template",
        "template argument list",
        "primary template",
        "view code",
        "code image",
        "template partial specialization",
        "typename",
        "class template",
        "template argument deduction",
        "template parameters"
      ],
      "concepts": [
        "template",
        "type",
        "classes",
        "void",
        "difference",
        "differ",
        "different",
        "functions",
        "function",
        "functionality"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 12,
          "title": "",
          "score": 0.948,
          "base_score": 0.798,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 1,
          "title": "",
          "score": 0.887,
          "base_score": 0.737,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 2,
          "title": "",
          "score": 0.817,
          "base_score": 0.667,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 31,
          "title": "",
          "score": 0.791,
          "base_score": 0.641,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 14,
          "title": "",
          "score": 0.759,
          "base_score": 0.759,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "templates",
          "template typename",
          "function",
          "template argument",
          "primary template"
        ],
        "semantic": [],
        "merged": [
          "templates",
          "template typename",
          "function",
          "template argument",
          "primary template"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5063214029746117,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.448380+00:00"
      }
    },
    {
      "chapter_number": 16,
      "title": "Segment 16 (pages 488-517)",
      "start_page": 488,
      "end_page": 517,
      "summary": "function is needed, whereas distinct template instances must be generated to handle\ndifferent types).\nthe template implementations).\nIn contrast, the following can be said about static polymorphism in C++:\n• Collections of built-in types are easily implemented.\n• Concrete types that provide only partial interfaces can still be used if only that part\nStatic polymorphism is often regarded as more type safe than dynamic\ninstantiated from a template.\npolymorphism using the inheritance-based curiously recurring template pattern (or\nOne argument against static polymorphism with templates is that the binding of the\ninterfaces is done by instantiating the corresponding templates.\nexplicitly provide (and check) interfaces for template parameters.\ntemplate<typename T>\nNow, we can rewrite some of our example templates to include a requires\nclause that constrains the template parameters with the GeoObj concept:\ntemplate<typename T>\ntemplate<typename T>\nThat is, such types are still defined without any specific base class or requirements\nThe availability of static polymorphism in C++ leads to new ways of implementing\nBridge pattern implemented using templates\nStatic polymorphism leads to the concept of generic programming.\nIn this sense, just about any use of C++ templates could be\nBoth algorithms and containers are templates.\ntemplate<typename Iterator>\nvalue\ncontainer, the container has to provide only an iterator type to traverse the sequence\nof values it contains and member functions to create such iterators:\ntemplate<typename T>\nis usually called a concept, which denotes a set of constraints that a template has to\nContainer types were a primary motivation for the introduction of templates into the\nPrior to templates, polymorphic hierarchies were a\nCollection to operate on different types of collections:\nequivalent code using the C++ standard library because most operations ended up\nsolved using templates, and homogeneous containers are an example of this.\nImplementing Traits\nTemplates enable us to parameterize classes and functions for various types.\nbe tempting to introduce as many template parameters as possible to enable the\nTraits (or traits templates) are C++ programming devices that greatly facilitate the\nstrength templates.\nMost of the traits presented here are available in the C++ standard library in some\nintroduce various levels at which policy classes and traits can help.\nBecause this book is about templates,\nwe wish to write a template that will work for many types.\ntraits/accum1.hpp\ntemplate<typename T>\nTo motivate our first traits template, consider the following code that makes use of\ntraits/accum1.cpp\nIn the first half of the program, we use accum() to sum five integer values:\nthe average value of the characters in \"templates\" is -5\nThe problem here is that our template was instantiated for the type char, which\nClearly, we could resolve this by introducing an additional template parameter AccT\nhave to specify an extra type in every invocation of our template.\neach type T for which accum() is called and the corresponding type that should be\nspecializations of a template:\ntemplate<typename T>\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<>\nThe template AccumulationTraits is called a traits template because it holds a\ntrait of its parameter type.\nthan one parameter.) We chose not to provide a generic definition of this template\nWith this in mind, we can rewrite our accum() template as follows:3\ntraits/accum2.hpp\ntemplate<typename T>\n// return type is traits of the element type\nAccT total{};  // assume this actually creates a zero value\nthe average value of the characters in \"templates\" is 108\ntemplate.\n19.1.2 Value Traits\nSo far, we have seen that traits represent additional type information related to a\nConstants and other classes of values can be associated with a type\nOur original accum() template uses the default constructor of the return value to\nAccT total{};  // assume this actually creates a zero value\nType AccT may not even have a default constructor.\ntrait to our AccumulationTraits:\ntemplate<typename T>\ntemplate<>\ntemplate<>\ntemplate<>\nIn this case, our new trait provides an zero element as a constant that can be\ntraits/accum3.hpp\ntemplate<typename T>\n// return type is traits of the element type\ntrait value\ndata member inside its class only if it has an integral or enumeration type.\ntemplate<>\ntemplate<>\nThe straightforward alternative is not to define the value trait in its class:\ntemplate<>\ntemplate<>\nAn alternative that works prior to C++17 is to use inline member functions for value\ntraits that won’t always yield integral values.\ntemplate<typename T>\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<>\nand then extend these traits for our own types:\ntemplate<>\ntrait function\nClearly, traits can be more than just extra types.\nelement type for which it is called.\nprovide an avenue to configure concrete elements (mostly types) for generic\nThe use of traits in accum() in the previous sections is called fixed, because once\nset of float values can safely be summed into a variable of the same type, and\nWe can address this problem by adding a template parameter AT for the trait itself\nhaving a default value determined by our traits template:\ntraits/accum5.hpp\ntemplate<typename T, typename AT = AccumulationTraits<T>>\nexceptional needs can specify an alternative to the preset accumulation type.\n19.2 Traits versus Policies and Policy Classes\nvalues.\nfunction template:\ntraits/accum6.hpp\ntemplate<typename T,\ntypename Traits = AccumulationTraits<T>>\nAccT total = Traits::zero();\ntraits/sumpolicy1.hpp\nstatic void accumulate (T1& total, T2 const& value) {\nBy specifying a different policy to accumulate values, we can compute different\ntraits/accum6.cpp\nstatic void accumulate (T1& total, T2 const& value) {\npolicies may interact, underscoring the importance of careful template design.\nThis policy may or may not make use of the trait\nwith traits and policies.\nC++ standard library takes the initial value as a third (function call) argument.\n19.2.1 Traits and Policies: What’s the Difference?\ntemplate argument with which it is combined.\nPolicies have much in common with traits but differ in that they put less\nTraits class: A class used in place of template parameters.\naggregates useful types and constants; as a template, it provides an avenue for\n• Traits represent natural additional properties of a template parameter.\n• Policies represent configurable behavior for generic functions and types (often with\n• Traits can be useful as fixed traits (i.e., without being passed through template\n• Traits parameters usually have very natural default values (which are rarely\n• Traits mostly combine types and constants rather than member functions.\n• Traits tend to be collected in traits templates.\n• Policy classes don’t contribute much if they aren’t passed as template parameters.\n• Policy parameters need not have default values and are often specified explicitly\n• Policy parameters are mostly orthogonal to other parameters of a template.\n• Policy classes mostly combine member functions.\n• Policies can be collected in plain classes or in class templates.\ncharacter traits of the C++ standard library also define functional behavior such as\ncalled traits, they have some properties associated with policies.\nMultPolicy as ordinary classes with a member template.\nof designing the policy class interface using class templates, which are then used as\nFor example, we could rewrite SumPolicy as a template:\ntraits/sumpolicy2.hpp\nstatic void accumulate (T1& total, T2 const& value) {\nThe interface of Accum can then be adapted to use a template template parameter:\ntraits/accum7.hpp\ntemplate<typename T,\ntemplate<typename,typename> class Policy = SumPolicy,\ntypename Traits = AccumulationTraits<T>>\nAccT total = Traits::zero();\nthis theme are possible: For example, instead of explicitly passing the AccT type to\nthe policy type, it may be advantageous to pass the accumulation trait and have the\npolicy determine the type of its result from a traits parameter.)\nThe major advantage of accessing policy classes through template template\ninformation (i.e., static data members) with a type that depends on the template\nembedded in a member class template.)\nHowever, a downside of the template template parameter approach is that policy\nclasses must now be written as templates, with the exact set of template parameters\n19.2.3 Combining Multiple Policies and/or Traits\nhaving multiple template parameters.\nstandard library provides iterator traits.\n(Traits are everywhere!) Thus, we could\ntraits/accum0.hpp\ntemplate<typename Iter>\nusing VT = typename std::iterator_traits<Iter>::value_type;\nThe std::iterator_traits structure encapsulates all the relevant properties\ntemplate<typename T>\nstruct iterator_traits<T*> {\nusing value_type        = T;\nHowever, there is no type for the accumulation of values to which an iterator refers;\n19.3 Type Functions\ntypes.\nbe called value functions: They take some values as arguments and return another\nWith templates, we can additionally define type functions: functions\nA very useful built-in type function is sizeof, which returns a constant\nClass templates can also\nserve as type functions.\nThe parameters of the type function are the template\nparameters, and the result is extracted as a member type or member constant.\ntemplate<typename T>\nstatic std::size_t const value = sizeof(T);\nclass template argument itself.\nIn what follows, we develop a few more general-purpose type functions that can\nbe used as traits classes in this way.\n19.3.1 Element Types\nAssume that we have a number of container templates, such as std::vector<>\ntemplate<typename T>\ntemplate<typename T>\nusing Type = T;\ntemplate<typename T>\nusing Type = T;",
      "keywords": [
        "view code image",
        "code image traits",
        "template",
        "Traits",
        "type",
        "view code",
        "code image",
        "ACCUM",
        "image traits",
        "code",
        "HPP",
        "template parameters",
        "AccT",
        "code image template",
        "typename"
      ],
      "concepts": [
        "template",
        "types",
        "traits",
        "values",
        "classes",
        "iterations",
        "click",
        "policy",
        "policies",
        "code"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 10,
          "title": "",
          "score": 0.912,
          "base_score": 0.762,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 20,
          "title": "",
          "score": 0.854,
          "base_score": 0.704,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 19,
          "title": "",
          "score": 0.846,
          "base_score": 0.696,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 17,
          "title": "",
          "score": 0.845,
          "base_score": 0.695,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 30,
          "title": "",
          "score": 0.775,
          "base_score": 0.625,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "traits",
          "policy",
          "type",
          "templates",
          "policies"
        ],
        "semantic": [],
        "merged": [
          "traits",
          "policy",
          "type",
          "templates",
          "policies"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4950327883810976,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.448464+00:00"
      }
    },
    {
      "chapter_number": 17,
      "title": "Segment 17 (pages 518-549)",
      "start_page": 518,
      "end_page": 549,
      "summary": "using Type = T;\nusing Type = T;\nNote that we should provide partial specializations for all possible array types (see\nWe can use the type function as follows:\n<< typeid(typename ElementT<T>::Type).name()\nThe use of partial specialization allows us to implement the type function without\nIn many cases, however, the type\nfunction is designed along with the applicable types, and the implementation can be\nFor example, if the container types define a member type value_type\nusing Type = typename C::value_type;\ncontainer types that do not have an appropriate member type value_type defined.\nNonetheless, it is usually advisable to provide member type definitions for class\ntemplate type parameters so that they can be accessed more easily in generic code\nHow is a type function useful?\nelement type explicitly, we can declare\ntypename ElementT<C>::Type sumOfElements (C const& c);\nwhere the element type is determined from the type function.\nObserve how the traits are implemented as an extension to existing types; that is,\nIn this case, the type ElementT is called a traits class because it is used to access\na trait of the given container type C (in general, more than one trait can be collected\nAs a convenience, we can create an alias template for type functions.\nusing ElementType = typename ElementT<T>::Type;\nIn addition to providing access to particular aspects of a main parameter type, traits\nusing Type = T;\nusing Type = T;\nusing Type = T;\nRemoving the reference from a type is typically useful when the type was derived\nusing a construct that sometimes produces reference types, such as the special\ndeduction rule for function parameters of type T&& discussed in Section 15.6 on\nThe C++ standard library provides a corresponding type trait\nusing Type = T&;\nusing AddLValueReference = typename AddLValueReferenceT<T>::Type;\nusing Type = T&&;\nusing AddRValueReference = typename AddRValueReferenceT<T>::Type;\nexample, calling AddLValueReference<int&&> produces type int& (there is\nusing Type = void;\nusing Type = void const;\nusing Type = void volatile;\nusing Type = void const volatile;\nThe C++ standard library provides corresponding type traits\nThe standard templates include the specializations for void types.\nTransformation traits can break down or introduce any kind of compound type, not\nusing Type = T;\nusing Type = T;\nusing RemoveConst = typename RemoveConstT<T>::Type;\nRemoveVolatileT<T>::Type> {\nusing RemoveCV = typename RemoveCVT<T>::Type;\nRemoveConstT rather than declaring its own Type member that is identical to the\nThe C++ standard library also provides corresponding type traits\ntype conversions when passing arguments to parameters by value.\nthis means that the arguments decay (turning array types into pointers and function\ntypes into pointer-to-function types; see Section 7.4 on page 115 and Section 11.1.1\ntype:\n#include <type_traits>\nstd::cout << \"Parameter type: \" << typeid(A).name() << ’\\n’;\nWe can implement a trait that produces the same type conversion of passing by\ntypes (with or without a bound) using partial specialization:\nusing Type = T*;\nusing Type = T*;\nusing Type = R (*)(Args…, …);\nNote that the second partial specialization matches any function type that uses C-\nspecialization implement parameter type decay, as illustrated by this example\n#include <type_traits>\nusing A = typename DecayT<T>::Type;\nstd::cout << \"Parameter type: \" << typeid(A).name() << ’\\n’;\nusing Decay = typename DecayT<T>::Type;\nAs written, the C++ standard library also provides a corresponding type traits\ntype functions that depend on multiple arguments.\nof type traits, type predicates (type functions yielding a Boolean value).\nThe IsSameT trait yields whether two types are equal:\nHere the primary template defines that, in general, two different types passed as\npartial specialization, when we have the special case that the two passed types are\nFor traits that produce a constant value, we cannot provide an alias template, but we\nThe C++ standard library provides a corresponding type trait std::is_same<>,\ntrue_type and false_type\ntypes for the possible two outcomes, true and false.\nwe can define IsSameT so that, depending on whether the two types match, it\nNow, the resulting type of\ndifferent function implementations or partial class template specializations at\nstd::cout << \"fooImpl(T,false) for other type called\\n\";\nNote that our BoolConstant implementation includes a Type member, which\nusing IsSame = typename IsSameT<T>::Type;\nrepresenting false instead of having each generic library defining its own types for\nFortunately, the C++ standard library provides corresponding types in\n<type_traits> since C++11: std::true_type and std::false_type.\nusing false_type = bool_constant<false>;\nFor this reason, we use std::true_type and std::false_type directly\n19.3.4 Result Type Traits\nAnother example of type functions that deal with multiple types are result type traits.\nint value, we really would prefer to allow such mixed-type operations with arrays\nBesides the different approaches introduced in Section 1.3 on page 9, a result type\nArray<typename PlusResultT<T1, T2>::Type>\nThe PlusResultT trait determines the type produced by adding values of two\n(possibly different) types with the + operator:\nusing Type = decltype(T1() + T2());\nusing PlusResult = typename PlusResultT<T1, T2>::Type;\nThis trait template uses decltype to compute the type of the expression T1() +\nproduce a reference type, but most likely our Array class template is not designed\nto handle reference types.\nreturn a value of const class type:\ntransform the result type by removing references and qualifiers, as discussed in the\nAt this point, the array addition operator properly computes the result type when\nadding two arrays of (possibly different) element types.\nPlusResultT places an undesirable restriction on the element types T1 and T2:\nBecause the expression T1() + T2() attempts to value-initialize values of types\nrequire value-initialization of its element type, so this is an additional, unnecessary\na constructor, by using a function that produces values of a given type T.\nThe expression declval<T>() produces a value of type T without requiring a\nreturned from a function, such as abstract class types (classes with pure virtual\nfunctions) or array types.\nusing Type = decltype(std::declval<T1>() + std::declval<T2>());\nusing PlusResult = typename PlusResultT<T1, T2>::Type;\nResult type traits offer a way to determine the precise return type of a particular\noperation and are often useful when describing the result types of function templates.\ninvalid types and expressions during template argument deduction (which would\ncompile-time techniques that can determine if a particular type or expression is valid.\nThis allows us to write traits that determine, for example, whether a type has a\nSFINAE with function overloading to find out whether a type is default\nis, for a given type T, an expression such as T() has to be valid.\nto declare two overloaded function templates named test() with different return\ntypes:\ntemplate<…> static char test(void*);\nIf the first test() member—whose return type is char—is selected, value will\nof the passed type T.\ninitialize a type parameter.\nsubstituted, so that for a type that isn’t default constructible, the code fails to compile\ndeclaring two overloaded function templates returning different return types:\ntemplate<…> static char test(void*);\nGiven that observation, we want to ensure that the return types of the test()\nthat matters is that the passed argument matches the expected type.\nBoolean value, should return a value derived from std::true_type or\nstd::false_type.\ntrait itself should derive from the Type of a helper class, which yields the necessary\nreturn types of the test() overloads:\ntemplate<…> static std::true_type test(void*);    // checking\ntemplate<…> static std::false_type test(…);     // fallback\nThat way, the Type member for the base class simply can be declared as follows:\nusing Type = decltype(test<FROM>(nullptr));\n#include <type_traits>\nstatic std::true_type test(void*);\nstatic std::false_type test(…);\nusing Type = decltype(test<T>(nullptr));\nIsDefaultConstructibleHelper<T>::Type {\nits return type std::true_type.\nderives from std::true_type.\nSFINAE, and IsDefaultConstructibleHelper::Type is initialized by the\nreturn type of the test() fall-back, that is, std::false_type.\nthat IsConvertibleT<… > then derives from std::false_type.\nAgain, we can use the example to find out whether a type T is default constructible:\n#include <type_traits>  //defines true_type and false_type\nstruct IsDefaultConstructibleT : std::false_type\nstd::true_type\ntraits above, we define the general case to be derived from std::false_type,\ntype of a helper VoidT.\nIn C++17, the C++ standard library introduced a type trait std::void_t<> that\n#include <type_traits>\nObviously, this way to define a type trait looks more condensed that the first\nfunction overloads enables us to use additional helper functions or helper types.\nstd::true_type isValidImpl(void*);\nstd::false_type isValidImpl(…);\n// helper template to represent a type as a value\nusing Type = T;\n// helper to wrap a type as a value\nconstexpr auto type = TypeT<T>{};\nLet’s start with the definition of isValid: It is a constexpr variable whose type\nis a lambda’s closure type.\nThe declaration must necessarily use a placeholder type\n(auto in our code) because C++ has no way to express closure types directly.\nSince isValid has a closure type, it can be\ntype, produced by the inner lambda expression.\nand, as the name suggests, it is a function object that checks the trait of a type being\nThe type helper variable template allows us to represent a type as a value.\nvalue x obtained that way can be turned back into the original type with\nIf that extracted type cannot be default-constructed,\nisDefaultConstructible(type<int>)  //true (int is default-\nisDefaultConstructible(type<int&>) //false (references are not\nwhich attempts to invoke a value of the type of its first template argument, which is\nthe closure type of the lambda in the definition of isDefaultConstructible,\nwith values of the types of the arguments (decltype(args)&&…) passed to\nabove, that argument has type TypeT<int> or TypeT<int&>.\nlesser match), which produces a false_type value.\nisDefaultConstructible produces false_type when type<int&> is\nIf instead type<int> is passed, the substitution does not fail, and the first\ndeclaration of isValidImpl() is selected, producing a true_type value.\ntype of that lambda, not in its body!\nIn general, a type trait should be able to answer a particular query without causing\nusing Type = decltype(std::declval<T1>() + std::declval<T2>());\nusing PlusResult = typename PlusResultT<T1, T2>::Type;\nprogram to become ill-formed, as in the following attempt to declare the return type\nof adding arrays of unrelated types A and B:20\n// declare + for arrays of different element types:\nArray<typename PlusResultT<T1, T2>::Type>\nspecify whether the types in a function template are actually instantiated if another\n// declare generic + for arrays of different element types:\nArray<typename PlusResultT<T1, T2>::Type>\n// overload + for concrete types:\nusing Type = decltype(std::declval<T1>() + std::declval<T2>\nthe given types:\n#include <type_traits>  // for true_type, false_type, and void_t\nstruct HasPlusT : std::false_type\n: std::true_type\nType at all.\nreturn type of the array operator+ template above—the missing member Type\nusing Type = decltype(std::declval<T1>() + std::declval<T2>());\nselected, with our existing definition of the Type member.\ncontract that PlusResultT provide the result type only if in fact the + operation is\nPlusResultT<A,B> will not have a Type member, because A and B values are\nTherefore, the result type of the array operator+ template is invalid,\nrelies on a (container) type having a member type value_type, the primary\ntemplate should attempt to define the member Type only when the container type\nhas such a value_type member:\ntemplate<typename C, bool = HasMemberT_value_type<C>::value>\nusing Type = typename C::value_type;\nIsConvertibleT trait yields whether we can convert a passed first type to a\npassed second type:\n#include <type_traits>  // for true_type and false_type\nstatic std::true_type test(void*);\nstatic std::false_type test(…);\nusing Type = decltype(test<FROM>(nullptr));\nstruct IsConvertibleT : IsConvertibleHelper<FROM, TO>::Type {\nusing IsConvertible = typename IsConvertibleT<FROM, TO>::Type;\ntemplates named test() with different return types and declare a Type member",
      "keywords": [
        "Type",
        "view code image",
        "code image template",
        "template",
        "view code",
        "code image",
        "code image traits",
        "typename",
        "image template",
        "array",
        "code",
        "traits",
        "Click",
        "view",
        "image"
      ],
      "concepts": [
        "type",
        "typing",
        "template",
        "traits",
        "click",
        "std",
        "value",
        "void",
        "tested",
        "implement"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 10,
          "title": "",
          "score": 0.864,
          "base_score": 0.714,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 19,
          "title": "",
          "score": 0.857,
          "base_score": 0.707,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 16,
          "title": "",
          "score": 0.845,
          "base_score": 0.695,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 20,
          "title": "",
          "score": 0.74,
          "base_score": 0.59,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 30,
          "title": "",
          "score": 0.72,
          "base_score": 0.57,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "type",
          "types",
          "using",
          "using type",
          "test"
        ],
        "semantic": [],
        "merged": [
          "type",
          "types",
          "using",
          "using type",
          "test"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5047702258434045,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.448549+00:00"
      }
    },
    {
      "chapter_number": 18,
      "title": "Segment 18 (pages 550-583)",
      "start_page": 550,
      "end_page": 583,
      "summary": "template<…> static std::true_type test(void*);\ntemplate<…> static std::false_type test(…);\nstruct IsConvertibleT : IsConvertibleHelper<FROM, TO>::Type {\nand provide the FROM type as an explicit template argument in the call to test()\n1. Conversions to array types should always yield false, but in our code, the\n2. Conversions to function types should always yield false, but just as with the\nusing Type = std::integral_constant<bool,\nIt yields false_type if we\nThe C++ standard library provides a corresponding type trait\ntraits) that can determine whether a given type T has a member of a given name X (a\ntype or a nontype member).\n19.6.1 Detecting Member Types\nLet’s first define a trait that can determine whether a given type T has a member type\nsize_type:\n#include <type_traits>  // defines true_type and false_type\nstruct HasSizeTypeT : std::false_type\nstruct HasSizeTypeT<T, VoidT<typename T::size_type>> :\nstd::true_type\nstd::false_type, because by default a type doesn’t have the member\nsize_type.\ntypename T::size_type\nThis construct is valid if and only if type T has a member type size_type, which\n(i.e., type T has no member type size_type), SFINAE causes the partial\nusing size_type = std::size_t;\nNote that if the member type size_type is private, HasSizeTypeT yields\nfalse because our traits templates have no special access to their argument type,\nother words, the trait tests whether we have an accessible member type\nsize_type.\nreference type\nIt is true that a reference type has not members per\n: std::true_type {\nIt’s also worth noting that our traits technique to detect member types will also\nstruct size_type {\nstruct Sizeable : size_type {\na member type, and that name is inherited.\n19.6.2 Detecting Arbitrary Member Types\nthe trait to be able to check for any member type name.\n#include <type_traits>  // for true_type, false_type, and void_t\nDEFINE_HAS_TYPE(MemType)                                    \\\n: std::false_type {\n: std::true_type { } // ; intentionally skipped\nFor example, we can use it to detect whether a type\nhas a value_type or a char_type member type as follows:\nDEFINE_HAS_TYPE(value_type);\nDEFINE_HAS_TYPE(char_type);\nstd::cout << \"int::value_type: \"\n<< HasTypeT_value_type<int>::value << ’\\n’;\nstd::cout << \"std::vector<int>::value_type: \"\n<< HasTypeT_value_type<std::vector<int>>::value <<\nstd::cout << \"std::iostream::value_type: \"\n<< HasTypeT_value_type<std::iostream>::value << ’\\n’;\nstd::cout << \"std::iostream::char_type: \"\n<< HasTypeT_char_type<std::iostream>::value << ’\\n’;\n#include <type_traits>  // for true_type, false_type, and void_t\n: std::false_type { };\n: std::true_type { } // ; intentionally skipped\n• If T::Member is a static data member, its type must not provide an operator&\n&T::Member is not a pointer-to-member type (which amounts to excluding static\nagainst attempts to create both invalid types and expressions in a function template\n#include <type_traits>  // for true_type, false_type, and void_t\nstruct HasBeginT : std::false_type {\n: std::true_type {\nto test whether, given a value/object of type T (using std::declval to avoid any\nFor example, we can test whether, given types T1 and T2,\nthere is a suitable < operator defined for values of these types:\n#include <type_traits>  // for true_type, false_type, and void_t\nstruct HasLessT : std::false_type\n: std::true_type\n#include <type_traits>  // for true_type, false_type, and void_t\nstruct HasVariousT : std::false_type\ntypename T::difference_type,\n: std::true_type\nfriendly traits (Section 19.4.4 on page 424) and to aid in overloading based on type\ntype member such as first or size_type exists or whether operator< is\n// define to check for member type size_type:\nusing size_type = std::size_t;\nif constexpr(!hasSizeType(type<int>)) {\ncout << \"int has no size_type\\n\";\nthe passed x because you can’t access a type member from a reference.\nTo be able to use the common generic syntax, taking types as template parameters,\n-> typename std::decay_t<decltype(x)>::size_type {\nusing size_type = std::size_t;\ncout << \"size_type: \" << HasSizeTypeT<CX>::value <<\ncout << \"size_type: \" << HasSizeTypeT<int>::value <<\ncompletely different implementation depending on the result of another type trait,\nWe can formulate this if-then-else behavior with a special type template\ntype parameters:\nusing Type = TrueType;\nusing Type = FalseType;\nFalseType>::Type;\ntype function that determines the lowest-ranked integer type for a given value:\nusing Type =\n>::Type\n>::Type\n>::Type\n>::Type\n>::Type;\nConsider, for example, a trait that yields the corresponding unsigned type for a given\nsigned type.\nusing Type = IfThenElse<std::is_integral<T>::value\ntypename std::make_unsigned<T>::type,\ntypename std::make_unsigned<T>::type\nIfThenElse arguments are themselves uses of type functions that wrap the result:\n// yield T when using member Type:\nusing Type = T;\nusing Type = typename std::make_unsigned<T>::type;\nusing Type = typename IfThenElse<std::is_integral<T>::value\n>::Type;\ninstances of type functions themselves.\nHowever, the type functions are not actually\nThe ::Type then\nusing Type = typename IfThenElse<std::is_integral<T>::value\nMakeUnsignedT<T>::Type,\n>::Type;\nIdentityT<T> to retrieve its Type member.\nusing Type\n>::Type;\n#include <type_traits>  // for bool_constant\ndefine std::true_type and std::false_type (see Section 19.3.3 on page\nfriendly (see Section 19.4.4 on page 424): If the trait is instantiated with a type that\nInstead of aborting the compilation, the type trait should yield a value of false.\n#include <type_traits>  // for true_type, false_type, and\nstruct IsNothrowMoveConstructibleT : std::false_type\nstd::false_type result.\nFor this reason, the type trait is\nThe C++ standard library provides a corresponding type trait\nOne common complaint with type traits is their relative verbosity, because each use\nof a type trait typically requires a trailing ::Type and, in a dependent context, a\nWhen multiple type\ntypename PlusResultT<T1, T2>::Type\n>::Type\n>::Type\nyielding types or values respectively more convenient.\nRather than expressing a type trait as a class template with a type member\nType, we can use an alias template directly.\ntemplates wrap the type traits used above:\ntype traits.\nHowever, there are downsides to using alias templates for type traits:\n3. The use of an alias template will always instantiate the type (e.g., the underlying\nthat don’t make sense for a given type (as discussed in Section 19.7.1 on page\nBecause the use of alias templates for type traits has both positive and negative\nThe type traits class templates yield a type in type and have no specific\nThe traits class templates producing a result in value have no specific suffix, and\n19.8 Type Classification\nsuite of type traits that allow us to determine various properties of a given type.\ntypes\nBy default, we assume a type is not fundamental, and we specialize the template for\n#include <type_traits>  // for true_type, false_type, and\n// primary template: in general T is not a fundamental type\nstruct IsFundaT : std::false_type {\n// macro to specialize for fundamental types\n#define MK_FUNDA_TYPE(T)                             \\\ntemplate<> struct IsFundaT<T> : std::true_type {  \\\nMK_FUNDA_TYPE(std::nullptr_t)\nstruct IsFundaT : std::false_type {\nFor each fundamental type, a specialization is defined so that\ntemplate<> struct IsFundaT<bool> : std::true_type {\nstd::cout << \"T is a fundamental type\" << ’\\n’;\nstd::cout << \"T is not a fundamental type\" << ’\\n’;\nT is a fundamental type\nT is not a fundamental type\nscalar types.\nthen composite type categories such as std::is_integral or\ninclude pointer types, lvalue and rvalue reference types, pointer-to-member types,\nand array types.\nClass types\narbitrary number of types (for parameters or members).\nEnumeration types are also\nstruct IsPointerT : std::false_type {     //primary template: by\nstruct IsPointerT<T*> : std::true_type {  //partial\nThe primary template is a catch-all case for nonpointer types and, as usual, provides\nits value constant false through is base class std::false_type, indicating\nthat the type is not a pointer.\n(T*) and provides the value true to indicate that the provided type is a pointer.\nAdditionally, it provides a type member BaseT that describes the type that the\nwas a pointer, making this a SFINAE-friendly type trait (see Section 19.4.4 on page\nwhich, however, does not provide a member for the type the pointer points to.\nstruct IsLValueReferenceT : std::false_type {      //by default\nstruct IsLValueReferenceT<T&> : std::true_type {  //unless T is\nusing BaseT = T;  // type referring to\nand rvalue reference types:\nstruct IsRValueReferenceT : std::false_type {      //by default\nstruct IsRValueReferenceT<T&&> : std::true_type {  //unless T is\nusing BaseT = T;  // type referring to\n>::Type {\nmember for the type the reference refers to.\nstruct IsArrayT : std::false_type {        //primary template:\nstruct IsArrayT<T[N]> : std::true_type {  //partial\nstruct IsArrayT<T[]> : std::true_type {  //partial specialization\nto check whether a type is an array, which is described in Section D.2.1 on page 704.\nstruct IsPointerToMemberT : std::false_type {         //by\nstruct IsPointerToMemberT<T C::*> : std::true_type {  //partial\nHere, the additional members provide both the type of the member and the type of\n19.8.3 Identifying Function Types\nin addition to the result type.\nstruct IsFunctionT : std::false_type {      //primary template:\nstruct IsFunctionT<R (Params…)> : std::true_type\nusing Type = R;\nstruct IsFunctionT<R (Params…, …)> : std::true_type {  //variadic\nusing Type = R;\nSuch function types can only be meaningfully used for nonstatic member functions\nbut are function types nonetheless.\nfunction type.\nstruct IsFunctionT<R (Params…) const> : std::true_type {\nusing Type = R;\nstruct IsFunctionT<R (Params…, …) volatile> : std::true_type {\nusing Type = R;\nstd::true_type {\nusing Type = R;\nstruct IsFunctionT<R (Params…, …) &> : std::true_type {\nusing Type = R;\nstruct IsFunctionT<R (Params…, …) const&> : std::true_type {\nusing Type = R;\nenumeration types.\n19.8.4 Determining Class Types\nspecialization patterns that match class types specifically.\nexpression that is valid for all class types (and not other type).\nWith that type or\ntypes can be used as the basis of pointer-to-member types.\nThat is, in a type\ntype X):\n#include <type_traits>\nstruct IsClassT : std::false_type {     //primary template: by\n: std::true_type {\nunnamed non-union class type.” For this reason, lambda expressions yield true\nNote also that the expression int T::* is also valid for union types (they are\nalso class types according to the C++ standard).\nThe C++ standard library provides the traits std::is_class<> and\nThe only types not yet classified by any of our traits are enumeration types.\nfor enumeration types can be performed directly by writing a SFINAE-based trait",
      "keywords": [
        "type",
        "view code image",
        "std",
        "template",
        "view code",
        "code image",
        "code image traits",
        "typename",
        "Section",
        "code image template",
        "member type",
        "member type size",
        "traits",
        "member",
        "code"
      ],
      "concepts": [
        "type",
        "std",
        "trait",
        "templates",
        "value",
        "members",
        "click",
        "classes",
        "uses",
        "useful"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.922,
          "base_score": 0.772,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 63,
          "title": "",
          "score": 0.867,
          "base_score": 0.717,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 64,
          "title": "",
          "score": 0.861,
          "base_score": 0.711,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.821,
          "base_score": 0.671,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 81,
          "title": "",
          "score": 0.803,
          "base_score": 0.653,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "type",
          "true_type",
          "std",
          "false_type",
          "std true_type"
        ],
        "semantic": [],
        "merged": [
          "type",
          "true_type",
          "std",
          "false_type",
          "std true_type"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4745041652436124,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.448635+00:00"
      }
    },
    {
      "chapter_number": 19,
      "title": "Segment 19 (pages 584-615)",
      "start_page": 584,
      "end_page": 615,
      "summary": "template<typename T>\nThe C++ standard library provides the trait std::is_enum<>, which is described\nSo far, our examples of traits templates have been used to determine properties of\ntemplate parameters: what sort of type they represent, the result type of an operator\ntemplate parameter (whereas policy classes are usually independent of other template\nAlthough property traits can often be implemented as type functions, policy traits\nlook at a type function that defines a policy for passing read-only parameters.\nhow large the type substituted for the template parameter will be.\ntemplate that is a type function: The function maps an intended argument type T onto\ntemplate can use by-value passing for types no larger than two pointers and by\ntemplate<typename T>\nT const&>::Type;\ntemplate<typename T>\nstd::is_trivially_move_constructible type traits are part of the C++\n#include <type_traits>\ntemplate<typename T>\nusing Type\nEither way, the policy can now be centralized in the traits template definition, and\ntemplate<>\nvoid foo (typename RParam<T1>::Type p1,\ntemplate that provides perfect forwarding (Section 15.6.3 on page 280), but it\nWith C++11, type traits became an intrinsic part of the C++ standard library.\ncomprise more or less all type functions and type traits discussed in this chapter.\nFor this reason, if you need type traits, we recommend that you use the ones from\n• The class template std::char_traits is used as a policy traits parameter by\na very simple std::iterator_traits property traits template is provided\n• The template std::numeric_limits can also be useful as a property traits\ntemplate.\nSince C++98, the template std::allocator is provided as the\nWith C++11, the template\nfor the default traits templates.\ntemplate by providing a custom traits argument, it is good practice to declare a type\nThe idea of storing properties of types as members of template specializations\nclassification templates was the __type_traits utility in the STL\n__type_traits specializations and provided information about the arguments\nthe __type_traits template was safe to use, albeit suboptimal.)\nBoost provides a rather complete set of type classification templates (see\nPODs) require compiler support, much like the __type_traits specializations\ninstead of a member function template.\ntemplate arguments resulted in a malformed type construct (e.g., T::X where T is\n20 For simplicity, the return value just uses PlusResultT<T1,T2>::Type.\nrequirement that the return type of the call is complete, because the returned value\n27 Specifically, when a function type is marked const, it refers to a qualifier on the\nlibraries implement various traits templates.\nfunctions, so long as those functions are distinguished by their parameter types.\nWith function templates, one overloads on type patterns such as pointer-to-T or\ntemplate<typename T> void f(T*);\ntemplate<typename T> void f(Array<T>);\noverload function templates based on the properties of the template arguments.\ntemplate<typename Container> void f(Container);// only for\nIn fact, the two f function templates immediately above are\nactually declarations of the same function template, rather than distinct overloads,\nbecause the names of template parameters are ignored when comparing two function\ntemplates.\noverloading of function templates based on type properties.\nOne of the common motivations behind overloading of function templates is to\nprovide more specialized versions of an algorithm based on knowledge of the types\ntemplate<typename T>\nFor some types, however, we\ntemplate<typename T>\nThe latter function template is therefore (conceptually) more specialized than the\nthe former function template.\nFortunately, the second function template is also more\nspecialized based on the partial ordering rules for function templates (see Section\nmore efficient) function template when it is applicable (i.e., for Array<T>\nfunction template (the second swap()) with the most general function template (the\nfirst swap()), and ensuring that the more specialized function template was also\ninto function templates that provide the right partial ordering behavior.\nUnfortunately, defining both of these function templates will result in a compiler\nbased on their template parameter names are not overloadable.\nfunction templates.\nstandard library’s iterator category tag types (defined below) to identify the two\ntemplate<typename Iterator, typename Distance>\nstd::input_iterator_tag)\ntemplate<typename Iterator, typename Distance>\nstd::random_access_iterator_tag) {\nThen, the advanceIter() function template itself simply forwards its arguments\ntemplate<typename Iterator, typename Distance>\nThe trait class std::iterator_traits provides a category for the iterator\nvia its member type iterator_category.\n_tag types mentioned earlier, which spec-ifies what kind of iterator the type is.\nstruct random_access_iterator_tag : public\nstd::input_iterator_tag and with\nstd::random_access_iterator_tag, and because\nstd::random_access_iterator_tag inherits from\nstd::input_iterator_tag, normal function overloading will prefer the more\nstd::random_access_iterator_tag) whenever advanceIterImpl()\nspecialized algorithm that is applicable to the given template arguments.\n20.3 Enabling/Disabling Function Templates\nAlgorithm specialization involves providing different function templates that are\nneither partial ordering of function templates (Section 16.2.2 on page 330) nor\nJust like std::enable_if, the EnableIf alias template can be used to\nenable (or disable) a specific function template under specific conditions.\ntemplate<typename Iterator>\ntypename std::iterator_traits<Iterator>::iterator_category, \nstd::random_access_iterator_tag>;\ntemplate<typename Iterator, typename Distance>\ntemplate should be enabled and the type produced by the EnableIf expansion\nIn our example above, we used the type trait\npage 447, as our condition, to define a type trait IsRandomAccessIterator.\nconsidered if the concrete type substituted for Iterator is usable as a random-\nstd::random_access_iterator_tag.\ntemplate<bool, typename T = void>\ntemplate< typename T>\nusing Type = T;\ntemplate<bool Cond, typename T = void>\nusing EnableIf = typename EnableIfT<Cond, T>::Type;\nEnableIf expands to a type and is therefore implemented as an alias template.\nalias templates cannot be partially specialized.\nthe alias template EnableIf simply select the result type from the helper template.\nEnableIf<…>) simply evaluates to the second template argument, T.\nclass template for EnableIfT has no member named Type.\n15.7 on page 284) context—such as the return type of a function template—it has the\neffect of causing template argument deduction to fail, removing the function\nFor advanceIter(), the use of EnableIf means that the function template\nwill be available (and have a return type of void) when the Iterator argument is\ntemplate for the types to which is applies.\nthe less specialized template, except that we negate the condition expression.\nIterator type.\ntemplate<typename Iterator, typename Distance>\nsophisticated logic: Each function template must use EnableIf with a condition\nthat is mutually exclusive with the conditions of all of the other function templates\nThe following set of function templates implements this:\n// implementation for random access iterators:\ntemplate<typename Iterator, typename Distance>\ntemplate<typename Iterator>\ntypename std::iterator_traits<Iterator>::iterator_category,\ntemplate<typename Iterator, typename Distance>\ntemplate<typename Iterator, typename Distance>\nBy making the EnableIf condition of each function template mutually exclusive\nwith the EnableIf conditions of every other function template, we ensure that, at\nmost, one of the function templates will succeed template argument deduction for a\narbitrary sets of properties determined by type traits.\nEnableIf is typically used in the return type of the function template.\nthis approach does not work for constructor templates or conversion function\ntemplates, because neither has a specified return type.5 Moreover, the use of\nembed the EnableIf in a defaulted template argument, as follows:\ntemplate<typename Iterator>\ntypename std::iterator_traits<Iterator>::iterator_category,\nstd::input_iterator_tag>;\ntemplate<typename T>\ntemplate<typename Iterator,\ntemplate<typename U, typename = EnableIf<IsConvertible<T, U>>>\ntemplate<typename Iterator,\ntemplate<typename Iterator,\ntemplate\ntemplate<typename Iterator,\ntemplate<typename Iterator,\ntemplate<typename Iterator, typename Distance>\n// implementation for random access iterators:\niterators) will only be instantiated for types that can support them.\nbody of the function template.\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename Iterator>\ntemplate<typename Iterator>\nrequirements of the template.\ntemplates that differ only in their requires clauses, eliminating the need for tag\nexample, to provide a sort() member function only when the type T is\ntemplate<typename T>\nClass template partial specializations can be used to provide alternate, specialized\nimplementations of a class template for specific template arguments, much like we\nused overloading for function templates.\nAnd, like overloaded function templates, it\nthe template arguments.\nConsider a generic Dictionary class template with key\nand value types as its template parameters.\ncan be implemented so long as the key type provides just an equality operator:\ntemplate<typename Key, typename Value>\nIf the key type supports a < operator, we can provide a more efficient\n20.4.1 Enabling/Disabling Class Templates\nThe way to enable/disable different implementations of class templates is to use\nenabled/disabled partial specializations of class templates.\nclass template partial specializations, we first introduce an unnamed, defaulted\ntemplate<typename Key, typename Value, typename = void>\nbe embedded in the template argument list of the partial specialization for the map\ntemplate<typename Key, typename Value>\nUnlike with overloaded function templates, we don’t need to disable any condition\ntemplate<typename Key, typename Value, typename = void>\ntemplate<typename Key, typename Value>\ntemplate typename Key, typename Value>\n20.4.2 Tag Dispatching for Class Templates\nTag dispatching, too, can be used to select among class template partial\nTo illustrate, we define a function object type\nfor bidirectional and random access iterators, relying on an auxiliary trait\ntemplate<typename Iterator,\ntypename std::iterator_traits<Iterator>\nstd::input_iterator_tag,\nstd::random_access_iterator_tag>>\ntemplate<typename Iterator>\nclass Advance<Iterator, std::input_iterator_tag>\ntypename std::iterator_traits<Iterator>::difference_type;\nvoid operator() (Iterator& x, DifferenceType n) const\ntemplate<typename Iterator>\nclass Advance<Iterator, std::bidirectional_iterator_tag>\ntypename std::iterator_traits<Iterator>::difference_type;\nvoid operator() (Iterator& x, DifferenceType n) const\ntemplate<typename Iterator>\nclass Advance<Iterator, std::random_access_iterator_tag>\ntypename std::iterator_traits<Iterator>::difference_type;\nvoid operator() (Iterator& x, DifferenceType n) const\nThis formulation is quite similar to that of tag dispatching for function templates.\niterator’s category tag and to report its parameter type:\nvoid f(std::input_iterator_tag);\nvoid f(std::bidirectional_iterator_tag);\nvoid f(std::random_access_iterator_tag);\ntemplate<typename… Types>\ntemplate<>\n: template<typename T, typename… Types>\ntemplate<typename T, typename… Types>\n>::Type;\nfunction with each type in the input set of Types.\nfunction(s) defined in its base class, which handles the remaining types in the list.\nmatch() functions and produces the return type of the selected (best) match()\nit relatively easy to use tag dispatching to select among class template partial\nThe essence of the EnableIf technique is to enable a particular template or partial\nspecialization only when the template arguments meet some specific criteria.\nstd::random_access_iterator_tag, which implies that the various\ntemplate performs on its template arguments as part of the EnableIf condition?\ntemplates here.\nWe would typically implement such as a template as follows:\ntemplate<typename T>\nThis template requires the type T to have a < operator able to compare two T\ntemplate<typename T> struct Identity;\ntemplate<typename U1, typename U2> static std::true_type\ntemplate<typename U1, typename U2> static std::false_type\ntemplate<typename T>",
      "keywords": [
        "iterator",
        "template",
        "typename Iterator",
        "type",
        "random access iterator",
        "code image template",
        "typename",
        "function template",
        "view code image",
        "access iterator",
        "function",
        "traits",
        "image template",
        "view code",
        "code image"
      ],
      "concepts": [
        "type",
        "template",
        "std",
        "functions",
        "function",
        "traits",
        "classes",
        "value",
        "operator",
        "operation"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 10,
          "title": "",
          "score": 0.858,
          "base_score": 0.708,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 17,
          "title": "",
          "score": 0.857,
          "base_score": 0.707,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 16,
          "title": "",
          "score": 0.846,
          "base_score": 0.696,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 20,
          "title": "",
          "score": 0.835,
          "base_score": 0.685,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 30,
          "title": "",
          "score": 0.726,
          "base_score": 0.576,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "iterator",
          "function",
          "typename iterator",
          "template typename",
          "templates"
        ],
        "semantic": [],
        "merged": [
          "iterator",
          "function",
          "typename iterator",
          "template typename",
          "templates"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5296245748339672,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.448745+00:00"
      }
    },
    {
      "chapter_number": 20,
      "title": "Segment 20 (pages 616-650)",
      "start_page": 616,
      "end_page": 650,
      "summary": "implementing instantiation-safe templates.\nforgotten the conversion-to-bool requirement, our min() template would have\ntemplate<typename T>\nclass IsContextualBoolT {\ntemplate<typename U> static std::true_type\ntemplate<typename U> static std::false_type\ntemplate<typename T>\ntemplate<typename T>\nchecks into traits that describe some class of types, such as forward iterators, and\n(std::iterator_traits) and the requirements placed on iterators, so they can\nThe C++11 standard library std::enable_if class template provides the same\nbehavior as the EnableIfT class template presented here.\nstrongly at the required use of std::enable_if<> or similar SFINAE-based\ntemplate to allow a vector to be built from an iterator sequence:\ndemonstrated its use for detecting the presence of member types (for example).\nto use EnableIf with class template partial specializations.\nadvanced template libraries, including the C++ standard library.\ntemplate arguments for function templates (another C++11 feature) made it possible\nto use EnableIf in constructor templates without introducing another function\n5 While a conversion function template does have a return type—the type it is\nconverting to—the template parameters in that type need to be deducible (see\n6 In C++17, one can eliminate the recursion with pack expansions in the base class\nTemplates and Inheritance\ndependent base classes forces us to deal carefully with unqualified names.\n21.1 The Empty Base Class Optimization (EBCO)\nThis is the case typically for classes that\nNonstatic data members, virtual functions, and virtual base classes, on the other\nEven empty classes, however, have nonzero size.\nclass EmptyClass {\nsystems impose more strict alignment requirements on class types and may print\nThe designers of C++ had various reasons to avoid zero-size classes.\nspecify that when an empty class is used as a base class, no space needs to be\nclarify what this empty base class optimization (EBCO) means in practice.\nclass Empty {\nusing Int = int;// type alias members don’t make a class\nclass EmptyToo : public Empty {\nclass EmptyThree : public EmptyToo {\nIf your compiler implements the EBCO, it will print the same size for every class,\nbut none of these classes has size zero (see Figure 21.1).\nThis means that within class\nNote also that an empty class\nclass Empty {\nusing Int = int;    // type alias members don’t make a class\nclass EmptyToo : public Empty {\ndoes not have any members and neither do its base classes.\naddress because this would cause the base class Empty of EmptyToo to end up at\nthe same address as the base class Empty of class NonEmpty.\nWhen two subobjects of such classes are used\nlibraries because a number of techniques rely on the introduction of base classes\n21.1.2 Members as Base Classes\nresult, it is sometimes desirable to implement as a (private) base class what would at\nparameters are often substituted with empty class types, but in general we cannot\nIf nothing is known about a template type parameter, the EBCO\nclass MyClass {\nempty class type.\nThis can be avoided by making the template arguments base classes instead:\n• The class may be final, in which case attempts to inherit from it will cause an\nAdding a base class can fundamentally modify the interface of the given class.\ntemplate parameter can affect whether a member function is virtual.\nparameter is known to be substituted by class types only and when another member\nof the class template is available.\nclass Optimizable {\na template implementer would use the following:\nclass Optimizable {\ntemplate<typename Base, typename Member>\nclass BaseMemberPair : private Base {\n// access base class data via first()\nAn implementation needs to use the member functions base() and member() to\nnamed pattern refers to a general class of techniques that consists of passing a\nderived class as a template argument to one of its own base classes.\ntemplate<typename Derived>\nclass CuriousBase {\nOur first outline of CRTP shows a nondependent base class: The class Curious is\ndependent base classes.\ntemplate<typename Derived>\nclass CuriousBase {\ntemplate<typename T>\nBy passing the derived class down to its base class via a template parameter, the base\nclass can customize its own behavior to the derived class without requiring the use of\nare dependent on the derived class’s identity.\ncertain class type were created.\nHowever, having to provide such code in every class is tedious, and implementing\nthis functionality via a single (non-CRTP) base class would confuse the object\ncounts for different derived classes.\nclass ObjectCounter {\nBefore C++17, we had to define it outside the class\ntemplate:\nclass ObjectCounter {\nclass type, it suffices to derive the class from the ObjectCounter template.\nexample, we can define and use a counted string class along the following lines:\nTo illustrate this, suppose we have a class template Array for which we want to\nmember of the class template, but this is not good practice because the first argument\ntemplate<typename T>\nclass Array {\ntemplate<typename T>\nHowever, if function templates cannot be overloaded, this presents a problem: No\nother operator == template can be declared in that scope, and yet it is likely that such\na template would be needed for other class templates.\nthis problem by defining the operator in the class as a normal friend function:\ntemplate<typename T>\nclass Array {\nitself is not an instantiation of a function template.\ndeclarations of operator == even before overloading of function templates was added\nbecause it avoided the use of a template operator==(T, T) that applied to all\nis defined inside a class definition, it is implicitly considered to be an inline\nfriend declarations would be visible in the enclosing scope of a class template when\nthe arguments of the function call must already have the class containing the friend\nfunction as an associated class.\narguments were of an unrelated class type that could be converted to the class\nclass S {\ntemplate<typename T>\nclass Wrapper {\nWrapper<S> which is a class associated with the argument w.2 However, in the\nnot visible because the class Wrapper<S> in which it is defined is not associated\nIn modern C++, the only advantages to defining a friend function in a class\nenclosing class and don’t need to restate all of the template parameters of enclosing\nclass templates.\nwith the Curiously Recurring Template Pattern (CRTP), as illustrated in the operator\nWhen implementing a class that provides overloaded operators, it is common to\nclass that implements the equality operator (==) will likely also implement the\ninequality operator (!=), and a class that implements the less-than operator (<) will\noperator for a class X is likely to be defined in terms of the equality operator:\ntemplate<typename T>\ndefinition will only be instantiated for types with a suitable == operator, the second\nprovided definitions that require, for example, a derived-to-base conversion, which\nAn alternative formulation of these operator templates based on CRTP allows\nclasses to opt in to the general operator definitions, providing the benefits of\ntemplate<typename Derived>\nclass EqualityComparable\nfriend bool operator!= (Derived const& x1, Derived const& x2)\nclass X : public EqualityComparable<X>\nderived class based on the derived class’s definition of operator==.\nCRTP can be useful when factoring behavior into a base class while retaining the\nidentity of the eventual derived class.\nWe can take this idea further, such that the CRTP base class\ndefines most or all of the public interface of a class in terms of a much smaller (but\neasier to implement) interface exposed by the CRTP derived class.\nmeet the requirements of some existing interface—numeric types, iterators,\nThe required interface for an iterator type\nclass template IteratorFacade demonstrates the requirements for an iterator\ntemplate<typename Derived, typename Value, typename Category,\nclass IteratorFacade\nusing value_type = typename std::remove_const<Value>::type;\nreference operator [](difference_type n) const { … }\nDerived& operator +=(difference_type n) { … }\nfriend difference_type operator -(IteratorFacade const& lhs,\nThe role of the facade is to adapt a type that implements only those core operations\nfollowing examples, we use the member functions asDerived() to access the\nCRTP derived class:\ntemplate<typename T>\nclass ListNode\ntemplate<typename T>\nclass ListNodeIterator\nIteratorFacade to perform all of its operations on the derived CRTP class\n// ‘friend’ this class to allow IteratorFacade access to core\niterator operations:\nclass IteratorFacadeAccess\ntemplate<typename Derived, typename Value, typename Category,\nfriend class IteratorFacade;\ntemplate<typename Reference, typename Iterator>\ntemplate<typename Iterator>\ntemplate<typename Iterator, typename Distance>\nThis class provides static member functions for each of the core iterator operations,\ncalling the corresponding (nonstatic) member function of the provided iterator.\nfriend class IteratorFacadeAccess;\n(base) iterator to some pointer-to-data member, for example,\n(Iterator) and the type of value that will be exposed by the iterator (T):\ntemplate<typename Iterator, typename T>\nclass ProjectionIterator\nstd::iterator_traits<Iterator>::difference_type>\nstd::iterator_traits<Iterator>::value_type;\ntypename std::iterator_traits<Iterator>::difference_type;\nfriend class IteratorFacadeAccess\n… //implement core iterator operations for IteratorFacade\nProjectionIterator(Iterator iter, T Base::* member)\ntemplate<typename Iterator, typename Base, typename T>\nauto project(Iterator iter, T Base::* member) {\ntemplate arguments provided to the IteratorFacade base class.\n(T&) arguments are the value and reference types of our projection iterator, defining\nthe category and difference types of the underlying iterator.\nreturn (*iter).*member;\nThe remaining operations are implemented in terms of the underlying iterator:\n++iter;\n--iter;\nConsider a simple Polygon class that consists of a sequence of points:\nclass Point\nclass Polygon\nThis Polygon class would be more useful if the user could extend the set of\nclass Polygon\nclass LabeledPoint : public Point\nanother: The addition of a new Point constructor could require each derived class\nbecause the new classes are “mixed in” to the inheritance hierarchy as base classes of\na class template rather than being created as a new derived class.\nA class template that supports mixins will typically accept an arbitrary number of\nextra classes from which it will derive:\nclass Point : public Mixins…\nNow, we can “mix in” a base class containing a label to produce a\nclass Label\nor even mix in several base classes:\nclass Color\nspecialization to their mixin class (Label or Color, above) to access that data or\nMoreover, the Point class can even be entirely hidden, with the mixins\nprovided to the Polygon class template itself:\nclass Polygon\neach of the mixins is actually a class template that will be provided with the type of\nclass Point : public Mixins<Point>…\nThis formulation requires some more work for each class that will be mixed in, so\nclasses such as Label and Color will need to become class templates.\nderived class they’ve been mixed into.\nMixins also allow us to indirectly parameterize other attributes of the derived class,\nclass NotVirtual {\nclass Virtual {\nclass Base :\n// (if any) in the base classes Mixins…\nclass Derived : public Base<Mixins…> {\nThis technique can provide a tool to design a class template that is usable both to\ninstantiate concrete classes and to extend using inheritance.\nsufficient just to sprinkle virtuality on some member functions to obtain a class that\nmakes a good base class for more specialized functionality.\npractical to design two different tools (class or class template hierarchies) than to try\nVarious template techniques sometimes cause a class template to end up with many\ndifferent template type parameters.\nA natural way to define such a class template may look as\nclass BreadSlicer {\nOur technique consists of placing the default type values in a base class and\narguments, we provide them through helper classes.\nclass BreadSlicer {\nmerge the different template arguments into a single type that overrides default type\n// PolicySelector<A,B,C,D> creates A,B,C,D as base classes\n// Discriminator<> allows having even the same base class more\ntemplate<typename Base, int D>\nclass Discriminator : public Base {\nclasses of the same type.\nIndirect base classes, on the other hand, can have types that\nAs announced earlier, we’re collecting the defaults in a base class:\nclass DefaultPolicies {\ntimes from this base class.\nTherefore, we ensure that the base class is inherited\n// class to define a use of the default policy values\nclass DefaultPolicyArgs : virtual public DefaultPolicies {\ntemplate<typename Policy>\nclass Policy1_is : virtual public DefaultPolicies {\nclass Policy2_is : virtual public DefaultPolicies {\nclass Policy3_is : virtual public DefaultPolicies {\nclass Policy4_is : virtual public DefaultPolicies {",
      "keywords": [
        "view code image",
        "code image template",
        "template",
        "view code",
        "base class",
        "code image",
        "iterator",
        "class template",
        "base",
        "typename",
        "image template",
        "derived class",
        "type",
        "code",
        "Empty Base Class"
      ],
      "concepts": [
        "classes",
        "template",
        "iterating",
        "operator",
        "operations",
        "operation",
        "type",
        "std",
        "public",
        "based"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 16,
          "title": "",
          "score": 0.854,
          "base_score": 0.704,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 19,
          "title": "",
          "score": 0.835,
          "base_score": 0.685,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 10,
          "title": "",
          "score": 0.807,
          "base_score": 0.657,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 30,
          "title": "",
          "score": 0.765,
          "base_score": 0.615,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 17,
          "title": "",
          "score": 0.74,
          "base_score": 0.59,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "class",
          "base",
          "derived",
          "iterator",
          "base class"
        ],
        "semantic": [],
        "merged": [
          "class",
          "base",
          "derived",
          "iterator",
          "base class"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.516820859964036,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.448832+00:00"
      }
    },
    {
      "chapter_number": 21,
      "title": "Segment 21 (pages 651-684)",
      "start_page": 651,
      "end_page": 684,
      "summary": "For this BreadSlicer<> the type Policies is defined as\nWith the help of the Discriminator<> class templates, this results in a hierarchy\nin which all template arguments are base classes (see Figure 21.4).\nResulting type hierarchy of BreadSlicer<>::Policies\nWe developed the technique for four template type parameters, but it obviously\nrich, standard-library compliant iterator interface for a derived type that provides a\nThe use of templates for mixins in C++ became popular shortly after\nNamed template arguments are used to simplify certain class templates in the\nBoost uses metaprogramming to create a type with properties similar\nfunction template overloading works in modern C++.\n2 Note that S is also a class associated with w because it is a template argument for\nthe type of w.\ntypes of operator -> and operator[] to account for proxies.\nChapter 18 described the nature of static polymorphism (via templates) and dynamic\npolymorphism (via inheritance and virtual functions) in C++.\ncode, but the set of types that can be used at run time is fixed at compile time.\npolymorphic function to work with types not known at the time it is compiled, but it\nis less flexible because types must inherit from the common base class.\npolymorphism that allows, for example, built-in types to work seamlessly.\ntemplate.\n22.1 Function Objects, Pointers, and std::function<>\nFunction objects are useful for providing customizable behavior to templates.\nexample, the following function template enumerates integer values from 0 up to\nsome value, providing each value to the given function object f:\ntemplate<typename F>\nstd::vector<int> values;\nThe forUpTo() function template can be used with any function object, including\na lambda, function pointer, or any class that either implements a suitable\noperator() or a conversion to a function pointer or reference, and each use of\nforUpTo() will likely produce a different instantiation of the function template.\nOur example function template is fairly small, but if the template were large, it is\nOne approach to limit this increase in code size is to turn the function template\nThe standard library’s class template std::function<> permits an alternative\nvoid forUpTo(int n, std::function<void(int)> f)\nThe template argument to std::function<> is a function type that describes the\nparameter types the function object will receive and the return type that it should\nproduce, much like a function pointer describes the parameter and result types.\n—the ability to work with an unbounded set of types including function pointers,\ncalled type erasure, which bridges the gap between static and dynamic\nThe std::function<> type is effectively a generalized form of a C++ function\nfunction itself.\nHowever, unlike a C++ function pointer, a std::function<> can also store a\nlambda or any other function object with a suitable operator(), all of which may\nhave different types.\npointer class template, FunctionPtr, to provide these same core operations and\nstd::vector<int> values;\nthe interface is how it is described entirely within a class template partial\nspecialization, which serves to break the template argument (a function type) into its\ncomponent pieces (result and argument types):\ntemplate<typename Signature>\ntemplate<typename F> FunctionPtr(F&& f);  // see functionptr-\ntemplate<typename F> FunctionPtr& operator=(F&& f) {\nR operator()(Args… args) const;    // see functionptr-cpinv.hpp\nThe FunctorBridge class template is responsible for the ownership and\nfunction object through virtual functions: a destructor, a clone() operation to\noperation to call the underlying function object.\nUsing these virtual functions, we can implement FunctionPtr’s copy\nconstructor and function call operator:\n22.4 Type Erasure\nparameterizing the derived class on the type of the function object it stores:\ninitialized to a new function object, completing the FunctionPtr example:\ntemplate<typename F>\nNote that while the FunctionPtr constructor itself is templated on the function\nobject type F, that type is known only to the particular specialization of\nSpecificFunctorBridge (described by the Bridge type alias).\ninformation about the specific type F is lost due to the derived-to-based conversion\nfrom Bridge * to FunctorBridge<R, Args…> *.2 This loss of type\nD.4 on page 731) to produce the Functor type, which makes the inferred type F\nsuitable for storage, for example, by turning references to function types into\nfunction pointer types and removing top-level const, volatile, and reference\ntypes.\nOur FunctionPtr template is nearly a drop-in replacement for a function pointer.\nHowever, it does not yet support one operation provided by function pointers: testing\nwhether two FunctionPtr objects will invoke the same function.\nthe stored function objects when they have the same type:\n//functors with different types are never equal:\nFunctionPtr is assigned or initialized with a function object that does not have a\nstd::vector—can be instantiated with types that don’t have an operator==\nThis problem with operator== is due to type erasure: Because we are\neffectively losing the type of the function object once the FunctionPtr has been\nincludes forming a call to the function object’s operator==, because we can’t be\ntemplate<typename T>\ntemplate<typename U>\nstatic std::true_type test(decltype(conv(std::declval<U\ntemplate<typename U>\nstatic std::false_type test(…);\nto compare two objects of type T const using == and then ensures that the result\noperations are well formed, the parameter types themselves will both be void*.\nclass template that can either invoke == on the given type (when it’s available) or\ntemplate<typename T,\ntemplate<typename T>\nFunctionPtr whenever the stored function object types match and the function\n//functors with different types are never equal:\nType erasure provides some of the advantages of both static polymorphism and\nclose (e.g., using FunctionPtr to simply add two integers), type erasure is likely\nKevlin Henney popularized type erasure in C++ with the introduction of the any\nstd::function<>.\nset of operations: any was a simple value type with only a copy and a cast operation;\nAdobe’s Poly library [AdobePoly], apply template metaprogramming techniques to\nallow users to form a type-erased value with some specified list of capabilities.\nexample, the following type (constructed using the Boost.TypeErasure library)\nthe FunctionPtr class makes the bridge pointer private, so clients of\nFunctionPtr have no access to the type itself.\nthe virtual functions of a class template (in this case,\nSpecificFunctorBridge) are typically instantiated when the class template\nMetaprogramming often relies on the concepts of traits and type functions, as\n23.1.1 Value Metaprogramming\nfairly advanced example computed the square root of an integer value at compile\ntime using recursive template instantiations.\nintroduction of constexpr functions.1 For example, since C++14, a compile-time\nfunction to compute a square root is easily written as follows:\ntemplate<typename T>\nThis function’s implementation may not be the most efficient at run time (where\nexample, only the usual template argument deduction for a function template.\nValue metaprogramming (i.e., programming the computation of compile-time\nand C++17): type metaprogramming and hybrid metaprogramming.\n23.1.2 Type Metaprogramming\nWe already encountered a form of type computation in our discussion of certain\ntraits templates in Chapter 19, which take a type as input and produce a new type\nFor example, our RemoveReferenceT class template computes the\n19 computed only fairly elementary type operations.\nperform type computations that are considerably more complex.\n// primary template: in general we yield the given type:\ntemplate<typename T>\nusing Type = T;\n// partial specializations for array types (with and without\ntemplate<typename T, std::size_t SZ>\ntemplate<typename T>\ntemplate<typename T>\nHere, RemoveAllExtents is a type metafunction (i.e., a computational device\nthat produces a result type) that will remove an arbitrary number of top-level “array\nlayers” from a type.2 You can use it as follows:\nThe same is true of type metaprogramming: Adding a “container of types”\n24 develops a Typelist<…> class template, which is exactly such a container of\ntypes, in great detail.\nWith value metaprogramming and type metaprogramming we can compute values\nand types at compile time.\nso we use these metaprograms in run time code in places where types and constants\ncontainer template declared as follows:\ntemplate<typename T, size_t N> struct array;\nwhere N is the number of elements (of type T) in the array.\nsame array type, their dot-product can be computed as follows:\ntemplate<typename T, std::size_t N>\ntemplate<typename T, std::size_t N>\ntemplate<typename T>\ntemplate<typename T, std::size_t N>\nauto dotProduct(std::array<T, N> const& x,\nThis new implementation delegates the work to a class template DotProductT.\nThat enables us to use recursive template instantiation with class template partial\nFor values of type std::array<T,N> there\nwill therefore be N instances of the primary template and one instance of the\ncompiler inlines every invocation of the static member functions result().\ncomputation (achieved here through recursive template instantiation) that determines\nmetaprogramming a fixed-length array type can be useful.\nvalues, each with a selectable type.\nstd::tuple class template that supports that notion.\ndefines a variable tVal that aggregates three values of types int, std::string,\nto simple union types would also be useful for hybrid computation.\n“yes.” The C++ standard library introduced a std::variant template for this\nBecause std::tuple and std::variant, like struct types, are\nheterogeneous types, hybrid metaprogramming that uses such types is sometimes\n23.1.4 Hybrid Metaprogramming for Unit Types\nable to compute results of values of different unit types.\nThe value computation is\nThe key, then, is to define a ratio type where each value has\nits own type:\nusing Type = Ratio<num, den>;\nWe can now define a class template for durations, parameterized with an arbitrary\nvalue type and a unit type that is an instance of Ratio<>:\n// duration type for values of type T with unit type U:\n// adding two durations where unit type might differ:\n// resulting type is a unit with 1 a nominator and\n// the resulting denominator of adding both unit type fractions\n// converted to the resulting unit type:\nunit types to compute the resulting duration to have a unit type that is the\nauto c = a + b; //computes resulting unit type 1/3000 seconds\nunit type Ratio<1,3000> at compile time and generates code to compute at run\ntime the resulting value, which is adjusted for the resulting unit type.\nBecause the value type is a template parameter, we can use class Duration with\nvalue types other than int or even use heterogeneous value types (as long as adding\nthe values of these types is defined):\nauto f = d + e;  //computes resulting unit type 1/3 seconds\nIn addition, the compiler can even perform the value computation at compile-time if\nthe values are known at compile time, because operator+ for durations is\nThe C++ standard library class template std::chrono uses this approach with\nand type metaprogramming based on recursive template instantiation.\nrecursive template instantiation, and, prior to the introduction of constexpr\ncode computes a square root of an integer using recursive instantiation:\n// primary template to compute sqrt(N)\ntemplate<int N, int LO=1, int HI=N>\nstatic constexpr auto value = (N<mid*mid) ?\nSqrt<N,mid,HI>::value;\ntemplate<int N, int M>\na nontype template argument instead of a function argument, and the “local\nFor example, given a class type, many\ncurrent traits are based on template instantiation, and C++ could conceivably provide\ntemplate instances that contain the reflected information at compile time.\napproach is a good match for computations based on recursive template\nUnfortunately, class template instances consume a lot of compiler\nHowever, it is also true that instantiating templates\nLet’s analyze the Sqrt<> template introduced in Section 23.2 on page 537.\nprimary template is the general recursive computation that is invoked with the\ntemplate parameter N (the value for which to compute the square root) and two other\nInside the template, we compute whether value is in\nIf mid2 is less than or equal to N, we use the same template\nTemplate instantiations are not cheap: Even relatively modest class templates can\nsimple program that uses our Sqrt template:\nInside the template, the metaprogram computes Sqrt<16,1,16>::value as\nThus, the result is computed as Sqrt<16,1,8>::value, which is expanded as\nFinally, Sqrt<16,3,4>::value results in the following:\naccess a member of the resulting class type using the :: operator, all the members\ninside that class type are also instantiated.\ntemplate<int N, int LO=1, int HI=N>\ntemplate<int N, int S>\nsecond type.\nclass template instance does not cause a C++ compiler to instantiate the body of that\nOur Sqrt<> example demonstrates that a template metaprogram can contain:\nFurthermore, because template instantiation requires substantial compiler resources,\nmost (but certainly not all) template metaprogramming tasks.\n23.5 Recursive Instantiation versus Recursive Template\nConsider the following recursive template:\ntemplate<int N>\ntemplate<>\ninstantiates Doublify over increasingly complex types.\nType Alias\nUnderlying Type\nthat do not involve recursive template arguments.\ncompiler keeps a representation of the mangled name for the type.\nname encodes the exact template specialization in some way, and early C++\nNewer C++ implementations take into account the fact that nested template-ids are\ngenerated for the template instance.\npreferable to organize recursive instantiation in such a way that template arguments\n// primary template to compute 3 to the Nth\ntemplate<int N>\ntemplate<>\n// primary template to compute 3 to the Nth\ntemplate<int N\nstatic int const value = 3 * Pow3<N-1>::value;\ntemplate<>\nstatic int const value = 1;",
      "keywords": [
        "view code image",
        "type",
        "template",
        "view code",
        "code image",
        "sqrt",
        "function",
        "code image bridge",
        "code",
        "class template",
        "std",
        "code image template",
        "function object",
        "typename",
        "Click"
      ],
      "concepts": [
        "type",
        "templates",
        "values",
        "classes",
        "functionality",
        "function",
        "functions",
        "operations",
        "operation",
        "operators"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 30,
          "title": "",
          "score": 0.751,
          "base_score": 0.751,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 16,
          "title": "",
          "score": 0.735,
          "base_score": 0.735,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 10,
          "title": "",
          "score": 0.705,
          "base_score": 0.705,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 19,
          "title": "",
          "score": 0.684,
          "base_score": 0.684,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 14,
          "title": "",
          "score": 0.667,
          "base_score": 0.667,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "type",
          "function",
          "functionptr",
          "types",
          "metaprogramming"
        ],
        "semantic": [],
        "merged": [
          "type",
          "function",
          "functionptr",
          "types",
          "metaprogramming"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5295260622054038,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.448917+00:00"
      }
    },
    {
      "chapter_number": 22,
      "title": "Segment 22 (pages 685-719)",
      "start_page": 685,
      "end_page": 719,
      "summary": "Typelists\nstructure is the typelist, which, as its name implies, is a list containing types.\nTemplate metaprograms can operate on these lists of types, manipulating them to\nA typelist is a type that represents a list of types and can be manipulated by a\niterating over the elements (types) in the list, adding elements, or removing elements.\nHowever, typelists differ from most run-time data structures, such as std::list,\nAdding an element to a typelist, on the\nwill likely recognize the parallels between working with typelists in C++ and lists in\nA typelist is typically implemented as a class template specialization that encodes\nA direct implementation of a typelist encodes the elements in a\nclass Typelist\nThe elements of a Typelist are written directly as its template arguments.\nas Typelist<int>, and so on.\nTypelist<signed char, short, int, long, long long>;\nfrom the typelist:\ntemplate<typename List>\nclass FrontT<Typelist<Head, Tail…>>\ntemplate<typename List>\nusing Front = typename FrontT<List>::Type;\nSimilarly, the PopFront metafunction removes the first element from the typelist.\nIt’s implementation splits the typelist elements into the head and tail, then forms a\nnew Typelist specialization from the elements in the tail.\ntemplate<typename List>\nclass PopFrontT<Typelist<Head, Tail…>> {\nusing Type = Typelist<Tail…>;\ntemplate<typename List>\nusing PopFront = typename PopFrontT<List>::Type;\nOne can also insert elements onto the front of the typelist by capturing all of the\nexisting elements into a template parameter pack, then creating a new Typelist\ntemplate<typename List, typename NewElement>\nusing Type = Typelist<NewElement, Elements…>;\ntemplate<typename List, typename NewElement>\nusing PushFront = typename PushFrontT<List, NewElement>::Type;\nTypelist<bool, signed char, short, int, long, long long>\n24.2 Typelist Algorithms\nreplace the first element in a typelist by applying PushFront to the result of\n// equivalent to Typelist<bool, short, int, long,\nas template metafunctions operating on typelists.\nOne of the most fundamental operations on a typelist is to extract a specific element\nfrom the list.\nexample, to extract the type at index 2 of the given typelist we can write:\nusing TL = NthElement<Typelist<short, int, long>, 2>;\nwith a recursive metaprogram that walks through the typelist until it finds the\ntemplate<typename List, unsigned N>\ntemplate<typename List>\ntemplate<typename List, unsigned N>\nusing NthElement = typename NthElementT<List, N>::Type; \nlist.\nthrough the typelist.\nNthElementT<Typelist<short, int, long>, 2>\nNthElementT<Typelist<int, long>, 1>\nany of the types in the list).\ntemplate<typename List>\ntemplate<typename List>\nusing First = Front<List>;\nusing Rest = typename LargestTypeT<PopFront<List>>::Type;\nclass LargestTypeT<Typelist<>>\ntemplate<typename List>\nusing LargestType = typename LargestTypeT<List>::Type;\nThe LargestType algorithm will return the first, largest type within the typelist.\nFor example, if given the typelist Typelist<bool, int, long, short>,\nexample, in the first step of recursion for the typelist Typelist<bool, int,\nalgorithm to Typelist<int, long, short>.\nIsEmpty metafunction that determines whether the given typelist has no elements:\ntemplate<typename List>\nclass IsEmpty<Typelist<>> {\ntemplate<typename List, bool Empty = IsEmpty<List>::value>\ntemplate<typename List>\nusing Best = typename LargestTypeT<PopFront<List>>::Type;\ntemplate<typename List>\ntemplate<typename List>\nusing LargestType = typename LargestTypeT<List>::Type;\nwhether the list is empty.\nFor our Typelist template, this operation\ntemplate<typename List, typename NewElement>\nusing Type = Typelist<Elements…, NewElement>;\ntemplate<typename List, typename NewElement>\nusing PushBack = typename PushBackT<List, NewElement>::Type;\ntemplate<typename List, typename NewElement, bool =\ntemplate<typename List, typename NewElement>\ntemplate<typename List, typename NewElement>\nusing Type = PushFront<List, NewElement>;\ntemplate<typename List, typename NewElement>\ntemplate<typename List, typename NewElement>\nusing PushBack = typename PushBackT<List, NewElement>::Type;\ninteresting: It splits the list into its first element (Head) and a typelist containing the\nPushBackRecT<Typelist<short, int>, long>\nIn our outermost step, Head is short and Tail is Typelist<int>.\nPushBackRecT<Typelist<int>, long>\nwhere Head is int and Tail is Typelist<>.\nPushFront<int, Typelist<long>>\nThis produces Typelist<int, long>.\nPushFront<short, Typelist<int, long>>\nTypelist<short, int, long>\ntemplate instantiations to evaluate, because for a typelist of length N, there will be N\n24.2.4 Reversing a Typelist\nto reverse the ordering of the elements in the typelist when applying some\nmay be more useful to reverse this list to produce the typelist Typelist<long\ntemplate<typename List, bool Empty = IsEmpty<List>::value>\ntemplate<typename List>\nusing Reverse = typename ReverseT<List>::Type;\ntemplate<typename List>\ntemplate<typename List>\nusing Type = List;\nempty typelist.\nThe recursive case splits the list into its first element and the\nTypelist<short, int, long>, the recursive step separates the first element\n(short) from the remaining elements (Typelist<int, long>).\nrecursively reverses the list of remaining elements (producing Typelist<long,\nint>) and, finally, appends the first element to that reversed list with PushBackT\n(producing Typelist<long, int, short>).\nfor typelists to remove the last element from a typelist:\ntemplate<typename List>\ntemplate<typename List>\nusing PopBack = typename PopBackT<List>::Type;\n24.2.5 Transforming a Typelist\nOur previous typelist algorithms have allowed us to extract arbitrary elements from a\ntypelist, search within the list, construct new lists, and reverse lists.\nhave yet to perform any operations on the elements within the typelist.\nwe may want to “transform” all of the types in the typelist in some way,5 such as by\nTo that end, we will implement a Transform algorithm that takes a typelist and a\nmetafunction and produces another typelist containing the result of applying the\ntypelist/transform.hpp\ntemplate<typename List, template<typename T> class MetaFun,\ntemplate<typename List, template<typename T> class MetaFun>\ntypename MetaFun<Front<List>>::Type>\ntemplate<typename List, template<typename T> class MetaFun>\nusing Type = List;\ntemplate<typename List, template<typename T> class MetaFun>\nusing Transform = typename TransformT<List, MetaFun>::Type;\ntransform is the result of transforming the first element in the typelist (second\nby recursively transforming the rest of the elements in the typelist (first argument to\n24.2.6 Accumulating Typelists\nalgorithm takes a typelist T with elements T1, T2, …, TN , an initial type I, and a\nthe result of the previous i − 1 steps and Ti. Depending on the typelist, choice of F , and initial type, we can use\nOn the other hand, if F accepts a typelist and a type and pushes the type\non the back of the typelist, Accumulate will behave like the Reverse algorithm.\ntypelist/accumulate.hpp\ntemplate<typename List,\ntemplate<typename List,\ntypename F<I, Front<List>>::Type>\ntemplate<typename List,\ntemplate<typename List,\nusing Accumulate = typename AccumulateT<List, F, I>::Type;\nof the list, passing the result of applying F on as the initial type for the accumulation\nmetafunction F and an empty typelist (TypeList<T>) as the initial type I:\nTypelist<>>;\n// produces TypeList<long long, long, int, short,\ntemplate<typename Typelist>\nFront<Typelist>>\ntemplate<typename Typelist>\nusing LargestTypeAcc = typename LargestTypeAccT<Typelist>::Type;\nit provides the first element of the typelist as the initial type.\nempty-list case explicitly, either by returning some sentinel type (char or void) or\ntemplate<typename Typelist, bool = IsEmpty<Typelist>::value>\ntemplate<typename Typelist>\nclass LargestTypeAccT<Typelist, false>\nFront<Typelist>>\ntemplate<typename Typelist>\nclass LargestTypeAccT<Typelist, true>\ntemplate<typename Typelist>\nusing LargestTypeAcc = typename LargestTypeAccT<Typelist>::Type;\nalgorithms for typelist manipulation.\nFor our final typelist algorithm, we will implement an insertion sort.\nalgorithms, the recursive step splits the list into its first element (the head) and the\nexpressed as a typelist algorithm:\ntemplate<typename List,\ntemplate<typename List,\n// recursive case (insert first element into sorted list):\ntemplate<typename List,\ntemplate<typename List,\nusing Type = List;\nThe Compare parameter is the comparison used to order elements in the typelist.\ntemplate<typename List, typename Element,\ntemplate<typename List, typename Element,\nclass InsertSortedT<List, Element, Compare, false>\ntypename IfThenElse<Compare<Element, Front<List>>::value,\nusing NewHead = IfThenElse<Compare<Element, Front<List>>::value,\nFront<List>>;\ntemplate<typename List, typename Element,\nclass InsertSortedT<List, Element, Compare, true>\ntemplate<typename List, typename Element,\nusing InsertSorted = typename InsertSortedT<List, Element,\ntemplate<typename List, typename Element,\nclass InsertSortedT<List, Element, Compare, false>\n: public IfThenElseT<Compare<Element, Front<List>>::value,\nPushFront<List, Element>,\nFront<List>>>\nlist.\nusing Types = Typelist<int, char, short, double>;\nTypelists provide the ability to describe and manipulate a sequence of types using a\nThere are several ways to produce a typelist of compile-time values.\nvalue) that represents a value of a specific type within a typelist:8\ntypelist/ctvalue.hpp\nUsing the CTValue template, we can now express a typelist containing integer\nusing Primes = Typelist<CTValue<int, 2>, CTValue<int, 3>,\nhomogeneous list of values, described as a Typelist of CTValues:\nusing CTTypelist = Typelist<CTValue<T, Values>…>;\ncreate an entirely new typelist class, Valuelist, that stores the values directly:\ntypelist/valuelist.hpp\nmade Valuelist a proper typelist that can be used with the algorithms defined in\ntypelist/ctvalue17.hpp\noperation to each of the elements in the list.\nusing Type = Typelist<typename MetaFun<Elements>::Type…>;\nThis implementation captures the typelist elements into a parameter pack\nElements and forms a typelist from the results.\nPushBack on Typelist described in Section 24.2.3 on page 555(which requires\nto produce a new typelist.\nusing Type = Typelist<NthElement<Types, Indices>…>;\nproduce a sequence of NthElement types to index into the given typelist,\nTypelist<signed char, short, int, long, long long>;\n// produces Typelist<long long, long, int, short, signed char>\nA nontype typelist containing indices into another list is often called an index list (or\ntypelist/cons.hpp\nAn empty typelist is written Nil, while a single-element list containing int is\ntemplate<typename List>\nusing Type = typename List::Head;\ntemplate<typename List>\nusing Front = typename FrontT<List>::Type;\ntemplate<typename List, typename Element>\nusing Type = Cons<Element, List>;\ntemplate<typename List, typename Element>\nusing PushFront = typename PushFrontT<List, Element>::Type;\nFinally, removing the first element from a recursive typelist extracts the tail of the\nlist:\ntemplate<typename List>\nusing Type = typename List::Tail;\ntemplate<typename List>\nusing PopFront = typename PopFrontT<List>::Type;\ntemplate<typename List>\nWith these typelist operations, we can now use the InsertionSort algorithm\nFinally, the use of variadic templates for typelists fits well with the\ntypelists for solving interesting design problems with template metaprogramming\n2 Note that the typelist could contain types to which sizeof does not apply, such\ncompute the largest type of the typelist.",
      "keywords": [
        "list",
        "typename List",
        "code image typelist",
        "typelist",
        "view code image",
        "type",
        "image typelist",
        "typename",
        "template",
        "view code",
        "code image",
        "element",
        "elements",
        "typename Typelist",
        "code"
      ],
      "concepts": [
        "template",
        "lists",
        "types",
        "values",
        "click",
        "elements",
        "element",
        "recursive",
        "recursion",
        "algorithms"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 23,
          "title": "",
          "score": 0.61,
          "base_score": 0.61,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 17,
          "title": "",
          "score": 0.596,
          "base_score": 0.596,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 49,
          "title": "",
          "score": 0.571,
          "base_score": 0.571,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 14,
          "title": "",
          "score": 0.557,
          "base_score": 0.557,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 10,
          "title": "",
          "score": 0.554,
          "base_score": 0.554,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "typelist",
          "list",
          "typename list",
          "template typename",
          "element"
        ],
        "semantic": [],
        "merged": [
          "typelist",
          "list",
          "typename list",
          "template typename",
          "element"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4469363370433425,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.449021+00:00"
      }
    },
    {
      "chapter_number": 23,
      "title": "Segment 23 (pages 720-752)",
      "start_page": 720,
      "end_page": 752,
      "summary": "Tuples\na tuple containing an int, a double, and a std::string is similar to a struct\ntuples more suitable than structs for use with template metaprogramming techniques.\nstd::string that can be manipulated at compile time, a Tuple<int,\nclass Tuple {\nTuple<int, double, std::string> t(17, 3.14, \"Hello, World!\");\nIt is common to use template metaprogramming with typelists to generate tuples that\nhave created the set of types stored by the tuple with a metaprogram.\nmanipulation of the Tuple class template, which is a simplified version of the class\ntemplate std::tuple.\nTuples contain storage for each of the types in the template argument list.\ntuple t.\nor header of the list) and a tuple containing N − 1 elements (the tail), with a separate\nspecial case for a zero-element tuple.\nThus, a three-element tuple Tuple<int,\ndouble, std::string> can be stored as an int and a Tuple<double,\nThat two-element tuple can then be stored as a double and a\nTuple<std::string>, which itself can be stored as a std::string and a\nTuple<>.\nclass Tuple;\nclass Tuple<Head, Tail…>\nTuple<Tail…> tail;\nTuple() {\nTuple(Head const& head, Tuple<Tail…> const& tail)\nTuple<Tail…>& getTail() { return tail; }\nTuple<Tail…> const& getTail() const { return tail; }\nclass Tuple<> {\nIn the recursive case, each Tuple instance contains a data member head that stores\ntuples/tupleget.hpp\nstatic auto apply(Tuple<Head, Tail…> const& t) {\nstatic Head const& apply(Tuple<Head, Tail…> const& t) {\nauto get(Tuple<Types…> const& t) {\nstatic member function apply() extracts the tail of the current tuple and\ndecrements N to keep looking for the requested element later in the tuple.\ncase (N = 0) returns the head of the current tuple, completing the implementation.\n578 Chapter 25: Tuples\nTuple() {\nTuple(Head const& head, Tuple<Tail…> const& tail)\nindependent values (one for each element) and from another tuple.\nTuple(Head const& head, Tail const&… tail)\nThis enables our initial Tuple example:\nTuple<int, double, std::string> t(17, 3.14, \"Hello, World!\");\nforwarding (Section 15.6.3 on page 280) to initialize the tuple:\n// ERROR: no conversion from Tuple<int, double, string> to long\nTuple<long int, long double, std::string> t2(t);\ntuple.\ntypes of the Tuple it returns, making it far easier to create a tuple from a given set\ntuples/maketuple.hpp\nreturn Tuple<std::decay_t<Types>…>(std::forward<Types>\nTuple<int, double, char const*>\n25.2 Basic Tuple Operations\nTuples are structural types that contain other values.\nTo compare two tuples, it\ntuples/tupleeq.hpp\n// empty tuples are always equivalent\nbool operator==(Tuple<Head1, Tail1…> const& lhs,\nTuple<Head2, Tail2…> const& rhs)\nLike many algorithms on typelists and tuples, the element-wise comparison visits the\nThroughout this chapter, we will be creating new tuple types, so it is useful to be\nprints any tuple whose element types can be printed:\ntuples/tupleio.hpp\nvoid printTuple(std::ostream& strm, Tuple<> const&, bool isFirst\nvoid printTuple(std::ostream& strm, Tuple<Head, Tail…> const& t,\nstd::ostream& operator<<(std::ostream& strm, Tuple<Types…> const&\n25.3 Tuple Algorithms\nelements (through get) as well as to create new tuples (directly or with\nmakeTuple()) and to break a tuple into its head and tail (getHead() and\ntuple algorithms, such as adding or removing elements from a tuple, reordering the\nelements in a tuple, or selecting some subset of the elements in the tuple.\nan algorithm to a tuple may result in a tuple with a completely different type, which\nFor example, reversing a Tuple<int,\ndouble, string> produces a Tuple<string, double, int>.\nstd::vector), tuple algorithms actually require code to execute at run time, and\n25.3.1 Tuples as Typelists\nIf we ignore the actual run-time component of our Tuple template, we see that it\ntuples/tupletypelist.hpp\n// determine whether the tuple is empty:\nstruct IsEmpty<Tuple<>> {\nclass FrontT<Tuple<Head, Tail…>> {\nclass PopFrontT<Tuple<Head, Tail…>> {\nusing Type = Tuple<Tail…>;\nclass PushFrontT<Tuple<Types…>, Element> {\nusing Type = Tuple<Element, Types…>;\nclass PushBackT<Tuple<Types…>, Element> {\nusing Type = Tuple<Types…, Element>;\nTuple and Typelist, so that we easily can deal with the type of tuples.\nTuple<int, double, std::string> t1(17, 3.14, \"Hello, World!\");\nAs we will see shortly, typelist algorithms applied to tuple types are often used to\nhelp determine the result type of a tuple algorithm.\nFor the values of tuples, the ability to add an element to the beginning or end of a\ntuples/pushfront.hpp\npushFront(Tuple<Types…> const& tuple, V const& value)\nreturn PushFront<Tuple<Types…>, V>(value, tuple);\nAdding a new element (called value) onto the front of an existing tuple requires us\nto form a new tuple with value as its head and the existing tuple as its tail.\nresulting tuple type is Tuple<V, Types…>.\nAdding a new element to the end of an existing tuple is more complicated,\ntuples/pushback.hpp\nTuple<V> pushBack(Tuple<> const&, V const& value)\nreturn Tuple<V>(value);\nTuple<Head, Tail…, V>\npushBack(Tuple<Head, Tail…> const& tuple, V const& value)\nreturn Tuple<Head, Tail…, V>(tuple.getHead(),\npushBack(tuple.getTail(),\ntuple containing just that value.\ncurrent element at the beginning of the list (tuple.getHead()) and the result of\nwe have opted to express the constructed type as Tuple<Head, Tail…, V>, we\nnote that this is equivalent to using the compile-time PushBack<Tuple<Head,\ntuples/popfront.hpp\nreturn tuple.getTail();\nTuple<int, double, std::string> t1(17, 3.14, \"Hello, World!\");\n25.3.3 Reversing a Tuple\nThe elements of a tuple can be reversed with another recursive tuple algorithm\ntuples/reverse.hpp\nTuple<> reverse(Tuple<> const& t)\nReverse<Tuple<Head, Tail…>> reverse(Tuple<Head, Tail…> const& t)\nwill produce a Tuple<string, double, int> with the values\ntuples/popback.hpp\nreturn reverse(popFront(reverse(tuple)));\nThe recursive formulation of tuple reversal in the previous section is correct, but it is\ntuples/copycounter.hpp\ntuples/copycountertest.hpp\nIn the ideal implementation of tuple reverse, each element\nposition in the result tuple.\ntuple element:\nTo perform tuple reversal with index lists, we first need a representation of index\nThe index list corresponding to the tuple reversal example above would be\ntuple, using a simple template metaprogram MakeIndexList:3\ntuples/makeindexlist.hpp\nindex-set tuple reverse() algorithm into two parts:\ntuples/indexlistreverse.hpp\nauto reverseImpl(Tuple<Elements…> const& t,\nauto reverse(Tuple<Elements…> const& t)\nthe resulting tuple in one step and therefore copies the tuple elements only a single\nreversed tuple actually contains no code specific to the reverse() operation.\nRather, it simply selects a particular set of indices from an existing tuple and uses\ntuples/select.hpp\nauto select(Tuple<Elements…> const& t,\nTuple<int, double, std::string> t1(42, 7.7, \"hello\"};\ntuples/splat.hpp\nauto splat(Tuple<Elements…> const& t)\nEven complicated tuple algorithms can also be implemented in terms of a template\nsort a tuple based on the sizes of the element types.\nwhich accepts a template metafunction comparing tuple element types as the\ncomparison operation, we could sort tuple elements by size with code like the\ntuples/tuplesorttest.hpp\nauto T2 = sort<SmallerThanT>(t1); // t2 is Tuple<int, long,\ntuple select():7\ntuples/tuplesort.hpp\n// metafunction wrapper that compares the elements in a tuple:\n// sort a tuple based on comparing the element types:\nauto sort(Tuple<Elements…> const& t)\nTuple<Elements…>,\nthe result of the insertion sort is a set of indices into the tuple, which is then provided\nresulting tuple is formed directly, with no extraneous copying of values at run time.\n25.4 Expanding Tuples\nTuples are useful for storing a set of related values together into a single value,\npoint, it may be necessary to unpack such a tuple, for example, to pass its elements\ntuple and pass its elements to the variadic print() operation described in Section\nTuple<std::string, char const*, int, char> t(\"Pi\", \"is roughly\",\nThe following function template apply() accepts a function and a tuple, then\ncalls the function with the unpacked tuple elements:\ntuples/apply.hpp\nauto apply(F f, Tuple<Elements…> const& t)\nthe elements of a tuple into the argument list for its function object argument f.\nTuple<std::string, char const*, int, char> t(\"Pi\", \"is roughly\",\nC++17 provides a similar function that works for any tuple-like type.\n25.5 Optimizing Tuple\nTuple implementation.\n25.5.1 Tuples and the EBCO\nTo improve Tuple’s storage efficiency, we can apply the empty base class\ntail tuple rather than making it a member.\ntuples/tuplestorage1.hpp\nclass Tuple<Head, Tail…> : private Tuple<Tail…>\nTuple<Tail…>& getTail() { return *this; }\nTuple<Tail…> const& getTail() const { return *this; }\nwhich the tuple elements are initialized in constructors.\nthis new formulation of Tuple storage, the tail is in a base class, so it will be\nthat Tuple can inherit from it:\ntuples/tuplestorage2.hpp\nclass Tuple;\nclass Tuple<Head, Tail...>\n: private TupleElt<Head>, private Tuple<Tail...>\nTuple<Tail...>& getTail() { return *this; }\nTuple<Tail...> const& getTail() const { return *this; }\nclass Tuple<> {\nelements of the same type, such as Tuple<int, int>, because the derived-to-\nbase conversion from a tuple to TupleElt of that type (e.g., TupleElt<int>)\nThe last element in the tuple will\ntuples/tupleelt1.hpp\ntuples/tuplestorage3.hpp\nclass Tuple;\nclass Tuple<Head, Tail...>\nTuple<Tail...>\nTuple<Tail...>& getTail() { return *this; }\nTuple<Tail...> const& getTail() const { return *this; }\nclass Tuple<> {\napplying the EBCO in Tuple.\nthe element type when it is safe to do so, without requiring changes to Tuple:\ntuples/tupleelt2.hpp\ntuples/constantget.hpp\nclass Tuple; \nauto get(Tuple<Elements...>& t)\n// inside the recursive case for class template Tuple:\n25.6 Tuple Subscript\ntuple, similarly to the way std::vector defines operator[].10 However,\nunlike std::vector, a tuple’s elements can each have a different type, so a\ntuple’s operator[] must be a template where the result type differs depending on\noperator as a member of Tuple:\nTuple t.\ntuples/literals.hpp\nWith this, we can use tuples as follows:\nTuple construction is one of those template applications that appears to have been\neventually grew into the C++11 std::tuple.\nPrior to C++11, many tuple implementations were based on the idea of a recursive\nseparated the list of types from the list of fields in the tuple, using the concept of\nthe list of types for a tuple, eliminating the need for recursive pairs.\nperformance of tuple and type list algorithms, that compilers include an intrinsic\n8 Another practical impact of this change is that the elements of the tuple will end\n9 It would be more intuitive to simply use the index of the tuple element rather than\nA given Tuple does know, however, how many elements are in its own tail.\nThe tuples developed in the previous chapter aggregate values of some list of types",
      "keywords": [
        "tuple",
        "code image tuples",
        "view code image",
        "image tuples",
        "tail",
        "Head",
        "view code",
        "code image",
        "template",
        "tuple element types",
        "types",
        "elements",
        "typename",
        "class Tuple",
        "element"
      ],
      "concepts": [
        "templates",
        "types",
        "std",
        "value",
        "elements",
        "element",
        "returns",
        "click",
        "classes",
        "time"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 72,
          "title": "",
          "score": 0.849,
          "base_score": 0.699,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 73,
          "title": "",
          "score": 0.687,
          "base_score": 0.687,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 49,
          "title": "",
          "score": 0.665,
          "base_score": 0.665,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 4,
          "title": "",
          "score": 0.62,
          "base_score": 0.62,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 22,
          "title": "",
          "score": 0.61,
          "base_score": 0.61,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "tuple",
          "tuples",
          "tail",
          "head",
          "tuple head"
        ],
        "semantic": [],
        "merged": [
          "tuple",
          "tuples",
          "tail",
          "head",
          "tuple head"
        ]
      },
      "topic_id": 10,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.49286987985384245,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.449108+00:00"
      }
    },
    {
      "chapter_number": 24,
      "title": "Segment 24 (pages 753-783)",
      "start_page": 753,
      "end_page": 783,
      "summary": "field = 42;      // assign value of same type\nfield = \"hello\"; //assign value of different type\nThe variant can be assigned to a value of any of its types.\nvariant currently contains a value of type T using the member function is<T>(),\nThe first major design aspect of our Variant type is how to manage the storage of\nthe active value, that is, the value that is currently stored within the variant.\nthe variant will need to store a discriminator to indicate which of the possible types\nis the type of the active value.\ntemplate<typename… Types>\nclass Variant {\nrequires storage equal to the sum of the sizes of all of the possible value types, even\nvariant into its head and tail, as we did with tuples in Section 25.1.1 on page 576, but\ntemplate<typename… Types>\ntypes, which we use as a buffer to store the active value.\nvariant/variantstorage.hpp\ntemplate<typename… Types>\ntypes.\nalignment suitable for any of the value types.3 The buffer we have computed is\noperators for our Variant template (see Section 26.4.3 on page 617).\nVariant type itself.\nthe shared variant storage through the most-derived type.\noperations needed to operate on the buffer when the variant’s active value is (or will\nbe) of type T:\nvariant/variantchoice.hpp\ntemplate<typename T, typename… Types>\nThe template parameter pack Types will contain all of the types in the Variant.\nvariant/findindexof.hpp\ntemplate<typename… Types>\nclass Variant\nVariant<int, double, std::string>\nThe discriminator values for these three base classes will be 1, 2, and 3, respectively.\nWhen the discriminator member of the variant’s storage matches the\nThe discriminator value 0 is reserved for cases where the variant contains no\nVariant.\ntemplate<typename… Types>\nclass Variant\nVisitResult<R, Visitor, Types const&…> visit(Visitor&& vis)\nVariant();                                         // see\nusing VariantChoice<Types, Types…>::operator=…;\nVariant& operator= (Variant const& source);       // see\nVariant& operator= (Variant&& source);\nVariant& operator= (Variant<SourceTypes…> const& source);\n~Variant() { destroy(); }\nThe most basic queries for a Variant type are to ask it whether its active value is\nof a particular type T and to access the active value when its type is known.\nstores a value of type T:\nvariant/variantis.hpp\ntemplate<typename… Types>\nbool Variant<Types…>::is() const\nGiven a variant v, v.is<int>() will determine whether v’s active value is of\nvariant.\nvariant’s active value is of that type:\nvariant/variantget.hpp\ntemplate<typename… Types>\nT& Variant<Types…>::get() & {\nWhen the variant does not store a value (its discriminator is 0), get() throws an\nOther attempts to get a value from the variant with the wrong type are programmer\nassignment, and destruction when the active value has type T.\nWe begin with initialization of a variant from a value of one of the types it stores.\nFor example, initializing a Variant<int, double, string> from a\naccept a value of type T:\nvariant/variantchoiceinit.hpp\ntemplate<typename T, typename… Types>\n// place value in buffer and set type discriminator:\ntemplate<typename T, typename… Types>\n// place moved value in buffer and set type discriminator:\nvalue of type T.\nset the discriminator value to indicate the (dynamic) type of the variant’s storage.\nOur eventual goal is to be able to initialize a variant from a value of any of its\nVariant<int, double, string> v(\"hello\"); //implicitly converted\nFor a Variant<int, double, string>, the\nVariant(int const&);\nVariant(int&&);\nVariant(double const&);\nVariant(double&&);\nVariant(string const&);\nVariant(string&&);\nWhen Variant is initialized, a value is constructed into its buffer.\nvariant/variantchoicedestroy.hpp\ntemplate<typename T, typename… Types>\nvariant without regard to which type is currently active.\nvariant/variantdestroy.hpp\ntemplate<typename… Types>\n// indicate that the variant does not store a value\nvariant/variantdestroy17.hpp\ntemplate<typename… Types>\n// indicate that the variant does not store a value\nvariant/variantchoiceassign.hpp\ntemplate<typename T, typename… Types>\nauto VariantChoice<T, Types…>::operator= (T const& value) ->\n// assign new value of same type:\n// assign new value of different type:\ntypes\ntemplate<typename T, typename… Types>\nauto VariantChoice<T, Types…>::operator= (T&& value) -> Derived&\n// assign new value of same type:\n*getDerived().template getBufferAs<T>() = std::move(value);\n// assign new value of different type:\ntypes\nAs with initialization from one of the stored value types, each VariantChoice\nprovides an assignment operator that copies (or moves) from its stored value type\ninto the variant’s storage.\nThese assignment operators are inherited by Variant via\nusing VariantChoice<Types, Types…>::operator=…;\nIf the variant already\nstores a value of the given type T (identified by a discriminator match), then the\nassignment operator will copy-assign or move-assign the value of type T directly\nIf the variant does not store a value of type T, assignment requires a two-step\nprocess: Destroy the current value using Variant::destroy(), then initialize a\nnew value of type T using placement new, setting the discriminator appropriately.\nSelf-assignment can occur for a variant v due to an expression like the following:\nvalue throws an exception, what is the state of the variant?\nVariant::destroy() resets the discriminator value to 0.\n0 to indicate that the variant does not store a value.\nto produce a variant without a value.\nattempting to copy a value of a type whose copy constructor throws:\n#include \"variant.hpp\"\nVariant<int, NonCopyable> v(17);\nstd::cout << \"Variant has no value.\" << ’\\n’;\nVariant has no value.\nAccesses to a variant that has no value, whether they are through get() or through\ntemplate<typename… Types>\nbool Variant<Types…>::empty() const {\nmight assume that a value it acquired from the previous state of a Variant object\nWithout mitigation, the net result would be that a program using Variant of types\nis of a specific type and access a value with that type.\npossible types within a variant quickly devolves into a redundant chain of if\nFor example, the following prints the value of a Variant<int,\nTo generalize this to print the value stored in an arbitrary variant requires a\n#include \"variant.hpp\"\ntemplate<typename… Types>\nvoid print(Variant<Types…> const& v)\nVariant<int, short, float, double> v(1.5);\nthe variant’s potential types, this operator() is likely either to be overloaded or\nsteps through the types of the Variant, checking whether the active value has the\nvariant/variantvisitimpl.hpp\nR variantVisitImpl(V&& variant, Visitor&& vis, Typelist<Head,\nif (variant.template is<Head>()) {\nstd::forward<V>(variant).template get<Head>()));\nreturn variantVisitImpl<R>(std::forward<V>(variant),\nThe template parameter R describes the result type of the\nV is the type of the variant and\ntypes in the Variant to effect recursion.\nthe given variant is of type Head: If so, the value is extracted from the variant via\nthe types have matched, the variant does not contain a value,8 in which case the\nvariant/variantvisit.hpp\ntemplate<typename… Types>\nVariant<Types…>::visit(Visitor&& vis)& {\ntemplate<typename… Types>\nVariant<Types…>::visit(Visitor&& vis) const& {\nusing Result = VisitResult<R, Visitor, Types const &…>;\ntemplate<typename… Types>\nVariant<Types…>::visit(Visitor&& vis) && {\nvariant itself, forwarding the visitor, and supplying the complete list of types.\n26.5.1 Visit Result Type\noperator() overloads that produce different result types, a templated\nlambda were passed to the visit() operation of a Variant<int, double>,\nanother Variant<int, double>.\nv.visit<Variant<int, double>>([](auto const& value) {\nTo compute its result type, visit passes all of its template parameters along to\nWhen calling a visitor that may produce different types for each of the variant’s\nvariant/commontype.hpp\nof the types in the variant:\n// the result type produced when calling a visitor with a value\nof type T:\n// the common result type for a visitor called with each of the\nusing Type =\nvisitor with a value of type T.\ntypes.\nIts initial value (the third argument to Accumulate) is the first result type,\nusing Type =\n#include \"variant.hpp\"\nVariant<int, short, double, float> v(1.5);\nauto result = v.visit([](auto const& value) {\n26.6 Variant Initialization and Assignment\nVariants can be initialized and assigned in a variety of ways, including default\nsection details these Variant operations.\nIf it does not, variants may be\nAlternatively, the default constructor could construct a value of some type.\nvariant, we follow the semantics of C++17’s std::variant<> and default-\nconstruct a value of the first type in the list of types:\nvariant/variantdefaultctor.hpp\ntemplate<typename… Types>\nvariants in most uses.\n#include \"variant.hpp\"\nVariant<int, double> v;\nVariant<double, int> v2;\nto determine which type it is currently storing, copy-construct that value into the\nactive value of the source variant, and the copy-assignment operator inherited from\nvariant/variantcopyctor.hpp\ntemplate<typename… Types>\nvisiting the source variant and move-assigning from the source value:\nvariant/variantmovector.hpp\ntemplate<typename… Types>\n*this = std::move(value);\nvariant/variantcopyctortmpl.hpp\ntemplate<typename… Types>\nthe types of the source variant.\nassignment from different variant types:\n#include \"variant.hpp\"\nVariant<int, std::string, double> v2(v1);\nVariant<double, int, std::string> v3(std::move(v1));\nVariant<double, int, std::string> v4(std::move(v1));\nThe Variant assignment operators are similar to the copy and move constructors\nvariant/variantcopyassign.hpp\ntemplate<typename… Types>\nVariant<Types…>& Variant<Types…>::operator= (Variant const&\nincluding a variant type ([BoostVariant]) that influenced the one developed in this\nUnlike our Variant template, std::variant allows multiple identical\ntemplate arguments (e.g., std::variant<int, int>).\n1 Note that the list of potential types is fixed at the time the Variant is declared,\ndiscriminated union would allow values of additional types, not known at the time\ngiven Variant only by the type T is that it prevents duplicate types.\nVariant design.\nperform a copy-construction because the variant initially stores no value.",
      "keywords": [
        "variant",
        "types",
        "code image variant",
        "result type",
        "image variant",
        "view code image",
        "Variant type",
        "Visitor",
        "typename",
        "typename Visitor",
        "view code",
        "template",
        "code image",
        "visitor result type",
        "std"
      ],
      "concepts": [
        "variant",
        "type",
        "template",
        "values",
        "discriminator",
        "discriminated",
        "click",
        "operations",
        "operate",
        "operator"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 74,
          "title": "",
          "score": 0.743,
          "base_score": 0.743,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 17,
          "title": "",
          "score": 0.628,
          "base_score": 0.628,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 51,
          "title": "",
          "score": 0.584,
          "base_score": 0.584,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 75,
          "title": "",
          "score": 0.581,
          "base_score": 0.581,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 23,
          "title": "",
          "score": 0.569,
          "base_score": 0.569,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "variant",
          "types",
          "value",
          "typename types",
          "types variant"
        ],
        "semantic": [],
        "merged": [
          "variant",
          "types",
          "value",
          "typename types",
          "types variant"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4646964280852748,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.449197+00:00"
      }
    },
    {
      "chapter_number": 25,
      "title": "Segment 25 (pages 784-814)",
      "start_page": 784,
      "end_page": 814,
      "summary": "approach to implement templates that enable numeric array operations.\ntemplate might look as follows (SArray stands for simple array):\ntemplate<typename T>\n// assignment operator\nSArray<T>& operator= (SArray<T> const& orig) {\nT const& operator[] (std::size_t idx) const {\nT& operator[] (std::size_t idx) {\n//copy values of another array\ntemplate<typename T>\nSArray<T> operator+ (SArray<T> const& a, SArray<T> const& b)\ntemplate<typename T>\nSArray<T> operator* (SArray<T> const& a, SArray<T> const& b)\ntemplate<typename T>\nSArray<T> operator* (T const& s, SArray<T> const& a)\ntmp1 = 1.2*x;      // loop of 1,000 operations\ntmp2 = x*y         // loop of 1,000 operations\noperations\noperations on small arrays unless special fast allocators are used.\ntemplate<typename T>\nSArray<T>& SArray<T>::operator+= (SArray<T> const& b)\ntemplate<typename T>\nSArray<T>& SArray<T>::operator*= (SArray<T> const& b)\ntemplate<typename T>\nSArray<T>& SArray<T>::operator*= (T const& s)\nNow we need no temporary array, and we have only two memory reads (x[idx]\nbandwidth is the limiting factor for the speed of these sorts of array operations, it is\n27.2 Encoding Expressions in Template Arguments\nthis means that the result of 1.2*x is not a new array but an object that represents\nA_Add<A_Mult<A_Scalar<double>,Array<double>>,\nWe combine a new fundamental Array class template with class templates\ntemplate-id represents the operations involved and the types of the objects to which\na placeholder for a scalar in an array expression.\n27.2.1 Operands of the Expression Templates\n// include helper class traits template to select whether to\n// expression template node either by value or by reference\nT operator[] (std::size_t idx) const {\nT operator[] (std::size_t idx) const {\ncompute the size and the values of the elements for the array resulting from the\nFor operations involving arrays only, the size of the result is the size of either\nHowever, for operations involving both an array and a scalar, the size of the\nresult is the size of the array operand.\nTo distinguish array operands from scalar\nThe A_Scalar template is therefore\ntemplate<typename T>\n// for index operations, the scalar is the value of each\nconstexpr T const& operator[] (std::size_t) const {\nNote that scalars also provide an index operator.\nrepresent an array with the same scalar value for each index.\ntemplate<typename T> class A_Scalar; \ntemplate<typename T>\ntemplate<typename T>\n27.2.2 The Array Type\nmust now create an Array type that controls actual storage and that knows about\nthe expression templates.\nrepresentation of an expression that results in an array.\nArray template as follows:\ntemplate<typename T, typename Rep = SArray<T>>\nclass Array;\nThe type Rep can be SArray if Array is a real array of storage,1 or it can be the\nnested template-id such as A_Add or A_Mult that encodes an expression.\nIn fact, even the definition of the Array template needs no specializations\nby our SArray template, although once the code is understood, it is not hard to add\ntemplate<typename T, typename Rep = SArray<T>>\nclass Array {\nArray (Rep const& rb)\n// assignment operator for same type\nArray& operator= (Array const& b) {\n// assignment operator for arrays of different type\ntemplate<typename T2, typename Rep2>\nArray& operator= (Array<T2, Rep2> const& b) {\ndecltype(auto) operator[] (std::size_t idx) const {\nT& operator[] (std::size_t idx) {\nthe other array is really built on an expression template.\nversion of that operator uses a deduced return type rather than the more traditional\nsubscripting operator returns a temporary value (i.e., a prvalue), which cannot be\nsubscript operator produces a const lvalue, and the deduced return type will be a\n27.2.3 The Operators\nnumeric Array template, except the operators themselves.\noperators only assemble the expression template objects—they don’t actually\nFor each ordinary binary operator, we must implement three versions: array-array,\nexample, the following operators:\noperator+ (Array<T,R1> const& a, Array<T,R2> const& b) {\noperator* (Array<T,R1> const& a, Array<T,R2> const& b) {\n// multiplication of scalar and Array:\nArray<T, A_Mult<T,A_Scalar<T>,R2>>\noperator* (T const& s, Array<T,R2> const& b) {\nreturn Array<T,A_Mult<T,A_Scalar<T>,R2>>\nArray\n// addition of Array and scalar:\noperator for two arrays first creates an A_Add<> object that represents the operator\nand wraps this object in an Array object so that we can use the result as any other\nFor scalar multiplication, we use the A_Scalar template to create the A_Mult\nreturn Array<T,A_Mult<T,A_Scalar<T>,R2>> (…);\nOn first discovery of the expression template idea, the interaction of the various\nArray<double> x(1000), y(1000);\nSo, x and y are arrays with “real” storage and\nthe compiler first applies the leftmost * operation, which is a scalar-array operator.\nOverload resolution thus selects the scalar-array form of operator*:\nArray<T, A_Mult<T,A_Scalar<T>,R2>>\noperator* (T const& s, Array<T,R2> const& b) {\nreturn Array<T,A_Mult<T,A_Scalar<T>,R2>>\nThe operand types are double and Array<double, SArray<double>>.\nArray<double, A_Mult<double, A_Scalar<double>, SArray<double>>>\nThe result value is constructed to reference an A_Scalar<double> object\nNext, the second multiplication is evaluated: It is an array-array operation x*y.\noperator* (Array<T,R1> const& a, Array<T,R2> const& b) {\nThe operand types are both Array<double, SArray<double>>, so the result\nIt is again an array-array operation, and the\noperator +:\noperator+ (Array<T,R1> const& a, Array<T,R2> const& b) {\nThis type is matched to the assignment operator template of the Array template:\ntemplate<typename T, typename Rep = SArray<T>>\nclass Array {\n// assignment operator for arrays of different type\ntemplate<typename T2, typename Rep2>\nArray& operator= (Array<T2, Rep2> const& b) {\nThe assignment operator computes each element of the destination x by applying the\nsubscript operator to the representation of the right side, the type of which is\n27.2.5 Expression Templates Assignments\nIt is not possible to instantiate write operations for an array with a Rep argument that\nis built on our example A_Mult and A_Add expression templates.\nexpression templates for which assignment to the result is possible.\nEnabling this implies that an array built on an expression template behaves like an\nThe expression template component for this is not\nconst versions of the subscript operators are provided, and they may return lvalues\ndecltype(auto) operator[] (std::size_t idx) const {\nT& operator[] (std::size_t idx) {\nwould require that additional subscript operators be added to the Array template.\nOne of these operators could be defined as follows (a corresponding const version\nArray<T, R>::operator[](Array<T2, R2> const& b) {\n27.3 Performance and Limitations of Expression Templates\nTo justify the complexity of the expression template idea, we have already invoked\ngreatly enhanced performance on array-wise operations.\nwith the expression templates, you’ll find that many small inline functions call each\nother and that many small expression template objects are allocated on the call stack.\nThe expression templates technique does not resolve all the problematic situations\ninvolving numeric operations on arrays.\nUnfortunately, the expression template loop updates the\nexpression tree instead of encoding the tree in the type of the expression template.\nIt was known long before expression templates were developed.\noperator: It could not be parameterized for the expression template.\nwork around this consisted of introducing in the expression templates a conversion\noperator to a Copier class parameterized with the expression template but\noperator could refer.\ntemplate<typename T>\nvirtual void copy_to(Array<T, SArray<T>>&) const;\ntemplate<typename T, typename X>\nvirtual void copy_to(Array<T, SArray<T>>&) const {\ntemplate<typename T, typename Rep = SArray<T>>\nclass Array {\nArray<T, Rep>& operator=(CopierInterface<T> const& b) {\nexpression templates, but even so, the resulting performance benefits were\nThe C++ standard library contains a class template valarray that was meant to\ntemplate developed in this chapter.\nwould recognize the array type and use highly optimized internal code for their\noperations.\ntemplate).\nSome time after the expression template technique was discovered, one of\nvalarray essentially into the Array template we developed (with many bells and\nthe arrays with actual storage and the expression template pseudo-arrays were\ndifferent templates.\ncalling foo(1.2*x) forced the conversion for the expression template to an array\ntemplate<typename Rep>\ndouble foo(Array<double, Rep> const&);\nimplementations based on expression templates.\nThis was perhaps the first compiler that made template programming\nExpression templates were first applied primarily for operations on array-like\nlibrary, which is a library to meta-program expression templates, with the goal of\nBoost.Fusion and Boost.Hana, also make advanced use of expression templates.\nDebugging Templates\nTemplates raise two classes of challenges when it comes to debugging them.\na < operator defined on a template type parameter (which is a syntactic constraint),\nrequired in a template library.\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\nno other purpose than to trigger an error if that code is instantiated with template\ntemplate<typename T>\ntemplate<typename T>\nas the code that implements the actual functionality of the template.\nStatic assertions can be used to provide useful error messages when a template\nargument does not satisfy the constraints of a template.\ntemplate<typename T>\ntemplate<typename U> static std::true_type\ntemplate<typename U> static std::false_type\ntemplate<typename T>\nNote that you can also apply them to class templates and use all type traits\ntemplate<typename T>\ncompile for any template arguments that meet the specified constraints for that\ntemplate.\ntemplate<typename T>\nint find(T const* array, int n, T const& value);\ntemplate:\ntemplate<typename T>\nint find(T const* array, int n, T const& value) {\nwhile(i != n && array[i] != value)\nThere are two problems with this template definition, both of which will manifest as\ncompilation errors when given certain template arguments that technically meet the\nArchetypes are user-defined classes that can be used as template arguments to test\ntemplate parameter.\noperations.\nIf instantiation of a template definition with the archetype as its template\noperations not explicitly required by the template.\noperator bool() const;\noperator==(EqualityComparableArchetype const&,\nof the find() template, so we can check whether the implementation of find()\ntemplate int find(EqualityComparableArchetype const*, int,\ntemplate libraries.\nsolves this first problem, and the find() template will successfully compile with\ntemplate<typename T>\nint find(T const* array, int n, T const& value) {\nwhile(i != n && !(array[i] == value))\noperator\noperator!\noperator bool() const;\noperators && and || to help find problems in other template definitions.\ntemplate implementer will want to develop an archetype for every concept identified\nin the template library and then use these archetypes to test each template definition\nTemplates can\nA tracer is a user-defined class that can be used as an argument for a template to\nthe template.",
      "keywords": [
        "view code image",
        "array",
        "template",
        "code image template",
        "view code",
        "code image",
        "array template",
        "typename",
        "scalar",
        "const",
        "expression templates",
        "code",
        "Mult",
        "size",
        "operator"
      ],
      "concepts": [
        "templates",
        "operations",
        "operators",
        "operates",
        "operation",
        "array",
        "click",
        "classes",
        "expression",
        "expressions"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 76,
          "title": "",
          "score": 0.84,
          "base_score": 0.69,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 77,
          "title": "",
          "score": 0.799,
          "base_score": 0.649,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 39,
          "title": "",
          "score": 0.583,
          "base_score": 0.583,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 14,
          "title": "",
          "score": 0.543,
          "base_score": 0.543,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 69,
          "title": "",
          "score": 0.539,
          "base_score": 0.539,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "array",
          "sarray",
          "operator",
          "expression",
          "const"
        ],
        "semantic": [],
        "merged": [
          "array",
          "sarray",
          "operator",
          "expression",
          "const"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.41809123458043657,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.449281+00:00"
      }
    },
    {
      "chapter_number": 26,
      "title": "Segment 26 (pages 815-849)",
      "start_page": 815,
      "end_page": 849,
      "summary": "SortTracer (int v = 0) : value(v), generation(1) {\nfor (int i=0; i<10; ++i) {\nfor (int i=0; i<10; ++i) {\nfunction, we find the following:\nrequires no more functionality than our tracer (e.g., operators == and > were not\n4 Before C++17, we had to initialize the static members outside the class\nobjects exactly once across all files, and define classes, inline functions, and inline\ntime (unlike classes and enumeration types, for example).\n• Classes, class templates, functions, function templates, member functions, and\nmember function templates: The declaration is a definition if and only if the\nincludes unions, operators, member operators, static member functions,\nsuch things (i.e., any class-like and function-like entity).\ndeclaration of a function parameter in a function definition is itself a definition\n• Static data members: The declaration is a definition if and only if it appears\noutside the class or class template of which it is a member or it is declared\ndeclaration following the template<> or template<…> is itself a definition,\ntemplate is a definition only if it includes an initializer.\n• Noninline functions and noninline member functions (including full specializations\nof function templates)\nFor example, a C++ program consisting of the following two translation units is\nint counter;                // ERROR: defined twice (ODR\ndistinct if they appear in distinct translation units; in C++11 and later, such entities\nFor example, the following two translation units can be combined into a\nstatic int counter = 2;  // unrelated to other translation units\nstatic int counter = 0;  // unrelated to other translation units\nfor straightforward code generation.3 This reference can be an access to the value of\na variable, a call to a function, or the address of such an entity.\nexample is invalid C++:\nThis can be the case for class types, inline functions, and inlines\nA class type X (including structs and unions) must be defined in a translation\n• The creation of an object of type X (e.g., as a variable declaration or through a new\ncontains an object of type X is being created.\n• The declaration of a data member of type X.\n• Applying the sizeof or typeid operator to an object of type X.\n• Explicitly or implicitly accessing members of type X.\n• Converting an expression to or from type X using any kind of conversion, or\nconverting an expression to or from a pointer or reference to X (except void*)\n• Assigning a value to an object of type X.\n• Defining or calling a function with an argument or return type of type X.\ndeclaring such a function doesn’t need the type to be defined, however.\nThe rules for types also apply to types X generated from class templates, which\nsuch a type X must be defined.\nInline functions must be defined in every translation unit in which they are used\nJust as with class templates, the use of a function generated from a parameterized\nfunction declaration (a function or member function template, or a member function\nC++ compilers; hence the C++ standard requires that compilers issue some sort of\nPlacing the definitions of entities that can be defined in multiple translation units\nclass X {\nX(int, int);\nD d1;// X(int, int) called by D()\nclass X {\nX(int, int);\nvalue and the address of the resulting expressions is not used (not even implicitly by\nEvery expression has a type,\nwhich describes the static type of the value that its computation produces.\nexpression 7 has type int, as does the expression 5 + 2, and the expression x if x\nis a variable of type int.\nEach expression also has a value category, which\nHistorically, there were only two value categories: lvalues and rvalues.\nexpressions that refer to actual values stored in memory or in a machine register,\nsuch as the expression x where x is the name of a variable.\nFor example, if x is a\nvariable of type int, the following assignment will replace the value of x with 7:\nHowever, when C was standardized in 1989, things changed: While an int\nint const x; // x is a nonmodifiable lvalue\nx = 7;      // ERROR: modifiable lvalue required on the left\nC++ changed things even further: Class rvalues can occur on the left-hand side of\nassignment operator of the class rather than “simple” assignments for scalar types, so\nthey follow the (separate) rules of member function calls.\nExpressions that refer to a variable are not the only kind of lvalue\nAnother class of expressions that are lvalues include pointer dereference\noperations (e.g., *p), which refer to the value stored at the address the pointer\nreferences, and expressions that refer to a member of a class object (e.g., p->data).\nEven calls to functions that return values of “traditional” lvalue reference type\nv.front()           //yields an lvalue because the return type\nis an lvalue reference\nx of integer type) and calls to functions that return a result by value.\nB.1.1 Lvalue-to-Rvalue Conversions\ny when x and y are variables of compatible type, even though the expressions x and\nundergoes an implicit conversion called the lvalue-to-rvalue conversion.\nB.2 Value Categories Since C++11\nWhen rvalue references were introduced in C++11 in support of move semantics, the\ntraditional partitioning of expressions into lvalues and rvalues was no longer\nNote that all expressions are still either lvalues or rvalues, but the rvalues category\nValue Categories since C++11\n• A glvalue is an expression whose evaluation determines the identity of an object,\n• A prvalue is an expression whose evaluation initializes an object or a bit-field, or\n• An lvalue is a glvalue that is not an xvalue.\n• An rvalue is an expression that is either a prvalue or an xvalue.\nsubobject, the type of the glvalue (expression) is called its static type, and the type of\nthe most derived object that base class is part of is called the dynamic type of the\ntypes are identical (i.e., the type of the expression).\nExamples of lvalues are:\n• Expressions that designate variables or functions\n• A call to a function with a return type that is an lvalue reference\n• A call to a function with a return type that is not a reference type\n• A call to a function with a return type that is an rvalue reference to an object type\n• A cast to an rvalue reference to an object type\nNote that rvalue references to function types produce lvalues, not xvalues.\nexpressions, and not values2 or entities.\nFor example, a variable is not an lvalue even\nthough an expression denoting a variable is an lvalue:\nint x = 3;  // x here is a variable, not an lvalue.\nint y = x;  // x here is an lvalue.\nlvalue expression does not\nbecause prvalues are the kinds of expressions that initialize objects (or provide the\nBecause f() in this example has a reference parameter, it expects a glvalue\n• A prvalue is bound to a reference (e.g., that call f(3) above).\n• A member of a class prvalue is accessed.\n• A prvalue appears in a braced initializer list that, for some type X, initializes an\nobject of type std::initializer_list<X>.\n• The sizeof or typeid operator is applied to a prvalue.\nThus, in C++17, the object initialized by a prvalue is always determined by the\nPrior to C++17, prvalues (particularly of class type) always implied a temporary.\n}                  // In C++17, no temporary is created at this\nauto n = make_N(); // ERROR prior to C++17 because the prvalue\nOK since C++17, because n\nPrior to C++17, the prvalue N{} produced a temporary of type N, but compilers were\nHence, C++11\nand C++14 compilers must issue an error for this example.\nWith C++17 the prvalue N itself does not produce a temporary.\nclass X {\nX const c;\nvoid f(X const&);   // accepts an expression of any value\nvoid f(X&&);        // accepts prvalues and xvalues only but is\nf()f(c);            // passes a nonmodifiable lvalue to the\nf(X());             // passes a prvalue (since C++17\nvalue category of any C++ expression.\n• type if x is a prvalue\n• type& if x is an lvalue\n• type&& if x is an xvalue\ndeclared type of a named entity in case where the expression x does indeed name an\nFor example, if the expression\nreflecting the value category of the expression x referring to that variable.\nThus, using type traits for any expression e, we can check its value category as\nif constexpr (std::is_lvalue_reference<decltype((e))>::value) {\nstd::cout << \"expression is lvalue\\n\";\n(std::is_rvalue_reference<decltype((e))>::value) {\nstd::cout << \"expression is xvalue\\n\";\nstd::cout << \"expression is prvalue\\n\";\nB.4 Reference Types\nReference types in C++—such as int&—interact with value categories in two\nThe first is that a reference may limit the value category of an\nFor example, a non-const lvalue reference of type int&\ncan only be initialized with an expression that is an lvalue of type int.\nrvalue reference of type int&& can only be initialized with an expression that is an\nrvalue of type int.\nThe second way in which value categories interact with references is with the\nreturn types of functions, where the use of a reference type as the return type affects\nthe value category of a call to that function.\n• A call to a function whose return type is an lvalue reference yields an lvalue.\n• A call to a function whose return type is an rvalue reference to an object type yields\nan xvalue (rvalue references to function types always result in lvalues).\n• A call to a function that returns a nonreference type yields a prvalue.\nWe illustrate the interactions between reference types and value categories in the\nint&  lvalue();\nint   prvalue();\nboth the value category and type of a given expression can be determined via\nAs described in Section 15.10.2 on page 298, it uses reference types to\ndescribe when the expression is an lvalue or xvalue:\nstd::is_same_v<decltype(lvalue()), int&     // yields true\nstd::is_same_v<decltype(prvalue()), int>    // yields true\nint& lref1 = lvalue();        // OK: lvalue reference can bind\nint& lref3 = prvalue();       // ERROR: lvalue reference cannot\nint& lref2 = xvalue();        // ERROR: lvalue reference cannot\nint&& rref1 = lvalue();       // ERROR: rvalue reference cannot\nint&& rref2 = prvalue();      // OK: rvalue reference can bind\nint&& rref3 = xvalue();       // OK: rvalue reference can bind\n1 User-defined literals can lead to lvalues or rvalues, depending on the return type\n3 In the world of C++11 value categories, the phrase glvalue-to-prvalue conversion\nOverload resolution is the process that selects the function to call for a given call\nIn this example, the function name display_num() is said to be overloaded.\ntypes of the call arguments.\nversion when the function is called with an integer argument and the double\ncalls through pointers to member functions are not subject to overload resolution\n• If necessary, this set is adjusted in various ways (e.g., template argument deduction\n• Any candidate that doesn’t match the call at all (even after considering implicit\nFor example, if it is a deleted function (i.e., one\nOverload resolution ranks the viable candidate functions by comparing how each\nmatches the first argument (the literal 1 of type int) best, whereas the second\nThe parameter has the type of the expression, or it has a type that is\na reference to the type of the expression (possibly with added const and/or\nargument of type int** to a parameter of type int const* const*.\nconversion (such as int to float) or conversion from a derived class to one of\n5. Match with user-defined conversions.\nAn ellipsis parameter can match almost any type.\nHowever, there is one exception: Class types with a nontrivial copy constructor\nThe following contrived example illustrates some of these matches:\nclass X {\nX(int);\nint f3(X);       // #5\nf3(7);           // calls #5 : match with user-defined\nNote that overload resolution occurs after template argument deduction, and this\nIn the context of template argument deduction, recall also that an rvalue reference\nto a template parameter can deduce to either an lvalue reference type (after reference\ncollapsing) if the corresponding argument is an lvalue or to an rvalue reference type\nC.2.1 The Implied Argument for Member Functions\nCalls to nonstatic member functions have a hidden parameter that is accessible in the\ndefinition of the member function as *this.\nFor a member function of a class\nversion of C++ before reference types were part of the language, and by the time\nreference types were added, too much code already depended on this being a\nstr[5] = ’c’; //possibly an overload resolution ambiguity!\nthe argument 5 has type int, and the operator expects an unsigned integer type\n(size_t and std::size_t usually have type unsigned int or unsigned\nlong, but never type int).\nimplicit member function argument), we obtain a pointer type, and now the built-in\nThis built-in operator takes an argument of type\npoor match (by user-defined conversion) for the implied argument, it is a better\nmatch than the operator defined at #1 for the actual subscript!\nwith a ptrdiff_t parameter, or you can replace the implicit type conversion to\nBy default, a nonstatic member function has an implicit *this parameter that is\nan lvalue reference type, but C++11 introduced syntax to make it an rvalue reference\nvoid f1();        // implicit *this parameter is an lvalue\nvoid f2() &&;     // implicit *this parameter is an rvalue\nvoid f3() &;      // implicit *this parameter is an lvalue\nparameter an rvalue reference (with the && suffix) but also to affirm the lvalue\nlvalue reference to non-const type when that reference is the traditional implicit\nS().f1();   // OK: old rule allows rvalue S() to match\n//     lvalue reference type S& of *this\nS().f2();   // OK: rvalue S() matches rvalue reference type\nS().f3();   // ERROR: rvalue S() cannot match explicit\n//        reference type of *this\nC.2.2 Refining the Perfect Match\nFor an argument of type X, there are four common parameter types that constitute a\nvoid report(int const&);  // #2\nversion with const can match rvalues.\nWith the addition of rvalue references in C++11, another common case of two\nperfect matches needing to be distinguished is illustrated by the following example:\npass(x);                // calls #1 , because x is an lvalue\nThis time, the version taking an rvalue reference is considered a better match for\nrvalues, but it cannot match lvalues.\nNote that this also applies to the implicit argument of a member function call:\nmatches can also create an ambiguity if you overload with and without references:\nvoid report(int const&);  // #3\nC.3 Overloading Details\nreally about function overloading in C++.\ntemplate<typename T> int f(T);    // #1\nvoid f(int);                      // #2\ninvolve the return type of the selected function.\ndifferent const and reference qualifiers), first the general rules of overload\nmember functions are defined that accept the same arguments as copy or move\nC.3.2 Conversion Sequences\ncount(object);   // matches with user-defined conversion\nint.\n2. A user-defined conversion of the resulting Base const object to type short 3.",
      "keywords": [
        "int",
        "type",
        "view code image",
        "type int",
        "function",
        "lvalue",
        "reference",
        "lvalue reference type",
        "lvalue reference",
        "expression",
        "view code",
        "translation unit",
        "code image",
        "reference type",
        "int main"
      ],
      "concepts": [
        "types",
        "operator",
        "operations",
        "operation",
        "function",
        "functionality",
        "functions",
        "classes",
        "void",
        "template"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 47,
          "title": "",
          "score": 0.731,
          "base_score": 0.581,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 11,
          "title": "",
          "score": 0.729,
          "base_score": 0.579,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 7,
          "title": "",
          "score": 0.716,
          "base_score": 0.566,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 9,
          "title": "",
          "score": 0.692,
          "base_score": 0.542,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 51,
          "title": "",
          "score": 0.649,
          "base_score": 0.499,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "lvalue",
          "type",
          "reference",
          "rvalue",
          "expression"
        ],
        "semantic": [],
        "merged": [
          "lvalue",
          "type",
          "reference",
          "rvalue",
          "expression"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.446638675295005,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.449370+00:00"
      }
    },
    {
      "chapter_number": 27,
      "title": "Segment 27 (pages 850-883)",
      "start_page": 850,
      "end_page": 883,
      "summary": "• Conversions to type bool\n• Conversions from an arbitrary pointer type to void*\nFirst, conversions to type bool (both from a regular pointer and from a pointer to\nWithin the category of regular pointer conversions, a conversion to type void* is\nseveral different kinds of parameters: initializer_lists, class types\nwith an initializer_list constructor, class types for which the initializer\nclass types whose members can be initialized by the elements of the initializer list.\nvoid f(std::initializer_list<int>) {\nstd::initializer_list values, which involves converting each of the\nelements in the initializer list to the element type of the\ntype int, so no additional conversion is needed.\nconversion from any given element in the initializer list to the element type of the\nvoid ovl(std::initializer_list<int>) {    //#2\nlast is of type int.\nWhen initializing an object of class type with an initializer list, as in the calls to\nstd::initializer_list<T> for some type T (after removing the top-level\narises when a call expression refers to a class type object instead of a function.\nconversion operator to a pointer to a function type (or to a reference to a function\nthe type designated by the conversion function, in addition to parameters with types\n3 Aggregate initialization is only available for aggregate types in C++, which are\nD.1 Using Type Traits\n<type_traits>:\n#include <type_traits>\nThen the usage depends on whether a trait yields a type or a value:\n• For traits yielding a type, you can access the type as follows:\ntypename std::trait<…>::type\n• For traits yielding a value, you can access the value as follows:\nstd::trait<…>::value\nstd::trait<…>()        //implicit conversion to its type\nstd::trait_v<…>        //since C++17\n#include <type_traits>\nstd::add_const<int>::type c = i;        // c is int const\nstatic_assert(std::is_const<decltype(c)>::value, \"c should be\nstd::cout << td::is_same_v<decltype(c), int\nif (std::is_same<decltype(c), int const>{}) {  //implicit\nAll standard type traits yielding a value are derived from an instance of the helper\nusing value_type = T;                           // type of\nconstexpr operator value_type() const noexcept {\nconstexpr value_type operator() () const noexcept {  //since\n• We can use the value_type member to query the type of the result.\ntraits yielding a value are predicates, value_type is often just bool.\n• Objects of traits types have an implicit type conversion to the type of the value\n• In C++14 (and later), objects of type traits are also function objects (functors),\n• The type member just yields the underlying integral_constant instance.\nso that these Boolean traits inherit from std::true_type if a specific property\napplies and from std::false_type if not.\n#include <type_traits>\nusing VT = is_const<MyType>::value_type;   // bool\ntype\n• Type traits apply directly to types, but decltype allows us to also test the\n// check the type of s:\nstd::is_lvalue_reference<decltype(s)>::value        //false\nstd::is_rvalue_reference<decltype(s)>::value        //true, as\nstd::is_lvalue_reference<decltype((s))>::value      //true, s\nstd::is_rvalue_reference<decltype((s))>::value      //false\n• Many traits require complete types (see Section 10.3.1 on page 154).\ntype.\nNote that for types std::size_t and std::ptrdiff_t, is_integral<>\nFor type std::max_align_t, which one of these primary type\nfloating-point or class type).\nexpression is a class type (see Section 15.10.6 on page 310).\nto that type therefore yields true.\nType void\nPointer type (including function pointer\nType of nullptr (since C++14)\nClass/struct or lambda type but not a\nunion type\nUnion type\nFunction type\nstd:: is_void < T >::value\n• Yields true if type T is (cv-qualified) void.\nis_void_v<int>            // yields false\nis_void_v<decltype(f)>    // yields false (f has function type)\nis_void_v<decltype(f())>  // yields true (return type of f() is\n• Yields true if type T is one of the following (cv-qualified) types:\n• Yields true if type T is (cv-qualified) float, double, or long double.\nstd:: is_array < T >::value\n• Yields true if type T is a (cv-qualified) array type.\nrules really has a pointer type.\n• Note that class std::array<> is not an array type, but a class type.\nis_array_v<int[]>          // yields true\nis_array_v<int[5]>         // yields true\nis_array_v<decltype(a)>    // yields false (a has type int*)\nis_array_v<decltype(b)>    // yields false (b has type int*)\nis_array_v<decltype(c)>    // yields false (c has type int*)\nstd:: is_pointer < T >::value\n• Yields true if type T is a (cv-qualified) pointer.\n– parameters declared as arrays (with or without length) or function types\n– pointer-to-member types (e.g., the type of &X::m where X is a class type and m is\n– the type of nullptr, std::nullptr_t\nis_pointer_v<int>                  // yields false\nis_pointer_v<int*>                 // yields true\nis_pointer_v<int* const>           // yields true\nis_pointer_v<int*&>                // yields false\nis_pointer_v<decltype(a)>          // yields true (a has type\nis_pointer_v<decltype(f)>          // yields true (f has type\ntype int*)\n• Yields true if type T is the (cv-qualified) std:: nullptr_t, which is the\ntype std::nullptr_t)\nstd:: is_member_object_pointer < T >::value\nstd:: is_member_function_pointer < T >::value\n• Yields true if type T is a (cv-qualified) pointer-to-member type (e.g., int X::*\nor int (X::*)() for some class type X).\n• Yields true if type T is a (cv-qualified) lvalue or rvalue reference type,\nis_lvalue_reference_v<int&>      // yields true\nis_rvalue_reference_v<int&&>      // yields true\n• Yields true if type T is a (cv-qualified) enumeration type.\nstd:: is_class < T >::value\n• Yields true if type T is a (cv-qualified) class type declared with class or\nstruct, including such a type generated from instantiating a class template.\n• Yields false for unions, scoped enumeration type (despite being declared with\nenum class), std::nullptr_t, and any other type.\nis_class_v<int>                 // yields false\nis_class_v<std::string>         // yields true\nis_class_v<std::string const>   // yields true\nis_class_v<std::string&>        // yields false\nis_class_v<decltype(l1)>        // yields true (a lambda is a\n• Yields true if type T is a (cv-qualified) union, including a union generated from\nstd:: is_function < T >::value\n• Yields true if type T is a (cv-qualified) function type.\nfunction pointer type, the type of a lambda expression, and any other type.\n• Recall that a parameter declared as an function type by language rules really has a\npointer type.\nis_function_v<decltype(f)>        // yields false (f has type\ntype)\nstd:: is_reference < T >::value\n• Yields true if type T is a reference type.\npoint type\nAny type except void, function, or reference\nstd:: is_member_pointer < T >::value\n• Yields true if type T is any pointer-to-member type.\n• Yields true if type T is an arithmetic type (bool, character type, integer type, or\n• Yields true if type T is a fundamental type (arithmetic type or void or\n• Yields true if type T is a “scalar” type.\n• Yields true if type T describes the type of an object.\n• Yields true if type T is a type compound out of other types.\n• Yields true if T is a signed arithmetic type (i.e., an arithmetic type that includes\nnegative value representations; this includes types like (signed) int, float).\n• For type bool, it yields false.\n• For type char, it is implementation defined whether it yields true or false.\n• For all nonarithmetic types (including enumeration types) is_signed yields\n• Yields true if T is an unsigned arithmetic type (i.e., an arithmetic type that does\nnot include negative value representations; this includes types like unsigned\n• For type char, it is implementation defined whether it yields true or false.\n• For all nonarithmetic types (including enumeration types) is_unsigned yields\nstd:: is_const < T >::value\n• Yields true if the type is const-qualified.\n• Note that a const pointer has a const-qualified type, whereas a non-const\npointer or a reference to a const type is not const-qualified.\n• The language defines arrays to be const-qualified if the element type is const-\nAggregate type (since C++17)\ntypes\ntypes\n• Yields true if the type is volatile-qualified.\n• Note that a volatile pointer has a volatile-qualified type, whereas a non-\n• The language defines arrays to be volatile-qualified if the element type is\n• Yields true if T is an aggregate type (either an array or a class/struct/union that\nColl::value_type>)  {\ncoll.emplace_back(typename Coll::value_type{std::forward<T>\n• Requires that the given type is either complete (see Section 10.3.1 on page 154) or\nstd:: is_trivial < T >::value\n• Yields true if the type is a “trivial” type:\n– a trivial class type (a class that has no virtual functions, no virtual base classes, no\n– an array of such types\n• Requires that the given type is either complete (see Section 10.3.1 on page 154) or\n• Yields true if the type is a “trivially copyable” type:\n– a trivial class type (a class that has no virtual functions, no virtual base classes, no\n• Yields the same as is_trivial_v<T> except it can produce true for a class\ntype without a trivial default constructor.\n• Requires that the given type is either complete (see Section 10.3.1 on page 154) or\n• Yields true if the type has a standard layout, which, for example, makes it easier\nto exchange values of this type with other languages.\n– a standard-layout class type (no virtual functions, no virtual base classes, no\n– an array of such types\n• Requires that the given type (for arrays, the basic type) is either complete (see\n• Objects of such types can be copied by copying the underlying storage (e.g., using\n• Requires that the given type is either complete (see Section 10.3.1 on page 154) or\nstd:: is_literal_type < T >::value\n• Yields true if the given type is a valid return type for a constexpr function\n• Yields true if T is a literal type:\n– a class type with at least one constexpr constructor that is not a copy/move\n– an array of such types\n• Requires that the given type is either complete (see Section 10.3.1 on page 154) or\nstd:: is_empty < T >::value\n• Yields true if T is a class type but not a union type, whose objects hold no data.\n• Yields true if T is defined as class or struct with\n• Requires that the given type is complete (see Section 10.3.1 on page 154) if it is a\n• Yields true if T is polymorphic class type (a class that declares or inherits a\n• Requires that the given type is either complete (see Section 10.3.1 on page 154) or\n• Yields true if T is an abstract class type (a class for which no objects can be\n• Requires that the given type is complete (see Section 10.3.1 on page 154) if it is a\n• Yields true if T is an final class type (a class or union that can’t serve as a base\n• For all non-class/union types such as int, it returns false (thus, this is not the\n• Requires that the given type T is either complete (see Section 10.3.1 on page 154)\n• Yields true if type T has a virtual destructor.\n• Requires that the given type is complete (see Section 10.3.1 on page 154) if it is a\n• Yields true if any two objects of type T have the same object representation in\n• Requires that the given type is trivially copyable (see Section D.3.1 on page 712)\n• Yields the alignment value of an object of type T as std::size_t (for arrays,\nuseful, however, because the trait can be passed around as a class type, which is\n• Yields the number of dimensions of an array of type T as std::size_t.\n• Yields 0 for all other types.\narray type does not have an actual array type, and std::array is not an array\ntype either.\n• Yields the size of the first or IDX-th dimension of an array of type T as\nstd:: underlying_type < T >::type\n• Yields the underlying type of an enumeration type T.\n• Requires that the given type is a complete (see Section 10.3.1 on page 154)\n• Requires that all given types are complete (see Section 10.3.1 on page 154) or (cv-\nstd::is_invocable<C>::value         //false\nstd::is_invocable<C,int>::value     //true\nstd::is_invocable<int*>::value      //false\nstd::is_invocable<int(*)()>::value  //true\nexception is thrown), returning a value convertible to type RET_T.\n• Requires that all passed types are complete (see Section 10.3.1 on page 154) or (cv-\nstd::is_invocable_r<bool,C,int>::value               //true\nstd::is_invocable_r<int,C,long>::value               //true\nstd::is_invocable_r<void,C,int>::value               //true\nstd::is_invocable_r<char*,C,int>::value              //false\nstd::is_invocable_r<long,int(*)(int)>::value         //false\nstd::is_invocable_r<long,int(*)(int),int>::value     //true\nstd::is_invocable_r<long,int(*)(int),double>::value  //true\n• Yields the return type of the callable T called for Args….\n• If no call is possible, there is no type member defined, so that using it is an error\n• That is, we can use these traits to get the return type obtained when we call or\n• Requires that all given types are either complete (see Section 10.3.1 on page 154),\n(cv-qualified) void, or an array type of unknown bound.\n(int)>::type;  // C++11\nusing T1 = typename std::result_of<ABC(int)>::type; // ERROR:\nusing T2 = typename std::invoke_result<ABC, int>::type; // OK\nCan initialize type T with\nCan trivially initialize type\nCan initialize type T with\nCan trivially assign type T2\nto type T\ntype (since C++17)\ntype and that operation\nTable D.4 lists the type traits that allow us to check for some specific operations.\nstd:: is_constructible < T, Args… >::value\nstd:: is_trivially_constructible < T, Args… >::value\nstd:: is_nothrow_constructible < T, Args… >::value\n• Yields true if an object of type T can be initialized with arguments of the types",
      "keywords": [
        "type",
        "yields true",
        "yields",
        "std",
        "yields false",
        "Section",
        "int",
        "class type",
        "Pointer",
        "type traits",
        "function",
        "type std",
        "void",
        "const",
        "Args"
      ],
      "concepts": [
        "std",
        "types",
        "classes",
        "values",
        "members",
        "functions",
        "yielding",
        "object",
        "traits",
        "operator"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 79,
          "title": "",
          "score": 0.796,
          "base_score": 0.646,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 28,
          "title": "",
          "score": 0.757,
          "base_score": 0.607,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 18,
          "title": "",
          "score": 0.715,
          "base_score": 0.565,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 64,
          "title": "",
          "score": 0.667,
          "base_score": 0.517,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.663,
          "base_score": 0.513,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "type",
          "yields",
          "yields true",
          "true",
          "true type"
        ],
        "semantic": [],
        "merged": [
          "type",
          "yields",
          "yields true",
          "true",
          "true type"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4342914648114644,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.449456+00:00"
      }
    },
    {
      "chapter_number": 28,
      "title": "Segment 28 (pages 884-918)",
      "start_page": 884,
      "end_page": 918,
      "summary": "• Requires that all given types are either complete (see Section 10.3.1 on page 154),\nis_constructible_v<char const*,std::string>          // false\nis_constructible_v<std::string,char const*>          // true\nis_constructible_v<std::string,char const*,int,int>  // true\ntypes.\n• Yields true if an object of type T can be initialized without any argument for\n• Requires that the given type is either complete (see Section 10.3.1 on page 154),\n• Yields true if an object of type T can be created by copying another value of type\n• Yields false if T is not a referenceable type (either (cv-qualified) void or a\nfunction type that is qualified with const, volatile, &, and/or &&).\n• Provided T is a referenceable type, same as is_constructible<T,T\ntype T, use is_constructible<T,T&&>, and so on.\n• Requires that the given type is either complete (see Section 10.3.1 on page 154),\nis_copy_constructible_v<int>                    // yields true\nis_copy_constructible_v<void>                   // yields false\nis_copy_constructible_v<std::unique_ptr<int>>   // yields false\nis_copy_constructible_v<std::string>            // yields true\nis_copy_constructible_v<std::string&>           // yields true\nis_copy_constructible_v<std::string&&>          // yields false\nis_constructible_v<std::string,std::string>     // yields true\nis_constructible_v<std::string&,std::string&>   // yields true\nis_constructible_v<std::string&&,std::string&&> // yields true\n• Yields true if an object of type T can be created from an rvalue of type T\n• Yields false if T is not a referenceable type (either (cv-qualified) void or a\nfunction type that is qualified with const, volatile, &, and/or &&).\n• Provided T is a referenceable type, same as\nconstructor to be public and not deleted; it also requires that the corresponding type\nis_move_constructible_v<int>                    // yields true\nis_move_constructible_v<void>                   // yields false\nis_move_constructible_v<std::unique_ptr<int>>   // yields true\nis_move_constructible_v<std::string>            // yields true\nis_move_constructible_v<std::string&>           // yields true\nis_move_constructible_v<std::string&&>          // yields true\nis_constructible_v<std::string,std::string>     // yields true\nis_constructible_v<std::string&,std::string&>   // yields true\nis_constructible_v<std::string&&,std::string&&> // yields true\n• Yields true if an object of type FROM can be assigned to an object of type TO\n• Requires that the given types are either complete (see Section 10.3.1 on page 154),\n• Note that is_assignable_v<> for a nonreference, nonclass type as first type\nalways yields false, because such types produce prvalues.\nFor class types, however, rvalues may be assigned to,\ntypes.\nis_assignable_v<int,int>                     // yields false\nis_assignable_v<int&,int>                    // yields true\nis_assignable_v<int&&,int>                   // yields false\nis_assignable_v<int&,int&>                   // yields true\nis_assignable_v<int&&,int&&>                 // yields false\nis_assignable_v<int&,long&>                  // yields true\nis_assignable_v<int&,void*>                  // yields false\nis_assignable_v<void*,int>                   // yields false\nis_assignable_v<void*,int&>                  // yields false\nis_assignable_v<std::string,std::string>     // yields true\nis_assignable_v<std::string&,std::string&>   // yields true\nis_assignable_v<std::string&&,std::string&&> // yields true\n• Yields true if a value of type T can be (copy-)assigned to an object of type T\n• Yields false if T is not a referenceable type (either (cv-qualified) void or a\nfunction type that is qualified with const, volatile, &, and/or &&).\n• Provided T is a referenceable type, same as is_assignable<T&,T\n• To find out whether an rvalue of type T can be copy assigned to another rvalue of\ntype T, use is_assignable<T&&,T&&>, and so on.\n• Note that void, built-in array types, and classes with deleted copy-assignment\n• Requires that the given type is either complete (see Section 10.3.1 on page 154),\nis_copy_assignable_v<int>                    // yields true\nis_copy_assignable_v<int&>                   // yields true\nis_copy_assignable_v<int&&>                  // yields true\nis_copy_assignable_v<void>                   // yields false\nis_copy_assignable_v<void*>                  // yields true\nis_copy_assignable_v<std::string>            // yields true\nis_copy_assignable_v<std::unique_ptr<int>>   // yields false\n• Yields true if an rvalue of type T can be move-assigned to an object of type T\n• Yields false if T is not a referenceable type (either (cv-qualified) void or a\nfunction type that is qualified with const, volatile, &, and/or &&).\n• Provided T is a referenceable type, same as\n• Note that void, built-in array types, and classes with deleted move-assignment\n• Requires that the given type is either complete (see Section 10.3.1 on page 154) or\nis_move_assignable_v<int>                    // yields true\nis_move_assignable_v<int&>                   // yields true\nis_move_assignable_v<int&&>                  // yields true\nis_move_assignable_v<void*>                  // yields true\nis_move_assignable_v<std::string>            // yields true\nis_move_assignable_v<std::unique_ptr<int>>   // yields true\n• Yields true if an object of type T can be destroyed (without using a nontrivial\n• Always yields true for references.\n• Always yields false for void, array types with unknown bounds, and function\ntypes.\n• Requires that the given type is either complete (see Section 10.3.1 on page 154),\n• Yields true if an expression of type T1 can be swap()’ed with an expression of\ntype T2 except that reference types only determine the value category of the\n• Requires that the given types are either complete (see Section 10.3.1 on page 154),\n• Note that is_swappable_with_v<> for a nonreference, nonclass type as first\nor second type always yields false, because such types produce prvalues.\nis_swappable_with_v<int&,int&>                   // yields true\nis_swappable_with_v<int&,void*>                  // yields false\nis_swappable_with_v<void*,int>                   // yields false\nis_swappable_with_v<void*,int&>                  // yields false\nis_swappable_with_v<std::string,std::string>     // yields false\nis_swappable_with_v<std::string&,std::string&>   // yields true\nis_swappable_with_v<std::string&&,std::string&&> // yields false\n• Yields true if lvalues of type T can be swapped (with the guarantee that no\n• Provided T is a referenceable type.\n• Yields false if T is not a referenceable type (either (cv-qualified) void or a\nfunction type that is qualified with const, volatile, &, and/or &&).\n• Requires that the given type is a complete type (Section 10.3.1 on page 154), (cv-\nis_swappable_v<int>                    // yields true\nis_swappable_v<int&>                   // yields true\nis_swappable_v<int&&>                  // yields true\nis_swappable_v<std::string&&>          // yields true\nis_swappable_v<std::unique_ptr<int>>   // yields true\nclass types.\n• Yields true if T1 and T2 name the same type including cv-qualifiers (const and\n• Yields true if a type is a type alias of another.\n• Yields true if two objects were initialized by objects of the same type.\n• Yields false for the (closure) types associated with two distinct lambda\nis_same_v<A,int>                       // yields true\n• Yields true if B is a base class of D or B is the same class as D.\n• It doesn’t matter whether a type is cv-qualified, private or protected inheritance is\n• Yields false if at least one of the types is a union.\n• Requires that type D is either complete (see Section 10.3.1 on page 154), has the\nis_base_of_v<B, D1>        // yields true\nis_base_of_v<B const, DD>  // yields true\nis_base_of_v<B, DD const>  // yields true\nis_base_of_v<B, B const>   // yields true\nis_base_of_v<B&, DD&>      // yields false (no class type)\nis_base_of_v<B[3], DD[3]>  // yields false (no class type)\nis_base_of_v<int, int>     // yields false (no class type)\n• Yields true if expression of type FROM is convertible to type TO.\n• A reference on top of type FROM is only used to determine the value category of\nis_constructible_v<C,C>   // yields true\n• Requires that the given types are either complete (see Section 10.3.1 on page 154),\nD.4 Type Construction\nThe traits listed in Table D.6 allow us to construct types from other types.\nCorresponding type without const\nCorresponding type without const and\nCorresponding const type\nCorresponding const volatile type\ntype\ntype otherwise)\nTraits for Type Construction\nstd:: remove_const < T >::type\nstd:: remove_volatile < T >::type\nstd:: remove_cv < T >::type\n• Yields the type T without const or/and volatile at the top level.\n• Note that a const pointer is a const-qualified type, whereas a non-const\npointer or reference to a const type is not const-qualified.\narray and function types to corresponding pointer types (see Section D.4 on page\nstd:: add_const < T >::type\nstd:: add_volatile < T >::type\nstd:: add_cv < T >::type\n• Yields the type of T with const or/and volatile qualifiers added at the top\n• Applying one of these traits to a reference type or a function type has no effect.\nstd:: make_signed < T >::type\nstd:: make_unsigned < T >::type\n• Yields the corresponding signed/unsigned type of T.\n• Requires that T is an enumeration type or a (cv-qualified) integral type other than\n• Applying one of these traits to a reference type or a function type has no effect,\nstd:: remove_reference < T >::type\n• Yields the type the reference type T refers to (or T itself if it is not a reference\ntype).\n• Note that a reference type itself is not a const type.\napplying type construction traits matters:13\narray and function types to corresponding pointer types (see Section D.4 on page\nstd:: add_lvalue_reference < T >::type\nstd:: add_rvalue_reference < T >::type\n• Yields an lvalue or rvalue reference to T if T is a referenceable type.\n• Yields T if T is not referenceable (either (cv-qualified) void or a function type\n• Note that if T already is a reference type, the traits use the reference collapsing\nstd:: remove_pointer < T >::type\n• Yields the type the pointer type T points to (or T itself if it is not a pointer type).\nstd:: add_pointer < T >::type\n• Yields the type of a pointer to T, or, in the case of a reference type T, the type of a\n• Yields T if there is no such type (applies to cv-qualified function types).\nstd:: remove_extent < T >::type\nstd:: remove_all_extents < T >::type\n• Given an array type, remove_extent produces its immediate element type\nan array type).\ntype either.\nstd:: decay < T >::type\n• Yields the decayed type of T.\n• In detail, for type T the following transformations are performed:\n– Otherwise, if the result is a function type, the type yielded by add_pointer for\nthat function type is produced (see Section 11.1.1 on page 159).\n• decay<> models by-value passing of arguments or the type conversions when\ntype of another function.\nenable_if<B, T=void > Yields type T only if bool B is true\nYields type T if bool B is true and type F\nOther Type Traits\nstd:: enable_if < cond >::type\nstd:: enable_if < cond, T >::type\n• Yields void or T in its member type if cond is true.\n• Because the type member is not defined when the cond is false, this trait can\nstd:: conditional < cond, T, F >::type\nstd:: common_type < T… >::type\n• Yields the “common type” of the given types T1, T2, …, Tn.\nare of those types U and V (with reference types used only to determine the value\noverridden by user specialization of std::common_type<U, V> (in the C++\n• If no type is given or no common type exists, there is no type member defined, so\n• While processing the common type, the passed types are decays, so that the trait\nalways yields a decayed type (see Section D.4 on page 731).\nusing type = std::decay_t<decltype(true ?\nstd:: aligned_union < MIN_SZ, T… >::type\n– std::alignment_of_v<type>::value (see Section D.3.1 on page 715)\n• Requires that at least one type is provided.\nvalue for the alignment instead of the type.\nstd:: aligned_storage < MAX_TYPE_SZ >::type\nstd:: aligned_storage < MAX_TYPE_SZ, DEF_ALIGN >::type\n• Yields a plain old data type (POD) usable as uninitialized storage that has a size to\n• Requires that MAX_TYPE_SZ is greater than zero and the platform has at least one\nD.6 Combining Type Traits\n• If you have to deal with traits that might fail (e.g., due to incomplete types).\n• If you want to combine type trait definitions.\nThe type traits std::conjunction<>, std::disjunction<>, and\nexample, if incomplete types are used:\nis_constructible<X,int> already yields true:\nexisting type traits.\n• Yields whether the passed Boolean trait B yields false.\nyields an “object” (rvalue reference) of a type without\n• Yields an “object” or function of any type without calling any constructor or\n• If T is void, the return type is void.\n• This can be used to deal with objects or functions of any type in unevaluated\n– If T is a plain type or an rvalue reference, it yields a T&&.\ncommon_type<> type trait in Section D.5 on page 732 for examples using it.\ntype.\nstd::true_type and std::false_type did exist\nHowever, because some type traits currently have requirements that are stronger\n4 Before C++14, the only exception was the type of nullptr,\nstd::nullptr_t, for which all primary type category utilities yielded false,\nPrior to C++14, aggregate class types could not have default member\n• Section 6.5 on page 103 illustrates how to use requirements and concepts to enable\n• Section 18.4 on page 377 shows how to use concepts to specify and require\nEqualityComparable<typename Seq::value_type>\ntypename Seq::value_type const& val)\nrequirements produce true values can the template be selected for the call and be\nThus, concepts can impose a relationship between type parameters.\nrequires EqualityComparable<typename Seq::value_type>\ntypename Seq::value_type const& val)\ntypes.\nConcepts are much like constexpr variable templates of type bool, but the type\nestablish whether type T is indeed comparable using the < operator, but the concepts\nRequires expressions can also express the need for associated types.\ntypes.\nSo the phrase typename type; expresses the requirement that type exists (this is\ncalled a type requirement).\nexample, require that there exist a type IteratorFor<Seq> instead, and that\nrequire not only that Seq::iterator be a type, but also that that type satisfies the\nStringLike<T>, and we decide to write templates to print out values of types of\nenvision types that satisfy both concepts, but we expect that to be rare enough that\ngiven a concept C and some types T1, T2, … that model the concept, we can\nWhen designing concepts, it is therefore recommended to also design simple types\n• Do interfaces and/or algorithms need to copy and/or move objects of the types\nand U are both std::string or when one type is a pointer and the other an",
      "keywords": [
        "yields true",
        "yields",
        "yields int const",
        "yields int",
        "type",
        "Yields false",
        "yields int remove",
        "view code image",
        "int",
        "std",
        "int const",
        "Section",
        "view code",
        "yields true std",
        "code image"
      ],
      "concepts": [
        "std",
        "types",
        "templates",
        "requires",
        "requirements",
        "requiring",
        "concepts",
        "click",
        "traits",
        "yields"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 80,
          "title": "",
          "score": 0.9,
          "base_score": 0.75,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 81,
          "title": "",
          "score": 0.862,
          "base_score": 0.712,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 79,
          "title": "",
          "score": 0.816,
          "base_score": 0.666,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.773,
          "base_score": 0.623,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 18,
          "title": "",
          "score": 0.76,
          "base_score": 0.61,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "yields",
          "type",
          "yields true",
          "true",
          "yields false"
        ],
        "semantic": [],
        "merged": [
          "yields",
          "type",
          "yields true",
          "true",
          "yields false"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.49340695498613757,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.449543+00:00"
      }
    },
    {
      "chapter_number": 29,
      "title": "Segment 29 (pages 919-949)",
      "start_page": 919,
      "end_page": 949,
      "summary": "template<typename T> requires LessThanComparable<T>\ntemplate<typename STR>\n: name(std::forward<STR>(n)) f{\ntemplate<typename Seq>\ntemplate<typename T>\ntemplate<typename T, typename U>\ntemplate<Sequence Seq>\nrequires EqualityComparable<typename Seq: :value_type>\ntemplate<typename T> concept LessThanComparable =...\ntemplate<typename T>\nconcept LessThanComparable = requires(T x, T y) {\ntemplate<typename T>\nconcept Swappable = requires(T x, T y) f\ntemplate<typename Seq>\nconcept Sequence = requires(Seq seq) {\ntemplate<typename Seq>\nconcept Sequence = requires(Seq seq) {\nrequires Iterator<typename Seq: :iterator>;\ntemplate<typename I>\ntemplate<typename T>\ntemplate<Forwardlterator T, typename D>\ntemplate<BidirectionalIterator T, typename D>\ntemplate<typename T>\ntemplate<typename T, typename U>\nrequires (T x, Uy) f\ntemplate<typename T>\nconcept HasPlus = requires (T x, T y) {\ntemplate<typename T> int f(T p) requires HasPlus<T> {\ntemplate<typename T>\nconcept HasMult = requires (T x, T y) {\ntemplate<typename T> int f(T p) requires HasMult<T> {\nthe topic of C++ templates.\nactual list of links for this book at the following site (and we expect this site to be\nBefore listing the books, articles, and Web sites, we introduce the more interactive\nand C++ (in various languages).\nhttps://stackoverflow.com/questions/tagged/c%2b%2b\nhttps://stackoverflow.com/questions/tagged/c%2b%2b%20templates\nhttps://www.quora.com/topic/C++-programming-language\nabout C++.\nBooks and Web Sites\nC++ Template Metaprogramming – Concepts, Tools, and Techniques from Boost\nGeneric Programming and the STL – Using and Extending the C++ Standard\nhttp://www.boost.org/libs/concept_check/concept_check.htm",
      "keywords": [
        "typename Seq",
        "Seq",
        "typename",
        "template",
        "requires",
        "iterator",
        "concept",
        "Seq const",
        "std",
        "Sequence Seq",
        "programming",
        "concept Sequence",
        "Web sites",
        "Boost",
        "void"
      ],
      "concepts": [
        "template",
        "requires",
        "programming",
        "concepts",
        "std",
        "void",
        "boost",
        "forums",
        "blitz",
        "organization"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 56,
          "title": "",
          "score": 0.86,
          "base_score": 0.71,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 65,
          "title": "",
          "score": 0.831,
          "base_score": 0.681,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 48,
          "title": "",
          "score": 0.78,
          "base_score": 0.63,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 66,
          "title": "",
          "score": 0.768,
          "base_score": 0.618,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 71,
          "title": "",
          "score": 0.731,
          "base_score": 0.581,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "seq",
          "requires",
          "concept",
          "typename seq",
          "template typename"
        ],
        "semantic": [],
        "merged": [
          "seq",
          "requires",
          "concept",
          "typename seq",
          "template typename"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5145102937651996,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.449663+00:00"
      }
    },
    {
      "chapter_number": 30,
      "title": "Segment 30 (pages 950-980)",
      "start_page": 950,
      "end_page": 980,
      "summary": "http://www.boost.org/libs/iterator\nhttp://www.boost.org/libs/utility/operators.htm\nhttp://www.boost.org/libs/type_traits\nhttp://www.boost.org/libs/variant\n[C++98]\n[C++03]\n[C++11]\n[C++14]\n[C++17]\nKrzysztof Czarnecki and Ulrich W.\nProposal to Add Template Aliases to C++\nEisenecker, Frank Blinn, and Krzysztof Czarnecki\nMixin-Based Programming in C++\nVariadic Templates\nFunction Overloading Based on Arbitrary Properties of Types\nThe C++ Standard Library – A Tutorial and Reference (2nd edition)\nAccelerated C++ – Practical Programming by Example\nC++ Library Issue 181\nInside the C++ Object Model\nCounting Objects In C++\nMTL, The Matrix Template Library\nNewMat10, A Matrix Library in C++\nMixin-Based Programming in C++\nThe Standard Template Library – HP Laboratories Technical Report 95-11(R.1)\nThe C++ Programming Language (Special Edition)\nBjarne Stroustrup’s C++ Glossary\nExceptional C++ – 47 Engineering Puzzles, Programming Problems, and Solutions\nMore Exceptional C++ – 40 New Engineering Puzzles, Programming Problems, and\nC++ Templates: The Complete Guide\nC++ Solutions\nUsing C++ Template Metaprograms\nC++ Report, May 1995\nof a function (or operator) in namespaces and classes that are in some way associated\nalias template\nactual type aliases can be generated by substituting the template parameters by\nAn alias template can be a class member.\nSee also template argument.\nclass\nany object of that type.\nIn C++, classes are structures with\nclass template\nactual classes can be generated by substituting the template parameters by specific\nClass templates are sometimes called parameterized classes.\nclass type\nA C++ type declared with class, struct, or union.\nIn C++, collection classes are also\nAny type that is not incomplete: a defined class, an array of complete elements and\nA named set of constraints that can be applied to one or more template parameters.\nA member function that can be called for constant and temporary objects because it\nA special member function that defines how an object can implicitly (or explicitly)\nwhere a class X derives from a base class that has X as a template argument.\nliteral \"Hello\" has type char const[6], but in many C++ contexts, it is\nThe process that implicitly determines template arguments from the context in which\ntemplates are used.\nThe complete term is template argument deduction.\nFor class\ntypes and function definitions, this amounts to declarations that include a brace-\ndependent base class\nA base class that depends on a template parameter.\naccess members of dependent base classes.\nA name the meaning of which depends on a template parameter.\nA<T>::x is a dependent name when A or T is a template parameter.\ntype that depends on a template parameter.\ndependent if T is a template parameter.\nThe name of a template parameter is not\ncharacter in C++ code.\ntemplate.\nalternative definition still depends on one or more template parameters, it is called a\nexpression template\nA class template used to represent a part of an expression.\nThe template itself\nThe template parameters stand for the kinds\ntemplate parameter.\nfunction object\nIn C++, these are pointers to\nfunctions, classes with an overloaded operator() (see functor), and classes with\nfunction template\nactual functions can be generated by substituting the template parameters by specific\nNote that a function template is a template and not a function.\ntemplates are sometimes called parameterized functions.\nAn object of a class type with an overloaded operator(), which can be called\nSuch files often contain declarations of variables and functions that are referred to\nfrom more than one translation unit, as well as definitions of types, inline functions,\ntemplates, constants, and macros.\nstandardization of C++.\nA class that is declared but not defined, an array of incomplete element type or of\nexample, to initialize members and base classes in constructor definitions.\nFor class templates, the\nname of the template is treated within the scope of the template as a class name if the\nname is not followed by a template argument list.\nThe term instance has two meanings in C++ programming: The meaning that is\nFor example, in C++, std::cout is an instance of the\nintended in this book) is a template instance: a class, a function, or a member\nfunction obtained by substituting all the template parameters by specific values.\nThe replacement of the template parameters in a template definition to create a\nconcrete entity (function, class, variable, or alias).\ntemplate but not its definition is substituted, the term partial template instantiation is\n(object) of a class is not used in this book (see instance).\ndevelop C++.\ndata member, including any such things generated from a template, as visible to the\nmember class template\nA construct that represents a family of member classes.\nIt is a class template declared\ninside another class or class template definition.\nIt has its own set of template\nparameters (unlike a member class of a class template).\nmember function template\ntemplate parameters (unlike a member function of a class template).\nto a function template, but when all the template parameters are substituted, the\ntemplates cannot be virtual.\nmember template\nA member class template, member function template, or static data member\ntemplate.\nThe phrase used in this book to refer to the language as standardized in C++11 or\nA name that is not dependent on a template parameter.\ndefinitions that appear in a C++ program.\nSee also Appendix C.\nFor macro parameters and template parameters, the\nSee also argument and template\nA class template or a class nested in a class template.\nbecause they do not correspond to a unique class until the template arguments have\nA function or member function template or a member function of a class template.\nmember function) until the template arguments have been specified.\nof a template.\nalternative definition still depends on template parameters.\nexists only for class templates.\nwithout certain C++ features (like virtual member functions, access keywords, and\nFor example, every ordinary C struct is a POD.\ntemplate (or a member of a template) is conceptually expanded by substituting\ntemplate parameters with template arguments.\nA class or class template the members of which describe configurable behavior for a\nPolicies are normally passed as template arguments.\ncalled policy templates or just policies.\nSee also traits template.\nIn C++, the traditional object-oriented concept of polymorphism\nfunctions that are overridden in derived classes.\nIn addition, C++ templates enable\nin C++.\nprimary template\nA template that is not a partial specialization.\nAny rvalue before C++11 is a prvalue in C++11.\ncalled a rvalue before C++11 is called a prvalue in C++11.\nsubstitute template arguments in invalid ways.\nOther templates in an overload set\nThe result of substituting template parameters with actual values.\nstatic data member template\nA variable template that is a member of a class or class template.\nThe process of replacing template parameters in templated entities by actual types,\nvalues, or templates.\ntemplate\nA construct that represents a family of types, functions, member functions, or\nIt specifies a pattern from which actual types, functions, member\nfunctions, or variables can be generated by substituting the template parameters by\nIn this book, the term does not include functions, classes, static data\na class template.\nSee alias template, variable template, class template, parameterized\nclass, function template, and parameterized function.\ntemplate argument\nThe “value” substituted for a template parameter.\nalthough certain constant values and templates can be valid template arguments too.\ntemplate argument deduction\ntemplate-id\nThe combination of a template name followed by template arguments specified\ntemplate parameter\nThe most common kind of template parameter\nvalues of a certain type, and template template parameters represent type templates.\ntemplated entity\nA template or an entity defined or created in a template.\nlike an ordinary member function of a class template or the closure type of a lambda\nexpression appearing in a template.\ntraits template\nA class template with members that describe characteristics (traits) of the template\ntemplate parameters.\nA generalization of the C struct concept such that members can be accessed by\nThe name lookup mechanism used for names in templates.\nthe processing of the template definition, and (2) the instantiation of the template for\nspecific template arguments.\ndeclaration, or the instantiation of an alias template.\ntype template\nA class template, member class template, or alias template.\ntemplate parameter.\ntoo universal, the C++17 standard introduced the term forwarding reference instead.\ncalled with one argument or a conversion function.\nconversion function is declared with the keyword explicit, the type conversion\nC++11 introduced alternative categories: glvalues\nin C++11 rvalues serve as a general category for both xvalues and prvalues (before\nC++11, rvalues were what prvalues are in C++11).\nvariable template\nsubstituting the template parameters by specific entities.\nin template argument list 50\ntemplate 43\nalias template 39, 312, 446\nfor function templates 192\nfor template template parameters 85, 197\ntype arguments 194\nfor class templates 40\nfor function templates 10\nas parameter in templates 71\nas template parameter 186\nas template 79\nas template parameter 50, 296\nbase class\nC++03 752\nC++11 753\nC++14 753\nC++17 753\nC++98 752\nas template argument 49, 354\nclass 4, 185, 760\nas template argument 49\ntemplate see class template\nclass template 23, 151, 760\nclass type 151, 760\ndisable function templates 475\nas template parameter 186\nas template parameters 356\nfor variable templates 473\nwith templates 74\nCoplien, James 515\nas template 79\nof template parameters 186\nof class template 24\ndecltype(auto) 162, 301\nas template parameter 302\nclass template arguments 40\nfunction template arguments 7",
      "keywords": [
        "Template",
        "class template",
        "template parameters",
        "Function",
        "member class template",
        "template arguments",
        "member function template",
        "function template",
        "member function",
        "Type",
        "parameters",
        "member",
        "base class",
        "Programming",
        "functions"
      ],
      "concepts": [
        "template",
        "classes",
        "type",
        "function",
        "functions",
        "parameters",
        "objects",
        "argument",
        "arguments",
        "special"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 10,
          "title": "",
          "score": 0.802,
          "base_score": 0.652,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 16,
          "title": "",
          "score": 0.775,
          "base_score": 0.625,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 20,
          "title": "",
          "score": 0.765,
          "base_score": 0.615,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 21,
          "title": "",
          "score": 0.751,
          "base_score": 0.751,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 19,
          "title": "",
          "score": 0.726,
          "base_score": 0.576,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "class",
          "function",
          "parameters",
          "template parameters",
          "member"
        ],
        "semantic": [],
        "merged": [
          "class",
          "function",
          "parameters",
          "template parameters",
          "member"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4955180157707608,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.449755+00:00"
      }
    },
    {
      "chapter_number": 31,
      "title": "Segment 31 (pages 981-1014)",
      "start_page": 981,
      "end_page": 1014,
      "summary": "guided type 42, 314\nfor template template parameter 197\nfor class templates 36\nfor function templates 13\nfor templates 190\nfor template template parameters 85\nof class types 668\nof templates 230\nof types 228\ndependent type 223, 228\ndesign pattern 379\ndetermining types 448, 460\nfor explicit instantiation 260\ndiscriminated union 603\nas template argument 49, 356\nclass templates 477\nentity templated 181\nerasure of types 523\nexplicit instantiation\nexplicit template argument 233\nexported templates 266\ninstantiation-dependent 234\ntype-dependent 217, 233\nexpression template 629, 762\nfalse_type 413, 699\nas template argument 49, 356\nclass templates 75\nfunction 211\nfunction versus function template 499\ntemplate 213\nof class templates 338\nof function templates 342\nof member function template 78\nof member templates 344\nfunction 517, 519\nfunction\nas template parameter 186\nfor types 401\ntemplate see function template\nfunction object type 157\nfunction template 3, 151, 763\ndefault template argument 13\nversus friend function 499\nfundamental type\nguided type 42, 314\nincomplete type 154, 171, 764\nof fundamental types 68\ninstantiated specialization 152\ninstantiation 5, 6, 152, 243, 764\ninstantiation-dependent expression 234\ninstantiation-safe template 482\ninstantiation time 6\nis_function 706\nis_literal_type 713\nis_member_function_pointer 705\niterated instantiation 259\nprimary type category 702\nlazy instantiation 245\nlevels of instantiation 542\nlevels of instantiation 542\nliteral type 391\nlookup\nmake_signed 729\nmake_unsigned 729\nmax_align_t and type traits 702\nlevels of instantiation 542\nalias template 178\nclass template 74, 178, 765\nfunction template 74, 178\nof current instantiation 240\ntemplate see member template\ntype check 431\nmember function 181\nas template 74, 178\ntemplate 151, 765\nmember function template\nmember template 74, 178, 765\nversus template template parameter 398\nfor unit types 534\non types 531\nmotivation of templates 1\nas template 79\ndependent of templates 230\ndependent of types 228\nlookup 215, 217\nof std::type_info 138\nnamed template argument 358, 512\ntemplate 231\nnarrowing nontype argument for templates\nas template 74, 178\nversus reference 115, 270, 638, 687\noverloading with template 332\nfor templates 194\nnumeric_limits 462\non-demand instantiation 243\nin template argument list 50\norder of header files 141\nclass templates 359\nof function templates 326\ntemplates and nontemplates 332\nfor variadic templates 335\nfunction 186\nof class templates 288\ntemplate template parameter 83, 187\ntype 185\nfunction 204\ntemplate 188, 200\nwith deduced type 298, 569\nmaximum munch 226\nfor function templates 356\nof class templates 347\nplaceholder class type 314\nplaceholder type 422\nas template parameter 50\ndecltype(auto) 301\nplacement new and launder() 617\nconversion to void* 689\npoint of instantiation 250, 668, 766\npop_back() for vectors 23\nprimary template 152, 184, 348, 767\nprimary type (category) 702\nptrdiff_t and type traits 702\nof array types 453\nof class types 456\nof enumeration types 457\nof function types 454\nof fundamental types 448\nof pointer-to-member types 454\nof pointer types 451\nof reference types 452\nqueried instantiation 257\nread-only parameter types 458\nas template argument 270\nas template parameter 167, 187\ncheck for type members 431\nrestricted template expansion 497\nresult type traits 413\nreturn type\ndecltype(auto) 301\nsemantic transparency 325\nreference types 432\nsize_t type and type traits 702\ninstantiated 152\nof member function template 78\npartial for function templates 356\nspecial member function 79\nsplit loop 634\nstandard-layout type 712\nStandard Template Library 241, 380, see STL\nin templates 6\nstatic data member template 768\nand reference template parameters 271\nas template argument 49, 354\nliteral as template parameters 271\nas parameter in templates 71\nversus class 151\nclass templates 479\ntemplate 768\nargument 155, see template argument\ninstantiation 152, 243, see\ninstantiation\nmember template 74, 178\nof template 28\ntype arguments 194\n.template 79, 231\n->template 80, 231\n::template 231\ntemplate argument 155, 192, 768\ntemplate argument list\ntemplate class 151, see class template\ntemplated entity 181, 768\ntemplate function 151, see function template\ntemplate-id 151, 155, 192, 216, 231, 768\ntemplate member function 151, see member function template\ntemplate parameter 768\nfunction 186\ntemplate parameter pack 188, 200\nwith deduced type 298, 569\ntemplate template argument 85, 197\ntemplate template parameter 83, 187, 398\nversus member template 398\ntemporary materialization 676\nmaximum munch 226\ntrailing return type 282\ntraits 385, 638, 769, see type traits\nfor incomplete types 734\ntemplate 769\nvariadic templates, multiple type traits\ntrivial type 712\ntrue_type 413, 699\ntype\nclosure type 310\ncomposite type (category) 702\ndefinition xxxii, 38, see type alias\nfunction 401\nprimary type (category) 702\ntype alias 769\ntype category\ntype-dependent expression 217, 233\ntype_info 138\ntype parameter 4\ntype template 769\ntype traits 164, see traits\nfor incomplete types 734\nvariadic templates, multiple type traits 734\n__type_traits 462\nunderlying_type 716\ntemplate 180\nunit types metaprogramming 534\nunnamed namespace 666\nfunctions 401\nof template parameters 187\nvalue_type\nvariable template 80, 447, 770\nvariadic template 55, 190, 200\nmultiple type traits 734\ninstantiation 246\nmember templates 182\nand decltype(auto) 162\nas template parameter 6\nin templates 361\ntemplate parameter 186",
      "keywords": [
        "template",
        "type",
        "function",
        "template parameter",
        "template argument",
        "function template",
        "class templates",
        "member function template",
        "parameter",
        "traits",
        "argument",
        "type traits",
        "member",
        "reference",
        "member template"
      ],
      "concepts": [
        "template",
        "type",
        "instantiated",
        "trait",
        "function",
        "functions",
        "parameter",
        "classes",
        "reference",
        "argument"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 1,
          "title": "",
          "score": 0.951,
          "base_score": 0.801,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 15,
          "title": "",
          "score": 0.791,
          "base_score": 0.641,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 12,
          "title": "",
          "score": 0.744,
          "base_score": 0.594,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 2,
          "title": "",
          "score": 0.663,
          "base_score": 0.513,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 47,
          "title": "",
          "score": 0.643,
          "base_score": 0.643,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "templates",
          "type",
          "function",
          "instantiation",
          "types"
        ],
        "semantic": [],
        "merged": [
          "templates",
          "type",
          "function",
          "instantiation",
          "types"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4329939890204539,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.449839+00:00"
      }
    },
    {
      "chapter_number": 32,
      "title": "Segment 32 (pages 1015-1044)",
      "start_page": 1015,
      "end_page": 1044,
      "summary": "int* const bookmark; /f the pointer cannot change, but the value pointed to can\ntypedef CHARS const CPTR; / constant pointer to chars\ntypedef const CHARS CPTR; / constant pointer to chars\nT max (T a, T b)\nstd::cout << \"max(f1,f£2): \" << ::max(f£1,£2) << ’\\n’;\nmax(7,i): 42\nmax(fi,f2): 3.4\nstd::string max (std::string, std::string) ;\nT max (T const& a, T constk& b)\nmax(i, ¢); /f OR: T is deduced as int\nmax(c, c); // OR: T is deduced as int\nmax(i, ir); // OR: T is deduced as int\nmax(4, 7.2}: Hf ERROR: T can be deduced as int or double\nfoo(\"hello\", s); // ERROR: T can be deduced as char const [6] or std::string\nmax<double>(4, 7.2); MOK\ntemplate<typename T = std::string>\nT max (T a, T b);",
      "keywords": [
        "chars typedef char",
        "CHARS const CPTR",
        "typedef char",
        "typedef const CHARS",
        "CHARS",
        "CPTR char",
        "constant pointer",
        "max",
        "CPTR",
        "const CPTR",
        "pointer to chars",
        "CHARS const",
        "typename",
        "constant chars"
      ],
      "concepts": [
        "template",
        "max",
        "std",
        "char",
        "error",
        "operator",
        "constant",
        "mas",
        "time",
        "maxi"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 41,
          "title": "",
          "score": 0.698,
          "base_score": 0.548,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 78,
          "title": "",
          "score": 0.689,
          "base_score": 0.539,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 55,
          "title": "",
          "score": 0.579,
          "base_score": 0.579,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 57,
          "title": "",
          "score": 0.547,
          "base_score": 0.547,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 33,
          "title": "",
          "score": 0.546,
          "base_score": 0.546,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "chars",
          "max",
          "cptr",
          "string max",
          "typedef"
        ],
        "semantic": [],
        "merged": [
          "chars",
          "max",
          "cptr",
          "string max",
          "typedef"
        ]
      },
      "topic_id": 8,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4245116205609789,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.449934+00:00"
      }
    },
    {
      "chapter_number": 33,
      "title": "Segment 33 (pages 1045-1079)",
      "start_page": 1045,
      "end_page": 1079,
      "summary": "RT max (Tl a, T2 b);\nRT max (Ti a, T2 b);\nRT max (Ti a, T2 b);\nauto max (Ti a, T2 b)\nauto max (Ti a, T2 b) -> decltype(b<a7a:b)\nauto max (Ti a, T2 b) -> decltype(b<a?a:b);\nauto max (Ti a, T2 b) -> decltype(true7a:b) ;\nauto max (Ti a, T2 b) -> typename std: :decay<decltype(true?a:b)>: : type\nstd: :common_type_t<T1,T2> max (Ti a, T2 b)\nRT max (Ti a, T2 b)\nRT max (Ti a, T2 b)\nauto b = ::max<double,int,long double>(7.2, 4);\nint max (int a, int b)\nT max (T a, T b)\n::max(7.0, 42.0);\n// calls max<int> (by argument deduction)\n:tmax(’?a’, ’b’?); A“ calls the max<char> (by argument deduction)\n:imax<>(7, 42); /# calls max<int> (by argument deduction)\nauto max (Ti a, T2 b)\nRT max (Ti a, T2 b)\nauto b = ::max<long double>(7.2, 4); //uses second template\nauto c = ::max<int>(4, 7.2); // ERROR: both function templates match\nT max (T a, T b)\nTx max (T* a, T* b)\nauto mi = ::max(a,b); /fmax() for two values of type int\nauto m2 = ::max(si,s2); //max() fortwo values of type std::string\nT const& max (T const& a, T const& b)\nreturn max (max(a,b), c); / error ifmax(a,b) uses call-by-value\nreturn max (max(a,b), c);\nbasics/max4.cpp\nT max (T a, T b)\nreturn max (max(a,b), c); //uses the template version even for ints\nint max (int a, int b)\nconstexpr auto max (Ti a, T2 b)",
      "keywords": [
        "max",
        "typename",
        "int",
        "auto max",
        "template",
        "type",
        "const",
        "auto",
        "char const",
        "calls max",
        "std",
        "return max",
        "char",
        "maximum",
        "int max"
      ],
      "concepts": [
        "max",
        "template",
        "std",
        "basics",
        "auto",
        "char",
        "returns",
        "string",
        "double",
        "declared"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.762,
          "base_score": 0.612,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 79,
          "title": "",
          "score": 0.729,
          "base_score": 0.579,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 60,
          "title": "",
          "score": 0.72,
          "base_score": 0.57,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.72,
          "base_score": 0.57,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 64,
          "title": "",
          "score": 0.71,
          "base_score": 0.56,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "max",
          "max ti",
          "ti t2",
          "auto max",
          "ti"
        ],
        "semantic": [],
        "merged": [
          "max",
          "max ti",
          "ti t2",
          "auto max",
          "ti"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4602885456048761,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.450023+00:00"
      }
    },
    {
      "chapter_number": 34,
      "title": "Segment 34 (pages 1080-1114)",
      "start_page": 1080,
      "end_page": 1114,
      "summary": "class Stack {\nstd: :vector<T> elems; // elements\nvoid push(T const& elem); “push element\nbool empty() const { // return whether the stack is empty\nvoid Stack<T>::push (T constk elem)\nvoid Stack<T>::pop ()\nclass Stack {\nclass Stack {\nclass Stack {\nvoid push(T const& elem);\nvoid Stack<T>::push (T const& elem)\nclass Stack {\nvoid push (T const& elem) {\n#include \"stack1.hpp\"\nclass Stack {\nStack<std: :pair<int,int>> ps; // note: std: :pair<> has no operator<< defined\nclass Stack {\nStack<T> const& s) {\nclass Stack {\nfriend std::ostreamk operator<< (std::ostream&, Stack<U> const&) ;\nclass Stack;\nstd: :ostream&k operator<< (std::ostream&, Stack<T> const&) ;\nclass Stack {\nStack<T> const&);\nStack<std: :pair<int,int>> ps; / std: :pair<> has no operator<< defined\nclass Stack<std::string> {\nvoid Stack<std::string>::push (std::string const& elem)\nclass Stack<std::string> {\nstd::deque<std::string> elems; // elements\nvoid push(std::string const&); // push element\nstd::string const& top() const; /refurn top element\nvoid Stack<std::string>::push (std::string const& elem)\nvoid Stack<std::string>::pop ()\nstd::string const& Stack<std::string>::top () const\nstd: :vector<T*> elems; #f elements\nbool empty() const { # return whether the stack is empty\nvoid Stack<std::string>::pop ()\nstd::string const& Stack<std::string>::top () const",
      "keywords": [
        "Stack",
        "class Stack",
        "const",
        "void Stack",
        "std",
        "typename",
        "template",
        "Stack const",
        "elem",
        "element",
        "void",
        "string const",
        "string",
        "int stack",
        "push"
      ],
      "concepts": [
        "stack",
        "std",
        "template",
        "push",
        "elements",
        "element",
        "include",
        "operator",
        "void",
        "pop"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 40,
          "title": "",
          "score": 0.914,
          "base_score": 0.764,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 36,
          "title": "",
          "score": 0.812,
          "base_score": 0.662,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 35,
          "title": "",
          "score": 0.795,
          "base_score": 0.645,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 72,
          "title": "",
          "score": 0.61,
          "base_score": 0.61,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 67,
          "title": "",
          "score": 0.609,
          "base_score": 0.609,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "stack",
          "stack std",
          "class stack",
          "push",
          "std"
        ],
        "semantic": [],
        "merged": [
          "stack",
          "stack std",
          "class stack",
          "push",
          "std"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4702390603101348,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.450111+00:00"
      }
    },
    {
      "chapter_number": 35,
      "title": "Segment 35 (pages 1115-1144)",
      "start_page": 1115,
      "end_page": 1144,
      "summary": "void Stack<T,Cont>: : push (T const& elem)\nvoid Stack<T,Cont>::push (T const elem)\nHf stack of ints:\nStack<int> intStack;\n# stack of doubles using a std: :deque<> fo manage the elements\nStack<double,std: :deque<double>> dblStack;\nHM manipulate int stack\nStack<double,std: :deque<double>>\ntypedef Stack<int> IntStack; // typedef\nvoid foo (IntStack const& s); // s is stack of ints\nIntStack istack[1i0] ; //istack is array of 10 stacks of ints\nusing IntStack = Stack<int>; // alias declaration\nvoid foo (IntStack const& s); Asis stack of ints\nIntStack istack[i0]; //istack ts array of 10 stacks of ints\ntypedef Stack<int> IntStack;\nusing IntStack = Stack<int>;\nusing DequeStack = Stack<T, std: :deque<T>>;\nStack<int> intStack1; Hf stack of strings\nStack<int> intStack2 = intStacki; / OK in all versions\nStack intStack3 = intStack1l; /f OBR since C++17\nStack (T const& elem)\nStack intStack = Q; // Stack<int> deduced since C++17\nstd: :vector<T> elems; // elements\nStack (T elem) # initialize stack with one element by value\nStack (T elem) // initialize stack with one element by value",
      "keywords": [
        "Stack",
        "typename",
        "typename Cont",
        "MyClass",
        "partial specialization",
        "template",
        "const",
        "Cont",
        "int",
        "class Stack",
        "std",
        "elem",
        "class MyClass",
        "intStack",
        "void Stack"
      ],
      "concepts": [
        "stack",
        "template",
        "std",
        "elements",
        "element",
        "pop",
        "include",
        "push",
        "doubles",
        "uses"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 40,
          "title": "",
          "score": 0.865,
          "base_score": 0.715,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 36,
          "title": "",
          "score": 0.834,
          "base_score": 0.684,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 34,
          "title": "",
          "score": 0.795,
          "base_score": 0.645,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 77,
          "title": "",
          "score": 0.617,
          "base_score": 0.617,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 76,
          "title": "",
          "score": 0.565,
          "base_score": 0.565,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "stack",
          "intstack",
          "stack int",
          "elem",
          "ints"
        ],
        "semantic": [],
        "merged": [
          "stack",
          "intstack",
          "stack int",
          "elem",
          "ints"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.44138200005258893,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.450195+00:00"
      }
    },
    {
      "chapter_number": 36,
      "title": "Segment 36 (pages 1145-1179)",
      "start_page": 1145,
      "end_page": 1179,
      "summary": "Stack(char const*) -> Stack<std::string>;\nStack stringStack{\"bottom\"}; // OK: Stack<std::string> deduced since C++17\nStack stringStack = \"bottom\"; //Stack<std::string> deduced, but still not valid\nStack (std::string constk elem)\n// initialize stack with one element\nStack stringStack{\"bottom\"}; /Stack<std::string> deduced and valid\nStack stack2{stringStack}; // Stack<std: :string> deduced\nStack stack3(stringStack) ; //Stack<std: :string> deduced\nStack stack4 = {stringStack}; //Stack<std: :string> deduced\ntemplate<typename T, std::size_t Maxsize>\nstd: :array<T,Maxsize> elems; // elements\nstd::size_t numElems; // current number of elements\nvoid push(T const& elem); //push element\nbool empty() const { # return whether the stack is empty\nstd::size_t size() const { “return current number of elements\ntemplate<typename T, std::size_t Maxsize>\ntemplate<typename T, std::size_t Maxsize>\nvoid Stack<T,Maxsize>::push (T const& elem)\ntemplate<typename T, std::size_t Maxsize>\ntemplate<typename T, std::size_t Maxsize>\nreturn elems[numElems-1]; A return last element\ntemplate<typename T, std::size_t Maxsize>\nstd: :array<T,Maxsize> elems; // elements\ntemplate<typename T, std::size_t Maxsize>\nvoid Stack<T,Maxsize>::push (T const& elem)\nStack<std::string,40> stringStack; # stack of up to 40 strings\ntemplate<typename T = int, std::size_t Maxsize = 100>\ntemplate<std::string name>\nstd: :array<T,Maxsize> elems; // elements\nsize_type numElems; # current number of elements\nbool empty() const { /f return whether the stack is empty\nsize_type size() const { / return current number of elements\nvoid Stack<T,Maxsize>::push (T const& elem)\nreturn elems[numElems-1]; // return last element\nstd: :array<T,Maxsize> elems; // elements\nsize_type size() const { // return current number of elements\nauto size() const { // return current number of elements\nStack<std: :string,40> stringStack; # stack of up to 40 strings",
      "keywords": [
        "Stack",
        "Maxsize",
        "std",
        "auto Maxsize",
        "const",
        "class Stack",
        "numElems",
        "typename",
        "template",
        "void Stack",
        "elements",
        "string",
        "Stack stringStack",
        "size",
        "T,Maxsize"
      ],
      "concepts": [
        "stack",
        "template",
        "std",
        "elements",
        "element",
        "string",
        "strings",
        "size",
        "include",
        "value"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 40,
          "title": "",
          "score": 0.867,
          "base_score": 0.717,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 35,
          "title": "",
          "score": 0.834,
          "base_score": 0.684,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 34,
          "title": "",
          "score": 0.812,
          "base_score": 0.662,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 81,
          "title": "",
          "score": 0.581,
          "base_score": 0.581,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 4,
          "title": "",
          "score": 0.569,
          "base_score": 0.569,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "maxsize",
          "stack",
          "stack std",
          "stringstack",
          "size_t maxsize"
        ],
        "semantic": [],
        "merged": [
          "maxsize",
          "stack",
          "stack std",
          "stringstack",
          "size_t maxsize"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.43638697064933646,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.450285+00:00"
      }
    },
    {
      "chapter_number": 37,
      "title": "Segment 37 (pages 1180-1210)",
      "start_page": 1180,
      "end_page": 1210,
      "summary": "std::cout << \"size types differ\" << ’\\n’;\nstd::cout << \"size types differ\" << ’\\n’;\nstd::cout << T << *\\n’;\nargs)\nstd::cout << firstArg << ’\\n’; “print first argument\nprint(args...); / call print () for remaining arguments\nargs)\nstd::string s(\"world\");\nprint<double, char const*, std::string> (7.5, \"hello\", s);\nprint<char const*, std::string> (\"hello\", s);\nprint<std::string> (s);\nvoid print (T arg)\nstd::cout << arg << ’\\n’; /“/print passed argument\nargs)\nprint(args...); # call print () for remaining arguments\nstd::cout << sizeof...(Types) << ’\\n’; “print number of remaining types\nstd::cout << sizeof...(args) << ’\\n’; 9 “print number of remaining args\nstd::cout << firstArg << ’\\n’;\nprint (args: o:); // and no print () for no arguments declared\nNode(int i=0) : value(i), left(nullptr), right(nullptr) {\nauto left = &Node::left;\nNode* traverse (T np, TP...\nroot->left->right = new Node{2};\nNode* node = traverse(root, left, right);\nvoid print (Types const&...\n(std: tcout << sao << args) << An’;\nvoid print (Args...\n( std::cout << ...\n<< AddSpace(args) ) << ’\\n’;\nauto sp = std: :make_shared<std: :complex<float>>(4.2, 7.7);\nprint (args + args...);\nprintDoubled(7.5, std::string(\"hello\"), std: :complex<float>(4,2));",
      "keywords": [
        "typename",
        "args",
        "std",
        "types",
        "void print",
        "Node",
        "template",
        "void",
        "cout",
        "firstArg",
        "int",
        "auto",
        "const",
        "Stack",
        "left"
      ],
      "concepts": [
        "std",
        "template",
        "types",
        "auto",
        "hello",
        "node",
        "arguments",
        "basics",
        "size",
        "paths"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 4,
          "title": "",
          "score": 0.971,
          "base_score": 0.821,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 43,
          "title": "",
          "score": 0.899,
          "base_score": 0.749,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 42,
          "title": "",
          "score": 0.884,
          "base_score": 0.734,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 38,
          "title": "",
          "score": 0.8,
          "base_score": 0.65,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 45,
          "title": "",
          "score": 0.765,
          "base_score": 0.615,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "print",
          "args",
          "node",
          "left",
          "print args"
        ],
        "semantic": [],
        "merged": [
          "print",
          "args",
          "node",
          "left",
          "print args"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.48347996830325096,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.450371+00:00"
      }
    },
    {
      "chapter_number": 38,
      "title": "Segment 38 (pages 1211-1240)",
      "start_page": 1211,
      "end_page": 1240,
      "summary": "std::string(\"hello\") + std::string(\"hello\"),\nreturn (std::is_same<T1,TN>::value && ...); since C+4+/17\nstd::is_same<int,int>::value && std::is_same<int,char const*>::value\nvoid printElems (C const& coll, Idx...\nstd::vector<std::string> coll = {\"good\", \"times\", \"say\", \"bye\"};\nvoid printIdx (C const& coll)\nprint (coll [Idx]...);\nstd: :vector<std::string> coll = {\"good\", \"times\",\nTuple<int, std::string, char> t; //% can hold integer, string, and character\nVariant<int, std::string, char> v; //v can hold integer, string, or character\ntemplate<typename T, std::size_t...\nprint (std: :get<Idx>(t)...);\nstd: :array<std::string, 5> arr = {\"Hello\", \"my\", \"new\", \"!\", \"World\"};\nstd::array<int, 3> a{42,45,77};\nstd::string name;\nCustomer(std::string const& n) : name(n) { }\nstd::string getName() const { return name; }\nstd::size_t operator() (Customer const& c) const {\nreturn std: :hash<std: :string>() (c.getName()) ;\nstd: :unordered_set<Customer,CustomerHash,CustomerEq> colll1;\nstd: :unordered_set<Customer,CustomerOP,Customer0P> coll2;\nvoid printcoll (T const& coll)\ntypename T::const_iterator pos; //iterator to iterate over coll",
      "keywords": [
        "std",
        "const",
        "typename",
        "Idx",
        "string",
        "template",
        "Customer const",
        "coll",
        "indices",
        "void",
        "Bases",
        "Customer",
        "iterator",
        "Overloader",
        "args"
      ],
      "concepts": [
        "std",
        "template",
        "classes",
        "customer",
        "void",
        "string",
        "operator",
        "indices",
        "base",
        "include"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 42,
          "title": "",
          "score": 0.811,
          "base_score": 0.661,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 37,
          "title": "",
          "score": 0.8,
          "base_score": 0.65,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 43,
          "title": "",
          "score": 0.748,
          "base_score": 0.598,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 4,
          "title": "",
          "score": 0.734,
          "base_score": 0.584,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 45,
          "title": "",
          "score": 0.673,
          "base_score": 0.523,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "coll",
          "std",
          "string",
          "customer",
          "std string"
        ],
        "semantic": [],
        "merged": [
          "coll",
          "std",
          "string",
          "customer",
          "std string"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4060749563231244,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.450453+00:00"
      }
    },
    {
      "chapter_number": 39,
      "title": "Segment 39 (pages 1241-1273)",
      "start_page": 1241,
      "end_page": 1273,
      "summary": "template<typename T, int N, int M>\nint x{] = (1, 2; 3};\nstd::cout << less(x,y) << ’\\n’;\ntemplate<int N, int M>\nbasics/arrays .hpp\ntemplate<typename T, std::size_t S5Z>\nstruct MyClass<T[SZ]> # partial specialization for arrays of known bounds\nstatic void print() { std::cout << \"print() for T[\" << 8Z << \"]\\n\"; }\ntemplate<typename T, std::size_t SZ>\nstatic void print() { std::cout << \"print() for T(&)[\" << SZ << \"]\\n\"; }\nstruct MyClass<T[]> /f partial specialization for arrays of unknown bounds\nstatic void print() { std::cout << \"print() for T[]\\n\"; }\nstatic void print() { std::cout << \"print() for T(&)[]\\n\"; }\nstatic void print() { std::cout << \"print() for T*\\n\"; }\nMyClass<decltype(x0)>::print() ;\nMyClass<decltype(x1)>::print() ;\nMyClass<decltype(x2)>::print() ;\nMyClass<decltype(x3)>::print();\nint x{].\nfloatStack = intStack1; /f ERROR: stacks have different types\nstd: :deque<T> elems; Hf elements\nvoid push(T const&) ; Hf push element\nT const& top() const; # return top element\nbool empty() const f{ / return whether the stack is empty\nf/f assign stack of elements of type T2\nstd: :deque<T> elems; /f elements\nvoid pop(); /f pop element\nT const& top() const; /f return top element\nbool empty() const { /f return whether the stack is empty\ntemplate<typename> friend class Stack;\ntemplate<typename> friend class Stack;\nfloatStack = intStack; /f OR: stacks have different types,\nStack<std::string> stringStack; //stack of strings\ntemplate<typename T, typename Cont = std::deque<T>>\nvoid push(T const&); Hf push element\nT const& top() const; // return top element\nbool empty() const { A return whether the stack is empty\n// assign stack of elements of type T2\ntemplate<typename, typename> friend class Stack;\nStack<T,Cont>::operator= (Stack<T2,Cont2> const& op2)\nStack<int ,std::vector<int>> vStack;\nBoolString (std::string const& s)\ntemplate<typename T = std: :string>\nstd::cout << sl.get<bool>() << ’\\n’; //prints false\nstd::cout << s2.get<bool>() << ’\\n’; /prints true\nvoid printBitset (std::bitset<N> const& bs) {\nreturn x + ¥;",
      "keywords": [
        "stack",
        "typename",
        "MyClass",
        "template",
        "std",
        "void",
        "const",
        "class Stack",
        "int",
        "struct MyClass",
        "cout",
        "void foo",
        "void print",
        "elements",
        "static void print"
      ],
      "concepts": [
        "std",
        "stack",
        "template",
        "basics",
        "prints",
        "bounds",
        "void",
        "value",
        "element",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 58,
          "title": "",
          "score": 0.7,
          "base_score": 0.7,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 49,
          "title": "",
          "score": 0.671,
          "base_score": 0.671,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 65,
          "title": "",
          "score": 0.65,
          "base_score": 0.65,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 52,
          "title": "",
          "score": 0.65,
          "base_score": 0.65,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 56,
          "title": "",
          "score": 0.649,
          "base_score": 0.649,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "print",
          "stack",
          "myclass",
          "void print",
          "cout print"
        ],
        "semantic": [],
        "merged": [
          "print",
          "stack",
          "myclass",
          "void print",
          "cout print"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5122772855311272,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.450538+00:00"
      }
    },
    {
      "chapter_number": 40,
      "title": "Segment 40 (pages 1274-1308)",
      "start_page": 1274,
      "end_page": 1308,
      "summary": "std::cout << val<long> << ’\\n’; //OK: prints 42\nStack<int, std::vector<int>> vStack; //integer stack that uses a vector\nStack<int, std::vector> vStack; // integer stack that uses a vector\ntemplate<typename Elem> class Cont = std::deque>\nclass Stack {\nCont<T> elems; // elements\ntemplate<typename Elem> class Cont\ntemplate<class Elem> class Cont = std: :deque>\ntemplate<typename Elem> typename Cont = std: :deque>\ntemplate<typename> class Cont = std: :deque>\nclass Stack {\ntemplate<typename T, template<typename> class Cont>\nvoid Stack<T,Cont>::push (T const& elem)\ntemplate<typename Elem,\ntypename Alloc = std: :allocator<Elem>>\nclass Cont = std::deque>\nclass Stack {\nCont<T> elems; // elements\ntypename = std: :allocator<Elem>>\nclass Cont = std: :deque>\nclass Stack {\ntemplate<typename Elem2,\ntypename = std::allocator<Elem2>\ntemplate<typename T, template<typename,typename> class Cont>\nvoid Stack<T,Cont>::push (T const& elem)\ntemplate<typename T, template<typename,typename> class Cont>\nvoid Stack<T,Cont>::pop ()\ntemplate<typename T, template<typename,typename> class Cont>\nT const& Stack<T,Cont>::top () const\ntemplate<typename T, template<typename,typename> class Cont>\ntemplate<typename T2, template<typename,typename> class Cont2>\nStack<T,Cont>&\n#include \"stack9.hpp\"\nStack<double, std::vector> vStack;\nstd::cout << \"vStack.top(Q): \" << vStack.top() << ’\\n’;\nstd::cout << vStack.top() << ’ ’;",
      "keywords": [
        "typename",
        "Stack",
        "class Cont",
        "std",
        "template",
        "cont",
        "class Stack",
        "typename Elem",
        "Elem",
        "const",
        "cout",
        "include",
        "int",
        "void Stack",
        "typename Cont"
      ],
      "concepts": [
        "stack",
        "std",
        "template",
        "include",
        "elements",
        "element",
        "value",
        "push",
        "code",
        "pop"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 34,
          "title": "",
          "score": 0.914,
          "base_score": 0.764,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 36,
          "title": "",
          "score": 0.867,
          "base_score": 0.717,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 35,
          "title": "",
          "score": 0.865,
          "base_score": 0.715,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 58,
          "title": "",
          "score": 0.691,
          "base_score": 0.691,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 3,
          "title": "",
          "score": 0.66,
          "base_score": 0.66,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "cont",
          "stack",
          "class cont",
          "elem",
          "stack cont"
        ],
        "semantic": [],
        "merged": [
          "cont",
          "stack",
          "class cont",
          "elem",
          "stack cont"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5189307120628865,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.450625+00:00"
      }
    },
    {
      "chapter_number": 41,
      "title": "Segment 41 (pages 1309-1342)",
      "start_page": 1309,
      "end_page": 1342,
      "summary": "std::cout << \"g() for variable\\n\";\nstd::cout << \"g() for constant\\n\";\nstd::cout << \"g() for movable object\\n\";\ng(val) ; //val is non-const lvalue => calls g(X&)\ng(std: :move(val)) ;\nval is const Ivalue => calls g(X const&)\n//val is non-const lvalue => needs std::move() to call g(X&&)\n4#£() for constant object calls £(X const&) => calls g(X const&)\ng(val); //val is non-const lvalue => calls g(X&)\ng(val); f#/valis const lvalue => calls g(X const&)\ng(std::move(val)); //val is non-const /value => needs std: :move() to call g(X&k)\nstd::cout << \"g() for variable\\n\";\nvoid g (X const&) f{\nstd::cout << \"g() for constant\\n\";\nstd::cout << \"g() for movable object\\n\";\n£(c): #£(Q for constant calls £(X const&) => calls g(X const&)\nf(std::move(v)); 4 £( for move-enabled variable calls £(X&&) => calls g(X&&)\nexplicit Person(std::string const n) : name(n) {\nstd::cout << \"copying string-CONSTR for ’\" << name << \"’\\n\";\nstd::cout << \"moving string-CONSTR for ’\" << name << \"?\\n\";\nstd::cout << \"COPY-CONSTR Person ’\" << name << \"’\\n\";\nstd::cout << \"MOVE-CONSTR Person ’\" << name << \"’\\n\";\nPerson pi(s); /# init with string object => calls copying string-CONSTR\nPerson p2(\"tmp\"); // init with string literal => calls moving strine-CONSTR\nPerson p4(std::move(p1)); //move Person => calls MOVE-CONST\nPerson(std::string const& n) : name(n) {\nstd::cout << \"copying string-CONSTR for ’\" << name << \"’\\n\";\nstd::cout << \"moving string-CONSTR for ’\" << name << \"’\\n\";\nPerson pi(s); /f init with string object => calls copying string-CONSTR\nPerson p2(\"tmp\") ; // init with string literal => calls moving string-CONSTR\nPerson p4(std::move(pi)); //move Person => calls MOVE-CONSTR\nexplicit Person(STR&& n) : name(std::forward<STR>(n)) {\nstd::cout << \"COPY-CONSTR Person ’\" << name << \"’\\n\";\nstd::cout << \"MOVE-CONSTR Person ’\" << name << \"’\\n\";\nPerson pi(s); // init with string object => calls TMPL-CONSTR\nPerson p2(\"tmp\"); // init with string literal => calls TMPL-CONSTR\nPerson p4(std::move(pi)); / OK: move Person => calls MOVE-CONST\nstd::cout << \"COPY-CONSTR Person ’\" << name << \"’\\n\";\nstd::cout << \"MOVE-CONSTR Person ’\" << name << \"’\\n\";\nPerson p4(std: :move(p1));",
      "keywords": [
        "Person",
        "std",
        "STR",
        "typename STR",
        "calls",
        "val",
        "typename",
        "string",
        "Person const",
        "move",
        "cout",
        "void",
        "const",
        "template",
        "move Person"
      ],
      "concepts": [
        "std",
        "person",
        "calls",
        "string",
        "template",
        "include",
        "copying",
        "constant",
        "basics",
        "object"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 78,
          "title": "",
          "score": 0.858,
          "base_score": 0.708,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 32,
          "title": "",
          "score": 0.698,
          "base_score": 0.548,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 46,
          "title": "",
          "score": 0.649,
          "base_score": 0.649,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 57,
          "title": "",
          "score": 0.638,
          "base_score": 0.638,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 34,
          "title": "",
          "score": 0.599,
          "base_score": 0.599,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "person",
          "constr",
          "constr person",
          "calls",
          "calls const"
        ],
        "semantic": [],
        "merged": [
          "person",
          "constr",
          "constr person",
          "calls",
          "calls const"
        ]
      },
      "topic_id": 8,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.47872340907685956,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.450731+00:00"
      }
    },
    {
      "chapter_number": 42,
      "title": "Segment 42 (pages 1343-1372)",
      "start_page": 1343,
      "end_page": 1372,
      "summary": "void printV (std::string arg)\nstd::string s = \"hi\";\nprintV(std::string(\"hi\")); //copying usually optimized away (if not, move constructor)\nstd::string const c = \"hi\";\nprintV(c); //c decays so that arg has type std::string\nvoid printV (char const* arg)\nvoid printR (T const& arg) {\nstd::string s = \"hi\";\nprintR(std::string(\"hi\")); 4/no copy\nprintR(std: :move(s)); // no copy\nvoid printR(int const& arg) {\nvoid printR (T const& arg) f{\nstd::string const c = \"hi\";\nprintR(c); WT deduced as std: : string, arg is std::string const&\nprintR(\"hi\"); 4 T deduced as char [3], arg is char const (&) [3]\nprintR(arr) ; 4T deduced as int [4], arg is int const (&) [4]\noutR(s) ; // OR: T deduced as std: : string, arg is std: :string&\noutR(std::string(\"hi\")); //ERROR: not allowed to pass a temporary (prvalue)\nstd::string const c = \"hi\";\noutR(c); // OR: T deduced as std::string const\noutR(std: :move(c)); /f OK: T deduced as std::string const®",
      "keywords": [
        "std",
        "const",
        "STR",
        "typename",
        "string",
        "template",
        "copy constructor",
        "arg",
        "copy",
        "constructor",
        "typename STR",
        "printV",
        "outR",
        "printR",
        "string const"
      ],
      "concepts": [
        "std",
        "template",
        "copy",
        "string",
        "value",
        "void",
        "type",
        "constructor",
        "public",
        "char"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 43,
          "title": "",
          "score": 0.935,
          "base_score": 0.785,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 37,
          "title": "",
          "score": 0.884,
          "base_score": 0.734,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 4,
          "title": "",
          "score": 0.825,
          "base_score": 0.675,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 38,
          "title": "",
          "score": 0.811,
          "base_score": 0.661,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 45,
          "title": "",
          "score": 0.715,
          "base_score": 0.565,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "printr",
          "arg",
          "string",
          "hi",
          "std string"
        ],
        "semantic": [],
        "merged": [
          "printr",
          "arg",
          "string",
          "hi",
          "std string"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.40192417486945503,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.450811+00:00"
      }
    },
    {
      "chapter_number": 43,
      "title": "Segment 43 (pages 1373-1403)",
      "start_page": 1373,
      "end_page": 1403,
      "summary": "typename = std::enable_if_t<!std::is_const<T>: :value>\nvoid passR (Tk& arg) { // arg declared as forwarding reference\nstd::string s = \"hi\";\npassR(s) ; // OR: T deduced as std:\npassR(std::string(\"hi\")); “OK: T deduced as std:\n:string& (also the type of arg)\n:string, arg is std: :string&&\n:string, arg is std: :stringk&\n:Sstring, arg is std: :string&&\npassR(arr) ; // OK: T deduced as int (&) [4] (also the type of arg)\nstd::string const c = \"hi\";\npassR(c) ; // OR: T deduced as std::string const&\npassR(\"hi\") ; // OR: T deduced as char const (&) [3] (also the type of arg)\npassR(\"hi\") ; // OK: T deduced as int (&) [4] (also the type of arg)\nvoid passR(T&& arg) { //arg is a forwarding reference\nstd::string s = \"hello\";\nvoid printString(std::string const& s)\nprintString (arg) ; #/ might convert arg back to std::string\nstd::cout << arg << \"\\n?;\nif (isless(std::cref(s) < std::string(\"world\"))) ...\nvoid foo (T const& argi, T const& arg2)\nvoid foo (T argi, T arg2)\nvoid foo (T argi, T arg2)\ntemplate<typename T, std::size_t Li, std::size_t L2>\nvoid foo(T (&argi) [Li], T (&arg2) [L2])\ntypename std: :remove_reference<T>::type retV(T p)\nauto retV(T p) /%/by-value return type deduced by compiler\nstruct IsPrime<0> { static constexpr bool value = false; };",
      "keywords": [
        "std",
        "typename",
        "arg",
        "string",
        "template",
        "passR",
        "deduced",
        "void",
        "string const",
        "void foo",
        "ERROR template",
        "static constexpr bool",
        "typename decay",
        "ERROR",
        "void passR"
      ],
      "concepts": [
        "std",
        "template",
        "returns",
        "string",
        "reference",
        "type",
        "passed",
        "include",
        "error",
        "recursion"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 42,
          "title": "",
          "score": 0.935,
          "base_score": 0.785,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 4,
          "title": "",
          "score": 0.903,
          "base_score": 0.753,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 37,
          "title": "",
          "score": 0.899,
          "base_score": 0.749,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 6,
          "title": "",
          "score": 0.865,
          "base_score": 0.715,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 38,
          "title": "",
          "score": 0.748,
          "base_score": 0.598,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "arg",
          "passr",
          "string",
          "std",
          "std string"
        ],
        "semantic": [],
        "merged": [
          "arg",
          "passr",
          "string",
          "std",
          "std string"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4622685654459544,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.450897+00:00"
      }
    },
    {
      "chapter_number": 44,
      "title": "Segment 44 (pages 1404-1436)",
      "start_page": 1404,
      "end_page": 1436,
      "summary": "constexpr bool isPrime (unsigned int p)\nstd::cout << isPrime(x); // evaluated at run time\ntemplate<typename T, std::size_t SZ>\nlong foo (std::array<T,SZ> const& coll)\nstd::size_t len (T(&) [N])\ntypename T::size_type len (T const& t)\nstd::cout << len(a); // OK: only len for array matches\nstd::cout << len(\"tmp\"); // OK: only len() for array matches\nstd::cout << len(v); 4/4 OK; only len() for a type with size_type matches\nstd::cout << len(p); /f ERROR: no matching Len() function found\nstd::cout << len(x); // ERROR: len() function found, but can’t size ()\nstd::size_t len (T(&) [N])\ntypename T::size_type len (T const& t)\nstd: :size_t len (...}\nstd::cout << len(a); // OK: Len() for array is best match\nstd::cout << len(\"tmp\"); MOK: 1len() for array is best match\nstd::cout << len(v); // OK: len() for a type with size_type is best match\nstd::cout << len(p); // OR: only fallback len(©) matches\nstd::cout << len(x); // ERROR: 2nd 1len() function matches best,\ntypename T::size_type len (T const& t)\nstd::cout << len(x) << ’\\n’; M4 ERROR: len() selected, but x has no size()\ntemplate<typename T, std::size_t SZ>\nvoid foo (std::array<T,SZ> const& coll)\nstd::cout << typeid(x).name() << ’\\n’;\nstd: :map<std: :string,double> coll;\n[L] (std::string const& s) {\nfrom /cygdrive/p/gcc/gcc61-include/bits/char_traits.h:39,\nfrom /cygdrive/p/gcc/gcec61-include/string:40,\n/cygdrive/p/gcc/gcc61-include/bits/predefined_ops.h: In instantiation of *bool __gnu_cxx\nterator<std::pair<const std::__cxxil::basic_string<char>, double> >; _Predicate = main()\n/cygdrive/p/ecc/gcc61-include/bits/stl_algo.h:104:42: required from ’_InputIterator\n(with _InputIterator = std::_Rb_tree_iterator<std: :pair<const std::__cxx11::basic_string\n/cygdrive/p/gec/gcc61-include/bits/stl_algo.h:161:23: required from ’_Iterator std::__\npair<const std::__cxxl1l::basic_string<char>, double> >; _Predicate = __gnu_cxe::__ops::_\n/cygdrive/p/gec/gcec61-include/bits/stl_algo.h:3824:28: required from *_IIter std::find\n_if(_IIter, _IIter, _Predicate) [with _IIter = std::_Rb_tree_iterator<std: :pair<const\nstd::__cxxli::basic_string<char>, double> >; _Predicate = main()::<lambda(const stringk)\n/cygdrive/p/gcc/gcc61-include/bits/predefined_ops.h:234:11: error: no match for call to\n*{main()::<lambda(const string&)>) (std::pair<const std::__cxxil::basic_string<char>,\n/cygdrive/p/gcc/gcec61-include/bits/predefined_ops.h:234:11: note: candidate: bool (*) (\nconst string&) {aka bool (*)(const std::__cxxii::basic_string<char>&)} <conversion>\n[] (std::string consté s) {\nerrornovell.cpp:11:52: note: no known conversion for argument 1 from ’std::pair<const\nstd::__cexxli::basic_string<char>, double>’ to ‘const stringk faka const std::__cxxii::\n[] (std::string const& s) {",
      "keywords": [
        "std",
        "const std",
        "const",
        "typename",
        "template",
        "len",
        "struct Helper",
        "helper",
        "cout",
        "int",
        "string",
        "size",
        "constexpr bool isPrime",
        "type",
        "primary helper template"
      ],
      "concepts": [
        "std",
        "include",
        "included",
        "template",
        "basics",
        "string",
        "implementation",
        "error",
        "double",
        "size"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 63,
          "title": "",
          "score": 0.848,
          "base_score": 0.698,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.825,
          "base_score": 0.675,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 18,
          "title": "",
          "score": 0.745,
          "base_score": 0.595,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 64,
          "title": "",
          "score": 0.745,
          "base_score": 0.595,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.744,
          "base_score": 0.594,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "len",
          "cout len",
          "std",
          "cygdrive",
          "const std"
        ],
        "semantic": [],
        "merged": [
          "len",
          "cout len",
          "std",
          "cygdrive",
          "const std"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.49510119656095314,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.450998+00:00"
      }
    },
    {
      "chapter_number": 45,
      "title": "Segment 45 (pages 1437-1468)",
      "start_page": 1437,
      "end_page": 1468,
      "summary": "(main()::<lambda(const string&)>) (std::pair<const std::__cxx11::basic_string<char>,\nfrom ’std::pair<const std::__cxx11::basic_string<char>, double>’\nto ’const string& {aka const std::__cxx11::basic_string<char>&}’\n\"std: :pair<const _Kty,_Ty>’ to ’const std::string &’\nc:\\tools_root\\cl\\inc\\algorithm(166): note: Reason: cannot convert from ‘std: :pair<const\n-Kty,_Ty>’ to ’const std::string’\n<std::pair<const std::string,double>>>>,\n—Mytree=std: :_Tree_val<std: :_Tree_simple_types<std: :pair<const std::string,\n21 main.cpp(13): note: see reference to function template instantiation ’_InIt std::find_if\nconst std::string,double>>>>,\ncannot convert from ’std::pair<const _Kty,_Ty>’ to ’const std::string’\nCustomer (std::string const& n)\nstd::string getName() const {\nstd::size_t operator() (Customer const& c) {\nreturn std: :hash<std: :string>( (c.getName());\n/cygdrive/p/gcec/gcc61-include/bits/hashtable_policy.h: In instantiation of *struct std::\n/cygdrive/p/gcec/gcc61-include/type_traits:143:12: required from ’struct std::__and_<\nstd::__is_fast_hash<main()::MyCustomerHash>, std::__detail::__is_noexcept_hash<Customer,\n/cygdrive/p/gcec/gcc61-include/type_traits:154:38: required from ‘struct std::__not_<\nstd::__and_<std::__is_fast_hash<main()::MyCustomerHash>, std::__detail::__is_noexcept_\n/cygdrive/p/gcec/gcc6l1-include/bits/unordered_set .h:95:63: required from ’class std::\nerrornovel?.cpp:22:17: note: candidate: std::size_t main()::MyCustomerHash: : operator () (\nstd::size_t operator() (const Customer c) {\nerrornovel2.cpp:22:17: note: passing ’const main()::MyCustomerHash*’ as ’this’ argument\n/cygdrive/p/gcec/gcec61-include/type_traits: In instantiation of ‘struct std::__not_<std::\n_.and_<std::__is_fast_hash<main()::MyCustomerHash>, std::__detail::__is_noexcept_hash<\n/cygdrive/p/gec/gcc61-include/bits/unordered_set.h:95:63: required from ‘class std::\n/cygdrive/p/gec/ecc61-include/type_traits:154:38: error: ‘value’ is not a member of ‘std\n:t__and_<std::__is_fast_hash<main()::MyCustomerHash>, std::__detail::__is_noexcept_hash<\n/cygdrive/p/gec/gec61-ineclude/bits/unordered_set.h: In instantiation of ‘class std::\nstd::size_t main()::MyCustomerHash: :operator() (const Customer&)\nstd::size_t operator() (const Customer& c) {\npassing ‘const main()::MyCustomerHash*’ as ’this’ argument discards qualifiers\nstd::size_t operator() (const Customer& c) const {\nerrornovel2.cpp:28:47: note: in instantiation of template class ’std::unordered_set<Customer\nstd::size_t operator() (const Customerk c) {",
      "keywords": [
        "std",
        "tree",
        "Customer",
        "const std",
        "Kty",
        "main",
        "const",
        "const Customer",
        "MyCustomerHash",
        "cygdrive",
        "string",
        "pair",
        "hash",
        "unordered",
        "’const std"
      ],
      "concepts": [
        "std",
        "main",
        "customer",
        "double",
        "hash",
        "include",
        "included",
        "type",
        "string",
        "operator"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 37,
          "title": "",
          "score": 0.765,
          "base_score": 0.615,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 4,
          "title": "",
          "score": 0.744,
          "base_score": 0.594,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 43,
          "title": "",
          "score": 0.72,
          "base_score": 0.57,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 42,
          "title": "",
          "score": 0.715,
          "base_score": 0.565,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 38,
          "title": "",
          "score": 0.673,
          "base_score": 0.523,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "std",
          "mycustomerhash",
          "customer",
          "cygdrive",
          "main"
        ],
        "semantic": [],
        "merged": [
          "std",
          "mycustomerhash",
          "customer",
          "cygdrive",
          "main"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4321657065340501,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.451083+00:00"
      }
    },
    {
      "chapter_number": 46,
      "title": "Segment 46 (pages 1469-1503)",
      "start_page": 1469,
      "end_page": 1503,
      "summary": "void foreach (Iter current, Iter end, Callable op)\nvoid func(int i)\nvoid operator() (int i) const { //Note: const member function\nstd::cout << \"FuncObj::op() called for: \" << i << 7?\\n’;\nstd: :vector<int> primes = { 2,\nvoid foreach (Iter current, Iter end, Callable op, Args const&...\nstd: :invoke(op, # call passed callable with\nvoid memfunc(int i) const {\nstd::cout << \"MyClass::memfunc() called for: \" << i << ’\\n’;\nstd: :vector<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19 };\n(] (std::string const& prefix, int i) { “lambda to call\n#include <utility> # for std: :invoke()\nreturn std::invoke(std: :forward<Callable>(op), # passed callable with\nstd: :forward<Args>(args)...); / any additional args\ndecltype(auto) ret{std: :invoke(std: :forward<Callable>(op),\nstd: :forward<Args>(args)...)};\nreturn std: :invoke(std: :forward<Callable>(op) ,\nstd: :forward<Args>(args)...);\n#include <utility> # for std: :invoke()\n#include <functional> //for std: :forward()\n#include <type_traits> //for std: :is_same<> and invoke_result<>\nif constexpr (std: :is_same_v<std: :invoke_result_t<Callable, Args...>,\nstd::invoke(std: :forward<Callable>(op),\nstd: :forward<Args>(args)...);\n#f return type is not void:\ndecltype(auto) ret{std::invoke(std: :forward<Callable>(op),\nstd: :forward<Args>(args)...)};\nif constexpr (std: :is_same_v<std: :invoke_result_t<Callable, Args...>,\nstatic_assert(!std::is_same_v<std: :remove_cv_t<T>,void>,\nif constexpr(std::is_reference_v<T>) {\nif constexpr (std: :has_virtual_destructor_v<V>) f{\nstd: :remove_const_t<int const&k> /f yields int const&\nstd: :remove_const_t<std: :remove_reference_t<int const&>> //int\nstd: :remove_reference_t<std: :remove_const_t<int const&>> //int const\nstd: :decay_t<int const&> /f yields int\nadd_rvalue_reference_t<int const> ffint const&&\nis_assignable_v<int,int> # yields false (can’t call 42 = 42)\nis_assignable_v<int&,int&> //yields true\nis_swappable_v<int> // yields true (assuming lvalues)\ntypename RT = std::decay_t<decltype(true ?\nstd::cout << \"T is reference: \" << std::is_reference_v<T> << ’\\n’;\nint i;\nRefMem<int&> rm3; # ERROR: invalid default value for N\ntemplate<typename T, int& 5Z> /f Note: size is reference\nint size = 10;\nArr<int&,size> y; //compile-time ERROR deep in the code of class std: : vector<>\nArr<int,size> x; //initializes internal vector with 10 elements\nArr<int&,size> y; //compile-time ERROR deep in the code of class std: :vector<>\nArr<int,size> x; / initializes internal vector with 10 elements",
      "keywords": [
        "std",
        "Callable",
        "int",
        "Args",
        "typename Callable",
        "typename",
        "include",
        "const",
        "template",
        "void",
        "int const",
        "Arr",
        "forward",
        "error",
        "Iter"
      ],
      "concepts": [
        "std",
        "template",
        "operator",
        "include",
        "forward",
        "size",
        "end",
        "error",
        "current",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 41,
          "title": "",
          "score": 0.649,
          "base_score": 0.649,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 65,
          "title": "",
          "score": 0.607,
          "base_score": 0.607,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 37,
          "title": "",
          "score": 0.596,
          "base_score": 0.596,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 57,
          "title": "",
          "score": 0.583,
          "base_score": 0.583,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 52,
          "title": "",
          "score": 0.58,
          "base_score": 0.58,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "callable",
          "std",
          "args",
          "op",
          "int"
        ],
        "semantic": [],
        "merged": [
          "callable",
          "std",
          "args",
          "op",
          "int"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4700372118878383,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.451234+00:00"
      }
    },
    {
      "chapter_number": 47,
      "title": "Segment 47 (pages 1504-1535)",
      "start_page": 1504,
      "end_page": 1535,
      "summary": "template<typename T>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T> // a namespace scope class template\ntemplate<typename T> /f an in-class member class template definition\ntemplate<typename T> #/ an in-class (and therefore implicitly inline)\ntemplate<typename T>\n//a namespace scope class template\n# another member class template,\ntemplate<typename T> // out-of-class member class template definition\ntemplate<typename T> /f out-of-class member function template definition\ntemplate<typename T2>\ntemplate<typename T> /f out-of-class static data member template definition\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\n// ordinary function in class template\n// ordinary enumeration type in class template\n// ordinary static data member in class template\ntemplate<int I> // definition of ordinary class in class template\ntemplate<int I> // definition of ordinary function in class template\ntemplate<int I> // definition of ordinary enumeration type class in class template\ntemplate<int I> # definition of ordinary static member in class template\ntemplate<typename T>\ntemplate<typename T2>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T> void f(T) {} /no linkage: cannot be redeclared\ntemplate<typename T> T zero = T{};\ntemplate<typename\ntemplate<typename\ntemplate<typename\ntemplate<typename\ntemplate<typename\ntemplate<typename\ntemplate<typename, int>\ntemplate<T> class Buf> //in the declaration of the third one\ntemplate<class X*> // anontype parameter of pointer type\ntemplate<int buf[5]> class Lexer;\ntemplate<int* buf> class Lexer;\ntemplate<int length> class Buffer; // same as previous declaration",
      "keywords": [
        "template",
        "typename",
        "class template",
        "class List",
        "List",
        "ERROR",
        "int",
        "void",
        "typename template",
        "class Cont",
        "member class template",
        "Allocator",
        "Cont",
        "template definition",
        "static"
      ],
      "concepts": [
        "template",
        "void",
        "static",
        "public",
        "value",
        "error",
        "types",
        "std",
        "linkage",
        "allocator"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 51,
          "title": "",
          "score": 0.872,
          "base_score": 0.722,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 9,
          "title": "",
          "score": 0.833,
          "base_score": 0.683,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 11,
          "title": "",
          "score": 0.827,
          "base_score": 0.677,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 7,
          "title": "",
          "score": 0.757,
          "base_score": 0.607,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "",
          "score": 0.731,
          "base_score": 0.581,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "template typename",
          "class",
          "typename template",
          "class template",
          "definition"
        ],
        "semantic": [],
        "merged": [
          "template typename",
          "class",
          "typename template",
          "class template",
          "definition"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5131079377895068,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.451614+00:00"
      }
    },
    {
      "chapter_number": 48,
      "title": "Segment 48 (pages 1536-1565)",
      "start_page": 1536,
      "end_page": 1565,
      "summary": "template<template<typename X> class C>\ntemplate<template<typename X> struct C>\ntemplate<template<typename X> union C>\ntemplate<template<typename X> typename C> //OK since C++17\ntemplate<template<typename T,\ntemplate<template<typename T, T*#> class Buf> //OK\ntemplate<typename...\ntemplate<typename T, unsigned...\ntemplate<typename...\ntemplate<typename...\ntemplate<typename...> Typelist;\ntemplate<typename X, typename Y> struct Zip;\ntemplate<typename...\ntemplate<typename...\ntemplate<typename...\ntemplate<typename\ntemplate<typename\ntemplate<typename\ntemplate<typename R = void, typename T>\ntemplate<typename T = void>\ntemplate<typename T = void>\ntemplate<typename T>\ntemplate<typename T = int>\ntemplate<typename...\nTs = int> struct X; /f ERROR\ntemplate<typename T> struct X\ntemplate<typename T = int> T X<T>::f£0 { // ERROR\ntemplate<typename = void> friend struct F;\ntemplate<typename = void> friend void f(); // ERROR: not a definition\ntemplate<typename> void g(); // ERROR: g() was given a default template argument\ntemplate<typename T>\ntemplate<typename ...\ntemplate<typename T> void single(T) ;\ntemplate<typename T> void multi(T);\ntemplate<typename T> void multi(T*) ;\ntemplate<typename T>\ntemplate<typename T> void templ_func();",
      "keywords": [
        "typename",
        "template",
        "ERROR",
        "int",
        "void",
        "typename class Quintuple",
        "template parameter",
        "Container",
        "class Adaptation",
        "struct",
        "ERROR template",
        "Tuple",
        "template parameter pack",
        "class Container",
        "parameter"
      ],
      "concepts": [
        "template",
        "error",
        "double",
        "char",
        "hello",
        "function",
        "functions",
        "variable",
        "variables",
        "types"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 56,
          "title": "",
          "score": 0.945,
          "base_score": 0.795,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 29,
          "title": "",
          "score": 0.78,
          "base_score": 0.63,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 65,
          "title": "",
          "score": 0.753,
          "base_score": 0.603,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 71,
          "title": "",
          "score": 0.727,
          "base_score": 0.577,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 58,
          "title": "",
          "score": 0.713,
          "base_score": 0.713,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "template typename",
          "typename template",
          "typename void",
          "void",
          "template template"
        ],
        "semantic": [],
        "merged": [
          "template typename",
          "typename template",
          "typename void",
          "void",
          "template template"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4949304010838734,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.451711+00:00"
      }
    },
    {
      "chapter_number": 49,
      "title": "Segment 49 (pages 1566-1599)",
      "start_page": 1566,
      "end_page": 1599,
      "summary": "template<typename> class Cont> //Cont expects one parameter\ntemplate<typename...\nclass Rel { #f type parameters\nRel<int, double, std::list> rel; / OK: std::list has two template parameters\nAlmostAnyTmpl<std::array> withArray; “ERROR: a template type parameter pack\ntemplate<typename T, int I>\ntemplate<int N> struct I {};\ntemplate<int M, int N> void £CI<M+N>); // #1\ntemplate<int N, int M> void f(I<N+M>); //#2\ntemplate<int M, int N> void fC(I<N+M>); “#3 ERROR\ntemplate<typename...\nclass Tuple {\nTuple<int> t1; // Types contains int\ntemplate<typename...\nclass Tuple {\ntemplate<typename...\nclass MyTuple : public Tuple<Types...> f{\ntemplate<typename...\nclass PtrTuple : public Tuple<Types*...> {\ntemplate<typename...\nclass Point : public Mixins...\ntemplate<typename...\nint 1;\ntemplate<typename...\nclass Point : public Mixins...\ntemplate<typename...\ntemplate<typename T> void c_style(int, T...);\ntemplate<typename...\nT> void pack(int, T...);\ntemplate<typename F, typename...\ntemplate<typename...\ntemplate<typename...\nvoid f(InnerTypes const&...\nvoid g(Types...\ntemplate<typename T>\ntemplate<typename...\ntemplate<typename...\ntemplate<typename...\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T2>\ntemplate<typename> friend class Stack;\ntemplate<typename T>\nvoid multiply(T); // function template\nfriend void multiply(int) { }\nfriend void ::multiply(int);\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>",
      "keywords": [
        "typename",
        "int",
        "template",
        "Types",
        "Tuple",
        "void",
        "public Tuple",
        "std",
        "friend",
        "Mixins",
        "Rel",
        "list",
        "Cont",
        "public",
        "friend void"
      ],
      "concepts": [
        "template",
        "void",
        "std",
        "friend",
        "types",
        "public",
        "values",
        "function",
        "double",
        "char"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 58,
          "title": "",
          "score": 0.973,
          "base_score": 0.823,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 53,
          "title": "",
          "score": 0.759,
          "base_score": 0.759,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 57,
          "title": "",
          "score": 0.754,
          "base_score": 0.754,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 52,
          "title": "",
          "score": 0.751,
          "base_score": 0.751,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 9,
          "title": "",
          "score": 0.709,
          "base_score": 0.709,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "template typename",
          "typename template",
          "int",
          "tuple",
          "rel"
        ],
        "semantic": [],
        "merged": [
          "template typename",
          "typename template",
          "int",
          "tuple",
          "rel"
        ]
      },
      "topic_id": 11,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.588644230085451,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.451814+00:00"
      }
    },
    {
      "chapter_number": 50,
      "title": "Segment 50 (pages 1600-1629)",
      "start_page": 1600,
      "end_page": 1629,
      "summary": "template<typename T> void f(T);\nvoid f(int)\nstd::cout << \"::f(int) called\\n\";\ntemplate<typename T>\nclass C {\nfriend void f(C<T> const&);\nvoid g (C<int>* p)\nf(*p); is £(C<int> const&) visible here?\nclass C {\nint f()\ntemplate<template<typename> class TT> class X {\ntemplate<typename T> class C {\ntemplate<int I, typename...\ntemplate<typename T> class Node {\ntemplate<typename T> class C {\nC<Type>* c2; /f C<Type> refers to a current instantiation\ntemplate<> struct C<int>::I {\ntemplate<int I> struct X f{\ntemplate<> struct X<0> {\nint n = a F<::)il; HM valid in C++98/C++03, but notin C++I1\ntemplate<typename T>\ntemplate<typename T>\nusing x = int; Hf #3 xis a type here\ntemplate<typename, T>\ntypename, X<T> f() {\ntypename, X<int>::C * s;\ntemplate<typename T>\ntemplate<int N>\nclass In {\ntemplate<int M>\ntemplate<typename T, int N>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\nclass X {\ntemplate<int I> void select (X*);\nvoid g (N::X* xp)\ntemplate<typename T> void select();\ntemplate<typename T> void typeDependenti(T x)\ntemplate<typename T> void typeDependent2(T x)\ntemplate<int N> void valueDependenti1()\ntemplate<typename T> void valueDependent2(T x)\ntemplate<typename T> void maybeDependent(T const& x)",
      "keywords": [
        "template",
        "int",
        "typename",
        "Type",
        "void",
        "count",
        "refers",
        "public",
        "BXT",
        "Node",
        "current instantiation",
        "const",
        "Magic",
        "instantiation",
        "count refers"
      ],
      "concepts": [
        "void",
        "template",
        "count",
        "type",
        "instantiation",
        "refers",
        "magic",
        "node",
        "static",
        "qualified"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 53,
          "title": "",
          "score": 0.905,
          "base_score": 0.755,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 52,
          "title": "",
          "score": 0.878,
          "base_score": 0.728,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 9,
          "title": "",
          "score": 0.754,
          "base_score": 0.754,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 51,
          "title": "",
          "score": 0.737,
          "base_score": 0.737,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 11,
          "title": "",
          "score": 0.715,
          "base_score": 0.715,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "template typename",
          "int",
          "void",
          "typename void",
          "template int"
        ],
        "semantic": [],
        "merged": [
          "template typename",
          "int",
          "void",
          "typename void",
          "template int"
        ]
      },
      "topic_id": 9,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5490441959948182,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.451903+00:00"
      }
    },
    {
      "chapter_number": 51,
      "title": "Segment 51 (pages 1630-1663)",
      "start_page": 1630,
      "end_page": 1663,
      "summary": "template<int x> void nondependentCall()\ntemplate<int N> void instantiationDependentBound()\nusing T = int;\nclass D1: public Base<Base<void>> { //not a template case really\nvoid f() { basefield = 3; } // usual access to inherited member\ntemplate<typename T>\nvoid f() { basefield = 7; } // usual access to inherited member\nvoid g (D2<int*>& d2, int* p)\ntemplate<typename T>\ntemplate<typename T>\nM Variation 2:\ntemplate<typename T>\nclass D : public B<T> f{\nvoid f() { basefield = 0; } W#2 fine\nvoid f() {\ntemplate<typename T> class C;\nvoid g (C<int>& c)\n4 #5 use class template declaration only\n// #6 use class template definition;\nvoid candidate(int) { } Hf #2\ntemplate<typename T> T f (T p) { return 2*p; }\ntemplate<typename T> class Q {\ntemplate<int N>\ntemplate<typename T, int N>\ntemplate<typename> void g() {}\ntemplate<typename> void f() {}\ntemplate<typename T> void h(T P) {\nf<int>(p);  // #1\nvoid g(Int)\nf<Int>(42); / point of call\nvoid f1(T x)\nvoid gi(int)\nclass S {\nusing I = int;\nvoid f()\nvoid helper (S<int>*) ;\nvoid helper (S<int>* s)\ntemplate void f<int>(int) ;\ntemplate void f<>(float);\ntemplate void f (long) ;\ntemplate void f(char);\ntemplate void S<int>::f(;\ntemplate class 8<void>;\ntemplate<typename T> void £(); /no definition: prevents instantiation\nf<int>();\ntemplate<typename T> void f()\ntemplate void f<int>(); /f manual instantiation\nvoid g();\ntemplate<typename T> void £(); //no definition: prevents instantiation\ntemplate<typename T> void f() //definition\ntemplate void f<int>(); // manual instantiation\ntemplate<typename T> void f£()\nextern template void f<int>(); // declared but not defined\nextern template void f<float>(); //declared but not defined\ntemplate void f<int>(); 4 definition\ntemplate void f<float>(); // definition\ntemplate<typename T> bool f(T p) {\n+} else f{\ntemplate<typename T> bool f(T p) f\nbool g(int n) f\nvoid f(Head&& h, Remainder&&...\nvoid g() f{",
      "keywords": [
        "void",
        "template",
        "int",
        "typename",
        "Base",
        "public Base",
        "public",
        "template void",
        "class Base",
        "type",
        "int main",
        "ERROR",
        "definition",
        "basefield",
        "bool"
      ],
      "concepts": [
        "template",
        "public",
        "definition",
        "instantiations",
        "instantiated",
        "instantiation",
        "danger",
        "base",
        "member",
        "declaration"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 11,
          "title": "",
          "score": 0.91,
          "base_score": 0.76,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 47,
          "title": "",
          "score": 0.872,
          "base_score": 0.722,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 68,
          "title": "",
          "score": 0.871,
          "base_score": 0.721,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 9,
          "title": "",
          "score": 0.869,
          "base_score": 0.719,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 53,
          "title": "",
          "score": 0.78,
          "base_score": 0.78,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "void",
          "template void",
          "int",
          "template typename",
          "void int"
        ],
        "semantic": [],
        "merged": [
          "void",
          "template void",
          "int",
          "template typename",
          "void int"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.549026194661493,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.452012+00:00"
      }
    },
    {
      "chapter_number": 52,
      "title": "Segment 52 (pages 1664-1696)",
      "start_page": 1664,
      "end_page": 1696,
      "summary": "void f (int* p)\nint x = at(p, 7);\ntemplate<typename T> void f(T); parameterized type P is T\ntemplate<typename T> void g(T&); //parameterized type P is also T\ng(seven); //reference parameter; Tis int const\ng(7); // reference parameter: Tis int => ERROR: can't pass T to int&\ntemplate<typename FE, int N>\nvoid g (int*** ppp)\ntemplate<int N>\nusing I = int;\nvoid f(int) {\ntemplate<int N>\ntemplate<typename T> void f(T p);\ntemplate<typename T> void f(std::initializer_list<T>) ;\nf({*’a’, ’e’, ?i’, *0’, °’u’, 423); A ERROR: T deduced to both char and int\nvoid g(int i, double j, int* k)\nvoid foo(pair<int, float> pif, pair<int, double> pid,\nhi(pif, pid); / OK: deduces T to int, Rest to {float, double}\nh2(pif, pid); // OK: deduces Ts to {int, int}, Rest to {float, double}\nh2(pif, pdd); // OK: deduces Ts to {int, double}, Rest to {float, double}\nvoid bar (Tuple<short, int, long> sv,\nfi€sv, sv); “OK: Types is deduced to {short, int, long}\n“ Types2 is deduced to {short, int, long}\nfi(sv, uv); “ERROR: Types is deduced to {short, int, long} from the Ist arg, but\nf£2(sv, uv); /OK: Typesi is deduced to {short, int, long},\ntemplate<char...> int operator \"\" _B7({); “#1\nint a = 121_B7; Mf #2\nint operator\"\" _B7()\nint i = 42;\ntemplate<typename T> void £(T&& p); //pisa forwarding reference\nint i;\n£(j)}; M4 argument is an lvalue; deduces T to int const&\n/f parameter p has type int const&\n// parameter p has type int&&\nvoid g(C const&) ;\ntemplate<typename T> void forwardToG(T&& x)\nvoid g(int*) ;\ntemplate<typename T> void forwardToG(T&& x)\ng(0); // calls g (int*)\nforwardToG(nullptr) ; // eventually calls g(int*)\nvoid int_lvalues(int&) ; “4 accepts lvalues of type int\ntemplate<typename T> void lvalues(T&); / accepts lvalues of any type\nvoid int_rvalues(int&g&) ; // accepts rvalues of type int",
      "keywords": [
        "int",
        "typename",
        "template",
        "void",
        "Rest",
        "ERROR",
        "type int",
        "type int template",
        "type",
        "struct Fact",
        "int const",
        "Fact",
        "const",
        "double",
        "std"
      ],
      "concepts": [
        "void",
        "deduces",
        "deduced",
        "double",
        "type",
        "char",
        "error",
        "std",
        "reference",
        "pair"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 53,
          "title": "",
          "score": 0.993,
          "base_score": 0.843,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 50,
          "title": "",
          "score": 0.878,
          "base_score": 0.728,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 49,
          "title": "",
          "score": 0.751,
          "base_score": 0.751,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 8,
          "title": "",
          "score": 0.726,
          "base_score": 0.726,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 4,
          "title": "",
          "score": 0.725,
          "base_score": 0.725,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "int",
          "void",
          "sv",
          "typename void",
          "pif"
        ],
        "semantic": [],
        "merged": [
          "int",
          "void",
          "sv",
          "typename void",
          "pif"
        ]
      },
      "topic_id": 9,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5747327097037763,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.452120+00:00"
      }
    },
    {
      "chapter_number": 53,
      "title": "Segment 53 (pages 1697-1728)",
      "start_page": 1697,
      "end_page": 1728,
      "summary": "template<typename T>\ntemplate<typename T>\ntemplate<typename Container>\ntemplate<typename T>\nf<int&>(0, 0); / ERROR: substituting int& for T in the first function template\ntemplate<typename T> auto f(T p) {\ntemplate<typename T> auto g(T p) -> decltype(f(p));\ntemplate<typename T> void f(B<T>*) ;\ntemplate<typename T> int f(T, typename T::X);\nint r = f(v, 7.0); 4 OK: T is deduced to int through the first parameter,\nS x(12); “ERROR before C++17: the class template parameter T was not deduced from\nvoid f (T x = 42)\nvoid g(T, int) throw(typename T::Nonexistent); // #1\ntemplate<typename T> void compute(T p)\ntemplate<typename T> T f(T); W#2\ntemplate<typename> void f();\nfriend int f<>(); // ERROR: return type conflict\ntemplate<typename T> typename T::EType f(); “#1\ntemplate<typename T> T f(); MH #2\nauto x = f<int*>();\nauto x = f<int*>; // OR: x is a pointer to function\ntemplate<typename T> void f(T);\ntemplate<typename T> void f(T, T);\nint main() f{\nauto x = f<int*>; // ERROR: there are two possible £<int*> here\nint main() f{\nf<double, int>(1, 2, 3); OK: the template arguments are <double, int, int>\ntemplate<typename Container>\ntemplate<typename T> void deducePos(T pos) ;\ntemplate<typename t> void £(T&& fr); //auto replaced by template parameter T\nint x;\ntemplate<typename Container> void g(Container c) {",
      "keywords": [
        "typename",
        "template",
        "int",
        "int main",
        "typename Container",
        "void",
        "Container",
        "main",
        "auto",
        "array",
        "ERROR",
        "template parameter",
        "double",
        "parameter",
        "std"
      ],
      "concepts": [
        "template",
        "auto",
        "container",
        "std",
        "void",
        "begin",
        "reference",
        "pos",
        "array",
        "main"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 52,
          "title": "",
          "score": 0.993,
          "base_score": 0.843,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 50,
          "title": "",
          "score": 0.905,
          "base_score": 0.755,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 9,
          "title": "",
          "score": 0.806,
          "base_score": 0.806,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 11,
          "title": "",
          "score": 0.794,
          "base_score": 0.794,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 14,
          "title": "",
          "score": 0.781,
          "base_score": 0.781,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "template typename",
          "int",
          "container",
          "typename void",
          "typename container"
        ],
        "semantic": [],
        "merged": [
          "template typename",
          "int",
          "container",
          "typename void",
          "typename container"
        ]
      },
      "topic_id": 9,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5868251664823566,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.452208+00:00"
      }
    },
    {
      "chapter_number": 54,
      "title": "Segment 54 (pages 1729-1761)",
      "start_page": 1729,
      "end_page": 1761,
      "summary": "auto const N = 400u; // OK: constant of type unsigned int\nauto const S::¥*pm = &X<int>::m; WOK: pmhas type int const X<int>::*\nX<auto> xa = X<int>(); // ERROR: auto in template argument\nint const auto::*pm2 = &X<int>::m; // ERROR: auto is part of the “declarator”\nint gO {\nauto int r = 24; /valid in C++03 but invalid in C++I/1\nauto lm = []) (int x) { return f(x); };\n/sameas: [] (int x) -> auto { return f(x); };\ntemplate<auto V> struct Value {\ntemplate<auto PMD> struct CounterHandle {\nint i:\ntemplate<auto V1, decltype(V1)...\nauto x = ref; // x1 has type int and is a new independent object\ndecltype(auto) y = ref; “y has type int const& and also refers toi\nauto x = v[0]; f/x denotes anew object of type int\ndecltype(auto) y = v0]; /y isa reference (type int&)\ndecltype(auto) z = x; // object of type int\ndecltype(auto) r = (x); // reference of type int&\ndecltype(auto) £0 {\ntemplate<decltype(auto) Val> class §\ntemplate<auto N> int f£(S<N> p);\ntemplate<auto V> int f(decltype(V) p);\nint r2 = deduce(42); // ERROR: decltype(V) is a nondeduced context\nauto primes = { 2, 3, 5, 7 }; // primes is std: :initializer_list<int>\nauto val { 2 }; /f OK: val has type int in C++17",
      "keywords": [
        "int",
        "decltype",
        "auto",
        "type int",
        "type",
        "type int const",
        "int const",
        "std",
        "ERROR",
        "const",
        "typename",
        "template",
        "struct",
        "type int decltype",
        "PMD"
      ],
      "concepts": [
        "auto",
        "template",
        "returns",
        "std",
        "error",
        "value",
        "void",
        "type",
        "object",
        "refers"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 53,
          "title": "",
          "score": 0.745,
          "base_score": 0.745,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 55,
          "title": "",
          "score": 0.709,
          "base_score": 0.709,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 52,
          "title": "",
          "score": 0.646,
          "base_score": 0.646,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 56,
          "title": "",
          "score": 0.644,
          "base_score": 0.644,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.643,
          "base_score": 0.643,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "auto",
          "int",
          "int decltype",
          "type int",
          "decltype"
        ],
        "semantic": [],
        "merged": [
          "auto",
          "int",
          "int decltype",
          "type int",
          "decltype"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.51921079707359,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.452295+00:00"
      }
    },
    {
      "chapter_number": 55,
      "title": "Segment 55 (pages 1762-1792)",
      "start_page": 1762,
      "end_page": 1792,
      "summary": "auto e@ =c, f = ctl: // ERROR: deduction mismatch char vs.\nint\nauto f(bool b) {\nauto f(int n)\nreturn n*f(n-1); // ERROR: type of £(n-1) unknown\nauto f{int n)\nreturn 1; // return type is deduced to be int\nreturn n*f(n-1); // OK: type of £ (n-1) is int and so is type of n*£ (n-1)\nauto f1() { } // OK: return type is void\nauto £2() { return; } // OK: return type is void\nauto* £3() {} // ERROR; auto* cannot deduce as void\nauto& [x, y, zl] = pt;\nauto f£() -> int(&)[2]; “£0 returns reference to int array\nstd: :tuple<bool, int> bi{true, 42};\ntemplate<> class std: :tuple_size<M> {\ntemplate<> class std::tuple_element<0, M> {\ntemplate<> class std::tuple_element<1, M> {\ntemplate<int> auto get(M);\ntemplate<> auto get<0O>(M) { return 42; }\ntemplate<> auto get<1>(M) { return 7.0; }\nauto [i, dJ) = MQ); A/asif: int&& i = 42; double&& d = 7.0;\nint.\nSomeCompilerSpectficNameY(int x, int y) //only callable by the compiler\nbool operator() (int i) const f{\nreturn i > _x && i < _y;\nficintStack) ; /f OR: T deduced to int, Cont deduced to std: :deque<int>\ntemplate<> using A<int> = void; //ERROR, but suppose it were possible...\n# OB in C++/17: T1 is int, T2 is double, T3 is char const*\nff OK in C++4+17: T1 is int, T2 and T3 are double\nS x{i2}; // OB since C++17, same as: S<int> x{i2};\nS yci2): // OR since C++17, same as: S<int> y(12);\nauto z = S${12}; “WOK since C++17, same as: auto z = S<int>{12};",
      "keywords": [
        "typename",
        "int",
        "auto",
        "template",
        "ERROR",
        "Iter",
        "std",
        "type",
        "tuple",
        "typename Iter",
        "void",
        "public",
        "element",
        "double",
        "return type"
      ],
      "concepts": [
        "auto",
        "template",
        "returns",
        "public",
        "void",
        "error",
        "std",
        "value",
        "deduces",
        "deduced"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 54,
          "title": "",
          "score": 0.709,
          "base_score": 0.709,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 57,
          "title": "",
          "score": 0.707,
          "base_score": 0.707,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 49,
          "title": "",
          "score": 0.701,
          "base_score": 0.701,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 52,
          "title": "",
          "score": 0.67,
          "base_score": 0.67,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 53,
          "title": "",
          "score": 0.663,
          "base_score": 0.663,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "auto",
          "int",
          "return",
          "auto int",
          "void auto"
        ],
        "semantic": [],
        "merged": [
          "auto",
          "int",
          "return",
          "auto int",
          "void auto"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5211860388493591,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.452381+00:00"
      }
    },
    {
      "chapter_number": 56,
      "title": "Segment 56 (pages 1793-1823)",
      "start_page": 1793,
      "end_page": 1823,
      "summary": "template<typename T>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T> struct X {\ntemplate<typename Iter> X(Iter b, Iter e);\ntemplate<typename Iter> auto f(Iter b, Iter e) {\nreturn X(b, e); “4 What ts this?\ntemplate<typename T> struct Y {\ntemplate<typename T, typename U> struct Z {\ntemplate<typename T> Z(T const&) -> Z<T, T&>; Mf #1\nint> 2212}:\ntemplate<typename ...\ntemplate<typename...\ntemplate<typename...\ntemplate<typename T> struct X {\ntemplate<typename T> struct Y {\ntemplate<typename T> Y(X<T>) -> Y<T>;\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\ndetatls/funcoverload1.cpp\nstd::cout << f<int*>((int*)nullptr); / calls £<T>(T)\nstd::cout << f<int>((int*)nullptr); /calls £<T>(T*)\nstd::cout << f<int*>((int*)nullptr); //calls £<T>(T)\nstd::cout << f<int>((int*)nullptr) ; // calls £<T>(T*)\nint £(T*)\nstd::cout << f(nullptr); #/ calls £<T>(T)\nstd::cout << f£((int*)nullptr); / calls £<T>(T*)\nvoid example(int* p)\nstd::string f(int const&)\nint\nstd::cout << f(x) << ’\\n’; /prints: Template",
      "keywords": [
        "typename",
        "template",
        "int",
        "std",
        "ERROR",
        "Tuple",
        "typename Iter",
        "Array",
        "void",
        "Iter",
        "cout",
        "const",
        "char",
        "struct",
        "nullptr"
      ],
      "concepts": [
        "template",
        "std",
        "void",
        "array",
        "vector",
        "include",
        "type",
        "exchange",
        "data",
        "error"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 48,
          "title": "",
          "score": 0.945,
          "base_score": 0.795,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 29,
          "title": "",
          "score": 0.86,
          "base_score": 0.71,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 65,
          "title": "",
          "score": 0.786,
          "base_score": 0.636,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 69,
          "title": "",
          "score": 0.76,
          "base_score": 0.61,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 53,
          "title": "",
          "score": 0.702,
          "base_score": 0.702,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "template typename",
          "nullptr calls",
          "iter",
          "int nullptr",
          "nullptr"
        ],
        "semantic": [],
        "merged": [
          "template typename",
          "nullptr calls",
          "iter",
          "int nullptr",
          "nullptr"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5155187930073859,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.452469+00:00"
      }
    },
    {
      "chapter_number": 57,
      "title": "Segment 57 (pages 1824-1855)",
      "start_page": 1824,
      "end_page": 1855,
      "summary": "return \"Template\";\nstd::cout << \"template constructor\\n\";\nint f(T*)\nint f(Ts...)\nstd::cout << f((int*)nullptr, (double*)nullptr); / calls f<>(Ts*...)\nstd::cout << f((int*)nullptr) ; Hf calls £<>(T*)\nf<int*,double*>((int*)nullptr, (double*)nullptr) /for second template\nf<int ,double>((int*)nullptr, (double*)nullptr) // for third template\ndetatls/tupleoverload.cpp\nint f(Tuple<T+*>)\nint f(Tuple<Ts...>)\nint f(Tuple<Ts*...>)\nstd::cout << f£(Tuple<int, double>()); 4 calls £<>(Tuple<Ts..\nstd::cout << f(Tuple<int*, double#>()); “calls £<>(Tuple<Ts*...>)\nstd::cout << f(Tuple<int*>()); “4 calls £<>(Tuple<T*>)\ntemplate<>\nclass S<void> {\nclass 5S;\ntemplate<> class S<char+**> {\ntemplate<>\nclass Qutside<void> {\n/f the following definition cannot be preceded by template<>\ntemplate<>\ntemplate<>\nclass Danger<void> {\nint f(T) Mf #1\ntemplate<> int f(int) //OK: specialization of #1\ntemplate<> int f (int*) // OK: specialization of #2\nint f(T, T x = 42)\ntemplate<> int f(int, int = 35) / ERROR\ntemplate<> constexpr std::size_t SZ<void> = 0;\nclass Outer f{\ntemplate<>\nvoid print() const f{\ntemplate<>\ntemplate<>\ntemplate<>\nint Outer<void>::code;\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<>\ntemplate<> class Outer<X>::Inner<void>; //ERROR\ntemplate<>",
      "keywords": [
        "template",
        "typename",
        "int",
        "Tuple",
        "void",
        "Outer",
        "std",
        "class Outer",
        "cout",
        "public",
        "static int",
        "static int count",
        "int Outer",
        "double",
        "const"
      ],
      "concepts": [
        "template",
        "void",
        "std",
        "public",
        "count",
        "char",
        "inner",
        "outer",
        "specialized",
        "special"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 49,
          "title": "",
          "score": 0.754,
          "base_score": 0.754,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 58,
          "title": "",
          "score": 0.743,
          "base_score": 0.743,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 50,
          "title": "",
          "score": 0.711,
          "base_score": 0.711,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 55,
          "title": "",
          "score": 0.707,
          "base_score": 0.707,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 52,
          "title": "",
          "score": 0.67,
          "base_score": 0.67,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "int",
          "outer",
          "template template",
          "tuple",
          "ts std"
        ],
        "semantic": [],
        "merged": [
          "int",
          "outer",
          "template template",
          "tuple",
          "ts std"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5431184215386948,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.452555+00:00"
      }
    },
    {
      "chapter_number": 58,
      "title": "Segment 58 (pages 1856-1886)",
      "start_page": 1856,
      "end_page": 1886,
      "summary": "template<typename T>\ntemplate<>\nclass List<void+> { #3\ntemplate<typename T, int I = 3>\nclass §; #f primary template\ntemplate<typename T>\ntemplate<typename T = int>\ntemplate<int I>\ntemplate<typename U, int K>\ntemplate<typename...\ntemplate<typename C>\ntemplate<typename T, typename C>\ntemplate<typename...\nclass Tuple; // primary template\ntemplate<typename T1>\ntemplate<typename T> constexpr std::size_t SZ = sizeof(T);\ntemplate<typename T> constexpr std::size_t SZ<T&> = sizeof (void*);\ntemplate<typename T, std::size_t N> T* null_iterator<T[N]> = null_ptr;\n/# invalid overloading of class templates\ntemplate<typename T1, typename T2> class Pair;\ntemplate<int Ni, int N2> class Pair;\ntemplate<typename T>\ntemplate<typename T>\ntemplate<typename T>\nvoid add (Tk x, int i); /#aprimary template\ntemplate<typename T1, typename T2>\nvoid add (Ti a, T2 b); // another (overloaded) primary template\ntemplate<typename T>\nvoid add<T+#> (T*&, int); /“ Which primary template does this specialize?\ntemplate<typename T,\ntemplate<typename T,\ntemplate<typename T>\ntemplate<typename T, unsigned Size>\ntemplate<typename...\ntemplate<typename FrontT, typename...\ntemplate<typename...\ntemplate<typename...\ntemplate<typename T, typename...\ntemplate<typename T, typename...\ntemplate<typename T>\ntemplate<typename T> requires LessThanComparable<T>\ntemplate<typename T> void report(T p) {\ntemplate<> void report(X const& p) {",
      "keywords": [
        "typename",
        "template",
        "class Tuple",
        "Tuple",
        "void",
        "const",
        "int",
        "class List",
        "typename Tail",
        "std",
        "List",
        "char const",
        "ERROR",
        "primary template",
        "class Pair"
      ],
      "concepts": [
        "template",
        "std",
        "sized",
        "size",
        "error",
        "returns",
        "info",
        "type",
        "array",
        "list"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 49,
          "title": "",
          "score": 0.973,
          "base_score": 0.823,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 53,
          "title": "",
          "score": 0.76,
          "base_score": 0.76,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 57,
          "title": "",
          "score": 0.743,
          "base_score": 0.743,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 52,
          "title": "",
          "score": 0.721,
          "base_score": 0.721,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 48,
          "title": "",
          "score": 0.713,
          "base_score": 0.713,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "template typename",
          "typename template",
          "primary template",
          "void add",
          "class pair"
        ],
        "semantic": [],
        "merged": [
          "template typename",
          "typename template",
          "primary template",
          "void add",
          "class pair"
        ]
      },
      "topic_id": 11,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5988236140919673,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.452641+00:00"
      }
    },
    {
      "chapter_number": 59,
      "title": "Segment 59 (pages 1887-1917)",
      "start_page": 1887,
      "end_page": 1917,
      "summary": "void f(Head&& h, Remainder&&...\n#include \"coord.hpp\"\nclass GeoObj {\n/f draw geometric object:\nvirtual void draw() const = 0;\n#f concrete geometric object class Circle\n#include \"dynahier.hpp\"\n#f draw any GeoObj\nvoid myDraw (Geo0bj const obj)\n/f compute distance of center of gravity between two GeoObjs\nCoord distance (GeoObj const& x1, GeoObj const& x2)\nvoid drawElems (std::vector<Geo0bj*> const& elems)\nvoid myDraw (Geo0bj const& obj) // GeoObj is abstract base class\nvoid myDraw (GeoObj constk obj) // GeoObj is template parameter\n#include \"coord.hpp\"\nvoid draw() const;\n#f - not derived from any class\nvoid draw({) const;\n#include \"statichier.hpp\"\nvoid myDraw (Geo0bj const& obj)\nobj .draw() ; f/f call draw() according to type of object\n/f compute distance of center of gravity between two GeoObjs\nCoord distance (Geo0bji const& x1, GeoObj2 const& x2)\nHf draw homogeneous collection af GeoObjs\nvoid drawElems (std::vector<Geo0bj> const& elems)\n#include \"coord.hpp\"\n#include \"conceptsreq.hpp\"\nvoid myDraw (T const& obj)\nvoid draw() const;\ntemplate<typename Iterator>\nusing const_iterator = ...;\nconst_iterator end() const;\nusing const_iterator = ...;\nconst_iterator end() const;\n#include \"MyClass.hpp\"\nT accum (T const* beg, T const* end)\n#include \"accumi.hpp\"\nthe average value of the characters in \"templates\" is -5\ntraits/accume.hpp\n#include \"accumtraits2.hpp\"\nauto accum (T const* beg, T const* end)\n/f return type is traits of the element type\nAccT total{}; assume this actually creates a zero value\nthe average value of the characters in \"templates\" is 108\nAccT total{}; assume this actually creates a zero value\nstatic AccT const zero = 0;\nstatic AccT const zero = 0;\nstatic AccT const zero = 0;\ntraits/accum3.hpp\n#include \"accumtraits3.hpp\"\nauto accum (T const* beg, T const* end)\nAccT total = AccumulationTraits<T>::zero; //init total by trait value\nAccT total = AccumulationTraits<T>: :zero;",
      "keywords": [
        "const",
        "typename",
        "ACCUM",
        "include",
        "AccT",
        "object class Circle",
        "struct AccumulationTraits",
        "template",
        "class Circle",
        "Iterator",
        "AccumulationTraits",
        "void",
        "hpp",
        "gravity",
        "draw"
      ],
      "concepts": [
        "template",
        "values",
        "include",
        "draw",
        "std",
        "total",
        "end",
        "distance",
        "zero",
        "vector"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 65,
          "title": "",
          "score": 0.656,
          "base_score": 0.506,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 56,
          "title": "",
          "score": 0.611,
          "base_score": 0.461,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 48,
          "title": "",
          "score": 0.561,
          "base_score": 0.411,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 69,
          "title": "",
          "score": 0.528,
          "base_score": 0.378,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 29,
          "title": "",
          "score": 0.5,
          "base_score": 0.35,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "draw",
          "acct",
          "const",
          "hpp",
          "geoobj"
        ],
        "semantic": [],
        "merged": [
          "draw",
          "acct",
          "const",
          "hpp",
          "geoobj"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.359352549312303,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.452721+00:00"
      }
    },
    {
      "chapter_number": 60,
      "title": "Segment 60 (pages 1918-1952)",
      "start_page": 1918,
      "end_page": 1952,
      "summary": "struct AccumulationTraits<BigInt> {\nstruct AccumulationTraits<BigInt> {\ntraits/accumtraits4.hpp\nstruct AccumulationTraits;\nstruct AccumulationTraits<int> {\nstruct AccumulationTraits<unsigned int> {\ntraits/accumtraits,bigint.hpp\nstruct AccumulationTraits<BigInt> {\nAccT total = AccumulationTraits<T>::zero(); //init total by trait function\nhpp\n#include \"accumtraits4.hpp\"\ntypename AT::AccT total = AT::zero();\ntraits/accum6.hpp\n#include \"accumtraits4.hpp\"\n#include \"sumpolicyl.hpp\"\ntypename Traits AccumulationTraits<T>>\nusing AccT = typename Traits: :AccT;\nAccT total = Traits::zero():\ntraits/sumpolicyl.hpp\nstatic void accumulate (T1i& total, T2 const& value) {\n#include \"accum6.hpp\"\nstatic void accumulate (Ti& total, T2 const& value) f{\nstatic void accumulate (T1& total, T2 const& value) {\nhpp\n#include \"accumtraits4.hpp\"\n#include \"sumpolicy2.hpp\"\ntypename Traits = AccumulationTraits<T>>\nusing AccT = typename Traits: :AccT;\nAccT total = Traits: :zero();\ntratts/accum0.hpp\nusing VT = typename std: :iterator_traits<Iter>: :value_type;\nstruct iterator_traits<T*> {\nvalue_type\nstatic std::size_t const value = sizeof(T);\nstd::cout << \"TypeSize<int>::value = \"\ntraits/elementtype.hpp\ntemplate<typename T, std::size_t N>\n#include \"elementtype.hpp\"\n<< typeid(typename ElementT<T>: :Type) .name()\nusing Type = typename C::value_type;\ntypename ElementT<C>::Type sum0fElements (C const& c);\nusing ElementType = typename ElementT<T>: :Type;\nhpp\nusing AddLValueReference = typename AddLValueReferenceT<T>: :Type;\nstruct AddLValueReferenceT<void> {\nstruct AddLValueReferenceT<void const> {\nusing Type = void const;\nstruct AddLValueReferenceT<void volatile> {\nstruct AddLValueReferenceT<void const volatile> {\nusing Type = void const volatile;\ntraits/removeconst.hpp\nstruct RemoveConstT<T const> {\nusing RemoveConst = typename RemoveConstT<T>: :Type;\ntraits/removecv.hpp\n#include \"removeconst.hpp\"\n#include “removevolatile.hpp\"\nstruct RemoveCVT : RemoveConstT<typename RemoveVolatileT<T>::Type> {\n#include <type_traits>\n<< std::is_same<A,int>::value << ’\\n’;\n<< std::is_const<A>::value << ’\\n’;",
      "keywords": [
        "typename",
        "type",
        "hpp",
        "template",
        "ACCUM",
        "struct",
        "struct AccumulationTraits",
        "AccT",
        "traits",
        "const",
        "include",
        "typename Traits",
        "BigInt",
        "static constexpr AccT",
        "AccumulationTraits"
      ],
      "concepts": [
        "traits",
        "include",
        "std",
        "total",
        "value",
        "type",
        "void",
        "zero",
        "bounds",
        "end"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 64,
          "title": "",
          "score": 0.736,
          "base_score": 0.586,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 33,
          "title": "",
          "score": 0.72,
          "base_score": 0.57,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.686,
          "base_score": 0.536,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.675,
          "base_score": 0.525,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 63,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "hpp",
          "accumulationtraits",
          "acct",
          "traits",
          "total"
        ],
        "semantic": [],
        "merged": [
          "hpp",
          "accumulationtraits",
          "acct",
          "traits",
          "total"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4380008621965448,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.452807+00:00"
      }
    },
    {
      "chapter_number": 61,
      "title": "Segment 61 (pages 1953-1984)",
      "start_page": 1953,
      "end_page": 1984,
      "summary": "using Type = T*;\ntemplate<typename T, std::size_t N>\nusing Type = T*;\n#include <type_traits>\nstd::cout << \"Parameter type:\nstd::cout << \"- is int: \"\nType;\n<< std::is_same<A,int>::value << ’\\n’;\n<< std::is_const<A>::value << ’\\n’;\nstatic constexpr bool value\nstatic constexpr bool value = true;\nif (IsSameT<T, int>::value) ...\nconstexpr bool isSame = IsSameT<T1, T2>:: value;\nstatic constexpr bool value = val;\nstruct IsSameT : FalseType\nstruct IsSameT<T, T> : TrueType\nstd::cout << \"foolmpl(T,true) for int called\\n\";\nstd::cout << \"fooImpl(T,false) for other type called\\n\";\nusing IsSame = typename IsSameT<T>: :Type;\nusing false_type\nusing false_type\nArray<typename PlusResultT<T1, T2>::Type>\nusing PlusResult = typename PlusResultT<T1, T2>::Type;\nusing PlusResult = typename PlusResultT<T1, T2>::Type;\nstatic char test(void*);\nstatic constexpr bool value\n= IsSameT<decltype(test<T>(nullptr)), char>::value;\ntemplate<...> static char test(void*) ;\ntemplate<...> static long test(...);\nstatic constexpr bool value\n= IsSameT<decltype(test<...>(nullptr)), char>::value;\nstatic char test(void*);\nstatic constexpr bool value\n= IsSameT<decltype(test<T>(nullptr)), char>::value;\ntemplate<...> static char test (void*) ;",
      "keywords": [
        "typename",
        "Type",
        "Array",
        "template",
        "std",
        "struct",
        "static",
        "bool",
        "Args",
        "const",
        "IsSameT",
        "int",
        "struct DecayT",
        "include",
        "static constexpr bool"
      ],
      "concepts": [
        "template",
        "type",
        "std",
        "traits",
        "static",
        "include",
        "void",
        "array",
        "char",
        "called"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 79,
          "title": "",
          "score": 0.928,
          "base_score": 0.778,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 63,
          "title": "",
          "score": 0.9,
          "base_score": 0.75,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 81,
          "title": "",
          "score": 0.871,
          "base_score": 0.721,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.858,
          "base_score": 0.708,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 64,
          "title": "",
          "score": 0.83,
          "base_score": 0.68,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "issamet",
          "constexpr bool",
          "bool value",
          "test",
          "static constexpr"
        ],
        "semantic": [],
        "merged": [
          "issamet",
          "constexpr bool",
          "bool value",
          "test",
          "static constexpr"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5716177198859358,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.452895+00:00"
      }
    },
    {
      "chapter_number": 62,
      "title": "Segment 62 (pages 1985-2015)",
      "start_page": 1985,
      "end_page": 2015,
      "summary": "template<...> static SizeiT test(void*); checking test()\ntemplate<...> static Size2T test(...); /f fallback\ntemplate<...> static std::true_type test(void*); checking test(\ntemplate<...> static std::false_type test(...); MH fallback\nusing Type = decltype(test<FROM>(nullptr));\nstatic std::true_type test (voids) ;\nstatic std::false_type test(...);\nusing Type = decltype(test<T>(nullptr)) ;\n#include <type_traits> //defines true_type and false_type\ntemplate<typename...> using VoidT = void;\nstruct IsDefaultConstructibleT : std::false_type\nstruct IsDefaultConstructibleT<T, VoidT<decltype(T())>> : std::true_type\ntypename = decltype(std: :declval<F>() (std: :declval<Args&&>()...))>\nstd::true_type isValidImpl (void*) ;\nstd::false_type isValidImpl(...);\n// helper template to represent a type as a value\n= isValid([] (auto x) -> decltype((void)valueT(x).first) f\nusing Type = decltype(std: :declval<T1>() + std: :declval<T2>());\nArray<typename PlusResultT<T1i, T2>::Type>\nArray<typename PlusResultT<T1i, T2>::Type>\nusing Type = decltype(std: :declval<T1i>() + std: :declval<T2>());\n#include <type_traits> //for true_type, false_type, and void_t\ntemplate<typename, typename, typename = std: :void_t<>>\nstruct HasPlusT : std::false_type\nstruct HasPlusT<T1, T2, std: :void_t<decltype(std: :declval<T1i>()\n: std::true_type\nusing Type = decltype(std: :declval<T1i>() + std: :declval<T2>());\ntemplate<typename C, bool = HasMemberT_value_type<C>: :value>\n#include <type_traits> //for true_type and false_type\ntypename = decltype(aux(std: :declval<F>()))>\nstatic std::true_type test(void*) ;\nstatic std::false_type test(...);\nusing Type = decltype(test<FROM>(nullptr)) ;\ntemplate<...> static std::true_type test (void*) ;\ntemplate<...> static std::false_type test(...);\nusing Type = decltype(test<FROM>(nullptr)) ;\ntemplate<typename = decltype(aux(std: :declval<FROM>()))>\ntemplate<typename F, typename = decltype(aux(std: :declval<F>()))>",
      "keywords": [
        "typename",
        "type",
        "std",
        "type test",
        "template",
        "decltype",
        "Array",
        "void",
        "static std",
        "struct",
        "static",
        "declval",
        "checking test",
        "args",
        "auto"
      ],
      "concepts": [
        "std",
        "voids",
        "type",
        "value",
        "array",
        "traits",
        "helper",
        "include",
        "char",
        "error"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 18,
          "title": "",
          "score": 0.922,
          "base_score": 0.772,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 81,
          "title": "",
          "score": 0.892,
          "base_score": 0.742,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 64,
          "title": "",
          "score": 0.882,
          "base_score": 0.732,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 63,
          "title": "",
          "score": 0.872,
          "base_score": 0.722,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.858,
          "base_score": 0.708,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "test",
          "declval",
          "std declval",
          "std",
          "decltype"
        ],
        "semantic": [],
        "merged": [
          "test",
          "declval",
          "std declval",
          "std",
          "decltype"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5280766852861509,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.452993+00:00"
      }
    },
    {
      "chapter_number": 63,
      "title": "Segment 63 (pages 2016-2049)",
      "start_page": 2016,
      "end_page": 2049,
      "summary": "#include <type_traits> //defines true_type and false_type\nstruct HasSizeTypeT : std::false_type\nstruct HasSizeTypeT<T, VoidT<typename T::size_type>> : std::true_type\nstd::cout << HasSizeTypeT<int>::value; //false\nusing size_type = std::size_t;\nstd::cout << HasSizeType<CX>: : value; //true\nstd::cout << HasSizeTypeT<CXR>: : value; // OK: prints true\nstd::cout << HasSizeTypeT<CX&>::value; “OOPS: prints false\nstd::cout << HasSizeTypeT<CXR&>::value; // OOPS: prints false\n: std::true_type {\n#include <type_traits> //for true_type, false_type, and void_t\ntemplate<typename, typename = std: :void_t<>>\n: std::false_type { };\nstruct HasTypeT_##MemType<T, std: :void_t<typename T: :MemType>>\n: std::true_type { } /; intentionally skipped\nstd::cout << “int::value_type: \"\n<< HasTypeT_value_type<int>::value << ’\\n’;\nstd::cout << \"std::vector<int>::value_type: \"\n<< HasTypeT_value_type<std: :vector<int>>::value << ’\\n’;\nstd::cout << \"std::iostream::value_type: \"\n<< HasTypeT_value_type<std::iostream>::value << ’\\n’;\nstd::cout << \"std::iostream::char_type: \"\n<< HasTypeT_char_type<std: :iostream>::value << ’\\n’;\ntemplate<typename, typename = std: :void_t<>>\n: std::false_type { };\nstruct HasMemberT_##Member<T, std::void_t<decltype(&T: :Member) >>\n: std::true_type { } /; intentionally skipped\nHasMemberT_size<std: :vector<int>>::value << ’\\n’;\nHasMemberT_first<std: :pair<int,int>>::value << ’\\n’;\nstd::cout << HasMemberT_begin<std: :vector<int>>::value; //false\n#include <type_traits> / for true_type, false_type, and void_t\nstruct HasBeginT : std::false_type {\n: std::true_type {\n#include <type_traits> //for true_type, false_type, and void_t\nstruct HasLessT : std::false_type\nstruct HasLessT<Ti, T2, std: :void_t<decltype(std: :declval<T1>(\n: std::true_type\nstruct HasVariousT : std::false_type\n; std: :true_type\ncout << \"hasFirst: \" << hasFirst(type<pair<int,int>>) << ’\\n’; /true\n= isValid([] (auto x) -> typename decltype(valueT(x))::size_type {\nusing size_type = std::size_t;\ncout << hasLess(42, type<char>) << ’\\n’; MH yields true\ncout << hasLess(type<string>, type<string>) << ’\\n’; //yields true\ncout << hasLess(type<string>, type<int>) << °\\n’; # yields false\ncout << hasLess(type<string>, \"hello\") << ’\\n’; # yields true\n-> typename std: :decay_t<decltype(x)>::size_type f\nusing size_type = std::size_t;\ncout << \"size_type: \" << HasSizeTypeT<CX>::value << ’\\n’; // true\ncout << \"size_type: \" << HasSizeTypeT<int>::value << ’\\n’; // false\ncout << HasLessT<int, char>::value << ’\\n’; /f true\ncout << HasLessT<string, int>::value << ’\\n’; // false\nHasFirstI<std: :pair<int ,int>>: : value\nusing Type = IfThenElse<std: :is_integral<T>: : value\ntypename std: :make_unsigned<T>: : type,\ntypename std: :make_unsigned<T>: :type\nusing Type = typename std: :make_unsigned<T>: : type;\nusing Type = typename I[fThenElse<std: :is_integral<T>: : value\nusing Type = typename IfThenElse<std: :is_integral<T>::value",
      "keywords": [
        "Type",
        "std",
        "typename",
        "template",
        "include",
        "int",
        "cout",
        "struct",
        "size",
        "define",
        "void",
        "typename std",
        "MEMBER",
        "traits",
        "decltype"
      ],
      "concepts": [
        "std",
        "value",
        "type",
        "template",
        "traits",
        "include",
        "void",
        "char",
        "define",
        "string"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.9,
          "base_score": 0.75,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.872,
          "base_score": 0.722,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 18,
          "title": "",
          "score": 0.867,
          "base_score": 0.717,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 64,
          "title": "",
          "score": 0.86,
          "base_score": 0.71,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 44,
          "title": "",
          "score": 0.848,
          "base_score": 0.698,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "std",
          "cout",
          "hassizetypet",
          "void_t",
          "true_type"
        ],
        "semantic": [],
        "merged": [
          "std",
          "cout",
          "hassizetypet",
          "void_t",
          "true_type"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5082740936513505,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.453080+00:00"
      }
    },
    {
      "chapter_number": 64,
      "title": "Segment 64 (pages 2050-2080)",
      "start_page": 2050,
      "end_page": 2080,
      "summary": "#include <type_traits> //for bool_constant\n#include <type_traits> //for true_type, false_type, and bool_constant<>\nstruct IsNothrowMoveConstructibleT : std::false_type\n>::Type\n>::Type\n#include <type_traits> //for true_type, false_type, and bool_constant<>\nstruct IsFundaT : std::false_type {\n#define MK_FUNDA_TYPE(T) \\\ntemplate<> struct IsFundaT<T> : std::true_type { \\\nMK_FUNDA_TYPE(void)\nMK_FUNDA_TYPE(boo1)\nMK_FUNDA_TYPE (char)\nMK_FUNDA_TYPE(signed char)\nMK_FUNDA_TYPE(unsigned char)\nMK_FUNDA_TYPE(char16_t)\nMK_FUNDA_TYPE(char32_t)\nMK_FUNDA_TYPE(signed int)\nMK_FUNDA_TYPE(unsigned int)\nMK_FUNDA_TYPE (float)\nMK_FUNDA_TYPE (double)\nMK_FUNDA_TYPE(std: :nullptr_t)\n#undef MK_FUNDA_TYPE\nstruct IsFundaT : std::false_type {\ntemplate<> struct IsFundaT<bool> : std::true_type {\nstruct IsPointerT : std::false_type { // primary template: by default not a pointer\nstruct IsPointerT<T*> : std::true_type { // partial specialization for pointers\nstruct IsLValueReferenceT : std::false_type { /f by default no lvalue reference\nstruct IsLValueReferenceT<T&> : std::true_type { // unless T is lvalue references\nstruct IsRValueReferenceT : std::false_type { // by default no rvalue reference\nstruct IsRValueReferenceT<T&&> : std::true_type { /unless T is rvalue reference\nstruct IsArrayT : std::false_type { // primary template: not an array\nstruct IsArrayT<T([N]> : std::true_type { / partial specialization for arrays\nstruct IsArrayT<T[]> : std::true_type { /partial specialization for unbound arrays\nstruct IsPointerToMemberT : std::false_type { “by default no pointer-to-member\nstruct IsPointerToMemberT<T C::*> : std::true_type { / partial specialization\nstruct IsFunctionT : std::false_type { # primary template: no function\nstruct IsFunctionT<R (Params...)> : std::true_type { // functions\nstruct IsFunctionT<R (Params..., ...)> : std::true_type { / variadic functions\nstruct IsFunctionT<R (Params...) const> : std::true_type {\n.5 «--) volatile> : std::true_type {\nstruct IsFunctionT<R (Params..., ...) const volatile> : std::true_type f\n:true_type {\nstd::true_type {\n#include <type_traits>\nstruct IsClassT : std::false_type { // primary template: by default no class\nstd::true_type f{",
      "keywords": [
        "type",
        "typename",
        "FUNDA",
        "std",
        "Params",
        "template",
        "struct",
        "bool",
        "typelist",
        "fundamental type",
        "include",
        "constexpr bool",
        "constexpr",
        "static constexpr",
        "static constexpr bool"
      ],
      "concepts": [
        "std",
        "template",
        "include",
        "value",
        "type",
        "void",
        "classes",
        "reference",
        "referring",
        "array"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.882,
          "base_score": 0.732,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 18,
          "title": "",
          "score": 0.861,
          "base_score": 0.711,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 63,
          "title": "",
          "score": 0.86,
          "base_score": 0.71,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.83,
          "base_score": 0.68,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 79,
          "title": "",
          "score": 0.784,
          "base_score": 0.634,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "mk_funda_type",
          "true_type",
          "struct",
          "std true_type",
          "false_type"
        ],
        "semantic": [],
        "merged": [
          "mk_funda_type",
          "true_type",
          "struct",
          "std true_type",
          "false_type"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.47924871757048976,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.453183+00:00"
      }
    },
    {
      "chapter_number": 65,
      "title": "Segment 65 (pages 2081-2112)",
      "start_page": 2081,
      "end_page": 2112,
      "summary": "#f pass MyClass2 objects with RParam<> by value\nvoid foo (typename RParam<Ti>::Type pi,\ntypename RParam<T2>::Type p2)\nvoid foo_core (typename RParam<T1i>::Type pi,\ntypename RParam<T2>::Type p2)\ntemplate<typename T> void f£(T*);\ntemplate<typename T> void f(Array<T>) ;\ntemplate<typename Number> void f(Number) ; // only for numbers\ntemplate<typename Container> void f(Container); //only for containers\nvoid advanceIter(InputIterator& x, Distance n)\nvoid advanceIter(RandomAccessIterator& x, Distance n) {\nx += n; /f constant time\ntemplate<typename Iterator, typename Distance>\nvoid advanceIterImpl(Iterator&® x, Distance n, std::input_iterator_tag)\ntemplate<typename Iterator, typename Distance>\nvoid advanceIterImpl(Iterator& x, Distance n,\ntemplate<typename Iterator, typename Distance>\nvoid advanceIter(Iterator& x, Distance n)\nstruct input_iterator_tag {};\ntemplate<typename Iterator>\ntypename std: :iterator_traits<Iterator>: :iterator_category,\ntemplate<typename Iterator, typename Distance>\nadvancelter(Iterator& x, Distance n) {\ntemplate<bool, typename T = void>\ntemplate<bool Cond, typename T = void>\ntemplate<typename Iterator, typename Distance>\nadvancelter(Iterator& x, Distance n)\n#include <iterator>\ntemplate<typename Iterator, typename Distance>\nadvancelter(Iterator& x, Distance n) {\ntemplate<typename Iterator>\ntypename std::iterator_traits<Iterator>: :iterator_category,\ntemplate<typename Iterator, typename Distance>\nadvancelter(Iterator&® x, Distance n) {\ntemplate<typename Iterator, typename Distance>\nadvancelter(Iterator& x, Distance n) f{\n#include <iterator>\ntemplate<typename Iterator>\ntypename std: :iterator_traits<Iterator>: :iterator_category,\nstd: :input_iterator_tag>;\ntemplate<typename Iterator,\ntypename = EnablelIf<IsInputIterator<Iterator>>>\ntemplate<typename Iterator,\ntypename = EnableIf<IsInputIterator<Iterator> &&\ntemplate<typename Iterator,\ntypename = EnableIf<IsInputIterator<Iterator> &&\ntemplate<typename Iterator,\ntypename = Enablelf<IsRandomAccessIterator<Iterator>>,\ntemplate<typename Iterator, typename Distance>\nvoid advancelIter(Iterator& x, Distance n) {\ntemplate<typename Iterator>\ntemplate<typename Iterator>\ntemplate<typename Key, typename Value>",
      "keywords": [
        "Iterator",
        "typename Iterator",
        "typename",
        "typename Distance",
        "Distance",
        "template",
        "iterator sequence",
        "Type",
        "input iterator",
        "input iterator sequence",
        "void",
        "Container",
        "typename RParam",
        "RParam",
        "std"
      ],
      "concepts": [
        "template",
        "std",
        "void",
        "public",
        "container",
        "include",
        "type",
        "key",
        "requires",
        "element"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 29,
          "title": "",
          "score": 0.831,
          "base_score": 0.681,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 66,
          "title": "",
          "score": 0.824,
          "base_score": 0.674,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 56,
          "title": "",
          "score": 0.786,
          "base_score": 0.636,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 69,
          "title": "",
          "score": 0.772,
          "base_score": 0.622,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 48,
          "title": "",
          "score": 0.753,
          "base_score": 0.603,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "iterator",
          "distance",
          "typename iterator",
          "iterator typename",
          "iterator distance"
        ],
        "semantic": [],
        "merged": [
          "iterator",
          "distance",
          "typename iterator",
          "iterator typename",
          "iterator distance"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5204013430417498,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.453271+00:00"
      }
    },
    {
      "chapter_number": 66,
      "title": "Segment 66 (pages 2113-2146)",
      "start_page": 2113,
      "end_page": 2146,
      "summary": "template<typename Key, typename Value, typename = void>\ntemplate<typename Key, typename Value>\ntemplate<typename Key, typename Value, typename = void>\ntemplate<typename Key, typename Value>\ntemplate<typename Key, typename Value>\ntemplate<typename Iterator,\ntypename std: :iterator_traits<Iterator>\ntemplate<typename Iterator>\nclass Advance<Iterator, std: :input_iterator_tag>\ntypename std: :iterator_traits<Iterator>: :difference_type;\nvoid operator() (Iterator& x, DifferenceType n) const\ntemplate<typename Iterator>\nclass Advance<Iterator, std: :bidirectional_iterator_tag>\ntypename std: :iterator_traits<Iterator>: :difference_type;\nvoid operator() (Iterator& x, DifferenceType n) const\ntemplate<typename Iterator>\nclass Advance<Iterator, std: :random_access_iterator_tag>\ntypename std: :iterator_traits<Iterator>: :difference_type;\nvoid operator() (Iteratork x, DifferenceType n) const\nvoid f(std: :input_iterator_tag) ;\nvoid f(std: :bidirectional_iterator_tag) ;\nvoid f (std: :random_access_iterator_tag) ;\ntemplate<typename...\ntemplate<typename T>\nT const& min(T const& x, T const& y)\nreturn x;\ntemplate<typename T> struct Identity;\ntemplate<typename Ul, typename U2> static std: :true_type\ntemplate<typename U1, typename U2> static std::false_type\ntemplate<typename Ti, typename T2, bool HasLess>\ntemplate<typename T>\nmin(T constk x, T const& y)\nreturn x;\nbool operator< (Xi const&, X1 const&) { return true; }\nstruct X2 { };\nbool operator<(X2, X2) { return true; }\nbool operator<(X3&, X3&) { return true; }\nstruct X4 { };\nstruct X6 { };\nstruct X7 { };\nBoolLike operator< (X7 const&, X7 const&) { return BoolLike(); }\nmin(T const& x, T const& y)\ntemplate<typename T>\ntemplate<typename T> struct Identity;\ntemplate<typename U> static std::true_type\ntemplate<typename U> static std::false_type\ntemplate<typename T>\ntemplate<typename T>\nmin(T const® x, T const& y)\nreturn X;\nclass Empty {\nusing Int = int; /type alias members don’t make a class nonempty\nclass Empty f{\ntemplate<typename Base, typename Member>\nclass BaseMemberPair : private Base {\n#f access base class data via first ()\nreturn static_cast<Base const&k>(*this) ;\ntemplate<typename T>\nclass ObjectCounter {",
      "keywords": [
        "typename",
        "Key",
        "typename Key",
        "Iterator",
        "const",
        "typename Iterator",
        "std",
        "Key const",
        "template",
        "class Dictionary",
        "type",
        "min",
        "Dictionary",
        "typename std",
        "public"
      ],
      "concepts": [
        "template",
        "std",
        "public",
        "value",
        "match",
        "private",
        "inherit",
        "include",
        "operator",
        "bases"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 65,
          "title": "",
          "score": 0.824,
          "base_score": 0.674,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 29,
          "title": "",
          "score": 0.768,
          "base_score": 0.618,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 69,
          "title": "",
          "score": 0.679,
          "base_score": 0.529,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 56,
          "title": "",
          "score": 0.676,
          "base_score": 0.526,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 58,
          "title": "",
          "score": 0.644,
          "base_score": 0.644,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "iterator",
          "template typename",
          "key",
          "typename key",
          "key typename"
        ],
        "semantic": [],
        "merged": [
          "iterator",
          "template typename",
          "key",
          "typename key",
          "key typename"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.47659477404619854,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.453358+00:00"
      }
    },
    {
      "chapter_number": 67,
      "title": "Segment 67 (pages 2147-2180)",
      "start_page": 2147,
      "end_page": 2180,
      "summary": "class MyString : public ObjectCounter<MyString<CharT>> {\nfriend bool operator== (Array<T> const& a, Array<T> const& b) {\nclass $5 f{\nclass Wrapper {\nbool operator!= (X const&® x1, X const& x2) {\nbool operator!= (T const& x1, T const& x2) f\nfriend bool operator!= (Derived const& x1, Derived const x2) {\nclass K : public EqualityComparable<X>\nfriend bool operator== (X const& x1, X const& x2) {\ntypename Reference = Value&, typename Distance = std::ptrdiff_t>\nclass IteratorFacade\nusing value_type = typename std: :remove_const<Value>: :type;\nreference operator *() const {...\nfriend bool operator== (IteratorFacade const& lhs,\nreference operator [](difference_type n) const {...\nfriend difference_type operator -(IteratorFacade const& lhs,\nfriend bool operator <(IteratorFacade const& lhs,\nreturn *static_cast<Derived const*>(this) ;\nreference operator*() const {\nfriend bool operator== (IteratorFacade const& lhs,\ninherit/Listnode.hpp\nclass ListNode\nstd: :forward_iterator_tag>\nHf ‘friend’ this class to allow IteratorFacade access to core iterator operations:\nfriend class IteratorFacade;\ntemplate<typename Reference, typename Iterator>\nstatic Reference dereference(Iterator const& i) {\ntemplate<typename Iterator>\nstatic void decrement (Iterator& i) {\ntemplate<typename Iterator, typename Distance>\nStatic void advance(Iterator& i, Distance n) {\ninherit/person.hpp\nfriend std::ostreamk operator<<(std::ostream& strm, Person const& p) {\ntemplate<typename Iterator, typename T>\nclass ProjectionIterator\ntypename std::iterator_traits<Iterator>: :iterator_category,\ntypename std: :iterator_traits<Iterator>: :difference_type>\nusing Base = typename std: :iterator_traits<Iterator>: :value_type;\ntypename std::iterator_traits<Iterator>: :difference_type;\n. # implement core iterator operations for IteratorFacade\ntemplate<typename Iterator, typename Base, typename T>\nreturn ProjectionIterator<Iterator, T>(iter, member) ;\nreturn (*iter).*member;\n++iter;\nreturn iter == other.iter;\n#include <iterator>\nstd: :ostream_iterator<std::string>(std::cout, \"\\n\"));\nclass Point\nstd::vector<P> points;\nclass LabeledPoint : public Point\nclass Point : public Mixins..\nclass Label\nstd: :vector<Point<Mixins...>> points;\nclass Point : public Mixins<Point>...",
      "keywords": [
        "typename",
        "iterator",
        "Point",
        "const",
        "std",
        "Array",
        "Derived",
        "operator",
        "public",
        "typename Iterator",
        "template",
        "bool operator",
        "typename std",
        "wrapper",
        "IteratorFacade"
      ],
      "concepts": [
        "std",
        "public",
        "operator",
        "operations",
        "template",
        "inherit",
        "friend",
        "derived",
        "person",
        "point"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 76,
          "title": "",
          "score": 0.621,
          "base_score": 0.621,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 34,
          "title": "",
          "score": 0.609,
          "base_score": 0.609,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 79,
          "title": "",
          "score": 0.594,
          "base_score": 0.594,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.587,
          "base_score": 0.587,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 65,
          "title": "",
          "score": 0.561,
          "base_score": 0.561,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "iterator",
          "iteratorfacade",
          "bool operator",
          "operator",
          "const"
        ],
        "semantic": [],
        "merged": [
          "iterator",
          "iteratorfacade",
          "bool operator",
          "operator",
          "const"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.46468785104813626,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.453446+00:00"
      }
    },
    {
      "chapter_number": 68,
      "title": "Segment 68 (pages 2181-2212)",
      "start_page": 2181,
      "end_page": 2212,
      "summary": "class Base : public Mixins...\nclass Derived : public Base<Mixins...> {\n/f PolicySelector<A,B,C,D> creates A,B,C,D as base classes\n/f Discriminator<> allows having even the same base class more than once\ntemplate<typename Base, int D>\n// class to define a use of the default policy values\nclass DefaultPolicyArgs : virtual public DefaultPolicies {\ntemplate<typename Policy>\nclass Policyi_is : virtual public DefaultPolicies {\ntemplate<typename Policy>\nclass Policy2_is : virtual public DefaultPolicies {\ntemplate<typename Policy>\nclass Policy3_is : virtual public DefaultPolicies {\ntemplate<typename Policy>\nclass Policy4_is : virtual public DefaultPolicies {\ntypedef DefaultPolicy4 F4;\nvoid print () f{\ntemplate<typename F>\nvoid forUpTo(int n, F f)\n/f insert values from 0 to 4:\nbridge/forupto2.hpp\nvoid forUpTo(int n, void (*f)(int))\n£(i); “call passed function f for i\nbridge/forupto3.hpp\nvoid forUpTo(int n, std::function<void(int)> f)\n£(i); “call passed function f fori\n#include \"functionptr.hpp\"\nvoid forUpTo(int n, FunctionPtr<void(int)> f)\nbridge/functionptr.hpp\n/f primary template:\nclass FunctionPtr;\nclass FunctionPtr<R(Args...)>\nFunctorBridge<R, Args...>* bridge;\nFunctionPtr() : bridge(nullptr) f{\nFunctionPtr(FunctionPtr const& other); /f see functionptr-cpinv.hpp\ntemplate<typename F> FunctionPtr(Fk& £); //see functionptr-init.hpp\ntemplate<typename F> FunctionPtr& operator=(F&& f) f\nFunctionPtr tmp(std: :forward<F>(f)) ;\nreturn bridge == nullptr;\nargs) const; // see functionptr-cpinv.hpp\nbridge/functorbridge.hpp\nFunctionPtr<R(Args...)>::FunctionPtr(FunctionPtr const& other)\nif (other.bridge) {\nbridge = other.\nreturn bridge->invoke(std: :forward<Args>(args)...);\nbridge/specificfunctorbridge.hpp\nclass SpecificFunctorBridge : public FunctorBridge<R, Args...> f{\nreturn functor (std: :forward<Args>(args)...);\ntemplate<typename F>\nFunctionPtr<R(Args...)>::FunctionPtr(F&& f£)\nusing Functor = std::decay_t<F>;\nusing Bridge = SpecificFunctorBridge<Functor, R, Args...>;\nbridge = new Bridge(std: :forward<F>(f));\nvirtual bool equals(FunctorBridge<R, Args...> const* fb) const override {\noperator==(FunctionPtr const& fi, FunctionPtr const& f2) {\n|| 1f2) £\nreturn !f1 && !f2;\nreturn f1.bridge->equals(f2.bridge) ;\noperator!=(FunctionPtr const& f1, FunctionPtr const& f2) {\nreturn !(f1 == £2);\nbridge/tryequals.hpp\nstatic bool equals(T const& x1, T const& x2) f{\nclass NotEqualityComparable : public std::exception\nvirtual bool equals(FunctorBridge<R, Args...> const* fb) const override {",
      "keywords": [
        "Args",
        "typename",
        "FunctionPtr",
        "public",
        "const",
        "bridge",
        "template",
        "std",
        "Base",
        "int",
        "Virtual",
        "policy",
        "Functor",
        "public Discriminator",
        "void"
      ],
      "concepts": [
        "bridge",
        "classes",
        "template",
        "std",
        "public",
        "void",
        "values",
        "virtual",
        "include",
        "policy"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 51,
          "title": "",
          "score": 0.871,
          "base_score": 0.721,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 9,
          "title": "",
          "score": 0.736,
          "base_score": 0.586,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 47,
          "title": "",
          "score": 0.724,
          "base_score": 0.574,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 11,
          "title": "",
          "score": 0.717,
          "base_score": 0.567,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 7,
          "title": "",
          "score": 0.684,
          "base_score": 0.534,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "functionptr",
          "bridge",
          "args",
          "public",
          "functionptr const"
        ],
        "semantic": [],
        "merged": [
          "functionptr",
          "bridge",
          "args",
          "public",
          "functionptr const"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.45501796784480203,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.453530+00:00"
      }
    },
    {
      "chapter_number": 69,
      "title": "Segment 69 (pages 2213-2247)",
      "start_page": 2213,
      "end_page": 2247,
      "summary": "template<typename T, size_t N> struct array;\ntemplate<typename T, std::size_t N>\nauto dotProduct(std::array<T, N> const& x, std::array<T, N> const& y)\ntemplate<typename T, std::size_t N>\ntemplate<typename T, std::size_t N>\nauto dotProduct(std::array<T, N> const& x,\nreturn DotProductT<T, N>::result(x.begin(), y.begin());\nmeta/ratio.hpp\ntemplate<unsigned N, unsigned D = 1>\n# duration type for values of type T with unit type U:\nconstexpr ValueType value() const f{\nauto a = Duration<int, Ratio<1,1000>>(x); &x milliseconds\nauto b = Duration<int, Ratio<2,3>>(y); // y 2/3 seconds\nauto e = Duration<int, Ratio<i>>(4); // 4 seconds\nauto f =d+e; //computes resulting unit type 1/3 seconds\nmeta/sqrt1.hpp\n#f primary template to compute sqrt (N)\ntemplate<int N, int LO=1, int HI=N>\nstruct Sqrt f{\nstatic constexpr auto mid = (LO+HI+1)/2;\nstatic constexpr auto value = (N<mid*mid) ?\nSqrt<N,LO,mid-1>::value\n: Sqrt<N,mid,HI>: : value;\ntemplate<int N, int M>\nstruct Sqrt<N,M,M> {\nstatic constexpr auto value = M;\nstd::cout << \"Sqrt<16>::value\nvalue = (16<9*9) ?\nSqrt<16,1,8>::value\n: Sqrt<16,9,16>:: value\nSqrt<16,1,8>:: value\n> Sqrt<16,9,16>:: value\nsqrt<16,1,8>::value\nvalue\nSqrt<16,1,4>::value\n> Sqrt<16,5,8>: :value\nSqrt<16,1,4>::value\nsqrt<16,1,4>::value\nvalue\nSqrt<16,1,2>::value\n> Sqrt<16,3,4>:: value\nSqrt<16,1,2>::value\n: Sqrt<16,3,4>:: value\n= Sqrt<16,3,4>::value\nSqrt<16,3,3>::value\n> Sqrt<16,4,4>::value\n> Sqrt<16,4,4>: : value\n= Sqrt<16,4,4>::value\nSqrt<16,1,8>::value\n: Sqrt<16,9,16>:: value\nmeta/sqrt2.hpp\ntemplate<int N, int LO=1, int HI=N>\nstatic constexpr auto mid = (LO+HI+1)/2;\nSqrt<N,LO,mid-1>,\nSqrt<N ,mid,HI>>;\nstatic constexpr auto value = SubT::value;\ntemplate<int N, int 5>\nstruct Sqrt<N, S, S> {\nstatic constexpr auto value = 58;\ntemplate<int N>\ntemplate<int N>\ntemplate<int N>\nstatic int const value = 3 * Pow3<N-1>::value;\nstatic int const value = 1;\ntemplate<int i>\ntemplate<int i>\nstatic int const value = i;\ntemplate<int i>",
      "keywords": [
        "sqrt",
        "typename",
        "int",
        "template",
        "Ratio",
        "type",
        "struct",
        "std",
        "struct Sqrt",
        "type Ratio",
        "static",
        "const",
        "auto",
        "static constexpr",
        "duration"
      ],
      "concepts": [
        "template",
        "value",
        "ratio",
        "std",
        "duration",
        "durations",
        "static",
        "type",
        "den",
        "result"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 65,
          "title": "",
          "score": 0.772,
          "base_score": 0.622,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 56,
          "title": "",
          "score": 0.76,
          "base_score": 0.61,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 29,
          "title": "",
          "score": 0.689,
          "base_score": 0.539,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 66,
          "title": "",
          "score": 0.679,
          "base_score": 0.529,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 48,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "sqrt",
          "value sqrt",
          "16 value",
          "sqrt 16",
          "16"
        ],
        "semantic": [],
        "merged": [
          "sqrt",
          "value sqrt",
          "16 value",
          "sqrt 16",
          "16"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4509951914045529,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.453617+00:00"
      }
    },
    {
      "chapter_number": 70,
      "title": "Segment 70 (pages 2248-2280)",
      "start_page": 2248,
      "end_page": 2280,
      "summary": "class Typelist\ntemplate<typename List>\ntemplate<typename List>\nusing Front = typename FrontT<List>: :Type;\ntemplate<typename List>\nusing Type = Typelist<Tail...>;\ntemplate<typename List>\nusing PopFront = typename PopFrontT<List>: :Type;\nclass PushFrontT<Typelist<Elements...>, NewElement> {\nusing Type = Typelist<NewElement, Elements...>;\nusing PushFront = typename PushFrontT<List, NewElement>: : Type;\ntemplate<typename List>\nusing NthElement = typename NthElementT<List, N>::Type;\nusing Rest = typename LargestTypeT<PopFront<List>>: :Type;\nclass LargestTypeT<Typelist<>>\nusing LargestType = typename LargestTypeT<List>: :Type;\nclass IsEmpty<Typelist<>> {\nclass LargestTypeT<List, false>\nusing Best = typename LargestTypeT<PopFront<List>>: :Type;\nclass LargestTypeT<List, true>\nusing LargestType = typename LargestTypeT<List>: :Type;\nclass PushBackT<Typelist<Elements...>, NewElement>\nusing Type = Typelist<Elements..., NewElement>;\nusing PushBack = typename PushBackT<List, NewElement>: :Type;\nclass PushBackRecT<List, NewElement, false>\nclass PushBackRecT<List, NewElement, true>\nusing Type = PushFront<List, NewElement>;\nclass PushBackT : public PushBackRecT<List, NewElement> { };\nusing PushBack = typename PushBackT<List, NewElement>: :Type;\nusing Reverse = typename ReverseT<List>: :Type;\nusing Type = List;\nusing PopBack = typename PopBackT<List>: :Type;\ntemplate<typename List, template<typename T> class MetaFun,\ntemplate<typename List, template<typename T> class MetaPun>\n: public PushFrontT<typename TransformT<PopFront<List>, MetaFun>::Type,\ntypename MetaFun<Pront<List>>: :Type>\ntemplate<typename List, template<typename T> class MetaFun>\nusing Type = List;\ntemplate<typename List, template<typename T> class MetaFun>\nusing Transform = typename TransformT<List, MetaPun>::Type;\nclass AccumulateT<List, F, I, false>\ntypename F<I, Front<List>>: :Type>\nclass AccumulateT<List, F, I, true>\nusing Accumulate = typename AccumulateT<List, F, I>::Type;",
      "keywords": [
        "typename List",
        "List",
        "typename",
        "Type",
        "typelist",
        "template",
        "typename NewElement",
        "long",
        "NewElement",
        "typename Head",
        "Head",
        "public",
        "Tail",
        "case",
        "int"
      ],
      "concepts": [
        "list",
        "template",
        "public",
        "type",
        "recursive",
        "tail",
        "head",
        "basis",
        "short",
        "accumulate"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 71,
          "title": "",
          "score": 0.687,
          "base_score": 0.687,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 58,
          "title": "",
          "score": 0.492,
          "base_score": 0.492,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 73,
          "title": "",
          "score": 0.461,
          "base_score": 0.461,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 49,
          "title": "",
          "score": 0.457,
          "base_score": 0.457,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 48,
          "title": "",
          "score": 0.452,
          "base_score": 0.452,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "list",
          "newelement",
          "list type",
          "typename list",
          "type"
        ],
        "semantic": [],
        "merged": [
          "list",
          "newelement",
          "list type",
          "typename list",
          "type"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.30295179663801985,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.453681+00:00"
      }
    },
    {
      "chapter_number": 71,
      "title": "Segment 71 (pages 2281-2311)",
      "start_page": 2281,
      "end_page": 2311,
      "summary": "template<typename Typelist>\ntemplate<typename Typelist>\nusing LargestTypeAcc = typename LargestTypeAccT<Typelist>: :Type;\ntemplate<typename Typelist, bool = IsEmpty<Typelist>: :value>\ntemplate<typename Typelist>\ntemplate<typename Typelist>\ntemplate<typename Typelist>\nusing LargestTypeAcc = typename LargestTypeAccT<Typelist>: :Type;\ntemplate<typename List,\ntemplate<typename List,\nusing InsertionSort = typename InsertionSortT<List, Compare>: : Type;\ntemplate<typename List,\ntemplate<typename List,\ntemplate<typename List, typename Element,\ntemplate<typename List, typename Element,\nclass InsertSortedT<List, Element, Compare, false>\ntypename IfThenElse<Compare<Element, Front<List>>::value,\nusing NewHead = IfThenElse<Compare<Element, Front<List>>::value,\ntemplate<typename List, typename Element,\nclass InsertSortedT<List, Element, Compare, true>\ntemplate<typename List, typename Element,\nusing InsertSorted = typename InsertSortedT<List, Element, Compare>: :Type;\ntemplate<typename List, typename Element,\nclass InsertSortedT<List, Element, Compare, false>\n: public IfThenElseT<Compare<Element, Front<List>>::value,\nusing Types = Typelist<int, char, short, double>;\nstd::cout << std::is_same<ST,Typelist<char, short, int, double>>::value\ntemplate<typename T, T Value>\nusing CTTypelist = Typelist<CTValue<T, Values>...>;\ntypelist/valuelist.hpp\nstruct PushFrontT<Valuelist<T, Values...>, CTValue<T, New>> {\nstruct PushBackT<Valuelist<T, Values...>, CTValue<T, New>> {\ntypelist/ctvalue17.hpp\nElements, template<typename T> class MetaFun>\nusing Type = Typelist<typename MetaFun<Elements>: :Type...>;\ntemplate<typename List>\nusing Type = typename List: :Head;\ntemplate<typename List>\nusing Front = typename FrontT<List>: :Type;\ntemplate<typename List, typename Element>\nusing Type = Cons<Element, List>;\ntemplate<typename List, typename Element>\nusing PushFront = typename PushFrontT<List, Element>: :Type;\ntemplate<typename List>\nusing Type = typename List::Tail;\ntemplate<typename List>\nusing PopFront = typename PopFrontT<List>: :Type;\ntemplate<typename List>",
      "keywords": [
        "typename List",
        "List",
        "typename",
        "typelist",
        "Compare",
        "Type",
        "typename Element",
        "typename Typelist",
        "class Compare",
        "template",
        "element",
        "typename Types",
        "Cons",
        "Valuelist",
        "CTValue"
      ],
      "concepts": [
        "template",
        "list",
        "value",
        "type",
        "cons",
        "public",
        "compare",
        "element",
        "elements",
        "static"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 29,
          "title": "",
          "score": 0.731,
          "base_score": 0.581,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 48,
          "title": "",
          "score": 0.727,
          "base_score": 0.577,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 70,
          "title": "",
          "score": 0.687,
          "base_score": 0.687,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 65,
          "title": "",
          "score": 0.666,
          "base_score": 0.516,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 56,
          "title": "",
          "score": 0.653,
          "base_score": 0.503,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "typename list",
          "list",
          "typelist",
          "element",
          "compare"
        ],
        "semantic": [],
        "merged": [
          "typename list",
          "list",
          "typelist",
          "element",
          "compare"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.36984764361952355,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.453759+00:00"
      }
    },
    {
      "chapter_number": 72,
      "title": "Segment 72 (pages 2312-2344)",
      "start_page": 2312,
      "end_page": 2344,
      "summary": "class Tuple {\nclass Tuple;\nclass Tuple<Head, Tail...>\nTuple<Tail...> tail;\nTuple() f\nTuple(Head const& head, Tuple<Tail...> const& tail)\nTuple<Tail...>& getTail() { return tail; }\nTuple<Tail...> const& getTail() const { return tail; }\nclass Tuple<> {\ntuples/tupleget.hpp\nstatic auto apply(Tuple<Head, Tail...> const& t) {\nstatic Head constk apply(Tuple<Head, Tail...> const& t) {\nauto get (Tuple<Types...> const& t) {\nTuple(Head const& head, Tuple<Tail...> const& tail)\nTuple(Head const& head, Tail constk...\ntuples/maketuple.hpp\nreturn Tuple<std: :decay_t<Types>...>(std::forward<Types>(elems)...);\nbool operator==(Tuple<Head1, Taili...> const& lhs,\nTuple<Head2, Tail2...> const& rhs)\nvoid printTuple(std::ostream&’ strm, Tuple<> const&, bool isFirst = true)\nvoid printTuple(std::ostream& strm, Tuple<Head, Tail...> const& t,\nstim <= ( ierirst 7G\" 2 Le!\nstd: :ostreamk operator<<(std::ostream& strm, Tuple<Types...> const& t)\nclass FrontT<Tuple<Head, Tail...>> {\nclass PopFrontT<Tuple<Head, Tail...>> {\nusing Type = Tuple<Tail...>;\nclass PushFrontT<Tuple<Types...>, Element> {\nusing Type = Tuple<Element, Types...>;\nclass PushBackT<Tuple<Types...>, Element> {\nusing Type = Tuple<Types..., Element>;\nTuple<int, double, std::string> ti(17, 3.14, \"Hello, World!\");\nPushFront<Tuple<Types...>, V>\npushFront (Tuple<Types...> const& tuple, V const& value)\nreturn PushFront<Tuple<Types...>, V>(value, tuple);\ntupLes/pushback.hpp\nreturn Tuple<V>(value) ;\nTuple<Head, Tail..., V>\npushBack(Tuple<Head, Tail...> const& tuple, V const& value)\nreturn Tuple<Head, Tail..., V>(tuple.getHead(),\ntuples/popfront.hpp\nPopFront<Tuple<Types...>>\npopFront (Tuple<Types...> const& tuple)\nreturn tuple.getTail();\nTuple<int, double, std::string> ti(17, 3.14, \"Hello, World!\");\ntuples/reverse.hpp\nTuple<> reverse(Tuple<> const& t)\nReverse<Tuple<Head, Tail...>> reverse(Tuple<Head, Tail...> const& t)\nPopBack<Tuple<Types...>>\npopBack(Tuple<Types...> const& tuple)\nreturn reverse (popFront (reverse (tuple) )) ;\ntuples/copycounter.hpp\ntuples/copycountertest.hpp",
      "keywords": [
        "Tuple",
        "Head",
        "Tail",
        "Types",
        "typename",
        "typename Head",
        "const",
        "template",
        "std",
        "copies",
        "Head const",
        "VTail",
        "element",
        "VHead",
        "class Tuple"
      ],
      "concepts": [
        "std",
        "tail",
        "type",
        "template",
        "head",
        "reverse",
        "reversed",
        "copies",
        "value",
        "element"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 23,
          "title": "",
          "score": 0.849,
          "base_score": 0.699,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 75,
          "title": "",
          "score": 0.634,
          "base_score": 0.634,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 58,
          "title": "",
          "score": 0.617,
          "base_score": 0.617,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 49,
          "title": "",
          "score": 0.616,
          "base_score": 0.616,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 34,
          "title": "",
          "score": 0.61,
          "base_score": 0.61,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "tuple",
          "tail",
          "head",
          "tuple head",
          "tuple types"
        ],
        "semantic": [],
        "merged": [
          "tuple",
          "tail",
          "head",
          "tuple head",
          "tuple types"
        ]
      },
      "topic_id": 10,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4856230574968651,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.453847+00:00"
      }
    },
    {
      "chapter_number": 73,
      "title": "Segment 73 (pages 2345-2376)",
      "start_page": 2345,
      "end_page": 2376,
      "summary": "template<unsigned N, typename Result = Valuelist<unsigned>>\ntemplate<unsigned N>\nauto reverselmpl] (Tuple<Elements...> const& t,\nauto reverse(Tuple<Elements...> const& t)\nauto select (Tuple<Elements...> const& t,\nTuple<int, double, std::string> t1(42, 7.7, \"hello\"};\ntemplate<unsigned I, unsigned N, typename IndexList = Valuelist<unsigned>>\ntemplate<unsigned I, unsigned N, unsigned...\nclass ReplicatedIndexListT<I, N, Valuelist<unsigned, Indices...>>\ntemplate<unsigned I, unsigned N>\ntemplate<unsigned I, unsigned N, typename...\nauto splat(Tuple<Elements...> const& t)\nauto t2 = sort<SmallerThanT>(t1); /“t2is Tuple<int, long, std: :string>\n/f metafunction wrapper that compares the elements in a tuple:\ntemplate<typename List, template<typename T, typename U> class F>\ntemplate<typename T, typename U> class Apply;\ntemplate<unsigned N, unsigned M>\n# sort a tuple based on comparing the element types:\nauto sort(Tuple<Elements...> const& t)\nTuple<Elements...>,\nTuple<std::string, char const*, int, char> t(\"Pi\", \"is roughly\",\ntuples/apply.hpp\ntemplate<typename F, typename...\nauto applyImpl(F f, Tuple<Elements...> const& t,\nreturn f(get<Indices>(t)...);\ntemplate<typename F, typename...\nunsigned N = sizeof...(Elements)>\nauto apply(F f, Tuple<Elements...> const& t)\nreturn applyImpl(f, t, MakeIndexList<N>());\nTuple<std::string, char const*, int, char> t(\"Pi\", \"is roughly\",\nclass Tuple<Head, Tail...> : private Tuple<Tail...>\nTuple<Tail...>& getTail() { return *this; }\nTuple<Tail...> const& getTail() const { return *this; }\nclass Tuple;\nclass Tuple<Head, Tail...>\n: private TupleElt<Head>, private Tuple<Tail...>\nreturn static_cast<TupleElt<Head> const*>(this)->get() ;\nTuple<Tail...>& getTail() { return *this; }\nTuple<Tail...> const& getTail() const { return *this; }\nclass Tuple<> {\ntuples/tupleelt1.hpp\ntemplate<unsigned Height, typename T>\nclass Tuple;\nclass Tuple<Head, Tail...>\n: private TupleElt<sizeof...(Tail), Head>, private Tuple<Tail...>\nTuple<Tail...>& getTail() { return *this; }\nTuple<Tail...> const& getTail() const { return *this; }\nclass Tuple<> {\ntuples/tupleelt2.hpp\ntemplate<unsigned Height, typename T,\ntemplate<unsigned Height, typename T>\ntemplate<unsigned Height, typename T>\ntemplate<unsigned H, typename T>\nclass Tuple;\ntemplate<unsigned I, typename...\nauto get (Tuple<Elements...>& t)\n// inside the recursive case for class template Tuple:\ntemplate<unsigned I, typename...\nfriend auto get(Tuple<Elements...>& t)\nauto t = makeTuple(O, ’1’, 2.2f, std::string{\"hello\"});\ntuples/literals.hpp\ntemplate<std::size_t N>\nconstexpr int parseInt(char const (#arr)([N]) f{\nfor (std::size_t i= 0; i< N - offset; ++i) f{",
      "keywords": [
        "unsigned",
        "typename Result",
        "typename",
        "Tuple",
        "Result",
        "Elements",
        "Indices",
        "const",
        "Tail",
        "template",
        "Head",
        "std",
        "class Tuple",
        "unsigned Height",
        "int"
      ],
      "concepts": [
        "std",
        "template",
        "unsigned",
        "include",
        "public",
        "prefixes",
        "prefix",
        "value",
        "based",
        "base"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 49,
          "title": "",
          "score": 0.694,
          "base_score": 0.694,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 23,
          "title": "",
          "score": 0.687,
          "base_score": 0.687,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 58,
          "title": "",
          "score": 0.678,
          "base_score": 0.678,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 77,
          "title": "",
          "score": 0.645,
          "base_score": 0.645,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 71,
          "title": "",
          "score": 0.637,
          "base_score": 0.637,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "tuple",
          "unsigned",
          "template unsigned",
          "tuple elements",
          "tail"
        ],
        "semantic": [],
        "merged": [
          "tuple",
          "unsigned",
          "template unsigned",
          "tuple elements",
          "tail"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5050166434758517,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:01:40.453944+00:00"
      }
    },
    {
      "chapter_number": 74,
      "title": "Segment 74 (pages 2377-2408)",
      "start_page": 2377,
      "end_page": 2408,
      "summary": "Variant<int, double, string> field;\n#include \"variant.hpp\"\nVariant<int, double, std::string> field(17);\nfield = 42; # assign value of same type\nfield = \"hello\"; / assign value of different type\nvariant/variantstorageasuntion.hpp\nvariant/variantstorage.hpp\nusing Derived = Variant<Types...>;\nFindIndex0fT<Typelist<Types...>, T>::value + 1;\nVariantChoice(T const& value); // see variantchoiceinit.hpp\nVariantChoice(Tk& value); // see variantchoiceinit.hpp\nvariant/findindezof.hpp\nvartant/variant-skel.hpp\nVariant<int, double, std: :string>\nVariantChoice<int, int, double, std::string>,\nVariantChoice<double, int, double, std::string>,\nVariantChoice<std::string, int, double, std: :string>\nvariant/vartant.hpp\nVariant (); // see variantdefaultctor.hpp\nVariant(Variant const source) ; H/ see variantcopyctor.hpp\nVariant (Variant<SourceTypes...> const& source); // variantcopyctortmpl.hpp\nVariant& operator= (Variant const& source) ; /#/ see variantcopyassign.hpp\nVariant& operator= (Variant<SourceTypes...> const source);\nbool Variant<Types...>::is( const\nVariantChoice<T, Types...>::Discriminator;\nT& Variant<Types...>::getQ & {\nvariant/variantchoiceinit.hpp\nVariantChoice<T, Types...>::VariantChoice(T const& value) {\n# place value in buffer and set type discriminator:\nVariantChoice<T, Types...>::VariantChoice(T&& value) {\nnew(getDerived().getRawBuffer()) T(std: :move(value)) ;\nVariant<int, double, string> v(\"hello\"); //implicitly converted to string\nvariant/variantchoicedestroy.hpp\nbool VariantChoice<T, Types...>::destroy() {\nvoid Variant<Types...>::destroy() f{\n# indicate that the variant does not store a value\nvariant/variantdestroy17.hpp\nvoid Variant<Types...>::destroy()\n# indicate that the variant does not store a value\nauto VariantChoice<T, Types...>::operator= (T const& value) -> Derived& {\n// assign new value of same type:\nff assign new value of different type:\nauto VariantChoice<T, Types...>::operator= (T&& value) -> Derived& {\n/f assign new value of same type:\n*getDerived().template getBufferAs<T>() = std: :move(value) ;\n# assign new value of different type:\n#include \"variant.hpp\"\nVariant<int, NonCopyable> v(17);\nstd::cout << \"Variant has no value.\" << ’\\n’;\nvariant/variantempty.hpp\nbool Variant<Types...>::empty() const {\nstd::cout << v.get<int>();\n#include \"variant.hpp\"\nstd::cout << v.template get<Head>();\nvoid print (Variant<Types...> const& v)\nprintImpl<Variant<Types...>, Types...>(v);\nVariant<int, short, float, double> v(1.5);\nv.visit([] (auto const& value) {\nvariant/variantuisitimpl.hpp\nR variantVisitImpl(V&& variant, Visitor&& vis, Typelist<Head, Tail...>) {\nif (variant.template is<Head>()) {\nstd: :forward<V>(variant).template get<Head>()));\nreturn variantVisitImp1<R>(std: :forward<V>(variant),",
      "keywords": [
        "Types",
        "typename",
        "Variant",
        "template",
        "std",
        "VariantChoice",
        "const",
        "typename Visitor",
        "Visitor",
        "discriminator",
        "getDerived",
        "int",
        "Tail",
        "typename List",
        "Head"
      ],
      "concepts": [
        "variant",
        "type",
        "std",
        "template",
        "discriminator",
        "public",
        "string",
        "void",
        "unsigned",
        "destroy"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 75,
          "title": "",
          "score": 0.753,
          "base_score": 0.603,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 24,
          "title": "",
          "score": 0.743,
          "base_score": 0.743,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 4,
          "title": "",
          "score": 0.574,
          "base_score": 0.574,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 38,
          "title": "",
          "score": 0.563,
          "base_score": 0.563,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.558,
          "base_score": 0.558,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "variant",
          "variantchoice",
          "hpp",
          "hpp variant",
          "variant types"
        ],
        "semantic": [],
        "merged": [
          "variant",
          "variantchoice",
          "hpp",
          "hpp variant",
          "variant types"
        ]
      },
      "topic_id": 12,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4497547175163978,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.454032+00:00"
      }
    },
    {
      "chapter_number": 75,
      "title": "Segment 75 (pages 2409-2441)",
      "start_page": 2409,
      "end_page": 2441,
      "summary": "Variant<Types...>::visit(Visitor&& vis)& {\nusing Result = VisitResult<R, Visitor, Types&...>;\nreturn variantVisitImpl<Result>(*this, std::forward<Visitor>(vis),\nVisitResult<R, Visitor, Types const&...>\nVariant<Types...>::visit(Visitor&& vis) const& {\nusing Result = VisitResult<R, Visitor, Types const &...>;\nreturn variantVisitImpl<Result>(*this, std::forward<Visitor>(vis),\nVisitResult<R, Visitor, Types&&...>\nVariant<Types...>::visit(Visitor&& vis) && f\nv.visit<Variant<int, double>>([] (auto const& value) {\nhpp\n4 an explicitly-provided visitor result type:\ntypename VisitResultT<R, Visitor, ElementTypes...>::Type;\nhpp\n“# the result type produced when calling a visitor with a value of type T:\nstd: :common_type_t<VisitElementResult<Visitor, ElementTypes>...>;\n#include \"variant .hpp\"\nVariant<int, short, double, float> v(1i.5);\nauto result = v.visit([] (auto const& value) {\nVariant<Types...>::Variant() f{\n#include \"variant.hpp\"\nVariant<int, double> v;\nstd::cout << \"Default-constructed v stores the int \"\nVariant<double, int> v2;\nstd::cout << \"Default-constructed v2 stores the double \"\nhpp\nVariant<Types...>::Variant(Variant const& source) {\nstd: :move(source) .visit(([&] (auto&k value) {\nVariant<Types...>::Variant (Variant<SourceTypes...> const& source) f{\nsource.visit([&] (auto const& value) f{\n#include \"variant .hpp\"\nVariant<int, std::string, double> v2(v1);\nVariant<double, int, std::string> v3(std::move(v1));\nstd::cout << \"v3 contains the double \" << v3.get<double>() << ’\\n’;\nVariant<double, int, std::string> v4(std::move(vi1));\nVariant<Types...>& Variant<Types...>::operator= (Variant const source) {\nexplicit SArray (std::size_t s)\nSArray<T>& operator= (SArray<T> const& orig) {\nstd::size_t size() const {\nT const& operator[] (std::size_t idx) const {\nT& operator[] (std::size_t idx) f\nvoid copy (SArray<T> const& orig) {\nSArray<T> operator+ (SArray<T> const& a, SArray<T> const& b)\nSArray<T> result(a.size());\nSArray<T> operator* (SArray<T> const& a, SArray<T> const& b)\nSArray<T> result(a.size());\nSArray<T> operator* (T constk s, SArray<T> const& a)\nSArray<T> result(a.size());\n#include \"sarray1.hpp\"\nSArray<double> x(1000), y(1000);\nhpp\nSArray<T>& SArray<T>::operator*= (SArray<T> const& b)\nSArray<T>& SArray<T>::operator*= (T const& s)\n#include \"sarray2.hpp\"\n#include \"sarrayops2.hpp\"\nSArray<double> x(1000), y(1000);\nSArray<double> tmp(x);\nSArray<double> x(1000), y(1000) ;",
      "keywords": [
        "typename Visitor",
        "Visitor",
        "typename",
        "Variant",
        "Types",
        "SArray",
        "visitor result type",
        "template",
        "std",
        "Result",
        "double",
        "const",
        "size",
        "include",
        "result type"
      ],
      "concepts": [
        "types",
        "variant",
        "std",
        "size",
        "visitor",
        "include",
        "double",
        "value",
        "result",
        "operator"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 74,
          "title": "",
          "score": 0.753,
          "base_score": 0.603,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 72,
          "title": "",
          "score": 0.634,
          "base_score": 0.634,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 24,
          "title": "",
          "score": 0.581,
          "base_score": 0.581,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 76,
          "title": "",
          "score": 0.559,
          "base_score": 0.559,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 67,
          "title": "",
          "score": 0.557,
          "base_score": 0.557,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "sarray",
          "variant",
          "visitor",
          "variant types",
          "sarray const"
        ],
        "semantic": [],
        "merged": [
          "sarray",
          "variant",
          "visitor",
          "variant types",
          "sarray const"
        ]
      },
      "topic_id": 12,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4800084845585795,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.454120+00:00"
      }
    },
    {
      "chapter_number": 76,
      "title": "Segment 76 (pages 2442-2473)",
      "start_page": 2442,
      "end_page": 2473,
      "summary": "typename A_Traits<OP1i>::ExprRef op1; // first operand\nT operator[] (std::size_t idx) const {\ntypename A_Traits<O0P2>::ExprRef op2; /f second operand\nT operator[] (std::size_t idx) const {\nconstexpr T const& operator[] (std::size_t) const {\ntypename A_Traits<0P1>::ExprRef op1; //f first operand\nOP1 const& opi; /refer to first operand by reference\ntemplate<typename T> class A_Scalar;\nexplicit Array (std::size_t s)\nArray (Rep const& rb)\nArray& operator= (Array const& b) {\nArray& operator= (Array<T2, Rep2> const& b) {\nfor (std::size_t idx = 0; idx<b.size(); ++idx) f{\nreturn expr_rep.size() ;\ndecltype(auto) operator[] (std::size_t idx) const {\nT& operator[] (std::size_t idx) {\noperator+ (Array<T,R1i> const® a, Array<T,R2> const& b) {\nreturn Array<T,A_Add<T,R1,R2>>\nArray<T, A_Mult<T,R1i,R2>>\noperator* (Array<T,R1i> constk a, Array<T,R2> const& b) {\nreturn Array<T,A_Mult<T,R1,R2>>\nArray<T, A_Mult<T,A_Scalar<T>,R2>>\noperator* (T const& s, Array<T,R2> const& b) {\nreturn Array<T,A_Mult<T,A_Scalar<T>,R2>>\n(A_Mult<T,A_Scalar<T>,R2>(A_Scalar<T>(s), b.rep()));\n#f addition of Array and scalar:\nreturn Array<T,A_Add<T,R1,R2>> (...);\nA_Mult<T,A_Scalar<T>,R2>(A_Scalar<T>(s), b.rep())\nreturn Array<T,A_Mult<T,A_Scalar<T>,R2>> (...);\nArray<T, A_Mult<T,A_Scalar<T>,R2>>\noperator* (T const& s, Array<T,R2> const& b) {\nreturn Array<T,A_Mult<T,A_Scalar<T>,R2>>\n(A_Mult<T,A_Scalar<T>,R2>(A_Scalar<T>(s), b.rep()));\nArray<T, A_Mult<T,R1i,R2>>\noperator* (Array<T,R1i> const& a, Array<T,R2> const& b) {\nreturn Array<T,A_Mult<T,Ri,R2>>\noperator+ (Array<T,Ri> const& a, Array<T,R2> const& b) {\nreturn Array<T,A_Add<T,R1,R2>>\nArray& operator= (Array<T2, Rep2> const& b) {\ndecltype(auto) operator[] (std::size_t idx) const f{\nTz operator[] (std::size_t idx) f{\n#f size is size of inner array\nArray<T, R>::operator[] (Array<T2, R2> const& b) f{\nreturn Array<T, A_Subscript<T, R, R2>>",
      "keywords": [
        "Array",
        "Mult",
        "idx",
        "typename",
        "Scalar",
        "return Array",
        "double",
        "size",
        "const",
        "Add",
        "Rep",
        "traits",
        "template",
        "operator",
        "std"
      ],
      "concepts": [
        "size",
        "array",
        "scalars",
        "rep",
        "include",
        "operator",
        "operations",
        "public",
        "value",
        "operands"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 25,
          "title": "",
          "score": 0.84,
          "base_score": 0.69,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 77,
          "title": "",
          "score": 0.823,
          "base_score": 0.673,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.672,
          "base_score": 0.672,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 79,
          "title": "",
          "score": 0.661,
          "base_score": 0.661,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 39,
          "title": "",
          "score": 0.622,
          "base_score": 0.622,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "r2",
          "array",
          "a_mult",
          "a_scalar",
          "return array"
        ],
        "semantic": [],
        "merged": [
          "r2",
          "array",
          "a_mult",
          "a_scalar",
          "return array"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5144639621432037,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.454208+00:00"
      }
    },
    {
      "chapter_number": 77,
      "title": "Segment 77 (pages 2474-2504)",
      "start_page": 2474,
      "end_page": 2504,
      "summary": "virtual void copy_to(Array<T, SArray<T>>&) const;\nvirtual void copy_to(Array<T, SArray<T>>&) const {\nArray<T, Rep>& operator=(CopierInterface<T> const& b) {\nvoid middle (typename T::Index p)\nvoid shell (T const& env)\nvoid ignore(T const)\nvoid shell (T const& env)\nvoid deref(typename T::Index ptr) f\ntemplate<typename U> static std::true_type\ntemplate<typename U> static std::false_type\nvoid shell (T const& env)\nstatic_assert (std: :is_default_constructible<T>: :value,\nint find(T const* array, int n, T const& value);\nint find(T const* array, int n, T const& value) {\nwhile(i !=n && array[i] != value)\ntemplate int find(EqualityComparableArchetype const*, int,\nint find(T const* array, int n, T const& value) {\nwhile(i !=n && !(arrayli] == value))\nclass SortTracer {\nint value;\nint generation;\nlong n_created = 0;\nlong n_destroyed = 0;\nlong n_assigned =\nlong n_compared =\nlong n_max_live\nstatic void update_max_live() {\nif (n_created-n_destroyed > n_max_live) {\nn_max_live = n_created-n_destroyed;\nreturn n_created;\nreturn n_destroyed;\nstatic long assignments() {\nreturn n_assigned;\nreturn n_compared;\nstatic long max_live() f{\nreturn n_max_live;\nSortTracer (int v\n++n_created;\n\"SortTracer #\" << n_created\nSortTracer (SortTracer const& b)\n++n_created;\n\"SortTracer #\" << n_created\n++n_destroyed;\n/f assignment\n++n_assigned ;\nstd::cerr << \"SortTracer assignment #\" << n_assigned\nfriend bool operator < (SortTracer const& a,\nSortTracer const& b) {\n++n_compared ;\nstd::cerr << \"SortTracer comparison #\" << n_compared\nlong created_at_start = SortTracer::creations() ;\nlong max_live_at_start = SortTracer: :max_live();\nlong assigned_at_start = SortTracer: :assignments() ;\nlong compared_at_start = SortTracer: :comparisons() ;\n\"std::sort() of 10 SortTracer’s\"\n\" temporary tracers\\n \"\nmax_live_at_start << \" before)\\n \"\n\" assignments \\n\ninline void f() {}",
      "keywords": [
        "const",
        "typename",
        "int",
        "std",
        "SortTracer",
        "Array",
        "static",
        "template",
        "void",
        "cerr",
        "long",
        "max",
        "generation",
        "live",
        "SortTracer const"
      ],
      "concepts": [
        "std",
        "void",
        "values",
        "include",
        "debugging",
        "debug",
        "public",
        "template",
        "static",
        "operator"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 76,
          "title": "",
          "score": 0.823,
          "base_score": 0.673,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 25,
          "title": "",
          "score": 0.799,
          "base_score": 0.649,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 49,
          "title": "",
          "score": 0.678,
          "base_score": 0.678,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 58,
          "title": "",
          "score": 0.676,
          "base_score": 0.676,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 53,
          "title": "",
          "score": 0.659,
          "base_score": 0.659,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "sorttracer",
          "n_created",
          "long",
          "n_destroyed",
          "const"
        ],
        "semantic": [],
        "merged": [
          "sorttracer",
          "n_created",
          "long",
          "n_destroyed",
          "const"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5387106179568387,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.454295+00:00"
      }
    },
    {
      "chapter_number": 78,
      "title": "Segment 78 (pages 2505-2534)",
      "start_page": 2505,
      "end_page": 2534,
      "summary": "class X f\nclass D : public X f{\nint const x; /“#/xisanonmodifiable lvalue\nstd: :vector<int> v;\nint x = 3; “x here is a variable, not an lvalue.\nvoid £(X const&); /accepts an expression of any value category\nvoid £(X&&); # accepts prvalues and xvalues only but is a better match\nif constexpr (std::is_lvalue_reference<decltype((e))>::value) {\nstd::cout << \"expression is lvalue\\n\";\nstd: :is_same_v<decltype(lvalue()), int&> // yields true because result is lvalue\nstd: :is_same_v<decltype(prvalue()), int> // yields true because result is prvalue\nint&\nint&\nint&\nint&&\nint&&\nint&&\n/f ERROR: lvalue reference cannot bind to a prvalue\n// ERROR: lvalue reference cannot bind to an xvalue\n// ERROR: rvalue reference cannot bind to an lvalue\nvoid display_num(int) ; Mf #1\nvoid combine(int, double);\nvoid combine(long, int);\nant £1 (int) : Hf #1\nint f1(double); Hf #2\nmt f2(int); Mf #3\nint £3(X); MH #5\nint £3(...); Mf #6\nvoid f10); // implicit *this parameter is an lvalue reference (see below)\nvoid £2() &&; / implicit *this parameter is an rvalue reference\nvoid £30) &; A implicit *this parameter is an lvalue reference\nvoid report (int&) ;\nvoid report(int const&) ;\nvoid pass(Value const&); // #1\npass(x); 4 calls #1, because x is an lvalue\npass(X()); /f calls #2, because XQ is an rvalue (in fact, prvalue)\npass(std: :move(x)); // calls #2, because std: :move (x) is an rvalue (in fact, xvalue)\nvoid tick() const;\nvoid tack() const;\nvoid report (int);\nvoid report (int&) ;\nvoid report(int const&) ;\ntemplate<typename T> int f(T); Mf #1\nvoid f (int); “i #2\nvoid count (int);\nvoid f(std::initializer_list<int>) {\nvoid f(std: :initializer_list<std::string>) {\nvoid g(std::vector<int> const& vec) {",
      "keywords": [
        "int",
        "void",
        "lvalue",
        "std",
        "ERROR",
        "const",
        "reference",
        "int main",
        "prvalue",
        "lvalue reference",
        "calls",
        "rvalue",
        "public",
        "char",
        "main"
      ],
      "concepts": [
        "void",
        "std",
        "error",
        "called",
        "public",
        "match",
        "matches",
        "char",
        "include",
        "passes"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 41,
          "title": "",
          "score": 0.858,
          "base_score": 0.708,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 32,
          "title": "",
          "score": 0.689,
          "base_score": 0.539,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 79,
          "title": "",
          "score": 0.684,
          "base_score": 0.684,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.628,
          "base_score": 0.628,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 55,
          "title": "",
          "score": 0.625,
          "base_score": 0.625,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "lvalue",
          "int",
          "void",
          "report int",
          "void report"
        ],
        "semantic": [],
        "merged": [
          "lvalue",
          "int",
          "void",
          "report int",
          "void report"
        ]
      },
      "topic_id": 8,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4506393405820655,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.454381+00:00"
      }
    },
    {
      "chapter_number": 79,
      "title": "Segment 79 (pages 2535-2565)",
      "start_page": 2535,
      "end_page": 2565,
      "summary": "void ovl(std::initializer_list<int>) { Mh #2\nvoid arri(Array<int>) f\nstd: :trait_v<...> #f since C++17\nstd: :add_const<int>::type c = i; /fcis int const\nstd: :add_const_t<int> c14 = i; #f since C++14\nstatic_assert (std: :is_const<decltype(c)>::value, \"c should be const\");\nstd::cout << std::is_same<decltype(c), int const>::value //Irue\nstd::cout << std::is_same_v<decltype(c), int const> “# since C++17\nif (std::is_same<decltype(c), int const>{}) { / implicit conversion to bool\nconstexpr value_type operator() () const noexcept { //since C++/4\ncout << is_const<MyType>::value << ’\\n’; //prints false\nusing T = is_const<MyType>: : type; # integral_constant<bool, false>\ncout << is_same<decltype(ic), is_const<int>>::value << *\\n’; /true\nis_void_v<int>\nis_void_v<decltype(f)>\nis_void_v<decltype(f())>\n// yields true (return type of £Q is void)\nis_array_v<int[]>\nis_array_v<int [5]>\nis_array_v<int*>\n// yields false (a has type int*)\n// yields false (b has type int*)\n// yields false (c has type int*)\nis_pointer_v<int> // yields false\nis_pointer_v<int*> // yields true\nis_pointer_v<int* const> // yields true\nis_pointer_v<int*k> // yields false\nis_pointer_v<decltype(nullptr)> // yields false\nis_pointer_v<decltype(a)> Hf yields true (a has type int*)\nis_pointer_v<decltype(f)> // yields true (£ has type void(*) ())\nis_pointer_v<decltype(foo)> // yields false\nis_pointer_v<decltype(&foo) > // yields true\nis_pointer_v<decltype(foo(a,f))> //yields true (for return type int*)\nis_null_pointer_v<decltype(nullptr)> //yields true\nis_null_pointer_v<decltype(p)> / vields false (p has not type std: :nullptr_t)\nis_class_v<int>\nis_class_v<std::string const>\nMH yields false (£ has type void(*) ()\nis_const<int* const>::value // true\nis_const<int const*>::value // false\nis_const<int constk>::value #/ false\nis_const<int [3]>::value //false\nis_const<int const[3]>::value // true\nis_const<int[]>::value 4 false\nis_const<int const[]>::value true\nis_volatile<int[3]>::value //false\nis_volatile<int[]>::value 4 false\nis_volatile<int[3]>::value //false\nis_volatile<int[]>::value 4 false\nif constexpr(!std::is_aggregate_v<typename Coll::value_type>) {\nrank_v<decltype(a2)>; /f yields 2\nrank_v<int*>; / yields 0 (no array)\nextent_v<int*>; Mf yields 0\nbool operator() (int) const {",
      "keywords": [
        "int",
        "std",
        "yields",
        "yields false",
        "decltype",
        "const",
        "yields true",
        "type",
        "void",
        "prints",
        "Array",
        "cout",
        "Point",
        "Point const",
        "int const"
      ],
      "concepts": [
        "std",
        "void",
        "value",
        "yields",
        "type",
        "operator",
        "main",
        "include",
        "array",
        "trait"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.928,
          "base_score": 0.778,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 81,
          "title": "",
          "score": 0.821,
          "base_score": 0.671,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 28,
          "title": "",
          "score": 0.816,
          "base_score": 0.666,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.814,
          "base_score": 0.664,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 27,
          "title": "",
          "score": 0.796,
          "base_score": 0.646,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "yields",
          "false",
          "int",
          "is_pointer_v",
          "is_const int"
        ],
        "semantic": [],
        "merged": [
          "yields",
          "false",
          "int",
          "is_pointer_v",
          "is_const int"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5258104169966716,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.454468+00:00"
      }
    },
    {
      "chapter_number": 80,
      "title": "Segment 80 (pages 2566-2598)",
      "start_page": 2566,
      "end_page": 2598,
      "summary": "is_constructible_v<int>\nis_constructible_v<int,int>\nis_constructible_v<long,int>\nis_constructible_v<int,void*>\nis_constructible_v<void*,int>\nis_constructible_v<std::string,char const*,int,int>\nis_copy_constructible_v<int> // yields true\nis_copy_constructible_v<void> // yields false\nis_copy_constructible_v<std::unique_ptr<int>> //yields false\nis_copy_constructible_v<std: :string> // yields true\nis_copy_constructible_v<std: :string&> // yields true\nis_copy_constructible_v<std: :string&&> // yields false\nis_constructible_v<std: :string,std: :string> // yields true\nis_constructible_v<std::string&,std::string&> //yields true\nis_constructible_v<std: :string&&,std: :string&&> // yields true\nis_move_constructible_v<int> // yields true\nis_move_constructible_v<void> // yields false\nis_move_constructible_v<std: :unique_ptr<int>> //yields true\nis_move_constructible_v<std: :string> “# yields true\nis_move_constructible_v<std: :string&> // yields true\nis_move_constructible_v<std: :string&&> // yields true\nis_constructible_v<std: :string,std: :string> // yields true\nis_constructible_v<std::string&,std::stringk>  //yields true\nis_constructible_v<std: :string&&,std: :string&&> // yields true\nis_assignable_v<int ,int> # yields false\nis_assignable_v<int&, int> ff yields true\nis_assignable_v<int&&,int> # yields false\nis_assignable_v<int&,int&> // yields true\nis_assignable_v<int&&, int&&> // yields false\nis_assignable_v<int&, long&> // yields true\nis_assignable_v<int&, void*> // yields false\nis_assignable_v<void*,int> // yields false\nis_assignable_v<std: :string,std: :string> // yields true\nis_assignable_v<std::string&,std::string&> //yields true\nis_assignable_v<std: :string&&,std::string&&> // yields true\n1is_copy_assignable_v<int>\nis_copy_assignable_v<int&>\nis_copy_assignable_v<int&k>\nis_copy_assignable_v<std: :unique_ptr<int>>\n1s_move_assignable_v<int>\nis_move_assignable_v<int&>\nis_move_assignable_v<int&k>\nis_move_assignable_v<std: :unique_ptr<int>>\nis_destructible_v<int>\nis_destructible_v<std: :pair<int,std: :string>>\nis_trivially_destructible_v<std: :pair<int,int>>\nis_trivially_destructible_v<std: :pair<int ,std: :string>>\nis_swappable_with_v<int&,void*>\nis_swappable_with_v<void*,int>\nis_swappable_with_v<void*, int&>\nis_swappable_v<int>\nis_swappable_v<int&>\nis_swappable_v<int&&>\nis_swappable_v<std: :unique_ptr<int>>\nis_same_v<A,int>\nis_constructible_v<C,C> /f yields true\n// yields int const volatile\n// yields int const volatile\n/# yields int const\n// yields int const\n// yields int&\n// yields int*\n// yields int (*) [3]\nHf yields void(*) (int)\n// yields void(*) (int)\n// yields void(int) const (no change)",
      "keywords": [
        "yields int const",
        "yields int",
        "int",
        "yields true",
        "int const",
        "yields",
        "yields int remove",
        "yields false",
        "std",
        "const",
        "int remove",
        "int const remove",
        "int const volatile",
        "string",
        "constructible"
      ],
      "concepts": [
        "std",
        "void",
        "yields",
        "char",
        "string",
        "type",
        "abc",
        "long",
        "auto",
        "virtual"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 28,
          "title": "",
          "score": 0.9,
          "base_score": 0.75,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 81,
          "title": "",
          "score": 0.842,
          "base_score": 0.692,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 79,
          "title": "",
          "score": 0.708,
          "base_score": 0.558,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 63,
          "title": "",
          "score": 0.669,
          "base_score": 0.519,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.66,
          "base_score": 0.51,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "yields",
          "int",
          "yields true",
          "is_constructible_v",
          "string yields"
        ],
        "semantic": [],
        "merged": [
          "yields",
          "int",
          "yields true",
          "is_constructible_v",
          "string yields"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.38862153942733474,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.454550+00:00"
      }
    },
    {
      "chapter_number": 81,
      "title": "Segment 81 (pages 2599-2606)",
      "start_page": 2599,
      "end_page": 2606,
      "summary": "|| std: :is_constructible<Y,int>{},\nstd: :is_constructible<Y, int>>{},\nstd::cout << isNoPtrT<void*>::value << ’\\n’; # false\nstd::cout << isNoPtrT<std::string>::value << ’\\n’; Hf true\nstd::cout << isNoPtrT<decltype(np)>::value << ’\\n’; /f false\nstd::cout << isNoPtr<int> << ’\\n’; // true",
      "keywords": [
        "std",
        "constructible",
        "false std",
        "int",
        "pointer",
        "n’t init",
        "undefined behavior",
        "isNoPtrT",
        "struct isNoPtrT",
        "cout",
        "typename",
        "template",
        "Y,int",
        "static",
        "assert"
      ],
      "concepts": [
        "std",
        "template",
        "value",
        "behavior",
        "tes",
        "undefined",
        "disjunction",
        "negation"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 62,
          "title": "",
          "score": 0.892,
          "base_score": 0.742,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 61,
          "title": "",
          "score": 0.871,
          "base_score": 0.721,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 28,
          "title": "",
          "score": 0.862,
          "base_score": 0.712,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 80,
          "title": "",
          "score": 0.842,
          "base_score": 0.692,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 63,
          "title": "",
          "score": 0.838,
          "base_score": 0.688,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "isnoptrt",
          "cout isnoptrt",
          "false std",
          "std",
          "cout"
        ],
        "semantic": [],
        "merged": [
          "isnoptrt",
          "cout isnoptrt",
          "false std",
          "std",
          "cout"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5611625571508713,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:01:40.454637+00:00"
      }
    }
  ],
  "total_chapters": 81,
  "enrichment_provenance": {
    "taxonomy_id": "none",
    "taxonomy_version": "none",
    "taxonomy_path": "none",
    "taxonomy_checksum": "sha256:none",
    "source_metadata_file": "C++ Templates_ The Complete Guide_metadata.json",
    "enrichment_date": "2025-12-17T23:01:40.468063+00:00",
    "enrichment_method": "msep",
    "model_version": "ai-agents-msep-v1",
    "processing_time_ms": 6711.81617000002,
    "total_similar_chapters": 405
  }
}