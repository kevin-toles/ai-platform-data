{
  "metadata": {
    "title": "Game Programming Gems 3",
    "source_file": "Game Programming Gems 3_metadata.json"
  },
  "chapters": [
    {
      "chapter_number": 1,
      "title": "Segment 1 (pages 1-15)",
      "start_page": 1,
      "end_page": 15,
      "summary": "Scheduling Game Events ........000 cence eee eee e eee eee 5\nReal-Time Input and Ulin 3D Games .......00000esneneneuuen 109\nBen Board and Mike Ducker\nMinimizing Latency in Real-Time Strategy Games ......\nReal-Time Modular Audio Processing for Games .......0.:00008: 630\nScheduling Game Events\nWith the growing sophistication of computer games, real-time events and simu-\nto manage and execute multiple events per frame, or many times within a frame's\nA scheduler can manage game events in a very flexible fashion, as well as\nA few examples of game technologies that can effectively utilize a scheduler are\nBy providing a finer resolution of time, the simulation\ntime = 10\nThe basic components of the scheduler are a task manager, an event manager, and a\nWith these components, the scheduler can generate time- or\nframe-based events and execute event handlers.\nevent handlers as tasks.\n1) Event Manager ( Task Manager q\nTask Manager\nEach task has a\ntask manager maintains a list of tasks, along with scheduling information about each\nThe event manager is the heart of the scheduler.\nAn event is a moment in time when a task is to be\nFor example, in Figure 1.1.2, Task1 defines events at times 10 and 15.\nevent manager generates events as needed to trigger the execution of tasks.\nA real-time scheduler is fairly simple in concept—the event manager sits in a loop.\nwatches a real-time clock, and as soon as a target time is reached, it fires an event.\nTask1\nnext_time = 10\n@ Task1 next_time = 10\n@ clock time = task time = 10\nExecute Task\nUpdate Task next time\nTask2\nnext_time = 12\nSince each task occurs exactly at its scheduled time, the\ntime between tasks is essentially wasted from the scheduler’s frame of reference.\nFrom the task’s point of view, time is only a number.\nThe scheduler can\nVirtual time is extremely useful because it allows the scheduler to execute tasks\nA virtual time scheduler divides time into frames.\nbetween frames, running in ‘virtual time,’ and then are synchronized with real-time\nIf the frame rate is high enough, the illusion of real-time\nHowever, a few dozen milliseconds between frames is a lot of time for the\nWe'll refer to virtual time as simulation time in this gem, since all objects within\nIf simulation time is stopped, then simulation\nTasks are executed sequentially while simulation time is updated between tasks.\nevents that occur at 51 ms and 54 ms, then they will be processed during Frame 2.\nbeginning of Frame 3, it looks at real-time and sees 60 ms.\ntasks scheduled for Frame 2.\nTask] is the first, at 51 ms; but the simulation clock is\nFrame 2 - Real-Time Frame 3 - Real-Time\n<Task’ ‘<Task2> kRender> een eee ee eee\nFrame 2 - Simulation Time Frame 3 - Simulation Time\nFIGURE 1.1.3 The difference between real-time and simulation time in Frame 2.\nOnce Task1 is done, the clock is advanced to the next event at 54 ms and Task2\nNo more events are scheduled for this frame, so the clock is set to the end\nIn this model, task execution and frame rendering always lag slightly behind real-\ntime.\nIf the frame rate is fixed, the scheduler\ncan predict the start and end times, and perform event processing in advance.\nTime events, on\nFor example, a time event can occur every 10 ms, regardless of the rendering\nIt is also possible to combine time events and frame events.\nan event could be scheduled to occur 10 ms after the start of every frame, or it could\nexecute five times per frame, evenly distributed in simulation time.\nThe clock component of the scheduler keeps track of real-time, the current simulation\ntime, and the frame count.\nrequired, one could use the 1-ms hardware clock and subdivide the real-time ticks as\nSince tasks are\ntasks:\ncases, tasks might be set to execute at the same time.\nboth Task1 and Task2 execute at time 15.\npriority than Task], it is executed first.\n1.1 Scheduling Game Events 9\nTime Task\n5 ms Task1\n10 ms Task1\n11 ms Task2\n15 ms Task2\n15 ms Task1\n19 ms Task2\nuseful for ordering frame-based tasks.\nfirst task to determine when the next event should occur.\nforemost task is ‘popped’ off the list and executed, its next time is updated, and it is\nexecute the scheduler.\nhave a fixed frame rate, the provided scheduler does support this constant velocity\nThe key is in the Clock.Update() method that samples the actual real-time\nand advances the simulation by the elapsed time.\n1.1 Scheduling Game Events 11\nSo, how does the scheduler manage time, anyway?\nScheduling\nThe first step in scheduling a task is to specify it as a time event, a frame event, or a\nThis code will schedule a frame event that starts on Frame 200, runs\nscheduler.Schedule(TASK_FRAME, 200, 3, 10,\nThis task would run on Frames 200, 203, 206, and 209.\nEach time the scheduler ExecuteFrame()\ning the frame count and computing new frame start and end times.\nthe frame count, it executes all time events, advances the simulation time to the end\nof the frame, executes all frame events, and then finally executes the render task.\nthe sample scheduler, the render task is a special frame task that does not have a start,\nstill performs renders and frame events, but time events are suspended.\nSince the scheduler can\nit to the last frame to determine elapsed time.\nelapsed time of each task by comparing the start time to the end time.\nor not to run the task and/or how often.\nmore time allowed.\nA task might have a ‘time budget’ per frame.\nthe accumulated budget and the accumulated running time, and only executes the\ntask if the current budget exceeds the actual time.\ntime budget of 2 ms per frame, but it runs in 3 ms on a slow CPU.\nThe scheduler will\nskip every third frame in order to keep the task within its budget (see Table 1.1.2).\nTable 1.1.2 Time Budget Per Task\nSome tasks might have a time budget ‘threshold’—if they exceed their budget.\nThe scheduler can also\ndetermine the time needed to perform the entire simulation by summing all of the\ntasks.\nThe difference between processing time and frame length is idle time.\ngame should use all the available time to improve gameplay, but should not use mor\nThe scheduler can add tasks tc\nfill idle time or remove tasks to reduce the load.\nusage statistics to tasks, the tasks can then scale themselves to use more or less time\nbudgets, scheduling of idle tasks (which only run during idle time), garbage collectioz\n1.1 Scheduling Game Events 13\ntasks might work better as a continuous process rather than a series of discrete events\nSuch tasks can be written as a thread, and the scheduler can control how\nmuch time the thread is allowed for processing.\norganize your events by using a scheduler in your next game.",
      "keywords": [
        "time",
        "frame",
        "task",
        "Scheduling Game Events",
        "eee",
        "scheduler",
        "simulation time",
        "Events",
        "event manager",
        "task manager",
        "Game Events",
        "Simulation",
        "Game",
        "Frame events",
        "Simulation Time Frame"
      ],
      "concepts": [
        "times",
        "task",
        "scheduling",
        "schedule",
        "events",
        "ees",
        "frame",
        "game",
        "gaming",
        "simulations"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 52,
          "title": "",
          "score": 0.565,
          "base_score": 0.415,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 2,
          "title": "",
          "score": 0.545,
          "base_score": 0.395,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 13,
          "title": "",
          "score": 0.539,
          "base_score": 0.389,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 30,
          "title": "",
          "score": 0.489,
          "base_score": 0.339,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 65,
          "title": "",
          "score": 0.405,
          "base_score": 0.405,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "time",
          "scheduler",
          "frame",
          "task",
          "events"
        ],
        "semantic": [],
        "merged": [
          "time",
          "scheduler",
          "frame",
          "task",
          "events"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20783698648592724,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921030+00:00"
      }
    },
    {
      "chapter_number": 2,
      "title": "Segment 2 (pages 16-26)",
      "start_page": 16,
      "end_page": 26,
      "summary": "[Dawson01] Dawson, Bruce “Micro-Threads for Game Object AI,” Game Program-\nGame Framework\nhis gem will present a design for a game framework based on object composition\nthis kind of framework can be useful for implementing the work required for games.\nThis game framework can serve as a reference for your own game systems.\ncan create new systems with the capabilities that you need and create new tasks that\ngame.applications.\nWe then discuss the game framework design issues.\nwe present an overview of the game framework implementation provided on the\nDuring the testing stage, we might need the ability to start the game in various\ngame.\n1.2 An Object-Composition Game Framework 17\nGame Framework Design\nWe will cover platform dependence, game\ndependence, object composition, inheritance, frame-based code, function-based\ncode, operation order, object lifetimes, and task integration.\nGames are usually filled with many concepts that transcend operating systems and\nThe more we can separate the game's conceptual work from platform specifics,\nof our goal in creating a game framework is making it easy to keep game concepts\nIf we want to use a framework for many games, it makes sense to have the framework\nHowever, if we are going to use a framework for a single game\ngame dependent.\nFor example, if our game controls a specific type of character that has many\ning code to access game-specific states and decide how the object should be rendered.\ndesign pattern, and create objects that are a subclass of an application class.\nA task system\nthe task lists and task objects.\nUsing a task system like this means that we can now build a framework based on\nOur task system controls task objects\nthrough their interfaces, and our tasks perform work by calling object interfaces.\nInstead, our task objects control the software.\nPerhaps this is an object framework rather than a class framework, but it is a frame-\nGames may be rendered at speeds up to 50 or 60 frames\nThis kind of frame-based operation requires game software to execute in\nFor our framework, frame-based operation will require a frame system class that\ncan tell our task system class when to call frame-synchronized tasks.\nOur task system\nwill also be able to process tasks that are not frame-synchronized, which we will call\nSince the frame system controls when to call frame-synchronized tasks, we can\n1.2 An Object-Composition Game Framework 19\nFor our framework, we can provide dynamic operation order by enabling task\nobjects to access the task system interface and submit new tasks.\nof object ownership and our tasks the power of object access, which limits the confu-\nWe can make the lifetimes of these objects dynamic by having tasks issue com-\ntasks that need the loaded objects are started.\ncontrol us and that our relationship with those objects is “fixed.” Tasks feel vertically\nIn object-composition framework, it might seem like our programming environ-\nGame Framework Implementation\nThe framework is composed of systems and tasks.\ntask called the “frame player” provides high-level control of audio-visual rendering\ntems that our game will use.\nFactorySys_t Creates objects using Factory IDs. ResourceSys_t Manages object instances using Instance IDs. TaskSys_t Manages task execution and control.\n1.2 An Object-Composition Game Framework\nTasks\nThe TaskSys_t class provides an interface to the task system.\nPost_TaskCommand function, we can post a task as either a frame-synchronized task or\nchronized tasks are called when the frame system reports that it is time to run the next\nstart a frame-synchronized task:\n// get the task system\n// push back the new frame-synchronized task\nTasks are passed to the Systems_t pointer\nwhen they are connected to the system via the task’s Connect (Systems_t *pSystems)\ngame screen is rendered in a layered fashion.\nmight have the world rendered as one layer and perhaps game objects as another layer,\nTo control layers of visual screens, audio data, and input-handling logic, we intro-\nframe-synchronized and manages audio-visual-layer (AVLayer_t) objects and logic-\nlayer (LogicLayer_t) objects.\nAudio-visual-layer objects are called each frame as follows:\nfor( each audio-visual layer (forward-order) )\nfor( each audio-visual layer (forward-order) )\nfor( each audio-visual layer (forward-order) )\nWe can see that each audio-visual layer is updated first with an Update() call.\nThis is when the audio-visual objects are updated, depending on their state of anima-\nLogic-layer objects are called each frame as follows:\naudio-visual-layer updates are meant to handle animation, logic-layer updates are\nJust as the task system has task commands, the FramePlayer_t class has layer\n// push back an audio-visual layer\nHere we see that we can get any audio-visual layer using its instance ID by calling\nWith this layer system, we can now change audio-visual layering dynamically.\nimplemented using layer and task commands.\nback audio-visual and logic layers for floating menus.\nscreens, we have the option of editing the layering of our frame-player task using the\nlayer commands, or we can switch between frame-player tasks using the task com-\nFinally, a sophisticated use of layer and task manipulation is in transitions.\non one game screen (the first audio-visual layer) can be gradually covered by items of\nanother game screen (the second audio-visual layer).\nThe CD-ROM includes source code to the game framework implementation and\nframework concepts and not game technology concepts.\nMode Task Audio-Visual Layers Logic Layers\nGame\nFIGURE 1.2.1 Using the game framework: An example of how game modes can be\nimplemented using tasks, audio-visual layers, and logic layers.",
      "keywords": [
        "Charles River Media",
        "Game",
        "Game Framework",
        "system",
        "task system",
        "Framework",
        "task",
        "Charles River",
        "River Media",
        "objects",
        "layer",
        "game framework implementation",
        "game framework design",
        "resource system",
        "Object-Composition Game Framework"
      ],
      "concepts": [
        "game",
        "object",
        "tasks",
        "provide",
        "framework",
        "layers",
        "layered",
        "programming",
        "program",
        "design"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 30,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 1,
          "title": "",
          "score": 0.545,
          "base_score": 0.395,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 13,
          "title": "",
          "score": 0.456,
          "base_score": 0.306,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 52,
          "title": "",
          "score": 0.417,
          "base_score": 0.267,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 14,
          "title": "",
          "score": 0.402,
          "base_score": 0.252,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "framework",
          "task",
          "audio visual",
          "game framework",
          "layer"
        ],
        "semantic": [],
        "merged": [
          "framework",
          "task",
          "audio visual",
          "game framework",
          "layer"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19509389517801107,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921131+00:00"
      }
    },
    {
      "chapter_number": 3,
      "title": "Segment 3 (pages 27-35)",
      "start_page": 27,
      "end_page": 35,
      "summary": "C-Style Macros\nhe lowly C-style macro (#define) is a powerful construct that is severely misun-\ntake into account the unique functionality that the macro possesses.\nmany C++ books fail to explain the basic properties of macros or even acknowledge\nIn a nutshell, the macro is a directive to the compiler’s preprocessor to do some\nmacros are useful and desirable in many surprising ways.\nMacros allow you to per-\ndialects of C/C++ by using macros is undesirable.\n1.3 Finding Redeeming Value in C-Style Macros 27\nof a macro.\n#define CaseEnum(a) case(a): LogMsgToFile(#a, id, time)\nTherefore, the macro trick is a sound\n#define DATA(Xx) x,\n#define DATA(x) #x, // make enums into strings\nMacro Trick #2: Compile-Time Constants from\nThe other special macro operator is ##.\nMacro source:\n1.3 Finding Redeeming Value in C-Style Macros 29\n#define BINARY6H(a,b,c,d,e,f,g,h) (Ox##a##b##cH#Hd##eH#THHg#HHh)\n#define BINARY8I(a,b,c,d,e,f,g,h) BINARY8H(a,b,c,d,e,f,g,h)\n#define BINARY8(a,b,c,d,e,f,g,h) BINARY8I(HEX_DIGIT(a), \\\nMacro Trick #3: Adding a Descriptive Comment to\nThe standard Windows assert (found in assert.h) is already a macro.\nWith the following macro, you can easily expand the standard assert to include a\n#define assertmsg(a,b) assert( a && b )\nMacro Trick #4: Compile-Time Assert ;\nThe following macro allows you to ver-\nify a statement at compile time, which in effect is a compile-time assert.\n#define cassert(expn) typedef char __C_ASSERT__[(expn)?1:-1\nMacro Trick #5: Determining the Number of\nlowing macro neatly returns the number of elements.\nMacro Trick #6: Making _ _LINE__\nSeveral very useful macros exist by default.\n__TIME__ //a string containing the time when it was compiled\nFor example, when an assert macro is placed in your code, it takes advantage of\nthe _ FILE__ and __LINE__ macros.\n1.3 Finding Redeeming Value in C-Style Macros 31\nstrings, here are several macros to turn the __FILE__ string and the __LINE__ integer\nThis trick doesn’t work with Microsoft Visual C++, since it replaces __LINE__ dif-\nInstead of replacing the macro __LINE__ with a simple\nMicrosoft Visual C++, the macro trick might produce a result like:\nHowever, this macro trick produces the desired result with both Metrowerks\nMacro Trick #7: Protecting Against Infinite Loops _\nThis trick creates a macro called “while limit,” which behaves similar to the\nThe previous example will assert if the loop spins more than 1,000 times.\nMacro Trick #8: Small, Specialized Languages\n#define UNIQUE_VAR(x) safety_limit ## x\n#define while_limit(a,b,c) \\\nint UNIQUE_VAR(c) = b; \\\nwhile(a && while_assert (--UNIQUE_VAR(c)>=0) )\n#define while_limit(a,b) _while_limit(a,b, COUNTER_)\nNote that a new default macro, __COUNTER__, is used in the previous code.\ntime, the variable’s name will be safety_limit1.) This unique-naming trick is neces-\nsary so that multiple while_limit macros could be used without their loop-iteration\nThe macro __COUNTER__ is not a standard ANSI C macro and is not implemented\ntrick exists by using the __LINE__ macro to help create the unique variable name.\nAlternate while_limit macro:\n#define _UNIQUE_VAR(x) safety_limit ## x\n#define while_limit(a,b) \\\nMacros can be quite powerful, and this trick probably demonstrates this best.\nlanguage that compiles directly into C/C++.\nWisdom (Rabin02)), there is an example of a macro language that standardizes the\nexample of a state machine using the macro language:\n1.3 Finding Redeeming Value in C-Style Macros 33\n// C++ code for state entry\n// C++ code for state clean-up\n// C++ code for state entry\npiles into C/C++ using only six macro keywords.\nmacro language actually hides the unnecessary details and lets you code the internals\nThe six macro keywords are as follows (OnEvent is a helper—it’s not used\n#define BeginStateMachine if(state < 0){if(0){\n#define EndStateMachine return(true);}}else{assert(0); \\\n#define State(a) return(true);}} \\\nMacro Trick #9: lifying Cl s Interfaces",
      "keywords": [
        "define HEX DIGIT",
        "Addison Wesley Longman",
        "define HEX",
        "HEX DIGIT",
        "DIGIT",
        "HEX",
        "macro",
        "macro trick",
        "define",
        "Charles River Media",
        "Wesley Longman",
        "Addison Wesley",
        "Object-Composition Game Framework",
        "trick",
        "line"
      ],
      "concepts": [
        "macros",
        "define",
        "defining",
        "tricks",
        "programming",
        "program",
        "assert",
        "assertion",
        "line",
        "compiler"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 55,
          "title": "",
          "score": 0.372,
          "base_score": 0.372,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 41,
          "title": "",
          "score": 0.357,
          "base_score": 0.357,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 8,
          "title": "",
          "score": 0.355,
          "base_score": 0.355,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 16,
          "title": "",
          "score": 0.354,
          "base_score": 0.354,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 4,
          "title": "",
          "score": 0.336,
          "base_score": 0.336,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "macro",
          "trick",
          "macro trick",
          "define",
          "macros"
        ],
        "semantic": [],
        "merged": [
          "macro",
          "trick",
          "macro trick",
          "define",
          "macros"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19010909903209394,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:24.921182+00:00"
      }
    },
    {
      "chapter_number": 4,
      "title": "Segment 4 (pages 36-45)",
      "start_page": 36,
      "end_page": 45,
      "summary": "// class declaration in Elmo.h\nBaseClass declares a virtual function\na pure virtual function.\nFurther, let’s assume that the derived class D3 overrides Foo(),\ndifferent functions, and that D3::Foo() is an entirely separate function from Base-\nClass::Foo().\nWhen we try to call Foo() as a virtual function on objects of class\nClass and D3 without also having to provide an additional declaration of D3: :Foo0().\ndeclare an interface—that is, it declares some number of virtual functions, most of\nthat base class.\nfunctions, and we derive 10 classes from that base class, that’s 100 extra function dec-\nity declared in the base class.” All of this extra text can make header files difficult to\nLet’s imagine we have a class called Creature, and we intend to derive various dif-\nferent classes of creatures from this base class.\nclass Creature\nFurthermore, assume we derive several different classes of creature (SnowCrab,\nNordicYeti, and SnowshoeBandit) from this base Creature class.\nCreature and all of the classes derived from it:\nclass Creature\nchange is the interface macro (INTERFACE_Creature in Creature.h).\nto modify the implementations in the various .cpp files; but given that the function is\nlook at the class declaration of NordicYeti in NordicYeti.h, we see DERIVED Creature\nNordicYeti, and that if we want to see the declaration of the creature-level function-\n[Dalton01] Dalton, ‘Peter, “Inline Functions Versus Macros,” Game Programming\nFunction-Binding Code\nAree function binding tool scans your C code for function prototypes,\nsigns unique integers to each function, writes out code that hashes the proto-\nintegers to the code that calls the functions.\nOnce the code generated by the binding tool is compiled into your program, such\nNow that we're older punks, we'll design a tool to write the code that handles the\ninternals of calling any function in our programs by text name.\nbe great if the code needed to send the new function calls to the other client machines\nble compiler-generation tools Lex and Yacc, along with grammars and specifications\ning C structures, typedefs, and function prototypes is mostly already complete on all\nious function-binding mechanisms.\nthe design for an automated and elegant Windows-, x86-, Visual C++ 6.0-specific\nSpecifically, functions tagged for compile-time DLL export were parsed\nAs we peruse the Lex specification for C [Degener95], we notice #define and\nFirst, take a C module whose functionality you want\ngenerated by cpp and extract function prototypes with the tool you will write with\nNext, in ‘Phase 2’ of this tool, take these extracted function prototypes,\nassign integer IDs to each of them, and generate C code for a table that associates the\nIn ‘Phase 3,’ we must write out yet more C code for a func-\nup the hard-coded function call with properly cast arguments.\nC code leaves the platform specifics of calling functions to the compiler.\nand link in the tool-generated C code, and youre ready to go.\nOnce we have Lex'd and Yacc'd together our function prototype-reading tool, we\nneed it to shove out some fast C code to bind function text names to IDs. Surpris-\nAfter compiling and linking our tool-generated C code into our games, we are\nWe can call our script-execution function on any script file,\nSupport for binding yet more languages to C/C++/objective-C code is in the works.\nC code to extract the token and calls your C code when it’s found.\n/* Put any C code here.\n/* Again, any C code of yours can go here */\nBetween the opening %{ and %}, we insert any C code we want at the top of the\ngenerated C code for this Lexer.\nthe two %% groupings, followed by bracketed C code that we want executed when the\nAfter the trailing %%, we again insert any C code we need.\nFear not, for you can also call functions and declare/assign variables from the C\n1.4 Platform-iIndependent, Function-Binding Code Generator 41\nlish sentences, we write a grammar for C so Yacc can distinguish a line of C from a\n/* Put any C code here.\nprintf (\"Function Failure: %s in %s at line\nLike cousin Lex, Yacc allows direct insertion of any C code between %{ and %}\ninto the generated C file.\ngrammer will include C code they want executed after a desired production.\ning the trailing %%, we again include all C code we want to include with the C code\nAgain, the exported functionality\nOnce you have function binding integrated into your RPC system, you need\naforementioned tool-generated, function prototype table of IDs and encoded\n1.4 Platform-Independent, Function-Binding Code Generator 43\nExporting and binding functions with tool-generated C code can save us lots of work\nin manually binding functions for scripting and RPC engines.\n[BilasO0] Bilas, Scott, “A Generic Function-Binding Interface,” Game Programming\n[Degener95] Degener, Jutta, “ANSI C Grammar, Lex Specification,” available online\nat http://www.lysator.liu.se/c/ANSI-C-grammar-l.huml, 1995.\n[Degener95] Degener, Jutta, “ANSI C Yacc Grammar,” available online at hetp://",
      "keywords": [
        "Elmo.cpp void Elmo",
        "Elmo.h class Elmo",
        "code",
        "Creature",
        "void Elmo",
        "function",
        "Charles River Media",
        "Elmo",
        "class Elmo",
        "base class",
        "Foo",
        "Yacc",
        "base Creature class",
        "Elmo.cpp void",
        "Lex"
      ],
      "concepts": [
        "function",
        "functions",
        "functionality",
        "classes",
        "code",
        "coding",
        "files",
        "creature",
        "design",
        "designate"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 27,
          "title": "",
          "score": 0.625,
          "base_score": 0.475,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 5,
          "title": "",
          "score": 0.498,
          "base_score": 0.348,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 7,
          "title": "",
          "score": 0.422,
          "base_score": 0.272,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 3,
          "title": "",
          "score": 0.336,
          "base_score": 0.336,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 41,
          "title": "",
          "score": 0.308,
          "base_score": 0.308,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "function",
          "code",
          "binding",
          "creature",
          "elmo"
        ],
        "semantic": [],
        "merged": [
          "function",
          "code",
          "binding",
          "creature",
          "elmo"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.17317960554160056,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921241+00:00"
      }
    },
    {
      "chapter_number": 5,
      "title": "Segment 5 (pages 46-58)",
      "start_page": 46,
      "end_page": 58,
      "summary": "Handle-Based Smart Pointers\nt any time, an object in a game can die and leave any pointers to that object dan-\noften a conversion provided from a handle to a pointer, but this can lead to accidental\nto wrap the handle inside a smart pointer.\nA smart pointer is a C++ class that uses syntax similar to a regular pointer, but it\nThere are many smart pointer implementations available with differ-\nLet’s consider when to use handle-based smart pointers.\nFinally, handle-based smart pointers are only necessary when several objects need\nto store pointers to the same object, such as four players that each require a reference\nNow that you know when and why to use handle-based smart pointers, we can move\n1.5 Handle-Based Smart Pointers 45\nsmart pointer.\nBecause the owner stores a smart pointer, a function is required rather than the delete\nple, the handle pointer can be dereferenced using operator -> or operator*.\ndestroyed, thus invalidating the handle pointer.\nThe handle is at the heart of a handle-based smart pointer and therefore must be\nSmart Pointer\nArray of Handle/Pointer Pairs\nHandle | Pointer\nThe smart pointer wraps the handle to provide familiar syntax when using the handle.\nsmart pointers.\nConstructing a smart pointer from a dumb pointer requires the creation of a handle.\nThe constructor passes the dumb pointer to a handle manager in order to create this\n1.5 Handle-Based Smart Pointers 47\nThe handle and the dumb pointer, which will be used for validation and\ndumb pointer is assigned to a single handle-based smart pointer immediately on\nobject creation, and all subsequent use is through the smart pointer or copies of the\nsmart pointer.\nOne option is to add a member function to the smart pointer\ntive is to use a friend function that deletes the dumb pointer when given a smart\nOnce the object is deleted, the handle manager must be\nIf there is the possibility that the object was destroyed, the smart pointer must be\nthat are used when checking a handle-based smart pointer: equality and inequality.\npointer.\nbut not defining the operator, and then returning a pointer to a global instance of the\nfunction can return a null pointer.\nThe most useful feature of a smart pointer comes from the dereferencing operators\nbecause they will be the most-frequently used handle-based smart pointer features.\nHandle-based smart pointers can be an efficient and powerful technique when used\nThe combination of handles and smart pointers sim-\nWe've covered the specific issues relating to smart pointers using handles, but\nful information on smart-pointer implementation and uses.\nCustom STL Allocators\nany games use custom memory allocation strategies, providing their own mal-\nto use your own allocation and deallocation methods with all standard C++ container\nyou could customize the list so that all memory allocations came from the stack rather\n// Create custom allocator object\n// Tell the list about the custom allocator\nStackAlloc is a custom STL allocator.\nof allocators is that you can write your own implementations that use whatever allo-\nallocate memory to store objects in the container.\nvide custom allocators that define how memory will be managed.\nThe default allocator\nstd::list<int> IntList; // uses default allocator<int>\nAllocator Requirements\nAny allocator object must meet the minimum requirements set forth by the C++\nAll allocator objects must include the typedef names shown here.\n1.6 Custom STL Allocators 51\nAllocators are regular C++ objects, so there must be a way to construct them, copy\nallocator() throw();\n~allocator() throw();\nconstructed given an allocator of another type.\nAllocator objects must provide a small set of utility functions.\nAllocation\nThe allocate function is one of the two critical functions in the allocator object,\ncate must return a pointer to raw memory of sufficient size to hold N objects of size\nThe second parameter is an allocation “hint,” commonly a pointer to another mem-\npointer allocate( size_type n, const void* pHint );\npointer allocate( size_type n, const void* )\nThe deallocate function is the second critical function of the allocator object.\nC++ Standard states that this function must free storage for N objects of size T, where\nThe pointer\nvoid deallocate( pointer p, size_type n );\nvoid deallocate( pointer p, size_type )\nNotice that unlike new and delete, allocate and deallocate don’t construct or\nThe allocator construct function allows existing memory to be used for con-\nactually allocate memory—it calls an object’s constructor using existing memory.\nvoid construct( pointer p, const_reference c )\n1.6 Custom STL Allocators 53\nSuppose you've defined your own allocator object for a list of integers.\n(vector being an exception) don’t actually allocate the objects they store.\nEach node contains an object plus one or more pointers.\nRebind simply allows allocator<T> to allocate objects of another type, U.\nexample, given allocator @ of type T, you can allocate an object of type U with the\nThe C++ Standard says two things about comparing allocators.\nallocated via the other.\nbool operator==( const allocator<T1>&,\nbool operator!=( const allocator<T1>&,\nThe C++ Standard requires that all STL implementations include a default allocator\nobject called “allocator<T>.” This is the allocator that’s used if a custom allocator is\nThe default allocator object is defined in the C++ Standard in Section 20.4.1\nYou can find the default allocator for your version of the STL in the <memory>\nThe standard says the default allocator must call operator new to allocate storage.\nimplementation of the default allocate function looks like this:\npointer allocate( size_type n, const void* )\nreturn pointer( operator new( n * sizeof(T) ) );\n1.6 Custom STL Allocators 55\nvoid deallocate( pointer p, size_type )\nAs you might expect, the default allocator object simply wraps new and delete.\nImplementations are free to provide additional optimizations in the default allocator\nAs mentioned above, every allocator object must meet the minimum requirements set\nis by copying the default allocator from <memory> and then customizing the allocate\nThe allocate\nfunction simply returns a pointer to the next unused portion of stack memory, then\npointer allocate( size type n, const void* )\nvoid deallocate( pointer p, size_type }\nallocator.\nallocator.",
      "keywords": [
        "Pointers Brian Hawkins",
        "smart pointer",
        "pointer",
        "Handle-Based Smart Pointers",
        "Smart Pointers Brian",
        "allocator",
        "Custom STL Allocators",
        "allocator object",
        "object",
        "handle",
        "Brian Hawkins",
        "Smart",
        "dumb pointer",
        "default allocator",
        "default allocator object"
      ],
      "concepts": [
        "allocators",
        "allocations",
        "allocate",
        "allocated",
        "pointers",
        "object",
        "handle",
        "functionality",
        "function",
        "functions"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 27,
          "title": "",
          "score": 0.707,
          "base_score": 0.557,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 4,
          "title": "",
          "score": 0.498,
          "base_score": 0.348,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 6,
          "title": "",
          "score": 0.478,
          "base_score": 0.328,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 7,
          "title": "",
          "score": 0.43,
          "base_score": 0.28,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 24,
          "title": "",
          "score": 0.377,
          "base_score": 0.377,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "allocator",
          "smart",
          "pointer",
          "smart pointer",
          "allocate"
        ],
        "semantic": [],
        "merged": [
          "allocator",
          "smart",
          "pointer",
          "smart pointer",
          "allocate"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1881865521139775,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921290+00:00"
      }
    },
    {
      "chapter_number": 6,
      "title": "Segment 6 (pages 59-68)",
      "start_page": 59,
      "end_page": 68,
      "summary": "Allocator State Data\ncomparable allocators, it’s dangerous for allocators to hold per-object data/state of any\nthe only safe path is writing allocators with no per-object data.\nwith per-object data is to examine the implementation of list: :splice.\ninal case, the splice function splices one list to another by shifting pointers, which is\nNow, consider the case where the allocators for the lists are truly different—\nresulting list would contain some nodes allocated on one heap and some on another.\nIn the list splice function, if there are two code paths based on the comparison\nobject data.\nBelow is a list of recommendations for writing a custom allocator.\n* Be wary of creating allocators that hold per-object data or that contain “state.”\nYour STL implementation might not support such allocators.\nsplice function to determine if your implementation supports allocators with\nper-object data.\nper-object data and allow nontrivial comparison functions.\nport allocators with per-object data and might provide custom member functions to\n[Dinkum] Plauger, P J., et.\nSave Me Now!\nability to save the game at any point.\nUnfortunately, this approach usually has a\nmented and object lists get jumbled.\nNote that this will require several passes through the ‘save data’\neach object type.\nSince most games have many types of objects, this can become an\nAlso, whenever any data structures change, all saved games are invali-\ndata elements and types to save for each object class, pass a list of object instances to\nowmeco a SAVENGR class framework that manages game saves with this automation.\nThe class\nAfter implementation, the process of saving a game becomes trivial.\nobjects that should be saved with calls to AddSaveObject(), and then call save() to\nsave the game.\nSAVEMGR builds a list of all the objects that are to be saved with each call to\nWhen the Save() function is invoked, SAVEMGR goes through this\nlist and calls the Save() member function for each object.\nWhen a pointer to an object\nneeds to be saved, SAVEMGR searches through this list to find the referenced object.\nthe object’s ID, which is then saved in place of the pointer.\nbeing referenced by the pointer is not in the list, then the game cannot be properly\nsaved.\nfor each object, it reads its class [D and calls the SAVEMGR: :MakeObject() function to\nfunction, which reads the object’s data.\nmanner, SAVEMGR makes a final call to each object’s PostLoad() function, which de-ref-\nride the Save(), Load(), and PostLoad() virtual functions, but it must be careful to\ncall the base class version of the functions before returning.\n1.7 Save Me Now!\nHow does it know what data to save for each object?\nspecifies the data elements to write into the save file.\nseveral macros for common types, including pointers, allocated data, and contiguous\nThe GetSaveID() member function must return a unique ID for each type of\nclass.\ntion to create a class of the correct type during loading.\nThe SAVEMGR class natively supports the saving of several different data types through\nported are contiguous generic data, pointers, allocated memory, and the save table of\nThese are listed in the save table through the macros SAVEDATA,\nThe SAVEDATA macro has two parameters; the first is the type of the class, and the\nthe SAVEPTR macro takes the type of the class and the member variable name.\nThe SAVEALLOC macro takes three parameters—the type of the class, the member\nFinally, the SAVEBASE macro takes a single parameter—a pointer to the save data\nFor instance, for a class PLAYER derived from the class OBJECT,\nthe save table could contain an entry SAVEBASE (OBJECT: :obj_savetable).\nOBJECT class was derived from another class, say MASTEROBJ, then the OBJECT save table\nclass would automatically save the data elements for its base OBJECT class and also its\nThis macro saves not only the offset of the pointer to the allocated data, but\nalso the offset of a variable containing the size of the data that has been allocated.\noften necessary to save data types that are specific to the current game state.\nIn some cases, it is desirable not to save certain data to the file, since it is derivable\nWhen an object is saved, the save manager calls SAVEOBJECT: :Save().\nmust override the Save() function.\nNote that the base Save() function must be called\nin the class until you have called the base class’s Load() function.\nfunction can be overridden and called for each object after all the objects have been\nThe following code demonstrates saving a simple class.\n/* This is the data for the PLAYER class */\n/* The data saved for class PLAYER */\n1.7 Save Me Now!\nThis is the class factory function.\nfunction returns a pointer to the save table for the PLAYER class, which defines the data\nSaving and loading games is arduous and requires careful data conversion and man-\ninto a simple task of maintaining one table of data for each type of class.\nthe game containing pointers to all objects derived from B, identifying the relatively\nas “to be listed,” and, with no further programmer effort, the class itself would create\nrequires half a line of code for each class to be listed.\n¢ It has a static, private member variable of type list-of-pointers-to-Ts.\n* On construction, it casts its this pointer to type T* and adds itself to that list.\nTAutolists<CListMe>), the class's this pointer (cast to a CListMe pointer) is added to\nallowed to the list object itself.\nobject, given the restrictions on removals from the list.\nof the regular list functionality without all the other useful stuff you can do with iter-\nThe cost of autolisting a class is trivial: one static list object containing one list ele-\nment per object listed (as it would be with any list), one static iterator per list, and the\nclass with an array (or list) of iterators to manage an iterator ‘stack’ within",
      "keywords": [
        "Save",
        "object",
        "list",
        "Data",
        "Allocators",
        "PLAYER class",
        "PLAYER",
        "function",
        "save table",
        "type",
        "game",
        "SAVEMGR",
        "object class",
        "save data",
        "functions"
      ],
      "concepts": [
        "function",
        "functions",
        "functionality",
        "save",
        "saving",
        "saved",
        "allocators",
        "allocated",
        "allocate",
        "allocation"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 55,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 27,
          "title": "",
          "score": 0.513,
          "base_score": 0.363,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 5,
          "title": "",
          "score": 0.478,
          "base_score": 0.328,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 7,
          "title": "",
          "score": 0.425,
          "base_score": 0.275,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "",
          "score": 0.334,
          "base_score": 0.334,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "save",
          "class",
          "object",
          "data",
          "list"
        ],
        "semantic": [],
        "merged": [
          "save",
          "class",
          "object",
          "data",
          "list"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.13953854355149176,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921336+00:00"
      }
    },
    {
      "chapter_number": 7,
      "title": "Segment 7 (pages 69-84)",
      "start_page": 69,
      "end_page": 84,
      "summary": "sider the perfectly sensible and useful situation in which class CBase is a parent to class\nHowever, this is not the case within CDerived, which inherits two functions called\nAutolists are a design pattern intended to ease the common game-programming task\nclass for a class J; creates a new list of pointers-to- 7, hides its implementation behind\nFloating-Point Exception\ntions in which floating-point exceptions are often handled automatically, caus-\ning the processor to keep quiet about any floating-point errors that might occur.\npoint exceptions might crash on some platforms and run on others.\nsince many operations work differently with illegal or infinite floating-point val-\n* To Avoid Sloppiness: Although most floating-point errors are very innocent,\ncode that causes floating-point exceptions.\nFloating-Point Exceptions?\nSome compilers (e.g., Microsoft Visual Studio 6) disable floating-point exceptions by\nHere is a short piece of test code that, when put into a program,\nfloating-point exceptions or crashes it.\nThe biggest consideration when enabling the floating-point exceptions is which types\nof exceptions to use.\nnot be enabled, as most floating-point operations are slightly imprecise and\n1.9 Floating-Point Exception Handling 71\nthis exception should not be enabled.\npared to normal floating-point values, and by testing your code with this flag on,\nThe code for enabling the floating-point exceptions is really simple.\nsome libraries overwrite the floating-point exception flags.\ncode should be at the core of the program, not just immediately after enabling the\nexceptions.\nNote that changing the floating-point exception flags can be expensive, so\nYou should also consider whether to enable floating-point exceptions in your released\nFor a game, it might make sense to disable all exceptions; a\n-Point Exceptions\nOk, so you enabled the exceptions and your program crashes.\nhave multistage pipelines, the floating-point error occurs at the earliest stage during\nthe next floating-point instruction, which might not even be in the same function.\nThe code to check for float-\ning-point exceptions is simple, but care has to be taken to put it in at the right place\nThere is no reason not to check for floating-point errors, and doing so offers the\nProgramming a Game Design-\ngame-design ideas because the game engine cannot cope with them.\nhand, we might be disappointed when the game designer frowns at a brand new\nWe have all faced these situations, usually due to the fact that game design and\ndesigners and programmers, both have their own ideas of what the game should be.\nThis gem will explore collaborative work between the game-design team and the\nBy working together on the same model, designers and programmers\nThe Object Is in the Game_\nObject-oriented programming (OOP) was modeled after the real world.\nof C++ as a game programming language.\nSoftware and Game Design Share History\nRecently, one of the most difficult challenges faced in game design is how to break\nStorm) promotes object-oriented game design in order to gain ‘global consistency’\nHe demonstrates that by using object classes that inherit\nSince game design is becoming more object-oriented, now is the time to work\nWhen considering design tools, it’s important to take the dynamic aspect of game’s\nThis is the case for UML.\nduces actors, use cases, sequences, and collaborative diagrams.\nBoth the game designer and the programmer use the game scenario as the starting\nDefining Which Case to Use\nthat can initiate an action—the game player, Groody, and the stormy cloud.\n1.10 Programming a Game Design-Compliant Engine Using UML 75\nFor UML, these actions are formalized as use cases.\nUse cases\nactors are drawn as stick figures, and use cases are drawn as ovals.\nLevel case uses the Jump over white clouds case.\nEach use case must also be described\nFIGURE 1.10.1 Use case diagram for Groody.\nUse cases are wonderful for creating a quick draft of the design concepts, but they can\nuse-case relationship, each time that an instance of an actor is created, it will execute\nan instance of the use case, also called the “scenario.” This scenario is unwrapped\nA sequence diagram features the dynamic interactions between objects.\nfocus on the Use Wind Blower use case, a typical scenario would be:\nSeveral sequences are defined for each use case.\nthat describes a use case.\nClasses Move .\nFIGURE 1.10.2 Sequence diagram for the Use Wind Blower use case (time goes\nwhereas the collaboration is object-based (see Figure 1.10.3).\nmost popular diagram for UML, the class diagram.\n1.10 Programming a Game Design-Compliant Engine Using UML 77\nFIGURE 1.10.3 Collaboration diagram for the Use Wind Blower use case.\nDuring the class design, the secret to efficient collabo-\nration between the programmer and the game designer is ‘vocabulary’ (see Figure\nprogrammer uses the terms “association,” “aggregation,” or “generalization,” the game\nThe collaboration diagram usually makes a good starting point.\nFrom the collaboration diagram (Figure 1.10.3), we define the messages as the\ngram after one use-case analysis.\nFIGURE 1.10.5 Class diagram (incomplete), after one use case analysis.\nUML has more advantages than just simplifying communication between game\n1.10 Programming a Game Design-Compliant Engine Using UML 79\ngame design in UML before beginning the engine implementation.\nincremental, back and forth between game designer and programmer.\nThe use of case\nThus, a programmer can code the game engine and go back to the design when\nan abstract enemy class and specialize the cloud class from this new one.\ncation implies a minor modification to the class diagram (see Figure 1.10.6).\nstormy cloud from the enemy class with the generalization link.\nFIGURE 1.10.6 Jncremental class diagram modifications.\nHowever, if you use a UML case tool, the code modifications\nthe sequence diagram (Figure 1.20.2), the Groody actor is responsible for polling\n3. The combat resolver finds a stormy cloud in Groody’s line of sight.\nThis new scenario results in a new sequence diagram (Figure 1.10.7), which in\ninserted into the class diagram.\nthe game design, however.\ncan be done from the class diagram at any time.\nusually build the source code from the design automatically.\n1.10 Programming a Game Design-Compliant Engine Using UML 81\nUsing a UML design, functions and classes can be\n[Python02], you can also use UML to code these game scripts.\nFIGURE 1.10.8 State diagram for the StormyCloud class.\ntranslating the class diagram into plain code.\nHowever, the best option is to use a case\nnecessary to keep both the UML model and the code consistent.\nThis gem proposed techniques for using UML for g game programming.\nstrated that using a modeling language can help game designers create object-oriented\ndesigner.\nUsing a case tool gives you the ability to work incrementally with object-oriented\nBeen Oe AR MING MENS AR ORIEN IO EERE\n[Dybsand00] Dybsand, Eric, “A Finite-State Machine Class,” Game Programming\n[GPG01] DeLoura, Mark, Game Programming Gems 2, Charles River Media, Inc.,",
      "keywords": [
        "game",
        "Game Design",
        "UML",
        "floating-point exceptions",
        "game programming",
        "code",
        "Programming",
        "Exception",
        "exceptions",
        "Design",
        "General Programming",
        "Floating-Point",
        "class diagram",
        "diagram",
        "case"
      ],
      "concepts": [
        "classes",
        "programming",
        "program",
        "game",
        "design",
        "uml",
        "useful",
        "uses",
        "figures",
        "floating"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 27,
          "title": "",
          "score": 0.506,
          "base_score": 0.356,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 5,
          "title": "",
          "score": 0.43,
          "base_score": 0.28,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 6,
          "title": "",
          "score": 0.425,
          "base_score": 0.275,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 4,
          "title": "",
          "score": 0.422,
          "base_score": 0.272,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 55,
          "title": "",
          "score": 0.364,
          "base_score": 0.214,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "floating point",
          "exceptions",
          "floating",
          "uml",
          "diagram"
        ],
        "semantic": [],
        "merged": [
          "floating point",
          "exceptions",
          "floating",
          "uml",
          "diagram"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1406780583241508,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921386+00:00"
      }
    },
    {
      "chapter_number": 8,
      "title": "Segment 8 (pages 85-92)",
      "start_page": 85,
      "end_page": 92,
      "summary": "Custom Data Files\ndata file.\nBriefly, the format of the custom data file will contain the data and descrip-\nThe separation of data from the code by using a custom data file has\n* Creating a custom data file for the subsystem helps organize the data so that it is\nThe custom data file is input to a tool.\nLex and Yacc, an\nLex and Yacc can extract data from\na text file and pass the data along to a tool for further processing.\nmethods for using Lex and Yacc within a tool for processing custom data files that can\nand parser for a custom data file, as well as how to build a simple data file format.\nfirst two sections provide a brief description of the basic functionality of Lex and Yacc.\nThe third section covers how both work together to parse custom data files.\nThe last two sections cover methods of using Lex and Yacc to generate game data.\nThe first method will discuss generating game data from a custom data file for a game\ndiate export data files.\nLex generates a source code file that specifies a lexical analyzer (also know as a lexer or\nThere are three sections to every Lex file: a C code section and the lexer specifica-\ntypes, and other data types that are used by the lexer and the last (C code) section.\nYacc generates a source code file that specifies a parser (and\nan optional header file to be used by the Lex-generated code that contains token\nIn our case of using custom data files, these actions are used to determine\nhow the text file should be interpreted into binary data.\ncontains C code and is usually used for inserting include files and the declaration of\nconstants, macros, global variables, function prototypes, and other data types that are\nSo, what is the advantage of using Lex to write lexers and Yacc to write parsers?\n1.11 Using Lex and Yace To Parse Custom Data Files 85\nNevertheless, there are disadvantages to using a lexer created by Lex and parser cre-\ncannot be performed within a Lex lexer and a Yacc parser with as much relative ease.\nfiles generated by Lex and Yacc are compiled and linked into a tool that uses them.\nThe tool will assign the Yacc global variable, yyin, to be a pointer to the custom data\nhas calls to the lexer functions created by Lex to grab the tokens of the input (the custom\nLex specification Lex generated C lexer code\nYacc specification Yacc generated C parser code\ndata file), Data is passed from Lex to Yacc by using the Yacc sunion and another Yacc\nData is passed to the tool from Lex and Yacc through global\ncustom data file\ndata file\nA custom data file can be used to specify data for a game subsystem.\nthe custom data file can be difficult to define.\nkind of structure that can be exploited to form a data file format that is both sensible\ntom data file formats.\ndata file, and the Yacc specification for the custom data file.\nbe configured using a custom data file.\nple of a custom data file for a weapon system, the Lex specification for the custom\n1.11 Using Lex and Yacc To Parse Custom Data Files 87\nThe custom data file must have enough structure so that a Yacc specification can\nbe used as a template for most simple data-file formats.\nA similar custom data file, Lex specification, and Yacc specification can be used\nand any other data for which a custom data file can be created.\nhave a similar data file to the weapon system’s data file.\nA custom data file can be created for menu or HUD system data, where data\nwhole specification can be created for menus within a data file that can be used to\nLex and Yacc can also be used to parse text data exported from tools like 3D Max. It is\ntext data to a binary file that can be loaded at game initialization.\nWe will now present an example (on the CD-ROM) using the custom data file format\nis called from the parser (generated by Yacc) whenever a new token is needed.\n“START_WEAPON,” the token constant TKN_START_WEAPON is returned to the Yacc\nListing 1.11.2 Lex specification for weapon data\n/* C code section for Lex specification */\n/* C code section for Lex specification */\n/* function to remove a comment from the input data file.\n1.11 Using Lex and Yacc To Parse Custom Data Files 89\nThe second section of the Yacc specification is the parser definition.\nspecifies what data is expected to be returned from Lex. These are unioned fields so be\nListing 1.11.3 Yace specification for weapon data\n_ custom data file.\n%stoken TKN_START_WEAPON TKN_START_AMMO TKN_END\n%stoken TKN_WEAPON TKN_AMMO\n// tokens that can return a value from Lex to Yacc via // yylval\n// weapon_data is the start symbol\nweapon_data: /* lamda rule - empty rule */\n| weapon_data weapon_section\n| weapon_data ammo_section",
      "keywords": [
        "custom data file",
        "data file",
        "Yacc",
        "Data",
        "Lex",
        "Custom Data",
        "Lex and Yacc",
        "TKN",
        "ammo",
        "weapon",
        "Yacc specification",
        "file",
        "Lex specification",
        "WEAPON TKN",
        "return TKN"
      ],
      "concepts": [
        "data",
        "files",
        "tokens",
        "parser",
        "returns",
        "weapon",
        "sections",
        "section",
        "ammo",
        "include"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 65,
          "title": "",
          "score": 0.523,
          "base_score": 0.373,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 66,
          "title": "",
          "score": 0.444,
          "base_score": 0.294,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 60,
          "title": "",
          "score": 0.383,
          "base_score": 0.233,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 9,
          "title": "",
          "score": 0.362,
          "base_score": 0.362,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 61,
          "title": "",
          "score": 0.357,
          "base_score": 0.207,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "data file",
          "custom data",
          "yacc",
          "lex",
          "file"
        ],
        "semantic": [],
        "merged": [
          "data file",
          "custom data",
          "yacc",
          "lex",
          "file"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18111100363365157,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921431+00:00"
      }
    },
    {
      "chapter_number": 9,
      "title": "Segment 9 (pages 93-101)",
      "start_page": 93,
      "end_page": 101,
      "summary": "Developing Games for\nUh recently, developing games for multiple language markets was often done as\nlanguage market, the coding work to support other languages would begin, with test\nreleased games in multiple language markets simultaneously, and titles such as Star-\n1.12 Developing Games for a World Market - 93\noptions and customizations particular to each language version of your game.\nFirst of all, you need fonts that contain all of the characters that must be displayed.\nOpenType fonts for ANSI and Unicode character display, respectively.\ncan contain characters for multiple languages, but they can result in much larger file\nHowever, games\nimportant to consider a game’s target markets when obtaining or developing fonts.\nIf your game supports multiline text input or display, one of the problems that can\nfollowing rule: Lines may be broken before, after, or between double-byte characters.\nHowever, when a line break is needed within single-byte characters, you should break\nat the last space or double-byte character.\n1.12 Developing Games for a World Market 93\noptions and customizations particular to each language version of your game.\nFirst of all, you need fonts that contain all of the characters that must be displayed.\nOpenType fonts for ANSI and Unicode character display, respectively.\ncan contain characters for multiple languages, but they can result in much larger file\nHowever, games\nimportant to consider a game's target markets when obtaining or developing fonts.\nIf your game supports multiline text input or display, one of the problems that can\nfollowing rule: Lines may be broken before, after, or between double-byte characters.\nHowever, when a line break is needed within single-byte characters, you should break\nat the last space or double-byte character.\nOnce you have your characters displaying properly, you need to deal with input as\nWhile some games allow input only in English, this can be very limiting when\ngame.\nAlthough supporting input of European characters requires few changes from\nThe first problem with implementing support for input of these languages is that\ncodes (and, more recently, pen- or mouse-driven input) into character codes.\nOnce the user selects the desired word (or string), the actual character\nchoose to support IME input in your game, you should familiarize yourself with the\nknowledge of the target language(s) for a game, it might still be possible to provide\nFor example, in a Japanese game, it is possible to allow users to input player\nphonetic characters, either of which can be used to represent any word in the Japan-\n1.12 Developing Games for a World Market 95\nFIGURE 1.12.1 On-screen keyboard for input of (A) Japanese hiragana characters, (B) Japanese\nkatakana characters, and (C) English characters, from Microsoft Xbox.\nCharacter Sets\nWhen implementing support for various languages into a game, there are several dif-\neach character encoding scheme.\nSingle-Byte Character Sets (SBCS)\nIn addition to character display, another issue that has to be dealt with is character\ncharacter.\nThis is called a “single-byte character set” (SBCS) and is often used to\nEnglish text, punctuation, and a few control characters.\nWindows, for example, these are represented by a form of the ANSI character set\n1.12 Developing Games for a World Market 97\npages (or encodings of characters to numerical values) have been developed.\nSBCS code pages differ only in the definition of the upper-range characters 128-255.\nHowever, since single-byte character sets can only represent 256 symbols, it is still not\nDouble and Multi-byte Character Sets (DBCS/MBCS)\nTo represent a wider range of characters, larger character sets were developed.\nname implies, a double-byte character set (DBCS) uses two bytes per character, and a\nof this is the Japanese Shift-JIS encoding scheme, which uses characters of one or two\nIn the Shift-JIS system, single-byte characters fall from 0x00 to 0x7F for ASCII\ncharacters and 0xA0 to OxDF for Japanese single-byte kana.\nDouble-byte characters\nsingle-byte characters, namely 0x81 to 0x9F and OxEO to OxFC.\ntrickier to develop for because character-counting, word-wrapping, and cursor-move-\nlead-byte ranges vary for different MBCS encodings, your code might need to provide\nProgramming for Various Byte-Size Character Sets\nWhen working with SBCS data, while code pages might be a concern, characters and\nthat a character does not necessarily correspond to a byte, and vice-versa.\nbytes with characters can lead to disastrous results.\nallocated as a 16-byte string, and the input algorithm counts user input by characters\nsearches in terms of characters, rather than bytes.\nand the same character code used as a nonlead byte of a double- or multibyte charac-\nserious bugs that are only reproducible when specific characters in certain languages\nimmediately before the cursor represents a single byte or part of a multibyte character.\nor multibyte character.\nwithout having to deal with code pages and characters of varying lengths.\ncode standard defines approximately 40,000 characters in a constant two-byte format,\nsupporting characters, symbols, and codes necessary to display the majority of major\nsupporting millions of characters and a plethora of languages (even Klingon!), the\ndouble-byte Unicode standard is typically sufficient for most games, and its flexibility\nIn addition to the character input, encoding, and display issues that were described",
      "keywords": [
        "characters",
        "Game",
        "Japanese",
        "Developing Games",
        "input",
        "languages",
        "Free Software Foundation",
        "World Market",
        "English",
        "Character Sets",
        "Market",
        "Fonts",
        "European languages",
        "game characters",
        "Unicode character display"
      ],
      "concepts": [
        "characters",
        "game",
        "input",
        "byte",
        "code",
        "coding",
        "languages",
        "market",
        "japanese",
        "developing"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 10,
          "title": "",
          "score": 0.693,
          "base_score": 0.543,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "",
          "score": 0.481,
          "base_score": 0.331,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 8,
          "title": "",
          "score": 0.362,
          "base_score": 0.362,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 2,
          "title": "",
          "score": 0.313,
          "base_score": 0.313,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "characters",
          "character",
          "byte",
          "single byte",
          "double"
        ],
        "semantic": [],
        "merged": [
          "characters",
          "character",
          "byte",
          "single byte",
          "double"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.11474968667755114,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921477+00:00"
      }
    },
    {
      "chapter_number": 10,
      "title": "Segment 10 (pages 102-110)",
      "start_page": 102,
      "end_page": 110,
      "summary": "1.1 2 Developing Games for a World Market 99\ntaken into account when developing a game for multiple markets.\ndevice input and video output, as well as UI design and game content.\nWhen developing for game consoles, it is important to keep video standards in mind.\npre-rendered video for your game might need to be provided in both formats.\nA common problem encountered when producing a PC game for a world market is\nIf your game is to have appeal in multiple language markets, it is important to\nThe problem arises when gamers use different keyboard layouts to play the game.\nspecifically Oxba-Oxbf, Oxc0, Oxdb-Oxde, and Oxe2.\nvirtual keys, and ASCII character codes, please refer to Table 1.12.1.\nOxde ‘ 0x27 Oxde 4 Oxe4 Oxc0 u Oxf9\nRegardless of the character encoding and input method systems used in a game, one\nEven if your game’s engine and UI is designed to\nencounter resizing and/or overlapping issues when you first localize your game.\nless likely to require changes when you begin localizing to languages that might\n1.12 Developing Games for a World Market\nthrough manual testing of the in-game UI, it is also possible to automate this process\nCulture-Neutral Game Design\nIn addition to making sure that the interface is designed for its target language, it is\nimportant to ensure that your game does not make any invalid assumptions regarding\nFor example, if your game expects the character\nWhile many games might be\nFor example, if you choose to develop a game that has strong adult themes, Nazism,\nFor example, if your game shows a map that contains\nWhen making a game for a world market, it is important to consider the\nin your target market or even having your game banned.\nOnce you've developed your game to display, input, and handle data in your target\nlanguage, you still have a problem—your game isn’t actually in the target language\nconfigurations to prepare a software product for another language market.\ndesign and development process in order to ensure that the localization process goes\nQuite possibly, the biggest impediment to the localization process is that of hard-coded\nmodification of in-game text.\nThis problem escalates when localizing a product, as having text in the wrong lan-\nIn order to prevent localization problems due to hard-coded strings, it is impor-\nOver-Localization\nshould be localized.\nin the localized French version should similarly portray the character as less than flu-\nexample, if your game contains graphical resources with embedded text, it is unrea-\nand localize it.\nthe localization process.\nIn addition, when producing audio or video, remember that the localized version\n1.12 Developing Games for a Worid Market 103\nsuch, it is best to ensure that in-game audio/video clips are long enough to accommo-\nIn addition, if you are targeting multiple language markets, please keep in\nvideo sequences using the game’s engine.\nAnother concern in localization is ensuring that the game has the same feel in\nyour game, it is a good idea to ensure that the character and tone of the original is\nIn addition, if your game has a character that\nLastly, keep in mind that if you use a celebrity in your game, he or she might\nAs such, if your game must use string concate-\nOnce you understand the core issues involved in developing games for a world mar-\nThere are several ways to plan multiple language releases of the same game.\ntends to increase the work for localization and testing, and might significantly hamper\nHowever, this could be the only choice if a game is\nTesting\nModifying a Game After the Fact\nIf you are trying to add multiple language support for a game that is already shipped or\npean languages in the game UI itself, but implement wider support in the install\nEnglish, but modify the game engine to support storage and display of a wider range\nFinally, you can modify the game to support MBCS (such as Shift-JIS),\nIn addition, if all versions of the game run off the same code base,\nguage versions of your game can ship.\nTesting of different localized versions of a product need not be\nIf your game is single-code base and world-ready, a full test pass needs be\nTesting on other language versions of the\ngame can focus on localization and functionality specific to those versions, although\ntesting that might require specific attention when dealing with an international game.\n1.12 Developing Games fora World Market 105\nOne of the first obstacles to testing a localized game is the language barrier.\nbeen testing the original-language version long enough, they should be able to walk\nIf they are localized in the test builds, it might be necessary to provide testers\never, in-game verification and other testing might require someone fluent in your tar-\ncompanies to which you can outsource localized testing.\nIn particular, danger-character testing is important\nJIS, the character value 0xDF represents the highest of the single-byte kana codes,\nlanguage/codepage and identify the following characters:\nIn addition, if your game is Unicode and\nallows multiple-language input, a good test string should include text (preferably dan-\nger characters) from multiple languages as well.\nbuffer limits for different strings (they should be detailed in the game specification,\ntesting on them with both single- and double-, or multibyte characters if possible.\nAnother issue that can arise in testing localized games is that of hardware configura-\nWhen testing for these markets, it is important\n1.12 Developing Games for a World Market 107\ndegree of customization in this area, and you should test to ensure that your game\nyour game) are cursor movement and text editing.\nTo test for problems in these\nUl and Localization Testing\nWhen performing localization and UJ testing, a sanity check can be performed by a\ncontext, string order, and translation testing.\nContext and string order testing refers to\nverifying the UI content (mostly text) and ensuring that strings are in the right places,\ndifferent in various languages, care must be taken in both localization and testing to\ninvolve the localization team in the testing process, since they are familiar with both\nIn addition, proper checks in the localization",
      "keywords": [
        "game",
        "Developing Games",
        "language",
        "strings",
        "character",
        "localization",
        "addition",
        "World Market",
        "Market",
        "string",
        "target language",
        "localized",
        "product",
        "English",
        "problems"
      ],
      "concepts": [
        "games",
        "tested",
        "strings",
        "string",
        "character",
        "localization",
        "localize",
        "localized",
        "language",
        "codes"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 9,
          "title": "",
          "score": 0.693,
          "base_score": 0.543,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "",
          "score": 0.556,
          "base_score": 0.406,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "game",
          "testing",
          "localization",
          "market",
          "language"
        ],
        "semantic": [],
        "merged": [
          "game",
          "testing",
          "localization",
          "market",
          "language"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.12184567751412297,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921523+00:00"
      }
    },
    {
      "chapter_number": 11,
      "title": "Segment 11 (pages 111-118)",
      "start_page": 111,
      "end_page": 118,
      "summary": "this process, along with ways of anticipating and resolving them as they relate to game\n[MicrosoftIME02] Microsoft Corporation, “Microsoft Global Input Method Editors\n(IMEs) Further Enhance East Asian Text Input,” available online at http://www.\nin 3D Games\neveloping a safe, fast, and responsive user interface and input system for your\ninput system possible.\nWe will also examine the important role that a user interface\nimplementing the User interfac\nWhen creating a 3D game, it is helpful to utilize the power of the available 3D hard-\ntempMatrix._42 = 1.0f;\nuser interface.\nThe method of using screen coordinates simplifies the encapsulation of any 2D user\nDirectX8 offers a method for rendering a sprite in screen coordinates that may be use-\nUser interfaces have grown increasingly complex over the years.\nSpecifying User Interface Elements\ninto the game.\nand element could be hard-coded into the game.\nIdeally, we would like to be able to specify the UI in an external file, allowing design-\n1.13 Real-Time Input and Ul in 3D Games\nideal candidate for specifying not only a user interface but also virtually all data-dri-\nven elements of the game engine.\nto specify a user interface screen.\nuser interface elements in a manner that is easy to parse as well as to read and edit.\nUsing percentages helps to ensure the UI is displayed as expected in a variety of screen\nThe user interface is on the forefront of this effort,\nshould always be considered throughout the development of the user interface and\nthe game engine itself.\n¢ Never hard-code any text that might eventually be translated; use a string table\n* Process WM_CHAR messages for all text displayed to the user.\nInstead, use a string table\nbyte character strings) or Unicode (wide character) strings throughout the game.\nAlso, never use DirectInput to process keyboard inputs that will be directly displayed\nto the user as text.\nsolution is to specify the font to use in the string table itself.\n1.13 Real-Time Input and Ul in 3D Games 113\nThe Input System\nThe user’s game experience incorporates more than simply the textures used for back-\nYour primary goals should include ensuring that all user input\nis responsive and performs as the user expects it to.\nDirectInput allows two methods of retrieving data from various input systems:\nis only processing a small amount of keyboard commands, such as left, right, up,\npress and release one or more keys between updates to the input system.\nevent specifies whether the key was pressed or released, which key it was, and provides\ninfrequently the input system is refreshed, we will know exactly what events occurred\nThe next step is to package up the input event, and put it on a queue of inputs to\nbe processed by the game engine.\n“pressed,” and “just released.” Storing our inputs in these three queues allows us to\nHowever, we will also use these keys as modi-\nA. For this reason, the input system will maintain a current modifier state consisting\nTherefore, each packaged input event will consist of the key for that event as well as\nWhen we are ready to process these inputs, the game engine\nas a map of input events to hotkey pointers.\nlocating the corresponding hotkey (if it exists) and executing the game engine code.\nWe now know exactly what keys the user pressed, no matter how often the input\nFurthermore, this method for processing input can serve as an\nthe user actually did, rather than checking against every possible key combination.\nThe mouse and joystick can benefit from buffered input in precisely the same manner\nInstead of key presses, we will package and process mouse and button\ngame engine, the mouse cursor or joystick controls might appear to jump around the\nscreen as the buffered axis inputs are processed.\nand immediate input.\nThe buffered input is used to process buttons and clicks, while\nOne fairly common implementation of the mouse in games is to run the mouse in its\ndered independently of other processing being performed by the game engine.\nIf the game is running at over 60 fps (frames per second), a mouse pointer\nthe solution is to separate the updating of the mouse axes from the processing of the\n1.13 Real-Time Input and UI in 3D Games 115\nAs the popularity of network games increases, so does users’ expectations of as fast and\nAt times, the user’s expectations can be rather\nA user running a complex network game on a 28.8k-baud modem will\nthe user.\nSome of the most successful online games, like Quake and Half-Life, use a\nof other entities in the game.\nA similar methodology can be applied to all aspects of the user interface and\ninput.\nAny and all feedback of the game, including updating UI buttons or selecting\nFor example, if the user presses the\nIf the user sends a chat message, it should be displayed on the screen instanta-\nIf the user clicks a button to build another unit, the onscreen counter should\nsionally compare the UI with the state of the game world, making corrections when\nthe user interface, knowing that eventually the server will receive the command.\nfast, safe, and robust user interface and input system for your game.\ncontains a complete keyboard input system that is easily adaptable for any game.\ninput system implements the fast, buffered-input method mentioned previously.",
      "keywords": [
        "input system",
        "Input",
        "user interface",
        "user",
        "game",
        "XML",
        "user interface elements",
        "Microsoft",
        "Microsoft Global Input",
        "game engine",
        "UITEXTITEM",
        "key",
        "Microsoft Anymore XML",
        "Microsoft Press",
        "interface"
      ],
      "concepts": [
        "game",
        "gaming",
        "user",
        "xml",
        "input",
        "useful",
        "process",
        "processing",
        "code",
        "data"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 10,
          "title": "",
          "score": 0.556,
          "base_score": 0.406,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 9,
          "title": "",
          "score": 0.481,
          "base_score": 0.331,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 13,
          "title": "",
          "score": 0.396,
          "base_score": 0.396,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 1,
          "title": "",
          "score": 0.36,
          "base_score": 0.36,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 42,
          "title": "",
          "score": 0.346,
          "base_score": 0.346,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "user",
          "input",
          "user interface",
          "game",
          "interface"
        ],
        "semantic": [],
        "merged": [
          "user",
          "input",
          "user interface",
          "game",
          "interface"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22617575069475426,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921580+00:00"
      }
    },
    {
      "chapter_number": 12,
      "title": "Segment 12 (pages 119-128)",
      "start_page": 119,
      "end_page": 128,
      "summary": "Evolution of Pie Menus\nPp menus are a naturally efficient user-interface technique—directional selection\npie, and all target slices are large, nearby, and in different directions.\nPie menus are\nthe pie menu advantage—their fast selection speed and low error rate is due to their\nThe Feng GUI of Pie Menus\nWhen designing a pie menu, think of Martha Stewart arranging a bunch of flow-\nResearching and Evaluating Pie Menus\nusers can design their own marking menus to customize their environment.\nsame, pie menus transparently train you to become an expert.\nremembers.” Pie menus exploit your body’s ability to remember muscle motion\nitems.\n1.14 Natural Selection: The Evolution of Pie Menus 119\npower-plant interfaces should stick to single level-two and four-item pie menus,\nwith using deeper menus with more items because it’s easier to recover from selecting\nExperienced users perceive single-level pie menus with two, four, and six items to\nIncreasing the number of items in a pie menu has an obvious detrimental effect\nEight and 12 items are especially easy to use, because the directions\nadd an extra item to 11-, 7-, and even 3-item menus, just to make them nice and even.\nWhen designing nested pie menus, the depth versus breadth trade-off seems to be\nbe arranged: shallow menus with many items, or deep menus with few items.\nmenus and submenus aren't arranged to take advantage of the pie menu directions,\nand pie menus with too many items are huge and unwieldy.\nmodifiable pie menus have been developed that the user could customize, and\nscrolling and paging pie menus can handle any numbers of items.\nPie menus can provide configuration languages, property sheets, and\ntheir own menus without programming.\nWe developed an open-source ActiveX pie menu component that can\nand to preview the pie menus (see Figure 1.14.1).\nActiveX pie menus support many properties and methods to control their appear-\nYou can customize pie menus by writing scripts that manipulate\nThe open-source JavaScript pie menus for Internet Explorer solve this problem\n1.14 Natural Selection: The Evolution of Pie Menus 121\nFIGURE 1.14.2 (A-I) Pie menus implemented using Dynamic HTML.\nThese menus a easy for Web page designers to use for static pages and for\nJavaScript pie menus are specified in XML, so it’s possible for people to manually\nThe JavaScript pie-menu component code is cleanly distinct\nfrom the Web page and XML pie-menu specification.\nreach into the pie menus and Web pages, and actually modify the Dynamic HTML\nUsing XML to specify pie menus has many advantages.\ndent of the implementation, so the same pie menus can be used across many different\nXML formats into pie menus by using standard XML-processing tools, like XSTL\ngenerate a Web page with ‘Punkemon’ pie menus, based on an XML database of trad-\nPunkemon Pie Menus!\nPunkemon Pie Menus!\nThe XML pie menu schema enables editors to automatically validate, construct,\nand edit pie menus.\nThe pie menu schema is on the CD-ROM as well as\ninterface experiment; it enables you to compare linear menus and pie menus.\nJavaScript pie menus also support the old-fashioned linear menu style, and they can\nalternates between pie menus and linear menus (as shown in Figure 1.14.5), and\n1.14 Natural Selection: The Evolution of Pie Menus 123\nDescraption: Pie Menu Center Backaround Color\ni <item\nPie Random 3036500 12166672 6%\nthe average selection time and error rate, so you can compare pie menus and linear\nmenus for yourself.\nPie menus work well with touchscreens on » handheld devices like the Palm Pilot and\n‘Finger Pies’ are easy enough to use with your finger, so no pen is\nvenient one-handed scrolling, dialing, panning maps, tilting pie menus, continuous\nIe featured p pie mer menus (see Figure 1.14.6) for\nStatic pie menus whose items don’t change can be carefully designed for ease of\ninto a convenient set of static pie menus.\nIcons in the pie menus are arranged in the\nPop-up pie menus let you quickly switch tools without moving back and forth\nYou soon learn to mouse-ahead through the pie\nThanks to Fitts’ Law, pie menus help you keep up with acceler-\nThe icons of the SimCity tool palette and pie menus are different sizes and shapes\n1.14 Natural Selection: The Evolution of Pie Menus",
      "keywords": [
        "Pie Menus",
        "Pie",
        "Menus",
        "JavaScript pie menus",
        "XML pie menu",
        "Pie Menus User",
        "items",
        "pie menu schema",
        "Static pie menus",
        "pie menu directions",
        "Punkemon Pie Menus",
        "Pie Menus Don",
        "linear menus",
        "Evaluating Pie Menus",
        "Pie Menu Bera"
      ],
      "concepts": [
        "pie",
        "pies",
        "item",
        "menus",
        "user",
        "xml",
        "directions",
        "directional",
        "direction",
        "tools"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 13,
          "title": "",
          "score": 0.658,
          "base_score": 0.658,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "pie",
          "menus",
          "pie menus",
          "pie menu",
          "menu"
        ],
        "semantic": [],
        "merged": [
          "pie",
          "menus",
          "pie menus",
          "pie menu",
          "menu"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.14134416340139416,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:24.921624+00:00"
      }
    },
    {
      "chapter_number": 13,
      "title": "Segment 13 (pages 129-137)",
      "start_page": 129,
      "end_page": 137,
      "summary": "The pie menus in The Sims use a combination of desaturation, darkening, and alpha\nthe pie menu and follows the cursor by looking at the currently selected item.\nway user interfaces are designed because of their new and unusual demands.\ntime games require quick, responsive, engaging user interfaces.\nDesigning a good user interface requires balancing many competing demands\nDon’t exclusively use pie menus when other\ndesign user interfaces with good Feng GUI, you can improve people’s lives and affect\n[JavaScript02] Hopkins, Don, “Open Source JavaScript Pie Menus,” available online\n[PieMenu02] Hopkins, Don, “Pie Menu Central,” available online at http://www\n[Punkemon02) Hopkins, Don, “Punkemon Pie Menus,” available online at http://\nLogging\nTo accomplish this end, an efficient logging system that is configurable at both\ntem without the need to remove logging calls that might be useful later.\nPolicies define a class interface that is compile-time bound as a template parameter.\nThe end user of a policy-based class can then\ncreate a class that conforms to the specified interface.\nparameter to configure an instance of a policy-based class without the need to change\nThis makes policies useful in creating robust libraries, a con-\ncept that will be used throughout the design of the logging system.\nboolean type for determining whether to perform various debugging operations.\nflag user.\nlogging.\nThe policy interface for\nThe first part of the interface defines the argument type used for initialization.\nThis is the type that will be passed to the flag’s constructor.\ntion that takes an argument of t_Type and converts it to a boolean value.\ndebug flag can be implemented to take an argument, convert it to boolean, and then\nThe interface for the assignment policy is identical to the initialization interface.\ntwo interfaces are separate in order to allow different types for initialization and\nto implement operator=, while the initialization policy is used to implement the\nThe primary use of this policy is to\nBy defining the type as a normal boolean,\nThe policy\ntypedef /*type*/ t_Boolean;\n1.15 Lightweight, Policy-Based Logging 131\nrequired later, there will be no effect on users of the public interface.\ntion policy for the debug flag that uses a Singleton configuration class.\nof t_Type, above, would become a string, and the conversion function would call the\nconfiguration Singleton class to convert the string to a boolean.\nThe log class brings all the components together with several policy interfaces to form\nFlag Policy\nEnabling and disabling of a log instance is based on the flag policy provided.\npolicy interface is:\nThe first two parts of the interface are type definitions for the constructor and\nThe flag policy must also support a constructor that takes the initializa-\npolicy differs from the others described previously because an instance of the flag is\ncreated within the log class, causing the need for a constructor.\nFinally, the flag policy\n* No support for user class types.\nbuffer issue by defining a buffer policy.\nDefining a Buffer Policy\nA buffer implementation, which determines how the log string is stored until being\ndispatched, is specified by the buffer policy:\n1.15 Lightweight, Policy-Based Logging ; 133\nstatic const string m ToString(const t_Type &i_buffer) ;\nThe first part of the interface is the buffer class type, an instance of which will be\ncreated with each log class.\nNote that the buffer type must support all instances of\noperator<< that are to be logged.\nThis allows the log class to pass on all operator<<\ncalls to the buffer policy with a template member function:\nt_LogImplementation& operator<<(t_Type i_value)\nother two buffer policy functions.\nThe standard string will then be passed to the dispatch policy (described later).\nThe most important performance issue to address is log instances that have been dis-\nFor disabled logs, a boolean test and a branch\nposes of logging, which would require the evaluation of all function arguments.\nplacing the boolean test before && and the logging function after, the entire logging\n#define LOG(type) (type) && (type)\nlog class that only calls the dispatch function when the internal flag is true:\nthe two boolean conversions in the LoG macro.\nOnce the buffer is full and operator bool is called on the log class, the string is\ndefined by the dispatch policy:\nThe first step in using the logging class is to create an instance of the class.",
      "keywords": [
        "EEE TOTO EOE",
        "Sims RSS ISSR",
        "NOE hESC ERC",
        "pie menus",
        "OOOO AOE",
        "ISSR ES TERESA",
        "MEIER NE NOE",
        "EEE TOTO",
        "TOTO EOE",
        "Living at Home",
        "RSS ISSR",
        "type",
        "pie",
        "menu",
        "log"
      ],
      "concepts": [
        "logging",
        "log",
        "logs",
        "types",
        "policy",
        "policies",
        "operation",
        "operations",
        "operator",
        "designed"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 12,
          "title": "",
          "score": 0.658,
          "base_score": 0.658,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 1,
          "title": "",
          "score": 0.539,
          "base_score": 0.389,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 14,
          "title": "",
          "score": 0.534,
          "base_score": 0.384,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 52,
          "title": "",
          "score": 0.516,
          "base_score": 0.366,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 30,
          "title": "",
          "score": 0.511,
          "base_score": 0.361,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "policy",
          "log",
          "logging",
          "flag",
          "boolean"
        ],
        "semantic": [],
        "merged": [
          "policy",
          "log",
          "logging",
          "flag",
          "boolean"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18573098813436476,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921687+00:00"
      }
    },
    {
      "chapter_number": 14,
      "title": "Segment 14 (pages 138-145)",
      "start_page": 138,
      "end_page": 145,
      "summary": "With the information presented in this gem, a logging library can be created that is\nJournaling Services\nTherefore, a solution could be to provide real-time information about what is\npresented to the user.\n1. 16 Journaling Services © 137\nThis way, journaling services can be\nOur journaling services are - built around three classes: the § Switch, the SwitchBox and\nthe Journal.\nThe switch is the primary interface that users interact with.\nstate and the associated output location wrapped in a Journal.\nEach Switch is owned\nSwitch A\nmySwitch = Journaling: :getSwitch(\"/Core/Loading/Trace\");\nIn the hierarchy, each SwitchBox is an internal node, and each Switch is a leaf.\nin this example, both “Core” and “Loading” are SwitchBoxes and “Trace” is a Switch.\nThe goal here is to have a Switch associated with a particular reporting facility for\nits reporting facilities with a simple query on the current state of its Switch.\nsystem, we considered the journaling services to be basic services.\nFirst, users must declare their own SwitchBox and Switch singleton objects in\nNote that macros are available for these tasks, but the generated code for a Switch is\nclass SwitchSample : public Switch\nStatic Switch * ourInstance;\nstatic Switch * staticFactory();\nstatic Switch * getInstance() {\n1.16 Journaling Services _ ; 139\nSwitch (OwnerType: :getInstance(),\nSwitch * SwitchSample::staticFactory() {\nSwitch * SwitchSample::ourInstance =\nDECLARE_SWITCH(SwitchSample, Root);\nIMPLEMENT_SWITCH(SwitchSample,\nvoid SwitchBox: :addSwitch(Switch * item) {\nThis could be useful to enable (or disable) a Switch for a system and\nalso provides a way to list and manage everything in the system.\nA class named Journaling implements many of these operations.\nJournaling: :disableAll();\nstd::cout << Journaling: : getRoot();\nEach SwitchBox supplies two singly linked lists that use forward iterators.\nfor Switch and the second one is for SwitchBox children.\nThus, in the previous example, if a Switch named “Trace” is added to the\nvoid Switch::setState(bool state, bool recursive) {\nvoid SwitchBox: :propagateState(Switch * source) {\nvoid SwitchBox::setState(Switch * source) {\nSwitch: :Iterator i = getSwitchesBegin();\nSwitch * leaf = &(*i+t+);\nto efficiently use the system and control the flow of information.\nThe supplied code sample also implements the Journal propagation and some\nthe system’s Switch states in real-time.\n1.16 Journaling Services 141\nThe Journal Interface\nAn output location is associated with a Switch instance using the Journal abstraction.\nbuffering, and only two virtual methods need to be implemented.\nclass DebuggerStreamBuf : public std::streambuf\nThe journal provides two additional virtual functions used to delimit the begin-\nFor the debugger journal, only the end is used,\nSo, to implement this journal, the\nclass DebuggerJournal : public Journal\nMore-elaborate journals can be built using this method.\nsample, we added a journal that uses a Win32 message box.\njournals.\nHowever, since the Switch class only contains a single Jour-\nnal reference, a new type of Journal that can handle this case needs to be designed.\ninstances of Journal that could be kept in a std: : vector.",
      "keywords": [
        "Switch",
        "Journaling Services",
        "system",
        "Journaling",
        "SwitchBox",
        "myBuf",
        "Policy-Based Logging",
        "Services",
        "Static Switch",
        "logging library",
        "information",
        "trace",
        "std",
        "code",
        "Journaling Services Eric"
      ],
      "concepts": [
        "switch",
        "journal",
        "reporting",
        "virtual",
        "debugging",
        "provided",
        "provide",
        "std",
        "formatted",
        "state"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 13,
          "title": "",
          "score": 0.534,
          "base_score": 0.384,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 30,
          "title": "",
          "score": 0.451,
          "base_score": 0.301,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 2,
          "title": "",
          "score": 0.402,
          "base_score": 0.252,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 52,
          "title": "",
          "score": 0.385,
          "base_score": 0.235,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 1,
          "title": "",
          "score": 0.346,
          "base_score": 0.196,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "switch",
          "journaling",
          "journal",
          "services",
          "journaling services"
        ],
        "semantic": [],
        "merged": [
          "switch",
          "journaling",
          "journal",
          "services",
          "journaling services"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.12287847976059631,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921734+00:00"
      }
    },
    {
      "chapter_number": 15,
      "title": "Segment 15 (pages 146-155)",
      "start_page": 146,
      "end_page": 155,
      "summary": "of real-time information, along with some basic tools to report it.\nProfiling\n90% of its time in 10% of the code.” Profiling is an invaluable tool for finding that\nthen processed to generate profiling data.\nSampling profilers can often tell you exactly\nin which line of code most of the time is being spent.\nMany commercial profilers\nThe other profiling method that is commonly used is to explicitly time blocks of\nIt is useful to see how the profiling data changes as\nAlso, these profiling samples will\nFor example, one might log how much time the code\nof profiling is that it only gives a general idea of where the code-processing time is\ncally have to use a sampling profiler or temporarily add more timing measurements to\nIdeally, we would like to have the best of both worlds—real-time profiling with as\nmuch detail as a sampling profiler.\n1.17 Real-Time Hierarchical Profiling ; 147\nattaining the resolution of a sampling profiler, can efficiently support thousands of\nprofiling samples that are logically and hierarchically organized.\nA ‘profile tree’ is con-\nThe Profile Tree\nThe profile tree is an V-ary tree made of profile nodes.\nmined by the placement of profiling macros in the application’s code.\nEach profile node corresponds to a single explicit timing sample of a block of\nEach node tracks the total amount of time spent within that block of code and\nthe total number of times that code has been executed.\nWhenever a new profiling call is made, a new child node is added to or reused in the\nRenegade had a total of over 1,000 profile nodes(see\nTo use this profiling system, PROFILE macros must be placed at key points in the code.\nAs will be described later, placing a PROFILE macro in the code will cause a profile\nPROFILE (\"My_Function\")\nIt can be helpful to break large routines into several independent profile samples.\neach with their own PROFILE macro.\nPROFILE(\"BigFunction Part 1\")\nFIGURE 1.17.1 his is a screenshot the real-time hierarchical profiler running inside of Command\ntime.\nPROFILE(\"BigFunction Part 2\")\nIt can also be useful to ‘flatten’ the profile structure of a member function in a\nwill be combined into a single profile sample, even when called from other derived\nclasses (assuming they use this profiling strategy).\nPROFILE(\"CarPhysics::Timestep\") ;\nBrowsing the Profiling Data\nThis profiling system generates a lot of data, so the user must have a way to navigate\ndown a bottleneck in real-time by walking up and down the profile tree, and focus on\nFor example, a representative profile sample\nTable 1.17.1 Profile Data for Main Loop\nTable 1.17.2 Profile Data for Render\nSince Render_Game takes a large portion of this node’s time, the user could then\nment of what the code is doing at that time.\nWhen the profile system is reset, the tree\nis not actually destroyed; only the timing data contained in the nodes are zeroed out.\nprofiling sample, you can very accurately compute the amount of time elapsed.\nOur profile nodes accumulate the amount of time in a float-\nThis is a small C++ class whose only task is to call the start_Profile() method of\nCProfileManager in its constructor and the Stop_Profile() method in its destructor.\nThis automates the task of starting and stopping a profile sample during the scope of\ncreate a CProfileSample object and to easily remove profiling code from release builds.\n‘ cProfileManager: :Start_Profile(name) ;\n#define PROFILE(name) CProfileSample _ profile(name)\nCurrentNode pointer into the profile tree that corresponds to the scope of the cur-\nIt also contains methods for accessing the profile tree for dis-\n1.17 Real-Time Hierarchical Profiling 151\nThe Start_Profile() method is used to start a profile sample.\ning for a particular profile sample.\nvoid CProfileManager: :Start_Profile(const char * name)\nThe Stop_Profile() method is used to end a profile sample.\ncall the Return() method on the current node to complete and record the timing.\nSince the profile manager has maintained the current node being sampled, no search-\nvoid CProfileManager::Stop Profile( void )\nThe remaining methods in the profile manager are either accessors or perform\nber of calls per frame for any profile sample.\nator() methods provide and destroy an iterator that is used to access the profile tree.\nThe CProfileNode is a C++ class that is private to the profiling system; it stores the\ntotal time spent in a block of code and the number of calls of that block of code.\nWhen the CPU is in the scope of a node, the node also stores the starting time.\nTo start a profiling sample, the profile manager calls the Cal1()method on the\nAt the end of a profiling sample, the Return() method is called.\nThis function also returns whether or not the code is recursing, so the profile\nProfile_Get_Ticks (&time) ;\nThis object provides an easy way to browse the profile tree.\nWith the ability to hierarchically profile code in real-time and sample thousands of\nRRR eer NR ARB 2 a sR eS EIST ee",
      "keywords": [
        "SOS TRINA TERRE",
        "TRINA TERRE NANA",
        "profile",
        "SHERRATT RRR AAA",
        "AAA NA ROSIE",
        "ROSIE RE ONO",
        "ONO GS SBOE",
        "SBOE R ANIONS",
        "ANIONS S SOS",
        "SOS TRINA",
        "TRINA TERRE",
        "TERRE NANA",
        "node",
        "time",
        "Profile Tree"
      ],
      "concepts": [
        "profiling",
        "profile",
        "times",
        "timing",
        "void",
        "nodes",
        "journal",
        "leaf",
        "method",
        "code"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 1,
          "title": "",
          "score": 0.34,
          "base_score": 0.34,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 14,
          "title": "",
          "score": 0.316,
          "base_score": 0.316,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 28,
          "title": "",
          "score": 0.316,
          "base_score": 0.316,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 41,
          "title": "",
          "score": 0.313,
          "base_score": 0.313,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "profile",
          "profiling",
          "profile tree",
          "tree",
          "sample"
        ],
        "semantic": [],
        "merged": [
          "profile",
          "profiling",
          "profile tree",
          "tree",
          "sample"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1613745011202907,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:24.921776+00:00"
      }
    },
    {
      "chapter_number": 16,
      "title": "Segment 16 (pages 156-165)",
      "start_page": 156,
      "end_page": 165,
      "summary": "n this gem, three utility functions are presented for computing values associated\nany 32-bit input value, in contrast to their floating-point alternatives.\nexpressions using 32-bit floating-point arithmetic on an Intel processor showed the\ndevoid of floating-point functionality, but a mechanism for computing the integral\nThey provide correct results over the entire 32-bit input range and are also more effi-\nBit Masks and Random Number Generation\nThe third utility function provided in this gem, bitmask(n), computes a mask in\nOne use for bitmask() is in generating uniformly-distributed random integers\nrand()generates uniformly-distributed random integers in the range 0 to 32767, but\nwe need a sequence of random numbers in the range [0, 2].\nuse the modulus operator to map the source range to the target range:\nsource range of [0, 32767], values of randomNum are not evenly distributed.\nFor instance, if we used this technique to generate numbers in the range [0, 32766},\nOne way to get evenly distributed results is to generate random numbers and\ngral divisor in the range of rand() to get to an intermediate range of random numbers\nSince most random number generators have a range that is a power of two, we\nrandom numbers over an arbitrary range:\n2. 1 Fast Base-2 Functions for Logarithms anc and Random Number Generation — 159\ndo { n = rand() & mask; } while (n >= range);\nreturn values to 32 or 33, depending on the function.\nbitmask() returns a bit mask ranging from 0 to OxFFFFFFFE\nwhere approximation at points of intersections can cause the algorithms to fail.\nniques are offered for representing these intersection points without approximation.\nproblem arises when an algorithm needs to reuse the results of calculations with\nWhen we try to represent fractional values as floating-point or fixed-point num-\nbers, we often introduce round-off errors that can affect the results of our algorithms.\nWe can’t represent 1/3 exactly using a fixed-point or floating-point number of finite\n(CSG) and points-of-visibility path-finding.\nApproximation at these intersections can lead to nonconvex geometry (see Figure\nFIGURE 2.2.2 Approximation results in a nonconvex face.\n[Young01] demonstrates how silhouette regions can be used to optimize points-of-\nFigure 2.2.3 shows how approximation at an intersection can cause path-finding\nThe boundary of a silhouette region intersects with another line, which might\nthe intersection means that our source point is incorrectly determined to be outside of\nthe silhouette region, so a connection to the associated point of visibility is not gener-\nThe line from the source point to the target point just clips the edge of the\nTarget point\nFIGURE 2.2.3 Path-finding fails because the source point is incorrectly determined to be\nOne solution to this problem is to treat the lines bounding our silhouette regions\nTo test if the source point is in a given region, we test inside of each\nby detecting which edges are traversed as a point is moved.\nour traversal an intersection is on.\nhouette region because the intersection is to the right of the line of traversal.\nFIGURE 2.2.4 Traversal into a silhouette region.\nFloating-point representation only gives us greater precision near zero.\nthe number range, we actually get less precision than with an integer representation\nFloating-point representation\nFIGURE 2.2.5 A floating-point grid.\nIntersection of 2D Lines\nConsider two infinite lines in two dimensions, represented with start points and axes\nrepresent the intersection I as a fractional distance along the axis of one of the lines\nFIGURE 2.2.6 Representing the point of intersection as a vector fraction.\nproducts with N,, a vector normal to the axis of the second line (Equation 2.2.2 and\nintersection of a 3D Line with a Plane\nTesting Side of Line for an Intersection\n‘To determine if a point P is on the right of an infinite line defined by start S and axis\nTo apply this to a point represented as a vector fraction, we simply substitute a\nimplement the traversal we require through path-finding regions.\ntor fraction, as shown in Equation 2.2.7), we transform the points to a common\nFigure 2.2.7 depicts the traversal problem.\nneed to determine the side of our traversal line (S, A3) for an intersection of region\nline S, A, from right to left, then we can compare fractional distances for intersections\nFIGURE 2.2.7 Determining order of intersection.",
      "keywords": [
        "Vector Fractions",
        "range",
        "intersection",
        "point",
        "Random Number Generation",
        "target range",
        "Random Number",
        "Vector",
        "Random",
        "line",
        "source point",
        "Number",
        "problem",
        "Equation",
        "traversal"
      ],
      "concepts": [
        "points",
        "figures",
        "range",
        "ranging",
        "fractions",
        "fractional",
        "fraction",
        "problem",
        "line",
        "algorithm"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 17,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 18,
          "title": "",
          "score": 0.565,
          "base_score": 0.415,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 64,
          "title": "",
          "score": 0.512,
          "base_score": 0.512,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 19,
          "title": "",
          "score": 0.437,
          "base_score": 0.437,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 3,
          "title": "",
          "score": 0.354,
          "base_score": 0.354,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "intersection",
          "point",
          "range",
          "random",
          "floating point"
        ],
        "semantic": [],
        "merged": [
          "intersection",
          "point",
          "range",
          "random",
          "floating point"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19719547091639536,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921828+00:00"
      }
    },
    {
      "chapter_number": 17,
      "title": "Segment 17 (pages 166-173)",
      "start_page": 166,
      "end_page": 173,
      "summary": "ever, we have to think carefully about number ranges to avoid the possibility of over-\nLet us assume that the coordinates of all points in our geometry are in the range [0, 7].\nThe range of vectors formed by subtraction of points will be from [-r, 7].\nof these vectors and therefore will have a range [—2r?, 2r?] for the two-dimensional\nFor the three-dimensional case, the range is [-3r?, 3r7] for dot products of\ngives us a range [—6r', 6r'] for each side of the inequality.\nFitting the Ranges into Integer Data Types\nSolving and rounding to integer coordinates yields a value for r.\nPoints and vectors can be stored in 32 bits, the results of dot products in 64 bits,\nputations are required, a different set of ranges and, therefore, a different set of data\naging the different ranges.\nFor example, points and vectors could be implemented as\nwe can use the compiler to check that the correct types are used for a computation.\nformance can be limited by only checking ranges when data types are constructed\nfrom other data types that do not have a defined range.\nAt compile time, it might not be possible to know what ranges will be required\nIn this case, or simply as an alternative to working out ranges\nFor platforms with a register size of 64 bits, working with big integers need not be a\nFor these platforms, multiplication of two 64-bit values will be performed\nFor platforms with a 32-bit register size, multiplication of 64-bit integers is a lit-\nintegers is too costly, then an alternative is to reduce the ranges so that only 32-bit\nmultiplies must be performed with 128-bit sources.\nplying numbers this large because of the resulting performance hit.\ntions for Equation 2.2.6 can be performed with 64-bit sources.\nAlternatively, we can use Equation 2.2.9 with six multiplies that all can be\nperformed with a 64-bit source.\nIf you are a gambler, you can use fewer bits than are theoretically required for inter-\nVector fractions based on a dynamic integer class can result in some very large\nspecial-case checks for the results of an approximation.\ntime to go back to basics and review implementations of the mathematical functions\nBefore we look at implementing functions, we need a standard set of tools for mea-\nany error.\nAn error of 3 is acceptable if the function should return 38,000, but an\nerror of 3 would be catastrophic if the function should return 0.008.\nneed to graph the relative error.\nWith functions like sin() and cos(), where the range is\nwider range, and relative error will be an important metric of success.\nfloat a = 2.0f*sin(PI*N);\nfloat c = 1.0f;\nFIGURE 2.3.1 Resonant filter sine and cosine—eight iterations over 37/2.\nclose attention to a (the step size) and to the initial values of c and s.\nyou cannot rely on samples at fractions of a cycle returning accurate values.\nThe end points of this function miss the correct values of 1.0 and 0.0 by quite\nupdates the two previous values (i.e., it’s a second order filter).\na series of sine and cosine values in the series x, = sin(a + *b) for integer values of n:\nfloat c2 = cos(a + b);\nfloat c1 = cos({a + 2*b);\nFIGURE 2.3.2 Resonant filter quarter-circle test, seven iterations over 1/2.\nfloat s,c;\noutput_cosine = c;\nBecause the values of s and c are constructed from the two previous samples, the algo-\nfloat b = 2.0f*PI/N;\nFIGURE 2.3.3 Goertzels algorithm: sine and cosine, eight iterations over 3m/2.\npasses the test well, producing more-accurate results than the resonant filter for fractions of\nFIGURE 2.3.4 Goertzels quarter-circle test, seven iterations over 1/2.",
      "keywords": [
        "range",
        "Vector Fractions",
        "error",
        "Equation",
        "dot products",
        "Resonant Filter",
        "Data Types",
        "float",
        "functions",
        "Vector",
        "Types",
        "Sine",
        "approximation",
        "Geometry",
        "Cosine"
      ],
      "concepts": [
        "range",
        "value",
        "bits",
        "error",
        "points",
        "integer",
        "different",
        "mathematics",
        "mathematical",
        "implemented"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 16,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 18,
          "title": "",
          "score": 0.473,
          "base_score": 0.323,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 29,
          "title": "",
          "score": 0.429,
          "base_score": 0.429,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 19,
          "title": "",
          "score": 0.362,
          "base_score": 0.362,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "",
          "score": 0.344,
          "base_score": 0.344,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "ranges",
          "range",
          "error",
          "float",
          "bit"
        ],
        "semantic": [],
        "merged": [
          "ranges",
          "range",
          "error",
          "float",
          "bit"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18838977892531317,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921873+00:00"
      }
    },
    {
      "chapter_number": 18,
      "title": "Segment 18 (pages 174-181)",
      "start_page": 174,
      "end_page": 181,
      "summary": "and use the input value to the function to hash into the table, look up the two closest\nsin(x) ~ table[i] + A * (cable +1]- table|\nUsing a table poses the question: How many samples do we need to get N digits\nThe table-based sine with 16 samples is shown in Figure 2.3.5, and the\nThe largest error (or maximal error) occurs where the curvature of the function is\nimal error where the step size is Ax = x, , , — x,, can be shown to be:\nFIGURE 2.3.6 Absolute error of 16 sample, linearly interpolated sine table.\nerror will be 1 — cos(m/16) = 0.0192147, giving us just under two decimal places of\nhow many entries will we need in the table?\nple, to approximate sin(x) to 1% error we only need 23 entries:\njust 45° of samples, meaning that we only need a table of 23/8 = 3 entries.\nTable 2.3.2 for some example values.\nTable 2.3.2 Size of Table Needed To Approximate Sin(X) to a Given Level of Accuracy\nproperly implement the sine function, we need to take any input angle and find out\ny = x -— (float)k * C;\nfloat table _sin(float x) {\nconst float CONVERT = (2.0f * TABLE_SIZE) / PI;\nfloat y = x — float(k)*PI_OVER_TWO;\ncase 0: return sin_table(index);\ncase 1: return sin_table(TABLE_SIZE-index) ;\ncase 2: return -sin_table(TABLE_SIZE-index) ;\ndefault: return -sin_table(index);\ns = sin_table(y);\nc = cos_table(y);\nYou will find that most libraries use the range reduction, approximation, and recon-\nsin(x) = x — ~ 4% _~% 4* _ (2.3.9)\nx-- —_\nsin(x)\ntion error.\nIf you graph the absolute error of this function (shown in Figure 2.3.8),\nsion, but the error increases almost exponentially away from x = 0.\nFIGURE 2.3.8 Absolute error of Taylor series over |-1t, 71].\nWe need good accuracy across the whole range, and we\nIf you reduce the range of the sine function\nthat we're trying to approximate, then, yes, we reduce the error because there’s less to\nuse a Taylor series as a technique for generating fast polynomial approximations,\nsome of this error and spread it out across the whole range.\nmal error,’ and it’s called the minimax polynomial.\n* Fora power N approximation, the error curve will change sign NV + 1 times.\n° The error curve will approach the maximal error V+ 2 times.\nsin(x) — a + bx, + cx?\n¢ the range over which the approximation is to be done,\nLet’s find a seventh-order polynomial approximation to sin(x) over the range [0,\nsin(x) about x = 0, just to get a feel for what the polynomial should look like.\nsin(x) = x — 0.166666667x°+0.00833333333x° — 0.000198412698x’ (2.3.12)\nto minimize the error, leading to some very small, odd-looking coefficients and many\nsin(x) = x + x° P(x’) (2.3.13)\nsin(x) — x — x° P(x’)\n: < error (2.3.14)\nsin(x)\nsin(x) _ 4+ — P(x?)\nsin(x)\nWe want the result in terms of every second power, so we substitute y = x7:\nthese through the minimax function, looking for a second-order result gives us:\nsin(x) = x — 0.166666546x* + 0.00833216076x° — 0.000195152832x” (2.3.21)\nIn order to reconstruct these coefficients as single precision floats, we need only\nabsolute and relative error curves over our range with a maximum absolute error of\n2.59e-9 at x = 0.785.",
      "keywords": [
        "error",
        "sin",
        "range",
        "function",
        "Trigonometric Functions",
        "Solutions As clock",
        "float",
        "absolute error",
        "range reduction",
        "polynomial",
        "Functions",
        "approximation",
        "sine",
        "Series",
        "cos"
      ],
      "concepts": [
        "functions",
        "function",
        "sin",
        "floats",
        "tables",
        "value",
        "polynomials",
        "number",
        "samples",
        "case"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 19,
          "title": "",
          "score": 0.638,
          "base_score": 0.638,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 16,
          "title": "",
          "score": 0.565,
          "base_score": 0.415,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 17,
          "title": "",
          "score": 0.473,
          "base_score": 0.323,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 36,
          "title": "",
          "score": 0.318,
          "base_score": 0.318,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "error",
          "sin",
          "table",
          "range",
          "sin_table"
        ],
        "semantic": [],
        "merged": [
          "error",
          "sin",
          "table",
          "range",
          "sin_table"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1533969529031911,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.921915+00:00"
      }
    },
    {
      "chapter_number": 19,
      "title": "Segment 19 (pages 182-189)",
      "start_page": 182,
      "end_page": 189,
      "summary": "2.3 More Approximations to Trigonometric Functions 183\nbering that all floating-point values are rational numbers, we can take the second\nsin(x)\nover the range [0, 7/4] with a maximal error of 3.39e-8 at x = 0.557, but with better\nThe absolute and relative error of float-optimized approximation over [0, 1/4] are\nFIGURE 2.3.10 Absolute and relative error of float-optimized approximation over\nHow do we choose the degree of polynomial that we need to approximate a function to\nWe can easily calculate how many bits of accuracy an approximation\nTable 2.3.3 Number of Significant Bits of Accuracy Versus Degree of Minimax\nPolynomial Approximating the Range [0, 1]\nsin(x) 7.8 12.7 16.1 21.6 25.5 31.3 35.7\nIn(1 + x) 8.2 11.1 14.0 16.8 19.6 22.3 25.0\n2. 3 More ‘Approximations to  Trigonometric Functions 185\nFirstly, it shows how well we can use polynomials to approximate exp(x) and\nsin(x), as each additional power gives us pretty much four bits of accuracy.\nbit single precision floating-point value, we will only need a sixth- or seventh-power\nThe table also shows how badly Vx is approximated by polynomials;\nlast bit of accuracy out of every floating-point number.\nFunction in IEEE Floating Point Arithmetic,” ACM Transactions on Mathemat-\nFunction in IEEE Floating Point Arithmetic,” ACM Transactions on Mathemati-\nQuaternion Compression\nmark@muckyfoot.com\nTypically, the rotation data is stored as quaternions.\npropose and compare methods for compressing a four-float quaternion into a 32-bit\nQuaternions\nA quaternion Q(x, y, z, w) can be used to represent a rotation matrix.\nquaternion for the rotation would be:\nIt is important to note that quaternion Q(x, y z, w) and quaternion Q*(-x, -y, -z,\nAlso, note that all the quaternions we consider\nThis means that for every quaternion Q(x, y, z, w):\nIn fact, none of the three smallest elements of a quaternion can have\ntwo elements of the quaternion have the same value and the other two are zero, as in\nSince we can store a direction vector (x, y, 2) using just two angles, yaw and pitch,\nwe can also store a quaternion as (yaw, pitch, w).\nNote that storing (x, y, z) with yaw\nquaternion.\nThe trouble with storing a direction vector as yaw and pitch is that the encoded\npole, we do not want to store a yaw.\nthe vector lies along the equator, we want to store many yaw values.\nacross the surface of the sphere, store (x, y, 2) or (yaw, pitch) for each point in a lookup\ntable, then store an 7-bit index into that table.\nFirst of all, we store the signs of x, y, and z separately so that we\nNow, if we let pitch be the row of e, and if we let yaw be the column of e, we can\n2.4 Quaternion Compression 189\nThe smallest three method neatly stores a quaternion into 32 bits.\nto store the index of the implied (largest) element, leaving 10 bits for each of the\nSince we know each of the stored elements lie in the range\nWe need an additional 3 bits to store the sign of x, »,\nand z, leaving 18 bits to store yaw and pitch.\nIf we are encoding yaw and pitch as a sin-\ngle number, then we can store 2'® values in 512 rows.\nbits for yaw and 9 bits for pitch.\ninterpolate these values to [0, 511] and store them as integers.\nConverting from yaw and pitch to a vector requires sine and cosine calculations\nfor both yaw and pitch, so we recommend using a fast polynomial approximation\nTo quantify the performance of each compression method, we used the quaternions\nWe compressed and decompressed each quaternion Q to get\nThe approximation method used\nMaximum (yaw, pitch) and w\n(yaw, pitch,w)\nquaternion data.",
      "keywords": [
        "Quaternion",
        "yaw",
        "store",
        "Functions",
        "bits",
        "pitch",
        "Floating Point Arithmetic",
        "error",
        "accuracy",
        "approximation",
        "Ping Tak Peter",
        "Elementary Functions",
        "Method",
        "sin",
        "compression method"
      ],
      "concepts": [
        "functions",
        "function",
        "value",
        "point",
        "approximations",
        "approximation",
        "approximate",
        "approximating",
        "accuracy",
        "numbers"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 18,
          "title": "",
          "score": 0.638,
          "base_score": 0.638,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 16,
          "title": "",
          "score": 0.437,
          "base_score": 0.437,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 17,
          "title": "",
          "score": 0.362,
          "base_score": 0.362,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 7,
          "title": "",
          "score": 0.326,
          "base_score": 0.326,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "yaw",
          "quaternion",
          "pitch",
          "yaw pitch",
          "bits"
        ],
        "semantic": [],
        "merged": [
          "yaw",
          "quaternion",
          "pitch",
          "yaw pitch",
          "bits"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.153250076906033,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:24.921960+00:00"
      }
    },
    {
      "chapter_number": 20,
      "title": "Segment 20 (pages 190-197)",
      "start_page": 190,
      "end_page": 197,
      "summary": "Bones Hierarchy\nForward kinematics allows us to simply adjust bone angles like a jointed, wooden\nbones so that an end bone attempts to align with a movable ‘effector.’ By providing\nstrate how to constrain the angular solutions based on the physical limits of the joints.\ntransform, we define a bone length, which is really a displacement along that trans-\nBy default, the origin of all child bones is positioned at the point\non the end of the parent bone.\nWe will refer to the space that the root bone moves in as the “world space,”\nAt each transform in the bone hierarchy, that transform, relative to its parent,\nThe values are similar to the angle/axis format, where a rotation of (2cos!\nure mode.”) The motion of the bones away from reference is used to deform the mesh\nlated motion data supply a bone-indexed set of world-aligned transforms at each\nAfter the parent-relative quaternion values have been determined for a frame,\nthe bone graph is traversed, and the world transforms are generated through simple\nThe IK system attempts to rotate a chain of participating bones so that the tip of the\nend bone is located at a movable control point, called an effector.\nquaternions for all the rotational operations.\nThe bone is rotated\nNext, the parent of that bone is\nthe solution by having some bones only rotate a fraction of the desired change for\naddressed bone is rotated to align the dotted line with the desired dashed line.\neffector position can cause a sudden change in the solution.\nTo do this, we take the world-based quaternion of the previous frame and compare\nthe new quaternion solution.\nWe convert the delta to angle-axis form and limit the\nAlthough our rotations are computed using quaternions, the limiting angles are usu-\nally supplied from the artist using Euler angles, an alternative angular representation\nFor example, Euler angles could represent the\ncan occur if one of the angles is near 90°, since two of the rotation axes can align and\nProgrammers would probably expect the angular limits of a particular bone to be\nworld-aligned axes to define the angles about which these limits are to be applied.\nThis means that if the world-relative reference transform of a parent bone is not\nthat the constrained bones in the reference pose (their ‘figure mode’) should be coin-\nlimits about world-aligned axes to the local axes of the bone.\n‘Kine’ Each Bone, and Apply the Constraints\nThis pseudo-code will describe the entire process of applying IK to one specific bone.\nEach bone contains a list of the effector solutions to which it participates.\neach bone that has an effector, there are usually several bones that participate in the\nsolution to draw that one bone toward the effector.\nily mean that the specific bone is trying to reach the effector, but rather it may be\nhelping a descendent bone meet the effector.\nour code, it is evenly divided, so if a bone has an effection to two effectors, each will\napplied once for each bone’s effection.\nVector3 effected = current end of effected bone in world space\nbone\ncompute a quaternion delta that would rotate current to desired\nif velocity-limiting is on, limit change to the max per-frame angle\nrotate the bone by the quaternion delta\nQuaternion global_rot = parent's world rotation * this bone's local\nrotation (this is the bone's current world transform)\nQuaternion parent_delta = parent's reference rotation * inverse of\nparent's current world rotation (this is how much the parent has\nparent reference world rotation (this is the bone rotation in world-\naligned axes adjusted for parent rotation)\nThe next block does the actual limiting of angles.\nA bias of zero means the bone is currently being limited by the minimum angle,\none indicates it is being limited by the maximum angle, and two indicates no preference.\nif active and not limited, skip this axis (any angle is fine)\nif not active, set the angle to the reference value; skip to next\nX,Z axes only: if Y angle is near 90 degrees, set angle to last\nif current angle is within limits, reset bias to 2 (no preference),\nif maxdiff<mindiff, set angle to max and bias to 1\nQuaternion constrained = inverse of parent reference world rotation\n* global_delta * parent reference world rotation\nset bone rotation to constrained\nrecompute cached current world transform for this bone and all\nIn our example, we use hard stops to limit the angles.",
      "keywords": [
        "bone",
        "RRS USE RAR",
        "ons pisncgronice Mot",
        "angle",
        "Quaternion",
        "effector",
        "Quaternion Compression",
        "Charles River Media",
        "parent",
        "world",
        "solution",
        "Game Programming Gems",
        "pisncgronice Mot",
        "parent reference world",
        "Euler Angles"
      ],
      "concepts": [
        "bones",
        "rotations",
        "rotational",
        "rotate",
        "rotated",
        "quaternion",
        "angle",
        "solutions",
        "solution",
        "limits"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 39,
          "title": "",
          "score": 0.699,
          "base_score": 0.549,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 40,
          "title": "",
          "score": 0.618,
          "base_score": 0.468,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 38,
          "title": "",
          "score": 0.596,
          "base_score": 0.446,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "",
          "score": 0.501,
          "base_score": 0.351,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "",
          "score": 0.483,
          "base_score": 0.333,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "bone",
          "parent",
          "rotation",
          "quaternion",
          "effector"
        ],
        "semantic": [],
        "merged": [
          "bone",
          "parent",
          "rotation",
          "quaternion",
          "effector"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19262243729099013,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922013+00:00"
      }
    },
    {
      "chapter_number": 21,
      "title": "Segment 21 (pages 198-207)",
      "start_page": 198,
      "end_page": 207,
      "summary": "tions for modeling air and water flow, heat distribution, building stresses and strains,\nheld in cells are the air pressure, temperature, amount of water, which direction the\nwater or air is flowing in, and so on.\nEach game turn, every cell is processed, and it compares itself with its neighbor-\ning cells.\nDifferences between them result in changes to the state of the cell and/or its\ncell is full or not—and some extremely simple rules for changing state according to\nthe state of neighboring cells.\ncells.\nIf we run the rules quickly enough on a sufficient number of cells, water will\n‘neighbor’ cells:\nsimpler, and there is only one type of neighbor cell, rather than three.\nit is far easier to only consider as neighbors the six cells that share a face with the cen-\ntral cell.\nFirst, choose the physical size of a CA cell.\nAny bigger, and a CA cell of air will not fit\nferent scales of games will naturally require a different size of CA cell; however,\nscale of half-meter cube cells in its examples.\nModeling them conventionally by using many small cells, and\nmarking those occupied by the wall as solid, would require using cells of no more\nmodel the faces between the cells as entities, as well as modeling the cells themselves.\nbetween two cells (e.g., walls, floorboards, short grass, or doors).\ntiny cells.\nonly a few centimeters thick, we expand the neighboring cells to take up the extra\nEven though the cells are no longer aligned on a grid, the CA code itself does\ndrawing a cell with one of these effects, the renderer needs to check each neighboring\ncell to see if its polygonal shape is smaller than the usual half-meter cube.\nthe centers of the cells are each half a meter away from each other, the total apparent\nBecause the CA only knows about cells, not polygons, the scenery must be con-\nThese cells are sim-\ncontinuous wall of CA cells, water will not flow through and break the illusion.\nIn this system, rather than simply being cells of inert material, scenery is modeled\nAs the cells\nmodeled with CA change their state according to the physical rules of the CA, the\nstoring half-meter cells for even a modest-size level consumes a huge amount of mem-\nmon operation in a CA is “find the cell next to me,” so it makes sense to optimize for\nis no neighboring cell in the octree, it is assumed that the neighboring cell is air at\nWhen an air cell returns to within a certain tol-\nThe octree holding CA cells can also be useful as a general-purpose octree.\nbehavior, since all CA cells are aligned to regular intervals and have a fixed size.\nfor ( neigh = each neighbor cell )\nfloat DPress = cell->Pressure — neigh->Pressure;\nfloat Flow = cell->Material->Flow * DPress;\ncell->Pressure / 6.0f,\ncell->NewPressure -= Flow;\nThe division by six is because there are six neighbor cells.\nConventionally, once all the cells have been processed in this way, the NewPres-\nWhen subsequently processing that cell, the turn number is checked; and\nif ( cell->Turn != CurrentTurn )\ncell->Turn = CurrentTurn;\ncell->Pressure = cell->NewPressure;\nfor ({ neigh = each neighbor cell )\nThis simple model works well for uniform redistribution of air pressure.\nFirst, find the nearest CA cell to\nSecond, add a large number to the cell’s pressure.\nexpands to fill the available space with cells changing pressure to do so, while water\nmass of water in the cell, above what the cell’s volume should be able to hold.\ntice, the amount of compression needed is tiny—allowing just 1% more water per cell\nIn a static body of water whose cells can normally\ncontain 1.00 liter of water each, the cells at the top will contain 1.00 liter, the ones\nif ( neighbor cell is above this one )\nif ( ( cell->Mass < material->MaxMass ) ||\nFlow = cell->Mass - material->MaxMass;\nFlow = cell->Mass — neigh->Mass\nelse if ( neighbor cell is below this one )\nif ( ( cell->Mass < material->MaxMass ) ||\nFlow = cell->Mass — neigh->Mass\nFlow = ( cell->Mass — neigh->Mass ) * 0.5f;\nThe two cases of code for the water model deal with different situations.\ncase is where one of the two cells is not full of water—such as on the surface of a body\nis simple—water flows downward to fill the lower cell of the two to the value Max -\nMass—the mass of water that can be contained by a single cell’s volume.\nThe second case is where both cells are full of water, or perhaps a bit over-full,\nthe upper cell has exactly MaxCompress more water than the lower cell.\nSo far the air and water models have ignored a fairly important property of any liquid\ntwo cells and used that to move mass around.\nbetween cells; it does not rigidly set it.\nmodeling waves, flowing rivers, and air currents.\nAlthough rivers can flow in models\nTo model momentum or speed of flow during each processing step, the difference\nthe masses of the cells directly, the pressure gradient only alters the flow between the\ncells.\nThe flow then changes the masses in the cells.\nvector as being the flow through the center of the cell.\nitive model—the flow and the mass of the cell are both measured at its center.\nneighboring cells, which in turn determines how mass flows from one neighboring\ncell to the other.\nNote the slightly odd result that, for a particular cell, the flow stored\nin it is not affected by the mass in the cell itself, but only by its neighbors.\nchange the mass of the cell, but only the mass of its neighbors’ cells.\nThus, the flow vector F stored at cell (x, y, z) is interpreted as mean-\ning that F, is the flow from cell (x, y, z) to cell (x + 1, y, z); F,is the flow from cell\nflow is in rivers, in most ‘human-size’ games, large bodies of water, such as lakes and",
      "keywords": [
        "Improved Bones Deformation",
        "cell",
        "Charles River Media",
        "flow",
        "Improved Bones",
        "Bones Deformation",
        "water",
        "mass",
        "Inverse Kinematics",
        "pressure",
        "Constrained Inverse Kinematics",
        "air",
        "Game Programming Gems",
        "neighbor cell",
        "games"
      ],
      "concepts": [
        "cells",
        "modeling",
        "flowing",
        "water",
        "physical",
        "physics",
        "pressure",
        "objects",
        "ways",
        "way"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 22,
          "title": "",
          "score": 0.531,
          "base_score": 0.531,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "cell",
          "cells",
          "water",
          "mass",
          "flow"
        ],
        "semantic": [],
        "merged": [
          "cell",
          "cells",
          "water",
          "mass",
          "flow"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.17483629233423212,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:24.922056+00:00"
      }
    },
    {
      "chapter_number": 22,
      "title": "Segment 22 (pages 208-217)",
      "start_page": 208,
      "end_page": 217,
      "summary": "‘Transmitting heat through the environment, whether from burning objects or from\nNeighboring cells pass heat energy\nIfa hot cell made of water (high SHC and hard to heat up) is next to a colder cell made\nfloat HCCell = cell->material->SHC * cell->Mass;\nfloat EnergyFlow = neigh->Temp - cell->Temp;\n// A constant according to cell update speed.\ncell->Temp += EnergyFlow / HCCell;\nif (((EnergyFlow>0.0f)&&(neigh->Temp<cell->Temp) ) | |\n( (EnergyFlow<=0.0f) &&(neigh->Temp>cell->Temp) ) )\nfloat TotalEnergy = HCCell * cell->Temp +\ncell->Temp = AverageTemp;\nThe physically correct solution is to integrate the transfer of heat over\nrating temperature into the model of water or air.\nflow will be influenced by the relative temperatures of cells as well as their relative\nRadiative heat modeling is very similar to the radiosity modeling that is used\nheavy amount of approximation to improve the speed of radiative heat modeling.\nEven with these algorithms, modeling even a fraction of the radiative heat seems like\nparts that burn at different rates and heats, and there are also different phases of mate-\nTo perform the calculations in real-time, the material models used during the\ngraph shows how much heat energy is released per unit of time when a substance burns\nfloat Temp = cell->Temp — material->Flashpoint;\n// And heat the cell up from the burning.\ncell->Temp += Burn * material->BurnTemp;\nNote that the damage done to a cell is proportional to its actual temperature, not\nhow much heat is generated by burning.\nily on the modeling of heat flow by the three methods discussed previously.\nSadly, radiative heat, as mentioned above, is extremely hard to model, and con-\naround the source of the fire to be modeled and updated, which is expensive.\nA hack for convection effects is simply to make conduction of heat far easier in an\nIn real life, a section of burning wall heats the air beside it, which\nused for heat conduction for all six neighbors of a cell.\nDynamic Update Rates\nupdate rates to maintain realism.\ncan only proceed at a maximum speed of one cell per update cycle.\nExplosions require extremely high update\nSimulating all of the above implies that update rates of 680 cycles per second\nplatform can sustain these sorts of update rates for a decent-size game world.\nuse the octree to reduce the update rates for cells that do not require fast updates to\nWhen a cell is processed, it decides how fast it needs to be updated to maintain a\nCells involved in explosions require high\nupdate rates; cells holding flowing water, burning objects, or high heat need medium\nupdate rates; cells with fairly static water require lower update rates; and cells that\nThis speed of processing is then stored in the cell and is also passed up the octree\nhierarchy, each level being marked so that it is processed at the highest update rate of\nOne point to note is that this system only works if the update rates are quantized\nQuantizing update rates to powers of two solves this\nAn obvious consequence of this variable update rate is that the physics routines\nneed to be able to handle variable update rates as well.\nWith variable update rates, the physically correct\ncells have a fairly constant behavior over the update interval.\nflow or rate by the time period since the last update.\nthe huge reduction in the number of cells updated per second.\nthe use of an even lower update rate, further improving speed overall.\nAn unexpected artifact of using a variable update rate can occur when neighbor-\ning cells have very different update rates.\nSince one cell is being updated much more\nfrequently than its neighbor, it can change rapidly before the other cell has time to\nThe solution is to limit the maximum difference in update rates of adjacent\ncells.\nEvery time a cell is processed, as well as exchanging temperature, heat, and sim-\nUsing a factor of two causes too many cells to have their update rates raised\nCan your physics model for friction handle all these cases correctly?\nModeling dry frictional forces is an important aspect of simulating mechanical\nfriction.\nA System with Dynamic Friction\nFor our first example, suppose a block is placed on a flat surface.\nis given an initial velocity v) > 0 in the x* (positive x) direction, as in Figure 2.7.1.\nmore, the rate of deceleration is independent of the block’s mass, m, and is propor-\nspeed v < 0 in the x direction, friction would have again decelerated the block until\nthe block and that friction exerts no force on the block when v = 0.\nEven though our block exists in the x and z\nFIGURE 2.7.1 A block set in motion on a flat surface will decelerate at a constant rate\nacceleration by the coefficient of dynamic friction Ly. 2.7 Coping with Friction in Dynamic Simulations 217\nIn this example we assume the block has no motion along the z direction; there-\nof the block as a function of time ¢, satisfies the system of differential equations:\nSince v will not change sign before the block stops, the\nIf the initial x-position of the block is xp = 0, integrating Equation 3 gives\nThe exact time and position at which the block comes to rest are:\nFor all times ¢ 2 ¢,, the block has stopped; in other words, the solution is\nThe position, velocity, and acceleration of the block over time are plotted in Fig-\nFIGURE 2.7.2 Plots of (a) position, (b) velocity, and (c) acceleration of a block sliding along a\nThis implies that the frictional force is equal and opposite the x",
      "keywords": [
        "Update Rates",
        "heat",
        "Temp",
        "block",
        "update",
        "cell",
        "Friction",
        "rates",
        "Transmitting heat",
        "variable update rate",
        "high update rates",
        "dynamic friction",
        "static friction",
        "temperature",
        "time"
      ],
      "concepts": [
        "cells",
        "heat",
        "friction",
        "update",
        "updated",
        "temperature",
        "burning",
        "modeling",
        "simulate",
        "simulation"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 21,
          "title": "",
          "score": 0.531,
          "base_score": 0.531,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "rates",
          "update rates",
          "cell",
          "update",
          "heat"
        ],
        "semantic": [],
        "merged": [
          "rates",
          "update rates",
          "cell",
          "update",
          "heat"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.10376264439039856,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:24.922107+00:00"
      }
    },
    {
      "chapter_number": 23,
      "title": "Segment 23 (pages 218-225)",
      "start_page": 218,
      "end_page": 225,
      "summary": "Consider the first example: a block sliding on a flat surface.\nand velocity v(¢) at time ¢, we might try to calculate the position and velocity of the\nblock at a later time, ¢ + 4, in the following way:\nand speed, this is the integration method of choice for many game programmers.\ncates the block will come to rest after ¢, = 0.10194 seconds at a position x, = 0.05097\nTable 2.7.1 Positions and Velocities Resulting from Euler's Method for a Block Slid-\nt x(t) v(t)\nNote: The numerical values never converge due to the discontinuity of acceleration at v = 0.\n2.7 Coping with Friction in Dynamic Simulations (221\nWhat is alarming, however, is that not only does v never converge to zero,\nIt might seem practical to solve this problem by simply setting v to zero when its\nessary to test each object affected by friction against every surface type on which it\nAs we shall see later, velocity thresholds cause more serious problems when evaluating\ntransitions between dynamic and static friction.\nWhen 1 is ‘small,’ our integration method will cause v to overshoot zero and change\nOn the following step, acceleration is in the opposite direction, which causes v\nSince v oscillates asymmetrically about zero, the position gets a\nmulation so that friction is continuous at v = 0.\n—sgn(v)u,N , when b| >v,,\nfor some velocity threshold v, > 0.\nwhen transitioning (either way) between dynamic and static friction.\nx2) _ Jot — 3 sgn(v)u, gt , whent <¢, (2.7.13)\nThe function x(z) and its derivative v(t) are both continuous at ¢, but acceleration\na(t), the first derivative of v(2), is not.\nneighborhood of t, where v goes to zero and the discontinuity occurs.\nmethod that assumes a valid Taylor series for x(¢) will not converge to the correct\nThe Taylor series for v(t + 4) is\nintegrate over time intervals [¢, ¢ + A] that satisfy ¢+ 4 < 4, this method is exact for our\nblock on a flat surface at any incline.\nh, = v (2.7.16)\nIf 4, satisfies this inequality at any particular step, we must set v = 0, and consider\nIn general, if the block has acceleration a(t), our method\nv(t +h) = o(r) + ha(z) .\n2.7 Coping with Friction in Dynamic Simulations\nTable 2.7.2 shows that ¢, and x, are exact, but more importantly, v(t) = 0 for ¢2 ¢,.\nPositions and Velocities Calculated with a Taylor Method\nNote: Positions and velocities calculated with a Taylor method are exact for our test system.\nTransitioning Between Static and Dynamic Friction\nThe previous approach handles only dynamic friction.\nwhether or not a transition between static and dynamic friction will occur.\nWhen v #\n0, friction is dynamic by definition, so we only need to consider these transitions\nwhen v = 0.\nIf the block is stationary and the forces on the block are changing over time,\nblock transitions from static to dynamic friction, its velocity is zero; so the direction\nof dynamic friction cannot be determined.\ndirection of F,, dynamic friction must therefore act opposite to F..\nIt is now easy to see why velocity thresholds cause problems when transitioning\nfrom static to dynamic friction.\nUpon the first application of dynamic friction, veloc-\nity goes from zero to some value v(t + 4).\nvelocity, then v is set back to zero.\nIf velocity consistently fails to rise above v,, then the block will slowly creep\nWe can now formulate dynamic friction in three dimensions:\n—,NE, when v = 0,\nThis formulation is consistent for transitions from static to dynamic friction.\nFriction\nvector V is tangent to the contact surface.\nWhen v = 0, static friction tries to counter tangential forces, and its magnitude\naccurately predict whether or not v goes to zero during the integration interval.\nthe interval [z, ¢ + 4], then only the magnitude of velocity changes over time.\nSince we are assuming the direction of v is constant and its magnitude decreases\na:v\n2.7 Coping with Friction in Dynamic Simulations 225\nThis reduces to the one-dimensional formula when v and a are in the same\nFIGURE 2.7.4 A block sliding along a flat surface will experience a discontinuity in tts\nthe object into the slope and give v a component normal to the surface.",
      "keywords": [
        "Dynamic Friction",
        "friction",
        "Method",
        "Dynamic",
        "Euler method",
        "Taylor method",
        "block",
        "velocity",
        "static friction",
        "surface",
        "Dynamic Simulations",
        "position",
        "approach",
        "Taylor",
        "numerical method"
      ],
      "concepts": [
        "friction",
        "frictional",
        "velocity",
        "velocities",
        "game",
        "approach",
        "model",
        "problem",
        "block",
        "numerical"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 32,
          "title": "",
          "score": 0.495,
          "base_score": 0.345,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "",
          "score": 0.435,
          "base_score": 0.285,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "",
          "score": 0.418,
          "base_score": 0.268,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 40,
          "title": "",
          "score": 0.417,
          "base_score": 0.267,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 29,
          "title": "",
          "score": 0.379,
          "base_score": 0.229,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "friction",
          "dynamic",
          "dynamic friction",
          "block",
          "velocity"
        ],
        "semantic": [],
        "merged": [
          "friction",
          "dynamic",
          "dynamic friction",
          "block",
          "velocity"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1514471962264158,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922168+00:00"
      }
    },
    {
      "chapter_number": 24,
      "title": "Segment 24 (pages 226-233)",
      "start_page": 226,
      "end_page": 233,
      "summary": "Each actor has a control state that defines if the actor is currently under player\ncontrol, AI control, or is in the training state.\nfly to transition the actor between one of these states.\nmethod will delegate processing to the current control state, which will determine the\nin a training state, the player controls the actor, as in the user-controlled state; except\nnow, the computer can observe and learn from the actor's actions.\nwhen an actor in this state calls its PerformAction() method.\nThe TrainingControlstate adds a private Train() method that it will use to learn\nple will also illustrate the process of mapping action states to the rules that detail\nDefining Action States\nOur toy car has five basic action states that define the operations that it can perform\nTable 3.1.1 Action States for Driving a Car\nAction State Description\nfor these action states.\nFIGURE 3.1.3 Action states for driving and the transitions between them.\nFIGURE 3.1.4 Class diagram for movement action states.\nNow we need to determine the rules that will detail when our car can transition to\nthese action states.\ntains the rules under which we can use the state (see Figure 3.1.1).\nFIGURE 3.1.5 Attaching sensors probes to a car.\nFIGURE 3.1.6 Rules for the TurnLeft behavior.\nWith our Evaluate() methods encapsulated in each rule, we can now build the\nFigure 3.1.6 depicts the TurnLeft action state\nwith its associated six sensor rules.\nLeft state and rules.\nLearning the Rules\nNow, we are ready to train our car’s rules.\nWe do this by swapping the car’s actor to the\ntraining control state with a human player in the driver's seat, as described here.\nFIGURE 3.1.7 Class diagram for TurnLeft ActionState rules.\nState and pass it to the Train() method.\nTrainingControlState:PerformAction( Actor )\nTrainingControlState.Train( ActionState )\nCluster Maps for Floating-Point Valued Rules\nTo allow us to dynamically train the rules, each rule has a ClusterMap associated with\nTrainingControlState:Train( ActionState )\nFor Rule in ActionState.GetRuleSet {)\nValue = Rule.fEvaluate( Actor )\nindicates that the player activated this action rule with this evaluation value.\nAs training goes on, more data flows into the system, and more rules are learned.\nthe rules that match the input action choices.\nWhen the actor performs its next action, it calls on its decision process\nand newly trained rules to determine its course of action.\nActionState = Actor.PerformAction( )\nThe cluster's Fire() method can now test the evaluation values against the train-\nIf a rule evaluates to a value that falls into a cluster\nthat has enough markers to reach the threshold, then that rule fires.\nIf all of the rules\nin the rule set fire, then the associated ActionState is returned for activation.\nFor Rule in Action.GetRuleSet()\nValue = Rule.Evaluate( Actor)\nEnd For Rule\nlearning of rule clusters.",
      "keywords": [
        "action states",
        "action",
        "state",
        "Car",
        "control state",
        "Actor",
        "rules",
        "Car Action State",
        "Cluster",
        "actionRuleSet transaction List",
        "Optimized Machine Learning",
        "ActionState",
        "method",
        "transaction List",
        "cluster map"
      ],
      "concepts": [
        "training",
        "actions",
        "rule",
        "actor",
        "cluster",
        "states",
        "car",
        "value",
        "valued",
        "probes"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 52,
          "title": "",
          "score": 0.668,
          "base_score": 0.518,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 30,
          "title": "",
          "score": 0.456,
          "base_score": 0.306,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 27,
          "title": "",
          "score": 0.45,
          "base_score": 0.45,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 13,
          "title": "",
          "score": 0.409,
          "base_score": 0.259,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 1,
          "title": "",
          "score": 0.402,
          "base_score": 0.252,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "action",
          "rules",
          "actor",
          "rule",
          "action states"
        ],
        "semantic": [],
        "merged": [
          "action",
          "rules",
          "actor",
          "rule",
          "action states"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15873360573066475,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922216+00:00"
      }
    },
    {
      "chapter_number": 25,
      "title": "Segment 25 (pages 234-242)",
      "start_page": 234,
      "end_page": 242,
      "summary": "Area Navigation: Expanding\nthe Path-Finding Paradigm\napproach to solving the path-finding problem involves placing nodes across the game\nworld and connecting them by edges, where the direct route linking any two points is\nOnce the world is deconstructed into nodes and connections, path-finding is nor-\nvalid nodes remain to be expanded (i.e., the attempted path-finding has failed).\npath-finding.\nRather than using nodes as the fundamental components of path-finding,\nit is suggested that regions of the environment be segregated into areas, each represented\nby one node in the search space, and that these areas be connected to one another if nav-\n3.2 Area Navigation: Expanding the Path-Finding Paradigm 241\nTraditionally, path-finding has used the waypoint as its fundamental component for\nFIGURE 3.2.1 A simple tile map for a 2D world.\nLight areas are walkable,\ndark areas are unwalkable.\nFIGURE 3.2.2 Procedurally placed nodes and connections.\nSuch a complete system of nodes ensures that an obstacle-free path can be found\n3.2 Area Navigation: Expanding the Path-Finding Paradigm 243\na nonuniform area of tiles.\nWhen approaching the problem of path-finding, the form of the environment should\nbe considered so that the path-finding algorithm can be optimally written for the\nTR RRB AES EN A A ABB 2 OHA RN MORRIS ESOT EE EM INE RIE\n© The usefulness of the resulting nodes for path traversal: \\t is preferable that the nodes\nThe use of areas rather than points is beneficial in both cases.\nThe world is broken into areas, each being of uniform navigability and internally\ngate between two areas, then the areas are connected by a ‘portal’ that is in the shape\nof the contact region between the two areas.\nsplit into areas as shown in Figure 3.2.3.\nAs seen in Figure 3.2.3, no points are arbitrarily used in path-finding.\nAll other sections of the path are generalized areas, split up by the way you perceive\nlkable areas connected by porta\nareas, unless there\nAny path\n3.2 Area Navigation: Expanding the Path-Finding Paradigm 245\nFIGURE 3.2.4 A simple metric for movement cost between areas.\nportal used to enter an area to the central point of the portal used to exit that area.\ninstance, if your path took you from area A to B to C during your path-finding\n¢ The world is split into an optimal set of areas, where each area is uniformly navi-\ngable, and any two points within the area can be traversed in a straight line with-\n¢ Each of these areas is represented by a node in a graph, and two nodes are connected\nby an edge if their associated areas have a common navigable interface (a portal).\nFIGURE 3.2.5 A more realistic metric for movement cost between areas.\n* Basic paths are generated by determining the containing areas for the start and\nend points of the journey, finding the associated nodes, and then searching the\n* Once this area-wise route is found, a specific path is created by moving between\nwith the tile-world example and explain a method of producing optimal areas from\n3.2 Area Navigation: Expanding the Path-Finding Paradigm 247\nConstructing areas from raw terrain data is a very game-specific problem.\nble you will have to extract the processed areas from polygons flagged for terrain type,\ncase as an example and show a method of rectangularizing a tile world to produce\ngles for path-finding, the following aspects are important to consider:\nquicker the path-finding process will occur, since fewer rectangles are necessary.\nFor the purposes of path-finding, the\noptimized rectangles for path traversal and optimized speed.\nOnly cells that are not already contained within an area are considered.\nint CellCount = number of free cells of type cellType\ntest size defines an area larger than the number of cells that the required type can\noccupy, then there is no way that the square will find an area consisting entirely of\nThe square defines an area of the world that is tested for uniform cells (of the\nrequired type) such that no cell under the square is contained by another area.\nsquare contains only free cells of the required type, then attempt to expand the square\nadded to the area by each expansion are permanently added to the rectangle (if they\nare of the required type and contained by any other area).\nExpand the area by one cell width\nAt this point, we have an area defined by this expanded rectangle that should be\nadded to the list of areas.",
      "keywords": [
        "Mike Ducker",
        "areas",
        "Area Navigation",
        "nodes",
        "Paradigm Ben Board",
        "Path-Finding",
        "world",
        "Path-Finding Paradigm",
        "Path-Finding Paradigm Ben",
        "path",
        "type",
        "tile",
        "square",
        "Dogfish Entertainment ben",
        "Paradigm"
      ],
      "concepts": [
        "area",
        "nodes",
        "path",
        "cells",
        "optimal",
        "optimally",
        "optimized",
        "tile",
        "algorithm",
        "process"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "",
          "score": 0.849,
          "base_score": 0.699,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "",
          "score": 0.75,
          "base_score": 0.6,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 32,
          "title": "",
          "score": 0.744,
          "base_score": 0.594,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "",
          "score": 0.577,
          "base_score": 0.427,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 31,
          "title": "",
          "score": 0.572,
          "base_score": 0.422,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "path",
          "areas",
          "path finding",
          "finding",
          "area"
        ],
        "semantic": [],
        "merged": [
          "path",
          "areas",
          "path finding",
          "finding",
          "area"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21661071173330584,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922268+00:00"
      }
    },
    {
      "chapter_number": 26,
      "title": "Segment 26 (pages 243-252)",
      "start_page": 243,
      "end_page": 252,
      "summary": "3.2 Area Navigation: Expanding the Path-Finding Paradigm 249\nof areas produced will adhere to the first two aspects of optimal rectangularization.\nthe next portal on the path or toward the goal point if the character has entered the\ngoal area.\nTo move a character toward its next area in a realistic manner, two simple modes\nFigure 3.2.8 shows the portion of area B where attraction\nby the normal alone will result in the transition from area B to area C.\nAn example attraction algorithm is to use the normal vector shown in Figure\nthe normal is reversed such that the vector is heading into the character's current area\ncell type would have its own area list, and all areas would have portals to all their\nNeighbors leading to areas that a specific character could not use would\nrepulse that character by using a different area type in the traversal algorithm.\nFIGURE 3.2.6 Autraction to area C by the central point of the portal connecting areas B\nFor each unwalkable area connected to the character’s current area, a repulsion\ncharacter is within the confines of the portal, as shown by the shaded area of Figure\nFinally, once the path traversal is in place, dynamic object avoidance can be\ncharacters in the world to the path-traversal vectors.\nFIGURE 3.2.7 Attraction to area C by the normal of the portal connecting areas B and C.\nDeconstructing the world into areas is a CPU-intensive process that must be carried\nFIGURE 3.2.8 The shaded area defines the portion of area B where attraction by the\nnormal of the portal connecting areas B and C (shown in Figure 3.2.7) will suffice to\ntraverse a character from area B to area C.\nFIGURE 3.2.9 The entire map is broken into walkable and unwalkable areas connected\nRemember, altering the set of areas not only requires deconstructing the world,\nbut it also requires recalculating the characters that are positioned in those areas.\nrequired is a method of deconstructing the world into efficient areas that obey the\nFIGURE 3.2.10 Repulsion is applied to characters within the area defined by the normal\nof the portal, which is shown by the shaded section of area B.\nTo support this process, a method of determining these optimal areas has been\nAlso, in order to use the resulting area-wise path and apply it to a navigat-\n3.2 Area Navigation: Expanding the Path-Finding Paradigm _ 255\ning character, a path-traversal method has been described.\nhe goal of this gem is to create an FSM (Finite State Machine) implementation\ntation has three design requirements: object-oriented implementation, minimal cod-\nThe first requirement, object-oriented implementation, is very important in\nthe addition of FSM functionality as simple as inheriting a class and adding some\nA system's behavior is represented within an FSM as a set of states, a set of input\n3.3 Function Pointer-Based, Embedded Finite-State Machines 257\nIn game programming, FSMs are generally used to control a game object’s behavior at\nWhile FSMs can be used to control virtually any game object, they are\nFSM Implementation\nit needs some code for mapping the current state to the appropriate state functions in\nthe game object.\nFSM implementations can be integrated into game objects in one of two ways.\nThe second method is to embed the FSM within the game object via inheri-\nbecause the FSM’s state-transition logic can use the game object’s data directly.\nFSM and the game object classes, which can pose a challenge later on in development,\nthis implementation, the current state is stored as an integer, and a switch statement\nthe switch implementation is not very object-oriented [Sweeney00].\nFor an FSM having states, the program will",
      "keywords": [
        "Area",
        "FSM",
        "FSMs",
        "FSM implementation",
        "portal connecting areas",
        "portal",
        "Switch",
        "State",
        "implementation",
        "Switch implementation",
        "game",
        "game object",
        "Current State",
        "attraction",
        "character"
      ],
      "concepts": [
        "area",
        "state",
        "figures",
        "object",
        "path",
        "function",
        "functionality",
        "functions",
        "algorithm",
        "game"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 25,
          "title": "",
          "score": 0.849,
          "base_score": 0.699,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 32,
          "title": "",
          "score": 0.74,
          "base_score": 0.59,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "",
          "score": 0.719,
          "base_score": 0.569,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "",
          "score": 0.59,
          "base_score": 0.44,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 31,
          "title": "",
          "score": 0.551,
          "base_score": 0.401,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "area",
          "fsm",
          "areas",
          "portal",
          "character"
        ],
        "semantic": [],
        "merged": [
          "area",
          "fsm",
          "areas",
          "portal",
          "character"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22540110308229228,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922319+00:00"
      }
    },
    {
      "chapter_number": 27,
      "title": "Segment 27 (pages 253-260)",
      "start_page": 253,
      "end_page": 260,
      "summary": "3.3 Function Pointer-Based, Embedded Finite-State Machines 259\nfunction call.\npriate state function might require several virtual function calls up the class hierarchy\nlate the state function calls within the current state variable.\nSince the state functions\nare usually associated with the game object, implementing the state functions directly\nHowever, the state functions can effectively be\nstored within a state object through the use of function pointers.\nFunction Pointers\nFunction\nThe class-specific nature of function pointers to member functions extends\nthey pass the class instance to the function via a hidden parameter (the this pointer).\nThus, execution of a member function through a function pointer requires a class\nWith these limitations, the use of function pointers to store the state functions\ncontinue to examine the use of function pointers in an FSM implementation.\nThe Function Pointer Implementation\nIn a function pointer implementation, each state is now represented as an object.\nWithin this object, the state function calls are stored in function pointers, and the\nfunction mapping occurs when the state is initialized.\nstate by maintaining a pointer to the current state object, and the state function calls\nare executed directly from the state object through the function pointers.\nInstead of overloading the Update() function in the derived class, new states can be\nstate function mapping is now stored as a set of function pointers instead of being\nof a base class using the function pointer implementation, as previously described.\nThe CFSM implementation has two separate parts: the state objects and the FSM.\nThe State Objects\nIn the CFSM implementation, each state is represented\nby three functions.\n3.3 Function Pointer-Based, Embedded Finite-State Machines __ _ 261\nThe BeginStateIdle() and EndStateIdle() functions are called during state\nThe StateIdle() function is the main state function and is called every tick from the\nSince three functions make up each game object state, the CFSM\nstate object uses three function pointers to store the state functions.\nTo create state objects, a two-class hierarchy is necessary.\nprovides a generic interface for executing the stored state functions.\nof class-specific function pointers, CStateTemplate is a template class.\nCStateTemplate implements the three state function pointers as well as a pointer\nThe execution functions from the CState class are overloaded\nplate, a game object can create class-specific state objects using CStateTemplate\nThe FSM implementation, however, can use the state objects generically by\ngame object in order to execute its state functions.\nWith state objects now defined, the CFSM base class can now use them to implement\nThe current state, m_pCurrentState, isa pointer to a CState object.\nCState pointer allows the FSM to completely implement the state function execution\nThe CFSM implementation defines an initial state using the CStateTemplate class\nand stores it in the state object m_StateInitial.\nFSM implementation always has a state to execute.\nthe initial state along with the pointers to the state objects.\n3.3 Function Pointer-Based, Embedded Finite-State Machines 263\nThe execution of the state functions occurs in the Update() function.\nUpon entering the Update() function, the FSM checks for a state transition using\nand ExecuteBeginState() functions, and changes the current state.\nof state objects.\nThe GotoState() function sets the new state variable and causes a\nstate transition on the next Update() function call.\nreturn (m_pCurrentState==&State) ;\nthe CFSM class will provide the FSM functionality.\nimplement the states, we add two state objects using the CStateTemplate class and the\ncorresponding state functions.\nThe constructor initializes the CFSM base class and initializes the two state objects.\n3.3 Function Pointer-Based, Embedded Finite-State Machines 265\nthe On state functions from CLightBulb.\nThe On state functions from\nLikewise, we implement the On Dim state functions.\nstate.\nThis gem illustrates an FSM implementation using function pointers that allows",
      "keywords": [
        "function pointers",
        "state",
        "Function",
        "state functions",
        "functions",
        "FSM",
        "Function Pointer Implementation",
        "CFSM",
        "state objects",
        "virtual void",
        "void",
        "state function calls",
        "pointers",
        "state function pointers",
        "virtual"
      ],
      "concepts": [
        "function",
        "functions",
        "functionality",
        "state",
        "stated",
        "void",
        "classes",
        "virtual",
        "pointer",
        "implementing"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 5,
          "title": "",
          "score": 0.707,
          "base_score": 0.557,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 4,
          "title": "",
          "score": 0.625,
          "base_score": 0.475,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 6,
          "title": "",
          "score": 0.513,
          "base_score": 0.363,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 7,
          "title": "",
          "score": 0.506,
          "base_score": 0.356,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 24,
          "title": "",
          "score": 0.45,
          "base_score": 0.45,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "state",
          "function",
          "function pointers",
          "state functions",
          "state function"
        ],
        "semantic": [],
        "merged": [
          "state",
          "function",
          "function pointers",
          "state functions",
          "state function"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21313635595709174,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922367+00:00"
      }
    },
    {
      "chapter_number": 28,
      "title": "Segment 28 (pages 261-270)",
      "start_page": 261,
      "end_page": 270,
      "summary": "Areas\nanalyze, we must consider: “What areas do I need to know about?” Will you want to\nrecognize forests, choke points, or oceans in your game?\nStatic Areas\nStatic areas don’t change throughout the course of the game.\ntend to have the most points (or tiles) and cover the largest areas.\ndynamic areas, static areas must be preprocessed before the game starts.\nReprocessing a very large area during runtime could make the game slow down to\nSome examples of static areas are:\n¢ Continents: Continents are one of the most important areas of terrain analysis.\nplayer might flee to a nearby hill to attack from an elevated point, or perhaps the\nvery useful for determining at what point a transport ship should pick up or drop\nDynamic Areas\nDynamic areas, which change with the runtime variations of the world, help keep a\nIf an area is very large and needs to be\nSome examples of useful dynamic areas in an RTS are:\nForests need to be dynamic, since if a player chops down a tree, the old location\nsented as a convex hull in which a number of buildings live (see Figure 3.4.1).\nTowns also differ from most other areas because\nthe convex hull encompassing all the points is more significant than the points\ninside a town, then they would need to get its convex hull and do a point-in-\ning checking its distance to each town’s convex hull.\nFIGURE 3.4.1 Highlighted area indicates a town.\nChoke points are useful\nplayer interaction, but there are other creative game-engine uses for armies as\nBuilding Generic Areas\nDesigning a generic area system is an example of how OOP can make life easier\nAn area class needs only a few data members.\nthem, the convex hull of those points (more on that soon), the type of area they are,\n* Create(): Creates the area.\n* GetClosestPointToArea(): This method takes another area and returns the clos-\nest point between the two areas.\nThis is most useful for areas\nlike towns, which have few actual points (the buildings); but you want it to seem\nlike every point in a town is actually stored inside this object (instead of just the\nfew that were used to make the hull).\n* GetRandomPoint(): This is probably the most useful area-related method.\nother areas inside the continent class.\nthe continent so that programmers can quickly get the choke points that they want.\nof a hash table can cut down the search time for tasks, like finding which forest’s hull\nBuilding your area system with a generic base class will make using your areas a\nYour computer player can often make intelligent decisions just by perform-\nOne of the more-complex areas of simulating human intelligence deals with the com-\nbehavior by using a simple and powerful geometric shape, the convex hull.\nA convex hull is a shape that does not fold in on itself.\nthe convex hull.\nWhy Use Convex Hulls?\nConvex hulls take up very little memory, can be very efficient, and provide a fuzzy\nConvex hulls can be used in almost every area of an RTS game engine.\narea.\nFIGURE 3.4.2 A convex hull surrounds an area (shown in a test application).\nIt’s not just the useful tasks alone that make the investment in convex hulls so\nWhat's in a Hull?\nA convex hull is really a polygon with special rules.\nthe construction of a convex hull class by constructing a base polygon class.\na good idea to make the polygon/convex hull class a template, since most tasks in an\nPC-based RTS game can use integer-based hulls for added performance.\nwe use float-based hulls.\narea of the polygon.\nIts area\nthe hull or polygon.\nhas two points, one at top left,\nfloat mArea The area inside the polygon.\n* CalculateArea(): Determines the area of the polygon or hull.\n* ContainsInPoly(): This virtual method does the appropriate point-in-polygon\noptimization for shapes like the convex hull.\n* CreateCenterPoint(): This virtual method computes the center point using the\n* GetClosestPoint(): One of the most useful methods for a convex hull, GetC1los-\nestPoint() returns a potentially fabricated point on the hull.\nhave two closest-point methods, one for returning the closest vertex and one for\nreturning the closest line-intersection point on the hull or polygon.\n* GetClosestPoints(): Use this method to find the closest point given two poly-\ngons or convex hulls.\n* SortPoints(): This is a template function used to sort the points.\n* TrimToVitalPoints(): This is where the convex hull-creation algorithm should\nDeriving from U2DPolygon<T>, the convex hull class needs to overload some of\nthe polygon’s base class methods, and one of the most important methods is Create().\nThe Create() method is the entry point for the convex hull-creation algorithm.\nPicking the right algorithm to construct a hull will make a big difference in hull-cre-\nThere are many published convex hull-creation methods and util-\nConvex hulls are very effective elements in terrain analysis as they allow the pro-",
      "keywords": [
        "convex hull",
        "Dirk Grundwald",
        "Benjamin Zorn",
        "Areas",
        "Embedded Finite-State Machines",
        "hull",
        "dynamic areas",
        "Game",
        "convex",
        "convex hull class",
        "points",
        "RTS",
        "Static Areas",
        "RTS game",
        "town"
      ],
      "concepts": [
        "areas",
        "points",
        "game",
        "gaming",
        "methods",
        "hulls",
        "useful",
        "uses",
        "towns",
        "classes"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 25,
          "title": "",
          "score": 0.447,
          "base_score": 0.447,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "",
          "score": 0.424,
          "base_score": 0.424,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 38,
          "title": "",
          "score": 0.343,
          "base_score": 0.343,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 32,
          "title": "",
          "score": 0.331,
          "base_score": 0.331,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 47,
          "title": "",
          "score": 0.32,
          "base_score": 0.32,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "hull",
          "convex",
          "convex hull",
          "areas",
          "area"
        ],
        "semantic": [],
        "merged": [
          "hull",
          "convex",
          "convex hull",
          "areas",
          "area"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.188641313367556,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:05:24.922413+00:00"
      }
    },
    {
      "chapter_number": 29,
      "title": "Segment 29 (pages 271-278)",
      "start_page": 271,
      "end_page": 278,
      "summary": "Having the convex hull of an area is terrific—until you need to get an actual point\nIf you want a real point (a point that exists on a continent, for example,\nthe continent's points.\nWhat we need is a memory superhero, something to crunch all these evil points\n“matchbox container,” is a series of linked lists that contain point ranges and simulate\nactual points.\nA matchbox container is really just a one-dimensional array in x, which\nis 400 x 400, then the continent contains 160,000 points.\nIf we put these points\ninside a matchbox container, the 160,000 points end up turning into only 400 points,\nsince we only need to store one point for each x value.\npoints from Figure 3.4.3a in a matchbox container, the end result would look much\n(6) How a continent’ points would be stored in a matchbox\nmatchbox container.\npoints.\narray is a y (start-end) point\nThis means if our points go\nMSize Number of points inside this container.\nSome of the methods for the matchbox container are:\nputs all of our points into an array format.\ntemplate versions because, if this container used floating-point numbers instead\nwe generate our list of points.\nto determine the center of all these points.\nContains(): Returns true if the passed-in-point exists (real or implied) inside this\nCreate(): Creates our container from the passed-in-points.\nest point to a passed-in-point or another matchbox container.\npoints would be returned.\nIt's a huge optimization to build a hull with 200 points instead of\nrandom-point method that will be used more than you might expect.\nOne method takes a point,\nanother takes a vector of points, and a third method takes a matchbox container.\n* Remove: Given a point or a vector of points, this method should remove them\nMatchbox Container Node\nThe matchbox container node contains a start y and an end y coordinate.\nin it are based on checks to see if a passed in point or coordinate exists within its start-\nIt’s an incredibly useful tool for optimizing terrain analysis and other areas.\nMost game engines use points, and therefore should have this or a similar structure in\nYou will recall that choke points are narrow passages that provide access to other\nThat being said, the method of creating choke points is really unique to every\nIn the RTS game Empire Earth, choke points are created when two or more\nchoke points are great for planning ambushes.\nFirst, the computer must pick a choke point from which to launch its ambush.\nMaybe it selected a random choke point or found a highly traveled one, or perhaps it\nfour divisions and place them all at opposite, extreme points of the choke point, as\nNotice that the four black Xs are the farthest points of the choke point.\nand watches until the enemy has reached the center of the choke point (the + sign),\nIn Empire Earth, having the choke point, together with its points and its convex\nFinding the Choke Point\nThe algorithm for finding a choke point temporarily costs a large amount of memory\nand CPU time, all of which fortunately go away once the choke points have been\nFIGURE 3.4.4 Ambush in a choke point.\nrary memory and will be returned after the choke points are computed.\nThe idea behind this algorithm is that each terrain area is given an influence\nmore auras intersect each other, then a choke point is formed.\n// copy the original map into choke point map.\n// create the final choke points.\n// store the blocking area's id and set a cost.\npoints with only themselves.\nThat tends to give the choke points\nand create choke points out of them.\ngather these scores and create the choke point areas.\nthing from path-finding units to creating forest areas and other terrain-analysis tasks",
      "keywords": [
        "matchbox container",
        "choke point",
        "points",
        "Matchbox",
        "container",
        "Matchbox ORS NERS",
        "PANERA ASAE RELL",
        "ASAE RELL ARRT",
        "RELL ARRT EPA",
        "ARRT EPA ION",
        "EPA ION CLE",
        "ION CLE Sad",
        "choke",
        "Matchbox Container Node",
        "choke point areas"
      ],
      "concepts": [
        "point",
        "contain",
        "maps",
        "map",
        "area",
        "costs",
        "terrain",
        "tile",
        "aura",
        "methods"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "",
          "score": 0.524,
          "base_score": 0.374,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "",
          "score": 0.509,
          "base_score": 0.359,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 32,
          "title": "",
          "score": 0.488,
          "base_score": 0.338,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "",
          "score": 0.476,
          "base_score": 0.326,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 25,
          "title": "",
          "score": 0.467,
          "base_score": 0.317,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "choke",
          "points",
          "matchbox",
          "choke point",
          "container"
        ],
        "semantic": [],
        "merged": [
          "choke",
          "points",
          "matchbox",
          "choke point",
          "container"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19342481619894727,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922464+00:00"
      }
    },
    {
      "chapter_number": 30,
      "title": "Segment 30 (pages 279-287)",
      "start_page": 279,
      "end_page": 287,
      "summary": "An Extensible Trigger System\nextensible trigger system.\nObject-Owned Trigger | Systems\nEach of the previous events can be specified with a trigger system using the sim-\nmember of the player’s party, the response was to slide open the door and play a stone-\nA trigger system can be made with just enough hooks that both your designers\nCraft level editor is a fine example of a trigger system that you should examine and\ntriggers existing on particular items, so the concept is still easy for players to grasp.\ndefine such a pillar in a level editor and attach a trigger definition that encompasses\nthe game and they all magically display the same behavior, since the trigger behavior\nA condition can be any event or state that you can quantify i in your game.\nConditions\n* Object X equipped by player\n¢ Player reached X level\n¢ Player talked to character X\n¢ Player killed enemy X\n3. 5 An Extensible Trigger System for Al Agents, Objects, and Quests — oe 287\nIf true, trigger fires\nFIGURE 3.5.1 [fall three conditions are “true,” then the door will open.\nIf true, trigger fires\nFIGURE 3.5.2 Jf either condition is “true,” then the door will open.\nIf true, trigger fires\nFIGURE 3.5.3 A more-complicated set of conditions for the door to open.\n¢ Hurt/Heal player by X points\n¢ Give player X experience\n¢ Move player/enemy X to spot (x,y,z)\n¢ Set player/enemy X on fire\n¢ Stun player/enemy X\n¢ Make player/enemy X invincible\n¢ Make player/enemy X invisible\n¢ Reset trigger\n¢ Send message X to player\nIf a particular set of conditions is met, the response will be executed.\nEvaluating a Trigger\nOnce a trigger is defined\nevent-driven (waiting for an event to be reported to the trigger system), or if it should\ntrigger system.\nFor conditions that are polled, we can call an update function within the trigger\nEvent-driven conditions\nWhether an event message or a polling update enters the trigger system, we need\ncondition set that requires both event messages and polling.\nWhen an event message or polling update enters the trigger system, it is routed to\nthe root Operator instance of each trigger.\nFIGURE 3.5.4 A trigger example that contains an event-driven condition (bottom left)\ntrigger testing is abandoned at this time.\nAt some point, the conditions for the specific trigger will all return the proper value,\ncausing the trigger to fire.\nOnce a trigger is fired, it will remember and not fire again.\nAll triggers should have two additional properties that are defined by the designer:\nbool SingleShot; // Whether the trigger should only\nThese two properties allow triggers to fire more than once.\ntrigger resets all of its conditions and accepts events again.\nCombining Triggers with Flags and Counters\nevery trigger within the system has access to.\nThus, every trigger system can be outfit-\nted with a set of flags and counters to keep track of triggers that have fired.\nthis as general as possible, we'll let each trigger create arbitrary flags simply by refer-\nThe trigger system will create a flag as it is refer-\n3.5 An Extensible Trigger System for Al Agents, Objects, and Quests 291\n¢ Set the value represented by flag_name to a value of X.\nWith these flags and counters, we can have the trigger system mark or count\nevents, such as counting how many times a player visits a particular area.\nthe trigger system can now be made to only trigger on particular sequences of events,\nFIGURE 3.5.5 Three triggers that work together through a counter named “Visited.” If\nNote that with the addition of flags and counters, the trigger system becomes\nTrigger Systems Versus Scripting Languages\nof using a trigger system instead of a full-featured scripting language:\nIncorrect syntax isn’t a problem, since triggers are structured around conditions\n° A trigger system is constrained.\nA trigger system can be imple-\n3.5 An Extensible Trigger System for Al Agents, Objects, and Quests 293\nAn extensible trigger system might be a luxury for many games with tight develop-\nIn addition, an extensible trigger system is also an effective way to have level designers\nWhile a trigger\n[Orkin02] Orkin, Jeff, “A General-Purpose Trigger System,” Al Game Programming",
      "keywords": [
        "Trigger System",
        "Extensible Trigger System",
        "Trigger",
        "System",
        "Nintendo of America",
        "player",
        "Charles River Media",
        "Extensible Trigger",
        "conditions",
        "Condition",
        "game",
        "flag",
        "Charles River",
        "River Media",
        "Game Programming"
      ],
      "concepts": [
        "trigger",
        "players",
        "conditions",
        "condition",
        "events",
        "flags",
        "scripting",
        "levels",
        "data",
        "objects"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 52,
          "title": "",
          "score": 0.563,
          "base_score": 0.413,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 2,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 13,
          "title": "",
          "score": 0.511,
          "base_score": 0.361,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 1,
          "title": "",
          "score": 0.489,
          "base_score": 0.339,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 24,
          "title": "",
          "score": 0.456,
          "base_score": 0.306,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "trigger",
          "extensible trigger",
          "conditions",
          "extensible",
          "player"
        ],
        "semantic": [],
        "merged": [
          "trigger",
          "extensible trigger",
          "conditions",
          "extensible",
          "player"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.17177225939100096,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922511+00:00"
      }
    },
    {
      "chapter_number": 31,
      "title": "Segment 31 (pages 288-295)",
      "start_page": 288,
      "end_page": 295,
      "summary": "Tactical Path-Finding with A*\nThis is called tactical path-finding, a situation where the AI needs to balance short\nTactical path-finding not only adds a realistic touch to AI movement, but it also\nhelp you to extend the standard A* algorithm so it generates tactical paths.\nFIGURE 3.6.1 A path that alternates exposure with cover and concealment.\n3.6 Tactical Path-Finding with A* 295\nAs a result, A* will generate paths that atrempt to avoid enemy observation and\nWe will then look at a few of these ‘flawed’ tactical paths, figure out why these\npaths are flawed, and how we can correct this in our A* cost function.\ncompare the computing costs of finding tactical paths with those of finding shortest\npaths.\nObviously, finding tactical paths will be more expensive, but we will look into\nevaluations that need to be done during the tactical path computation.\nFor path-finding, the cost function\nThe heuristic function for path-finding typically provides an estimate of the\nListing 3.6.1 Cost function and heuristic for evaluating shortest paths.\nUsing such a cost function and heuristic A* will find and return a path with the\nIf we now introduce additional costs for visiting locations in the enemy’s line of\nListing 3.6.2 Cost function for evaluating tactical paths.\nYou'll find an example of a more-tactical A* cost function in Listing 3.6.2.\n3.6 Tactical Path-Finding with A* 297\nadding costs for the risk of being under fire, we can obtain paths that show a clever\nFIGURE 3.6.2 (a) Shortest path.\nfunction will provide paths that are tactically flawed and break the illusion of intelli-\nAnother problem is that the ‘tactical’ nature of path-finding also comes with a\npath-finding and come up with some ways to limit these costs.\nTactical Improvements to Flawed Paths\n¢ It assumes that threats remain static during the path’s duration.\ntactical-cost function to try to solve them.\nImagine that the helicopter can reach its destination via two paths of identical\nOne path exposes the helicopter to the missile launcher only once but for 20\nThe other path exposes the helicopter for 20 seconds also, but in\nBoth paths are equal to our cost function, Tact icalCostNodeToNode1(), which\nthe path with four brief exposures, however, this is less likely to happen.\nnodes and cost function:\nIn the cost function, we use and update the aiming information detailed in List-\nListing 3.6.4 Cost function tactical path.\n3.6 Tactical Path-Finding with A* 299\npath.\nFIGURE 3.6.3 A flawed tactical path where one long exposure is preferred over four brief\nBoth paths feature the same amount of exposure to hostile fire—20 seconds.\nIn the bottom path, the exposure consists of one interval\nFor both paths, aiming by the threat (gray bars) starts as soon as the\npath is exposed.\nAs soon as the path is no longer exposed, the aiming decreases (gray\nThe threat might predict the movement on the covered path for a while, but the\nFor the top path, the total amount of ‘aiming’ when\nSimilarly, when the AI starts a search for a tactical path from a position already\nour A* cost function, we get tactically better paths.\nof the path is left to chance, and so is the player’s perception of the AI.\nTo obtain better tactical paths, we must anticipate the enemy's movements.\nNote how much the path in Figure 3.6.4a depends on the initial position of\nThe path chosen is not robust against threat movement, and it ignores the\nFIGURE 3.6.4 (a) Tactical path assuming threats remain static.\n(b) A path assuming threats move\n3.6 Tactical Path-Finding with A* 301\nour tactical A* cost function.\ncount the number of hostile lines-of-fire to a given path position, rather than just dis-\nThe path-finding algorithm will prefer\nEven in the absence of known threats, there can still be tactical path-finding.\nBy introducing additional costs for visiting these locations, the paths\ngenerated by our tactical A* path-finding will try to avoid them.\nAs a point of reference, finding a tactical path with A* was about 10\ntimes more expensive than finding a shortest path for squad AI in a Quake-based\nOn the other hand, most AI movement does not require a tactical path.\nsuffices to replan a squad’s tactical path once every three seconds or so.",
      "keywords": [
        "cost function",
        "path",
        "Tactical",
        "tactical path",
        "cost",
        "Tactical Path-Finding",
        "van der Sterren",
        "William van der",
        "function",
        "aiming",
        "function tactical path",
        "finding tactical paths",
        "tactical cost function",
        "enemy",
        "node"
      ],
      "concepts": [
        "path",
        "tactical",
        "tactically",
        "aim",
        "aiming",
        "costs",
        "threats",
        "float",
        "exposure",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 25,
          "title": "",
          "score": 0.572,
          "base_score": 0.422,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "",
          "score": 0.554,
          "base_score": 0.404,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "",
          "score": 0.551,
          "base_score": 0.401,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 32,
          "title": "",
          "score": 0.539,
          "base_score": 0.389,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "",
          "score": 0.402,
          "base_score": 0.252,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "tactical",
          "path",
          "tactical path",
          "paths",
          "cost function"
        ],
        "semantic": [],
        "merged": [
          "tactical",
          "path",
          "tactical path",
          "paths",
          "cost function"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15059956701346008,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922559+00:00"
      }
    },
    {
      "chapter_number": 32,
      "title": "Segment 32 (pages 296-313)",
      "start_page": 296,
      "end_page": 313,
      "summary": "incorrect: ©\nFIGURE 3.6.5 Sector-based LOF lookup and the resulting path.\nObviously, such a small sector-based lookup table does not represent all lines-of-\nverified and tuned the path-finding with the more ‘exact’ floating-point cost func-\nPath-Finding Paradigm,” Game Programming Gems 3, Charles River Media, Inc.,\n[White02] White, Stephen, “A Fast Approach to Navigation Meshes,” Game Pro-\nThe shortest distance between these two points is a straight line.\nline isn’t appropriate when there is an obstacle blocking a direct movement between\nobstacles are obstacles that can move or be removed, such as other creatures, the\nNav Meshes\ncreature could maneuver.\nthe creature should not be allowed to pass through.\nTo describe where a creature was allowed to maneuver within an area, the artists\nmodeled a ‘nav mesh.’ The mesh was a collection of triangles, and each triangle repre-\nto represent areas where the creature could not travel within the natural boundaries.\nNote that our nav meshes were largely two-dimensional in nature and defined a\ntwo-dimensional area where a creature could travel.\nAs an example, suppose there is a clearing that we want a creature to be able to\nEach triangle in the mesh would describe a valid area\nwhere the creature is allowed to travel.\ndimensional space described by the mesh triangles, the creature could neither exit the\nA fairly simple nav mesh\nFIGURE 3.7.1 A clearing with a static obstacle.\nFIGURE 3.7.2 A clearing with a nav mesh added.\nThe triangles of the nav mesh do more than just establish an area where a creature can\nIn the case of our nav meshes, the portals were repre-\nthe creature, point B represents the desired destination of the creature, and both\npoints are within the same triangle, then we know that the creature can move directly\ntoward point B, since we already know that the creature can move anywhere within\ntriangle as the creature.\nIn this case, the creature might need to choose a direction that\nwill both keep the creature on the nav mesh and intelligently move the creature along\ncreature in a direction away from the desired destination.\na two-dimensional array that specified the portal to use to get from any triangle to any\nother triangle on the mesh.\npractice, our nav meshes rarely exceeded more than 64 triangles (one kilobyte of\nsame nav mesh, there were relatively few nav meshes overall, so the memory cost was\nFiguring out which portal to use is now extremely fast, since it is a simple table\nOnce we know the portal to use for a given triangle, we can take the desired direc-\ntion vector from point A to point B and then solve for the point on the portal that\nThe creature then moves in the direction\nIf point B is within the creature’s new triangle, then\nthe creature can move directly to point B.\nIf point B is still not within the creature's\nnew triangle, then another look-up in the table is done to determine which portal to\nThe logic repeats until the creature eventually reaches the triangle that con-\nPoint A starts the creature out located within\ntriangle 0, and point B (its destination) is located within triangle 3.\nin the same triangle as point B, a look-up in the table is done to determine which por-\ntal to use, and the returned value tells us to use the portal connecting triangle 0 to tri-\nA point is found on that portal that most closely matches the desired direction\nof point B, and the creature is moved to that point.\nThe creature is then considered to\nThis behavior is repeated until the creature enters triangle 3,\nwhich is where point B is located; and the creature can then move directly to point B.\nFIGURE 3.7.3 Navigating from A to B on a simple mesh.\nA triangle represents an area, and not a single point.\nthat the distance between a point on one triangle and a point on another triangle can\nmethod that we chose was to compute a point to represent the center of each triangle.\nIf more than one path was found between two triangles, then the algorithm\n‘ s of\n‘ \\\nsect a direct path from point A to point B.\nstruct this nav mesh, where the direct path is always taken.\nOne such complication is that as point A approaches a portal\nedge, the test for whether the vector from point A to point B intersects the portal edge\npoint was closer than some chosen epsilon distance to the portal edge.\ndirect navigation as the creature travels around winding pathways.\nRepresenting Creatures\nUsing a nav mesh, we are able to travel intelligently from one point on the mesh to\nanother point on the mesh.\nMost creatures, however, occupy more space than a single\nthe two-dimensional area of a creature on the nav mesh, where the radius of the circle\nrepresented the thickness of the creature.\ning for collision with the nav mesh or other dynamic obstacles.\nInstead of trying to adapt our nice, simple, point-to-point nav mesh logic to a\nour nav meshes to account for the radii of the creatures that may be using it.\ncles, the mesh is modeled to stay at least some radius from all obstacles.\nshows how a nav mesh might be modeled for a small creature, and Figure 3.7.8 shows\nFIGURE 3.7.7 Mesh for small creatures.\nthe same scene with a nav mesh modeled for a larger creature.\ndistance from the edges of the nav mesh to all static obstacles is greater than or equal\nto the radius of the creatures that use the nav mesh, then the creature can be repre-\nThis is an enormous optimization, since moving a point around the nav mesh is\nThe biggest problem is that different types of creatures might want to use\nthe same nav mesh, and some creatures might have significantly larger circles than\nother creatures.\nIf the nav mesh is modeled to work for the larger creatures, then the\nsmaller creatures might not be able to move very close to the static obstacles.\ntance of the nav mesh was far enough from static obstacles that the player could stand\nTo fix this undesirable behavior, we would adjust the distance of the nav mesh\ntures would overlap the static obstacles slightly, but smaller creatures would be able to\nto use when modeling a nav mesh.\nradii of the circles representing the creatures on the mesh, and the types of creatures\nFIGURE 3.7.8 Mesh for large creatures.\nUsing circles to represent creatures gave us the advantage that we could treat creatures\nas points when moving them around the nav mesh.\ntures around dynamic obstacles, such as other creatures.\nthe circles of surrounding obstacles by the radius of the creature currently being\nFor example, Figure 3.7.9 shows a creature of radius r and two dynamic\nobstacles with different radii, and Figure 3.7.10 shows how we treat the creature as a\npoint by adding its radius to the obstacles.\npoint and reduced our navigation issues to the relatively simple problem of moving a\npoint inside the bounds of a mesh while avoiding surrounding circles.\nTo navigate the point among the circles, we checked to see if the direction that we\ncreature\nFIGURE 3.7.9 Creature as circle with two circular dynamic obstacles.\nFIGURE 3.7.10 Creature simplified to a point with obstacles enlarged to\nthat more closely matched the creature’s last direction.\nOne problem we had with this approach was that the creature could occasionally\ncreature overlapped the most, and after computing the directions to avoid the other\ntion using the nav mesh and its portals.\nnav mesh.\nIf so, we clamped the movement to the nav mesh.\nThe final step of clamping movement to stay on the nav mesh was done for effi-\nOne problem was that a creature might\na creature's movement vector to be bent against the edge of the nav mesh instead of\nThe bent vector allowed the creature to continue moving, but\nwe didn’t do an additional check to see if the bent vector would cause the creature to\noverlap nearby circles; so a creature might subsequently become embedded within\nanother creature.\nSince our circle avoidance logic made creatures naturally want to\nmove away from overlaps, this usually wasn’t an issue between two moving creatures.\nWe did, however, encounter issues when a moving creature overlapped a dynamic\nAdditional Nav Mesh Thoughts\nOur nav meshes predominantly denoted two-dimensional areas where dynamic\nuse just a two-dimensional nav mesh to describe the staircase.\ntion, we had a maximum height that the creature could be from the surface of a nav\nmesh triangle in order to be considered on that triangle.\nmesh to have three-dimensionally crisscrossing triangles, as long as the triangles that\nthat it was clear which triangle a creature was using.\ncreatures to jump across certain obstacles to reach the desired final destination.\nWhen a creature crossed a portal into a gap triangle, a\nsearch found the triangle on the far side of the gap, and the creature was sent a mes-\nIn order to keep the creature\nfrom landing on top of a dynamic obstacle on the other side of the gap, the creature",
      "keywords": [
        "nav mesh",
        "creature",
        "mesh",
        "point",
        "Nav",
        "triangle",
        "obstacles",
        "Dynamic Obstacles",
        "portal",
        "Nav Meshes",
        "Navigation Meshes",
        "Artificial Intelligence",
        "path",
        "nav mesh triangle",
        "Static obstacles"
      ],
      "concepts": [
        "creatures",
        "meshes",
        "mesh",
        "path",
        "distances",
        "obstacles",
        "figuring",
        "point",
        "sectors",
        "triangles"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 25,
          "title": "",
          "score": 0.744,
          "base_score": 0.594,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "",
          "score": 0.74,
          "base_score": 0.59,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "",
          "score": 0.629,
          "base_score": 0.479,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "",
          "score": 0.54,
          "base_score": 0.39,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 31,
          "title": "",
          "score": 0.539,
          "base_score": 0.389,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "creature",
          "nav",
          "nav mesh",
          "mesh",
          "creatures"
        ],
        "semantic": [],
        "merged": [
          "creature",
          "nav",
          "nav mesh",
          "mesh",
          "creatures"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1980759631400282,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922605+00:00"
      }
    },
    {
      "chapter_number": 33,
      "title": "Segment 33 (pages 314-325)",
      "start_page": 314,
      "end_page": 325,
      "summary": "Between Path-Finding\nand Collision\nThe relationship between path-finding and the collision system is a key\nvent this from happening, character movement can be controlled by a collision sub-\nThe Collision Model for Path-Finding\nWe can often describe this collision model in terms of path-finding space and\nIn a tile- or cell-based pathfinder, path-finding space is defined by the\nFigure 3.8.1a shows a tile-based path-finding space\nbased system, the path-finding space is represented explicitly along with a set of\nFigure 3.8.1b shows what the path-finding space might look like in this case.\n(Note that this path-finding space must correspond with the set of points used, oth-\npathfinder allows the possibility of movement within the path-finding space, but it\ndoes not allow paths to cross through obstructed space.\nFIGURE 3.8.1 Path-finding space for (A) a tile-based system and (B) a points-of-\nIt is the relationship between this collision model for path-finding and the colli-\nA defined relationship between the collision model used by path-finding and collision\nThe implication is that whoever codes the path-finding system will need to\n3.8 Choosing a Relationshp Between Path-Finding and Collision 323\nThe idea behind the fault-tolerant approach is that the collision model for path-\nfinding need only roughly correspond to the actual, more-detailed collision applied to\npaths under arbitration by the collision system.\nIn Figure 3.8.2, collision takes place between a character and the obstacles drawn\nThe pathfinder approximates this with a polygonal path-finding space,\ngray line shows the direction in which the character must move to avoid collision\npath.\nThe more closely path-finding space approximates real collision, the bet-\n3.8 Choosing a Relationshp Between Path-Finding and Collision 325\ntive behaviors, we could mark that gap as blocked in our path-finding representation.\nWith this approach, we can define a relationship between collision and path-finding\nneed to guarantee that all points in path-finding space are unobstructed by collision;\ncharacter is in collision, then that orientation adds an extra dimension(s) to unob-\nFor this approach, path-finding space can be represented in fewer\ndimensions than true unobstructed space, and the boundary of path-finding space is\nFigure 3.8.4 shows how path-finding space might be constructed for this\nfor any position in path-finding space.\nWe can use a similar approach for tile-based path-finding.\nFIGURE 3.8.4 Path-finding in a subset of unobstructed space.\nBecause path-finding space is only a subset of true unobstructed space, we must\ndeal with the possibility that characters might find themselves outside of valid space.\nCharacters should never get to an invalid position by following paths returned by the\nside of path-finding space by interactions with other characters, the force of an explo-\nThe pathfinder cannot tell a character outside path-finding space how to get back\ninto path-finding space without colliding.\nOnce a character is outside of path-finding\nbehavior is to allow characters to cheat collision when moving back into path-finding\n3.8 Choosing a Relationshp Between Path-Finding and Collision 327\nitself outside of path-finding space is to keep track of the last known good position.\ncan give bad results if a character moves a significant distance while outside path-finding\nposition outside path-finding space for which there is no last-known good position.\nclosest point inside path-finding space to a given point outside that space.\nallowed to cheat collision, then the result is that a character gets through a wall and\nFor the case where characters are allowed to cheat collision while returning to\npath-finding space, the backbones provide a way for us to enforce constraints about\nIf we do implement path-finding around backbones, then this will also be use-\nCharacter Collision\nprovide character collision.\nThis approach guarantees that characters cannot be\npushed out of path-finding space and, therefore, that the pathfinder will always be\nable to understand a character’s current position (and that paths returned by the\nThere are other advantages to using simplified character collision.\nThe collision\nCharacters might still need to deal with target positions outside path-finding\nIf behavior is implemented in terms of movement through path-finding space\nMovement through path-finding space will often\nered architecture, a path-finding collision layer deals with this part of character move-\n3.8 Choosing a Relationshp Between Path-Finding and Collision 329\nWorld collision can take responsibility for extra dimensions of the character's\ncharacter) if those dimensions are not relevant to the pathfinder’s collision model.\nhave to be careful when applying world collision to character orientation.\nwith the ability of a character to move along a path; so for these types of events, we\ncan allow world collision to affect movement through path-finding space.\npath-finding space by the interaction, so we know that the character will be able to get\na 3D interaction might be fed back into the path-finding collision layer.\ncollision\nFor the second and third approaches, we assume that a character moving along a path\nwill not leave path-finding space.\napproach number three, these problems can result in a character being blocked by\npath-finding collision and unable to move along the path.\nalong the edges of path-finding space will help in many cases, but not all.\npoints along a path.\nnal boundary of path-finding space, as shown in Figure 3.8.8a.\n3.8 Choosing a Relationshp Between Path-Finding and Collision 331\nThe relationship between AI, path-finding, and collision is a key issue for movement-\nfinding and collision.\nPath-finding in a subset of truly unobstructed space gives reliable behavior most\nof the time at the cost of requiring some minimal linkage between the path-finding\nSince characters can still get outside path-finding space, we\nbehavior with this approach if we allow characters to cheat collision in certain cir-\nUsing the pathfinder itself to control character collision results in the simplest",
      "keywords": [
        "path-finding space",
        "Collision",
        "Path-Finding",
        "character",
        "space",
        "collision system",
        "Character Collision",
        "path",
        "pathfinder",
        "path-finding collision",
        "movement",
        "Collision Model",
        "approach",
        "character movement",
        "system"
      ],
      "concepts": [
        "collision",
        "collisions",
        "path",
        "space",
        "approaches",
        "approach",
        "world",
        "behaviors",
        "points",
        "position"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 25,
          "title": "",
          "score": 0.75,
          "base_score": 0.6,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "",
          "score": 0.719,
          "base_score": 0.569,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 32,
          "title": "",
          "score": 0.629,
          "base_score": 0.479,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "",
          "score": 0.571,
          "base_score": 0.421,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 31,
          "title": "",
          "score": 0.554,
          "base_score": 0.404,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "path finding",
          "path",
          "collision",
          "finding",
          "finding space"
        ],
        "semantic": [],
        "merged": [
          "path finding",
          "path",
          "collision",
          "finding",
          "finding space"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19555829105444034,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922665+00:00"
      }
    },
    {
      "chapter_number": 34,
      "title": "Segment 34 (pages 326-336)",
      "start_page": 326,
      "end_page": 336,
      "summary": "uppose that a scene contains two polygons that share a common edge as shown in\nWhen two such polygons belong to the same object, the vertices\nboth polygons reference the same vertices to save space and bus bandwidth.\nfor the endpoints of shared edges, the rasterizer produces pixels for each polygon that\ntheir own copy of the endpoint vertices for the shared edge.\nThese vertices might\nFIGURE 4.1.1 (A) Adjacent polygons sharing a common edge.\nIn such a situation, a vertex belonging to one polygon lies within the interior of an\njunction elimination adds vertices to existing polygons (that are not necessarily con-\nany other immovable objects possessing a vertex that lies within an edge of object A.\nWe treat both objects as collections of polygons having the\ntices lie very close to any of object X’s vertices.\ning to both objects into world space and search for vertices separated by a distance less\nAny vertex V, of object A that is this close to a vertex Vy\nof object X should be moved so that V, and Vy have the exact same world-space coor-\nX that lie within a small distance € of an edge of object A, but which do not lie within\nthe distance € of any vertex of object A.\nand P, be endpoints of an edge of object A, and let Q be a vertex of object X.\nthe edge of object A, but we still need to determine whether Q actually lies between\nIf t > lr, - P|| — €, then the point Q does not lie within the interior of the edge\nshould be added to the polygon of object A between P, and P,, precisely at Q’s\neliminated for a single polygon, its edges might contain several vertices that fall in a\nsearch for a set of three consecutive vertices for which the corresponding triangle is\npolygon’s remaining vertices.\nthe three vertices.\nIf the cross-product (P, — P,) x (P3 — P,) points in the same direc-\nOur third requirement is that the triangle contains no other vertices belonging to\nthe polygon.\nN, = N, x(P, -B)\nN, = N, x(P; — Py)\nN, = N, x(P, - Py) (4.1.5)\nAs shown in Figure 4.1.3, a point Q lies inside the triangle formed by P,, P,, and\nSince we have to calculate the normals given by Equation 4.1.5 for each triangle,\nThis determines whether the point P; lies on the positive side of the edge con-\neach of the three edges of the triangle.\nSoo NAAT RAPIER REAR RR ER RRR NTIS\noNTHECD —_ four consecutive vertices and, at each iteration, determines whether valid triangles can\nof three vertices forms a valid triangle, then that triangle is omitted, and the algorithm\nneither set of three vertices provides a valid triangle, the working set of four vertices is\ncannot locate a set of three consecutive vertices that form a valid triangle.\npolygons may contain three or more collinear vertices.\nof heightfield meshes to significantly optimize vertex normal calculation.\nmals and vertex normals.\nFace Normals\nCalculating face normals is relatively straightforward.\nshare a common vertex and define two vectors (v, and v2) pointing along the edges\nThe face normal (m;) is a unit vector pointing in\nVertex Normals\nVertex normals are a little less straightforward.\nfor a given face, a given vertex might have multiple normals, each associated with a\ntypical for heightfields), we can find a reasonably unique vertex normal by averaging\nthe normals of each face that touches the vertex.\nFIGURE 4.2.1 Calculating a face normal for a triangle.\nLet {72), 7, 3...2,} be the normals of the faces touching vertex v, and let {a), a,\n4;...a,} be the angles between the edges of faces 1 through n.\nThe normal at vertex v is given by Equation 4.2.2, as shown in Figure 4.2.2.\nFIGURE 4.2.2 Calculating a vertex normal using face normals,\nFor a given vertex v in the heightfield, we can arrange\nthe neighboring vertices as shown in Figure 4.2.3.\nFIGURE 4.2.3 Heightfield vertex neighbors.\nassumptions that simplify the general vertex normal formula.\nheight values diverge significantly, the local vertices no longer have unique normals;\nthe neighboring vertices will all have x and y values of 1, -1, or 0.",
      "keywords": [
        "Artificial Intelligence",
        "vertices",
        "vertex",
        "normals",
        "object",
        "T-Junction Elimination",
        "triangle",
        "polygons",
        "vertex normal",
        "edge",
        "adjacent polygons",
        "Face normals",
        "T-Junction",
        "face"
      ],
      "concepts": [
        "vertex",
        "normal",
        "normalized",
        "vertices",
        "polygons",
        "triangles",
        "face",
        "graphics",
        "calculate",
        "calculation"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "",
          "score": 0.59,
          "base_score": 0.44,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 25,
          "title": "",
          "score": 0.577,
          "base_score": 0.427,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "",
          "score": 0.571,
          "base_score": 0.421,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 32,
          "title": "",
          "score": 0.54,
          "base_score": 0.39,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 37,
          "title": "",
          "score": 0.525,
          "base_score": 0.525,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "vertices",
          "vertex",
          "normals",
          "triangle",
          "edge"
        ],
        "semantic": [],
        "merged": [
          "vertices",
          "vertex",
          "normals",
          "triangle",
          "edge"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2093388726600174,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922718+00:00"
      }
    },
    {
      "chapter_number": 35,
      "title": "Segment 35 (pages 337-346)",
      "start_page": 337,
      "end_page": 346,
      "summary": "kinds of applications, the speed of vertex normal calculation is probably not an issue,\nFast Patch Normals\nFor that, you need the normal vector at each vertex.\nThese patches are represented by 16 control points\nOnly the four corner control points actually lie on the surface.\nA surface normal (hereafter referred to as “normal”) is a unit vector that lies per-\nwe regard the patch as a 4 X 4 grid of control points, then the u value represents the\nThe actual-world position of a (u, v) point depends entirely on the control\nhere would be inappropriate, since this method of generating normals is applicable to\nThe most obvious approach to generating a patch vertex normal involves examining\nbors, it still needs a cross-product and a normalize operation per vertex.\nIn order to efficiently process a patch on current PC graphics hardware, you must use\ntarget is to have the vertex stream just contain the patch (#, v) coordinates for each\nThese two methods presume that we only know the position at each control point,\nfrom which we can generate the curve equations and, ultimately, the normals.\nwe also have the normals at each control point to start with?\nThese are easily generated at each control point using a variety of methods,\nA control point would then consist\nAny skinning code applied to a control point’s position\nnormal across the patch, just as we do the position.\ndinates of the current vertex to correctly generate its position, normal, and texture\nexactly the same code as the position generation, just using control normals instead of\ncontrol points.\n4.3 Fast Patch Normals 351\nAnother advantage of this method is that by generating the normals in different ways,\nvertex normals for each control point exactly as we would for a Gouraud-shaded\nIf the normals are generated in this way, we eliminate curve-\nA Bézier curve has the property that the control points form a bounding mesh that\nthan the modulus of the control mesh normals.\nthan or equal to the modulus of the control normal.\nnormal difference across the patch is not too large, meaning that the interpolation is\nstrategic use of most modern graphic cards’ ability to automatically normalize nor-\nBy treating the normal at each control point as a second con-\ntrol mesh, we can quickly approximate the correct surface normal.\n“sss eA LL RR RS NAOT TNE ES HORAN AN RSE NN IRE ERRORS RRR\nThere are several classes of algorithms to determine which primitives\nBack-face culling algorithms determine those primitives\nThis gem describes two occlusion culling algorithms that are practical, effective,\n(PLP) algorithm, which is an approximate algorithm that determines, for a given bud-\nget, a set of primitives that is likely to be visible.\nservative version of PLP that guarantees finding all visible primitives.\nSome algorithms compute visibility from the eye-point only, while others compute\nthe from-region algorithms amortize the cost of visibility computations over a num-\ninstance, most from-region algorithms require a preprocessing step to divide the\nmodel into regions and compute region visibility.\nSome algorithms compute visibility in object space using the exact, original 3D prim-\nFew visibility algorithms compute exact visibility.\nand over-estimate the set of visible primitives.\nPLP [Klosowski00] is an approximate, from-point, object-space visibility algorithm\nditional algorithm recursively traverses the model hierarchy from the root node down\nThis PLP algorithm differs from the traditional one in several ways.\nof traversing the model hierarchy in a predefined order, PLP keeps the hierarchy of\nWhen we visit a node (or project it, in PLP parlance), we add it to\nond, instead of traversing the entire hierarchy, PLP works on a budget, stopping\nthe traversal after a certain number of primitives have been added to the visible\nFinally, PLP requires each node to know not only its children, but also all of its\nAn implementation of PLP can be simple or sophisticated, depending on the\nIn this gem, we use an extremely simple heuristic to assign priorities\nThe node containing the eye-point receives priority —1, its neighbors\nthe traversal proceeds in layers of nodes around the eye-point.\nWe use PLP as a front-end to the hardware’s implementation of the z-buffer algo-\nFor a given budget, PLP gives us the set of primitives it considers\nThe C++ implementation of PLP can be found on the CD-ROM.\nAlthough PLP is, in practice, quite accurate for most frames, it does mot guarantee\npotential problem, we use cPLP [Klosowski01], a conservative extension of PLP.\nThe main idea of cPLP is to use the visible set given by PLP as an initial guess,\nwhile adding nodes to the visible set until the front (of the priority queue) is empty.\nPLP and cPLP are attractive visibility algorithms for several reasons:\n¢ PLP and cPLP are from-point algorithms, and they make no assumption about\n¢ PLP and cPLP require little preprocessing.\n¢ Although occlusion culling algorithms such as PLP avoid rendering unseen\ndetail, the number of visible primitives in a given frame might overwhelm a low-\nThe PLP budget gives the user a convenient way to balance\nPLP is most useful when higher frame rates are more important than absolute\nshould allow the user to switch back and forth between PLP and cPLP on the fly.\nFor PLP, the average frame rate was 10.1 Hz, with 75% of the tests having a\nthe rates for PLP, the image is guaranteed to be 100% correct.\nracy of PLP by counting the number of incorrect pixels in the images it generated ver-\nThe average accuracy for PLP was 96.3%; and for\nFIGURE 4.4.1 Using the prioritized-layered projection algorithm (PLP) to walk through\ncomputer with Nvidia GeForce2 graphics, PLP achieves an average frame rate of 10.1\nPLP and cPLP are practical solutions to the ubiquitous visibility problem.\nWith PLP there is no guarantee of image",
      "keywords": [
        "PLP",
        "control points",
        "normal",
        "vertex",
        "Fast Patch Normals",
        "control",
        "algorithms",
        "occlusion culling algorithms",
        "Patch",
        "eacnaeeneoReR ENERO Conclusion",
        "patch vertex normal",
        "primitives",
        "culling algorithms",
        "vertex normal",
        "cPLP"
      ],
      "concepts": [
        "normals",
        "normalized",
        "normalize",
        "algorithms",
        "graphics",
        "points",
        "patch",
        "patches",
        "visible",
        "visibility"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 43,
          "title": "",
          "score": 0.646,
          "base_score": 0.496,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 41,
          "title": "",
          "score": 0.599,
          "base_score": 0.449,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 36,
          "title": "",
          "score": 0.553,
          "base_score": 0.403,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 49,
          "title": "",
          "score": 0.527,
          "base_score": 0.377,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "",
          "score": 0.51,
          "base_score": 0.36,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "plp",
          "control",
          "algorithms",
          "patch",
          "primitives"
        ],
        "semantic": [],
        "merged": [
          "plp",
          "control",
          "algorithms",
          "patch",
          "primitives"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.17797821995921184,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922767+00:00"
      }
    },
    {
      "chapter_number": 36,
      "title": "Segment 36 (pages 347-355)",
      "start_page": 347,
      "end_page": 355,
      "summary": "Triangle Strips _\nTriangle Strip Creation,\ngem focuses on how to generate triangle strips from arbitrary 3D polygonal models.\ndescribing the triangle strip algorithm, we will explain the benefits of triangle strips,\nIn addition, several other triangle strip creation algorithms will be\nA triangle strip (tri-strip) is a series of connected triangles.\nthe triangles.\nFigure 4.5.1 shows a simple triangle strip with shared edges V,V3 and\nthe same smoothing group and material group as the other triangles in the tri-strip.\ngle strips, this gives them a tremendous advantage over a pure triangle graphics API\nthat by using triangle strips and vertex indexing, it is possible to bring the vertex-to-\nFIGURE 4.5.1 (A).A simple triangle strip with shared edges V,V; and V3V,.\nordering of the triangles in the tri-strip alternate between clockwise and counterclockwise\nTriangle strip creation has four goals:\n4.5 Triangle Strip Creation, Optimizations, and Rendering 361\nIt is also better to have several isolated triangles (tri-strips of three vertices) than\na few tri-strips of four vertices because you can batch the isolated triangles into an\nDepending on how the triangle strips are submitted\nTriangle strips can also give you an advantage with vertex\nTriangle Strip Creatio\nThere are several triangle strip creation algorithms in the research space, but each\noptimize tri-strips within patches, whereas [Hoppe99] uses a cache-friendly triangle\nThe approach we chose is to optimize the length of the triangle strip\nSince it is impossible to have the perfect triangle stripping of a mesh for any situ-\nedge is the edge of a triangle within the strip onto which new triangles can be added.\nadded to the triangle strip.\ndoes not align with the neighboring triangle to be added to the strip.\nFIGURE 4.5.2 The various stages in which triangles can be added to a triangle strip.\nactive edge borders the new triangle, F can just be added to the end of the tri-strip.\nreordering the first face of a triangle strip to match the second face is crucial to minimize\nIf the triangle strip started as CAB, then B and C would have to be\nCABBCD is the new triangle strip.\n4.5 Triangle Strip Creation, Optimizations, and Rendering 363\nThe preprocess stage is used to create metrics for generating quality triangle strips.\ntriangle.\nstarting point for the triangle strip algorithm.\nOnce we have the preprocess stage complete, we can start generating triangle strips.\nEach time a triangle of the mesh is added to a tri-strip, mark the triangle invalid.\nOtherwise, end the triangle strip\nwith a swap in order to continue creating the triangle strip (see Figure\n6. Check to see if any remaining triangles are not included in a tri-strip.\n// Generate the triangle strips\n// the previous triangle strips can be connected\nOnce the creation algorithm is finished, the output will be N triangle strips.\nConnecting Triangle Strips\nAs a second pass, the triangle strips can be analyzed to see if there are any points at\nstarting edges and ending edges of each triangle strip along with the face index\nof all of the other triangle strips to see if a match occurs.\nMost cases will require some number of vertex repetitions to merge the triangle strips.\nmatching triangle strip.\nSince the goal of developing triangle strips is to increase performance, optimizations\nare a key part of any triangle strip generation algorithm.\ninto several areas of the triangle strip development process: preprocess, generation,\n4.5 Triangle Strip Creation, Optimizations, and Rendering 365\nThis will limit the length of a triangle strip.\n¢ Sort triangle strips via material groups before submitting them to the graphics\nMost graphics APIs have support for rendering triangle strips.\nple of formats you can choose from when submitting triangle strips to the graphics\nOne format requires sending the vertex data for each vertex in the triangle strip.\nmultiple triangle strips.\nAnother format requires submitting the triangle strips via an\ntriangle strip vertex indices into the vertex pool.\nthat they only allow one triangle strip submission per API call.\nsubmit dummy vertices to allow the submission of multiple triangle strips.\nder99] and [Microsoft00] both list the API submission calls for triangle strips.\nCache-Friendly Triangle Strips\nAnother triangle strip creation algorithm creates triangle strips that are cache friendly\nthe triangle strips that were created at the higher resolution by breaking them up and\nwould be to create a set of triangle strips for every resolution of the model.\nwould be to create the triangle strips on the fly and store them in memory until the\nto a triangle strip that neighbored its current active edge or required a swap.\nneighbors existed, then the triangle strip would be ended.",
      "keywords": [
        "Triangle Strips",
        "Triangle",
        "Triangle Strip Creation",
        "Computer Graphics Proceedings",
        "Strips",
        "Computer Graphics",
        "triangle strip algorithm",
        "Graphics",
        "Strip Creation",
        "Graphics Proceedings",
        "vertex",
        "triangle strip vertex",
        "rendering triangle strips",
        "triangle graphics API",
        "simple triangle strip"
      ],
      "concepts": [
        "triangle",
        "vertex",
        "strips",
        "stripping",
        "graphics",
        "rendering",
        "optimizations",
        "optimize",
        "optimal",
        "optimizing"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 42,
          "title": "",
          "score": 0.652,
          "base_score": 0.502,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 41,
          "title": "",
          "score": 0.589,
          "base_score": 0.439,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 35,
          "title": "",
          "score": 0.553,
          "base_score": 0.403,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 37,
          "title": "",
          "score": 0.519,
          "base_score": 0.369,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 49,
          "title": "",
          "score": 0.486,
          "base_score": 0.336,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "triangle",
          "strip",
          "triangle strip",
          "strips",
          "triangle strips"
        ],
        "semantic": [],
        "merged": [
          "triangle",
          "strip",
          "triangle strip",
          "strips",
          "triangle strips"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21480535847666038,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922830+00:00"
      }
    },
    {
      "chapter_number": 37,
      "title": "Segment 37 (pages 356-366)",
      "start_page": 356,
      "end_page": 366,
      "summary": "Starting with all the front-facing polygons that lie in\npolygon’s closest vertex will suffice.\nWe call these polygons the “input array.” We also need an\nNow we perform a series of operations on each of the polygons in the input array.\nFirst, create a beam (a small frustum) from the light source and the polygon.\nposition and each edge of the polygon.\noverlapping polygons), there may be polygons remaining in the output array that\nis created with just the current input polygon, and it is clipped using the beams of\nThe remaining polygons (in the temporary array) are copied\nAfter processing each input polygon, we need to run an optimization algorithm\non the output polygon array to reduce the amount of polygon splitting.\nFIGURE 4.6.1 Ax illustration of beam construction and output polygon culling.\npolygon.\nThe output polygons are then clipped against this beam.\nFIGURE 4.6.2 Dealing with obstructing output polygons.\n(black) beam polygon.\n(B) The light-gray polygon, which is in the output array, is clipped\nthe currently selected (black) polygon, a recursive step is taken to create a beam frustum\nping to beam frustums can create excessive numbers of sliver polygons.\nthis, all subpolygons created from an original input polygon are collapsed into the\nit unnecessary to optimize across the original polygon boundaries at every iteration.\nOptimizing in groups based on the original input polygons does everything that is\nThere are two algorithms that can be utilized to optimize the polygonal mesh.\nwhich vertex should be removed or which edge collapsed.\nNext, build an edge table for all of the edges in this mesh.\nvertex\nFIGURE 4.6.3 Removing a vertex.\ntex in the mesh, choose a starting triangle that contains that vertex, and use the edge\nthat vertex.\nEdge Collapse\nAn example of collapsing an edge is illustrated in Figure 4.6.4.\ntex, and use the edge table to walk clockwise around the vertex to neighboring trian-\nNote that keeping track of the original edges of the input triangles might also\nreduce the computation time for the edge collapse.\nFIGURE 4.6.4 Collapsing an edge by removing a shared vertex.\nAtherton, “Hidden Surface Removal Using Polygon Area\nSubdivision Schemes\nSubdivision schemes use a mask to define a set of vertices and corresponding\ndivided into edge, crease, and normal masks.\nThe masks are applied to each vertex in\nFIGURE 4.7.2 Butterfly interpolating subdivision surface for four iterations.\nHowever, when dealing with edges and noncontinuous surfaces, special masks\nThe mask for this scheme is given by Equation 4.7.1 (see Figure\nFIGURE 4.7.3 Loop subdivision mask.\nFIGURE 4.7.4 Butterfly subdivision mask.\nHierarchical Half-Edge Mesh\nA half-edge data structure can be created for each level of subdivision.\nhalf-edge data structure uses a vertex, an edge, and a face structure to make up the\nstruct edge\nedge *p_next;\nedge vertex starts */\nother half of edge */\nnext edge in face */\nprevious edge in face */\nface edge is part of */\nvertex that starts edge */\nan edge in the face */\nA half edge is an\nedge that is split between two neighboring faces.\nEach edge points to its next and pre-\n(Actually, the original half-edge data structure did not have a pointer to a\nof, as well as the vertex starting the edge (see the previous code).\nEach edge need only\nEach vertex points to the edge it starts, and each face points to\none of the edges that make up the face (see Figure 4.7.5).\nFIGURE 4.7.5 Half-edge mesh.\nthe half edge associated with that vertex.\nhalf edge references the first connected vertex.\ninitial edge, then all connected vertices will have been found (see Figure 4.7.6).\nEven if the half-edge data structure is not used directly within the sub-\nThe half-edge data structure is also perfect for\ndetection (e.g., more than two faces sharing an edge).\nhave an edge shared between more than two faces without undergoing",
      "keywords": [
        "edge",
        "vertex",
        "polygon",
        "Subdivision",
        "Subdivision Surfaces",
        "Original",
        "mesh",
        "output array",
        "beam",
        "array",
        "schemes",
        "Surfaces",
        "face",
        "data structure",
        "Shadow Volumes"
      ],
      "concepts": [
        "edge",
        "polygonal",
        "polygons",
        "vertex",
        "schemes",
        "figures",
        "subdivision",
        "surface",
        "method",
        "point"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 41,
          "title": "",
          "score": 0.534,
          "base_score": 0.384,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "",
          "score": 0.525,
          "base_score": 0.525,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 36,
          "title": "",
          "score": 0.519,
          "base_score": 0.369,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 42,
          "title": "",
          "score": 0.483,
          "base_score": 0.333,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 44,
          "title": "",
          "score": 0.469,
          "base_score": 0.319,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "edge",
          "polygon",
          "half edge",
          "vertex",
          "half"
        ],
        "semantic": [],
        "merged": [
          "edge",
          "polygon",
          "half edge",
          "vertex",
          "half"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1695846309565597,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922895+00:00"
      }
    },
    {
      "chapter_number": 38,
      "title": "Segment 38 (pages 367-374)",
      "start_page": 367,
      "end_page": 374,
      "summary": "When animating a character, a bone hierarchy is often needed.\nThe bone hierarchy is\nAs the hierarchy is descended, each node and its vertices are transformed by\nFortunately, when using subdivision surfaces for character\nanimation, we only need to transform the control points of the mesh to alter\nVertex weighting introduces complications to the task of transforming the vertices.\nused as the vertex buffer for the subdivision scheme.\nNow the subdivision mesh\nadded advantage, the subdivision surface and skinning procedures are now separated\nWhen using many subdivision surfaces together, it is important to reduce the overall\nusing subdivision surfaces, we know that child faces have similar properties to their\nIt is also used to reduce the number of subdivision faces that need to be\nprocessed, since we avoid the subdivision of hidden surfaces.\nAnother optimization method is lazy spatial subdivision, which uses the subdivision\nthe subdivision is only performed on those faces.\nEach subdivision mesh is contained in a bounding box.\neach face is tagged with the frame number each time its visibility is determined.\nthe number of faces that have to be tested against the frustum.\ncan cull out faces where subdivision is unnecessary and only subdivide those that are\nFor small meshes, it is preferable to use the view frustum directly for\nculling visible faces.\nThis data is then used to reduce the number of child faces produced by\nsubdivision or to cull out any faces before they are sent down the rendering pipeline.\nspeed up the display and generation of subdivision surfaces.\nPrecomputed Face Vertex Indices\nPrecomputation of the face vertex indices is very useful when it comes time to display\na face in the subdivision surface.\nfaces prior to using the subdivision surface.\nThe face index array looks like:\nPrecomputed Weights and Vertex Indices\nPrecomputation of the weights and vertex indices is used for the generation of even\nBasically, a set of weights (w;) and indices (v,) for each vertex (2) in\nsubdivision scheme.\nThus, eight vertex indices and weights are stored, as well\nweight-and-index array looks like:\n4.7 Subdivision Surfaces for Character Animation — 381\nare stored in a single array, whose size grows to accommodate the number of vertices\nOn the final pass, the vertices and faces are dumped into a geometry array,\nArrays are used to store the data for subdivision surfaces.\nthe graphics API in the form of vertex arrays.\nArrays tend to use less memory because pointers do not need\naccumulation buffer for skinning, the face indices and other reference data need not\nThe visibility culling is only performed on the original mesh to save time, since it is an\nneed to know in advance how many levels of subdivision are required.\nthe support areas required by the subdivision schemes overlap, producing a depen-\nuse a lazy evaluation method that generates faces as they are needed.\nuse the same methods to determine the extra faces needed in addition to those that are\nFIGURE 4.7.8 Support areas required by Loop and butterfly subdivision schemes.\nput into a vertex array and then rendered.\nSubdivision surfaces can be used to create very detailed characters with natural forms.\nfor subdivision schemes.\nHowever, these subdivision methods don’t provide an easy means to reduce\nuse subdivision to increase detail, and use progressive meshes to reduce it.\nSubdivision\nsurfaces also reduce the number of transformation operations necessary to perform\n4.7 Subdivision Surfaces for Character Animation 7 a ; 383\nskinning, as only the initial mesh needs to be modified.\nsubdivision surfaces is possible.\nthan the vertices of the mesh.\n[Dyn90] Dyn, Nira, et al., “A Butterfly Subdivision Scheme for Surface Interpolation\n[Loop87] Loop, Charles, “Smooth Subdivision Surfaces Based on Triangles,” Master’s\n[Zorin96] Zorin, Denis, et al., “Interpolating Subdivision for Meshes with Arbitrary\nStoring a full set of vertex positions for every frame of animation is\nBy transforming each vertex of a mesh through multiple matrices instead of just\nsmoothly deform these meshes to any position and play back the results at any frame\nThe motion of the bones away from the reference pose is used to deform the mesh to\nAs we pass each vertex in the elbow through each of the two transforms,",
      "keywords": [
        "subdivision surfaces",
        "subdivision",
        "HEE OEE",
        "faces",
        "subdivision schemes",
        "vertices",
        "Face Vertex Indices",
        "Vertex",
        "surfaces",
        "mesh",
        "Graphics",
        "Vertex Indices",
        "Computer Graphics Proceedings",
        "teaetcecnenE H HEE",
        "Smooth Subdivision Surfaces"
      ],
      "concepts": [
        "faces",
        "mesh",
        "meshes",
        "method",
        "bones",
        "array",
        "weighted",
        "visibility",
        "visible",
        "visibilities"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 20,
          "title": "",
          "score": 0.596,
          "base_score": 0.446,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "",
          "score": 0.517,
          "base_score": 0.367,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "",
          "score": 0.495,
          "base_score": 0.345,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 40,
          "title": "",
          "score": 0.486,
          "base_score": 0.336,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 39,
          "title": "",
          "score": 0.474,
          "base_score": 0.324,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "subdivision",
          "surfaces",
          "subdivision surfaces",
          "faces",
          "vertex"
        ],
        "semantic": [],
        "merged": [
          "subdivision",
          "surfaces",
          "subdivision surfaces",
          "faces",
          "vertex"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21391807506942123,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.922956+00:00"
      }
    },
    {
      "chapter_number": 39,
      "title": "Segment 39 (pages 375-382)",
      "start_page": 375,
      "end_page": 382,
      "summary": "Adding the Bones\nlarge angles over several smaller bones conveniently placed at the joints.\nthe joint and the length of the child bone:\nThe bones\ntwo points, take a weighted average to find the center for the desired link.\nweighting goes linearly from 100% of the point on BC at either the first or last link to\n4.8 Improved Deformation of Bones\nFIGURE 4.8.3 (A) A small chain of bones added to the joint.\nThe instantiation and weighting of the links only need to occur once.\nMost of the weights around a bone-linked joint will need to be reassigned.\nweights should transition smoothly from the original parent to the first link, then\nalong to each element in the chain, and finally to the original child bone.\nchild bone, it is sufficient to use the longitudinal (x) position to find which two bones\nto attach to (including the new link bones).\nber line, with the parent bone as zero and the original child as (number_of_links+2),\nand use the fractional part to determine the weights.\ntion scales to 2.3 in ‘bone link space,’ the new weights will be 70% for the second link\nbone and 30% for the third link bone.\nparticular link chain is to only reassign a fair fraction of the parent’s influence and\nleave the remainder of the influence for other bones to consider.\nupper arm, but it is also well anchored to one or more spinal bones.\nbones between the clavicle and upper arm, we don’t want to reassign the portion that\nTo determine this fair fraction, all the weights are found for the particular vertex\nthese competitor weights, we determine the fraction as:\nThe weight to be reassigned is then:\n4.8 Improved Deformation of Bones 389\nchild entry, which has now been entirely reassigned, and then add a new weight entry\nFigure 4.8.4a shows a shoulder joint with reassigned weights.\nwhich of the given links the vertices are weighted to.\nof the weights or any weights to other bones, like the spine.\nconnects the clavicle bone to the upper arm.\nFIGURE 4.8.4 New weighting with three added links (A) for a shoulder mesh (B).\ncenter of each bone that the vertex is influenced by.\ntake the dot product of a vertex’s normal with respect to the longitudinal bone axis.\nFrom this result, we subtract the x displacement of the vertex along the bone, divided\nadded to the parent’s weight.\ndecision to make is whether to process the weights in a ‘bone-major’ or ‘vertex-major’\nFor the bone-major method, you have to first clear all the vertex positions and\nthe weights for a vertex are clumped together, we can accumulate the results in a local\nwrite per weight per vertex.\nEvery bone in the skeleton has a transform, including the added bone links.\nto store vertex offsets relative to each bone.\nSince the vertex weights will usually be a larger data structure than the matrix array or\neven the mesh, it is important to keep the weight list small in order to reduce the\nmatrix array and the fractional weight.\nNote that storing the vertex position and normal in the weight list means that we\nvertex weights.\ndistribution, and add bone links.\nRRR RRR ERR RR ROR ES ENR ARMAS ERE RENT NR NHS PO RRA I RIRRRALNRRA OBEN SEA BIE MTORO\n4.8 Improved Deformation of Bones",
      "keywords": [
        "bone",
        "Weights",
        "vertex",
        "link",
        "child bone",
        "link bone",
        "added bone links",
        "joint",
        "mesh",
        "vertex weights",
        "original vertex weights",
        "bone link space",
        "weight list"
      ],
      "concepts": [
        "bones",
        "weighted",
        "vertex",
        "links",
        "deformation",
        "influences",
        "influenced",
        "improved",
        "improvements",
        "improve"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 20,
          "title": "",
          "score": 0.699,
          "base_score": 0.549,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 40,
          "title": "",
          "score": 0.493,
          "base_score": 0.343,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 38,
          "title": "",
          "score": 0.474,
          "base_score": 0.324,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "",
          "score": 0.379,
          "base_score": 0.229,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 29,
          "title": "",
          "score": 0.365,
          "base_score": 0.215,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "bone",
          "weights",
          "bones",
          "vertex",
          "link"
        ],
        "semantic": [],
        "merged": [
          "bone",
          "weights",
          "bones",
          "vertex",
          "link"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.11051445935543638,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923005+00:00"
      }
    },
    {
      "chapter_number": 40,
      "title": "Segment 40 (pages 383-392)",
      "start_page": 383,
      "end_page": 392,
      "summary": "We can ensure smooth transition between animations with a tweening modifier.\nmodifier calculates the in-between (or tween) positions in animation poses.\nsolve the problem of arbitrary targets for locomotion by modifying the translation\nof these modifiers will result in foot-sliding.\nthis idea to the problem of realistic character animation by using independent modi-\nFIGURE 4.9.1 A character with fixed animations attempting to move to arbitrary points and angles.\npoint toward the target with one or two rotation animations.\nThe character in Figure 4.9.1 has an animation for starting to walk, a walk cycle\nIn this case, the character only has one turn animation.\nPlaying the animation once\nthe situation by providing more animations for a character to choose from, but the\nWe can solve this problem by modifying the translational or rotational offsets for ani-\nIn Figure 4.9.2, the closest set of animations in length is chosen\npoint of the animations to the target is split across the animations and applied as a\nmodification to each animation.\nFIGURE 4.9.2 Plan and modify movement to arbitrary targets.\nIn order to modify the translational or rotational result of an animation, we sim-\nply apply an offset to the position or orientation of the character origin with a\nmotion-captured animation, we need to transition smoothly between captures that\nnext until we must play that animation.\napproach to the problem is to modify the start of each animation to be the same as the\nanimation.\n(B) State of skeleton at start of following animation.\nmodification later in an animation causes problems at a foot.\nend of the previous animation, and then ease out this modification as the animation\nThe character in Figure 4.9.3a shows the state of the skeleton at the end of the\nprevious animation.\nanimation.\nsition back to the original position as the second animation plays.\nis applied to the skeleton later on in the animation.\nthat will be applied by our modifier to the left leg.\nin a ‘correct’ position for the skeleton when applied to the first frame of animation\nlater on in the animation results in the foot hovering above the floor.\nbetween the foot and the floor over a period of animation depends on a combination\nApplying a modifier to the rotation\nonce again, while we have an approach for transitioning between two animations, the\nBy modifying an animation slightly as it is played, we can solve some problems in\nnately, most animations will have at least one foot on the floor most of the way\nthrough the animation.\nwe can ease out each modifier over different sections of the animation.\nify an animation without introducing foot-sliding, we use a separate modifier for each\nFor a walk animation in which the left foot moves first, followed by the right foot,\nwe ease out the left-leg modifier while the left foot is moving forward, then we wait\nuntil the right foot starts to move before easing out the right-leg modifier.\ntwo-step animation with the corresponding movement profile for each foot.\nFIGURE 4.9.4 A two-step animation with corresponding movement profile ford the 1 fet\nIf a foot does not move at all during the animation, or if there is insufficient total\nto allow some foot-sliding for that animation or allow the modifier to remain at the\nend of the animation without being eased out completely.\nFor the problem of locomotion to an arbitrary target, we need the animation to be\ncharacter origin, we already bring the feet and legs to the correct position by the end\nof the animation.\ntween ratio controls a global offset applied to the character origin.\nA modifier is then applied at each leg to correct the difference\nHalfway through the animation, the global tween ratio is 0.5; the\nto be modified by 0.5 and the right leg by —0.5.\nskeleton at different points in a two-step animation.\nthe same effect as the global modifier, when the modifier is applied with a positive\ncharacter origin is at the hips, then a rotational modifier can simply rotate the leg by\nA translational modifier for a L foot needs to apply an offset to the position of that foot\nstraints correctly throughout the animation, but there are some problems with this\nThe most important constraint for consistent animation is that the modifier\nthe position of the leg in the original animation conforms to the constraints of our IK\neach point in the leg that corresponds better to the original animation.\nRRR REREAD HERE ORR ORI RARER CARER THS REARS DARREN MSE AES\nWe can apply the same framework for transitions between animations.\nrate modifie ach leg, we can eliminate problems resulting from changing the\nHowever, applying a modifier to\nthe angles of the legs while the character origin is moving will still cause problems at\nthe animation plays).\nthe foot at the end of the previous animation.\nsoon as the foot starts moving, the modifier can be eased out.\nend of the previous animation, but it does not do anything about the rest of the leg.\nlation to the leg as before, but with the anchored modifier applied to the result of that\nget the chance to ease out modifiers on both legs while the animation is playing.\nsition modifiers enable us to generalize the technique also to single-step animations.\nAny modifiers not eased out by the end of an animation will be dealt with by modi-\nlection of moving-on-the-spot animations to avoid characters standing completely\nIf these animations include moving the feet slightly, then this gives the ani-\nSequences of animations over which a given foot does not move at all can\nIn order to solve problems in character locomotion, we often need to modify anima-\nUnfortunately, modifying animation can break the interface between the foot",
      "keywords": [
        "animation",
        "Realistic Character Locomotion",
        "Character",
        "foot",
        "Character Locomotion",
        "modifier",
        "animations",
        "realistic character",
        "leg",
        "realistic character animation",
        "position",
        "Character Locomotion Thomas",
        "problem",
        "feet",
        "Locomotion"
      ],
      "concepts": [
        "animation",
        "animations",
        "modifier",
        "modifying",
        "modified",
        "character",
        "problem",
        "foot",
        "applying",
        "applies"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 20,
          "title": "",
          "score": 0.618,
          "base_score": 0.468,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "",
          "score": 0.534,
          "base_score": 0.384,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 39,
          "title": "",
          "score": 0.493,
          "base_score": 0.343,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 38,
          "title": "",
          "score": 0.486,
          "base_score": 0.336,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "",
          "score": 0.482,
          "base_score": 0.332,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "animation",
          "foot",
          "modifier",
          "animations",
          "leg"
        ],
        "semantic": [],
        "merged": [
          "animation",
          "foot",
          "modifier",
          "animations",
          "leg"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.16120798386765617,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923054+00:00"
      }
    },
    {
      "chapter_number": 41,
      "title": "Segment 41 (pages 393-400)",
      "start_page": 393,
      "end_page": 400,
      "summary": "ammable Vertex Shader\nShader Compiler\nhis gem discusses the implementation of a compiler for programmable vertex\nretarget the front end of our compiler to a new code generator for the new instruction\nThis allows shaders written in a high-level language to be compiled to the shader\nAlso, by writing a shader in a high-level, C-like language, it is easier for us to read and\nThe CD-ROM includes a full implementation of a simple vertex shader com-\npilers and an example that compiles the OpenGL lighting equation into a DirectX\nvertex shader!\nA vertex shader is a program that takes the standard lighting equation parameters, such\nlight parameters are sent to the vertex shader through a set of constant registers that\nwidely used vertex shader implementation, DirectX8, has 96 constant registers, 12\ntemporary registers, and 16 vertex registers [Microsoft00] (see Figure 4.10.1).\noutput of this program (the final vertex properties) are loaded into a set of output reg-\n4.10 Programmable Vertex Shader Compiler\nVertex Registers\nVertex Program -!\nOutput Registers\nThere are 16 registers for vertex data, 96\n128 instructions per vertex program.\nvertex shader, are passed to the pixel shader for final display.\nAll registers are four-\nAs previously mentioned, the vertex shader program utilizes a set of assembly\nput registers.\nListing 4.10.1 A cartoon vertex shader in vertex shader assembly\nvN is a vertex register\nSymbol Table—Contains keywords and variables used in the program.\nsymbols, out of the characters that are passed to the scanner.\nto the parser and adds new variables to the symbol table.\nAbstract Syntax Tree (AST)—Each time the parser accepts a statement, it adds it\nThe syntax tree is passed from the parser to the code generator.\nCode Generator—Walks the AST and emits code for the vertex shader based on\n4.10 Programmable Vertex Shader Compiler 407\nFIGURE 4.10.2 We start with a high-level program that is passed to our compiler.\nwe use our scanner and parser to determine whether we have a valid program.\nthis process, we also build a syntax tree and a symbol table.\nThe code generator walks the syntax tree and emits a valid vertex shader\nVertex\nThe compiler is broken up into seven components: the language, scanner, parser,\nabstract syntax tree, symbol table, temporary register set, and code generation.\nSince vertex shaders do not currently support looping or branching, we do not\nues that we would like to utilize in our vertex shader.\nstant register set.\ncompiler agree on which register this value resides in.\nFor example, in our compiler,\napplication must put the light direction into this register for the shader, or the shader\nTable 4.10.1 Keywords Used in Vertex Shading Language\nare part of the output register set in DirectX8.\nstored by looking up LightDiro in the symbol table and returning the register index\nour vertex shader.\nWe recognize the list of tokens in the symbol table, as well as vari-\nThe CD-ROM contains an example in the directory for this gem, (see scanner.l).\nLex is used to build the actual C program that is then compiled to build the scanner.\n4.10 Programmable Vertex Shader Compiler 409\nThe parser works in conjunction with the scanner to accept or reject a program.\nWhile the scanner recognizes tokens, or symbols, the parser accepts or rejects sets of\nsymbols, or statements.\nsymbols, and the semicolon at the end of the statement.\nnized as a set of symbols because it matches one of the statements in the language.\nprogram is complete, and we are not left with only the start symbol on the stack, then\nexample grammar file, yaccer.c, the start symbol is Program.\nThe grammar is the set of statements the parser will recognize.\nIn other words, if the set of symbols on the stack with\nthe most-recently recognized symbol (or token) matches this statement, then take the\nthe context of the vertex shader compiler.\nSymbol Table\nThe symbol table stores symbols that are used in the compiler.\nized with all of the keywords and symbols used in the language.\nparses the program, new variables are added to the symbol table.\nIf the symbol already\n4.10 Programmable Vertex Shader Compiler ; ;\nsents the symbol in the scanner.\n’ component of the four-component register once the symbol has been assigned to a register.\nAn example symbol table is contained in the file CSymbol-\nTemporary Register Set\nFigure 4.10.1 showed that there is a set of temporary registers that we use as our work-\nThe code generator contains the heart of the compiler.\nTo see the results, compile the example vertex shader compiler with the shader on the",
      "keywords": [
        "Vertex Shader Compiler",
        "Vertex Shader",
        "Programmable Vertex Shader",
        "Vertex",
        "Shader",
        "Symbol Table",
        "Shader Compiler",
        "register",
        "Compiler",
        "Programmable Vertex",
        "vertex shader program",
        "vertex shader assembly",
        "Symbol",
        "Shader Compiler Adam",
        "temporary register set"
      ],
      "concepts": [
        "registers",
        "compiler",
        "compiles",
        "vertex",
        "symbol",
        "program",
        "scanner",
        "type",
        "lighting",
        "sections"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "",
          "score": 0.617,
          "base_score": 0.467,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 35,
          "title": "",
          "score": 0.599,
          "base_score": 0.449,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 36,
          "title": "",
          "score": 0.589,
          "base_score": 0.439,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 49,
          "title": "",
          "score": 0.561,
          "base_score": 0.411,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 44,
          "title": "",
          "score": 0.553,
          "base_score": 0.403,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "shader",
          "vertex",
          "vertex shader",
          "symbol",
          "compiler"
        ],
        "semantic": [],
        "merged": [
          "shader",
          "vertex",
          "vertex shader",
          "symbol",
          "compiler"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23134433687176428,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923172+00:00"
      }
    },
    {
      "chapter_number": 42,
      "title": "Segment 42 (pages 401-412)",
      "start_page": 401,
      "end_page": 412,
      "summary": "[Lake01] Lake, Adam, “Cartoon Rendering Using Texture Mapping and Programma-\nBillboard Beams\nSeveral methods are available for creating a beam effect, each of which has its own\nThe rest of this gem describes in detail the positioning and texture\nmapping of the triangles to create the illusion of a three-dimensional beam.\nHowever, for a beam, the billboard matrices should be oriented along\nimportance when considering texture mapping.\nFigure 4.11.2 shows the two main texture mapping alternatives that allow for triangle\nVertices V, to V¢ are matched up with the corresponding texture coor-\nHowever, the texture\nspace left is broken into two triangles that might be hard to use for other textures.\nsecond method, presented in Figure 4.11.2b, is more efficient in its use of texture\nFIGURE 4.11.2 Example texture layout with texture coordinates.\ncepts may also be useful in other 3D engines as a replacement for flat billboard sprites\nConsider an isometric game engine where each game object is created in some 3D\nwill call “cells.” Each cell is represented in the game by a single 2D image.\ncell (see the projected texture created in Figure 4.12.1).\nan orthogonal camera, rendering the game world is a matter of figuring out which cells\nder these depth-enabled images in a 3D setting.\nmon way to draw 2D images within a 3D system is through the use of billboards.\nThese are flat pieces of geometry onto which the individual cell images are texture-\nIf one billboard is used for each of the game cell images, and the scene is ren-\nTexture\nFIGURE 4.12.1 An orthogonal projection of the original cell contents creates both the\ntexture image and per-pixel depth information, stored as shades of gray in the alpha\ntexture must be recorded.\ntextured with a slice of the cell volume, so that together they approximate the original\nin a cell group can be mapped with a single texture containing depth information for\nthe cell within the alpha channel of the texture.\nFIGURE 4.12.2 An exploded view of mutltiple-depth slices, texture-mapped on stacked\ning, individual depth layers of the cell texture can be drawn on each billboard.\ntexture (see Figure 4.12.2).\nUsing a subtraction operation within the texture stage, this value is subtracted\nfrom the alpha channel of the texture sample.\nensures that only those portions of the texture that have a depth value higher than the\nSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE) ;\nSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE) ;\nOnly one height value is used per pixel to define the image volume, giv-\nobject, giving us two values per pixel: one to define the depth value at the front of the\nThis is created in the same manner as our current depth texture using a camera\nmation in the second texture.\nMethod 2: Warping Textures\nWhile not the fastest method for representing a cell’s contents on a billboard, proce-\nthey suffer from is a preprocessing step to warp the billboard texture each time the\nand requires a discrete texture for each cell, it is only useful for unique objects in the\nsters, can get a strong sense of depth from relief textures.\nThe idea is based on the fact that the texture contains per-pixel depth\nGiven a camera position, each pixel in the texture can be off-\nset to a new position on the texture, given its original texture position and depth\nThe resulting texture, created after all pixels have been offset, describes the cell\ndepth value { view vector\nFIGURE 4.12.3 Viewed from above, this diagram shows the reprojection of a pixel onto\nlocation on the billboard and the depth information encoded into the texture’ alpha\nIn the sample code provided, only the u offset is performed during the texture warp.\ncreated in the image (locations to which no pixels have been offset), and occlusion\nTo handle occlusion, the texture must be processed in the direction of the pixel\nexample, if the billboard is located on the camera's left side, the pixels will be offset to\npixels closer to the camera (toward the right of the image) overwrite those further\nIf the billboard is to the right of the camera, the opposite is true, and the texture\ndles the camera's view vector, the texture must be processed in both directions,\nHoles are created when two adjacent pixels in the original texture map to two\nThe final result yields a texture that is properly warped for the given viewing\nThis texture can then be mapped directly on the billboard for display.\nMethod 3: Vertically Interlaced Textures\nThe final method presented here builds off of the relief textures used earlier.\nbetween prewarped versions of our texture can be performed during rendering.\nThink of the texture mapped across the billboard as a sheet of paper riddled with\nWhat the relief textures do, in a\nIn this final method, a texture is created that contains four views of the cell con-\nUsing a pixel shader and a second utility texture, the\nrelief texture method, without the need for a procedural texture warp.\na horizontal sample set of four pixels, one for each viewing angle.\nu coordinate to the desired viewing angle within that set, using the texbem instruc-\nThe result is a per-pixel blend between two of our four viewing angles, packed\ninto the texture.\nThe first step of the shader uses the utility texture mentioned earlier.\nThis texture\nFIGURE 4.12.4 The interlaced texture is created by sampling identical pixel locations in\nthe source textures and organizing them into sample sets of four pixels each.\nthe sample set in the second texture.\nThis texture should be the same width as the\ninterlaced texture and is filled with the value (w*4) for every pixel on the w-axis.\nbillboard is given texture coordinates along u from 0.00 through 0.25, then the utility\ntexture will convert the incoming value to the range [0.0, 1.0] in steps that are equiv-\nalent to a four-pixel span within the interlaced texture.\nThe second step is to offset this value to select the desired pixel within the sample\nfour_pixel_span value is the width, in texture space, of four pixels.\nto the desired sample within, resulting in a per-pixel blend of the two closest camera\nWhile no billboard method can fully replace a complex 3D model, these techniques",
      "keywords": [
        "Texture",
        "Billboard",
        "cell",
        "depth",
        "Intel Labs Graphics",
        "beam",
        "pixel",
        "relief textures",
        "method",
        "Graphics",
        "camera",
        "Texture Mapping",
        "vector",
        "image",
        "depth information"
      ],
      "concepts": [
        "texture",
        "textured",
        "billboard",
        "pixels",
        "depth",
        "methods",
        "mapping",
        "map",
        "maps",
        "beams"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 45,
          "title": "",
          "score": 0.658,
          "base_score": 0.508,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 36,
          "title": "",
          "score": 0.652,
          "base_score": 0.502,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 47,
          "title": "",
          "score": 0.649,
          "base_score": 0.499,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 46,
          "title": "",
          "score": 0.59,
          "base_score": 0.44,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 49,
          "title": "",
          "score": 0.559,
          "base_score": 0.409,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "texture",
          "billboard",
          "depth",
          "pixel",
          "cell"
        ],
        "semantic": [],
        "merged": [
          "texture",
          "billboard",
          "depth",
          "pixel",
          "cell"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19719140960376913,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923236+00:00"
      }
    },
    {
      "chapter_number": 43,
      "title": "Segment 43 (pages 413-421)",
      "start_page": 413,
      "end_page": 421,
      "summary": "Normal Maps\nmon way to simulate curvature using low-detail models.\nface to simulate the curvature of a denser model by using bump mapping.\nFIGURE 4.13.1 Result of the bump-mapping process.\noriginal model, and two examples of the final result using bump mapping.\n4. 130 Curvation Simulation Using Normal Maps 425\nNormal Maps\nfied as an RGB color), which is called a normal map.\nBy modulating the lighting across the low-resolution model surface, we will\nThe low-resolution model does not need to be a simplified version of the\nlution mesh into a normal map.\nnal model while taking into account that our low-resolution mesh has a curvature of\nThis curvature is defined by the normals on the dense model, so we need to\ncapture those normals and store them into a map.\nAt runtime, the generated texture will perturb the normal for each point on the\nmake the surface seem like the original object at that point (note that our normal map\n¢ Rasterizing each polygon into the map (using the uv coordinates of each vertex).\n¢ Normals at each vertex, which are smooth across the model.\nFor the low-resolution model:\nThe tangent-space bases are needed to transform the computed normals into tex-\nknow how to map the low-resolution mesh map to the texture.\nThe first and easiest way is to use the normal of the current face (closest-point).\nClosest-Point Normal-Shooting\nlow resolution model\nFIGURE 4.13.2 Rays traced using closest-point and normal-shooting.\n4.13 Curvation Simulation Using Normal Maps\nwith the dense model, the normal at that point is computed using the barycentric\nlower-resolution mesh, shoot a ray along the interpolated normal and obtain the\nintersection point in a triangle of the high-resolution model.\nbarycentric coordinates so we can interpolate the normal of the high-resolution mesh\nNow we must store it into the normal map.\nFIGURE 4.13.4 The captured normal (H) is converted to texture space (H’).\nneeded to use the captured normal (see Figure 4.13.4).\n(Equation 4.13.6), which is a transformation from model space into texture space.\nAfter computing the normal rr map, it will still have many empty regions.\nWe solve this by filling the normal map with a light blue color—RGB (127,\n4.13 Curvation Simulation Using Normal Maps 429\nmapping that computes the lighting in texture space.\nture space allows us to change the geometry and still use the same normal map.\nThe problem is that due to the uv mapping, the tangent space bases are not\nDoing the lighting in model space completely avoids the problem; although\nlow-resolution model\nit has a counterpart: If the normals were defined in model space, we would need\nIt is interesting to talk about other approaches for computing the normal map, par-\nMoreover, the original model was already uv mapped, or it was added using some\nmodels for each texel, since they have common vertices (the same 4 coordinate and v\nThis scheme can be simplified if we do not transform the normals into texture\nSince this is exactly the same as drawing the normals of the dense model\ndirectly to the normal map, we can implement this scheme using 3D hardware raster-\nThis is very useful if we are able to uv map the model.\nmodels share vertices (and their properties, like uv coordinates).\nAfter generating the normal map, we can still add hand-made bumps for small\nModeling such details in a dense mesh\ngenerated normal map with simple normal-map combiner code; only a perturbation\nof the normal stored in the texture is needed.\n4.13 Curvation Simulation Using Normal Maps 431",
      "keywords": [
        "normal map",
        "Normal",
        "model",
        "Normal Maps Oscar",
        "map",
        "Maps Oscar Blasco",
        "Normal Maps Bump",
        "dense model",
        "low-resolution model",
        "space",
        "low-resolution mesh",
        "mesh",
        "texture space",
        "texture",
        "low-resolution model FIGURE"
      ],
      "concepts": [
        "normal",
        "maps",
        "mapping",
        "map",
        "models",
        "space",
        "point",
        "textures",
        "way",
        "ways"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 49,
          "title": "",
          "score": 0.734,
          "base_score": 0.584,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 35,
          "title": "",
          "score": 0.646,
          "base_score": 0.496,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "",
          "score": 0.638,
          "base_score": 0.488,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 45,
          "title": "",
          "score": 0.634,
          "base_score": 0.484,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 44,
          "title": "",
          "score": 0.595,
          "base_score": 0.445,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "normal",
          "model",
          "low resolution",
          "map",
          "normal map"
        ],
        "semantic": [],
        "merged": [
          "normal",
          "model",
          "low resolution",
          "map",
          "normal map"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.14819389616427128,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923288+00:00"
      }
    },
    {
      "chapter_number": 44,
      "title": "Segment 44 (pages 422-430)",
      "start_page": 422,
      "end_page": 430,
      "summary": "Photorealistic Terrain Lighting\nically based lighting solutions for terrain under dynamic lighting conditions.\nlight is radiance, or light flux along a ray.\nalize a small square (area A) centered on the light ray and perpendicular to it (see Fig-\nFIGURE 4.14.1 (A-B) Radiance area A along a light ray and patch Aon the radiance sphere.\nWe can measure the flux per area at the intersection point p (M = d® / dA, or power\n4.14.1b, we see a sphere (radius R) centered on p, and a small patch (area A’) on this\nIf we use an area that is at an angle to the ray (e.g., when\nmost hardware limits us to a small range of light values.\ndent radiance at p from —V, and dQ is the differential solid angle used for integration.\nance multiplied by the color C(p) divided by m:\n4.14 Methods for Dynamic, Photorealistic Terrain Lighting © 435\npoints on a heightfield terrain (at a finite resolution) under changing lighting condi-\nSince the terrain is Lambertian, and we assume that C(p) is known, this is\nother terrain points are visible.\nNow, the directions in which other terrain points are visible pose a difficult prob-\nknow the outgoing radiance for other terrain points.\nproblems, in which case two techniques must be used and the resulting radiances\nSome of these solutions involve calculating light values on the CPU and upload-\nSunlight: Horizon Angles,\nNNN EG : aR\ntions to this subproblem ignore light reflected from other terrain points.\nWithout inter-reflections, the sun’s contribution to the irradiance at p is\nwhere S is the set of directions that point at the sun.\nSince the sun’s solid angle, @,,,,\nwhere V,,,, is the direction to the sun’s center and O,,,(p) the percentage of the sun\nbetween terrain points, are the dot product and the occlusion factor.\ncost of calculating the dot product, we quantized the normals of all the terrain points\nAnother possibility is to use a normal map and dot3 texture blending in hardware.\nbased on storing the horizon angles for each point in a given set of directions (see Fig-\nis in shadow or not is simply a matter of comparing the angle of the sun to the horizon\nIf the sun angle @ is below the horizon angle g, the point is in\nshadow (0O,,,,(p) = 0).\nWe have had good results with storing the horizon angles\ning them in 8-bit texture channels and performing the calculations in a pixel shader.\nThis will help when calculating horizon angles.\nquite long shadows when the sun is at oblique angles.\nalways be clamped to H(p), or errors will result (see Figure 4.14.2b.).\n4.14 Methods for Dynamic, Photorealistic Terrain Lighting 437\nFIGURE 4.14.2 (A) Terrain profile showing sun angle ® and horizon angle @.\nHorizon angles must be clamped to H(p).\ntage over horizon angles is that it can handle arbitrary sun positions.\nof the terrain using a radiosity package, with the sun at several different positions.\nsun does not need to move in an arc through the zenith as it does in horizon mapping,\nUse a sun color of\npossible to use PTMs to get the full lighting solution.\nall we need to do is calculate the lighting for our terrain with a sky radiance equal to\nRGB(I,1,1), and then store the result in a RGB texture.\ntexture with the current RGB sky radiance to get the desired result.\ntexture will be relatively subtle, since it will result from inter-reflections with the col-\nthe skylight texture is to use a radiosity package, with the terrain and a hemispherical\npoints in the scene that have a similar radiance value.\nin H(p), where another terrain point is visible, L;(p, -V) = L,(p).\n4.14 Methods for Dynamic, Photorealistic Terrain Lighting 439\nform using horizon angles to determine which directions are covered by terrain.\nformulation uses any number of horizon angles.\nyou are already calculating horizon angles for sunlight shadows, there is no reason not\ncraters) by recalculating the skylight texture in the affected area and a small distance\nexample, the sky could be divided into NV patches, and N skylight textures could be\ncalculated, each one based on the terrain being illuminated only by the relevant patch.\nAt runtime, each of the skylight textures is modulated by the radiance of the relevant\nClouds’ shadows are cast onto terrain through the\nocclusion of light from the sun.\ndensity with sunlight and oll the result to the sky’s light contribution\nwhere D(p) is the cloud density as aa onto the point p.\nmapping of a cloud to its shadow on the ground is a perspective projection from the sun\nonto the earth's curved terrain at an angle.\nrate assumption frequently made in the calculation of texture-mapping coordinates for\ncloud shadows is that the sun is located vertically above the terrain.\nof terrain vertices to texture coordinates using only scale and bias factors:\nchange in time of day, the sun’s angle should be taken into account in the texture-pro-\nupdating texture offsets in the direction of cloud movement.\nThe terrain’s color texture is mapped as a planar projection and is performed\n4.14 Methods for Dynamic, Photorealistic Terrain Lighting\nThe sunlight texture is mapped in the same way, but the projection is redone, as\nThe second cloud layer projection is applied to a fourth set of output texture\nmul CLOUD_SHADOW_LUM, TEX_SUNLIGHT,\nNext, a constant skylight color factor is multiplied by the terrain texture color.\nmul SKYLIGHT, TEX_TERRAIN_COLOR, CP_SKYLIGHT\nFinally, the skylight contribution is added to the shadowed sunlight factor, times\nthe terrain color.\nmad OUTPUT_REG, CLOUD _SHADOW_LUM, TEX_TERRAIN COLOR,\nFor this example, the constant sky radiance factor and sun radiance textures were\n¢ For the color texture, place the sun vertically above the terrain and disable terrain\n¢ For the skylight factor, render terrain with a gray surface with sun at an angle, and\n¢ For the sunlight texture, subtract the skylight factor from the above image.",
      "keywords": [
        "Terrain",
        "Photorealistic Terrain Lighting",
        "Horizon Angles",
        "sun",
        "terrain points",
        "texture",
        "light",
        "radiance",
        "Terrain Lighting",
        "Angles",
        "cloud",
        "Horizon",
        "Photorealistic Terrain",
        "color",
        "point"
      ],
      "concepts": [
        "lighting",
        "texture",
        "radiance",
        "terrain",
        "cloud",
        "area",
        "sun",
        "skylight",
        "angle",
        "shadow"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "",
          "score": 0.715,
          "base_score": 0.565,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 45,
          "title": "",
          "score": 0.679,
          "base_score": 0.529,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 49,
          "title": "",
          "score": 0.661,
          "base_score": 0.511,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 43,
          "title": "",
          "score": 0.595,
          "base_score": 0.445,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 41,
          "title": "",
          "score": 0.553,
          "base_score": 0.403,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "terrain",
          "sun",
          "horizon",
          "radiance",
          "texture"
        ],
        "semantic": [],
        "merged": [
          "terrain",
          "sun",
          "horizon",
          "radiance",
          "texture"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.16025288045673367,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923339+00:00"
      }
    },
    {
      "chapter_number": 45,
      "title": "Segment 45 (pages 431-439)",
      "start_page": 431,
      "end_page": 439,
      "summary": "A brute-force method for generating dynamic te terrain lighting is to render canned\nmap effect can be achieved by applying a lit video texture to the terrain at a smaller\ngenerated by rendering the shadow to a texture surface) and mapped onto the terrain.\n4.14 Methods for Dynamic, Photorealistic Terrain Lighting 443\n[Hoftman01] Hoffman, Naty, et al., “Photorealistic Terrain Lighting in Real-Time,”\n[Kautz00] Kautz, Jan, et al., “Bump Map Shadows for OpenGL Rendering,” available\n[Malzbender01] Malzbender, Tom, et al., “Polynomial Texture Maps,” Computer\n[Max88] Max, Nelson, “Horizon Mapping: Shadows for Bump-Mapped Surfaces,”\nRendering in dynamic, Low-Frequency Lighting Environments,” to appear, Pro-\nPhysical Properties of Cube Maps\nCube Map Lighting\nCc: maps were introduced to game developers in DirectX7.\nintroduced the Geforce 256 and brought cube maps to the mass PC gamer mar-\nHowever, the cube\nmap can be used in more-interesting ways.\nencode different lighting conditions as well as other properties within cube maps.\nwill give a brief overview of the properties of cube maps and how to index into them.\nCube maps are represented as six textures in hardware.\nof a cube.\ncube map.\npassed into the hardware, it would select the positive z face of the cube map, since 0.7\nOne difference between cube maps and regu-\naddressed such that the center of the cube face is uv coordinate (0, 0).\nmapping uses the upper-left corner as the (0, 0) uv coordinate.\nFIGURE 4.15.1 Hardware layout of a cube map.\nHow Get Data to/from a Cube Map\nto create a .dds cube map file is to use Microsoft's DirectX Texture Tool, which is\nThe following code demonstrates loading a cube map from\nLoading cube maps in DirectX8 can be accomplished in s\na call to D3DXCreateCubeTexture to create the cube map texture and then a call to\nGetCubeMapSurface for each face of the cube map.\nAlternatively, the texture maps can\nRendering with the Cube Map\nSetting up the 3D texture coordinates for a cube map can be done in one of several\nup rendering of cube maps:\nFLOAT fENX = m_vEyePt.x - pVIn->v.x;\nFLOAT fENY = m_vEyePt.y - pVIn->v.y;\nFLOAT fENZ = m_vEyePt.z - pVIn->v.z;\nDirectX8 introduced a new method for dealing with cube maps.\nset up by specifying texture stage states and render states, with the cube map-specific\nThis instructs the hardware to use the texture coordinates directly without\nThe vertex shader then puts the normal into the output texture coordinate\nthat corresponds to the texture stage where the cube map was selected.\n4. 15 _Cube Map Lighting Techniques 447\nEncoding cloud cover into a cube map is not as straightforward as it might at first\nular textures to tile seamlessly; however, these images cannot be loaded into cube\nThis poses a problem for cube maps, since all the edges must match in order to\nclouds into a cube map.\n// now loop through each pixel of the cube map, gathering the fBm\n// Description: returns a 3 vector given a from an x,y, face of a cube\n// map\n// Parameters: face = face of cube map to calculate vector from\n// tInfo = x,y, width and height of cube map face texture\nTo use this cube map for a sky sphere, create a sphere that is representative of the\nworld’s atmosphere and use the coordinates as lookups into the cube map.\nneed to normalize the coordinates, since the lookup into the cube map does not\n4.15 Cube Map Lighting Techniques 449\nA side benefit of encoding the clouds in a cube map is that shadows from the\na pixel shader by taking one minus the color from the original cloud cube map.\npositions for the terrain are used as indices into the cube map, and the alpha compo-\nEncodin Lights in a Cube Map\nStatic and dynamic lights can be encoded in a cube map in a number of ways.\nstatic lights, like the sun, can be prerendered into the cube map using the techniques\ndescribed to index into the cube map.\nthe cube map and retrieve the light that is rendered into the cube map.\nThe idea is to render the moving lights into the cube\nmap by using a 90° field of view and pointing the camera at each side of the cube.\nThe cube\nmaps do not have to be very big for this technique to work convincingly, so keep this\nEncoding Diffuse Lighting in a Cube Map\nDiffuse maps can also be incorporated into scenes with many lights by using the\nabove code that traversed through a cube map to build the cloud texture.\ncoordinate on a face of a cube map, a vector 7 (normal) is calculated.\nanother vector / (light) is calculated from each uv coordinate of each cube face.\nthat is used to blend the pixels of the cube map together.\nn. The cube map in Figure 4.15.2 is the result of this sampling.\nTo use this cube map\nFIGURE 4.15.2 Encoded diffuse cube map.\nEncoding of a specular map can be accomplished in much the same way as the dif-\nfuse map by following the same guidelines for traversing the cube map and sampling\nEncoding a Day/Night Cycle into the Cube Map\nDay/night cycles can also be used with the cloud cube map p by using the technique\ndescribed to create a cloud cube map and only encoding the grayscale portions of the\npixel shader as part of the lighting calculation, and, as the sun rotates, the color of the",
      "keywords": [
        "Cube Map",
        "Cube Maps",
        "Cube Map Lighting",
        "Cube",
        "een Fon ERS",
        "cloud cube map",
        "map",
        "cube map texture",
        "Fon ERS",
        "texture",
        "Graphics een Fon",
        "Map Lighting Techniques",
        "Maps",
        "cube map face",
        "Cube Map Day"
      ],
      "concepts": [
        "texture",
        "textured",
        "map",
        "mapped",
        "maps",
        "light",
        "render",
        "rendering",
        "shadows",
        "video"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "",
          "score": 0.751,
          "base_score": 0.601,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 44,
          "title": "",
          "score": 0.679,
          "base_score": 0.529,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 42,
          "title": "",
          "score": 0.658,
          "base_score": 0.508,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 49,
          "title": "",
          "score": 0.656,
          "base_score": 0.506,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 43,
          "title": "",
          "score": 0.634,
          "base_score": 0.484,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "cube",
          "cube map",
          "map",
          "maps",
          "cube maps"
        ],
        "semantic": [],
        "merged": [
          "cube",
          "cube map",
          "map",
          "maps",
          "cube maps"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18351886081336227,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923396+00:00"
      }
    },
    {
      "chapter_number": 46,
      "title": "Segment 46 (pages 440-447)",
      "start_page": 440,
      "end_page": 447,
      "summary": "Parameters and Procedures\nProcedural Texturing\nDarwyn Peachy, in Texturing & Modeling, defines procedural as a way “to dis-\nability to map a texture image onto a surface through mathematical functions.\nWhenever discussing procedural texture mapping with artists, almost invariably\nNot only can we generate unique, new textures with procedures, we can manipulate\nThe creation of a procedural texture requires two elements—a procedure that will be\nused to generate the texture and the parameters that control this procedure.\nParameters passed into generating procedures guide the outcome of the texture.\nprocedural textures.\ngenerators and processing functions to create a unique texture.\n4.16 Procedural Texturing 453\nProcedures\nThe majority of procedural effects used in games have been based on Ken Perlin’s\nNoise is the workhorse of procedural textures and the\nmost-applicable and widely used type of procedure for games.\npseudo-random numbers into sources of textures for graphic images [Macri00].\nerate dynamic, procedural clouds by summing octaves into turbulent noise.\nNoise algorithms are a direct method for the creation of a procedural texture\nAnother method for texture generation takes a texture source and evolves it\nWhen used to generate procedural textures, an initial texture is divided\ntion of the procedure, each texel in the texture is modified according to a set of rules.\nFor example, a pseudo-random noise procedure can generate\nProcedural texturing techniques have been used in a variety of computer graphics\nUses of Procedural Textures\nProcedural texturing is still in the early stages as far as prime-time game development\nHowever, procedural texturing excels at representations of natural phenomena and\ntexture.\nware, the texture can be moved over the image’s surface.\nA series of textures can be\ngenerated and then played back as an animated texture.\nThe real power of procedural textures is\nachieved when the textures are generated in real-time within the game project.\nIn addition to their use as color source material, procedural textures can be used\nprocedural texture could be used to show cracks or dents in a surface by perturbing\nthe texture space normals using a function.\nAdvantages of Procedural Textures\nThere are many advantages to using procedural textures in your game.\nAlso, procedural textures are\nence texture memory for pixel colors.\nA bark texture on\nscenes with a lot of different procedural textures will lower the frame rate.\nProcedural textures lend themselves to\nreuse, and we can use the same texture for multiple objects, like a fire procedure for all\nProcedural textures can be one-, two-, or three-dimensional.\nA procedurally\ngenerated, three-dimensional texture will allow a plane, intersecting at any angle with\nThis technique is also known as “solid texturing.” The color space incor-\nporates the use of a 3D array of color values for texturing, and the textured object is\nmon in games, and solid texturing will amplify the reality of objects in the scene.\nProcedural textures have\nGetting Procedural Textures in the Game\nThere are two basic types of procedural textures that can be used in your game: real-\nPregenerated procedural textures can be made in content\napplications such as Lightwave or Photoshop, or in a professional procedural texture\nIf you want to implement a real-time procedural system in your game engine,\ntexturing and shading.\nOther Uses for Procedural Functions\nProcedural modeling is an increasing area of interest for game designers,\nreal-time procedural textures in games without a large performance hit on the main\nThe main issue for real-time generation of procedural textures is the ability of the\ncan be used to create several source noise textures of various frequencies.\nnoise textures can then be combined by rendering them to a surface using the avail-\nBeyond this kind of direct, procedural texture creation, it is even possible to cre-\n4.16 Procedural Texturing 457\nProcedural texturing is a powerful and flexible way to g\nprocedures, noise and cellular systems, will be leading the way.\nthe use of graphics hardware to create dynamic procedural 3D textures.\ngle precomputed 3D noise texture, which is accessed multiple times using the texture\nnovel part of this technique is that the noise texture is prefiltered using a cubic filter.\nTo produce the final fractal noise pattern, we use four or more 3D texture\nlookups for the noise texture.\nWe use the texture matrix to\neffects can also be created by translating or rotating the texture coordinates of each\n(and more) in a single pass and provide much more flexible procedural texturing pos-\n[James01] James, Greg, “Operations for Hardware-Accelerated Procedural Texture",
      "keywords": [
        "TEE NAAN NUE",
        "NAAN NUE TET",
        "NUE TET CEERI",
        "ACD ETS MONEE",
        "ETS MONEE PARR",
        "MONEE PARR AEERE",
        "procedural textures",
        "texture",
        "Procedural",
        "TEE NAAN",
        "NAAN NUE",
        "NUE TET",
        "TET CEERI",
        "CEERI TN INIT",
        "INIT RNR"
      ],
      "concepts": [
        "texture",
        "textured",
        "procedures",
        "procedural",
        "noise",
        "color",
        "games",
        "generation",
        "generate",
        "generating"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 47,
          "title": "",
          "score": 0.845,
          "base_score": 0.695,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 49,
          "title": "",
          "score": 0.635,
          "base_score": 0.485,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 45,
          "title": "",
          "score": 0.596,
          "base_score": 0.446,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 42,
          "title": "",
          "score": 0.59,
          "base_score": 0.44,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 65,
          "title": "",
          "score": 0.518,
          "base_score": 0.518,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "procedural",
          "texture",
          "textures",
          "procedural textures",
          "texturing"
        ],
        "semantic": [],
        "merged": [
          "procedural",
          "texture",
          "textures",
          "procedural textures",
          "texturing"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22953258035593563,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923452+00:00"
      }
    },
    {
      "chapter_number": 47,
      "title": "Segment 47 (pages 448-455)",
      "start_page": 448,
      "end_page": 455,
      "summary": "Unique Textures\nences—wood grain, surface texture, dirt marks, scuffs, faded paint, footprints, graf-\nNevertheless, computer games reuse the same textures over and over\nsupply, and using a different texture for each surface in a scene would have caused\nWe demand higher-resolution textures, which chew memory at a prodigious rate.\nMany of these problems can be solved by generating textures in a more proce-\nof artist-generated source textures and combine them at runtime using a variety of\nblends, fractal methods, and random numbers to create the textures required for the\nProcedural Textures\ntextures allows artists to do less actual pixel-pushing, and start generating descriptions\nSmart Texture C\nBecause each surface’s texture is uniquely generated, each one can adapt to the\nThe most obvious benefit is that texture\nAt the heart of a typical graphics system is a texture cache.\nthen composite the various source textures together in cunning ways to create the\nIf you expect or find the texture cache to be relatively slow, some simple refine-\nhighest-resolution mipmap level that will be required for a given texture on an object.\nwith a source texture, composited on top of the last result with a type of blend.\never, any useful blending controlled by random numbers requires a more-complex\nrequired to composite together many alpha channels and then do a color blend using\nneeds to be an explicit way of labeling layers and blends as alpha-only to ensure that\n4.17 Unique Textures 461\nThis includes the layers representing source textures,\nthe intermediate layers, and, most importantly, the target layer—the texture that will\nbe generated by the composition and actually passed to the graphics chip to texture\nwhich allows textures to be combined to flow continuously over any surface shape.\ncases, an object cannot simply be partitioned into different materials with one texture\nOnce the composition is done and the target textures are generated, this\nblend might be biased and scaled by values held at each vertex; this way the artist can\nIn some cases, these values might need to be encoded into another texture\nrect position on the target texture.\nalpha blend, multiplicative, additive, subtractive, and so on.\nsimple Photoshop blending methods with their equivalent mathematics and alpha-\nexample, in a blend between two alpha channels with the blend factor determined by\nTable 4.17.1 Photoshop Blending Methods and the Equivalent Multipass Alpha Blend\nAlpha Blend (source, combine, destination}\n4.17 Unique Textures 463\nble, as this avoids additional temporary textures.\nAs a result of using unique texturing systems, artists require increasingly sophisticated\nways to generate numbers as blend factors or mapping transforms.\nDynamic Textures\nvariety of effects and texture variations are possible without losing batching efficiency,\nOne example when dynamic texture blends might be useful is on bump maps.\nSimply alpha-blending multiple Dot3 bump maps together does not work very well.\nis the complete heightfield turned into a Dot3 normal-map texture with a filter.\nstandard decals that simply alpha-blend into the frame buffer, this sort of compositing\nAnother use of this method is to composite multiple shadow maps together in a\nThis method would increase texture-cache\nmemory to be used more efficiently to generate higher-resolution textures only on the\nthe textures.\n* Reduce the size of source textures, using smaller mipmaps.\n* Reduce the size of target textures.\nreduces swapping of textures in and out of video memory.\nFor example, detail textures and decals can be removed or reduced without\nSome of these items can also be applied selectively to distant textures.\nSomething to be careful not to do is recompositing all textures when the scene-\nrate stall as every texture in the scene is recomposited.\nSecond, all the textures will\nposite textures when they are offscreen.\nIf a texture does need to be recomposited\nwhile onscreen for whatever reason, at least spend the time to alpha-blend between\n4.17 Unique Textures 7 465\ngraphics chip is designed to do—take several textures, apply uv transformations to\nspeed penalties when swapping source and target textures in and out of video mem-\nare powerful and fast, and most simple blends and filters will be limited by memory\nUsing the graphics chip to perform composition is trickier for PC games than for\nHowever, the graphics chip is smart and can do 90% of the filters and blends\nThere is only one source texture used, which has been colored differently according to\nThe texture is also shifted randomly at each vertex\nWhen compositing a particular texture, the terrain types for\neach of the 25 vertices on that texture are blended together.\ntexture is very quick.\nSeamless texturing using a small number of\nsource textures (just one in this case) is simple and effective.\nA smart texture cache and simple distance-based mipmap-\nping substantially reduces the amount of compositing and texture memory required.\nExtra details normally produced with detail textures, light maps,\nFinally, using a scripting language to drive the texture-composition engine gives",
      "keywords": [
        "Textures Tom Forsyth",
        "Textures",
        "Unique Textures Tom",
        "Mucky Foot",
        "Tom Forsyth",
        "blends",
        "source textures",
        "Textures Tom",
        "Unique Textures",
        "graphics",
        "graphics chip",
        "source",
        "texture cache",
        "target textures",
        "methods"
      ],
      "concepts": [
        "textures",
        "blends",
        "layers",
        "memory",
        "mapped",
        "maps",
        "map",
        "source",
        "methods",
        "artists"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 46,
          "title": "",
          "score": 0.845,
          "base_score": 0.695,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 42,
          "title": "",
          "score": 0.649,
          "base_score": 0.499,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 49,
          "title": "",
          "score": 0.598,
          "base_score": 0.448,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 45,
          "title": "",
          "score": 0.572,
          "base_score": 0.422,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 43,
          "title": "",
          "score": 0.506,
          "base_score": 0.356,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "textures",
          "texture",
          "blend",
          "alpha",
          "unique textures"
        ],
        "semantic": [],
        "merged": [
          "textures",
          "texture",
          "blend",
          "alpha",
          "unique textures"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20610678341421862,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923509+00:00"
      }
    },
    {
      "chapter_number": 48,
      "title": "Segment 48 (pages 456-465)",
      "start_page": 456,
      "end_page": 465,
      "summary": "for Per-Pixel Lighting\nuse texture maps as a means to solve functions through a lookup table, focusing on\nlighting computations.\nSpecular Per-Pixel Lighting Without Using a Cube\nAn alternative to using normalization cube maps followed by a 1D specular\ntexture fetch is to use an 2.4/h.h map as a lookup table in your shader.\nthe normalization cube map is still used to normalize tangent space light vector, /.\n¢ Fetch 7 (per-pixel normal) from the normal map (bump map).\n¢ Halfway vector (H) is stored as a 3D texture coordinate and interpolated across\nFIGURE 4.18.1 n.h/h.h Map (k = 32).\nmap that allows for per-pixel specular lighting with a specular exponent of 32.\n* Using this 2D texture coordinate, fetch into the n.4/h.4 map.\nfetched is the specular lighting term raised to some constant power &.\nn. hl h.h mapping:\n4.18 Textures as Lookup Tables for Per-Pixel Lighting Computations 469\nPer-Pixel Specular Exponent Using an (n.h)}* Map\ntexld r0O, tO ;normal map n\ndp3_sat r3.r, rO_bx2, r2 ;(n.h)\n3(n.h)/(h.n)*k map lookup\n3(specular * color) + (basemap * light)\nunique specular exponent on a per-pixel basis.\n(n.h)* texture, is also required.\nFetch x (per-pixel normal) from the normal map (bump map).\nHalfway vector (H) is stored as a 3D texture coordinate and interpolated across\nA projective, dependant texture fetch is required into the (7.4)* map.\nThe texel fetched with these coordinates is the specular lighting\nJust like the .4/h.4 map, the n.4* map is used to reduce the amount of math you\nThis projective divide causes the resulting texture lookup coordinates to be:\nFor n.h* mapping, the texture lookup table computes the following function:\nular lighting on a per-pixel basis.\nThe specular exponent varies per-pixel as defined by\nrally generated (n.4)* map that allows for per-pixel specular lighting with a per-pixel\nFIGURE 4.18.2 An RGB texture of a tiled surface without any lighting.\n4.18 Textures as Lookup Tables for Per-Pixel Lighting Computations\nFIGURE 4.18.3 A procedurally generated (n.h} (k=[0,64]) map that allows for per-\npixel specular lighting with a unique specular exponent specified at each pixel.\ntexture from figure 4.18.3 to obtain artist-editable per-pixel specular exponents.\ndp3_sat r3.r, rO_bx2, r2 ;(n.h)\n;Attenuated (n.h)*k map\nAnother rendering effect using texture lookup tables is color-shift iridescence.\ndard Phong lighting and then multiplies the specular highlight color by a texel\nfetched from a 1D, hue-based gradient texture addressed by (n.v), where 7 is the per-\npixel shader performs the color-shift iridescence.\n4. 18 Textures as Lookup Tables fe for Per-Pixel Lighting Computations © 473\ndp3_sat r4.r, rO_bx2, r5_bx2 ;(n.v)\ndp3_sat r3.r, rO_bx2, r2 ;(n.h)\n;Attenuated (n.h)*k map\nPer-Pixel Point Lights with Correct\nAnother useful application for texture lookup functions i is correct per-pixel light\nComputing distance falloff for point lights is traditionally sampled at the\nThe vertex shader computes the vertex position in normalized light space (NLS)\nFIGURE 4.18.5 1D point light texture that renders light color and intensity change as a function of\ndistance from the point light source.\nThe pixel shader then computes the distance\nThen, a 1D texture is sampled using the NLS distance squared\nPer-Pixel Spotlights and Directional Lights with\nA natural extension of the per-pixel point light attenuation is to model spotlights and\ntexture for the light, a 2D texture is required.\ndistance squared in the same way as a point light.\nTo use this 2D texture, we extend the notion of normalized light space to repre-\nIn the vertex shader, similar to point lights, the vertex position is transformed\ninto normalized light space.\nNLS distance squared (exactly like point lights, above).\nThese two dot product values are then used as a lookup into a 2D texture, which\n4.18 Textures as Lookup Tables for Per-Pixel Lighting Computations 475\nIf we simply do a dp3 as written below, the 2D texture map represents values\nmodifiers, the 2D texture can represent other frustum angles.\nBy using the scale factors for the frustum angle, the y resolution of the texture\n;distance squared from light\n;Base* light\ndirectional light frustum.\nFIGURE 4.18.6 2D spot/directional light texture that renders how, along one axis, light\ncolor and intensity changes as a function of distance from the light source.\nrenders how the light changes as a function of angle from the light vector.\nORTLAND TASS ANI SHARIN RAEI RRR HITTITE ERP RE ICS LAT OL ANA RTS AN AR UMARINE\nBoyd, “DirectX 8.0 Shader Applications (Per Pixel Light-\nMicrosoft.com, “DirectX 8.1 Pixel Shader Reference,” avail-",
      "keywords": [
        "map",
        "texture",
        "cube map lookup",
        "light",
        "Specular",
        "texture lookup table",
        "map lookup",
        "Per-Pixel",
        "ATI Research Alex",
        "texture coordinate",
        "Per-Pixel Lighting Computations",
        "specular exponent",
        "cube map",
        "texture lookup",
        "Lookup"
      ],
      "concepts": [
        "lighting",
        "textures",
        "pixel",
        "map",
        "mapping",
        "specular",
        "base",
        "based",
        "tables",
        "normalization"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 45,
          "title": "",
          "score": 0.751,
          "base_score": 0.601,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 44,
          "title": "",
          "score": 0.715,
          "base_score": 0.565,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 49,
          "title": "",
          "score": 0.681,
          "base_score": 0.531,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 43,
          "title": "",
          "score": 0.638,
          "base_score": 0.488,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 41,
          "title": "",
          "score": 0.617,
          "base_score": 0.467,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "pixel",
          "texture",
          "specular",
          "light",
          "lookup"
        ],
        "semantic": [],
        "merged": [
          "pixel",
          "texture",
          "specular",
          "light",
          "lookup"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.16505537417361735,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923565+00:00"
      }
    },
    {
      "chapter_number": 49,
      "title": "Segment 49 (pages 466-476)",
      "start_page": 466,
      "end_page": 476,
      "summary": "Shading Models\nand more-realistic shading models for graphics hardware [Heidrich99, Kautz99],\nWe propose to use a simple technique called normal distribution\nfunction (NDF) shading.\n\\t allows an artist to handcraft shading models, with the\ning models can also be created.\nA shading model determines how much light reflects off a surface, depending on the\nSo far, most-interactive rendering systems use the Blinn-Phong [Blinn77] model,\nThe parameter &, is the diffuse coefficient, usually stored in a color texture map;\nFor anisotropic shading, which is used to render\nShading Models\nA few methods have been proposed that can incorporate better shading models [Hei-\nMicrofacet-Based Shading Models\nShading models that are based on microfacets (see [Cook81]) assume that the surface\nbased shading models use the distribution of the microfacet normals 7 ,,.\nFIGURE 4.19.1 A surface consisting of tiny microfacets and its normal distribution\n419 Rendering with Handcrafted Shading Models 479\nwith a normal x,, that is equal to the halfway vector 4 between the light and view\nThe specular part of the Blinn-Phong model can be seen as a simple microfacet-\nbased shading model.\nThe shading model that we want to use is just a slight modification of the original\nBlinn-Phong model:\ntion, we use an arbitrary normal distribution function.\nHow can we store the normal distribution function so that it can be used with graph-\nFigure 4.19.1 ilkustrates an example of a normal distribution function that was\nSo, how do we render an object with this new shading model?\ntexture by storing a normal distribution function, then we need to do the following to\nGenerating the NDF Texture\nSo how do we create such an NDF texture?\nWe now will suggest how to use the diffuse term and the new specular NDF term to\ngenerate interesting shading models.\nPhong model) is desired, then the NDF texture should probably be grayscale, so that\nIn contrast to the normal diffuse term, the directional diffuse term\ndirectional diffuse NDF plus a red diffuse term.\n4.19 Rendering with Handcrafted Shading Models 481\nNDF shading can be easily incorporated with bump mapping, as long as you have\nPhong model, only you have to compute the texture coordinates, #, and w,, with the\ntexld r2, r2 ; NDF is in texture unit 2\nThe shading model could be extended with a Fresnel term and a (so-called) self-\nThis makes a big difference in the shading, especially if a directional diffuse term\nobject in an intuitive way by just painting a highlight and/or a directional diffuse term\nSee Color Plate 19 for an example of NDF shading applied to the\nphysical explanation behind this shading technique, it does not accurately model any\nshading model is fascinating.\nTorrance, “A Reflectance Model for Computer Graphics,”\ning and Lighting,” Computer Graphics Proceedings (SIGGRAPH 1999): pp.\n4.19 Rendering with Handcrafted Shading Models 483\nultiplayer real-time strategy games have different networking requirements than\nthe coordination of real-time strategy games.\nUnder this method, the clients send out an update every\ncentral server that processes it and echoes the results to all clients.\nsuch frame-locked games render more than one frame before sending an update; but\nAs long as all clients are send-\nHowever, if one client’s update\nwaiting for the delayed client's input, the game would immediately be out of synchro-\nfirst update at time 0, Clients A and B send their updates to the server.\n5.1 Minimizing Latency in Real-Time Strategy Games 489\nTime ClientA Server Client B\nFIGURE 5.1.1 Freezing under frame-locking: Server and Client A are held up by Client B,\nThe server waits, and so does Client A.\nUnder this method, each client sends requests for events, which are evaluated\nby the server and, if approved, broadcast to all clients simultaneously.\nFor example, imagine a typical real-time strategy game in which one player\nIf legal, the client sends a\npacket to all clients, including the one that originally made the request.\nNote that not all clients will receive the event packets at the same time.\nevents must be structured so that clients can begin execution at the appropriate time.\nA client that receives\nment requests, it could be safe to start ‘unofficial’ movement on the client if server\nThere will be cases when the server rejects a client’s request or sends a path differ-\ning a RequestMoveTank, Client B requested the construction of a building near the tank.\nClient A might create a path that rolls the tank to the north and begins the movement\nClient A receives the correct path, it must warp the tank from the unofficial path to\nThe fact that some units might be in unofficial positions on a given client means\nreal-time strategy games, one of the client machines is also the server.\nbetween the client and server.\n6.1 Minimizing Latency in Reai-Time Strategy Games 491\nTime ClientA Server Client B\n// even if this client also happens\nNote that all clients send\n// requests, even the client who also happens",
      "keywords": [
        "Shading Models",
        "Handcrafted Shading Models",
        "NDFs NDF shading",
        "Shading",
        "NDF",
        "client",
        "Shading Models Jan",
        "model",
        "NDF texture",
        "normal distribution function",
        "diffuse term",
        "server",
        "NDF shading",
        "normal distribution",
        "term"
      ],
      "concepts": [
        "models",
        "shading",
        "server",
        "networking",
        "clients",
        "normal",
        "normalized",
        "normalize",
        "games",
        "time"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 43,
          "title": "",
          "score": 0.734,
          "base_score": 0.584,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "",
          "score": 0.681,
          "base_score": 0.531,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 44,
          "title": "",
          "score": 0.661,
          "base_score": 0.511,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 45,
          "title": "",
          "score": 0.656,
          "base_score": 0.506,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 46,
          "title": "",
          "score": 0.635,
          "base_score": 0.485,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "shading",
          "shading models",
          "ndf",
          "client",
          "models"
        ],
        "semantic": [],
        "merged": [
          "shading",
          "shading models",
          "ndf",
          "client",
          "models"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2187811279048777,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923617+00:00"
      }
    },
    {
      "chapter_number": 50,
      "title": "Segment 50 (pages 477-487)",
      "start_page": 477,
      "end_page": 487,
      "summary": "In other game protocols—for example, those that might be used\nSome game developers have written their own reliable protocols on\nThis implies that game developers will\n6.1 Minimizing Latency in Real-Time Strategy Games 493\nout clock synchronization, time 7 on one client could differ from another client's by\nTime Protocol (SNTP) [Mills96].\nIn this protocol, the client machine to be synchro-\nthe receiver with the time as it is known to the server.\nUnlike SNTP, the Network Time Protocol (NTP) [Mills92}] does attempt to\nThis makes NTP less than ideal for network game play where players expect games to\n1. The client stamps the current local time on a ‘time request’ packet and\n2. Upon receipt by the server, the server stamps its time and returns the packet.\n5.1 Minimizing Latency in Real-Time Strategy Games 495\n9600-baud modem on the server machine and even less on the clients.\nNetwork Programming in Age of Empires and Beyond,” Game Developer Con-\n[Mills96] Mills, David, “Simple Network Time Protocol (Version 4),” University of\ngames.\nStar Topia [StarTopia01) is a real-time strategy (RT'S) game that supports four-\nThis gem is based on the simple network protocol we used for this game.\nwill also include a simplified example game.\nThe systems that concern us here are for games involving up to 10 players, rather than\nfor first-person action games is that each player is sitting\nA server runs the game, effectively remote from any client, even if in practice it resides\nEach client tells the server what it wants to happen, based on player controls.\nare refinements to smooth out the game, based on the client’s prediction of server\nClients can drop in and out, but the game on the\n6.2 Real-Time Strategy Network Protocol 497\nHowever, it does require thar the client’s visible game state is small\nas an option for real-time strategy games where a tremendous amount of game state is\nWith the peer-to-peer protocol, no computer in the game is more important than any\nThe benefit of this protocol is that the game state owned by the computer is\nOf course, as the size of the game state increases, the number of\nAs the name implies, a game using this protocol runs in lockstep with ali computers\nThey start with the same game state, and game time is split into turns.\neach turn, each computer models the game world to advance the action by one step.\nlectively model the next game turn and stay synchronized.\nfor real-time strategy games.\nA problem with this protocol is chat the number of game turns per second is lim-\nited by the round-trip network delay; at the end of each game curn, the machines\nto ensure that no user actions directly affect the game, but rather indirectly affect the\ngame via the network code.\nillegal changes enacted on the game state will cause that machine to fall out of sync\nOn the other hand, because the entire game state is available\non each machine, other cheats become possible—for example, changing the game to\npacket per event (to the server), rather than one to each of the other clients.\nmethod enables the server to be in charge of negotiating the game state when a\nWith lockstep, the clients collect input from the others between each game turn.\neach client is broadcast to all machines upon being received by the server.\nprocessed, but the game turns continue to occur at a steady pace in the meantime (see\n* At the start of play, the state of the game on all machines is identical.\n* The server then sends an identical stream of packets to the clients.\nTherefore, the game stays synchronized\n* For this reason, it is vital to decouple local user input from the local game state.\nUser input gets transmitted to the server, which in turn broadcasts them to the\n© Game turns don’t necessarily happen absolutely simultaneously on all computers,\nbut game events occur in the same order.\nAlso, packets from the server\nNumber of Game Turns per Second\nSeveral factors must be considered when deciding how many game turn updates\nLowering the game-turn rate has the following\nGame controls\ngame world on\nFIGURE 5.2.1 The server/client and game turn/time relations.\n* Most of the time, the only network activity that occurs is the server issuing game-\n* Most game-turn processing is at a constant cost per turn, no matter how many\nLowering the game-turn rate reduces the CPU cost of model-\ning the game.\n* When user input arrives, its effect is only realized in the game the next time it is\nThis means that, on average, the response time of the game is lagged by\nhalf of a game turn.\nIf game turns happen more often, this effect is reduced.\nnumber of turns per second should work for most real-time strategy games.\ninterpolating Between Game Turns\nFirst, the clients anticipate when game turns will arrive from the server and try to\nsion from the server to model the next turn, possibly with some new user input.\nPlayers with faster machines get a much smoother view, but the game is the same for\nThis improvement needs no prediction of future game state.\nbetween the last two game turns you modeled.\nIdeally, the system will correctly anticipate the moment the next game turn\ntheir effects on the game world.\nUser input only affects the game after the event has\n5.2 Real-Time Strategy Network Protocol 501\nmade the trip to the server and back, adding a game-turn delay plus an extra turn for\ngame into the interface, the network code, and the game state.\nThe game state is the\nmuch of the response of the game to the user as possible.\nExamples of game state that we (re)classify as interface are:\ndoesn’t affect the game.\nIt is, in fact, possible to use this protocol in a game that involves more-direct\nwant to have moved left on game turn x.’ The image displayed to the local user would\nleaves the game.\na clock that counts game turns and acts as a short-term holding bay for user input\n‘The remaining clients must decide which machine will host the new server.\ngames were just one-on-one, so server dropout happened less often than expected.\ntle effect on the game.\nThe server will keep generating game turns at a steady rate, which might be too fast\nIf game turn update requests are\narriving four times a second, but the client takes half a second to model a game turn,\nWe simply added an occasional extra packet that clients would send to the server,\ntime was taken by modeling the game.\nEven in the single-player game, there should be a simulated network lag.\nWhen we started testing the network game, the testers were\nThe game was\nAlthough the game state might be completely synchronized, pointers won't necessar-",
      "keywords": [
        "game",
        "Network Time Protocol",
        "game state",
        "game turn",
        "server",
        "Time",
        "Network",
        "Real-Time Strategy Games",
        "protocol",
        "Strategy Network Protocol",
        "Strategy Games",
        "Time Protocol",
        "Network Protocol",
        "turns",
        "client"
      ],
      "concepts": [
        "game",
        "time",
        "server",
        "protocol",
        "client",
        "turns",
        "network",
        "packet",
        "player",
        "latency"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 51,
          "title": "",
          "score": 0.755,
          "base_score": 0.605,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 53,
          "title": "",
          "score": 0.726,
          "base_score": 0.576,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 59,
          "title": "",
          "score": 0.719,
          "base_score": 0.569,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 54,
          "title": "",
          "score": 0.637,
          "base_score": 0.487,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 57,
          "title": "",
          "score": 0.607,
          "base_score": 0.457,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "game",
          "server",
          "turn",
          "protocol",
          "turns"
        ],
        "semantic": [],
        "merged": [
          "game",
          "server",
          "turn",
          "protocol",
          "turns"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.16805428783366205,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923671+00:00"
      }
    },
    {
      "chapter_number": 51,
      "title": "Segment 51 (pages 488-496)",
      "start_page": 488,
      "end_page": 496,
      "summary": "The major part of network game debugging was tracking down reasons why clients\nDetecting that the game was out of sync was done\nOnce the game is out of sync, looking at the differences in the game state tells you\ndump’ only when the game went of sync.\ntaining game-turn increments and user events.\nlarge portion of the game before the network protocol was incorporated.\n* Changing game state directly rather than making the change via a network packet\n* Game code referring to the player that is local to the player’s machine.\n* Game code referring to the camera.\n* Game code referring to the system clock for timing, rather than the game turn.\nThese problems can be avoided by keeping the interface and game state as far apart\nFor example, no code that controls game state should know which player is\nsions, it is almost worth having a checksum of all data loaded into the game.\nThe typical instance of this pitfall or bug is that an event packet refers to some object\nan appropriate state to receive this event.\nstate to respond to an event.\nExample Game\nThis protocol was easy to implement and worked well for our game.\nfreedom to write a game full of many concurrent events, without worrying about\n(Ireland01) Ireland, Tom, list compiled during game development, July 2001.\nMultiplayer Games\nThor Alexander, Hard Coded Games\nnetworking, rendering, database access, and game simulation.\ngame simulation, and it presents a solution that provides for a flexible simulation\narchitecture that can be reused to create many different styles of online games.\nonline game service will have a lifetime of at least five years.\nAt its core, an MMP is a client/server system.\nrelays message packets across the Internet between the client and server processes.\n5.3 A Flexible Simulation Architecture for Massively Muitiplayer Games 507\nThese message packets are received and interpreted by the game-simulation layer.\nlayer is responsible for maintaining the consistency of the game state-space on the\nclient and the server.\nDetailed simulation of the physical representations of the objects\nlayer presents only what the player can perceive, the number of objects simulated at\nany given time on the client need only be a subset of those on the server.\nthe client to perform the physics simulation at a much higher level of detail than the\n[ Game Simulation ; Cl Game Simulation\nFIGURE 5.3.1 Client/Server game architecture.\nThe game-simulation layer on the server holds the one true representation of the\nThe server broadcasts changes to the actors and objects in the state-space as simula-\nThe client uses these events to update the proxy objects that\nThe user interacts with the server simulation\nby sending action requests that the server simulation layer must validate before the\nClient Server\nFIGURE 4.3.2 Chtent/Server simulation via Actors and Prexies.\nMMP design must never trust the client’s representation of state-space.\nSimulation Events\nSimulation events are the transactional objects of this system.\nAn event object contains the event\n5.3 A Flexibie Simulation Architecture for Massively Multiplayer Games 509\n[Dybsand00].) SimulationState serves as the base class for all states in our architec-\nDerived state classes can implement additional checks to meet their\nEach child class will need to implement this method and provide any specific behav-\nActionStates are the typical game-simulation operations, such as slapping an opponent\nthe server simulation with the animation play-back time on the client.\nFIGURE 5.3.4 Simulation state class diagrams.\nsuch as a scripted state for use with in-game cut-scenes.\nswapped on the fly to transition the actor between these states.\nreceived on the server from the user on the client.\nwhen an actor in this state calls its Performaction method.\nshould be implemented with an AI technique that best suits a given simulation’s game\nA Simulation Object (SOB) forms the base for all of the core classes that the simulation\nSimulationObjects communicate with each other by sending simulation events.\ncan subscribe to the events that they care about with other simulation objects.\nSOB maintains a subscribers dictionary that it uses to publish events that it generates.\ntents dictionary of the objects that it contains, as well as an ownerld that refers to the\nItems can become in-game con-\nSimilar to containment, SimulationObjects also maintain a dictionary of links\n5.3 A Flexible Simulation Architecture for Massively Multiplayer Games 511\nSOBs. This provides for a simple, yet powerful way to enable objects to receive events\nSimulationObjects also provide a property dictionary for storing game system-spe-\ncan be replicated down to the associated proxy object on the client in an intelligent,\nThe simulation layer can call the Store method on the SOB when needed.\nforms the converse operation and loads the object into the simulation.\nFIGURE 5.3.6 Simulation Object class diagram.\nThe abstract Performer core class provides for the shared client/server functionality\nand common interface of the Actor and ActorProxy simulation object classes.\nformer class maintains a schedulePriority attribute that is used by the simulation for",
      "keywords": [
        "game",
        "Simulation",
        "game simulation",
        "Game Simulation Server",
        "flexible simulation architecture",
        "server",
        "server simulation",
        "client",
        "Massively Multiplayer Games",
        "game state",
        "object",
        "Simulation Server Client",
        "state",
        "Server game architecture",
        "Simulation Object"
      ],
      "concepts": [
        "game",
        "simulation",
        "simulated",
        "state",
        "object",
        "dictionary",
        "classes",
        "network",
        "events",
        "server"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 50,
          "title": "",
          "score": 0.755,
          "base_score": 0.605,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 53,
          "title": "",
          "score": 0.688,
          "base_score": 0.538,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 54,
          "title": "",
          "score": 0.617,
          "base_score": 0.467,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 59,
          "title": "",
          "score": 0.555,
          "base_score": 0.405,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 58,
          "title": "",
          "score": 0.508,
          "base_score": 0.358,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "simulation",
          "game",
          "server",
          "game simulation",
          "client"
        ],
        "semantic": [],
        "merged": [
          "simulation",
          "game",
          "server",
          "game simulation",
          "client"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.178885282578019,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923718+00:00"
      }
    },
    {
      "chapter_number": 52,
      "title": "Segment 52 (pages 497-504)",
      "start_page": 497,
      "end_page": 504,
      "summary": "A performer also maintains the object’s currentActionState, which rep-\nresents the action that the object is currently performing.\nmented by expanding the object to contain several parallel action states for mutually\nFIGURE 5.3.7 Performer class diagram.\nAn Actor is defined to be a server-side simulation object that is capable of interacting\nThe Actor class also maintains an eventQueue that is\npopulated by the ReceiveEvent method (see Figure 5.3.8).\ning to decide what it needs to do every time an Actor receives an event.\nFIGURE 5.3.8 Actor class diagram.\nevent simulation, like MMP games where the actors need to be aware of everything\nmethod that routes outbound action requests to the associated actor on the server.\nFinally, there is a PerformAction method available to process any client-side-only\nbehavior that does not need to be replicated by the server simulation, such as dynamic\nFIGURE 5.3.9 ActorProxy class diagram.\nThese objects do not perform actions and do not\nreceive any scheduled processing time from the simulation.\n* Ltems—Small game objects that can be picked up, moved, and dropped by actors.\nused to filter who can and cannot see (or if needed, hear) simulation events.\nclasses and objects.\nThe SOBFactory is responsible for creating simulation objects and guaranteeing that\nIf the client-side simulation needs to create local simulation objects, it can\nFIGURE 5.3.10 SOBFactory class diagram.\nAn SOBManager is responsible for maintaining a dictionary of simulation objects.\nThe main function of this manager is to resolve SOB IDs into object references via\nThis manager also provides methods to Store and Restore\nThese two methods delegate the actual object-\npersistence implementation down to the specific simulation objects.\nobjects within it (see Figure 5.3.11).\nFIGURE 8.3.11 SOBManager class diagram.\nThe ScheduleManager is responsible for scheduling a Performaction method callback\nfor all of the Performer simulation objects that are active in the simulation (see Figure\nFIGURE 5.3.12 Class diagram for ScheduleManager.\nor object databases and loaded on simulation startup.\nFIGURE 5.3.13 Class diagram for LookupManager.\nthem all up in a nice top-level interface for managing the client/server simulation lay-\nobject references to our manager singletons, as well as a reference to the root simula-\nThis object represents the entire simulation universe and provides a\npointer to anchor all top-level Area simulation objects to.\nThe simulation maintains\nration of simulation objects is useful for debugging, maintenance, and archival pur-\nFIGURE 5.3.14 Simulation class diagrams.\nDetachUser methods, providing a mechanism to request that the calling user be\nAttaching a user to an Actor allows that user to send action requests and\nreceive simulation events.\ndesired action, and passes them to the server simulation layer.\nthe simulation layer to trigger all processing of pending actions.\nThis method is\nFIGURE 5.3.15 Action request sequence diagram.\ning it over to the schedule manager via the ProcessTasks method.\nphysics layer that maintains the main game loop (see Figure 5.3.16).\nFIGURE 5.3.16 Action-scheduling sequence diagram.\nneed to inform other simulation objects of the state transition.\nthrough simulation events.\ndictionary of other objects that have registered an interest in its actions.\nFIGURE 5.3.17 Event-broadcast sequence diagram.",
      "keywords": [
        "simulation",
        "simulation objects",
        "Massively Multiplayer Games",
        "Actor",
        "Flexible Simulation Architecture",
        "method",
        "objects",
        "Multiplayer Games",
        "Simulation Architecture",
        "Charles River Media",
        "class diagram",
        "game",
        "Performer simulation objects",
        "Actor class diagram",
        "Massively Multiplayer"
      ],
      "concepts": [
        "simulations",
        "games",
        "method",
        "actor",
        "classes",
        "object",
        "action",
        "events",
        "states",
        "diagram"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 24,
          "title": "",
          "score": 0.668,
          "base_score": 0.518,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 1,
          "title": "",
          "score": 0.565,
          "base_score": 0.415,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 30,
          "title": "",
          "score": 0.563,
          "base_score": 0.413,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 13,
          "title": "",
          "score": 0.516,
          "base_score": 0.366,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 54,
          "title": "",
          "score": 0.481,
          "base_score": 0.481,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "simulation",
          "simulation objects",
          "diagram",
          "objects",
          "class diagram"
        ],
        "semantic": [],
        "merged": [
          "simulation",
          "simulation objects",
          "diagram",
          "objects",
          "class diagram"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19908471109871825,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.923764+00:00"
      }
    },
    {
      "chapter_number": 53,
      "title": "Segment 53 (pages 505-512)",
      "start_page": 505,
      "end_page": 512,
      "summary": "Scaling Multiplayer Servers\ngaming, players suffered from lag and server resource starvation.\nleave servers open to more exploits, The amount of throughput required to simulate\nclustering server processes and optimizing systems to reduce throughput requirements\nNever trust the client to send good information back to the game server.\nPlayers will send false packets to move faster in a game, to\n* Data that is sent from the client—the client lies to the server about what it is\ndoing or assaults another client on the network,\nGame clients usually\nas much information on the client as possible to prevent objects from ‘popping’ into\nStrategy 1: Don’t Send the Data\nData sent to the client should be on a ‘need-to-know.’ basis.\nLess data on the client\nimprove client-side simulation, but sending health points for all potential foes in the\nclient.\nsome precaching data be sent to improve the simulated experience on the client.\nthat is not sent to the client.\nThe data is in ciphertext when it reaches the client.\nAfter all, precaching information is sent because the client will likely be interacting\nis amortized, and the data becomes relevant in the time it takes to send those few\ncache message to request a background load of assets; while game information like\nStrategy 3: Clients Send Commands, Not States\nIf the client is not authoritative for position, health points, combat results, or what-\ndead.” Instead, the client should only be allowed to send commands like “walk,”\nStrategy 4: Server Validates Client Output\nThe player might not be allowed to send the message “Attack Joe,” or might send a\nshould be ready to either discard the data or discard the client altogether by discon-\nStrategy 5: Never, Ever Tell a Client the Network\nAddress of Another Client\nIt is important to prepare the server code for the consequences of a high-throughput\nUsing the network system in game code\nservers.\nThis is fine for low-volume network services handling a few dozen connections,\nreceive data\nvolume network server applications [MSDN00].\nA server written in a strongly typed language can catch message-type errors at compile\nover a network is no more difficult than ensuring type safety when storing objects on\nused for network-based data synchronization, with a few exceptions.\nThe client might\n5.4 Scaling Multiplayer Servers 525\nOpt for serialization that is common to network messaging, file I/O, and data-\ndeltas to object data as well as to construct whole objects.\nprocess might receive a position update network message, interpret it as SQL, and\neffective uses of a typed message system is in dispatching data to server systems.\nthe message is received, the header is read, and more data is extracted from a packet\nuntil the whole message has been processed.\nWhen enough message types are\ncode is tightly coupled with each new message.\nNew message code cannot leverage old\nmessage data.\n“when connection X sends message Y, invoke my member function Z to handle it.”\nwhat types of objects are requesting a message or what types of messages are handled.\n* It provides a ‘connect’ method that accepts a reference to a dispatch object that\n* The connection object adds the requestor’s dispatch object and callback function\n* When the dispatch system receives a network message, it constructs the message\n© Requestor objects have their member functions invoked with the message as an\nprovides type-safe message dispatch and compile-time errors when message types (or\nIn the context of a network messaging system, a connection receives a network\nbuffer, constructs a new message of a specific type, and dispatches it:\nvoid Client::Client(Connection * connection) :\nvoid Connection: :onReceive(const Archive: :Stream & data}\nThis can be used for far more than network messaging.\nobject on the server process.\nclients that see the monster.\nvoid Client: :onCreateMonsterOnRemote(Monster * m)\n&Client::onKilledMonster);\nvoid Client: :onKilledMonster(KillMsssage & k)\n5.4 Scaling Multiplayer Servers 527\nmessage that was emitted by the monster in the old code can trigger new code in a\nEnsuring that server systems can scale to arbitrarily large connection counts often\nHow does a client find\nWhere does the world persist game data between process startup and shutdown?\nWhat happens when clients need to interact with objects on",
      "keywords": [
        "Sony Online Entertainment",
        "Servers Justin Randall",
        "Multiplayer Servers Justin",
        "client",
        "Justin Randall",
        "Sony Online",
        "Online Entertainment",
        "Scaling Multiplayer Servers",
        "data",
        "server",
        "message",
        "network",
        "Multiplayer Servers",
        "system",
        "Servers Justin"
      ],
      "concepts": [
        "data",
        "servers",
        "message",
        "messaging",
        "players",
        "gaming",
        "client",
        "connect",
        "connections",
        "connection"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 54,
          "title": "",
          "score": 0.8,
          "base_score": 0.65,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 50,
          "title": "",
          "score": 0.726,
          "base_score": 0.576,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 51,
          "title": "",
          "score": 0.688,
          "base_score": 0.538,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 58,
          "title": "",
          "score": 0.676,
          "base_score": 0.526,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 59,
          "title": "",
          "score": 0.607,
          "base_score": 0.457,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "client",
          "message",
          "servers",
          "network",
          "server"
        ],
        "semantic": [],
        "merged": [
          "client",
          "message",
          "servers",
          "network",
          "server"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18453574969497563,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.924493+00:00"
      }
    },
    {
      "chapter_number": 54,
      "title": "Segment 54 (pages 513-523)",
      "start_page": 513,
      "end_page": 523,
      "summary": "Consider Using a Front-End Process To Interact\nSeparating client traffic from the rest of the servers is a good first step to solving prob-\nWhen a client connects to a game server, it is really interacting with\na front-end process (FEP).\npresent the client with several ‘servers’ with which it may interact.\nEach server is one\nof several front-end processes that separate the client from back-end game processes.\nOnce the client connects to an FEP, that process will communicate with other back-\nend processes to insert a player’s character into the world simulation so that it may\nHow the world is presented to the client and which\nback-end process interacts with the client depends on the design of the game.\nin might be the target process for the new client.\nBack-end processes\nProcess (FEP).\nWhich objects are on\nwhich servers?\nWhich players are on which servers?\none in which the game world appears as a single server covering a contiguous simula-\nIf a client has to move from one back-end game-\nserver process to another, there is no reconnection process necessary on the client.\nThis might all be handled with interactions between the FEP and the game-server\nclient attempts to send a malformed packet to crash game servers).\nFront-end processes safeguard clients from game-service failures on the back-end.\nIf there is a recovery scenario implemented, clients need never know that the server\nactive while the back-end starts a new game service and redirects the clients to the new\nDistributing server processes does not necessitate the use of FEPs. Some game\ndesigns that involve autonomous game servers (i.e., there is no requirement for a uni-\nfor using front-end processes.\nThe majority of technical exploits arise when players interact across process bound-\nier load, interacting with more objects than a client scene has polygons.\nbetween one million objects that are scattered over 20 or more processes will quickly\ndemonstrate a requirement to cull objects on the server as well!\nIt is desirable, even necessary, to limit what each object can interact with to some\nupdate objects, independent of any perspective presented by a single object, and use\nThe sphere tree is an ideal distance-based spatial sorting algorithm.\nSphere trees make speedy distance queries, quickly returning a solution set of\nobjects that are within an arbitrary sphere.\ninteraction between objects in the world simulation.\nA sphere tree organizes objects in a hierarchy of spheres, There is a root node con-\nAs an object\nsize has been reached, the object is sorted into the parent's parent sphere, and a new\nBecause objects in a sphere tree are sorted based on bounding\nspheres, when a range-based query is made to the tree, it tests the top-most nodes in\nuseful property of sphere trees with distance-based culling.\nEach object has a bounding sphere so that it properly sorts into the tree.\nAs the object moves, so does the interest sphere.\nWhen the query returns a new object to interact with,\nThe new object is placed in a set of\npotentially interactive objects.\nWhen the server checks for interactions between objects, it need only query the\nAs the new object is added, the server might also check to see if it is a player char-\ntially interactive list, and baseline information for the new object might be sent to\nAs the object moves or changes, the client can receive updates about\nthat object.\nThe server will only have to send updates about objects that are poten-\ntially interactive with the client.\ntentially interactive set, they might be unloaded from clients.\nIt is tempting to place an interest radius on a client’s character object.\nvides a single interactive set that the client can query for new information.\nefficient, however, to have interactive sets relative to other objects.\nBy storing the interactive set on the viewed objects rather than the viewer,\nFor the most part, objects are not in motion, and so they do not query the sphere\nwith the interaction spheres of stationary objects.\nInteraction spheres might be bounding spheres placed into a sphere tree as well.\nThis same approach can be used to cull server-to-server interactions.\nServers will\nneed to perform some processing on remote objects if they interact.\nprocesses to spend CPU on all objects in the world will quickly bring a server cluster\nSphere trees are not the only solution to problems of spatial sorting and culling\nnetwork API, even at the expense of portability, so that servers can handle the greatest\nsphere trees for culling provide high server performance and isolate back-end servers\nTemplate-Based Object\nSerialization\n| a networked game, either client/server or peer-to-peer, it is important to have\nan efficient method of converting objects to and from a network-friendly repre-\nThis process is known as serialization.\nEven for non-networked games, serialization is useful for dealing with the file\nThis gem presents a serialization method designed for network usage.\ntypes, STL containers, and user-defined classes.\nstructure containing the data to be serialized, fill it in, and simply use memcpy(} to\n5.5 Template-Based Object Serialization 535\ntice involves the use of an object that has methods to store and retrieve each desired\nclass Serializer\nWhen it comes to user-defined classes, we face a dilemma—should Serializer\nTherefore, serialization support should be incorporated into each class directly.\nvirtual bool PutInto(Serializer& s} const = 0;\nvirtual bool GetFrom{Serializer& s} = 0;\nThen, extend Serializer to support serializable objects:\nbool Serializer::Put(const Serializable& obj)\nbool Serializer: :Get(Serializable& obj}\nNetworked games, especially those of the client/server variety, are often multiplatform\nFor serialization, this poses a problem, because the exact size of an object must\n5.5 Template-Based Object Serialization 537\nserialization system must be able to convert to and from a standard byte order in order\nthumb is to go with the native format on the server side, since clients presumably have\nThe Serializer Class\n* Support primitive types, STL containers, and user-defined classes, with minimal\nclass Serializer\nbool Serializer: :Put(const std::string& obj)\nbool Serializer: :Get(std::string& obj)\nSerializer makes use of a ‘byte-buffer’ utility class that handles the mundane details",
      "keywords": [
        "client",
        "server",
        "objects",
        "Sphere Tree",
        "Sphere",
        "Process",
        "Clients Separating client",
        "Multiplayer Servers",
        "Serializer",
        "FEP",
        "game",
        "Scaling Multiplayer Servers",
        "bool Put",
        "bool",
        "Put"
      ],
      "concepts": [
        "interact",
        "interactions",
        "interaction",
        "objects",
        "server",
        "clients",
        "serialization",
        "serialized",
        "process",
        "processes"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 53,
          "title": "",
          "score": 0.8,
          "base_score": 0.65,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 50,
          "title": "",
          "score": 0.637,
          "base_score": 0.487,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 51,
          "title": "",
          "score": 0.617,
          "base_score": 0.467,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 58,
          "title": "",
          "score": 0.595,
          "base_score": 0.445,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 52,
          "title": "",
          "score": 0.481,
          "base_score": 0.481,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "client",
          "sphere",
          "serializer",
          "server",
          "objects"
        ],
        "semantic": [],
        "merged": [
          "client",
          "sphere",
          "serializer",
          "server",
          "objects"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18890304818464643,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.924546+00:00"
      }
    },
    {
      "chapter_number": 55,
      "title": "Segment 55 (pages 524-531)",
      "start_page": 524,
      "end_page": 531,
      "summary": "5.5 Template-Based Object Serialization 539\nThe code for each type is similar.\nHandling Simple Variable-Length Types\nTwo types fall into the simple variable-length types category: C-style strings and\nOne workaround is to define an application-specific wide-string class (per-\nhaps based on the basic_string template), and make it serializable.\nclass that can act like a byte array (Buffer), and it is easily made serializable.\nHandling STL Containers\nStoring the contents of an STL container is straightforward.\nmany algorithms that come with the STL (e.g., find_if()}) use iterators almost exclu-\nand only rely on the public interface of Serializer.\nbool SerializeHelper: :PutRange(Serializer& s,\nif (!s.Put(size)) return false; // store size\nhas two extra wrinkles—first, the type of objects contained must be determined (e.g.,\nit must be inserted back into the container.\ntionality in the iterator_traits class and the concept of insert iterators [Josuttis99),\nbool SerializeHelper: :GetRange(Serializer& s,\niterator_traits<Inserter>: :value type obj;\n*it = obj; // inserts into container\nis needed is a way to determine the type of the contained objects.\nGetRange(} certainly knows this, and thus can pass in a null pointer of that type T,\nif (!s.Get({size)} return false;\n5.5 Template-Based Object Serialization 541\n*it = obj; // inserts into container\nbool SerializeHelper: :GatFrom{Serializer& s,\nThe rest of the STL containers are handled similarly, with the only difference\nbeing in the number of template arguments (e.g., map requires two types—key and\ncontainers use the back_inserter adapter (which calls push_back()), while the others\nmust also define serialization functions for the utility template class pair.\nSTL containers of any serializable class are supported (including nested containers),\nHandling User-Defined Classes\nWhen a class has private data, the SerializeHelper functions will have to be\nThe base class\nSince more message classes\nwill probably be added in the future, the network layer (where messages are serialized\nproperly serialize an arbitrary Message, and how can it create an arbitrary Message out\nbase class Message directly serializable {i.c., define PutInto() and GetFrom{}).\nthese functions call into pure virtual methods that Message subclasses must define in\norder to handle class-specific data.\nfacture, a header with type information (e.g., a ‘message~class id’) is also required.\nresult, this means that STL containers of pointers cannot be automatically serialized.\nincluded—-but in general, using the STL vector class is every bit as fast as arrays.\nlike pointers, an STL container of arrays is not going to work out-of-the-box,\nStrings, buffers, and $TL containers store their sizes in serialized outputs.\nencode the length in a variable number of bytes.\nEach byte contains seven data bits,\nis a bad idea if the values being stored falf into an even distribution across the type’s\n5.5 Template-Based Object Serialization 543\nEncoding is beneficial only because most of the values being serialized are\ntions on the value type.\nAs might be expected, this class is a template (with member\nto the Buffer class defined earlier.\nPut() first serializes value into a Buffer, and\nwork game can do to minimize the size of messages being sent between client and\nIf an object update message contained\nthat bandwidth would be wasted—an object's scale, color, and type are not likely to\nObviously, individual message types could be used for\nan object update contained a KayedSerializer (perhaps using uints as the key type),\na single message can handle any combination of properties, use a single code path,\nObject Tagging\nIf two objects serialize into the same number of bytes (e.g., float32 and\nuint32), then it is possible to store one type and read the other.\nTo compute the tag for a given type, another func-\nUsing a one-byte tag, this is the resulting code (changes in bold):\ntemplate <typename T> bool Put(const T& obj)\nuint8 tag = SerializeHelper: :ComputeTag (obj);\ntemplate <typename T> bool Get(T& obj)\nIt goes without saying that this will increase the size of the serialized output.\nThere are a number of ways by which Serializer and its related classes can be\nabstract interface and implement serialization to/from files, both binary and\n5.5 Template-Based Object Serialization 545\n* Build a code generator that automates the creation of serializable classes, based on\nThis gem has presented a system for object serialization that is efficient, extensible,\ncan be implemented within the context of game network code.",
      "keywords": [
        "STL",
        "STL Containers",
        "type",
        "Message",
        "size",
        "Object Serialization",
        "Object",
        "template",
        "Template-Based Object Serialization",
        "Put",
        "Serialization",
        "network",
        "STL Containers Storing",
        "SerializeHelper",
        "Containers"
      ],
      "concepts": [
        "serialization",
        "serialized",
        "serialize",
        "classes",
        "template",
        "type",
        "networks",
        "containers",
        "code",
        "bytes"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 6,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 27,
          "title": "",
          "score": 0.399,
          "base_score": 0.249,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 3,
          "title": "",
          "score": 0.372,
          "base_score": 0.372,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 7,
          "title": "",
          "score": 0.364,
          "base_score": 0.214,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 5,
          "title": "",
          "score": 0.354,
          "base_score": 0.204,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "containers",
          "stl",
          "serialization",
          "template",
          "message"
        ],
        "semantic": [],
        "merged": [
          "containers",
          "stl",
          "serialization",
          "template",
          "message"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.16223813378350535,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.924592+00:00"
      }
    },
    {
      "chapter_number": 56,
      "title": "Segment 56 (pages 532-540)",
      "start_page": 532,
      "end_page": 540,
      "summary": "into the payload of the packet, which is in turn both encrypted and authenticated.\nauthentication of the payload proves that the packet came from someone who knows\nSecurity Associations\nA security association (SA) is a logical ‘connection’ created for security purposes.\nand authentication keys, modes, algorithms, and other data that define the packet for-\nPrior to sending or receiving secure data, the communicating pair must establish\na security association.\ntion and encryption in order to maximize security.\nTable 5.6.1 Security Association Data\nEncryption Key The synumecric key dava used by the encryption algorithm\nSequence Number The next sequence number ro be used by a packet sent on this SA\nThe block size is based on the encryption algorithm.\nImplementing secure sockets is a matter of encrypting and stamping a hash on data\nbefore sending it, and authenticating and decrypting the data when receiving it.\n5.6.2 shows the format of a secure packet, detailing which portions of the packet are\nauthenticated and encrypted.\nTable 5.6.2 Secure Packet Farmat\nData Size (bytes) Default Size (bytes) Authenticated Encrypted\npacket so the receiver can select the SA under which the packet will be processed.\nencrypted, because it is used to identify the SA thar defines the algorithms and keys.\nThe first packet\nsent using a given security association will have a sequence number of one, the next\npacket will be number two, and so on.\nThe sequence number is not encrypted so that replay attacks\ncan be detected without having to decrypt the packet.\nIf an attacker modifies the sequence number, the packet\nsender with random data and is fed to the encryption algorithm, The receiver initial-\nThis data is encrypted in the packet that\nPadding is appended to the payload before encryption.\nFirst, the encryption algorithm might require a certain block size.\nmany symmetric encryption algorithms use eight-byte blocks.\npacket.\nAn HMAC is a keyed hashing algorithm that uses a combination of a\nstandard cryptographic hash algorithm and a secret symmetric key [RFC2104].\nsecure packet.\nThe sender calculates the ICV by hashing the encrypted packet data using the\nauthentication key of the SA.\nSending data is a matter of encrypting the payload and generating a cryptographic\nPrior to sending secure data, the sender establishes a security association with the\nlink has the data it needs to encrypt, decrypt, and authenticate traffic sent between\nThe header includes the SPI, the sequence number, and the encryption IV.\ntion algorithm requires a larger TV than what is sent in the packet, the remaining\nPadding is generated based on the size of the plaintext payload and the SA encryption\nEncrypting the Payload\nThe encrypted portion of the packet includes the original payload, the padding, and\nabove, and the encrypted payload is generated using the SA symmetric encryption key\nand SA symmetric encryption algorithm.\ninitialized with the SA cryptographic hash algorithm and authentication key.\nhash algorithm is then applied to the packet header and encrypted payload/padding.\nSending the Secure Packet\nThe receiver must validate the packet SPI, ICV, and sequence number.\nmay then decrypt the packet and validate padding.\ncomplete can the receiver process the packet payload.\nRecelving the Secure Packet\nThe secure packet is received using whatever UDP socket mechanism the game uses,\ndoes not match a security association in the receiver’s security association database,\nsecure packet.\ninitialized with the SA cryptographic hash algorithm and key.\nis then applied to the packet header and encrypted payload.\nauthentic packet.\nresents the highest validated sequence number received on the SA.\nPackets that con-\nPackets falling within the window are checked against the list of received\npackets.\nIfa packet with a matching sequence number is received, it is a replay and is\nPackets with a\nand padding bytes are deciphered using the SA symmetric decryption key.\ning plaintext includes the original payload, padding bytes, and padding size.\nand receiving secure data.\nSecurityAssociation Security association data\nSecureBuffer Functions for encrypting, decrypting, and authenticating payloads\n// Securely exchange nSPI and keys with other end\nSending a Secure Packet\nGenerate and send a secure packet:\n// Generate the encrypted and authenticated buffer.\n// Send the secure packet\nReceiving a Secure Packet\n{/ Receive the secure packet\n// Validate the packet\nThe cryptographic algorithms and key management use the Windows CryptoAPI, Alf\nalgorithm with eight-byte block requirement (e.g., DES), minimum packet overhead\nThe second performance issue is encryption/decryption and authentication.\nChoose algorithms and key lengths that provide solid security at a rea-\n2000, and using the default SA settings with DES encryption (64-bit keys) and MD5\nPayload Size (bytes) Create (ms) Authenticate (ms) Decrypt (ms}\nSecurity\ntion, be aware that an authenticated packet without encryption exposes your game to",
      "keywords": [
        "secure packet",
        "packet",
        "Sequence Number",
        "security association",
        "Secure",
        "Security",
        "Encryption Algorithm",
        "data",
        "encryption",
        "payload",
        "Number",
        "Algorithm",
        "Secure Sockets",
        "Security Association Data",
        "Padding"
      ],
      "concepts": [
        "secure",
        "security",
        "packet",
        "key",
        "keys",
        "authenticated",
        "authentication",
        "authenticate",
        "encrypted",
        "encryption"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 57,
          "title": "",
          "score": 0.632,
          "base_score": 0.482,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 53,
          "title": "",
          "score": 0.482,
          "base_score": 0.332,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 50,
          "title": "",
          "score": 0.457,
          "base_score": 0.307,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 51,
          "title": "",
          "score": 0.406,
          "base_score": 0.256,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 58,
          "title": "",
          "score": 0.393,
          "base_score": 0.243,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "packet",
          "secure",
          "encryption",
          "security",
          "sa"
        ],
        "semantic": [],
        "merged": [
          "packet",
          "secure",
          "encryption",
          "security",
          "sa"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.14608285885895067,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.924654+00:00"
      }
    },
    {
      "chapter_number": 57,
      "title": "Segment 57 (pages 541-549)",
      "start_page": 541,
      "end_page": 549,
      "summary": "[RFC1321] “The MD5 Message-Digest Algorithm,” available online at herp://\n{RFC2104] “HMAC: Keyed-Hashing for Message Authentication,” available online\n[RFC2401] “Security Architecture for the Internet Protocol,” available online at\n[RFC2403] “The Use of HMAC-MD5-96 within ESP and AH,” available online at\n[RFC2404] “The Use of HMAC-SHA-1-96 within ESP and AH,” available online at\n[RFC2406] “IP Encapsulating Security Payload {ESP),” available online at http://\n[RFC3174] “US Secure Hash Algorithm (SHAI),” available online at http://\n[PSec,” available online at http://www.counterpane.com/ipsec.huml, February\nUDP filters are one-\nuse the same port to send and receive data.\nNetTool simulates network latency on a per-packet basis according to a Gaussian\nIncoming packets are only\nChecking the Listed box causes incoming packets to be dis-\nAs packets arrive, NetTool dispatches them according to the settings of the filters thac\nThis shows the packet's\n* Sent immediately: No extra latency is required for this packet, so it’s sent right\n* Delayed Xms: The network simulation requires that the packet be delayed before\n* Dropped: The packet was not forwarded.\nThis occurs only for UDP packets\nwhen the filter’s Packet Joss setting is nonzero.\n* Reordered: The packet was sent before another packet that arrived previously.\nThis can only occur for UDP packets when the Reordering setting is nonzero.\n* Duplicated: The packet was sent twice.\nThis occurs only for UDP packets when\n© Wair for connect: For a TCP filter, data arrived before the remote connection\nTCP is a reliable, stream-based protocol: Data arrives in the order it was sent, in arbi-\nNetTool appends all incoming data on a filter to a single queue.\nthen polls the queue, forwarding as much data as the sender’s and receiver's band-\nFor example, data can arrive from the sender before the connection to the receiver has\ncompleted, or the sender can shut down the connection before previously sent data\nUDP Simulation\nUDP is message-oriented, meaning that data arrives in the same chunks in which it\nUDP is also unreliable, meaning that individual messages might be lost in\nOn a local network, UDP packets are almost never lost; but on the Internet, packet\nNetTool drops packets with a probability given by the Packet loss box.\nIf a packet is not dropped, it might be duplicated (sent twice) with a probability\ncated packets will not arrive one after the other.\nPacket reordering will only occur under certain circumstances.\npackets, A and B, arrive on the same port.\nmodem connection, it takes an entire second just to send 30 bytes (assuming 8 bits\ncan set the bandwidth available at each host.\nThe send and receive bandwidth can be\nUDP header), though this can be reduced to a simulated 7 bytes if Uses PPP is\nDirectPlay adds 4 bytes to each packet—this is called the “packet header.” Direct-\nreceiving side needs to know in order to process the packet correctly.\nFIGURE 5.6.1 The DirectPlay message flow.\nUDP offers fast transmissions of data, with no guarantee that the packets will\nwill want to make sure a packet gets to its intended recipient, and in the order sent.\nA typical client-side send in DirectPlay is implemented as follows:\nBy default, DirectPlay sends messages nonguaranteed and sequential.\nFor example, if you wanted to send your data guar-\nAfter a call to Send(} or SendTo{), your message is placed into the DirectPlay\nThere is an associated send queue with every connection in a session, This ensures\nyour send queue by calling GetSendqueueInfo(), as shown in the following code.\nserver interface takes an additional parameter, specifying which player's send queue\nDWORD dwNumBytes; //number of bytes in the send queue\nA message will remain in the send queue until it is either sent or a timeout occurs.\nIf the message will\nreceiver, prohibiting DirectPlay from processing incoming messages.\nbility is that you are sending data more quickly than the receiver can process it, caus-\nsend the message nonguaranteed, then you run the risk of losing the invisibility mes-\nsend the message guaranteed, the player might start sporadically firing their railgun at\nOnce a message is received, the recipient sends back an ACK to the sender An\nno ACK is received by the sender for a particular packet, then it is considered unde-\nsender will simply continue sending data from the message queue, ignoring the\ndropped packet.\nWith a guaranteed message, the sender will retry sending the dropped\npacket until it is received, or until a timeout occurs.\nmessage times out in this manner, DirectPlay determines that the connection has\nIn the event that there are no data packets to piggy-\nback, DirectPlay will create a special ACK packet and attempt to deliver it to the\nDirectPlay will create these special ACK packets is high enough (around 100 ms) to",
      "keywords": [
        "UDP packets",
        "packet",
        "AES Cipher Algorithm",
        "UDP",
        "send",
        "data",
        "DirectPlay",
        "Message",
        "Network",
        "send queue",
        "online",
        "Multiplayer References",
        "November",
        "AES Cipher",
        "online at http"
      ],
      "concepts": [
        "message",
        "messaging",
        "packet",
        "data",
        "network",
        "available",
        "send",
        "latency",
        "connection",
        "connect"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 56,
          "title": "",
          "score": 0.632,
          "base_score": 0.482,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 50,
          "title": "",
          "score": 0.607,
          "base_score": 0.457,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 53,
          "title": "",
          "score": 0.483,
          "base_score": 0.333,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 51,
          "title": "",
          "score": 0.471,
          "base_score": 0.321,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 59,
          "title": "",
          "score": 0.434,
          "base_score": 0.284,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "packet",
          "udp",
          "packets",
          "message",
          "directplay"
        ],
        "semantic": [],
        "merged": [
          "packet",
          "udp",
          "packets",
          "message",
          "directplay"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.12189084843149404,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.924724+00:00"
      }
    },
    {
      "chapter_number": 58,
      "title": "Segment 58 (pages 550-557)",
      "start_page": 550,
      "end_page": 557,
      "summary": "every key press a player makes; instead, it sends state information across the wire.\nIf the player's client is\nGrouping allows the application developer to perform fewer sends, because they can\ntransmit to a group of players, rather than transmitting the same data to all of them\nThis is an excellent way to group players.\nYou can create a group of all the players in a\ncertain sector and send out your data to that one group.\nIn an FPS, it probably would not be beneficial to group players geographically.\ngroup players.\nThe following code shows how to create a group in DirectPlay:\nZeroMemory{&dpnGrpInfo, sizeof (DPN_GROUP_INFO)) ;\ndpnGrpInfo.dwSize = sizeof ({DPN_GROUP_INFO) ;\nOnce this code has been executed, your server interface’s callback function will be\ninvoked with a message of type DPN_MSGID_CREATE_GROUP, containing a DPNID.\nDPNID is a unique identifier assigned to each player or group in a session.\nDPN_MSGID_CREATE_GROUP message is received, it is safe to start adding players to the\nTo send a message to the group, you would need to supply the returned\nYou can also send a message\nto all players in your session by setting the DPNID_ALL_PLAYERS_GROUP constant in\nWhen you send a message, DirectPlay creates an internal copy of that message.\nmessage on the local stack, you should not use asynchronous Send({) operations\nSending a message synchronously will\nnot encounter this condition, since the Send() call will not return until the message\nopers because DirectPlay relies heavily on reentrant callback functions.\nyour callback function prevents DirectPlay from using that thread to process other\nOne way to avoid holding DirectPlay threads is to queue up your incoming mes-\nsages, and have a separate thread process them, thus freeing up the DirectPlay threads\nprocessing the message so that DirectPlay can free those resources.\n5.8 Creating Multiplayer Games with DirectPlay 8.1 567\nOnce the queue has processed the message, make the call to ReturnBuffer():\nsophisticated way of offloading message processing from your callback function.\nAsa side note, it is not always a bad thing to hold DirectPlay receive threads.\ndefault, DirectPlay spins up 2” + 2 threads, where » is the number of processors in your\ncause the CPU to thrash if you spin up more threads to handle DirectPlay messages.\nto decrease the number of threads DirectPlay can use.\nthreads in your DirectPlay application, remember that the threadpool can only be\nretrieve the thread count available by DirectPlay to process incoming messages by\nthe amount of context-switching between the time a message is received on the wire\nhave an application with two client interfaces, one for data and one for voice (as you'll\nsee later in this gem, a DirectPlay voice connection requires a DirectPlay client or peer\not DPNMSG_CREATE_PLAYER messages.\nplayer joins the session, its context value is set.\nthat same player implying that it now has a damage modifier, the server can use the\ncase DPN_MSGID_CREATE_PLAYER:\nPDPNMSG_CREATE_PLAYER pMsg;\npMsg = (PDPNMSG_CREATE_PLAYER)pMessage;\n5.8 Creating Multiplayer Games with DirectPlay 3.1 569\nplayer will not be handled on separate threads at the same time.\nwould be a server receiving a message from a client to join a session.\nDESTROY_PLAYER message were to arrive before the server has had time to complete its\nplayer initialization code, the server could be left trying to access an invalid object in\nSending Voice with DirectPlay\nIf you're using DirectPlay for your\nnetworking layer, you can easily add voice communications to your game, and it only\nThe DirectPlayVoice interface allows you to send voice data over your network\nDirectPlay session setup for your voice data to use as a transport session, getting\nDirectPlay Voice up and running is simple.\nVoice server to host a session:\nInitializing and connecting a voice client to a hosting session is similarly easy.\nfollowing code will initialize, connect, and set transmit targets for your voice client:\nDirectPlay Voice manipulates audio using DirectSound, allowing the developer to\nDirectPlay Voice also supports 3D positional audio, which can greatly\nDirectPlay Voice can be set up in one of three different configurations:\n* A peer-to-peer configuration allows all players to send their voice data directly to\nneeded to process the voice data.\n* A forwarding configuration sends the voice data to a central server, where it is for-\nwarded to the receiving players.\nsend one voice message out with a list of intended recipients, cutting down band-\nhigher, as it must send out several voice messages to different players.\nA mixing server, like the forwarding server, allows clients to send one\nthe client and server, but it requires more processing power.\nIf you want to use a peer-to-peer configuration with your voice data, you must\ntwo valid networking models for a client/server game with voice: one with a peer-to-\nGame Server\nGame Server Voice Server\nRight: Client/Server voice",
      "keywords": [
        "DirectPlay",
        "voice",
        "Creating Multiplayer Games",
        "server",
        "player",
        "message",
        "group",
        "DPN",
        "send",
        "DirectPlay voice",
        "voice data",
        "callback function",
        "group players",
        "client",
        "Multiplayer Games"
      ],
      "concepts": [
        "players",
        "messages",
        "voice",
        "server",
        "networking",
        "process",
        "processing",
        "received",
        "receive",
        "games"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 53,
          "title": "",
          "score": 0.676,
          "base_score": 0.526,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 54,
          "title": "",
          "score": 0.595,
          "base_score": 0.445,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 50,
          "title": "",
          "score": 0.512,
          "base_score": 0.362,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 51,
          "title": "",
          "score": 0.508,
          "base_score": 0.358,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 59,
          "title": "",
          "score": 0.46,
          "base_score": 0.31,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "directplay",
          "voice",
          "message",
          "server",
          "group"
        ],
        "semantic": [],
        "merged": [
          "directplay",
          "voice",
          "message",
          "server",
          "group"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15396839842809762,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.924770+00:00"
      }
    },
    {
      "chapter_number": 59,
      "title": "Segment 59 (pages 558-566)",
      "start_page": 558,
      "end_page": 566,
      "summary": "Wireless Gaming Using the\nwriting games for a wireless device can feel lackluster.\nAnd there’s limited network con-\nnectivity; most second-generation wireless networks send data at 9.6 kbps (kilobits\nThe processors on wireless devices are also hundreds of times slower than\nIf a compelling wireless game caught fire, it would\nscreen, there's one thing mobile phone games offer chat even the best consoles can't\nmany wireless networks implement some form of mobile positioning.\nWireless games are not only portable and convenient to play, but with some clever\nAnother burgeoning field is in creating wireless extensions to existing games.\nexample, a mobile interface can tap into a persistent multiplayer game world that is\nLatency is the time it takes for a packet of data to travel from one point to another,\nMultiplayer game programmers struggle with the Internet's high latency and the\nSecond-generation (2G) wireless networks, how-\nCommunication (GSM), which sends data at 9.6 kbps.\nWide area wireless networks are also high latency because of the inherent inter-\nMost wireless networks force data\nSatellite-based wireless networks gen-\nFor the time being, then, wireless game designers should assume that they are\nJava (Sun Microsystems) is emerging as a standard language for wireless devices.\nstandard Java and pare them down for smaller devices, such as mobile phones, pagers,\n5.9 Wireless Gaming Using the Java Micro Edition 575\nSun to create the CLDC (Connected, Limited Device Configuration} [CLDC01],\nMobile phone manufacturers have embraced Java in a way that not even PC man-\nJava is emerging as the platform of choice for mobile devices.\nFor starters, we have no idea what type of network transport protocol a phone is\nDevices that work over circuit-switched networks can use streaming always-on\nswitched networks might only be able to handle its network data in discrete, nonguar-\nConnection class is a catch-all that can, in theory, handle any kind of network con-\nConnector .open{ “http: //java.sun.com/developer\");\nThe remote ‘server’ could, of course, be another mobile device.\nto-peer games, one of the peers generally acts as a server, and the other acts as a client.\nserver component in Java Standard Edition (or any other language), running on any\nUnfortunately, many wireless devices do not support datagrams.\nThe only protocol that MIDP devices must support is HTTP.\nommended that you design wireless games for the lowest common denominator—\nto bulk up your MIDlet with extra networking code.\n5.9 Wireless Gaming Using the Java Micro Edition 577\nA player moves, the new game state is sent\nHowever, if your game is more advanced and has unpredictable data packets com-\nfull-featured game server that uses UDP?\nate multiple connections—one that sends data to the server and one that stays alive,\nretrieving server data.\nThe server creates an open connection and assigns it some sort of unique ID.\nThe client can now create one client-to-server connection with an incredibly\nopen server-to-client connection.\nAnother way of creating robust wireless communications is to write your game server\nYou can then tap into the game server via an HTTP\ninstead of a game server.\nallow you to create a better experience for devices that support better network proto-\nFor example, devices that support datagrams can try communicating directly\nwith your game server.\nSo how do we create meaningful game traffic using HTTP over a high-latency, low-\nbandwidth network?\nIn effect, the challenge of creating a wireless game is similar to\nthat of any other multiplayer game: Packets must be as small as possible, and design-\ning the game around network limitations is tantamount.\nThe following game scenario illustrates a basic problem involving latency.\nthe game.\nIt might also be wise to have your game server measure the latency of packets it\nA typical multiplayer shooter-game server sends data at\ngame.\nBandwidth is usually not as much of an issue as latency, since game packets can often\nRather than send the game state every frame, you should delta-compress your\nThe game server should prioritize messages.\n5.9 Wireless Gaming Using the Java Micro Edition 579\nnately, there is no method to directly grab an image from the network, Rather, the\n// Create an image from the raw data\nIf you want images to look as good as possible on various mobile devices, it is rec-\nThat way, your game can send the device's\nThe biggest challenge in wireless networking, other than the limitations of the net-\nwork itself, is to balance limited device space, speed, and memory with advanced net-\nFitting both the game code and the networking\nDesigning games cleverly in order to make the most of limitations is always the\nsome types of games will simply not be possible until better wireless networks and\nWireless devices offer\noriginal wireless game concept can revolutionize the face of entertainment.\nGames,” Gamasutra.\n[CLDC01} Sun.com, “CLDC Information Page,” available online at hetp://java.\n[Fox01] Fox, David, “Creating Games Using J2ME,” Gamasutra.\n&.9 Wireless Gaming Using the Java Micro Edition 581\n(J2ME01] Sun.com, “J2ME Information Page,” available online at herp://java.sun\n[Javalmage01] Sun.com, “Java Advanced Imaging API,” available online at hetp://\njava.sun.com/products/midp/.",
      "keywords": [
        "Java Micro Edition",
        "Game",
        "Wireless",
        "Java",
        "wireless networks",
        "Java Micro",
        "wireless game",
        "Micro Edition",
        "wireless devices",
        "network",
        "game server",
        "data",
        "Java Standard Edition",
        "Wireless Gaming",
        "server"
      ],
      "concepts": [
        "gaming",
        "game",
        "networking",
        "java",
        "wireless",
        "device",
        "server",
        "mobile",
        "latency",
        "latencies"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 50,
          "title": "",
          "score": 0.719,
          "base_score": 0.569,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 53,
          "title": "",
          "score": 0.607,
          "base_score": 0.457,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 51,
          "title": "",
          "score": 0.555,
          "base_score": 0.405,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 54,
          "title": "",
          "score": 0.478,
          "base_score": 0.328,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 58,
          "title": "",
          "score": 0.46,
          "base_score": 0.31,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "wireless",
          "java",
          "server",
          "devices",
          "networks"
        ],
        "semantic": [],
        "merged": [
          "wireless",
          "java",
          "server",
          "devices",
          "networks"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.14754539468490255,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.924822+00:00"
      }
    },
    {
      "chapter_number": 60,
      "title": "Segment 60 (pages 567-574)",
      "start_page": 567,
      "end_page": 574,
      "summary": "Audio Compression with\nver since computers could produce sound, audio has been a part of games in\nThen, as sound cards became prevalent, MOD-type files became\nRedbook audio (normal CD audio) started to become popular, and finally games\ncial games to try and alleviate the size of music files while retaining the quality, but its\nHigh-quality music is now a must for any game, and\naudio and music in games, music files will have to get smaller.\nPsychoacoustic compression works by eliminating all the parts of the sound that the\n588 Section 6 Audio\nThe absolute threshold of hearing represents how loud a sound has to be at a cer-\nAny sounds that are\nHow Do Sound-Compression Techniques Compare?\nlet's take a look at how it compares to the other forms of audio compression that\nFor CD-quality audio,\nResampling uses fewer samples per second to represent the sound.\ngreatly reduced file sizes, but they come at the cost of quality and the loss of stereo.\n6.1 Audio Compression with Ogg Vorbis 589\nIt is sometimes used in games to shrink audio without the unaccept-\nthough, and does degrade audio quality.\nIt also only compresses audio to one quarter\nof the size, meaning that an hour’s worth of audio can still be almost 200 MB.\nOgg Vorbis [Ogg Vorbis02] stands above the rest as the perfect fit for games and\nMIDI with CD-quality audio for synchronized device control.\nFor example, using Ogg, a game developer could add synchronized mouth move-\nIf game developers want to keep advancing the current state of the art, the audio\ncompressed music into a game, considering several possibilities about speed require-\ncompressed audio in about 2% to 5% of the total processor time on Pentium III-class\nAlso, the type of sound being decoded is important as well.\nof several files at once.\nWith these situations in mind, let’s outline some ways that compressed audio can\nSection 6 Audio\nThe most common method of using Ogg in a game would be to decode audio on-the-\nIn this scenario, an audio stream has been completely encoded in Ogg format and\nis decoded and played in real-time while the game is running.\nlarge, uncompressed audio files sitting around on the player’s hard drive.\nIn this case, decoding the files to a cache on\nmentation to keep all audio data compressed that is not needed to be immediately\nThis is also a nice way to produce sound effects, The game could decode them\non-the-fly the first time they were used, and play the already decoded audio on subse-\nIf latency is a problem with decoding, the sound effects could be\n6.1 Audio Compression with Ogg Vorbis 591\nA few code examples will illustrate how easy it is to use Ogg Vorbis.\nThen, we must open the Ogg Vorbis file with an already open FILE*.\nNow that the Ogg file has been opened by the vorbisfile library, the library owns\nthe file.\nThe vorbis_info struct will contain information about the opened Ogg file, such\nnumber of bytes per sample (usually 2 bytes for 16-bit audio).\nNow that we have a buffer allocated for the entire decoded output, ov_read() is\nInstead, the code assumes that there is an audio_output() function that takes a buffer\n6.1 Audio Compression with Ogg Vorbis 593\nsend the current block to the audio_out:\naudio_out(pcmout, ret};\nwhen making compressed Ogg files, and understanding these will lead to better-\nsounding music and sound effects in your game.\nQuality and size are integrally related in Ogg, and both are controlled by a single\nIn Ogg, you adjust the ‘quality’ knob, which implicitly changes the size.\nthe bigger you're willing to make the file, the better it will sound; and conversely, the\nless quality you need, the smaller the file can be.\nThe size of compressed audio is measured by bit rate: the amount of bits used to\nOgg files should sound quite good at 64 kbps (kilobits per second) and should hardly\ntion; lower-bit-rate Ogg files should be more than enough to give gamers an excellent-\nTwo other knobs are the number of channels and the sample rate of the audio.\nhalve the sample rate, the audio sounds worse, but possibly not much worse.\nis at a premium, you can downmix and resample before compressing with Ogg. This\nleads to smaller files with an acceptable loss of audio quality.\n594 Section 6 Audio\nAs game audio grows in importance, it seems obvious that better forms of compres-\nyour next project, consider psychoacoustic compression with Ogg Vorbis.",
      "keywords": [
        "Vorbis Jack Moffitt",
        "Ogg Vorbis Jack",
        "Ogg Vorbis",
        "Audio",
        "Ogg",
        "Xiph.org Foundation",
        "Jack Moffitt",
        "Ogg Vorbis file",
        "Audio Compression",
        "file",
        "Ogg files",
        "sound",
        "Compression",
        "Ogg Vorbis Psychoacoustic",
        "Vorbis"
      ],
      "concepts": [
        "audio",
        "files",
        "sound",
        "compression",
        "compresses",
        "compressed",
        "quality",
        "games",
        "decode",
        "decoded"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 65,
          "title": "",
          "score": 0.655,
          "base_score": 0.505,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 61,
          "title": "",
          "score": 0.653,
          "base_score": 0.503,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 63,
          "title": "",
          "score": 0.606,
          "base_score": 0.456,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 66,
          "title": "",
          "score": 0.489,
          "base_score": 0.339,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 64,
          "title": "",
          "score": 0.479,
          "base_score": 0.329,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "ogg",
          "audio",
          "vorbis",
          "ogg vorbis",
          "sound"
        ],
        "semantic": [],
        "merged": [
          "ogg",
          "audio",
          "vorbis",
          "ogg vorbis",
          "sound"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.16412883940035952,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.924869+00:00"
      }
    },
    {
      "chapter_number": 61,
      "title": "Segment 61 (pages 575-584)",
      "start_page": 575,
      "end_page": 584,
      "summary": "Audio Environment\nhis gem will provide you with techniques for creating compelling 3D audio in\nyour games by applying a few simple rules to your audio engine design and the\nWe will introduce some basic concepts of 3D audio rendering, provide\ntips on how to maximize the effectiveness of your audio engine, and offer examples of\nnent 3D audio APIs, but the concepts should be transferable if you are using another\n3D Audio Core Concepts\nfundamental idea of a 3D audio engine is to provide a way to use the same three-\nto 3D positional audio rendering and are critical to your audio engine design.\nThere is a single ‘listener’ object representing where the sound is heard in the 3D\nEach sound-producing object in the environment is represented by a source.\nsources are mixed and represented at the listener’s position, and each corresponds to a\nA buffer object contains the actual audio data.\nIn OpenAL, the audio data is separated from\n596 Section6 Audio\nsources.\nIn DirectSound 3D, a buffer and a source are the same\nIn OpenAL, a source object directly corte-\nwhich should convincingly portray the 3D audio world.\nand attenuation characteristics are for each source at the listener's position.\ntive positions and orientations of the listener, and each source can be used to figure\nThe distance between each source and the listener\ndetermines the attenuation of each source, and the resulting audio is then mixed and\nUsing Your Audio Engine Effectively\nhelp you maximize the quality of a 3D audio engine.\nIf you intend to apply effects to your audio, make sure there are no effects applied to\n6.2 Creating a Compoliing 3D Audio Environment 507\nto provide the correct information to the low-level API so that it can render the audio\nproperly, This means that the audio API needs to understand the physical parameters\nIf the audio world units are in meters, but the game world is in\n3D position, the low-level API {e.g., DirectSound 3D, OpenAL) will have global and\naudio, then you will need to set per-source reference distance appropriately.\nOpenAL and DirectSound 3D have a notion of directional audio as well—an under-\nSpeed of sound AL_ DOPPLER VELOCITY DistanceFactor, applied to listener\nTable 6.2.2 Examples of Per-Source Properties in OpenAL and DirectSound 3D\nProcess the audio to accommodate the game environment.\neffects does not need to be limited to dry audio, either—filtering and additional\nIn most games, the audio\nThe audio data should be normalized and dry.\nThe global parameters are all applied only once, and after the audio data is loaded.\n3) Adjust Per-Source Parameters\nSome games set the audio parameters less fre-\n6.2 Creating a Compeiling 3D Audio Environment 599\nBoth global and per-source effects are being used in the demo program.\nper-source EAX effects.\nAny game will need to apply both global and per-source\nCreating a compelling 3D audio environment for your game is a difficult job with\n[Loki01] Loki Entertainment Software, “OpenAL | Open Source Audio Library,”\nThe OpenAL source -\ndirectly from source to listener.\nbeing obstructed, Figure 6.3.1 shows the unobstructed and obstructed sound source.\nwe can use that value to determine the gain of a low-pass filter applied to our sound\nFIGURE 6.3.1 An unobstructed (left) versus obstructed (right) sound source.\n6.3 Obstruction Using Axis-Aligned Bounding Boxes 601\nchoose to evaluate is the edge closest to the sound source.\nbuild an angle, o, from the vectors that go from source to corner to listener.\nTo speed up the process even further, we can use axis-aligned bounding boxes\nTo calculate this angle given our source position, listener position, and obstruc-\ntion bounding box, we start by computing two bit vectors, one for the source and one\nSection6 Audio\nSource\nFIGURE 6.3.3 Obstruction covered by axis-aligned bounding box.\nA set bit indicates that the source or listener is in front of that plane; this code\nthe source and the listener are in front of the same plane.\ning-box planes closest to the source.\ndetermine the zone that the source is in (26 possible zones outside of the bounding box\n6.3 Obstruction Using Axis-Aillgned Bounding Boxes 603\ncase 0x01:// Behind bounding box\nFor each plane, we check to see if it intersects the source/listener vector.\n604 Section6 Audio\nWith the intersection point now on an edge of the bounding box, we can com-",
      "keywords": [
        "Audio",
        "audio data",
        "audio engine",
        "source",
        "bounding box",
        "Listener",
        "Audio Source Bounding",
        "obstruction",
        "Audio Environment Garin",
        "Audio Environment",
        "Bounding",
        "box",
        "sound",
        "effects",
        "sound source"
      ],
      "concepts": [
        "audio",
        "sources",
        "obstruction",
        "obstructed",
        "sound",
        "tips",
        "tip",
        "effectiveness",
        "object",
        "boxes"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 60,
          "title": "",
          "score": 0.653,
          "base_score": 0.503,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 65,
          "title": "",
          "score": 0.619,
          "base_score": 0.469,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 66,
          "title": "",
          "score": 0.556,
          "base_score": 0.406,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 63,
          "title": "",
          "score": 0.478,
          "base_score": 0.328,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 64,
          "title": "",
          "score": 0.46,
          "base_score": 0.31,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "audio",
          "source",
          "listener",
          "3d audio",
          "3d"
        ],
        "semantic": [],
        "merged": [
          "audio",
          "source",
          "listener",
          "3d audio",
          "3d"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19886446992738008,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.924915+00:00"
      }
    },
    {
      "chapter_number": 62,
      "title": "Segment 62 (pages 585-592)",
      "start_page": 585,
      "end_page": 592,
      "summary": "Resonant Filter\nmultipurpose resonant filter.\nBy changing the filter coefficients, it can perform\nvarious filter-pass operations, such as low pass, band pass, high pass, band stop, and\nbiquad filter, and how to calculate coefficients for various functions.\nof the sound-filtering techniques and synthesis tricks will be provided.\nYou can use a filter to change the character of a sound.\nFilters change the amplitude\nHowever, if you pass a sample through a filter while changing para-\n(Examples of using a biquad filter to create complex sound effects are also given in\na higher frequency sound will have a greater phase change because the time delay is a\n6.4 Using the Biquad Resonant Filter 607\nA typical digital filter contains a delay line made up of successive, one-sample\npass filter is:\nBecause this filter passes low frequencies more\nthan high frequencies, we call this simple averaging filter a /ow-pass filter.\nA high-pass filter can be constructed by changing the plus (+) sign in the equa-\ntion for the low-pass filter to a minus (—) sign.\nThe simple high-pass filter equa-\nInfinite impulse response (IIR) filters use delayed versions of both the incoming\nIIR filters.\nThe Biquad Filter Implementation\nThe biquad filter has three taps on the input side and two on the output side\nThe equation for this filter is:\nBy changing the coefficients, a, 2), 42, 6, and &, you can make the filter behave\nas a low-pass, high-pass, band-pass, band stop, peaking EQ, or other type of filter.\nfor the filter operation is in a loop.\n{/ Generate outputs by filtering inputs.\nperform two filters per loop.\n// Generate outputs by filtering inputs.\n6.4 Using the Biquad Resonant Filter 609\nAlso, many of the filter types have coefficients that are the same or zero; so, you\nControlling the Filter\nThere are two parameters that control the behavior of the filter: the cutoff frequency\nFor a low-pass filter, frequencies above the cutoff frequency will\nFor a high-pass filter, frequencies below the cutoff frequency will\nback in the filter.\nCalculating Coefficients for the Filter\nDigital filters simply operate on a stream of numbers or samples.\nSo before calculating the filter, we convert the cutoff frequency\nLow-pass filters reduce the high frequency content of a sound and pass the low-\n{* Coefficients for LowPass Filters */\nLow-pass filters, when combined with reverberation, can make a sound seem\nRinging low-pass filters can be use to create unusual |\nHigh-pass filters reduce the low frequency content of a sound and pass the high-\nHigh-pass filters can be used to make a voice sound tinny, like it is on a telephone\n6.4 Using the Biquad Resonant Filter 611\nBand-Pass Filters\nBand-pass filters reduce the frequencies on either side of a center frequency.\nresponse curve of a band-pass filter, this frequency will be at the center of the peak.\n/* Coefficients for BandPass Filters */\nYou can combine low-pass and high-pass filters in series by passing the output of one\nfilter to the input of another.\nalso combine low-pass and high-pass filters to create custom band-pass filters with a\nCombining three or more band-pass filters can create formats that create vocal\nnoise or an impulse train through the filters to hear how they sound, You can also\nchange the resonance of the filter.\nThe filter frequency is slowly swept up and down\nA biquad filter gives us a simple way to modify the character of a sound without using\nshows us how to implement a filter efficiently, and the example software shows us\nhow to filter sounds and play the result.",
      "keywords": [
        "Filter",
        "biquad filter",
        "Biquad Resonant Filter",
        "Resonant Filter",
        "sound",
        "frequency",
        "Biquad",
        "High-pass filters",
        "Band-Pass Filters",
        "Low-pass filters",
        "coefficients",
        "omega",
        "digital filters",
        "frequencies",
        "Biquad Filter Implementation"
      ],
      "concepts": [
        "filter",
        "filtering",
        "sound",
        "frequencies",
        "frequency",
        "audio",
        "passes",
        "passing",
        "delaying",
        "input"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 63,
          "title": "",
          "score": 0.523,
          "base_score": 0.373,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 65,
          "title": "",
          "score": 0.504,
          "base_score": 0.354,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 64,
          "title": "",
          "score": 0.413,
          "base_score": 0.263,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 60,
          "title": "",
          "score": 0.405,
          "base_score": 0.255,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 61,
          "title": "",
          "score": 0.38,
          "base_score": 0.23,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "filter",
          "pass",
          "filters",
          "pass filters",
          "biquad"
        ],
        "semantic": [],
        "merged": [
          "filter",
          "pass",
          "filters",
          "pass filters",
          "biquad"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.05490727727750926,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.924958+00:00"
      }
    },
    {
      "chapter_number": 63,
      "title": "Segment 63 (pages 593-601)",
      "start_page": 593,
      "end_page": 601,
      "summary": "Voice Compression and\nvocoder is a device for altering speech, now made famous by that Cher song,\nVocoders are best known for the robot voices they produce,\n[Lucas99], but they can also produce bizarre alien voices, as well as “singing” guitars\nAlthough voice effects and voice compression seem like different problems, the\nThe algorithm we present here is called linear predictive coding (LPC) and\nModeling the Voice\nLPC attempts to model the way speech is produced in the human body, but in such a\ngeneral way that it can also model sound production under different circumstances.\nresonator (see Figure 6.5.2).\nOscillator Voice Signal\nvibrates, producing sound waves.\nThe human voice is no exception; the person's vocal chords is che oscillator.\n6.6 Linear Predictive Coding for Volce Compression and Effects 615\nA resonator acts as a natural amplifier for the sound produced by the\nresonance helps to actually reduce inharmonic sounds from the strings.\ntion of the resonator, since the oscillator (mouthpiece) is incapable of changing pitch.\ninterior cavities of the head, through which the sound from the vocal chords travels\nSince the resonator can change its characteristics over time, we break the model-\nbe simulated with a sample player, and the resonator is modeled with a digital filter.\nThe oscillator feeds samples to the filter, and speech is produced.\nand produces a sequence of filtered output samples.\nThe filter works by calculating\n// re[] = reflection coefficients\nIf we invert that filter and run the speech through it, we will get the\noscillator output signal.\n(When we run the filter this way, the oscillator signal is called\n// re{] = reflection coefficients\nIn our analysis phase, we have the speech signal, but\nnot the oscillator signal.\nNow we can extract the oscillator signal (residual) to be used\nAll we need are the reflection coefficients.\n6.5 Linear Predictive Coding for Volce Compression and Effects 617\nVoice Signal\nOscillator Signal\nThe code on the CD-ROM uses Schur’s algorithm [Degener94], which is\nsis—which (barring rounding errors) reproduces the original speech sample precisely.\nThe only parameters are frame time (in samples) and filter complexity (number of\nreflection coefficients).\nThe test code uses frames of 20 ms (160 samples at 8 kHz)\nand eight reflection coefficients.\nwith a synthesized sound.\nThis synthesized sound is then filtered, and the end result is\nThe important thing to remember here is that the synthesized sound is merely\nbeing filtered, so any frequencies that are not in the sound to begin with will not be in\nnot generate interesting sounds.\ntry to use a sound that is rich in frequency content.\nThese choices give more alien-sounding voices, with weirder input waveforms\nIf that sample is the residual, we get\nactivate our vocal chords at all, and the oscillator signal is just a hiss.\nThe only difficult part of generating the new oscillator signal is getting the pitch and\n6.5 Linear Predictive Coding for Voice Compression and Effects 619\nover the residual for each frame of the sound.\nFirst, assume the pitch is less than 1 kHz, and filter the residual using a low-pass filter\nwaveform then passes through the filter to give the resultant resynthesized speech.\nNote that the parameters of the speech (pitch, volume, and reflection coefficients)\nDigital Filter Voice Signal\nFIGURE 6.5.4 The speech resynthesizer.\nters and the speed).\nSince our reflection coefficients reflect a physical model of a resonator, we can change\nthe resonator by changing the coefficients.\nIf we begin with 8 reflection coefficients, we could generate 16\nAlternatively, by cropping reflection coefficients off, the filter becomes more\n‘shallow-—the speech becomes indistinct and sounds as if the speaker has just been to\nGiven the pitch, volume, and eight reflection coefficients, we now have 10 numbers\nper frame describing everything we need to generate a robotic or alien voice.\ngenerate a variety of male voices from a single source sample.\nThe residual signal is quite hard to encode, because it does contain a lot of\nFor instance, most speech sounds use the vocal chords, but\nOther sounds, like a “p”, are made by a different process altogether-—in this case,\nThe plosive is not well modeled by the vocal-chord-plus-filter model, so most\nWe might be able to model these sounds\n6.5 Linear Predictive Coding for Volce Compression and Effects 621\nand two multiplies per coefficient per sample.\nIn this case, some work would have to be done on the encod-\nYou can load speech samples into the pro-\ncan be played back using either the residual or a voice defined in the program.\n[Degener94] Degener, Jutta, “Digital Speech Compression,” Dr. Dobbs Journal\n[Degener00] Degener, Jutta, “GSM 06.10 Lossy Speech Compression,” available",
      "keywords": [
        "Linear Predictive Coding",
        "oscillator signal",
        "reflection coefficients",
        "speech",
        "oscillator",
        "filter",
        "Signal",
        "coefficients",
        "LPC",
        "sound",
        "resonator",
        "Voice",
        "Predictive Coding",
        "Voice Signal Oscillator",
        "Linear Predictive"
      ],
      "concepts": [
        "speech",
        "voice",
        "sound",
        "sample",
        "waveform",
        "filter",
        "filtered",
        "effects",
        "oscillator",
        "linear"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 65,
          "title": "",
          "score": 0.638,
          "base_score": 0.488,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 60,
          "title": "",
          "score": 0.606,
          "base_score": 0.456,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 62,
          "title": "",
          "score": 0.523,
          "base_score": 0.373,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 64,
          "title": "",
          "score": 0.482,
          "base_score": 0.332,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 61,
          "title": "",
          "score": 0.478,
          "base_score": 0.328,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "speech",
          "oscillator",
          "signal",
          "coefficients",
          "voice"
        ],
        "semantic": [],
        "merged": [
          "speech",
          "oscillator",
          "signal",
          "coefficients",
          "voice"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.13188963318198965,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.925001+00:00"
      }
    },
    {
      "chapter_number": 64,
      "title": "Segment 64 (pages 602-609)",
      "start_page": 602,
      "end_page": 609,
      "summary": "Complex Sounds\ncan use random numbers at a low level to generate noise.\nas a sound source or a modulation source.\nMost games use digital audio samples to create sounds.\nsounds do not sound the same every time.\nSamples are sometimes used to create continuous sounds, such as wind.\nsynthesis is that the sound designer has control over many more parameters.\nThese will include filters, noise generators, oscillators or tone genera-\nYou cannot generate truly random numbers using software.\nsound random, even if they aren't really random.\n6.6 The Stochastic Synthesis of Comptex Sounds 623\nThe most common and cheapest pseudo-random number generator is the linear\nthen feed the result back into the function to generate a sequence of random\nSo, if you want to generate 16-bit random numbers, shift right and use the top 16 bits\nThe direct result of the Linear Congruential Algorithm is white noise, which sounds\nYou can generate red noise by calculating a new random number every few sam-\nover the following code to generate samples or a control signal.\nFIGURE 6.8.1 (Left) White noise with new random values for every sample.\nnoise with samples interpolated between random values.\nGenerating a Wind Sound\nA wind sound can be generated using a white noise generator (WhiteNoise) as the\nsound source.\nNoise) controls the cutoff frequency of the filter and mimics the random rising and\noutput by the modDepth and add the result to the frequency value to generate the\nthese generators will create a more realistic sound.\nThe sound slowly fades away over time.\n6.6 The Stochastic Synthesis of Complex Sounds 625\nFIGURE 6.6.2 A wind sound example.\nabout 700 Hz. To make the filter ring for a longer time, set the @ to larger values, like\nTo increase the sound of the ‘ping’ try setting the Impulse amplitude to seven.\nTo make it sound like it is\ngenerator.\nThe circuit is identical to the wind sound example shown in Figure 6.6.1, except\nGenerating the Sound of Rain\nWe cannot generate the sound of each individual\nsound.\nSo, instead we use the familiar ringing filter to generate the plop.\nThe ringing filter will always generate the same pitch every time we hit it unless\nNoise generator, as we have in the previous examples.\nThe ringing filter will give us the sound of individual raindrops that are near to\nWe can use a reverb effects processor to echo the sound of a\nfew raindrops and create the sound of many raindrops.\npass filter that muffles the sound of the other raindrops and makes them seem farther\n6.6 The Stochastic Synthesis of Compiex Sounds 627\nGenerating a Rocket Engine Sound\nA decent rocket engine sound can be generated using just two RedNoise generators.\nSo we can use one RedNoise generator to medulate the frequency\nFigure 6.6.4 illustrates the rocket engine sound\nGenerating a Helicopter Rotor Sound\nThis sound uses filtered white noise as the source sound as in the wind example.\nIt then passes the sound through two variable delays.\nFIGURE 6.6.4 Rocket engine sound using red noise pair and an envelope generated by a\nThe speed of sound is\nThe previous code example generates the proper modDepth.\nFIGURE 6.6.5 Helicopter rotor sound created using Doppler shifts 180° out of phase.\n6.6 The Stochastic Synthesis of Complex Sounds 629\nexperiment with these sounds.\nUsing just a few simple unit generators, you can synthesize a wide variety of sounds\nThis gives you more control over the sound parameters\nStochastic processes are also useful at a higher level to trigger short sound events, such\nsound generators than are actually present in the circuit.",
      "keywords": [
        "sound",
        "filter",
        "noise",
        "Wind Sound",
        "Stochastic Synthesis",
        "generate",
        "Rocket Engine Sound",
        "random",
        "frequency",
        "Engine Sound",
        "Synthesis",
        "random numbers",
        "phase",
        "red noise",
        "Complex Sounds"
      ],
      "concepts": [
        "sounds",
        "generate",
        "generators",
        "generating",
        "filters",
        "filtered",
        "value",
        "examples",
        "phase",
        "noise"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 65,
          "title": "",
          "score": 0.718,
          "base_score": 0.568,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 16,
          "title": "",
          "score": 0.512,
          "base_score": 0.512,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 46,
          "title": "",
          "score": 0.505,
          "base_score": 0.505,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 63,
          "title": "",
          "score": 0.482,
          "base_score": 0.332,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 60,
          "title": "",
          "score": 0.479,
          "base_score": 0.329,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "sound",
          "noise",
          "sounds",
          "random",
          "wind"
        ],
        "semantic": [],
        "merged": [
          "sound",
          "noise",
          "sounds",
          "random",
          "wind"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1464070281117622,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.925047+00:00"
      }
    },
    {
      "chapter_number": 65,
      "title": "Segment 65 (pages 610-617)",
      "start_page": 610,
      "end_page": 617,
      "summary": "game to procedurally generate sounds in real-time, Often games use one-shot or\nlooped samples to play game sounds.\nactions, Procedural sound generation with modular audio processing provides many\nModular audio processing systems can be created in software using virtual modules\nYou create a sound by connecting units like oscilla-\nThe data flow of audio processing is determined by the connections that are cho-\nthe only way to save a patch with all its connections was by shooting a Polaroid.\nPatches are created by appending DSP units to a processing chain.\nplex components can be built on top of simpler patches, using units that represent\n6.7 Real-Time Modular Audio Processing for Games 631\nProcedural Sound Generation\nsubtractive synthesizer has an oscillator that generates the basic audio tone, mostly a\nmodulators; so over time, the sound changes dynamically in pitch, timbre, and\nConnected to an audio oscillator, you will get vibrato.\nThe other modulator is the envelope generator (EG) for one-shot\nAnother important synthesis method is FM modulation, a frequency (or phase)\nmodulation in audio range.\nbe used to generate procedural sounds in your games.\nProcessor Unit, Filter, Block, Node, (DSP} Module\nSphinx MMOS defaults to 256 samples.\ntypes are oscillators, noise generators, envelopes, filters, and mixers.\ntrol triggering of sounds, there are processors for impulse generation, sequencing, and\nTable 6.7.2 Some of the Processors in Sphinx MMOS\nOscillators Noise Generators\n6.7 Real-Time Modular Audio Processing for Games 633\nIt’s an oscillator with a base frequency of 200 Hz, modulated\nby an LFO at 3.5 Hz. FMAttenuation is set to 0.1, which limits the modulation depth\nAll processors of the audio chain are listed inside the patch.\nCGAPatch “Sine Oscillator with LFO Modulation\"\nThe last line of the patch connects the sample output of the LFO with the (bipo-\nlar) frequency modulation input of the VCO.\nthat patch right into your game:\n“Sine Oscillator with LFO Modulation\");\nThe first line creates a new patch and appends it to the application's patch list.\nappends it to the list of processors in our patch.\nwe connect the pin Samp1e0ut of oscillator zero with the input pin FM of oscillator one.\naudio rendering, the current version of Sphinx MMOS uses its own set of wrapper\nPatch File Applications\nprocessors and their connections, an infinite variety of patches are possible.\ntake the place of certain processors in a given patch, thus giving us organic control\nover digital sound generation and signal processing.\naudio stream at the sample rate.\nTo show how we can apply this patch system to games, we will now describe how\npatch configurations can be designed to simulate engine sounds.\nA vehicle sound is a complex signal produced by several sources.\n6.7 Real-Time Modular Audio Processing for Games 635\nAt low speed, the sound signature is dominated by these deterministic components,\nThe basic idea behind an engine patch is to simulate the alternating phases of a\nsound.\nIn order to generate sophisticated and less-predictable sounds, we combine\nlooped and simple one-shot samples with synthesized sounds, We will use a sequencer\nto control the timing of the sounds.\nEach impulse at the inpur of the selector selects che next sound source input, and it\n¢ The PowerStroke patch simulates the generic, four-cylinder, four-stroke engine.\nning of the patch file, we load the samples into the CGASignal objects and give\nspeed of the impulse generator, the RPM, is controlled by a low-frequency oscil-\n* The Turbine patch plays a turbine sample loop.\nThe cGAWavetableOscillator is frequency modulated by a smoothed LFO\nhere to combine the modulation signals from the LFO and the VCO.\nis the Turbine AudioFM1 patch.\n* The Rotor—Enveloped Sample patch demonstrates a looping sample that is\nsample m_propeller01.wav consists of a strong noise component and a low-fre-\nThe turbine’s frequency and the trigger speed of the envelope are controlled\n¢ The Helicopter with Turbine, Rotor and Flap Fx patch uses sequenced waveta-\nComponents of this patch are the Jet/Turbine Engine with its\nparameters, an additional generator to intensify air noise at greater speeds, and\nIn our patch,\nsound signature of a submarine, we use two special oscillators to generate pink noise-\n6.7 Real-Time Modular Audio Processing for Games 637\nThe propeller sound is simulated by a looped sample containing higher frequen-\n* The Sonar—Noise Modulated Sine Patch is a sine wave of 2000 Hz, with\namplitude modulated by a descending ramp and frequency modulated by noise.\nThe noise modulation is shaped by an envelope to get a fade-in effect, thus the\n* The Submarine—Engine Only is just an amplitude-modulated sample with an\npatches introduce two special oscillators for tonal noise generation, the\nNo additional filter is used for this patch.\nof the above sonar patch and add frequency modulation on the engine sample to\npatch files, and samples.\nSome patch files demonstrate the various processors, and",
      "keywords": [
        "modular audio processing",
        "Sphinx MMOS",
        "Sphinx MMOS System",
        "Modular Audio",
        "audio processing",
        "Real-Time Modular Audio",
        "Audio",
        "patch",
        "sound",
        "Sphinx MMOS Oscillators",
        "Sphinx",
        "MMOS",
        "Games Frank Luchs",
        "sample",
        "Processing"
      ],
      "concepts": [
        "patch",
        "patches",
        "modules",
        "modulations",
        "modulation",
        "modulated",
        "modulates",
        "noise",
        "audio",
        "frequency"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 64,
          "title": "",
          "score": 0.718,
          "base_score": 0.568,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 60,
          "title": "",
          "score": 0.655,
          "base_score": 0.505,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 63,
          "title": "",
          "score": 0.638,
          "base_score": 0.488,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 61,
          "title": "",
          "score": 0.619,
          "base_score": 0.469,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 8,
          "title": "",
          "score": 0.523,
          "base_score": 0.373,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "patch",
          "audio",
          "sound",
          "modulation",
          "modular"
        ],
        "semantic": [],
        "merged": [
          "patch",
          "audio",
          "sound",
          "modulation",
          "modular"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24256329514701697,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.925093+00:00"
      }
    },
    {
      "chapter_number": 66,
      "title": "Segment 66 (pages 618-618)",
      "start_page": 618,
      "end_page": 618,
      "summary": "ented Media Composition Framework.” available online at hwtp://citeseer.nj.\nform Audio API,” available online at http://www.portaudio.com, 2001.\n[GENRef] Generator by Native Instruments, available online at hetp://www.native-\n[MAXRef] MAX / MSP by Cycling 74, available online at hitp://www.cycling74.\n[PD Ref] Puckette, Miller, “Pure Data Dot Org,” available online at http://www.pure-\n[Visiomedia] Updates to the Sphinx MMOS system, available online at hetp://\nFinite Volume Scheme,” available online at http://www.ae.gatech.edu/-Isankar/",
      "keywords": [
        "online",
        "Sphinx base interface",
        "Sphinx MMOS system",
        "Section",
        "Sphinx",
        "online at http",
        "Audio",
        "Sphinx MMOS",
        "Media Composition Framework",
        "Sphinx base",
        "original Sphinx",
        "Charles River Media",
        "plug-in",
        "American Helicopter Society",
        "Classic Super Mario"
      ],
      "concepts": [
        "audio",
        "available",
        "sounds",
        "helicopter",
        "games",
        "pure",
        "playback",
        "media",
        "procedural",
        "files"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 61,
          "title": "",
          "score": 0.556,
          "base_score": 0.406,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 65,
          "title": "",
          "score": 0.496,
          "base_score": 0.346,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 60,
          "title": "",
          "score": 0.489,
          "base_score": 0.339,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 8,
          "title": "",
          "score": 0.444,
          "base_score": 0.294,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 63,
          "title": "",
          "score": 0.416,
          "base_score": 0.266,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "sphinx",
          "online",
          "available online",
          "www",
          "available"
        ],
        "semantic": [],
        "merged": [
          "sphinx",
          "online",
          "available online",
          "www",
          "available"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1388775793259436,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:05:24.925136+00:00"
      }
    }
  ],
  "total_chapters": 66,
  "enrichment_provenance": {
    "taxonomy_id": "none",
    "taxonomy_version": "none",
    "taxonomy_path": "none",
    "taxonomy_checksum": "sha256:none",
    "source_metadata_file": "Game Programming Gems 3_metadata.json",
    "enrichment_date": "2025-12-17T23:05:24.934908+00:00",
    "enrichment_method": "msep",
    "model_version": "ai-agents-msep-v1",
    "processing_time_ms": 5102.48412799956,
    "total_similar_chapters": 311
  }
}