{
  "metadata": {
    "title": "makinggames",
    "author": "Al Sweigart",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 365,
    "conversion_date": "2025-11-28T12:14:47.546182",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "makinggames.pdf",
    "extraction_method": "PyMuPDF (Direct: 365, OCR: 0)"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "detection_method": "topic_boundary",
      "content": " \n \nMaking Games with \nPython & Pygame \n \n \n \n \n \n \n \n \n \n \n \n \n \nBy Al Sweigart \n \n\n\n \n \nEmail questions to the author: al@inventwithpython.com \n \nCopyright © 2012 by Albert Sweigart \nSome Rights Reserved. ―Making Games with Python & Pygame‖) is licensed under a Creative \nCommons Attribution-Noncommercial-Share Alike 3.0 United States License. \nYou are free: \n To Share — to copy, distribute, display, and perform the work \n To Remix — to make derivative works \nUnder the following conditions: \n Attribution — You must attribute the work in the manner specified by the author or \nlicensor (but not in any way that suggests that they endorse you or your use of the work). \n(Visibly include the title and author's name in any excerpts of this work.) \n Noncommercial — You may not use this work for commercial purposes. \n Share Alike — If you alter, transform, or build upon this work, you may distribute \nthe resulting work only under the same or similar license to this one. \n \nThis summary is located here: http://creativecommons.org/licenses/by-nc-sa/3.0/us/ \n \nYour fair use and other rights are in no way affected by the above. There is a human-readable \nsummary of the Legal Code (the full license), located here: \nhttp://creativecommons.org/licenses/by-nc-sa/3.0/us/legalcode \n \nBook Version 2 \nIf you've downloaded this book from a torrent, it’s probably out of date. Go \nto http://inventwithpython.com/pygame to download the latest version.  \n \nISBN (978-1469901732) \n1st Edition \n \n\n\n \n \n \n \n \n \nFor Calvin Chaos \n \n\n\n \n \nEmail questions to the author: al@inventwithpython.com \n \n \n\n\nWho is this book for?    i \n \n \nWHO IS THIS BOOK FOR?  \nWhen you get down to it, programming video games is just about lighting up pixels to make \npretty pictures appear on the screen in response to keyboard and mouse input. \nAnd there are very few things that are as fun. \nThis book will teach you how to make graphical computer games in the Python programming \nlanguage using the Pygame library. This book assumes you know a little bit about Python or \nprogramming in general. If you don’t know how to program, you can learn by downloading the \nfree book ―Invent Your Own Computer Games with Python‖ from http://inventwithpython.com. \nOr you can jump right into this book and mostly pick it up along the way. \nThis book is for the intermediate programmer who has learned what variables and loops are, but \nnow wants to know, ―What do actual game programs look like?‖ There was a long gap after I first \nlearned programming but didn’t really know how to use that skill to make something cool. It’s \nmy hope that the games in this book will give you enough ideas about how programs work to \nprovide a foundation to implement your own games. \nThe full text of this book is available in HTML or PDF format at \nhttp://inventwithpython.com/pygame. \n-Al Sweigart \n\n\nii    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nABOUT THIS BOOK \nHello! This book will teach you how to make graphical computer games with the Pygame \nframework (also called the Pygame library) in the Python programming language. Pygame makes \nit easy to create programs with 2D graphics. Both Python and the Pygame framework can be \ndownloaded for free from http://python.org and http://pygame.org. All you need is a computer \nand this book to begin making your own games. \nThis book is an intermediate programming book. If you are completely new to programming, \nyou can still try to follow along with the source code examples and figure out how programming \nworks. However, it might be easier to learn how to program in Python first. ―Invent Your Own \nComputer Games with Python‖ is a book that is available completely for free from \nhttp://inventwithpython.com. That book teaches programming by making non-graphical, text-\nbased games for complete beginners, and also has a few chapters about using the Pygame library. \nHowever, if you already know how to program in Python (or even some other language, since \nPython is so easy to pick up) and want to start making games beyond just text, then this is the \nbook for you. The book starts with a short introduction to how the Pygame library works and the \nfunctions it provides. Then it provides the complete source code for some actual games and \nexplains how the code works, so you can understand how actual game programs make use of \nPygame. \nThis book features seven different games that are clones of popular games that you’ve probably \nalready played. The games are a lot more fun and interactive than the text-based games in ―Invent \nwith Python‖, but are still fairly short. All of the programs are less than 600 lines long. This is \npretty small when you consider that professional games you download or buy in a store can be \nhundreds of thousands of lines long. These games require an entire team of programmers and \nartists working with each other for months or years to make. \nThe website for this book is http://inventwithpython.com/pygame. All the programs and files \nmentioned in this book can be downloaded for free from this website, including this book itself. \nProgramming is a great creative activity, so please share this book as widely as possible. The \nCreative Commons license that this book is released under gives you the right to copy and \nduplicate this book as much as you want (as long as you don’t charge money for it). \nIf you ever have questions about how these programs work, feel free to email me at \nal@inventwithpython.com. \n \n\n\nAbout This Book    iii \n \nTABLE OF CONTENTS \nWho is this book for? ........................................................................................................................ i \nAbout This Book .............................................................................................................................. ii \nChapter 1 – Installing Python and Pygame ...................................................................................... 1 \nWhat You Should Know Before You Begin ................................................................................ 1 \nDownloading and Installing Python ............................................................................................. 1 \nWindows Instructions .................................................................................................................. 1 \nMac OS X Instructions ................................................................................................................. 2 \nUbuntu and Linux Instructions .................................................................................................... 2 \nStarting Python............................................................................................................................. 2 \nInstalling Pygame......................................................................................................................... 3 \nHow to Use This Book ................................................................................................................. 4 \nThe Featured Programs ................................................................................................................ 4 \nDownloading Graphics and Sound Files ...................................................................................... 4 \nLine Numbers and Spaces ............................................................................................................ 4 \nText Wrapping in This Book ....................................................................................................... 5 \nChecking Your Code Online ........................................................................................................ 6 \nMore Info Links on http://invpy.com ........................................................................................... 6 \nChapter 2 – Pygame Basics .............................................................................................................. 7 \nGUI vs. CLI ................................................................................................................................. 7 \nSource Code for Hello World with Pygame ................................................................................ 7 \nSetting Up a Pygame Program ..................................................................................................... 8 \nGame Loops and Game States ................................................................................................... 10 \npygame.event.Event Objects ........................................................................................... 11 \nThe QUIT Event and pygame.quit() Function .................................................................. 12 \nPixel Coordinates ....................................................................................................................... 13 \n\n\niv    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nA Reminder About Functions, Methods, Constructor Functions, and Functions in Modules (and \nthe Difference Between Them) .................................................................................................. 14 \nSurface Objects and The Window ............................................................................................. 15 \nColors ......................................................................................................................................... 16 \nTransparent Colors ..................................................................................................................... 17 \npygame.Color Objects .......................................................................................................... 18 \nRect Objects ............................................................................................................................... 18 \nPrimitive Drawing Functions ..................................................................................................... 20 \npygame.PixelArray Objects .............................................................................................. 23 \nThe pygame.display.update() Function ...................................................................... 24 \nAnimation .................................................................................................................................. 24 \nFrames Per Second and pygame.time.Clock Objects ....................................................... 27 \nDrawing Images with pygame.image.load() and blit() ............................................ 28 \nFonts ........................................................................................................................................... 28 \nAnti-Aliasing.............................................................................................................................. 30 \nPlaying Sounds........................................................................................................................... 31 \nSummary .................................................................................................................................... 32 \nChapter 3 – Memory Puzzle .......................................................................................................... 33 \nHow to Play Memory Puzzle ..................................................................................................... 33 \nNested for Loops ..................................................................................................................... 33 \nSource Code of Memory Puzzle ................................................................................................ 34 \nCredits and Imports .................................................................................................................... 42 \nMagic Numbers are Bad ............................................................................................................ 42 \nSanity Checks with assert Statements ................................................................................... 43 \nTelling If a Number is Even or Odd .......................................................................................... 44 \nCrash Early and Crash Often! .................................................................................................... 44 \nMaking the Source Code Look Pretty ........................................................................................ 45 \nUsing Constant Variables Instead of Strings ............................................................................. 46 \nMaking Sure We Have Enough Icons ........................................................................................ 47 \nTuples vs. Lists, Immutable vs. Mutable ................................................................................... 47 \n",
      "page_number": 1,
      "chapter_number": 1,
      "summary": "This chapter covers segment 1 (pages 1-8). Key topics include programming, program, and book. ―Making Games with Python & Pygame‖) is licensed under a Creative \nCommons Attribution-Noncommercial-Share Alike 3.0 United States License.",
      "keywords": [
        "Book",
        "Python",
        "Pygame",
        "Games",
        "Albert Sweigart",
        "computer games",
        "source code",
        "Pygame library",
        "Code",
        "Making Games",
        "Installing Python",
        "work",
        "programming",
        "programs",
        "Making"
      ],
      "concepts": [
        "programming",
        "program",
        "book",
        "making",
        "make",
        "games",
        "work",
        "functions",
        "function",
        "objects"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 2,
          "title": "Segment 2 (pages 19-41)",
          "relevance_score": 0.67,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.62,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 42,
          "title": "Segment 42 (pages 849-853)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 2,
          "title": "Segment 2 (pages 9-18)",
          "relevance_score": 0.6,
          "method": "api"
        }
      ]
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 9-16)",
      "start_page": 9,
      "end_page": 16,
      "detection_method": "topic_boundary",
      "content": "About This Book    v \n \nOne Item Tuples Need a Trailing Comma ................................................................................. 48 \nConverting Between Lists and Tuples ....................................................................................... 49 \nThe global statement, and Why Global Variables are Evil.................................................... 49 \nData Structures and 2D Lists ..................................................................................................... 51 \nThe ―Start Game‖ Animation ..................................................................................................... 52 \nThe Game Loop ......................................................................................................................... 52 \nThe Event Handling Loop .......................................................................................................... 53 \nChecking Which Box The Mouse Cursor is Over ..................................................................... 54 \nHandling the First Clicked Box ................................................................................................. 55 \nHandling a Mismatched Pair of Icons ........................................................................................ 56 \nHandling If the Player Won ....................................................................................................... 56 \nDrawing the Game State to the Screen ...................................................................................... 57 \nCreating the ―Revealed Boxes‖ Data Structure ......................................................................... 58 \nCreating the Board Data Structure: Step 1 – Get All Possible Icons ......................................... 58 \nStep 2 – Shuffling and Truncating the List of All Icons ............................................................ 59 \nStep 3 – Placing the Icons on the Board .................................................................................... 59 \nSplitting a List into a List of Lists.............................................................................................. 60 \nDifferent Coordinate Systems .................................................................................................... 61 \nConverting from Pixel Coordinates to Box Coordinates ........................................................... 62 \nDrawing the Icon, and Syntactic Sugar ...................................................................................... 63 \nSyntactic Sugar with Getting a Board Space’s Icon’s Shape and Color .................................... 64 \nDrawing the Box Cover ............................................................................................................. 64 \nHandling the Revealing and Covering Animation ..................................................................... 65 \nDrawing the Entire Board .......................................................................................................... 66 \nDrawing the Highlight ............................................................................................................... 67 \nThe ―Start Game‖ Animation ..................................................................................................... 67 \nRevealing and Covering the Groups of Boxes ........................................................................... 68 \nThe ―Game Won‖ Animation .................................................................................................... 68 \nTelling if the Player Has Won ................................................................................................... 69 \n\n\nvi    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nWhy Bother Having a main() Function? ................................................................................ 69 \nWhy Bother With Readability? .................................................................................................. 70 \nSummary, and a Hacking Suggestion ........................................................................................ 74 \nChapter 4 – Slide Puzzle ................................................................................................................ 77 \nHow to Play Slide Puzzle ........................................................................................................... 77 \nSource Code to Slide Puzzle ...................................................................................................... 77 \nSecond Verse, Same as the First ................................................................................................ 85 \nSetting Up the Buttons ............................................................................................................... 86 \nBeing Smart By Using Stupid Code .......................................................................................... 87 \nThe Main Game Loop ................................................................................................................ 88 \nClicking on the Buttons ............................................................................................................. 89 \nSliding Tiles with the Mouse ..................................................................................................... 90 \nSliding Tiles with the Keyboard ................................................................................................ 90 \n―Equal To One Of‖ Trick with the in Operator ........................................................................ 91 \nWASD and Arrow Keys ............................................................................................................ 91 \nActually Performing the Tile Slide ............................................................................................ 92 \nIDLE and Terminating Pygame Programs ................................................................................. 92 \nChecking for a Specific Event, and Posting Events to Pygame’s Event Queue ........................ 92 \nCreating the Board Data Structure ............................................................................................. 93 \nNot Tracking the Blank Position ................................................................................................ 94 \nMaking a Move by Updating the Board Data Structure ............................................................ 94 \nWhen NOT to Use an Assertion ................................................................................................ 95 \nGetting a Not-So-Random Move ............................................................................................... 96 \nConverting Tile Coordinates to Pixel Coordinates .................................................................... 97 \nConverting from Pixel Coordinates to Board Coordinates ........................................................ 97 \nDrawing a Tile ........................................................................................................................... 97 \nThe Making Text Appear on the Screen .................................................................................... 98 \nDrawing the Board ..................................................................................................................... 99 \nDrawing the Border of the Board ............................................................................................... 99 \n\n\nAbout This Book    vii \n \nDrawing the Buttons ................................................................................................................ 100 \nAnimating the Tile Slides ........................................................................................................ 100 \nThe copy() Surface Method ................................................................................................. 101 \nCreating a New Puzzle ............................................................................................................. 103 \nAnimating the Board Reset ...................................................................................................... 104 \nTime vs. Memory Tradeoffs .................................................................................................... 105 \nNobody Cares About a Few Bytes ........................................................................................... 106 \nNobody Cares About a Few Million Nanoseconds .................................................................. 107 \nSummary .................................................................................................................................. 107 \nChapter 5 – Simulate .................................................................................................................... 108 \nHow to Play Simulate .............................................................................................................. 108 \nSource Code to Simulate .......................................................................................................... 108 \nThe Usual Starting Stuff .......................................................................................................... 114 \nSetting Up the Buttons ............................................................................................................. 115 \nThe main() Function ............................................................................................................. 115 \nSome Local Variables Used in This Program .......................................................................... 116 \nDrawing the Board and Handling Input ................................................................................... 117 \nChecking for Mouse Clicks ..................................................................................................... 118 \nChecking for Keyboard Presses ............................................................................................... 118 \nThe Two States of the Game Loop .......................................................................................... 119 \nFiguring Out if the Player Pressed the Right Buttons .............................................................. 119 \nEpoch Time .............................................................................................................................. 121 \nDrawing the Board to the Screen ............................................................................................. 122 \nSame Old terminate() Function ....................................................................................... 122 \nReusing The Constant Variables .............................................................................................. 123 \nAnimating the Button Flash ..................................................................................................... 123 \nDrawing the Buttons ................................................................................................................ 126 \nAnimating the Background Change ......................................................................................... 126 \nThe Game Over Animation ...................................................................................................... 127 \n\n\nviii    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nConverting from Pixel Coordinates to Buttons ........................................................................ 129 \nExplicit is Better Than Implicit ................................................................................................ 129 \nChapter 6 – Wormy ...................................................................................................................... 131 \nHow to Play Wormy ................................................................................................................ 131 \nSource Code to Wormy ............................................................................................................ 131 \nThe Grid ................................................................................................................................... 137 \nThe Setup Code ........................................................................................................................ 137 \nThe main() Function ............................................................................................................. 138 \nA Separate runGame() Function .......................................................................................... 139 \nThe Event Handling Loop ........................................................................................................ 139 \nCollision Detection .................................................................................................................. 140 \nDetecting Collisions with the Apple ........................................................................................ 141 \nMoving the Worm .................................................................................................................... 142 \nThe insert() List Method................................................................................................... 142 \nDrawing the Screen .................................................................................................................. 143 \nDrawing ―Press a key‖ Text to the Screen ............................................................................... 143 \nThe checkForKeyPress() Function ................................................................................ 143 \nThe Start Screen ....................................................................................................................... 144 \nRotating the Start Screen Text ................................................................................................. 145 \nRotations Are Not Perfect ........................................................................................................ 146 \nDeciding Where the Apple Appears ........................................................................................ 147 \nGame Over Screens .................................................................................................................. 147 \nDrawing Functions ................................................................................................................... 148 \nDon’t Reuse Variable Names ................................................................................................... 151 \nChapter 7 - Tetromino .................................................................................................................. 153 \nHow to Play Tetromino ............................................................................................................ 153 \nSome Tetromino Nomenclature ............................................................................................... 153 \nSource Code to Tetromino ....................................................................................................... 154 \nThe Usual Setup Code ............................................................................................................. 166 \n\n\nAbout This Book    ix \n \nSetting up Timing Constants for Holding Down Keys ............................................................ 166 \nMore Setup Code ..................................................................................................................... 166 \nSetting Up the Piece Templates ............................................................................................... 168 \nSplitting a ―Line of Code‖ Across Multiple Lines ................................................................... 171 \nThe main() Function ............................................................................................................. 172 \nThe Start of a New Game ......................................................................................................... 173 \nThe Game Loop ....................................................................................................................... 174 \nThe Event Handling Loop ........................................................................................................ 174 \nPausing the Game .................................................................................................................... 174 \nUsing Movement Variables to Handle User Input ................................................................... 175 \nChecking if a Slide or Rotation is Valid .................................................................................. 175 \nFinding the Bottom .................................................................................................................. 178 \nMoving by Holding Down the Key.......................................................................................... 179 \nLetting the Piece ―Naturally‖ Fall ............................................................................................ 182 \nDrawing Everything on the Screen .......................................................................................... 182 \nmakeTextObjs(), A Shortcut Function for Making Text .................................................. 183 \nThe Same Old terminate() Function ................................................................................ 183 \nWaiting for a Key Press Event with the checkForKeyPress() Function ........................ 183 \nshowTextScreen(), A Generic Text Screen Function ..................................................... 184 \nThe checkForQuit() Function .......................................................................................... 185 \nThe calculateLevelAndFallFreq() Function .......................................................... 185 \nGenerating Pieces with the getNewPiece() Function ....................................................... 188 \nAdding Pieces to the Board Data Structure ............................................................................. 189 \nCreating a New Board Data Structure ...................................................................................... 189 \nThe isOnBoard() and isValidPosition() Functions ............................................... 190 \nChecking for, and Removing, Complete Lines ........................................................................ 192 \nConvert from Board Coordinates to Pixel Coordinates ........................................................... 195 \nDrawing a Box on the Board or Elsewhere on the Screen ....................................................... 195 \nDrawing Everything to the Screen ........................................................................................... 196 \n\n\nx    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nDrawing the Score and Level Text .......................................................................................... 196 \nDrawing a Piece on the Board or Elsewhere on the Screen ..................................................... 197 \nDrawing the ―Next‖ Piece ........................................................................................................ 197 \nSummary .................................................................................................................................. 198 \nChapter 8 – Squirrel Eat Squirrel ................................................................................................. 200 \nHow to Play Squirrel Eat Squirrel............................................................................................ 200 \nThe Design of Squirrel Eat Squirrel ......................................................................................... 200 \nSource Code to Squirrel Eat Squirrel ....................................................................................... 201 \nThe Usual Setup Code ............................................................................................................. 211 \nDescribing the Data Structures ................................................................................................ 212 \nThe main() Function ............................................................................................................. 213 \nThe pygame.transform.flip() Function .................................................................... 214 \nA More Detailed Game State than Usual ................................................................................. 214 \nThe Usual Text Creation Code................................................................................................. 215 \nCameras ................................................................................................................................... 215 \nThe ―Active Area‖ ................................................................................................................... 217 \nKeeping Track of the Location of Things in the Game World ................................................ 218 \nStarting Off with Some Grass .................................................................................................. 219 \nThe Game Loop ....................................................................................................................... 219 \nChecking to Disable Invulnerability ........................................................................................ 219 \nMoving the Enemy Squirrels ................................................................................................... 219 \nRemoving the Far Away Grass and Squirrel Objects .............................................................. 221 \nWhen Deleting Items in a List, Iterate Over the List in Reverse ............................................. 221 \nAdding New Grass and Squirrel Objects ................................................................................. 223 \nCamera Slack, and Moving the Camera View ......................................................................... 223 \nDrawing the Background, Grass, Squirrels, and Health Meter ................................................ 224 \nThe Event Handling Loop ........................................................................................................ 226 \nMoving the Player, and Accounting for Bounce ...................................................................... 228 \nCollision Detection: Eat or Be Eaten ....................................................................................... 229 \n\n\nAbout This Book    xi \n \nThe Game Over Screen ............................................................................................................ 231 \nWinning ................................................................................................................................... 232 \nDrawing a Graphical Health Meter .......................................................................................... 232 \nThe Same Old terminate() Function ................................................................................ 232 \nThe Mathematics of the Sine Function .................................................................................... 233 \nBackwards Compatibility with Python Version 2 .................................................................... 236 \nThe getRandomVelocity() Function .............................................................................. 237 \nFinding a Place to Add New Squirrels and Grass .................................................................... 237 \nCreating Enemy Squirrel Data Structures ................................................................................ 238 \nFlipping the Squirrel Image ..................................................................................................... 239 \nCreating Grass Data Structures ................................................................................................ 239 \nChecking if Outside the Active Area ....................................................................................... 240 \nSummary .................................................................................................................................. 241 \nChapter 9 – Star Pusher ................................................................................................................ 242 \nHow to Play Star Pusher .......................................................................................................... 242 \nSource Code to Star Pusher ...................................................................................................... 242 \nThe Initial Setup ....................................................................................................................... 256 \nData Structures in Star Pusher ................................................................................................. 271 \nThe ―Game State‖ Data Structure ............................................................................................ 271 \nThe ―Map‖ Data Structure ....................................................................................................... 271 \nThe ―Levels‖ Data Structure .................................................................................................... 272 \nReading and Writing Text Files ............................................................................................... 272 \nText Files and Binary Files ...................................................................................................... 272 \nWriting to Files ........................................................................................................................ 273 \nReading from Files ................................................................................................................... 274 \nAbout the Star Pusher Map File Format .................................................................................. 274 \nRecursive Functions ................................................................................................................. 280 \nStack Overflows ....................................................................................................................... 281 \nPreventing Stack Overflows with a Base Case ........................................................................ 283 \n\n\nxii    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe Flood Fill Algorithm ......................................................................................................... 284 \nDrawing the Map ..................................................................................................................... 285 \nChecking if the Level is Finished ............................................................................................ 287 \nSummary .................................................................................................................................. 288 \nChapter 10 – Four Extra Games ................................................................................................... 289 \nFlippy, an ―Othello‖ Clone ...................................................................................................... 290 \nSource Code for Flippy ............................................................................................................ 292 \nInk Spill, a ―Flood It‖ Clone .................................................................................................... 305 \nSource Code for Ink Spill ........................................................................................................ 305 \nFour-In-A-Row, a ―Connect Four‖ Clone ................................................................................ 317 \nSource Code for Four-In-A-Row ............................................................................................. 317 \nGemgem, a ―Bejeweled‖ Clone ............................................................................................... 327 \nSource Code for Gemgem ........................................................................................................ 327 \nSummary .................................................................................................................................. 340 \nGlossary ....................................................................................................................................... 342 \nAbout the Author ......................................................................................................................... 347 \n \n \n \n",
      "page_number": 9,
      "chapter_number": 2,
      "summary": "This chapter covers segment 2 (pages 9-16). Key topics include function, functions, and drawing. 49 \nThe global statement, and Why Global Variables are Evil.",
      "keywords": [
        "Board Data Structure",
        "Source Code",
        "Event Handling Loop",
        "Data Structure",
        "Trailing Comma",
        "Drawing",
        "Board Data",
        "Game Loop",
        "Board",
        "Function",
        "Code",
        "Game",
        "Squirrel Data Structures",
        "Handling Loop",
        "Text Screen Function"
      ],
      "concepts": [
        "function",
        "functions",
        "drawing",
        "text",
        "game",
        "summary",
        "squirrel",
        "animation",
        "animating",
        "data"
      ],
      "similar_chapters": [
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 5,
          "title": "Segment 5 (pages 35-42)",
          "relevance_score": 0.69,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 8,
          "title": "Segment 8 (pages 142-159)",
          "relevance_score": 0.67,
          "method": "api"
        },
        {
          "book": "AI Agents In Action",
          "chapter": 18,
          "title": "Segment 18 (pages 147-158)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 40,
          "title": "Segment 40 (pages 809-829)",
          "relevance_score": 0.66,
          "method": "api"
        }
      ]
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 17-24)",
      "start_page": 17,
      "end_page": 24,
      "detection_method": "topic_boundary",
      "content": "About This Book    xiii \n \n \n \n \nThis page intentionally left blank. \n \n \n \n \n \n \n \n…except for the above text. \nAnd the above text. \nAnd the above text. \nAnd the above text. \nAnd the above text. \nAnd the above text. \nAnd the above text. \nAnd the above text. \nAnd the above text. \nTraceback (most recent call last): \n  File \"<pyshell#1>\", line 1, in blankpage \n    def blankpage(): blankpage() \nRuntimeError: maximum recursion depth exceeded  \n\n\nxiv    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n\n\nChapter 1 – Installing Python and Pygame    1 \n \nCHAPTER 1 – INSTALLING \nPYTHON AND PYGAME \nWhat You Should Know Before You Begin \nIt might help if you know a bit about Python programming (or how to program in another \nlanguage besides Python) before you read through this book; however even if you haven’t you \ncan still read this book anyway. Programming isn’t nearly as hard as people think it is. If you ever \nrun into some trouble, you can read the free book ―Invent Your Own Computer Games with \nPython‖ online at http://inventwithpython.com or look up a topic that you find confusing on the \nInvent with Python wiki at http://inventwithpython.com/wiki. \nYou don’t need to know how to use the Pygame library before reading this book. The next \nchapter is a brief tutorial on all of Pygame’s major features and functions. \nJust in case you haven’t read the first book and already installed Python and Pygame on your \ncomputer, the installation instructions are in this chapter. If you already have installed both of \nthese then you can skip this chapter. \nDownloading and Installing Python \nBefore we can begin programming you'll need to install software called the Python interpreter on \nyour computer. (You may need to ask an adult for help here.) The interpreter is a program that \nunderstands the instructions that you’ll write (or rather, type out) in the Python language. Without \nthe interpreter, your computer won't be able to run your Python programs. We'll just refer to ―the \nPython interpreter‖ as ―Python‖ from now on. \nThe Python interpreter software can be downloaded from the official website of the Python \nprogramming language, http://www.python.org. You might want the help of someone else to \ndownload and install the Python software. The installation is a little different depending on if \nyour computer’s operating system is Windows, Mac OS X, or a Linux OS such as Ubuntu. You \ncan also find videos online of people installing the Python software on their computers at \nhttp://invpy.com/installing. \nWindows Instructions \nWhen you get to http://python.org, you should see a list of links on the left (such as ―About‖, \n―News‖, ―Documentation‖, ―Download‖, and so on). Click on the Download link to go to the \n\n\n2    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \ndownload page, then look for the file called ―Python 3.2 Windows Installer (Windows binary -- \ndoes not include source)‖ and click on its link to download Python for Windows. \nDouble-click on the python-3.2.msi file that you've just downloaded to start the Python installer. \n(If it doesn’t start, try right-clicking the file and choosing Install.) Once the installer starts up, \njust keep clicking the Next button and just accept the choices in the installer as you go (no need \nto make any changes). When the install is finished, click Finish. \nMac OS X Instructions \nMac OS X 10.5 comes with Python 2.5.1 pre-installed by Apple. Currently, Pygame only \nsupports Python 2 and not Python 3. However, the programs in this book work with both Python \n2 and 3. \nThe Python website also has some additional information about using Python on a Mac at \nhttp://docs.python.org/dev/using/mac.html. \nUbuntu and Linux Instructions \nPygame for Linux also only supports Python 2, not Python 3. If your operating system is Ubuntu, \nyou can install Python by opening a terminal window (from the desktop click on Applications > \nAccessories > Terminal) and entering ―sudo apt-get install python2.7‖ then \npressing Enter. You will need to enter the root password to install Python, so ask the person who \nowns the computer to type in this password if you do not know it. \nYou also need to install the IDLE software. From the terminal, type in ―sudo apt-get \ninstall idle‖. The root password is also needed to install IDLE (ask the owner of your \ncomputer to type in this password for you). \nStarting Python \nWe will be using the IDLE software to type in our programs and run them. IDLE stands for \nInteractive DeveLopment Environment. The development environment is software that makes it \neasy to write Python programs, just like word processor software makes it easy to write books. \nIf your operating system is Windows XP, you should be able to run Python by clicking the Start \nbutton, then selecting Programs, Python 3.1, IDLE (Python GUI). For Windows Vista or \nWindows 7, just click the Windows button in the lower left corner, type ―IDLE‖ and select \n―IDLE (Python GUI)‖. \nIf your operating system is Max OS X, start IDLE by opening the Finder window and click on \nApplications, then click Python 3.2, then click the IDLE icon. \n\n\nChapter 1 – Installing Python and Pygame    3 \n \nIf your operating system is Ubuntu or Linux, start IDLE by opening a terminal window and then \ntype ―idle3‖ and press Enter. You may also be able to click on Applications at the top of the \nscreen, and then select Programming, then IDLE 3. \n \n \n \n \nThe window that appears when you first run IDLE is called the interactive shell. A shell is a \nprogram that lets you type instructions into the computer. The Python shell lets you type Python \ninstructions, and the shell sends these instructions to the Python interpreter to perform. \nInstalling Pygame \nPygame does not come with Python. Like Python, Pygame is available for free. You will have to \ndownload and install Pygame, which is as easy as downloading and installing the Python \ninterpreter. In a web browser, go to the URL http://pygame.org and click on the ―Downloads‖ \nlink on the left side of the web site. This book assumes you have the Windows operating system, \nbut Pygame works the same for every operating system. You need to download the Pygame \ninstaller for your operating system and the version of Python you have installed. \nYou do not want to download the ―source‖ for Pygame, but rather the Pygame ―binary‖ for your \noperating system. For Windows, download the pygame-1.9.1.win32-py3.2.msi file. (This is \nPygame for Python 3.2 on Windows. If you installed a different version of Python (such as 2.7 or \n2.6) download the .msi file for your version of Python.) The current version of Pygame at the \ntime this book was written is 1.9.1. If you see a newer version on the website, download and \ninstall the newer Pygame.  \nFor Mac OS X, download the .zip or .dmg file for the version of Python you have and run it. \nFor Linux, open a terminal and run ―sudo apt-get install python-pygame‖. \nOn Windows, double click on the downloaded file to install Pygame. To check that Pygame is \ninstall correctly, type the following into the interactive shell: \n>>> import pygame \n\n\n4    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nIf nothing appears after you hit the Enter key, then you know Pygame has successfully been \ninstalled. If the error ImportError: No module named pygame appears, then try to \ninstall Pygame again (and make sure you typed import pygame correctly). \nThis chapter has five small programs that demonstrate how to use the different features that \nPygame provides. In the last chapter, you will use these features for a complete game written in \nPython with Pygame. \nA video tutorial of how to install Pygame is available from this book's website at \nhttp://invpy.com/videos. \nHow to Use This Book \n―Making Games with Python & Pygame‖ is different from other programming books because it \nfocuses on the complete source code for several game programs. Instead of teaching you \nprogramming concepts and leaving it up to you to figure out how to make programs with those \nconcepts, this book shows you some programs and then explains how they are put together. \nIn general, you should read these chapters in order. There are many concepts that are used over \nand over in these games, and they are only explained in detail in the first game they appear in. \nBut if there is a game you think is interesting, go ahead and jump to that chapter. You can always \nread the previous chapters later if you got ahead of yourself. \nThe Featured Programs \nEach chapter focuses on a single game program and explain how different parts of the code work. \nIt is very helpful to copy these programs by typing in the code line by line from this book. \nHowever, you can also download the source code file from this book's website. In a web browser, \ngo to the URL http://invpy.com/source and follow the instructions to download the source code \nfile. But typing in the code yourself really helps you learn the code better. \nDownloading Graphics and Sound Files \nWhile you can just type in the code you read out of this book, you will need to download the \ngraphics and sound files used by the games in this book from http://invpy.com/downloads. Make \nsure that these image and sound files are located in the same folder as the .py Python file \notherwise your Python program will not be able to find these files. \nLine Numbers and Spaces \nWhen entering the source code yourself, do not type the line numbers that appear at the beginning \nof each line. For example, if you see this in the book: \n\n\nChapter 1 – Installing Python and Pygame    5 \n \n1. number = random.randint(1, 20) \n2. spam = 42 \n3. print('Hello world!') \nYou do not need to type the ―1.‖ on the left side, or the space that immediately follows it. Just \ntype it like this: \nnumber = random.randint(1, 20) \nspam = 42 \nprint('Hello world!') \nThose numbers are only used so that this book can refer to specific lines in the code. They are not \na part of the actual program. \nAside from the line numbers, be sure to enter the code exactly as it appears. Notice that some of \nthe lines don’t begin at the leftmost edge of the page, but are indented by four or eight or more \nspaces. Be sure to put in the correct number of spaces at the start of each line. (Since each \ncharacter in IDLE is the same width, you can count the number of spaces by counting the number \nof characters above or below the line you're looking at.) \nFor example in the code below, you can see that the second line is indented by four spaces \nbecause the four characters (―whil‖) on the line above are over the indented space. The third line \nis indented by another four spaces (the four characters, ―if n‖ are above the third line's indented \nspace): \nwhile spam < 10: \n    if number == 42: \n        print('Hello') \nText Wrapping in This Book \nSome lines of code are too long to fit on one line on the pages in this book, and the text of the \ncode will wrap around to the next line. When you type these lines into the file editor, enter the \ncode all on one line without pressing Enter. \nYou can tell when a new line starts by looking at the line numbers on the left side of the code. For \nexample, the code below has only two lines of code, even though the first line wraps around: \n1. print('This is the first line! xxxxxxxxxxxxxxxxxxxxxxxxxxxxx \nxxxxxxxxxxxxxx’) \n2. print('This is the second line, not the third line.') \n\n\n6    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nChecking Your Code Online \nSome of the programs in this book are a little long. Although it is very helpful to learn Python by \ntyping out the source code for these programs, you may accidentally make typos that cause your \nprograms to crash. It may not be obvious where the typo is. \nYou can copy and paste the text of your source code to the online diff tool on the book’s website. \nThe diff tool will show any differences between the source code in the book and the source code \nyou’ve typed. This is an easy way of finding any typos in your program. \nCopying and pasting text is a very useful computer skill, especially for computer programming. \nThere is a video tutorial on copying and pasting at this book’s website at \nhttp://invpy.com/copypaste. \nThe online diff tool is at this web page: http://invpy.com/diff/pygame. There is also a video \ntutorial on how to use this tool on the book’s website. \nMore Info Links on http://invpy.com \nThere is a lot that you can learn about programming. But you don’t need to learn all of it now. \nThere are several times in this book where you might like to learn these additional details and \nexplanations, but if I included them in this book then it would add many more pages. If this \nlarger, heavier book accidentally fell on you the weight of these many additional pages would \ncrush you, resulting in death. Instead, I have included ―more info‖ links in this book that you can \nfollow on this book’s website. You do not have to read this additional information to understand \nanything in this book, but it is there if you are curious. These (and other) links have been \nshortened and begin with http://invpy.com. \nAll of the information from these ―more info‖ links can also be downloaded from \nhttp://invpy.com/pygamemoreinfo. \nEven though this book is not dangerously heavy, please do not let it fall on you anyway. \n \n \n",
      "page_number": 17,
      "chapter_number": 3,
      "summary": "Just in case you haven’t read the first book and already installed Python and Pygame on your \ncomputer, the installation instructions are in this chapter Key topics include python, programming, and program.",
      "keywords": [
        "Python",
        "Pygame",
        "Installing Python",
        "Book",
        "Python interpreter",
        "IDLE",
        "code",
        "install Pygame",
        "line",
        "Python programs",
        "Windows",
        "install",
        "download",
        "text",
        "Python GUI"
      ],
      "concepts": [
        "python",
        "programming",
        "program",
        "book",
        "windows",
        "downloading",
        "installing",
        "line",
        "file",
        "idle"
      ],
      "similar_chapters": [
        {
          "book": "Python Distilled",
          "chapter": 2,
          "title": "Segment 2 (pages 9-18)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 39,
          "title": "Segment 39 (pages 353-355)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Python Data Analysis 3rd",
          "chapter": 2,
          "title": "Python Language Basics, IPython,",
          "relevance_score": 0.53,
          "method": "api"
        }
      ]
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 25-33)",
      "start_page": 25,
      "end_page": 33,
      "detection_method": "topic_boundary",
      "content": "Chapter 2 – Pygame Basics    7 \n \nCHAPTER 2 – PYGAME BASICS \nJust like how Python comes with several modules like random, math, or time that provide \nadditional functions for your programs, the Pygame framework includes several modules with \nfunctions for drawing graphics, playing sounds, handling mouse input, and other things. \nThis chapter will cover the basic modules and functions that Pygame provides and assumes you \nalready know basic Python programming. If you have trouble with some of the programming \nconcepts, you can read through the ―Invent Your Own Computer Games with Python‖ book \nonline at http://invpy.com/book. This book is aimed at complete beginners to programming. \nThe ―Invent with Python‖ book also has a few chapters covering Pygame. You can read them \nonline at http://invpy.com/chap17. \nOnce you learn more about Pygame, you can view the other modules that Pygame provides from \nthe online documentation at http://pygame.org/docs. \nGUI vs. CLI \nThe Python programs that you can write with Python’s built-in functions only deal with text \nthrough the print() and input() functions. Your program can display text on the screen and \nlet the user type in text from the keyboard. This type of program has a command line interface, \nor CLI (which is pronounced like the first part of ―climb‖ and rhymes with ―sky‖). These \nprograms are somewhat limited because they can’t display graphics, have colors, or use the \nmouse. These CLI programs only get input from the keyboard with the input() function and \neven then user must press Enter before the program can respond to the input. This means real-\ntime (that is, continuing to run code without waiting for the user) action games are impossible to \nmake. \nPygame provides functions for creating programs with a graphical user interface, or GUI \n(pronounced, ―gooey‖). Instead of a text-based CLI, programs with a graphics-based GUI can \nshow a window with images and colors. \nSource Code for Hello World with Pygame \nOur first program made with Pygame is a small program that makes a window that says ―Hello \nWorld!‖ appear on the screen. Open a new file editor window by clicking on IDLE’s File menu, \nthen New Window. Type in the following code into IDLE’s file editor and save it as \nblankpygame.py. Then run the program by pressing F5 or selecting Run > Run Module from the \nmenu at the top of the file editor. \n\n\n8    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nRemember, do not type the numbers or the periods at the beginning of each line (that’s just for \nreference in this book). \n 1. import pygame, sys \n 2. from pygame.locals import * \n 3.  \n 4. pygame.init() \n 5. DISPLAYSURF = pygame.display.set_mode((400, 300)) \n 6. pygame.display.set_caption('Hello World!') \n 7. while True: # main game loop \n 8.     for event in pygame.event.get(): \n 9.         if event.type == QUIT: \n10.             pygame.quit() \n11.             sys.exit() \n12.     pygame.display.update() \nWhen you run this program, a black window like this will appear: \n \nYay! You’ve just made the world’s most boring video game! It’s just a blank window with ―Hello \nWorld!‖ at the top of the window (in what is called the window’s title bar, which holds the \ncaption text). But creating a window is the first step to making graphical games. When you click \non the X button in the corner of the window, the program will end and the window will disappear. \nCalling the print() function to make text appear in the window won’t work because \nprint() is a function for CLI programs. The same goes for input() to get keyboard input \nfrom the user. Pygame uses other functions for input and output which are explained later in this \nchapter. For now, let’s look at each line in our ―Hello World‖ program in more detail. \nSetting Up a Pygame Program \nThe first few lines of code in the Hello World program are lines that will begin almost every \nprogram you write that uses Pygame. \n 1. import pygame, sys \n\n\nChapter 2 – Pygame Basics    9 \n \nLine 1 is a simple import statement that imports the pygame and sys modules so that our \nprogram can use the functions in them. All of the Pygame functions dealing with graphics, sound, \nand other features that Pygame provides are in the pygame module. \nNote that when you import the pygame module you automatically import all the modules that \nare in the pygame module as well, such as pygame.images and pygame.mixer.music. \nThere’s no need to import these modules-inside-modules with additional import statements. \n 2. from pygame.locals import * \nLine 2 is also an import statement. However, instead of the import modulename format, it \nuses the from modulename import * format. Normally if you want to call a function that \nis in a module, you must use the modulename.functionname() format after importing the \nmodule. However, with from modulename import *, you can skip the modulename. \nportion and simply use functionname() (just like Python’s built-in functions). \nThe reason we use this form of import statement for pygame.locals is because \npygame.locals contains several constant variables that are easy to identify as being in the \npygame.locals module without pygame.locals. in front of them. For all other modules, \nyou generally want to use the regular import modulename format. (There is more \ninformation about why you want to do this at http://invpy.com/namespaces.) \n 4. pygame.init() \nLine 4 is the pygame.init() function call, which always needs to be called after importing \nthe pygame module and before calling any other Pygame function. You don’t need to know what \nthis function does, you just need to know that it needs to be called first in order for many Pygame \nfunctions to work. If you ever see an error message like pygame.error: font not \ninitialized, check to see if you forgot to call pygame.init() at the start of your \nprogram. \n 5. DISPLAYSURF = pygame.display.set_mode((400, 300)) \nLine 5 is a call to the pygame.display.set_mode() function, which returns the \npygame.Surface object for the window. (Surface objects are described later in this chapter.) \nNotice that we pass a tuple value of two integers to the function: (400, 300). This tuple tells \nthe set_mode() function how wide and how high to make the window in pixels. (400, \n300) will make a window with a width of 400 pixels and height of 300 pixels.  \n\n\n10    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nRemember to pass a tuple of two integers to set_mode(), not just two integers themselves. The \ncorrect way to call the function is like this: pygame.display.set_mode((400, 300)). \nA function call like pygame.display.set_mode(400, 300) will cause an error that \nlooks like this: TypeError: argument 1 must be 2-item sequence, not int. \nThe pygame.Surface object (we will just call them Surface objects for short) returned is \nstored in a variable named DISPLAYSURF. \n 6. pygame.display.set_caption('Hello World!') \nLine 6 sets the caption text that will appear at the top of the window by calling the \npygame.display.set_caption() function. The string value 'Hello World!' is \npassed in this function call to make that text appear as the caption: \n \nGame Loops and Game States \n 7. while True: # main game loop \n 8.     for event in pygame.event.get(): \nLine 7 is a while loop that has a condition of simply the value True. This means that it never \nexits due to its condition evaluating to False. The only way the program execution will ever \nexit the loop is if a break statement is executed (which moves execution to the first line after the \nloop) or sys.exit() (which terminates the program). If a loop like this was inside a function, \na return statement will also move execution out of the loop (as well as the function too). \nThe games in this book all have these while True loops in them along with a comment calling \nit the ―main game loop‖. A game loop (also called a main loop) is a loop where the code does \nthree things: \n1. Handles events. \n2. Updates the game state. \n3. Draws the game state to the screen.  \nThe game state is simply a way of referring to a set of values for all the variables in a game \nprogram. In many games, the game state includes the values in the variables that tracks the \nplayer’s health and position, the health and position of any enemies, which marks have been \nmade on a board, the score, or whose turn it is. Whenever something happens like the player \n\n\nChapter 2 – Pygame Basics    11 \n \ntaking damage (which lowers their health value), or an enemy moves somewhere, or something \nhappens in the game world we say that the game state has changed. \nIf you’ve ever played a game that let you saved, the ―save state‖ is the game state at the point that \nyou’ve saved it. In most games, pausing the game will prevent the game state from changing. \nSince the game state is usually updated in response to events (such as mouse clicks or keyboard \npresses) or the passage of time, the game loop is constantly checking and re-checking many times \na second for any new events that have happened. Inside the main loop is code that looks at which \nevents have been created (with Pygame, this is done by calling the pygame.event.get() \nfunction). The main loop also has code that updates the game state based on which events have \nbeen created. This is usually called event handling. \n \npygame.event.Event Objects \nAny time the user does one of several actions (they are listed later in this chapter) such as \npressing a keyboard key or moving the mouse on the program’s window, a \npygame.event.Event object is created by the Pygame library to record this ―event‖. (This is \na type of object called Event that exists in the event module, which itself is in the pygame \nmodule.) We can find out which events have happened by calling the pygame.event.get() \nfunction, which returns a list of pygame.event.Event objects (which we will just call Event \nobjects for short). \nThe list of Event objects will be for each event that has happened since the last time the \npygame.event.get() function was called. (Or, if pygame.event.get() has never been \ncalled, the events that have happened since the start of the program.) \n\n\n12    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 7. while True: # main game loop \n 8.     for event in pygame.event.get(): \nLine 8 is a for loop that will iterate over the list of Event objects that was returned by \npygame.event.get(). On each iteration through the for loop, a variable named event \nwill be assigned the value of the next event object in this list. The list of Event objects returned \nfrom pygame.event.get() will be in the order that the events happened. If the user clicked \nthe mouse and then pressed a keyboard key, the Event object for the mouse click would be the \nfirst item in the list and the Event object for the keyboard press would be second. If no events \nhave happened, then pygame.event.get() will return a blank list. \nThe QUIT Event and pygame.quit() Function \n 9.         if event.type == QUIT: \n10.             pygame.quit() \n11.             sys.exit() \nEvent objects have a member variable (also called attributes or properties) named type \nwhich tells us what kind of event the object represents. Pygame has a constant variable for each \nof possible types in the pygame.locals modules. Line 9 checks if the Event object’s type is \nequal to the constant QUIT. Remember that since we used the from pygame.locals \nimport * form of the import statement, we only have to type QUIT instead of \npygame.locals.QUIT. \nIf the Event object is a quit event, then the pygame.quit() and sys.exit() functions are \ncalled. The pygame.quit() function is sort of the opposite of the pygame.init() \nfunction: it runs code that deactivates the Pygame library. Your programs should always call \npygame.quit() before they call sys.exit() to terminate the program. Normally it doesn’t \nreally matter since Python closes it when the program exits anyway. But there is a bug in IDLE \nthat causes IDLE to hang if a Pygame program terminates before pygame.quit() is called. \nSince we have no if statements that run code for other types of Event object, there is no event-\nhandling code for when the user clicks the mouse, presses keyboard keys, or causes any other \ntype of Event objects to be created. The user can do things to create these Event objects but it \ndoesn’t change anything in the program because the program does not have any event-handling \ncode for these types of Event objects. After the for loop on line 8 is done handling all the Event \nobjects that have been returned by pygame.event.get(), the program execution continues \nto line 12. \n12.     pygame.display.update() \n\n\nChapter 2 – Pygame Basics    13 \n \nLine 12 calls the pygame.display.update() function, which draws the Surface object \nreturned by pygame.display.set_mode() to the screen (remember we stored this object \nin the DISPLAYSURF variable). Since the Surface object hasn’t changed (for example, by some \nof the drawing functions that are explained later in this chapter), the same black image is redrawn \nto the screen each time pygame.display.update() is called. \nThat is the entire program. After line 12 is done, the infinite while loop starts again from the \nbeginning. This program does nothing besides make a black window appear on the screen, \nconstantly check for a QUIT event, and then redraws the unchanged black window to the screen \nover and over again. Let’s learn how to make interesting things appear on this window instead of \njust blackness by learning about pixels, Surface objects, Color objects, Rect objects, and the \nPygame drawing functions. \nPixel Coordinates \nThe window that the ―Hello World‖ program creates is just composed of little square dots on your \nscreen called pixels. Each pixel starts off as black but can be set to a different color. Imagine that \ninstead of a Surface object that is 400 pixels wide and 300 pixels tall, we just had a Surface object \nthat was 8 pixels by 8 pixels. If that tiny 8x8 Surface was enlarged so that each pixel looks like a \nsquare in a grid, and we added numbers for the X and Y axis, then a good representation of it \ncould look something like this: \n \nWe can refer to a specific pixel by using a Cartesian Coordinate system. Each column of the X-\naxis and each row of the Y-axis will have an ―address‖ that is an integer from 0 to 7 so that we \ncan locate any pixel by specifying the X and Y axis integers. \nFor example, in the above 8x8 image, we can see that the pixels at the XY coordinates (4, 0), (2, \n2), (0, 5), and (5, 6) have been painted black, the pixel at (2, 4) has been painted gray, while all \nthe other pixels are painted white. XY coordinates are also called points. If you’ve taken a math \nclass and learned about Cartesian Coordinates, you might notice that the Y-axis starts at 0 at the \ntop and then increases going down, rather than increasing as it goes up. This is just how Cartesian \nCoordinates work in Pygame (and almost every programming language). \n\n\n14    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe Pygame framework often represents Cartesian Coordinates as a tuple of two integers, such as \n(4, 0) or (2, 2). The first integer is the X coordinate and the second is the Y coordinate. (Cartesian \nCoordinates are covered in more detail in chapter 12 of ―Invent Your Own Computer Games with \nPython‖ at http://invpy.com/chap12) \nA Reminder About Functions, Methods, Constructor Functions, and \nFunctions in Modules (and the Difference Between Them) \nFunctions and methods are almost the same thing. They can both be called to execute the code in \nthem. The difference between a function and a method is that a method will always be attached to \nan object. Usually methods change something about that particular object (you can think of the \nattached object as a sort of permanent argument passed to the method). \nThis is a function call of a function named foo(): \nfoo() \nThis is a method call of a method also named foo(), which is attached to an object stored in a \nvariable named duckie: \nduckie.foo() \nA call to a function inside of a module may look like a method call. To tell the difference, you \nneed to look at the first name and see if it is the name of a module or the name of a variable that \ncontains an object. You can tell that sys.exit() is a call to function inside of a module, \nbecause at the top of the program will be an import statement like import sys. \nA constructor function is the same thing as a normal function call, except that its return value is \na new object. Just by looking at source code, a function and constructor function look the same. \nConstructor functions (also called simply a ―constructor‖ or sometimes ―ctor‖ (―see-tor‖) for \nshort) are just a name given to functions that return a new object. But usually ctors start with a \ncapital letter. This is why when you write your own programs, your function names should only \nbegin with a lowercase letter. \nFor example, pygame.Rect() and pygame.Surface() are both constructor functions \ninside the pygame module that return new Rect and Surface objects. (These objects are \ndescribed later.) \nHere’s an example of a function call, a method call, and a call to a function inside a module: \nimport whammy \nfizzy() \n\n\nChapter 2 – Pygame Basics    15 \n \negg = Wombat() \negg.bluhbluh() \nwhammy.spam() \nEven though these names are all made up, you can tell which is a function call, a method call, and \na call to a function inside a method. The name whammy refers to a module, since you can see it is \nbeing imported on the first line. The fizzy name has nothing before it and parentheses after it, \nso you know it is a function call. \nWombat() is also a function call, in this case it is a constructor function that returns an object. \n(The capital letter that it starts with isn’t a guarantee that it’s a constructor function rather than a \nregular function, but it is a safe bet.) The object is stored in a variable named egg. The \negg.bluhbluh() call is a method call, which you can tell because bluhbluh is attached to a \nvariable with an object in it. \nMeanwhile, whammy.spam() is a function call, not a method call. You can tell it is not a \nmethod because the name whammy was imported as a module earlier. \nSurface Objects and The Window \nSurface objects are objects that represent a rectangular 2D image. The pixels of the Surface object \ncan be changed by calling the Pygame drawing functions (described later in this chapter) and then \ndisplayed on the screen. The window border, title bar, and buttons are not part of the display \nSurface object. \nIn particular, the Surface object returned by pygame.display.set_mode() is called the \ndisplay Surface. Anything that is drawn on the display Surface object will be displayed on the \nwindow when the pygame.display.update() function is called. It is a lot faster to draw \non a Surface object (which only exists in the computer’s memory) than it is to draw a Surface \nobject to the computer screen. Computer memory is much faster to change than pixels on a \nmonitor. \nOften your program will draw several different things to a Surface object. Once you are done \ndrawing everything on the display Surface object for this iteration of the game loop (called a \nframe, just like a still image on a paused DVD is called) on a Surface object, it can be drawn to \nthe screen. The computer can draw frames very quickly, and our programs will often run around \n30 frames per second (that is, 30 FPS). This is called the ―frame rate‖ and is explained later in \nthis chapter. \nDrawing on Surface objects will be covered in the ―Primitive Drawing Functions‖ and ―Drawing \nImages‖ sections later this chapter. \n",
      "page_number": 25,
      "chapter_number": 4,
      "summary": "This chapter will cover the basic modules and functions that Pygame provides and assumes you \nalready know basic Python programming Key topics include functions, function, and programs. Covers function.",
      "keywords": [
        "Pygame",
        "Surface object",
        "function",
        "Event objects",
        "event",
        "object",
        "Surface",
        "function call",
        "functions",
        "pygame module",
        "Pygame Basics",
        "program",
        "Pygame drawing functions",
        "game",
        "call"
      ],
      "concepts": [
        "functions",
        "function",
        "programs",
        "programming",
        "imports",
        "object",
        "called",
        "line",
        "window",
        "pixels"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 14,
          "title": "Segment 14 (pages 116-123)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 2,
          "title": "Segment 2 (pages 9-18)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 2,
          "title": "Segment 2 (pages 19-41)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 40,
          "title": "Segment 40 (pages 420-428)",
          "relevance_score": 0.55,
          "method": "api"
        }
      ]
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 34-42)",
      "start_page": 34,
      "end_page": 42,
      "detection_method": "topic_boundary",
      "content": "16    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nColors \nThere are three primary colors of light: red, green and blue. (Red, blue, and yellow are the \nprimary colors for paints and pigments, but the computer monitor uses light, not paint.) By \ncombining different amounts of these three colors you can form any other color. In Pygame, we \nrepresent colors with tuples of three integers. The first value in the tuple is how much red is in the \ncolor. An integer value of 0 means there is no red in this color, and a value of 255 means there is \nthe maximum amount of red in the color. The second value is for green and the third value is for \nblue. These tuples of three integers used to represent a color are often called RGB values.  \nBecause you can use any combination of 0 to 255 for each of the three primary colors, this \nmeans Pygame can draw 16,777,216 different colors (that is, 256 x 256 x 256 colors). However, \nif try to use a number larger than 255 or a negative number, you will get an error that looks like \n―ValueError: invalid color argument‖. \nFor example, we will create the tuple (0, 0, 0) and store it in a variable named BLACK. With \nno amount of red, green, or blue, the resulting color is completely black. The color black is the \nabsence of any color. The tuple (255, 255, 255) for a maximum amount of red, green, and \nblue to result in white. The color white is the full combination of red, green, and blue. The tuple \n(255, 0, 0) represents the maximum amount of red but no amount of green and blue, so the \nresulting color is red. Similarly, (0, 255, 0) is green and (0, 0, 255) is blue. \nYou can mix the amount of red, green, and blue to form other colors. Here are the RGB values for \na few common colors: \nColor \nRGB Values \nAqua \n(  0, 255, 255) \nBlack \n(  0,   0,   0) \nBlue \n(  0,   0, 255) \nFuchsia \n(255,   0, 255) \nGray \n(128, 128, 128) \nGreen \n(  0, 128,   0) \nLime \n(  0, 255,   0) \nMaroon \n(128,   0,   0) \nNavy Blue \n(  0,   0, 128) \nOlive \n(128, 128,   0) \nPurple \n(128,   0, 128) \nRed \n(255,   0,   0) \nSilver \n(192, 192, 192) \nTeal \n(  0, 128, 128) \nWhite \n(255, 255, 255) \nYellow \n(255, 255,   0) \n \n\n\nChapter 2 – Pygame Basics    17 \n \nTransparent Colors \nWhen you look through a glass window that has a deep red tint, all of the colors behind it have a \nred shade added to them. You can mimic this effect by adding a fourth 0 to 255 integer value to \nyour color values. \nThis value is known as the alpha value. It is a measure of how opaque (that is, not transparent) a \ncolor is. Normally when you draw a pixel onto a surface object, the new color completely \nreplaces whatever color was already there. But with colors that have an alpha value, you can \ninstead just add a colored tint to the color that is already there. \nFor example, this tuple of three integers is for the color green: (0, 255, 0). But if we add a \nfourth integer for the alpha value, we can make this a half transparent green color: (0, 255, \n0, 128). An alpha value of 255 is completely opaque (that is, not transparency at all). The \ncolors (0, 255, 0) and (0, 255, 0, 255) look exactly the same. An alpha value of 0 \nmeans the color is completely transparent. If you draw any color that has an alpha value of 0 to a \nsurface object, it will have no effect, because this color is completely transparent and invisible. \nIn order to draw using transparent colors, you must create a Surface object with the \nconvert_alpha() method. For example, the following code creates a Surface object that \ntransparent colors can be drawn on: \nanotherSurface = DISPLAYSURF.convert_alpha() \nOnce things have been drawn on the Surface object stored in anotherSurface, then \nanotherSurface can be ―blitted‖ (that is, copied) to DISPLAYSURF so it will appear on the \nscreen. (See the ―Drawing Images with pygame.image.load() and blit()‖ section later \nin this chapter.) \nIt’s important to note that you cannot use transparent colors on Surface objects not returned from \na convert_alpha() call, including the display Surface that was returned from \npygame.display.set_mode(). \nIf we were to create a color tuple to draw the legendary Invisible Pink Unicorn, we would use \n(255, 192, 192, 0), which ends up looking completely invisible just like any other color \nthat has a 0 for its alpha value. It is, after all, invisible. \n\n\n18    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n(Above is a screenshot of a drawing of the Invisible Pink Unicorn.) \npygame.Color Objects \nYou need to know how to represent a color because Pygame’s drawing functions need a way to \nknow what color you want to draw with. A tuple of three or four integers is one way. Another \nway is as a pygame.Color object. You can create Color objects by calling the \npygame.Color() constructor function and passing either three or four integers. You can store \nthis Color object in variables just like you can store tuples in variables. Try typing the following \ninto the interactive shell: \n>>> import pygame \n>>> pygame.Color(255, 0, 0) \n(255, 0, 0, 255) \n>>> myColor = pygame.Color(255, 0, 0, 128) \n>>> myColor == (255, 0, 0, 128) \nTrue \n>>> \nAny drawing function in Pygame (which we will learn about in a bit) that has a parameter for \ncolor can have either the tuple form or Color object form of a color passed for it. Even though \nthey are different data types, a Color object is equal to a tuple of four integers if they both \nrepresent the same color (just like how 42 == 42.0 will evaluate to True). \nNow that you know how to represent colors (as a pygame.Color object or a tuple of three or \nfour integers for red, green, blue, and optionally alpha) and coordinates (as a tuple of two integers \nfor X and Y), let’s learn about pygame.Rect objects so we can start using Pygame’s drawing \nfunctions. \nRect Objects \nPygame has two ways to represent rectangular areas (just like there are two ways to represent \ncolors). The first is a tuple of four integers:  \n1. The X coordinate of the top left corner. \n\n\nChapter 2 – Pygame Basics    19 \n \n2. The Y coordinate of the top left corner. \n3. The width (in pixels) of the rectangle. \n4. Then height (in pixels) of the rectangle. \nThe second way is as a pygame.Rect object, which we will call Rect objects for short. For \nexample, the code below creates a Rect object with a top left corner at (10, 20) that is 200 pixels \nwide and 300 pixels tall: \n>>> import pygame \n>>> spamRect = pygame.Rect(10, 20, 200, 300) \n>>> spamRect == (10, 20, 200, 300) \nTrue \nThe handy thing about this is that the Rect object automatically calculates the coordinates for \nother features of the rectangle. For example, if you need to know the X coordinate of the right \nedge of the pygame.Rect object we stored in the spamRect variable, you can just access the \nRect object’s right attribute: \n>>> spamRect.right \n210 \nThe Pygame code for the Rect object automatically calculated that if the left edge is at the X \ncoordinate 10 and the rectangle is 200 pixels wide, then the right edge must be at the X \ncoordinate 210. If you reassign the right attribute, all the other attributes are automatically \nrecalculated: \n>>> spam.right = 350 \n>>> spam.left \n150 \nHere’s a list of all the attributes that pygame.Rect objects provide (in our example, the \nvariable where the Rect object is stored in a variable named myRect): \n\n\n20    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nAttribute Name \nDescription \nmyRect.left \nThe int value of the X-coordinate of the left side of the rectangle. \nmyRect.right \nThe int value of the X-coordinate of the right side of the rectangle. \nmyRect.top \nThe int value of the Y-coordinate of the top side of the rectangle. \nmyRect.bottom \nThe int value of the Y-coordinate of the bottom side. \nmyRect.centerx \nThe int value of the X-coordinate of the center of the rectangle. \nmyRect.centery \nThe int value of the Y-coordinate of the center of the rectangle. \nmyRect.width \nThe int value of the width of the rectangle. \nmyRect.height \nThe int value of the height of the rectangle. \nmyRect.size \nA tuple of two ints: (width, height) \nmyRect.topleft \nA tuple of two ints: (left, top) \nmyRect.topright \nA tuple of two ints: (right, top) \nmyRect.bottomleft \nA tuple of two ints: (left, bottom) \nmyRect.bottomright A tuple of two ints: (right, bottom) \nmyRect.midleft \nA tuple of two ints: (left, centery) \nmyRect.midright \nA tuple of two ints: (right, centery) \nmyRect.midtop \nA tuple of two ints: (centerx, top) \nmyRect.midbottom \nA tuple of two ints: (centerx, bottom) \nPrimitive Drawing Functions \nPygame provides several different functions for drawing different shapes onto a surface object. \nThese shapes such as rectangles, circles, ellipses, lines, or individual pixels are often called \ndrawing primitives. Open IDLE’s file editor and type in the following program, and save it as \ndrawing.py. \n 1. import pygame, sys \n 2. from pygame.locals import * \n\n\nChapter 2 – Pygame Basics    21 \n \n 3.  \n 4. pygame.init() \n 5.  \n 6. # set up the window \n 7. DISPLAYSURF = pygame.display.set_mode((500, 400), 0, 32) \n 8. pygame.display.set_caption('Drawing') \n 9.  \n10. # set up the colors \n11. BLACK = (  0,   0,   0) \n12. WHITE = (255, 255, 255) \n13. RED   = (255,   0,   0) \n14. GREEN = (  0, 255,   0) \n15. BLUE  = (  0,   0, 255) \n16.  \n17. # draw on the surface object \n18. DISPLAYSURF.fill(WHITE) \n19. pygame.draw.polygon(DISPLAYSURF, GREEN, ((146, 0), (291, 106), (236, 277), \n(56, 277), (0, 106))) \n20. pygame.draw.line(DISPLAYSURF, BLUE, (60, 60), (120, 60), 4) \n21. pygame.draw.line(DISPLAYSURF, BLUE, (120, 60), (60, 120)) \n22. pygame.draw.line(DISPLAYSURF, BLUE, (60, 120), (120, 120), 4) \n23. pygame.draw.circle(DISPLAYSURF, BLUE, (300, 50), 20, 0) \n24. pygame.draw.ellipse(DISPLAYSURF, RED, (300, 250, 40, 80), 1) \n25. pygame.draw.rect(DISPLAYSURF, RED, (200, 150, 100, 50)) \n26.  \n27. pixObj = pygame.PixelArray(DISPLAYSURF) \n28. pixObj[480][380] = BLACK \n29. pixObj[482][382] = BLACK \n30. pixObj[484][384] = BLACK \n31. pixObj[486][386] = BLACK \n32. pixObj[488][388] = BLACK \n33. del pixObj \n34.  \n35. # run the game loop \n36. while True: \n37.     for event in pygame.event.get(): \n38.         if event.type == QUIT: \n39.             pygame.quit() \n40.             sys.exit() \n41.     pygame.display.update() \nWhen this program is run, the following window is displayed until the user closes the window: \n\n\n22    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nNotice how we make constant variables for each of the colors. Doing this makes our code more \nreadable, because seeing GREEN in the source code is much easier to understand as representing \nthe color green than (0, 255, 0) is.  \nThe drawing functions are named after the shapes they draw. The parameters you pass these \nfunctions tell them which Surface object to draw on, where to draw the shape (and what size), in \nwhat color, and how wide to make the lines. You can see how these functions are called in the \ndrawing.py program, but here is a short description of each function: \n \n \nfill(color) – The fill() method is not a function but a method of pygame.Surface \nobjects. It will completely fill in the entire Surface object with whatever color value you pass \nas for the color parameter. \n \npygame.draw.polygon(surface, color, pointlist, width) – A polygon is shape made up of \nonly flat sides. The surface and color parameters tell the function on what surface to \ndraw the polygon, and what color to make it. \nThe pointlist parameter is a tuple or list of points (that is, tuple or list of two-integer \ntuples for XY coordinates). The polygon is drawn by drawing lines between each point and \nthe point that comes after it in the tuple. Then a line is drawn from the last point to the first \npoint. You can also pass a list of points instead of a tuple of points. \nThe width parameter is optional. If you leave it out, the polygon that is drawn will be filled \nin, just like our green polygon on the screen is filled in with color. If you do pass an integer \nvalue for the width parameter, only the outline of the polygon will be drawn. The integer \nrepresents how many pixels width the polygon’s outline will be. Passing 1 for the width \nparameter will make a skinny polygon, while passing 4 or 10 or 20 will make thicker \npolygons. If you pass the integer 0 for the width parameter, the polygon will be filled in \n(just like if you left the width parameter out entirely). \nAll of the pygame.draw drawing functions have optional width parameters at the end, \nand they work the same way as pygame.draw.polygon()’s width parameter. \nProbably a better name for the width parameter would have been thickness, since that \nparameter controls how thick the lines you draw are. \n\n\nChapter 2 – Pygame Basics    23 \n \n \npygame.draw.line(surface, color, start_point, end_point, width) – This function draws a \nline between the start_point and end_point parameters. \n \npygame.draw.lines(surface, color, closed, pointlist, width) – This function draws a series \nof lines from one point to the next, much like pygame.draw.polygon(). The only \ndifference is that if you pass False for the closed parameter, there will not be a line from \nthe last point in the pointlist parameter to the first point. If you pass True, then it will \ndraw a line from the last point to the first. \n \npygame.draw.circle(surface, color, center_point, radius, width) – This function draws a \ncircle. The center of the circle is at the center_point parameter. The integer passed for \nthe radius parameter sets the size of the circle. \nThe radius of a circle is the distance from the center to the edge. (The radius of a circle is \nalways half of the diameter.) Passing 20 for the radius parameter will draw a circle that \nhas a radius of 20 pixels. \n \npygame.draw.ellipse(surface, color, bounding_rectangle, width) – This function draws an \nellipse (which is like a squashed or stretched circle). This function has all the usual \nparameters, but in order to tell the function how large and where to draw the ellipse, you must \nspecify the bounding rectangle of the ellipse. A bounding rectangle is the smallest rectangle \nthat can be drawn around a shape. Here’s an example of an ellipse and its bounding rectangle: \n \nThe bounding_rectangle parameter can be a pygame.Rect object or a tuple of four \nintegers. Note that you do not specify the center point for the ellipse like you do for the \npygame.draw.circle() function. \n \npygame.draw.rect(surface, color, rectangle_tuple, width) – This function draws a \nrectangle. The rectangle_tuple is either a tuple of four integers (for the XY coordinates \nof the top left corner, and the width and height) or a pygame.Rect object can be passed \ninstead. If the rectangle_tuple has the same size for the width and height, a square will \nbe drawn. \npygame.PixelArray Objects \nUnfortunately, there isn’t a single function you can call that will set a single pixel to a color \n(unless you call pygame.draw.line() with the same start and end point). The Pygame \nframework needs to run some code behind the scenes before and after drawing to a Surface \nobject. If it had to do this for every single pixel you wanted to set, your program would run much \nslower. (By my quick testing, drawing pixels this way is two or three times slower.) \nInstead, you should create a pygame.PixelArray object (we’ll call them PixelArray objects \nfor short) of a Surface object and then set individual pixels. Creating a PixelArray object of a \nSurface object will ―lock‖ the Surface object. While a Surface object is locked, the drawing \n\n\n24    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nfunctions can still be called on it, but it cannot have images like PNG or JPG images drawn on it \nwith the blit() method. (The blit() method is explained later in this chapter.) \nIf you want to see if a Surface object is locked, the get_locked() Surface method will return \nTrue if it is locked and False if it is not. \nThe PixelArray object that is returned from pygame.PixelArray() can have individual \npixels set by accessing them with two indexes. For example, line 28’s pixObj[480][380] = \nBLACK will set the pixel at X coordinate 480 and Y coordinate 380 to be black (remember that \nthe BLACK variable stores the color tuple (0, 0, 0)). \nTo tell Pygame that you are finished drawing individual pixels, delete the PixelArray object with \na del statement. This is what line 33 does. Deleting the PixelArray object will ―unlock‖ the \nSurface object so that you can once again draw images on it. If you forget to delete the \nPixelArray object, the next time you try to blit (that is, draw) an image to the Surface the program \nwill raise an error that says, ―pygame.error: Surfaces must not be locked \nduring blit‖. \nThe pygame.display.update() Function \nAfter you are done calling the drawing functions to make the display Surface object look the way \nyou want, you must call pygame.display.update() to make the display Surface actually \nappear on the user’s monitor. \nThe one thing that you must remember is that pygame.display.update() will only make \nthe display Surface (that is, the Surface object that was returned from the call to \npygame.display.set_mode()) appear on the screen. If you want the images on other \nSurface objects to appear on the screen, you must ―blit‖ them (that is, copy them) to the display \nSurface object with the blit() method (which is explained next in the ―Drawing Images‖ \nsection). \nAnimation \nNow that we know how to get the Pygame framework to draw to the screen, let’s learn how to \nmake animated pictures. A game with only still, unmoving images would be fairly dull. (Sales of \nmy game ―Look At This Rock‖ have been disappointing.) Animated images are the result of \ndrawing an image on the screen, then a split second later drawing a slightly different image on the \nscreen. Imagine the program’s window was 6 pixels wide and 1 pixel tall, with all the pixels \nwhite except for a black pixel at 4, 0. It would look like this: \n",
      "page_number": 34,
      "chapter_number": 5,
      "summary": "For example, we will create the tuple (0, 0, 0) and store it in a variable named BLACK Key topics include colors, draw, and parameter.",
      "keywords": [
        "surface object",
        "color",
        "surface",
        "object",
        "tuple",
        "Pygame",
        "blue",
        "Color object",
        "red",
        "Drawing",
        "Rect object",
        "green",
        "rectangle",
        "BLACK",
        "width"
      ],
      "concepts": [
        "colors",
        "draw",
        "parameter",
        "surface",
        "object",
        "pixel",
        "images",
        "black",
        "width",
        "different"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 32,
          "title": "Segment 32 (pages 336-344)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 4,
          "title": "Segment 4 (pages 27-34)",
          "relevance_score": 0.46,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 5,
          "title": "Segment 5 (pages 35-42)",
          "relevance_score": 0.46,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 4,
          "title": "Segment 4 (pages 62-83)",
          "relevance_score": 0.46,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 21,
          "title": "Segment 21 (pages 415-432)",
          "relevance_score": 0.46,
          "method": "api"
        }
      ]
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 43-50)",
      "start_page": 43,
      "end_page": 50,
      "detection_method": "topic_boundary",
      "content": "Chapter 2 – Pygame Basics    25 \n \n \nIf you changed the window so that 3, 0 was black and 4,0 was white, it would look like this: \n \nTo the user, it looks like the black pixel has ―moved‖ over to the left. If you redrew the window \nto have the black pixel at 2, 0, it would continue to look like the black pixel is moving left: \n \nIt may look like the black pixel is moving, but this is just an illusion. To the computer, it is just \nshowing three different images that each just happen to have one black pixel. Consider if the \nthree following images were rapidly shown on the screen: \n \nTo the user, it would look like the cat is moving towards the squirrel. But to the computer, they’re \njust a bunch of pixels. The trick to making believable looking animation is to have your program \ndraw a picture to the window, wait a fraction of a second, and then draw a slightly different \npicture. \nHere is an example program demonstrating a simple animation. Type this code into IDLE’s file \neditor and save it as catanimation.py. It will also require the image file cat.png to be in the same \nfolder as the catanimation.py file. You can download this image from http://invpy.com/cat.png. \nThis code is available at http://invpy.com/catanimation.py. \n\n\n26    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 1. import pygame, sys \n 2. from pygame.locals import * \n 3.  \n 4. pygame.init() \n 5.  \n 6. FPS = 30 # frames per second setting \n 7. fpsClock = pygame.time.Clock() \n 8.  \n 9. # set up the window \n10. DISPLAYSURF = pygame.display.set_mode((400, 300), 0, 32) \n11. pygame.display.set_caption('Animation') \n12. \n13. WHITE = (255, 255, 255) \n14. catImg = pygame.image.load('cat.png') \n15. catx = 10 \n16. caty = 10 \n17. direction = 'right' \n18. \n19. while True: # the main game loop \n20.     DISPLAYSURF.fill(WHITE) \n21.  \n22.     if direction == 'right': \n23.         catx += 5 \n24.         if catx == 280: \n25.             direction = 'down' \n26.     elif direction == 'down': \n27.         caty += 5 \n28.         if caty == 220: \n29.             direction = 'left' \n30.     elif direction == 'left': \n31.         catx -= 5 \n32.         if catx == 10: \n33.             direction = 'up' \n34.     elif direction == 'up': \n35.         caty -= 5 \n36.         if caty == 10: \n37.             direction = 'right' \n38.  \n39.     DISPLAYSURF.blit(catImg, (catx, caty)) \n40.  \n41.     for event in pygame.event.get(): \n42.         if event.type == QUIT: \n43.             pygame.quit() \n44.             sys.exit() \n45. \n46.     pygame.display.update() \n\n\nChapter 2 – Pygame Basics    27 \n \n47.     fpsClock.tick(FPS) \nLook at that animated cat go! This program will be much more of a commercial success than my \ngame, ―Look At This Rock 2: A Different Rock‖. \nFrames Per Second and pygame.time.Clock Objects \nThe frame rate or refresh rate is the number of pictures that the program draws per second, and \nis measured in FPS or frames per second. (On computer monitors, the common name for FPS is \nhertz. Many monitors have a frame rate of 60 hertz, or 60 frames per second.) A low frame rate in \nvideo games can make the game look choppy or jumpy. If the program has too much code to run \nto draw to the screen frequently enough, then the FPS goes down. But the games in this book are \nsimple enough that this won’t be issue even on old computers. \nA pygame.time.Clock object can help us make sure our program runs at a certain maximum \nFPS. This Clock object will ensure that our game programs don’t run too fast by putting in \nsmall pauses on each iteration of the game loop. If we didn’t have these pauses, our game \nprogram would run as fast as the computer could run it. This is often too fast for the player, and \nas computers get faster they would run the game faster too. A call to the tick() method of a \nClock object in the game loop can make sure the game runs at the same speed no matter how \nfast of a computer it runs on. The Clock object is created on line 7 of the catanimation.py \nprogram. \n7. fpsClock = pygame.time.Clock() \nThe Clock object’s tick() method should be called at the very end of the game loop, after the \ncall to pygame.display.update(). The length of the pause is calculated based on how \nlong it has been since the previous call to tick(), which would have taken place at the end of \nthe previous iteration of the game loop. (The first time the tick() method is called, it doesn’t \npause at all.) In the animation program, is it run on line 47 as the last instruction in the game loop. \nAll you need to know is that you should call the tick() method once per iteration through the \ngame loop at the end of the loop. Usually this is right after the call to \npygame.display.update(). \n47.     fpsClock.tick(FPS) \nTry modifying the FPS constant variable to run the same program at different frame rates. Setting \nit to a lower value would make the program run slower. Setting it to a higher value would make \nthe program run faster. \n\n\n28    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nDrawing Images with pygame.image.load() and blit() \nThe drawing functions are fine if you want to draw simple shapes on the screen, but many games \nhave images (also called sprites). Pygame is able to load images onto Surface objects from PNG, \nJPG, GIF, and BMP image files. The differences between these image file formats is described at \nhttp://invpy.com/formats. \nThe image of the cat was stored in a file named cat.png. To load this file’s image, the string \n'cat.png' is passed to the pygame.image.load() function. The \npygame.image.load() function call will return a Surface object that has the image drawn \non it. This Surface object will be a separate Surface object from the display Surface object, so we \nmust blit (that is, copy) the image’s Surface object to the display Surface object. Blitting is \ndrawing the contents of one Surface onto another. It is done with the blit() Surface object \nmethod. \nIf you get an error message like ―pygame.error: Couldn't open cat.png‖ when \ncalling pygame.image.load(), then make sure the cat.png file is in the same folder as the \ncatanimation.py file before you run the program. \n39.     DISPLAYSURF.blit(catImg, (catx, caty)) \nLine 39 of the animation program uses the blit() method to copy catImg to DISPLAYSURF. \nThere are two parameters for blit(). The first is the source Surface object, which is what will \nbe copied onto the DISPLAYSURF Surface object. The second parameter is a two-integer tuple \nfor the X and Y values of the topleft corner where the image should be blitted to. \nIf catx and caty were set to 100 and 200 and the width of catImg was 125 and the height \nwas 79, this blit() call would copy this image onto DISPLAYSURF so that the top left corner \nof the catImg was at the XY coordinate (100, 200) and the bottom right corner’s XY coordinate \nwas at (225, 279). \nNote that you cannot blit to a Surface that is currently ―locked‖ (such as when a PixelArray object \nhas been made from it and not yet been deleted.) \nThe rest of the game loop is just changing the catx, caty, and direction variables so that \nthe cat moves around the window. There is also a call to pygame.event.get() to handle the \nQUIT event. \nFonts \nIf you want to draw text to the screen, you could write several calls to pygame.draw.line() \nto draw out the lines of each letter. This would be a headache to type out all those \n\n\nChapter 2 – Pygame Basics    29 \n \npygame.draw.line() calls and figure out all the XY coordinates, and probably wouldn’t \nlook very good. \n \nThe above message would take forty one calls to the pygame.draw.line() function to \nmake. Instead, Pygame provides some much simpler functions for fonts and creating text. Here is \na small Hello World program using Pygame’s font functions. Type it into IDLE’s file editor and \nsave it as fonttext.py: \n 1. import pygame, sys \n 2. from pygame.locals import * \n 3. \n 4. pygame.init() \n 5. DISPLAYSURF = pygame.display.set_mode((400, 300)) \n 6. pygame.display.set_caption('Hello World!') \n 7.  \n 8. WHITE = (255, 255, 255) \n 9. GREEN = (0, 255, 0) \n10. BLUE = (0, 0, 128) \n11.  \n12. fontObj = pygame.font.Font('freesansbold.ttf', 32) \n13. textSurfaceObj = fontObj.render('Hello world!', True, GREEN, BLUE) \n14. textRectObj = textSurfaceObj.get_rect() \n15. textRectObj.center = (200, 150) \n16. \n17. while True: # main game loop \n18.     DISPLAYSURF.fill(WHITE) \n19.     DISPLAYSURF.blit(textSurfaceObj, textRectObj) \n20.     for event in pygame.event.get(): \n21.         if event.type == QUIT: \n22.             pygame.quit() \n23.             sys.exit() \n24.     pygame.display.update() \nThere are six steps to making text appear on the screen: \n1. Create a pygame.font.Font object. (Like on line 12) \n2. Create a Surface object with the text drawn on it by calling the Font object’s render() \nmethod. (Line 13) \n3. Create a Rect object from the Surface object by calling the Surface object’s \nget_rect() method. (Line 14) This Rect object will have the width and height \ncorrectly set for the text that was rendered, but the top and left attributes will be 0. \n\n\n30    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n4. Set the position of the Rect object by changing one of its attributes. On line 15, we set the \ncenter of the Rect object to be at 200, 150. \n5. Blit the Surface object with the text onto the Surface object returned by \npygame.display.set_mode(). (Line 19) \n6. Call pygame.display.update() to make the display Surface appear on the screen. \n(Line 24) \nThe parameters to the pygame.font.Font() constructor function is a string of the font file to \nuse, and an integer of the size of the font (in points, like how word processors measure font size). \nOn line 12, we pass 'freesansbold.ttf' (this is a font that comes with Pygame) and the \ninteger 32 (for a 32-point sized font). \nSee http://invpy.com/usingotherfonts for more info on using other fonts. \nThe parameters to the render() method call are a string of the text to render, a Boolean value \nto specify if we want anti-aliasing (explained later in this chapter), the color of the text, and the \ncolor of the background. If you want a transparent background, then simply leave off the \nbackground color parameter in the method call. \nAnti-Aliasing \nAnti-aliasing is a graphics technique for making text and shapes look less blocky by adding a \nlittle bit of blur to their edges. It takes a little more computation time to draw with anti-aliasing, \nso although the graphics may look better, your program may run slower (but only just a little). \nIf you zoom in on an aliased line and an anti-aliased line, they look like this: \n \nTo make Pygame’s text use anti-aliasing, just pass True for the second parameter of the \nrender() method. The pygame.draw.aaline() and pygame.draw.aalines() \nfunctions have the same parameters as pygame.draw.line() and \n\n\nChapter 2 – Pygame Basics    31 \n \npygame.draw.lines(), except they will draw anti-aliased (smooth) lines instead of aliased \n(blocky) lines. \nPlaying Sounds \nPlaying sounds that are stored in sound files is even simpler than displaying images from image \nfiles. First, you must create a pygame.mixer.Sound object (which we will call Sound objects \nfor short) by calling the pygame.mixer.Sound() constructor function. It takes one string \nparameter, which is the filename of the sound file. Pygame can load WAV, MP3, or OGG files. \nThe difference between these audio file formats is explained at http://invpy.com/formats. \nTo play this sound, call the Sound object’s play() method. If you want to immediately stop the \nSound object from playing call the stop() method. The stop() method has no arguments. \nHere is some sample code: \nsoundObj = pygame.mixer.Sound('beeps.wav') \nsoundObj.play() \nimport time \ntime.sleep(1) # wait and let the sound play for 1 second \nsoundObj.stop() \nYou can download the beeps.wav file from http://invpy.com/beeps.wav. \nThe program execution continues immediately after play() is called; it does not wait for the \nsound to finish playing before moving on to the next line of code. \nThe Sound objects are good for sound effects to play when the player takes damage, slashes a \nsword, or collects a coin. But your games might also be better if they had background music \nplaying regardless of what was going on in the game. Pygame can only load one music file to \nplay in the background at a time. To load a background music file, call the \npygame.mixer.music.load() function and pass it a string argument of the sound file to \nload. This file can be WAV, MP3, or MIDI format.  \nTo begin playing the loaded sound file as the background music, call the \npygame.mixer.music.play(-1, 0.0) function. The -1 argument makes the \nbackground music forever loop when it reaches the end of the sound file. If you set it to an integer \n0 or larger, then the music will only loop that number of times instead of looping forever. The \n0.0 means to start playing the sound file from the beginning. If you pass a larger integer or float, \nthe music will begin playing that many seconds into the sound file. For example, if you pass \n13.5 for the second parameter, the sound file with begin playing at the point 13.5 seconds in \nfrom the beginning. \n\n\n32    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nTo stop playing the background music immediately, call the pygame.mixer.music.stop() \nfunction. This function has no arguments. \nHere is some example code of the sound methods and functions: \n# Loading and playing a sound effect: \nsoundObj = pygame.mixer.Sound('beepingsound.wav') \nsoundObj.play() \n \n# Loading and playing background music: \npygame.mixer.music.load(backgroundmusic.mp3') \npygame.mixer.music.play(-1, 0.0) \n# ...some more of your code goes here... \npygame.mixer.music.stop() \nSummary \nThis covers the basics of making graphical games with the Pygame framework. Of course, just \nreading about these functions probably isn’t enough to help you learn how to make games using \nthese functions. The rest of the chapters in this book each focus on the source code for a small, \ncomplete game. This will give you an idea of what complete game programs ―look like‖, so you \ncan then get some ideas for how to code your own game programs. \nUnlike the ―Invent Your Own Computer Games with Python‖ book, this book assumes that you \nknow the basics of Python programming. If you have trouble remembering how variables, \nfunctions, loops, if-else statements, and conditions work, you can probably figure it out just \nby seeing what’s in the code and how the program behaves. But if you are still stuck, you can \nread the ―Invent with Python‖ book (it’s for people who are completely new to programming) for \nfree online at http://inventwithpython.com. \n \n \n",
      "page_number": 43,
      "chapter_number": 6,
      "summary": "This chapter covers segment 6 (pages 43-50). Key topics include programs, programming, and file. The trick to making believable looking animation is to have your program \ndraw a picture to the window, wait a fraction of a second, and then draw a slightly different \npicture.",
      "keywords": [
        "Surface object",
        "object",
        "Surface",
        "game",
        "file",
        "sound",
        "sound file",
        "game loop",
        "Pygame",
        "program",
        "black pixel",
        "call",
        "DISPLAYSURF Surface object",
        "line",
        "display Surface object"
      ],
      "concepts": [
        "programs",
        "programming",
        "file",
        "playing",
        "functions",
        "function",
        "line",
        "game",
        "look",
        "objects"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 4,
          "title": "Segment 4 (pages 64-82)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 50,
          "title": "Segment 50 (pages 487-494)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 26,
          "title": "Segment 26 (pages 503-525)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 53,
          "title": "Segment 53 (pages 511-519)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 3,
          "title": "Segment 3 (pages 42-63)",
          "relevance_score": 0.56,
          "method": "api"
        }
      ]
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 51-59)",
      "start_page": 51,
      "end_page": 59,
      "detection_method": "topic_boundary",
      "content": "Chapter 3 – Memory Puzzle    33 \n \nCHAPTER 3 – MEMORY \nPUZZLE \n \nHow to Play Memory Puzzle \nIn the Memory Puzzle game, several icons are covered up by white boxes. There are two of each \nicon. The player can click on two boxes to see what icon is behind them. If the icons match, then \nthose boxes remain uncovered. The player wins when all the boxes on the board are uncovered. \nTo give the player a hint, the boxes are quickly uncovered once at the beginning of the game. \nNested for Loops \nOne concept that you will see in Memory Puzzle (and most of the games in this book) is the use \nof a for loop inside of another for loop. These are called nested for loops. Nested for loops \nare handy for going through every possible combination of two lists. Type the following into the \ninteractive shell: \n>>> for x in [0, 1, 2, 3, 4]: \n...     for y in ['a', 'b', 'c']: \n...         print(x, y) \n... \n0 a \n0 b \n0 c \n1 a \n1 b \n1 c \n2 a \n\n\n34    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n2 b \n2 c \n3 a \n3 b \n3 c \n4 a \n4 b \n4 c \n>>> \nThere are several times in the Memory Puzzle code that we need to iterate through every possible \nX and Y coordinate on the board. We’ll use nested for loops to make sure that we get every \ncombination. Note that the inner for loop (the for loop inside the other for loop) will go \nthrough all of its iterations before going to the next iteration of the outer for loop. If we reverse \nthe order of the for loops, the same values will be printed but they will be printed in a different \norder. Type the following code into the interactive shell, and compare the order it prints values to \nthe order in the previous nested for loop example: \n>>> for y in ['a', 'b', 'c']: \n...     for x in [0, 1, 2, 3, 4]: \n...         print(x, y) \n... \n0 a \n1 a \n2 a \n3 a \n4 a \n0 b \n1 b \n2 b \n3 b \n4 b \n0 c \n1 c \n2 c \n3 c \n4 c \n>>> \nSource Code of Memory Puzzle \nThis source code can be downloaded from http://invpy.com/memorypuzzle.py. \nGo ahead and first type in the entire program into IDLE’s file editor, save it as memorypuzzle.py, \nand run it. If you get any error messages, look at the line number that is mentioned in the error \n\n\nChapter 3 – Memory Puzzle    35 \n \nmessage and check your code for any typos. You can also copy and paste your code into the web \nform at http://invpy.com/diff/memorypuzzle to see if the differences between your code and the \ncode in the book. \nYou’ll probably pick up a few ideas about how the program works just by typing it in once. And \nwhen you’re done typing it in, you can then play the game for yourself. \n  1. # Memory Puzzle \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Released under a \"Simplified BSD\" license \n  5.  \n  6. import random, pygame, sys \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 # frames per second, the general speed of the program \n 10. WINDOWWIDTH = 640 # size of window's width in pixels \n 11. WINDOWHEIGHT = 480 # size of windows' height in pixels \n 12. REVEALSPEED = 8 # speed boxes' sliding reveals and covers \n 13. BOXSIZE = 40 # size of box height & width in pixels \n 14. GAPSIZE = 10 # size of gap between boxes in pixels \n 15. BOARDWIDTH = 10 # number of columns of icons \n 16. BOARDHEIGHT = 7 # number of rows of icons \n 17. assert (BOARDWIDTH * BOARDHEIGHT) % 2 == 0, 'Board needs to have an even \nnumber of boxes for pairs of matches.' \n 18. XMARGIN = int((WINDOWWIDTH - (BOARDWIDTH * (BOXSIZE + GAPSIZE))) / 2) \n 19. YMARGIN = int((WINDOWHEIGHT - (BOARDHEIGHT * (BOXSIZE + GAPSIZE))) / 2) \n 20.  \n 21. #            R    G    B \n 22. GRAY     = (100, 100, 100) \n 23. NAVYBLUE = ( 60,  60, 100) \n 24. WHITE    = (255, 255, 255) \n 25. RED      = (255,   0,   0) \n 26. GREEN    = (  0, 255,   0) \n 27. BLUE     = (  0,   0, 255) \n 28. YELLOW   = (255, 255,   0) \n 29. ORANGE   = (255, 128,   0) \n 30. PURPLE   = (255,   0, 255) \n 31. CYAN     = (  0, 255, 255) \n 32.  \n 33. BGCOLOR = NAVYBLUE \n 34. LIGHTBGCOLOR = GRAY \n 35. BOXCOLOR = WHITE \n 36. HIGHLIGHTCOLOR = BLUE \n 37.  \n 38. DONUT = 'donut' \n\n\n36    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 39. SQUARE = 'square' \n 40. DIAMOND = 'diamond' \n 41. LINES = 'lines' \n 42. OVAL = 'oval' \n 43.  \n 44. ALLCOLORS = (RED, GREEN, BLUE, YELLOW, ORANGE, PURPLE, CYAN) \n 45. ALLSHAPES = (DONUT, SQUARE, DIAMOND, LINES, OVAL) \n 46. assert len(ALLCOLORS) * len(ALLSHAPES) * 2 >= BOARDWIDTH * BOARDHEIGHT, \n\"Board is too big for the number of shapes/colors defined.\" \n 47.  \n 48. def main(): \n 49.     global FPSCLOCK, DISPLAYSURF \n 50.     pygame.init() \n 51.     FPSCLOCK = pygame.time.Clock() \n 52.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 53.  \n 54.     mousex = 0 # used to store x coordinate of mouse event \n 55.     mousey = 0 # used to store y coordinate of mouse event \n 56.     pygame.display.set_caption('Memory Game') \n 57.  \n 58.     mainBoard = getRandomizedBoard() \n 59.     revealedBoxes = generateRevealedBoxesData(False) \n 60.  \n 61.     firstSelection = None # stores the (x, y) of the first box clicked. \n 62.  \n 63.     DISPLAYSURF.fill(BGCOLOR) \n 64.     startGameAnimation(mainBoard) \n 65.  \n 66.     while True: # main game loop \n 67.         mouseClicked = False \n 68.  \n 69.         DISPLAYSURF.fill(BGCOLOR) # drawing the window \n 70.         drawBoard(mainBoard, revealedBoxes) \n 71.  \n 72.         for event in pygame.event.get(): # event handling loop \n 73.             if event.type == QUIT or (event.type == KEYUP and event.key == \nK_ESCAPE): \n 74.                 pygame.quit() \n 75.                 sys.exit() \n 76.             elif event.type == MOUSEMOTION: \n 77.                 mousex, mousey = event.pos \n 78.             elif event.type == MOUSEBUTTONUP: \n 79.                 mousex, mousey = event.pos \n 80.                 mouseClicked = True \n 81.  \n 82.         boxx, boxy = getBoxAtPixel(mousex, mousey) \n\n\nChapter 3 – Memory Puzzle    37 \n \n 83.         if boxx != None and boxy != None: \n 84.             # The mouse is currently over a box. \n 85.             if not revealedBoxes[boxx][boxy]: \n 86.                drawHighlightBox(boxx, boxy) \n 87.             if not revealedBoxes[boxx][boxy] and mouseClicked: \n 88.                 revealBoxesAnimation(mainBoard, [(boxx, boxy)]) \n 89.                 revealedBoxes[boxx][boxy] = True # set the box as \n\"revealed\" \n 90.                 if firstSelection == None: # the current box was the first \nbox clicked \n 91.                     firstSelection = (boxx, boxy) \n 92.                 else: # the current box was the second box clicked \n 93.                     # Check if there is a match between the two icons. \n 94.                     icon1shape, icon1color = getShapeAndColor(mainBoard, \nfirstSelection[0], firstSelection[1]) \n 95.                     icon2shape, icon2color = getShapeAndColor(mainBoard, \nboxx, boxy) \n 96.  \n 97.                     if icon1shape != icon2shape or icon1color != \nicon2color: \n 98.                         # Icons don't match. Re-cover up both selections. \n 99.                         pygame.time.wait(1000) # 1000 milliseconds = 1 sec \n100.                         coverBoxesAnimation(mainBoard, \n[(firstSelection[0], firstSelection[1]), (boxx, boxy)]) \n101.                         revealedBoxes[firstSelection[0]][firstSelection \n[1]] = False \n102.                         revealedBoxes[boxx][boxy] = False \n103.                     elif hasWon(revealedBoxes): # check if all pairs found \n104.                         gameWonAnimation(mainBoard) \n105.                         pygame.time.wait(2000) \n106.  \n107.                         # Reset the board \n108.                         mainBoard = getRandomizedBoard() \n109.                         revealedBoxes = generateRevealedBoxesData(False) \n110.  \n111.                         # Show the fully unrevealed board for a second. \n112.                         drawBoard(mainBoard, revealedBoxes) \n113.                         pygame.display.update() \n114.                         pygame.time.wait(1000) \n115.  \n116.                         # Replay the start game animation. \n117.                         startGameAnimation(mainBoard) \n \n118.                     firstSelection = None # reset firstSelection variable \n119.  \n120.         # Redraw the screen and wait a clock tick. \n121.         pygame.display.update() \n\n\n38    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n122.         FPSCLOCK.tick(FPS) \n123.  \n124.  \n125. def generateRevealedBoxesData(val): \n126.     revealedBoxes = [] \n127.     for i in range(BOARDWIDTH): \n128.         revealedBoxes.append([val] * BOARDHEIGHT) \n129.     return revealedBoxes \n130.  \n131.  \n132. def getRandomizedBoard(): \n133.     # Get a list of every possible shape in every possible color. \n134.     icons = [] \n135.     for color in ALLCOLORS: \n136.         for shape in ALLSHAPES: \n137.             icons.append( (shape, color) ) \n138.  \n139.     random.shuffle(icons) # randomize the order of the icons list \n140.     numIconsUsed = int(BOARDWIDTH * BOARDHEIGHT / 2) # calculate how many \nicons are needed \n141.     icons = icons[:numIconsUsed] * 2 # make two of each \n142.     random.shuffle(icons) \n143. \n144.     # Create the board data structure, with randomly placed icons. \n145.     board = [] \n146.     for x in range(BOARDWIDTH): \n147.         column = [] \n148.         for y in range(BOARDHEIGHT): \n149.             column.append(icons[0]) \n150.             del icons[0] # remove the icons as we assign them \n151.         board.append(column) \n152.     return board \n153.  \n154.  \n155. def splitIntoGroupsOf(groupSize, theList): \n156.     # splits a list into a list of lists, where the inner lists have at \n157.     # most groupSize number of items. \n158.     result = [] \n159.     for i in range(0, len(theList), groupSize): \n160.         result.append(theList[i:i + groupSize]) \n161.     return result \n162.  \n163.  \n164. def leftTopCoordsOfBox(boxx, boxy): \n165.     # Convert board coordinates to pixel coordinates \n166.     left = boxx * (BOXSIZE + GAPSIZE) + XMARGIN \n\n\nChapter 3 – Memory Puzzle    39 \n \n167.     top = boxy * (BOXSIZE + GAPSIZE) + YMARGIN \n168.     return (left, top) \n169.  \n170.  \n171. def getBoxAtPixel(x, y): \n172.     for boxx in range(BOARDWIDTH): \n173.         for boxy in range(BOARDHEIGHT): \n174.             left, top = leftTopCoordsOfBox(boxx, boxy) \n175.             boxRect = pygame.Rect(left, top, BOXSIZE, BOXSIZE) \n176.             if boxRect.collidepoint(x, y): \n177.                 return (boxx, boxy) \n178.     return (None, None) \n179.  \n180.  \n181. def drawIcon(shape, color, boxx, boxy): \n182.     quarter = int(BOXSIZE * 0.25) # syntactic sugar \n183.     half =    int(BOXSIZE * 0.5)  # syntactic sugar \n184.  \n185.     left, top = leftTopCoordsOfBox(boxx, boxy) # get pixel coords from \nboard coords \n186.     # Draw the shapes \n187.     if shape == DONUT: \n188.         pygame.draw.circle(DISPLAYSURF, color, (left + half, top + half), \nhalf - 5) \n189.         pygame.draw.circle(DISPLAYSURF, BGCOLOR, (left + half, top + \nhalf), quarter - 5) \n190.     elif shape == SQUARE: \n191.         pygame.draw.rect(DISPLAYSURF, color, (left + quarter, top + \nquarter, BOXSIZE - half, BOXSIZE - half)) \n192.     elif shape == DIAMOND: \n193.         pygame.draw.polygon(DISPLAYSURF, color, ((left + half, top), (left \n+ BOXSIZE - 1, top + half), (left + half, top + BOXSIZE - 1), (left, top + \nhalf))) \n194.     elif shape == LINES: \n195.         for i in range(0, BOXSIZE, 4): \n196.             pygame.draw.line(DISPLAYSURF, color, (left, top + i), (left + \ni, top)) \n197.             pygame.draw.line(DISPLAYSURF, color, (left + i, top + BOXSIZE \n- 1), (left + BOXSIZE - 1, top + i)) \n198.     elif shape == OVAL: \n199.         pygame.draw.ellipse(DISPLAYSURF, color, (left, top + quarter, \nBOXSIZE, half)) \n200.  \n201.  \n202. def getShapeAndColor(board, boxx, boxy): \n203.     # shape value for x, y spot is stored in board[x][y][0] \n\n\n40    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n204.     # color value for x, y spot is stored in board[x][y][1] \n205.     return board[boxx][boxy][0], board[boxx][boxy][1] \n206.  \n207.  \n208. def drawBoxCovers(board, boxes, coverage): \n209.     # Draws boxes being covered/revealed. \"boxes\" is a list \n210.     # of two-item lists, which have the x & y spot of the box. \n211.     for box in boxes: \n212.         left, top = leftTopCoordsOfBox(box[0], box[1]) \n213.         pygame.draw.rect(DISPLAYSURF, BGCOLOR, (left, top, BOXSIZE, \nBOXSIZE)) \n214.         shape, color = getShapeAndColor(board, box[0], box[1]) \n215.         drawIcon(shape, color, box[0], box[1]) \n216.         if coverage > 0: # only draw the cover if there is an coverage \n217.             pygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, coverage, \nBOXSIZE)) \n218.     pygame.display.update() \n219.     FPSCLOCK.tick(FPS) \n220.  \n221.  \n222. def revealBoxesAnimation(board, boxesToReveal): \n223.     # Do the \"box reveal\" animation. \n224.     for coverage in range(BOXSIZE, (-REVEALSPEED) - 1, - REVEALSPEED): \n225.         drawBoxCovers(board, boxesToReveal, coverage) \n226.  \n227.  \n228. def coverBoxesAnimation(board, boxesToCover): \n229.     # Do the \"box cover\" animation. \n230.     for coverage in range(0, BOXSIZE + REVEALSPEED, REVEALSPEED): \n231.         drawBoxCovers(board, boxesToCover, coverage) \n232.  \n233.  \n234. def drawBoard(board, revealed): \n235.     # Draws all of the boxes in their covered or revealed state. \n236.     for boxx in range(BOARDWIDTH): \n237.         for boxy in range(BOARDHEIGHT): \n238.             left, top = leftTopCoordsOfBox(boxx, boxy) \n239.             if not revealed[boxx][boxy]: \n240.                 # Draw a covered box. \n241.                 pygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, \nBOXSIZE, BOXSIZE)) \n242.             else: \n243.                 # Draw the (revealed) icon. \n244.                 shape, color = getShapeAndColor(board, boxx, boxy) \n245.                 drawIcon(shape, color, boxx, boxy) \n246.  \n\n\nChapter 3 – Memory Puzzle    41 \n \n247.  \n248. def drawHighlightBox(boxx, boxy): \n249.     left, top = leftTopCoordsOfBox(boxx, boxy) \n250.     pygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, (left - 5, top - 5, \nBOXSIZE + 10, BOXSIZE + 10), 4) \n251.  \n252.  \n253. def startGameAnimation(board): \n254.     # Randomly reveal the boxes 8 at a time. \n255.     coveredBoxes = generateRevealedBoxesData(False) \n256.     boxes = [] \n257.     for x in range(BOARDWIDTH): \n258.         for y in range(BOARDHEIGHT): \n259.             boxes.append( (x, y) ) \n260.     random.shuffle(boxes) \n261.     boxGroups = splitIntoGroupsOf(8, boxes) \n262.  \n263.     drawBoard(board, coveredBoxes) \n264.     for boxGroup in boxGroups: \n265.         revealBoxesAnimation(board, boxGroup) \n266.         coverBoxesAnimation(board, boxGroup) \n267.  \n268.  \n269. def gameWonAnimation(board): \n270.     # flash the background color when the player has won \n271.     coveredBoxes = generateRevealedBoxesData(True) \n272.     color1 = LIGHTBGCOLOR \n273.     color2 = BGCOLOR \n274.  \n275.     for i in range(13): \n276.         color1, color2 = color2, color1 # swap colors \n277.         DISPLAYSURF.fill(color1) \n278.         drawBoard(board, coveredBoxes) \n279.         pygame.display.update() \n280.         pygame.time.wait(300) \n281.  \n282.  \n283. def hasWon(revealedBoxes): \n284.     # Returns True if all the boxes have been revealed, otherwise False \n285.     for i in revealedBoxes: \n286.         if False in i: \n287.             return False # return False if any boxes are covered. \n288.     return True \n289.  \n290.  \n291. if __name__ == '__main__': \n",
      "page_number": 51,
      "chapter_number": 7,
      "summary": "This chapter covers segment 7 (pages 51-59). Key topics include board, boxes.",
      "keywords": [
        "Memory Puzzle",
        "BOXSIZE",
        "left",
        "top",
        "board",
        "boxx",
        "boxy",
        "Memory",
        "DISPLAYSURF",
        "Puzzle",
        "BOARDWIDTH",
        "BOARDHEIGHT",
        "box",
        "icons",
        "Memory Puzzle code"
      ],
      "concepts": [
        "board",
        "boxes",
        "box",
        "icons",
        "color",
        "left",
        "returns",
        "shapes",
        "drawing",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 4,
          "title": "Segment 4 (pages 25-32)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 3,
          "title": "Segment 3 (pages 17-24)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 33,
          "title": "Segment 33 (pages 662-682)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 25,
          "title": "Segment 25 (pages 231-249)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.6,
          "method": "api"
        }
      ]
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 60-68)",
      "start_page": 60,
      "end_page": 68,
      "detection_method": "topic_boundary",
      "content": "42    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n292.     main() \nCredits and Imports \n  1. # Memory Puzzle \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Released under a \"Simplified BSD\" license \n  5.  \n  6. import random, pygame, sys \n  7. from pygame.locals import * \nAt the top of the program are comments about what the game is, who made it, and where the user \ncould find more information. There’s also a note that the source code is freely copyable under a \n―Simplified BSD‖ license. The Simplified BSD license is more appropriate for software than the \nCreative Common license (which this book is released under), but they basically mean the same \nthing: People are free to copy and share this game. More info about licenses can be found at \nhttp://invpy.com/licenses. \nThis program makes use of many functions in other modules, so it imports those modules on line \n6. Line 7 is also an import statement in the from (module name) import * format, \nwhich means you do not have to type the module name in front of it. There are no functions in the \npygame.locals module, but there are several constant variables in it that we want to use such \nas MOUSEMOTION, KEYUP, or QUIT. Using this style of import statement, we only have to \ntype MOUSEMOTION rather than pygame.locals.MOUSEMOTION. \nMagic Numbers are Bad \n  9. FPS = 30 # frames per second, the general speed of the program \n 10. WINDOWWIDTH = 640 # size of window's width in pixels \n 11. WINDOWHEIGHT = 480 # size of windows' height in pixels \n 12. REVEALSPEED = 8 # speed boxes' sliding reveals and covers \n 13. BOXSIZE = 40 # size of box height & width in pixels \n 14. GAPSIZE = 10 # size of gap between boxes in pixels \nThe game programs in this book use a lot of constant variables. You might not realize why \nthey’re so handy. For example, instead of using the BOXSIZE variable in our code we could just \ntype the integer 40 directly in the code. But there are two reasons to use constant variables. \nFirst, if we ever wanted to change the size of each box later, we would have to go through the \nentire program and find and replace each time we typed 40. By just using the BOXSIZE \nconstant, we only have to change line 13 and the rest of the program is already up to date. This is \n\n\nChapter 3 – Memory Puzzle    43 \n \nmuch better, especially since we might use the integer value 40 for something else besides the \nsize of the white boxes, and changing that 40 accidentally would cause bugs in our program. \nSecond, it makes the code more readable. Go down to the next section and look at line 18. This \nsets up a calculation for the XMARGIN constant, which is how many pixels are on the side of the \nentire board. It is a complicated looking expression, but you can carefully piece out what it \nmeans. Line 18 looks like this: \nXMARGIN = int((WINDOWWIDTH - (BOARDWIDTH * (BOXSIZE + GAPSIZE))) / 2) \nBut if line 18 didn’t use constant variables, it would look like this: \nXMARGIN = int((640 – (10 * (40 + 10))) / 2) \nNow it becomes impossible to remember what exactly the programmer intended to mean. These \nunexplained numbers in the source code are often called magic numbers. Whenever you find \nyourself entering magic numbers, you should consider replacing them with a constant variable \ninstead. To the Python interpreter, both of the previous lines are the exact same. But to a human \nprogrammer who is reading the source code and trying to understand how it works, the second \nversion of line 18 doesn’t make much sense at all! Constants really help the readability of source \ncode. \nOf course, you can go too far replacing numbers with constant variables. Look at the following \ncode: \nZERO = 0 \nONE = 1 \nTWO = 99999999 \nTWOANDTHREEQUARTERS = 2.75 \nDon’t write code like that. That’s just silly. \nSanity Checks with assert Statements \n 15. BOARDWIDTH = 10 # number of columns of icons \n 16. BOARDHEIGHT = 7 # number of rows of icons \n 17. assert (BOARDWIDTH * BOARDHEIGHT) % 2 == 0, 'Board needs to have an even \nnumber of boxes for pairs of matches.' \n 18. XMARGIN = int((WINDOWWIDTH - (BOARDWIDTH * (BOXSIZE + GAPSIZE))) / 2) \n 19. YMARGIN = int((WINDOWHEIGHT - (BOARDHEIGHT * (BOXSIZE + GAPSIZE))) / 2) \n\n\n44    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe assert statement on line 15 ensures that the board width and height we’ve selected will \nresult in an even number of boxes (since we will have pairs of icons in this game). There are three \nparts to an assert statement: the assert keyword, an expression which, if False, results in \ncrashing the program. The third part (after the comma after the expression) is a string that appears \nif the program crashes because of the assertion. \nThe assert statement with an expression basically says, ―The programmer asserts that this \nexpression must be True, otherwise crash the program.‖ This is a good way of adding a sanity \ncheck to your program to make sure that if the execution ever passes an assertion we can at least \nknow that that code is working as expected. \nTelling If a Number is Even or Odd \nIf the product of the board width and height is divided by two and has a remainder of 0 (the % \nmodulus operator evaluates what the remainder is) then the number is even. Even numbers \ndivided by two will always have a remainder of zero. Odd numbers divided by two will always \nhave a remainder of one. This is a good trick to remember if you need your code to tell if a \nnumber is even or odd: \n>>> isEven = someNumber % 2 == 0 \n>>> isOdd = someNumber % 2 != 0 \nIn the above case, if the integer in someNumber was even, then isEven will be True. If it was \nodd, then isOdd will be True. \nCrash Early and Crash Often! \nHaving your program crash is a bad thing. It happens when your program has some mistake in the \ncode and cannot continue. But there are some cases where crashing a program early can avoid \nworse bugs later. \nIf the values we chose for BOARDWIDTH and BOARDHEIGHT that we chose on line 15 and 16 \nresult in a board with an odd number of boxes (such as if the width were 3 and the height were 5), \nthen there would always be one left over icon that would not have a pair to be matched with. This \nwould cause a bug later on in the program, and it could take a lot of debugging work to figure out \nthat the real source of the bug is at the very beginning of the program. In fact, just for fun, try \ncommenting out the assertion so it doesn’t run, and then setting the BOARDWIDTH and \nBOARDHEIGHT constants both to odd numbers. When you run the program, it will immediately \nshow an error happening on a line 149 in memorypuzzle.py, which is in \ngetRandomizedBoard() function! \nTraceback (most recent call last): \n\n\nChapter 3 – Memory Puzzle    45 \n \n  File \"C:\\book2svn\\src\\memorypuzzle.py\", line 292, in <module> \n    main() \n  File \"C:\\book2svn\\src\\memorypuzzle.py\", line 58, in main \n    mainBoard = getRandomizedBoard() \n  File \"C:\\book2svn\\src\\memorypuzzle.py\", line 149, in getRandomizedBoard \n    columns.append(icons[0]) \nIndexError: list index out of range \nWe could spend a lot of time looking at getRandomizedBoard() trying to figure out what’s \nwrong with it before realizing that getRandomizedBoard() is perfectly fine: the real source \nof the bug was on line 15 and 16 where we set the BOARDWIDTH and BOARDHEIGHT constants. \nThe assertion makes sure that this never happens. If our code is going to crash, we want it to \ncrash as soon as it detects something is terribly wrong, because otherwise the bug may not \nbecome apparent until much later in the program. Crash early! \nYou want to add assert statements whenever there is some condition in your program that \nmust always, always, always be True. Crash often! You don’t have to go overboard and put \nassert statements everywhere, but crashing often with asserts goes a long way in detecting the \ntrue source of a bug. Crash early and crash often!  \n(In your code that is. Not, say, when riding a pony.) \nMaking the Source Code Look Pretty \n 21. #            R    G    B \n 22. GRAY     = (100, 100, 100) \n 23. NAVYBLUE = ( 60,  60, 100) \n 24. WHITE    = (255, 255, 255) \n 25. RED      = (255,   0,   0) \n 26. GREEN    = (  0, 255,   0) \n 27. BLUE     = (  0,   0, 255) \n 28. YELLOW   = (255, 255,   0) \n 29. ORANGE   = (255, 128,   0) \n 30. PURPLE   = (255,   0, 255) \n 31. CYAN     = (  0, 255, 255) \n 32.  \n 33. BGCOLOR = NAVYBLUE \n 34. LIGHTBGCOLOR = GRAY \n 35. BOXCOLOR = WHITE \n 36. HIGHLIGHTCOLOR = BLUE \nRemember that colors in Pygame are represented by a tuple of three integers from 0 to 255. \nThese three integers represent the amount of red, green, and blue in the color which is why these \n\n\n46    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \ntuples are called RGB values. Notice the spacing of the tuples on lines 22 to 31 are such that the \nR, G, and B integers line up. In Python the indentation (that is, the space at the beginning of the \nline) is needs to be exact, but the spacing in the rest of the line is not so strict. By spacing the \nintegers in the tuple out, we can clearly see how the RGB values compare to each other. (More \ninfo on spacing and indentation is as http://invpy.com/whitespace.) \nIt is a nice thing to make your code more readable this way, but don’t bother spending too much \ntime doing it. Code doesn’t have to be pretty to work. At a certain point, you’ll just be spending \nmore time typing spaces than you would have saved by having readable tuple values. \nUsing Constant Variables Instead of Strings \n 38. DONUT = 'donut' \n 39. SQUARE = 'square' \n 40. DIAMOND = 'diamond' \n 41. LINES = 'lines' \n 42. OVAL = 'oval' \nThe program also sets up constant variables for some strings. These constants will be used in the \ndata structure for the board, tracking which spaces on the board have which icons. Using a \nconstant variable instead of the string value is a good idea. Look at the following code, which \ncomes from line 187: \n    if shape == DONUT: \nThe shape variable will be set to one of the strings 'donut', 'square', 'diamond', \n'lines', or 'oval' and then compared to the DONUT constant. If we made a typo when \nwriting line 187, for example, something like this: \n    if shape == DUNOT: \nThen Python would crash, giving an error message saying that there is no variable named DUNOT. \nThis is good. Since the program has crashed on line 187, when we check that line it will be easy \nto see that the bug was caused by a typo. However, if we were using strings instead of constant \nvariables and made the same typo, line 187 would look like this: \n    if shape == 'dunot': \nThis is perfectly acceptable Python code, so it won’t crash at first when you run it. However, this \nwill lead to weird bugs later on in our program. Because the code does not immediately crash \nwhere the problem is caused, it can be much harder to find it. \n\n\nChapter 3 – Memory Puzzle    47 \n \nMaking Sure We Have Enough Icons \n 44. ALLCOLORS = (RED, GREEN, BLUE, YELLOW, ORANGE, PURPLE, CYAN) \n 45. ALLSHAPES = (DONUT, SQUARE, DIAMOND, LINES, OVAL) \n 46. assert len(ALLCOLORS) * len(ALLSHAPES) * 2 >= BOARDWIDTH * BOARDHEIGHT, \n\"Board is too big for the number of shapes/colors defined.\" \nIn order for our game program to be able to create icons of every possible color and shape \ncombination, we need to make a tuple that holds all of these values. There is also another \nassertion on line 46 to make sure that there are enough color/shape combinations for the size of \nthe board we have. If there isn’t, then the program will crash on line 46 and we will know that we \neither have to add more colors and shapes, or make the board width and height smaller. With 7 \ncolors and 5 shapes, we can make 35 (that is, 7 x 5) different icons. And because we’ll have a pair \nof each icon, that means we can have a board with up to 70 (that is, 35 x 2, or 7 x 5 x 2) spaces. \nTuples vs. Lists, Immutable vs. Mutable \nYou might have noticed that the ALLCOLORS and ALLSHAPES variables are tuples instead of \nlists. When do we want to use tuples and when do we want to use lists? And what’s the difference \nbetween them anyway? \nTuples and lists are the same in every way except two: tuples use parentheses instead of square \nbrackets, and the items in tuples cannot be modified (but the items in lists can be modified). We \noften call lists mutable (meaning they can be changed) and tuples immutable (meaning they \ncannot be changed). \nFor an example of trying to change values in lists and tuples, look at the following code: \n>>> listVal = [1, 1, 2, 3, 5, 8] \n>>> tupleVal = (1, 1, 2, 3, 5, 8) \n>>> listVal[4] = 'hello!' \n>>> listVal \n[1, 1, 2, 3, 'hello!', 8] \n>>> tupleVal[4] = 'hello!' \nTraceback (most recent call last): \n  File \"<stdin>\", line 1, in <module> \nTypeError: 'tuple' object does not support item assignment \n>>> tupleVal \n(1, 1, 2, 3, 5, 8) \n>>> tupleVal[4] \n5 \nNotice that when we try to change the item at index 2 in the tuple, Python gives us an error \nmessage saying that tuple objects do not support ―item assignment‖. \n\n\n48    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThere is a silly benefit and an important benefit to tuple’s immutability. The silly benefit is that \ncode that uses tuples is slightly faster than code that uses lists. (Python is able to make some \noptimizations knowing that the values in a tuple will never change.) But having your code run a \nfew nanoseconds faster is not important. \nThe important benefit to using tuples is similar to the benefit of using constant variables: it’s a \nsign that the value in the tuple will never change, so anyone reading the code later will be able to \nsay, ―I can expect that this tuple will always be the same. Otherwise the programmer would have \nused a list.‖ This also lets a future programmer reading your code say, ―If I see a list value, I \nknow that it could be modified at some point in this program. Otherwise, the programmer who \nwrote this code would have used a tuple.‖ \nYou can still assign a new tuple value to a variable: \n>>> tupleVal = (1, 2, 3) \n>>> tupleVal = (1, 2, 3, 4) \nThe reason this code works is because the code isn’t changing the (1, 2, 3) tuple on the \nsecond line. It is assigning an entirely new tuple (1, 2, 3, 4) to the tupleVal, and \noverwriting the old tuple value. You cannot however, use the square brackets to modify an item \nin the tuple. \nStrings are also an immutable data type. You can use the square brackets to read a single \ncharacter in a string, but you cannot change a single character in a string: \n>>> strVal = 'Hello' \n>>> strVal[1] \n'e' \n>>> strVal[1] = 'X' \nTraceback (most recent call last): \n  File \"<stdin>\", line 1, in <module> \nTypeError: 'str' object does not support item assignment \nOne Item Tuples Need a Trailing Comma \nAlso, one minor details about tuples: if you ever need to write code about a tuple that has one \nvalue in it, then it needs to have a trailing comma in it, such as this: \noneValueTuple = (42, ) \n\n\nChapter 3 – Memory Puzzle    49 \n \nIf you forget this comma (and it is very easy to forget), then Python won’t be able to tell the \ndifference between this and a set of parentheses that just change the order of operations. For \nexample, look at the following two lines of code: \nvariableA = (5 * 6) \nvariableB = (5 * 6, ) \nThe value that is stored in variableA is just the integer 30. However, the expression for \nvariableB’s assignment statement is the single-item tuple value (30, ). Blank tuple values \ndo not need a comma in them, they can just be a set of parentheses by themselves: (). \nConverting Between Lists and Tuples \nYou can convert between list and tuple values just like you can convert between string and \ninteger values. Just pass a tuple value to the list() function and it will return a list form of that \ntuple value. Or, pass a list value to the tuple() function and it will return a tuple form of that \nlist value. Try typing the following into the interactive shell: \n>>> spam = (1, 2, 3, 4) \n>>> spam = list(spam) \n>>> spam \n[1, 2, 3, 4] \n>>> spam = tuple(spam) \n>>> spam \n(1, 2, 3, 4) \n>>> \nThe global statement, and Why Global Variables are Evil \n 48. def main(): \n 49.     global FPSCLOCK, DISPLAYSURF \n 50.     pygame.init() \n 51.     FPSCLOCK = pygame.time.Clock() \n 52.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 53.  \n 54.     mousex = 0 # used to store x coordinate of mouse event \n 55.     mousey = 0 # used to store y coordinate of mouse event \n 56.     pygame.display.set_caption('Memory Game') \nThis is the start of the main() function, which is where (oddly enough) the main part of the \ngame code is. The functions called in the main() function will be explained later in this chapter. \nLine 49 is a global statement. The global statement is the global keyword followed by a \ncomma-delimited list of variable names. These variable names are then marked as global \n\n\n50    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nvariables. Inside the main() function, those names are not for local variables that might just \nhappen to have the same name as global variables. They are the global variables. Any values \nassigned to them in the main() function will persist outside the main() function. We are \nmarking the FPSCLOCK and DISPLAYSURF variables as global because they are used in several \nother functions in the program. (More info is at http://invpy.com/scope.) \nThere are four simple rules to determine if a variable is local or global: \n1. If there is a global statement for a variable at the beginning of the function, then the \nvariable is global. \n2. If the name of a variable in a function has the same name as a global variable and the \nfunction never assigns the variable a value, then that variable is the global variable. \n3. If the name of a variable in a function has the same name as a global variable and the \nfunction does assign the variable a value, then that variable is a local variable. \n4. If there isn't a global variable with the same name as the variable in the function, then \nthat variable is obviously a local variable. \nYou generally want to avoid using global variables inside functions. A function is supposed to be \nlike a mini-program inside your program with specific inputs (the parameters) and an output (the \nreturn value). But a function that reads and writes to global variables has additional inputs and \noutput. Since the global variable could have been modified in many places before the function \nwas called, it can be tricky to track down a bug involving a bad value set in the global variable. \nHaving a function as a separate mini-program that doesn’t use global variables makes it easier to \nfind bugs in your code, since the parameters of the function are clearly known. It also makes \nchanging the code in a function easier, since if the new function works with the same parameters \nand gives the same return value, it will automatically work with the rest of the program just like \nthe old function. \nBasically, using global variables might make it easier to write your program but they generally \nmake it harder to debug. \nIn the games in this book, global variables are mostly used for variables that would be global \nconstants that never change, but need the pygame.init() function called first. Since this \nhappens in the main() function, they are set in the main() function and must be global for \nother functions to see them. But the global variables are used as constants and don’t change, so \nthey are less likely to cause confusing bugs. \nIf you don’t understand this, don’t worry. Just write your code so that you pass in values to \nfunctions rather than have the functions read global variables as a general rule. \n",
      "page_number": 60,
      "chapter_number": 8,
      "summary": "This chapter covers segment 8 (pages 60-68). Key topics include code, value, and line. Covers function. # By Al Sweigart al@inventwithpython.com \n  3.",
      "keywords": [
        "code",
        "variable",
        "Global Variables",
        "variables",
        "constant variables",
        "tuple",
        "line",
        "global",
        "program",
        "function",
        "constant",
        "Memory Puzzle",
        "n’t",
        "crash",
        "Simplified BSD"
      ],
      "concepts": [
        "code",
        "value",
        "line",
        "functions",
        "function",
        "variable",
        "list",
        "look",
        "assert",
        "assertion"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 8,
          "title": "Segment 8 (pages 142-159)",
          "relevance_score": 0.73,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 16,
          "title": "Segment 16 (pages 308-330)",
          "relevance_score": 0.72,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 5,
          "title": "Segment 5 (pages 35-42)",
          "relevance_score": 0.72,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 54,
          "title": "Segment 54 (pages 1084-1102)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.7,
          "method": "api"
        }
      ]
    },
    {
      "number": 9,
      "title": "Segment 9 (pages 69-77)",
      "start_page": 69,
      "end_page": 77,
      "detection_method": "topic_boundary",
      "content": "Chapter 3 – Memory Puzzle    51 \n \nData Structures and 2D Lists \n 58.     mainBoard = getRandomizedBoard() \n 59.     revealedBoxes = generateRevealedBoxesData(False) \nThe getRandomizedBoard() function returns a data structure that represents the state of the \nboard. The generateRevealedBoxesData() function returns a data structure that \nrepresents which boxes are covered, respectively. The return values of these functions are two \ndimensional (2D) lists, or lists of lists. A list of lists of lists of values would be a 3D list. Another \nword for two or more dimensional lists is a multidimensional list. \nIf we have a list value stored in a variable named spam, we could access a value in that list with \nthe square brackets, such as spam[2] to retrieve the third value in the list. If the value at \nspam[2] is itself a list, then we could use another set of square brackets to retrieve a value in \nthat list. This would look like, for example, spam[2][4], which would retrieve the fifth value \nin the list that is the third value in spam. Using the this notation of lists of lists makes it easy to \nmap a 2D board to a 2D list value. Since the mainBoard variable will store icons in it, if we \nwanted to get the icon on the board at the position (4, 5) then we could just use the expression \nmainBoard[4][5]. Since the icons themselves are stored as two-item tuples with the shape \nand color, the complete data structure is a list of list of two-item tuples. Whew! \nHere’s an small example. Say the board looked like this: \n \nThe corresponding data structure would be: \nmainBoard = [[(DONUT, BLUE), (LINES, BLUE), (SQUARE, ORANGE)], [(SQUARE, \nGREEN), (DONUT, BLUE), (DIAMOND, YELLOW)], [(SQUARE, GREEN), (OVAL, YELLOW), \n(SQUARE, ORANGE)], [(DIAMOND, YELLOW), (LINES, BLUE), (OVAL, YELLOW)]] \n(If your book is in black and white, you can see a color version of the above picture at \nhttp://invpy.com/memoryboard.) You’ll notice that mainBoard[x][y] will correspond to the \nicon at the (x, y) coordinate on the board. \n\n\n52    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nMeanwhile, the ―revealed boxes‖ data structure is also a 2D list, except instead of two-item tuples \nlike the board data structure, it has Boolean values: True if the box at that x, y coordinate is \nrevealed, and False if it is covered up. Passing False to the \ngenerateRevealedBoxesData() function sets all of the Boolean values to False. (This \nfunction is explained in detail later.) \nThese two data structures are used to keep track of the state of the game board. \nThe “Start Game” Animation \n 61.     firstSelection = None # stores the (x, y) of the first box clicked. \n 62.  \n 63.     DISPLAYSURF.fill(BGCOLOR) \n 64.     startGameAnimation(mainBoard) \nLine 61 sets up a variable called firstSelection with the value None. (None is the value \nthat represents a lack of a value. It is the only value of the data type, NoneType. More info at \nhttp://invpy.com/None) When the player clicks on an icon on the board, the program needs to \ntrack if this was the first icon of the pair that was clicked on or the second icon. If \nfirstSelection is None, the click was on the first icon and we store the XY coordinates in \nthe firstSelection variable as a tuple of two integers (one for the X value, the other for Y). \nOn the second click the value will be this tuple and not None, which is how the program tracks \nthat it is the second icon click. Line 63 fills the entire surface with the background color. This will \nalso paint over anything that used to be on the surface, which gives us a clean slate to start \ndrawing graphics on. \nIf you’ve played the Memory Puzzle game, you’ll notice that at the beginning of the game, all of \nthe boxes are quickly covered and uncovered randomly to give the player a sneak peek at which \nicons are under which boxes. This all happens in the startGameAnimation() function, \nwhich is explained later in this chapter. \nIt’s important to give the player this sneak peek (but not long enough of a peek to let the player \neasily memorize the icon locations), because otherwise they would have no clue where any icons \nare. Blindly clicking on the icons isn’t as much fun as having a little hint to go on. \nThe Game Loop \n 66.     while True: # main game loop \n 67.         mouseClicked = False \n 68.  \n 69.         DISPLAYSURF.fill(BGCOLOR) # drawing the window \n 70.         drawBoard(mainBoard, revealedBoxes) \n\n\nChapter 3 – Memory Puzzle    53 \n \nThe game loop is an infinite loop that starts on line 66 that keeps iterating for as long as the game \nis in progress. Remember that the game loop handles events, updates the game state, and draws \nthe game state to the screen. \nThe game state for the Memory Puzzle program is stored in the following variables: \n \nmainBoard \n \nrevealedBoxes \n \nfirstSelection \n \nmouseClicked \n \nmousex \n \nmousey \nOn each iteration of the game loop in the Memory Puzzle program, the mouseClicked variable \nstores a Boolean value that is True if the player has clicked the mouse during this iteration \nthrough the game loop. (This is part of keeping track of the game state.) \nOn line 69, the surface is painted over with the background color to erase anything that was \npreviously drawn on it. The program then calls drawBoard() to draw the current state of the \nboard based on the board and ―revealed boxes‖ data structures that we pass it. (These lines of \ncode are part of drawing and updating the screen.) \nRemember that our drawing functions only draw on the in-memory display Surface object. This \nSurface object will not actually appear on the screen until we call \npygame.display.update(), which is done at the end of the game loop on line 121. \nThe Event Handling Loop                                                                                                                \n 72.         for event in pygame.event.get(): # event handling loop \n 73.             if event.type == QUIT or (event.type == KEYUP and event.key == \nK_ESCAPE): \n 74.                 pygame.quit() \n 75.                 sys.exit() \n 76.             elif event.type == MOUSEMOTION: \n 77.                 mousex, mousey = event.pos \n 78.             elif event.type == MOUSEBUTTONUP: \n 79.                 mousex, mousey = event.pos \n 80.                 mouseClicked = True \nThe for loop on line 72 executes code for every event that has happened since the last iteration \nof the game loop. This loop is called the event handling loop (which is different from the game \nloop, although the event handling loop is inside of the game loop) and iterates over the list of \npygame.Event objects returned by the pygame.event.get() call. \n\n\n54    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nIf the event object was a either a QUIT event or a KEYUP event for the Esc key, then the program \nshould terminate. Otherwise, in the event of a MOUSEMOTION event (that is, the mouse cursor \nhas moved) or MOUSEBUTTONUP event (that is, a mouse button was pressed earlier and now the \nbutton was let up), the position of the mouse cursor should be stored in the mousex and mousey \nvariables. If this was a MOUSEBUTTONUP event, mouseClicked should also be set to True. \nOnce we have handled all of the events, the values stored in mousex, mousey, and \nmouseClicked will tell us any input that player has given us. Now we should update the game \nstate and draw the results to the screen. \nChecking Which Box The Mouse Cursor is Over \n 82.         boxx, boxy = getBoxAtPixel(mousex, mousey) \n 83.         if boxx != None and boxy != None: \n 84.             # The mouse is currently over a box. \n 85.             if not revealedBoxes[boxx][boxy]: \n 86.                drawHighlightBox(boxx, boxy) \nThe getBoxAtPixel() function will return a tuple of two integers. The integers represent the \nXY board coordinates of the box that the mouse coordinates are over. How getBoxAtPixel() \ndoes this is explained later. All we have to know for now is that if the mousex and mousey \ncoordinates were over a box, a tuple of the XY board coordinates are returned by the function and \nstored in boxx and boxy. If the mouse cursor was not over any box (for example, if it was off to \nthe side of the board or in a gap in between boxes) then the tuple (None, None) is returned by \nthe function and boxx and boxy will both have None stored in them. \nWe are only interested in the case where boxx and boxy do not have None in them, so the next \nseveral lines of code are in the block following the if statement on line 83 that checks for this \ncase. If execution has come inside this block, we know the user has the mouse cursor over a box \n(and maybe has also clicked the mouse, depending on the value stored in mouseClicked). \nThe if statement on line 85 checks if the box is covered up or not by reading the value stored in \nrevealedBoxes[boxx][boxy]. If it is False, then we know the box is covered. \nWhenever the mouse is over a covered up box, we want to draw a blue highlight around the box \nto inform the player that they can click on it. This highlighting is not done for boxes that are \nalready uncovered. The highlight drawing is handled by our drawHighlightBox() function, \nwhich is explained later. \n 87.             if not revealedBoxes[boxx][boxy] and mouseClicked: \n 88.                 revealBoxesAnimation(mainBoard, [(boxx, boxy)]) \n\n\nChapter 3 – Memory Puzzle    55 \n \n 89.                 revealedBoxes[boxx][boxy] = True # set the box as \n\"revealed\" \nOn line 87, we check if the mouse cursor is not only over a covered up box but if the mouse has \nalso been clicked. In that case, we want to play the ―reveal‖ animation for that box by calling our \nrevealBoxesAnimation() function (which is, as with all the other functions main() calls, \nexplained later in this chapter). You should note that calling this function only draws the \nanimation of the box being uncovered. It isn’t until line 89 when we set \nrevealedBoxes[boxx][boxy] = True that the data structure that tracks the game state \nis updated. \nIf you comment out line 89 and then run the program, you’ll notice that after clicking on a box \nthe reveal animation is played, but then the box immediately appears covered up again. This is \nbecause revealedBoxes[boxx][boxy] is still set to False, so on the next iteration of the \ngame loop, the board is drawn with this box covered up. Not having line 89 would cause quite an \nodd bug in our program. \nHandling the First Clicked Box \n 90.                 if firstSelection == None: # the current box was the first \nbox clicked \n 91.                     firstSelection = (boxx, boxy) \n 92.                 else: # the current box was the second box clicked \n 93.                     # Check if there is a match between the two icons. \n 94.                     icon1shape, icon1color = getShapeAndColor(mainBoard, \nfirstSelection[0], firstSelection[1]) \n 95.                     icon2shape, icon2color = getShapeAndColor(mainBoard, \nboxx, boxy) \nBefore the execution entered the game loop, the firstSelection variable was set to None. \nOur program will interpret this to mean that no boxes have been clicked, so if line 90’s condition \nis True, that means this is the first of the two possibly matching boxes that was clicked. We \nwant to play the reveal animation for the box and then keep that box uncovered. We also set the \nfirstSelection variable to a tuple of the box coordinates for the box that was clicked. \nIf this is the second box the player has clicked on, we want to play the reveal animation for that \nbox but then check if the two icons under the boxes are matching. The getShapeAndColor() \nfunction (explained later) will retrieve the shape and color values of the icons. (These values will \nbe one of the values in the ALLCOLORS and ALLSHAPES tuples.) \n\n\n56    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nHandling a Mismatched Pair of Icons \n 97.                     if icon1shape != icon2shape or icon1color != \nicon2color: \n 98.                         # Icons don't match. Re-cover up both selections. \n 99.                         pygame.time.wait(1000) # 1000 milliseconds = 1 sec \n100.                         coverBoxesAnimation(mainBoard, \n[(firstSelection[0], firstSelection[1]), (boxx, boxy)]) \n101.                         revealedBoxes[firstSelection[0]][firstSelection \n[1]] = False \n102.                         revealedBoxes[boxx][boxy] = False \nThe if statement on line 97 checks if either the shapes or colors of the two icons don’t match. If \nthis is the case, then we want to pause the game for 1000 milliseconds (which is the same as 1 \nsecond) by calling pygame.time.wait(1000) so that the player has a chance to see that the \ntwo icons don’t match. Then the ―cover up‖ animation plays for both boxes. We also want to \nupdate the game state to mark these boxes as not revealed (that is, covered up). \nHandling If the Player Won \n103.                     elif hasWon(revealedBoxes): # check if all pairs found \n104.                         gameWonAnimation(mainBoard) \n105.                         pygame.time.wait(2000) \n106.  \n107.                         # Reset the board \n108.                         mainBoard = getRandomizedBoard() \n109.                         revealedBoxes = generateRevealedBoxesData(False) \n110.  \n111.                         # Show the fully unrevealed board for a second. \n112.                         drawBoard(mainBoard, revealedBoxes) \n113.                         pygame.display.update() \n114.                         pygame.time.wait(1000) \n115.  \n116.                         # Replay the start game animation. \n117.                         startGameAnimation(mainBoard) \n \n118.                     firstSelection = None # reset firstSelection variable \nOtherwise, if line 97’s condition was False, then the two icons must be a match. The program \ndoesn’t really have to do anything else to the boxes at that point: it can just leave both boxes in \nthe revealed state. However, the program should check if this was the last pair of icons on the \nboard to be matched. This is done inside our hasWon() function, which returns True if the \nboard is in a winning state (that is, all of the boxes are revealed).  \n\n\nChapter 3 – Memory Puzzle    57 \n \nIf that is the case, we want to play the ―game won‖ animation by calling \ngameWonAnimation(), then pause slightly to let the player revel in their victory, and then \nreset the data structures in mainBoard and revealedBoxes to start a new game. \nLine 117 plays the ―start game‖ animation again. After that, the program execution will just loop \nthrough the game loop as usual, and the player can continue playing until they quit the program. \nNo matter if the two boxes were matching or not, after the second box was clicked line 118 will \nset the firstSelection variable back to None so that the next box the player clicks on will \nbe interpreted as the first clicked box of a pair of possibly matching icons. \nDrawing the Game State to the Screen \n120.         # Redraw the screen and wait a clock tick. \n121.         pygame.display.update() \n122.         FPSCLOCK.tick(FPS) \nAt this point, the game state has been updated depending on the player’s input, and the latest \ngame state has been drawn to the DISPLAYSURF display Surface object. We’ve reached the end \nof the game loop, so we call pygame.display.update() to draw the DISPLAYSURF \nSurface object to the computer screen. \nLine 9 set the FPS constant to the integer value 30, meaning we want the game to run (at most) at \n30 frames per second. If we want the program to run faster, we can increase this number. If we \nwant the program to run slower, we can decrease this number. It can even be set to a float value \nlike 0.5, which will run the program at half a frame per second, that is, one frame per two \nseconds. \nIn order to run at 30 frames per second, each frame must be drawn in 1/30th of a second. This \nmeans that pygame.display.update() and all the code in the game loop must execute in \nunder 33.3 milliseconds. Any modern computer can do this easily with plenty of time left over. \nTo prevent the program from running too fast, we call the tick() method of the \npygame.Clock object in FPSCLOCK to have to it pause the program for the rest of the 33.3 \nmilliseconds. \nSince this is done at the very end of the game loop, it ensures that each iteration of the game loop \ntakes (at least) 33.3 milliseconds. If for some reason the pygame.display.update() call \nand the code in the game loop takes longer than 33.3 milliseconds, then the tick() method will \nnot wait at all and immediately return. \n\n\n58    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nI’ve kept saying that the other functions would be explained later in the chapter. Now that we’ve \ngone over the main() function and you have an idea for how the general program works, let’s \ngo into the details of all the other functions that are called from main(). \nCreating the “Revealed Boxes” Data Structure \n125. def generateRevealedBoxesData(val): \n126.     revealedBoxes = [] \n127.     for i in range(BOARDWIDTH): \n128.         revealedBoxes.append([val] * BOARDHEIGHT) \n129.     return revealedBoxes \nThe generateRevealedBoxesData() function needs to create a list of lists of Boolean \nvalues. The Boolean value will just be the one that is passed to the function as the val parameter. \nWe start the data structure as an empty list in the revealedBoxes variable. \nIn order to make the data structure have the revealedBoxes[x][y] structure, we need to \nmake sure that the inner lists represent the vertical columns of the board and not the horizontal \nrows. Otherwise, the data structure will have a revealedBoxes[y][x] structure. \nThe for loop will create the columns and then append them to revealedBoxes. The columns \nare created using list replication, so that the column list has as many val values as the \nBOARDHEIGHT dictates. \nCreating the Board Data Structure: Step 1 – Get All Possible Icons \n132. def getRandomizedBoard(): \n133.     # Get a list of every possible shape in every possible color. \n134.     icons = [] \n135.     for color in ALLCOLORS: \n136.         for shape in ALLSHAPES: \n137.             icons.append( (shape, color) ) \nThe board data structure is just a list of lists of tuples, where each tuple has a two values: one for \nthe icon’s shape and one for the icon’s color. But creating this data structure is a little \ncomplicated. We need to be sure to have exactly as many icons for the number of boxes on the \nboard and also be sure there are two and only two icons of each type. \nThe first step to do this is to create a list with every possible combination of shape and color. \nRecall that we have a list of each color and shape in ALLCOLORS and ALLSHAPES, so nested \nfor loops on lines 135 and 136 will go through every possible shape for every possible color. \nThese are each added to the list in the icons variable on line 137. \n\n\nChapter 3 – Memory Puzzle    59 \n \nStep 2 – Shuffling and Truncating the List of All Icons \n139.     random.shuffle(icons) # randomize the order of the icons list \n140.     numIconsUsed = int(BOARDWIDTH * BOARDHEIGHT / 2) # calculate how many \nicons are needed \n141.     icons = icons[:numIconsUsed] * 2 # make two of each \n142.     random.shuffle(icons) \nBut remember, there may be more possible combinations than spaces on the board. We need to \ncalculate the number of spaces on the board by multiplying BOARDWIDTH by BOARDHEIGHT. \nThen we divide that number by 2 because we will have pairs of icons. On a board with 70 spaces, \nwe’d only need 35 different icons, since there will be two of each icon. This number will be \nstored in numIconsUsed. \nLine 141 uses list slicing to grab the first numIconsUsed number of icons in the list. (If you’ve \nforgotten how list slicing works, check out http://invpy.com/slicing.) This list has been shuffled \non line 139, so it won’t always be the same icons each game. Then this list is replicated by using \nthe * operator so that there are two of each of the icons. This new doubled up list will overwrite \nthe old list in the icons variable. Since the first half of this new list is identical to the last half, \nwe call the shuffle() method again to randomly mix up the order of the icons. \nStep 3 – Placing the Icons on the Board \n144.     # Create the board data structure, with randomly placed icons. \n145.     board = [] \n146.     for x in range(BOARDWIDTH): \n147.         column = [] \n148.         for y in range(BOARDHEIGHT): \n149.             column.append(icons[0]) \n150.             del icons[0] # remove the icons as we assign them \n151.         board.append(column) \n152.     return board \nNow we need to create a list of lists data structure for the board. We can do this with nested for \nloops just like the generateRevealedBoxesData() function did. For each column on the \nboard, we will create a list of randomly selected icons. As we add icons to the column, on line \n149 we will then delete them from the front of the icons list on line 150. This way, as the \nicons list gets shorter and shorter, icons[0] will have a different icon to add to the columns. \nTo picture this better, type the following code into the interactive shell. Notice how the del \nstatement changes the myList list. \n>>> myList = ['cat', 'dog', 'mouse', 'lizard'] \n",
      "page_number": 69,
      "chapter_number": 9,
      "summary": "revealedBoxes = generateRevealedBoxesData(False) \nThe getRandomizedBoard() function returns a data structure that represents the state of the \nboard Key topics include icons, lists, and lines.",
      "keywords": [
        "Game Loop",
        "icons",
        "game",
        "list",
        "data structure",
        "box",
        "board",
        "Memory Puzzle",
        "Loop",
        "game state",
        "board data structure",
        "Line",
        "Data",
        "structure",
        "icons list"
      ],
      "concepts": [
        "icons",
        "lists",
        "lines",
        "value",
        "board",
        "events",
        "functions",
        "game",
        "boxes",
        "box"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.46,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 38,
          "title": "Segment 38 (pages 764-785)",
          "relevance_score": 0.46,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 50,
          "title": "Segment 50 (pages 483-490)",
          "relevance_score": 0.45,
          "method": "api"
        }
      ]
    },
    {
      "number": 10,
      "title": "Segment 10 (pages 78-86)",
      "start_page": 78,
      "end_page": 86,
      "detection_method": "topic_boundary",
      "content": "60    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n>>> del myList[0] \n>>> myList \n['dog', 'mouse', 'lizard'] \n>>> del myList[0] \n>>> myList \n['mouse', 'lizard'] \n>>> del myList[0] \n>>> myList \n['lizard'] \n>>> del myList[0] \n>>> myList \n[] \n>>> \nBecause we are deleting the item at the front of the list, the other items shift forward so that the \nnext item in the list becomes the new ―first‖ item. This is the same way line 150 works. \nSplitting a List into a List of Lists \n155. def splitIntoGroupsOf(groupSize, theList): \n156.     # splits a list into a list of lists, where the inner lists have at \n157.     # most groupSize number of items. \n158.     result = [] \n159.     for i in range(0, len(theList), groupSize): \n160.         result.append(theList[i:i + groupSize]) \n161.     return result \nThe splitIntoGroupsOf() function (which will be called by the \nstartGameAnimation() function) splits a list into a list of lists, where the inner lists have \ngroupSize number of items in them. (The last list could have less if there are less than \ngroupSize items left over.) \nThe call to range() on line 159 uses the three-parameter form of range(). (If you are \nunfamiliar with this form, take a look at http://invpy.com/range.) Let’s use an example. If the \nlength of the list is 20 and the groupSize parameter is 8, then range(0, \nlen(theList), groupSize) evaluates to range(0, 20, 8). This will give the i \nvariable the values 0, 8, and 16 for the three iterations of the for loop. \nThe list slicing on line 160 with theList[i:i + groupSize] creates the lists that are \nadded to the result list. On each iteration where i is 0, 8, and 16 (and groupSize is 8), this \nlist slicing expression would be theList[0:8], then theList[8:16] on the second \niteration, and then theList[16:24] on the third iteration. \n\n\nChapter 3 – Memory Puzzle    61 \n \nNote that even though the largest index of theList would be 19 in our example, \ntheList[16:24] won’t raise an IndexError error even though 24 is larger than 19. It will \njust create a list slice with the remaining items in the list. List slicing doesn’t destroy or change \nthe original list stored in theList. It just copies a portion of it to evaluate to a new list value. \nThis new list value is the list that is appended to the list in the result variable on line 160. So \nwhen we return result at the end of this function, we are returning a list of lists. \nDifferent Coordinate Systems \n164. def leftTopCoordsOfBox(boxx, boxy): \n165.     # Convert board coordinates to pixel coordinates \n166.     left = boxx * (BOXSIZE + GAPSIZE) + XMARGIN \n167.     top = boxy * (BOXSIZE + GAPSIZE) + YMARGIN \n168.     return (left, top) \nYou should be familiar with Cartesian Coordinate systems. (If you’d like a refresher on this topic, \nread http://invpy.com/coordinates.) In most of our games we will be using multiple Cartesian \nCoordinate systems. One system of coordinates that is used in the Memory Puzzle game is for the \npixel or screen coordinates. But we will also be using another coordinate system for the boxes. \nThis is because it will be easier to use (3, 2) to refer to the 4th box from the left and 3rd from the \ntop (remember that the numbers start with 0, not 1) instead of using the pixel coordinate of the \nbox’s top left corner, (220, 165). However, we need a way to translate between these two \ncoordinate systems. \nHere’s a picture of the game and the two different coordinate systems. Remember that the \nwindow is 640 pixels wide and 480 pixels tall, so (639, 479) is the bottom right corner (because \nthe top left corner’s pixel is (0, 0), and not (1, 1)). \n\n\n62    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nThe leftTopCoordsOfBox() function will take box coordinates and return pixel \ncoordinates. Because a box takes up multiple pixels on the screen, we will always return the \nsingle pixel at the top left corner of the box. This value will be returned as a two-integer tuple. \nThe leftTopCoordsOfBox() function will often be used when we need pixel coordinates for \ndrawing these boxes. \nConverting from Pixel Coordinates to Box Coordinates \n171. def getBoxAtPixel(x, y): \n172.     for boxx in range(BOARDWIDTH): \n173.         for boxy in range(BOARDHEIGHT): \n174.             left, top = leftTopCoordsOfBox(boxx, boxy) \n175.             boxRect = pygame.Rect(left, top, BOXSIZE, BOXSIZE) \n176.             if boxRect.collidepoint(x, y): \n177.                 return (boxx, boxy) \n178.     return (None, None) \nWe will also need a function to convert from pixel coordinates (which the mouse clicks and \nmouse movement events use) to box coordinates (so we can find out over which box the mouse \nevent happened). Rect objects have a collidepoint() method that you can pass X and Y \ncoordinates too and it will return True if the coordinates are inside (that is, collide with) the Rect \nobject’s area. \n\n\nChapter 3 – Memory Puzzle    63 \n \nIn order to find which box the mouse coordinates are over, we will go through each box’s \ncoordinates and call the collidepoint() method on a Rect object with those coordinates. \nWhen collidepoint() returns True, we know we have found the box that was clicked on or \nmoved over and will return the box coordinates. If none of them return True, then the \ngetBoxAtPixel() function will return the value (None, None). This tuple is returned \ninstead of simply returning None because the caller of getBoxAtPixel() is expecting a tuple \nof two values to be returned. \nDrawing the Icon, and Syntactic Sugar \n181. def drawIcon(shape, color, boxx, boxy): \n182.     quarter = int(BOXSIZE * 0.25) # syntactic sugar \n183.     half =    int(BOXSIZE * 0.5)  # syntactic sugar \n184.  \n185.     left, top = leftTopCoordsOfBox(boxx, boxy) # get pixel coords from \nboard coords \nThe drawIcon() function will draw an icon (with the specified shape and color) at the \nspace whose coordinates are given in the boxx and boxy parameters. Each possible shape has a \ndifferent set of Pygame drawing function calls for it, so we must have a large set of if and elif \nstatements to differentiate between them. (These statements are on lines 187 to 198.) \nThe X and Y coordinates of the left and top edge of the box can be obtained by calling the \nleftTopCoordsOfBox() function. The width and height of the box are both set in the \nBOXSIZE constant. However, many of the shape drawing function calls use the midpoint and \nquarter-point of the box as well. We can calculate this and store it in the variables quarter and \nhalf. We could just as easily have the code int(BOXSIZE * 0.25) instead of the variable \nquarter, but this way the code becomes easier to read since it is more obvious what quarter \nmeans rather than int(BOXSIZE * 0.25). \nSuch variables are an example of syntactic sugar. Syntactic sugar is when we add code that \ncould have been written in another way (probably with less actual code and variables), but does \nmake the source code easier to read. Constant variables are one form of syntactic sugar. Pre-\ncalculating a value and storing it in a variable is another type of syntactic sugar. (For example, in \nthe getRandomizedBoard() function, we could have easily made the code on lines 140 and \nline 141 into a single line of code. But it’s easier to read as two separate lines.) We don’t need to \nhave the extra quarter and half variables, but having them makes the code easier to read. \nCode that is easy to read is easy to debug and upgrade in the future. \n186.     # Draw the shapes \n187.     if shape == DONUT: \n\n\n64    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n188.         pygame.draw.circle(DISPLAYSURF, color, (left + half, top + half), \nhalf - 5) \n189.         pygame.draw.circle(DISPLAYSURF, BGCOLOR, (left + half, top + \nhalf), quarter - 5) \n190.     elif shape == SQUARE: \n191.         pygame.draw.rect(DISPLAYSURF, color, (left + quarter, top + \nquarter, BOXSIZE - half, BOXSIZE - half)) \n192.     elif shape == DIAMOND: \n193.         pygame.draw.polygon(DISPLAYSURF, color, ((left + half, top), (left \n+ BOXSIZE - 1, top + half), (left + half, top + BOXSIZE - 1), (left, top + \nhalf))) \n194.     elif shape == LINES: \n195.         for i in range(0, BOXSIZE, 4): \n196.             pygame.draw.line(DISPLAYSURF, color, (left, top + i), (left + \ni, top)) \n197.             pygame.draw.line(DISPLAYSURF, color, (left + i, top + BOXSIZE \n- 1), (left + BOXSIZE - 1, top + i)) \n198.     elif shape == OVAL: \n199.         pygame.draw.ellipse(DISPLAYSURF, color, (left, top + quarter, \nBOXSIZE, half)) \nEach of the donut, square, diamond, lines, and oval functions require different drawing primitive \nfunction calls to make.  \nSyntactic Sugar with Getting a Board Space’s Icon’s Shape and Color \n202. def getShapeAndColor(board, boxx, boxy): \n203.     # shape value for x, y spot is stored in board[x][y][0] \n204.     # color value for x, y spot is stored in board[x][y][1] \n205.     return board[boxx][boxy][0], board[boxx][boxy][1] \nThe getShapeAndColor() function only has one line. You might wonder why we would \nwant a function instead of just typing in that one line of code whenever we need it. This is done \nfor the same reason we use constant variables: it improves the readability of the code. \nIt’s easy to figure out what a code like shape, color = getShapeAndColor() does. \nBut if you looked a code like shape, color = board[boxx][boxy][0], \nboard[boxx][boxy][1], it would be a bit more difficult to figure out. \nDrawing the Box Cover \n208. def drawBoxCovers(board, boxes, coverage): \n209.     # Draws boxes being covered/revealed. \"boxes\" is a list \n210.     # of two-item lists, which have the x & y spot of the box. \n211.     for box in boxes: \n\n\nChapter 3 – Memory Puzzle    65 \n \n212.         left, top = leftTopCoordsOfBox(box[0], box[1]) \n213.         pygame.draw.rect(DISPLAYSURF, BGCOLOR, (left, top, BOXSIZE, \nBOXSIZE)) \n214.         shape, color = getShapeAndColor(board, box[0], box[1]) \n215.         drawIcon(shape, color, box[0], box[1]) \n216.         if coverage > 0: # only draw the cover if there is an coverage \n217.             pygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, coverage, \nBOXSIZE)) \n218.     pygame.display.update() \n219.     FPSCLOCK.tick(FPS) \nThe drawBoxCovers() function has three parameters: the board data structure, a list of (X, Y) \ntuples for each box that should have the cover drawn, and then the amount of coverage to draw \nfor the boxes. \nSince we want to use the same drawing code for each box in the boxes parameter, we will use a \nfor loop on line 211 so we execute the same code on each box in the boxes list. Inside this \nfor loop, the code should do three things: draw the background color (to paint over anything that \nwas there before), draw the icon, then draw however much of the white box over the icon that is \nneeded. The leftTopCoordsOfBox() function will return the pixel coordinates of the top \nleft corner of the box. The if statement on line 216 makes sure that if the number in coverage \nhappens to be less than 0, we won’t call the pygame.draw.rect() function. \nWhen the coverage parameter is 0, there is no coverage at all. When the coverage is set to \n20, there is a 20 pixel wide white box covering the icon. The largest size we’ll want the \ncoverage set to is the number in BOXSIZE, where the entire icon is completely covered. \ndrawBoxCovers() is going to be called from a separate loop than the game loop. Because of \nthis, it needs to have its own calls to pygame.display.update() and \nFPSCLOCK.tick(FPS) to display the animation. (This does mean that while inside this loop, \nthere is no code being run to handle any events being generated. That’s fine, since the cover and \nreveal animations only take a second or so to play.) \nHandling the Revealing and Covering Animation \n222. def revealBoxesAnimation(board, boxesToReveal): \n223.     # Do the \"box reveal\" animation. \n224.     for coverage in range(BOXSIZE, (-REVEALSPEED) - 1, - REVEALSPEED): \n225.         drawBoxCovers(board, boxesToReveal, coverage) \n226.  \n227.  \n228. def coverBoxesAnimation(board, boxesToCover): \n229.     # Do the \"box cover\" animation. \n\n\n66    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n230.     for coverage in range(0, BOXSIZE + REVEALSPEED, REVEALSPEED): \n231.         drawBoxCovers(board, boxesToCover, coverage) \nRemember that an animation is simply just displaying different images for brief moments of time, \nand together they make it seem like things are moving on the screen. The \nrevealBoxesAnimation() and coverBoxesAnimation() only need to draw an icon \nwith a varying amount of coverage by the white box. We can write a single function called \ndrawBoxCovers() which can do this, and then have our animation function call \ndrawBoxCovers() for each frame of animation. As we saw in the last section, \ndrawBoxCovers() makes a call to pygame.display.update() and \nFPSCLOCK.tick(FPS) itself. \nTo do this, we’ll set up a for loop to make decreasing (in the case of \nrevealBoxesAnimation()) or increasing (in the case of coverBoxesAnimation()) \nnumbers for the converage parameter. The amount that the coverage variable will \ndecrease/increase by is the number in the REVEALSPEED constant. On line 12 we set this \nconstant to 8, meaning that on each call to drawBoxCovers(), the white box will \ndecrease/increase by 8 pixels on each iteration. If we increase this number, then more pixels will \nbe drawn on each call, meaning that the white box will decrease/increase in size faster. If we set it \nto 1, then the white box will only appear to decrease or increase by 1 pixel on each iteration, \nmaking the entire reveal or cover animation take longer. \nThink of it like climbing stairs. If on each step you take, you climbed one stair, then it would take \na normal amount of time to climb the entire staircase. But if you climbed two stairs at a time on \neach step (and the steps took just as long as before), you could climb the entire staircase twice as \nfast. If you could climb the staircase 8 stairs at a time, then you would climb the entire staircase 8 \ntimes as fast. \nDrawing the Entire Board \n234. def drawBoard(board, revealed): \n235.     # Draws all of the boxes in their covered or revealed state. \n236.     for boxx in range(BOARDWIDTH): \n237.         for boxy in range(BOARDHEIGHT): \n238.             left, top = leftTopCoordsOfBox(boxx, boxy) \n239.             if not revealed[boxx][boxy]: \n240.                 # Draw a covered box. \n241.                 pygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, \nBOXSIZE, BOXSIZE)) \n242.             else: \n243.                 # Draw the (revealed) icon. \n244.                 shape, color = getShapeAndColor(board, boxx, boxy) \n\n\nChapter 3 – Memory Puzzle    67 \n \n245.                 drawIcon(shape, color, boxx, boxy) \nThe drawBoard() function makes a call to drawIcon() for each of the boxes on the board. \nThe nested for loops on lines 236 and 237 will loop through every possible X and Y coordinate \nfor the boxes, and will either draw the icon at that location or draw a white square instead (to \nrepresent a covered up box). \nDrawing the Highlight \n248. def drawHighlightBox(boxx, boxy): \n249.     left, top = leftTopCoordsOfBox(boxx, boxy) \n250.     pygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, (left - 5, top - 5, \nBOXSIZE + 10, BOXSIZE + 10), 4) \nTo help the player recognize that they can click on a covered box to reveal it, we will make a blue \noutline appear around a box to highlight it. This outline is drawn with a call to \npygame.draw.rect() to make a rectangle with a width of 4 pixels. \nThe “Start Game” Animation \n253. def startGameAnimation(board): \n254.     # Randomly reveal the boxes 8 at a time. \n255.     coveredBoxes = generateRevealedBoxesData(False) \n256.     boxes = [] \n257.     for x in range(BOARDWIDTH): \n258.         for y in range(BOARDHEIGHT): \n259.             boxes.append( (x, y) ) \n260.     random.shuffle(boxes) \n261.     boxGroups = splitIntoGroupsOf(8, boxes) \nThe animation that plays at the beginning of the game gives the player a quick hint as to where all \nthe icons are located. In order to make this animation, we have to reveal and cover up groups of \nboxes one group after another. To do this, first we’ll create a list of every possible space on the \nboard. The nested for loops on lines 257 and 258 will add (X, Y) tuples to a list in the boxes \nvariable. \nWe will reveal and cover up the first 8 boxes in this list, then the next 8, then the next 8 after that, \nand so on. However, since the order of the (X, Y) tuples in boxes would be the same each time, \nthen the same order of boxes would be displayed. (Try commenting out line 260 and then running \nto program a few times to see this effect.) \nTo change up the boxes each time a game starts, we will call the random.shuffle() function \nto randomly shuffle the order of the tuples in the boxes list. Then when we reveal and cover up \n\n\n68    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nthe first 8 boxes in this list (and each group of 8 boxes afterwards), it will be random group of 8 \nboxes. \nTo get the lists of 8 boxes, we call our splitIntoGroupsOf() function, passing 8 and the \nlist in boxes. The list of lists that the function returns will be stored in a variable named \nboxGroups. \nRevealing and Covering the Groups of Boxes \n263.     drawBoard(board, coveredBoxes) \n264.     for boxGroup in boxGroups: \n265.         revealBoxesAnimation(board, boxGroup) \n266.         coverBoxesAnimation(board, boxGroup) \nFirst, we draw the board. Since every value in coveredBoxes is set to False, this call to \ndrawBoard() will end up drawing only covered up white boxes. The \nrevealBoxesAnimation() and coverBoxesAnimation() functions will draw over the \nspaces of these white boxes. \nThe for loop will go through each of the inner lists in the boxGroups lists. We pass these to \nrevealBoxesAnimation(), which will perform the animation of the white boxes being \npulled away to reveal the icon underneath. Then the call to coverBoxesAnimation() will \nanimate the white boxes expanding to cover up the icons. Then the for loop goes to the next \niteration to animate the next set of 8 boxes. \nThe “Game Won” Animation \n269. def gameWonAnimation(board): \n270.     # flash the background color when the player has won \n271.     coveredBoxes = generateRevealedBoxesData(True) \n272.     color1 = LIGHTBGCOLOR \n273.     color2 = BGCOLOR \n274.  \n275.     for i in range(13): \n276.         color1, color2 = color2, color1 # swap colors \n277.         DISPLAYSURF.fill(color1) \n278.         drawBoard(board, coveredBoxes) \n279.         pygame.display.update() \n280.         pygame.time.wait(300) \nWhen the player has uncovered all of the boxes by matching every pair on the board, we want to \ncongratulate them by flashing the background color. The for loop will draw the color in the \ncolor1 variable for the background color and then draw the board over it. However, on each \niteration of the for loop, the values in color1 and color2 will be swapped with each other \n",
      "page_number": 78,
      "chapter_number": 10,
      "summary": "This chapter covers segment 10 (pages 78-86). Key topics include boxes, function. return result \nThe splitIntoGroupsOf() function (which will be called by the \nstartGameAnimation() function) splits a list into a list of lists, where the inner lists have \ngroupSize number of items in them.",
      "keywords": [
        "del myList",
        "BOXSIZE",
        "list",
        "box",
        "boxes",
        "left",
        "board",
        "top",
        "myList",
        "coordinates",
        "function",
        "color",
        "pixel coordinates",
        "box coordinates",
        "draw"
      ],
      "concepts": [
        "boxes",
        "box",
        "function",
        "functions",
        "drawing",
        "color",
        "left",
        "shape",
        "list",
        "returning"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 41,
          "title": "Segment 41 (pages 389-403)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 56,
          "title": "Segment 56 (pages 544-551)",
          "relevance_score": 0.5,
          "method": "api"
        }
      ]
    },
    {
      "number": 11,
      "title": "Segment 11 (pages 87-94)",
      "start_page": 87,
      "end_page": 94,
      "detection_method": "topic_boundary",
      "content": "Chapter 3 – Memory Puzzle    69 \n \non line 276. This way the program will alternate between drawing two different background \ncolors. \nRemember that this function needs to call pygame.display.update() to actually make the \nDISPLAYSURF surface appear on the screen. \nTelling if the Player Has Won \n283. def hasWon(revealedBoxes): \n284.     # Returns True if all the boxes have been revealed, otherwise False \n285.     for i in revealedBoxes: \n286.         if False in i: \n287.             return False # return False if any boxes are covered. \n288.     return True \nThe player has won the game when all of the icon pairs have been matched. Since the ―revealed‖ \ndata structure gets values in it set to True as icons have been matched, we can simply loop \nthrough every space in revealedBoxes looking for a False value. If even one False value \nis in revealedBoxes, then we know there are still unmatched icons on the board. \nNote that because revealedBoxes is a list of lists, the for loop on line 285 will set the inner \nlist as the values of i. But we can use the in operator to search for a False value in the entire \ninner list. This way we don’t need to write an additional line of code and have two nested for \nloops like this: \nfor x in revealedBoxes: \n    for y in revealedBoxes[x]: \n        if False == revealedBoxes[x][y]: \n            return False \nWhy Bother Having a main() Function? \n291. if __name__ == '__main__': \n292.     main() \nIt may seem pointless to have a main() function, since you could just put that code in the global \nscope at the bottom of the program instead, and the code would run the exact same. However, \nthere are two good reasons to put them inside of a main() function. \nFirst, this lets you have local variables whereas otherwise the local variables in the main() \nfunction would have to become global variables. Limiting the number of global variables is a \ngood way to keep the code simple and easier to debug. (See the ―Why Global Variables are Evil‖ \nsection in this chapter.) \n\n\n70    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nSecond, this also lets you import the program so that you can call and test individual functions. If \nthe memorypuzzle.py file is in the C:\\Python32 folder, then you can import it from the interactive \nshell. Type the following to test out the splitIntoGroupsOf() and getBoxAtPixel() \nfunctions to make sure they return the correct return values: \n>>> import memorypuzzle \n>>> memorypuzzle.splitIntoGroupsOf(3, [0,1,2,3,4,5,6,7,8,9]) \n[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]] \n>>> memorypuzzle.getBoxAtPixel(0, 0) \n(None, None) \n>>> memorypuzzle.getBoxAtPixel(150, 150) \n(1, 1) \nWhen a module is imported, all of the code in it is run. If we didn’t have the main() function, \nand had its code in the global scope, then the game would have automatically started as soon as \nwe imported it, which really wouldn’t let us call individual functions in it. \nThat’s why the code is in a separate function that we have named main(). Then we check the \nbuilt-in Python variable __name__ to see if we should call the main() function or not. This \nvariable is automatically set by the Python interpreter to the string '__main__' if the program \nitself is being run and 'memorypuzzle' if it is being imported. This is why the main() \nfunction is not run when we executed the import memorypuzzle statement in the interactive \nshell. \nThis is a handy technique for being able to import the program you are working on from the \ninteractive shell and make sure individual functions are returning the correct values by testing \nthem one call at a time. \nWhy Bother With Readability? \nA lot of the suggestions in this chapter haven’t been about how to write programs that computers \ncan run so much as how to write programs that programmers can read. You might not understand \nwhy this is important. After all, as long as the code works, who cares if it is hard or easy for \nhuman programmers to read? \nHowever, the important thing to realize about software is that it is rarely ever left alone. When \nyou are creating your own games, you will rarely be ―done‖ with the program. You will always \nget new ideas for game features you want add, or find new bugs with the program. Because of \nthis, it is important that your program is readable so that you can look at the code and understand \nit. And understanding the code is the first step to changing it to add more code or fix bugs. \nAs an example, here is an obfuscated version of the Memory Puzzle program that was made \nentirely unreadable. If you type it in (or download it from \n\n\nChapter 3 – Memory Puzzle    71 \n \nhttp://invpy.com/memorypuzzle_obfuscated.py) and run it you will find it runs exactly the same \nas the code at the beginning of this chapter. But if there was a bug with this code, it would be \nimpossible to read the code and understand what’s going on, much less fix the bug. \nThe computer doesn’t mind code as unreadable as this. It’s all the same to it. \nimport random, pygame, sys \nfrom pygame.locals import * \ndef hhh(): \n    global a, b \n    pygame.init() \n    a = pygame.time.Clock() \n    b = pygame.display.set_mode((640, 480)) \n    j = 0 \n    k = 0 \n    pygame.display.set_caption('Memory Game') \n    i = c() \n    hh = d(False) \n    h = None \n    b.fill((60, 60, 100)) \n    g(i) \n    while True: \n        e = False \n        b.fill((60, 60, 100)) \n        f(i, hh) \n        for eee in pygame.event.get(): \n            if eee.type == QUIT or (eee.type == KEYUP and eee.key == K_ESCAPE): \n                pygame.quit() \n                sys.exit() \n            elif eee.type == MOUSEMOTION: \n                j, k = eee.pos \n            elif eee.type == MOUSEBUTTONUP: \n                j, k = eee.pos \n                e = True \n        bb, ee = m(j, k) \n        if bb != None and ee != None: \n            if not hh[bb][ee]: \n                n(bb, ee) \n            if not hh[bb][ee] and e: \n                o(i, [(bb, ee)]) \n                hh[bb][ee] = True \n                if h == None: \n                    h = (bb, ee) \n                else: \n                    q, fff = s(i, h[0], h[1]) \n                    r, ggg = s(i, bb, ee) \n\n\n72    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n                    if q != r or fff != ggg: \n                        pygame.time.wait(1000) \n                        p(i, [(h[0], h[1]), (bb, ee)]) \n                        hh[h[0]][h[1]] = False \n                        hh[bb][ee] = False \n                    elif ii(hh): \n                        jj(i) \n                        pygame.time.wait(2000) \n                        i = c() \n                        hh = d(False) \n                        f(i, hh) \n                        pygame.display.update() \n                        pygame.time.wait(1000) \n                        g(i) \n                    h = None \n        pygame.display.update() \n        a.tick(30) \ndef d(ccc): \n    hh = [] \n    for i in range(10): \n        hh.append([ccc] * 7) \n    return hh \ndef c(): \n    rr = [] \n    for tt in ((255, 0, 0), (0, 255, 0), (0, 0, 255), (255, 255, 0), (255, 128, \n0), (255, 0, 255), (0, 255, 255)): \n        for ss in ('a', 'b', 'c', 'd', 'e'): \n            rr.append( (ss, tt) ) \n    random.shuffle(rr) \n    rr = rr[:35] * 2 \n    random.shuffle(rr) \n    bbb = [] \n    for x in range(10): \n        v = [] \n        for y in range(7): \n            v.append(rr[0]) \n            del rr[0] \n        bbb.append(v) \n    return bbb \ndef t(vv, uu): \n    ww = [] \n    for i in range(0, len(uu), vv): \n        ww.append(uu[i:i + vv]) \n    return ww \ndef aa(bb, ee): \n    return (bb * 50 + 70, ee * 50 + 65) \ndef m(x, y): \n\n\nChapter 3 – Memory Puzzle    73 \n \n    for bb in range(10): \n        for ee in range(7): \n            oo, ddd = aa(bb, ee) \n            aaa = pygame.Rect(oo, ddd, 40, 40) \n            if aaa.collidepoint(x, y): \n                return (bb, ee) \n    return (None, None) \ndef w(ss, tt, bb, ee): \n    oo, ddd = aa(bb, ee) \n    if ss == 'a': \n        pygame.draw.circle(b, tt, (oo + 20, ddd + 20), 15) \n        pygame.draw.circle(b, (60, 60, 100), (oo + 20, ddd + 20), 5) \n    elif ss == 'b': \n        pygame.draw.rect(b, tt, (oo + 10, ddd + 10, 20, 20)) \n    elif ss == 'c': \n        pygame.draw.polygon(b, tt, ((oo + 20, ddd), (oo + 40 - 1, ddd + 20), \n(oo + 20, ddd + 40 - 1), (oo, ddd + 20))) \n    elif ss == 'd': \n        for i in range(0, 40, 4): \n            pygame.draw.line(b, tt, (oo, ddd + i), (oo + i, ddd)) \n            pygame.draw.line(b, tt, (oo + i, ddd + 39), (oo + 39, ddd + i)) \n    elif ss == 'e': \n        pygame.draw.ellipse(b, tt, (oo, ddd + 10, 40, 20)) \ndef s(bbb, bb, ee): \n    return bbb[bb][ee][0], bbb[bb][ee][1] \ndef dd(bbb, boxes, gg): \n    for box in boxes: \n        oo, ddd = aa(box[0], box[1]) \n        pygame.draw.rect(b, (60, 60, 100), (oo, ddd, 40, 40)) \n        ss, tt = s(bbb, box[0], box[1]) \n        w(ss, tt, box[0], box[1]) \n        if gg > 0: \n            pygame.draw.rect(b, (255, 255, 255), (oo, ddd, gg, 40)) \n    pygame.display.update() \n    a.tick(30) \ndef o(bbb, cc): \n    for gg in range(40, (-8) - 1, -8): \n        dd(bbb, cc, gg) \ndef p(bbb, ff): \n    for gg in range(0, 48, 8): \n        dd(bbb, ff, gg) \ndef f(bbb, pp): \n    for bb in range(10): \n        for ee in range(7): \n            oo, ddd = aa(bb, ee) \n            if not pp[bb][ee]: \n                pygame.draw.rect(b, (255, 255, 255), (oo, ddd, 40, 40)) \n\n\n74    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n            else: \n                ss, tt = s(bbb, bb, ee) \n                w(ss, tt, bb, ee) \ndef n(bb, ee): \n    oo, ddd = aa(bb, ee) \n    pygame.draw.rect(b, (0, 0, 255), (oo - 5, ddd - 5, 50, 50), 4) \ndef g(bbb): \n    mm = d(False) \n    boxes = [] \n    for x in range(10): \n        for y in range(7): \n            boxes.append( (x, y) ) \n    random.shuffle(boxes) \n    kk = t(8, boxes) \n    f(bbb, mm) \n    for nn in kk: \n        o(bbb, nn) \n        p(bbb, nn) \ndef jj(bbb): \n    mm = d(True) \n    tt1 = (100, 100, 100) \n    tt2 = (60, 60, 100) \n    for i in range(13): \n        tt1, tt2 = tt2, tt1 \n        b.fill(tt1) \n        f(bbb, mm) \n        pygame.display.update() \n        pygame.time.wait(300) \ndef ii(hh): \n    for i in hh: \n        if False in i: \n            return False \n    return True \nif __name__ == '__main__': \n    hhh() \nNever write code like this. If you program like this while facing the mirror in a bathroom with the \nlights turned off, the ghost of Ada Lovelace will come out of the mirror and throw you into the \njaws of a Jacquard loom. \nSummary, and a Hacking Suggestion \nThis chapter covers the entire explanation of how the Memory Puzzle program works. Read over \nthe chapter and the source code again to understand it better. Many of the other game programs in \nthis book make use of the same programming concepts (like nested for loops, syntactic sugar, \n\n\nChapter 3 – Memory Puzzle    75 \n \nand different coordinate systems in the same program) so they won’t be explained again to keep \nthis book short. \nOne idea to try out to understand how the code works is to intentionally break it by commenting \nout random lines. Doing this to some of the lines will probably cause a syntactic error that will \nprevent the script from running at all. But commenting out other lines will result in weird bugs \nand other cool effects. Try doing this and then figure out why a program has the bugs it does. \nThis is also the first step in being able to add your own secret cheats or hacks to the program. By \nbreaking the program from what it normally does, you can learn how to change it to do something \nneat effect (like secretly giving you hints on how to solve the puzzle). Feel free to experiment. \nYou can always save a copy of the unchanged source code in a different file if you want to play \nthe regular game again. \nIn fact, if you’d like some practice fixing bugs, there are several versions of this game’s source \ncode that have small bugs in them. You can download these buggy versions from \nhttp://invpy.com/buggy/memorypuzzle. Try running the program to figure out what the bug is, \nand why the program is acting that way. \n \n\n\n76    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n \n",
      "page_number": 87,
      "chapter_number": 11,
      "summary": "This chapter covers segment 11 (pages 87-94). Key topics include returns, program, and programming. This way the program will alternate between drawing two different background \ncolors.",
      "keywords": [
        "False return True",
        "ddd",
        "return False",
        "Memory Puzzle",
        "code",
        "Memory Puzzle program",
        "program",
        "bbb",
        "range",
        "main",
        "return True",
        "Memory",
        "Puzzle",
        "function"
      ],
      "concepts": [
        "returns",
        "program",
        "programming",
        "code",
        "bugs",
        "bug",
        "boxes",
        "box",
        "make",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 1,
          "title": "Segment 1 (pages 1-20)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 4,
          "title": "Segment 4 (pages 25-32)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 12,
          "title": "Segment 12 (pages 219-238)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "AntiPatterns",
          "chapter": 9,
          "title": "Segment 9 (pages 74-81)",
          "relevance_score": 0.65,
          "method": "api"
        }
      ]
    },
    {
      "number": 12,
      "title": "Segment 12 (pages 95-102)",
      "start_page": 95,
      "end_page": 102,
      "detection_method": "topic_boundary",
      "content": "Chapter 4 – Slide Puzzle    77 \n \nCHAPTER 4 – SLIDE PUZZLE \n \nHow to Play Slide Puzzle \nThe board is a 4x4 grid with fifteen tiles (numbered 1 through 15 going left to right) and one \nblank space. The tiles start out in random positions, and the player must slide tiles around until \nthe tiles are back in their original order. \nSource Code to Slide Puzzle \nThis source code can be downloaded from http://invpy.com/slidepuzzle.py. If you get any error \nmessages, look at the line number that is mentioned in the error message and check your code for \nany typos. You can also copy and paste your code into the web form at \nhttp://invpy.com/diff/slidepuzzle to see if the differences between your code and the code in the \nbook. \n  1. # Slide Puzzle \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import pygame, sys, random \n  7. from pygame.locals import * \n  8.  \n  9. # Create the constants (go ahead and experiment with different values) \n 10. BOARDWIDTH = 4  # number of columns in the board \n 11. BOARDHEIGHT = 4 # number of rows in the board \n 12. TILESIZE = 80 \n\n\n78    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 13. WINDOWWIDTH = 640 \n 14. WINDOWHEIGHT = 480 \n 15. FPS = 30 \n 16. BLANK = None \n 17.  \n 18. #                 R    G    B \n 19. BLACK =         (  0,   0,   0) \n 20. WHITE =         (255, 255, 255) \n 21. BRIGHTBLUE =    (  0,  50, 255) \n 22. DARKTURQUOISE = (  3,  54,  73) \n 23. GREEN =         (  0, 204,   0) \n 24.  \n 25. BGCOLOR = DARKTURQUOISE \n 26. TILECOLOR = GREEN \n 27. TEXTCOLOR = WHITE \n 28. BORDERCOLOR = BRIGHTBLUE \n 29. BASICFONTSIZE = 20 \n 30.  \n 31. BUTTONCOLOR = WHITE \n 32. BUTTONTEXTCOLOR = BLACK \n 33. MESSAGECOLOR = WHITE \n 34.  \n 35. XMARGIN = int((WINDOWWIDTH - (TILESIZE * BOARDWIDTH + (BOARDWIDTH - 1))) / \n2) \n 36. YMARGIN = int((WINDOWHEIGHT - (TILESIZE * BOARDHEIGHT + (BOARDHEIGHT - \n1))) / 2) \n 37.  \n 38. UP = 'up' \n 39. DOWN = 'down' \n 40. LEFT = 'left' \n 41. RIGHT = 'right' \n 42.  \n 43. def main(): \n 44.     global FPSCLOCK, DISPLAYSURF, BASICFONT, RESET_SURF, RESET_RECT, \nNEW_SURF, NEW_RECT, SOLVE_SURF, SOLVE_RECT \n 45.  \n 46.     pygame.init() \n 47.     FPSCLOCK = pygame.time.Clock() \n 48.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 49.     pygame.display.set_caption('Slide Puzzle') \n 50.     BASICFONT = pygame.font.Font('freesansbold.ttf', BASICFONTSIZE) \n 51.  \n 52.     # Store the option buttons and their rectangles in OPTIONS. \n 53.     RESET_SURF, RESET_RECT = makeText('Reset',    TEXTCOLOR, TILECOLOR, \nWINDOWWIDTH - 120, WINDOWHEIGHT - 90) \n\n\nChapter 4 – Slide Puzzle    79 \n \n 54.     NEW_SURF,   NEW_RECT   = makeText('New Game', TEXTCOLOR, TILECOLOR, \nWINDOWWIDTH - 120, WINDOWHEIGHT - 60) \n \n 55.     SOLVE_SURF, SOLVE_RECT = makeText('Solve',    TEXTCOLOR, TILECOLOR, \nWINDOWWIDTH - 120, WINDOWHEIGHT - 30) \n 56.  \n 57.     mainBoard, solutionSeq = generateNewPuzzle(80) \n 58.     SOLVEDBOARD = getStartingBoard() # a solved board is the same as the \nboard in a start state. \n 59.     allMoves = [] # list of moves made from the solved configuration \n 60.  \n 61.     while True: # main game loop \n 62.         slideTo = None # the direction, if any, a tile should slide \n 63.         msg = '' # contains the message to show in the upper left corner. \n 64.         if mainBoard == SOLVEDBOARD: \n 65.             msg = 'Solved!' \n 66.  \n 67.         drawBoard(mainBoard, msg) \n 68.  \n 69.         checkForQuit() \n 70.         for event in pygame.event.get(): # event handling loop \n 71.             if event.type == MOUSEBUTTONUP: \n 72.                 spotx, spoty = getSpotClicked(mainBoard, event.pos[0], \nevent.pos[1]) \n 73.  \n 74.                 if (spotx, spoty) == (None, None): \n 75.                     # check if the user clicked on an option button \n 76.                     if RESET_RECT.collidepoint(event.pos): \n 77.                         resetAnimation(mainBoard, allMoves) # clicked on \nReset button \n 78.                         allMoves = [] \n 79.                     elif NEW_RECT.collidepoint(event.pos): \n 80.                         mainBoard, solutionSeq = generateNewPuzzle(80) # \nclicked on New Game button \n 81.                         allMoves = [] \n 82.                     elif SOLVE_RECT.collidepoint(event.pos): \n 83.                         resetAnimation(mainBoard, solutionSeq + allMoves) \n# clicked on Solve button \n 84.                         allMoves = [] \n 85.                 else: \n 86.                     # check if the clicked tile was next to the blank spot \n 87.  \n 88.                     blankx, blanky = getBlankPosition(mainBoard) \n 89.                     if spotx == blankx + 1 and spoty == blanky: \n 90.                         slideTo = LEFT \n 91.                     elif spotx == blankx - 1 and spoty == blanky: \n\n\n80    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 92.                         slideTo = RIGHT \n 93.                     elif spotx == blankx and spoty == blanky + 1: \n 94.                         slideTo = UP \n 95.                     elif spotx == blankx and spoty == blanky - 1: \n 96.                         slideTo = DOWN \n 97.  \n 98.             elif event.type == KEYUP: \n 99.                 # check if the user pressed a key to slide a tile \n100.                 if event.key in (K_LEFT, K_a) and isValidMove(mainBoard, \nLEFT): \n101.                     slideTo = LEFT \n102.                 elif event.key in (K_RIGHT, K_d) and \nisValidMove(mainBoard, RIGHT): \n103.                     slideTo = RIGHT \n104.                 elif event.key in (K_UP, K_w) and isValidMove(mainBoard, \nUP): \n105.                     slideTo = UP \n106.                 elif event.key in (K_DOWN, K_s) and isValidMove(mainBoard, \nDOWN): \n107.                     slideTo = DOWN \n108.  \n109.         if slideTo: \n110.             slideAnimation(mainBoard, slideTo, 'Click tile or press arrow \nkeys to slide.', 8) # show slide on screen \n111.             makeMove(mainBoard, slideTo) \n112.             allMoves.append(slideTo) # record the slide \n113.         pygame.display.update() \n114.         FPSCLOCK.tick(FPS) \n115.  \n116.  \n117. def terminate(): \n118.     pygame.quit() \n119.     sys.exit() \n120.  \n121.  \n122. def checkForQuit(): \n123.     for event in pygame.event.get(QUIT): # get all the QUIT events \n124.         terminate() # terminate if any QUIT events are present \n125.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n126.         if event.key == K_ESCAPE: \n127.             terminate() # terminate if the KEYUP event was for the Esc key \n128.         pygame.event.post(event) # put the other KEYUP event objects back \n129.  \n130.  \n131. def getStartingBoard(): \n132.     # Return a board data structure with tiles in the solved state. \n\n\nChapter 4 – Slide Puzzle    81 \n \n133.     # For example, if BOARDWIDTH and BOARDHEIGHT are both 3, this function \n134.     # returns [[1, 4, 7], [2, 5, 8], [3, 6, None]] \n135.     counter = 1 \n136.     board = [] \n137.     for x in range(BOARDWIDTH): \n138.         column = [] \n139.         for y in range(BOARDHEIGHT): \n140.             column.append(counter) \n141.             counter += BOARDWIDTH \n142.         board.append(column) \n143.         counter -= BOARDWIDTH * (BOARDHEIGHT - 1) + BOARDWIDTH - 1 \n144.  \n145.     board[BOARDWIDTH-1][BOARDHEIGHT-1] = None \n146.     return board \n147.  \n148.  \n149. def getBlankPosition(board): \n150.     # Return the x and y of board coordinates of the blank space. \n151.     for x in range(BOARDWIDTH)): \n152.         for y in range(BOARDHEIGHT): \n153.             if board[x][y] == None: \n154.                 return (x, y) \n155.  \n156.  \n157. def makeMove(board, move): \n158.     # This function does not check if the move is valid. \n159.     blankx, blanky = getBlankPosition(board) \n160.  \n161.     if move == UP: \n162.         board[blankx][blanky], board[blankx][blanky + 1] = \nboard[blankx][blanky + 1], board[blankx][blanky] \n163.     elif move == DOWN: \n164.         board[blankx][blanky], board[blankx][blanky - 1] = \nboard[blankx][blanky - 1], board[blankx][blanky] \n165.     elif move == LEFT: \n166.         board[blankx][blanky], board[blankx + 1][blanky] = board[blankx + \n1][blanky], board[blankx][blanky] \n167.     elif move == RIGHT: \n168.         board[blankx][blanky], board[blankx - 1][blanky] = board[blankx - \n1][blanky], board[blankx][blanky] \n169.  \n170.  \n171. def isValidMove(board, move): \n172.     blankx, blanky = getBlankPosition(board) \n173.     return (move == UP and blanky != len(board[0]) - 1) or \\ \n174.            (move == DOWN and blanky != 0) or \\ \n\n\n82    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n175.            (move == LEFT and blankx != len(board) - 1) or \\ \n176.            (move == RIGHT and blankx != 0) \n177.  \n178.  \n179. def getRandomMove(board, lastMove=None): \n180.     # start with a full list of all four moves \n181.     validMoves = [UP, DOWN, LEFT, RIGHT] \n182.  \n183.     # remove moves from the list as they are disqualified \n184.     if lastMove == UP or not isValidMove(board, DOWN): \n185.         validMoves.remove(DOWN) \n186.     if lastMove == DOWN or not isValidMove(board, UP): \n187.         validMoves.remove(UP) \n188.     if lastMove == LEFT or not isValidMove(board, RIGHT): \n189.         validMoves.remove(RIGHT) \n190.     if lastMove == RIGHT or not isValidMove(board, LEFT): \n191.         validMoves.remove(LEFT) \n192.  \n193.     # return a random move from the list of remaining moves \n194.     return random.choice(validMoves) \n195.  \n196.  \n197. def getLeftTopOfTile(tileX, tileY): \n198.     left = XMARGIN + (tileX * TILESIZE) + (tileX - 1) \n199.     top = YMARGIN + (tileY * TILESIZE) + (tileY - 1) \n200.     return (left, top) \n201.  \n202.  \n203. def getSpotClicked(board, x, y): \n204.     # from the x & y pixel coordinates, get the x & y board coordinates \n205.     for tileX in range(len(board)): \n206.         for tileY in range(len(board[0])): \n207.             left, top = getLeftTopOfTile(tileX, tileY) \n208.             tileRect = pygame.Rect(left, top, TILESIZE, TILESIZE) \n209.             if tileRect.collidepoint(x, y): \n210.                 return (tileX, tileY) \n211.     return (None, None) \n212.  \n213.  \n214. def drawTile(tilex, tiley, number, adjx=0, adjy=0): \n215.     # draw a tile at board coordinates tilex and tiley, optionally a few \n216.     # pixels over (determined by adjx and adjy) \n217.     left, top = getLeftTopOfTile(tilex, tiley) \n218.     pygame.draw.rect(DISPLAYSURF, TILECOLOR, (left + adjx, top + adjy, \nTILESIZE, TILESIZE)) \n219.     textSurf = BASICFONT.render(str(number), True, TEXTCOLOR) \n\n\nChapter 4 – Slide Puzzle    83 \n \n220.     textRect = textSurf.get_rect() \n221.     textRect.center = left + int(TILESIZE / 2) + adjx, top + int(TILESIZE \n/ 2) + adjy \n222.     DISPLAYSURF.blit(textSurf, textRect) \n223.  \n224.  \n225. def makeText(text, color, bgcolor, top, left): \n226.     # create the Surface and Rect objects for some text. \n227.     textSurf = BASICFONT.render(text, True, color, bgcolor) \n228.     textRect = textSurf.get_rect() \n229.     textRect.topleft = (top, left) \n230.     return (textSurf, textRect) \n231.  \n232.  \n233. def drawBoard(board, message): \n234.     DISPLAYSURF.fill(BGCOLOR) \n235.     if message: \n236.         textSurf, textRect = makeText(message, MESSAGECOLOR, BGCOLOR, 5, \n5) \n237.         DISPLAYSURF.blit(textSurf, textRect) \n238.  \n239.     for tilex in range(len(board)): \n240.         for tiley in range(len(board[0])): \n241.             if board[tilex][tiley]: \n242.                 drawTile(tilex, tiley, board[tilex][tiley]) \n243.  \n244.     left, top = getLeftTopOfTile(0, 0) \n245.     width = BOARDWIDTH * TILESIZE \n246.     height = BOARDHEIGHT * TILESIZE \n247.     pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (left - 5, top - 5, width + \n11, height + 11), 4) \n248.  \n249.     DISPLAYSURF.blit(RESET_SURF, RESET_RECT) \n250.     DISPLAYSURF.blit(NEW_SURF, NEW_RECT) \n251.     DISPLAYSURF.blit(SOLVE_SURF, SOLVE_RECT) \n252.  \n253.  \n254. def slideAnimation(board, direction, message, animationSpeed): \n255.     # Note: This function does not check if the move is valid. \n256.  \n257.     blankx, blanky = getBlankPosition(board) \n258.     if direction == UP: \n259.         movex = blankx \n260.         movey = blanky + 1 \n261.     elif direction == DOWN: \n262.         movex = blankx \n\n\n84    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n263.         movey = blanky - 1 \n264.     elif direction == LEFT: \n265.         movex = blankx + 1 \n266.         movey = blanky \n267.     elif direction == RIGHT: \n268.         movex = blankx - 1 \n269.         movey = blanky \n270.  \n271.     # prepare the base surface \n272.     drawBoard(board, message) \n273.     baseSurf = DISPLAYSURF.copy() \n274.     # draw a blank space over the moving tile on the baseSurf Surface. \n275.     moveLeft, moveTop = getLeftTopOfTile(movex, movey) \n276.     pygame.draw.rect(baseSurf, BGCOLOR, (moveLeft, moveTop, TILESIZE, \nTILESIZE)) \n277.  \n278.     for i in range(0, TILESIZE, animationSpeed): \n279.         # animate the tile sliding over \n280.         checkForQuit() \n281.         DISPLAYSURF.blit(baseSurf, (0, 0)) \n282.         if direction == UP: \n283.             drawTile(movex, movey, board[movex][movey], 0, -i) \n284.         if direction == DOWN: \n285.             drawTile(movex, movey, board[movex][movey], 0, i) \n286.         if direction == LEFT: \n287.             drawTile(movex, movey, board[movex][movey], -i, 0) \n288.         if direction == RIGHT: \n289.             drawTile(movex, movey, board[movex][movey], i, 0) \n290.  \n291.         pygame.display.update() \n292.         FPSCLOCK.tick(FPS) \n293.  \n294.  \n295. def generateNewPuzzle(numSlides): \n296.     # From a starting configuration, make numSlides number of moves (and \n297.     # animate these moves). \n298.     sequence = [] \n299.     board = getStartingBoard() \n300.     drawBoard(board, '') \n301.     pygame.display.update() \n302.     pygame.time.wait(500) # pause 500 milliseconds for effect \n303.     lastMove = None \n304.     for i in range(numSlides): \n305.         move = getRandomMove(board, lastMove) \n306.         slideAnimation(board, move, 'Generating new puzzle...', \nint(TILESIZE / 3)) \n",
      "page_number": 95,
      "chapter_number": 12,
      "summary": "This chapter covers segment 12 (pages 95-102). Key topics include board, left, and event. Source Code to Slide Puzzle \nThis source code can be downloaded from http://invpy.com/slidepuzzle.py.",
      "keywords": [
        "board",
        "Play Slide Puzzle",
        "TILESIZE",
        "Slide Puzzle",
        "blanky",
        "left",
        "blankx",
        "Slide",
        "Play Slide",
        "SURF",
        "Puzzle",
        "RECT",
        "BOARDWIDTH",
        "move",
        "movex"
      ],
      "concepts": [
        "board",
        "left",
        "event",
        "returns",
        "messages",
        "right",
        "slide",
        "sliding",
        "white",
        "numbered"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "Segment 11 (pages 100-107)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 27,
          "title": "Segment 27 (pages 526-548)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 4,
          "title": "Segment 4 (pages 25-32)",
          "relevance_score": 0.53,
          "method": "api"
        }
      ]
    },
    {
      "number": 13,
      "title": "Segment 13 (pages 103-111)",
      "start_page": 103,
      "end_page": 111,
      "detection_method": "topic_boundary",
      "content": "Chapter 4 – Slide Puzzle    85 \n \n307.         makeMove(board, move) \n308.         sequence.append(move) \n309.         lastMove = move \n310.     return (board, sequence) \n311.  \n312.  \n313. def resetAnimation(board, allMoves): \n314.     # make all of the moves in allMoves in reverse. \n315.     revAllMoves = allMoves[:] # gets a copy of the list \n316.     revAllMoves.reverse() \n317.  \n318.     for move in revAllMoves: \n319.         if move == UP: \n320.             oppositeMove = DOWN \n321.         elif move == DOWN: \n322.             oppositeMove = UP \n323.         elif move == RIGHT: \n324.             oppositeMove = LEFT \n325.         elif move == LEFT: \n326.             oppositeMove = RIGHT \n327.         slideAnimation(board, oppositeMove, '', int(TILESIZE / 2)) \n328.         makeMove(board, oppositeMove) \n329.  \n330.  \n331. if __name__ == '__main__': \n332.     main() \nSecond Verse, Same as the First \nMuch of the code in Wormy is similar to the previous games we’ve looked at, especially the \nconstants being set at the start of the code. \n  1. # Slide Puzzle \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import pygame, sys, random \n  7. from pygame.locals import * \n  8.  \n  9. # Create the constants (go ahead and experiment with different values) \n 10. BOARDWIDTH = 4  # number of columns in the board \n 11. BOARDHEIGHT = 4 # number of rows in the board \n 12. TILESIZE = 80 \n 13. WINDOWWIDTH = 640 \n\n\n86    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 14. WINDOWHEIGHT = 480 \n 15. FPS = 30 \n 16. BLANK = None \n 17.  \n 18. #                 R    G    B \n 19. BLACK =         (  0,   0,   0) \n 20. WHITE =         (255, 255, 255) \n 21. BRIGHTBLUE =    (  0,  50, 255) \n 22. DARKTURQUOISE = (  3,  54,  73) \n 23. GREEN =         (  0, 204,   0) \n 24.  \n 25. BGCOLOR = DARKTURQUOISE \n 26. TILECOLOR = GREEN \n 27. TEXTCOLOR = WHITE \n 28. BORDERCOLOR = BRIGHTBLUE \n 29. BASICFONTSIZE = 20 \n 30.  \n 31. BUTTONCOLOR = WHITE \n 32. BUTTONTEXTCOLOR = BLACK \n 33. MESSAGECOLOR = WHITE \n 34.  \n 35. XMARGIN = int((WINDOWWIDTH - (TILESIZE * BOARDWIDTH + (BOARDWIDTH - 1))) / \n2) \n 36. YMARGIN = int((WINDOWHEIGHT - (TILESIZE * BOARDHEIGHT + (BOARDHEIGHT - \n1))) / 2) \n 37.  \n 38. UP = 'up' \n 39. DOWN = 'down' \n 40. LEFT = 'left' \n 41. RIGHT = 'right' \nThis code at the top of the program just handles all the basic importing of modules and creating \nconstants. This is just like the beginning of the Memory Puzzle game from the last chapter. \nSetting Up the Buttons \n 43. def main(): \n 44.     global FPSCLOCK, DISPLAYSURF, BASICFONT, RESET_SURF, RESET_RECT, \nNEW_SURF, NEW_RECT, SOLVE_SURF, SOLVE_RECT \n 45.  \n 46.     pygame.init() \n 47.     FPSCLOCK = pygame.time.Clock() \n 48.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 49.     pygame.display.set_caption('Slide Puzzle') \n 50.     BASICFONT = pygame.font.Font('freesansbold.ttf', BASICFONTSIZE) \n 51.  \n\n\nChapter 4 – Slide Puzzle    87 \n \n 52.     # Store the option buttons and their rectangles in OPTIONS. \n 53.     RESET_SURF, RESET_RECT = makeText('Reset',    TEXTCOLOR, TILECOLOR, \nWINDOWWIDTH - 120, WINDOWHEIGHT - 90) \n 54.     NEW_SURF,   NEW_RECT   = makeText('New Game', TEXTCOLOR, TILECOLOR, \nWINDOWWIDTH - 120, WINDOWHEIGHT - 60) \n 55.     SOLVE_SURF, SOLVE_RECT = makeText('Solve',    TEXTCOLOR, TILECOLOR, \nWINDOWWIDTH - 120, WINDOWHEIGHT - 30) \n 56.  \n 57.     mainBoard, solutionSeq = generateNewPuzzle(80) \n 58.     SOLVEDBOARD = getStartingBoard() # a solved board is the same as the \nboard in a start state. \nJust like in the last chapter, the functions called from the main() function calls will be \nexplained later in the chapter. For now, you just need to know what they do and what values they \nreturn. You don’t need to know how they work. \nThe first part of the main() function will handle creating the window, Clock object, and Font \nobject. The makeText() function is defined later in the program, but for now you just need to \nknow that it returns a pygame.Surface object and pygame.Rect object which can be used \nto make clickable buttons. The Slide Puzzle game will have three buttons: a ―Reset‖ button that \nwill undo any moves the player has made, a ―New‖ button that will create a new slide puzzle, and \na ―Solve‖ button that will solve the puzzle for the player. \nWe will need to have two board data structures for this program. One board will represent the \ncurrent game state. The other board will have its tiles in the ―solved‖ state, meaning that all the \ntiles are lined up in order. When the current game state’s board is exactly the same as the solved \nboard, then we know the player has won. (We won’t ever change this second one. It’ll just be \nthere to compare the current game state board to.) \nThe generateNewPuzzle() will create a board data structure that started off in the ordered, \nsolved state and then had 80 random slide moves performed on it (because we passed the integer \n80 to it. If we want the board to be even more jumbled, then we can pass a larger integer to it). \nThis will make the board into a randomly jumbled state that the player will have to solve (which \nwill be stored in a variable named mainBoard). The generateNewBoard() also returns a \nlist of all the random moves that were performed on it (which will be stored in a variable named \nsolutionSeq). \nBeing Smart By Using Stupid Code \n 59.     allMoves = [] # list of moves made from the solved configuration \n\n\n88    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nSolving a slide puzzle can be really tricky. We could program the computer to do it, but that \nwould require us to figure out an algorithm that can solve the slide puzzle. That would be very \ndifficult and involve a lot of cleverness and effort to put into this program.  \nFortunately, there’s an easier way. We could just have the computer memorize all the random \nslides it made when it created the board data structure, and then the board can be solved just by \nperforming the opposite slide. Since the board originally started in the solved state, undoing all \nthe slides would return it to the solved state. \nFor example, below we perform a ―right‖ slide on the board on the left side of the page, which \nleaves the board in the state that is on the right side of the page: \n \nAfter the right slide, if we do the opposite slide (a left slide) then the board will be back in the \noriginal state. So to get back to the original state after several slides, we just have to do the \nopposite slides in reverse order. If we did a right slide, then another right slide, then a down slide, \nwe would have to do an up slide, left slide, and left slide to undo those first three slides. This is \nmuch easier than writing a function that can solve these puzzles simply by looking at the current \nstate of them. \nThe Main Game Loop \n 61.     while True: # main game loop \n 62.         slideTo = None # the direction, if any, a tile should slide \n 63.         msg = '' # contains the message to show in the upper left corner. \n 64.         if mainBoard == SOLVEDBOARD: \n 65.             msg = 'Solved!' \n 66.  \n 67.         drawBoard(mainBoard, msg) \nIn the main game loop, the slideTo variable will track which direction the player wants to slide \na tile (it starts off at the beginning of the game loop as None and is set later) and the msg \nvariable tracks what string to display at the top of the window. The program does a quick check \non line 64 to see if the board data structure has the same value as the solved board data structure \nstored in SOLVEDBOARD. If so, then the msg variable is changed to the string 'Solved!'. \n\n\nChapter 4 – Slide Puzzle    89 \n \nThis won’t appear on the screen until drawBoard() has been called to draw it to the \nDISPLAYSURF Surface object (which is done on line 67) and pygame.display.update() \nis called to draw the display Surface object on the actual computer screen (which is done on line \n291 at the end of the game loop). \nClicking on the Buttons \n 69.         checkForQuit() \n 70.         for event in pygame.event.get(): # event handling loop \n 71.             if event.type == MOUSEBUTTONUP: \n 72.                 spotx, spoty = getSpotClicked(mainBoard, event.pos[0], \nevent.pos[1]) \n 73.  \n 74.                 if (spotx, spoty) == (None, None): \n 75.                     # check if the user clicked on an option button \n 76.                     if RESET_RECT.collidepoint(event.pos): \n 77.                         resetAnimation(mainBoard, allMoves) # clicked on \nReset button \n 78.                         allMoves = [] \n 79.                     elif NEW_RECT.collidepoint(event.pos): \n 80.                         mainBoard, solutionSeq = generateNewPuzzle(80) # \nclicked on New Game button \n 81.                         allMoves = [] \n 82.                     elif SOLVE_RECT.collidepoint(event.pos): \n 83.                         resetAnimation(mainBoard, solutionSeq + allMoves) \n# clicked on Solve button \n 84.                         allMoves = [] \nBefore going into the event loop, the program calls checkForQuit() on line 69 to see if any \nQUIT events have been created (and terminates the program if there have). Why we have a \nseparate function (the checkForQuit() function) for handling the QUIT events will be \nexplained later. The for loop on line 70 executes the event handling code for any other event \ncreated since the last time pygame.event.get() was called (or since the program started, if \npygame.event.get() has never been called before). \nIf the type of event was a MOUSEBUTTONUP event (that is, the player had released a mouse \nbutton somewhere over the window), then we pass the mouse coordinates to our \ngetSpotClicked() function which will return the board coordinates of the spot on the board \nthe mouse release happened. The event.pos[0] is the X coordinate and event.pos[1] is \nthe Y coordinate. \nIf the mouse button release did not happen over one of the spaces on the board (but obviously still \nhappened somewhere on the window, since a MOUSEBUTTONUP event was created), then \ngetSpotClicked() will return None. If this is the case, we want to do an additional check to \n\n\n90    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nsee if the player might have clicked on the Reset, New, or Solve buttons (which are not located on \nthe board).  \nThe coordinates of where these buttons are on the window are stored in the pygame.Rect \nobjects that are stored in the RESET_RECT, NEW_RECT, and SOLVE_RECT variables. We can \npass the mouse coordinates from the Event object to the collidepoint() method. This \nmethod will return True if the mouse coordinates are within the Rect object’s area and False \notherwise. \nSliding Tiles with the Mouse \n 85.                 else: \n 86.                     # check if the clicked tile was next to the blank spot \n 87.  \n 88.                     blankx, blanky = getBlankPosition(mainBoard) \n 89.                     if spotx == blankx + 1 and spoty == blanky: \n 90.                         slideTo = LEFT \n 91.                     elif spotx == blankx - 1 and spoty == blanky: \n 92.                         slideTo = RIGHT \n 93.                     elif spotx == blankx and spoty == blanky + 1: \n 94.                         slideTo = UP \n 95.                     elif spotx == blankx and spoty == blanky - 1: \n 96.                         slideTo = DOWN \nIf getSpotClicked() did not return (None, None), then it will have returned a tuple of \ntwo integer values that represent the X and Y coordinate of the spot on the board that was clicked. \nThen the if and elif statements on lines 89 to 96 check if the spot that was clicked is a tile that \nis next to the blank spot (otherwise the tile will have no place to slide). \nOur getBlankPosition() function will take the board data structure and return the X and Y \nboard coordinates of the blank spot, which we store in the variables blankx and blanky. If the \nspot the user clicked on was next to the blank space, we set the slideTo variable with the value \nthat the tile should slide. \nSliding Tiles with the Keyboard \n 98.             elif event.type == KEYUP: \n 99.                 # check if the user pressed a key to slide a tile \n100.                 if event.key in (K_LEFT, K_a) and isValidMove(mainBoard, \nLEFT): \n101.                     slideTo = LEFT \n102.                 elif event.key in (K_RIGHT, K_d) and \nisValidMove(mainBoard, RIGHT): \n103.                     slideTo = RIGHT \n\n\nChapter 4 – Slide Puzzle    91 \n \n104.                 elif event.key in (K_UP, K_w) and isValidMove(mainBoard, \nUP): \n105.                     slideTo = UP \n106.                 elif event.key in (K_DOWN, K_s) and isValidMove(mainBoard, \nDOWN): \n107.                     slideTo = DOWN \nWe can also let the user slide tiles by pressing keyboard keys. The if and elif statements on \nlines 100 to 107 let the user set the slideTo variable by either pressing the arrow keys or the \nWASD keys (explained later). Each if and elif statement also has a call to isValidMove() \nto make sure that the tile can slide in that direction. (We didn’t have to make this call with the \nmouse clicks because the checks for the neighboring blank space did the same thing.) \n“Equal To One Of” Trick with the in Operator \nThe expression event.key in (K_LEFT, K_a) is just a Python trick to make the code \nsimpler. It is a way of saying ―evaluate to True if event.key is equal to one of K_LEFT or \nK_a‖. The following two expressions will evaluate the exact same way: \nevent.key in (K_LEFT, K_a) \n \nevent.key == K_LEFT or event.key == K_a \nYou can really save on some space by using this trick when you have to check if a value is equal \nto one of multiple values. The following two expressions will evaluate the exact same way: \nspam == 'dog' or spam == 'cat' or spam == 'mouse' or spam == 'horse' or spam == \n42 or spam == 'dingo' \n \nspam in ('dog', 'cat', 'mouse', 'horse', 42, 'dingo') \nWASD and Arrow Keys \nThe W, A, S, and D keys (together called the WASD keys, pronounced ―waz-dee‖) are \ncommonly used in computer games to do the same thing as the arrow keys, except the player can \nuse their left hand instead (since the WASD keys are on the left side of the keyboard). W is for \nup, A is for left, S is for down, and D is for right. You can easily remember this because the \nWASD keys have the same layout as the arrow keys: \n\n\n92    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nActually Performing the Tile Slide \n109.         if slideTo: \n110.             slideAnimation(mainBoard, slideTo, 'Click tile or press arrow \nkeys to slide.', 8) # show slide on screen \n111.             makeMove(mainBoard, slideTo) \n112.             allMoves.append(slideTo) # record the slide \n113.         pygame.display.update() \n114.         FPSCLOCK.tick(FPS) \nNow that the events have all been handled, we should update the variables of the game state and \ndisplay the new state on the screen. If slideTo has been set (either by the mouse event or \nkeyboard event handling code) then we can call slideAnimation() to perform the sliding \nanimation. The parameters are the board data structure, the direction of the slide, a message to \ndisplay while sliding the tile, and the speed of the sliding. \nAfter it returns, we need to update the actual board data structure (which is done by the \nmakeMove() function) and then add the slide to the allMoves list of all the slides made so \nfar. This is done so that if the player clicks on the ―Reset‖ button, we know how to undo all the \nplayer’s slides. \nIDLE and Terminating Pygame Programs \n117. def terminate(): \n118.     pygame.quit() \n119.     sys.exit() \nThis is a function that we can call that calls both the pygame.quit() and sys.exit() \nfunctions. This is a bit of syntactic sugar, so that instead of remembering to make both of these \ncalls, there is just a single function we can call instead. \nChecking for a Specific Event, and Posting Events to Pygame’s Event \nQueue \n122. def checkForQuit(): \n123.     for event in pygame.event.get(QUIT): # get all the QUIT events \n124.         terminate() # terminate if any QUIT events are present \n\n\nChapter 4 – Slide Puzzle    93 \n \n125.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n126.         if event.key == K_ESCAPE: \n127.             terminate() # terminate if the KEYUP event was for the Esc key \n128.         pygame.event.post(event) # put the other KEYUP event objects back \nThe checkForQuit() function will check for QUIT events (or if the user has pressed the Esc \nkey) and then call the terminate() function. But this is a bit tricky and requires some \nexplanation. \nPygame internally has its own list data structure that it creates and appends Event objects to as \nthey are made. This data structure is called the event queue. When the \npygame.event.get() function is called with no parameters, the entire list is returned. \nHowever, you can pass a constant like QUIT to pygame.event.get() so that it will only \nreturn the QUIT events (if any) that are in the internal event queue. The rest of the events will \nstay in the event queue for the next time pygame.event.get() is called. \nYou should note that Pygame’s event queue only stores up to 127 Event objects. If your program \ndoes not call pygame.event.get() frequently enough and the queue fills up, then any new \nevents that happen won’t be added to the event queue. \nLine 123 pulls out a list of QUIT events from Pygame’s event queue and returns them. If there \nare any QUIT events in the event queue, the program terminates. \nLine 125 pulls out all the KEYUP events from the event queue and checks if any of them are for \nthe Esc key. If one of the events is, then the program terminates. However, there could be KEYUP \nevents for keys other than the Esc key. In this case, we need to put the KEYUP event back into \nPygame’s event queue. We can do this with the pygame.event.post() function, which adds \nthe Event object passed to it to the end of the Pygame event queue. This way, when line 70 calls \npygame.event.get() the non-Esc key KEYUP events will still be there. Otherwise calls to \ncheckForQuit() would ―consume‖ all of the KEYUP events and those events would never be \nhandled. \nThe pygame.event.post() function is also handy if you ever want your program to add \nEvent objects to the Pygame event queue. \nCreating the Board Data Structure \n131. def getStartingBoard(): \n132.     # Return a board data structure with tiles in the solved state. \n133.     # For example, if BOARDWIDTH and BOARDHEIGHT are both 3, this function \n134.     # returns [[1, 4, 7], [2, 5, 8], [3, 6, None]] \n135.     counter = 1 \n",
      "page_number": 103,
      "chapter_number": 13,
      "summary": "This chapter covers segment 13 (pages 103-111). Key topics include event, slide, and sliding.",
      "keywords": [
        "Slide Puzzle",
        "Slide",
        "event",
        "board",
        "QUIT events",
        "Event Queue",
        "board data structure",
        "KEYUP events",
        "LEFT",
        "board data",
        "left slide",
        "Puzzle",
        "SOLVE",
        "Pygame event queue",
        "function"
      ],
      "concepts": [
        "event",
        "slide",
        "sliding",
        "key",
        "keys",
        "board",
        "functions",
        "function",
        "solved",
        "solve"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.59,
          "method": "api"
        }
      ]
    },
    {
      "number": 14,
      "title": "Segment 14 (pages 112-120)",
      "start_page": 112,
      "end_page": 120,
      "detection_method": "topic_boundary",
      "content": "94    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n136.     board = [] \n137.     for x in range(BOARDWIDTH): \n138.         column = [] \n139.         for y in range(BOARDHEIGHT): \n140.             column.append(counter) \n141.             counter += BOARDWIDTH \n142.         board.append(column) \n143.         counter -= BOARDWIDTH * (BOARDHEIGHT - 1) + BOARDWIDTH - 1 \n144.  \n145.     board[BOARDWIDTH-1][BOARDHEIGHT-1] = None \n146.     return board \nThe getStartingBoard() data structure will create and return a data structure that \nrepresents a ―solved‖ board, where all the numbered tiles are in order and the blank tile is in the \nlower right corner. This is done with nested for loops, just like the board data structure in the \nMemory Puzzle game was made. \nHowever, notice that the first column isn’t going to be [1, 2, 3] but instead [1, 4, 7]. \nThis is because the numbers on the tiles increase by 1 going across the row, not down the column. \nGoing down the column, the numbers increase by the size of the board’s width (which is stored in \nthe BOARDWIDTH constant). We will use the counter variable to keep track of the number that \nshould go on the next tile. When the numbering of the tiles in the column is finished, then we \nneed to set counter to the number at the start of the next column.  \nNot Tracking the Blank Position \n149. def getBlankPosition(board): \n150.     # Return the x and y of board coordinates of the blank space. \n151.     for x in range(BOARDWIDTH)): \n152.         for y in range(BOARDHEIGHT): \n153.             if board[x][y] == None: \n154.                 return (x, y) \nWhenever our code needs to find the XY coordinates of the blank space, instead of keeping track \nof where the blank space is after each slide, we can just create a function that goes through the \nentire board and finds the blank space coordinates. The None value is used in the board data \nstructure to represent the blank space. The code in getBlankPosition() simply uses nested \nfor loops to find which space on the board is the blank space. \nMaking a Move by Updating the Board Data Structure \n157. def makeMove(board, move): \n158.     # This function does not check if the move is valid. \n\n\nChapter 4 – Slide Puzzle    95 \n \n159.     blankx, blanky = getBlankPosition(board) \n160.  \n161.     if move == UP: \n162.         board[blankx][blanky], board[blankx][blanky + 1] = \nboard[blankx][blanky + 1], board[blankx][blanky] \n163.     elif move == DOWN: \n164.         board[blankx][blanky], board[blankx][blanky - 1] = \nboard[blankx][blanky - 1], board[blankx][blanky] \n165.     elif move == LEFT: \n166.         board[blankx][blanky], board[blankx + 1][blanky] = board[blankx + \n1][blanky], board[blankx][blanky] \n167.     elif move == RIGHT: \n168.         board[blankx][blanky], board[blankx - 1][blanky] = board[blankx - \n1][blanky], board[blankx][blanky] \nThe data structure in the board parameter is a 2D list that represents where all the tiles are. \nWhenever the player makes a move, the program needs to update this data structure. What \nhappens is that the value for the tile is swapped with the value for the blank space. \nThe makeMove() function doesn’t have to return any values, because the board parameter has \na list reference passed for its argument. This means that any changes we make to board in this \nfunction will be made to the list value that was passed to makeMove(). (You can review the \nconcept of references at http://invpy.com/references.) \nWhen NOT to Use an Assertion \n171. def isValidMove(board, move): \n172.     blankx, blanky = getBlankPosition(board) \n173.     return (move == UP and blanky != len(board[0]) - 1) or \\ \n174.            (move == DOWN and blanky != 0) or \\ \n175.            (move == LEFT and blankx != len(board) - 1) or \\ \n176.            (move == RIGHT and blankx != 0) \nThe isValidMove() function is passed a board data structure and a move the player would \nwant to make. The return value is True if this move is possible and False if it is not. For \nexample, you cannot slide a tile to the left one hundred times in a row, because eventually the \nblank space will be at the edge and there are no more tiles to slide to the left. \nWhether a move is valid or not depends on where the blank space is. This function makes a call to \ngetBlankPosition() to find the X and Y coordinates of the blank spot. Lines 173 to 176 \nare a return statement with a single expression. The \\ slashes at the end of the first three lines \ntells the Python interpreter that that is not the end of the line of code (even though it is at the end \n\n\n96    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nof the line). This will let us split up a ―line of code‖ across multiple lines to look pretty, rather \nthan just have one very long unreadable line. \nBecause the parts of this expression in parentheses are joined by or operators, only one of them \nneeds to be True for the entire expression to be True. Each of these parts checks what the \nintended move is and then sees if the coordinate of the blank space allows that move. \nGetting a Not-So-Random Move \n179. def getRandomMove(board, lastMove=None): \n180.     # start with a full list of all four moves \n181.     validMoves = [UP, DOWN, LEFT, RIGHT] \n182.  \n183.     # remove moves from the list as they are disqualified \n184.     if lastMove == UP or not isValidMove(board, DOWN): \n185.         validMoves.remove(DOWN) \n186.     if lastMove == DOWN or not isValidMove(board, UP): \n187.         validMoves.remove(UP) \n188.     if lastMove == LEFT or not isValidMove(board, RIGHT): \n189.         validMoves.remove(RIGHT) \n190.     if lastMove == RIGHT or not isValidMove(board, LEFT): \n191.         validMoves.remove(LEFT) \n192.  \n193.     # return a random move from the list of remaining moves \n194.     return random.choice(validMoves) \nAt the beginning of the game, we start with the board data structure in the solved, ordered state \nand create the puzzle by randomly sliding around tiles. To decide which of the four directions we \nshould slide, we’ll call our getRandomMove() function. Normally we could just use the \nrandom.choice() function and pass it a tuple (UP, DOWN, LEFT, RIGHT) to have \nPython simply randomly choose a direction value for us. But the Sliding Puzzle game has a small \nrestriction that prevents us from choosing a purely random number. \nIf you had a slide puzzle and slid a tile to left, and then slid a tile to the right, you would end up \nwith the exact same board you had at the start. It’s pointless to make a slide followed by the \nopposite slide. Also, if the blank space is in the lower right corner than it is impossible to slide a \ntile up or to the left. \nThe code in getRandomMove() will take these factors into account. To prevent the function \nfrom selecting the last move that was made, the caller of the function can pass a directional value \nfor the lastMove parameter. Line 181 starts with a list of all four directional values stored in \nthe validMoves variable. The lastMove value (if not set to None) is removed from \n\n\nChapter 4 – Slide Puzzle    97 \n \nvalidMoves. Depending on if the blank space is at the edge of the board, lines 184 to 191 will \nremove other directional values from the lastMove list. \nOf the values that are left in lastMove, one of them is randomly selected with a call to \nrandom.choice() and returned. \nConverting Tile Coordinates to Pixel Coordinates \n197. def getLeftTopOfTile(tileX, tileY): \n198.     left = XMARGIN + (tileX * TILESIZE) + (tileX - 1) \n199.     top = YMARGIN + (tileY * TILESIZE) + (tileY - 1) \n200.     return (left, top) \nThe getLeftTopOfTile() function converts board coordinates to pixel coordinates. For the \nboard XY coordinates that are passed in, the function calculates and returns the pixel XY \ncoordinates of the pixel at the top left of that board space. \nConverting from Pixel Coordinates to Board Coordinates \n203. def getSpotClicked(board, x, y): \n204.     # from the x & y pixel coordinates, get the x & y board coordinates \n205.     for tileX in range(len(board)): \n206.         for tileY in range(len(board[0])): \n207.             left, top = getLeftTopOfTile(tileX, tileY) \n208.             tileRect = pygame.Rect(left, top, TILESIZE, TILESIZE) \n209.             if tileRect.collidepoint(x, y): \n210.                 return (tileX, tileY) \n211.     return (None, None) \nThe getSpotClicked() function does the opposite of getLeftTopOfTile() and \nconverts from pixel coordinates to board coordinates. The nested loops on lines 205 and 206 go \nthrough every possible XY board coordinate, and if the pixel coordinates that were passed in are \nwithin that space on the board, it returns those board coordinates. Since all of the tiles have a \nwidth and height that is set in the TILESIZE constant, we can create a Rect object that \nrepresents the space on the board by getting the pixel coordinates of the top left corner of the \nboard space, and then use the collidepoint() Rect method to see if the pixel coordinates are \ninside that Rect object’s area. \nIf the pixel coordinates that were passed in were not over any board space, then the value \n(None, None) is returned. \nDrawing a Tile \n214. def drawTile(tilex, tiley, number, adjx=0, adjy=0): \n\n\n98    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n215.     # draw a tile at board coordinates tilex and tiley, optionally a few \n216.     # pixels over (determined by adjx and adjy) \n217.     left, top = getLeftTopOfTile(tilex, tiley) \n218.     pygame.draw.rect(DISPLAYSURF, TILECOLOR, (left + adjx, top + adjy, \nTILESIZE, TILESIZE)) \n219.     textSurf = BASICFONT.render(str(number), True, TEXTCOLOR) \n220.     textRect = textSurf.get_rect() \n221.     textRect.center = left + int(TILESIZE / 2) + adjx, top + int(TILESIZE \n/ 2) + adjy \n222.     DISPLAYSURF.blit(textSurf, textRect) \nThe drawTile() function will draw a single numbered tile on the board. The tilex and \ntiley parameters are the board coordinates of the tile. The number parameter is a string of the \ntile’s number (like '3' or '12'). The adjx and adjy keyword parameters are for making \nminor adjustments to the position of the tile. For example, passing 5 for adjx would make the \ntile appear 5 pixels to the right of the tilex and tiley space on the board. Passing -10 for \nadjx would make the tile appear 10 pixels to the left of the space.  \nThese adjustment values will be handy when we need to draw the tile in the middle of sliding. If \nno values are passed for these arguments when drawTile() is called, then by default they are \nset to 0. This means they will be exactly on the board space given by tilex and tiley.  \nThe Pygame drawing functions only use pixel coordinates, so first line 217 converts the board \ncoordinates in tilex and tiley to pixel coordinates, which we will store in variables left \nand top (since getLeftTopOfTile() returns the top left corner’s coordinates). We draw the \nbackground square of the tile with a call to pygame.draw.rect() while adding the adjx \nand adjy values to left and top in case the code needs to adjust the position of the tile. \nLines 219 to 222 then create the Surface object that has the number text drawn on it. A Rect \nobject for the Surface object is positioned, and then used to blit the Surface object to the display \nSurface. The drawTile() function doesn’t call pygame.display.update() function, \nsince the caller of drawTile() probably will want to draw more tiles for the rest of the board \nbefore making them appear on the screen. \nThe Making Text Appear on the Screen \n225. def makeText(text, color, bgcolor, top, left): \n226.     # create the Surface and Rect objects for some text. \n227.     textSurf = BASICFONT.render(text, True, color, bgcolor) \n228.     textRect = textSurf.get_rect() \n229.     textRect.topleft = (top, left) \n230.     return (textSurf, textRect) \n\n\nChapter 4 – Slide Puzzle    99 \n \nThe makeText() function handles creating the Surface and Rect objects for positioning text on \nthe screen. Instead of doing all these calls each time we want to make text on the screen, we can \njust call makeText() instead. This saves us on the amount of typing we have to do for our \nprogram. (Though drawTile() makes the calls to render() and get_rect() itself \nbecause it positions the text Surface object by the center point rather than the topleft point and \nuses a transparent background color.) \nDrawing the Board \n233. def drawBoard(board, message): \n234.     DISPLAYSURF.fill(BGCOLOR) \n235.     if message: \n236.         textSurf, textRect = makeText(message, MESSAGECOLOR, BGCOLOR, 5, \n5) \n237.         DISPLAYSURF.blit(textSurf, textRect) \n238.  \n239.     for tilex in range(len(board)): \n240.         for tiley in range(len(board[0])): \n241.             if board[tilex][tiley]: \n242.                 drawTile(tilex, tiley, board[tilex][tiley]) \nThis function handles drawing the entire board and all of its tiles to the DISPLAYSURF display \nSurface object. The fill() method on line 234 completely paints over anything that used to be \ndrawn on the display Surface object before so that we start from scratch. \nLine 235 to 237 handles drawing the message at the top of the window. We use this for the \n―Generating new puzzle…‖ and other text we want to display at the top of the window. \nRemember that if statement conditions consider the blank string to be a False value, so if \nmessage is set to '' then the condition is False and lines 236 and 237 are skipped. \nNext, nested for loops are used to draw each tile to the display Surface object by calling the \ndrawTile() function. \nDrawing the Border of the Board \n244.     left, top = getLeftTopOfTile(0, 0) \n245.     width = BOARDWIDTH * TILESIZE \n246.     height = BOARDHEIGHT * TILESIZE \n247.     pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (left - 5, top - 5, width + \n11, height + 11), 4) \nLines 244 to 247 draw a border around the tiles. The top left corner of the boarder will be 5 pixels \nto the left and 5 pixels above the top left corner of the tile at board coordinates (0, 0). The width \nand height of the border are calculated from the number of tiles wide and high the board is (stored \n\n\n100    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nin the BOARDWIDTH and BOARDHEIGHT constants) multiplied by the size of the tiles (stored in \nthe TILESIZE constant). \nThe rectangle we draw on line 247 will have a thickness of 4 pixels, so we will move the boarder \n5 pixels to the left and above where the top and left variables point so the thickness of the line \nwon’t overlap the tiles. We will also add 11 to the width and length (5 of those 11 pixels are to \ncompensate for moving the rectangle to the left and up). \nDrawing the Buttons \n249.     DISPLAYSURF.blit(RESET_SURF, RESET_RECT) \n250.     DISPLAYSURF.blit(NEW_SURF, NEW_RECT) \n251.     DISPLAYSURF.blit(SOLVE_SURF, SOLVE_RECT) \nFinally, we draw the buttons off to the slide of the screen. The text and position of these buttons \nnever changes, which is why they were stored in constant variables at the beginning of the \nmain() function. \nAnimating the Tile Slides \n254. def slideAnimation(board, direction, message, animationSpeed): \n255.     # Note: This function does not check if the move is valid. \n256.  \n257.     blankx, blanky = getBlankPosition(board) \n258.     if direction == UP: \n259.         movex = blankx \n260.         movey = blanky + 1 \n261.     elif direction == DOWN: \n262.         movex = blankx \n263.         movey = blanky - 1 \n264.     elif direction == LEFT: \n265.         movex = blankx + 1 \n266.         movey = blanky \n267.     elif direction == RIGHT: \n268.         movex = blankx - 1 \n269.         movey = blanky \nThe first thing our tile sliding animation code needs to calculate is where the blank space is and \nwhere the moving tile is. The comment on line 255 reminds us that the code that calls \nslideAnimation() should make sure that the slide it passes for the direction parameter is a \nvalid move to make. \n\n\nChapter 4 – Slide Puzzle    101 \n \nThe blank space’s coordinates come from a call to getBlankPosition(). From these \ncoordinates and the direction of the slide, we can figure out the XY board coordinates of the tile \nthat will slide. These coordinates will be stored in the movex and movey variables. \nThe copy() Surface Method \n271.     # prepare the base surface \n272.     drawBoard(board, message) \n273.     baseSurf = DISPLAYSURF.copy() \n274.     # draw a blank space over the moving tile on the baseSurf Surface. \n275.     moveLeft, moveTop = getLeftTopOfTile(movex, movey) \n276.     pygame.draw.rect(baseSurf, BGCOLOR, (moveLeft, moveTop, TILESIZE, \nTILESIZE)) \nThe copy() method of Surface objects will return a new Surface object that has the same image \ndrawn to it. But they are two separate Surface objects. After calling the copy() method, if we \ndraw on one Surface object using blit() or the Pygame drawing functions, it will not change \nthe image on the other Surface object. We store this copy in the baseSurf variable on line 273. \nNext, we paint another blank space over the tile that will slide. This is because when we draw \neach frame of the sliding animation, we will draw the sliding tile over different parts of the \nbaseSurf Surface object. If we didn’t blank out the moving tile on the baseSurf Surface, \nthen it would still be there as we draw the sliding tile. In that case, here is what the baseSurf \nSurface would look like: \n \nAnd then what it would look like when we draw the ―9‖ tile sliding upwards on top of it: \n\n\n102    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nYou can see this for yourself by commenting out line 276 and running the program. \n278.     for i in range(0, TILESIZE, animationSpeed): \n279.         # animate the tile sliding over \n280.         checkForQuit() \n281.         DISPLAYSURF.blit(baseSurf, (0, 0)) \n282.         if direction == UP: \n283.             drawTile(movex, movey, board[movex][movey], 0, -i) \n284.         if direction == DOWN: \n285.             drawTile(movex, movey, board[movex][movey], 0, i) \n286.         if direction == LEFT: \n287.             drawTile(movex, movey, board[movex][movey], -i, 0) \n288.         if direction == RIGHT: \n289.             drawTile(movex, movey, board[movex][movey], i, 0) \n290.  \n291.         pygame.display.update() \n292.         FPSCLOCK.tick(FPS) \nIn order to draw the frames of the sliding animation, we must draw the baseSurf surface on the \ndisplay Surface, then on each frame of the animation draw the sliding tile closer and closer to its \nfinal position where the original blank space was. The space between two adjacent tiles is the \nsame size as a single tile, which we have stored in TILESIZE. The code uses a for loop to go \nfrom 0 to TILESIZE.  \nNormally this would mean that we would draw the tile 0 pixels over, then on the next frame draw \nthe tile 1 pixel over, then 2 pixels, then 3, and so on. Each of these frames would take 1/30th of a \nsecond. If you have TILESIZE set to 80 (as the program in this book does on line 12) then \nsliding a tile would take over two and a half seconds, which is actually kind of slow. \n",
      "page_number": 112,
      "chapter_number": 14,
      "summary": "return board \nThe getStartingBoard() data structure will create and return a data structure that \nrepresents a ―solved‖ board, where all the numbered tiles are in order and the blank tile is in the \nlower right corner Key topics include board, left, and lines.",
      "keywords": [
        "board",
        "board coordinates",
        "LEFT",
        "tile",
        "Surface",
        "coordinates",
        "Surface object",
        "blank space",
        "Pixel Coordinates",
        "TILESIZE",
        "Move",
        "space",
        "blankx",
        "board data structure",
        "blanky"
      ],
      "concepts": [
        "board",
        "left",
        "lines",
        "function",
        "functions",
        "returned",
        "surface",
        "numbers",
        "numbering",
        "text"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 9,
          "title": "Segment 9 (pages 76-90)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 31,
          "title": "Segment 31 (pages 291-298)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 36,
          "title": "Segment 36 (pages 360-367)",
          "relevance_score": 0.48,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 45,
          "title": "Segment 45 (pages 429-442)",
          "relevance_score": 0.48,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 12,
          "title": "Segment 12 (pages 219-238)",
          "relevance_score": 0.47,
          "method": "api"
        }
      ]
    },
    {
      "number": 15,
      "title": "Segment 15 (pages 121-129)",
      "start_page": 121,
      "end_page": 129,
      "detection_method": "topic_boundary",
      "content": "Chapter 4 – Slide Puzzle    103 \n \nSo instead we will have the for loop iterate from 0 to TILESIZE by several pixels each frame. \nThe number of pixels it jumps over is stored in animationSpeed, which is passed in when \nslideAnimation() is called. For example, if animationSpeed was set to 8 and the \nconstant TILESIZE was set to 80, then the for loop and range(0, TILESIZE, \nanimationSpeed) would set the i variable to the values 0, 8, 16, 24, 32, 40, 48, 56, 64, \n72. (It does not include 80 because the range() function goes up to, but not including, the \nsecond argument.) This means the entire sliding animation would be done in 10 frames, which \nwould mean it is done in 10/30th of a second (a third of a second) since the game runs at 30 FPS. \nLines 282 to 289 makes sure that we draw the tile sliding in the correct direction (based on what \nvalue the direction variable has). After the animation is done, then the function returns. \nNotice that while the animation is happening, any events being created by the user are not being \nhandled. Those events will be handled the next time execution reaches line 70 in the main() \nfunction or the code in the checkForQuit() function. \nCreating a New Puzzle \n295. def generateNewPuzzle(numSlides): \n296.     # From a starting configuration, make numSlides number of moves (and \n297.     # animate these moves). \n298.     sequence = [] \n299.     board = getStartingBoard() \n300.     drawBoard(board, '') \n301.     pygame.display.update() \n302.     pygame.time.wait(500) # pause 500 milliseconds for effect \nThe generateNewPuzzle() function will be called at the start of each new game. It will \ncreate a new board data structure by calling getStartingBoard() and then randomly \nscramble it. The first few lines of generateNewPuzzle() get the board and then draw it to \nthe screen (freezing for half a second to let the player see the fresh board for a moment). \n303.     lastMove = None \n304.     for i in range(numSlides): \n305.         move = getRandomMove(board, lastMove) \n306.         slideAnimation(board, move, 'Generating new puzzle...', \nint(TILESIZE / 3)) \n307.         makeMove(board, move) \n308.         sequence.append(move) \n309.         lastMove = move \n310.     return (board, sequence) \nThe numSlides parameter will show tell the function how many of these random moves to \nmake. The code for doing a random move is the getRandomMove() call on line 305 to get the \n\n\n104    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nmove itself, then call slideAnimation() to perform the animation on the screen. Because \ndoing the slide animation does not actually update the board data structure, we update the board \nby calling makeMove() on line 307. \nWe need to keep track of each of the random moves that was made so that the player can click the \n―Solve‖ button later and have the program undo all these random moves. (The ―Being Smart By \nUsing Stupid Code‖ section talks about why and how we do this.) So the move is appended to the \nlist of moves in sequence on line 308. \nThen we store the random move in a variable called lastMove which will be passed to \ngetRandomMove() on the next iteration. This prevents the next random move from undoing \nthe random move we just performed. \nAll of this needs to happen numSlides number of times, so we put lines 305 to 309 inside a \nfor loop. When the board is done being scrambled, then we return the board data structure and \nalso the list of the random moves made on it. \nAnimating the Board Reset \n313. def resetAnimation(board, allMoves): \n314.     # make all of the moves in allMoves in reverse. \n315.     revAllMoves = allMoves[:] # gets a copy of the list \n316.     revAllMoves.reverse() \n317.  \n318.     for move in revAllMoves: \n319.         if move == UP: \n320.             oppositeMove = DOWN \n321.         elif move == DOWN: \n322.             oppositeMove = UP \n323.         elif move == RIGHT: \n324.             oppositeMove = LEFT \n325.         elif move == LEFT: \n326.             oppositeMove = RIGHT \n327.         slideAnimation(board, oppositeMove, '', int(TILESIZE / 2)) \n328.         makeMove(board, oppositeMove) \nWhen the player clicks on ―Reset‖ or ―Solve‖, the Slide Puzzle game program needs to undo all \nof the moves that were made to the board. The list of directional values for the slides will be \npassed as the argument for the allMoves parameter. \nLine 315 uses list slicing to create a duplicate of the allMoves list. Remember that if you don’t \nspecify a number before the :, then Python assumes the slice should start from the very \nbeginning of the list. And if you don’t specify a number after the :, then Python assumes the slice \nshould keep going to the very end of the list. So allMoves[:] creates a list slice of the entire \n\n\nChapter 4 – Slide Puzzle    105 \n \nallMoves list. This makes a copy of the actual list to store in revAllMoves, rather than just a \ncopy of the list reference. (See http://invpy.com/references for details.) \nTo undo all the moves in allMoves, we need to perform the opposite move of the moves in \nallMoves, and in reverse order. There is a list method called reverse() which will reverse \nthe order of the items in a list. We call this on the revAllMoves list on line 316. \nThe for loop on line 318 iterates over the list of directional values. Remember, we want the \nopposite move, so the if and elif statements from line 319 to 326 set the correct directional \nvalue in the oppositeMove variable. Then we call slideAnimation() to perform the \nanimation, and makeMove() to update the board data structure. \n331. if __name__ == '__main__': \n332.     main() \nJust like in the Memory Puzzle game, after all the def statements have been executed to create \nall the functions, we call the main() function to begin the meat of the program. \nThat’s all there is to the Slide Puzzle program! But let’s talk about some general programming \nconcepts that came up in this game. \nTime vs. Memory Tradeoffs \nOf course, there are a few different ways to write the Slide Puzzle game so that it looks and acts \nthe exact same way even though the code is different. There are many different ways the a \nprogram that does a task could be written. The most common differences are making tradeoffs \nbetween execution time and memory usage. \nUsually, the faster a program can run, the better it is. This is especially true with programs that \nneed to do a lot of calculations, whether they are scientific weather simulators or games with a \nlarge amount of detailed 3D graphics to draw. It’s also good to use the least amount of memory \npossible. The more variables and the larger the lists your program uses, the more memory it takes \nup. (You can find out how to measure your program’s memory usage and execution time at \nhttp://invpy.com/profiling.) \nRight now, the programs in this book aren’t big and complicated enough where you have to \nworry about conserving memory or optimizing the execution time. But it can be something to \nconsider as you become a more skilled programmer. \nFor example, consider the getBlankPosition() function. This function takes time to run, \nsince it goes through all the possible board coordinates to find where the blank space is. Instead, \nwe could just have a blankspacex and blankspacey variable which would have these XY \n\n\n106    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \ncoordinates so we would not have to look through the entire board each time we want to know \nwhere it was. (We would also need code that updates the blankspacex and blankspacey \nvariables whenever a move is done. This code could go in makeMove().) Using these variables \nwould take up more memory, but they would save you on execution time so your program would \nrun faster. \nAnother example is that we keep a board data structure in the solved state in the SOLVEDBOARD \nvariable, so that we can compare the current board to SOLVEDBOARD to see if the player has \nsolved the puzzle. Each time we wanted to do this check, we could just call the \ngetStartingBoard() function and compare the returned value to the current board. Then \nwe would not need the SOLVEDBOARD variable. This would save us a little bit of memory, but \nthen our program would take longer to run because it is re-creating the solved-state board data \nstructure each time we do this check. \nThere is one thing you must remember though. Writing code that is readable is a very important \nskill. Code that is ―readable‖ is code that is easy to understand, especially by programmers who \ndid not write the code. If another programmer can look at your program’s source code and figure \nout what it does without much trouble, then that program is very readable. Readability is \nimportant because when you want to fix bugs or add new features to your program (and bugs and \nideas for new features always come up), then having a readable program makes those tasks much \neasier. \nNobody Cares About a Few Bytes \nAlso, there is one thing that might seem kind of silly to say in this book because it seem obvious, \nbut many people wonder about it. You should know that using short variable names like x or num \ninstead of longer, more descriptive variable names like blankx or numSlides does not save \nyou any memory when your program actually runs. Using these longer variable names is better \nbecause they’ll make your program more readable. \nYou might also come up with some clever tricks that do save a few bytes of memory here and \nthere. One trick is that when you no longer need a variable, you can reuse that variable name for a \ndifferent purpose instead of just using two differently named variables.  \nTry to avoid the temptation to do this. Usually, these tricks reduce code readability and make it \nharder to debug your programs. Modern computers have billions of bytes of memory, and saving \na few bytes here and there really isn’t worth making the code more confusing for human \nprogrammers. \n\n\nChapter 4 – Slide Puzzle    107 \n \nNobody Cares About a Few Million Nanoseconds \nSimilarly, there are times when you can rearrange your code in some way to make it slightly \nfaster by a few nanoseconds. These tricks also usually make the code harder to read. When you \nconsider that several billion nanoseconds have passed in the time it takes you to read this \nsentence, saving a few nanoseconds of execution time in your program won’t be noticed by the \nplayer. \nSummary \nThis chapter hasn’t introduced any new Pygame programming concepts that the Memory Puzzle \ngame didn’t use, aside from using the copy() method of Surface objects. Just knowing a few \ndifferent concepts will let you create completely different games. \nFor practice, you can download buggy versions of the Sliding Puzzle program from \nhttp://invpy.com/buggy/slidepuzzle.  \n \n\n\n108    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nCHAPTER 5 – SIMULATE \n \nHow to Play Simulate \nSimulate is a clone of the game Simon. There are four colored buttons on the screen. The buttons \nlight up in a certain random pattern, and then the player must repeat this pattern by pressing the \nbuttons in the correct order. Each time the player successfully simulates the pattern, the pattern \ngets longer. The player tries to match the pattern for as long as possible. \nSource Code to Simulate \nThis source code can be downloaded from http://invpy.com/simulate.py. If you get any error \nmessages, look at the line number that is mentioned in the error message and check your code for \nany typos. You can also copy and paste your code into the web form at \nhttp://invpy.com/diff/simulate to see if the differences between your code and the code in the \nbook. \nYou can download the four sound files that this program uses from: \n \nhttp://invpy.com/beep1.ogg \n \nhttp://invpy.com/beep2.ogg \n \nhttp://invpy.com/beep3.ogg \n \nhttp://invpy.com/beep4.ogg \n  1. # Simulate (a Simon clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n\n\nChapter 5 – Simulate    109 \n \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, sys, time, pygame \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 \n 10. WINDOWWIDTH = 640 \n 11. WINDOWHEIGHT = 480 \n 12. FLASHSPEED = 500 # in milliseconds \n 13. FLASHDELAY = 200 # in milliseconds \n 14. BUTTONSIZE = 200 \n 15. BUTTONGAPSIZE = 20 \n 16. TIMEOUT = 4 # seconds before game over if no button is pushed. \n 17.  \n 18. #                R    G    B \n 19. WHITE        = (255, 255, 255) \n 20. BLACK        = (  0,   0,   0) \n 21. BRIGHTRED    = (255,   0,   0) \n 22. RED          = (155,   0,   0) \n 23. BRIGHTGREEN  = (  0, 255,   0) \n 24. GREEN        = (  0, 155,   0) \n 25. BRIGHTBLUE   = (  0,   0, 255) \n 26. BLUE         = (  0,   0, 155) \n 27. BRIGHTYELLOW = (255, 255,   0) \n 28. YELLOW       = (155, 155,   0) \n 29. DARKGRAY     = ( 40,  40,  40) \n 30. bgColor = BLACK \n 31.  \n 32. XMARGIN = int((WINDOWWIDTH - (2 * BUTTONSIZE) - BUTTONGAPSIZE) / 2) \n 33. YMARGIN = int((WINDOWHEIGHT - (2 * BUTTONSIZE) - BUTTONGAPSIZE) / 2) \n 34.  \n 35. # Rect objects for each of the four buttons \n 36. YELLOWRECT = pygame.Rect(XMARGIN, YMARGIN, BUTTONSIZE, BUTTONSIZE) \n 37. BLUERECT   = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN, \nBUTTONSIZE, BUTTONSIZE) \n 38. REDRECT    = pygame.Rect(XMARGIN, YMARGIN + BUTTONSIZE + BUTTONGAPSIZE, \nBUTTONSIZE, BUTTONSIZE) \n 39. GREENRECT  = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN + \nBUTTONSIZE + BUTTONGAPSIZE, BUTTONSIZE, BUTTONSIZE) \n 40.  \n 41. def main(): \n 42.     global FPSCLOCK, DISPLAYSURF, BASICFONT, BEEP1, BEEP2, BEEP3, BEEP4 \n 43.  \n 44.     pygame.init() \n 45.     FPSCLOCK = pygame.time.Clock() \n 46.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n\n\n110    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 47.     pygame.display.set_caption('Simulate') \n 48.  \n 49.     BASICFONT = pygame.font.Font('freesansbold.ttf', 16) \n 50. \n 51.     infoSurf = BASICFONT.render('Match the pattern by clicking on the \nbutton or using the Q, W, A, S keys.', 1, DARKGRAY) \n 52.     infoRect = infoSurf.get_rect() \n 53.     infoRect.topleft = (10, WINDOWHEIGHT - 25) \n 54.     # load the sound files \n 55.     BEEP1 = pygame.mixer.Sound('beep1.ogg') \n 56.     BEEP2 = pygame.mixer.Sound('beep2.ogg') \n 57.     BEEP3 = pygame.mixer.Sound('beep3.ogg') \n 58.     BEEP4 = pygame.mixer.Sound('beep4.ogg') \n 59.  \n 60.     # Initialize some variables for a new game \n 61.     pattern = [] # stores the pattern of colors \n 62.     currentStep = 0 # the color the player must push next \n 63.     lastClickTime = 0 # timestamp of the player's last button push \n 64.     score = 0 \n 65.     # when False, the pattern is playing. when True, waiting for the \nplayer to click a colored button: \n 66.     waitingForInput = False \n 67.  \n 68.     while True: # main game loop \n 69.         clickedButton = None # button that was clicked (set to YELLOW, \nRED, GREEN, or BLUE) \n 70.         DISPLAYSURF.fill(bgColor) \n 71.         drawButtons() \n 72.  \n 73.         scoreSurf = BASICFONT.render('Score: ' + str(score), 1, WHITE) \n 74.         scoreRect = scoreSurf.get_rect() \n 75.         scoreRect.topleft = (WINDOWWIDTH - 100, 10) \n 76.         DISPLAYSURF.blit(scoreSurf, scoreRect) \n 77.  \n 78.         DISPLAYSURF.blit(infoSurf, infoRect) \n 79.  \n 80.         checkForQuit() \n 81.         for event in pygame.event.get(): # event handling loop \n 82.             if event.type == MOUSEBUTTONUP: \n 83.                 mousex, mousey = event.pos \n 84.                 clickedButton = getButtonClicked(mousex, mousey) \n 85.             elif event.type == KEYDOWN: \n 86.                 if event.key == K_q: \n 87.                     clickedButton = YELLOW \n 88.                 elif event.key == K_w: \n 89.                     clickedButton = BLUE \n\n\nChapter 5 – Simulate    111 \n \n 90.                 elif event.key == K_a: \n 91.                     clickedButton = RED \n 92.                 elif event.key == K_s: \n 93.                     clickedButton = GREEN \n 94. \n 95. \n 96. \n 97.         if not waitingForInput: \n 98.             # play the pattern \n 99.             pygame.display.update() \n100.             pygame.time.wait(1000) \n101.             pattern.append(random.choice((YELLOW, BLUE, RED, GREEN))) \n102.             for button in pattern: \n103.                 flashButtonAnimation(button) \n104.                 pygame.time.wait(FLASHDELAY) \n105.             waitingForInput = True \n106.         else: \n107.             # wait for the player to enter buttons \n108.             if clickedButton and clickedButton == pattern[currentStep]: \n109.                 # pushed the correct button \n110.                 flashButtonAnimation(clickedButton) \n111.                 currentStep += 1 \n112.                 lastClickTime = time.time() \n113. \n114.                 if currentStep == len(pattern): \n115.                     # pushed the last button in the pattern \n116.                     changeBackgroundAnimation() \n117.                     score += 1 \n118.                     waitingForInput = False \n119.                     currentStep = 0 # reset back to first step \n120. \n121.             elif (clickedButton and clickedButton != pattern[currentStep]) \nor (currentStep != 0 and time.time() - TIMEOUT > lastClickTime): \n122.                 # pushed the incorrect button, or has timed out \n123.                 gameOverAnimation() \n124.                 # reset the variables for a new game: \n125.                 pattern = [] \n126.                 currentStep = 0 \n127.                 waitingForInput = False \n128.                 score = 0 \n129.                 pygame.time.wait(1000) \n130.                 changeBackgroundAnimation() \n131. \n132.         pygame.display.update() \n133.         FPSCLOCK.tick(FPS) \n134. \n",
      "page_number": 121,
      "chapter_number": 15,
      "summary": "Chapter 4 – Slide Puzzle    103 \n \nSo instead we will have the for loop iterate from 0 to TILESIZE by several pixels each frame Key topics include board, program, and programming.",
      "keywords": [
        "board",
        "Slide Puzzle",
        "move",
        "BUTTONSIZE",
        "code",
        "program",
        "Puzzle",
        "Slide Puzzle game",
        "list",
        "Memory Puzzle game",
        "pattern",
        "Memory",
        "board data structure",
        "time",
        "Puzzle game"
      ],
      "concepts": [
        "board",
        "program",
        "programming",
        "button",
        "variable",
        "variables",
        "simulators",
        "simulate",
        "pattern",
        "code"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 9,
          "title": "Segment 9 (pages 76-90)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 62,
          "title": "Segment 62 (pages 601-608)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 10,
          "title": "Segment 10 (pages 91-99)",
          "relevance_score": 0.49,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 17,
          "title": "Segment 17 (pages 326-347)",
          "relevance_score": 0.47,
          "method": "api"
        }
      ]
    },
    {
      "number": 16,
      "title": "Segment 16 (pages 130-139)",
      "start_page": 130,
      "end_page": 139,
      "detection_method": "topic_boundary",
      "content": "112    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n135. \n136. def terminate(): \n137.     pygame.quit() \n138.     sys.exit() \n139.  \n140.  \n141. def checkForQuit(): \n142.     for event in pygame.event.get(QUIT): # get all the QUIT events \n143.         terminate() # terminate if any QUIT events are present \n144.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n145.         if event.key == K_ESCAPE: \n146.             terminate() # terminate if the KEYUP event was for the Esc key \n147.         pygame.event.post(event) # put the other KEYUP event objects back \n148. \n149. \n150. def flashButtonAnimation(color, animationSpeed=50): \n151.     if color == YELLOW: \n152.         sound = BEEP1 \n153.         flashColor = BRIGHTYELLOW \n154.         rectangle = YELLOWRECT \n155.     elif color == BLUE: \n156.         sound = BEEP2 \n157.         flashColor = BRIGHTBLUE \n158.         rectangle = BLUERECT \n159.     elif color == RED: \n160.         sound = BEEP3 \n161.         flashColor = BRIGHTRED \n162.         rectangle = REDRECT \n163.     elif color == GREEN: \n164.         sound = BEEP4 \n165.         flashColor = BRIGHTGREEN \n166.         rectangle = GREENRECT \n167. \n168.     origSurf = DISPLAYSURF.copy() \n169.     flashSurf = pygame.Surface((BUTTONSIZE, BUTTONSIZE)) \n170.     flashSurf = flashSurf.convert_alpha() \n171.     r, g, b = flashColor \n172.     sound.play() \n173.     for start, end, step in ((0, 255, 1), (255, 0, -1)): # animation loop \n174.         for alpha in range(start, end, animationSpeed * step): \n175.             checkForQuit() \n176.             DISPLAYSURF.blit(origSurf, (0, 0)) \n177.             flashSurf.fill((r, g, b, alpha)) \n178.             DISPLAYSURF.blit(flashSurf, rectangle.topleft) \n179.             pygame.display.update() \n180.             FPSCLOCK.tick(FPS) \n\n\nChapter 5 – Simulate    113 \n \n181.     DISPLAYSURF.blit(origSurf, (0, 0)) \n182.  \n183.  \n184. def drawButtons(): \n185.     pygame.draw.rect(DISPLAYSURF, YELLOW, YELLOWRECT) \n186.     pygame.draw.rect(DISPLAYSURF, BLUE,   BLUERECT) \n187.     pygame.draw.rect(DISPLAYSURF, RED,    REDRECT) \n188.     pygame.draw.rect(DISPLAYSURF, GREEN,  GREENRECT) \n189. \n190. \n191. def changeBackgroundAnimation(animationSpeed=40): \n192.     global bgColor \n193.     newBgColor = (random.randint(0, 255), random.randint(0, 255), \nrandom.randint(0, 255)) \n194.  \n195.     newBgSurf = pygame.Surface((WINDOWWIDTH, WINDOWHEIGHT)) \n196.     newBgSurf = newBgSurf.convert_alpha() \n197.     r, g, b = newBgColor \n198.     for alpha in range(0, 255, animationSpeed): # animation loop \n199.         checkForQuit() \n200.         DISPLAYSURF.fill(bgColor) \n201.  \n202.         newBgSurf.fill((r, g, b, alpha)) \n203.         DISPLAYSURF.blit(newBgSurf, (0, 0)) \n204.  \n205.         drawButtons() # redraw the buttons on top of the tint \n206.  \n207.         pygame.display.update() \n208.         FPSCLOCK.tick(FPS) \n209.     bgColor = newBgColor \n210. \n211. \n212. def gameOverAnimation(color=WHITE, animationSpeed=50): \n213.     # play all beeps at once, then flash the background \n214.     origSurf = DISPLAYSURF.copy() \n215.     flashSurf = pygame.Surface(DISPLAYSURF.get_size()) \n216.     flashSurf = flashSurf.convert_alpha() \n217.     BEEP1.play() # play all four beeps at the same time, roughly. \n218.     BEEP2.play() \n219.     BEEP3.play() \n220.     BEEP4.play() \n221.     r, g, b = color \n222.     for i in range(3): # do the flash 3 times \n223.         for start, end, step in ((0, 255, 1), (255, 0, -1)): \n224.             # The first iteration in this loop sets the following for loop \n225.             # to go from 0 to 255, the second from 255 to 0. \n\n\n114    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n226.             for alpha in range(start, end, animationSpeed * step): # \nanimation loop \n227.                 # alpha means transparency. 255 is opaque, 0 is invisible \n228.                 checkForQuit() \n229.                 flashSurf.fill((r, g, b, alpha)) \n230.                 DISPLAYSURF.blit(origSurf, (0, 0)) \n231.                 DISPLAYSURF.blit(flashSurf, (0, 0)) \n232.                 drawButtons() \n233.                 pygame.display.update() \n234.                 FPSCLOCK.tick(FPS) \n235.  \n236. \n237. \n238. def getButtonClicked(x, y): \n239.     if YELLOWRECT.collidepoint( (x, y) ): \n240.         return YELLOW \n241.     elif BLUERECT.collidepoint( (x, y) ): \n242.         return BLUE \n243.     elif REDRECT.collidepoint( (x, y) ): \n244.         return RED \n245.     elif GREENRECT.collidepoint( (x, y) ): \n246.         return GREEN \n247.     return None \n248.  \n249.  \n250. if __name__ == '__main__': \n251.     main() \nThe Usual Starting Stuff \n  1. # Simulate (a Simon clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, sys, time, pygame \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 \n 10. WINDOWWIDTH = 640 \n 11. WINDOWHEIGHT = 480 \n 12. FLASHSPEED = 500 # in milliseconds \n 13. FLASHDELAY = 200 # in milliseconds \n 14. BUTTONSIZE = 200 \n 15. BUTTONGAPSIZE = 20 \n 16. TIMEOUT = 4 # seconds before game over if no button is pushed. \n\n\nChapter 5 – Simulate    115 \n \n 17.  \n 18. #                R    G    B \n 19. WHITE        = (255, 255, 255) \n 20. BLACK        = (  0,   0,   0) \n 21. BRIGHTRED    = (255,   0,   0) \n 22. RED          = (155,   0,   0) \n 23. BRIGHTGREEN  = (  0, 255,   0) \n 24. GREEN        = (  0, 155,   0) \n 25. BRIGHTBLUE   = (  0,   0, 255) \n 26. BLUE         = (  0,   0, 155) \n 27. BRIGHTYELLOW = (255, 255,   0) \n 28. YELLOW       = (155, 155,   0) \n 29. DARKGRAY     = ( 40,  40,  40) \n 30. bgColor = BLACK \n 31.  \n 32. XMARGIN = int((WINDOWWIDTH - (2 * BUTTONSIZE) - BUTTONGAPSIZE) / 2) \n 33. YMARGIN = int((WINDOWHEIGHT - (2 * BUTTONSIZE) - BUTTONGAPSIZE) / 2) \nHere we set up the usual constants for things that we might want to modify later such as the size \nof the four buttons, the shades of color used for the buttons (the bright colors are used when the \nbuttons light up) and the amount of time the player has to push the next button in the sequence \nbefore the game times out. \nSetting Up the Buttons \n 35. # Rect objects for each of the four buttons \n 36. YELLOWRECT = pygame.Rect(XMARGIN, YMARGIN, BUTTONSIZE, BUTTONSIZE) \n 37. BLUERECT   = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN, \nBUTTONSIZE, BUTTONSIZE) \n 38. REDRECT    = pygame.Rect(XMARGIN, YMARGIN + BUTTONSIZE + BUTTONGAPSIZE, \nBUTTONSIZE, BUTTONSIZE) \n 39. GREENRECT  = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN + \nBUTTONSIZE + BUTTONGAPSIZE, BUTTONSIZE, BUTTONSIZE) \nJust like the buttons in the Sliding Puzzle games for ―Reset‖, ―Solve‖ and ―New Game‖, the \nSimulate game has four rectangular areas and code to handle when the player clicks inside of \nthose areas. The program will need Rect objects for the areas of the four buttons so it can call the \ncollidepoint() method on them. Lines 36 to 39 set up these Rect objects with the \nappropriate coordinates and sizes. \nThe main() Function \n 41. def main(): \n 42.     global FPSCLOCK, DISPLAYSURF, BASICFONT, BEEP1, BEEP2, BEEP3, BEEP4 \n\n\n116    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 43.  \n 44.     pygame.init() \n 45.     FPSCLOCK = pygame.time.Clock() \n 46.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 47.     pygame.display.set_caption('Simulate') \n 48.  \n 49.     BASICFONT = pygame.font.Font('freesansbold.ttf', 16) \n 50. \n 51.     infoSurf = BASICFONT.render('Match the pattern by clicking on the \nbutton or using the Q, W, A, S keys.', 1, DARKGRAY) \n 52.     infoRect = infoSurf.get_rect() \n 53.     infoRect.topleft = (10, WINDOWHEIGHT - 25) \n 54.     # load the sound files \n 55.     BEEP1 = pygame.mixer.Sound('beep1.ogg') \n 56.     BEEP2 = pygame.mixer.Sound('beep2.ogg') \n 57.     BEEP3 = pygame.mixer.Sound('beep3.ogg') \n 58.     BEEP4 = pygame.mixer.Sound('beep4.ogg') \nThe main() function will implement the bulk of the program and call the other functions as they \nare needed. The usual Pygame setup functions are called to initialize the library, create a Clock \nobject, create a window, set the caption, and create a Font object that will be used to display the \nscore and the instructions on the window. The objects that are created by these function calls will \nbe stored in global variables so that they can be used in other functions. But they are basically \nconstants since the value in them is never changed. \nLines 55 to 58 will load sound files so that Simulate can play sound effects as the player clicks on \neach button. The pygame.mixer.Sound() constructor function will return a Sound object, \nwhich we store in the variables BEEP1 to BEEP4 which were made into global variables on line \n42. \nSome Local Variables Used in This Program \n 60.     # Initialize some variables for a new game \n 61.     pattern = [] # stores the pattern of colors \n 62.     currentStep = 0 # the color the player must push next \n 63.     lastClickTime = 0 # timestamp of the player's last button push \n 64.     score = 0 \n 65.     # when False, the pattern is playing. when True, waiting for the \nplayer to click a colored button: \n 66.     waitingForInput = False \nThe pattern variable will be a list of color values (either YELLOW, RED, BLUE, or GREEN) to \nkeep track of the pattern that the player must memorize. For example, if the value of pattern was \n[RED, RED, YELLOW, RED, BLUE, BLUE, RED, GREEN] then the player would \n\n\nChapter 5 – Simulate    117 \n \nhave to first click the red button twice, then the yellow button, then the red button, and so on until \nthe final green button. As the player finishes each round, a new random color is added to the end \nof the list. \nThe currentStep variable will keep track of which color in the pattern list the player has to \nclick next. If currentStep was 0 and pattern was [GREEN, RED, RED, YELLOW], \nthen the player would have to click the green button. If they clicked on any other button, the code \nwill cause a game over. \nThere is a TIMEOUT constant that makes the player click on next button in the pattern within a \nnumber of seconds, otherwise the code causes a game over. In order to check if enough time has \npassed since the last button click, the lastClickTime variable needs to keep track of the last \ntime the player clicked on a button. (Python has a module named time and a time.time() \nfunction to return the current time. This will be explained later.) \nIt may be hard to believe, but the score variable keeps track of the score. Inconceivable! \nThere are also two modes that our program will be in. Either the program is playing the pattern of \nbuttons for the player (in which case, waitingForInput is set to False), or the program has \nfinished playing the pattern and is waiting for the user to click the buttons in the correct order (in \nwhich case, waitingForInput is set to True). \nDrawing the Board and Handling Input \n 68.     while True: # main game loop \n 69.         clickedButton = None # button that was clicked (set to YELLOW, \nRED, GREEN, or BLUE) \n 70.         DISPLAYSURF.fill(bgColor) \n 71.         drawButtons() \n 72.  \n 73.         scoreSurf = BASICFONT.render('Score: ' + str(score), 1, WHITE) \n 74.         scoreRect = scoreSurf.get_rect() \n 75.         scoreRect.topleft = (WINDOWWIDTH - 100, 10) \n 76.         DISPLAYSURF.blit(scoreSurf, scoreRect) \n 77.  \n 78.         DISPLAYSURF.blit(infoSurf, infoRect) \nLine 68 is the start of the main game loop. The clickedButton will be reset to None at the \nbeginning of each iteration. If a button is clicked during this iteration, then clickedButton \nwill be set to one of the color values to match the button (YELLOW, RED, GREEN, or BLUE). \n\n\n118    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe fill() method is called on line 70 to repaint the entire display Surface so that we can start \ndrawing from scratch. The four colored buttons are drawn with a call to the drawButtons() \n(explained later). Then the text for the score is created on lines 73 to 76. \nThere will also be text that tells the player what their current score is. Unlike the call to the \nrender() method on line 51 for the instruction text, the text for the score changes. It starts off \nas 'Score: 0' and then becomes 'Score: 1' and then 'Score: 2' and so on. This is \nwhy we create new Surface objects by calling the render() method on line 73 inside the game \nloop. Since the instruction text (―Match the pattern by…‖) never changes, we only need one call \nto render() outside the game loop on line 50. \nChecking for Mouse Clicks \n 80.         checkForQuit() \n 81.         for event in pygame.event.get(): # event handling loop \n 82.             if event.type == MOUSEBUTTONUP: \n 83.                 mousex, mousey = event.pos \n 84.                 clickedButton = getButtonClicked(mousex, mousey) \nLine 80 does a quick check for any QUIT events, and then line 81 is the start of the event \nhandling loop. The XY coordinates of any mouse clicks will be stored in the mousex and \nmousey variables. If the mouse click was over one of the four buttons, then our \ngetButtonClicked() function will return a Color object of the button clicked (otherwise it \nreturns None). \nChecking for Keyboard Presses \n 85.             elif event.type == KEYDOWN: \n 86.                 if event.key == K_q: \n 87.                     clickedButton = YELLOW \n 88.                 elif event.key == K_w: \n 89.                     clickedButton = BLUE \n 90.                 elif event.key == K_a: \n 91.                     clickedButton = RED \n 92.                 elif event.key == K_s: \n 93.                     clickedButton = GREEN \nLines 85 to 93 check for any KEYDOWN events (created when the user presses a key on the \nkeyboard). The Q, W, A, and S keys correspond to the buttons because they are arranged in a \nsquare shape on the keyboard. \nThe Q key is in the upper left of the four keyboard keys, just like the yellow button on the screen \nis in the upper left, so we will make pressing the Q key the same as clicking on the yellow button. \n\n\nChapter 5 – Simulate    119 \n \nWe can do this by setting the clickedButton variable to the value in the constant variable \nYELLOW. We can do the same for the three other keys. This way, the user can play Simulate with \neither the mouse or keyboard. \nThe Two States of the Game Loop \n 97.         if not waitingForInput: \n 98.             # play the pattern \n 99.             pygame.display.update() \n100.             pygame.time.wait(1000) \n101.             pattern.append(random.choice((YELLOW, BLUE, RED, GREEN))) \n102.             for button in pattern: \n103.                 flashButtonAnimation(button) \n104.                 pygame.time.wait(FLASHDELAY) \n105.             waitingForInput = True \nThere are two different ―modes‖ or ―states‖ that the program can be in. When \nwaitingForInput is False, the program will be displaying the animation for the pattern. \nWhen waitingForInput is True, the program will be waiting for the user to select buttons. \nLines 97 to 105 will cover the case where the program displays the pattern animation. Since this \nis done at the start of the game or when the player finishes a pattern, line 101 will add a random \ncolor to the pattern list to make the pattern one step longer. Then lines 102 to 104 loops through \neach of the values in the pattern list and calls flashButtonAnimation() which makes that \nbutton light up. After it is done lighting up all the buttons in the pattern list, the program sets the \nwaitingForInput variable to True. \nFiguring Out if the Player Pressed the Right Buttons \n106.         else: \n107.             # wait for the player to enter buttons \n108.             if clickedButton and clickedButton == pattern[currentStep]: \n109.                 # pushed the correct button \n110.                 flashButtonAnimation(clickedButton) \n111.                 currentStep += 1 \n112.                 lastClickTime = time.time() \nIf waitingForInput is True, then the code in line 106’s else statement will execute. Line \n108 checks if the player has clicked on a button during this iteration of the game loop and if that \nbutton was the correct one. The currentStep variable keeps track of the index in the pattern \nlist for the button that the player should click on next. \n\n\n120    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nFor example, if pattern was set to [YELLOW, RED, RED] and the currentStep variable \nwas set to 0 (like it would be when the player first starts the game), then the correct button for the \nplayer to click would be pattern[0] (the yellow button). \nIf the player has clicked on the correct button, we want to flash the button the player clicked by \ncalling flashButtonAnimation() then, increase the currentStep to the next step, and \nthen update the lastClickTime variable to the current time. (The time.time() function \nreturns a float value of the number of seconds since January 1st, 1970, so we can use it to keep \ntrack of time.) \n114.                 if currentStep == len(pattern): \n115.                     # pushed the last button in the pattern \n116.                     changeBackgroundAnimation() \n117.                     score += 1 \n118.                     waitingForInput = False \n119.                     currentStep = 0 # reset back to first step \nLines 114 to 119 are inside the else statement that started on line 106. If the execution is inside \nthat else statement, we know the player clicked on a button and also it was the correct button. \nLine 114 checks if this was the last correct button in the pattern list by checking if the integer \nstored in currentStep is equal to the number of values inside the pattern list. \nIf this is True, then we want to change the background color by calling our \nchangeBackgroundAnimation(). This is a simple way to let the player know they have \nentered the entire pattern correctly. The score is incremented, currentStep is set back to 0, \nand the waitingForInput variable is set to False so that on the next iteration of the game \nloop the code will add a new Color value to the pattern list and then flash the buttons. \n121.             elif (clickedButton and clickedButton != pattern[currentStep]) \nor (currentStep != 0 and time.time() - TIMEOUT > lastClickTime): \nIf the player did not click on the correct button, the elif statement on line 121 handles the case \nwhere either the player clicked on the wrong button or the player has waited too long to click on a \nbutton. Either way, we need to show the ―game over‖ animation and start a new game. \nThe (clickedButton and clickedButton != pattern[currentStep]) part of \nthe elif statement’s condition checks if a button was clicked and was the wrong button to click. \nYou can compare this to line 108’s if statement’s condition clickedButton and \nclickedButton == pattern[currentStep] which evaluates to True if the player \nclicked a button and it was the correct button to click. \n\n\nChapter 5 – Simulate    121 \n \nThe other part of line 121’s elif condition is (currentStep != 0 and time.time() \n- TIMEOUT > lastClickTime). This handles making sure the player did not ―time out‖. \nNotice that this part of the condition has two expressions connected by an and keyword. That \nmeans both sides of the and keyword need to evaluate to True. \nIn order to ―time out‖, it must not be the player’s first button click. But once they’ve started to \nclick buttons, they must keep clicking the buttons quickly enough until they’ve entered the entire \npattern (or have clicked on the wrong pattern and gotten a ―game over‖). If currentStep != \n0 is True, then we know the player has begun clicking the buttons. \nEpoch Time \nAlso in order to ―time out‖, the current time (returned by time.time()) minus four seconds \n(because 4 is stored in TIMEOUT) must be greater than the last time clicked a button (stored in \nlastClickTime). The reason why time.time() - TIMEOUT > lastClickTime \nworks has to do with how epoch time works. Epoch time (also called Unix epoch time) is the \nnumber of seconds it has been since January 1st, 1970. This date is called the Unix epoch. \nFor example, when I run time.time() from the interactive shell (don’t forget to import the \ntime module first), it looks like this: \n>>> import time \n>>> time.time() \n1320460242.118 \nWhat this number means is that the moment the time.time() function was called was a little \nover 1,320,460,242 seconds since midnight of January 1st, 1970. (This translates to November 4th, \n2011 at 7:30:42pm. You can learn how to convert from Unix epoch time to regular English time \nat http://invpy.com/epochtime) \nIf I call time.time() from the interactive shell a few seconds later, it might look like this: \n>>> time.time() \n1320460261.315 \n1320460261.315 seconds after midnight of the Unix epoch is November 4th, 2011 at 7:31:01pm. \n(Actually, it’s 7:31 and 0.315 seconds if you want to be precise.) \nDealing with time would be difficult if we had to deal with strings. It’s hard to tell that 19 \nseconds have passed if we only had the string values '7:30:42 PM' and '7:31:01 PM' to \ncompare. But with epoch time, it’s just a matter of subtracting the integers 1320460261.315 \n- 1320460242.118, which evaluates to 19.197000026702881. This value is the number \n",
      "page_number": 130,
      "chapter_number": 16,
      "summary": "This chapter covers segment 16 (pages 130-139). Key topics include buttons, time, and pattern. Covers pattern. pygame.event.post(event) # put the other KEYUP event objects back \n148.",
      "keywords": [
        "button",
        "pattern",
        "player",
        "RED",
        "BUTTONSIZE",
        "yellow button",
        "YELLOW",
        "time",
        "line",
        "game",
        "GREEN",
        "correct button",
        "color",
        "BLUE",
        "red button"
      ],
      "concepts": [
        "buttons",
        "time",
        "pattern",
        "color",
        "event",
        "variables",
        "variable",
        "key",
        "keys",
        "lines"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "Segment 11 (pages 100-107)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.53,
          "method": "api"
        }
      ]
    },
    {
      "number": 17,
      "title": "Segment 17 (pages 140-147)",
      "start_page": 140,
      "end_page": 147,
      "detection_method": "topic_boundary",
      "content": "122    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nof seconds between those two times. (The extra 0.000026702881 comes from very small \nrounding errors that happen when you do math with floating point numbers. They only happen \nsometimes and are usually too tiny to matter. You can learn more about floating point rounding \nerrors at http://invpy.com/roundingerrors.) \nGoing back to line 121, if time.time() - TIMEOUT > lastClickTime evaluates to \nTrue, then it has been longer than 4 seconds since time.time() was called and stored in \nlastClickTime. If it evaluates to False, then it has been less than 4 seconds. \n122.                 # pushed the incorrect button, or has timed out \n123.                 gameOverAnimation() \n124.                 # reset the variables for a new game: \n125.                 pattern = [] \n126.                 currentStep = 0 \n127.                 waitingForInput = False \n128.                 score = 0 \n129.                 pygame.time.wait(1000) \n130.                 changeBackgroundAnimation() \nIf either the player clicked on the wrong button or has timed out, the program should play the \n―game over‖ animation and then reset the variables for a new game. This involves setting the \npattern list to a blank list, currentStep to 0, waitingForInput to False, and then \nscore to 0. A small pause and a new background color will be set to indicate to the player the \nstart of a new game, which will begin on the next iteration of the game loop. \nDrawing the Board to the Screen \n132.         pygame.display.update() \n133.         FPSCLOCK.tick(FPS) \nJust like the other game programs, the last thing done in the game loop is drawing the display \nSurface object to the screen and calling the tick() method. \nSame Old terminate() Function \n136. def terminate(): \n137.     pygame.quit() \n138.     sys.exit() \n139.  \n140.  \n141. def checkForQuit(): \n142.     for event in pygame.event.get(QUIT): # get all the QUIT events \n143.         terminate() # terminate if any QUIT events are present \n144.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n\n\nChapter 5 – Simulate    123 \n \n145.         if event.key == K_ESCAPE: \n146.             terminate() # terminate if the KEYUP event was for the Esc key \n147.         pygame.event.post(event) # put the other KEYUP event objects back \nThe terminate() and checkForQuit() functions were used and explained in the Sliding \nPuzzle chapter, so we will skip describing them again. \nReusing The Constant Variables \n150. def flashButtonAnimation(color, animationSpeed=50): \n151.     if color == YELLOW: \n152.         sound = BEEP1 \n153.         flashColor = BRIGHTYELLOW \n154.         rectangle = YELLOWRECT \n155.     elif color == BLUE: \n156.         sound = BEEP2 \n157.         flashColor = BRIGHTBLUE \n158.         rectangle = BLUERECT \n159.     elif color == RED: \n160.         sound = BEEP3 \n161.         flashColor = BRIGHTRED \n162.         rectangle = REDRECT \n163.     elif color == GREEN: \n164.         sound = BEEP4 \n165.         flashColor = BRIGHTGREEN \n166.         rectangle = GREENRECT \nDepending on which Color value is passed as an argument for the color parameter, the sound, \ncolor of the bright flash, and rectangular area of the flash will be different. Line 151 to 166 sets \nthree local variables differently depending on the value in the color parameter: sound, \nflashColor, and rectangle. \nAnimating the Button Flash \n168.     origSurf = DISPLAYSURF.copy() \n169.     flashSurf = pygame.Surface((BUTTONSIZE, BUTTONSIZE)) \n170.     flashSurf = flashSurf.convert_alpha() \n171.     r, g, b = flashColor \n172.     sound.play() \nThe process of animating the button flash is simple: On each frame of the animation, the normal \nboard is drawn and then on top of that, the bright color version of the button that is flashing is \ndrawn over the button. The alpha value of the bright color starts off at 0 for the first frame of \nanimation, but then on each frame after the alpha value is slowly increased until it is fully opaque \n\n\n124    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nand the bright color version completely paints over the normal button color. This will make it \nlook like the button is slowly brightening up. \nThe brightening up is the first half of the animation. The second half is the button dimming. This \nis done with the same code, except that instead of the alpha value increasing for each frame, it \nwill be decreasing. As the alpha value gets lower and lower, the bright color painted on top will \nbecome more and more invisible, until only the original board with the dull colors is visible. \nTo do this in code, line 168 creates a copy of the display Surface object and stores it in \norigSurf. Line 169 creates a new Surface object the size of a single button and stores it in \nflashSurf. The convert_alpha() method is called on flashSurf so that the Surface \nobject can have transparent colors drawn on it (otherwise, the alpha value in the Color objects we \nuse will be ignored and automatically assumed to be 255). In your own game programs, if you are \nhaving trouble getting color transparency to work, make sure that you have called the \nconvert_alpha() method on any Surface objects that have transparent colors painted on \nthem. \nLine 171 creates individual local variables named r, g, and b to store the individual RGB values \nof the tuple stored in flashColor. This is just some syntactic sugar that makes the rest of the \ncode in this function easier to read. Before we begin animating the button flash, line 172 will play \nthe sound effect for that button. The program execution keeps going after the sound effect has \nstarted to play, so the sound will be playing during the button flash animation. \n173.     for start, end, step in ((0, 255, 1), (255, 0, -1)): # animation loop \n174.         for alpha in range(start, end, animationSpeed * step): \n175.             checkForQuit() \n176.             DISPLAYSURF.blit(origSurf, (0, 0)) \n177.             flashSurf.fill((r, g, b, alpha)) \n178.             DISPLAYSURF.blit(flashSurf, rectangle.topleft) \n179.             pygame.display.update() \n180.             FPSCLOCK.tick(FPS) \n181.     DISPLAYSURF.blit(origSurf, (0, 0)) \nRemember that to do the animation, we want to first draw the flashSurf with color that has \nincreasing alpha values from 0 to 255 to do the brightening part of the animation. Then to do the \ndimming, we want the alpha value to go from 255 to 0. We could do that with code like this: \n    for alpha in range(0, 255, animationSpeed): # brightening \n        checkForQuit() \n        DISPLAYSURF.blit(origSurf, (0, 0)) \n        flashSurf.fill((r, g, b, alpha)) \n        DISPLAYSURF.blit(flashSurf, rectangle.topleft) \n\n\nChapter 5 – Simulate    125 \n \n        pygame.display.update() \n        FPSCLOCK.tick(FPS) \n    for alpha in range(255, 0, -animationSpeed): # dimming \n        checkForQuit() \n        DISPLAYSURF.blit(origSurf, (0, 0)) \n        flashSurf.fill((r, g, b, alpha)) \n        DISPLAYSURF.blit(flashSurf, rectangle.topleft) \n        pygame.display.update() \n        FPSCLOCK.tick(FPS) \nBut notice that the code inside the for loops handles drawing the frame and are identical to each \nother. If we wrote the code like the above, then the first for loop would handle the brightening \npart of the animation (where the alpha value goes from 0 to 255) and the second for loop would \nhandle the dimming part of the animation (where the alpha values goes from 255 to 0). Note that \nfor the second for loop, the third argument to the range() call is a negative number. \nWhenever we have identical code like this, we can probably shorten our code so we don’t have to \nrepeat it. This is what we do with the for loop on line 173, which supplies different values for \nthe range() call on line 174: \n173.     for start, end, step in ((0, 255, 1), (255, 0, -1)): # animation loop \n174.         for alpha in range(start, end, animationSpeed * step): \nOn the first iteration of line 173’s for loop, start is set to 0, end is set to 255, and step is \nset to 1. This way, when the for loop on line 174 is executed, it is calling range(0, 255, \nanimationSpeed). (Note that animationSpeed * 1 is the same as animationSpeed. \nMultiplying a number by 1 gives us the same number.) \nLine 174’s for loop then executes and performs the brightening animation. \nOn the second iteration of line 173’s for loop (there are always two and only two iterations of \nthis inner for loop), start is set to 255, end is set to 0, and step is set to -1. When the line \n174’s for loop is executed, it is calling range(255, 0, -animationSpeed). (Note that \nanimationSpeed * -1 evaluates to -animationSpeed, since multiplying any number \nby -1 returns the negative form of that same number.) \nThis way, we don’t have to have two separate for loops and repeat all the code that is inside of \nthem. Here’s the code again that is inside line 174’s for loop: \n175.             checkForQuit() \n176.             DISPLAYSURF.blit(origSurf, (0, 0)) \n177.             flashSurf.fill((r, g, b, alpha)) \n\n\n126    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n178.             DISPLAYSURF.blit(flashSurf, rectangle.topleft) \n179.             pygame.display.update() \n180.             FPSCLOCK.tick(FPS) \n181.     DISPLAYSURF.blit(origSurf, (0, 0)) \nWe check for any QUIT events (in case the user tried to close the program during the animation), \nthen blit the origSurf Surface to the display Surface. Then we paint the flashSurf Surface \nby calling fill() (supplying the r, g, b values of the color we got on line 171 and the alpha \nvalue that the for loop sets in the alpha variable). Then the flashSurf Surface is blitted to \nthe display Surface.  \nThen, to make the display Surface appear on the screen, pygame.display.update() is \ncalled on line 179. To make sure the animation doesn’t play as fast as the computer can draw it, \nwe add short pauses with a call to the tick() method. (If you want to see the flashing animation \nplay very slowly, put a low number like 1 or 2 as the argument to tick() instead of FPS.) \nDrawing the Buttons \n184. def drawButtons(): \n185.     pygame.draw.rect(DISPLAYSURF, YELLOW, YELLOWRECT) \n186.     pygame.draw.rect(DISPLAYSURF, BLUE,   BLUERECT) \n187.     pygame.draw.rect(DISPLAYSURF, RED,    REDRECT) \n188.     pygame.draw.rect(DISPLAYSURF, GREEN,  GREENRECT) \nSince each of the buttons is just a rectangle of a certain color in a certain place, we just make four \ncalls to pygame.draw.rect() to draw the buttons on the display Surface. The Color object \nand the Rect object we use to position them never change, which is why we stored them in \nconstant variables like YELLOW and YELLOWRECT. \nAnimating the Background Change \n191. def changeBackgroundAnimation(animationSpeed=40): \n192.     global bgColor \n193.     newBgColor = (random.randint(0, 255), random.randint(0, 255), \nrandom.randint(0, 255)) \n194.  \n195.     newBgSurf = pygame.Surface((WINDOWWIDTH, WINDOWHEIGHT)) \n196.     newBgSurf = newBgSurf.convert_alpha() \n197.     r, g, b = newBgColor \n198.     for alpha in range(0, 255, animationSpeed): # animation loop \n199.         checkForQuit() \n200.         DISPLAYSURF.fill(bgColor) \n201.  \n202.         newBgSurf.fill((r, g, b, alpha)) \n\n\nChapter 5 – Simulate    127 \n \n203.         DISPLAYSURF.blit(newBgSurf, (0, 0)) \n204.  \n205.         drawButtons() # redraw the buttons on top of the tint \n206.  \n207.         pygame.display.update() \n208.         FPSCLOCK.tick(FPS) \n209.     bgColor = newBgColor \nThe background color change animation happens whenever the player finishes entering the entire \npattern correctly. On each iteration through the loop which starts on line 198 the entire display \nSurface has to be redrawn (blended with a less and less transparent new background color, until \nthe background is completely covered by the new color). The steps done on each iteration of the \nloop are: \n \nLine 200 fills in the entire display Surface (stored in DISPLAYSURF) with the old \nbackground color (which is stored in bgColor). \n \nLine 202 fills in a different Surface object (stored in newBgSurf) with the new \nbackground color’s RGB values (and the alpha transparency value changes on each \niteration since that is what the for loop on line 198 does). \n \nLine 203 then draws the newBgSurf Surface to the display Surface in DISPLAYSURF. \nThe reason we didn’t just paint our semitransparent new background color on \nDISPLAYSURF to begin with is because the fill() method will just replace the color \non the Surface, whereas the blit() method will blend the colors. \n \nNow that we have the background the way we want it, we’ll draw the buttons over it with \na call to drawButtons() on line 205.  \n \nLine 207 and 208 then just draws the display Surface to the screen and adds a pause. \nThe reason there is a global statement at the beginning of the \nchangeBackgroundAnimation() function is for the bgColor variable is because this \nfunction modifies the content of the variable with an assignment statement on line 209. Any \nfunction can read the value of a global variable without specifying the global statement.  \nIf that function assigns a value to a global variable without a global statement, then Python \nconsiders that variable to be a local variable that just happens to have the same name as a global \nvariable. The main() function uses the bgColor variable but doesn’t need a global statement \nfor it because it only reads the contents of the bgColor the main() function never assigns \nbgColor a new value. This concept is explained in more detail at http://invpy.com/global. \nThe Game Over Animation \n212. def gameOverAnimation(color=WHITE, animationSpeed=50): \n\n\n128    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n213.     # play all beeps at once, then flash the background \n214.     origSurf = DISPLAYSURF.copy() \n215.     flashSurf = pygame.Surface(DISPLAYSURF.get_size()) \n216.     flashSurf = flashSurf.convert_alpha() \n217.     BEEP1.play() # play all four beeps at the same time, roughly. \n218.     BEEP2.play() \n219.     BEEP3.play() \n220.     BEEP4.play() \n221.     r, g, b = color \n222.     for i in range(3): # do the flash 3 times \nEach of the iterations of the for loop on the next line (line 223 below) will perform a flash. To \nhave three flashes done, we put all of that code in a for loop that has three iterations. If you want \nmore or fewer flashes, then change the integer that is passed to range() on line 222. \n223.         for start, end, step in ((0, 255, 1), (255, 0, -1)): \nThe for loop on line 223 is exactly the same as the one line 173. The start, end, and step \nvariables will be used on the next for loop (on line 224) to control how the alpha variable \nchanges. Reread the ―Animating the Button Flash‖ section if you need to refresh yourself on how \nthese loops work. \n224.             # The first iteration in this loop sets the following for loop \n225.             # to go from 0 to 255, the second from 255 to 0. \n226.             for alpha in range(start, end, animationSpeed * step): # \nanimation loop \n227.                 # alpha means transparency. 255 is opaque, 0 is invisible \n228.                 checkForQuit() \n229.                 flashSurf.fill((r, g, b, alpha)) \n230.                 DISPLAYSURF.blit(origSurf, (0, 0)) \n231.                 DISPLAYSURF.blit(flashSurf, (0, 0)) \n232.                 drawButtons() \n233.                 pygame.display.update() \n234.                 FPSCLOCK.tick(FPS) \nThis animation loop works the same as the previous flashing animation code in the ―Animating \nthe Background Change‖ section. The copy of the original Surface object stored in origSurf is \ndrawn on the display Surface, then flashSurf (which has the new flashing color painted on it) \nis blitted on top of the display Surface. After the background color is set up, the buttons are drawn \non top on line 232. Finally the display Surface is drawn to the screen with the call to \npygame.display.update(). \n\n\nChapter 5 – Simulate    129 \n \nThe for loop on line 226 adjusts the alpha value for the color used for each frame of animation \n(increasing at first, and then decreasing). \nConverting from Pixel Coordinates to Buttons \n238. def getButtonClicked(x, y): \n239.     if YELLOWRECT.collidepoint( (x, y) ): \n240.         return YELLOW \n241.     elif BLUERECT.collidepoint( (x, y) ): \n242.         return BLUE \n243.     elif REDRECT.collidepoint( (x, y) ): \n244.         return RED \n245.     elif GREENRECT.collidepoint( (x, y) ): \n246.         return GREEN \n247.     return None \n248.  \n249.  \n250. if __name__ == '__main__': \n251.     main() \nThe getButtonClicked() function simply takes XY pixel coordinates and returns either the \nvalues YELLOW, BLUE, RED, or GREEN if one of the buttons was clicked, or returns None if the \nXY pixel coordinates are not over any of the four buttons. \nExplicit is Better Than Implicit \nYou may have noticed that the code for getButtonClicked() ends with a return None \nstatement on line 247. This might seem like an odd thing to type out, since all functions return \nNone if they don’t have any return statement at all. We could have left line 47 out entirely and \nthe program would have worked the exact same way. So why bother writing it in? \nNormally when a function reaches the end and returns the None value implicitly (that is, there is \nno return statement outright saying that it is returning None) the code that calls it doesn’t care \nabout the return value. All function calls have to return a value (so that they can evaluate to \nsomething and be part of expressions), but our code doesn’t always make use of the return value. \nFor example, think about the print() function. Technically, this function returns the None \nvalue, but we never care about it: \n>>> spam = print('Hello') \nHello \n>>> spam == None \nTrue \n>>> \n",
      "page_number": 140,
      "chapter_number": 17,
      "summary": "This chapter covers segment 17 (pages 140-147). Key topics include color, function, and functions. # reset the variables for a new game: \n125.",
      "keywords": [
        "display Surface",
        "line",
        "Surface",
        "color",
        "alpha",
        "loop",
        "Surface object",
        "animation",
        "background color",
        "button",
        "animation loop",
        "display Surface object",
        "animationSpeed",
        "Button Flash",
        "code"
      ],
      "concepts": [
        "color",
        "function",
        "functions",
        "line",
        "value",
        "animation",
        "animating",
        "surface",
        "flash",
        "flashes"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 3,
          "title": "Segment 3 (pages 42-63)",
          "relevance_score": 0.62,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 40,
          "title": "Segment 40 (pages 809-829)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.6,
          "method": "api"
        }
      ]
    },
    {
      "number": 18,
      "title": "Segment 18 (pages 148-160)",
      "start_page": 148,
      "end_page": 160,
      "detection_method": "topic_boundary",
      "content": "130    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nHowever, when getButtonClicked() returns None, it means that the coordinates that were \npassed to it were not over any of the four buttons. To make it clear that in this case the value \nNone is returned from getButtonClicked(), we have the return None line at the end of \nthe function. \nTo make your code more readable, it is better to have your code be explicit (that is, clearly state \nsomething even if it might be obvious) rather than implicit (that is, leaving it up to the person \nreading code to know how it works without outright telling them). In fact, ―explicit is better than \nimplicit‖ is one of the Python Koans.  \nThe koans are a group of little sayings about how to write good code. There’s an Easter egg (that \nis, a little hidden surprise) in the Python interactive shell where if you try to import a module \nnamed this, then it will display ―The Zen of Python‖ koans. Try it out in the interactive shell: \n>>> import this \nThe Zen of Python, by Tim Peters \n \nBeautiful is better than ugly. \nExplicit is better than implicit. \nSimple is better than complex. \nComplex is better than complicated. \nFlat is better than nested. \nSparse is better than dense. \nReadability counts. \nSpecial cases aren't special enough to break the rules. \nAlthough practicality beats purity. \nErrors should never pass silently. \nUnless explicitly silenced. \nIn the face of ambiguity, refuse the temptation to guess. \nThere should be one-- and preferably only one --obvious way to do it. \nAlthough that way may not be obvious at first unless you're Dutch. \nNow is better than never. \nAlthough never is often better than *right* now. \nIf the implementation is hard to explain, it's a bad idea. \nIf the implementation is easy to explain, it may be a good idea. \nNamespaces are one honking great idea -- let's do more of those! \nIf you’d like to know more about what these individual koans mean, visit http://invpy.com/zen. \n \n \n\n\nChapter 6 – Wormy    131 \n \nCHAPTER 6 – WORMY \n \n \nHow to Play Wormy \nWormy is a Nibbles clone. The player starts out controlling a short worm that is constantly \nmoving around the screen. The player cannot stop or slow down the worm, but they can control \nwhich direction it turns. A red apple appears randomly on the screen, and the player must move \nthe worm so that it eats the apple. Each time the worm eats an apple, the worm grows longer by \none segment and a new apply randomly appears on the screen. The game is over if the worm \ncrashes into itself or the edges of the screen. \nSource Code to Wormy \nThis source code can be downloaded from http://invpy.com/wormy.py. If you get any error \nmessages, look at the line number that is mentioned in the error message and check your code for \nany typos. You can also copy and paste your code into the web form at \nhttp://invpy.com/diff/wormy to see if the differences between your code and the code in the book. \n  1. # Wormy (a Nibbles clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, pygame, sys \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 15 \n 10. WINDOWWIDTH = 640 \n 11. WINDOWHEIGHT = 480 \n\n\n132    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 12. CELLSIZE = 20 \n 13. assert WINDOWWIDTH % CELLSIZE == 0, \"Window width must be a multiple of \ncell size.\" \n 14. assert WINDOWHEIGHT % CELLSIZE == 0, \"Window height must be a multiple of \ncell size.\" \n 15. CELLWIDTH = int(WINDOWWIDTH / CELLSIZE) \n 16. CELLHEIGHT = int(WINDOWHEIGHT / CELLSIZE) \n 17.  \n 18. #             R    G    B \n 19. WHITE     = (255, 255, 255) \n 20. BLACK     = (  0,   0,   0) \n 21. RED       = (255,   0,   0) \n 22. GREEN     = (  0, 255,   0) \n 23. DARKGREEN = (  0, 155,   0) \n 24. DARKGRAY  = ( 40,  40,  40) \n 25. BGCOLOR = BLACK \n 26.  \n 27. UP = 'up' \n 28. DOWN = 'down' \n 29. LEFT = 'left' \n 30. RIGHT = 'right' \n 31.  \n 32. HEAD = 0 # syntactic sugar: index of the worm's head \n 33.  \n 34. def main(): \n 35.     global FPSCLOCK, DISPLAYSURF, BASICFONT \n 36.  \n 37.     pygame.init() \n 38.     FPSCLOCK = pygame.time.Clock() \n 39.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 40.     BASICFONT = pygame.font.Font('freesansbold.ttf', 18) \n 41.     pygame.display.set_caption('Wormy') \n 42.  \n 43.     showStartScreen() \n 44.     while True: \n 45.         runGame() \n 46.         showGameOverScreen() \n 47.  \n 48.  \n 49. def runGame(): \n 50.     # Set a random start point. \n 51.     startx = random.randint(5, CELLWIDTH - 6) \n 52.     starty = random.randint(5, CELLHEIGHT - 6) \n 53.     wormCoords = [{'x': startx,     'y': starty}, \n 54.                   {'x': startx - 1, 'y': starty}, \n 55.                   {'x': startx - 2, 'y': starty}] \n\n\nChapter 6 – Wormy    133 \n \n 56.     direction = RIGHT \n 57.  \n 58.     # Start the apple in a random place. \n 59.     apple = getRandomLocation() \n 60.  \n 61.     while True: # main game loop \n 62.         for event in pygame.event.get(): # event handling loop \n 63.             if event.type == QUIT: \n 64.                 terminate() \n 65.             elif event.type == KEYDOWN: \n 66.                 if (event.key == K_LEFT or event.key == K_a) and direction \n!= RIGHT: \n 67.                     direction = LEFT \n 68.                 elif (event.key == K_RIGHT or event.key == K_d) and \ndirection != LEFT: \n 69.                     direction = RIGHT \n 70.                 elif (event.key == K_UP or event.key == K_w) and direction \n!= DOWN: \n 71.                     direction = UP \n 72.                 elif (event.key == K_DOWN or event.key == K_s) and \ndirection != UP: \n 73.                     direction = DOWN \n 74.                 elif event.key == K_ESCAPE: \n 75.                     terminate() \n 76.  \n 77.         # check if the worm has hit itself or the edge \n 78.         if wormCoords[HEAD]['x'] == -1 or wormCoords[HEAD]['x'] == \nCELLWIDTH or wormCoords[HEAD]['y'] == -1 or wormCoords[HEAD]['y'] == \nCELLHEIGHT: \n 79.             return # game over \n 80.         for wormBody in wormCoords[1:]: \n 81.             if wormBody['x'] == wormCoords[HEAD]['x'] and wormBody['y'] == \nwormCoords[HEAD]['y']: \n 82.                 return # game over \n 83.  \n 84.         # check if worm has eaten an apply \n 85.         if wormCoords[HEAD]['x'] == apple['x'] and wormCoords[HEAD]['y'] \n== apple['y']: \n 86.             # don't remove worm's tail segment \n 87.             apple = getRandomLocation() # set a new apple somewhere \n 88.         else: \n 89.             del wormCoords[-1] # remove worm's tail segment \n 90.  \n 91.         # move the worm by adding a segment in the direction it is moving \n 92.         if direction == UP: \n\n\n134    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 93.             newHead = {'x': wormCoords[HEAD]['x'], 'y': \nwormCoords[HEAD]['y'] - 1} \n 94.         elif direction == DOWN: \n 95.             newHead = {'x': wormCoords[HEAD]['x'], 'y': \nwormCoords[HEAD]['y'] + 1} \n 96.         elif direction == LEFT: \n 97.             newHead = {'x': wormCoords[HEAD]['x'] - 1, 'y': \nwormCoords[HEAD]['y']} \n 98.         elif direction == RIGHT: \n 99.             newHead = {'x': wormCoords[HEAD]['x'] + 1, 'y': \nwormCoords[HEAD]['y']} \n100.         wormCoords.insert(0, newHead) \n101.         DISPLAYSURF.fill(BGCOLOR) \n102.         drawGrid() \n103.         drawWorm(wormCoords) \n104.         drawApple(apple) \n105.         drawScore(len(wormCoords) - 3) \n106.         pygame.display.update() \n107.         FPSCLOCK.tick(FPS) \n108.  \n109. def drawPressKeyMsg(): \n110.     pressKeySurf = BASICFONT.render('Press a key to play.', True, \nDARKGRAY) \n111.     pressKeyRect = pressKeySurf.get_rect() \n112.     pressKeyRect.topleft = (WINDOWWIDTH - 200, WINDOWHEIGHT - 30) \n113.     DISPLAYSURF.blit(pressKeySurf, pressKeyRect) \n114.  \n115. \n116. def checkForKeyPress(): \n117.     if len(pygame.event.get(QUIT)) > 0: \n118.         terminate() \n119.  \n120.     keyUpEvents = pygame.event.get(KEYUP) \n121.     if len(keyUpEvents) == 0: \n122.         return None \n123.     if keyUpEvents[0].key == K_ESCAPE: \n124.         terminate() \n125.     return keyUpEvents[0].key \n126. \n127. \n128. def showStartScreen(): \n129.     titleFont = pygame.font.Font('freesansbold.ttf', 100) \n130.     titleSurf1 = titleFont.render('Wormy!', True, WHITE, DARKGREEN) \n131.     titleSurf2 = titleFont.render('Wormy!', True, GREEN) \n132.  \n133.     degrees1 = 0 \n\n\nChapter 6 – Wormy    135 \n \n134.     degrees2 = 0 \n135.     while True: \n136.         DISPLAYSURF.fill(BGCOLOR) \n137.         rotatedSurf1 = pygame.transform.rotate(titleSurf1, degrees1) \n138.         rotatedRect1 = rotatedSurf1.get_rect() \n139.         rotatedRect1.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2) \n140.         DISPLAYSURF.blit(rotatedSurf1, rotatedRect1) \n141.  \n142.         rotatedSurf2 = pygame.transform.rotate(titleSurf2, degrees2) \n143.         rotatedRect2 = rotatedSurf2.get_rect() \n144.         rotatedRect2.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2) \n145.         DISPLAYSURF.blit(rotatedSurf2, rotatedRect2) \n146.  \n147.         drawPressKeyMsg() \n148.  \n149.         if checkForKeyPress(): \n150.             pygame.event.get() # clear event queue \n151.             return \n152.         pygame.display.update() \n153.         FPSCLOCK.tick(FPS) \n154.         degrees1 += 3 # rotate by 3 degrees each frame \n155.         degrees2 += 7 # rotate by 7 degrees each frame \n156.  \n157.  \n158. def terminate(): \n159.     pygame.quit() \n160.     sys.exit() \n161.  \n162.  \n163. def getRandomLocation(): \n164.     return {'x': random.randint(0, CELLWIDTH - 1), 'y': random.randint(0, \nCELLHEIGHT - 1)} \n165.  \n166.  \n167. def showGameOverScreen(): \n168.     gameOverFont = pygame.font.Font('freesansbold.ttf', 150) \n169.     gameSurf = gameOverFont.render('Game', True, WHITE) \n170.     overSurf = gameOverFont.render('Over', True, WHITE) \n171.     gameRect = gameSurf.get_rect() \n172.     overRect = overSurf.get_rect() \n173.     gameRect.midtop = (WINDOWWIDTH / 2, 10) \n174.     overRect.midtop = (WINDOWWIDTH / 2, gameRect.height + 10 + 25) \n175.  \n176.     DISPLAYSURF.blit(gameSurf, gameRect) \n177.     DISPLAYSURF.blit(overSurf, overRect) \n178.     drawPressKeyMsg() \n\n\n136    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n179.     pygame.display.update() \n180.     pygame.time.wait(500) \n181.     checkForKeyPress() # clear out any key presses in the event queue \n182.  \n183.     while True: \n184.         if checkForKeyPress(): \n185.             pygame.event.get() # clear event queue \n186.             return \n187.  \n188. def drawScore(score): \n189.     scoreSurf = BASICFONT.render('Score: %s' % (score), True, WHITE) \n190.     scoreRect = scoreSurf.get_rect() \n191.     scoreRect.topleft = (WINDOWWIDTH - 120, 10) \n192.     DISPLAYSURF.blit(scoreSurf, scoreRect) \n193.  \n194.  \n195. def drawWorm(wormCoords): \n196.     for coord in wormCoords: \n197.         x = coord['x'] * CELLSIZE \n198.         y = coord['y'] * CELLSIZE \n199.         wormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \n200.         pygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \n201.         wormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, \nCELLSIZE - 8) \n202.         pygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \n203.  \n204.  \n205. def drawApple(coord): \n206.     x = coord['x'] * CELLSIZE \n207.     y = coord['y'] * CELLSIZE \n208.     appleRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \n209.     pygame.draw.rect(DISPLAYSURF, RED, appleRect) \n210.  \n211.  \n212. def drawGrid(): \n213.     for x in range(0, WINDOWWIDTH, CELLSIZE): # draw vertical lines \n214.         pygame.draw.line(DISPLAYSURF, DARKGRAY, (x, 0), (x, WINDOWHEIGHT)) \n215.     for y in range(0, WINDOWHEIGHT, CELLSIZE): # draw horizontal lines \n216.         pygame.draw.line(DISPLAYSURF, DARKGRAY, (0, y), (WINDOWWIDTH, y)) \n217. \n218. \n219. if __name__ == '__main__': \n220.     main() \n\n\nChapter 6 – Wormy    137 \n \nThe Grid \n \nIf you play the game a little, you’ll notice that the apple and the segments of the worm’s body \nalways fit along a grid of lines. We will call each of the squares in this grid a cell (it’s not always \nwhat a space in a grid is called, it’s just a name I came up with). The cells have their own \nCartesian coordinate system, with (0, 0) being the top left cell and (31, 23) being the bottom right \ncell. \nThe Setup Code \n  1. # Wormy (a Nibbles clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, pygame, sys \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 15 \n 10. WINDOWWIDTH = 640 \n 11. WINDOWHEIGHT = 480 \n 12. CELLSIZE = 20 \n 13. assert WINDOWWIDTH % CELLSIZE == 0, \"Window width must be a multiple of \ncell size.\" \n 14. assert WINDOWHEIGHT % CELLSIZE == 0, \"Window height must be a multiple of \ncell size.\" \n 15. CELLWIDTH = int(WINDOWWIDTH / CELLSIZE) \n 16. CELLHEIGHT = int(WINDOWHEIGHT / CELLSIZE) \n\n\n138    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe code at the start of the program just sets up some constant variables used in the game. The \nwidth and height of the cells are stored in CELLSIZE. The assert statements on lines 13 and \n14 ensure that the cells fit perfectly in the window. For example, if the CELLSIZE was 10 and \nthe WINDOWWIDTH or WINDOWHEIGHT constants were set to 15, then only 1.5 cells could fit. \nThe assert statements make sure that only a whole integer number of cells fits in the window. \n 18. #             R    G    B \n 19. WHITE     = (255, 255, 255) \n 20. BLACK     = (  0,   0,   0) \n 21. RED       = (255,   0,   0) \n 22. GREEN     = (  0, 255,   0) \n 23. DARKGREEN = (  0, 155,   0) \n 24. DARKGRAY  = ( 40,  40,  40) \n 25. BGCOLOR = BLACK \n 26.  \n 27. UP = 'up' \n 28. DOWN = 'down' \n 29. LEFT = 'left' \n 30. RIGHT = 'right' \n 31.  \n 32. HEAD = 0 # syntactic sugar: index of the worm's head \nSome more constants are set on lines 19 to 32. The HEAD constant will be explained later in this \nchapter. \nThe main() Function \n 34. def main(): \n 35.     global FPSCLOCK, DISPLAYSURF, BASICFONT \n 36.  \n 37.     pygame.init() \n 38.     FPSCLOCK = pygame.time.Clock() \n 39.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 40.     BASICFONT = pygame.font.Font('freesansbold.ttf', 18) \n 41.     pygame.display.set_caption('Wormy') \n 42.  \n 43.     showStartScreen() \n 44.     while True: \n 45.         runGame() \n 46.         showGameOverScreen() \nIn the Wormy game program, we’ve put the main part of the code in a function called \nrunGame(). This is because we only want to show the ―start screen‖ (the animation with the \nrotating ―Wormy‖ text) once when the program starts (by calling the showStartScreen() \n\n\nChapter 6 – Wormy    139 \n \nfunction). Then we want to call runGame(), which will start a game of Wormy. This function \nwill return when the player’s worm collides into a wall or into itself and causes a game over. \nAt that point we will show the game over screen by calling showGameOverScreen(). When \nthat function call returns, the loop goes back to the start and calls runGame() again. The \nwhile loop on line 44 will loop forever until the program terminates. \nA Separate runGame() Function \n 49. def runGame(): \n 50.     # Set a random start point. \n 51.     startx = random.randint(5, CELLWIDTH - 6) \n 52.     starty = random.randint(5, CELLHEIGHT - 6) \n 53.     wormCoords = [{'x': startx,     'y': starty}, \n 54.                   {'x': startx - 1, 'y': starty}, \n 55.                   {'x': startx - 2, 'y': starty}] \n 56.     direction = RIGHT \n 57.  \n 58.     # Start the apple in a random place. \n 59.     apple = getRandomLocation() \nAt the beginning of a game, we want the worm to start in a random position (but not too close to \nthe edges of the board) so we store a random coordinate in startx and starty. (Remember \nthat CELLWIDTH and CELLHEIGHT is the number of cells wide and high the window is, not the \nnumber of pixels wide and high). \nThe body of the worm will be stored in a list of dictionary values. There will be one dictionary \nvalue per body segment of the worm. The dictionary will have keys 'x' and 'y' for the XY \ncoordinates of that body segment. The head of the body to be at startx and starty. The other \ntwo body segments will be one and two cells to the left of the head. \nThe head of the worm will always be the body part at wormCoords[0]. To make this code \nmore readable, we’ve set the HEAD constant to 0 on line 32, so that we can use \nwormCoords[HEAD] instead of wormCoords[0]. \nThe Event Handling Loop \n 61.     while True: # main game loop \n 62.         for event in pygame.event.get(): # event handling loop \n 63.             if event.type == QUIT: \n 64.                 terminate() \n 65.             elif event.type == KEYDOWN: \n 66.                 if (event.key == K_LEFT or event.key == K_a) and direction \n!= RIGHT: \n\n\n140    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 67.                     direction = LEFT \n 68.                 elif (event.key == K_RIGHT or event.key == K_d) and \ndirection != LEFT: \n 69.                     direction = RIGHT \n 70.                 elif (event.key == K_UP or event.key == K_w) and direction \n!= DOWN: \n 71.                     direction = UP \n 72.                 elif (event.key == K_DOWN or event.key == K_s) and \ndirection != UP: \n 73.                     direction = DOWN \n 74.                 elif event.key == K_ESCAPE: \n 75.                     terminate() \nLine 61 is the start of the main game loop and line 62 is the start of the event handling loop. If the \nevent is a QUIT event, then we call terminate() (which we’ve defined the same as the \nterminate() function in the previous game programs). \nOtherwise, if the event is a KEYDOWN event, then we check if the key that was pressed down is an \narrow key or a WASD key. We want an additional check so that the worm does not turn in on \nitself. For example, if the worm is moving left, then if the player accidentally presses the right \narrow key, the worm would immediate start going right and crash into itself. \nThat is why we have this check for the current value of the direction variable. That way, if \nthe player accidentally presses an arrow key that would cause them to immediately crash the \nworm, we just ignore that key press. \nCollision Detection \n77.         # check if the worm has hit itself or the edge \n78.         if wormCoords[HEAD]['x'] == -1 or wormCoords[HEAD]['x'] == \nCELLWIDTH or wormCoords[HEAD]['y'] == -1 or wormCoords[HEAD]['y'] == \nCELLHEIGHT: \n79.             return # game over \n80.         for wormBody in wormCoords[1:]: \n81.             if wormBody['x'] == wormCoords[HEAD]['x'] and wormBody['y'] == \nwormCoords[HEAD]['y']: \n82.                 return # game over \nThe worm has crashed when the head has moved off the edge of the grid or when the head moves \nonto a cell that is already occupied by another body segment. \nWe can check if the head has moved off the edge of the grid by seeing if either the X coordinate \nof the head (which is stored in wormCoords[HEAD]['x']) is -1 (which is past the left edge \n\n\nChapter 6 – Wormy    141 \n \nof the grid) or equal to CELLWIDTH (which is past the right edge, since the rightmost X cell \ncoordinate is one less than CELLWIDTH).  \nThe head has also moved off the grid if the Y coordinate of the head (which is stored in \nwormCoords[HEAD]['y']) is either -1 (which is past the top edge) or CELLHEIGHT \n(which is past the bottom edge). \nAll we have to do to end the current game is to return out of runGame(). When runGame() \nreturns to the function call in main(), the next line after the runGame() call (line 46) is the \ncall to showGameOverScreen() which makes the large ―Game Over‖ text appear. This is \nwhy we have the return statement on line 79. \nLine 80 loops through every body segment in wormCoords after the head (which is at index 0. \nThis is why the for loop iterates over wormCoords[1:] instead of just wormCoords). If \nboth the 'x' and 'y' values of the body segment are the same as the 'x' and 'y' of the head, \nthen we also end the game by returning out of the runGame() function. \nDetecting Collisions with the Apple \n 84.         # check if worm has eaten an apply \n 85.         if wormCoords[HEAD]['x'] == apple['x'] and wormCoords[HEAD]['y'] \n== apple['y']: \n 86.             # don't remove worm's tail segment \n 87.             apple = getRandomLocation() # set a new apple somewhere \n 88.         else: \n 89.             del wormCoords[-1] # remove worm's tail segment \nWe do a similar collision detection check between the head of the worm and the apple’s XY \ncoordinates. If they match, we set the coordinates of the apple to a random new location (which \nwe get from the return value of getRandomLocation()). \nIf the head has not collided with an apple, then we delete the last body segment in the \nwormCoords list. Remember that negative integers for indexes count from the end of the list. \nSo while 0 is the index of the first item in the list and 1 is for the second item, -1 is for the last \nitem in the list and -2 is for the second to last item. \nThe code on lines 91 to 100 (described next in the ―Moving the Worm‖ section) will add a new \nbody segment (for the head) in the direction that the worm is going. This will make the worm one \nsegment longer. By not deleting the last body segment when the worm eats an apple, the overall \nlength of the worm increases by one. But when line 89 deletes the last body segment, the size \nremains the same because a new head segment is added right afterwards. \n\n\n142    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nMoving the Worm \n 91.         # move the worm by adding a segment in the direction it is moving \n 92.         if direction == UP: \n 93.             newHead = {'x': wormCoords[HEAD]['x'], 'y': \nwormCoords[HEAD]['y'] - 1} \n 94.         elif direction == DOWN: \n 95.             newHead = {'x': wormCoords[HEAD]['x'], 'y': \nwormCoords[HEAD]['y'] + 1} \n 96.         elif direction == LEFT: \n 97.             newHead = {'x': wormCoords[HEAD]['x'] - 1, 'y': \nwormCoords[HEAD]['y']} \n 98.         elif direction == RIGHT: \n 99.             newHead = {'x': wormCoords[HEAD]['x'] + 1, 'y': \nwormCoords[HEAD]['y']} \n100.         wormCoords.insert(0, newHead) \nTo move the worm, we add a new body segment to the beginning of the wormCoords list. \nBecause the body segment is being added to the beginning of the list, it will become the new \nhead. The coordinates of the new head will be right next to the old head’s coordinates. Whether 1 \nis added or subtracted from either the X or Y coordinate depends on the direction the worm was \ngoing. \nThis new head segment is added to wormCoords with the insert() list method on line 100. \nThe insert() List Method \nUnlike the append() list method that can only add items to the end of a list, the insert() list \nmethod can add items anywhere inside the list. The first parameter for insert() is the index \nwhere the item should go (all the items originally at this index and after have their indexes \nincrease by one). If the argument passed for the first parameter is larger than the length of the list, \nthe item is simply added to the end of the list (just like what append() does). The second \nparameter for insert() is the item value to be added. Type the following into the interactive \nshell to see how insert() works: \n>>> spam = ['cat', 'dog', 'bat'] \n>>> spam.insert(0, 'frog') \n>>> spam \n['frog', 'cat', 'dog', 'bat'] \n>>> spam.insert(10, 42) \n>>> spam \n['frog', 'cat', 'dog', 'bat', 42] \n>>> spam.insert(2, 'horse') \n>>> spam \n['frog', 'cat', 'horse', 'dog', 'bat', 42] \n",
      "page_number": 148,
      "chapter_number": 18,
      "summary": "This chapter covers segment 18 (pages 148-160). Key topics include wormy, keys. To make it clear that in this case the value \nNone is returned from getButtonClicked(), we have the return None line at the end of \nthe function.",
      "keywords": [
        "HEAD",
        "wormCoords",
        "worm",
        "CELLSIZE",
        "direction",
        "Wormy",
        "WINDOWWIDTH",
        "WINDOWHEIGHT",
        "LEFT",
        "apple",
        "game",
        "worm head",
        "segment",
        "event.key",
        "body segment"
      ],
      "concepts": [
        "wormy",
        "key",
        "keys",
        "worm",
        "randomly",
        "returns",
        "head",
        "right",
        "idea",
        "apple"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 40,
          "title": "Segment 40 (pages 809-829)",
          "relevance_score": 0.42,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 10,
          "title": "Segment 10 (pages 83-98)",
          "relevance_score": 0.39,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.38,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.35,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.35,
          "method": "api"
        }
      ]
    },
    {
      "number": 19,
      "title": "Segment 19 (pages 161-168)",
      "start_page": 161,
      "end_page": 168,
      "detection_method": "topic_boundary",
      "content": "Chapter 6 – Wormy    143 \n \n>>> \nDrawing the Screen \n101.         DISPLAYSURF.fill(BGCOLOR) \n102.         drawGrid() \n103.         drawWorm(wormCoords) \n104.         drawApple(apple) \n105.         drawScore(len(wormCoords) - 3) \n106.         pygame.display.update() \n107.         FPSCLOCK.tick(FPS) \nThe code for drawing the screen in the runGame() function is fairly simple. Line 101 fills in \nthe entire display Surface with the background color. Lines 102 to 105 draw the grid, worm, \napple, and score to the display Surface. Then the call to pygame.display.update() draws \nthe display Surface to the actual computer screen. \nDrawing “Press a key” Text to the Screen \n109. def drawPressKeyMsg(): \n110.     pressKeySurf = BASICFONT.render('Press a key to play.', True, \nDARKGRAY) \n111.     pressKeyRect = pressKeySurf.get_rect() \n112.     pressKeyRect.topleft = (WINDOWWIDTH - 200, WINDOWHEIGHT - 30) \n113.     DISPLAYSURF.blit(pressKeySurf, pressKeyRect) \nWhile the start screen animation is playing or the game over screen is being shown, there will be \nsome small text in the bottom right corner that says ―Press a key to play.‖ Rather than have the \ncode typed out in both the showStartScreen() and the showGameOverScreen(), we \nput it in a this separate function and simply call the function from showStartScreen() and \nshowGameOverScreen(). \nThe checkForKeyPress() Function \n116. def checkForKeyPress(): \n117.     if len(pygame.event.get(QUIT)) > 0: \n118.         terminate() \n119.  \n120.     keyUpEvents = pygame.event.get(KEYUP) \n121.     if len(keyUpEvents) == 0: \n122.         return None \n123.     if keyUpEvents[0].key == K_ESCAPE: \n124.         terminate() \n125.     return keyUpEvents[0].key \n\n\n144    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThis function first checks if there are any QUIT events in the event queue. The call to \npygame.event.get() on line 117 returns a list of all the QUIT events in the event queue \n(because we pass QUIT as an argument). If there are not QUIT events in the event queue, then \nthe list that pygame.event.get() returns will be the empty list: [] \nThe len() call on line 117 will return 0 if pygame.event.get() returned an empty list. If \nthere are more than zero items in the list returned by pygame.event.get() (and remember, \nany items in this list will only be QUIT events because we passed QUIT as the argument to \npygame.event.get()), then the terminate() function gets called on line 118 and the \nprogram terminates. \nAfter that, the call to pygame.event.get() gets a list of any KEYUP events in the event \nqueue. If the key event is for the Esc key, then the program terminates in that case as well. \nOtherwise, the first key event object in the list that was returned by pygame.event.get() is \nreturned from this checkForKeyPress() function. \nThe Start Screen \n128. def showStartScreen(): \n129.     titleFont = pygame.font.Font('freesansbold.ttf', 100) \n130.     titleSurf1 = titleFont.render('Wormy!', True, WHITE, DARKGREEN) \n131.     titleSurf2 = titleFont.render('Wormy!', True, GREEN) \n132.  \n133.     degrees1 = 0 \n134.     degrees2 = 0 \n135.     while True: \n136.         DISPLAYSURF.fill(BGCOLOR) \nWhen the Wormy game program first begins running, the player doesn’t automatically begin \nplaying the game. Instead, a start screen appears which tells the player what program they are \nrunning. A start screen also gives the player a chance to prepare for the game to begin (otherwise \nthe player might not be ready and crash on their first game). \nThe Wormy start screen requires two Surface objects with the ―Wormy!‖ text drawn on them. \nThese are what the render() method calls create on lines 130 and 131. The text will be large: \nthe Font() constructor function call on line 129 creates a Font object that is 100 points in size. \nThe first ―Wormy!‖ text will have white text with a dark green background, and the other will \nhave green text with a transparent background. \nLine 135 begins the animation loop for the start screen. During this animation, the two pieces of \ntext will be rotated and drawn to the display Surface object. \n\n\nChapter 6 – Wormy    145 \n \nRotating the Start Screen Text \n137.         rotatedSurf1 = pygame.transform.rotate(titleSurf1, degrees1) \n138.         rotatedRect1 = rotatedSurf1.get_rect() \n139.         rotatedRect1.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2) \n140.         DISPLAYSURF.blit(rotatedSurf1, rotatedRect1) \n141.  \n142.         rotatedSurf2 = pygame.transform.rotate(titleSurf2, degrees2) \n143.         rotatedRect2 = rotatedSurf2.get_rect() \n144.         rotatedRect2.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2) \n145.         DISPLAYSURF.blit(rotatedSurf2, rotatedRect2) \n146.  \n147.         drawPressKeyMsg() \n148.  \n149.         if checkForKeyPress(): \n150.             pygame.event.get() # clear event queue \n151.             return \n152.         pygame.display.update() \n153.         FPSCLOCK.tick(FPS) \nThe showStartScreen() function will rotate the images on the Surface objects that the \n―Wormy!‖ text is written on. The first parameter is the Surface object to make a rotated copy of. \nThe second parameter is the number of degrees to rotate the Surface. The \npygame.transform.rotate() function doesn’t change the Surface object you pass it, but \nrather returns a new Surface object with the rotated image drawn on it. \nNote that this new Surface object will probably be larger than the original one, since all Surface \nobjects represent rectangular areas and the corners of the rotated Surface will stick out past the \nwidth and height of original Surface. The picture below has a black rectangle along with a \nslightly rotated version of itself. In order to make a Surface object that can fit the rotated \nrectangle (which is colored gray in the picture below), it must be larger than the original black \nrectangle’s Surface object: \n \nThe amount you rotate it is given in degrees, which is a measure of rotation. There are 360 \ndegrees in a circle. Not rotated at all is 0 degrees. Rotating to one quarter counter-clockwise is 90 \ndegrees. To rotate clockwise, pass a negative integer. Rotating 360 degrees is rotating the image \nall the way around, which means you end up with the same image as if you rotated it 0 degrees. In \nfact, if the rotation argument you pass to pygame.transform.rotate() is 360 or larger, \n\n\n146    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nthen Pygame automatically keeps subtracting 360 from it until it gets a number less than 360. \nThis image shows several examples of different rotation amounts: \n \nThe two rotated ―Wormy!‖ Surface objects are blitted to the display Surface on each frame of the \nanimation loop on lines 140 and 145. \nOn line 147 the drawPressKeyMsg() function call draws the ―Press a key to play.‖ text in the \nlower corner of the display Surface object. This animation loop will keep looping until \ncheckForKeyPress() returns a value that is not None, which happens if the player presses a \nkey. Before returning, pygame.event.get() is called simply to clear out any other events \nthat have accumulated in the event queue which the start screen was displayed. \nRotations Are Not Perfect \nYou may wonder why we store the rotated Surface in a separate variable, rather than just \noverwrite the titleSurf1 and titleSurf2 variables. There are two reasons. \nFirst, rotating a 2D image is never completely perfect. The rotated image is always approximate. \nIf you rotate an image by 10 degrees counterclockwise, and then rotate it back 10 degrees \nclockwise, the image you have will not be the exact same image you started with. Think of it as \nmaking a photocopy, and then a photocopy of the first photocopy, and the another photocopy of \nthat photocopy. If you keep doing this, the image gets worse and worse as the slight distortions \nadd up. \n(The only exception to this is if you rotate an image by a multiple of 90 degrees, such as 0, 90, \n180, 270, or 360 degrees. In that case, the pixels can be rotated without any distortion.) \nSecond, if you rotate a 2D image then the rotated image will be slightly larger than the original \nimage. If you rotate that rotated image, then the next rotated image will be slightly larger again. If \nyou keep doing this, eventually the image will become too large for Pygame to handle, and your \n\n\nChapter 6 – Wormy    147 \n \nprogram will crash with the error message, pygame.error: Width or height is too \nlarge. \n154.         degrees1 += 3 # rotate by 3 degrees each frame \n155.         degrees2 += 7 # rotate by 7 degrees each frame \nThe amount that we rotate the two ―Wormy!‖ text Surface objects is stored in degrees1 and \ndegrees2. On each iteration through the animation loop, we increase the number stored in \ndegrees1 by 3 and degrees2 by 7. This means on the next iteration of the animation loop \nthe white text ―Wormy!‖ Surface object will be rotated by another 3 degrees and the green text \n―Wormy!‖ Surface object will be rotated by another 7 degrees. This is why the one of the Surface \nobjects rotates slower than the other. \n158. def terminate(): \n159.     pygame.quit() \n160.     sys.exit() \nThe terminate() function calls pygame.quit() and sys.exit() so that the game \ncorrectly shuts down. It is identical to the terminate() functions in the previous game \nprograms. \nDeciding Where the Apple Appears \n163. def getRandomLocation(): \n164.     return {'x': random.randint(0, CELLWIDTH - 1), 'y': random.randint(0, \nCELLHEIGHT - 1)} \nThe getRandomLocation() function is called whenever new coordinates for the apple are \nneeded. This function returns a dictionary with keys 'x' and 'y', with the values set to random \nXY coordinates. \nGame Over Screens \n167. def showGameOverScreen(): \n168.     gameOverFont = pygame.font.Font('freesansbold.ttf', 150) \n169.     gameSurf = gameOverFont.render('Game', True, WHITE) \n170.     overSurf = gameOverFont.render('Over', True, WHITE) \n171.     gameRect = gameSurf.get_rect() \n172.     overRect = overSurf.get_rect() \n173.     gameRect.midtop = (WINDOWWIDTH / 2, 10) \n174.     overRect.midtop = (WINDOWWIDTH / 2, gameRect.height + 10 + 25) \n175.  \n176.     DISPLAYSURF.blit(gameSurf, gameRect) \n\n\n148    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n177.     DISPLAYSURF.blit(overSurf, overRect) \n178.     drawPressKeyMsg() \n179.     pygame.display.update() \nThe game over screen is similar to the start screen, except it isn’t animated. The words ―Game‖ \nand ―Over‖ are rendered to two Surface objects which are then drawn on the screen. \n180.     pygame.time.wait(500) \n181.     checkForKeyPress() # clear out any key presses in the event queue \n182.  \n183.     while True: \n184.         if checkForKeyPress(): \n185.             pygame.event.get() # clear event queue \n186.             return \nThe Game Over text will stay on the screen until the player pushes a key. Just to make sure the \nplayer doesn’t accidentally press a key too soon, we will put a half second pause with the call to \npygame.time.wait() on line 180. (The 500 argument stands for a 500 millisecond pause, \nwhich is half of one second.)  \nThen, checkForKeyPress() is called so that any key events that were made since the \nshowGameOverScreen() function started are ignored. This pause and dropping of the key \nevents is to prevent the following situation: Say the player was trying to turn away from the edge \nof the screen at the last minute, but pressed the key too late and crashed into the edge of the \nboard. If this happens, then the key press would have happened after the \nshowGameOverScreen() was called, and that key press would cause the game over screen to \ndisappear almost instantly. The next game would start immediately after that, and might take the \nplayer by surprise. Adding this pause helps the make the game more ―user friendly‖. \nDrawing Functions \nThe code to draw the score, worm, apple, and grid are all put into separate functions. \n188. def drawScore(score): \n189.     scoreSurf = BASICFONT.render('Score: %s' % (score), True, WHITE) \n190.     scoreRect = scoreSurf.get_rect() \n191.     scoreRect.topleft = (WINDOWWIDTH - 120, 10) \n192.     DISPLAYSURF.blit(scoreSurf, scoreRect) \nThe drawScore() function simply renders and draws the text of the score that was passed in \nits score parameter on the display Surface object. \n\n\nChapter 6 – Wormy    149 \n \n195. def drawWorm(wormCoords): \n196.     for coord in wormCoords: \n197.         x = coord['x'] * CELLSIZE \n198.         y = coord['y'] * CELLSIZE \n199.         wormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \n200.         pygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \n201.         wormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, \nCELLSIZE - 8) \n202.         pygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nThe drawWorm() function will draw a green box for each of the segments of the worm’s body. \nThe segments are passed in the wormCoords parameter, which is a list of dictionaries each with \nan 'x' key and a 'y' key. The for loop on line 196 loops through each of the dictionary values \nin wormCoords. \nBecause the grid coordinates take up the entire window and also begin a 0, 0 pixel, it is fairly \neasy to convert from grid coordinates to pixel coordinates. Line 197 and 198 simply multiply the \ncoord['x'] and coord['y'] coordinate by the CELLSIZE. \nLine 199 creates a Rect object for the worm segment that will be passed to the \npygame.draw.rect() function on line 200. Remember that each cell in the grid is \nCELLSIZE in width and height, so that’s what the size of the segment’s Rect object should be. \nLine 200 draws a dark green rectangle for the segment. Then on top of this, a smaller bright green \nrectangle is drawn. This makes the worm look a little nicer.  \nThe inner bright green rectangle starts 4 pixels to the right and 4 pixels below the topleft corner of \nthe cell. The width and height of this rectangle are 8 pixels less than the cell size, so there will be \na 4 pixel margin on the right and bottom sides as well. \n205. def drawApple(coord): \n206.     x = coord['x'] * CELLSIZE \n207.     y = coord['y'] * CELLSIZE \n208.     appleRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \n209.     pygame.draw.rect(DISPLAYSURF, RED, appleRect) \nThe drawApple() function is very similar to drawWorm(), except since the red apple is just \na single rectangle that fills up the cell, all the function needs to do is convert to pixel coordinates \n(which is what lines 206 and 207 do), create the Rect object with the location and size of the \napple (line 208), and then pass this Rect object to the pygame.draw.rect() function. \n212. def drawGrid(): \n213.     for x in range(0, WINDOWWIDTH, CELLSIZE): # draw vertical lines \n\n\n150    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n214.         pygame.draw.line(DISPLAYSURF, DARKGRAY, (x, 0), (x, WINDOWHEIGHT)) \n215.     for y in range(0, WINDOWHEIGHT, CELLSIZE): # draw horizontal lines \n216.         pygame.draw.line(DISPLAYSURF, DARKGRAY, (0, y), (WINDOWWIDTH, y)) \nJust to make it easier to visualize the grid of cells, we call pygame.draw.line() to draw out \neach of the vertical and horizontal lines of the grid. \nNormally, to draw the 32 vertical lines needed, we would need 32 calls to \npygame.draw.line() with the following coordinates: \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 0), (0, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (20, 0), (20, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (40, 0), (40, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (60, 0), (60, WINDOWHEIGHT)) \n...skipped for brevity... \npygame.draw.line(DISPLAYSURF, DARKGRAY, (560, 0), (560, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (580, 0), (580, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (600, 0), (600, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (620, 0), (620, WINDOWHEIGHT)) \nInstead of typing out all these lines of code, we can just have one line of code inside a for loop. \nNotice that the pattern for the vertical lines is that the X coordinate of the start and end point \nstarts at 0 and goes up to 620, increasing by 20 each time. The Y coordinate is always 0 for the \nstart point and WINDOWHEIGHT for the end point parameter. That means the for loop should \niterate over range(0, 640, 20). This is why the for loop on line 213 iterates over \nrange(0, WINDOWWIDTH, CELLSIZE). \nFor the horizontal lines, the coordinates would have to be: \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 0), (WINDOWWIDTH, 0)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 20), (WINDOWWIDTH, 20)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 40), (WINDOWWIDTH, 40)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 60), (WINDOWWIDTH, 60)) \n...skipped for brevity... \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 400), (WINDOWWIDTH, 400)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 420), (WINDOWWIDTH, 420)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 440), (WINDOWWIDTH, 440)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 460), (WINDOWWIDTH, 460)) \nThe Y coordinate ranges from 0 to 460, increasing by 20 each time. The X coordinate is always \n0 for the start point and WINDOWWIDTH for the end point parameter. We can also use a for loop \nhere so we don’t have to type out all those pygame.draw.line() calls. \n",
      "page_number": 161,
      "chapter_number": 19,
      "summary": "This chapter covers segment 19 (pages 161-168). Key topics include rotated, rotate, and rotation. FPSCLOCK.tick(FPS) \nThe code for drawing the screen in the runGame() function is fairly simple.",
      "keywords": [
        "Surface object",
        "Surface",
        "DISPLAYSURF",
        "DARKGRAY",
        "WINDOWWIDTH",
        "start screen",
        "display Surface object",
        "display Surface",
        "Wormy",
        "Screen",
        "CELLSIZE",
        "function",
        "WINDOWHEIGHT",
        "key",
        "object"
      ],
      "concepts": [
        "rotated",
        "rotate",
        "rotation",
        "rotations",
        "line",
        "function",
        "functions",
        "drawing",
        "green",
        "coordinates"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "Segment 12 (pages 108-115)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 20,
          "title": "Segment 20 (pages 385-402)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 13,
          "title": "Segment 13 (pages 115-123)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 6,
          "title": "Segment 6 (pages 103-120)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 24,
          "title": "Segment 24 (pages 213-226)",
          "relevance_score": 0.5,
          "method": "api"
        }
      ]
    },
    {
      "number": 20,
      "title": "Segment 20 (pages 169-178)",
      "start_page": 169,
      "end_page": 178,
      "detection_method": "topic_boundary",
      "content": "Chapter 6 – Wormy    151 \n \nNoticing regular patterns needed by the calls and using loops is a clever programmer trick to save \nus from a lot of typing. We could have typed out all 56 pygame.draw.line() calls and the \nprogram would have worked the exact same. But by being a little bit clever, we can save \nourselves a lot of work. \n219. if __name__ == '__main__': \n220.     main() \nAfter all the functions and constants and global variables have been defined and created, the \nmain() function is called to start the game. \nDon’t Reuse Variable Names \nTake a look at a few lines of code from the drawWorm() function again: \n199.         wormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \n200.         pygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \n201.         wormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, \nCELLSIZE - 8) \n202.         pygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nNotice that two different Rect objects are created on lines 199 and 201. The Rect object created \non line 199 is stored in the wormSegmentRect local variable and is passed to the \npygame.draw.rect() function on line 200. The Rect object created on line 201 is stored in \nthe wormInnerSegmentRect local variable and is passed to the pygame.draw.rect() \nfunction on line 202. \nEvery time you create a variable, it takes up a small amount of the computer’s memory. You \nmight think it would be clever to reuse the wormSegmentRect variable for both Rect objects, \nlike this: \n199.         wormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \n200.         pygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \n201.         wormSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, CELLSIZE \n- 8) \n202.         pygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nBecause the Rect object returned by pygame.Rect() on line 199 won’t be needed after 200, \nwe can overwrite this value and reuse the variable to store the Rect object returned by \npygame.Rect() on line 201. Since we are now using fewer variables we are saving memory, \nright? \n\n\n152    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nWhile this is technically true, you really are only saving a few bytes. Modern computers have \nmemory of several billion bytes. So the savings aren’t that great. Meanwhile, reusing variables \nreduces the code readability. If a programmer was reading through this code after it was written, \nthey would see that wormSegmentRect is passed to the pygame.draw.rect() calls on \nline 200 and 202. If they tried to find the first time the wormSegmentRect variable was \nassigned a value, they would see the pygame.Rect() call on line 199. They might not realize \nthat the Rect object returned by line 199’s pygame.Rect() call isn’t the same as the one that is \npassed to the pygame.draw.rect() call on line 202. \nLittle things like this make it harder to understand how exactly your program works. It won’t just \nbe other programmers looking at your code who will be confused. When you look at your own \ncode a couple weeks after writing it, you may have a hard time remembering how exactly it \nworks. Code readability is much more important than saving a few bytes of memory here and \nthere. \nFor additional programming practice, you can download buggy versions of Wormy from \nhttp://invpy.com/buggy/wormy and try to figure out how to fix the bugs. \n \n \n\n\nChapter 7 - Tetromino    153 \n \nCHAPTER 7 - TETROMINO \n \nHow to Play Tetromino \nTetromino is a Tetris clone. Differently shaped blocks (each made up of four boxes) fall from the \ntop of the screen, and the player must guide them down to form complete rows that have no gaps \nin them. When a complete row is formed, the row disappears and each row above it moves down \none row. The player tries to keep forming complete lines until the screen fills up and a new \nfalling block cannot fit on the screen. \nSome Tetromino Nomenclature \nIn this chapter, I have come up with a set of terms for the different things in the game program. \n \nBoard – The board is made up of 10 x 20 spaces that the blocks fall and stack up in. \n \nBox – A box is a single filled-in square space on the board. \n \nPiece – The things that fall from the top of the board that the player can rotate and \nposition. Each piece has a shape and is made up of 4 boxes. \n \nShape – The shapes are the different types of pieces in the game. The names of the \nshapes are T, S, Z, J, L, I, and O. \n \n\n\n154    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nTemplate – A list of shape data structures that represents all the possible rotations of a \nshape. These are store in variables with names like S_SHAPE_TEMPLATE or \nJ_SHAPE_TEMPLATE. \n \nLanded – When a piece has either reached the bottom of the board or is touching a box \non the board, we say that the piece has landed. At that point, the next piece should start \nfalling. \nSource Code to Tetromino \nThis source code can be downloaded from http://invpy.com/tetromino.py. If you get any error \nmessages, look at the line number that is mentioned in the error message and check your code for \nany typos. You can also copy and paste your code into the web form at \nhttp://invpy.com/diff/tetromino to see if the differences between your code and the code in the \nbook. \nYou will also need the background music files in the same folder of as the tetromino.py file. You \ncan download them from here: \n \nhttp://invpy.com/tetrisb.mid \n \nhttp://invpy.com/tetrisc.mid \n  1. # Tetromino (a Tetris clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, time, pygame, sys \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 25 \n 10. WINDOWWIDTH = 640 \n 11. WINDOWHEIGHT = 480 \n 12. BOXSIZE = 20 \n 13. BOARDWIDTH = 10 \n 14. BOARDHEIGHT = 20 \n 15. BLANK = '.' \n 16.  \n 17. MOVESIDEWAYSFREQ = 0.15 \n 18. MOVEDOWNFREQ = 0.1 \n 19.  \n 20. XMARGIN = int((WINDOWWIDTH - BOARDWIDTH * BOXSIZE) / 2) \n 21. TOPMARGIN = WINDOWHEIGHT - (BOARDHEIGHT * BOXSIZE) - 5 \n 22.  \n 23. #               R    G    B \n\n\nChapter 7 - Tetromino    155 \n \n 24. WHITE       = (255, 255, 255) \n 25. GRAY        = (185, 185, 185) \n 26. BLACK       = (  0,   0,   0) \n 27. RED         = (155,   0,   0) \n 28. LIGHTRED    = (175,  20,  20) \n 29. GREEN       = (  0, 155,   0) \n 30. LIGHTGREEN  = ( 20, 175,  20) \n 31. BLUE        = (  0,   0, 155) \n 32. LIGHTBLUE   = ( 20,  20, 175) \n 33. YELLOW      = (155, 155,   0) \n 34. LIGHTYELLOW = (175, 175,  20) \n 35.  \n 36. BORDERCOLOR = BLUE \n 37. BGCOLOR = BLACK \n 38. TEXTCOLOR = WHITE \n 39. TEXTSHADOWCOLOR = GRAY \n 40. COLORS      = (     BLUE,      GREEN,      RED,      YELLOW) \n 41. LIGHTCOLORS = (LIGHTBLUE, LIGHTGREEN, LIGHTRED, LIGHTYELLOW) \n 42. assert len(COLORS) == len(LIGHTCOLORS) # each color must have light color \n 43.  \n 44. TEMPLATEWIDTH = 5 \n 45. TEMPLATEHEIGHT = 5 \n 46.  \n 47. S_SHAPE_TEMPLATE = [['.....', \n 48.                      '.....', \n 49.                      '..OO.', \n 50.                      '.OO..', \n 51.                      '.....'], \n 52.                     ['.....', \n 53.                      '..O..', \n 54.                      '..OO.', \n 55.                      '...O.', \n 56.                      '.....']] \n 57.  \n 58. Z_SHAPE_TEMPLATE = [['.....', \n 59.                      '.....', \n 60.                      '.OO..', \n 61.                      '..OO.', \n 62.                      '.....'], \n 63.                     ['.....', \n 64.                      '..O..', \n 65.                      '.OO..', \n 66.                      '.O...', \n 67.                      '.....']] \n 68.  \n 69. I_SHAPE_TEMPLATE = [['..O..', \n\n\n156    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 70.                      '..O..', \n 71.                      '..O..', \n 72.                      '..O..', \n 73.                      '.....'], \n 74.                     ['.....', \n 75.                      '.....', \n 76.                      'OOOO.', \n 77.                      '.....', \n 78.                      '.....']] \n 79.  \n 80. O_SHAPE_TEMPLATE = [['.....', \n 81.                      '.....', \n 82.                      '.OO..', \n 83.                      '.OO..', \n 84.                      '.....']] \n 85.  \n 86. J_SHAPE_TEMPLATE = [['.....', \n 87.                      '.O...', \n 88.                      '.OOO.', \n 89.                      '.....', \n 90.                      '.....'], \n 91.                     ['.....', \n 92.                      '..OO.', \n 93.                      '..O..', \n 94.                      '..O..', \n 95.                      '.....'], \n 96.                     ['.....', \n 97.                      '.....', \n 98.                      '.OOO.', \n 99.                      '...O.', \n100.                      '.....'], \n101.                     ['.....', \n102.                      '..O..', \n103.                      '..O..', \n104.                      '.OO..', \n105.                      '.....']] \n106.  \n107. L_SHAPE_TEMPLATE = [['.....', \n108.                      '...O.', \n109.                      '.OOO.', \n110.                      '.....', \n111.                      '.....'], \n112.                     ['.....', \n113.                      '..O..', \n114.                      '..O..', \n115.                      '..OO.', \n\n\nChapter 7 - Tetromino    157 \n \n116.                      '.....'], \n117.                     ['.....', \n118.                      '.....', \n119.                      '.OOO.', \n120.                      '.O...', \n121.                      '.....'], \n122.                     ['.....', \n123.                      '.OO..', \n124.                      '..O..', \n125.                      '..O..', \n126.                      '.....']] \n127.  \n128. T_SHAPE_TEMPLATE = [['.....', \n129.                      '..O..', \n130.                      '.OOO.', \n131.                      '.....', \n132.                      '.....'], \n133.                     ['.....', \n134.                      '..O..', \n135.                      '..OO.', \n136.                      '..O..', \n137.                      '.....'], \n138.                     ['.....', \n139.                      '.....', \n140.                      '.OOO.', \n141.                      '..O..', \n142.                      '.....'], \n143.                     ['.....', \n144.                      '..O..', \n145.                      '.OO..', \n146.                      '..O..', \n147.                      '.....']] \n148.  \n149. SHAPES = {'S': S_SHAPE_TEMPLATE, \n150.           'Z': Z_SHAPE_TEMPLATE, \n151.           'J': J_SHAPE_TEMPLATE, \n152.           'L': L_SHAPE_TEMPLATE, \n153.           'I': I_SHAPE_TEMPLATE, \n154.           'O': O_SHAPE_TEMPLATE, \n155.           'T': T_SHAPE_TEMPLATE} \n156.  \n157. \n158. def main(): \n159.     global FPSCLOCK, DISPLAYSURF, BASICFONT, BIGFONT \n160.     pygame.init() \n161.     FPSCLOCK = pygame.time.Clock() \n\n\n158    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n162.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n163.     BASICFONT = pygame.font.Font('freesansbold.ttf', 18) \n164.     BIGFONT = pygame.font.Font('freesansbold.ttf', 100) \n165.     pygame.display.set_caption('Tetromino') \n166.  \n167.     showTextScreen('Tetromino') \n168.     while True: # game loop \n169.         if random.randint(0, 1) == 0: \n170.             pygame.mixer.music.load('tetrisb.mid') \n171.         else: \n172.             pygame.mixer.music.load('tetrisc.mid') \n173.         pygame.mixer.music.play(-1, 0.0) \n174.         runGame() \n175.         pygame.mixer.music.stop() \n176.         showTextScreen('Game Over') \n177.  \n178.  \n179. def runGame(): \n180.     # setup variables for the start of the game \n181.     board = getBlankBoard() \n182.     lastMoveDownTime = time.time() \n183.     lastMoveSidewaysTime = time.time() \n184.     lastFallTime = time.time() \n185.     movingDown = False # note: there is no movingUp variable \n186.     movingLeft = False \n187.     movingRight = False \n188.     score = 0 \n189.     level, fallFreq = calculateLevelAndFallFreq(score) \n190.  \n191.     fallingPiece = getNewPiece() \n192.     nextPiece = getNewPiece() \n193.  \n194.     while True: # main game loop \n195.         if fallingPiece == None: \n196.             # No falling piece in play, so start a new piece at the top \n197.             fallingPiece = nextPiece \n198.             nextPiece = getNewPiece() \n199.             lastFallTime = time.time() # reset lastFallTime \n200.  \n201.             if not isValidPosition(board, fallingPiece): \n202.                 return # can't fit a new piece on the board, so game over \n203.  \n204.         checkForQuit() \n205.         for event in pygame.event.get(): # event handling loop \n206.             if event.type == KEYUP: \n207.                 if (event.key == K_p): \n\n\nChapter 7 - Tetromino    159 \n \n208.                     # Pausing the game \n209.                     DISPLAYSURF.fill(BGCOLOR) \n210.                     pygame.mixer.music.stop() \n211.                     showTextScreen('Paused') # pause until a key press \n212.                     pygame.mixer.music.play(-1, 0.0) \n213.                     lastFallTime = time.time() \n214.                     lastMoveDownTime = time.time() \n215.                     lastMoveSidewaysTime = time.time() \n216.                 elif (event.key == K_LEFT or event.key == K_a): \n217.                     movingLeft = False \n218.                 elif (event.key == K_RIGHT or event.key == K_d): \n219.                     movingRight = False \n220.                 elif (event.key == K_DOWN or event.key == K_s): \n221.                     movingDown = False \n222.  \n223.             elif event.type == KEYDOWN: \n224.                 # moving the block sideways \n225.                 if (event.key == K_LEFT or event.key == K_a) and \nisValidPosition(board, fallingPiece, adjX=-1): \n226.                     fallingPiece['x'] -= 1 \n227.                     movingLeft = True \n228.                     movingRight = False \n229.                     lastMoveSidewaysTime = time.time() \n230. \n231.                 elif (event.key == K_RIGHT or event.key == K_d) and \nisValidPosition(board, fallingPiece, adjX=1): \n232.                     fallingPiece['x'] += 1 \n233.                     movingRight = True \n234.                     movingLeft = False \n235.                     lastMoveSidewaysTime = time.time() \n236.  \n237.                 # rotating the block (if there is room to rotate) \n238.                 elif (event.key == K_UP or event.key == K_w): \n239.                     fallingPiece['rotation'] = (fallingPiece['rotation'] + \n1) % len(SHAPES[fallingPiece['shape']]) \n240.                     if not isValidPosition(board, fallingPiece): \n241.                         fallingPiece['rotation'] = \n(fallingPiece['rotation'] - 1) % len(SHAPES[fallingPiece['shape']]) \n242.                 elif (event.key == K_q): # rotate the other direction \n243.                     fallingPiece['rotation'] = (fallingPiece['rotation'] - \n1) % len(SHAPES[fallingPiece['shape']]) \n244.                     if not isValidPosition(board, fallingPiece): \n245.                         fallingPiece['rotation'] = \n(fallingPiece['rotation'] + 1) % len(SHAPES[fallingPiece['shape']]) \n246.  \n247.                 # making the block fall faster with the down key \n\n\n160    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n248.                 elif (event.key == K_DOWN or event.key == K_s): \n249.                     movingDown = True \n250.                     if isValidPosition(board, fallingPiece, adjY=1): \n251.                         fallingPiece['y'] += 1 \n252.                     lastMoveDownTime = time.time() \n253.  \n254.                 # move the current block all the way down \n255.                 elif event.key == K_SPACE: \n256.                     movingDown = False \n257.                     movingLeft = False \n258.                     movingRight = False \n259.                     for i in range(1, BOARDHEIGHT): \n260.                         if not isValidPosition(board, fallingPiece, \nadjY=i): \n261.                             break \n262.                     fallingPiece['y'] += i - 1 \n263.  \n264.         # handle moving the block because of user input \n265.         if (movingLeft or movingRight) and time.time() - \nlastMoveSidewaysTime > MOVESIDEWAYSFREQ: \n266.             if movingLeft and isValidPosition(board, fallingPiece, adjX=-\n1): \n267.                 fallingPiece['x'] -= 1 \n268.             elif movingRight and isValidPosition(board, fallingPiece, \nadjX=1): \n269.                 fallingPiece['x'] += 1 \n270.             lastMoveSidewaysTime = time.time() \n271.  \n272.         if movingDown and time.time() - lastMoveDownTime > MOVEDOWNFREQ \nand isValidPosition(board, fallingPiece, adjY=1): \n273.             fallingPiece['y'] += 1 \n274.             lastMoveDownTime = time.time() \n275.  \n276.         # let the piece fall if it is time to fall \n277.         if time.time() - lastFallTime > fallFreq: \n278.             # see if the piece has landed \n279.             if not isValidPosition(board, fallingPiece, adjY=1): \n280.                 # falling piece has landed, set it on the board \n281.                 addToBoard(board, fallingPiece) \n282.                 score += removeCompleteLines(board) \n283.                 level, fallFreq = calculateLevelAndFallFreq(score) \n284.                 fallingPiece = None \n285.             else: \n286.                 # piece did not land, just move the block down \n287.                 fallingPiece['y'] += 1 \n288.                 lastFallTime = time.time() \n",
      "page_number": 169,
      "chapter_number": 20,
      "summary": "This chapter covers segment 20 (pages 169-178). Key topics include time, variables. We could have typed out all 56 pygame.draw.line() calls and the \nprogram would have worked the exact same.",
      "keywords": [
        "shape",
        "fallingPiece",
        "Noticing regular patterns",
        "Template",
        "Board",
        "event.key",
        "Rect object",
        "Tetromino",
        "CELLSIZE",
        "Noticing regular",
        "time.time",
        "Rect",
        "code",
        "line",
        "Piece"
      ],
      "concepts": [
        "time",
        "key",
        "variables",
        "variable",
        "fall",
        "board",
        "shape",
        "lines",
        "game",
        "music"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 32,
          "title": "Segment 32 (pages 336-344)",
          "relevance_score": 0.48,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.48,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 3,
          "title": "Segment 3 (pages 17-26)",
          "relevance_score": 0.48,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 13,
          "title": "Segment 13 (pages 115-123)",
          "relevance_score": 0.46,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 5,
          "title": "Segment 5 (pages 35-42)",
          "relevance_score": 0.46,
          "method": "api"
        }
      ]
    },
    {
      "number": 21,
      "title": "Segment 21 (pages 179-188)",
      "start_page": 179,
      "end_page": 188,
      "detection_method": "topic_boundary",
      "content": "Chapter 7 - Tetromino    161 \n \n289.  \n290.         # drawing everything on the screen \n291.         DISPLAYSURF.fill(BGCOLOR) \n292.         drawBoard(board) \n293.         drawStatus(score, level) \n294.         drawNextPiece(nextPiece) \n295.         if fallingPiece != None: \n296.             drawPiece(fallingPiece) \n297.  \n298.         pygame.display.update() \n299.         FPSCLOCK.tick(FPS) \n300.  \n301.  \n302. def makeTextObjs(text, font, color): \n303.     surf = font.render(text, True, color) \n304.     return surf, surf.get_rect() \n305.  \n306.  \n307. def terminate(): \n308.     pygame.quit() \n309.     sys.exit() \n310.  \n311.  \n312. def checkForKeyPress(): \n313.     # Go through event queue looking for a KEYUP event. \n314.     # Grab KEYDOWN events to remove them from the event queue. \n315.     checkForQuit() \n316. \n317.     for event in pygame.event.get([KEYDOWN, KEYUP]): \n318.         if event.type == KEYDOWN: \n319.             continue \n320.         return event.key \n321.     return None \n322.  \n323.  \n324. def showTextScreen(text): \n325.     # This function displays large text in the \n326.     # center of the screen until a key is pressed. \n327.     # Draw the text drop shadow \n328.     titleSurf, titleRect = makeTextObjs(text, BIGFONT, TEXTSHADOWCOLOR) \n329.     titleRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2)) \n330.     DISPLAYSURF.blit(titleSurf, titleRect) \n331.  \n332.     # Draw the text \n333.     titleSurf, titleRect = makeTextObjs(text, BIGFONT, TEXTCOLOR) \n\n\n162    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n334.     titleRect.center = (int(WINDOWWIDTH / 2) - 3, int(WINDOWHEIGHT / 2) - \n3) \n335.     DISPLAYSURF.blit(titleSurf, titleRect) \n336.  \n337.     # Draw the additional \"Press a key to play.\" text. \n338.     pressKeySurf, pressKeyRect = makeTextObjs('Press a key to play.', \nBASICFONT, TEXTCOLOR) \n339.     pressKeyRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2) + \n100) \n340.     DISPLAYSURF.blit(pressKeySurf, pressKeyRect) \n341.  \n342.     while checkForKeyPress() == None: \n343.         pygame.display.update() \n344.         FPSCLOCK.tick() \n345.  \n346.  \n347. def checkForQuit(): \n348.     for event in pygame.event.get(QUIT): # get all the QUIT events \n349.         terminate() # terminate if any QUIT events are present \n350.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n351.         if event.key == K_ESCAPE: \n352.             terminate() # terminate if the KEYUP event was for the Esc key \n353.         pygame.event.post(event) # put the other KEYUP event objects back \n354.  \n355. \n356. def calculateLevelAndFallFreq(score): \n357.     # Based on the score, return the level the player is on and \n358.     # how many seconds pass until a falling piece falls one space. \n359.     level = int(score / 10) + 1 \n360.     fallFreq = 0.27 - (level * 0.02) \n361.     return level, fallFreq \n362.  \n363. def getNewPiece(): \n364.     # return a random new piece in a random rotation and color \n365.     shape = random.choice(list(SHAPES.keys())) \n366.     newPiece = {'shape': shape, \n367.                 'rotation': random.randint(0, len(SHAPES[shape]) - 1), \n368.                 'x': int(BOARDWIDTH / 2) - int(TEMPLATEWIDTH / 2), \n369.                 'y': -2, # start it above the board (i.e. less than 0) \n370.                 'color': random.randint(0, len(COLORS)-1)} \n371.     return newPiece \n372.  \n373.  \n374. def addToBoard(board, piece): \n375.     # fill in the board based on piece's location, shape, and rotation \n376.     for x in range(TEMPLATEWIDTH): \n\n\nChapter 7 - Tetromino    163 \n \n377.         for y in range(TEMPLATEHEIGHT): \n378.             if SHAPES[piece['shape']][piece['rotation']][y][x] != BLANK: \n379.                 board[x + piece['x']][y + piece['y']] = piece['color'] \n380.  \n381.  \n382. def getBlankBoard(): \n383.     # create and return a new blank board data structure \n384.     board = [] \n385.     for i in range(BOARDWIDTH): \n386.         board.append([BLANK] * BOARDHEIGHT) \n387.     return board \n388.  \n389.  \n390. def isOnBoard(x, y): \n391.     return x >= 0 and x < BOARDWIDTH and y < BOARDHEIGHT \n392.  \n393.  \n394. def isValidPosition(board, piece, adjX=0, adjY=0): \n395.     # Return True if the piece is within the board and not colliding \n396.     for x in range(TEMPLATEWIDTH): \n397.         for y in range(TEMPLATEHEIGHT): \n398.             isAboveBoard = y + piece['y'] + adjY < 0 \n399.             if isAboveBoard or \nSHAPES[piece['shape']][piece['rotation']][y][x] == BLANK: \n400.                 continue \n401.             if not isOnBoard(x + piece['x'] + adjX, y + piece['y'] + \nadjY): \n402.                 return False \n403.             if board[x + piece['x'] + adjX][y + piece['y'] + adjY] != \nBLANK: \n404.                 return False \n405.     return True \n406.  \n407. def isCompleteLine(board, y): \n408.     # Return True if the line filled with boxes with no gaps. \n409.     for x in range(BOARDWIDTH): \n410.         if board[x][y] == BLANK: \n411.             return False \n412.     return True \n413.  \n414.  \n415. def removeCompleteLines(board): \n416.     # Remove any completed lines on the board, move everything above them \ndown, and return the number of complete lines. \n417.     numLinesRemoved = 0 \n418.     y = BOARDHEIGHT - 1 # start y at the bottom of the board \n\n\n164    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n419.     while y >= 0: \n420.         if isCompleteLine(board, y): \n421.             # Remove the line and pull boxes down by one line. \n422.             for pullDownY in range(y, 0, -1): \n423.                 for x in range(BOARDWIDTH): \n424.                     board[x][pullDownY] = board[x][pullDownY-1] \n425.             # Set very top line to blank. \n426.             for x in range(BOARDWIDTH): \n427.                 board[x][0] = BLANK \n428.             numLinesRemoved += 1 \n429.             # Note on the next iteration of the loop, y is the same. \n430.             # This is so that if the line that was pulled down is also \n431.             # complete, it will be removed. \n432.         else: \n433.             y -= 1 # move on to check next row up \n434.     return numLinesRemoved \n435.  \n436.  \n437. def convertToPixelCoords(boxx, boxy): \n438.     # Convert the given xy coordinates of the board to xy  \n439.     # coordinates of the location on the screen. \n440.     return (XMARGIN + (boxx * BOXSIZE)), (TOPMARGIN + (boxy * BOXSIZE)) \n441.  \n442.  \n443. def drawBox(boxx, boxy, color, pixelx=None, pixely=None): \n444.     # draw a single box (each tetromino piece has four boxes) \n445.     # at xy coordinates on the board. Or, if pixelx & pixely \n446.     # are specified, draw to the pixel coordinates stored in \n447.     # pixelx & pixely (this is used for the \"Next\" piece). \n448.     if color == BLANK: \n449.         return \n450.     if pixelx == None and pixely == None: \n451.         pixelx, pixely = convertToPixelCoords(boxx, boxy) \n452.     pygame.draw.rect(DISPLAYSURF, COLORS[color], (pixelx + 1, pixely + 1, \nBOXSIZE - 1, BOXSIZE - 1)) \n453.     pygame.draw.rect(DISPLAYSURF, LIGHTCOLORS[color], (pixelx + 1, pixely \n+ 1, BOXSIZE - 4, BOXSIZE - 4)) \n454.  \n455.  \n456. def drawBoard(board): \n457.     # draw the border around the board \n458.     pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (XMARGIN - 3, TOPMARGIN - \n7, (BOARDWIDTH * BOXSIZE) + 8, (BOARDHEIGHT * BOXSIZE) + 8), 5) \n459.  \n460.     # fill the background of the board \n\n\nChapter 7 - Tetromino    165 \n \n461.     pygame.draw.rect(DISPLAYSURF, BGCOLOR, (XMARGIN, TOPMARGIN, BOXSIZE * \nBOARDWIDTH, BOXSIZE * BOARDHEIGHT)) \n462.     # draw the individual boxes on the board \n463.     for x in range(BOARDWIDTH): \n464.         for y in range(BOARDHEIGHT): \n465.             drawBox(x, y, board[x][y]) \n466.  \n467.  \n468. def drawStatus(score, level): \n469.     # draw the score text \n470.     scoreSurf = BASICFONT.render('Score: %s' % score, True, TEXTCOLOR) \n471.     scoreRect = scoreSurf.get_rect() \n472.     scoreRect.topleft = (WINDOWWIDTH - 150, 20) \n473.     DISPLAYSURF.blit(scoreSurf, scoreRect) \n474.  \n475.     # draw the level text \n476.     levelSurf = BASICFONT.render('Level: %s' % level, True, TEXTCOLOR) \n477.     levelRect = levelSurf.get_rect() \n478.     levelRect.topleft = (WINDOWWIDTH - 150, 50) \n479.     DISPLAYSURF.blit(levelSurf, levelRect) \n480.  \n481.  \n482. def drawPiece(piece, pixelx=None, pixely=None): \n483.     shapeToDraw = SHAPES[piece['shape']][piece['rotation']] \n484.     if pixelx == None and pixely == None: \n485.         # if pixelx & pixely hasn't been specified, use the location \nstored in the piece data structure \n486.         pixelx, pixely = convertToPixelCoords(piece['x'], piece['y']) \n487.  \n488.     # draw each of the blocks that make up the piece \n489.     for x in range(TEMPLATEWIDTH): \n490.         for y in range(TEMPLATEHEIGHT): \n491.             if shapeToDraw[y][x] != BLANK: \n492.                 drawBox(None, None, piece['color'], pixelx + (x * \nBOXSIZE), pixely + (y * BOXSIZE)) \n493. \n494. \n495. def drawNextPiece(piece): \n496.     # draw the \"next\" text \n497.     nextSurf = BASICFONT.render('Next:', True, TEXTCOLOR) \n498.     nextRect = nextSurf.get_rect() \n499.     nextRect.topleft = (WINDOWWIDTH - 120, 80) \n500.     DISPLAYSURF.blit(nextSurf, nextRect) \n501.     # draw the \"next\" piece \n502.     drawPiece(piece, pixelx=WINDOWWIDTH-120, pixely=100) \n503.  \n\n\n166    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n504.  \n505. if __name__ == '__main__': \n506.     main() \nThe Usual Setup Code \n  1. # Tetromino (a Tetris clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, time, pygame, sys \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 25 \n 10. WINDOWWIDTH = 640 \n 11. WINDOWHEIGHT = 480 \n 12. BOXSIZE = 20 \n 13. BOARDWIDTH = 10 \n 14. BOARDHEIGHT = 20 \n 15. BLANK = '.' \nThese are the constants used by our Tetromino game. Each box is a square that is 20 pixels wide \nand high. The board itself is 10 boxes wide and 20 boxes tall. The BLANK constant will be used \nas a value to represent blank spaces in the board’s data structure. \nSetting up Timing Constants for Holding Down Keys \n 17. MOVESIDEWAYSFREQ = 0.15 \n 18. MOVEDOWNFREQ = 0.1 \nEvery time the player pushes the left or right arrow key down, the falling piece should move one \nbox over to the left or right, respectively. However, the player can also hold down the left or right \narrow key to keep moving the falling piece. The MOVESIDEWAYSFREQ constant will set it so \nthat every 0.15 seconds that passes with the left or right arrow key held down, the piece will \nmove another space over. \nThe MOVEDOWNFREQ constant is the same thing except it tells how frequently the piece drops by \none box while the player has the down arrow key held down. \nMore Setup Code \n 20. XMARGIN = int((WINDOWWIDTH - BOARDWIDTH * BOXSIZE) / 2) \n\n\nChapter 7 - Tetromino    167 \n \n 21. TOPMARGIN = WINDOWHEIGHT - (BOARDHEIGHT * BOXSIZE) - 5 \nThe program needs to calculate how many pixels are to the left and right side of the board to use \nlater in the program. WINDOWWIDTH is the total number of pixels wide the entire window is. The \nboard is BOARDWIDTH boxes wide and each box is BOXSIZE pixels wide. If we subtract \nBOXSIZE pixels from this for each of the boxes wide in the board (which is BOARDWIDTH * \nBOXSIZE), we’ll have the size of the margin to the left and right of the board. If we divide this \nby 2, then we will have the size of just one margin. Since the margins are the same size, we can \nuse XMARGIN for either the left-side or right-side margin. \nWe can calculate the size of the space between the top of the board and the top of the window in a \nsimilar manner. The board will be drawn 5 pixels above the bottom of the window, so 5 is \nsubtracted from topmargin to account for this. \n \n 23. #               R    G    B \n 24. WHITE       = (255, 255, 255) \n 25. GRAY        = (185, 185, 185) \n 26. BLACK       = (  0,   0,   0) \n 27. RED         = (155,   0,   0) \n 28. LIGHTRED    = (175,  20,  20) \n 29. GREEN       = (  0, 155,   0) \n 30. LIGHTGREEN  = ( 20, 175,  20) \n 31. BLUE        = (  0,   0, 155) \n 32. LIGHTBLUE   = ( 20,  20, 175) \n 33. YELLOW      = (155, 155,   0) \n 34. LIGHTYELLOW = (175, 175,  20) \n\n\n168    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 35.  \n 36. BORDERCOLOR = BLUE \n 37. BGCOLOR = BLACK \n 38. TEXTCOLOR = WHITE \n 39. TEXTSHADOWCOLOR = GRAY \n 40. COLORS      = (     BLUE,      GREEN,      RED,      YELLOW) \n 41. LIGHTCOLORS = (LIGHTBLUE, LIGHTGREEN, LIGHTRED, LIGHTYELLOW) \n 42. assert len(COLORS) == len(LIGHTCOLORS) # each color must have light color \nThe pieces will come in four colors: blue, green, red, and yellow. When we draw the boxes \nthough, there will be a thin highlight on the box in a lighter color. So this means we need to create \nlight blue, light green, light red, and light yellow colors as well. \nEach of these four colors will be stored in tuples named COLORS (for the normal colors) and \nLIGHTCOLORS (for the lighter colors). \nSetting Up the Piece Templates \n 44. TEMPLATEWIDTH = 5 \n 45. TEMPLATEHEIGHT = 5 \n 46.  \n 47. S_SHAPE_TEMPLATE = [['.....', \n 48.                      '.....', \n 49.                      '..OO.', \n 50.                      '.OO..', \n 51.                      '.....'], \n 52.                     ['.....', \n 53.                      '..O..', \n 54.                      '..OO.', \n 55.                      '...O.', \n 56.                      '.....']] \n 57.  \n 58. Z_SHAPE_TEMPLATE = [['.....', \n 59.                      '.....', \n 60.                      '.OO..', \n 61.                      '..OO.', \n 62.                      '.....'], \n 63.                     ['.....', \n 64.                      '..O..', \n 65.                      '.OO..', \n 66.                      '.O...', \n 67.                      '.....']] \n 68.  \n 69. I_SHAPE_TEMPLATE = [['..O..', \n 70.                      '..O..', \n\n\nChapter 7 - Tetromino    169 \n \n 71.                      '..O..', \n 72.                      '..O..', \n 73.                      '.....'], \n 74.                     ['.....', \n 75.                      '.....', \n 76.                      'OOOO.', \n 77.                      '.....', \n 78.                      '.....']] \n 79.  \n 80. O_SHAPE_TEMPLATE = [['.....', \n 81.                      '.....', \n 82.                      '.OO..', \n 83.                      '.OO..', \n 84.                      '.....']] \n 85.  \n 86. J_SHAPE_TEMPLATE = [['.....', \n 87.                      '.O...', \n 88.                      '.OOO.', \n 89.                      '.....', \n 90.                      '.....'], \n 91.                     ['.....', \n 92.                      '..OO.', \n 93.                      '..O..', \n 94.                      '..O..', \n 95.                      '.....'], \n 96.                     ['.....', \n 97.                      '.....', \n 98.                      '.OOO.', \n 99.                      '...O.', \n100.                      '.....'], \n101.                     ['.....', \n102.                      '..O..', \n103.                      '..O..', \n104.                      '.OO..', \n105.                      '.....']] \n106.  \n107. L_SHAPE_TEMPLATE = [['.....', \n108.                      '...O.', \n109.                      '.OOO.', \n110.                      '.....', \n111.                      '.....'], \n112.                     ['.....', \n113.                      '..O..', \n114.                      '..O..', \n115.                      '..OO.', \n116.                      '.....'], \n\n\n170    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n117.                     ['.....', \n118.                      '.....', \n119.                      '.OOO.', \n120.                      '.O...', \n121.                      '.....'], \n122.                     ['.....', \n123.                      '.OO..', \n124.                      '..O..', \n125.                      '..O..', \n126.                      '.....']] \n127.  \n128. T_SHAPE_TEMPLATE = [['.....', \n129.                      '..O..', \n130.                      '.OOO.', \n131.                      '.....', \n132.                      '.....'], \n133.                     ['.....', \n134.                      '..O..', \n135.                      '..OO.', \n136.                      '..O..', \n137.                      '.....'], \n138.                     ['.....', \n139.                      '.....', \n140.                      '.OOO.', \n141.                      '..O..', \n142.                      '.....'], \n143.                     ['.....', \n144.                      '..O..', \n145.                      '.OO..', \n146.                      '..O..', \n147.                      '.....']] \nOur game program needs to know how each of the shapes are shaped, including for all of their \npossible rotations. In order to do this, we will create lists of lists of strings. The inner list of \nstrings will represent a single rotation of a shape, like this: \n['.....', \n '.....', \n '..OO.', \n '.OO..', \n '.....'] \nWe will write the rest of our code so that it interprets a list of strings like the one above to \nrepresent a shape where the periods are empty spaces and the O’s are boxes, like this: \n",
      "page_number": 179,
      "chapter_number": 21,
      "summary": "This chapter covers segment 21 (pages 179-188). Key topics include board, color, and piece.",
      "keywords": [
        "board",
        "piece",
        "BOXSIZE",
        "shape",
        "BOARDWIDTH",
        "BLANK",
        "Return True",
        "color",
        "Draw",
        "range",
        "pixelx",
        "shape piece",
        "WINDOWWIDTH",
        "BOARDHEIGHT",
        "pixely"
      ],
      "concepts": [
        "board",
        "color",
        "piece",
        "text",
        "event",
        "blank",
        "shape",
        "shaped",
        "key",
        "keys"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "Segment 11 (pages 100-107)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Building LLM Powered Applications",
          "chapter": 59,
          "title": "Segment 59 (pages 499-500)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 41,
          "title": "Segment 41 (pages 389-403)",
          "relevance_score": 0.6,
          "method": "api"
        }
      ]
    },
    {
      "number": 22,
      "title": "Segment 22 (pages 189-197)",
      "start_page": 189,
      "end_page": 197,
      "detection_method": "topic_boundary",
      "content": "Chapter 7 - Tetromino    171 \n \n \nSplitting a “Line of Code” Across Multiple Lines \nYou can see that this list is spread across many lines in the file editor. This is perfectly valid \nPython, because the Python interpreter realizes that until it sees the ] closing square bracket, the \nlist isn’t finished. The indentation doesn’t matter because Python knows you won’t have different \nindentation for a new block in the middle of a list. This code below works just fine: \nspam = ['hello', 3.14, 'world', 42, 10, 'fuzz'] \neggs = ['hello', 3.14, \n   'world' \n         , 42, \n       10, 'fuzz'] \nThough, of course, the code for the eggs list would be much more readable if we lined up all the \nitems in the list or put on a single line like spam. \nNormally, splitting a line of code across multiple lines in the file editor would require putting a \\ \ncharacter at the end of the line. The \\ tells Python, ―This code continues onto the next line.‖ (This \nslash was first used in the Sliding Puzzle game in the isValidMove() function.) \nWe will make ―template‖ data structures of the shapes by creating a list of these list of strings, \nand store them in variables such as S_SHAPE_TEMPLATE. This way, \nlen(S_SHAPE_TEMPLATE) will represent how many possible rotations there are for the S \nshape, and S_SHAPE_TEMPLATE[0] will represent the S shape’s first possible rotation. Lines \n47 to 147 will create ―template‖ data structures for each of the shapes. \nImagine that each possible piece in a tiny 5 x 5 board of empty space, with some of the spaces on \nthe board filled in with boxes. The following expressions that use S_SHAPE_TEMPLATE[0] \nare True: \nS_SHAPE_TEMPLATE[0][2][2] == 'O' \nS_SHAPE_TEMPLATE[0][2][3] == 'O' \nS_SHAPE_TEMPLATE[0][3][1] == 'O' \nS_SHAPE_TEMPLATE[0][3][2] == 'O' \nIf we represented this shape on paper, it would look something like this: \n\n\n172    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nThis is how we can represent things like Tetromino pieces as Python values such as strings and \nlists. The TEMPLATEWIDTH and TEMPLATEHEIGHT constants simply set how large each row \nand column for each shape’s rotation should be. (The templates will always be 5x5.) \n149. SHAPES = {'S': S_SHAPE_TEMPLATE, \n150.           'Z': Z_SHAPE_TEMPLATE, \n151.           'J': J_SHAPE_TEMPLATE, \n152.           'L': L_SHAPE_TEMPLATE, \n153.           'I': I_SHAPE_TEMPLATE, \n154.           'O': O_SHAPE_TEMPLATE, \n155.           'T': T_SHAPE_TEMPLATE} \nThe SHAPES variable will be a dictionary that stores all of the different templates. Because each \ntemplate has all the possible rotations of a single shape, this means that the SHAPES variable \ncontains all possible rotations of every possible shape. This will be the data structure that contains \nall of the shape data in our game. \nThe main() Function \n158. def main(): \n159.     global FPSCLOCK, DISPLAYSURF, BASICFONT, BIGFONT \n160.     pygame.init() \n161.     FPSCLOCK = pygame.time.Clock() \n162.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n163.     BASICFONT = pygame.font.Font('freesansbold.ttf', 18) \n164.     BIGFONT = pygame.font.Font('freesansbold.ttf', 100) \n165.     pygame.display.set_caption('Tetromino') \n166.  \n167.     showTextScreen('Tetromino') \n\n\nChapter 7 - Tetromino    173 \n \nThe main() function handles creating some more global constants and showing the start screen \nthat appears when the program is run.  \n168.     while True: # game loop \n169.         if random.randint(0, 1) == 0: \n170.             pygame.mixer.music.load('tetrisb.mid') \n171.         else: \n172.             pygame.mixer.music.load('tetrisc.mid') \n173.         pygame.mixer.music.play(-1, 0.0) \n174.         runGame() \n175.         pygame.mixer.music.stop() \n176.         showTextScreen('Game Over') \nThe code for the actual game is all in runGame(). The main() function here simply randomly \ndecides what background music to start playing (either the tetrisb.mid or tetrisc.mid MIDI music \nfile), then calls runGame() to begin the game. When the player loses, runGame() will return \nto main(), which then stops the background music and displays the game over screen. \nWhen the player presses a key, the showTextScreen() function that displays the game over \nscreen will return. The game loop will loop back to the beginning at line 169 and start another \ngame. \nThe Start of a New Game \n179. def runGame(): \n180.     # setup variables for the start of the game \n181.     board = getBlankBoard() \n182.     lastMoveDownTime = time.time() \n183.     lastMoveSidewaysTime = time.time() \n184.     lastFallTime = time.time() \n185.     movingDown = False # note: there is no movingUp variable \n186.     movingLeft = False \n187.     movingRight = False \n188.     score = 0 \n189.     level, fallFreq = calculateLevelAndFallFreq(score) \n190.  \n191.     fallingPiece = getNewPiece() \n192.     nextPiece = getNewPiece() \nBefore the game begins and pieces start falling, we need to initialize some variables to their start-\nof-game values. On line 191 the fallingPiece variable will be set to the currently falling \npiece that can be rotated by the player. On line 192 the nextPiece variable will be set to the \npiece that shows up in the ―Next‖ part of the screen so that player knows what piece is coming up \nafter setting the falling piece. \n\n\n174    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe Game Loop \n194.     while True: # main game loop \n195.         if fallingPiece == None: \n196.             # No falling piece in play, so start a new piece at the top \n197.             fallingPiece = nextPiece \n198.             nextPiece = getNewPiece() \n199.             lastFallTime = time.time() # reset lastFallTime \n200.  \n201.             if not isValidPosition(board, fallingPiece): \n202.                 return # can't fit a new piece on the board, so game over \n203.  \n204.         checkForQuit() \nThe main game loop that starts on line 194 handles all of the code for the main part of the game \nwhen pieces are falling to the bottom. The fallingPiece variable is set to None after the \nfalling piece has landed. This means that the piece in nextPiece should be copied to the \nfallingPiece variable, and a random new piece should be put into the nextPiece variable. \nA new piece can be generated from the getNewPiece() function. The lastFallTime \nvariable is also reset to the current time so that the piece will fall in however many seconds is in \nfallFreq.  \nThe pieces that getNewPiece() are positioned a little bit above the board, usually with part of \nthe piece already on the board. But if this is an invalid position because the board is already filled \nup there (in which case the isValidPosition() call on line 201 will return False), then \nwe know that the board is full and the player should lose the game. When this happens, the \nrunGame() function returns. \nThe Event Handling Loop \n205.         for event in pygame.event.get(): # event handling loop \n206.             if event.type == KEYUP: \nThe event handling loop takes care of when the player rotates the falling piece, moves the falling \npiece, or pauses the game. \nPausing the Game \n207.                 if (event.key == K_p): \n208.                     # Pausing the game \n209.                     DISPLAYSURF.fill(BGCOLOR) \n210.                     pygame.mixer.music.stop() \n211.                     showTextScreen('Paused') # pause until a key press \n212.                     pygame.mixer.music.play(-1, 0.0) \n\n\nChapter 7 - Tetromino    175 \n \n213.                     lastFallTime = time.time() \n214.                     lastMoveDownTime = time.time() \n215.                     lastMoveSidewaysTime = time.time() \nIf the player has pressed the P key, then the game should pause. We need to hide the board from \nthe player (otherwise the player could cheat by pausing the game and taking time to decide where \nto move the piece). \nThe code blanks out the display Surface with a call to DISPLAYSURF.fill(BGCOLOR) and \nstops the music. The showTextScreen() function is called to display the ―Paused‖ text and \nwait for the player to press a key to continue. \nOnce the player has pressed a key, showTextScreen() will return. Line 212 will restart the \nbackground music. Also, since a large amount of time could have passed since the player paused \nthe game, the lastFallTime, lastMoveDownTime, and lastMoveSidewaysTime \nvariables should all be reset to the current time (which is done on lines 213 to 215). \nUsing Movement Variables to Handle User Input \n216.                 elif (event.key == K_LEFT or event.key == K_a): \n217.                     movingLeft = False \n218.                 elif (event.key == K_RIGHT or event.key == K_d): \n219.                     movingRight = False \n220.                 elif (event.key == K_DOWN or event.key == K_s): \n221.                     movingDown = False \nLetting up on one of the arrow keys (or the WASD keys) will set the movingLeft, \nmovingRight, or movingDown variables back to False, indicating that the player no longer \nwants to move the piece in those directions. The code later will handle what to do based on the \nBoolean values inside these ―moving‖ variables. Note that the up arrow and W keys are used for \nrotating the piece, not moving the piece up. This is why there is no movingUp variable. \nChecking if a Slide or Rotation is Valid \n223.             elif event.type == KEYDOWN: \n224.                 # moving the block sideways \n225.                 if (event.key == K_LEFT or event.key == K_a) and \nisValidPosition(board, fallingPiece, adjX=-1): \n226.                     fallingPiece['x'] -= 1 \n227.                     movingLeft = True \n228.                     movingRight = False \n229.                     lastMoveSidewaysTime = time.time() \n\n\n176    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nWhen the left arrow key is pressed down (and moving to the left is a valid move for the falling \npiece, as determined by the call to isValidPosition()), then we should change the position \nto one space to the left by subtracting the value of fallingPiece['x'] by 1. The \nisValidPosition() function has optional parameters called adjX and adjY. Normally the \nisValidPosition() function checks the position of the data provided by the piece object \nthat is passed for the second parameter. However, sometimes we don’t want to check where the \npiece is currently located, but rather a few spaces over from that position. \nIf we pass -1 for the adjX (a short name for ―adjusted X‖), then it doesn’t check the validity of \nthe position in the piece’s data structure, but rather if the position of where the piece would be if \nit was one space to the left. Passing 1 for adjX would check one space to the right. There is also \nan adjY optional parameter. Passing -1 for adjY checks one space above where the piece is \ncurrently positioned, and passing a value like 3 for adjY would check three spaces down from \nwhere the piece is. \nThe movingLeft variable is set to True, and just to make sure the falling piece won’t move \nboth left and right, the movingRight variable is set to False on line 228. The \nlastMoveSidewaysTime variable will be updated to the current time on line 229. \nThese variables are set so that the player can just hold down the arrow key to keep moving the \npiece over. If the movingLeft variable is set to True, the program can know that the left \narrow key (or A key) has been pressed and not yet let go. And if 0.15 seconds (the number stored \nin MOVESIDEWAYSFREQ) has passed since the time stored in lastMoveSidewaysTime, \nthen it is time for the program to move the falling piece to the left again. \nThe lastMoveSidewaysTime works just like how the lastClickTime variable did in the \nSimulate chapter. \n231.                 elif (event.key == K_RIGHT or event.key == K_d) and \nisValidPosition(board, fallingPiece, adjX=1): \n232.                     fallingPiece['x'] += 1 \n233.                     movingRight = True \n234.                     movingLeft = False \n235.                     lastMoveSidewaysTime = time.time() \nThe code on lines 231 to 235 is almost identical to lines 225 to 229, except that it handles moving \nthe falling piece to the right when the right arrow key (or D key) has been pressed. \n237.                 # rotating the block (if there is room to rotate) \n238.                 elif (event.key == K_UP or event.key == K_w): \n\n\nChapter 7 - Tetromino    177 \n \n239.                     fallingPiece['rotation'] = (fallingPiece['rotation'] + \n1) % len(SHAPES[fallingPiece['shape']]) \nThe up arrow key (or W key) will rotate the falling piece to its next rotation. All the code has to \ndo is increment the 'rotation' key’s value in the fallingPiece dictionary by 1. \nHowever, if incrementing the 'rotation' key’s value makes it larger than the total number of \nrotations, then ―modding‖ by the total number of possible rotations for that shape (which is what \nlen(SHAPES[fallingPiece['shape']]) is) then it will ―roll over‖ to 0. \nHere’s an example of this modding with the J shape, which has 4 possible rotations: \n>>> 0 % 4 \n0 \n>>> 1 % 4 \n1 \n>>> 2 % 4 \n2 \n>>> 3 % 4 \n3 \n>>> 5 % 4 \n1 \n>>> 6 % 4 \n2 \n>>> 7 % 4 \n3 \n>>> 8 % 4 \n0 \n>>> \n240.                     if not isValidPosition(board, fallingPiece): \n241.                         fallingPiece['rotation'] = \n(fallingPiece['rotation'] - 1) % len(SHAPES[fallingPiece['shape']]) \nIf the new rotated position is not valid because it overlaps some boxes already on the board, then \nwe want to switch it back to the original rotation by subtracting 1 from \nfallingPiece['rotation']. We can also mod it by \nlen(SHAPES[fallingPiece['shape']]) so that if the new value is -1, the modding \nwill change it back to the last rotation in the list. Here’s an example of modding a negative \nnumber: \n>>> -1 % 4 \n3 \n\n\n178    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n242.                 elif (event.key == K_q): # rotate the other direction \n243.                     fallingPiece['rotation'] = (fallingPiece['rotation'] - \n1) % len(SHAPES[fallingPiece['shape']]) \n244.                     if not isValidPosition(board, fallingPiece): \n245.                         fallingPiece['rotation'] = \n(fallingPiece['rotation'] + 1) % len(SHAPES[fallingPiece['shape']]) \nLines 242 to 245 do the same thing 238 to 241, except they handle the case where the player has \npressed the Q key which rotates the piece in the opposite direction. In this case, we subtract 1 \nfrom fallingPiece['rotation'] (which is done on line 243) instead of adding 1. \n247.                 # making the block fall faster with the down key \n248.                 elif (event.key == K_DOWN or event.key == K_s): \n249.                     movingDown = True \n250.                     if isValidPosition(board, fallingPiece, adjY=1): \n251.                         fallingPiece['y'] += 1 \n252.                     lastMoveDownTime = time.time() \nIf the down arrow or S key is pressed down, then the player wants the piece to fall faster than \nnormal. Line 251 moves the piece down one space on the board (but only if it is a valid space). \nThe movingDown variable is set to True and lastMoveDownTime is reset to the current \ntime. These variables will be checked later so that the piece keeps falling at the faster rate as long \nas the down arrow or S key is held down. \nFinding the Bottom \n254.                 # move the current block all the way down \n255.                 elif event.key == K_SPACE: \n256.                     movingDown = False \n257.                     movingLeft = False \n258.                     movingRight = False \n259.                     for i in range(1, BOARDHEIGHT): \n260.                         if not isValidPosition(board, fallingPiece, \nadjY=i): \n261.                             break \n262.                     fallingPiece['y'] += i - 1 \nWhen the player presses the space key the falling piece will immediately drop down as far as it \ncan go on the board and land. The program first needs to find out how many spaces the piece can \nmove until it lands. \nLines 256 to 258 will set all the moving variables to False (which makes the code in later parts \nof the programming think that the user has let up on any arrow keys that were held down). This is \n\n\nChapter 7 - Tetromino    179 \n \ndone because this code will move the piece to the absolute bottom and begin falling the next \npiece, and we don’t want to surprise the player by having those pieces immediately start moving \njust because they were holding down an arrow key when they hit the space key. \nTo find the farthest that the piece can fall, we should first call isValidPosition() and pass \nthe integer 1 for the adjY parameter. If isValidPosition() returns False, we know that \nthe piece cannot fall any further and is already at the bottom. If isValidPosition() returns \nTrue, then we know that it can fall 1 space down. \nIn that case, we should call isValidPosition() with adjY set to 2. If it returns True \nagain, we will call isValidPosition() with adjY set to 3, and so on. This is what the for \nloop on line 259 handles: calling isValidPosition() with increasing integer values to pass \nfor adjY until the function call returns False. At that point, we know that the value in i is one \nspace more past the bottom. This is why line 262 increases fallingPiece['y'] by i - 1 \ninstead of i. \n(Also note that the second parameter to range() on line 259’s for statement is set to \nBOARDHEIGHT because this is the maximum amount that the piece could fall before it must hit \nthe bottom of the board.) \nMoving by Holding Down the Key \n264.         # handle moving the block because of user input \n265.         if (movingLeft or movingRight) and time.time() - \nlastMoveSidewaysTime > MOVESIDEWAYSFREQ: \n266.             if movingLeft and isValidPosition(board, fallingPiece, adjX=-\n1): \n267.                 fallingPiece['x'] -= 1 \n268.             elif movingRight and isValidPosition(board, fallingPiece, \nadjX=1): \n269.                 fallingPiece['x'] += 1 \n270.             lastMoveSidewaysTime = time.time() \nRemember that on line 227 the movingLeft variable was set to True if the player pressed \ndown on the left arrow key? (The same for line 233 where movingRight was set to True if \nthe player pressed down on the right arrow key.) The moving variables were set back to False if \nthe user let up on these keys also (see line 217 and 219). \nWhat also happened when the player pressed down on the left or right arrow key was that the \nlastMoveSidewaysTime variable was set to the current time (which was the return value of \ntime.time()). If the player continued to hold down the arrow key without letting up on it, \nthen the movingLeft or movingRight variable would still be set to True. \n",
      "page_number": 189,
      "chapter_number": 22,
      "summary": "This chapter covers segment 22 (pages 189-197). Key topics include keys, variables. This is perfectly valid \nPython, because the Python interpreter realizes that until it sees the ] closing square bracket, the \nlist isn’t finished.",
      "keywords": [
        "SHAPE",
        "piece",
        "fallingPiece",
        "template",
        "game",
        "key",
        "Line",
        "variable",
        "player",
        "board",
        "arrow key",
        "rotation",
        "isValidPosition",
        "SHAPES variable",
        "event.key"
      ],
      "concepts": [
        "key",
        "keys",
        "variables",
        "variable",
        "game",
        "line",
        "lined",
        "time",
        "rotations",
        "rotation"
      ],
      "similar_chapters": [
        {
          "book": "Fluent Python 2nd",
          "chapter": 7,
          "title": "Segment 7 (pages 128-146)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 5,
          "title": "Segment 5 (pages 35-42)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 4,
          "title": "Segment 4 (pages 27-34)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 32,
          "title": "Segment 32 (pages 336-344)",
          "relevance_score": 0.51,
          "method": "api"
        }
      ]
    },
    {
      "number": 23,
      "title": "Segment 23 (pages 198-212)",
      "start_page": 198,
      "end_page": 212,
      "detection_method": "topic_boundary",
      "content": "180    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nIf the user held down on the key for longer than 0.15 seconds (the value stored in \nMOVESIDEWAYSFREQ is the float 0.15) then the expression time.time() - \nlastMoveSidewaysTime > MOVESIDEWAYSFREQ would evaluate to True. Line 265’s \ncondition is True if the user has both held down the arrow key and 0.15 seconds has passed, and \nin that case we should move the falling piece to the left or right even though the user hasn’t \npressed the arrow key again. \nThis is very useful because it would become tiresome for the player to repeatedly hit the arrow \nkeys to get the falling piece to move over multiple spaces on the board. Instead, they can just hold \ndown an arrow key and the piece will keep moving over until they let up on the key. When that \nhappens, the code on lines 216 to 221 will set the moving variable to False and the condition on \nline 265 will be False. That is what stops the falling piece from sliding over more. \nTo demonstrate why the time.time() - lastMoveSidewaysTime > \nMOVESIDEWAYSFREQ returns True after the number of seconds in MOVESIDEWAYSFREQ has \npassed, run this short program: \nimport time \n \nWAITTIME = 4 \nbegin = time.time() \n \nwhile True: \n    now = time.time() \n    message = '%s, %s, %s' % (begin, now, (now - begin)) \n    if now - begin > WAITTIME: \n        print(message + ' PASSED WAIT TIME!') \n    else: \n        print(message + ' Not yet...') \n    time.sleep(0.2) \nThis program has an infinite loop, so in order to terminate it, press Ctrl-C. The output of this \nprogram will look something like this: \n1322106392.2, 1322106392.2, 0.0 Not yet... \n1322106392.2, 1322106392.42, 0.219000101089 Not yet... \n1322106392.2, 1322106392.65, 0.449000120163 Not yet... \n1322106392.2, 1322106392.88, 0.680999994278 Not yet... \n1322106392.2, 1322106393.11, 0.910000085831 Not yet... \n1322106392.2, 1322106393.34, 1.1400001049 Not yet... \n1322106392.2, 1322106393.57, 1.3710000515 Not yet... \n1322106392.2, 1322106393.83, 1.6360001564 Not yet... \n1322106392.2, 1322106394.05, 1.85199999809 Not yet... \n\n\nChapter 7 - Tetromino    181 \n \n1322106392.2, 1322106394.28, 2.08000016212 Not yet... \n1322106392.2, 1322106394.51, 2.30900001526 Not yet... \n1322106392.2, 1322106394.74, 2.54100012779 Not yet... \n1322106392.2, 1322106394.97, 2.76999998093 Not yet... \n1322106392.2, 1322106395.2, 2.99800014496 Not yet... \n1322106392.2, 1322106395.42, 3.22699999809 Not yet... \n1322106392.2, 1322106395.65, 3.45600008965 Not yet... \n1322106392.2, 1322106395.89, 3.69200015068 Not yet... \n1322106392.2, 1322106396.12, 3.92100000381 Not yet... \n1322106392.2, 1322106396.35, 4.14899992943 PASSED WAIT TIME! \n1322106392.2, 1322106396.58, 4.3789999485 PASSED WAIT TIME! \n1322106392.2, 1322106396.81, 4.60700011253 PASSED WAIT TIME! \n1322106392.2, 1322106397.04, 4.83700013161 PASSED WAIT TIME! \n1322106392.2, 1322106397.26, 5.06500005722 PASSED WAIT TIME! \nTraceback (most recent call last): \n  File \"C:\\timetest.py\", line 13, in <module> \n    time.sleep(0.2) \nKeyboardInterrupt \nThe first number on each line of output is the return value of time.time() when the program \nfirst started (and this value never changes). The second number is the latest return value from \ntime.time() (this value keeps getting updated on each iteration of the loop). And the third \nnumber is the current time minus the start time. This third number is the number of seconds that \nhave elapsed since the begin = time.time() line of code was executed. \nIf this number is greater than 4, the code will start printing ―PASSED WAIT TIME!‖ instead of \n―Not yet...‖. This is how our game program can know if a certain amount of time has passed since \na line of code was run. \nIn our Tetromino program, the time.time() – lastMoveSidewaysTime expression will \nevaluate to the number of seconds that has elapsed since the last time \nlastMoveSidewaysTime was set to the current time. If this value is greater than the value in \nMOVESIDEWAYSFREQ, we know it is time for the code to move the falling piece over one more \nspace. \nDon’t forget to update lastMoveSidewaysTime to the current time again! This is what we \ndo on line 270. \n272.         if movingDown and time.time() - lastMoveDownTime > MOVEDOWNFREQ \nand isValidPosition(board, fallingPiece, adjY=1): \n273.             fallingPiece['y'] += 1 \n274.             lastMoveDownTime = time.time() \n\n\n182    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nLines 272 to 274 do almost the same thing as lines 265 to 270 do except for moving the falling \npiece down. This has a separate move variable (movingDown) and ―last time‖ variable \n(lastMoveDownTime) as well as a different ―move frequency‖ variable (MOVEDOWNFREQ).  \nLetting the Piece “Naturally” Fall \n276.         # let the piece fall if it is time to fall \n277.         if time.time() - lastFallTime > fallFreq: \n278.             # see if the piece has landed \n279.             if not isValidPosition(board, fallingPiece, adjY=1): \n280.                 # falling piece has landed, set it on the board \n281.                 addToBoard(board, fallingPiece) \n282.                 score += removeCompleteLines(board) \n283.                 level, fallFreq = calculateLevelAndFallFreq(score) \n284.                 fallingPiece = None \n285.             else: \n286.                 # piece did not land, just move the block down \n287.                 fallingPiece['y'] += 1 \n288.                 lastFallTime = time.time() \nThe rate that the piece is naturally moving down (that is, falling) is tracked by the \nlastFallTime variable. If enough time has elapsed since the falling piece last fell down one \nspace, lines 279 to 288 will handle dropping the piece by one space. \nIf the condition on line 279 is True, then the piece has landed. The call to addToBoard() will \nmake the piece part of the board data structure (so that future pieces can land on it), and the \nremoveCompleteLines() call will handle erasing any complete lines on the board and \npulling the boxes down. The removeCompleteLines() function also returns an integer \nvalue of how many lines were removed, so we add this number to the score.  \nBecause the score may have changed, we call the calculateLevelAndFallFreq() \nfunction to update the current level and frequency that the pieces fall. And finally, we set the \nfallingPiece variable to None to indicate that the next piece should become the new falling \npiece, and a random new piece should be generated for the new next piece. (That is done on lines \n195 to 199 at the beginning of the game loop.) \nIf the piece has not landed, we simply set its Y position down one space (on line 287) and reset \nlastFallTime to the current time (on line 288). \nDrawing Everything on the Screen \n290.         # drawing everything on the screen \n291.         DISPLAYSURF.fill(BGCOLOR) \n292.         drawBoard(board) \n\n\nChapter 7 - Tetromino    183 \n \n293.         drawStatus(score, level) \n294.         drawNextPiece(nextPiece) \n295.         if fallingPiece != None: \n296.             drawPiece(fallingPiece) \n297.  \n298.         pygame.display.update() \n299.         FPSCLOCK.tick(FPS) \nNow that the game loop has handled all events and updated the game state, the game loop just \nneeds to draw the game state to the screen. Most of the drawing is handled by other functions, so \nthe game loop code just needs to call those functions. Then the call to \npygame.display.update() makes the display Surface appear on the actual computer \nscreen, and the tick() method call adds a slight pause so the game doesn’t run too fast. \nmakeTextObjs(), A Shortcut Function for Making Text \n302. def makeTextObjs(text, font, color): \n303.     surf = font.render(text, True, color) \n304.     return surf, surf.get_rect() \nThe makeTextObjs() function just provides us with a shortcut. Given the text, Font object, \nand a Color object, it calls render() for us and returns the Surface and Rect object for this text. \nThis just saves us from typing out the code to create the Surface and Rect object each time we \nneed them. \nThe Same Old terminate() Function \n307. def terminate(): \n308.     pygame.quit() \n309.     sys.exit() \nThe terminate() function works the same as in the previous game programs. \nWaiting for a Key Press Event with the checkForKeyPress() \nFunction \n312. def checkForKeyPress(): \n313.     # Go through event queue looking for a KEYUP event. \n314.     # Grab KEYDOWN events to remove them from the event queue. \n315.     checkForQuit() \n316. \n317.     for event in pygame.event.get([KEYDOWN, KEYUP]): \n318.         if event.type == KEYDOWN: \n\n\n184    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n319.             continue \n320.         return event.key \n321.     return None \nThe checkForKeyPress() function works almost the same as it did in the Wormy game. \nFirst it calls checkForQuit() to handle any QUIT events (or KEYUP events specifically for \nthe Esc key) and terminates the program if there are any. Then it pulls out all the KEYUP and \nKEYDOWN events from the event queue. It ignores any KEYDOWN events (KEYDOWN was \nspecified to pygame.event.get() only to clear those events out of the event queue). \nIf there were no KEYUP events in the event queue, then the function returns None. \nshowTextScreen(), A Generic Text Screen Function \n324. def showTextScreen(text): \n325.     # This function displays large text in the \n326.     # center of the screen until a key is pressed. \n327.     # Draw the text drop shadow \n328.     titleSurf, titleRect = makeTextObjs(text, BIGFONT, TEXTSHADOWCOLOR) \n329.     titleRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2)) \n330.     DISPLAYSURF.blit(titleSurf, titleRect) \n331.  \n332.     # Draw the text \n333.     titleSurf, titleRect = makeTextObjs(text, BIGFONT, TEXTCOLOR) \n334.     titleRect.center = (int(WINDOWWIDTH / 2) - 3, int(WINDOWHEIGHT / 2) - \n3) \n335.     DISPLAYSURF.blit(titleSurf, titleRect) \n336.  \n337.     # Draw the additional \"Press a key to play.\" text. \n338.     pressKeySurf, pressKeyRect = makeTextObjs('Press a key to play.', \nBASICFONT, TEXTCOLOR) \n339.     pressKeyRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2) + \n100) \n340.     DISPLAYSURF.blit(pressKeySurf, pressKeyRect) \nInstead of separate functions for the start screen and game over screens, we will create one \ngeneric function named showTextScreen(). The showTextScreen() function will draw \nwhatever text we pass for the text parameter. Also, the text ―Press a key to play.‖ will be \ndisplayed in addition. \nNotice that lines 328 to 330 draw the text in a darker shadow color first, and then lines 333 to 335 \ndraw the same text again, except offset by 3 pixels to the left and 3 pixels upward. This creates a \n―drop shadow‖ effect that makes the text look a bit prettier. You can compare the difference by \ncommenting out lines 328 to 330 to see the text without a drop shadow. \n\n\nChapter 7 - Tetromino    185 \n \nThe showTextScreen() will be used for the start screen, the game over screen, and also for a \npause screen. (The pause screen is explained later in this chapter.) \n342.     while checkForKeyPress() == None: \n343.         pygame.display.update() \n344.         FPSCLOCK.tick() \nWe want the text to stay on the screen until the user presses a key. This small loop will constantly \ncall pygame.display.update() and FPSCLOCK.tick() until \ncheckForKeyPress() returns a value other than None. This happens when the user presses \na key. \nThe checkForQuit() Function \n347. def checkForQuit(): \n348.     for event in pygame.event.get(QUIT): # get all the QUIT events \n349.         terminate() # terminate if any QUIT events are present \n350.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n351.         if event.key == K_ESCAPE: \n352.             terminate() # terminate if the KEYUP event was for the Esc key \n353.         pygame.event.post(event) # put the other KEYUP event objects back \nThe checkForQuit() function can be called to handle any events that will cause the program \nto terminate. This happens if there are any QUIT events in the event queue (this is handle by lines \n348 and 349), or if there is a KEYUP event of the Esc key. The player should be able to press the \nEsc key at any time to quit the program. \nBecause the pygame.event.get() call on line 350 pulls out all of the KEYUP events \n(including events for keys other than the Esc key), if the event is not for the Esc key, we want to \nput it back into the event queue by calling the pygame.event.post() function. \nThe calculateLevelAndFallFreq() Function \n356. def calculateLevelAndFallFreq(score): \n357.     # Based on the score, return the level the player is on and \n358.     # how many seconds pass until a falling piece falls one space. \n359.     level = int(score / 10) + 1 \n360.     fallFreq = 0.27 - (level * 0.02) \n361.     return level, fallFreq \nEvery time the player completes a line, their score will increase by one point. Every ten points, \nthe game goes up a level and the pieces start falling down faster. Both the level and the falling \nfrequency can be calculated from the score that is passed to this function. \n\n\n186    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nTo calculate the level, we use the int() function to round down the score divided by 10. So if \nthe score any number between 0 and 9, the int() call will round it down to 0. The + 1 part of \nthe code is there because we want the first level to be level 1, not level 0. When the score reaches \n10, then int(10 / 10) will evaluate to 1, and the + 1 will make the level 2. Here is a graph \nshowing the values of level for the scores 1 to 34: \n \nTo calculate the falling frequency, we start with a base time of 0.27 (meaning that the piece will \nnaturally fall once every 0.27 seconds). Then we multiply the level by 0.02, and subtract that \nfrom the 0.27 base time. So on level 1, we subtract 0.02 * 1 (that is, 0.02) from 0.27 to \nget 0.25. On level 2, we subtract 0.02 * 2 (that is, 0.04) to get 0.23. You can think of the \nlevel * 0.02 part of the equation as ―for every level, the piece will fall 0.02 seconds faster \nthan the previous level.‖ \nWe can also make a graph showing how fast the pieces will fall at each level of the game: \n0\n1\n2\n3\n4\n5\n1\n3\n5\n7\n9\n11\n13 15\n17 19\n21 23 25\n27 29\n31 33\nLevel \nScore \nlevel = int(score / 10) + 1 \n\n\nChapter 7 - Tetromino    187 \n \n \nYou can see that at level 14, the falling frequency will be less than 0. This won’t cause any bugs \nwith our code, because line 277 just checks that the elapsed time since the falling piece last fell \none space is greater than the calculated falling frequency. So if the falling frequency is negative, \nthen the condition on line 277 will always be True and the piece will fall on every iteration of \nthe game loop. From level 14 and beyond, the piece cannot fall any faster. \nIf the FPS is set at 25, this means that at reaching level 14, the falling piece will fall 25 spaces a \nsecond. Considering that the board is only 20 spaces tall, that means the player will have less than \na second to set each piece! \nIf you want the pieces to start (if you can see what I mean) falling faster at a slower rate, you can \nchange the equation that the calculateLevelAndFallFreq() uses. For example, let’s say \nline 360 was this: \n360.     fallFreq = 0.27 - (level * 0.01) \nIn the above case, the pieces would only fall 0.01 seconds faster on each level rather than 0.02 \nseconds faster. The graph would look like this (the original line is also in the graph in light grey): \n-0.05\n0\n0.05\n0.1\n0.15\n0.2\n0.25\n0.3\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nFall Frequency (seconds) \nLevel \nfallFreq = 0.27 - (level * 0.02) \n\n\n188    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nAs you can see, with this new equation, level 14 would only be as hard as the original level 7. \nYou can change the game to be as difficult or easy as you like by changing the equations in \ncalculateLevelAndFallFreq(). \nGenerating Pieces with the getNewPiece() Function \n363. def getNewPiece(): \n364.     # return a random new piece in a random rotation and color \n365.     shape = random.choice(list(SHAPES.keys())) \n366.     newPiece = {'shape': shape, \n367.                 'rotation': random.randint(0, len(SHAPES[shape]) - 1), \n368.                 'x': int(BOARDWIDTH / 2) - int(TEMPLATEWIDTH / 2), \n369.                 'y': -2, # start it above the board (i.e. less than 0) \n370.                 'color': random.randint(0, len(COLORS)-1)} \n371.     return newPiece \nThe getNewPiece() function generates a random piece that is positioned at the top of the \nboard. First, to randomly choose the shape of the piece, we create a list of all the possible shapes \nby calling list(SHAPES.keys()) on line 365. The keys() dictionary method returns a \nvalue of the data type ―dict_keys‖, which must be converted to a list value with the list() \nfunction before being passed to random.choice(). This is because the random.choice() \nfunction only accepts list values for its parameter. The random.choice() function then \nrandomly returns the value of an item from the list. \nThe piece data structures are simply a dictionary value with the keys 'shape', 'rotation', \n'x', 'y', and 'color'. \n-0.05\n0\n0.05\n0.1\n0.15\n0.2\n0.25\n0.3\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nFall Frequency (seconds) \nLevel \nfallFreq = 0.27 - (level * 0.01) \n\n\nChapter 7 - Tetromino    189 \n \nThe value for the 'rotation' key is a random integer between 0 to one less than however \nmany possible rotations there are for that shape. The number of rotations for a shape can be found \nfrom the expression len(SHAPES[shape]). \nNotice that we don’t store the list of string values (like the ones store in the constants like \nS_SHAPE_TEMPLATE) in each piece data structure to represent the boxes of each piece. Instead, \nwe just store an index for the shape and rotation which refer to the PIECES constant. \nThe 'x' key’s value is always set to the middle of the board (also accounting for the width of the \npieces themselves, which is found from our TEMPLATEWIDTH constant). The 'y' key’s value is \nalways set to -2 to place it slightly above the board. (The top row of the board is row 0.) \nSince the COLORS constant is a tuple of the different colors, selecting a random number from 0 \nto the length of COLORS (subtracting one) will give us a random index value for the piece’s \ncolor. \nOnce all of the values in the newPiece dictionary are set, the getNewPiece() function \nreturns newPiece.  \nAdding Pieces to the Board Data Structure \n374. def addToBoard(board, piece): \n375.     # fill in the board based on piece's location, shape, and rotation \n376.     for x in range(TEMPLATEWIDTH): \n377.         for y in range(TEMPLATEHEIGHT): \n378.             if SHAPES[piece['shape']][piece['rotation']][y][x] != BLANK: \n379.                 board[x + piece['x']][y + piece['y']] = piece['color'] \nThe board data structure is a data representation for the rectangular space where pieces that have \npreviously landed are tracked. The currently falling piece is not marked on the board data \nstructure. What the addToBoard() function does is takes a piece data structure and adds its \nboxes to the board data structure. This happens after a piece has landed. \nThe nested for loops on lines 376 and 377 go through every space in the piece data structure, \nand if it finds a box in the space (line 378), it adds it to the board (line 379). \nCreating a New Board Data Structure \n382. def getBlankBoard(): \n383.     # create and return a new blank board data structure \n384.     board = [] \n385.     for i in range(BOARDWIDTH): \n386.         board.append([BLANK] * BOARDHEIGHT) \n\n\n190    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n387.     return board \nThe data structure used for the board is fairly simple: it’s a list of lists of values. If the value is the \nsame as the value in BLANK, then it is an empty space. If the value is an integer, then it represents \na box that is the color that the integer indexes in the COLORS constant list. That is, 0 is blue, 1 is \ngreen, 2 is red, and 3 is yellow. \nIn order to create a blank board, list replication is used to create the lists of BLANK values which \nrepresents a column. This is done on line 386. One of these lists is created for each of the \ncolumns in the board (this is what the for loop on line 385 does). \nThe isOnBoard() and isValidPosition() Functions \n390. def isOnBoard(x, y): \n391.     return x >= 0 and x < BOARDWIDTH and y < BOARDHEIGHT \nThe isOnBoard() is a simple function which checks that the XY coordinates that are passed \nrepresent valid values that exist on the board. As long as both the XY coordinates are not less 0 \nor greater than or equal to the BOARDWIDTH and BOARDHEIGHT constants, then the function \nreturns True.  \n394. def isValidPosition(board, piece, adjX=0, adjY=0): \n395.     # Return True if the piece is within the board and not colliding \n396.     for x in range(TEMPLATEWIDTH): \n397.         for y in range(TEMPLATEHEIGHT): \n398.             isAboveBoard = y + piece['y'] + adjY < 0 \n399.             if isAboveBoard or \nSHAPES[piece['shape']][piece['rotation']][y][x] == BLANK: \n400.                 continue \nThe isValidPosition() function is given a board data structure and a piece data structure, \nand returns True if all the boxes in the piece are both on the board and not overlapping any \nboxes on the board. This is done by taking the piece’s XY coordinates (which is really the \ncoordinate of the upper right box on the 5x5 boxes for the piece) and adding the coordinate inside \nthe piece data structure. Here’s a couple pictures to help illustrate this: \n\n\nChapter 7 - Tetromino    191 \n \n \n \nThe board with a falling piece in a valid \nposition. \nThe board with the falling piece in an invalid \nposition. \n \nOn the left board, the falling piece’s (that is, the top left corner of the falling piece’s) XY \ncoordinates are (2, 3) on the board. But the boxes inside the falling piece’s coordinate system \nhave their own coordinates. To find the ―board‖ coordinates of these pieces, we just have to add \nthe ―board‖ coordinates of the falling piece’s top left box and the ―piece‖ coordinates of the \nboxes. \nOn the left board, the falling piece’s boxes are at the following ―piece‖ coordinates: \n \n(2, 2) \n(3, 2) \n(1, 3) \n(2, 3) \nWhen we add the (2, 3) coordinate (the piece’s coordinates on the board) to these coordinates, it \nlooks like this: \n \n(2 + 2, 2 + 3) \n(3 + 2, 2 + 3) \n(1 + 2, 3 + 3) \n(2 + 2, 3 + 3) \nAfter adding the (2, 3) coordinate the boxes are at the following ―board‖ coordinates: \n \n(4, 5) \n(5, 5) \n(3, 6) \n(4, 6) \n\n\n192    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nAnd now that we can figure out where the falling piece’s boxes are as board coordinates, we can \nsee if they overlap with the landed boxes that are already on the board. The nested for loops on \nlines 396 and 397 go through each of the possible coordinates on the falling piece. \nWe want to check if a box of the falling piece is either off of the board or overlapping a box on \nthe board. (Although one exception is if the box is above the board, which is where it could be \nwhen the falling piece just begins falling.) Line 398 creates a variable named isAboveBoard \nthat is set to True if the box on the falling piece at the coordinates pointed to be x and y is above \nthe board. Otherwise it is set to False. \nThe if statement on line 399 checks if the space on the piece is above the board or is blank. If \neither of those is True, then the code executes a continue statement and goes to the next \niteration. (Note that the end of line 399 has [y][x] instead of [x][y]. This is because the \ncoordinates in the PIECES data structure are reversed. See the previous section, ―Setting Up the \nPiece Templates‖). \n401.             if not isOnBoard(x + piece['x'] + adjX, y + piece['y'] + \nadjY): \n402.                 return False \n403.             if board[x + piece['x'] + adjX][y + piece['y'] + adjY] != \nBLANK: \n404.                 return False \n405.     return True \nThe if statement on line 401 checks that the piece’s box is not located on the board. The if \nstatement on line 403 checks that the board space the piece’s box is located is not blank. If either \nof these conditions are True, then the isValidPosition() function will return False. \nNotice that these if statements also adjust the coordinates for the adjX and adjY parameters \nthat were passed in to the function. \nIf the code goes through the nested for loop and hasn’t found a reason to return False, then the \nposition of the piece must be valid and so the function returns True on line 405. \nChecking for, and Removing, Complete Lines \n407. def isCompleteLine(board, y): \n408.     # Return True if the line filled with boxes with no gaps. \n409.     for x in range(BOARDWIDTH): \n410.         if board[x][y] == BLANK: \n411.             return False \n412.     return True \n\n\nChapter 7 - Tetromino    193 \n \nThe isCompleteLine does a simple check at the row specified by the y parameter. A row on \nthe board is considered to be ―complete‖ when every space is filled by a box. The for loop on \nline 409 goes through each space in the row. If a space is blank (which is caused by it having the \nsame value as the BLANK constant), then the function return False. \n415. def removeCompleteLines(board): \n416.     # Remove any completed lines on the board, move everything above them \ndown, and return the number of complete lines. \n417.     numLinesRemoved = 0 \n418.     y = BOARDHEIGHT - 1 # start y at the bottom of the board \n419.     while y >= 0: \nThe removeCompleteLines() function will find any complete lines in the passed board data \nstructure, remove the lines, and then shift all the boxes on the board above that line down one \nrow. The function will return the number of lines that were removed (which is tracked by the \nnumLinesRemoved variable) so that this can be added to the score. \nThe way this function works is by running in a loop starting on line 419 with the y variable \nstarting at the lowest row (which is BOARDHEIGHT - 1). Whenever the row specified by y is \nnot complete, y will be decremented to the next highest row. The loop finally stops once y \nreaches -1. \n420.         if isCompleteLine(board, y): \n421.             # Remove the line and pull boxes down by one line. \n422.             for pullDownY in range(y, 0, -1): \n423.                 for x in range(BOARDWIDTH): \n424.                     board[x][pullDownY] = board[x][pullDownY-1] \n425.             # Set very top line to blank. \n426.             for x in range(BOARDWIDTH): \n427.                 board[x][0] = BLANK \n428.             numLinesRemoved += 1 \n429.             # Note on the next iteration of the loop, y is the same. \n430.             # This is so that if the line that was pulled down is also \n431.             # complete, it will be removed. \n432.         else: \n433.             y -= 1 # move on to check next row up \n434.     return numLinesRemoved \nThe isCompleteLine() function will return True if the line that y is referring to is \ncomplete. In that case, the program needs to copy the values of each row above the removed line \nto the next lowest line. This is what the for loop on line 422 does (which is why its call to the \nrange() function begins at y, rather than 0. Also note that it uses the three argument form of \n\n\n194    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nrange(), so that the list it returns starts at y, ends at 0, and after each iteration ―increases‖ by -\n1.) \nLet’s look at the following example. To save space, only the top five rows of the board are \nshown. Row 3 is a complete line, which means that all the rows above it (row 2, 1, and 0) must be \n―pulled down‖. First, row 2 is copied down to row 3. The board on the right shows what the board \nwill look like after this is done: \n \nThis ―pulling down‖ is really just copying the higher row’s values to the row below it on line 424. \nAfter row 2 is copied to row 3, then row 1 is copied to row 2 followed by row 0 copied to row 1: \n \n \nRow 0 (the row at the very top) doesn’t have a row above it to copy values down. But row 0 \ndoesn’t need a row copied to it, it just needs all the spaces set to BLANK. This is what lines 426 \nand 427 do. After that, the board will have changed from the board shown below on the left to the \nboard shown below on the right: \n \nAfter the complete line is removed, the execution reaches the end of the while loop that started \non line 419, so the execution jumps back to the beginning of the loop. Note that at no point when \n",
      "page_number": 198,
      "chapter_number": 23,
      "summary": "This chapter covers segment 23 (pages 198-212). Key topics include function, functions, and board. Covers function. When that \nhappens, the code on lines 216 to 221 will set the moving variable to False and the condition on \nline 265 will be False.",
      "keywords": [
        "piece",
        "falling piece",
        "board",
        "PASSED WAIT TIME",
        "Line",
        "board data structure",
        "function",
        "piece data structure",
        "level",
        "function returns True",
        "falling",
        "time",
        "board data",
        "WAIT TIME",
        "PASSED WAIT"
      ],
      "concepts": [
        "function",
        "functions",
        "board",
        "returns",
        "time",
        "line",
        "pieces",
        "text",
        "fall",
        "level"
      ],
      "similar_chapters": [
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 54,
          "title": "Segment 54 (pages 1084-1102)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 17,
          "title": "Segment 17 (pages 144-151)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 40,
          "title": "Segment 40 (pages 368-375)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 17,
          "title": "Segment 17 (pages 331-351)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 40,
          "title": "Segment 40 (pages 809-829)",
          "relevance_score": 0.52,
          "method": "api"
        }
      ]
    },
    {
      "number": 24,
      "title": "Segment 24 (pages 213-221)",
      "start_page": 213,
      "end_page": 221,
      "detection_method": "topic_boundary",
      "content": "Chapter 7 - Tetromino    195 \n \nthe line was being removed and the rows being pulled down that the y variable changed at all. So \non the next iteration, the y variable is pointing to the same row as before. \nThis is needed because if there were two complete lines, then the second complete line would \nhave been pulled down and would also have to be removed. The code will then remove this \ncomplete line, and then go to the next iteration. It is only when there is not a completed line that \nthe y variable is decremented on line 433. Once the y variable has been decremented all the way \nto 0, the execution will exit the while loop. \nConvert from Board Coordinates to Pixel Coordinates  \n437. def convertToPixelCoords(boxx, boxy): \n438.     # Convert the given xy coordinates of the board to xy  \n439.     # coordinates of the location on the screen. \n440.     return (XMARGIN + (boxx * BOXSIZE)), (TOPMARGIN + (boxy * BOXSIZE)) \nThis helper function converts the board’s box coordinates to pixel coordinates. This function \nworks the same way to the other ―convert coordinates‖ functions used in the previous game \nprograms. \nDrawing a Box on the Board or Elsewhere on the Screen \n443. def drawBox(boxx, boxy, color, pixelx=None, pixely=None): \n444.     # draw a single box (each tetromino piece has four boxes) \n445.     # at xy coordinates on the board. Or, if pixelx & pixely \n446.     # are specified, draw to the pixel coordinates stored in \n447.     # pixelx & pixely (this is used for the \"Next\" piece). \n448.     if color == BLANK: \n449.         return \n450.     if pixelx == None and pixely == None: \n451.         pixelx, pixely = convertToPixelCoords(boxx, boxy) \n452.     pygame.draw.rect(DISPLAYSURF, COLORS[color], (pixelx + 1, pixely + 1, \nBOXSIZE - 1, BOXSIZE - 1)) \n453.     pygame.draw.rect(DISPLAYSURF, LIGHTCOLORS[color], (pixelx + 1, pixely \n+ 1, BOXSIZE - 4, BOXSIZE - 4)) \nThe drawBox() function draws a single box on the screen. The function can receive boxx and \nboxy parameters for board coordinates where the box should be drawn. However, if the pixelx \nand pixely parameters are specified, then these pixel coordinates will override the boxx and \nboxy parameters. The pixelx and pixely parameters are used to draw the boxes of the \n―Next‖ piece, which is not on the board. \nIf the pixelx and pixely parameters are not set, then they will be set to None by default \nwhen the function first begins. Then the if statement on line 450 will overwrite the None values \n\n\n196    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nwith the return values from convertToPixelCoords(). This call gets the pixel coordinates \nof the board coordinates specified by boxx and boxy. \nThe code won’t fill the entire box’s space with color. To have a black outline in between the \nboxes of a piece, the left and top parameters in the pygame.draw.rect() call have + 1 \nadded to them and a - 1 is added to the width and height parameters. In order to draw the \nhighlighted box, first the box is drawn with the darker color on line 452. Then, a slightly smaller \nbox is drawn on top of the darker box on line 453. \nDrawing Everything to the Screen \n456. def drawBoard(board): \n457.     # draw the border around the board \n458.     pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (XMARGIN - 3, TOPMARGIN - \n7, (BOARDWIDTH * BOXSIZE) + 8, (BOARDHEIGHT * BOXSIZE) + 8), 5) \n459.  \n460.     # fill the background of the board \n461.     pygame.draw.rect(DISPLAYSURF, BGCOLOR, (XMARGIN, TOPMARGIN, BOXSIZE * \nBOARDWIDTH, BOXSIZE * BOARDHEIGHT)) \n462.     # draw the individual boxes on the board \n463.     for x in range(BOARDWIDTH): \n464.         for y in range(BOARDHEIGHT): \n465.             drawBox(x, y, board[x][y]) \nThe drawBoard() function is responsible for calling the drawing functions for the board’s \nborder and all the boxes on the board. First the board’s border is drawn on DISPLAYSURF, \nfollowed by the background color of the board. Then a call to drawBox() is made for each \nspace on the board. The drawBox() function is smart enough to leave out the box if \nboard[x][y] is set to BLANK. \nDrawing the Score and Level Text \n468. def drawStatus(score, level): \n469.     # draw the score text \n470.     scoreSurf = BASICFONT.render('Score: %s' % score, True, TEXTCOLOR) \n471.     scoreRect = scoreSurf.get_rect() \n472.     scoreRect.topleft = (WINDOWWIDTH - 150, 20) \n473.     DISPLAYSURF.blit(scoreSurf, scoreRect) \n474.  \n475.     # draw the level text \n476.     levelSurf = BASICFONT.render('Level: %s' % level, True, TEXTCOLOR) \n477.     levelRect = levelSurf.get_rect() \n478.     levelRect.topleft = (WINDOWWIDTH - 150, 50) \n479.     DISPLAYSURF.blit(levelSurf, levelRect) \n\n\nChapter 7 - Tetromino    197 \n \nThe drawStatus() function is responsible for rendering the text for the ―Score:‖ and ―Level:‖ \ninformation that appears in the upper right of the corner of the screen. \nDrawing a Piece on the Board or Elsewhere on the Screen \n482. def drawPiece(piece, pixelx=None, pixely=None): \n483.     shapeToDraw = SHAPES[piece['shape']][piece['rotation']] \n484.     if pixelx == None and pixely == None: \n485.         # if pixelx & pixely hasn't been specified, use the location \nstored in the piece data structure \n486.         pixelx, pixely = convertToPixelCoords(piece['x'], piece['y']) \n487.  \n488.     # draw each of the blocks that make up the piece \n489.     for x in range(TEMPLATEWIDTH): \n490.         for y in range(TEMPLATEHEIGHT): \n491.             if shapeToDraw[y][x] != BLANK: \n492.                 drawBox(None, None, piece['color'], pixelx + (x * \nBOXSIZE), pixely + (y * BOXSIZE)) \nThe drawPiece() function will draw the boxes of a piece according to the piece data structure \nthat is passed to it. This function will be used to draw the falling piece and the ―Next‖ piece. \nSince the piece data structure will contain all of the shape, position, rotation, and color \ninformation, nothing else besides the piece data structure needs to be passed to the function. \nHowever, the ―Next‖ piece is not drawn on the board. In this case, we ignore the position \ninformation stored inside the piece data structure and instead let the caller of the drawPiece() \nfunction pass in arguments for the optional pixelx and pixely parameters to specify where \nexactly on the window the piece should be drawn. \nIf no pixelx and pixely arguments are passed in, then lines 484 and 486 will overwrite those \nvariables with the return values of convertToPixelCoords() call. \nThe nested for loops on line 489 and 490 will then call drawBox() for each box of the piece \nthat needs to be drawn. \nDrawing the “Next” Piece \n495. def drawNextPiece(piece): \n496.     # draw the \"next\" text \n497.     nextSurf = BASICFONT.render('Next:', True, TEXTCOLOR) \n498.     nextRect = nextSurf.get_rect() \n499.     nextRect.topleft = (WINDOWWIDTH - 120, 80) \n500.     DISPLAYSURF.blit(nextSurf, nextRect) \n501.     # draw the \"next\" piece \n502.     drawPiece(piece, pixelx=WINDOWWIDTH-120, pixely=100) \n\n\n198    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n503.  \n504.  \n505. if __name__ == '__main__': \n506.     main() \nThe drawNextPiece() draws the ―Next‖ piece in the upper right corner of the screen. It does \nthis by calling the drawPiece() function and passing in arguments for drawPiece()’s \npixelx and pixely parameters. \nThat’s the last function. Line 505 and 506 are run after all the function definitions have been \nexecuted, and then the main() function is called to begin the main part of the program. \nSummary \nThe Tetromino game (which is a clone of the more popular game, ―Tetris‖) is pretty easy to \nexplain to someone in English: ―Blocks fall from the top of a board, and the player moves and \nrotates them so that they form complete lines. The complete lines disappear (giving the player \npoints) and the lines above them move down. The game keeps going until the blocks fill up the \nentire board and the player loses.‖ \nExplaining it in plain English is one thing, but when we have to tell a computer exactly what to \ndo there are many details we have to fill in. The original Tetris game was designed and \nprogrammed one person, Alex Pajitnov, in the Soviet Union in 1984. The game is simple, fun, \nand addictive. It is one of the most popular video games ever made, and has sold 100 million \ncopies with many people creating their own clones and variations of it. \nAnd it was all created by one person who knew how to program. \nWith the right idea and some programming knowledge you can create incredibly fun games. And \nwith some practice, you will be able to turn your game ideas into real programs that might \nbecome as popular as Tetris! \nFor additional programming practice, you can download buggy versions of Tetromino from \nhttp://invpy.com/buggy/tetromino and try to figure out how to fix the bugs. \nThere are also variations of the Tetromino game on the book’s website. ―Pentomino‖ is a version \nof this game with pieces made up of five boxes. There is also ―Tetromino for Idiots‖, where all of \nthe pieces are made up of just one box. \n\n\nChapter 7 - Tetromino    199 \n \n \nThese variations can be downloaded from: \n \nhttp://invpy.com/pentomino.py \n \nhttp://invpy.com/tetrominoforidiots.py \n  \n \n\n\n200    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nCHAPTER 8 – SQUIRREL EAT \nSQUIRREL \n \n \nHow to Play Squirrel Eat Squirrel \nSquirrel Eat Squirrel is loosely based on the game ―Katamari Damacy‖. The player controls a \nsmall squirrel that must hop around the screen eating smaller squirrels and avoiding larger \nsquirrels. Each time the player’s squirrel eats a squirrel that is smaller than it, it grows larger. If \nthe player’s squirrel gets hit by a larger squirrel larger than it, it loses a life point. The player wins \nwhen the squirrel becomes a monstrously large squirrel called the Omega Squirrel. The player \nloses if their squirrel gets hit three times. \nI’m not really sure where I got the idea for a video game where squirrels eat each other. I’m a \nlittle strange sometimes. \nThe Design of Squirrel Eat Squirrel \nThere are three types of data structures in this game, which are represented as dictionary values. \nThe types are player squirrels, enemy squirrels, and grass objects. There is only one player \nsquirrel object at a time in the game. \nNote: Technically, ―object‖ means something specific in Object-Oriented Programming. Python \ndoes have OOP features, but they aren’t covered in this book. Technically the Pygame objects \nsuch as ―Rect object‖ or ―Surface object‖ are objects. But I’m going to use the term ―object‖ in \nthis book to refer to ―things that exist in the game world‖. But really, the player squirrel, enemy \nsquirrels, and grass ―objects‖ are just dictionary values. \n\n\nChapter 8 – Squirrel Eat Squirrel    201 \n \nAll the objects have the following keys in their dictionary value: 'x', 'y', and 'rect'. The \n'x' and 'y' key’s value give the coordinates of the top left of the object in game world \ncoordinates. These are different from pixel coordinates (which is what the 'rect' key’s value \ntracks). The difference between game world and pixel coordinates will be explained when you \nlearn about the concept of cameras. \nIn addition, the player squirrel, enemy squirrel, and grass objects have other keys which are \nexplained in a large comment at the start of the source code.  \nSource Code to Squirrel Eat Squirrel \nThis source code can be downloaded from http://invpy.com/squirrel.py. If you get any error \nmessages, look at the line number that is mentioned in the error message and check your code for \nany typos. You can also copy and paste your code into the web form at \nhttp://invpy.com/diff/squirrel to see if the differences between your code and the code in the \nbook. \nYou will also need to download the following image files: \n \nhttp://invpy.com/gameicon.png \n \nhttp://invpy.com/squirrel.png \n \nhttp://invpy.com/grass1.png \n \nhttp://invpy.com/grass2.png \n \nhttp://invpy.com/grass3.png \n \nhttp://invpy.com/grass4.png \n  1. # Squirrel Eat Squirrel (a 2D Katamari Damacy clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, sys, time, math, pygame \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 # frames per second to update the screen \n 10. WINWIDTH = 640 # width of the program's window, in pixels \n 11. WINHEIGHT = 480 # height in pixels \n 12. HALF_WINWIDTH = int(WINWIDTH / 2) \n 13. HALF_WINHEIGHT = int(WINHEIGHT / 2) \n 14.  \n 15. GRASSCOLOR = (24, 255, 0) \n 16. WHITE = (255, 255, 255) \n 17. RED = (255, 0, 0) \n 18.  \n\n\n202    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 19. CAMERASLACK = 90     # how far from the center the squirrel moves before \nmoving the camera \n 20. MOVERATE = 9         # how fast the player moves \n 21. BOUNCERATE = 6       # how fast the player bounces (large is slower) \n 22. BOUNCEHEIGHT = 30    # how high the player bounces \n 23. STARTSIZE = 25       # how big the player starts off \n 24. WINSIZE = 300        # how big the player needs to be to win \n 25. INVULNTIME = 2       # how long the player is invulnerable after being hit \nin seconds \n 26. GAMEOVERTIME = 4     # how long the \"game over\" text stays on the screen \nin seconds \n 27. MAXHEALTH = 3        # how much health the player starts with \n 28.  \n 29. NUMGRASS = 80        # number of grass objects in the active area \n 30. NUMSQUIRRELS = 30    # number of squirrels in the active area \n 31. SQUIRRELMINSPEED = 3 # slowest squirrel speed \n 32. SQUIRRELMAXSPEED = 7 # fastest squirrel speed \n 33. DIRCHANGEFREQ = 2    # % chance of direction change per frame \n 34. LEFT = 'left' \n 35. RIGHT = 'right' \n 36.  \n 37. \"\"\" \n 38. This program has three data structures to represent the player, enemy \nsquirrels, and grass background objects. The data structures are dictionaries \nwith the following keys: \n 39.  \n 40. Keys used by all three data structures: \n 41.     'x' - the left edge coordinate of the object in the game world (not a \npixel coordinate on the screen) \n 42.     'y' - the top edge coordinate of the object in the game world (not a \npixel coordinate on the screen) \n 43.     'rect' - the pygame.Rect object representing where on the screen the \nobject is located. \n 44. Player data structure keys: \n 45.     'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen. \n 46.     'facing' - either set to LEFT or RIGHT, stores which direction the \nplayer is facing. \n 47.     'size' - the width and height of the player in pixels. (The width & \nheight are always the same.) \n 48.     'bounce' - represents at what point in a bounce the player is in. 0 \nmeans standing (no bounce), up to BOUNCERATE (the completion of the bounce) \n 49.     'health' - an integer showing how many more times the player can be \nhit by a larger squirrel before dying. \n 50. Enemy Squirrel data structure keys: \n\n\nChapter 8 – Squirrel Eat Squirrel    203 \n \n 51.     'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen. \n 52.     'movex' - how many pixels per frame the squirrel moves horizontally. A \nnegative integer is moving to the left, a positive to the right. \n 53.     'movey' - how many pixels per frame the squirrel moves vertically. A \nnegative integer is moving up, a positive moving down. \n 54.     'width' - the width of the squirrel's image, in pixels \n 55.     'height' - the height of the squirrel's image, in pixels \n 56.     'bounce' - represents at what point in a bounce the player is in. 0 \nmeans standing (no bounce), up to BOUNCERATE (the completion of the bounce) \n 57.     'bouncerate' - how quickly the squirrel bounces. A lower number means \na quicker bounce. \n 58.     'bounceheight' - how high (in pixels) the squirrel bounces \n 59. Grass data structure keys: \n 60.     'grassImage' - an integer that refers to the index of the \npygame.Surface object in GRASSIMAGES used for this grass object \n 61. \"\"\" \n 62.  \n 63. def main(): \n 64.     global FPSCLOCK, DISPLAYSURF, BASICFONT, L_SQUIR_IMG, R_SQUIR_IMG, \nGRASSIMAGES \n 65.  \n 66.     pygame.init() \n 67.     FPSCLOCK = pygame.time.Clock() \n 68.     pygame.display.set_icon(pygame.image.load('gameicon.png')) \n 69.     DISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT)) \n 70.     pygame.display.set_caption('Squirrel Eat Squirrel') \n 71.     BASICFONT = pygame.font.Font('freesansbold.ttf', 32) \n 72.  \n 73.     # load the image files \n 74.     L_SQUIR_IMG = pygame.image.load('squirrel.png') \n 75.     R_SQUIR_IMG = pygame.transform.flip(L_SQUIR_IMG, True, False) \n 76.     GRASSIMAGES = [] \n 77.     for i in range(1, 5): \n 78.         GRASSIMAGES.append(pygame.image.load('grass%s.png' % i)) \n 79.  \n 80.     while True: \n 81.         runGame() \n 82.  \n 83.  \n 84. def runGame(): \n 85.     # set up variables for the start of a new game \n 86.     invulnerableMode = False  # if the player is invulnerable \n 87.     invulnerableStartTime = 0 # time the player became invulnerable \n 88.     gameOverMode = False      # if the player has lost \n 89.     gameOverStartTime = 0     # time the player lost \n",
      "page_number": 213,
      "chapter_number": 24,
      "summary": "This chapter covers segment 24 (pages 213-221). Key topics include squirrel, game, and drawing. So \non the next iteration, the y variable is pointing to the same row as before.",
      "keywords": [
        "SQUIRREL",
        "SQUIRREL EAT",
        "player",
        "piece",
        "Board",
        "BOXSIZE",
        "Coordinates",
        "player squirrel",
        "pixely",
        "Pixel Coordinates",
        "pixelx",
        "game",
        "player squirrel object",
        "piece data structure",
        "screen"
      ],
      "concepts": [
        "squirrel",
        "game",
        "drawing",
        "piece",
        "bounces",
        "function",
        "functions",
        "programs",
        "programmed",
        "objects"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 10,
          "title": "Segment 10 (pages 91-99)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 13,
          "title": "Segment 13 (pages 115-123)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "Segment 32 (pages 301-308)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 31,
          "title": "Segment 31 (pages 291-298)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.54,
          "method": "api"
        }
      ]
    },
    {
      "number": 25,
      "title": "Segment 25 (pages 222-229)",
      "start_page": 222,
      "end_page": 229,
      "detection_method": "topic_boundary",
      "content": "204    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 90.     winMode = False           # if the player has won \n 91.      \n 92.     # create the surfaces to hold game text \n 93.     gameOverSurf = BASICFONT.render('Game Over', True, WHITE) \n 94.     gameOverRect = gameOverSurf.get_rect() \n 95.     gameOverRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT) \n 96.  \n 97.     winSurf = BASICFONT.render('You have achieved OMEGA SQUIRREL!', True, \nWHITE) \n 98.     winRect = winSurf.get_rect() \n 99.     winRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT) \n100.  \n101.     winSurf2 = BASICFONT.render('(Press \"r\" to restart.)', True, WHITE) \n102.     winRect2 = winSurf2.get_rect() \n103.     winRect2.center = (HALF_WINWIDTH, HALF_WINHEIGHT + 30) \n104.  \n105.     # camerax and cameray are where the middle of the camera view is \n106.     camerax = 0 \n107.     cameray = 0 \n108.  \n109.     grassObjs = []    # stores all the grass objects in the game \n110.     squirrelObjs = [] # stores all the non-player squirrel objects \n111.     # stores the player object: \n112.     playerObj = {'surface': pygame.transform.scale(L_SQUIR_IMG, \n(STARTSIZE, STARTSIZE)), \n113.                  'facing': LEFT, \n114.                  'size': STARTSIZE, \n115.                  'x': HALF_WINWIDTH, \n116.                  'y': HALF_WINHEIGHT, \n117.                  'bounce':0, \n118.                  'health': MAXHEALTH} \n119.  \n120.     moveLeft  = False \n121.     moveRight = False \n122.     moveUp    = False \n123.     moveDown  = False \n124.  \n125.     # start off with some random grass images on the screen \n126.     for i in range(10): \n127.         grassObjs.append(makeNewGrass(camerax, cameray)) \n128.         grassObjs[i]['x'] = random.randint(0, WINWIDTH) \n129.         grassObjs[i]['y'] = random.randint(0, WINHEIGHT) \n130.  \n131.     while True: # main game loop \n132.         # Check if we should turn off invulnerability \n\n\nChapter 8 – Squirrel Eat Squirrel    205 \n \n133.         if invulnerableMode and time.time() - invulnerableStartTime > \nINVULNTIME: \n134.             invulnerableMode = False \n135.  \n136.         # move all the squirrels \n137.         for sObj in squirrelObjs: \n138.             # move the squirrel, and adjust for their bounce \n139.             sObj['x'] += sObj['movex'] \n140.             sObj['y'] += sObj['movey'] \n141.             sObj['bounce'] += 1 \n142.             if sObj['bounce'] > sObj['bouncerate']: \n143.                 sObj['bounce'] = 0 # reset bounce amount \n144. \n145.             # random chance they change direction \n146.             if random.randint(0, 99) < DIRCHANGEFREQ: \n147.                 sObj['movex'] = getRandomVelocity() \n148.                 sObj['movey'] = getRandomVelocity() \n149.                 if sObj['movex'] > 0: # faces right \n150.                     sObj['surface'] = pygame.transform.scale(R_SQUIR_IMG, \n(sObj['width'], sObj['height'])) \n151.                 else: # faces left \n152.                     sObj['surface'] = pygame.transform.scale(L_SQUIR_IMG, \n(sObj['width'], sObj['height'])) \n153. \n154.  \n155.         # go through all the objects and see if any need to be deleted. \n156.         for i in range(len(grassObjs) - 1, -1, -1): \n157.             if isOutsideActiveArea(camerax, cameray, grassObjs[i]): \n158.                 del grassObjs[i] \n159.         for i in range(len(squirrelObjs) - 1, -1, -1): \n160.             if isOutsideActiveArea(camerax, cameray, squirrelObjs[i]): \n161.                 del squirrelObjs[i] \n162.  \n163.         # add more grass & squirrels if we don't have enough. \n164.         while len(grassObjs) < NUMGRASS: \n165.             grassObjs.append(makeNewGrass(camerax, cameray)) \n166.         while len(squirrelObjs) < NUMSQUIRRELS: \n167.             squirrelObjs.append(makeNewSquirrel(camerax, cameray)) \n168.  \n169.         # adjust camerax and cameray if beyond the \"camera slack\" \n170.         playerCenterx = playerObj['x'] + int(playerObj['size'] / 2) \n171.         playerCentery = playerObj['y'] + int(playerObj['size'] / 2) \n172.         if (camerax + HALF_WINWIDTH) - playerCenterx > CAMERASLACK: \n173.             camerax = playerCenterx + CAMERASLACK - HALF_WINWIDTH \n174.         elif playerCenterx – (camerax + HALF_WINWIDTH) > CAMERASLACK: \n175.             camerax = playerCenterx – CAMERASLACK - HALF_WINWIDTH \n\n\n206    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n176.         if (cameray + HALF_WINHEIGHT) - playerCentery > CAMERASLACK: \n177.             cameray = playerCentery + CAMERASLACK - HALF_WINHEIGHT \n178.         elif playerCentery – (cameray + HALF_WINHEIGHT) > CAMERASLACK: \n179.             cameray = playerCentery – CAMERASLACK - HALF_WINHEIGHT \n180.  \n181.         # draw the green background \n182.         DISPLAYSURF.fill(GRASSCOLOR) \n183.  \n184.         # draw all the grass objects on the screen \n185.         for gObj in grassObjs: \n186.             gRect = pygame.Rect( (gObj['x'] - camerax, \n187.                                   gObj['y'] - cameray, \n188.                                   gObj['width'], \n189.                                   gObj['height']) ) \n190.             DISPLAYSURF.blit(GRASSIMAGES[gObj['grassImage']], gRect) \n191. \n192.  \n193.         # draw the other squirrels \n194.         for sObj in squirrelObjs: \n195.             sObj['rect'] = pygame.Rect( (sObj['x'] - camerax, \n196.                                          sObj['y'] - cameray - \ngetBounceAmount(sObj['bounce'], sObj['bouncerate'], sObj['bounceheight']), \n197.                                          sObj['width'], \n198.                                          sObj['height']) ) \n199.             DISPLAYSURF.blit(sObj['surface'], sObj['rect']) \n200. \n201.  \n202.         # draw the player squirrel \n203.         flashIsOn = round(time.time(), 1) * 10 % 2 == 1 \n204.         if not gameOverMode and not (invulnerableMode and flashIsOn): \n205.             playerObj['rect'] = pygame.Rect( (playerObj['x'] - camerax, \n206.                                               playerObj['y'] – cameray - \ngetBounceAmount(playerObj['bounce'], BOUNCERATE, BOUNCEHEIGHT), \n207.                                               playerObj['size'], \n208.                                               playerObj['size']) ) \n209.             DISPLAYSURF.blit(playerObj['surface'], playerObj['rect']) \n210. \n211.  \n212.         # draw the health meter \n213.         drawHealthMeter(playerObj['health']) \n214.  \n215.         for event in pygame.event.get(): # event handling loop \n216.             if event.type == QUIT: \n217.                 terminate() \n218. \n219.             elif event.type == KEYDOWN: \n\n\nChapter 8 – Squirrel Eat Squirrel    207 \n \n220.                 if event.key in (K_UP, K_w): \n221.                     moveDown = False \n222.                     moveUp = True \n223.                 elif event.key in (K_DOWN, K_s): \n224.                     moveUp = False \n225.                     moveDown = True \n226.                 elif event.key in (K_LEFT, K_a): \n227.                     moveRight = False \n228.                     moveLeft = True \n229.                     if playerObj['facing'] == RIGHT: # change player image \n230.                         playerObj['surface'] = \npygame.transform.scale(L_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n231.                     playerObj['facing'] = LEFT \n232.                 elif event.key in (K_RIGHT, K_d): \n233.                     moveLeft = False \n234.                     moveRight = True \n235.                     if playerObj['facing'] == LEFT: # change player image \n236.                         playerObj['surface'] = \npygame.transform.scale(R_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n237.                     playerObj['facing'] = RIGHT \n238.                 elif winMode and event.key == K_r: \n239.                     return \n240. \n241.             elif event.type == KEYUP: \n242.                 # stop moving the player's squirrel \n243.                 if event.key in (K_LEFT, K_a): \n244.                     moveLeft = False \n245.                 elif event.key in (K_RIGHT, K_d): \n246.                     moveRight = False \n247.                 elif event.key in (K_UP, K_w): \n248.                     moveUp = False \n249.                 elif event.key in (K_DOWN, K_s): \n250.                     moveDown = False \n251. \n252.                 elif event.key == K_ESCAPE: \n253.                     terminate() \n254. \n255.         if not gameOverMode: \n256.             # actually move the player \n257.             if moveLeft: \n258.                 playerObj['x'] -= MOVERATE \n259.             if moveRight: \n260.                 playerObj['x'] += MOVERATE \n261.             if moveUp: \n262.                 playerObj['y'] -= MOVERATE \n263.             if moveDown: \n\n\n208    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n264.                 playerObj['y'] += MOVERATE \n265. \n266.             if (moveLeft or moveRight or moveUp or moveDown) or \nplayerObj['bounce'] != 0: \n267.                 playerObj['bounce'] += 1 \n268.  \n269.             if playerObj['bounce'] > BOUNCERATE: \n270.                 playerObj['bounce'] = 0 # reset bounce amount \n271. \n272.             # check if the player has collided with any squirrels \n273.             for i in range(len(squirrelObjs)-1, -1, -1): \n274.                 sqObj = squirrelObjs[i] \n275.                 if 'rect' in sqObj and \nplayerObj['rect'].colliderect(sqObj['rect']): \n276.                     # a player/squirrel collision has occurred \n277. \n278.                     if sqObj['width'] * sqObj['height'] <= \nplayerObj['size']**2: \n279.                         # player is larger and eats the squirrel \n280.                         playerObj['size'] += int( (sqObj['width'] * \nsqObj['height'])**0.2 ) + 1 \n281.                         del squirrelObjs[i] \n282. \n283.                         if playerObj['facing'] == LEFT: \n284.                             playerObj['surface'] = \npygame.transform.scale(L_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n285.                         if playerObj['facing'] == RIGHT: \n286.                             playerObj['surface'] = \npygame.transform.scale(R_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n287. \n288.                         if playerObj['size'] > WINSIZE: \n289.                             winMode = True # turn on \"win mode\" \n290. \n291.                     elif not invulnerableMode: \n292.                         # player is smaller and takes damage \n293.                         invulnerableMode = True \n294.                         invulnerableStartTime = time.time() \n295.                         playerObj['health'] -= 1 \n296.                         if playerObj['health'] == 0: \n297.                             gameOverMode = True # turn on \"game over mode\" \n298.                             gameOverStartTime = time.time() \n299.         else: \n300.             # game is over, show \"game over\" text \n301.             DISPLAYSURF.blit(gameOverSurf, gameOverRect) \n302.             if time.time() - gameOverStartTime > GAMEOVERTIME: \n303.                 return # end the current game \n\n\nChapter 8 – Squirrel Eat Squirrel    209 \n \n304.  \n305.         # check if the player has won. \n306.         if winMode: \n307.             DISPLAYSURF.blit(winSurf, winRect) \n308.             DISPLAYSURF.blit(winSurf2, winRect2) \n309.  \n310.         pygame.display.update() \n311.         FPSCLOCK.tick(FPS) \n312.  \n313.  \n314. \n315. \n316. def drawHealthMeter(currentHealth): \n317.     for i in range(currentHealth): # draw red health bars \n318.         pygame.draw.rect(DISPLAYSURF, RED,   (15, 5 + (10 * MAXHEALTH) - i \n* 10, 20, 10)) \n319.     for i in range(MAXHEALTH): # draw the white outlines \n320.         pygame.draw.rect(DISPLAYSURF, WHITE, (15, 5 + (10 * MAXHEALTH) - i \n* 10, 20, 10), 1) \n321.  \n322.  \n323. def terminate(): \n324.     pygame.quit() \n325.     sys.exit() \n326. \n327. \n328. def getBounceAmount(currentBounce, bounceRate, bounceHeight): \n329.     # Returns the number of pixels to offset based on the bounce. \n330.     # Larger bounceRate means a slower bounce. \n331.     # Larger bounceHeight means a higher bounce. \n332.     # currentBounce will always be less than bounceRate \n333.     return int(math.sin( (math.pi / float(bounceRate)) * currentBounce ) * \nbounceHeight) \n334. \n335. def getRandomVelocity(): \n336.     speed = random.randint(SQUIRRELMINSPEED, SQUIRRELMAXSPEED) \n337.     if random.randint(0, 1) == 0: \n338.         return speed \n339.     else: \n340.         return -speed \n341.  \n342.  \n343. def getRandomOffCameraPos(camerax, cameray, objWidth, objHeight): \n344.     # create a Rect of the camera view \n345.     cameraRect = pygame.Rect(camerax, cameray, WINWIDTH, WINHEIGHT) \n346.     while True: \n\n\n210    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n347.         x = random.randint(camerax - WINWIDTH, camerax + (2 * WINWIDTH)) \n348.         y = random.randint(cameray - WINHEIGHT, cameray + (2 * WINHEIGHT)) \n349.         # create a Rect object with the random coordinates and use \ncolliderect() \n350.         # to make sure the right edge isn't in the camera view. \n351.         objRect = pygame.Rect(x, y, objWidth, objHeight) \n352.         if not objRect.colliderect(cameraRect): \n353.             return x, y \n354.  \n355.  \n356. def makeNewSquirrel(camerax, cameray): \n357.     sq = {} \n358.     generalSize = random.randint(5, 25) \n359.     multiplier = random.randint(1, 3) \n360.     sq['width']  = (generalSize + random.randint(0, 10)) * multiplier \n361.     sq['height'] = (generalSize + random.randint(0, 10)) * multiplier \n362.     sq['x'], sq['y'] = getRandomOffCameraPos(camerax, cameray, \nsq['width'], sq['height']) \n363.     sq['movex'] = getRandomVelocity() \n364.     sq['movey'] = getRandomVelocity() \n365.     if sq['movex'] < 0: # squirrel is facing left \n366.         sq['surface'] = pygame.transform.scale(L_SQUIR_IMG, (sq['width'], \nsq['height'])) \n367.     else: # squirrel is facing right \n368.         sq['surface'] = pygame.transform.scale(R_SQUIR_IMG, (sq['width'], \nsq['height'])) \n369.     sq['bounce'] = 0 \n370.     sq['bouncerate'] = random.randint(10, 18) \n371.     sq['bounceheight'] = random.randint(10, 50) \n372.     return sq \n373.  \n374.  \n375. def makeNewGrass(camerax, cameray): \n376.     gr = {} \n377.     gr['grassImage'] = random.randint(0, len(GRASSIMAGES) - 1) \n378.     gr['width']  = GRASSIMAGES[0].get_width() \n379.     gr['height'] = GRASSIMAGES[0].get_height() \n380.     gr['x'], gr['y'] = getRandomOffCameraPos(camerax, cameray, \ngr['width'], gr['height']) \n381.     gr['rect'] = pygame.Rect( (gr['x'], gr['y'], gr['width'], \ngr['height']) ) \n382.     return gr \n383. \n384. \n385. def isOutsideActiveArea(camerax, cameray, obj): \n386.     # Return False if camerax and cameray are more than \n\n\nChapter 8 – Squirrel Eat Squirrel    211 \n \n387.     # a half-window length beyond the edge of the window. \n388.     boundsLeftEdge = camerax - WINWIDTH \n389.     boundsTopEdge = cameray - WINHEIGHT \n390.     boundsRect = pygame.Rect(boundsLeftEdge, boundsTopEdge, WINWIDTH * 3, \nWINHEIGHT * 3) \n391.     objRect = pygame.Rect(obj['x'], obj['y'], obj['width'], obj['height']) \n392.     return not boundsRect.colliderect(objRect) \n393.  \n394.  \n395. if __name__ == '__main__': \n396.     main() \nThe Usual Setup Code \n  1. # Squirrel Eat Squirrel (a 2D Katamari Damacy clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, sys, time, math, pygame \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 # frames per second to update the screen \n 10. WINWIDTH = 640 # width of the program's window, in pixels \n 11. WINHEIGHT = 480 # height in pixels \n 12. HALF_WINWIDTH = int(WINWIDTH / 2) \n 13. HALF_WINHEIGHT = int(WINHEIGHT / 2) \n 14.  \n 15. GRASSCOLOR = (24, 255, 0) \n 16. WHITE = (255, 255, 255) \n 17. RED = (255, 0, 0) \nThe start of the program assigns several constant variables. This program frequently makes use of \nthe half length of the width and height of the window so much that the HALF_WINWIDTH and \nHALF_WINHEIGHT variables store these numbers. \n 19. CAMERASLACK = 90     # how far from the center the squirrel moves before \nmoving the camera \nThe ―camera slack‖ is described later. Basically, it means that the camera will begin following the \nplayer squirrel when it moves 90 pixels away from the center of the window. \n 20. MOVERATE = 9         # how fast the player moves \n 21. BOUNCERATE = 6       # how fast the player bounces (large is slower) \n",
      "page_number": 222,
      "chapter_number": 25,
      "summary": "This chapter covers segment 25 (pages 222-229). Key topics include squirrel, returns, and bounce.",
      "keywords": [
        "playerObj",
        "HALF",
        "WINWIDTH",
        "WINHEIGHT",
        "sObj",
        "SQUIRREL",
        "cameray",
        "camerax",
        "size",
        "CAMERASLACK",
        "Squirrel Eat",
        "SQUIR",
        "IMG",
        "bounce",
        "player"
      ],
      "concepts": [
        "squirrel",
        "returns",
        "bounce",
        "random",
        "game",
        "height",
        "player",
        "white",
        "later",
        "draw"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "Segment 11 (pages 100-107)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "Segment 32 (pages 301-308)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "AI Agents and Applications",
          "chapter": 29,
          "title": "Segment 29 (pages 249-256)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.52,
          "method": "api"
        }
      ]
    },
    {
      "number": 26,
      "title": "Segment 26 (pages 230-238)",
      "start_page": 230,
      "end_page": 238,
      "detection_method": "topic_boundary",
      "content": "212    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 22. BOUNCEHEIGHT = 30    # how high the player bounces \n 23. STARTSIZE = 25       # how big the player starts off \n 24. WINSIZE = 300        # how big the player needs to be to win \n 25. INVULNTIME = 2       # how long the player is invulnerable after being hit \nin seconds \n 26. GAMEOVERTIME = 4     # how long the \"game over\" text stays on the screen \nin seconds \n 27. MAXHEALTH = 3        # how much health the player starts with \n 28.  \n 29. NUMGRASS = 80        # number of grass objects in the active area \n 30. NUMSQUIRRELS = 30    # number of squirrels in the active area \n 31. SQUIRRELMINSPEED = 3 # slowest squirrel speed \n 32. SQUIRRELMAXSPEED = 7 # fastest squirrel speed \n 33. DIRCHANGEFREQ = 2    # % chance of direction change per frame \n 34. LEFT = 'left' \n 35. RIGHT = 'right' \nThe comments next to these constants explains what the constant variable is used for.  \nDescribing the Data Structures \n 37. \"\"\" \n 38. This program has three data structures to represent the player, enemy \nsquirrels, and grass background objects. The data structures are dictionaries \nwith the following keys: \n 39.  \n 40. Keys used by all three data structures: \n 41.     'x' - the left edge coordinate of the object in the game world (not a \npixel coordinate on the screen) \n 42.     'y' - the top edge coordinate of the object in the game world (not a \npixel coordinate on the screen) \n 43.     'rect' - the pygame.Rect object representing where on the screen the \nobject is located. \n 44. Player data structure keys: \n 45.     'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen. \n 46.     'facing' - either set to LEFT or RIGHT, stores which direction the \nplayer is facing. \n 47.     'size' - the width and height of the player in pixels. (The width & \nheight are always the same.) \n 48.     'bounce' - represents at what point in a bounce the player is in. 0 \nmeans standing (no bounce), up to BOUNCERATE (the completion of the bounce) \n 49.     'health' - an integer showing how many more times the player can be \nhit by a larger squirrel before dying. \n 50. Enemy Squirrel data structure keys: \n\n\nChapter 8 – Squirrel Eat Squirrel    213 \n \n 51.     'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen. \n 52.     'movex' - how many pixels per frame the squirrel moves horizontally. A \nnegative integer is moving to the left, a positive to the right. \n 53.     'movey' - how many pixels per frame the squirrel moves vertically. A \nnegative integer is moving up, a positive moving down. \n 54.     'width' - the width of the squirrel's image, in pixels \n 55.     'height' - the height of the squirrel's image, in pixels \n 56.     'bounce' - represents at what point in a bounce the player is in. 0 \nmeans standing (no bounce), up to BOUNCERATE (the completion of the bounce) \n 57.     'bouncerate' - how quickly the squirrel bounces. A lower number means \na quicker bounce. \n 58.     'bounceheight' - how high (in pixels) the squirrel bounces \n 59. Grass data structure keys: \n 60.     'grassImage' - an integer that refers to the index of the \npygame.Surface object in GRASSIMAGES used for this grass object \n 61. \"\"\" \nThe comments from lines 37 to 61 are in one large, multi-line string. They describe the keys in \nthe player squirrel, enemy squirrel, and grass objects. In Python, a multi-line string value by itself \nworks as a multi-line comment. \nThe main() Function \n 63. def main(): \n 64.     global FPSCLOCK, DISPLAYSURF, BASICFONT, L_SQUIR_IMG, R_SQUIR_IMG, \nGRASSIMAGES \n 65.  \n 66.     pygame.init() \n 67.     FPSCLOCK = pygame.time.Clock() \n 68.     pygame.display.set_icon(pygame.image.load('gameicon.png')) \n 69.     DISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT)) \n 70.     pygame.display.set_caption('Squirrel Eat Squirrel') \n 71.     BASICFONT = pygame.font.Font('freesansbold.ttf', 32) \nThe first several lines of the main() function are the same setup code that we’ve seen in our \nprevious game programs. The pygame.display.set_icon() is a Pygame function that \nsets the icon in the window’s title bar (just like pygame.display.set_caption() sets the \ncaption text in the title bar). The single argument to pygame.display.set_icon() is a \nSurface object of a small image. The ideal image size is 32 x 32 pixels, although you can use \nother sized images. The image will just be compressed into a smaller size to be used as the \nwindow’s icon. \n\n\n214    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe pygame.transform.flip() Function \n 73.     # load the image files \n 74.     L_SQUIR_IMG = pygame.image.load('squirrel.png') \n 75.     R_SQUIR_IMG = pygame.transform.flip(L_SQUIR_IMG, True, False) \n 76.     GRASSIMAGES = [] \n 77.     for i in range(1, 5): \n 78.         GRASSIMAGES.append(pygame.image.load('grass%s.png' % i)) \nThe image for the player and enemy squirrels is loaded from squirrel.png on line 74. Make sure \nthat this PNG file is in the same folder as squirrel.py, otherwise you will get the error \npygame.error: Couldn't open squirrel.png. \nThe image in squirrel.png (which you can download from http://invpy.com/squirrel.png) is of a \nsquirrel facing to the left. We also need a Surface object that contains a picture of the squirrel \nfacing to the right. Instead of creating a second PNG image file, we can call the \npygame.transform.flip() function. This function has three parameters: the Surface \nobject with the image to flip, a Boolean value to do a horizontal flip, and a Boolean value to do a \nvertical flip. By passing True for the second parameter and False for the third parameter, the \nSurface object that returns has the image of the squirrel facing to the right. The original Surface \nobject in L_SQUIR_IMG that we passed in is unchanged. \nHere are examples of images being horizontally and vertically flipped: \n \n \n \n \nOriginal \nHorizontal Flip \nVertical Flip \nHorizontal and \nVertical Flip \n \n 80.     while True: \n 81.         runGame() \nAfter the setup in main() is complete, the game begins with runGame() being called.  \nA More Detailed Game State than Usual \n 84. def runGame(): \n 85.     # set up variables for the start of a new game \n\n\nChapter 8 – Squirrel Eat Squirrel    215 \n \n 86.     invulnerableMode = False  # if the player is invulnerable \n 87.     invulnerableStartTime = 0 # time the player became invulnerable \n 88.     gameOverMode = False      # if the player has lost \n 89.     gameOverStartTime = 0     # time the player lost \n 90.     winMode = False           # if the player has won \nThe Squirrel Eat Squirrel game has quite a few variables that track the game state. These \nvariables will be explained in more detail later when they are used in the code. \nThe Usual Text Creation Code \n 92.     # create the surfaces to hold game text \n 93.     gameOverSurf = BASICFONT.render('Game Over', True, WHITE) \n 94.     gameOverRect = gameOverSurf.get_rect() \n 95.     gameOverRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT) \n 96.  \n 97.     winSurf = BASICFONT.render('You have achieved OMEGA SQUIRREL!', True, \nWHITE) \n 98.     winRect = winSurf.get_rect() \n 99.     winRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT) \n100.  \n101.     winSurf2 = BASICFONT.render('(Press \"r\" to restart.)', True, WHITE) \n102.     winRect2 = winSurf2.get_rect() \n103.     winRect2.center = (HALF_WINWIDTH, HALF_WINHEIGHT + 30) \nThese variables contain Surface objects with the ―Game Over‖, ―You have achieved OMEGA \nSQUIRREL!‖, and ―(Press \"r\" to restart.)‖ text that appears on the screen after the game ends \n(with either the player losing or winning). \nCameras \n105.     # camerax and cameray are where the middle of the camera view is \n106.     camerax = 0 \n107.     cameray = 0 \nThe camerax and cameray variables track the game coordinates of the ―camera‖. Imagine the \ngame world as an infinite 2D space. This could, of course, never fit on any screen. We can only \ndraw a portion of the infinite 2D space on the screen. We call the area of this portion a camera, \nbecause it is as though our screen is just the area of the game world in front what a camera would \nsee. Here’s a picture of the game world (an infinite green field) and the area that the camera can \nview: \n\n\n216    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nAs you can see, the game world XY coordinates keep getting bigger and smaller forever. The \ngame world origin is where the (0, 0) game world coordinates are. You can see that the three \nsquirrels are located (in game world coordinates) at (-384, -84), (384, 306), and (585, -234). \nBut we can only display 640 x 480 pixel area on the screen (though this can change if we pass \ndifferent numbers to the pygame.display.set_mode() function), so we need to track \nwhere the camera’s origin is located in game world coordinates. In the picture above, the camera \nis placed at (-486, -330) in game world coordinates. \nThe picture below shows the same field and squirrels, except everything is given in camera \ncoordinates: \n\n\nChapter 8 – Squirrel Eat Squirrel    217 \n \n \nThe area that the camera can see (called the camera view) has it’s center (that is, its origin) at the \ngame world coordinates (-486, -330). Since what the camera sees is displayed on the player’s \nscreen, the ―camera‖ coordinates are the same as the ―pixel‖ coordinates. To find out the pixel \ncoordinates of the squirrels (that is, where on the screen they appear), take the game coordinates \nof the squirrel and subtract the game coordinates of the camera’s origin. \nSo the squirrel on the left has game world coordinates of (-384, -84) but appears at (102, 246) on \nthe screen in pixel coordinates. (For the X coordinate, -384 - -486 = 102 and for the Y coordinate, \n-84 - -330 = 246.) \nWhen we do the same calculation to find the pixel coordinates of the other two squirrels, we find \nthat they exist outside of the range of the screen. This is why they don’t appear in the camera’s \nview. \nThe “Active Area” \nThe ―active area‖ is just a name I came up with to describe the area of the game world that the \ncamera views plus an area around it the size of the camera area: \n \n\n\n218    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nCalculating if something is in the active area or not is explained in the \nisOutsideActiveArea() function’s explanation later in this chapter. When we create new \nenemy squirrel or grass objects, we don’t want them to be created inside the view of the camera, \nsince it’ll appear that they just pop out of nowhere. \nBut we also don’t want to create them too far away from the camera, because then they may \nnever wander into the camera’s view. Inside the active area but outside the camera is where \nsquirrel and grass objects can safely be created. \nAlso, when squirrel and grass objects are beyond the border of the active area then they are far \naway enough to delete so that they don’t take up memory any more. Objects that far away aren’t \nneeded since it is much less likely that they’ll come back into view of the camera. \nIf you have ever played Super Mario World on the Super Nintendo, there is a good YouTube \nvideo explaining how Super Mario World’s camera system works. You can find this video at \nhttp://invpy.com/mariocamera. \nKeeping Track of the Location of Things in the Game World \n109.     grassObjs = []    # stores all the grass objects in the game \n110.     squirrelObjs = [] # stores all the non-player squirrel objects \n111.     # stores the player object: \n112.     playerObj = {'surface': pygame.transform.scale(L_SQUIR_IMG, \n(STARTSIZE, STARTSIZE)), \n113.                  'facing': LEFT, \n114.                  'size': STARTSIZE, \n115.                  'x': HALF_WINWIDTH, \n116.                  'y': HALF_WINHEIGHT, \n117.                  'bounce':0, \n118.                  'health': MAXHEALTH} \n119.  \n120.     moveLeft  = False \n121.     moveRight = False \n122.     moveUp    = False \n123.     moveDown  = False \nThe grassObjs variable holds a list of all the grass objects in the game. As new grass objects \nare created, they are added to this list. As grass objects are deleted, they are removed from this \nlist. The same goes for the squirrelObjs variable and the enemy squirrel objects. \nThe playerObj variable is not a list, but just the dictionary value itself. \nThe move variables on lines 120 to 123 track which of arrow keys (or WASD keys) are being \nheld down, just like in a few of the previous game programs. \n\n\nChapter 8 – Squirrel Eat Squirrel    219 \n \nStarting Off with Some Grass \n125.     # start off with some random grass images on the screen \n126.     for i in range(10): \n127.         grassObjs.append(makeNewGrass(camerax, cameray)) \n128.         grassObjs[i]['x'] = random.randint(0, WINWIDTH) \n129.         grassObjs[i]['y'] = random.randint(0, WINHEIGHT) \nThe active area should start off with a few grass objects visible on the screen. The \nmakeNewGrass() function will create and return a grass object that is randomly located \nsomewhere in the active area but outside the camera view. This is what we normally want when \nwe call makeNewGrass(), but since we want to make sure the first few grass objects are on the \nscreen, the X and Y coordinates are overwritten. \nThe Game Loop \n131.     while True: # main game loop \nThe game loop, like the game loops in the previous game programs, will do event handling, \nupdating the game state, and drawing everything to the screen. \nChecking to Disable Invulnerability \n132.         # Check if we should turn off invulnerability \n133.         if invulnerableMode and time.time() - invulnerableStartTime > \nINVULNTIME: \n134.             invulnerableMode = False \nWhen the player gets hit by an enemy squirrel and does not die, we make the player invulnerable \nfor a couple seconds (since the INVULNTIME constant is set to 2). During this time, the player’s \nsquirrel flashes and the won’t take any damage from other squirrels. If the ―invulnerability mode‖ \ntime is over, line 134 will set invulnerableMode to False. \nMoving the Enemy Squirrels \n136.         # move all the squirrels \n137.         for sObj in squirrelObjs: \n138.             # move the squirrel, and adjust for their bounce \n139.             sObj['x'] += sObj['movex'] \n140.             sObj['y'] += sObj['movey'] \nThe enemy squirrels all move according to the values in their 'movex' and 'movey' keys. If \nthese values are positive, the squirrels move right or down. If these values are negative, they \n\n\n220    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nmove left or up. The larger the value, the farther they move on each iteration through the game \nloop (which means they move faster). \nThe for loop on line 137 will apply this moving code to each of the enemy squirrel objects in the \nsquirrelObjs list. First, line 139 and 140 will adjust their 'x' and 'y' keys’ values. \n141.             sObj['bounce'] += 1 \n142.             if sObj['bounce'] > sObj['bouncerate']: \n143.                 sObj['bounce'] = 0 # reset bounce amount \nThe value in sObj['bounce'] is incremented on each iteration of the game loop for each \nsquirrel. When this value is 0, the squirrel is at the very beginning of its bounce. When this value \nis equal to the value in sObj['bouncerate'] the value is at its end. (This is why a smaller \nsObj['bouncerate'] value makes for a faster bounce. If sObj['bouncerate'] is 3, \nthen it only takes three iterations through the game loop for the squirrel to do a full bounce. If \nsObj['bouncerate'] were 10, then it would take ten iterations.) \nWhen sObj['bounce'] gets larger than sObj['bouncerate'], then it needs to be reset \nto 0. This is what lines 142 and 143 do. \n145.             # random chance they change direction \n146.             if random.randint(0, 99) < DIRCHANGEFREQ: \n147.                 sObj['movex'] = getRandomVelocity() \n148.                 sObj['movey'] = getRandomVelocity() \n149.                 if sObj['movex'] > 0: # faces right \n150.                     sObj['surface'] = pygame.transform.scale(R_SQUIR_IMG, \n(sObj['width'], sObj['height'])) \n151.                 else: # faces left \n152.                     sObj['surface'] = pygame.transform.scale(L_SQUIR_IMG, \n(sObj['width'], sObj['height'])) \nThere is a 2% chance on each iteration through the game loop that the squirrel will randomly \nchange speed and direction. On line 146 the random.randint(0, 99) call randomly selects \nan integer out of 100 possible integers. If this number is less than DIRCHANGEFREQ (which we \nset to 2 on line 33) then a new value will be set for sObj['movex'] and sObj['movey'].  \nBecause this means the squirrel might have changed direction, the Surface object in \nsObj['surface'] should be replaced by a new one that is properly facing left or right and \nscaled to the squirrel’s size. This is what lines 149 to 152 determine. Note that line 150 gets a \nSurface object scaled from R_SQUIR_IMG and line 152 gets one scaled from L_SQUIR_IMG. \n",
      "page_number": 230,
      "chapter_number": 26,
      "summary": "RIGHT = 'right' \nThe comments next to these constants explains what the constant variable is used for Key topics include squirrels, game, and bounce. NUMGRASS = 80        # number of grass objects in the active area \n 30.",
      "keywords": [
        "squirrel",
        "game",
        "game world",
        "game world coordinates",
        "Squirrel Eat",
        "player",
        "grass objects",
        "Surface object",
        "sObj",
        "Enemy Squirrel",
        "Eat Squirrel game",
        "camera",
        "enemy squirrel objects",
        "objects",
        "squirrel objects"
      ],
      "concepts": [
        "squirrels",
        "game",
        "bounce",
        "object",
        "keys",
        "value",
        "cameras",
        "variable",
        "variables",
        "number"
      ],
      "similar_chapters": [
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 5,
          "title": "Segment 5 (pages 35-42)",
          "relevance_score": 0.45,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 7,
          "title": "Segment 7 (pages 121-141)",
          "relevance_score": 0.42,
          "method": "api"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 15,
          "title": "Segment 15 (pages 125-135)",
          "relevance_score": 0.41,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 22,
          "title": "Segment 22 (pages 205-213)",
          "relevance_score": 0.41,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 36,
          "title": "Segment 36 (pages 719-740)",
          "relevance_score": 0.41,
          "method": "api"
        }
      ]
    },
    {
      "number": 27,
      "title": "Segment 27 (pages 239-248)",
      "start_page": 239,
      "end_page": 248,
      "detection_method": "topic_boundary",
      "content": "Chapter 8 – Squirrel Eat Squirrel    221 \n \nRemoving the Far Away Grass and Squirrel Objects \n155.         # go through all the objects and see if any need to be deleted. \n156.         for i in range(len(grassObjs) - 1, -1, -1): \n157.             if isOutsideActiveArea(camerax, cameray, grassObjs[i]): \n158.                 del grassObjs[i] \n159.         for i in range(len(squirrelObjs) - 1, -1, -1): \n160.             if isOutsideActiveArea(camerax, cameray, squirrelObjs[i]): \n161.                 del squirrelObjs[i] \nDuring each iteration of the game loop, the code will check all of the grass and enemy squirrel \nobjects to see if they are outside the ―active area‖. The isOutsideActiveArea() function \ntakes the current coordinates of the camera (which are stored in camerax and cameray) and \nthe grass/enemy squirrel object, and returns True if the object is not located in the active area. \nIf this is the case, this object is deleted on line 158 (for grass objects) or line 161 (for squirrel \nobjects). This is how squirrel and grass objects get deleted when the player moves far enough \naway from them (or when the enemy squirrels move away far enough from the player). This \nensures that there is always a number of squirrels and grass objects near the player. \nWhen Deleting Items in a List, Iterate Over the List in Reverse \nDeleting squirrel and grass objects is done with the del operator. However, notice that the for \nloop on line 156 and 159 pass arguments to the range() function so that the numbering starts at \nthe index of the last item and then decrements by -1 (unlike incrementing by 1 as it normally \ndoes) until it reaches the number -1. We are iterating backwards over the list’s indexes compared \nto how it is normally done. This is done because we are iterating over the list that we are also \ndeleting items from. \nTo see why this reverse order is needed, say we had the following list value: \nanimals = ['cat', 'mouse', 'dog', 'horse'] \nSo we wanted to write code to delete any instances of the string 'dog' from this list. We might \nthink to write out code like this: \nfor i in range(len(animals)): \n    if animals[i] == 'dog': \n        del animals[i] \nBut if we ran this code, we would get an IndexError error that looks like this: \nTraceback (most recent call last): \n\n\n222    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n  File \"<stdin>\", line 2, in <module> \nIndexError: list index out of range \nTo see why this error happens, let’s walk through the code. First, the animals list would be set \nto ['cat', 'mouse', 'dog', 'horse'] and len(animals) would return 4. This \nmeans that the call to range(4) would cause the for loop to iterate with the values 0, 1, 2, \nand 3. \nWhen the for loop iterates with i set to 2, the if statement’s condition will be True and the \ndel animals[i] statement will delete animals[2]. This means that afterwards the \nanimals list will be ['cat', 'mouse', 'horse']. The indexes of all the items after \n'dog' are all shifted down by one because the 'dog' value was removed. \nBut on the next iteration through the for loop, i is set to 3. But animals[3] is out of bounds \nbecause the valid indexes of the animals list is no longer 0 to 3 but 0 to 2. The original call to \nrange() was for a list with 4 items in it. The list changed in length, but the for loop is set up \nfor the original length. \nHowever, if we iterate from the last index of the list to 0, we don’t run into this problem. The \nfollowing program deletes the 'dog' string from the animals list without causing an \nIndexError error: \nanimals = ['cat', 'mouse', 'dog', 'horse'] \nfor i in range(len(animals) - 1, -1, -1): \n    if animals[i] == 'dog': \n        del animals[i] \nThe reason this code doesn’t cause an error is because the for loop iterates over 3, 2, 1, and 0. \nOn the first iteration, the code checks if animals[3] is equal to 'dog'. It isn’t \n(animals[3] is 'horse') so the code moves on to the next iteration. Then animals[2] is \nchecked if it equals 'dog'. It does, so animals[2] is deleted. \nAfter animals[2] is deleted, the animals list is set to ['cat', 'mouse', 'horse']. \nOn the next iteration, i is set to 1. There is a value at animals[1] (the 'mouse' value), so no \nerror is caused. It doesn’t matter that all the items in the list after 'dog' have shifted down by \none, because since we started at the end of the list and are going towards the front, all of those \nitems have already been checked. \nSimilarly, we can delete grass and squirrel objects from the grassObjs and squirrelObjs \nlists without error because the for loop on lines 156 and 159 iterate in reverse order. \n\n\nChapter 8 – Squirrel Eat Squirrel    223 \n \nAdding New Grass and Squirrel Objects \n163.         # add more grass & squirrels if we don't have enough. \n164.         while len(grassObjs) < NUMGRASS: \n165.             grassObjs.append(makeNewGrass(camerax, cameray)) \n166.         while len(squirrelObjs) < NUMSQUIRRELS: \n167.             squirrelObjs.append(makeNewSquirrel(camerax, cameray)) \nRemember that the NUMGRASS constant was set to 80 and the NUMSQUIRRELS constant was set \nto 30 at the beginning of the program? These variables are set so that we can be sure there are \nalways plenty of grass and squirrel objects in the active area at all times. If the length of the \ngrassObjs or squirrelObjs drops below NUMGRASS or NUMSQUIRRELS respectively, \nthen new grass and squirrel objects are created. The makeNewGrass() and \nmakeNewSquirrel() functions that create these objects are explained later in this chapter. \nCamera Slack, and Moving the Camera View \n169.         # adjust camerax and cameray if beyond the \"camera slack\" \n170.         playerCenterx = playerObj['x'] + int(playerObj['size'] / 2) \n171.         playerCentery = playerObj['y'] + int(playerObj['size'] / 2) \n172.         if (camerax + HALF_WINWIDTH) - playerCenterx > CAMERASLACK: \n173.             camerax = playerCenterx + CAMERASLACK - HALF_WINWIDTH \n174.         elif playerCenterx – (camerax + HALF_WINWIDTH) > CAMERASLACK: \n175.             camerax = playerCenterx – CAMERASLACK - HALF_WINWIDTH \n176.         if (cameray + HALF_WINHEIGHT) - playerCentery > CAMERASLACK: \n177.             cameray = playerCentery + CAMERASLACK - HALF_WINHEIGHT \n178.         elif playerCentery – (cameray + HALF_WINHEIGHT) > CAMERASLACK: \n179.             cameray = playerCentery – CAMERASLACK - HALF_WINHEIGHT \nThe camera’s position (which is stored as integers in the camerax and cameray variables) \nneeds to be updated when the player moves over. I’ve called the number of pixels the player can \nmove before the camera gets updated the ―camera slack‖. Line 19 set the CAMERASLACK \nconstant to 90, which our program will take to mean that the player squirrel can move 90 pixels \nfrom the center before the camera position gets updated to follow the squirrel. \nIn order to understand the equations used in the if statements on lines 172, 174, 176, and 178, \nyou should note that (camerax + HALF_WINWIDTH) and (cameray + \nHALF_WINHEIGHT) are the XY game world coordinates currently at the center of the screen. \nThe playerCenterx and playerCentery is set to the middle of the player’s squirrel’s \nposition, also in game world coordinates. \nFor line 172, if the center X coordinate minus the player’s center X coordinate is greater than the \nCAMERASLACK value, that means the player is more pixels to the right of the center of the \n\n\n224    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \ncamera than the camera slack should allow. The camerax value needs to be updated so that the \nplayer squirrel is just at the edge of the camera slack. This is why line 173 sets camerax to \nplayerCenterx + CAMERASLACK – HALF_WINWIDTH. Note that the camerax \nvariable is changed, not the playerObj['x'] value. We want to move the camera, not the \nplayer. \nThe other three if statements follow similar logic for the left, up and down sides. \nDrawing the Background, Grass, Squirrels, and Health Meter \n181.         # draw the green background \n182.         DISPLAYSURF.fill(GRASSCOLOR) \nLine 182 begins the code that starts drawing the contents of the display Surface object. First, line \n182 draws a green color for the background. This will paint over all of the previous contents of \nthe Surface so that we can start drawing the frame from scratch. \n184.         # draw all the grass objects on the screen \n185.         for gObj in grassObjs: \n186.             gRect = pygame.Rect( (gObj['x'] - camerax, \n187.                                   gObj['y'] - cameray, \n188.                                   gObj['width'], \n189.                                   gObj['height']) ) \n190.             DISPLAYSURF.blit(GRASSIMAGES[gObj['grassImage']], gRect) \nThe for loop on line 185 goes through all the grass objects in the grassObjs list and creates a \nRect object from the x, y, width, and height information stored in it. This Rect object is stored in \na variable named gRect. On line 190, gRect is used in the blit() method call to draw the \ngrass image on the display Surface. Note that gObj['grassImage'] only contains an integer \nthat is an index to GRASSIMAGES. GRASSIMAGES is a list of Surface objects that contain all \nthe grass images. Surface objects take up much more memory than just a single integer, and all \nthe grass objects with similar gObj['grassImage'] values look identical. So it makes sense \nto only have each grass image stored once in GRASSIMAGES and simply store integers in the \ngrass objects themselves. \n193.         # draw the other squirrels \n194.         for sObj in squirrelObjs: \n195.             sObj['rect'] = pygame.Rect( (sObj['x'] - camerax, \n196.                                          sObj['y'] - cameray - \ngetBounceAmount(sObj['bounce'], sObj['bouncerate'], sObj['bounceheight']), \n197.                                          sObj['width'], \n198.                                          sObj['height']) ) \n\n\nChapter 8 – Squirrel Eat Squirrel    225 \n \n199.             DISPLAYSURF.blit(sObj['surface'], sObj['rect']) \nThe for loop that draws all the enemy squirrel game objects is similar to the previous for loop, \nexcept that the Rect object it creates is saved in the 'rect' key’s value of the squirrel \ndictionary. The reason the code does this is because we will use this Rect object later to check if \nthe enemy squirrels have collided with the player squirrel. \nNote that the top parameter for the Rect constructor is not just sObj['y'] - cameray but \nsObj['y'] - cameray - getBounceAmount(sObj['bounce'], \nsObj['bouncerate'], sObj['bounceheight']). The getBounceAmount() \nfunction will return the number of pixels that the top value should be raised. \nAlso, there is no common list of Surface objects of the squirrel images, like there was with grass \ngame objects and GRASSIMAGES. Each enemy squirrel game object has its own Surface object \nstored in the 'surface' key. This is because the squirrel images can be scaled to different \nsizes. \n202.         # draw the player squirrel \n203.         flashIsOn = round(time.time(), 1) * 10 % 2 == 1 \nAfter drawing the grass and enemy squirrels, the code will draw the player’s squirrel. However, \nthere is one case where we would skip drawing the player’s squirrel. When the player collides \nwith a larger enemy squirrel, the player takes damage and flashes for a little bit to indicate that \nthe player is temporarily invulnerable. This flashing effect is done by drawing the player squirrel \non some iterations through the game loop but not on others.  \nThe player squirrel will be drawn on game loop iterations for a tenth of a second, and then not \ndrawn on the game loop iterations for a tenth of second. This repeats over and over again as long \nas the player is invulnerable (which, in the code, means that the invulnerableMode variable \nis set to True). Our code will make the flashing last for two seconds, since 2 was stored in the \nINVULNTIME constant variable on line 25. \nTo determine if the flash is on or not, line 202 grabs the current time from time.time(). Let’s \nuse the example where this function call returns 1323926893.622. This value is passed to \nround(), which rounds it to one digit past the decimal point (since 1 is passed as round()’s \nsecond parameter). This means round() will return the value 1323926893.6. \nThis value is then multiplied by 10, to become 13239268936. Once we have it as an integer, \nwe can do the ―mod two‖ trick first discussed in the Memory Puzzle chapter to see if it is even or \nodd. 13239268936 % 2 evaluates to 0, which means that flashIsOn will be set to False, \nsince 0 == 1 is False. \n\n\n226    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nIn fact, time.time() will keep returning values that will end up putting False into \nflashIsOn until 1323926893.700, which is the next tenth second. This is why the \nflashIsOn variable will constantly have False for one tenth of a second, and then True for \nthe next one tenth of a second (no matter how many iterations happen in that tenth of a second). \n204.         if not gameOverMode and not (invulnerableMode and flashIsOn): \n205.             playerObj['rect'] = pygame.Rect( (playerObj['x'] - camerax, \n206.                                               playerObj['y'] – cameray - \ngetBounceAmount(playerObj['bounce'], BOUNCERATE, BOUNCEHEIGHT), \n207.                                               playerObj['size'], \n208.                                               playerObj['size']) ) \n209.             DISPLAYSURF.blit(playerObj['surface'], playerObj['rect']) \nThere are three things that must be True before we draw the player’s squirrel. The game must \ncurrently be going on (which happens while gameOverMode is False) and the player is not \ninvulnerable and not flashing (which happens while invulnerableMode and flashIsOn \nare False). \nThe code for drawing the player’s squirrel is almost identical to the code for drawing the enemy \nsquirrels. \n212.         # draw the health meter \n213.         drawHealthMeter(playerObj['health']) \nThe drawHealthMeter() function draws the indicator at the top left corner of the screen that \ntells the player how many times the player squirrel can be hit before dying. This function will be \nexplained later in this chapter. \nThe Event Handling Loop \n215.         for event in pygame.event.get(): # event handling loop \n216.             if event.type == QUIT: \n217.                 terminate() \nThe first thing that is checked in the event handling loop is if the QUIT event has been generated. \nIf so, then the program should be terminated. \n219.             elif event.type == KEYDOWN: \n220.                 if event.key in (K_UP, K_w): \n221.                     moveDown = False \n222.                     moveUp = True \n223.                 elif event.key in (K_DOWN, K_s): \n\n\nChapter 8 – Squirrel Eat Squirrel    227 \n \n224.                     moveUp = False \n225.                     moveDown = True \nIf the up or down arrow keys have been pressed (or their WASD equivalents), then the move \nvariable (moveRight, moveDown, etc.) for that direction should be set to True and the move \nvariable for the opposite direction should be set to False. \n226.                 elif event.key in (K_LEFT, K_a): \n227.                     moveRight = False \n228.                     moveLeft = True \n229.                     if playerObj['facing'] == RIGHT: # change player image \n230.                         playerObj['surface'] = \npygame.transform.scale(L_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n231.                     playerObj['facing'] = LEFT \n232.                 elif event.key in (K_RIGHT, K_d): \n233.                     moveLeft = False \n234.                     moveRight = True \n235.                     if playerObj['facing'] == LEFT: # change player image \n236.                         playerObj['surface'] = \npygame.transform.scale(R_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n237.                     playerObj['facing'] = RIGHT \nThe moveLeft and moveRight variables should also be set when the left or right arrow keys \nare pressed. Also, the value in playerObj['facing'] should be updated to either LEFT or \nRIGHT. If the player squirrel is now facing a new direction, the playerObj['surface'] \nvalue should be replaced with a correctly scaled image of the squirrel facing the new direction. \nLine 229 is run if the left arrow key was pressed and checks if the player squirrel was facing \nright. If that was so, then a new scaled Surface object of the player squirrel image is stored in \nplayerObj['surface']. The code in line 232’s elif statement handles the opposite case. \n238.                 elif winMode and event.key == K_r: \n239.                     return \nIf the player has won the game by growing large enough (in which case, winMode will be set to \nTrue) and the R key has been pressed, then runGame()should return. This will end the current \ngame, and a new game will start the next time that runGame() gets called. \n241.             elif event.type == KEYUP: \n242.                 # stop moving the player's squirrel \n243.                 if event.key in (K_LEFT, K_a): \n244.                     moveLeft = False \n\n\n228    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n245.                 elif event.key in (K_RIGHT, K_d): \n246.                     moveRight = False \n247.                 elif event.key in (K_UP, K_w): \n248.                     moveUp = False \n249.                 elif event.key in (K_DOWN, K_s): \n250.                     moveDown = False \nIf the player lets up on any of the arrow or WASD keys, then the code should set the move \nvariable for that direction to False. This will stop the squirrel from moving in that direction any \nmore. \n252.                 elif event.key == K_ESCAPE: \n253.                     terminate() \nIf the key that was pressed was the Esc key, then terminate the program. \nMoving the Player, and Accounting for Bounce \n255.         if not gameOverMode: \n256.             # actually move the player \n257.             if moveLeft: \n258.                 playerObj['x'] -= MOVERATE \n259.             if moveRight: \n260.                 playerObj['x'] += MOVERATE \n261.             if moveUp: \n262.                 playerObj['y'] -= MOVERATE \n263.             if moveDown: \n264.                 playerObj['y'] += MOVERATE \nThe code inside the if statement on line 255 will move the player’s squirrel around only if the \ngame is not over. (This is why pressing on the arrow keys after the player’s squirrel dies will have \nno effect.) Depending on which of the move variables is set to True, the playerObj dictionary \nshould have its playerObj['x'] and playerObj['y'] values changed by MOVERATE. \n(This is why a larger value in MOVERATE makes the squirrel move faster.) \n266.             if (moveLeft or moveRight or moveUp or moveDown) or \nplayerObj['bounce'] != 0: \n267.                 playerObj['bounce'] += 1 \n268.  \n269.             if playerObj['bounce'] > BOUNCERATE: \n270.                 playerObj['bounce'] = 0 # reset bounce amount \n\n\nChapter 8 – Squirrel Eat Squirrel    229 \n \nThe value in playerObj['bounce'] keeps track of at what point in bouncing the player is \nat. This variable stores an integer value from 0 to BOUNCERATE. Just like the bounce value for \nthe enemy squirrels, a playerObj['bounce'] value of 0 means the player squirrel is at the \nstart of a bounce and a value of BOUNCERATE means the player squirrel is at the end of the \nbounce. \nThe player squirrel will bounce whenever the player is moving, or if the player has stopped \nmoving but the squirrel hasn’t finished its current bounce. This condition is captured in the if \nstatement on line 266. If any of the move variables is set to True or the current \nplayerObj['bounce'] is not 0 (which means the player is currently in a bounce), then the \nvariable should be incremented on line 267. \nBecause the playerObj['bounce'] variable should only be in the range of 0 to \nBOUNCERATE, if incrementing it makes it larger than BOUNCERATE, it should be reset back to \n0. \nCollision Detection: Eat or Be Eaten \n272.             # check if the player has collided with any squirrels \n273.             for i in range(len(squirrelObjs)-1, -1, -1): \n274.                 sqObj = squirrelObjs[i] \nThe for loop on 273 will go run code on each of the enemy squirrel game objects in \nsquirrelObjs. Notice that the parameters to range() on line 273 start at the last index of \nsquirrelObjs and decrement. This is because the code inside this for loop may end up \ndeleting some of these enemy squirrel game objects (if the player’s squirrel ends up eating them), \nso it is important to iterate from the end down to the front. The reason why was explained \npreviously in the ―When Deleting Items in a List, Iterate Over the List in Reverse‖ section. \n275.                 if 'rect' in sqObj and \nplayerObj['rect'].colliderect(sqObj['rect']): \n276.                     # a player/squirrel collision has occurred \n277. \n278.                     if sqObj['width'] * sqObj['height'] <= \nplayerObj['size']**2: \n279.                         # player is larger and eats the squirrel \n280.                         playerObj['size'] += int( (sqObj['width'] * \nsqObj['height'])**0.2 ) + 1 \n281.                         del squirrelObjs[i] \nIf the player’s squirrel is equal or larger than the size of the enemy squirrel it has collided with, \nthen the player’s squirrel will eat that squirrel and grow. The number that is added to the 'size' \n\n\n230    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nkey in the player object (that is, the growth) is calculated based on the enemy squirrel’s size on \nline 280. Here’s a graph showing the growth from different sized squirrels. Notice that larger \nsquirrels cause more growth: \n \nSo, according to the chart, eating a squirrel that has a width and height of 45 (that is, an area of \n1600 pixels) would cause the player to grow 5 pixels wider and taller. \nLine 281 deletes the eaten squirrel object from the squirrelObjs list so that it will no longer \nappear on the screen or have its position updated. \n283.                         if playerObj['facing'] == LEFT: \n284.                             playerObj['surface'] = \npygame.transform.scale(L_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n285.                         if playerObj['facing'] == RIGHT: \n286.                             playerObj['surface'] = \npygame.transform.scale(R_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \nThe player’s squirrel image needs to be updated now that the squirrel is larger. This can be done \nby passing the original squirrel image in L_SQUIR_IMG or R_SQUIR_IMG to the \npygame.transform.scale() function, which will return an enlarged version of the image. \nDepending on whether playerObj['facing'] is equal to LEFT or RIGHT determines \nwhich original squirrel image we pass to the function. \n288.                         if playerObj['size'] > WINSIZE: \n289.                             winMode = True # turn on \"win mode\" \n0\n1\n2\n3\n4\n5\n6\n7\n8\n1\n5\n9\n13\n17\n21\n25\n29\n33\n37\n41\n45\n49\n53\n57\n61\n65\n69\n73\n77\n81\n85\n89\n93\n97\nGrowth \nSize of Eaten Squirrel (width & height) \nint( (sqObj['width'] * sqObj['height'])**0.2 ) + 1 \n",
      "page_number": 239,
      "chapter_number": 27,
      "summary": "This chapter covers segment 27 (pages 239-248). Key topics include squirrel, line, and values. # go through all the objects and see if any need to be deleted.",
      "keywords": [
        "Squirrel",
        "player squirrel",
        "player",
        "playerObj",
        "Squirrel Objects",
        "enemy squirrel",
        "squirrel game objects",
        "Objects",
        "List",
        "Squirrel Eat",
        "grass objects",
        "Grass",
        "animals",
        "enemy squirrel game",
        "line"
      ],
      "concepts": [
        "squirrel",
        "line",
        "values",
        "key",
        "keys",
        "sizes",
        "sized",
        "list",
        "drawing",
        "objects"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "Segment 32 (pages 301-308)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 32,
          "title": "Segment 32 (pages 336-344)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.54,
          "method": "api"
        }
      ]
    },
    {
      "number": 28,
      "title": "Segment 28 (pages 249-257)",
      "start_page": 249,
      "end_page": 257,
      "detection_method": "topic_boundary",
      "content": "Chapter 8 – Squirrel Eat Squirrel    231 \n \nThe way the player wins the game is by getting the squirrel to have a size larger than the integer \nstored in the WINSIZE constant variable. If this is true, then the winMode variable is set to \nTrue. Code in the other parts of this function will handle displaying the congratulations text and \nchecking for the player to press the R key to restart the game. \n291.                     elif not invulnerableMode: \n292.                         # player is smaller and takes damage \n293.                         invulnerableMode = True \n294.                         invulnerableStartTime = time.time() \n295.                         playerObj['health'] -= 1 \n296.                         if playerObj['health'] == 0: \n297.                             gameOverMode = True # turn on \"game over mode\" \n298.                             gameOverStartTime = time.time() \nIf the player’s area was not equal to or larger than the area of the enemy squirrel, and \ninvulnerableMode was not set to True, then the player will take damage from colliding \nwith this larger squirrel. \nTo prevent the player from being damaged several times by the same squirrel immediately, we \nwill briefly make the player invulnerable to further squirrel attacks by setting \ninvulnerableMode to True on line 293. Line 294 will set invulnerableStartTime to \nthe current time (which is returned by time.time()) so that lines 133 and 134 can know when \nto set invulnerableMode to False. \nLine 295 decrements the player’s health by 1. Because there is a chance that the player’s health is \nnow at 0, line 296 checks for this and, if so, sets gameOverMode to True and \ngameOverStartTime to the current time. \nThe Game Over Screen \n299.         else: \n300.             # game is over, show \"game over\" text \n301.             DISPLAYSURF.blit(gameOverSurf, gameOverRect) \n302.             if time.time() - gameOverStartTime > GAMEOVERTIME: \n303.                 return # end the current game \nWhen the player has died, the ―Game Over‖ text (which is on the Surface object in the \ngameOverSurf variable) will be shown on the screen for the number of seconds that is in the \nGAMEOVERTIME constant. Once this amount of time has elapsed, then the runGame() function \nwill return. \n\n\n232    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThis lets the enemy squirrels continue to be animated and moving around for a few seconds after \nthe player dies and before the next game starts. The ―game over screen‖ in Squirrel Eat Squirrel \ndoes not wait until the player presses a key before a new game starts. \nWinning \n305.         # check if the player has won. \n306.         if winMode: \n307.             DISPLAYSURF.blit(winSurf, winRect) \n308.             DISPLAYSURF.blit(winSurf2, winRect2) \n309.  \n310.         pygame.display.update() \n311.         FPSCLOCK.tick(FPS) \nThe winMode variable is set to True on line 289 if the player has reached a certain size (which \nis dictated by the WINSIZE constant). All that happens when the player has won is that the ―You \nhave achieved OMEGA SQUIRREL!‖ text (which is on the Surface object stored in the \nwinSurf variable) and the ―(Press ―r‖ to restart.)‖ text (which is on the Surface object stored in \nthe winSurf2 variable) appears on the screen. The game continues until the user presses the R \nkey, at which point the program execution will return from runGame(). The event handling \ncode for the R key is done on lines 238 and 239. \nDrawing a Graphical Health Meter \n316. def drawHealthMeter(currentHealth): \n317.     for i in range(currentHealth): # draw red health bars \n318.         pygame.draw.rect(DISPLAYSURF, RED,   (15, 5 + (10 * MAXHEALTH) - i \n* 10, 20, 10)) \n319.     for i in range(MAXHEALTH): # draw the white outlines \n320.         pygame.draw.rect(DISPLAYSURF, WHITE, (15, 5 + (10 * MAXHEALTH) - i \n* 10, 20, 10), 1) \nTo draw the health meter, first the for loop on line 317 draws the filled-in red rectangle for the \namount of health the player has. Then the for loop on line 319 draws an unfilled white rectangle \nfor all of the possible health the player could have (which is the integer value stored in the \nMAXHEALTH constant). Note that the pygame.display.update() function is not called in \ndrawHealthMeter(). \nThe Same Old terminate() Function \n323. def terminate(): \n324.     pygame.quit() \n325.     sys.exit() \n\n\nChapter 8 – Squirrel Eat Squirrel    233 \n \nThe terminate() function works the same as in the previous game programs. \nThe Mathematics of the Sine Function \n328. def getBounceAmount(currentBounce, bounceRate, bounceHeight): \n329.     # Returns the number of pixels to offset based on the bounce. \n330.     # Larger bounceRate means a slower bounce. \n331.     # Larger bounceHeight means a higher bounce. \n332.     # currentBounce will always be less than bounceRate \n333.     return int(math.sin( (math.pi / float(bounceRate)) * currentBounce ) * \nbounceHeight) \n334. \nThere is a mathematical function (which is similar to functions in programming in that they both \n―return‖ or ―evaluate‖ to a number based on their parameters) called sine (pronounced like ―sign‖ \nand often abbreviated as ―sin‖). You may have learned about it in math class, but if you haven’t it \nwill be explained here. Python has this mathematic function as a Python function in the math \nmodule. You can pass an int or float value to math.sin(), and it will return a float value that is \ncalled the ―sine value‖ \nIn the interactive shell, let’s see what math.sin() returns for some values: \n>>> import math \n>>> math.sin(1) \n0.8414709848078965 \n>>> math.sin(2) \n0.90929742682568171 \n>>> math.sin(3) \n0.14112000805986721 \n>>> math.sin(4) \n-0.7568024953079282 \n>>> math.sin(5) \n-0.95892427466313845 \nIt seems really hard to predict what value math.sin() is going to return based on what value \nwe pass it (which might make you wonder what math.sin() is useful for). But if we graph the \nsine values of the integers 1 through 10 on a graph, we would get this: \n\n\n234    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nYou can kind of see a wavy pattern in the values returned by math.sin(). If you figure out the \nsine values for more numbers besides integers (for example, 1.5 and 2.5 and so on) and then \nconnect the dots with lines, you can see this wavy pattern more easily: \n \nIn fact, if you kept adding more and more data points to this graph, you would see that the sine \nwave looks like this: \n \n-1.5\n-1\n-0.5\n0\n0.5\n1\n1.5\n0\n2\n4\n6\n8\n10\n12\nmath.sin(arg) \narg \nValues Returned by math.sin() \n-1.5\n-1\n-0.5\n0\n0.5\n1\n1.5\n0 0.5 1 1.5 2 2.5 3 3.5 4 4.5 5 5.5 6 6.5 7 7.5 8 8.5 9 9.5 10\nmath.sin(arg) \narg \nValues Returned by math.sin() \n\n\nChapter 8 – Squirrel Eat Squirrel    235 \n \nNotice that math.sin(0) returns 0, then gradually increases until math.sin(3.14 / 2) \nreturns 1, then it begins to decrease until math.sin(3.14) returns 0. The number 3.14 is a \nspecial number in mathematics called pi (pronounced the same as delicious ―pie‖). This value is \nalso stored in the constant variable pi in the math module (which is why line 333 uses the \nvariable, math.pi), which is technically the float value 3.1415926535897931. Since we \nwant a wavy-looking bounce for our squirrel, we’ll only pay attention to the return values of \nmath.sin() for the arguments 0 to 3.14: \n \nLet’s take a look at the return value of getBounceAmount() and figure out what it does \nexactly. \n333.     return int(math.sin( (math.pi / float(bounceRate)) * currentBounce ) * \nbounceHeight) \nRemember that on line 21 we set the BOUNCERATE constant to 6. This means that our code will \nonly increment playerObj['bounce'] from 0 to 6 and that we want to split up the range of \nfloating-point values from 0 to 3.14 into 6 parts, which we can do with simple division: 3.14 \n/ 6 = 0.5235. Each of the 6 equal parts of the 3.14 length on the graph for the ―sine wave \nbounce‖ is 0.5235. \nYou can see that when playerObj['bounce'] is at 3 (halfway between 0 and 6), the value \npassed to the math.sin() call is math.pi / 6 * 3, which is 1.5707 (halfway between 0 \nand 3.1415). Then math.sin(1.5707) will return 1.0, which is the highest part of the sine \nwave (and the highest part of the sine wave happens half way through the wave). \n0\n0.2\n0.4\n0.6\n0.8\n1\n1.2\n0\n0.12\n0.24\n0.36\n0.48\n0.6\n0.72\n0.84\n0.96\n1.08\n1.2\n1.32\n1.44\n1.56\n1.68\n1.8\n1.92\n2.04\n2.16\n2.28\n2.4\n2.52\n2.64\n2.76\n2.88\n3\n3.14\nmath.sin(arg) \narg \nValues Returned by math.sin() \n\n\n236    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nAs playerObj['bounce'] gets its value incremented, the getBounceAmount() function \nwill return values that have the same bounce shape that the sine wave has from 0 to 3.14. If you \nwant to make the bounce higher, than increase the BOUNCEHEIGHT constant. If you want to \nmake the bounce slower, than increase the BOUNCERATE constant. \nThe sine function is a concept from trigonometry mathematics. If you’d like to learn more about \nthe sine wave, the Wikipedia page has detailed information: http://en.wikipedia.org/wiki/Sine \nBackwards Compatibility with Python Version 2 \nThe reason we call float() to convert bounceRate to a floating point number is simply so \nthat this program will work in Python version 2. In Python version 3, the division operator will \nevaluate to a floating point value even if both of the operands are integers, like this: \n>>> # Python version 3 \n... \n>>> 10 / 5 \n2.0 \n>>> 10 / 4 \n2.5 \n>>> \nHowever, in Python version 2, the / division operator will only evaluate to a floating point value \nif one of the operands is also a floating point value. If both operands are integers, then Python 2’s \ndivision operator will evaluate to an integer value (rounding down if needed), like this: \n>>> # Python version 2 \n... \n>>> 10 / 5 \n2 \n>>> 10 / 4 \n2 \n>>> 10 / 4.0 \n2.5 \n>>> 10.0 / 4 \n2.5 \n>>> 10.0 / 4.0 \n2.5 \nBut if we always convert one of the values to a floating point value with the float() function, \nthen the division operator will evaluate to a float value no matter which version of Python runs \nthis source code. Making these changes so that our code works with older versions of software is \ncalled backwards compatibility. It is important to maintain backwards compatibility, because \n\n\nChapter 8 – Squirrel Eat Squirrel    237 \n \nnot everyone will always be running the latest version of software and you want to ensure that the \ncode you write works with as many computers as possible. \nYou can’t always make your Python 3 code backwards compatible with Python 2, but if it’s \npossible then you should do it. Otherwise, when people with Python 2 try to run your games will \nget error messages and think that your program is buggy. \nA list of some differences between Python 2 and Python 3 can be found at \nhttp://inventwithpython.com/appendixa.html. \nThe getRandomVelocity() Function \n335. def getRandomVelocity(): \n336.     speed = random.randint(SQUIRRELMINSPEED, SQUIRRELMAXSPEED) \n337.     if random.randint(0, 1) == 0: \n338.         return speed \n339.     else: \n340.         return -speed \nThe getRandomVelocity() function is used to randomly determine how fast an enemy \nsquirrel will move. The range of this velocity is set in the SQUIRRELMINSPEED and \nSQUIRRELMAXSPEED constants, but on top of that, the speed is either negative (indicating the \nsquirrel goes to the left or up) or positive (indicating the squirrel goes to the right or down). There \nis a fifty-fifty chance for the random speed to be positive or negative. \nFinding a Place to Add New Squirrels and Grass \n343. def getRandomOffCameraPos(camerax, cameray, objWidth, objHeight): \n344.     # create a Rect of the camera view \n345.     cameraRect = pygame.Rect(camerax, cameray, WINWIDTH, WINHEIGHT) \n346.     while True: \n347.         x = random.randint(camerax - WINWIDTH, camerax + (2 * WINWIDTH)) \n348.         y = random.randint(cameray - WINHEIGHT, cameray + (2 * WINHEIGHT)) \n349.         # create a Rect object with the random coordinates and use \ncolliderect() \n350.         # to make sure the right edge isn't in the camera view. \n351.         objRect = pygame.Rect(x, y, objWidth, objHeight) \n352.         if not objRect.colliderect(cameraRect): \n353.             return x, y \nWhen a new squirrel or grass object is created in the game world, we want it to be within the \nactive area (so that it is near the player’s squirrel) but not within the view of the camera (so that it \ndoesn’t just suddenly pop into existence on the screen). To do this, we create a Rect object that \n\n\n238    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nrepresents the area of the camera (using camerax, cameray, WINWIDTH, and WINHEIGHT \nconstants). \nNext, we randomly generate numbers for the XY coordinates that would be within the active area. \nThe active area’s left and top edge are WINWIDTH and WINHEIGHT pixels to the left and up of \ncamerax and cameray. So the active area’s left and top edge are at camerax - WINWIDTH \nand cameray - WINHEIGHT. The active area’s width and height are also three times the size \nof the WINWIDTH and WINHEIGHT, as you can see in this image (where WINWIDTH is set to \n640 pixels and WINHEIGHT set to 480 pixels): \n \nThis means the right and bottom edges will be at camerax + (2 * WINWIDTH) and \ncameray + (2 * WINHEIGHT). Line 352 will check if the random XY coordinates would \ncollide with the camera view’s Rect object. If not, then those coordinates are returned. If so, then \nthe while loop on line 346 will keep generating new coordinates until it finds acceptable ones. \nCreating Enemy Squirrel Data Structures \n356. def makeNewSquirrel(camerax, cameray): \n357.     sq = {} \n358.     generalSize = random.randint(5, 25) \n359.     multiplier = random.randint(1, 3) \n360.     sq['width']  = (generalSize + random.randint(0, 10)) * multiplier \n361.     sq['height'] = (generalSize + random.randint(0, 10)) * multiplier \n362.     sq['x'], sq['y'] = getRandomOffCameraPos(camerax, cameray, \nsq['width'], sq['height']) \n363.     sq['movex'] = getRandomVelocity() \n364.     sq['movey'] = getRandomVelocity() \nCreating enemy squirrel game objects is similar to making the grass game objects. The data for \neach enemy squirrel is also stored in a dictionary. The width and height are set to random sizes on \nline 360 and 361. The generalSize variable is used so that the width and height of each \n\n\nChapter 8 – Squirrel Eat Squirrel    239 \n \nsquirrel aren’t too different from each other. Otherwise, using completely random numbers for \nwidth and height could give us very tall and skinny squirrels or very short and wide squirrels. The \nwidth and height of the squirrel are this general size with a random number from 0 to 10 added to \nit (for slight variation), and then multiplied by the multiplier variable. \nThe original XY coordinate position of the squirrel will be a random location that the camera \ncannot see, to prevent the squirrels from just ―popping‖ into existence on the screen. \nThe speed and direction are also randomly selected by the getRandomVelocity() function. \nFlipping the Squirrel Image \n365.     if sq['movex'] < 0: # squirrel is facing left \n366.         sq['surface'] = pygame.transform.scale(L_SQUIR_IMG, (sq['width'], \nsq['height'])) \n367.     else: # squirrel is facing right \n368.         sq['surface'] = pygame.transform.scale(R_SQUIR_IMG, (sq['width'], \nsq['height'])) \n369.     sq['bounce'] = 0 \n370.     sq['bouncerate'] = random.randint(10, 18) \n371.     sq['bounceheight'] = random.randint(10, 50) \n372.     return sq \nThe L_SQUIR_IMG and R_SQUIR_IMG constants contain Surface objects with left-facing and \nright-facing squirrel images on them. New Surface objects will be made using the \npygame.transform.scale() function to match the squirrel’s  width and height (stored in \nsq['width'] and sq['height'] respectively). \nAfter that, the three bounce-related values are randomly generated (except for sq['bounce'] \nwhich is 0 because the squirrel always starts at the beginning of the bounce) and the dictionary is \nreturned on line 372. \nCreating Grass Data Structures \n375. def makeNewGrass(camerax, cameray): \n376.     gr = {} \n377.     gr['grassImage'] = random.randint(0, len(GRASSIMAGES) - 1) \n378.     gr['width']  = GRASSIMAGES[0].get_width() \n379.     gr['height'] = GRASSIMAGES[0].get_height() \n380.     gr['x'], gr['y'] = getRandomOffCameraPos(camerax, cameray, \ngr['width'], gr['height']) \n381.     gr['rect'] = pygame.Rect( (gr['x'], gr['y'], gr['width'], \ngr['height']) ) \n382.     return gr \n",
      "page_number": 249,
      "chapter_number": 28,
      "summary": "This chapter covers segment 28 (pages 249-257). Key topics include squirrel, random, and returned. Covers function. If this is true, then the winMode variable is set to \nTrue.",
      "keywords": [
        "Squirrel",
        "Squirrel Eat",
        "math.sin",
        "Python",
        "player",
        "Python Version",
        "game",
        "function",
        "enemy squirrel",
        "line",
        "width",
        "height",
        "WINHEIGHT",
        "bounce",
        "WINWIDTH"
      ],
      "concepts": [
        "squirrel",
        "random",
        "returned",
        "function",
        "functions",
        "game",
        "value",
        "bounce",
        "constant",
        "code"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 28,
          "title": "Segment 28 (pages 261-272)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "AI Agents In Action",
          "chapter": 18,
          "title": "Segment 18 (pages 147-158)",
          "relevance_score": 0.49,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 5,
          "title": "Segment 5 (pages 35-42)",
          "relevance_score": 0.49,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 40,
          "title": "Segment 40 (pages 368-375)",
          "relevance_score": 0.47,
          "method": "api"
        }
      ]
    },
    {
      "number": 29,
      "title": "Segment 29 (pages 258-265)",
      "start_page": 258,
      "end_page": 265,
      "detection_method": "topic_boundary",
      "content": "240    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe grass game objects are dictionaries with the usual 'x', 'y', 'width', 'height', and \n'rect' keys but also a 'grassImage' key which is a number from 0 to one less than the \nlength of the GRASSIMAGES list. This number will determine what image the grass game object \nhas. For example, if the value of the grass object’s 'grassImage' key is 3, then it will use the \nSurface object stored at GRASSIMAGES[3] for its image. \nChecking if Outside the Active Area \n385. def isOutsideActiveArea(camerax, cameray, obj): \n386.     # Return False if camerax and cameray are more than \n387.     # a half-window length beyond the edge of the window. \n388.     boundsLeftEdge = camerax - WINWIDTH \n389.     boundsTopEdge = cameray - WINHEIGHT \n390.     boundsRect = pygame.Rect(boundsLeftEdge, boundsTopEdge, WINWIDTH * 3, \nWINHEIGHT * 3) \n391.     objRect = pygame.Rect(obj['x'], obj['y'], obj['width'], obj['height']) \n392.     return not boundsRect.colliderect(objRect) \nThe isOutsideActiveArea() will return True if the object you pass it is outside of the \n―active area‖ that is dictated by the camerax and cameray parameters. Remember that the \nactive area is an area around the camera view the size of the camera view (which has a width and \nheight set by WINWIDTH and WINHEIGHT), like this: \n \nWe can create a Rect object that represents the active area by passing camerax - WINWIDTH \nfor the left edge value and cameray - WINHEIGHT for the top edge value, and then \nWINWIDTH * 3 and WINHEIGHT * 3 for the width and height. Once we have the active area \nrepresented as a Rect object, we can use the colliderect() method to determine if the object \nin the obj parameter is collides with (that is, is inside of) the active area Rect object. \n\n\nChapter 8 – Squirrel Eat Squirrel    241 \n \nSince the player squirrel, enemy squirrel and grass objects all have 'x', 'y', 'width' and \n'height' keys, the isOutsideActiveArea() code can work with any type of those game \nobjects.  \n395. if __name__ == '__main__': \n396.     main() \nFinally, after all the functions have been defined, the program will run the main() function and \nstart the game. \nSummary \nSquirrel Eat Squirrel was our first game to have multiple enemies moving around the board at \nonce. The key to having several enemies was using a dictionary value with identical keys for each \nenemy squirrel, so that the same code could be run on each of them during an iteration through \nthe game loop. \nThe concept of the camera was also introduced. Cameras weren’t needed for our previous games \nbecause the entire game world fit onto one screen. However, when you make your own games \nthat involve a player moving around a large game world, you will need code to handle converting \nbetween the game world’s coordinate system and the screen’s pixel coordinate system. \nFinally, the mathematical sine function was introduced to give realistic squirrel hops (no matter \nhow tall or long each hop was). You don’t need to know a lot of math to do programming. In \nmost cases, just knowing addition, multiplication, and negative numbers is fine. However, if you \nstudy mathematics, you’ll often find several uses for math to make your games cooler. \nFor additional programming practice, you can download buggy versions of Squirrel Eat Squirrel \nfrom http://invpy.com/buggy/squirrel and try to figure out how to fix the bugs. \n \n\n\n242    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nCHAPTER 9 – STAR PUSHER \n \n \nHow to Play Star Pusher \nStar Pusher is a Sokoban or ―Box Pusher‖ clone. The player is in a room with several stars. There \nare star marks on the grounds of some of the tile sprites in the room. The player must figure out \nhow to push the stars on top of the tiles with star marks. The player cannot push a star if there is a \nwall or another star behind it. The player cannot pull stars, so if a star gets pushed into a corner, \nthe player will have to restart the level. When all of the stars have been pushed onto star-marked \nfloor tiles, the level is complete and the next level starts. \nEach level is made up of a 2D grid of tile images. Tile sprites are images of the same size that \ncan be placed next to each other to form more complex images. With a few floor and wall tiles, \nwe can create levels of many interesting shapes and sizes. \nThe level files are not included in the source code. Instead, you can either create the level files \nyourself or download them. A level file with 201 levels can be downloaded from \nhttp://invpy.com/starPusherLevels.txt. When you run the Star Pusher program, make sure that this \nlevel file is in the same folder as the starpusher.py file. Otherwise you will get this error message: \nAssertionError: Cannot find the level file: starPusherLevels.txt \nThe level designs were originally made David W. Skinner. You can download more puzzles from \nhis website at http://users.bentonrea.com/~sasquatch/sokoban/. \nSource Code to Star Pusher \nThis source code can be downloaded from http://invpy.com/starpusher.py. If you get any error \nmessages, look at the line number that is mentioned in the error message and check your code for \nany typos. You can also copy and paste your code into the web form at \n\n\nChapter 9 – Star Pusher    243 \n \nhttp://invpy.com/diff/starpusher to see if the differences between your code and the code in the \nbook. \nThe level file can be downloaded from http://invpy.com/starPusherLevels.txt. The tiles can be \ndownloaded from http://invpy.com/starPusherImages.zip. \nAlso, just like the squirrel, grass, and enemy ―objects‖ in the Squirrel Eat Squirrel game, when I \nsay ―map objects‖, ―game state objects‖, or ―level objects‖ in this chapter, I do not mean objects \nin the Object-Oriented Programming sense. These ―objects‖ are really just dictionary values, but \nit is easier to refer to them as objects since they represent things in the game world. \n  1. # Star Pusher (a Sokoban clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, sys, copy, os, pygame \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 # frames per second to update the screen \n 10. WINWIDTH = 800 # width of the program's window, in pixels \n 11. WINHEIGHT = 600 # height in pixels \n 12. HALF_WINWIDTH = int(WINWIDTH / 2) \n 13. HALF_WINHEIGHT = int(WINHEIGHT / 2) \n 14.  \n 15. # The total width and height of each tile in pixels. \n 16. TILEWIDTH = 50 \n 17. TILEHEIGHT = 85 \n 18. TILEFLOORHEIGHT = 45 \n 19.  \n 20. CAM_MOVE_SPEED = 5 # how many pixels per frame the camera moves \n 21.  \n 22. # The percentage of outdoor tiles that have additional \n 23. # decoration on them, such as a tree or rock. \n 24. OUTSIDE_DECORATION_PCT = 20 \n 25.  \n 26. BRIGHTBLUE = (  0, 170, 255) \n 27. WHITE      = (255, 255, 255) \n 28. BGCOLOR = BRIGHTBLUE \n 29. TEXTCOLOR = WHITE \n 30.  \n 31. UP = 'up' \n 32. DOWN = 'down' \n 33. LEFT = 'left' \n 34. RIGHT = 'right' \n\n\n244    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 35. \n 36. \n 37. def main(): \n 38.     global FPSCLOCK, DISPLAYSURF, IMAGESDICT, TILEMAPPING, \nOUTSIDEDECOMAPPING, BASICFONT, PLAYERIMAGES, currentImage \n 39.  \n 40.     # Pygame initialization and basic set up of the global variables. \n 41.     pygame.init() \n 42.     FPSCLOCK = pygame.time.Clock() \n 43.  \n 44.     # Because the Surface object stored in DISPLAYSURF was returned \n 45.     # from the pygame.display.set_mode() function, this is the \n 46.     # Surface object that is drawn to the actual computer screen \n 47.     # when pygame.display.update() is called. \n 48.     DISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT)) \n 49.  \n 50.     pygame.display.set_caption('Star Pusher') \n 51.     BASICFONT = pygame.font.Font('freesansbold.ttf', 18) \n 52. \n 53.     # A global dict value that will contain all the Pygame \n 54.     # Surface objects returned by pygame.image.load(). \n 55.     IMAGESDICT = {'uncovered goal': pygame.image.load('RedSelector.png'), \n 56.                   'covered goal': pygame.image.load('Selector.png'), \n 57.                   'star': pygame.image.load('Star.png'), \n 58.                   'corner': pygame.image.load('Wall Block Tall.png'), \n 59.                   'wall': pygame.image.load('Wood Block Tall.png'), \n 60.                   'inside floor': pygame.image.load('Plain Block.png'), \n 61.                   'outside floor': pygame.image.load('Grass Block.png'), \n 62.                   'title': pygame.image.load('star_title.png'), \n 63.                   'solved': pygame.image.load('star_solved.png'), \n 64.                   'princess': pygame.image.load('princess.png'), \n 65.                   'boy': pygame.image.load('boy.png'), \n 66.                   'catgirl': pygame.image.load('catgirl.png'), \n 67.                   'horngirl': pygame.image.load('horngirl.png'), \n 68.                   'pinkgirl': pygame.image.load('pinkgirl.png'), \n 69.                   'rock': pygame.image.load('Rock.png'), \n 70.                   'short tree': pygame.image.load('Tree_Short.png'), \n 71.                   'tall tree': pygame.image.load('Tree_Tall.png'), \n 72.                   'ugly tree': pygame.image.load('Tree_Ugly.png')} \n 73.  \n 74.     # These dict values are global, and map the character that appears \n 75.     # in the level file to the Surface object it represents. \n 76.     TILEMAPPING = {'x': IMAGESDICT['corner'], \n 77.                    '#': IMAGESDICT['wall'], \n 78.                    'o': IMAGESDICT['inside floor'], \n 79.                    ' ': IMAGESDICT['outside floor']} \n\n\nChapter 9 – Star Pusher    245 \n \n 80.     OUTSIDEDECOMAPPING = {'1': IMAGESDICT['rock'], \n 81.                           '2': IMAGESDICT['short tree'], \n 82.                           '3': IMAGESDICT['tall tree'], \n 83.                           '4': IMAGESDICT['ugly tree']} \n 84. \n 85.     # PLAYERIMAGES is a list of all possible characters the player can be. \n 86.     # currentImage is the index of the player's current player image. \n 87.     currentImage = 0 \n 88.     PLAYERIMAGES = [IMAGESDICT['princess'], \n 89.                     IMAGESDICT['boy'], \n 90.                     IMAGESDICT['catgirl'], \n 91.                     IMAGESDICT['horngirl'], \n 92.                     IMAGESDICT['pinkgirl']] \n 93. \n 94.     startScreen() # show the title screen until the user presses a key \n 95.  \n 96.     # Read in the levels from the text file. See the readLevelsFile() for \n 97.     # details on the format of this file and how to make your own levels. \n 98.     levels = readLevelsFile('starPusherLevels.txt') \n 99.     currentLevelIndex = 0 \n100. \n101.     # The main game loop. This loop runs a single level, when the user \n102.     # finishes that level, the next/previous level is loaded. \n103.     while True: # main game loop \n104.         # Run the level to actually start playing the game: \n105.         result = runLevel(levels, currentLevelIndex) \n106. \n107.         if result in ('solved', 'next'): \n108.             # Go to the next level. \n109.             currentLevelIndex += 1 \n110.             if currentLevelIndex >= len(levels): \n111.                 # If there are no more levels, go back to the first one. \n112.                 currentLevelIndex = 0 \n113.         elif result == 'back': \n114.             # Go to the previous level. \n115.             currentLevelIndex -= 1 \n116.             if currentLevelIndex < 0: \n117.                 # If there are no previous levels, go to the last one. \n118.                 currentLevelIndex = len(levels)-1 \n119.         elif result == 'reset': \n120.             pass # Do nothing. Loop re-calls runLevel() to reset the level \n121. \n122. \n123. def runLevel(levels, levelNum): \n124.     global currentImage \n125.     levelObj = levels[levelnum] \n\n\n246    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n126.     mapObj = decorateMap(levelObj['mapObj'], \nlevelObj['startState']['player']) \n127.     gameStateObj = copy.deepcopy(levelObj['startState']) \n128.     mapNeedsRedraw = True # set to True to call drawMap() \n129.     levelSurf = BASICFONT.render('Level %s of %s' % (levelObj['levelNum'] \n+ 1, totalNumOfLevels), 1, TEXTCOLOR) \n130.     levelRect = levelSurf.get_rect() \n131.     levelRect.bottomleft = (20, WINHEIGHT - 35) \n132.     mapWidth = len(mapObj) * TILEWIDTH \n133.     mapHeight = (len(mapObj[0]) - 1) * (TILEHEIGHT - TILEFLOORHEIGHT) + \nTILEHEIGHT \n134.     MAX_CAM_X_PAN = abs(HALF_WINHEIGHT - int(mapHeight / 2)) + TILEWIDTH \n135.     MAX_CAM_Y_PAN = abs(HALF_WINWIDTH - int(mapWidth / 2)) + TILEHEIGHT \n136.  \n137.     levelIsComplete = False \n138.     # Track how much the camera has moved: \n139.     cameraOffsetX = 0 \n140.     cameraOffsetY = 0 \n141.     # Track if the keys to move the camera are being held down: \n142.     cameraUp = False \n143.     cameraDown = False \n144.     cameraLeft = False \n145.     cameraRight = False \n146.  \n147.     while True: # main game loop \n148.         # Reset these variables: \n149.         playerMoveTo = None \n150.         keyPressed = False \n151.  \n152.         for event in pygame.event.get(): # event handling loop \n153.             if event.type == QUIT: \n154.                 # Player clicked the \"X\" at the corner of the window. \n155.                 terminate() \n156.  \n157.             elif event.type == KEYDOWN: \n158.                 # Handle key presses \n159.                 keyPressed = True \n160.                 if event.key == K_LEFT: \n161.                     playerMoveTo = LEFT \n162.                 elif event.key == K_RIGHT: \n163.                     playerMoveTo = RIGHT \n164.                 elif event.key == K_UP: \n165.                     playerMoveTo = UP \n166.                 elif event.key == K_DOWN: \n167.                     playerMoveTo = DOWN \n168.  \n\n\nChapter 9 – Star Pusher    247 \n \n169.                 # Set the camera move mode. \n170.                 elif event.key == K_a: \n171.                     cameraLeft = True \n172.                 elif event.key == K_d: \n173.                     cameraRight = True \n174.                 elif event.key == K_w: \n175.                     cameraUp = True \n176.                 elif event.key == K_s: \n177.                     cameraDown = True \n178.  \n179.                 elif event.key == K_n: \n180.                     return 'next' \n181.                 elif event.key == K_b: \n182.                     return 'back' \n183.  \n184.                 elif event.key == K_ESCAPE: \n185.                     terminate() # Esc key quits. \n186.                 elif event.key == K_BACKSPACE: \n187.                     return 'reset' # Reset the level. \n188.                 elif event.key == K_p: \n189.                     # Change the player image to the next one. \n190.                     currentImage += 1 \n191.                     if currentImage >= len(PLAYERIMAGES): \n192.                         # After the last player image, use the first one. \n193.                         currentImage = 0 \n194.                     mapNeedsRedraw = True \n195.  \n196.             elif event.type == KEYUP: \n197.                 # Unset the camera move mode. \n198.                 if event.key == K_a: \n199.                     cameraLeft = False \n200.                 elif event.key == K_d: \n201.                     cameraRight = False \n202.                 elif event.key == K_w: \n203.                     cameraUp = False \n204.                 elif event.key == K_s: \n205.                     cameraDown = False \n206.  \n207.         if playerMoveTo != None and not levelIsComplete: \n208.             # If the player pushed a key to move, make the move \n209.             # (if possible) and push any stars that are pushable. \n210.             moved = makeMove(mapObj, gameStateObj, playerMoveTo) \n211.  \n212.             if moved: \n213.                 # increment the step counter. \n214.                 gameStateObj['stepCounter'] += 1 \n",
      "page_number": 258,
      "chapter_number": 29,
      "summary": "This chapter covers segment 29 (pages 258-265). Key topics include loaded, level. This number will determine what image the grass game object \nhas.",
      "keywords": [
        "STAR PUSHER",
        "elif event.key",
        "IMAGESDICT",
        "level",
        "STAR",
        "Squirrel",
        "game",
        "Squirrel Eat",
        "event.key",
        "PUSHER",
        "WINHEIGHT",
        "objects"
      ],
      "concepts": [
        "key",
        "loaded",
        "level",
        "games",
        "object",
        "squirrel",
        "star",
        "player",
        "moving",
        "moves"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 13,
          "title": "Segment 13 (pages 115-123)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 22,
          "title": "Segment 22 (pages 205-213)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.52,
          "method": "api"
        }
      ]
    },
    {
      "number": 30,
      "title": "Segment 30 (pages 266-273)",
      "start_page": 266,
      "end_page": 273,
      "detection_method": "topic_boundary",
      "content": "248    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n215.                 mapNeedsRedraw = True \n216.  \n217.             if isLevelFinished(levelObj, gameStateObj): \n218.                 # level is solved, we should show the \"Solved!\" image. \n219.                 levelIsComplete = True \n220.                 keyPressed = False \n221.  \n222.         DISPLAYSURF.fill(BGCOLOR) \n223.  \n224.         if mapNeedsRedraw: \n225.             mapSurf = drawMap(mapObj, gameStateObj, levelObj['goals']) \n226.             mapNeedsRedraw = False \n227.  \n228.         if cameraUp and cameraOffsetY < MAX_CAM_X_PAN: \n229.             cameraOffsetY += CAM_MOVE_SPEED \n230.         elif cameraDown and cameraOffsetY > -MAX_CAM_X_PAN: \n231.             cameraOffsetY -= CAM_MOVE_SPEED \n232.         if cameraLeft and cameraOffsetX < MAX_CAM_Y_PAN: \n233.             cameraOffsetX += CAM_MOVE_SPEED \n234.         elif cameraRight and cameraOffsetX > -MAX_CAM_Y_PAN: \n235.             cameraOffsetX -= CAM_MOVE_SPEED \n236.  \n237.         # Adjust mapSurf's Rect object based on the camera offset. \n238.         mapSurfRect = mapSurf.get_rect() \n239.         mapSurfRect.center = (HALF_WINWIDTH + cameraOffsetX, \nHALF_WINHEIGHT + cameraOffsetY) \n240.  \n241.         # Draw mapSurf to the DISPLAYSURF Surface object. \n242.         DISPLAYSURF.blit(mapSurf, mapSurfRect) \n243.  \n244.         DISPLAYSURF.blit(levelSurf, levelRect) \n245.         stepSurf = BASICFONT.render('Steps: %s' % \n(gameStateObj['stepCounter']), 1, TEXTCOLOR) \n246.         stepRect = stepSurf.get_rect() \n247.         stepRect.bottomleft = (20, WINHEIGHT - 10) \n248.         DISPLAYSURF.blit(stepSurf, stepRect) \n249.  \n250.         if levelIsComplete: \n251.             # is solved, show the \"Solved!\" image until the player \n252.             # has pressed a key. \n253.             solvedRect = IMAGESDICT['solved'].get_rect() \n254.             solvedRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT) \n255.             DISPLAYSURF.blit(IMAGESDICT['solved'], solvedRect) \n256.  \n257.             if keyPressed: \n258.                 return 'solved' \n\n\nChapter 9 – Star Pusher    249 \n \n259.  \n260.         pygame.display.update() # draw DISPLAYSURF to the screen. \n261.         FPSCLOCK.tick() \n262. \n263. \n274. def decorateMap(mapObj, startxy): \n275.     \"\"\"Makes a copy of the given map object and modifies it. \n276.     Here is what is done to it: \n277.         * Walls that are corners are turned into corner pieces. \n278.         * The outside/inside floor tile distinction is made. \n279.         * Tree/rock decorations are randomly added to the outside tiles. \n280.  \n281.     Returns the decorated map object.\"\"\" \n282.  \n283.     startx, starty = startxy # Syntactic sugar \n284.  \n285.     # Copy the map object so we don't modify the original passed \n286.     mapObjCopy = copy.deepcopy(mapObj) \n287.  \n288.     # Remove the non-wall characters from the map data \n289.     for x in range(len(mapObjCopy)): \n290.         for y in range(len(mapObjCopy[0])): \n291.             if mapObjCopy[x][y] in ('$', '.', '@', '+', '*'): \n292.                 mapObjCopy[x][y] = ' ' \n293.  \n294.     # Flood fill to determine inside/outside floor tiles. \n295.     floodFill(mapObjCopy, startx, starty, ' ', 'o') \n296.  \n297.     # Convert the adjoined walls into corner tiles. \n298.     for x in range(len(mapObjCopy)): \n299.         for y in range(len(mapObjCopy[0])): \n300. \n301.             if mapObjCopy[x][y] == '#': \n302.                 if (isWall(mapObjCopy, x, y-1) and isWall(mapObjCopy, x+1, \ny)) or \\ \n303.                    (isWall(mapObjCopy, x+1, y) and isWall(mapObjCopy, x, \ny+1)) or \\ \n304.                    (isWall(mapObjCopy, x, y+1) and isWall(mapObjCopy, x-1, \ny)) or \\ \n305.                    (isWall(mapObjCopy, x-1, y) and isWall(mapObjCopy, x, \ny-1)): \n306.                     mapObjCopy[x][y] = 'x' \n307. \n308.             elif mapObjCopy[x][y] == ' ' and random.randint(0, 99) < \nOUTSIDE_DECORATION_PCT: \n\n\n250    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n309.                 mapObjCopy[x][y] = \nrandom.choice(list(OUTSIDEDECOMAPPING.keys())) \n310.  \n311.     return mapObjCopy  \n312. \n313. \n314. def isBlocked(mapObj, gameStateObj, x, y): \n315.     \"\"\"Returns True if the (x, y) position on the map is \n316.     blocked by a wall or star, otherwise return False.\"\"\" \n317. \n318.     if isWall(mapObj, x, y): \n319.         return True \n320. \n321.     elif x < 0 or x >= len(mapObj) or y < 0 or y >= len(mapObj[x]): \n322.         return True # x and y aren't actually on the map. \n323. \n324.     elif (x, y) in gameStateObj['stars']: \n325.         return True # a star is blocking \n326.  \n327.     return False \n328. \n329. \n330. def makeMove(mapObj, gameStateObj, playerMoveTo): \n331.     \"\"\"Given a map and game state object, see if it is possible for the \n332.     player to make the given move. If it is, then change the player's \n333.     position (and the position of any pushed star). If not, do nothing. \n334.  \n335.     Returns True if the player moved, otherwise False.\"\"\" \n336.  \n337.     # Make sure the player can move in the direction they want. \n338.     playerx, playery = gameStateObj['player'] \n339.  \n340.     # This variable is \"syntactic sugar\". Typing \"stars\" is more \n341.     # readable than typing \"gameStateObj['stars']\" in our code. \n342.     stars = gameStateObj['stars'] \n343.  \n344.     # The code for handling each of the directions is so similar aside \n345.     # from adding or subtracting 1 to the x/y coordinates. We can \n346.     # simplify it by using the xOffset and yOffset variables. \n347.     if playerMoveTo == UP: \n348.         xOffset = 0 \n349.         yOffset = -1 \n350.     elif playerMoveTo == RIGHT: \n351.         xOffset = 1 \n352.         yOffset = 0 \n353.     elif playerMoveTo == DOWN: \n\n\nChapter 9 – Star Pusher    251 \n \n354.         xOffset = 0 \n355.         yOffset = 1 \n356.     elif playerMoveTo == LEFT: \n357.         xOffset = -1 \n358.         yOffset = 0 \n359.  \n360.     # See if the player can move in that direction. \n361.     if isWall(mapObj, playerx + xOffset, playery + yOffset): \n362.         return False \n363.     else: \n364.         if (playerx + xOffset, playery + yOffset) in stars: \n365.             # There is a star in the way, see if the player can push it. \n366.             if not isBlocked(mapObj, gameStateObj, playerx + (xOffset*2), \nplayery + (yOffset*2)): \n367.                 # Move the star. \n368.                 ind = stars.index((playerx + xOffset, playery + yOffset)) \n369.                 stars[ind] = (stars[ind][0] + xOffset, stars[ind][1] + \nyOffset) \n370.             else: \n371.                 return False \n372.         # Move the player upwards. \n373.         gameStateObj['player'] = (playerx + xOffset, playery + yOffset) \n374.         return True \n375. \n376. \n377. def startScreen(): \n378.     \"\"\"Display the start screen (which has the title and instructions) \n379.     until the player presses a key. Returns None.\"\"\" \n380.  \n381.     # Position the title image. \n382.     titleRect = IMAGESDICT['title'].get_rect() \n383.     topCoord = 50 # topCoord tracks where to position the top of the text \n384.     titleRect.top = topCoord \n385.     titleRect.centerx = HALF_WINWIDTH \n386.     topCoord += titleRect.height \n387.  \n388.     # Unfortunately, Pygame's font & text system only shows one line at \n389.     # a time, so we can't use strings with \\n newline characters in them. \n390.     # So we will use a list with each line in it. \n391.     instructionText = ['Push the stars over the marks.', \n392.                        'Arrow keys to move, WASD for camera control, P to \nchange character.', \n393.                        'Backspace to reset level, Esc to quit.', \n394.                        'N for next level, B to go back a level.'] \n395.  \n396.     # Start with drawing a blank color to the entire window: \n\n\n252    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n397.     DISPLAYSURF.fill(BGCOLOR) \n398.  \n399.     # Draw the title image to the window: \n400.     DISPLAYSURF.blit(IMAGESDICT['title'], titleRect) \n401.  \n402.     # Position and draw the text. \n403.     for i in range(len(instructionText)): \n404.         instSurf = BASICFONT.render(instructionText[i], 1, TEXTCOLOR) \n405.         instRect = instSurf.get_rect() \n406.         topCoord += 10 # 10 pixels will go in between each line of text. \n407.         instRect.top = topCoord \n408.         instRect.centerx = HALF_WINWIDTH \n409.         topCoord += instRect.height # Adjust for the height of the line. \n410.         DISPLAYSURF.blit(instSurf, instRect) \n411.  \n412.     while True: # Main loop for the start screen. \n413.         for event in pygame.event.get(): \n414.             if event.type == QUIT: \n415.                 terminate() \n416.             elif event.type == KEYDOWN: \n417.                 if event.key == K_ESCAPE: \n418.                     terminate() \n419.                 return # user has pressed a key, so return. \n420.  \n421.         # Display the DISPLAYSURF contents to the actual screen. \n422.         pygame.display.update() \n423.         FPSCLOCK.tick() \n424. \n425. \n426. def readLevelsFile(filename): \n427.     assert os.path.exists(filename), 'Cannot find the level file: %s' % \n(filename) \n428.     mapFile = open(filename, 'r') \n429.     # Each level must end with a blank line \n430.     content = mapFile.readlines() + ['\\r\\n'] \n431.     mapFile.close() \n432. \n433.     levels = [] # Will contain a list of level objects. \n434.     levelNum = 0 \n435.     mapTextLines = [] # contains the lines for a single level's map. \n436.     mapObj = [] # the map object made from the data in mapTextLines \n437.     for lineNum in range(len(content)): \n438.         # Process each line that was in the level file. \n439.         line = content[lineNum].rstrip('\\r\\n') \n440.  \n441.         if ';' in line: \n\n\nChapter 9 – Star Pusher    253 \n \n442.             # Ignore the ; lines, they're comments in the level file. \n443.             line = line[:line.find(';')] \n444.  \n445.         if line != '': \n446.             # This line is part of the map. \n447.             mapTextLines.append(line) \n448.         elif line == '' and len(mapTextLines) > 0: \n449.             # A blank line indicates the end of a level's map in the file. \n450.             # Convert the text in mapTextLines into a level object. \n451.  \n452.             # Find the longest row in the map. \n453.             maxWidth = -1 \n454.             for i in range(len(mapTextLines)): \n455.                 if len(mapTextLines[i]) > maxWidth: \n456.                     maxWidth = len(mapTextLines[i]) \n457.             # Add spaces to the ends of the shorter rows. This \n458.             # ensures the map will be rectangular. \n459.             for i in range(len(mapTextLines)): \n460.                 mapTextLines[i] += ' ' * (maxWidth - len(mapTextLines[i])) \n461.  \n462.             # Convert mapTextLines to a map object. \n463.             for x in range(len(mapTextLines[0])): \n464.                 mapObj.append([]) \n465.             for y in range(len(mapTextLines)): \n466.                 for x in range(maxWidth): \n467.                     mapObj[x].append(mapTextLines[y][x]) \n468.  \n469.             # Loop through the spaces in the map and find the @, ., and $ \n470.             # characters for the starting game state. \n471.             startx = None # The x and y for the player's starting position \n472.             starty = None \n473.             goals = [] # list of (x, y) tuples for each goal. \n474.             stars = [] # list of (x, y) for each star's starting position. \n475.             for x in range(maxWidth): \n476.                 for y in range(len(mapObj[x])): \n477.                     if mapObj[x][y] in ('@', '+'): \n478.                         # '@' is player, '+' is player & goal \n479.                         startx = x \n480.                         starty = y \n481.                     if mapObj[x][y] in ('.', '+', '*'): \n482.                         # '.' is goal, '*' is star & goal \n483.                         goals.append((x, y)) \n484.                     if mapObj[x][y] in ('$', '*'): \n485.                         # '$' is star \n486.                         stars.append((x, y)) \n487.  \n\n\n254    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n488.             # Basic level design sanity checks: \n489.             assert startx != None and starty != None, 'Level %s (around \nline %s) in %s is missing a \"@\" or \"+\" to mark the start point.' % (levelNum+1, \nlineNum, filename) \n490.             assert len(goals) > 0, 'Level %s (around line %s) in %s must \nhave at least one goal.' % (levelNum+1, lineNum, filename) \n \n491.             assert len(stars) >= len(goals), 'Level %s (around line %s) in \n%s is impossible to solve. It has %s goals but only %s stars.' % (levelNum+1, \nlineNum, filename, len(goals), len(stars)) \n492.  \n493.             # Create level object and starting game state object. \n494.             gameStateObj = {'player': (startx, starty), \n495.                             'stepCounter': 0, \n496.                             'stars': stars} \n497.             levelObj = {'width': maxWidth, \n498.                         'height': len(mapObj), \n499.                         'mapObj': mapObj, \n500.                         'goals': goals, \n501.                         'startState': gameStateObj} \n502. \n503.             levels.append(levelObj) \n504.  \n505.             # Reset the variables for reading the next map. \n506.             mapTextLines = [] \n507.             mapObj = [] \n508.             gameStateObj = {} \n509.             levelNum += 1 \n510.     return levels \n511. \n512. \n513. def floodFill(mapObj, x, y, oldCharacter, newCharacter): \n514.     \"\"\"Changes any values matching oldCharacter on the map object to \n515.     newCharacter at the (x, y) position, and does the same for the \n516.     positions to the left, right, down, and up of (x, y), recursively.\"\"\" \n517.  \n518.     # In this game, the flood fill algorithm creates the inside/outside \n519.     # floor distinction. This is a \"recursive\" function. \n520.     # For more info on the Flood Fill algorithm, see: \n521.     #   http://en.wikipedia.org/wiki/Flood_fill \n522.     if mapObj[x][y] == oldCharacter: \n523.         mapObj[x][y] = newCharacter \n524.  \n525.     if x < len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter: \n526.         floodFill(mapObj, x+1, y, oldCharacter, newCharacter) # call right \n527.     if x > 0 and mapObj[x-1][y] == oldCharacter: \n\n\nChapter 9 – Star Pusher    255 \n \n528.         floodFill(mapObj, x-1, y, oldCharacter, newCharacter) # call left \n529.     if y < len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter: \n530.         floodFill(mapObj, x, y+1, oldCharacter, newCharacter) # call down \n531.     if y > 0 and mapObj[x][y-1] == oldCharacter: \n532.         floodFill(mapObj, x, y-1, oldCharacter, newCharacter) # call up \n533. \n534. \n535. def drawMap(mapObj, gameStateObj, goals): \n536.     \"\"\"Draws the map to a Surface object, including the player and \n537.     stars. This function does not call pygame.display.update(), nor \n538.     does it draw the \"Level\" and \"Steps\" text in the corner.\"\"\" \n539.  \n540.     # mapSurf will be the single Surface object that the tiles are drawn \n541.     # on, so that it is easy to position the entire map on the DISPLAYSURF \n542.     # Surface object. First, the width and height must be calculated. \n543.     mapSurfWidth = len(mapObj) * TILEWIDTH \n544.     mapSurfHeight = (len(mapObj[0]) - 1) * (TILEHEIGHT - TILEFLOORHEIGHT) \n+ TILEHEIGHT \n545.     mapSurf = pygame.Surface((mapSurfWidth, mapSurfHeight)) \n546.     mapSurf.fill(BGCOLOR) # start with a blank color on the surface. \n547.  \n548.     # Draw the tile sprites onto this surface. \n549.     for x in range(len(mapObj)): \n550.         for y in range(len(mapObj[x])): \n551.             spaceRect = pygame.Rect((x * TILEWIDTH, y * (TILEHEIGHT - \nTILEFLOORHEIGHT), TILEWIDTH, TILEHEIGHT)) \n552.             if mapObj[x][y] in TILEMAPPING: \n553.                 baseTile = TILEMAPPING[mapObj[x][y]] \n554.             elif mapObj[x][y] in OUTSIDEDECOMAPPING: \n555.                 baseTile = TILEMAPPING[' '] \n556.  \n557.             # First draw the base ground/wall tile. \n558.             mapSurf.blit(baseTile, spaceRect) \n559.  \n560.             if mapObj[x][y] in OUTSIDEDECOMAPPING: \n561.                 # Draw any tree/rock decorations that are on this tile. \n562.                 mapSurf.blit(OUTSIDEDECOMAPPING[mapObj[x][y]], spaceRect) \n563.             elif (x, y) in gameStateObj['stars']: \n564.                 if (x, y) in goals: \n565.                     # A goal AND star are on this space, draw goal first. \n566.                     mapSurf.blit(IMAGESDICT['covered goal'], spaceRect) \n567.                 # Then draw the star sprite. \n568.                 mapSurf.blit(IMAGESDICT['star'], spaceRect) \n569.             elif (x, y) in goals: \n570.                 # Draw a goal without a star on it. \n571.                 mapSurf.blit(IMAGESDICT['uncovered goal'], spaceRect) \n",
      "page_number": 266,
      "chapter_number": 30,
      "summary": "This chapter covers segment 30 (pages 266-273). Key topics include star, level, and returns.",
      "keywords": [
        "mapObj",
        "len",
        "mapObjCopy",
        "stars",
        "level",
        "map",
        "gameStateObj",
        "line",
        "CAM",
        "range",
        "player",
        "return True",
        "mapTextLines",
        "object",
        "Draw"
      ],
      "concepts": [
        "star",
        "level",
        "returns",
        "goals",
        "objects",
        "tile",
        "map",
        "draw",
        "filename",
        "line"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "Segment 11 (pages 100-107)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 30,
          "title": "Segment 30 (pages 279-290)",
          "relevance_score": 0.62,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 31,
          "title": "Segment 31 (pages 291-298)",
          "relevance_score": 0.62,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 41,
          "title": "Segment 41 (pages 389-403)",
          "relevance_score": 0.62,
          "method": "api"
        }
      ]
    },
    {
      "number": 31,
      "title": "Segment 31 (pages 274-281)",
      "start_page": 274,
      "end_page": 281,
      "detection_method": "topic_boundary",
      "content": "256    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n572.  \n573.             # Last draw the player on the board. \n574.             if (x, y) == gameStateObj['player']: \n575.                 # Note: The value \"currentImage\" refers \n576.                 # to a key in \"PLAYERIMAGES\" which has the \n577.                 # specific player image we want to show. \n578.                 mapSurf.blit(PLAYERIMAGES[currentImage], spaceRect) \n579.  \n580.     return mapSurf \n581. \n582. \n583. def isLevelFinished(levelObj, gameStateObj): \n584.     \"\"\"Returns True if all the goals have stars in them.\"\"\" \n585.     for goal in levelObj['goals']: \n586.         if goal not in gameStateObj['stars']: \n587.             # Found a space with a goal but no star on it. \n588.             return False \n589.     return True \n590. \n591. \n592. def terminate(): \n593.     pygame.quit() \n594.     sys.exit() \n595. \n596. \n597. if __name__ == '__main__': \n598.     main() \nThe Initial Setup \n  1. # Star Pusher (a Sokoban clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, sys, copy, os, pygame \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 # frames per second to update the screen \n 10. WINWIDTH = 800 # width of the program's window, in pixels \n 11. WINHEIGHT = 600 # height in pixels \n 12. HALF_WINWIDTH = int(WINWIDTH / 2) \n 13. HALF_WINHEIGHT = int(WINHEIGHT / 2) \n 14.  \n 15. # The total width and height of each tile in pixels. \n 16. TILEWIDTH = 50 \n\n\nChapter 9 – Star Pusher    257 \n \n 17. TILEHEIGHT = 85 \n 18. TILEFLOORHEIGHT = 45 \n 19.  \n 20. CAM_MOVE_SPEED = 5 # how many pixels per frame the camera moves \n 21.  \n 22. # The percentage of outdoor tiles that have additional \n 23. # decoration on them, such as a tree or rock. \n 24. OUTSIDE_DECORATION_PCT = 20 \n 25.  \n 26. BRIGHTBLUE = (  0, 170, 255) \n 27. WHITE      = (255, 255, 255) \n 28. BGCOLOR = BRIGHTBLUE \n 29. TEXTCOLOR = WHITE \n 30.  \n 31. UP = 'up' \n 32. DOWN = 'down' \n 33. LEFT = 'left' \n 34. RIGHT = 'right' \nThese constants are used in various parts of the program. The TILEWIDTH and TILEHEIGHT \nvariables show that each of the tile images are 50 pixels wide and 85 pixels tall. However, these \ntiles overlap with each other when drawn on the screen. (This is explained later.) The \nTILEFLOORHEIGHT refers to the fact that the part of the tile that represents the floor is 45 \npixels tall. Here is a diagram of the plain floor image: \n \nThe grassy tiles outside of the level’s room will sometimes have extra decorations added to them \n(such as trees or rocks). The OUTSIDE_DECORATION_PCT constant shows what percentage of \nthese tiles will randomly have these decorations. \n 37. def main(): \n 38.     global FPSCLOCK, DISPLAYSURF, IMAGESDICT, TILEMAPPING, \nOUTSIDEDECOMAPPING, BASICFONT, PLAYERIMAGES, currentImage \n 39.  \n 40.     # Pygame initialization and basic set up of the global variables. \n 41.     pygame.init() \n 42.     FPSCLOCK = pygame.time.Clock() \n 43.  \n 44.     # Because the Surface object stored in DISPLAYSURF was returned \n\n\n258    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 45.     # from the pygame.display.set_mode() function, this is the \n 46.     # Surface object that is drawn to the actual computer screen \n 47.     # when pygame.display.update() is called. \n 48.     DISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT)) \n 49.  \n 50.     pygame.display.set_caption('Star Pusher') \n 51.     BASICFONT = pygame.font.Font('freesansbold.ttf', 18) \nThis is the usual Pygame setup that happens at the beginning of the program. \n 53.     # A global dict value that will contain all the Pygame \n 54.     # Surface objects returned by pygame.image.load(). \n 55.     IMAGESDICT = {'uncovered goal': pygame.image.load('RedSelector.png'), \n 56.                   'covered goal': pygame.image.load('Selector.png'), \n 57.                   'star': pygame.image.load('Star.png'), \n 58.                   'corner': pygame.image.load('Wall Block Tall.png'), \n 59.                   'wall': pygame.image.load('Wood Block Tall.png'), \n 60.                   'inside floor': pygame.image.load('Plain Block.png'), \n 61.                   'outside floor': pygame.image.load('Grass Block.png'), \n 62.                   'title': pygame.image.load('star_title.png'), \n 63.                   'solved': pygame.image.load('star_solved.png'), \n 64.                   'princess': pygame.image.load('princess.png'), \n 65.                   'boy': pygame.image.load('boy.png'), \n 66.                   'catgirl': pygame.image.load('catgirl.png'), \n 67.                   'horngirl': pygame.image.load('horngirl.png'), \n 68.                   'pinkgirl': pygame.image.load('pinkgirl.png'), \n 69.                   'rock': pygame.image.load('Rock.png'), \n 70.                   'short tree': pygame.image.load('Tree_Short.png'), \n 71.                   'tall tree': pygame.image.load('Tree_Tall.png'), \n 72.                   'ugly tree': pygame.image.load('Tree_Ugly.png')} \nThe IMAGESDICT is a dictionary where all of the loaded images are stored. This makes it easier \nto use in other functions, since only the IMAGESDICT variable needs to be made global. If we \nstored each of these images in separate variables, then all 18 variables (for the 18 images used in \nthis game) would need to be made global. A dictionary containing all of the Surface objects with \nthe images is easier to handle. \n 74.     # These dict values are global, and map the character that appears \n 75.     # in the level file to the Surface object it represents. \n 76.     TILEMAPPING = {'x': IMAGESDICT['corner'], \n 77.                    '#': IMAGESDICT['wall'], \n 78.                    'o': IMAGESDICT['inside floor'], \n 79.                    ' ': IMAGESDICT['outside floor']} \n\n\nChapter 9 – Star Pusher    259 \n \nThe data structure for the map is just a 2D list of single character strings. The TILEMAPPING \ndictionary links the characters used in this map data structure to the images that they represent. \n(This will become more clear in the drawMap() function’s explanation.) \n 80.     OUTSIDEDECOMAPPING = {'1': IMAGESDICT['rock'], \n 81.                           '2': IMAGESDICT['short tree'], \n 82.                           '3': IMAGESDICT['tall tree'], \n 83.                           '4': IMAGESDICT['ugly tree']} \nThe OUTSIDEDECOMAPPING is also a dictionary that links the characters used in the map data \nstructure to images that were loaded. The ―outside decoration‖ images are drawn on top of the \noutdoor grassy tile. \n 85.     # PLAYERIMAGES is a list of all possible characters the player can be. \n 86.     # currentImage is the index of the player's current player image. \n 87.     currentImage = 0 \n 88.     PLAYERIMAGES = [IMAGESDICT['princess'], \n 89.                     IMAGESDICT['boy'], \n 90.                     IMAGESDICT['catgirl'], \n 91.                     IMAGESDICT['horngirl'], \n 92.                     IMAGESDICT['pinkgirl']] \nThe PLAYERIMAGES list stores the images used for the player. The currentImage variable \ntracks the index of the currently selected player image. For example, when currentImage is \nset to 0 then PLAYERIMAGES[0], which is the ―princess‖ player image, is drawn to the screen. \n 94.     startScreen() # show the title screen until the user presses a key \n 95.  \n 96.     # Read in the levels from the text file. See the readLevelsFile() for \n 97.     # details on the format of this file and how to make your own levels. \n 98.     levels = readLevelsFile('starPusherLevels.txt') \n 99.     currentLevelIndex = 0 \nThe startScreen() function will keep displaying the initial start screen (which also has the \ninstructions for the game) until the player presses a key. When the player presses a key, the \nstartScreen() function returns and then reads in the levels from the level file. The player \nstarts off on the first level, which is the level object in the levels list at index 0. \n101.     # The main game loop. This loop runs a single level, when the user \n102.     # finishes that level, the next/previous level is loaded. \n103.     while True: # main game loop \n104.         # Run the level to actually start playing the game: \n\n\n260    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n105.         result = runLevel(levels, currentLevelIndex) \nThe runLevel() function handles all the action for the game. It is passed a list of level objects, \nand the integer index of the level in that list to be played. When the player has finished playing \nthe level, runLevel() will return one of the following strings: 'solved' (because the player \nhas finished putting all the stars on the goals), 'next' (because the player wants to skip to the \nnext level), 'back' (because the player wants to go back to the previous level), and 'reset' \n(because the player wants to start playing the current level over again, maybe because they \npushed a star into a corner). \n107.         if result in ('solved', 'next'): \n108.             # Go to the next level. \n109.             currentLevelIndex += 1 \n110.             if currentLevelIndex >= len(levels): \n111.                 # If there are no more levels, go back to the first one. \n112.                 currentLevelIndex = 0 \n113.         elif result == 'back': \n114.             # Go to the previous level. \n115.             currentLevelIndex -= 1 \n116.             if currentLevelIndex < 0: \n117.                 # If there are no previous levels, go to the last one. \n118.                 currentLevelIndex = len(levels)-1 \nIf runLevel() has returned the strings 'solved' or 'next', then we need to increment \nlevelNum by 1. If this increments levelNum beyond the number of levels there are, then \nlevelNum is set back at 0. \nThe opposite is done if 'back' is returned, then levelNum is decremented by 1. If this makes \nit go below 0, then it is set to the last level (which is len(levels)-1). \n119.         elif result == 'reset': \n120.             pass # Do nothing. Loop re-calls runLevel() to reset the level \nIf the return value was 'reset', then the code does nothing. The pass statement does nothing \n(like a comment), but is needed because the Python interpreter expects an indented line of code \nafter an elif statement. \nWe could remove lines 119 and 120 from the source code entirely, and the program will still \nwork just the same. The reason we include it here is for program readability, so that if we make \nchanges to the code later, we won’t forget that runLevel() can also return the string \n'reset'. \n\n\nChapter 9 – Star Pusher    261 \n \n123. def runLevel(levels, levelNum): \n124.     global currentImage \n125.     levelObj = levels[levelnum] \n126.     mapObj = decorateMap(levelObj['mapObj'], \nlevelObj['startState']['player']) \n127.     gameStateObj = copy.deepcopy(levelObj['startState']) \nThe levels list contains all the level objects that were loaded from the level file. The level object \nfor the current level (which is what levelNum is set to) is stored in the levelObj variable. A \nmap object (which makes a distinction between indoor and outdoor tiles, and decorates the \noutdoor tiles with trees and rocks) is returned from the decorateMap() function. And to track \nthe state of the game while the player plays this level, a copy of the game state object that is \nstored in levelObj is made using the copy.deepcopy() function. \nThe game state object copy is made because the game state object stored in \nlevelObj['startState'] represents the game state at the very beginning of the level, and \nwe do not want to modify this. Otherwise, if the player restarts the level, the original game state \nfor that level will be lost. \nThe copy.deepcopy() function is used because the game state object is a dictionary of that \nhas tuples. But technically, the dictionary contains references to tuples. (References are explained \nin detail at http://invpy.com/references.) Using an assignment statement to make a copy of the \ndictionary will make a copy of the references but not the values they refer to, so that both the \ncopy and the original dictionary still refer to the same tuples. \nThe copy.deepcopy() function solves this problem by making copies of the actual tuples in \nthe dictionary. This way we can guarantee that changing one dictionary will not affect the other \ndictionary. \n128.     mapNeedsRedraw = True # set to True to call drawMap() \n129.     levelSurf = BASICFONT.render('Level %s of %s' % (levelObj['levelNum'] \n+ 1, totalNumOfLevels), 1, TEXTCOLOR) \n130.     levelRect = levelSurf.get_rect() \n131.     levelRect.bottomleft = (20, WINHEIGHT - 35) \n132.     mapWidth = len(mapObj) * TILEWIDTH \n133.     mapHeight = (len(mapObj[0]) - 1) * (TILEHEIGHT - TILEFLOORHEIGHT) + \nTILEHEIGHT \n134.     MAX_CAM_X_PAN = abs(HALF_WINHEIGHT - int(mapHeight / 2)) + TILEWIDTH \n135.     MAX_CAM_Y_PAN = abs(HALF_WINWIDTH - int(mapWidth / 2)) + TILEHEIGHT \n136.  \n137.     levelIsComplete = False \n138.     # Track how much the camera has moved: \n139.     cameraOffsetX = 0 \n\n\n262    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n140.     cameraOffsetY = 0 \n141.     # Track if the keys to move the camera are being held down: \n142.     cameraUp = False \n143.     cameraDown = False \n144.     cameraLeft = False \n145.     cameraRight = False \nMore variables are set at the start of playing a level. The mapWidth and mapHeight variables \nare the size of the maps in pixels. The expression for calculating mapHeight is a bit \ncomplicated since the tiles overlap each other. Only the bottom row of tiles is the full height \n(which accounts for the + TILEHEIGHT part of the expression), all of the other rows of tiles \n(which number as (len(mapObj[0]) - 1)) are slightly overlapped. This means that they \nare effectively each only (TILEHEIGHT - TILEFLOORHEIGHT) pixels tall. \nThe camera in Star Pusher can be moved independently of the player moving around the map. \nThis is why the camera needs its own set of ―moving‖ variables: cameraUp, cameraDown, \ncameraLeft, and cameraRight. The cameraOffsetX and cameraOffsetY variables \ntrack the position of the camera. \n147.     while True: # main game loop \n148.         # Reset these variables: \n149.         playerMoveTo = None \n150.         keyPressed = False \n151.  \n152.         for event in pygame.event.get(): # event handling loop \n153.             if event.type == QUIT: \n154.                 # Player clicked the \"X\" at the corner of the window. \n155.                 terminate() \n156.  \nThe playerMoveTo variable will be set to the direction constant that the player intends to \nmove the player character on the map. The keyPressed variable tracks if any key has been \npressed during this iteration of the game loop. This variable is checked later when the player has \nsolved the level. \n157.             elif event.type == KEYDOWN: \n158.                 # Handle key presses \n159.                 keyPressed = True \n160.                 if event.key == K_LEFT: \n161.                     playerMoveTo = LEFT \n162.                 elif event.key == K_RIGHT: \n163.                     playerMoveTo = RIGHT \n164.                 elif event.key == K_UP: \n\n\nChapter 9 – Star Pusher    263 \n \n165.                     playerMoveTo = UP \n166.                 elif event.key == K_DOWN: \n167.                     playerMoveTo = DOWN \n168.  \n169.                 # Set the camera move mode. \n170.                 elif event.key == K_a: \n171.                     cameraLeft = True \n172.                 elif event.key == K_d: \n173.                     cameraRight = True \n174.                 elif event.key == K_w: \n175.                     cameraUp = True \n176.                 elif event.key == K_s: \n177.                     cameraDown = True \n178.  \n179.                 elif event.key == K_n: \n180.                     return 'next' \n181.                 elif event.key == K_b: \n182.                     return 'back' \n183.  \n184.                 elif event.key == K_ESCAPE: \n185.                     terminate() # Esc key quits. \n186.                 elif event.key == K_BACKSPACE: \n187.                     return 'reset' # Reset the level. \n188.                 elif event.key == K_p: \n189.                     # Change the player image to the next one. \n190.                     currentImage += 1 \n191.                     if currentImage >= len(PLAYERIMAGES): \n192.                         # After the last player image, use the first one. \n193.                         currentImage = 0 \n194.                     mapNeedsRedraw = True \n195.  \n196.             elif event.type == KEYUP: \n197.                 # Unset the camera move mode. \n198.                 if event.key == K_a: \n199.                     cameraLeft = False \n200.                 elif event.key == K_d: \n201.                     cameraRight = False \n202.                 elif event.key == K_w: \n203.                     cameraUp = False \n204.                 elif event.key == K_s: \n205.                     cameraDown = False \nThis code handles what to do when the various keys are pressed. \n207.         if playerMoveTo != None and not levelIsComplete: \n208.             # If the player pushed a key to move, make the move \n",
      "page_number": 274,
      "chapter_number": 31,
      "summary": "This chapter covers segment 31 (pages 274-281). Key topics include player, loaded.",
      "keywords": [
        "level",
        "player",
        "IMAGESDICT",
        "elif event.key",
        "Star Pusher",
        "player image",
        "event.key",
        "star",
        "game",
        "tree",
        "PLAYERIMAGES",
        "object",
        "Pusher",
        "images",
        "currentImage"
      ],
      "concepts": [
        "player",
        "loaded",
        "key",
        "keys",
        "level",
        "variables",
        "variable",
        "returns",
        "function",
        "functions"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.62,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 21,
          "title": "Segment 21 (pages 651-684)",
          "relevance_score": 0.58,
          "method": "api"
        }
      ]
    },
    {
      "number": 32,
      "title": "Segment 32 (pages 282-290)",
      "start_page": 282,
      "end_page": 290,
      "detection_method": "topic_boundary",
      "content": "264    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n209.             # (if possible) and push any stars that are pushable. \n210.             moved = makeMove(mapObj, gameStateObj, playerMoveTo) \n211.  \n212.             if moved: \n213.                 # increment the step counter. \n214.                 gameStateObj['stepCounter'] += 1 \n215.                 mapNeedsRedraw = True \n216.  \n217.             if isLevelFinished(levelObj, gameStateObj): \n218.                 # level is solved, we should show the \"Solved!\" image. \n219.                 levelIsComplete = True \n220.                 keyPressed = False \nIf the playerMoveTo variable is no longer set to None, then we know the player intended to \nmove. The call to makeMove() handles changing the XY coordinates of the player’s position in \nthe gameStateObj, as well as pushing any stars. The return value of makeMove() is stored \nin moved. If this value is True, then the player character was moved in that direction. If the \nvalue was False, then the player must have tried to move into a tile that was a wall, or push a \nstar that had something behind it. In this case, the player can’t move and nothing on the map \nchanges. \n222.         DISPLAYSURF.fill(BGCOLOR) \n223.  \n224.         if mapNeedsRedraw: \n225.             mapSurf = drawMap(mapObj, gameStateObj, levelObj['goals']) \n226.             mapNeedsRedraw = False \nThe map does not need to be redrawn on each iteration through the game loop. In fact, this game \nprogram is complicated enough that doing so would cause a slight (but noticeable) slowdown in \nthe game. And the map really only needs to be redrawn when something has changed (such as the \nplayer moving or a star being pushed). So the Surface object in the mapSurf variable is only \nupdated with a call to the drawMap() function when the mapNeedsRedraw variable is set to \nTrue. \nAfter the map has been drawn on line 225, the mapNeedsRedraw variable is set to False. If \nyou want to see how the program slows down by drawing on each iteration through the game \nloop, comment out line 226 and rerun the program. You will notice that moving the camera is \nsignificantly slower. \n228.         if cameraUp and cameraOffsetY < MAX_CAM_X_PAN: \n229.             cameraOffsetY += CAM_MOVE_SPEED \n230.         elif cameraDown and cameraOffsetY > -MAX_CAM_X_PAN: \n\n\nChapter 9 – Star Pusher    265 \n \n231.             cameraOffsetY -= CAM_MOVE_SPEED \n232.         if cameraLeft and cameraOffsetX < MAX_CAM_Y_PAN: \n233.             cameraOffsetX += CAM_MOVE_SPEED \n234.         elif cameraRight and cameraOffsetX > -MAX_CAM_Y_PAN: \n235.             cameraOffsetX -= CAM_MOVE_SPEED \nIf the camera movement variables are set to True and the camera has not gone past (i.e. panned \npassed) the boundaries set by the MAX_CAM_X_PAN and MAX_CAM_Y_PAN, then the camera \nlocation (stored in cameraOffsetX and cameraOffsetY) should move over by \nCAM_MOVE_SPEED pixels. \nNote that there is an if and elif statement on lines 228 and 230 for moving the camera up and \ndown, and then a separate if and elif statement on lines 232 and 234. This way, the user can \nmove the camera both vertically and horizontally at the same time. This wouldn’t be possible if \nline 232 were an elif statement. \n237.         # Adjust mapSurf's Rect object based on the camera offset. \n238.         mapSurfRect = mapSurf.get_rect() \n239.         mapSurfRect.center = (HALF_WINWIDTH + cameraOffsetX, \nHALF_WINHEIGHT + cameraOffsetY) \n240.  \n241.         # Draw mapSurf to the DISPLAYSURF Surface object. \n242.         DISPLAYSURF.blit(mapSurf, mapSurfRect) \n243.  \n244.         DISPLAYSURF.blit(levelSurf, levelRect) \n245.         stepSurf = BASICFONT.render('Steps: %s' % \n(gameStateObj['stepCounter']), 1, TEXTCOLOR) \n246.         stepRect = stepSurf.get_rect() \n247.         stepRect.bottomleft = (20, WINHEIGHT - 10) \n248.         DISPLAYSURF.blit(stepSurf, stepRect) \n249.  \n250.         if levelIsComplete: \n251.             # is solved, show the \"Solved!\" image until the player \n252.             # has pressed a key. \n253.             solvedRect = IMAGESDICT['solved'].get_rect() \n254.             solvedRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT) \n255.             DISPLAYSURF.blit(IMAGESDICT['solved'], solvedRect) \n256.  \n257.             if keyPressed: \n258.                 return 'solved' \n259.  \n260.         pygame.display.update() # draw DISPLAYSURF to the screen. \n261.         FPSCLOCK.tick() \n262. \n\n\n266    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n263. \nLines 237 to 261 position the camera and draw the map and other graphics to the display Surface \nobject in DISPLAYSURF. If the level is solved, then the victory graphic is also drawn on top of \neverything else. The keyPressed variable will be set to True if the user pressed a key during \nthis iteration, at which point the runLevel() function returns. \n264. def isWall(mapObj, x, y): \n265.     \"\"\"Returns True if the (x, y) position on \n266.     the map is a wall, otherwise return False.\"\"\" \n267.     if x < 0 or x >= len(mapObj) or y < 0 or y >= len(mapObj[x]): \n268.         return False # x and y aren't actually on the map. \n269.     elif mapObj[x][y] in ('#', 'x'): \n270.         return True # wall is blocking \n271.     return False \nThe isWall() function returns True if there is a wall on the map object at the XY coordinates \npassed to the function. Wall objects are represented as either a 'x' or '#' string in the map \nobject. \n274. def decorateMap(mapObj, startxy): \n275.     \"\"\"Makes a copy of the given map object and modifies it. \n276.     Here is what is done to it: \n277.         * Walls that are corners are turned into corner pieces. \n278.         * The outside/inside floor tile distinction is made. \n279.         * Tree/rock decorations are randomly added to the outside tiles. \n280.  \n281.     Returns the decorated map object.\"\"\" \n282.  \n283.     startx, starty = startxy # Syntactic sugar \n284.  \n285.     # Copy the map object so we don't modify the original passed \n286.     mapObjCopy = copy.deepcopy(mapObj) \nThe decorateMap() function alters the data structure mapObj so that it isn’t as plain as it \nappears in the map file. The three things that decorateMap() changes are explained in the \ncomment at the top of the function. \n288.     # Remove the non-wall characters from the map data \n289.     for x in range(len(mapObjCopy)): \n290.         for y in range(len(mapObjCopy[0])): \n291.             if mapObjCopy[x][y] in ('$', '.', '@', '+', '*'): \n\n\nChapter 9 – Star Pusher    267 \n \n292.                 mapObjCopy[x][y] = ' ' \nThe map object has characters that represent the position of the player, goals, and stars. These are \nnecessary for the map object (they’re stored in other data structures after the map file is read) so \nthey are converted to blank spaces. \n294.     # Flood fill to determine inside/outside floor tiles. \n295.     floodFill(mapObjCopy, startx, starty, ' ', 'o') \nThe floodFill() function will change all of the tiles inside the walls from ' ' characters to \n'o' characters. It does this using a programming concept called recursion, which is explained in \n―Recursive Functions‖ section later in this chapter. \n297.     # Convert the adjoined walls into corner tiles. \n298.     for x in range(len(mapObjCopy)): \n299.         for y in range(len(mapObjCopy[0])): \n300. \n301.             if mapObjCopy[x][y] == '#': \n302.                 if (isWall(mapObjCopy, x, y-1) and isWall(mapObjCopy, x+1, \ny)) or \\ \n303.                    (isWall(mapObjCopy, x+1, y) and isWall(mapObjCopy, x, \ny+1)) or \\ \n304.                    (isWall(mapObjCopy, x, y+1) and isWall(mapObjCopy, x-1, \ny)) or \\ \n305.                    (isWall(mapObjCopy, x-1, y) and isWall(mapObjCopy, x, \ny-1)): \n306.                     mapObjCopy[x][y] = 'x' \n307. \n308.             elif mapObjCopy[x][y] == ' ' and random.randint(0, 99) < \nOUTSIDE_DECORATION_PCT: \n309.                 mapObjCopy[x][y] = \nrandom.choice(list(OUTSIDEDECOMAPPING.keys())) \n310.  \n311.     return mapObjCopy  \nThe large, multi-line if statement on line 301 checks if the wall tile at the current XY \ncoordinates are a corner wall tile by checking if there are wall tiles adjacent to it that form a \ncorner shape. If so, the '#' string in the map object that represents a normal wall is changed to a \n'x' string which represents a corner wall tile. \n314. def isBlocked(mapObj, gameStateObj, x, y): \n315.     \"\"\"Returns True if the (x, y) position on the map is \n316.     blocked by a wall or star, otherwise return False.\"\"\" \n\n\n268    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n317. \n318.     if isWall(mapObj, x, y): \n319.         return True \n320. \n321.     elif x < 0 or x >= len(mapObj) or y < 0 or y >= len(mapObj[x]): \n322.         return True # x and y aren't actually on the map. \n323. \n324.     elif (x, y) in gameStateObj['stars']: \n325.         return True # a star is blocking \n326.  \n327.     return False \nThere are three cases where a space on the map would be blocked: if there is a star, a wall, or the \ncoordinates of the space are past the edges of the map. The isBlocked() function checks for \nthese three cases and returns True if the XY coordinates are blocked and False if not. \n330. def makeMove(mapObj, gameStateObj, playerMoveTo): \n331.     \"\"\"Given a map and game state object, see if it is possible for the \n332.     player to make the given move. If it is, then change the player's \n333.     position (and the position of any pushed star). If not, do nothing. \n334.  \n335.     Returns True if the player moved, otherwise False.\"\"\" \n336.  \n337.     # Make sure the player can move in the direction they want. \n338.     playerx, playery = gameStateObj['player'] \n339.  \n340.     # This variable is \"syntactic sugar\". Typing \"stars\" is more \n341.     # readable than typing \"gameStateObj['stars']\" in our code. \n342.     stars = gameStateObj['stars'] \n343.  \n344.     # The code for handling each of the directions is so similar aside \n345.     # from adding or subtracting 1 to the x/y coordinates. We can \n346.     # simplify it by using the xOffset and yOffset variables. \n347.     if playerMoveTo == UP: \n348.         xOffset = 0 \n349.         yOffset = -1 \n350.     elif playerMoveTo == RIGHT: \n351.         xOffset = 1 \n352.         yOffset = 0 \n353.     elif playerMoveTo == DOWN: \n354.         xOffset = 0 \n355.         yOffset = 1 \n356.     elif playerMoveTo == LEFT: \n357.         xOffset = -1 \n358.         yOffset = 0 \n\n\nChapter 9 – Star Pusher    269 \n \n359.  \n360.     # See if the player can move in that direction. \n361.     if isWall(mapObj, playerx + xOffset, playery + yOffset): \n362.         return False \n363.     else: \n364.         if (playerx + xOffset, playery + yOffset) in stars: \n365.             # There is a star in the way, see if the player can push it. \n366.             if not isBlocked(mapObj, gameStateObj, playerx + (xOffset*2), \nplayery + (yOffset*2)): \n367.                 # Move the star. \n368.                 ind = stars.index((playerx + xOffset, playery + yOffset)) \n369.                 stars[ind] = (stars[ind][0] + xOffset, stars[ind][1] + \nyOffset) \n370.             else: \n371.                 return False \n372.         # Move the player upwards. \n373.         gameStateObj['player'] = (playerx + xOffset, playery + yOffset) \n374.         return True \nThe makeMove() function checks to make sure if moving the player in a particular direction is \na valid move. As long as there isn’t a wall blocking the path, or a star that has a wall or star \nbehind it, the player will be able to move in that direction. The gameStateObj variable will be \nupdated to reflect this, and the True value will be returned to tell the function’s caller that the \nplayer was moved. \nIf there was a star in the space that the player wanted to move, that star’s position is also changed \nand this information is updated in the gameStateObj variable as well. This is how the ―star \npushing‖ is implemented. \nIf the player is blocked from moving in the desired direction, then the gameStateObj is not \nmodified and the function returns False. \n377. def startScreen(): \n378.     \"\"\"Display the start screen (which has the title and instructions) \n379.     until the player presses a key. Returns None.\"\"\" \n380.  \n381.     # Position the title image. \n382.     titleRect = IMAGESDICT['title'].get_rect() \n383.     topCoord = 50 # topCoord tracks where to position the top of the text \n384.     titleRect.top = topCoord \n385.     titleRect.centerx = HALF_WINWIDTH \n386.     topCoord += titleRect.height \n387.  \n388.     # Unfortunately, Pygame's font & text system only shows one line at \n\n\n270    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n389.     # a time, so we can't use strings with \\n newline characters in them. \n390.     # So we will use a list with each line in it. \n391.     instructionText = ['Push the stars over the marks.', \n392.                        'Arrow keys to move, WASD for camera control, P to \nchange character.', \n393.                        'Backspace to reset level, Esc to quit.', \n394.                        'N for next level, B to go back a level.'] \nThe startScreen() function needs to display a few different pieces of text down the center \nof the window. We will store each line as a string in the instructionText list. The title \nimage (stored in IMAGESDICT['title'] as a Surface object (that was originally loaded from \nthe star_title.png file)) will be positioned 50 pixels from the top of the window. This is because \nthe integer 50 was stored in the topCoord variable on line 383. The topCoord variable will \ntrack the Y axis positioning of the title image and the instructional text. The X axis is always \ngoing to be set so that the images and text are centered, as it is on line 385 for the title image. \nOn line 386, the topCoord variable is increased by whatever the height of that image is. This \nway we can modify the image and the start screen code won’t have to be changed. \n396.     # Start with drawing a blank color to the entire window: \n397.     DISPLAYSURF.fill(BGCOLOR) \n398.  \n399.     # Draw the title image to the window: \n400.     DISPLAYSURF.blit(IMAGESDICT['title'], titleRect) \n401.  \n402.     # Position and draw the text. \n403.     for i in range(len(instructionText)): \n404.         instSurf = BASICFONT.render(instructionText[i], 1, TEXTCOLOR) \n405.         instRect = instSurf.get_rect() \n406.         topCoord += 10 # 10 pixels will go in between each line of text. \n407.         instRect.top = topCoord \n408.         instRect.centerx = HALF_WINWIDTH \n409.         topCoord += instRect.height # Adjust for the height of the line. \n410.         DISPLAYSURF.blit(instSurf, instRect) \nLine 400 is where the title image is blitted to the display Surface object. The for loop starting on \nline 403 will render, position, and blit each instructional string in the instructionText loop. \nThe topCoord variable will always be incremented by the size of the previously rendered text \n(line 409) and 10 additional pixels (on line 406, so that there will be a 10 pixel gap between the \nlines of text). \n412.     while True: # Main loop for the start screen. \n413.         for event in pygame.event.get(): \n\n\nChapter 9 – Star Pusher    271 \n \n414.             if event.type == QUIT: \n415.                 terminate() \n416.             elif event.type == KEYDOWN: \n417.                 if event.key == K_ESCAPE: \n418.                     terminate() \n419.                 return # user has pressed a key, so return. \n420.  \n421.         # Display the DISPLAYSURF contents to the actual screen. \n422.         pygame.display.update() \n423.         FPSCLOCK.tick() \nThere is a game loop in startScreen() that begins on line 412 and handles events that \nindicate if the program should terminate or return from the startScreen() function. Until the \nplayer does either, the loop will keep calling pygame.display.update() and \nFPSCLOCK.tick() to keep the start screen displayed on the screen. \nData Structures in Star Pusher \nStar Pusher has a specific format for the levels, maps, and game state data structures. \nThe “Game State” Data Structure \nThe game state object will be a dictionary with three keys: 'player', 'stepCounter', and \n'stars'. \n \nThe value at the 'player' key will be a tuple of two integers for the current XY \nposition of the player. \n \nThe value at the 'stepCounter' key will be an integer that tracks how many moves \nthe player has made in this level (so the player can try to solve the puzzle in the future \nwith fewer steps). \n \nThe value at the 'stars' key is a list of two-integer tuples of XY values for each of the \nstars on the current level. \nThe “Map” Data Structure \nThe map data structure is simply a 2D list of lists where the two indexes used represent the X and \nY coordinates of the map. The value at each index in the list of lists is a single-character string \nthat represents the title that is on that map at each space: \n \n'#' – A wooden wall. \n \n'x' – A corner wall. \n \n'@' – The starting space for the player on this level. \n \n'.' – A goal space. \n \n'$' – A space where a star is at the start of the level. \n\n\n272    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n'+' – A space with a goal and the starting player’s space. \n \n'*' – A space with a goal and a star at the start of the level. \n \n' ' – A grassy outdoor space. \n \n'o' – An inside floor space. (This is a lowercase letter O, not a zero.) \n \n'1' – A rock on grass. \n \n'2' – A short tree on grass. \n \n'3' – A tall tree on grass. \n \n'4' – An ugly tree on grass. \nThe “Levels” Data Structure \nThe level object contains a game state object (which will be the state used when the level first \nstarts), a map object, and a few other values. The level object itself is a dictionary with the \nfollowing keys: \n \nThe value at the key 'width' is an integer of how many tiles wide the entire map is. \n \nThe value at the key 'height' is an integer of how many tiles tall the entire map is. \n \nThe value at the key 'mapObj' is the map object for this level. \n \nThe value at the key 'goals' is a list of two-integer tuples with the XY coordinates of \neach goal space on the map. \n \nThe value at the key 'startState' is a game state object used to show the starting \nposition of the stars and player at the start of the level. \nReading and Writing Text Files \nPython has functions for reading files off of the player’s hard drive. This will be useful for having \na separate file keep all of the data for each level. This is also a good idea because in order to get \nnew levels, the player doesn’t have to change the source code of the game but instead can just \ndownload new level files. \nText Files and Binary Files \nText files are files that contain simple text data. Text files are created in Windows by the Notepad \napplication, Gedit on Ubuntu, and TextEdit on Mac OS X. There are many other programs called \ntext editors that can create and modify text files. IDLE’s own file editor is a text editor. \nThe difference between text editors and word processors (like Microsoft Word, or OpenOffice \nWriter, or iWork Pages) is that text editors have text only. You can’t set the font, size, or color of \nthe text. (IDLE automatically sets the color of the text based on what kind of Python code it is, \nbut you can’t change this yourself, so it is still a text editor.) The difference between text and \nbinary files isn’t important for this game program, but you can read about it at \n",
      "page_number": 282,
      "chapter_number": 32,
      "summary": "This chapter covers segment 32 (pages 282-290). Key topics include function, functions, and text.",
      "keywords": [
        "map",
        "player",
        "star",
        "Returns True",
        "map object",
        "return False",
        "text",
        "Star Pusher",
        "move",
        "object",
        "mapObjCopy",
        "CAM",
        "line",
        "level",
        "wall"
      ],
      "concepts": [
        "function",
        "functions",
        "text",
        "returns",
        "key",
        "keys",
        "tile",
        "file",
        "level",
        "wall"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 41,
          "title": "Segment 41 (pages 389-403)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "Segment 33 (pages 314-325)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 30,
          "title": "Segment 30 (pages 279-290)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.63,
          "method": "api"
        }
      ]
    },
    {
      "number": 33,
      "title": "Segment 33 (pages 291-299)",
      "start_page": 291,
      "end_page": 299,
      "detection_method": "topic_boundary",
      "content": "Chapter 9 – Star Pusher    273 \n \nhttp://invpy.com/textbinary. All you need to know is the this chapter and the Star Pusher program \nonly deal with text files. \nWriting to Files \nTo create a file, call the open() function pass it two arguments: a string for the name of the file, \nand the string 'w' to tell the open() function you want to open the file in ―write‖ mode. The \nopen() function returns a file object: \n>>> textFile = open('hello.txt', 'w') \n>>> \nIf you run this code from the interactive shell, the hello.txt file that this function creates will be \ncreated in the same folder that the python.exe program is in (on Windows, this will probably be \nC:\\Python32). If the open() function is called from a .py program, the file is created in the same \nfolder that the .py file is in. \nThe ―write‖ mode tells open() to create the file if it does not exist. If it does exist, then \nopen() will delete that file and create a new, blank file. This is just like how an assignment \nstatement can create a new variable, or overwrite the current value in an already existing variable. \nThis can be somewhat dangerous. If you accidentally send a filename of an important file to the \nopen() function with 'w' as the second parameter, it will be deleted. This could result in \nhaving to reinstall the operating system on your computer and/or the launching of nuclear \nmissiles. \nThe file object has a method called write() which can be used to write text to the file. Just pass \nit a string like you would pass a string to the print() function. The difference is that write() \ndoes not automatically add a newline character ('\\n') to the end of the string. If you want to add \na newline, you will have to include it in the string: \n>>> textFile = open('hello.txt', 'w') \n>>> textFile.write('This will be the content of the file.\\nHello world!\\n') \n>>> \nTo tell Python that you are done writing content to this file, you should call the close() \nmethod of the file object. (Although Python will automatically close any opened file objects when \nthe program ends.) \n>>> textFile.close() \n\n\n274    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nReading from Files \nTo read the content of a file, pass the string 'r' instead of 'w' to the open() function. Then \ncall the readlines() method on the file object to read in the contents of the file. Last, close \nthe file by calling the close() method. \n>>> textFile = open('hello.txt', 'r') \n>>> content = textFile.readlines() \n>>> textFile.close() \nThe readlines() method returns a list of strings: one string for each line of text in the file: \n>>> content \n['This will be the content of the file.\\n', 'Hello world!\\n'] \n>>> \nIf you want to re-read the contents of that file, you will have to call close() on the file object \nand re-open it. \nAs an alternative to readlines(), you can also call the read() method, which will return \nthe entire contents of the file as a single string value: \n>>> textFile = open('hello.txt', 'r') \n>>> content = textFile.read() \n>>> content \n'This will be the content of the file.\\nHello world!\\n' \nOn a side note, if you leave out the second parameter to the open() function, Python will \nassume you mean to open the file in read mode. So open('foobar.txt', 'r') and \nopen('foobar.txt') do the exact same thing. \nAbout the Star Pusher Map File Format \nWe need the level text file to be in a specific format. Which characters represent walls, or stars, or \nthe player’s starting position? If we have the maps for multiple levels, how can we tell when one \nlevel’s map ends and the next one begins? \nFortunately, the map file format we will use is already defined for us. There are many Sokoban \ngames out there (you can find more at http://invpy.com/sokobanclones), and they all use the same \nmap file format. If you download the levels file from http://invpy.com/starPusherLevels.txt and \nopen it in a text editor, you’ll see something like this: \n; Star Pusher (Sokoban clone) \n\n\nChapter 9 – Star Pusher    275 \n \n; http://inventwithpython.com/blog \n; By Al Sweigart al@inventwithpython.com \n; \n; Everything after the ; is a comment and will be ignored by the game that \n; reads in this file. \n; \n; The format is described at: \n; http://sokobano.de/wiki/index.php?title=Level_format \n;   @ - The starting position of the player. \n;   $ - The starting position for a pushable star. \n;   . - A goal where a star needs to be pushed. \n;   + - Player & goal \n;   * - Star & goal \n;  (space) - an empty open space. \n;   # - A wall. \n; \n; Level maps are separated by a blank line (I like to use a ; at the start \n; of the line since it is more visible.) \n; \n; I tried to use the same format as other people use for their Sokoban games, \n; so that loading new levels is easy. Just place the levels in a text file \n; and name it \"starPusherLevels.txt\" (after renaming this file, of course). \n \n \n; Starting demo level: \n ######## \n##      # \n#   .   # \n#   $   # \n# .$@$. # \n####$   # \n   #.   # \n   #   ## \n   ##### \nThe comments at the top of the file explain the file’s format. When you load the first level, it \nlooks like this: \n\n\n276    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n426. def readLevelsFile(filename): \n427.     assert os.path.exists(filename), 'Cannot find the level file: %s' % \n(filename) \nThe os.path.exists() function will return True if the file specified by the string passed to \nthe function exists. If it does not exist, os.path.exists() returns False. \n428.     mapFile = open(filename, 'r') \n429.     # Each level must end with a blank line \n430.     content = mapFile.readlines() + ['\\r\\n'] \n431.     mapFile.close() \n432. \n433.     levels = [] # Will contain a list of level objects. \n434.     levelNum = 0 \n435.     mapTextLines = [] # contains the lines for a single level's map. \n436.     mapObj = [] # the map object made from the data in mapTextLines \nThe file object for the level file that is opened for reading is stored in mapFile. All of the text \nfrom the level file is stored as a list of strings in the content variable, with a blank line added \nto the end. (The reason that this is done is explained later.) \nAfter the level objects are created, they will be stored in the levels list. The levelNum \nvariable will keep track of how many levels are found inside the level file. The mapTextLines \nlist will be a list of strings from the content list for a single map (as opposed to how content \nstores the strings of all maps in the level file). The mapObj variable will be a 2D list. \n437.     for lineNum in range(len(content)): \n438.         # Process each line that was in the level file. \n439.         line = content[lineNum].rstrip('\\r\\n') \n\n\nChapter 9 – Star Pusher    277 \n \nThe for loop on line 437 will go through each line that was read from the level file one line at a \ntime. The line number will be stored in lineNum and the string of text for the line will be stored \nin line. Any newline characters at the end of the string will be stripped off. \n441.         if ';' in line: \n442.             # Ignore the ; lines, they're comments in the level file. \n443.             line = line[:line.find(';')] \nAny text that exists after a semicolon in the map file is treated like a comment and is ignored. \nThis is just like the # sign for Python comments. To make sure that our code does not \naccidentally think the comment is part of the map, the line variable is modified so that it only \nconsists of the text up to (but not including) the semicolon character. (Remember that this is only \nchanging the string in the content list. It is not changing the level file on the hard drive.) \n445.         if line != '': \n446.             # This line is part of the map. \n447.             mapTextLines.append(line) \nThere can be maps for multiple levels in the map file. The mapTextLines list will contain the \nlines of text from the map file for the current level being loaded. As long as the current line is not \nblank, the line will be appended to the end of mapTextLines. \n448.         elif line == '' and len(mapTextLines) > 0: \n449.             # A blank line indicates the end of a level's map in the file. \n450.             # Convert the text in mapTextLines into a level object. \nWhen there is a blank line in the map file, that indicates that the map for the current level has \nended. And future lines of text will be for the later levels. Note however, that there must at least \nbe one line in mapTextLines so that multiple blank lines together are not counted as the start \nand stop to multiple levels. \n452.             # Find the longest row in the map. \n453.             maxWidth = -1 \n454.             for i in range(len(mapTextLines)): \n455.                 if len(mapTextLines[i]) > maxWidth: \n456.                     maxWidth = len(mapTextLines[i]) \nAll of the strings in mapTextLines need to be the same length (so that they form a rectangle), \nso they should be padded with extra blank spaces until they are all as long as the longest string. \nThe for loop goes through each of the strings in mapTextLines and updates maxWidth \n\n\n278    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nwhen it finds a new longest string. After this loop finishes executing, the maxWidth variable \nwill be set to the length of the longest string in mapTextLines. \n457.             # Add spaces to the ends of the shorter rows. This \n458.             # ensures the map will be rectangular. \n459.             for i in range(len(mapTextLines)): \n460.                 mapTextLines[i] += ' ' * (maxWidth - len(mapTextLines[i])) \nThe for loop on line 459 goes through the strings in mapTextLines again, this time to add \nenough space characters to pad each to be as long as maxWidth. \n462.             # Convert mapTextLines to a map object. \n463.             for x in range(len(mapTextLines[0])): \n464.                 mapObj.append([]) \n465.             for y in range(len(mapTextLines)): \n466.                 for x in range(maxWidth): \n467.                     mapObj[x].append(mapTextLines[y][x]) \nThe mapTextLines variable just stores a list of strings. (Each string in the list represents a \nrow, and each character in the string represents a character at a different column. This is why line \n467 has the Y and X indexes reversed, just like the SHAPES data structure in the Tetromino \ngame.) But the map object will have to be a list of list of single-character strings such that \nmapObj[x][y] refers to the tile at the XY coordinates. The for loop on line 463 adds an \nempty list to mapObj for each column in mapTextLines. \nThe nested for loops on line 465 and 466 will fill these lists with single-character strings to \nrepresent each tile on the map. This creates the map object that Star Pusher uses. \n469.             # Loop through the spaces in the map and find the @, ., and $ \n470.             # characters for the starting game state. \n471.             startx = None # The x and y for the player's starting position \n472.             starty = None \n473.             goals = [] # list of (x, y) tuples for each goal. \n474.             stars = [] # list of (x, y) for each star's starting position. \n475.             for x in range(maxWidth): \n476.                 for y in range(len(mapObj[x])): \n477.                     if mapObj[x][y] in ('@', '+'): \n478.                         # '@' is player, '+' is player & goal \n479.                         startx = x \n480.                         starty = y \n481.                     if mapObj[x][y] in ('.', '+', '*'): \n482.                         # '.' is goal, '*' is star & goal \n483.                         goals.append((x, y)) \n\n\nChapter 9 – Star Pusher    279 \n \n484.                     if mapObj[x][y] in ('$', '*'): \n485.                         # '$' is star \n486.                         stars.append((x, y)) \nAfter creating the map object, the nested for loops on lines 475 and 476 will go through each \nspace to find the XY coordinates three things: \n1. The player’s starting position. This will be stored in the startx and starty variables, \nwhich will then be stored in the game state object later on line 494. \n2. The starting position of all the stars These will be stored in the stars list, which is later \nstored in the game state object on line 496. \n3. The position of all the goals. These will be stored in the goals list, which is later stored \nin the level object on line 500. \nRemember, the game state object contains all the things that can change. This is why the player’s \nposition is stored in it (because the player can move around) and why the stars are stored in it \n(because the stars can be pushed around by the player). But the goals are stored in the level \nobject, since they will never move around. \n488.             # Basic level design sanity checks: \n489.             assert startx != None and starty != None, 'Level %s (around \nline %s) in %s is missing a \"@\" or \"+\" to mark the start point.' % (levelNum+1, \nlineNum, filename) \n490.             assert len(goals) > 0, 'Level %s (around line %s) in %s must \nhave at least one goal.' % (levelNum+1, lineNum, filename) \n491.             assert len(stars) >= len(goals), 'Level %s (around line %s) in \n%s is impossible to solve. It has %s goals but only %s stars.' % (levelNum+1, \nlineNum, filename, len(goals), len(stars)) \nAt this point, the level has been read in and processed. To be sure that this level will work \nproperly, a few assertions must pass. If any of the conditions for these assertions are False, then \nPython will produce an error (using the string from the assert statement) saying what is wrong \nwith the level file. \nThe first assertion on line 489 checks to make sure that there is a player starting point listed \nsomewhere on the map. The second assertion on line 490 checks to make sure there is at least one \ngoal (or more) somewhere on the map. And the third assertion on line 491 checks to make sure \nthat there is at least one star for each goal (but having more stars than goals is allowed). \n493.             # Create level object and starting game state object. \n494.             gameStateObj = {'player': (startx, starty), \n495.                             'stepCounter': 0, \n\n\n280    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n496.                             'stars': stars} \n497.             levelObj = {'width': maxWidth, \n498.                         'height': len(mapObj), \n499.                         'mapObj': mapObj, \n500.                         'goals': goals, \n501.                         'startState': gameStateObj} \n502. \n503.             levels.append(levelObj) \nFinally, these objects are stored in the game state object, which itself is stored in the level object. \nThe level object is added to a list of level objects on line 503. It is this levels list that will be \nreturned by the readLevelsFile() function when all of the maps have been processed. \n505.             # Reset the variables for reading the next map. \n506.             mapTextLines = [] \n507.             mapObj = [] \n508.             gameStateObj = {} \n509.             levelNum += 1 \n510.     return levels \nNow that this level is done processing, the variables for mapTextLines, mapObj, and \ngameStateObj should be reset to blank values for the next level that will be read in from the \nlevel file. The levelNum variable is also incremented by 1 for the next level’s level number. \nRecursive Functions \nBefore you can learn how the floodFill() function works, you need to learn about recursion. \nRecursion is a simple concept: A recursive function is just a function that calls itself, like the \none in the following program: (don’t type the letters at the beginning of each line though) \nA. def passFortyTwoWhenYouCallThisFunction(param): \nB.     print('Start of function.') \nC.     if param != 42: \nD.         print('You did not pass 42 when you called this function.') \nE.         print('Fine. I will do it myself.') \nF.         passFortyTwoWhenYouCallThisFunction(42) # this is the recursive call \nG.     if param == 42: \nH.         print('Thank you for passing 42 when you called this function.') \nI.     print('End of function.') \nJ.  \nK. passFortyTwoWhenYouCallThisFunction(41) \n(In your own programs, don’t make functions have names as long as \npassFortyTwoWhenYouCallThisFunction(). I’m just being stupid and silly. Stupilly.) \n\n\nChapter 9 – Star Pusher    281 \n \nWhen you run this program, the function gets defined when the def statement on line A \nexecutes. The next line of code that is executed is line K, which calls \npassFortyTwoWhenYouCallThisFunction() and passes (gasp!) 41. As a result, the \nfunction calls itself on line F and passes 42. We call this call the recursive call. \nThis is what our program outputs: \nStart of function. \nYou did not pass 42 when you called this function. \nFine. I will do it myself. \nStart of function. \nThank you for passing 42 when you called this function. \nEnd of function. \nEnd of function. \nNotice that the ―Start of function.‖ and ―End of function.‖ text appears twice. Let’s figure out \nwhat exactly happens and what order it happens in. \nOn line K, the function is called and 41 is passed for the param parameter. Line B prints out \n―Start of function.‖. The condition on line C will be True (since 41 != 42) so Line C and D \nwill print out their messages. Line F will then make a call, recursively, to the function and passes \n42 for the param parameter. So execution starts on line B again and prints out ―Start of \nfunction.‖. Line C’s condition this time is False, so it skips to line G and finds that condition to \nbe True. This causes line H to be called and displays ―Thank you…‖ on the screen. Then the last \nline of the function, line I, will execute to print out ―End of function.‖ and the function returns to \nthe line that called it. \nBut remember, the line of code that called the function was line F. And in this original call, param \nwas set to 41. The code goes down to line G and checks the condition, which is False (since 41 \n== 42 is False) so it skips the print() call on line H. Instead, it runs the print() call on \nline I which makes ―End of function.‖ display for a second time. \nSince it has reached the end of the function, it returns to the line of code that called this function \ncall, which was line K. There are no more lines of code after line K, so the program terminates.  \nNote that local variables are not just local to the function, but to a specific call of the function. \nStack Overflows \nEach time a function is called, the Python interpreter remembers which line of code made the call. \nThat way when the function returns Python knows where to resume the execution. Remembering \nthis takes up a tiny bit of memory. This isn’t normally a big deal, but take a look at this code: \n",
      "page_number": 291,
      "chapter_number": 33,
      "summary": "All you need to know is the this chapter and the Star Pusher program \nonly deal with text files Key topics include line, functions, and level. Covers function.",
      "keywords": [
        "line",
        "file",
        "level file",
        "level",
        "function",
        "Map File",
        "Map",
        "Star Pusher",
        "file object",
        "mapTextLines",
        "level object",
        "object",
        "Map File Format",
        "string",
        "open"
      ],
      "concepts": [
        "line",
        "functions",
        "level",
        "files",
        "content",
        "string",
        "strings",
        "star",
        "starting",
        "python"
      ],
      "similar_chapters": [
        {
          "book": "Python Distilled",
          "chapter": 32,
          "title": "Segment 32 (pages 289-298)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 13,
          "title": "Segment 13 (pages 115-123)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 13,
          "title": "Segment 13 (pages 109-116)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "Designing Machine Learning Systems An Iterative Process for Production-Ready Applications",
          "chapter": 10,
          "title": "Segment 10 (pages 80-87)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 32,
          "title": "Segment 32 (pages 336-344)",
          "relevance_score": 0.52,
          "method": "api"
        }
      ]
    },
    {
      "number": 34,
      "title": "Segment 34 (pages 300-307)",
      "start_page": 300,
      "end_page": 307,
      "detection_method": "topic_boundary",
      "content": "282    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \ndef funky(): \n    funky() \n \nfunky() \nIf you run this program, you’ll get a large amount of output which looks like this: \n... \n  File \"C:\\test67.py\", line 2, in funky \n    funky() \n  File \"C:\\test67.py\", line 2, in funky \n    funky() \n  File \"C:\\test67.py\", line 2, in funky \n    funky() \n  File \"C:\\test67.py\", line 2, in funky \n    funky() \n  File \"C:\\test67.py\", line 2, in funky \n    funky() \nRuntimeError: maximum recursion depth exceeded \nThe funky() function does nothing but call itself. And then in that call, the function calls itself \nagain. Then it calls itself again, and again, and again. Each time it calls itself, Python has to \nremember what line of code made that call so that when the function returns it can resume the \nexecution there. But the funky() function never returns, it just keeps making calls to itself. \nThis is just like the infinite loop bug, where the program keeps going and never stops. To prevent \nitself from running out of memory, Python will cause an error after you are a 1000 calls deep and \ncrash the program. This type of bug is called a stack overflow. \nThis code also causes a stack overflow, even though there are no recursive functions: \ndef spam(): \n    eggs() \n \ndef eggs(): \n    spam() \n \nspam() \nWhen you run this program, it causes an error that looks like this: \n... \n  File \"C:\\test67.py\", line 2, in spam \n    eggs() \n\n\nChapter 9 – Star Pusher    283 \n \n  File \"C:\\test67.py\", line 5, in eggs \n    spam() \n  File \"C:\\test67.py\", line 2, in spam \n    eggs() \n  File \"C:\\test67.py\", line 5, in eggs \n    spam() \n  File \"C:\\test67.py\", line 2, in spam \n    eggs() \nRuntimeError: maximum recursion depth exceeded \nPreventing Stack Overflows with a Base Case \nIn order to prevent stack overflow bugs, you must have a base case where the function stops \nmake new recursive calls. If there is no base case then the function calls will never stop and \neventually a stack overflow will occur. Here is an example of a recursive function with a base \ncase. The base case is when the param parameter equals 2. \ndef fizz(param): \n    print(param) \n    if param == 2: \n        return \n    fizz(param - 1) \n \nfizz(5) \nWhen you run this program, the output will look like this: \n5 \n4 \n3 \n2 \nThis program does not have a stack overflow error because once the param parameter is set to 2, \nthe if statement’s condition will be True and the function will return, and then the rest of the \ncalls will also return in turn. \nThough if your code never reaches the base case, then this will cause a stack overflow. If we \nchanged the fizz(5) call to fizz(0), then the program’s output would look like this: \n  File \"C:\\rectest.py\", line 5, in fizz \n    fizz(param - 1) \n  File \"C:\\rectest.py\", line 5, in fizz \n    fizz(param - 1) \n  File \"C:\\rectest.py\", line 5, in fizz \n\n\n284    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n    fizz(param - 1) \n  File \"C:\\rectest.py\", line 2, in fizz \n    print(param) \nRuntimeError: maximum recursion depth exceeded \nRecursive calls and base cases will be used to perform the flood fill algorithm, which is described \nnext. \nThe Flood Fill Algorithm \nThe flood fill algorithm is used in Star Pusher to change all of the floor tiles inside the walls of \nthe level to use the ―inside floor‖ tile image instead of the ―outside floor‖ tile (which all the tiles \non the map are by default). The original floodFill() call is on line 295. It will convert any \ntiles represented with the ' ' string (which represents an outdoor floor) to a 'o' string (which \nrepresents an indoor floor). \n513. def floodFill(mapObj, x, y, oldCharacter, newCharacter): \n514.     \"\"\"Changes any values matching oldCharacter on the map object to \n515.     newCharacter at the (x, y) position, and does the same for the \n516.     positions to the left, right, down, and up of (x, y), recursively.\"\"\" \n517.  \n518.     # In this game, the flood fill algorithm creates the inside/outside \n519.     # floor distinction. This is a \"recursive\" function. \n520.     # For more info on the Flood Fill algorithm, see: \n521.     #   http://en.wikipedia.org/wiki/Flood_fill \n522.     if mapObj[x][y] == oldCharacter: \n523.         mapObj[x][y] = newCharacter \nLine 522 and 523 converts the tile at the XY coordinate passed to floodFill() to the \nnewCharacter string if it originally was the same as the oldCharacter string. \n525.     if x < len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter: \n526.         floodFill(mapObj, x+1, y, oldCharacter, newCharacter) # call right \n527.     if x > 0 and mapObj[x-1][y] == oldCharacter: \n528.         floodFill(mapObj, x-1, y, oldCharacter, newCharacter) # call left \n529.     if y < len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter: \n530.         floodFill(mapObj, x, y+1, oldCharacter, newCharacter) # call down \n531.     if y > 0 and mapObj[x][y-1] == oldCharacter: \n532.         floodFill(mapObj, x, y-1, oldCharacter, newCharacter) # call up \nThese four if statements check if the tile to the right, left, down, and up of the XY coordinate are \nthe same as oldCharacter, and if so, a recursive call is made to floodFill() with those \ncoordinates. \n\n\nChapter 9 – Star Pusher    285 \n \nTo better understand how the floodFill() function works, here is a version that does not use \nrecursive calls, but instead uses a list of XY coordinates to keep track of which spaces on the map \nshould be checked and possibly changed to newCharacter. \ndef floodFill(mapObj, x, y, oldCharacter, newCharacter): \n    spacesToCheck = [] \n    if mapObj[x][y] == oldCharacter: \n        spacesToCheck.append((x, y)) \n    while spacesToCheck != []: \n        x, y = spacesToCheck.pop() \n        mapObj[x][y] = newCharacter \n \n        if x < len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter: \n            spacesToCheck.append((x+1, y)) # check right \n        if x > 0 and mapObj[x-1][y] == oldCharacter: \n            spacesToCheck.append((x-1, y)) # check left \n        if y < len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter: \n            spacesToCheck.append((x, y+1)) # check down \n        if y > 0 and mapObj[x][y-1] == oldCharacter: \n            spacesToCheck.append((x, y-1)) # check up \nIf you would like to read a more detailed tutorial on recursion that uses cats and zombies for an \nexample, go to http://invpy.com/recursivezombies. \nDrawing the Map \n535. def drawMap(mapObj, gameStateObj, goals): \n536.     \"\"\"Draws the map to a Surface object, including the player and \n537.     stars. This function does not call pygame.display.update(), nor \n538.     does it draw the \"Level\" and \"Steps\" text in the corner.\"\"\" \n539.  \n540.     # mapSurf will be the single Surface object that the tiles are drawn \n541.     # on, so that it is easy to position the entire map on the DISPLAYSURF \n542.     # Surface object. First, the width and height must be calculated. \n543.     mapSurfWidth = len(mapObj) * TILEWIDTH \n544.     mapSurfHeight = (len(mapObj[0]) - 1) * (TILEHEIGHT - TILEFLOORHEIGHT) \n+ TILEHEIGHT \n545.     mapSurf = pygame.Surface((mapSurfWidth, mapSurfHeight)) \n546.     mapSurf.fill(BGCOLOR) # start with a blank color on the surface. \nThe drawMap() function will return a Surface object with the entire map (and the player and \nstars) drawn on it. The width and height needed for this Surface have to be calculated from \nmapObj (which is done on line 543 and 544). The Surface object that everything will be drawn \n\n\n286    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \non is created on line 545. To begin with, the entire Surface object is painted to the background \ncolor on line 546. \n548.     # Draw the tile sprites onto this surface. \n549.     for x in range(len(mapObj)): \n550.         for y in range(len(mapObj[x])): \n551.             spaceRect = pygame.Rect((x * TILEWIDTH, y * (TILEHEIGHT - \nTILEFLOORHEIGHT), TILEWIDTH, TILEHEIGHT)) \nThe set of nested for loops on line 549 and 550 will go through every possible XY coordinate \non the map and draw the appropriate tile image at that location. \n552.             if mapObj[x][y] in TILEMAPPING: \n553.                 baseTile = TILEMAPPING[mapObj[x][y]] \n554.             elif mapObj[x][y] in OUTSIDEDECOMAPPING: \n555.                 baseTile = TILEMAPPING[' '] \n556.  \n557.             # First draw the base ground/wall tile. \n558.             mapSurf.blit(baseTile, spaceRect) \n559.  \nThe baseTile variable is set to the Surface object of the tile image to be drawn at the \niteration’s current XY coordinate. If the single-character string is in the \nOUTSIDEDECOMAPPING dictionary, then TILEMAPPING[' '] (the single-character string \nfor the basic outdoor floor tile) will be used. \n560.             if mapObj[x][y] in OUTSIDEDECOMAPPING: \n561.                 # Draw any tree/rock decorations that are on this tile. \n562.                 mapSurf.blit(OUTSIDEDECOMAPPING[mapObj[x][y]], spaceRect) \nAdditionally, if the tile was listed in the OUTSIDEDECOMAPPING dictionary, the corresponding \ntree or rock image should be drawn on top of the tile that was just drawn at that XY coordinate. \n563.             elif (x, y) in gameStateObj['stars']: \n564.                 if (x, y) in goals: \n565.                     # A goal AND star are on this space, draw goal first. \n566.                     mapSurf.blit(IMAGESDICT['covered goal'], spaceRect) \n567.                 # Then draw the star sprite. \n568.                 mapSurf.blit(IMAGESDICT['star'], spaceRect) \nIf there is a star located at this XY coordinate on the map (which can be found out by checking \nfor (x, y) in the list at gameStateObj['stars']), then a star should be drawn at this XY \n\n\nChapter 9 – Star Pusher    287 \n \ncoordinate (which is done on line 568). Before the star is drawn, the code should first check if \nthere is also a goal at this location, in which case, the ―covered goal‖ tile should be drawn first. \n569.             elif (x, y) in goals: \n570.                 # Draw a goal without a star on it. \n571.                 mapSurf.blit(IMAGESDICT['uncovered goal'], spaceRect) \nIf there is a goal at this XY coordinate on the map, then the ―uncovered goal‖ should be drawn on \ntop of the tile. The uncovered goal is drawn because if execution has reached the elif statement \non line 569, we know that the elif statement’s condition on line 563 was False and there is no \nstar that is also at this XY coordinate. \n573.             # Last draw the player on the board. \n574.             if (x, y) == gameStateObj['player']: \n575.                 # Note: The value \"currentImage\" refers \n576.                 # to a key in \"PLAYERIMAGES\" which has the \n577.                 # specific player image we want to show. \n578.                 mapSurf.blit(PLAYERIMAGES[currentImage], spaceRect) \n579.  \n580.     return mapSurf \nFinally, the drawMap() function checks if the player is located at this XY coordinate, and if so, \nthe player’s image is drawn over the tile. Line 580 is outside of the nested for loops that began \non line 549 and 550, so by the time the Surface object is returned, the entire map has been drawn \non it. \nChecking if the Level is Finished \n583. def isLevelFinished(levelObj, gameStateObj): \n584.     \"\"\"Returns True if all the goals have stars in them.\"\"\" \n585.     for goal in levelObj['goals']: \n586.         if goal not in gameStateObj['stars']: \n587.             # Found a space with a goal but no star on it. \n588.             return False \n589.     return True \nThe isLevelFinished() function returns True if all the goals are covered stars. Some \nlevels could have more stars than goals, so it’s important to check that all the goals are covered \nby stars, rather than checking if all the stars are over goals. \nThe for loop on line 585 goes through the goals in levelObj['goals'] (which is a list of \ntuples of XY coordinates for each goal) and checks if there is a star in the \ngameStateObj['stars'] list that has those same XY coordinates (the not in operators \n\n\n288    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nwork here because gameStateObj['stars'] is a list of those same tuples of XY \ncoordinates). The first time the code finds a goal with no star at the same position, the function \nreturns False. \nIf it gets through all of the goals and finds a star on each of them, isLevelFinished() \nreturns True. \n592. def terminate(): \n593.     pygame.quit() \n594.     sys.exit() \nThis terminate() function is the same as in all the previous programs. \n597. if __name__ == '__main__': \n598.     main() \nAfter all the functions have been defined, the main() function is called on line 602 to begin the \ngame. \nSummary \nIn the Squirrel Eat Squirrel game, the game world was pretty simple: just an infinite green plain \nwith grass images randomly scattered around it. The Star Pusher game introduced something \nnew: having uniquely designed levels with tile graphics. In order to store these levels in a format \nthat the computer can read, they are typed out into a text file and code in the program reads those \nfiles and creates the data structures for the level. \nReally, rather than just make a simple game with a single map, the Star Pusher program is more \nof a system for loading custom maps based on the level file. Just by modifying the level file, we \ncan change where walls, stars, and goals appear in the game world. The Star Pusher program can \nhandle any configuration that the level file is set to (as long as it passes the assert statements \nthat ensure the map makes sense). \nYou won’t even have to know how to program Python to make your own levels. A text editor \nprogram that modifies the starPusherLevels.txt file is all that anyone needs to have their own \nlevel editor for the Star Pusher game. \nFor additional programming practice, you can download buggy versions of Star Pusher from \nhttp://invpy.com/buggy/starpusher and try to figure out how to fix the bugs. \n \n\n\nChapter 10 – Four Extra Games    289 \n \nCHAPTER 10 – FOUR EXTRA \nGAMES \nIncluded in this chapter is the source code for four extra games. Unfortunately, only the source \ncode (including comments) is in this chapter without any detailed explanation of the code. By \nnow, you can play these games and figure out how the code works by looking at the source code \nand comments. \nThe games are: \n \nFlippy – An ―Othello‖ clone where the player tries to flip the computer AI player’s tiles. \n \nInk Spill – A ―Flood It‖ clone that makes use of the flood fill algorithm. \n \nFour in a Row – A ―Connect Four‖ clone against the computer AI player. \n \nGemgem – A ―Bejeweled‖ clone where the player swaps gems to try to get three \nidentical gems in a row. \nIf you have any questions about the source code in this book, feel free to email the author at \nal@inventwithpython.com. \nBuggy versions of these programs are also available if you want to practice fixing bugs: \n \nhttp://invpy.com/buggy/flippy \n \nhttp://invpy.com/buggy/inkspill \n \nhttp://invpy.com/buggy/fourinarow \n \nhttp://invpy.com/buggy/gemgem \n \n \n",
      "page_number": 300,
      "chapter_number": 34,
      "summary": "It will convert any \ntiles represented with the ' ' string (which represents an outdoor floor) to a 'o' string (which \nrepresents an indoor floor) Key topics include game, star, and player. Covers function.",
      "keywords": [
        "mapObj",
        "Star Pusher",
        "funky",
        "Star",
        "line",
        "File",
        "function",
        "Star Pusher game",
        "Surface object",
        "Star Pusher program",
        "oldCharacter",
        "Surface",
        "goal",
        "flood fill algorithm",
        "tile"
      ],
      "concepts": [
        "game",
        "star",
        "player",
        "function",
        "functions",
        "program",
        "programming",
        "buggy",
        "file",
        "images"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 25,
          "title": "Segment 25 (pages 234-242)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 9,
          "title": "Segment 9 (pages 93-101)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 35,
          "title": "Segment 35 (pages 316-323)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 62,
          "title": "Segment 62 (pages 601-608)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 48,
          "title": "Segment 48 (pages 461-471)",
          "relevance_score": 0.5,
          "method": "api"
        }
      ]
    },
    {
      "number": 35,
      "title": "Segment 35 (pages 308-315)",
      "start_page": 308,
      "end_page": 315,
      "detection_method": "topic_boundary",
      "content": "290    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nFlippy, an “Othello” Clone \n     \n \nOthello, also known by the generic name Reversi, has an 8 x 8 board with tiles that are black on \none side and white on the other. The starting board looks like Figure 10-1. Each player takes turn \nplacing down a new tile of their color. Any of the opponent's tiles that are between the new tile \nand the other tiles of that color is flipped. The goal of the game is to have as many of the tiles \nwith your color as possible. For example, Figure 10-2 is what it looks like if the white player \nplaces a new white tile on space 5, 6. \n \n \nThe starting Reversi board has two white tiles \nand two black tiles. \nWhite places a new tile. \n \n\n\nChapter 10 – Four Extra Games    291 \n \nThe black tile at 5, 5 is in between the new white tile and the existing white tile at 5, 4. That black \ntile is flipped over and becomes a new white tile, making the board look like Figure 10-3. Black \nmakes a similar move next, placing a black tile on 4, 6 which flips the white tile at 4, 5. This \nresults in a board that looks like Figure 10-4. \n \n \nWhite's move will flip over one of black's tiles. \nBlack places a new tile, which flips over one of \nwhite's tiles. \n \nTiles in all directions are flipped as long as they are in between the player's new tile and existing \ntile. In Figure 10-5, the white player places a tile at 3, 6 and flips black tiles in both directions \n(marked by the lines). The result is in Figure 10-6. \n\n\n292    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n \nWhite's second move at 3, 6 will flip two of \nblack's tiles. \nThe board after white's second move. \n \nAs you can see, each player can quickly grab a majority of the tiles on the board in just one or \ntwo moves. Players must always make a move that captures at least one tile. The game ends when \na player either cannot make a move, or the board is completely full. The player with the most tiles \nof their color wins. \nYou can learn more about Reversi from Wikipedia: http://en.wikipedia.org/wiki/Reversi \nA text version of this game that uses print() and input() instead of Pygame is featured in \nChapter 15 of ―Invent Your Own Computer Games with Python‖. You can read that chapter for \ndetails about how the computer AI’s algorithm was put together. \nhttp://inventwithpython.com/chapter15.html \nThe computer AI for this game is pretty good, because it is easy for a computer to simulate every \npossible move and take the one that flips over the most tiles. It usually beats me whenever I play \nit. \nSource Code for Flippy \nThis source code can be downloaded from http://invpy.com/flippy.py. \nThe image files that Flippy uses can be downloaded from http://invpy.com/flippyimages.zip. \n  1. # Flippy (an Othello or Reversi clone) \n\n\nChapter 10 – Four Extra Games    293 \n \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Released under a \"Simplified BSD\" license \n  5.  \n  6. # Based on the \"reversi.py\" code that originally appeared in \"Invent \n  7. # Your Own Computer Games with Python\", chapter 15: \n  8. #   http://inventwithpython.com/chapter15.html \n  9.  \n 10. import random, sys, pygame, time, copy \n 11. from pygame.locals import * \n 12.  \n 13. FPS = 10 # frames per second to update the screen \n 14. WINDOWWIDTH = 640 # width of the program's window, in pixels \n 15. WINDOWHEIGHT = 480 # height in pixels \n 16. SPACESIZE = 50 # width & height of each space on the board, in pixels \n 17. BOARDWIDTH = 8 # how many columns of spaces on the game board \n 18. BOARDHEIGHT = 8 # how many rows of spaces on the game board \n 19. WHITE_TILE = 'WHITE_TILE' # an arbitrary but unique value \n 20. BLACK_TILE = 'BLACK_TILE' # an arbitrary but unique value \n 21. EMPTY_SPACE = 'EMPTY_SPACE' # an arbitrary but unique value \n 22. HINT_TILE = 'HINT_TILE' # an arbitrary but unique value \n 23. ANIMATIONSPEED = 25 # integer from 1 to 100, higher is faster animation \n 24.  \n 25. # Amount of space on the left & right side (XMARGIN) or above and below \n 26. # (YMARGIN) the game board, in pixels. \n 27. XMARGIN = int((WINDOWWIDTH - (BOARDWIDTH * SPACESIZE)) / 2) \n 28. YMARGIN = int((WINDOWHEIGHT - (BOARDHEIGHT * SPACESIZE)) / 2) \n 29.  \n 30. #              R    G    B \n 31. WHITE      = (255, 255, 255) \n 32. BLACK      = (  0,   0,   0) \n 33. GREEN      = (  0, 155,   0) \n 34. BRIGHTBLUE = (  0,  50, 255) \n 35. BROWN      = (174,  94,   0) \n 36.  \n 37. TEXTBGCOLOR1 = BRIGHTBLUE \n 38. TEXTBGCOLOR2 = GREEN \n 39. GRIDLINECOLOR = BLACK \n 40. TEXTCOLOR = WHITE \n 41. HINTCOLOR = BROWN \n 42.  \n 43.  \n 44. def main(): \n 45.     global MAINCLOCK, DISPLAYSURF, FONT, BIGFONT, BGIMAGE \n 46.  \n 47.     pygame.init() \n\n\n294    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 48.     MAINCLOCK = pygame.time.Clock() \n 49.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 50.     pygame.display.set_caption('Flippy') \n 51.     FONT = pygame.font.Font('freesansbold.ttf', 16) \n 52.     BIGFONT = pygame.font.Font('freesansbold.ttf', 32) \n 53.  \n 54.     # Set up the background image. \n 55.     boardImage = pygame.image.load('flippyboard.png') \n 56.     # Use smoothscale() to stretch the board image to fit the entire \nboard: \n 57.     boardImage = pygame.transform.smoothscale(boardImage, (BOARDWIDTH * \nSPACESIZE, BOARDHEIGHT * SPACESIZE)) \n 58.     boardImageRect = boardImage.get_rect() \n 59.     boardImageRect.topleft = (XMARGIN, YMARGIN) \n 60.     BGIMAGE = pygame.image.load('flippybackground.png') \n 61.     # Use smoothscale() to stretch the background image to fit the entire \nwindow: \n 62.     BGIMAGE = pygame.transform.smoothscale(BGIMAGE, (WINDOWWIDTH, \nWINDOWHEIGHT)) \n 63.     BGIMAGE.blit(boardImage, boardImageRect) \n 64.  \n 65.     # Run the main game. \n 66.     while True: \n 67.         if runGame() == False: \n 68.             break \n 69.  \n 70.  \n 71. def runGame(): \n 72.     # Plays a single game of reversi each time this function is called. \n 73.  \n 74.     # Reset the board and game. \n 75.     mainBoard = getNewBoard() \n 76.     resetBoard(mainBoard) \n 77.     showHints = False \n 78.     turn = random.choice(['computer', 'player']) \n 79.  \n 80.     # Draw the starting board and ask the player what color they want. \n 81.     drawBoard(mainBoard) \n 82.     playerTile, computerTile = enterPlayerTile() \n 83.  \n 84.     # Make the Surface and Rect objects for the \"New Game\" and \"Hints\" \nbuttons \n 85.     newGameSurf = FONT.render('New Game', True, TEXTCOLOR, TEXTBGCOLOR2) \n 86.     newGameRect = newGameSurf.get_rect() \n 87.     newGameRect.topright = (WINDOWWIDTH - 8, 10) \n 88.     hintsSurf = FONT.render('Hints', True, TEXTCOLOR, TEXTBGCOLOR2) \n\n\nChapter 10 – Four Extra Games    295 \n \n 89.     hintsRect = hintsSurf.get_rect() \n 90.     hintsRect.topright = (WINDOWWIDTH - 8, 40) \n 91.  \n 92.     while True: # main game loop \n 93.         # Keep looping for player and computer's turns. \n 94.         if turn == 'player': \n 95.             # Player's turn: \n 96.             if getValidMoves(mainBoard, playerTile) == []: \n 97.                 # If it's the player's turn but they \n 98.                 # can't move, then end the game. \n 99.                 break \n100.             movexy = None \n101.             while movexy == None: \n102.                 # Keep looping until the player clicks on a valid space. \n103.  \n104.                 # Determine which board data structure to use for display. \n105.                 if showHints: \n106.                     boardToDraw = getBoardWithValidMoves(mainBoard, \nplayerTile) \n107.                 else: \n108.                     boardToDraw = mainBoard \n109.  \n110.                 checkForQuit() \n111.                 for event in pygame.event.get(): # event handling loop \n112.                     if event.type == MOUSEBUTTONUP: \n113.                         # Handle mouse click events \n114.                         mousex, mousey = event.pos \n115.                         if newGameRect.collidepoint( (mousex, mousey) ): \n116.                             # Start a new game \n117.                             return True \n118.                         elif hintsRect.collidepoint( (mousex, mousey) ): \n119.                             # Toggle hints mode \n120.                             showHints = not showHints \n121.                         # movexy is set to a two-item tuple XY coordinate, \nor None value \n122.                         movexy = getSpaceClicked(mousex, mousey) \n123.                         if movexy != None and not isValidMove(mainBoard, \nplayerTile, movexy[0], movexy[1]): \n124.                             movexy = None \n125.  \n126.                 # Draw the game board. \n127.                 drawBoard(boardToDraw) \n128.                 drawInfo(boardToDraw, playerTile, computerTile, turn) \n129.  \n130.                 # Draw the \"New Game\" and \"Hints\" buttons. \n131.                 DISPLAYSURF.blit(newGameSurf, newGameRect) \n\n\n296    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n132.                 DISPLAYSURF.blit(hintsSurf, hintsRect) \n133.  \n134.                 MAINCLOCK.tick(FPS) \n135.                 pygame.display.update() \n136.  \n137.             # Make the move and end the turn. \n138.             makeMove(mainBoard, playerTile, movexy[0], movexy[1], True) \n139.             if getValidMoves(mainBoard, computerTile) != []: \n140.                 # Only set for the computer's turn if it can make a move. \n141.                 turn = 'computer' \n142.  \n143.         else: \n144.             # Computer's turn: \n145.             if getValidMoves(mainBoard, computerTile) == []: \n146.                 # If it was set to be the computer's turn but \n147.                 # they can't move, then end the game. \n148.                 break \n149.  \n150.             # Draw the board. \n151.             drawBoard(mainBoard) \n152.             drawInfo(mainBoard, playerTile, computerTile, turn) \n153.  \n154.             # Draw the \"New Game\" and \"Hints\" buttons. \n155.             DISPLAYSURF.blit(newGameSurf, newGameRect) \n156.             DISPLAYSURF.blit(hintsSurf, hintsRect) \n157.  \n158.             # Make it look like the computer is thinking by pausing a bit. \n159.             pauseUntil = time.time() + random.randint(5, 15) * 0.1 \n160.             while time.time() < pauseUntil: \n161.                 pygame.display.update() \n162.  \n163.             # Make the move and end the turn. \n164.             x, y = getComputerMove(mainBoard, computerTile) \n165.             makeMove(mainBoard, computerTile, x, y, True) \n166.             if getValidMoves(mainBoard, playerTile) != []: \n167.                 # Only set for the player's turn if they can make a move. \n168.                 turn = 'player' \n169.  \n170.     # Display the final score. \n171.     drawBoard(mainBoard) \n172.     scores = getScoreOfBoard(mainBoard) \n173.  \n174.     # Determine the text of the message to display. \n175.     if scores[playerTile] > scores[computerTile]: \n176.         text = 'You beat the computer by %s points! Congratulations!' % \\ \n177.                (scores[playerTile] - scores[computerTile]) \n\n\nChapter 10 – Four Extra Games    297 \n \n178.     elif scores[playerTile] < scores[computerTile]: \n179.         text = 'You lost. The computer beat you by %s points.' % \\ \n180.                (scores[computerTile] - scores[playerTile]) \n181.     else: \n182.         text = 'The game was a tie!' \n183.  \n184.     textSurf = FONT.render(text, True, TEXTCOLOR, TEXTBGCOLOR1) \n185.     textRect = textSurf.get_rect() \n186.     textRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2)) \n187.     DISPLAYSURF.blit(textSurf, textRect) \n188.  \n189.     # Display the \"Play again?\" text with Yes and No buttons. \n190.     text2Surf = BIGFONT.render('Play again?', True, TEXTCOLOR, \nTEXTBGCOLOR1) \n191.     text2Rect = text2Surf.get_rect() \n192.     text2Rect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2) + 50) \n193.  \n194.     # Make \"Yes\" button. \n195.     yesSurf = BIGFONT.render('Yes', True, TEXTCOLOR, TEXTBGCOLOR1) \n196.     yesRect = yesSurf.get_rect() \n197.     yesRect.center = (int(WINDOWWIDTH / 2) - 60, int(WINDOWHEIGHT / 2) + \n90) \n198.  \n199.     # Make \"No\" button. \n200.     noSurf = BIGFONT.render('No', True, TEXTCOLOR, TEXTBGCOLOR1) \n201.     noRect = noSurf.get_rect() \n202.     noRect.center = (int(WINDOWWIDTH / 2) + 60, int(WINDOWHEIGHT / 2) + \n90) \n203.  \n204.     while True: \n205.         # Process events until the user clicks on Yes or No. \n206.         checkForQuit() \n207.         for event in pygame.event.get(): # event handling loop \n208.             if event.type == MOUSEBUTTONUP: \n209.                 mousex, mousey = event.pos \n210.                 if yesRect.collidepoint( (mousex, mousey) ): \n211.                     return True \n212.                 elif noRect.collidepoint( (mousex, mousey) ): \n213.                     return False \n214.         DISPLAYSURF.blit(textSurf, textRect) \n215.         DISPLAYSURF.blit(text2Surf, text2Rect) \n216.         DISPLAYSURF.blit(yesSurf, yesRect) \n217.         DISPLAYSURF.blit(noSurf, noRect) \n218.         pygame.display.update() \n219.         MAINCLOCK.tick(FPS) \n220.  \n",
      "page_number": 308,
      "chapter_number": 35,
      "summary": "This chapter covers segment 35 (pages 308-315). Key topics include game, board, and white.",
      "keywords": [
        "tile",
        "white tile",
        "game",
        "black tiles",
        "white",
        "mainBoard",
        "black",
        "board",
        "WINDOWWIDTH",
        "player",
        "Extra Games",
        "game board",
        "Computer",
        "turn",
        "move"
      ],
      "concepts": [
        "game",
        "board",
        "white",
        "score",
        "event",
        "black",
        "turn",
        "player",
        "font",
        "text"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "Segment 11 (pages 100-107)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 47,
          "title": "Segment 47 (pages 448-460)",
          "relevance_score": 0.65,
          "method": "api"
        }
      ]
    },
    {
      "number": 36,
      "title": "Segment 36 (pages 316-323)",
      "start_page": 316,
      "end_page": 323,
      "detection_method": "topic_boundary",
      "content": "298    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n221.  \n222. def translateBoardToPixelCoord(x, y): \n223.     return XMARGIN + x * SPACESIZE + int(SPACESIZE / 2), YMARGIN + y * \nSPACESIZE + int(SPACESIZE / 2) \n224.  \n225.  \n226. def animateTileChange(tilesToFlip, tileColor, additionalTile): \n227.     # Draw the additional tile that was just laid down. (Otherwise we'd \n228.     # have to completely redraw the board & the board info.) \n229.     if tileColor == WHITE_TILE: \n230.         additionalTileColor = WHITE \n231.     else: \n232.         additionalTileColor = BLACK \n233.     additionalTileX, additionalTileY = \ntranslateBoardToPixelCoord(additionalTile[0], additionalTile[1]) \n234.     pygame.draw.circle(DISPLAYSURF, additionalTileColor, (additionalTileX, \nadditionalTileY), int(SPACESIZE / 2) - 4) \n235.     pygame.display.update() \n236.  \n237.     for rgbValues in range(0, 255, int(ANIMATIONSPEED * 2.55)): \n238.         if rgbValues > 255: \n239.             rgbValues = 255 \n240.         elif rgbValues < 0: \n241.             rgbValues = 0 \n242.  \n243.         if tileColor == WHITE_TILE: \n244.             color = tuple([rgbValues] * 3) # rgbValues goes from 0 to 255 \n245.         elif tileColor == BLACK_TILE: \n246.             color = tuple([255 - rgbValues] * 3) # rgbValues goes from 255 \nto 0 \n247.  \n248.         for x, y in tilesToFlip: \n249.             centerx, centery = translateBoardToPixelCoord(x, y) \n250.             pygame.draw.circle(DISPLAYSURF, color, (centerx, centery), \nint(SPACESIZE / 2) - 4) \n251.         pygame.display.update() \n252.         MAINCLOCK.tick(FPS) \n253.         checkForQuit() \n254.  \n255.  \n256. def drawBoard(board): \n257.     # Draw background of board. \n258.     DISPLAYSURF.blit(BGIMAGE, BGIMAGE.get_rect()) \n259.  \n260.     # Draw grid lines of the board. \n261.     for x in range(BOARDWIDTH + 1): \n\n\nChapter 10 – Four Extra Games    299 \n \n262.         # Draw the horizontal lines. \n263.         startx = (x * SPACESIZE) + XMARGIN \n264.         starty = YMARGIN \n265.         endx = (x * SPACESIZE) + XMARGIN \n266.         endy = YMARGIN + (BOARDHEIGHT * SPACESIZE) \n267.         pygame.draw.line(DISPLAYSURF, GRIDLINECOLOR, (startx, starty), \n(endx, endy)) \n268.     for y in range(BOARDHEIGHT + 1): \n269.         # Draw the vertical lines. \n270.         startx = XMARGIN \n271.         starty = (y * SPACESIZE) + YMARGIN \n272.         endx = XMARGIN + (BOARDWIDTH * SPACESIZE) \n273.         endy = (y * SPACESIZE) + YMARGIN \n274.         pygame.draw.line(DISPLAYSURF, GRIDLINECOLOR, (startx, starty), \n(endx, endy)) \n275.  \n276.     # Draw the black & white tiles or hint spots. \n277.     for x in range(BOARDWIDTH): \n278.         for y in range(BOARDHEIGHT): \n279.             centerx, centery = translateBoardToPixelCoord(x, y) \n280.             if board[x][y] == WHITE_TILE or board[x][y] == BLACK_TILE: \n281.                 if board[x][y] == WHITE_TILE: \n282.                     tileColor = WHITE \n283.                 else: \n284.                     tileColor = BLACK \n285.                 pygame.draw.circle(DISPLAYSURF, tileColor, (centerx, \ncentery), int(SPACESIZE / 2) - 4) \n286.             if board[x][y] == HINT_TILE: \n287.                 pygame.draw.rect(DISPLAYSURF, HINTCOLOR, (centerx - 4, \ncentery - 4, 8, 8)) \n288.  \n289.  \n290. def getSpaceClicked(mousex, mousey): \n291.     # Return a tuple of two integers of the board space coordinates where \n292.     # the mouse was clicked. (Or returns None not in any space.) \n293.     for x in range(BOARDWIDTH): \n294.         for y in range(BOARDHEIGHT): \n295.             if mousex > x * SPACESIZE + XMARGIN and \\ \n296.                mousex < (x + 1) * SPACESIZE + XMARGIN and \\ \n297.                mousey > y * SPACESIZE + YMARGIN and \\ \n298.                mousey < (y + 1) * SPACESIZE + YMARGIN: \n299.                 return (x, y) \n300.     return None \n301.  \n302.  \n303. def drawInfo(board, playerTile, computerTile, turn): \n\n\n300    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n304.     # Draws scores and whose turn it is at the bottom of the screen. \n305.     scores = getScoreOfBoard(board) \n306.     scoreSurf = FONT.render(\"Player Score: %s    Computer Score: %s    \n%s's Turn\" % (str(scores[playerTile]), str(scores[computerTile]), \nturn.title()), True, TEXTCOLOR) \n307.     scoreRect = scoreSurf.get_rect() \n308.     scoreRect.bottomleft = (10, WINDOWHEIGHT - 5) \n309.     DISPLAYSURF.blit(scoreSurf, scoreRect) \n310.  \n311.  \n312. def resetBoard(board): \n313.     # Blanks out the board it is passed, and sets up starting tiles. \n314.     for x in range(BOARDWIDTH): \n315.         for y in range(BOARDHEIGHT): \n316.             board[x][y] = EMPTY_SPACE \n317.  \n318.     # Add starting pieces to the center \n319.     board[3][3] = WHITE_TILE \n320.     board[3][4] = BLACK_TILE \n321.     board[4][3] = BLACK_TILE \n322.     board[4][4] = WHITE_TILE \n323.  \n324.  \n325. def getNewBoard(): \n326.     # Creates a brand new, empty board data structure. \n327.     board = [] \n328.     for i in range(BOARDWIDTH): \n329.         board.append([EMPTY_SPACE] * BOARDHEIGHT) \n330.  \n331.     return board \n332.  \n333.  \n334. def isValidMove(board, tile, xstart, ystart): \n335.     # Returns False if the player's move is invalid. If it is a valid \n336.     # move, returns a list of spaces of the captured pieces. \n337.     if board[xstart][ystart] != EMPTY_SPACE or not isOnBoard(xstart, \nystart): \n338.         return False \n339.  \n340.     board[xstart][ystart] = tile # temporarily set the tile on the board. \n341.  \n342.     if tile == WHITE_TILE: \n343.         otherTile = BLACK_TILE \n344.     else: \n345.         otherTile = WHITE_TILE \n346.  \n\n\nChapter 10 – Four Extra Games    301 \n \n347.     tilesToFlip = [] \n348.     # check each of the eight directions: \n349.     for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -\n1], [-1, -1], [-1, 0], [-1, 1]]: \n350.         x, y = xstart, ystart \n351.         x += xdirection \n352.         y += ydirection \n353.         if isOnBoard(x, y) and board[x][y] == otherTile: \n354.             # The piece belongs to the other player next to our piece. \n355.             x += xdirection \n356.             y += ydirection \n357.             if not isOnBoard(x, y): \n358.                 continue \n359.             while board[x][y] == otherTile: \n360.                 x += xdirection \n361.                 y += ydirection \n362.                 if not isOnBoard(x, y): \n363.                     break # break out of while loop, continue in for loop \n364.             if not isOnBoard(x, y): \n365.                 continue \n366.             if board[x][y] == tile: \n367.                 # There are pieces to flip over. Go in the reverse \n368.                 # direction until we reach the original space, noting all \n369.                 # the tiles along the way. \n370.                 while True: \n371.                     x -= xdirection \n372.                     y -= ydirection \n373.                     if x == xstart and y == ystart: \n374.                         break \n375.                     tilesToFlip.append([x, y]) \n376.  \n377.     board[xstart][ystart] = EMPTY_SPACE # make space empty \n378.     if len(tilesToFlip) == 0: # If no tiles flipped, this move is invalid \n379.         return False \n380.     return tilesToFlip \n381.  \n382.  \n383. def isOnBoard(x, y): \n384.     # Returns True if the coordinates are located on the board. \n385.     return x >= 0 and x < BOARDWIDTH and y >= 0 and y < BOARDHEIGHT \n386.  \n387.  \n388. def getBoardWithValidMoves(board, tile): \n389.     # Returns a new board with hint markings. \n390.     dupeBoard = copy.deepcopy(board) \n391.  \n\n\n302    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n392.     for x, y in getValidMoves(dupeBoard, tile): \n393.         dupeBoard[x][y] = HINT_TILE \n394.     return dupeBoard \n395.  \n396.  \n397. def getValidMoves(board, tile): \n398.     # Returns a list of (x,y) tuples of all valid moves. \n399.     validMoves = [] \n400.  \n401.     for x in range(BOARDWIDTH): \n402.         for y in range(BOARDHEIGHT): \n403.             if isValidMove(board, tile, x, y) != False: \n404.                 validMoves.append((x, y)) \n405.     return validMoves \n406.  \n407.  \n408. def getScoreOfBoard(board): \n409.     # Determine the score by counting the tiles. \n410.     xscore = 0 \n411.     oscore = 0 \n412.     for x in range(BOARDWIDTH): \n413.         for y in range(BOARDHEIGHT): \n414.             if board[x][y] == WHITE_TILE: \n415.                 xscore += 1 \n416.             if board[x][y] == BLACK_TILE: \n417.                 oscore += 1 \n418.     return {WHITE_TILE:xscore, BLACK_TILE:oscore} \n419.  \n420.  \n421. def enterPlayerTile(): \n422.     # Draws the text and handles the mouse click events for letting \n423.     # the player choose which color they want to be.  Returns \n424.     # [WHITE_TILE, BLACK_TILE] if the player chooses to be White, \n425.     # [BLACK_TILE, WHITE_TILE] if Black. \n426.  \n427.     # Create the text. \n428.     textSurf = FONT.render('Do you want to be white or black?', True, \nTEXTCOLOR, TEXTBGCOLOR1) \n429.     textRect = textSurf.get_rect() \n430.     textRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2)) \n431.  \n432.     xSurf = BIGFONT.render('White', True, TEXTCOLOR, TEXTBGCOLOR1) \n433.     xRect = xSurf.get_rect() \n434.     xRect.center = (int(WINDOWWIDTH / 2) - 60, int(WINDOWHEIGHT / 2) + 40) \n435.  \n436.     oSurf = BIGFONT.render('Black', True, TEXTCOLOR, TEXTBGCOLOR1) \n\n\nChapter 10 – Four Extra Games    303 \n \n437.     oRect = oSurf.get_rect() \n438.     oRect.center = (int(WINDOWWIDTH / 2) + 60, int(WINDOWHEIGHT / 2) + 40) \n439.  \n440.     while True: \n441.         # Keep looping until the player has clicked on a color. \n442.         checkForQuit() \n443.         for event in pygame.event.get(): # event handling loop \n444.             if event.type == MOUSEBUTTONUP: \n445.                 mousex, mousey = event.pos \n446.                 if xRect.collidepoint( (mousex, mousey) ): \n447.                     return [WHITE_TILE, BLACK_TILE] \n448.                 elif oRect.collidepoint( (mousex, mousey) ): \n449.                     return [BLACK_TILE, WHITE_TILE] \n450.  \n451.         # Draw the screen. \n452.         DISPLAYSURF.blit(textSurf, textRect) \n453.         DISPLAYSURF.blit(xSurf, xRect) \n454.         DISPLAYSURF.blit(oSurf, oRect) \n455.         pygame.display.update() \n456.         MAINCLOCK.tick(FPS) \n457.  \n458.  \n459. def makeMove(board, tile, xstart, ystart, realMove=False): \n460.     # Place the tile on the board at xstart, ystart, and flip tiles \n461.     # Returns False if this is an invalid move, True if it is valid. \n462.     tilesToFlip = isValidMove(board, tile, xstart, ystart) \n463.  \n464.     if tilesToFlip == False: \n465.         return False \n466.  \n467.     board[xstart][ystart] = tile \n468.  \n469.     if realMove: \n470.         animateTileChange(tilesToFlip, tile, (xstart, ystart)) \n471.  \n472.     for x, y in tilesToFlip: \n473.         board[x][y] = tile \n474.     return True \n475.  \n476.  \n477. def isOnCorner(x, y): \n478.     # Returns True if the position is in one of the four corners. \n479.     return (x == 0 and y == 0) or \\ \n480.            (x == BOARDWIDTH and y == 0) or \\ \n481.            (x == 0 and y == BOARDHEIGHT) or \\ \n482.            (x == BOARDWIDTH and y == BOARDHEIGHT) \n\n\n304    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n483.  \n484.  \n485. def getComputerMove(board, computerTile): \n486.     # Given a board and the computer's tile, determine where to \n487.     # move and return that move as a [x, y] list. \n488.     possibleMoves = getValidMoves(board, computerTile) \n489.  \n490.     # randomize the order of the possible moves \n491.     random.shuffle(possibleMoves) \n492.  \n493.     # always go for a corner if available. \n494.     for x, y in possibleMoves: \n495.         if isOnCorner(x, y): \n496.             return [x, y] \n497.  \n498.     # Go through all possible moves and remember the best scoring move \n499.     bestScore = -1 \n500.     for x, y in possibleMoves: \n501.         dupeBoard = copy.deepcopy(board) \n502.         makeMove(dupeBoard, computerTile, x, y) \n503.         score = getScoreOfBoard(dupeBoard)[computerTile] \n504.         if score > bestScore: \n505.             bestMove = [x, y] \n506.             bestScore = score \n507.     return bestMove \n508.  \n509.  \n510. def checkForQuit(): \n511.     for event in pygame.event.get((QUIT, KEYUP)): # event handling loop \n512.         if event.type == QUIT or (event.type == KEYUP and event.key == \nK_ESCAPE): \n513.             pygame.quit() \n514.             sys.exit() \n515.  \n516.  \n517. if __name__ == '__main__': \n518.     main() \n \n\n\nChapter 10 – Four Extra Games    305 \n \nInk Spill, a “Flood It” Clone \n      \n \nThe game ―Flood It‖ begins with a board filled with colored tiles. On each turn the player chooses \na new color to paint the top left tile and any tiles adjacent to it of that same color. This game \nmakes use of the flood fill algorithm (described in the Star Pusher chapter). The goal of the game \nis to turn the entire board into a single color before running out of turns. \nThis game also has a Settings screen where the player can change the size of the board and the \ndifficulty of the game. If the player gets board of the colors, there are a few other color schemes \nthey can switch to as well. \nSource Code for Ink Spill \nThis source code can be downloaded from http://invpy.com/inkspill.py. \nThe image files that Flippy uses can be downloaded from http://invpy.com/inkspillimages.zip. \n  1. # Ink Spill (a Flood It clone) \n  2. # http://inventwithpython.com/pygame \n  3. # By Al Sweigart al@inventwithpython.com \n  4. # Released under a \"Simplified BSD\" license \n  5.  \n  6. import random, sys, webbrowser, copy, pygame \n  7. from pygame.locals import * \n  8.  \n  9. # There are different box sizes, number of boxes, and \n 10. # life depending on the \"board size\" setting selected. \n 11. SMALLBOXSIZE  = 60 # size is in pixels \n 12. MEDIUMBOXSIZE = 20 \n 13. LARGEBOXSIZE  = 11 \n 14.  \n 15. SMALLBOARDSIZE  = 6 # size is in boxes \n",
      "page_number": 316,
      "chapter_number": 36,
      "summary": "This chapter covers segment 36 (pages 316-323). Key topics include board, returns, and tile.",
      "keywords": [
        "tile",
        "board",
        "SPACESIZE",
        "WHITE",
        "BLACK",
        "BOARDHEIGHT",
        "BOARDWIDTH",
        "range",
        "int",
        "Draw",
        "ystart",
        "YMARGIN",
        "returns",
        "XMARGIN",
        "return False"
      ],
      "concepts": [
        "board",
        "returns",
        "tile",
        "draw",
        "space",
        "score",
        "scoring",
        "events",
        "color",
        "size"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 36,
          "title": "Segment 36 (pages 360-367)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 6",
          "chapter": 32,
          "title": "Segment 32 (pages 559-576)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 4",
          "chapter": 8,
          "title": "Segment 8 (pages 127-144)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 6",
          "chapter": 8,
          "title": "Segment 8 (pages 127-144)",
          "relevance_score": 0.57,
          "method": "api"
        }
      ]
    },
    {
      "number": 37,
      "title": "Segment 37 (pages 324-331)",
      "start_page": 324,
      "end_page": 331,
      "detection_method": "topic_boundary",
      "content": "306    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 16. MEDIUMBOARDSIZE = 17 \n 17. LARGEBOARDSIZE  = 30 \n 18.  \n 19. SMALLMAXLIFE  = 10 # number of turns \n 20. MEDIUMMAXLIFE = 30 \n 21. LARGEMAXLIFE  = 64 \n 22.  \n 23. FPS = 30 \n 24. WINDOWWIDTH = 640 \n 25. WINDOWHEIGHT = 480 \n 26. boxSize = MEDIUMBOXSIZE \n 27. PALETTEGAPSIZE = 10 \n 28. PALETTESIZE = 45 \n 29. EASY = 0   # arbitrary but unique value \n 30. MEDIUM = 1 # arbitrary but unique value \n 31. HARD = 2   # arbitrary but unique value \n 32.  \n 33. difficulty = MEDIUM # game starts in \"medium\" mode \n 34. maxLife = MEDIUMMAXLIFE \n 35. boardWidth = MEDIUMBOARDSIZE \n 36. boardHeight = MEDIUMBOARDSIZE \n 37.  \n 38.  \n 39. #            R    G    B \n 40. WHITE    = (255, 255, 255) \n 41. DARKGRAY = ( 70,  70,  70) \n 42. BLACK    = (  0,   0,   0) \n 43. RED      = (255,   0,   0) \n 44. GREEN    = (  0, 255,   0) \n 45. BLUE     = (  0,   0, 255) \n 46. YELLOW   = (255, 255,   0) \n 47. ORANGE   = (255, 128,   0) \n 48. PURPLE   = (255,   0, 255) \n 49.  \n 50. # The first color in each scheme is the background color, the next six are \nthe palette colors. \n 51. COLORSCHEMES = (((150, 200, 255), RED, GREEN, BLUE, YELLOW, ORANGE, \nPURPLE), \n 52.                 ((0, 155, 104),  (97, 215, 164),  (228, 0, 69),  (0, 125, \n50),   (204, 246, 0),   (148, 0, 45),    (241, 109, 149)), \n 53.                 ((195, 179, 0),  (255, 239, 115), (255, 226, 0), (147, 3, \n167),  (24, 38, 176),   (166, 147, 0),   (197, 97, 211)), \n 54.                 ((85, 0, 0),     (155, 39, 102),  (0, 201, 13),  (255, \n118, 0),  (206, 0, 113),   (0, 130, 9),     (255, 180, 115)), \n 55.                 ((191, 159, 64), (183, 182, 208), (4, 31, 183),  (167, \n184, 45), (122, 128, 212), (37, 204, 7),    (88, 155, 213)), \n\n\nChapter 10 – Four Extra Games    307 \n \n 56.                 ((200, 33, 205), (116, 252, 185), (68, 56, 56),  (52, 238, \n83),  (23, 149, 195),  (222, 157, 227), (212, 86, 185))) \n 57. for i in range(len(COLORSCHEMES)): \n 58.     assert len(COLORSCHEMES[i]) == 7, 'Color scheme %s does not have \nexactly 7 colors.' % (i) \n 59. bgColor = COLORSCHEMES[0][0] \n 60. paletteColors =  COLORSCHEMES[0][1:] \n 61.  \n 62. def main(): \n 63.     global FPSCLOCK, DISPLAYSURF, LOGOIMAGE, SPOTIMAGE, SETTINGSIMAGE, \nSETTINGSBUTTONIMAGE, RESETBUTTONIMAGE \n 64.  \n 65.     pygame.init() \n 66.     FPSCLOCK = pygame.time.Clock() \n 67.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 68.  \n 69.     # Load images \n 70.     LOGOIMAGE = pygame.image.load('inkspilllogo.png') \n 71.     SPOTIMAGE = pygame.image.load('inkspillspot.png') \n 72.     SETTINGSIMAGE = pygame.image.load('inkspillsettings.png') \n 73.     SETTINGSBUTTONIMAGE = pygame.image.load('inkspillsettingsbutton.png') \n 74.     RESETBUTTONIMAGE = pygame.image.load('inkspillresetbutton.png') \n 75.  \n 76.     pygame.display.set_caption('Ink Spill') \n 77.     mousex = 0 \n 78.     mousey = 0 \n 79.     mainBoard = generateRandomBoard(boardWidth, boardHeight, difficulty) \n 80.     life = maxLife \n 81.     lastPaletteClicked = None \n 82.  \n 83.     while True: # main game loop \n 84.         paletteClicked = None \n 85.         resetGame = False \n 86.  \n 87.         # Draw the screen. \n 88.         DISPLAYSURF.fill(bgColor) \n 89.         drawLogoAndButtons() \n 90.         drawBoard(mainBoard) \n 91.         drawLifeMeter(life) \n 92.         drawPalettes() \n 93.  \n 94.         checkForQuit() \n 95.         for event in pygame.event.get(): # event handling loop \n 96.             if event.type == MOUSEBUTTONUP: \n 97.                 mousex, mousey = event.pos \n\n\n308    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 98.                 if pygame.Rect(WINDOWWIDTH - \nSETTINGSBUTTONIMAGE.get_width(), \n 99.                                WINDOWHEIGHT - \nSETTINGSBUTTONIMAGE.get_height(), \n100.                                SETTINGSBUTTONIMAGE.get_width(), \n101.                                \nSETTINGSBUTTONIMAGE.get_height()).collidepoint(mousex, mousey): \n102.                     resetGame = showSettingsScreen() # clicked on Settings \nbutton \n103.                 elif pygame.Rect(WINDOWWIDTH - \nRESETBUTTONIMAGE.get_width(), \n104.                                  WINDOWHEIGHT - \nSETTINGSBUTTONIMAGE.get_height() - RESETBUTTONIMAGE.get_height(), \n105.                                  RESETBUTTONIMAGE.get_width(), \n106.                                  \nRESETBUTTONIMAGE.get_height()).collidepoint(mousex, mousey): \n107.                     resetGame = True # clicked on Reset button \n108.                 else: \n109.                     # check if a palette button was clicked \n110.                     paletteClicked = getColorOfPaletteAt(mousex, mousey) \n111.  \n112.         if paletteClicked != None and paletteClicked != \nlastPaletteClicked: \n113.             # a palette button was clicked that is different from the \n114.             # last palette button clicked (this check prevents the player \n115.             # from accidentally clicking the same palette twice) \n116.             lastPaletteClicked = paletteClicked \n117.             floodAnimation(mainBoard, paletteClicked) \n118.             life -= 1 \n119.  \n120.             resetGame = False \n121.             if hasWon(mainBoard): \n122.                 for i in range(4): # flash border 4 times \n123.                     flashBorderAnimation(WHITE, mainBoard) \n124.                 resetGame = True \n125.                 pygame.time.wait(2000) # pause so the player can bask in \nvictory \n126.             elif life == 0: \n127.                 # life is zero, so player has lost \n128.                 drawLifeMeter(0) \n129.                 pygame.display.update() \n130.                 pygame.time.wait(400) \n131.                 for i in range(4): \n132.                     flashBorderAnimation(BLACK, mainBoard) \n133.                 resetGame = True \n\n\nChapter 10 – Four Extra Games    309 \n \n134.                 pygame.time.wait(2000) # pause so the player can suffer in \ntheir defeat \n135.  \n136.         if resetGame: \n137.             # start a new game \n138.             mainBoard = generateRandomBoard(boardWidth, boardHeight, \ndifficulty) \n139.             life = maxLife \n140.             lastPaletteClicked = None \n141.  \n142.         pygame.display.update() \n143.         FPSCLOCK.tick(FPS) \n144.  \n145.  \n146. def checkForQuit(): \n147.     # Terminates the program if there are any QUIT or escape key events. \n148.     for event in pygame.event.get(QUIT): # get all the QUIT events \n149.         pygame.quit() # terminate if any QUIT events are present \n150.         sys.exit() \n151.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n152.         if event.key == K_ESCAPE: \n153.             pygame.quit() # terminate if the KEYUP event was for the Esc \nkey \n154.             sys.exit() \n155.         pygame.event.post(event) # put the other KEYUP event objects back \n156.  \n157.  \n158. def hasWon(board): \n159.     # if the entire board is the same color, player has won \n160.     for x in range(boardWidth): \n161.         for y in range(boardHeight): \n162.             if board[x][y] != board[0][0]: \n163.                 return False # found a different color, player has not won \n164.     return True \n165.  \n166.  \n167. def showSettingsScreen(): \n168.     global difficulty, boxSize, boardWidth, boardHeight, maxLife, \npaletteColors, bgColor \n169.  \n170.     # The pixel coordinates in this function were obtained by loading \n171.     # the inkspillsettings.png image into a graphics editor and reading \n172.     # the pixel coordinates from there. Handy trick. \n173.  \n174.     origDifficulty = difficulty \n175.     origBoxSize = boxSize \n\n\n310    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n176.     screenNeedsRedraw = True \n177.  \n178.     while True: \n179.         if screenNeedsRedraw: \n180.             DISPLAYSURF.fill(bgColor) \n181.             DISPLAYSURF.blit(SETTINGSIMAGE, (0,0)) \n182.  \n183.             # place the ink spot marker next to the selected difficulty \n184.             if difficulty == EASY: \n185.                 DISPLAYSURF.blit(SPOTIMAGE, (30, 4)) \n186.             if difficulty == MEDIUM: \n187.                 DISPLAYSURF.blit(SPOTIMAGE, (8, 41)) \n188.             if difficulty == HARD: \n189.                 DISPLAYSURF.blit(SPOTIMAGE, (30, 76)) \n190.  \n191.             # place the ink spot marker next to the selected size \n192.             if boxSize == SMALLBOXSIZE: \n193.                 DISPLAYSURF.blit(SPOTIMAGE, (22, 150)) \n194.             if boxSize == MEDIUMBOXSIZE: \n195.                 DISPLAYSURF.blit(SPOTIMAGE, (11, 185)) \n196.             if boxSize == LARGEBOXSIZE: \n197.                 DISPLAYSURF.blit(SPOTIMAGE, (24, 220)) \n198.  \n199.             for i in range(len(COLORSCHEMES)): \n200.                 drawColorSchemeBoxes(500, i * 60 + 30, i) \n201.  \n202.             pygame.display.update() \n203.  \n204.         screenNeedsRedraw = False # by default, don't redraw the screen \n205.         for event in pygame.event.get(): # event handling loop \n206.             if event.type == QUIT: \n207.                 pygame.quit() \n208.                 sys.exit() \n209.             elif event.type == KEYUP: \n210.                 if event.key == K_ESCAPE: \n211.                     # Esc key on settings screen goes back to game \n212.                     return not (origDifficulty == difficulty and \norigBoxSize == boxSize) \n213.             elif event.type == MOUSEBUTTONUP: \n214.                 screenNeedsRedraw = True # screen should be redrawn \n215.                 mousex, mousey = event.pos # syntactic sugar \n216.  \n217.                 # check for clicks on the difficulty buttons \n218.                 if pygame.Rect(74, 16, 111, 30).collidepoint(mousex, \nmousey): \n219.                     difficulty = EASY \n\n\nChapter 10 – Four Extra Games    311 \n \n220.                 elif pygame.Rect(53, 50, 104, 29).collidepoint(mousex, \nmousey): \n221.                     difficulty = MEDIUM \n222.                 elif pygame.Rect(72, 85, 65, 31).collidepoint(mousex, \nmousey): \n223.                     difficulty = HARD \n224.  \n225.                 # check for clicks on the size buttons \n226.                 elif pygame.Rect(63, 156, 84, 31).collidepoint(mousex, \nmousey): \n227.                     # small board size setting: \n228.                     boxSize = SMALLBOXSIZE \n229.                     boardWidth = SMALLBOARDSIZE \n230.                     boardHeight = SMALLBOARDSIZE \n231.                     maxLife = SMALLMAXLIFE \n232.                 elif pygame.Rect(52, 192, 106,32).collidepoint(mousex, \nmousey): \n233.                     # medium board size setting: \n234.                     boxSize = MEDIUMBOXSIZE \n235.                     boardWidth = MEDIUMBOARDSIZE \n236.                     boardHeight = MEDIUMBOARDSIZE \n237.                     maxLife = MEDIUMMAXLIFE \n238.                 elif pygame.Rect(67, 228, 58, 37).collidepoint(mousex, \nmousey): \n239.                     # large board size setting: \n240.                     boxSize = LARGEBOXSIZE \n241.                     boardWidth = LARGEBOARDSIZE \n242.                     boardHeight = LARGEBOARDSIZE \n243.                     maxLife = LARGEMAXLIFE \n244.                 elif pygame.Rect(14, 299, 371, 97).collidepoint(mousex, \nmousey): \n245.                     # clicked on the \"learn programming\" ad \n246.                     webbrowser.open('http://inventwithpython.com') # opens \na web browser \n247.                 elif pygame.Rect(178, 418, 215, 34).collidepoint(mousex, \nmousey): \n248.                     # clicked on the \"back to game\" button \n249.                     return not (origDifficulty == difficulty and \norigBoxSize == boxSize) \n250.  \n251.                 for i in range(len(COLORSCHEMES)): \n252.                     # clicked on a color scheme button \n253.                     if pygame.Rect(500, 30 + i * 60, MEDIUMBOXSIZE * 3, \nMEDIUMBOXSIZE * 2).collidepoint(mousex, mousey): \n254.                         bgColor = COLORSCHEMES[i][0] \n255.                         paletteColors  = COLORSCHEMES[i][1:] \n\n\n312    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n256.  \n257.  \n258. def drawColorSchemeBoxes(x, y, schemeNum): \n259.     # Draws the color scheme boxes that appear on the \"Settings\" screen. \n260.     for boxy in range(2): \n261.         for boxx in range(3): \n262.             pygame.draw.rect(DISPLAYSURF, COLORSCHEMES[schemeNum][3 * boxy \n+ boxx + 1], (x + MEDIUMBOXSIZE * boxx, y + MEDIUMBOXSIZE * boxy, \nMEDIUMBOXSIZE, MEDIUMBOXSIZE)) \n263.             if paletteColors == COLORSCHEMES[schemeNum][1:]: \n264.                 # put the ink spot next to the selected color scheme \n265.                 DISPLAYSURF.blit(SPOTIMAGE, (x - 50, y)) \n266.  \n267.  \n268. def flashBorderAnimation(color, board, animationSpeed=30): \n269.     origSurf = DISPLAYSURF.copy() \n270.     flashSurf = pygame.Surface(DISPLAYSURF.get_size()) \n271.     flashSurf = flashSurf.convert_alpha() \n272.     for start, end, step in ((0, 256, 1), (255, 0, -1)): \n273.         # the first iteration on the outer loop will set the inner loop \n274.         # to have transparency go from 0 to 255, the second iteration will \n275.         # have it go from 255 to 0. This is the \"flash\". \n276.         for transparency in range(start, end, animationSpeed * step): \n277.             DISPLAYSURF.blit(origSurf, (0, 0)) \n278.             r, g, b = color \n279.             flashSurf.fill((r, g, b, transparency)) \n280.             DISPLAYSURF.blit(flashSurf, (0, 0)) \n281.             drawBoard(board) # draw board ON TOP OF the transparency layer \n282.             pygame.display.update() \n283.             FPSCLOCK.tick(FPS) \n284.     DISPLAYSURF.blit(origSurf, (0, 0)) # redraw the original surface \n285.  \n286.  \n287. def floodAnimation(board, paletteClicked, animationSpeed=25): \n288.     origBoard = copy.deepcopy(board) \n289.     floodFill(board, board[0][0], paletteClicked, 0, 0) \n290.  \n291.     for transparency in range(0, 255, animationSpeed): \n292.         # The \"new\" board slowly become opaque over the original board. \n293.         drawBoard(origBoard) \n294.         drawBoard(board, transparency) \n295.         pygame.display.update() \n296.         FPSCLOCK.tick(FPS) \n297.  \n298.  \n299. def generateRandomBoard(width, height, difficulty=MEDIUM): \n\n\nChapter 10 – Four Extra Games    313 \n \n300.     # Creates a board data structure with random colors for each box. \n301.     board = [] \n302.     for x in range(width): \n303.         column = [] \n304.         for y in range(height): \n305.             column.append(random.randint(0, len(paletteColors) - 1)) \n306.         board.append(column) \n307.  \n308.     # Make board easier by setting some boxes to same color as a neighbor. \n309.  \n310.     # Determine how many boxes to change. \n311.     if difficulty == EASY: \n312.         if boxSize == SMALLBOXSIZE: \n313.             boxesToChange = 100 \n314.         else: \n315.             boxesToChange = 1500 \n316.     elif difficulty == MEDIUM: \n317.         if boxSize == SMALLBOXSIZE: \n318.             boxesToChange = 5 \n319.         else: \n320.             boxesToChange = 200 \n321.     else: \n322.         boxesToChange = 0 \n323.  \n324.     # Change neighbor's colors: \n325.     for i in range(boxesToChange): \n326.         # Randomly choose a box whose color to copy \n327.         x = random.randint(1, width-2) \n328.         y = random.randint(1, height-2) \n329.  \n330.         # Randomly choose neighbors to change. \n331.         direction = random.randint(0, 3) \n332.         if direction == 0: # change left and up neighbor \n333.             board[x-1][y] == board[x][y] \n334.             board[x][y-1] == board[x][y] \n335.         elif direction == 1: # change right and down neighbor \n336.             board[x+1][y] == board[x][y] \n337.             board[x][y+1] == board[x][y] \n338.         elif direction == 2: # change right and up neighbor \n339.             board[x][y-1] == board[x][y] \n340.             board[x+1][y] == board[x][y] \n341.         else: # change left and down neighbor \n342.             board[x][y+1] == board[x][y] \n343.             board[x-1][y] == board[x][y] \n344.     return board \n345.  \n",
      "page_number": 324,
      "chapter_number": 37,
      "summary": "This chapter covers segment 37 (pages 324-331). Key topics include board, color, and difficulty.",
      "keywords": [
        "board",
        "COLORSCHEMES",
        "mousex",
        "mousey",
        "difficulty",
        "range",
        "SPOTIMAGE",
        "elif pygame.Rect",
        "MEDIUMBOXSIZE",
        "boxSize",
        "DISPLAYSURF.blit",
        "collidepoint",
        "pygame.Rect",
        "color",
        "MEDIUM"
      ],
      "concepts": [
        "board",
        "color",
        "difficulty",
        "event",
        "game",
        "range",
        "button",
        "mousey",
        "medium",
        "random"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "Segment 11 (pages 100-107)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 39,
          "title": "Segment 39 (pages 353-355)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.56,
          "method": "api"
        }
      ]
    },
    {
      "number": 38,
      "title": "Segment 38 (pages 332-339)",
      "start_page": 332,
      "end_page": 339,
      "detection_method": "topic_boundary",
      "content": "314    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n346.  \n347. def drawLogoAndButtons(): \n348.     # draw the Ink Spill logo and Settings and Reset buttons. \n349.     DISPLAYSURF.blit(LOGOIMAGE, (WINDOWWIDTH - LOGOIMAGE.get_width(), 0)) \n350.     DISPLAYSURF.blit(SETTINGSBUTTONIMAGE, (WINDOWWIDTH - \nSETTINGSBUTTONIMAGE.get_width(), WINDOWHEIGHT - \nSETTINGSBUTTONIMAGE.get_height())) \n351.     DISPLAYSURF.blit(RESETBUTTONIMAGE, (WINDOWWIDTH - \nRESETBUTTONIMAGE.get_width(), WINDOWHEIGHT - SETTINGSBUTTONIMAGE.get_height() - \nRESETBUTTONIMAGE.get_height())) \n352.  \n353.  \n354. def drawBoard(board, transparency=255): \n355.     # The colored squares are drawn to a temporary surface which is then \n356.     # drawn to the DISPLAYSURF surface. This is done so we can draw the \n357.     # squares with transparency on top of DISPLAYSURF as it currently is. \n358.     tempSurf = pygame.Surface(DISPLAYSURF.get_size()) \n359.     tempSurf = tempSurf.convert_alpha() \n360.     tempSurf.fill((0, 0, 0, 0)) \n361.  \n362.     for x in range(boardWidth): \n363.         for y in range(boardHeight): \n364.             left, top = leftTopPixelCoordOfBox(x, y) \n365.             r, g, b = paletteColors[board[x][y]] \n366.             pygame.draw.rect(tempSurf, (r, g, b, transparency), (left, \ntop, boxSize, boxSize)) \n367.     left, top = leftTopPixelCoordOfBox(0, 0) \n368.     pygame.draw.rect(tempSurf, BLACK, (left-1, top-1, boxSize * boardWidth \n+ 1, boxSize * boardHeight + 1), 1) \n369.     DISPLAYSURF.blit(tempSurf, (0, 0)) \n370.  \n371.  \n372. def drawPalettes(): \n373.     # Draws the six color palettes at the bottom of the screen. \n374.     numColors = len(paletteColors) \n375.     xmargin = int((WINDOWWIDTH - ((PALETTESIZE * numColors) + \n(PALETTEGAPSIZE * (numColors - 1)))) / 2) \n376.     for i in range(numColors): \n377.         left = xmargin + (i * PALETTESIZE) + (i * PALETTEGAPSIZE) \n378.         top = WINDOWHEIGHT - PALETTESIZE - 10 \n379.         pygame.draw.rect(DISPLAYSURF, paletteColors[i], (left, top, \nPALETTESIZE, PALETTESIZE)) \n380.         pygame.draw.rect(DISPLAYSURF, bgColor,   (left + 2, top + 2, \nPALETTESIZE - 4, PALETTESIZE - 4), 2) \n381.  \n382.  \n\n\nChapter 10 – Four Extra Games    315 \n \n383. def drawLifeMeter(currentLife): \n384.     lifeBoxSize = int((WINDOWHEIGHT - 40) / maxLife) \n385.  \n386.     # Draw background color of life meter. \n387.     pygame.draw.rect(DISPLAYSURF, bgColor, (20, 20, 20, 20 + (maxLife * \nlifeBoxSize))) \n388.  \n389.     for i in range(maxLife): \n390.         if currentLife >= (maxLife - i): # draw a solid red box \n391.             pygame.draw.rect(DISPLAYSURF, RED, (20, 20 + (i * \nlifeBoxSize), 20, lifeBoxSize)) \n392.         pygame.draw.rect(DISPLAYSURF, WHITE, (20, 20 + (i * lifeBoxSize), \n20, lifeBoxSize), 1) # draw white outline \n393.  \n394.  \n395. def getColorOfPaletteAt(x, y): \n396.     # Returns the index of the color in paletteColors that the x and y \nparameters \n397.     # are over. Returns None if x and y are not over any palette. \n398.     numColors = len(paletteColors) \n399.     xmargin = int((WINDOWWIDTH - ((PALETTESIZE * numColors) + \n(PALETTEGAPSIZE * (numColors - 1)))) / 2) \n400.     top = WINDOWHEIGHT - PALETTESIZE - 10 \n401.     for i in range(numColors): \n402.         # Find out if the mouse click is inside any of the palettes. \n403.         left = xmargin + (i * PALETTESIZE) + (i * PALETTEGAPSIZE) \n404.         r = pygame.Rect(left, top, PALETTESIZE, PALETTESIZE) \n405.         if r.collidepoint(x, y): \n406.             return i \n407.     return None # no palette exists at these x, y coordinates \n408.  \n409.  \n410. def floodFill(board, oldColor, newColor, x, y): \n411.     # This is the flood fill algorithm. \n412.     if oldColor == newColor or board[x][y] != oldColor: \n413.         return \n414.  \n415.     board[x][y] = newColor # change the color of the current box \n416.  \n417.     # Make the recursive call for any neighboring boxes: \n418.     if x > 0: \n419.         floodFill(board, oldColor, newColor, x - 1, y) # on box to the \nleft \n420.     if x < boardWidth - 1: \n421.         floodFill(board, oldColor, newColor, x + 1, y) # on box to the \nright \n\n\n316    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n422.     if y > 0: \n423.         floodFill(board, oldColor, newColor, x, y - 1) # on box to up \n424.     if y < boardHeight - 1: \n425.         floodFill(board, oldColor, newColor, x, y + 1) # on box to down \n426.  \n427.  \n428. def leftTopPixelCoordOfBox(boxx, boxy): \n429.     # Returns the x and y of the left-topmost pixel of the xth & yth box. \n430.     xmargin = int((WINDOWWIDTH - (boardWidth * boxSize)) / 2) \n431.     ymargin = int((WINDOWHEIGHT - (boardHeight * boxSize)) / 2) \n432.     return (boxx * boxSize + xmargin, boxy * boxSize + ymargin) \n433.  \n434.  \n435. if __name__ == '__main__': \n436.     main() \n \n\n\nChapter 10 – Four Extra Games    317 \n \nFour-In-A-Row, a “Connect Four” Clone \n      \n \nThe game ―Connect Four‖ has a 7 x 6 board where the players take turns dropping tokens from \nthe top of the board. The tokens will fall from the top of each column and come to rest on the \nbottom of the board or on top of the topmost token in that column. A player wins when four of \ntheir tokens line up in a row either horizontally, vertically, or diagonally. \nThe AI for this game is pretty good. It simulates every possible move it can make, then simulates \nevery possible move the human player can make in response to each of those moves, and then \nsimulates every possible move it can make in response to that, and then simulates every possible \nmove the human player could make in response to each of those moves! After all that thinking, \nthe computer determines which move is most likely to lead to it winning. \nSo the computer is kind of tough to beat. I usually lose to it. \nSince there are seven possible moves you can make on your turn (unless some columns are full), \nand seven possible moves the opponent could make, and seven moves in response to that, and \nseven moves in response to that, that means that on each turn the computer is considering 7 x 7 x \n7 x 7 = 2,401 possible moves. You can make the computer consider the game even further by \nsetting the DIFFICULTY constant to a higher number, but when I set to a value larger than 2, the \ncomputer takes a long time to calculate its turn. \nYou can also make the computer easier by setting DIFFICULTY to 1. Then the computer only \nconsiders each of its moves and the player’s possible responses to those moves. If you set the \nDIFFICULTY to 0, then the computer loses all intelligence and simply makes random moves. \nSource Code for Four-In-A-Row \nThis source code can be downloaded from http://invpy.com/fourinarow.py. \n\n\n318    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe image files that Flippy uses can be downloaded from http://invpy.com/fourinarowimages.zip. \n  1. # Four-In-A-Row (a Connect Four clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Released under a \"Simplified BSD\" license \n  5.  \n  6. import random, copy, sys, pygame \n  7. from pygame.locals import * \n  8.  \n  9. BOARDWIDTH = 7  # how many spaces wide the board is \n 10. BOARDHEIGHT = 6 # how many spaces tall the board is \n 11. assert BOARDWIDTH >= 4 and BOARDHEIGHT >= 4, 'Board must be at least 4x4.' \n 12.  \n 13. DIFFICULTY = 2 # how many moves to look ahead. (>2 is usually too slow) \n 14.  \n 15. SPACESIZE = 50 # size of the tokens and individual board spaces in pixels \n 16.  \n 17. FPS = 30 # frames per second to update the screen \n 18. WINDOWWIDTH = 640 # width of the program's window, in pixels \n 19. WINDOWHEIGHT = 480 # height in pixels \n 20.  \n 21. XMARGIN = int((WINDOWWIDTH - BOARDWIDTH * SPACESIZE) / 2) \n 22. YMARGIN = int((WINDOWHEIGHT - BOARDHEIGHT * SPACESIZE) / 2) \n 23.  \n 24. BRIGHTBLUE = (0, 50, 255) \n 25. WHITE = (255, 255, 255) \n 26.  \n 27. BGCOLOR = BRIGHTBLUE \n 28. TEXTCOLOR = WHITE \n 29.  \n 30. RED = 'red' \n 31. BLACK = 'black' \n 32. EMPTY = None \n 33. HUMAN = 'human' \n 34. COMPUTER = 'computer' \n 35.  \n 36.  \n 37. def main(): \n 38.     global FPSCLOCK, DISPLAYSURF, REDPILERECT, BLACKPILERECT, REDTOKENIMG \n 39.     global BLACKTOKENIMG, BOARDIMG, ARROWIMG, ARROWRECT, HUMANWINNERIMG \n 40.     global COMPUTERWINNERIMG, WINNERRECT, TIEWINNERIMG \n 41.  \n 42.     pygame.init() \n 43.     FPSCLOCK = pygame.time.Clock() \n 44.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n\n\nChapter 10 – Four Extra Games    319 \n \n 45.     pygame.display.set_caption('Four in a Row') \n 46.  \n 47.     REDPILERECT = pygame.Rect(int(SPACESIZE / 2), WINDOWHEIGHT - int(3 * \nSPACESIZE / 2), SPACESIZE, SPACESIZE) \n 48.     BLACKPILERECT = pygame.Rect(WINDOWWIDTH - int(3 * SPACESIZE / 2), \nWINDOWHEIGHT - int(3 * SPACESIZE / 2), SPACESIZE, SPACESIZE) \n 49.     REDTOKENIMG = pygame.image.load('4row_red.png') \n 50.     REDTOKENIMG = pygame.transform.smoothscale(REDTOKENIMG, (SPACESIZE, \nSPACESIZE)) \n 51.     BLACKTOKENIMG = pygame.image.load('4row_black.png') \n 52.     BLACKTOKENIMG = pygame.transform.smoothscale(BLACKTOKENIMG, \n(SPACESIZE, SPACESIZE)) \n 53.     BOARDIMG = pygame.image.load('4row_board.png') \n 54.     BOARDIMG = pygame.transform.smoothscale(BOARDIMG, (SPACESIZE, \nSPACESIZE)) \n 55.  \n 56.     HUMANWINNERIMG = pygame.image.load('4row_humanwinner.png') \n 57.     COMPUTERWINNERIMG = pygame.image.load('4row_computerwinner.png') \n 58.     TIEWINNERIMG = pygame.image.load('4row_tie.png') \n 59.     WINNERRECT = HUMANWINNERIMG.get_rect() \n 60.     WINNERRECT.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2)) \n 61.  \n 62.     ARROWIMG = pygame.image.load('4row_arrow.png') \n 63.     ARROWRECT = ARROWIMG.get_rect() \n 64.     ARROWRECT.left = REDPILERECT.right + 10 \n 65.     ARROWRECT.centery = REDPILERECT.centery \n 66.  \n 67.     isFirstGame = True \n 68.  \n 69.     while True: \n 70.         runGame(isFirstGame) \n 71.         isFirstGame = False \n 72.  \n 73.  \n 74. def runGame(isFirstGame): \n 75.     if isFirstGame: \n 76.         # Let the computer go first on the first game, so the player \n 77.         # can see how the tokens are dragged from the token piles. \n 78.         turn = COMPUTER \n 79.         showHelp = True \n 80.     else: \n 81.         # Randomly choose who goes first. \n 82.         if random.randint(0, 1) == 0: \n 83.             turn = COMPUTER \n 84.         else: \n 85.             turn = HUMAN \n\n\n320    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 86.         showHelp = False \n 87.  \n 88.     # Set up a blank board data structure. \n 89.     mainBoard = getNewBoard() \n 90.  \n 91.     while True: # main game loop \n 92.         if turn == HUMAN: \n 93.             # Human player's turn. \n 94.             getHumanMove(mainBoard, showHelp) \n 95.             if showHelp: \n 96.                 # turn off help arrow after the first move \n 97.                 showHelp = False \n 98.             if isWinner(mainBoard, RED): \n 99.                 winnerImg = HUMANWINNERIMG \n100.                 break \n101.             turn = COMPUTER # switch to other player's turn \n102.         else: \n103.             # Computer player's turn. \n104.             column = getComputerMove(mainBoard) \n105.             animateComputerMoving(mainBoard, column) \n106.             makeMove(mainBoard, BLACK, column) \n107.             if isWinner(mainBoard, BLACK): \n108.                 winnerImg = COMPUTERWINNERIMG \n109.                 break \n110.             turn = HUMAN # switch to other player's turn \n111.  \n112.         if isBoardFull(mainBoard): \n113.             # A completely filled board means it's a tie. \n114.             winnerImg = TIEWINNERIMG \n115.             break \n116.  \n117.     while True: \n118.         # Keep looping until player clicks the mouse or quits. \n119.         drawBoard(mainBoard) \n120.         DISPLAYSURF.blit(winnerImg, WINNERRECT) \n121.         pygame.display.update() \n122.         FPSCLOCK.tick() \n123.         for event in pygame.event.get(): # event handling loop \n124.             if event.type == QUIT or (event.type == KEYUP and event.key == \nK_ESCAPE): \n125.                 pygame.quit() \n126.                 sys.exit() \n127.             elif event.type == MOUSEBUTTONUP: \n128.                 return \n129.  \n130.  \n\n\nChapter 10 – Four Extra Games    321 \n \n131. def makeMove(board, player, column): \n132.     lowest = getLowestEmptySpace(board, column) \n133.     if lowest != -1: \n134.         board[column][lowest] = player \n135.  \n136.  \n137. def drawBoard(board, extraToken=None): \n138.     DISPLAYSURF.fill(BGCOLOR) \n139.  \n140.     # draw tokens \n141.     spaceRect = pygame.Rect(0, 0, SPACESIZE, SPACESIZE) \n142.     for x in range(BOARDWIDTH): \n143.         for y in range(BOARDHEIGHT): \n144.             spaceRect.topleft = (XMARGIN + (x * SPACESIZE), YMARGIN + (y * \nSPACESIZE)) \n145.             if board[x][y] == RED: \n146.                 DISPLAYSURF.blit(REDTOKENIMG, spaceRect) \n147.             elif board[x][y] == BLACK: \n148.                 DISPLAYSURF.blit(BLACKTOKENIMG, spaceRect) \n149.  \n150.     # draw the extra token \n151.     if extraToken != None: \n152.         if extraToken['color'] == RED: \n153.             DISPLAYSURF.blit(REDTOKENIMG, (extraToken['x'], \nextraToken['y'], SPACESIZE, SPACESIZE)) \n154.         elif extraToken['color'] == BLACK: \n155.             DISPLAYSURF.blit(BLACKTOKENIMG, (extraToken['x'], \nextraToken['y'], SPACESIZE, SPACESIZE)) \n156.  \n157.     # draw board over the tokens \n158.     for x in range(BOARDWIDTH): \n159.         for y in range(BOARDHEIGHT): \n160.             spaceRect.topleft = (XMARGIN + (x * SPACESIZE), YMARGIN + (y * \nSPACESIZE)) \n161.             DISPLAYSURF.blit(BOARDIMG, spaceRect) \n162.  \n163.     # draw the red and black tokens off to the side \n164.     DISPLAYSURF.blit(REDTOKENIMG, REDPILERECT) # red on the left \n165.     DISPLAYSURF.blit(BLACKTOKENIMG, BLACKPILERECT) # black on the right \n166.  \n167.  \n168. def getNewBoard(): \n169.     board = [] \n170.     for x in range(BOARDWIDTH): \n171.         board.append([EMPTY] * BOARDHEIGHT) \n172.     return board \n",
      "page_number": 332,
      "chapter_number": 38,
      "summary": "This chapter covers segment 38 (pages 332-339). Key topics include board, draw, and left.",
      "keywords": [
        "SPACESIZE",
        "PALETTESIZE",
        "board",
        "WINDOWHEIGHT",
        "WINDOWWIDTH",
        "computer",
        "int",
        "DISPLAYSURF",
        "boardWidth",
        "boardHeight",
        "top",
        "DISPLAYSURF.blit",
        "turn",
        "xmargin",
        "moves"
      ],
      "concepts": [
        "board",
        "draw",
        "left",
        "black",
        "boxes",
        "random",
        "turns",
        "tokens",
        "players",
        "returns"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "Segment 11 (pages 100-107)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 6",
          "chapter": 32,
          "title": "Segment 32 (pages 559-576)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 32,
          "title": "Segment 32 (pages 301-308)",
          "relevance_score": 0.58,
          "method": "api"
        }
      ]
    },
    {
      "number": 39,
      "title": "Segment 39 (pages 340-347)",
      "start_page": 340,
      "end_page": 347,
      "detection_method": "topic_boundary",
      "content": "322    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n173.  \n174.  \n175. def getHumanMove(board, isFirstMove): \n176.     draggingToken = False \n177.     tokenx, tokeny = None, None \n178.     while True: \n179.         for event in pygame.event.get(): # event handling loop \n180.             if event.type == QUIT: \n181.                 pygame.quit() \n182.                 sys.exit() \n183.             elif event.type == MOUSEBUTTONDOWN and not draggingToken and \nREDPILERECT.collidepoint(event.pos): \n184.                 # start of dragging on red token pile. \n185.                 draggingToken = True \n186.                 tokenx, tokeny = event.pos \n187.             elif event.type == MOUSEMOTION and draggingToken: \n188.                 # update the position of the red token being dragged \n189.                 tokenx, tokeny = event.pos \n190.             elif event.type == MOUSEBUTTONUP and draggingToken: \n191.                 # let go of the token being dragged \n192.                 if tokeny < YMARGIN and tokenx > XMARGIN and tokenx < \nWINDOWWIDTH - XMARGIN: \n193.                     # let go at the top of the screen. \n194.                     column = int((tokenx - XMARGIN) / SPACESIZE) \n195.                     if isValidMove(board, column): \n196.                         animateDroppingToken(board, column, RED) \n197.                         board[column][getLowestEmptySpace(board, column)] \n= RED \n198.                         drawBoard(board) \n199.                         pygame.display.update() \n200.                         return \n201.                 tokenx, tokeny = None, None \n202.                 draggingToken = False \n203.         if tokenx != None and tokeny != None: \n204.             drawBoard(board, {'x':tokenx - int(SPACESIZE / 2), 'y':tokeny \n- int(SPACESIZE / 2), 'color':RED}) \n205.         else: \n206.             drawBoard(board) \n207.  \n208.         if isFirstMove: \n209.             # Show the help arrow for the player's first move. \n210.             DISPLAYSURF.blit(ARROWIMG, ARROWRECT) \n211.  \n212.         pygame.display.update() \n213.         FPSCLOCK.tick() \n214.  \n\n\nChapter 10 – Four Extra Games    323 \n \n215.  \n216. def animateDroppingToken(board, column, color): \n217.     x = XMARGIN + column * SPACESIZE \n218.     y = YMARGIN - SPACESIZE \n219.     dropSpeed = 1.0 \n220.  \n221.     lowestEmptySpace = getLowestEmptySpace(board, column) \n222.  \n223.     while True: \n224.         y += int(dropSpeed) \n225.         dropSpeed += 0.5 \n226.         if int((y - YMARGIN) / SPACESIZE) >= lowestEmptySpace: \n227.             return \n228.         drawBoard(board, {'x':x, 'y':y, 'color':color}) \n229.         pygame.display.update() \n230.         FPSCLOCK.tick() \n231.  \n232.  \n233. def animateComputerMoving(board, column): \n234.     x = BLACKPILERECT.left \n235.     y = BLACKPILERECT.top \n236.     speed = 1.0 \n237.     # moving the black tile up \n238.     while y > (YMARGIN - SPACESIZE): \n239.         y -= int(speed) \n240.         speed += 0.5 \n241.         drawBoard(board, {'x':x, 'y':y, 'color':BLACK}) \n242.         pygame.display.update() \n243.         FPSCLOCK.tick() \n244.     # moving the black tile over \n245.     y = YMARGIN - SPACESIZE \n246.     speed = 1.0 \n247.     while x > (XMARGIN + column * SPACESIZE): \n248.         x -= int(speed) \n249.         speed += 0.5 \n250.         drawBoard(board, {'x':x, 'y':y, 'color':BLACK}) \n251.         pygame.display.update() \n252.         FPSCLOCK.tick() \n253.     # dropping the black tile \n254.     animateDroppingToken(board, column, BLACK) \n255.  \n256.  \n257. def getComputerMove(board): \n258.     potentialMoves = getPotentialMoves(board, BLACK, DIFFICULTY) \n259.     # get the best fitness from the potential moves \n260.     bestMoveFitness = -1 \n\n\n324    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n261.     for i in range(BOARDWIDTH): \n262.         if potentialMoves[i] > bestMoveFitness and isValidMove(board, i): \n263.             bestMoveFitness = potentialMoves[i] \n264.     # find all potential moves that have this best fitness \n265.     bestMoves = [] \n266.     for i in range(len(potentialMoves)): \n267.         if potentialMoves[i] == bestMoveFitness and isValidMove(board, i): \n268.             bestMoves.append(i) \n269.     return random.choice(bestMoves) \n270.  \n271.  \n272. def getPotentialMoves(board, tile, lookAhead): \n273.     if lookAhead == 0 or isBoardFull(board): \n274.         return [0] * BOARDWIDTH \n275.  \n276.     if tile == RED: \n277.         enemyTile = BLACK \n278.     else: \n279.         enemyTile = RED \n280.  \n281.     # Figure out the best move to make. \n282.     potentialMoves = [0] * BOARDWIDTH \n283.     for firstMove in range(BOARDWIDTH): \n284.         dupeBoard = copy.deepcopy(board) \n285.         if not isValidMove(dupeBoard, firstMove): \n286.             continue \n287.         makeMove(dupeBoard, tile, firstMove) \n288.         if isWinner(dupeBoard, tile): \n289.             # a winning move automatically gets a perfect fitness \n290.             potentialMoves[firstMove] = 1 \n291.             break # don't bother calculating other moves \n292.         else: \n293.             # do other player's counter moves and determine best one \n294.             if isBoardFull(dupeBoard): \n295.                 potentialMoves[firstMove] = 0 \n296.             else: \n297.                 for counterMove in range(BOARDWIDTH): \n298.                     dupeBoard2 = copy.deepcopy(dupeBoard) \n299.                     if not isValidMove(dupeBoard2, counterMove): \n300.                         continue \n301.                     makeMove(dupeBoard2, enemyTile, counterMove) \n302.                     if isWinner(dupeBoard2, enemyTile): \n303.                         # a losing move automatically gets the worst \nfitness \n304.                         potentialMoves[firstMove] = -1 \n305.                         break \n\n\nChapter 10 – Four Extra Games    325 \n \n306.                     else: \n307.                         # do the recursive call to getPotentialMoves() \n308.                         results = getPotentialMoves(dupeBoard2, tile, \nlookAhead - 1) \n309.                         potentialMoves[firstMove] += (sum(results) / \nBOARDWIDTH) / BOARDWIDTH \n310.     return potentialMoves \n311.  \n312.  \n313. def getLowestEmptySpace(board, column): \n314.     # Return the row number of the lowest empty row in the given column. \n315.     for y in range(BOARDHEIGHT-1, -1, -1): \n316.         if board[column][y] == EMPTY: \n317.             return y \n318.     return -1 \n319.  \n320.  \n321. def isValidMove(board, column): \n322.     # Returns True if there is an empty space in the given column. \n323.     # Otherwise returns False. \n324.     if column < 0 or column >= (BOARDWIDTH) or board[column][0] != EMPTY: \n325.         return False \n326.     return True \n327.  \n328.  \n329. def isBoardFull(board): \n330.     # Returns True if there are no empty spaces anywhere on the board. \n331.     for x in range(BOARDWIDTH): \n332.         for y in range(BOARDHEIGHT): \n333.             if board[x][y] == EMPTY: \n334.                 return False \n335.     return True \n336.  \n337.  \n338. def isWinner(board, tile): \n339.     # check horizontal spaces \n340.     for x in range(BOARDWIDTH - 3): \n341.         for y in range(BOARDHEIGHT): \n342.             if board[x][y] == tile and board[x+1][y] == tile and \nboard[x+2][y] == tile and board[x+3][y] == tile: \n343.                 return True \n344.     # check vertical spaces \n345.     for x in range(BOARDWIDTH): \n346.         for y in range(BOARDHEIGHT - 3): \n347.             if board[x][y] == tile and board[x][y+1] == tile and \nboard[x][y+2] == tile and board[x][y+3] == tile: \n\n\n326    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n348.                 return True \n349.     # check / diagonal spaces \n350.     for x in range(BOARDWIDTH - 3): \n351.         for y in range(3, BOARDHEIGHT): \n352.             if board[x][y] == tile and board[x+1][y-1] == tile and \nboard[x+2][y-2] == tile and board[x+3][y-3] == tile: \n353.                 return True \n354.     # check \\ diagonal spaces \n355.     for x in range(BOARDWIDTH - 3): \n356.         for y in range(BOARDHEIGHT - 3): \n357.             if board[x][y] == tile and board[x+1][y+1] == tile and \nboard[x+2][y+2] == tile and board[x+3][y+3] == tile: \n358.                 return True \n359.     return False \n360.  \n361.  \n362. if __name__ == '__main__': \n363.     main() \n \n \n \n \n\n\nChapter 10 – Four Extra Games    327 \n \nGemgem, a “Bejeweled” Clone \n    \n \n―Bejeweled‖ is a game where gems fall to fill up a board. The player can swap any two adjacent \ngems to try to match three gems in a row (vertically or horizontally, but not diagonally). The \nmatched gems then disappear, making way for new gems to fall from the top. Matching more \nthan three gems, or causing a chain reaction of gem matches will result in more points. The \nplayer’s score slowly drops over time, so the player must constantly be making new matches. The \ngame ends when no possible match can be made on the board. \nSource Code for Gemgem \nThis source code can be downloaded from http://invpy.com/gemgem.py. \nThe image files that Flippy uses can be downloaded from http://invpy.com/gemgemimages.zip. \n  1. # Gemgem (a Bejeweled clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Released under a \"Simplified BSD\" license \n  5.  \n  6. \"\"\" \n  7. This program has \"gem data structures\", which are basically dictionaries \n  8. with the following keys: \n  9.   'x' and 'y' - The location of the gem on the board. 0,0 is the top left. \n 10.                 There is also a ROWABOVEBOARD row that 'y' can be set to, \n 11.                 to indicate that it is above the board. \n 12.   'direction' - one of the four constant variables UP, DOWN, LEFT, RIGHT. \n 13.                 This is the direction the gem is moving. \n 14.   'imageNum'  - The integer index into GEMIMAGES to denote which image \n 15.                 this gem uses. \n 16. \"\"\" \n 17.  \n\n\n328    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 18. import random, time, pygame, sys, copy \n 19. from pygame.locals import * \n 20.  \n 21. FPS = 30 # frames per second to update the screen \n 22. WINDOWWIDTH = 600  # width of the program's window, in pixels \n 23. WINDOWHEIGHT = 600 # height in pixels \n 24.  \n 25. BOARDWIDTH = 8 # how many columns in the board \n 26. BOARDHEIGHT = 8 # how many rows in the board \n 27. GEMIMAGESIZE = 64 # width & height of each space in pixels \n 28.  \n 29. # NUMGEMIMAGES is the number of gem types. You will need .png image \n 30. # files named gem0.png, gem1.png, etc. up to gem(N-1).png. \n 31. NUMGEMIMAGES = 7 \n 32. assert NUMGEMIMAGES >= 5 # game needs at least 5 types of gems to work \n 33.  \n 34. # NUMMATCHSOUNDS is the number of different sounds to choose from when \n 35. # a match is made. The .wav files are named match0.wav, match1.wav, etc. \n 36. NUMMATCHSOUNDS = 6 \n 37.  \n 38. MOVERATE = 25 # 1 to 100, larger num means faster animations \n 39. DEDUCTSPEED = 0.8 # reduces score by 1 point every DEDUCTSPEED seconds. \n 40.  \n 41. #             R    G    B \n 42. PURPLE    = (255,   0, 255) \n 43. LIGHTBLUE = (170, 190, 255) \n 44. BLUE      = (  0,   0, 255) \n 45. RED       = (255, 100, 100) \n 46. BLACK     = (  0,   0,   0) \n 47. BROWN     = ( 85,  65,   0) \n 48. HIGHLIGHTCOLOR = PURPLE # color of the selected gem's border \n 49. BGCOLOR = LIGHTBLUE # background color on the screen \n 50. GRIDCOLOR = BLUE # color of the game board \n 51. GAMEOVERCOLOR = RED # color of the \"Game over\" text. \n 52. GAMEOVERBGCOLOR = BLACK # background color of the \"Game over\" text. \n 53. SCORECOLOR = BROWN # color of the text for the player's score \n 54.  \n 55. # The amount of space to the sides of the board to the edge of the window \n 56. # is used several times, so calculate it once here and store in variables. \n 57. XMARGIN = int((WINDOWWIDTH - GEMIMAGESIZE * BOARDWIDTH) / 2) \n 58. YMARGIN = int((WINDOWHEIGHT - GEMIMAGESIZE * BOARDHEIGHT) / 2) \n 59.  \n 60. # constants for direction values \n 61. UP = 'up' \n 62. DOWN = 'down' \n 63. LEFT = 'left' \n\n\nChapter 10 – Four Extra Games    329 \n \n 64. RIGHT = 'right' \n 65.  \n 66. EMPTY_SPACE = -1 # an arbitrary, nonpositive value \n 67. ROWABOVEBOARD = 'row above board' # an arbitrary, noninteger value \n 68.  \n 69. def main(): \n 70.     global FPSCLOCK, DISPLAYSURF, GEMIMAGES, GAMESOUNDS, BASICFONT, \nBOARDRECTS \n 71.  \n 72.     # Initial set up. \n 73.     pygame.init() \n 74.     FPSCLOCK = pygame.time.Clock() \n 75.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 76.     pygame.display.set_caption('Gemgem') \n 77.     BASICFONT = pygame.font.Font('freesansbold.ttf', 36) \n 78.  \n 79.     # Load the images \n 80.     GEMIMAGES = [] \n 81.     for i in range(1, NUMGEMIMAGES+1): \n 82.         gemImage = pygame.image.load('gem%s.png' % i) \n 83.         if gemImage.get_size() != (GEMIMAGESIZE, GEMIMAGESIZE): \n 84.             gemImage = pygame.transform.smoothscale(gemImage, \n(GEMIMAGESIZE, GEMIMAGESIZE)) \n 85.         GEMIMAGES.append(gemImage) \n 86.  \n 87.     # Load the sounds. \n 88.     GAMESOUNDS = {} \n 89.     GAMESOUNDS['bad swap'] = pygame.mixer.Sound('badswap.wav') \n 90.     GAMESOUNDS['match'] = [] \n 91.     for i in range(NUMMATCHSOUNDS): \n 92.         GAMESOUNDS['match'].append(pygame.mixer.Sound('match%s.wav' % i)) \n 93.  \n 94.     # Create pygame.Rect objects for each board space to \n 95.     # do board-coordinate-to-pixel-coordinate conversions. \n 96.     BOARDRECTS = [] \n 97.     for x in range(BOARDWIDTH): \n 98.         BOARDRECTS.append([]) \n 99.         for y in range(BOARDHEIGHT): \n100.             r = pygame.Rect((XMARGIN + (x * GEMIMAGESIZE), \n101.                              YMARGIN + (y * GEMIMAGESIZE), \n102.                              GEMIMAGESIZE, \n103.                              GEMIMAGESIZE)) \n104.             BOARDRECTS[x].append(r) \n105.  \n106.     while True: \n107.         runGame() \n",
      "page_number": 340,
      "chapter_number": 39,
      "summary": "This chapter covers segment 39 (pages 340-347). Key topics include board, gems, and returns.",
      "keywords": [
        "board",
        "BOARDWIDTH",
        "tile",
        "range",
        "return True",
        "GEMIMAGESIZE",
        "SPACESIZE",
        "column",
        "black",
        "red",
        "BOARDHEIGHT",
        "black tile",
        "color",
        "XMARGIN",
        "YMARGIN"
      ],
      "concepts": [
        "board",
        "gems",
        "returns",
        "column",
        "red",
        "event",
        "color",
        "match",
        "types",
        "games"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 65,
          "title": "Segment 65 (pages 625-632)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 1,
          "title": "Segment 1 (pages 1-13)",
          "relevance_score": 0.62,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 6",
          "chapter": 30,
          "title": "Segment 30 (pages 523-540)",
          "relevance_score": 0.61,
          "method": "api"
        }
      ]
    },
    {
      "number": 40,
      "title": "Segment 40 (pages 348-355)",
      "start_page": 348,
      "end_page": 355,
      "detection_method": "topic_boundary",
      "content": "330    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n108.  \n109.  \n110. def runGame(): \n111.     # Plays through a single game. When the game is over, this function \nreturns. \n112.  \n113.     # initialize the board \n114.     gameBoard = getBlankBoard() \n115.     score = 0 \n116.     fillBoardAndAnimate(gameBoard, [], score) # Drop the initial gems. \n117.  \n118.     # initialize variables for the start of a new game \n119.     firstSelectedGem = None \n120.     lastMouseDownX = None \n121.     lastMouseDownY = None \n122.     gameIsOver = False \n123.     lastScoreDeduction = time.time() \n124.     clickContinueTextSurf = None \n125.  \n126.     while True: # main game loop \n127.         clickedSpace = None \n128.         for event in pygame.event.get(): # event handling loop \n129.             if event.type == QUIT or (event.type == KEYUP and event.key == \nK_ESCAPE): \n130.                 pygame.quit() \n131.                 sys.exit() \n132.             elif event.type == KEYUP and event.key == K_BACKSPACE: \n133.                 return # start a new game \n134.  \n135.             elif event.type == MOUSEBUTTONUP: \n136.                 if gameIsOver: \n137.                     return # after games ends, click to start a new game \n138.  \n139.                 if event.pos == (lastMouseDownX, lastMouseDownY): \n140.                     # This event is a mouse click, not the end of a mouse \ndrag. \n141.                     clickedSpace = checkForGemClick(event.pos) \n142.                 else: \n143.                     # this is the end of a mouse drag \n144.                     firstSelectedGem = checkForGemClick((lastMouseDownX, \nlastMouseDownY)) \n145.                     clickedSpace = checkForGemClick(event.pos) \n146.                     if not firstSelectedGem or not clickedSpace: \n147.                         # if not part of a valid drag, deselect both \n148.                         firstSelectedGem = None \n149.                         clickedSpace = None \n\n\nChapter 10 – Four Extra Games    331 \n \n150.             elif event.type == MOUSEBUTTONDOWN: \n151.                 # this is the start of a mouse click or mouse drag \n152.                 lastMouseDownX, lastMouseDownY = event.pos \n153.  \n154.         if clickedSpace and not firstSelectedGem: \n155.             # This was the first gem clicked on. \n156.             firstSelectedGem = clickedSpace \n157.         elif clickedSpace and firstSelectedGem: \n158.             # Two gems have been clicked on and selected. Swap the gems. \n159.             firstSwappingGem, secondSwappingGem = \ngetSwappingGems(gameBoard, firstSelectedGem, clickedSpace) \n160.             if firstSwappingGem == None and secondSwappingGem == None: \n161.                 # If both are None, then the gems were not adjacent \n162.                 firstSelectedGem = None # deselect the first gem \n163.                 continue \n164.  \n165.             # Show the swap animation on the screen. \n166.             boardCopy = getBoardCopyMinusGems(gameBoard, \n(firstSwappingGem, secondSwappingGem)) \n167.             animateMovingGems(boardCopy, [firstSwappingGem, \nsecondSwappingGem], [], score) \n168.  \n169.             # Swap the gems in the board data structure. \n170.             gameBoard[firstSwappingGem['x']][firstSwappingGem['y']] = \nsecondSwappingGem['imageNum'] \n171.             gameBoard[secondSwappingGem['x']][secondSwappingGem['y']] = \nfirstSwappingGem['imageNum'] \n172.  \n173.             # See if this is a matching move. \n174.             matchedGems = findMatchingGems(gameBoard) \n175.             if matchedGems == []: \n176.                 # Was not a matching move; swap the gems back \n177.                 GAMESOUNDS['bad swap'].play() \n178.                 animateMovingGems(boardCopy, [firstSwappingGem, \nsecondSwappingGem], [], score) \n179.                 gameBoard[firstSwappingGem['x']][firstSwappingGem['y']] = \nfirstSwappingGem['imageNum'] \n180.                 gameBoard[secondSwappingGem['x']][secondSwappingGem['y']] \n= secondSwappingGem['imageNum'] \n181.             else: \n182.                 # This was a matching move. \n183.                 scoreAdd = 0 \n184.                 while matchedGems != []: \n185.                     # Remove matched gems, then pull down the board. \n186.  \n\n\n332    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n187.                     # points is a list of dicts that tells \nfillBoardAndAnimate() \n188.                     # where on the screen to display text to show how many  \n189.                     # points the player got. points is a list because if  \n190.                     # the player gets multiple matches, then multiple \npoints text should appear. \n191.                     points = [] \n192.                     for gemSet in matchedGems: \n193.                         scoreAdd += (10 + (len(gemSet) - 3) * 10) \n194.                         for gem in gemSet: \n195.                             gameBoard[gem[0]][gem[1]] = EMPTY_SPACE \n196.                         points.append({'points': scoreAdd, \n197.                                        'x': gem[0] * GEMIMAGESIZE + \nXMARGIN, \n198.                                        'y': gem[1] * GEMIMAGESIZE + \nYMARGIN}) \n199.                     random.choice(GAMESOUNDS['match']).play() \n200.                     score += scoreAdd \n201.  \n202.                     # Drop the new gems. \n203.                     fillBoardAndAnimate(gameBoard, points, score) \n204.  \n205.                     # Check if there are any new matches. \n206.                     matchedGems = findMatchingGems(gameBoard) \n207.             firstSelectedGem = None \n208.  \n209.             if not canMakeMove(gameBoard): \n210.                 gameIsOver = True \n211.  \n212.         # Draw the board. \n213.         DISPLAYSURF.fill(BGCOLOR) \n214.         drawBoard(gameBoard) \n215.         if firstSelectedGem != None: \n216.             highlightSpace(firstSelectedGem['x'], firstSelectedGem['y']) \n217.         if gameIsOver: \n218.             if clickContinueTextSurf == None: \n219.                 # Only render the text once. In future iterations, just \n220.                 # use the Surface object already in clickContinueTextSurf \n221.                 clickContinueTextSurf = BASICFONT.render('Final Score: %s \n(Click to continue)' % (score), 1, GAMEOVERCOLOR, GAMEOVERBGCOLOR) \n222.                 clickContinueTextRect = clickContinueTextSurf.get_rect() \n223.                 clickContinueTextRect.center = int(WINDOWWIDTH / 2), \nint(WINDOWHEIGHT / 2) \n224.             DISPLAYSURF.blit(clickContinueTextSurf, clickContinueTextRect) \n225.         elif score > 0 and time.time() - lastScoreDeduction > DEDUCTSPEED: \n226.             # score drops over time \n\n\nChapter 10 – Four Extra Games    333 \n \n227.             score -= 1 \n228.             lastScoreDeduction = time.time() \n229.         drawScore(score) \n230.         pygame.display.update() \n231.         FPSCLOCK.tick(FPS) \n232.  \n233.  \n234. def getSwappingGems(board, firstXY, secondXY): \n235.     # If the gems at the (X, Y) coordinates of the two gems are adjacent, \n236.     # then their 'direction' keys are set to the appropriate direction \n237.     # value to be swapped with each other. \n238.     # Otherwise, (None, None) is returned. \n239.     firstGem = {'imageNum': board[firstXY['x']][firstXY['y']], \n240.                 'x': firstXY['x'], \n241.                 'y': firstXY['y']} \n242.     secondGem = {'imageNum': board[secondXY['x']][secondXY['y']], \n243.                  'x': secondXY['x'], \n244.                  'y': secondXY['y']} \n245.     highlightedGem = None \n246.     if firstGem['x'] == secondGem['x'] + 1 and firstGem['y'] == \nsecondGem['y']: \n247.         firstGem['direction'] = LEFT \n248.         secondGem['direction'] = RIGHT \n249.     elif firstGem['x'] == secondGem['x'] - 1 and firstGem['y'] == \nsecondGem['y']: \n250.         firstGem['direction'] = RIGHT \n251.         secondGem['direction'] = LEFT \n252.     elif firstGem['y'] == secondGem['y'] + 1 and firstGem['x'] == \nsecondGem['x']: \n253.         firstGem['direction'] = UP \n254.         secondGem['direction'] = DOWN \n255.     elif firstGem['y'] == secondGem['y'] - 1 and firstGem['x'] == \nsecondGem['x']: \n256.         firstGem['direction'] = DOWN \n257.         secondGem['direction'] = UP \n258.     else: \n259.         # These gems are not adjacent and can't be swapped. \n260.         return None, None \n261.     return firstGem, secondGem \n262.  \n263.  \n264. def getBlankBoard(): \n265.     # Create and return a blank board data structure. \n266.     board = [] \n267.     for x in range(BOARDWIDTH): \n268.         board.append([EMPTY_SPACE] * BOARDHEIGHT) \n\n\n334    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n269.     return board \n270.  \n271.  \n272. def canMakeMove(board): \n273.     # Return True if the board is in a state where a matching \n274.     # move can be made on it. Otherwise return False. \n275.  \n276.     # The patterns in oneOffPatterns represent gems that are configured \n277.     # in a way where it only takes one move to make a triplet. \n278.     oneOffPatterns = (((0,1), (1,0), (2,0)), \n279.                       ((0,1), (1,1), (2,0)), \n280.                       ((0,0), (1,1), (2,0)), \n281.                       ((0,1), (1,0), (2,1)), \n282.                       ((0,0), (1,0), (2,1)), \n283.                       ((0,0), (1,1), (2,1)), \n284.                       ((0,0), (0,2), (0,3)), \n285.                       ((0,0), (0,1), (0,3))) \n286.  \n287.     # The x and y variables iterate over each space on the board. \n288.     # If we use + to represent the currently iterated space on the \n289.     # board, then this pattern: ((0,1), (1,0), (2,0))refers to identical \n290.     # gems being set up like this: \n291.     # \n292.     #     +A \n293.     #     B \n294.     #     C \n295.     # \n296.     # That is, gem A is offset from the + by (0,1), gem B is offset \n297.     # by (1,0), and gem C is offset by (2,0). In this case, gem A can \n298.     # be swapped to the left to form a vertical three-in-a-row triplet. \n299.     # \n300.     # There are eight possible ways for the gems to be one move \n301.     # away from forming a triple, hence oneOffPattern has 8 patterns. \n302.  \n303.     for x in range(BOARDWIDTH): \n304.         for y in range(BOARDHEIGHT): \n305.             for pat in oneOffPatterns: \n306.                 # check each possible pattern of \"match in next move\" to \n307.                 # see if a possible move can be made. \n308.                 if (getGemAt(board, x+pat[0][0], y+pat[0][1]) == \\ \n309.                     getGemAt(board, x+pat[1][0], y+pat[1][1]) == \\ \n310.                     getGemAt(board, x+pat[2][0], y+pat[2][1]) != None) or \n\\ \n311.                    (getGemAt(board, x+pat[0][1], y+pat[0][0]) == \\ \n312.                     getGemAt(board, x+pat[1][1], y+pat[1][0]) == \\ \n313.                     getGemAt(board, x+pat[2][1], y+pat[2][0]) != None): \n\n\nChapter 10 – Four Extra Games    335 \n \n314.                     return True # return True the first time you find a \npattern \n315.     return False \n316.  \n317.  \n318. def drawMovingGem(gem, progress): \n319.     # Draw a gem sliding in the direction that its 'direction' key \n320.     # indicates. The progress parameter is a number from 0 (just \n321.     # starting) to 100 (slide complete). \n322.     movex = 0 \n323.     movey = 0 \n324.     progress *= 0.01 \n325.  \n326.     if gem['direction'] == UP: \n327.         movey = -int(progress * GEMIMAGESIZE) \n328.     elif gem['direction'] == DOWN: \n329.         movey = int(progress * GEMIMAGESIZE) \n330.     elif gem['direction'] == RIGHT: \n331.         movex = int(progress * GEMIMAGESIZE) \n332.     elif gem['direction'] == LEFT: \n333.         movex = -int(progress * GEMIMAGESIZE) \n334.  \n335.     basex = gem['x'] \n336.     basey = gem['y'] \n337.     if basey == ROWABOVEBOARD: \n338.         basey = -1 \n339.  \n340.     pixelx = XMARGIN + (basex * GEMIMAGESIZE) \n341.     pixely = YMARGIN + (basey * GEMIMAGESIZE) \n342.     r = pygame.Rect( (pixelx + movex, pixely + movey, GEMIMAGESIZE, \nGEMIMAGESIZE) ) \n343.     DISPLAYSURF.blit(GEMIMAGES[gem['imageNum']], r) \n344.  \n345.  \n346. def pullDownAllGems(board): \n347.     # pulls down gems on the board to the bottom to fill in any gaps \n348.     for x in range(BOARDWIDTH): \n349.         gemsInColumn = [] \n350.         for y in range(BOARDHEIGHT): \n351.             if board[x][y] != EMPTY_SPACE: \n352.                 gemsInColumn.append(board[x][y]) \n353.         board[x] = ([EMPTY_SPACE] * (BOARDHEIGHT - len(gemsInColumn))) + \ngemsInColumn \n354.  \n355.  \n356. def getGemAt(board, x, y): \n\n\n336    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n357.     if x < 0 or y < 0 or x >= BOARDWIDTH or y >= BOARDHEIGHT: \n358.         return None \n359.     else: \n360.         return board[x][y] \n361.  \n362.  \n363. def getDropSlots(board): \n364.     # Creates a \"drop slot\" for each column and fills the slot with a \n365.     # number of gems that that column is lacking. This function assumes \n366.     # that the gems have been gravity dropped already. \n367.     boardCopy = copy.deepcopy(board) \n368.     pullDownAllGems(boardCopy) \n369.  \n370.     dropSlots = [] \n371.     for i in range(BOARDWIDTH): \n372.         dropSlots.append([]) \n373.  \n374.     # count the number of empty spaces in each column on the board \n375.     for x in range(BOARDWIDTH): \n376.         for y in range(BOARDHEIGHT-1, -1, -1): # start from bottom, going \nup \n377.             if boardCopy[x][y] == EMPTY_SPACE: \n378.                 possibleGems = list(range(len(GEMIMAGES))) \n379.                 for offsetX, offsetY in ((0, -1), (1, 0), (0, 1), (-1, \n0)): \n380.                     # Narrow down the possible gems we should put in the \n381.                     # blank space so we don't end up putting an two of \n382.                     # the same gems next to each other when they drop. \n383.                     neighborGem = getGemAt(boardCopy, x + offsetX, y + \noffsetY) \n384.                     if neighborGem != None and neighborGem in \npossibleGems: \n385.                         possibleGems.remove(neighborGem) \n386.  \n387.                 newGem = random.choice(possibleGems) \n388.                 boardCopy[x][y] = newGem \n389.                 dropSlots[x].append(newGem) \n390.     return dropSlots \n391.  \n392.  \n393. def findMatchingGems(board): \n394.     gemsToRemove = [] # a list of lists of gems in matching triplets that \nshould be removed \n395.     boardCopy = copy.deepcopy(board) \n396.  \n397.     # loop through each space, checking for 3 adjacent identical gems \n\n\nChapter 10 – Four Extra Games    337 \n \n398.     for x in range(BOARDWIDTH): \n399.         for y in range(BOARDHEIGHT): \n400.             # look for horizontal matches \n401.             if getGemAt(boardCopy, x, y) == getGemAt(boardCopy, x + 1, y) \n== getGemAt(boardCopy, x + 2, y) and getGemAt(boardCopy, x, y) != EMPTY_SPACE: \n402.                 targetGem = boardCopy[x][y] \n403.                 offset = 0 \n404.                 removeSet = [] \n405.                 while getGemAt(boardCopy, x + offset, y) == targetGem: \n406.                     # keep checking, in case there's more than 3 gems in a \nrow \n407.                     removeSet.append((x + offset, y)) \n408.                     boardCopy[x + offset][y] = EMPTY_SPACE \n409.                     offset += 1 \n410.                 gemsToRemove.append(removeSet) \n411.  \n412.             # look for vertical matches \n413.             if getGemAt(boardCopy, x, y) == getGemAt(boardCopy, x, y + 1) \n== getGemAt(boardCopy, x, y + 2) and getGemAt(boardCopy, x, y) != EMPTY_SPACE: \n414.                 targetGem = boardCopy[x][y] \n415.                 offset = 0 \n416.                 removeSet = [] \n417.                 while getGemAt(boardCopy, x, y + offset) == targetGem: \n418.                     # keep checking if there's more than 3 gems in a row \n419.                     removeSet.append((x, y + offset)) \n420.                     boardCopy[x][y + offset] = EMPTY_SPACE \n421.                     offset += 1 \n422.                 gemsToRemove.append(removeSet) \n423.  \n424.     return gemsToRemove \n425.  \n426.  \n427. def highlightSpace(x, y): \n428.     pygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, BOARDRECTS[x][y], 4) \n429.  \n430.  \n431. def getDroppingGems(board): \n432.     # Find all the gems that have an empty space below them \n433.     boardCopy = copy.deepcopy(board) \n434.     droppingGems = [] \n435.     for x in range(BOARDWIDTH): \n436.         for y in range(BOARDHEIGHT - 2, -1, -1): \n437.             if boardCopy[x][y + 1] == EMPTY_SPACE and boardCopy[x][y] != \nEMPTY_SPACE: \n438.                 # This space drops if not empty but the space below it is \n",
      "page_number": 348,
      "chapter_number": 40,
      "summary": "This chapter covers segment 40 (pages 348-355). Key topics include gems, board. When the game is over, this function \nreturns.",
      "keywords": [
        "board",
        "boardCopy",
        "gems",
        "SPACE",
        "gem",
        "getGemAt",
        "EMPTY",
        "gameBoard",
        "GEMIMAGESIZE",
        "secondGem",
        "firstGem",
        "range",
        "direction",
        "firstSelectedGem",
        "BOARDWIDTH"
      ],
      "concepts": [
        "gems",
        "gem",
        "board",
        "score",
        "returns",
        "gameboard",
        "space",
        "matching",
        "matches",
        "game"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.58,
          "method": "api"
        }
      ]
    },
    {
      "number": 41,
      "title": "Segment 41 (pages 356-363)",
      "start_page": 356,
      "end_page": 363,
      "detection_method": "topic_boundary",
      "content": "338    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n439.                 droppingGems.append( {'imageNum': boardCopy[x][y], 'x': x, \n'y': y, 'direction': DOWN} ) \n440.                 boardCopy[x][y] = EMPTY_SPACE \n441.     return droppingGems \n442.  \n443.  \n444. def animateMovingGems(board, gems, pointsText, score): \n445.     # pointsText is a dictionary with keys 'x', 'y', and 'points' \n446.     progress = 0 # progress at 0 represents beginning, 100 means finished. \n447.     while progress < 100: # animation loop \n448.         DISPLAYSURF.fill(BGCOLOR) \n449.         drawBoard(board) \n450.         for gem in gems: # Draw each gem. \n451.             drawMovingGem(gem, progress) \n452.         drawScore(score) \n453.         for pointText in pointsText: \n454.             pointsSurf = BASICFONT.render(str(pointText['points']), 1, \nSCORECOLOR) \n455.             pointsRect = pointsSurf.get_rect() \n456.             pointsRect.center = (pointText['x'], pointText['y']) \n457.             DISPLAYSURF.blit(pointsSurf, pointsRect) \n458.  \n459.         pygame.display.update() \n460.         FPSCLOCK.tick(FPS) \n461.         progress += MOVERATE # progress the animation a little bit more \nfor the next frame \n462.  \n463.  \n464. def moveGems(board, movingGems): \n465.     # movingGems is a list of dicts with keys x, y, direction, imageNum \n466.     for gem in movingGems: \n467.         if gem['y'] != ROWABOVEBOARD: \n468.             board[gem['x']][gem['y']] = EMPTY_SPACE \n469.             movex = 0 \n470.             movey = 0 \n471.             if gem['direction'] == LEFT: \n472.                 movex = -1 \n473.             elif gem['direction'] == RIGHT: \n474.                 movex = 1 \n475.             elif gem['direction'] == DOWN: \n476.                 movey = 1 \n477.             elif gem['direction'] == UP: \n478.                 movey = -1 \n479.             board[gem['x'] + movex][gem['y'] + movey] = gem['imageNum'] \n480.         else: \n481.             # gem is located above the board (where new gems come from) \n\n\nChapter 10 – Four Extra Games    339 \n \n482.             board[gem['x']][0] = gem['imageNum'] # move to top row \n483.  \n484.  \n485. def fillBoardAndAnimate(board, points, score): \n486.     dropSlots = getDropSlots(board) \n487.     while dropSlots != [[]] * BOARDWIDTH: \n488.         # do the dropping animation as long as there are more gems to drop \n489.         movingGems = getDroppingGems(board) \n490.         for x in range(len(dropSlots)): \n491.             if len(dropSlots[x]) != 0: \n492.                 # cause the lowest gem in each slot to begin moving in the \nDOWN direction \n493.                 movingGems.append({'imageNum': dropSlots[x][0], 'x': x, \n'y': ROWABOVEBOARD, 'direction': DOWN}) \n494.  \n495.         boardCopy = getBoardCopyMinusGems(board, movingGems) \n496.         animateMovingGems(boardCopy, movingGems, points, score) \n497.         moveGems(board, movingGems) \n498.  \n499.         # Make the next row of gems from the drop slots \n500.         # the lowest by deleting the previous lowest gems. \n501.         for x in range(len(dropSlots)): \n502.             if len(dropSlots[x]) == 0: \n503.                 continue \n504.             board[x][0] = dropSlots[x][0] \n505.             del dropSlots[x][0] \n506.  \n507.  \n508. def checkForGemClick(pos): \n509.     # See if the mouse click was on the board \n510.     for x in range(BOARDWIDTH): \n511.         for y in range(BOARDHEIGHT): \n512.             if BOARDRECTS[x][y].collidepoint(pos[0], pos[1]): \n513.                 return {'x': x, 'y': y} \n514.     return None # Click was not on the board. \n515.  \n516.  \n517. def drawBoard(board): \n518.     for x in range(BOARDWIDTH): \n519.         for y in range(BOARDHEIGHT): \n520.             pygame.draw.rect(DISPLAYSURF, GRIDCOLOR, BOARDRECTS[x][y], 1) \n521.             gemToDraw = board[x][y] \n522.             if gemToDraw != EMPTY_SPACE: \n523.                 DISPLAYSURF.blit(GEMIMAGES[gemToDraw], BOARDRECTS[x][y]) \n524.  \n525.  \n\n\n340    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n526. def getBoardCopyMinusGems(board, gems): \n527.     # Creates and returns a copy of the passed board data structure, \n528.     # with the gems in the \"gems\" list removed from it. \n529.     # \n530.     # Gems is a list of dicts, with keys x, y, direction, imageNum \n531.  \n532.     boardCopy = copy.deepcopy(board) \n533.  \n534.     # Remove some of the gems from this board data structure copy. \n535.     for gem in gems: \n536.         if gem['y'] != ROWABOVEBOARD: \n537.             boardCopy[gem['x']][gem['y']] = EMPTY_SPACE \n538.     return boardCopy \n539.  \n540.  \n541. def drawScore(score): \n542.     scoreImg = BASICFONT.render(str(score), 1, SCORECOLOR) \n543.     scoreRect = scoreImg.get_rect() \n544.     scoreRect.bottomleft = (10, WINDOWHEIGHT - 6) \n545.     DISPLAYSURF.blit(scoreImg, scoreRect) \n546.  \n547.  \n548. if __name__ == '__main__': \n549.     main() \nSummary \nI hope these game programs have given you your own ideas about what games you’d like to make \nand how you can write the code for them. Even if you don’t have any ideas of your own, it’s great \npractice to try to program clones of other games you’ve played. \nHere are several websites that can teach you more about programming Python: \n \nhttp://pygame.org – The official Pygame website has the source code to hundreds of \ngames that people have written that make use of the Pygame library. You can learn a lot \nby downloading and reading other people’s source code. \n \nhttp://python.org/doc/ - More Python tutorials and the documentation of all the Python \nmodules and functions. \n \nhttp://pygame.org/docs/ - Complete documentation on the modules and functions for \nPygame \n \nhttp://reddit.com/r/learnpython and http://reddit.com/r/learnprogramming have several \nusers that could help you with finding resources to learn programming. \n\n\nChapter 10 – Four Extra Games    341 \n \n \nhttp://inventwithpython.com/pygame - This book's website, which includes all the source \ncode for these programs and additional information. This site also has the image and \nsound files used in the Pygame programs.  \n \nhttp://inventwithpython.com - The website for the book ―Invent Your Own Computer \nGames with Python‖, which covers basic Python programming. \n \nhttp://invpy.com/wiki - A wiki that covers individual Python programming concepts that \nyou can look up if you need to learn about something specific. \n \nhttp://invpy.com/traces - A web application that helps you trace through the execution of \nthe programs in this book, step by step. \n \nhttp://invpy.com/videos - Videos that accompany the programs in this book. \n \nhttp://gamedevlessons.com - A helpful website about how to design and program video \ngames. \n \nal@inventwithpython.com - My email address. Feel free to email me your questions \nabout this book or about Python programming. \nOr you can find out more about Python by searching the World Wide Web. Go to the search \nwebsite http://google.com and search for ―Python programming‖ or ―Python tutorials‖ to find \nweb sites that can teach you more about Python programming. \nNow get going and invent your own games. And good luck! \n \n \n\n\n342    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nGLOSSARY \nAlpha Value - The amount of transparency for a color. In Pygame, alpha values range from 0 \n(completely transparent) to 255 (completely opaque). \nAnti-Aliasing - A technique for making shapes look smoother and less blocky by adding fuzzy \ncolors to their edges. Anti-aliased drawings look smooth. Aliased drawings look blocky. \nAttributes - A variable that is part of an object. For example, Rect objects have members such as \ntop and left which hold integer values for the Rect object. \nBackwards Compatibility - Writing code that is compatible with older versions of software. \nPython version 3 has some backwards-incompatible features with Python version 2, but it is \npossible to write Python 3 programs that are backwards-compatible with Python 2. \nBase Case - In recursion, the base case is the condition that stops further recursive function calls. \nA base case is necessary to prevent stack overflow errors. \nBlitting - A word that means copying the image on one Surface object to another. In \nprogramming in general, it means to copy one image to another image. \nBounding Rectangle - The smallest rectangle that can be drawn around another shape. \nCamera - A view of a particular part of the game world. Cameras are used when the game world \nis too large to fit on the player's screen. \nCaption - In programming, the caption is the text on the title bar of the window. In Pygame, the \ncaption can be set with the pygame.display.set_caption() function. \nCLI - See, Command Line Interface \nCommand Line Interface - A program that the user can use by seeing text on the screen and \ntyping text through the keyboard. Old computers used to be able to only run CLI programs, but \nnew computers have Graphical User Interfaces. \nConstructor Function - The function that creates a new object. In Python, these functions have \nthe same name as the kind of objects they produce. For example, pygame.Rect() creates Rect \nobjects. \nDisplay Surface - The Surface object returned by the call to \npygame.display.set_mode(). This Surface object is special because anything drawn on it \n\n\nGlossary    343 \n \nwith the Pygame drawing or blitting functions will appear on the screen when \npygame.display.update() is called. \nDrawing Primitives - The name for the basic shape-drawing functions in Pygame. Drawing \nprimitives include rectangles, lines, and ellipses. Drawing primitives do not include images like \nthe ones in .png or .jpg files. \nEvent Handling - The code that performs actions in response to Event objects that have been \ngenerated by the user, such as key presses or mouse clicks. \nEvent Handling Loop - The event handling code is usually inside a loop to handle each of the \nevents that have been generated since the last time the event handling loop was executed. \nEvent Queue - When events such as mouse clicks or key presses happen, Pygame stores them in \nan internal queue data structure. Events can be removed and retrieved from the event queue by \ncalling pygame.event.get(). \nFPS - See, Frames Per Second \nFrame - A single image that is displayed on the screen as part of an animation. Animated \ngraphics will be composed of many frames, each shown for a split second. \nFrame Rate - See, Refresh Rate \nFrames Per Second - The measure of how many frames of an animation are displayed per \nsecond. It is common for games to be run at 30 frames per second or more. \nGame Loop - The game loop contains code that performs event handling, updates the game \nworld's state, and draws the game world's state to the screen. This is done many times a second. \nGame State - The entire collection of values that make up the game world. This can include \ninformation about the player's character, which pieces are on a board, or the score and level \nnumber. \nGraphical User Interface - A program that displays graphics to the user for output and can \naccept keyboard presses and mouse clicks for input. \nGUI - See, Graphical User Interface \nImmutable - Not changeable or modifiable. In Python, list values are mutable and tuple values \nare immutable. \nInteractive Shell - A program (part of IDLE) that executes Python instructions one at a time. The \ninteractive shell is a good way to experiment with what a line of code does. \n\n\n344    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nInterpreter - The software that executes instructions written in the Python programming \nlanguage. On Windows, this is python.exe. When someone says, \"Python runs this program\", they \nmean \"the Python interpreter software runs this program.\" \nMagic Numbers - Integers or floating-point values used in a program without explanation. Magic \nnumbers should be replaced by constant variables with descriptive names to increase readability. \nMain Loop - See, Game Loop \nMember Variable - See, Attributes. \nModulus Operator - In Python, the modulus operator is the % sign. It performs \"remainder\" \narithmetic. For example, since 22 / 7 is ―3 remainder 1‖, then 22 % 7 is 1. \nMultidimensional - Having more than one dimension. In Python, this usually refers to when a \nlist contains another list, or a dictionary contains a tuple (which in turn could contain other lists, \ntuples, or dictionaries.) \nMutable - Changeable or modifiable. In Python, list values are mutable and tuple values are \nimmutable. \nPi - The number of diameter lengths of a circle that can fit along the outside circumference. Pi is \nthe same number no matter what the size of the circle is. This value is available in the math \nmodule as math.pi, which is the float value 3.1415926535897931. \nPixels - Stands for \"picture element\". A pixel is a single square of color on the computer screen. \nThe screen is made up of hundreds of thousands of pixels which can be set to different colors to \nform an image. \nPoints - A point in Python is usually represented as a tuple of two integers (or float values) to \nrepresent the X and Y coordinates of a position on a 2D surface. \nProperties - See, Attributes. \nReal-time - A program that runs continuously and does not wait for the player to do something is \nsaid to run in real-time. \nRecursive Call - The function call in a recursive function that calls that same function. \nRecursive Function - A function that calls itself. \nRefresh Rate - The frequency that the computer screen updates its image. A high or fast refresh \nrate will make animations appear smoothly, while a low or slow refresh rate will make animation \nlook choppy. Refresh rate is measured in FPS or hertz (which mean the same thing). \n\n\nGlossary    345 \n \nRGB Values - An RGB value is an exact value of a particular color. RGB stands for red, green \nblue. In Pygame, an RGB value is a tuple of three integers (all between 0 and 255) which \nrepresent the amount of red, green, and blue are in the color. \nShell - See, Interactive Shell. \nSine - A mathematical function that produces a wavey line when drawn on a graph. Python has a \nsine function in the math module: math.sin(). \nSprites - A name given for a picture of something. Games commonly have a sprite for each kind \nof object in the game. \nStack Overflow - An error caused when a recursive function does not have a base case. \nSyntactic Sugar - A bit of code that is written to make the program more readable, even though \nit isn't necessary for the program to work. \nTile Sprites - Tiles are a kind of sprite designed to be drawn on a 2D grid. They are usually \nimages of the background, such as floors or walls. \nTitle Bar - The bar along the top of programs that usually contain the program's caption and \nclose button. The style of the title bar varies between operating systems. \nX-axis - The horizontal arrangement of numbers used in cartesian coordinate systems. The X \ncoordinates get smaller going to the left and larger going to the right. \nY-axis - The vertical arrangement of numbers used in cartesian coordinate systems. The Y \ncoordinates get smaller going up and larger going down. (This is the opposite of how the Y-axis \nworks in mathematics.) \n \n",
      "page_number": 356,
      "chapter_number": 41,
      "summary": "progress = 0 # progress at 0 represents beginning, 100 means finished Key topics include python, board, and gems. Covers function.",
      "keywords": [
        "Python",
        "gem",
        "board",
        "Python programming",
        "gems",
        "game",
        "Pygame",
        "function",
        "program",
        "game world",
        "Game Loop",
        "code",
        "programming",
        "loop",
        "direction"
      ],
      "concepts": [
        "python",
        "board",
        "gems",
        "gem",
        "program",
        "programming",
        "games",
        "functions",
        "function",
        "event"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 1",
          "chapter": 26,
          "title": "Segment 26 (pages 238-247)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 54,
          "title": "Segment 54 (pages 1084-1102)",
          "relevance_score": 0.58,
          "method": "api"
        }
      ]
    },
    {
      "number": 42,
      "title": "Segment 42 (pages 364-365)",
      "start_page": 364,
      "end_page": 365,
      "detection_method": "topic_boundary",
      "content": "346    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n \n\n\nAbout the Author    347 \n \nABOUT THE AUTHOR \n \nAlbert Sweigart (but you can call him Al), is a software developer in San Francisco, California \nwho enjoys bicycling, volunteering, haunting coffee shops, and making useful software. ―Making \nGames with Python & Pygame‖ is his second book. \nHis first book, ―Invent Your Own Computer Games with Python‖ can be read online at \nhttp://inventwithpython.com. \nHe is originally from Houston, Texas. He finally put his University of Texas at Austin computer \nscience degree in a frame. He laughs out loud when watching park squirrels, which makes people \nthink he’s a simpleton. \n \nEmail: al@inventwithpython.com \n \nBlog: http://coffeeghost.net \n \nTwitter: @AlSweigart \n",
      "page_number": 364,
      "chapter_number": 42,
      "summary": "This chapter covers segment 42 (pages 364-365). Key topics include email, book, and software. ―Making \nGames with Python & Pygame‖ is his second book.",
      "keywords": [
        "AUTHOR Albert Sweigart",
        "haunting coffee shops",
        "Albert Sweigart",
        "San Francisco",
        "AUTHOR Albert",
        "California who enjoys",
        "developer in San",
        "Games with Python",
        "enjoys bicycling",
        "haunting coffee",
        "coffee shops",
        "software developer",
        "Author",
        "Making Games",
        "Sweigart"
      ],
      "concepts": [
        "email",
        "book",
        "software",
        "bicycling",
        "twitter",
        "albert",
        "texas",
        "houston",
        "author",
        "blog"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 42,
          "title": "Segment 42 (pages 849-853)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 2,
          "title": "Segment 2 (pages 19-41)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 25,
          "title": "Segment 25 (pages 238-245)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "Python Distilled",
          "chapter": 39,
          "title": "Segment 39 (pages 353-355)",
          "relevance_score": 0.53,
          "method": "api"
        }
      ]
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "chapter": null,
      "content": " \n \nMaking Games with \nPython & Pygame \n \n \n \n \n \n \n \n \n \n \n \n \n \nBy Al Sweigart \n \n",
      "content_length": 84,
      "extraction_method": "Direct"
    },
    {
      "page_number": 2,
      "chapter": null,
      "content": " \n \nEmail questions to the author: al@inventwithpython.com \n \nCopyright © 2012 by Albert Sweigart \nSome Rights Reserved. ―Making Games with Python & Pygame‖) is licensed under a Creative \nCommons Attribution-Noncommercial-Share Alike 3.0 United States License. \nYou are free: \n To Share — to copy, distribute, display, and perform the work \n To Remix — to make derivative works \nUnder the following conditions: \n Attribution — You must attribute the work in the manner specified by the author or \nlicensor (but not in any way that suggests that they endorse you or your use of the work). \n(Visibly include the title and author's name in any excerpts of this work.) \n Noncommercial — You may not use this work for commercial purposes. \n Share Alike — If you alter, transform, or build upon this work, you may distribute \nthe resulting work only under the same or similar license to this one. \n \nThis summary is located here: http://creativecommons.org/licenses/by-nc-sa/3.0/us/ \n \nYour fair use and other rights are in no way affected by the above. There is a human-readable \nsummary of the Legal Code (the full license), located here: \nhttp://creativecommons.org/licenses/by-nc-sa/3.0/us/legalcode \n \nBook Version 2 \nIf you've downloaded this book from a torrent, it’s probably out of date. Go \nto http://inventwithpython.com/pygame to download the latest version.  \n \nISBN (978-1469901732) \n1st Edition \n \n",
      "content_length": 1407,
      "extraction_method": "Direct"
    },
    {
      "page_number": 3,
      "chapter": null,
      "content": " \n \n \n \n \n \nFor Calvin Chaos \n \n",
      "content_length": 32,
      "extraction_method": "Direct"
    },
    {
      "page_number": 4,
      "chapter": null,
      "content": " \n \nEmail questions to the author: al@inventwithpython.com \n \n \n",
      "content_length": 64,
      "extraction_method": "Direct"
    },
    {
      "page_number": 5,
      "chapter": null,
      "content": "Who is this book for?    i \n \n \nWHO IS THIS BOOK FOR?  \nWhen you get down to it, programming video games is just about lighting up pixels to make \npretty pictures appear on the screen in response to keyboard and mouse input. \nAnd there are very few things that are as fun. \nThis book will teach you how to make graphical computer games in the Python programming \nlanguage using the Pygame library. This book assumes you know a little bit about Python or \nprogramming in general. If you don’t know how to program, you can learn by downloading the \nfree book ―Invent Your Own Computer Games with Python‖ from http://inventwithpython.com. \nOr you can jump right into this book and mostly pick it up along the way. \nThis book is for the intermediate programmer who has learned what variables and loops are, but \nnow wants to know, ―What do actual game programs look like?‖ There was a long gap after I first \nlearned programming but didn’t really know how to use that skill to make something cool. It’s \nmy hope that the games in this book will give you enough ideas about how programs work to \nprovide a foundation to implement your own games. \nThe full text of this book is available in HTML or PDF format at \nhttp://inventwithpython.com/pygame. \n-Al Sweigart \n",
      "content_length": 1259,
      "extraction_method": "Direct"
    },
    {
      "page_number": 6,
      "chapter": null,
      "content": "ii    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nABOUT THIS BOOK \nHello! This book will teach you how to make graphical computer games with the Pygame \nframework (also called the Pygame library) in the Python programming language. Pygame makes \nit easy to create programs with 2D graphics. Both Python and the Pygame framework can be \ndownloaded for free from http://python.org and http://pygame.org. All you need is a computer \nand this book to begin making your own games. \nThis book is an intermediate programming book. If you are completely new to programming, \nyou can still try to follow along with the source code examples and figure out how programming \nworks. However, it might be easier to learn how to program in Python first. ―Invent Your Own \nComputer Games with Python‖ is a book that is available completely for free from \nhttp://inventwithpython.com. That book teaches programming by making non-graphical, text-\nbased games for complete beginners, and also has a few chapters about using the Pygame library. \nHowever, if you already know how to program in Python (or even some other language, since \nPython is so easy to pick up) and want to start making games beyond just text, then this is the \nbook for you. The book starts with a short introduction to how the Pygame library works and the \nfunctions it provides. Then it provides the complete source code for some actual games and \nexplains how the code works, so you can understand how actual game programs make use of \nPygame. \nThis book features seven different games that are clones of popular games that you’ve probably \nalready played. The games are a lot more fun and interactive than the text-based games in ―Invent \nwith Python‖, but are still fairly short. All of the programs are less than 600 lines long. This is \npretty small when you consider that professional games you download or buy in a store can be \nhundreds of thousands of lines long. These games require an entire team of programmers and \nartists working with each other for months or years to make. \nThe website for this book is http://inventwithpython.com/pygame. All the programs and files \nmentioned in this book can be downloaded for free from this website, including this book itself. \nProgramming is a great creative activity, so please share this book as widely as possible. The \nCreative Commons license that this book is released under gives you the right to copy and \nduplicate this book as much as you want (as long as you don’t charge money for it). \nIf you ever have questions about how these programs work, feel free to email me at \nal@inventwithpython.com. \n \n",
      "content_length": 2672,
      "extraction_method": "Direct"
    },
    {
      "page_number": 7,
      "chapter": null,
      "content": "About This Book    iii \n \nTABLE OF CONTENTS \nWho is this book for? ........................................................................................................................ i \nAbout This Book .............................................................................................................................. ii \nChapter 1 – Installing Python and Pygame ...................................................................................... 1 \nWhat You Should Know Before You Begin ................................................................................ 1 \nDownloading and Installing Python ............................................................................................. 1 \nWindows Instructions .................................................................................................................. 1 \nMac OS X Instructions ................................................................................................................. 2 \nUbuntu and Linux Instructions .................................................................................................... 2 \nStarting Python............................................................................................................................. 2 \nInstalling Pygame......................................................................................................................... 3 \nHow to Use This Book ................................................................................................................. 4 \nThe Featured Programs ................................................................................................................ 4 \nDownloading Graphics and Sound Files ...................................................................................... 4 \nLine Numbers and Spaces ............................................................................................................ 4 \nText Wrapping in This Book ....................................................................................................... 5 \nChecking Your Code Online ........................................................................................................ 6 \nMore Info Links on http://invpy.com ........................................................................................... 6 \nChapter 2 – Pygame Basics .............................................................................................................. 7 \nGUI vs. CLI ................................................................................................................................. 7 \nSource Code for Hello World with Pygame ................................................................................ 7 \nSetting Up a Pygame Program ..................................................................................................... 8 \nGame Loops and Game States ................................................................................................... 10 \npygame.event.Event Objects ........................................................................................... 11 \nThe QUIT Event and pygame.quit() Function .................................................................. 12 \nPixel Coordinates ....................................................................................................................... 13 \n",
      "content_length": 3409,
      "extraction_method": "Direct"
    },
    {
      "page_number": 8,
      "chapter": null,
      "content": "iv    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nA Reminder About Functions, Methods, Constructor Functions, and Functions in Modules (and \nthe Difference Between Them) .................................................................................................. 14 \nSurface Objects and The Window ............................................................................................. 15 \nColors ......................................................................................................................................... 16 \nTransparent Colors ..................................................................................................................... 17 \npygame.Color Objects .......................................................................................................... 18 \nRect Objects ............................................................................................................................... 18 \nPrimitive Drawing Functions ..................................................................................................... 20 \npygame.PixelArray Objects .............................................................................................. 23 \nThe pygame.display.update() Function ...................................................................... 24 \nAnimation .................................................................................................................................. 24 \nFrames Per Second and pygame.time.Clock Objects ....................................................... 27 \nDrawing Images with pygame.image.load() and blit() ............................................ 28 \nFonts ........................................................................................................................................... 28 \nAnti-Aliasing.............................................................................................................................. 30 \nPlaying Sounds........................................................................................................................... 31 \nSummary .................................................................................................................................... 32 \nChapter 3 – Memory Puzzle .......................................................................................................... 33 \nHow to Play Memory Puzzle ..................................................................................................... 33 \nNested for Loops ..................................................................................................................... 33 \nSource Code of Memory Puzzle ................................................................................................ 34 \nCredits and Imports .................................................................................................................... 42 \nMagic Numbers are Bad ............................................................................................................ 42 \nSanity Checks with assert Statements ................................................................................... 43 \nTelling If a Number is Even or Odd .......................................................................................... 44 \nCrash Early and Crash Often! .................................................................................................... 44 \nMaking the Source Code Look Pretty ........................................................................................ 45 \nUsing Constant Variables Instead of Strings ............................................................................. 46 \nMaking Sure We Have Enough Icons ........................................................................................ 47 \nTuples vs. Lists, Immutable vs. Mutable ................................................................................... 47 \n",
      "content_length": 4037,
      "extraction_method": "Direct"
    },
    {
      "page_number": 9,
      "chapter": null,
      "content": "About This Book    v \n \nOne Item Tuples Need a Trailing Comma ................................................................................. 48 \nConverting Between Lists and Tuples ....................................................................................... 49 \nThe global statement, and Why Global Variables are Evil.................................................... 49 \nData Structures and 2D Lists ..................................................................................................... 51 \nThe ―Start Game‖ Animation ..................................................................................................... 52 \nThe Game Loop ......................................................................................................................... 52 \nThe Event Handling Loop .......................................................................................................... 53 \nChecking Which Box The Mouse Cursor is Over ..................................................................... 54 \nHandling the First Clicked Box ................................................................................................. 55 \nHandling a Mismatched Pair of Icons ........................................................................................ 56 \nHandling If the Player Won ....................................................................................................... 56 \nDrawing the Game State to the Screen ...................................................................................... 57 \nCreating the ―Revealed Boxes‖ Data Structure ......................................................................... 58 \nCreating the Board Data Structure: Step 1 – Get All Possible Icons ......................................... 58 \nStep 2 – Shuffling and Truncating the List of All Icons ............................................................ 59 \nStep 3 – Placing the Icons on the Board .................................................................................... 59 \nSplitting a List into a List of Lists.............................................................................................. 60 \nDifferent Coordinate Systems .................................................................................................... 61 \nConverting from Pixel Coordinates to Box Coordinates ........................................................... 62 \nDrawing the Icon, and Syntactic Sugar ...................................................................................... 63 \nSyntactic Sugar with Getting a Board Space’s Icon’s Shape and Color .................................... 64 \nDrawing the Box Cover ............................................................................................................. 64 \nHandling the Revealing and Covering Animation ..................................................................... 65 \nDrawing the Entire Board .......................................................................................................... 66 \nDrawing the Highlight ............................................................................................................... 67 \nThe ―Start Game‖ Animation ..................................................................................................... 67 \nRevealing and Covering the Groups of Boxes ........................................................................... 68 \nThe ―Game Won‖ Animation .................................................................................................... 68 \nTelling if the Player Has Won ................................................................................................... 69 \n",
      "content_length": 3735,
      "extraction_method": "Direct"
    },
    {
      "page_number": 10,
      "chapter": null,
      "content": "vi    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nWhy Bother Having a main() Function? ................................................................................ 69 \nWhy Bother With Readability? .................................................................................................. 70 \nSummary, and a Hacking Suggestion ........................................................................................ 74 \nChapter 4 – Slide Puzzle ................................................................................................................ 77 \nHow to Play Slide Puzzle ........................................................................................................... 77 \nSource Code to Slide Puzzle ...................................................................................................... 77 \nSecond Verse, Same as the First ................................................................................................ 85 \nSetting Up the Buttons ............................................................................................................... 86 \nBeing Smart By Using Stupid Code .......................................................................................... 87 \nThe Main Game Loop ................................................................................................................ 88 \nClicking on the Buttons ............................................................................................................. 89 \nSliding Tiles with the Mouse ..................................................................................................... 90 \nSliding Tiles with the Keyboard ................................................................................................ 90 \n―Equal To One Of‖ Trick with the in Operator ........................................................................ 91 \nWASD and Arrow Keys ............................................................................................................ 91 \nActually Performing the Tile Slide ............................................................................................ 92 \nIDLE and Terminating Pygame Programs ................................................................................. 92 \nChecking for a Specific Event, and Posting Events to Pygame’s Event Queue ........................ 92 \nCreating the Board Data Structure ............................................................................................. 93 \nNot Tracking the Blank Position ................................................................................................ 94 \nMaking a Move by Updating the Board Data Structure ............................................................ 94 \nWhen NOT to Use an Assertion ................................................................................................ 95 \nGetting a Not-So-Random Move ............................................................................................... 96 \nConverting Tile Coordinates to Pixel Coordinates .................................................................... 97 \nConverting from Pixel Coordinates to Board Coordinates ........................................................ 97 \nDrawing a Tile ........................................................................................................................... 97 \nThe Making Text Appear on the Screen .................................................................................... 98 \nDrawing the Board ..................................................................................................................... 99 \nDrawing the Border of the Board ............................................................................................... 99 \n",
      "content_length": 3871,
      "extraction_method": "Direct"
    },
    {
      "page_number": 11,
      "chapter": null,
      "content": "About This Book    vii \n \nDrawing the Buttons ................................................................................................................ 100 \nAnimating the Tile Slides ........................................................................................................ 100 \nThe copy() Surface Method ................................................................................................. 101 \nCreating a New Puzzle ............................................................................................................. 103 \nAnimating the Board Reset ...................................................................................................... 104 \nTime vs. Memory Tradeoffs .................................................................................................... 105 \nNobody Cares About a Few Bytes ........................................................................................... 106 \nNobody Cares About a Few Million Nanoseconds .................................................................. 107 \nSummary .................................................................................................................................. 107 \nChapter 5 – Simulate .................................................................................................................... 108 \nHow to Play Simulate .............................................................................................................. 108 \nSource Code to Simulate .......................................................................................................... 108 \nThe Usual Starting Stuff .......................................................................................................... 114 \nSetting Up the Buttons ............................................................................................................. 115 \nThe main() Function ............................................................................................................. 115 \nSome Local Variables Used in This Program .......................................................................... 116 \nDrawing the Board and Handling Input ................................................................................... 117 \nChecking for Mouse Clicks ..................................................................................................... 118 \nChecking for Keyboard Presses ............................................................................................... 118 \nThe Two States of the Game Loop .......................................................................................... 119 \nFiguring Out if the Player Pressed the Right Buttons .............................................................. 119 \nEpoch Time .............................................................................................................................. 121 \nDrawing the Board to the Screen ............................................................................................. 122 \nSame Old terminate() Function ....................................................................................... 122 \nReusing The Constant Variables .............................................................................................. 123 \nAnimating the Button Flash ..................................................................................................... 123 \nDrawing the Buttons ................................................................................................................ 126 \nAnimating the Background Change ......................................................................................... 126 \nThe Game Over Animation ...................................................................................................... 127 \n",
      "content_length": 3867,
      "extraction_method": "Direct"
    },
    {
      "page_number": 12,
      "chapter": null,
      "content": "viii    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nConverting from Pixel Coordinates to Buttons ........................................................................ 129 \nExplicit is Better Than Implicit ................................................................................................ 129 \nChapter 6 – Wormy ...................................................................................................................... 131 \nHow to Play Wormy ................................................................................................................ 131 \nSource Code to Wormy ............................................................................................................ 131 \nThe Grid ................................................................................................................................... 137 \nThe Setup Code ........................................................................................................................ 137 \nThe main() Function ............................................................................................................. 138 \nA Separate runGame() Function .......................................................................................... 139 \nThe Event Handling Loop ........................................................................................................ 139 \nCollision Detection .................................................................................................................. 140 \nDetecting Collisions with the Apple ........................................................................................ 141 \nMoving the Worm .................................................................................................................... 142 \nThe insert() List Method................................................................................................... 142 \nDrawing the Screen .................................................................................................................. 143 \nDrawing ―Press a key‖ Text to the Screen ............................................................................... 143 \nThe checkForKeyPress() Function ................................................................................ 143 \nThe Start Screen ....................................................................................................................... 144 \nRotating the Start Screen Text ................................................................................................. 145 \nRotations Are Not Perfect ........................................................................................................ 146 \nDeciding Where the Apple Appears ........................................................................................ 147 \nGame Over Screens .................................................................................................................. 147 \nDrawing Functions ................................................................................................................... 148 \nDon’t Reuse Variable Names ................................................................................................... 151 \nChapter 7 - Tetromino .................................................................................................................. 153 \nHow to Play Tetromino ............................................................................................................ 153 \nSome Tetromino Nomenclature ............................................................................................... 153 \nSource Code to Tetromino ....................................................................................................... 154 \nThe Usual Setup Code ............................................................................................................. 166 \n",
      "content_length": 4002,
      "extraction_method": "Direct"
    },
    {
      "page_number": 13,
      "chapter": null,
      "content": "About This Book    ix \n \nSetting up Timing Constants for Holding Down Keys ............................................................ 166 \nMore Setup Code ..................................................................................................................... 166 \nSetting Up the Piece Templates ............................................................................................... 168 \nSplitting a ―Line of Code‖ Across Multiple Lines ................................................................... 171 \nThe main() Function ............................................................................................................. 172 \nThe Start of a New Game ......................................................................................................... 173 \nThe Game Loop ....................................................................................................................... 174 \nThe Event Handling Loop ........................................................................................................ 174 \nPausing the Game .................................................................................................................... 174 \nUsing Movement Variables to Handle User Input ................................................................... 175 \nChecking if a Slide or Rotation is Valid .................................................................................. 175 \nFinding the Bottom .................................................................................................................. 178 \nMoving by Holding Down the Key.......................................................................................... 179 \nLetting the Piece ―Naturally‖ Fall ............................................................................................ 182 \nDrawing Everything on the Screen .......................................................................................... 182 \nmakeTextObjs(), A Shortcut Function for Making Text .................................................. 183 \nThe Same Old terminate() Function ................................................................................ 183 \nWaiting for a Key Press Event with the checkForKeyPress() Function ........................ 183 \nshowTextScreen(), A Generic Text Screen Function ..................................................... 184 \nThe checkForQuit() Function .......................................................................................... 185 \nThe calculateLevelAndFallFreq() Function .......................................................... 185 \nGenerating Pieces with the getNewPiece() Function ....................................................... 188 \nAdding Pieces to the Board Data Structure ............................................................................. 189 \nCreating a New Board Data Structure ...................................................................................... 189 \nThe isOnBoard() and isValidPosition() Functions ............................................... 190 \nChecking for, and Removing, Complete Lines ........................................................................ 192 \nConvert from Board Coordinates to Pixel Coordinates ........................................................... 195 \nDrawing a Box on the Board or Elsewhere on the Screen ....................................................... 195 \nDrawing Everything to the Screen ........................................................................................... 196 \n",
      "content_length": 3601,
      "extraction_method": "Direct"
    },
    {
      "page_number": 14,
      "chapter": null,
      "content": "x    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nDrawing the Score and Level Text .......................................................................................... 196 \nDrawing a Piece on the Board or Elsewhere on the Screen ..................................................... 197 \nDrawing the ―Next‖ Piece ........................................................................................................ 197 \nSummary .................................................................................................................................. 198 \nChapter 8 – Squirrel Eat Squirrel ................................................................................................. 200 \nHow to Play Squirrel Eat Squirrel............................................................................................ 200 \nThe Design of Squirrel Eat Squirrel ......................................................................................... 200 \nSource Code to Squirrel Eat Squirrel ....................................................................................... 201 \nThe Usual Setup Code ............................................................................................................. 211 \nDescribing the Data Structures ................................................................................................ 212 \nThe main() Function ............................................................................................................. 213 \nThe pygame.transform.flip() Function .................................................................... 214 \nA More Detailed Game State than Usual ................................................................................. 214 \nThe Usual Text Creation Code................................................................................................. 215 \nCameras ................................................................................................................................... 215 \nThe ―Active Area‖ ................................................................................................................... 217 \nKeeping Track of the Location of Things in the Game World ................................................ 218 \nStarting Off with Some Grass .................................................................................................. 219 \nThe Game Loop ....................................................................................................................... 219 \nChecking to Disable Invulnerability ........................................................................................ 219 \nMoving the Enemy Squirrels ................................................................................................... 219 \nRemoving the Far Away Grass and Squirrel Objects .............................................................. 221 \nWhen Deleting Items in a List, Iterate Over the List in Reverse ............................................. 221 \nAdding New Grass and Squirrel Objects ................................................................................. 223 \nCamera Slack, and Moving the Camera View ......................................................................... 223 \nDrawing the Background, Grass, Squirrels, and Health Meter ................................................ 224 \nThe Event Handling Loop ........................................................................................................ 226 \nMoving the Player, and Accounting for Bounce ...................................................................... 228 \nCollision Detection: Eat or Be Eaten ....................................................................................... 229 \n",
      "content_length": 3829,
      "extraction_method": "Direct"
    },
    {
      "page_number": 15,
      "chapter": null,
      "content": "About This Book    xi \n \nThe Game Over Screen ............................................................................................................ 231 \nWinning ................................................................................................................................... 232 \nDrawing a Graphical Health Meter .......................................................................................... 232 \nThe Same Old terminate() Function ................................................................................ 232 \nThe Mathematics of the Sine Function .................................................................................... 233 \nBackwards Compatibility with Python Version 2 .................................................................... 236 \nThe getRandomVelocity() Function .............................................................................. 237 \nFinding a Place to Add New Squirrels and Grass .................................................................... 237 \nCreating Enemy Squirrel Data Structures ................................................................................ 238 \nFlipping the Squirrel Image ..................................................................................................... 239 \nCreating Grass Data Structures ................................................................................................ 239 \nChecking if Outside the Active Area ....................................................................................... 240 \nSummary .................................................................................................................................. 241 \nChapter 9 – Star Pusher ................................................................................................................ 242 \nHow to Play Star Pusher .......................................................................................................... 242 \nSource Code to Star Pusher ...................................................................................................... 242 \nThe Initial Setup ....................................................................................................................... 256 \nData Structures in Star Pusher ................................................................................................. 271 \nThe ―Game State‖ Data Structure ............................................................................................ 271 \nThe ―Map‖ Data Structure ....................................................................................................... 271 \nThe ―Levels‖ Data Structure .................................................................................................... 272 \nReading and Writing Text Files ............................................................................................... 272 \nText Files and Binary Files ...................................................................................................... 272 \nWriting to Files ........................................................................................................................ 273 \nReading from Files ................................................................................................................... 274 \nAbout the Star Pusher Map File Format .................................................................................. 274 \nRecursive Functions ................................................................................................................. 280 \nStack Overflows ....................................................................................................................... 281 \nPreventing Stack Overflows with a Base Case ........................................................................ 283 \n",
      "content_length": 3873,
      "extraction_method": "Direct"
    },
    {
      "page_number": 16,
      "chapter": null,
      "content": "xii    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe Flood Fill Algorithm ......................................................................................................... 284 \nDrawing the Map ..................................................................................................................... 285 \nChecking if the Level is Finished ............................................................................................ 287 \nSummary .................................................................................................................................. 288 \nChapter 10 – Four Extra Games ................................................................................................... 289 \nFlippy, an ―Othello‖ Clone ...................................................................................................... 290 \nSource Code for Flippy ............................................................................................................ 292 \nInk Spill, a ―Flood It‖ Clone .................................................................................................... 305 \nSource Code for Ink Spill ........................................................................................................ 305 \nFour-In-A-Row, a ―Connect Four‖ Clone ................................................................................ 317 \nSource Code for Four-In-A-Row ............................................................................................. 317 \nGemgem, a ―Bejeweled‖ Clone ............................................................................................... 327 \nSource Code for Gemgem ........................................................................................................ 327 \nSummary .................................................................................................................................. 340 \nGlossary ....................................................................................................................................... 342 \nAbout the Author ......................................................................................................................... 347 \n \n \n \n",
      "content_length": 2292,
      "extraction_method": "Direct"
    },
    {
      "page_number": 17,
      "chapter": null,
      "content": "About This Book    xiii \n \n \n \n \nThis page intentionally left blank. \n \n \n \n \n \n \n \n…except for the above text. \nAnd the above text. \nAnd the above text. \nAnd the above text. \nAnd the above text. \nAnd the above text. \nAnd the above text. \nAnd the above text. \nAnd the above text. \nTraceback (most recent call last): \n  File \"<pyshell#1>\", line 1, in blankpage \n    def blankpage(): blankpage() \nRuntimeError: maximum recursion depth exceeded  \n",
      "content_length": 444,
      "extraction_method": "Direct"
    },
    {
      "page_number": 18,
      "chapter": null,
      "content": "xiv    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n",
      "content_length": 105,
      "extraction_method": "Direct"
    },
    {
      "page_number": 19,
      "chapter": null,
      "content": "Chapter 1 – Installing Python and Pygame    1 \n \nCHAPTER 1 – INSTALLING \nPYTHON AND PYGAME \nWhat You Should Know Before You Begin \nIt might help if you know a bit about Python programming (or how to program in another \nlanguage besides Python) before you read through this book; however even if you haven’t you \ncan still read this book anyway. Programming isn’t nearly as hard as people think it is. If you ever \nrun into some trouble, you can read the free book ―Invent Your Own Computer Games with \nPython‖ online at http://inventwithpython.com or look up a topic that you find confusing on the \nInvent with Python wiki at http://inventwithpython.com/wiki. \nYou don’t need to know how to use the Pygame library before reading this book. The next \nchapter is a brief tutorial on all of Pygame’s major features and functions. \nJust in case you haven’t read the first book and already installed Python and Pygame on your \ncomputer, the installation instructions are in this chapter. If you already have installed both of \nthese then you can skip this chapter. \nDownloading and Installing Python \nBefore we can begin programming you'll need to install software called the Python interpreter on \nyour computer. (You may need to ask an adult for help here.) The interpreter is a program that \nunderstands the instructions that you’ll write (or rather, type out) in the Python language. Without \nthe interpreter, your computer won't be able to run your Python programs. We'll just refer to ―the \nPython interpreter‖ as ―Python‖ from now on. \nThe Python interpreter software can be downloaded from the official website of the Python \nprogramming language, http://www.python.org. You might want the help of someone else to \ndownload and install the Python software. The installation is a little different depending on if \nyour computer’s operating system is Windows, Mac OS X, or a Linux OS such as Ubuntu. You \ncan also find videos online of people installing the Python software on their computers at \nhttp://invpy.com/installing. \nWindows Instructions \nWhen you get to http://python.org, you should see a list of links on the left (such as ―About‖, \n―News‖, ―Documentation‖, ―Download‖, and so on). Click on the Download link to go to the \n",
      "content_length": 2237,
      "extraction_method": "Direct"
    },
    {
      "page_number": 20,
      "chapter": null,
      "content": "2    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \ndownload page, then look for the file called ―Python 3.2 Windows Installer (Windows binary -- \ndoes not include source)‖ and click on its link to download Python for Windows. \nDouble-click on the python-3.2.msi file that you've just downloaded to start the Python installer. \n(If it doesn’t start, try right-clicking the file and choosing Install.) Once the installer starts up, \njust keep clicking the Next button and just accept the choices in the installer as you go (no need \nto make any changes). When the install is finished, click Finish. \nMac OS X Instructions \nMac OS X 10.5 comes with Python 2.5.1 pre-installed by Apple. Currently, Pygame only \nsupports Python 2 and not Python 3. However, the programs in this book work with both Python \n2 and 3. \nThe Python website also has some additional information about using Python on a Mac at \nhttp://docs.python.org/dev/using/mac.html. \nUbuntu and Linux Instructions \nPygame for Linux also only supports Python 2, not Python 3. If your operating system is Ubuntu, \nyou can install Python by opening a terminal window (from the desktop click on Applications > \nAccessories > Terminal) and entering ―sudo apt-get install python2.7‖ then \npressing Enter. You will need to enter the root password to install Python, so ask the person who \nowns the computer to type in this password if you do not know it. \nYou also need to install the IDLE software. From the terminal, type in ―sudo apt-get \ninstall idle‖. The root password is also needed to install IDLE (ask the owner of your \ncomputer to type in this password for you). \nStarting Python \nWe will be using the IDLE software to type in our programs and run them. IDLE stands for \nInteractive DeveLopment Environment. The development environment is software that makes it \neasy to write Python programs, just like word processor software makes it easy to write books. \nIf your operating system is Windows XP, you should be able to run Python by clicking the Start \nbutton, then selecting Programs, Python 3.1, IDLE (Python GUI). For Windows Vista or \nWindows 7, just click the Windows button in the lower left corner, type ―IDLE‖ and select \n―IDLE (Python GUI)‖. \nIf your operating system is Max OS X, start IDLE by opening the Finder window and click on \nApplications, then click Python 3.2, then click the IDLE icon. \n",
      "content_length": 2423,
      "extraction_method": "Direct"
    },
    {
      "page_number": 21,
      "chapter": null,
      "content": "Chapter 1 – Installing Python and Pygame    3 \n \nIf your operating system is Ubuntu or Linux, start IDLE by opening a terminal window and then \ntype ―idle3‖ and press Enter. You may also be able to click on Applications at the top of the \nscreen, and then select Programming, then IDLE 3. \n \n \n \n \nThe window that appears when you first run IDLE is called the interactive shell. A shell is a \nprogram that lets you type instructions into the computer. The Python shell lets you type Python \ninstructions, and the shell sends these instructions to the Python interpreter to perform. \nInstalling Pygame \nPygame does not come with Python. Like Python, Pygame is available for free. You will have to \ndownload and install Pygame, which is as easy as downloading and installing the Python \ninterpreter. In a web browser, go to the URL http://pygame.org and click on the ―Downloads‖ \nlink on the left side of the web site. This book assumes you have the Windows operating system, \nbut Pygame works the same for every operating system. You need to download the Pygame \ninstaller for your operating system and the version of Python you have installed. \nYou do not want to download the ―source‖ for Pygame, but rather the Pygame ―binary‖ for your \noperating system. For Windows, download the pygame-1.9.1.win32-py3.2.msi file. (This is \nPygame for Python 3.2 on Windows. If you installed a different version of Python (such as 2.7 or \n2.6) download the .msi file for your version of Python.) The current version of Pygame at the \ntime this book was written is 1.9.1. If you see a newer version on the website, download and \ninstall the newer Pygame.  \nFor Mac OS X, download the .zip or .dmg file for the version of Python you have and run it. \nFor Linux, open a terminal and run ―sudo apt-get install python-pygame‖. \nOn Windows, double click on the downloaded file to install Pygame. To check that Pygame is \ninstall correctly, type the following into the interactive shell: \n>>> import pygame \n",
      "content_length": 1988,
      "extraction_method": "Direct"
    },
    {
      "page_number": 22,
      "chapter": null,
      "content": "4    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nIf nothing appears after you hit the Enter key, then you know Pygame has successfully been \ninstalled. If the error ImportError: No module named pygame appears, then try to \ninstall Pygame again (and make sure you typed import pygame correctly). \nThis chapter has five small programs that demonstrate how to use the different features that \nPygame provides. In the last chapter, you will use these features for a complete game written in \nPython with Pygame. \nA video tutorial of how to install Pygame is available from this book's website at \nhttp://invpy.com/videos. \nHow to Use This Book \n―Making Games with Python & Pygame‖ is different from other programming books because it \nfocuses on the complete source code for several game programs. Instead of teaching you \nprogramming concepts and leaving it up to you to figure out how to make programs with those \nconcepts, this book shows you some programs and then explains how they are put together. \nIn general, you should read these chapters in order. There are many concepts that are used over \nand over in these games, and they are only explained in detail in the first game they appear in. \nBut if there is a game you think is interesting, go ahead and jump to that chapter. You can always \nread the previous chapters later if you got ahead of yourself. \nThe Featured Programs \nEach chapter focuses on a single game program and explain how different parts of the code work. \nIt is very helpful to copy these programs by typing in the code line by line from this book. \nHowever, you can also download the source code file from this book's website. In a web browser, \ngo to the URL http://invpy.com/source and follow the instructions to download the source code \nfile. But typing in the code yourself really helps you learn the code better. \nDownloading Graphics and Sound Files \nWhile you can just type in the code you read out of this book, you will need to download the \ngraphics and sound files used by the games in this book from http://invpy.com/downloads. Make \nsure that these image and sound files are located in the same folder as the .py Python file \notherwise your Python program will not be able to find these files. \nLine Numbers and Spaces \nWhen entering the source code yourself, do not type the line numbers that appear at the beginning \nof each line. For example, if you see this in the book: \n",
      "content_length": 2468,
      "extraction_method": "Direct"
    },
    {
      "page_number": 23,
      "chapter": null,
      "content": "Chapter 1 – Installing Python and Pygame    5 \n \n1. number = random.randint(1, 20) \n2. spam = 42 \n3. print('Hello world!') \nYou do not need to type the ―1.‖ on the left side, or the space that immediately follows it. Just \ntype it like this: \nnumber = random.randint(1, 20) \nspam = 42 \nprint('Hello world!') \nThose numbers are only used so that this book can refer to specific lines in the code. They are not \na part of the actual program. \nAside from the line numbers, be sure to enter the code exactly as it appears. Notice that some of \nthe lines don’t begin at the leftmost edge of the page, but are indented by four or eight or more \nspaces. Be sure to put in the correct number of spaces at the start of each line. (Since each \ncharacter in IDLE is the same width, you can count the number of spaces by counting the number \nof characters above or below the line you're looking at.) \nFor example in the code below, you can see that the second line is indented by four spaces \nbecause the four characters (―whil‖) on the line above are over the indented space. The third line \nis indented by another four spaces (the four characters, ―if n‖ are above the third line's indented \nspace): \nwhile spam < 10: \n    if number == 42: \n        print('Hello') \nText Wrapping in This Book \nSome lines of code are too long to fit on one line on the pages in this book, and the text of the \ncode will wrap around to the next line. When you type these lines into the file editor, enter the \ncode all on one line without pressing Enter. \nYou can tell when a new line starts by looking at the line numbers on the left side of the code. For \nexample, the code below has only two lines of code, even though the first line wraps around: \n1. print('This is the first line! xxxxxxxxxxxxxxxxxxxxxxxxxxxxx \nxxxxxxxxxxxxxx’) \n2. print('This is the second line, not the third line.') \n",
      "content_length": 1864,
      "extraction_method": "Direct"
    },
    {
      "page_number": 24,
      "chapter": null,
      "content": "6    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nChecking Your Code Online \nSome of the programs in this book are a little long. Although it is very helpful to learn Python by \ntyping out the source code for these programs, you may accidentally make typos that cause your \nprograms to crash. It may not be obvious where the typo is. \nYou can copy and paste the text of your source code to the online diff tool on the book’s website. \nThe diff tool will show any differences between the source code in the book and the source code \nyou’ve typed. This is an easy way of finding any typos in your program. \nCopying and pasting text is a very useful computer skill, especially for computer programming. \nThere is a video tutorial on copying and pasting at this book’s website at \nhttp://invpy.com/copypaste. \nThe online diff tool is at this web page: http://invpy.com/diff/pygame. There is also a video \ntutorial on how to use this tool on the book’s website. \nMore Info Links on http://invpy.com \nThere is a lot that you can learn about programming. But you don’t need to learn all of it now. \nThere are several times in this book where you might like to learn these additional details and \nexplanations, but if I included them in this book then it would add many more pages. If this \nlarger, heavier book accidentally fell on you the weight of these many additional pages would \ncrush you, resulting in death. Instead, I have included ―more info‖ links in this book that you can \nfollow on this book’s website. You do not have to read this additional information to understand \nanything in this book, but it is there if you are curious. These (and other) links have been \nshortened and begin with http://invpy.com. \nAll of the information from these ―more info‖ links can also be downloaded from \nhttp://invpy.com/pygamemoreinfo. \nEven though this book is not dangerously heavy, please do not let it fall on you anyway. \n \n \n",
      "content_length": 1975,
      "extraction_method": "Direct"
    },
    {
      "page_number": 25,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    7 \n \nCHAPTER 2 – PYGAME BASICS \nJust like how Python comes with several modules like random, math, or time that provide \nadditional functions for your programs, the Pygame framework includes several modules with \nfunctions for drawing graphics, playing sounds, handling mouse input, and other things. \nThis chapter will cover the basic modules and functions that Pygame provides and assumes you \nalready know basic Python programming. If you have trouble with some of the programming \nconcepts, you can read through the ―Invent Your Own Computer Games with Python‖ book \nonline at http://invpy.com/book. This book is aimed at complete beginners to programming. \nThe ―Invent with Python‖ book also has a few chapters covering Pygame. You can read them \nonline at http://invpy.com/chap17. \nOnce you learn more about Pygame, you can view the other modules that Pygame provides from \nthe online documentation at http://pygame.org/docs. \nGUI vs. CLI \nThe Python programs that you can write with Python’s built-in functions only deal with text \nthrough the print() and input() functions. Your program can display text on the screen and \nlet the user type in text from the keyboard. This type of program has a command line interface, \nor CLI (which is pronounced like the first part of ―climb‖ and rhymes with ―sky‖). These \nprograms are somewhat limited because they can’t display graphics, have colors, or use the \nmouse. These CLI programs only get input from the keyboard with the input() function and \neven then user must press Enter before the program can respond to the input. This means real-\ntime (that is, continuing to run code without waiting for the user) action games are impossible to \nmake. \nPygame provides functions for creating programs with a graphical user interface, or GUI \n(pronounced, ―gooey‖). Instead of a text-based CLI, programs with a graphics-based GUI can \nshow a window with images and colors. \nSource Code for Hello World with Pygame \nOur first program made with Pygame is a small program that makes a window that says ―Hello \nWorld!‖ appear on the screen. Open a new file editor window by clicking on IDLE’s File menu, \nthen New Window. Type in the following code into IDLE’s file editor and save it as \nblankpygame.py. Then run the program by pressing F5 or selecting Run > Run Module from the \nmenu at the top of the file editor. \n",
      "content_length": 2390,
      "extraction_method": "Direct"
    },
    {
      "page_number": 26,
      "chapter": null,
      "content": "8    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nRemember, do not type the numbers or the periods at the beginning of each line (that’s just for \nreference in this book). \n 1. import pygame, sys \n 2. from pygame.locals import * \n 3.  \n 4. pygame.init() \n 5. DISPLAYSURF = pygame.display.set_mode((400, 300)) \n 6. pygame.display.set_caption('Hello World!') \n 7. while True: # main game loop \n 8.     for event in pygame.event.get(): \n 9.         if event.type == QUIT: \n10.             pygame.quit() \n11.             sys.exit() \n12.     pygame.display.update() \nWhen you run this program, a black window like this will appear: \n \nYay! You’ve just made the world’s most boring video game! It’s just a blank window with ―Hello \nWorld!‖ at the top of the window (in what is called the window’s title bar, which holds the \ncaption text). But creating a window is the first step to making graphical games. When you click \non the X button in the corner of the window, the program will end and the window will disappear. \nCalling the print() function to make text appear in the window won’t work because \nprint() is a function for CLI programs. The same goes for input() to get keyboard input \nfrom the user. Pygame uses other functions for input and output which are explained later in this \nchapter. For now, let’s look at each line in our ―Hello World‖ program in more detail. \nSetting Up a Pygame Program \nThe first few lines of code in the Hello World program are lines that will begin almost every \nprogram you write that uses Pygame. \n 1. import pygame, sys \n",
      "content_length": 1610,
      "extraction_method": "Direct"
    },
    {
      "page_number": 27,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    9 \n \nLine 1 is a simple import statement that imports the pygame and sys modules so that our \nprogram can use the functions in them. All of the Pygame functions dealing with graphics, sound, \nand other features that Pygame provides are in the pygame module. \nNote that when you import the pygame module you automatically import all the modules that \nare in the pygame module as well, such as pygame.images and pygame.mixer.music. \nThere’s no need to import these modules-inside-modules with additional import statements. \n 2. from pygame.locals import * \nLine 2 is also an import statement. However, instead of the import modulename format, it \nuses the from modulename import * format. Normally if you want to call a function that \nis in a module, you must use the modulename.functionname() format after importing the \nmodule. However, with from modulename import *, you can skip the modulename. \nportion and simply use functionname() (just like Python’s built-in functions). \nThe reason we use this form of import statement for pygame.locals is because \npygame.locals contains several constant variables that are easy to identify as being in the \npygame.locals module without pygame.locals. in front of them. For all other modules, \nyou generally want to use the regular import modulename format. (There is more \ninformation about why you want to do this at http://invpy.com/namespaces.) \n 4. pygame.init() \nLine 4 is the pygame.init() function call, which always needs to be called after importing \nthe pygame module and before calling any other Pygame function. You don’t need to know what \nthis function does, you just need to know that it needs to be called first in order for many Pygame \nfunctions to work. If you ever see an error message like pygame.error: font not \ninitialized, check to see if you forgot to call pygame.init() at the start of your \nprogram. \n 5. DISPLAYSURF = pygame.display.set_mode((400, 300)) \nLine 5 is a call to the pygame.display.set_mode() function, which returns the \npygame.Surface object for the window. (Surface objects are described later in this chapter.) \nNotice that we pass a tuple value of two integers to the function: (400, 300). This tuple tells \nthe set_mode() function how wide and how high to make the window in pixels. (400, \n300) will make a window with a width of 400 pixels and height of 300 pixels.  \n",
      "content_length": 2387,
      "extraction_method": "Direct"
    },
    {
      "page_number": 28,
      "chapter": null,
      "content": "10    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nRemember to pass a tuple of two integers to set_mode(), not just two integers themselves. The \ncorrect way to call the function is like this: pygame.display.set_mode((400, 300)). \nA function call like pygame.display.set_mode(400, 300) will cause an error that \nlooks like this: TypeError: argument 1 must be 2-item sequence, not int. \nThe pygame.Surface object (we will just call them Surface objects for short) returned is \nstored in a variable named DISPLAYSURF. \n 6. pygame.display.set_caption('Hello World!') \nLine 6 sets the caption text that will appear at the top of the window by calling the \npygame.display.set_caption() function. The string value 'Hello World!' is \npassed in this function call to make that text appear as the caption: \n \nGame Loops and Game States \n 7. while True: # main game loop \n 8.     for event in pygame.event.get(): \nLine 7 is a while loop that has a condition of simply the value True. This means that it never \nexits due to its condition evaluating to False. The only way the program execution will ever \nexit the loop is if a break statement is executed (which moves execution to the first line after the \nloop) or sys.exit() (which terminates the program). If a loop like this was inside a function, \na return statement will also move execution out of the loop (as well as the function too). \nThe games in this book all have these while True loops in them along with a comment calling \nit the ―main game loop‖. A game loop (also called a main loop) is a loop where the code does \nthree things: \n1. Handles events. \n2. Updates the game state. \n3. Draws the game state to the screen.  \nThe game state is simply a way of referring to a set of values for all the variables in a game \nprogram. In many games, the game state includes the values in the variables that tracks the \nplayer’s health and position, the health and position of any enemies, which marks have been \nmade on a board, the score, or whose turn it is. Whenever something happens like the player \n",
      "content_length": 2101,
      "extraction_method": "Direct"
    },
    {
      "page_number": 29,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    11 \n \ntaking damage (which lowers their health value), or an enemy moves somewhere, or something \nhappens in the game world we say that the game state has changed. \nIf you’ve ever played a game that let you saved, the ―save state‖ is the game state at the point that \nyou’ve saved it. In most games, pausing the game will prevent the game state from changing. \nSince the game state is usually updated in response to events (such as mouse clicks or keyboard \npresses) or the passage of time, the game loop is constantly checking and re-checking many times \na second for any new events that have happened. Inside the main loop is code that looks at which \nevents have been created (with Pygame, this is done by calling the pygame.event.get() \nfunction). The main loop also has code that updates the game state based on which events have \nbeen created. This is usually called event handling. \n \npygame.event.Event Objects \nAny time the user does one of several actions (they are listed later in this chapter) such as \npressing a keyboard key or moving the mouse on the program’s window, a \npygame.event.Event object is created by the Pygame library to record this ―event‖. (This is \na type of object called Event that exists in the event module, which itself is in the pygame \nmodule.) We can find out which events have happened by calling the pygame.event.get() \nfunction, which returns a list of pygame.event.Event objects (which we will just call Event \nobjects for short). \nThe list of Event objects will be for each event that has happened since the last time the \npygame.event.get() function was called. (Or, if pygame.event.get() has never been \ncalled, the events that have happened since the start of the program.) \n",
      "content_length": 1751,
      "extraction_method": "Direct"
    },
    {
      "page_number": 30,
      "chapter": null,
      "content": "12    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 7. while True: # main game loop \n 8.     for event in pygame.event.get(): \nLine 8 is a for loop that will iterate over the list of Event objects that was returned by \npygame.event.get(). On each iteration through the for loop, a variable named event \nwill be assigned the value of the next event object in this list. The list of Event objects returned \nfrom pygame.event.get() will be in the order that the events happened. If the user clicked \nthe mouse and then pressed a keyboard key, the Event object for the mouse click would be the \nfirst item in the list and the Event object for the keyboard press would be second. If no events \nhave happened, then pygame.event.get() will return a blank list. \nThe QUIT Event and pygame.quit() Function \n 9.         if event.type == QUIT: \n10.             pygame.quit() \n11.             sys.exit() \nEvent objects have a member variable (also called attributes or properties) named type \nwhich tells us what kind of event the object represents. Pygame has a constant variable for each \nof possible types in the pygame.locals modules. Line 9 checks if the Event object’s type is \nequal to the constant QUIT. Remember that since we used the from pygame.locals \nimport * form of the import statement, we only have to type QUIT instead of \npygame.locals.QUIT. \nIf the Event object is a quit event, then the pygame.quit() and sys.exit() functions are \ncalled. The pygame.quit() function is sort of the opposite of the pygame.init() \nfunction: it runs code that deactivates the Pygame library. Your programs should always call \npygame.quit() before they call sys.exit() to terminate the program. Normally it doesn’t \nreally matter since Python closes it when the program exits anyway. But there is a bug in IDLE \nthat causes IDLE to hang if a Pygame program terminates before pygame.quit() is called. \nSince we have no if statements that run code for other types of Event object, there is no event-\nhandling code for when the user clicks the mouse, presses keyboard keys, or causes any other \ntype of Event objects to be created. The user can do things to create these Event objects but it \ndoesn’t change anything in the program because the program does not have any event-handling \ncode for these types of Event objects. After the for loop on line 8 is done handling all the Event \nobjects that have been returned by pygame.event.get(), the program execution continues \nto line 12. \n12.     pygame.display.update() \n",
      "content_length": 2556,
      "extraction_method": "Direct"
    },
    {
      "page_number": 31,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    13 \n \nLine 12 calls the pygame.display.update() function, which draws the Surface object \nreturned by pygame.display.set_mode() to the screen (remember we stored this object \nin the DISPLAYSURF variable). Since the Surface object hasn’t changed (for example, by some \nof the drawing functions that are explained later in this chapter), the same black image is redrawn \nto the screen each time pygame.display.update() is called. \nThat is the entire program. After line 12 is done, the infinite while loop starts again from the \nbeginning. This program does nothing besides make a black window appear on the screen, \nconstantly check for a QUIT event, and then redraws the unchanged black window to the screen \nover and over again. Let’s learn how to make interesting things appear on this window instead of \njust blackness by learning about pixels, Surface objects, Color objects, Rect objects, and the \nPygame drawing functions. \nPixel Coordinates \nThe window that the ―Hello World‖ program creates is just composed of little square dots on your \nscreen called pixels. Each pixel starts off as black but can be set to a different color. Imagine that \ninstead of a Surface object that is 400 pixels wide and 300 pixels tall, we just had a Surface object \nthat was 8 pixels by 8 pixels. If that tiny 8x8 Surface was enlarged so that each pixel looks like a \nsquare in a grid, and we added numbers for the X and Y axis, then a good representation of it \ncould look something like this: \n \nWe can refer to a specific pixel by using a Cartesian Coordinate system. Each column of the X-\naxis and each row of the Y-axis will have an ―address‖ that is an integer from 0 to 7 so that we \ncan locate any pixel by specifying the X and Y axis integers. \nFor example, in the above 8x8 image, we can see that the pixels at the XY coordinates (4, 0), (2, \n2), (0, 5), and (5, 6) have been painted black, the pixel at (2, 4) has been painted gray, while all \nthe other pixels are painted white. XY coordinates are also called points. If you’ve taken a math \nclass and learned about Cartesian Coordinates, you might notice that the Y-axis starts at 0 at the \ntop and then increases going down, rather than increasing as it goes up. This is just how Cartesian \nCoordinates work in Pygame (and almost every programming language). \n",
      "content_length": 2341,
      "extraction_method": "Direct"
    },
    {
      "page_number": 32,
      "chapter": null,
      "content": "14    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe Pygame framework often represents Cartesian Coordinates as a tuple of two integers, such as \n(4, 0) or (2, 2). The first integer is the X coordinate and the second is the Y coordinate. (Cartesian \nCoordinates are covered in more detail in chapter 12 of ―Invent Your Own Computer Games with \nPython‖ at http://invpy.com/chap12) \nA Reminder About Functions, Methods, Constructor Functions, and \nFunctions in Modules (and the Difference Between Them) \nFunctions and methods are almost the same thing. They can both be called to execute the code in \nthem. The difference between a function and a method is that a method will always be attached to \nan object. Usually methods change something about that particular object (you can think of the \nattached object as a sort of permanent argument passed to the method). \nThis is a function call of a function named foo(): \nfoo() \nThis is a method call of a method also named foo(), which is attached to an object stored in a \nvariable named duckie: \nduckie.foo() \nA call to a function inside of a module may look like a method call. To tell the difference, you \nneed to look at the first name and see if it is the name of a module or the name of a variable that \ncontains an object. You can tell that sys.exit() is a call to function inside of a module, \nbecause at the top of the program will be an import statement like import sys. \nA constructor function is the same thing as a normal function call, except that its return value is \na new object. Just by looking at source code, a function and constructor function look the same. \nConstructor functions (also called simply a ―constructor‖ or sometimes ―ctor‖ (―see-tor‖) for \nshort) are just a name given to functions that return a new object. But usually ctors start with a \ncapital letter. This is why when you write your own programs, your function names should only \nbegin with a lowercase letter. \nFor example, pygame.Rect() and pygame.Surface() are both constructor functions \ninside the pygame module that return new Rect and Surface objects. (These objects are \ndescribed later.) \nHere’s an example of a function call, a method call, and a call to a function inside a module: \nimport whammy \nfizzy() \n",
      "content_length": 2309,
      "extraction_method": "Direct"
    },
    {
      "page_number": 33,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    15 \n \negg = Wombat() \negg.bluhbluh() \nwhammy.spam() \nEven though these names are all made up, you can tell which is a function call, a method call, and \na call to a function inside a method. The name whammy refers to a module, since you can see it is \nbeing imported on the first line. The fizzy name has nothing before it and parentheses after it, \nso you know it is a function call. \nWombat() is also a function call, in this case it is a constructor function that returns an object. \n(The capital letter that it starts with isn’t a guarantee that it’s a constructor function rather than a \nregular function, but it is a safe bet.) The object is stored in a variable named egg. The \negg.bluhbluh() call is a method call, which you can tell because bluhbluh is attached to a \nvariable with an object in it. \nMeanwhile, whammy.spam() is a function call, not a method call. You can tell it is not a \nmethod because the name whammy was imported as a module earlier. \nSurface Objects and The Window \nSurface objects are objects that represent a rectangular 2D image. The pixels of the Surface object \ncan be changed by calling the Pygame drawing functions (described later in this chapter) and then \ndisplayed on the screen. The window border, title bar, and buttons are not part of the display \nSurface object. \nIn particular, the Surface object returned by pygame.display.set_mode() is called the \ndisplay Surface. Anything that is drawn on the display Surface object will be displayed on the \nwindow when the pygame.display.update() function is called. It is a lot faster to draw \non a Surface object (which only exists in the computer’s memory) than it is to draw a Surface \nobject to the computer screen. Computer memory is much faster to change than pixels on a \nmonitor. \nOften your program will draw several different things to a Surface object. Once you are done \ndrawing everything on the display Surface object for this iteration of the game loop (called a \nframe, just like a still image on a paused DVD is called) on a Surface object, it can be drawn to \nthe screen. The computer can draw frames very quickly, and our programs will often run around \n30 frames per second (that is, 30 FPS). This is called the ―frame rate‖ and is explained later in \nthis chapter. \nDrawing on Surface objects will be covered in the ―Primitive Drawing Functions‖ and ―Drawing \nImages‖ sections later this chapter. \n",
      "content_length": 2435,
      "extraction_method": "Direct"
    },
    {
      "page_number": 34,
      "chapter": null,
      "content": "16    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nColors \nThere are three primary colors of light: red, green and blue. (Red, blue, and yellow are the \nprimary colors for paints and pigments, but the computer monitor uses light, not paint.) By \ncombining different amounts of these three colors you can form any other color. In Pygame, we \nrepresent colors with tuples of three integers. The first value in the tuple is how much red is in the \ncolor. An integer value of 0 means there is no red in this color, and a value of 255 means there is \nthe maximum amount of red in the color. The second value is for green and the third value is for \nblue. These tuples of three integers used to represent a color are often called RGB values.  \nBecause you can use any combination of 0 to 255 for each of the three primary colors, this \nmeans Pygame can draw 16,777,216 different colors (that is, 256 x 256 x 256 colors). However, \nif try to use a number larger than 255 or a negative number, you will get an error that looks like \n―ValueError: invalid color argument‖. \nFor example, we will create the tuple (0, 0, 0) and store it in a variable named BLACK. With \nno amount of red, green, or blue, the resulting color is completely black. The color black is the \nabsence of any color. The tuple (255, 255, 255) for a maximum amount of red, green, and \nblue to result in white. The color white is the full combination of red, green, and blue. The tuple \n(255, 0, 0) represents the maximum amount of red but no amount of green and blue, so the \nresulting color is red. Similarly, (0, 255, 0) is green and (0, 0, 255) is blue. \nYou can mix the amount of red, green, and blue to form other colors. Here are the RGB values for \na few common colors: \nColor \nRGB Values \nAqua \n(  0, 255, 255) \nBlack \n(  0,   0,   0) \nBlue \n(  0,   0, 255) \nFuchsia \n(255,   0, 255) \nGray \n(128, 128, 128) \nGreen \n(  0, 128,   0) \nLime \n(  0, 255,   0) \nMaroon \n(128,   0,   0) \nNavy Blue \n(  0,   0, 128) \nOlive \n(128, 128,   0) \nPurple \n(128,   0, 128) \nRed \n(255,   0,   0) \nSilver \n(192, 192, 192) \nTeal \n(  0, 128, 128) \nWhite \n(255, 255, 255) \nYellow \n(255, 255,   0) \n \n",
      "content_length": 2198,
      "extraction_method": "Direct"
    },
    {
      "page_number": 35,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    17 \n \nTransparent Colors \nWhen you look through a glass window that has a deep red tint, all of the colors behind it have a \nred shade added to them. You can mimic this effect by adding a fourth 0 to 255 integer value to \nyour color values. \nThis value is known as the alpha value. It is a measure of how opaque (that is, not transparent) a \ncolor is. Normally when you draw a pixel onto a surface object, the new color completely \nreplaces whatever color was already there. But with colors that have an alpha value, you can \ninstead just add a colored tint to the color that is already there. \nFor example, this tuple of three integers is for the color green: (0, 255, 0). But if we add a \nfourth integer for the alpha value, we can make this a half transparent green color: (0, 255, \n0, 128). An alpha value of 255 is completely opaque (that is, not transparency at all). The \ncolors (0, 255, 0) and (0, 255, 0, 255) look exactly the same. An alpha value of 0 \nmeans the color is completely transparent. If you draw any color that has an alpha value of 0 to a \nsurface object, it will have no effect, because this color is completely transparent and invisible. \nIn order to draw using transparent colors, you must create a Surface object with the \nconvert_alpha() method. For example, the following code creates a Surface object that \ntransparent colors can be drawn on: \nanotherSurface = DISPLAYSURF.convert_alpha() \nOnce things have been drawn on the Surface object stored in anotherSurface, then \nanotherSurface can be ―blitted‖ (that is, copied) to DISPLAYSURF so it will appear on the \nscreen. (See the ―Drawing Images with pygame.image.load() and blit()‖ section later \nin this chapter.) \nIt’s important to note that you cannot use transparent colors on Surface objects not returned from \na convert_alpha() call, including the display Surface that was returned from \npygame.display.set_mode(). \nIf we were to create a color tuple to draw the legendary Invisible Pink Unicorn, we would use \n(255, 192, 192, 0), which ends up looking completely invisible just like any other color \nthat has a 0 for its alpha value. It is, after all, invisible. \n",
      "content_length": 2181,
      "extraction_method": "Direct"
    },
    {
      "page_number": 36,
      "chapter": null,
      "content": "18    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n(Above is a screenshot of a drawing of the Invisible Pink Unicorn.) \npygame.Color Objects \nYou need to know how to represent a color because Pygame’s drawing functions need a way to \nknow what color you want to draw with. A tuple of three or four integers is one way. Another \nway is as a pygame.Color object. You can create Color objects by calling the \npygame.Color() constructor function and passing either three or four integers. You can store \nthis Color object in variables just like you can store tuples in variables. Try typing the following \ninto the interactive shell: \n>>> import pygame \n>>> pygame.Color(255, 0, 0) \n(255, 0, 0, 255) \n>>> myColor = pygame.Color(255, 0, 0, 128) \n>>> myColor == (255, 0, 0, 128) \nTrue \n>>> \nAny drawing function in Pygame (which we will learn about in a bit) that has a parameter for \ncolor can have either the tuple form or Color object form of a color passed for it. Even though \nthey are different data types, a Color object is equal to a tuple of four integers if they both \nrepresent the same color (just like how 42 == 42.0 will evaluate to True). \nNow that you know how to represent colors (as a pygame.Color object or a tuple of three or \nfour integers for red, green, blue, and optionally alpha) and coordinates (as a tuple of two integers \nfor X and Y), let’s learn about pygame.Rect objects so we can start using Pygame’s drawing \nfunctions. \nRect Objects \nPygame has two ways to represent rectangular areas (just like there are two ways to represent \ncolors). The first is a tuple of four integers:  \n1. The X coordinate of the top left corner. \n",
      "content_length": 1705,
      "extraction_method": "Direct"
    },
    {
      "page_number": 37,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    19 \n \n2. The Y coordinate of the top left corner. \n3. The width (in pixels) of the rectangle. \n4. Then height (in pixels) of the rectangle. \nThe second way is as a pygame.Rect object, which we will call Rect objects for short. For \nexample, the code below creates a Rect object with a top left corner at (10, 20) that is 200 pixels \nwide and 300 pixels tall: \n>>> import pygame \n>>> spamRect = pygame.Rect(10, 20, 200, 300) \n>>> spamRect == (10, 20, 200, 300) \nTrue \nThe handy thing about this is that the Rect object automatically calculates the coordinates for \nother features of the rectangle. For example, if you need to know the X coordinate of the right \nedge of the pygame.Rect object we stored in the spamRect variable, you can just access the \nRect object’s right attribute: \n>>> spamRect.right \n210 \nThe Pygame code for the Rect object automatically calculated that if the left edge is at the X \ncoordinate 10 and the rectangle is 200 pixels wide, then the right edge must be at the X \ncoordinate 210. If you reassign the right attribute, all the other attributes are automatically \nrecalculated: \n>>> spam.right = 350 \n>>> spam.left \n150 \nHere’s a list of all the attributes that pygame.Rect objects provide (in our example, the \nvariable where the Rect object is stored in a variable named myRect): \n",
      "content_length": 1341,
      "extraction_method": "Direct"
    },
    {
      "page_number": 38,
      "chapter": null,
      "content": "20    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nAttribute Name \nDescription \nmyRect.left \nThe int value of the X-coordinate of the left side of the rectangle. \nmyRect.right \nThe int value of the X-coordinate of the right side of the rectangle. \nmyRect.top \nThe int value of the Y-coordinate of the top side of the rectangle. \nmyRect.bottom \nThe int value of the Y-coordinate of the bottom side. \nmyRect.centerx \nThe int value of the X-coordinate of the center of the rectangle. \nmyRect.centery \nThe int value of the Y-coordinate of the center of the rectangle. \nmyRect.width \nThe int value of the width of the rectangle. \nmyRect.height \nThe int value of the height of the rectangle. \nmyRect.size \nA tuple of two ints: (width, height) \nmyRect.topleft \nA tuple of two ints: (left, top) \nmyRect.topright \nA tuple of two ints: (right, top) \nmyRect.bottomleft \nA tuple of two ints: (left, bottom) \nmyRect.bottomright A tuple of two ints: (right, bottom) \nmyRect.midleft \nA tuple of two ints: (left, centery) \nmyRect.midright \nA tuple of two ints: (right, centery) \nmyRect.midtop \nA tuple of two ints: (centerx, top) \nmyRect.midbottom \nA tuple of two ints: (centerx, bottom) \nPrimitive Drawing Functions \nPygame provides several different functions for drawing different shapes onto a surface object. \nThese shapes such as rectangles, circles, ellipses, lines, or individual pixels are often called \ndrawing primitives. Open IDLE’s file editor and type in the following program, and save it as \ndrawing.py. \n 1. import pygame, sys \n 2. from pygame.locals import * \n",
      "content_length": 1613,
      "extraction_method": "Direct"
    },
    {
      "page_number": 39,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    21 \n \n 3.  \n 4. pygame.init() \n 5.  \n 6. # set up the window \n 7. DISPLAYSURF = pygame.display.set_mode((500, 400), 0, 32) \n 8. pygame.display.set_caption('Drawing') \n 9.  \n10. # set up the colors \n11. BLACK = (  0,   0,   0) \n12. WHITE = (255, 255, 255) \n13. RED   = (255,   0,   0) \n14. GREEN = (  0, 255,   0) \n15. BLUE  = (  0,   0, 255) \n16.  \n17. # draw on the surface object \n18. DISPLAYSURF.fill(WHITE) \n19. pygame.draw.polygon(DISPLAYSURF, GREEN, ((146, 0), (291, 106), (236, 277), \n(56, 277), (0, 106))) \n20. pygame.draw.line(DISPLAYSURF, BLUE, (60, 60), (120, 60), 4) \n21. pygame.draw.line(DISPLAYSURF, BLUE, (120, 60), (60, 120)) \n22. pygame.draw.line(DISPLAYSURF, BLUE, (60, 120), (120, 120), 4) \n23. pygame.draw.circle(DISPLAYSURF, BLUE, (300, 50), 20, 0) \n24. pygame.draw.ellipse(DISPLAYSURF, RED, (300, 250, 40, 80), 1) \n25. pygame.draw.rect(DISPLAYSURF, RED, (200, 150, 100, 50)) \n26.  \n27. pixObj = pygame.PixelArray(DISPLAYSURF) \n28. pixObj[480][380] = BLACK \n29. pixObj[482][382] = BLACK \n30. pixObj[484][384] = BLACK \n31. pixObj[486][386] = BLACK \n32. pixObj[488][388] = BLACK \n33. del pixObj \n34.  \n35. # run the game loop \n36. while True: \n37.     for event in pygame.event.get(): \n38.         if event.type == QUIT: \n39.             pygame.quit() \n40.             sys.exit() \n41.     pygame.display.update() \nWhen this program is run, the following window is displayed until the user closes the window: \n",
      "content_length": 1457,
      "extraction_method": "Direct"
    },
    {
      "page_number": 40,
      "chapter": null,
      "content": "22    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nNotice how we make constant variables for each of the colors. Doing this makes our code more \nreadable, because seeing GREEN in the source code is much easier to understand as representing \nthe color green than (0, 255, 0) is.  \nThe drawing functions are named after the shapes they draw. The parameters you pass these \nfunctions tell them which Surface object to draw on, where to draw the shape (and what size), in \nwhat color, and how wide to make the lines. You can see how these functions are called in the \ndrawing.py program, but here is a short description of each function: \n \n \nfill(color) – The fill() method is not a function but a method of pygame.Surface \nobjects. It will completely fill in the entire Surface object with whatever color value you pass \nas for the color parameter. \n \npygame.draw.polygon(surface, color, pointlist, width) – A polygon is shape made up of \nonly flat sides. The surface and color parameters tell the function on what surface to \ndraw the polygon, and what color to make it. \nThe pointlist parameter is a tuple or list of points (that is, tuple or list of two-integer \ntuples for XY coordinates). The polygon is drawn by drawing lines between each point and \nthe point that comes after it in the tuple. Then a line is drawn from the last point to the first \npoint. You can also pass a list of points instead of a tuple of points. \nThe width parameter is optional. If you leave it out, the polygon that is drawn will be filled \nin, just like our green polygon on the screen is filled in with color. If you do pass an integer \nvalue for the width parameter, only the outline of the polygon will be drawn. The integer \nrepresents how many pixels width the polygon’s outline will be. Passing 1 for the width \nparameter will make a skinny polygon, while passing 4 or 10 or 20 will make thicker \npolygons. If you pass the integer 0 for the width parameter, the polygon will be filled in \n(just like if you left the width parameter out entirely). \nAll of the pygame.draw drawing functions have optional width parameters at the end, \nand they work the same way as pygame.draw.polygon()’s width parameter. \nProbably a better name for the width parameter would have been thickness, since that \nparameter controls how thick the lines you draw are. \n",
      "content_length": 2388,
      "extraction_method": "Direct"
    },
    {
      "page_number": 41,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    23 \n \n \npygame.draw.line(surface, color, start_point, end_point, width) – This function draws a \nline between the start_point and end_point parameters. \n \npygame.draw.lines(surface, color, closed, pointlist, width) – This function draws a series \nof lines from one point to the next, much like pygame.draw.polygon(). The only \ndifference is that if you pass False for the closed parameter, there will not be a line from \nthe last point in the pointlist parameter to the first point. If you pass True, then it will \ndraw a line from the last point to the first. \n \npygame.draw.circle(surface, color, center_point, radius, width) – This function draws a \ncircle. The center of the circle is at the center_point parameter. The integer passed for \nthe radius parameter sets the size of the circle. \nThe radius of a circle is the distance from the center to the edge. (The radius of a circle is \nalways half of the diameter.) Passing 20 for the radius parameter will draw a circle that \nhas a radius of 20 pixels. \n \npygame.draw.ellipse(surface, color, bounding_rectangle, width) – This function draws an \nellipse (which is like a squashed or stretched circle). This function has all the usual \nparameters, but in order to tell the function how large and where to draw the ellipse, you must \nspecify the bounding rectangle of the ellipse. A bounding rectangle is the smallest rectangle \nthat can be drawn around a shape. Here’s an example of an ellipse and its bounding rectangle: \n \nThe bounding_rectangle parameter can be a pygame.Rect object or a tuple of four \nintegers. Note that you do not specify the center point for the ellipse like you do for the \npygame.draw.circle() function. \n \npygame.draw.rect(surface, color, rectangle_tuple, width) – This function draws a \nrectangle. The rectangle_tuple is either a tuple of four integers (for the XY coordinates \nof the top left corner, and the width and height) or a pygame.Rect object can be passed \ninstead. If the rectangle_tuple has the same size for the width and height, a square will \nbe drawn. \npygame.PixelArray Objects \nUnfortunately, there isn’t a single function you can call that will set a single pixel to a color \n(unless you call pygame.draw.line() with the same start and end point). The Pygame \nframework needs to run some code behind the scenes before and after drawing to a Surface \nobject. If it had to do this for every single pixel you wanted to set, your program would run much \nslower. (By my quick testing, drawing pixels this way is two or three times slower.) \nInstead, you should create a pygame.PixelArray object (we’ll call them PixelArray objects \nfor short) of a Surface object and then set individual pixels. Creating a PixelArray object of a \nSurface object will ―lock‖ the Surface object. While a Surface object is locked, the drawing \n",
      "content_length": 2854,
      "extraction_method": "Direct"
    },
    {
      "page_number": 42,
      "chapter": null,
      "content": "24    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nfunctions can still be called on it, but it cannot have images like PNG or JPG images drawn on it \nwith the blit() method. (The blit() method is explained later in this chapter.) \nIf you want to see if a Surface object is locked, the get_locked() Surface method will return \nTrue if it is locked and False if it is not. \nThe PixelArray object that is returned from pygame.PixelArray() can have individual \npixels set by accessing them with two indexes. For example, line 28’s pixObj[480][380] = \nBLACK will set the pixel at X coordinate 480 and Y coordinate 380 to be black (remember that \nthe BLACK variable stores the color tuple (0, 0, 0)). \nTo tell Pygame that you are finished drawing individual pixels, delete the PixelArray object with \na del statement. This is what line 33 does. Deleting the PixelArray object will ―unlock‖ the \nSurface object so that you can once again draw images on it. If you forget to delete the \nPixelArray object, the next time you try to blit (that is, draw) an image to the Surface the program \nwill raise an error that says, ―pygame.error: Surfaces must not be locked \nduring blit‖. \nThe pygame.display.update() Function \nAfter you are done calling the drawing functions to make the display Surface object look the way \nyou want, you must call pygame.display.update() to make the display Surface actually \nappear on the user’s monitor. \nThe one thing that you must remember is that pygame.display.update() will only make \nthe display Surface (that is, the Surface object that was returned from the call to \npygame.display.set_mode()) appear on the screen. If you want the images on other \nSurface objects to appear on the screen, you must ―blit‖ them (that is, copy them) to the display \nSurface object with the blit() method (which is explained next in the ―Drawing Images‖ \nsection). \nAnimation \nNow that we know how to get the Pygame framework to draw to the screen, let’s learn how to \nmake animated pictures. A game with only still, unmoving images would be fairly dull. (Sales of \nmy game ―Look At This Rock‖ have been disappointing.) Animated images are the result of \ndrawing an image on the screen, then a split second later drawing a slightly different image on the \nscreen. Imagine the program’s window was 6 pixels wide and 1 pixel tall, with all the pixels \nwhite except for a black pixel at 4, 0. It would look like this: \n",
      "content_length": 2475,
      "extraction_method": "Direct"
    },
    {
      "page_number": 43,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    25 \n \n \nIf you changed the window so that 3, 0 was black and 4,0 was white, it would look like this: \n \nTo the user, it looks like the black pixel has ―moved‖ over to the left. If you redrew the window \nto have the black pixel at 2, 0, it would continue to look like the black pixel is moving left: \n \nIt may look like the black pixel is moving, but this is just an illusion. To the computer, it is just \nshowing three different images that each just happen to have one black pixel. Consider if the \nthree following images were rapidly shown on the screen: \n \nTo the user, it would look like the cat is moving towards the squirrel. But to the computer, they’re \njust a bunch of pixels. The trick to making believable looking animation is to have your program \ndraw a picture to the window, wait a fraction of a second, and then draw a slightly different \npicture. \nHere is an example program demonstrating a simple animation. Type this code into IDLE’s file \neditor and save it as catanimation.py. It will also require the image file cat.png to be in the same \nfolder as the catanimation.py file. You can download this image from http://invpy.com/cat.png. \nThis code is available at http://invpy.com/catanimation.py. \n",
      "content_length": 1247,
      "extraction_method": "Direct"
    },
    {
      "page_number": 44,
      "chapter": null,
      "content": "26    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 1. import pygame, sys \n 2. from pygame.locals import * \n 3.  \n 4. pygame.init() \n 5.  \n 6. FPS = 30 # frames per second setting \n 7. fpsClock = pygame.time.Clock() \n 8.  \n 9. # set up the window \n10. DISPLAYSURF = pygame.display.set_mode((400, 300), 0, 32) \n11. pygame.display.set_caption('Animation') \n12. \n13. WHITE = (255, 255, 255) \n14. catImg = pygame.image.load('cat.png') \n15. catx = 10 \n16. caty = 10 \n17. direction = 'right' \n18. \n19. while True: # the main game loop \n20.     DISPLAYSURF.fill(WHITE) \n21.  \n22.     if direction == 'right': \n23.         catx += 5 \n24.         if catx == 280: \n25.             direction = 'down' \n26.     elif direction == 'down': \n27.         caty += 5 \n28.         if caty == 220: \n29.             direction = 'left' \n30.     elif direction == 'left': \n31.         catx -= 5 \n32.         if catx == 10: \n33.             direction = 'up' \n34.     elif direction == 'up': \n35.         caty -= 5 \n36.         if caty == 10: \n37.             direction = 'right' \n38.  \n39.     DISPLAYSURF.blit(catImg, (catx, caty)) \n40.  \n41.     for event in pygame.event.get(): \n42.         if event.type == QUIT: \n43.             pygame.quit() \n44.             sys.exit() \n45. \n46.     pygame.display.update() \n",
      "content_length": 1341,
      "extraction_method": "Direct"
    },
    {
      "page_number": 45,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    27 \n \n47.     fpsClock.tick(FPS) \nLook at that animated cat go! This program will be much more of a commercial success than my \ngame, ―Look At This Rock 2: A Different Rock‖. \nFrames Per Second and pygame.time.Clock Objects \nThe frame rate or refresh rate is the number of pictures that the program draws per second, and \nis measured in FPS or frames per second. (On computer monitors, the common name for FPS is \nhertz. Many monitors have a frame rate of 60 hertz, or 60 frames per second.) A low frame rate in \nvideo games can make the game look choppy or jumpy. If the program has too much code to run \nto draw to the screen frequently enough, then the FPS goes down. But the games in this book are \nsimple enough that this won’t be issue even on old computers. \nA pygame.time.Clock object can help us make sure our program runs at a certain maximum \nFPS. This Clock object will ensure that our game programs don’t run too fast by putting in \nsmall pauses on each iteration of the game loop. If we didn’t have these pauses, our game \nprogram would run as fast as the computer could run it. This is often too fast for the player, and \nas computers get faster they would run the game faster too. A call to the tick() method of a \nClock object in the game loop can make sure the game runs at the same speed no matter how \nfast of a computer it runs on. The Clock object is created on line 7 of the catanimation.py \nprogram. \n7. fpsClock = pygame.time.Clock() \nThe Clock object’s tick() method should be called at the very end of the game loop, after the \ncall to pygame.display.update(). The length of the pause is calculated based on how \nlong it has been since the previous call to tick(), which would have taken place at the end of \nthe previous iteration of the game loop. (The first time the tick() method is called, it doesn’t \npause at all.) In the animation program, is it run on line 47 as the last instruction in the game loop. \nAll you need to know is that you should call the tick() method once per iteration through the \ngame loop at the end of the loop. Usually this is right after the call to \npygame.display.update(). \n47.     fpsClock.tick(FPS) \nTry modifying the FPS constant variable to run the same program at different frame rates. Setting \nit to a lower value would make the program run slower. Setting it to a higher value would make \nthe program run faster. \n",
      "content_length": 2412,
      "extraction_method": "Direct"
    },
    {
      "page_number": 46,
      "chapter": null,
      "content": "28    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nDrawing Images with pygame.image.load() and blit() \nThe drawing functions are fine if you want to draw simple shapes on the screen, but many games \nhave images (also called sprites). Pygame is able to load images onto Surface objects from PNG, \nJPG, GIF, and BMP image files. The differences between these image file formats is described at \nhttp://invpy.com/formats. \nThe image of the cat was stored in a file named cat.png. To load this file’s image, the string \n'cat.png' is passed to the pygame.image.load() function. The \npygame.image.load() function call will return a Surface object that has the image drawn \non it. This Surface object will be a separate Surface object from the display Surface object, so we \nmust blit (that is, copy) the image’s Surface object to the display Surface object. Blitting is \ndrawing the contents of one Surface onto another. It is done with the blit() Surface object \nmethod. \nIf you get an error message like ―pygame.error: Couldn't open cat.png‖ when \ncalling pygame.image.load(), then make sure the cat.png file is in the same folder as the \ncatanimation.py file before you run the program. \n39.     DISPLAYSURF.blit(catImg, (catx, caty)) \nLine 39 of the animation program uses the blit() method to copy catImg to DISPLAYSURF. \nThere are two parameters for blit(). The first is the source Surface object, which is what will \nbe copied onto the DISPLAYSURF Surface object. The second parameter is a two-integer tuple \nfor the X and Y values of the topleft corner where the image should be blitted to. \nIf catx and caty were set to 100 and 200 and the width of catImg was 125 and the height \nwas 79, this blit() call would copy this image onto DISPLAYSURF so that the top left corner \nof the catImg was at the XY coordinate (100, 200) and the bottom right corner’s XY coordinate \nwas at (225, 279). \nNote that you cannot blit to a Surface that is currently ―locked‖ (such as when a PixelArray object \nhas been made from it and not yet been deleted.) \nThe rest of the game loop is just changing the catx, caty, and direction variables so that \nthe cat moves around the window. There is also a call to pygame.event.get() to handle the \nQUIT event. \nFonts \nIf you want to draw text to the screen, you could write several calls to pygame.draw.line() \nto draw out the lines of each letter. This would be a headache to type out all those \n",
      "content_length": 2475,
      "extraction_method": "Direct"
    },
    {
      "page_number": 47,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    29 \n \npygame.draw.line() calls and figure out all the XY coordinates, and probably wouldn’t \nlook very good. \n \nThe above message would take forty one calls to the pygame.draw.line() function to \nmake. Instead, Pygame provides some much simpler functions for fonts and creating text. Here is \na small Hello World program using Pygame’s font functions. Type it into IDLE’s file editor and \nsave it as fonttext.py: \n 1. import pygame, sys \n 2. from pygame.locals import * \n 3. \n 4. pygame.init() \n 5. DISPLAYSURF = pygame.display.set_mode((400, 300)) \n 6. pygame.display.set_caption('Hello World!') \n 7.  \n 8. WHITE = (255, 255, 255) \n 9. GREEN = (0, 255, 0) \n10. BLUE = (0, 0, 128) \n11.  \n12. fontObj = pygame.font.Font('freesansbold.ttf', 32) \n13. textSurfaceObj = fontObj.render('Hello world!', True, GREEN, BLUE) \n14. textRectObj = textSurfaceObj.get_rect() \n15. textRectObj.center = (200, 150) \n16. \n17. while True: # main game loop \n18.     DISPLAYSURF.fill(WHITE) \n19.     DISPLAYSURF.blit(textSurfaceObj, textRectObj) \n20.     for event in pygame.event.get(): \n21.         if event.type == QUIT: \n22.             pygame.quit() \n23.             sys.exit() \n24.     pygame.display.update() \nThere are six steps to making text appear on the screen: \n1. Create a pygame.font.Font object. (Like on line 12) \n2. Create a Surface object with the text drawn on it by calling the Font object’s render() \nmethod. (Line 13) \n3. Create a Rect object from the Surface object by calling the Surface object’s \nget_rect() method. (Line 14) This Rect object will have the width and height \ncorrectly set for the text that was rendered, but the top and left attributes will be 0. \n",
      "content_length": 1698,
      "extraction_method": "Direct"
    },
    {
      "page_number": 48,
      "chapter": null,
      "content": "30    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n4. Set the position of the Rect object by changing one of its attributes. On line 15, we set the \ncenter of the Rect object to be at 200, 150. \n5. Blit the Surface object with the text onto the Surface object returned by \npygame.display.set_mode(). (Line 19) \n6. Call pygame.display.update() to make the display Surface appear on the screen. \n(Line 24) \nThe parameters to the pygame.font.Font() constructor function is a string of the font file to \nuse, and an integer of the size of the font (in points, like how word processors measure font size). \nOn line 12, we pass 'freesansbold.ttf' (this is a font that comes with Pygame) and the \ninteger 32 (for a 32-point sized font). \nSee http://invpy.com/usingotherfonts for more info on using other fonts. \nThe parameters to the render() method call are a string of the text to render, a Boolean value \nto specify if we want anti-aliasing (explained later in this chapter), the color of the text, and the \ncolor of the background. If you want a transparent background, then simply leave off the \nbackground color parameter in the method call. \nAnti-Aliasing \nAnti-aliasing is a graphics technique for making text and shapes look less blocky by adding a \nlittle bit of blur to their edges. It takes a little more computation time to draw with anti-aliasing, \nso although the graphics may look better, your program may run slower (but only just a little). \nIf you zoom in on an aliased line and an anti-aliased line, they look like this: \n \nTo make Pygame’s text use anti-aliasing, just pass True for the second parameter of the \nrender() method. The pygame.draw.aaline() and pygame.draw.aalines() \nfunctions have the same parameters as pygame.draw.line() and \n",
      "content_length": 1808,
      "extraction_method": "Direct"
    },
    {
      "page_number": 49,
      "chapter": null,
      "content": "Chapter 2 – Pygame Basics    31 \n \npygame.draw.lines(), except they will draw anti-aliased (smooth) lines instead of aliased \n(blocky) lines. \nPlaying Sounds \nPlaying sounds that are stored in sound files is even simpler than displaying images from image \nfiles. First, you must create a pygame.mixer.Sound object (which we will call Sound objects \nfor short) by calling the pygame.mixer.Sound() constructor function. It takes one string \nparameter, which is the filename of the sound file. Pygame can load WAV, MP3, or OGG files. \nThe difference between these audio file formats is explained at http://invpy.com/formats. \nTo play this sound, call the Sound object’s play() method. If you want to immediately stop the \nSound object from playing call the stop() method. The stop() method has no arguments. \nHere is some sample code: \nsoundObj = pygame.mixer.Sound('beeps.wav') \nsoundObj.play() \nimport time \ntime.sleep(1) # wait and let the sound play for 1 second \nsoundObj.stop() \nYou can download the beeps.wav file from http://invpy.com/beeps.wav. \nThe program execution continues immediately after play() is called; it does not wait for the \nsound to finish playing before moving on to the next line of code. \nThe Sound objects are good for sound effects to play when the player takes damage, slashes a \nsword, or collects a coin. But your games might also be better if they had background music \nplaying regardless of what was going on in the game. Pygame can only load one music file to \nplay in the background at a time. To load a background music file, call the \npygame.mixer.music.load() function and pass it a string argument of the sound file to \nload. This file can be WAV, MP3, or MIDI format.  \nTo begin playing the loaded sound file as the background music, call the \npygame.mixer.music.play(-1, 0.0) function. The -1 argument makes the \nbackground music forever loop when it reaches the end of the sound file. If you set it to an integer \n0 or larger, then the music will only loop that number of times instead of looping forever. The \n0.0 means to start playing the sound file from the beginning. If you pass a larger integer or float, \nthe music will begin playing that many seconds into the sound file. For example, if you pass \n13.5 for the second parameter, the sound file with begin playing at the point 13.5 seconds in \nfrom the beginning. \n",
      "content_length": 2364,
      "extraction_method": "Direct"
    },
    {
      "page_number": 50,
      "chapter": null,
      "content": "32    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nTo stop playing the background music immediately, call the pygame.mixer.music.stop() \nfunction. This function has no arguments. \nHere is some example code of the sound methods and functions: \n# Loading and playing a sound effect: \nsoundObj = pygame.mixer.Sound('beepingsound.wav') \nsoundObj.play() \n \n# Loading and playing background music: \npygame.mixer.music.load(backgroundmusic.mp3') \npygame.mixer.music.play(-1, 0.0) \n# ...some more of your code goes here... \npygame.mixer.music.stop() \nSummary \nThis covers the basics of making graphical games with the Pygame framework. Of course, just \nreading about these functions probably isn’t enough to help you learn how to make games using \nthese functions. The rest of the chapters in this book each focus on the source code for a small, \ncomplete game. This will give you an idea of what complete game programs ―look like‖, so you \ncan then get some ideas for how to code your own game programs. \nUnlike the ―Invent Your Own Computer Games with Python‖ book, this book assumes that you \nknow the basics of Python programming. If you have trouble remembering how variables, \nfunctions, loops, if-else statements, and conditions work, you can probably figure it out just \nby seeing what’s in the code and how the program behaves. But if you are still stuck, you can \nread the ―Invent with Python‖ book (it’s for people who are completely new to programming) for \nfree online at http://inventwithpython.com. \n \n \n",
      "content_length": 1562,
      "extraction_method": "Direct"
    },
    {
      "page_number": 51,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    33 \n \nCHAPTER 3 – MEMORY \nPUZZLE \n \nHow to Play Memory Puzzle \nIn the Memory Puzzle game, several icons are covered up by white boxes. There are two of each \nicon. The player can click on two boxes to see what icon is behind them. If the icons match, then \nthose boxes remain uncovered. The player wins when all the boxes on the board are uncovered. \nTo give the player a hint, the boxes are quickly uncovered once at the beginning of the game. \nNested for Loops \nOne concept that you will see in Memory Puzzle (and most of the games in this book) is the use \nof a for loop inside of another for loop. These are called nested for loops. Nested for loops \nare handy for going through every possible combination of two lists. Type the following into the \ninteractive shell: \n>>> for x in [0, 1, 2, 3, 4]: \n...     for y in ['a', 'b', 'c']: \n...         print(x, y) \n... \n0 a \n0 b \n0 c \n1 a \n1 b \n1 c \n2 a \n",
      "content_length": 933,
      "extraction_method": "Direct"
    },
    {
      "page_number": 52,
      "chapter": null,
      "content": "34    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n2 b \n2 c \n3 a \n3 b \n3 c \n4 a \n4 b \n4 c \n>>> \nThere are several times in the Memory Puzzle code that we need to iterate through every possible \nX and Y coordinate on the board. We’ll use nested for loops to make sure that we get every \ncombination. Note that the inner for loop (the for loop inside the other for loop) will go \nthrough all of its iterations before going to the next iteration of the outer for loop. If we reverse \nthe order of the for loops, the same values will be printed but they will be printed in a different \norder. Type the following code into the interactive shell, and compare the order it prints values to \nthe order in the previous nested for loop example: \n>>> for y in ['a', 'b', 'c']: \n...     for x in [0, 1, 2, 3, 4]: \n...         print(x, y) \n... \n0 a \n1 a \n2 a \n3 a \n4 a \n0 b \n1 b \n2 b \n3 b \n4 b \n0 c \n1 c \n2 c \n3 c \n4 c \n>>> \nSource Code of Memory Puzzle \nThis source code can be downloaded from http://invpy.com/memorypuzzle.py. \nGo ahead and first type in the entire program into IDLE’s file editor, save it as memorypuzzle.py, \nand run it. If you get any error messages, look at the line number that is mentioned in the error \n",
      "content_length": 1267,
      "extraction_method": "Direct"
    },
    {
      "page_number": 53,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    35 \n \nmessage and check your code for any typos. You can also copy and paste your code into the web \nform at http://invpy.com/diff/memorypuzzle to see if the differences between your code and the \ncode in the book. \nYou’ll probably pick up a few ideas about how the program works just by typing it in once. And \nwhen you’re done typing it in, you can then play the game for yourself. \n  1. # Memory Puzzle \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Released under a \"Simplified BSD\" license \n  5.  \n  6. import random, pygame, sys \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 # frames per second, the general speed of the program \n 10. WINDOWWIDTH = 640 # size of window's width in pixels \n 11. WINDOWHEIGHT = 480 # size of windows' height in pixels \n 12. REVEALSPEED = 8 # speed boxes' sliding reveals and covers \n 13. BOXSIZE = 40 # size of box height & width in pixels \n 14. GAPSIZE = 10 # size of gap between boxes in pixels \n 15. BOARDWIDTH = 10 # number of columns of icons \n 16. BOARDHEIGHT = 7 # number of rows of icons \n 17. assert (BOARDWIDTH * BOARDHEIGHT) % 2 == 0, 'Board needs to have an even \nnumber of boxes for pairs of matches.' \n 18. XMARGIN = int((WINDOWWIDTH - (BOARDWIDTH * (BOXSIZE + GAPSIZE))) / 2) \n 19. YMARGIN = int((WINDOWHEIGHT - (BOARDHEIGHT * (BOXSIZE + GAPSIZE))) / 2) \n 20.  \n 21. #            R    G    B \n 22. GRAY     = (100, 100, 100) \n 23. NAVYBLUE = ( 60,  60, 100) \n 24. WHITE    = (255, 255, 255) \n 25. RED      = (255,   0,   0) \n 26. GREEN    = (  0, 255,   0) \n 27. BLUE     = (  0,   0, 255) \n 28. YELLOW   = (255, 255,   0) \n 29. ORANGE   = (255, 128,   0) \n 30. PURPLE   = (255,   0, 255) \n 31. CYAN     = (  0, 255, 255) \n 32.  \n 33. BGCOLOR = NAVYBLUE \n 34. LIGHTBGCOLOR = GRAY \n 35. BOXCOLOR = WHITE \n 36. HIGHLIGHTCOLOR = BLUE \n 37.  \n 38. DONUT = 'donut' \n",
      "content_length": 1903,
      "extraction_method": "Direct"
    },
    {
      "page_number": 54,
      "chapter": null,
      "content": "36    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 39. SQUARE = 'square' \n 40. DIAMOND = 'diamond' \n 41. LINES = 'lines' \n 42. OVAL = 'oval' \n 43.  \n 44. ALLCOLORS = (RED, GREEN, BLUE, YELLOW, ORANGE, PURPLE, CYAN) \n 45. ALLSHAPES = (DONUT, SQUARE, DIAMOND, LINES, OVAL) \n 46. assert len(ALLCOLORS) * len(ALLSHAPES) * 2 >= BOARDWIDTH * BOARDHEIGHT, \n\"Board is too big for the number of shapes/colors defined.\" \n 47.  \n 48. def main(): \n 49.     global FPSCLOCK, DISPLAYSURF \n 50.     pygame.init() \n 51.     FPSCLOCK = pygame.time.Clock() \n 52.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 53.  \n 54.     mousex = 0 # used to store x coordinate of mouse event \n 55.     mousey = 0 # used to store y coordinate of mouse event \n 56.     pygame.display.set_caption('Memory Game') \n 57.  \n 58.     mainBoard = getRandomizedBoard() \n 59.     revealedBoxes = generateRevealedBoxesData(False) \n 60.  \n 61.     firstSelection = None # stores the (x, y) of the first box clicked. \n 62.  \n 63.     DISPLAYSURF.fill(BGCOLOR) \n 64.     startGameAnimation(mainBoard) \n 65.  \n 66.     while True: # main game loop \n 67.         mouseClicked = False \n 68.  \n 69.         DISPLAYSURF.fill(BGCOLOR) # drawing the window \n 70.         drawBoard(mainBoard, revealedBoxes) \n 71.  \n 72.         for event in pygame.event.get(): # event handling loop \n 73.             if event.type == QUIT or (event.type == KEYUP and event.key == \nK_ESCAPE): \n 74.                 pygame.quit() \n 75.                 sys.exit() \n 76.             elif event.type == MOUSEMOTION: \n 77.                 mousex, mousey = event.pos \n 78.             elif event.type == MOUSEBUTTONUP: \n 79.                 mousex, mousey = event.pos \n 80.                 mouseClicked = True \n 81.  \n 82.         boxx, boxy = getBoxAtPixel(mousex, mousey) \n",
      "content_length": 1878,
      "extraction_method": "Direct"
    },
    {
      "page_number": 55,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    37 \n \n 83.         if boxx != None and boxy != None: \n 84.             # The mouse is currently over a box. \n 85.             if not revealedBoxes[boxx][boxy]: \n 86.                drawHighlightBox(boxx, boxy) \n 87.             if not revealedBoxes[boxx][boxy] and mouseClicked: \n 88.                 revealBoxesAnimation(mainBoard, [(boxx, boxy)]) \n 89.                 revealedBoxes[boxx][boxy] = True # set the box as \n\"revealed\" \n 90.                 if firstSelection == None: # the current box was the first \nbox clicked \n 91.                     firstSelection = (boxx, boxy) \n 92.                 else: # the current box was the second box clicked \n 93.                     # Check if there is a match between the two icons. \n 94.                     icon1shape, icon1color = getShapeAndColor(mainBoard, \nfirstSelection[0], firstSelection[1]) \n 95.                     icon2shape, icon2color = getShapeAndColor(mainBoard, \nboxx, boxy) \n 96.  \n 97.                     if icon1shape != icon2shape or icon1color != \nicon2color: \n 98.                         # Icons don't match. Re-cover up both selections. \n 99.                         pygame.time.wait(1000) # 1000 milliseconds = 1 sec \n100.                         coverBoxesAnimation(mainBoard, \n[(firstSelection[0], firstSelection[1]), (boxx, boxy)]) \n101.                         revealedBoxes[firstSelection[0]][firstSelection \n[1]] = False \n102.                         revealedBoxes[boxx][boxy] = False \n103.                     elif hasWon(revealedBoxes): # check if all pairs found \n104.                         gameWonAnimation(mainBoard) \n105.                         pygame.time.wait(2000) \n106.  \n107.                         # Reset the board \n108.                         mainBoard = getRandomizedBoard() \n109.                         revealedBoxes = generateRevealedBoxesData(False) \n110.  \n111.                         # Show the fully unrevealed board for a second. \n112.                         drawBoard(mainBoard, revealedBoxes) \n113.                         pygame.display.update() \n114.                         pygame.time.wait(1000) \n115.  \n116.                         # Replay the start game animation. \n117.                         startGameAnimation(mainBoard) \n \n118.                     firstSelection = None # reset firstSelection variable \n119.  \n120.         # Redraw the screen and wait a clock tick. \n121.         pygame.display.update() \n",
      "content_length": 2462,
      "extraction_method": "Direct"
    },
    {
      "page_number": 56,
      "chapter": null,
      "content": "38    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n122.         FPSCLOCK.tick(FPS) \n123.  \n124.  \n125. def generateRevealedBoxesData(val): \n126.     revealedBoxes = [] \n127.     for i in range(BOARDWIDTH): \n128.         revealedBoxes.append([val] * BOARDHEIGHT) \n129.     return revealedBoxes \n130.  \n131.  \n132. def getRandomizedBoard(): \n133.     # Get a list of every possible shape in every possible color. \n134.     icons = [] \n135.     for color in ALLCOLORS: \n136.         for shape in ALLSHAPES: \n137.             icons.append( (shape, color) ) \n138.  \n139.     random.shuffle(icons) # randomize the order of the icons list \n140.     numIconsUsed = int(BOARDWIDTH * BOARDHEIGHT / 2) # calculate how many \nicons are needed \n141.     icons = icons[:numIconsUsed] * 2 # make two of each \n142.     random.shuffle(icons) \n143. \n144.     # Create the board data structure, with randomly placed icons. \n145.     board = [] \n146.     for x in range(BOARDWIDTH): \n147.         column = [] \n148.         for y in range(BOARDHEIGHT): \n149.             column.append(icons[0]) \n150.             del icons[0] # remove the icons as we assign them \n151.         board.append(column) \n152.     return board \n153.  \n154.  \n155. def splitIntoGroupsOf(groupSize, theList): \n156.     # splits a list into a list of lists, where the inner lists have at \n157.     # most groupSize number of items. \n158.     result = [] \n159.     for i in range(0, len(theList), groupSize): \n160.         result.append(theList[i:i + groupSize]) \n161.     return result \n162.  \n163.  \n164. def leftTopCoordsOfBox(boxx, boxy): \n165.     # Convert board coordinates to pixel coordinates \n166.     left = boxx * (BOXSIZE + GAPSIZE) + XMARGIN \n",
      "content_length": 1759,
      "extraction_method": "Direct"
    },
    {
      "page_number": 57,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    39 \n \n167.     top = boxy * (BOXSIZE + GAPSIZE) + YMARGIN \n168.     return (left, top) \n169.  \n170.  \n171. def getBoxAtPixel(x, y): \n172.     for boxx in range(BOARDWIDTH): \n173.         for boxy in range(BOARDHEIGHT): \n174.             left, top = leftTopCoordsOfBox(boxx, boxy) \n175.             boxRect = pygame.Rect(left, top, BOXSIZE, BOXSIZE) \n176.             if boxRect.collidepoint(x, y): \n177.                 return (boxx, boxy) \n178.     return (None, None) \n179.  \n180.  \n181. def drawIcon(shape, color, boxx, boxy): \n182.     quarter = int(BOXSIZE * 0.25) # syntactic sugar \n183.     half =    int(BOXSIZE * 0.5)  # syntactic sugar \n184.  \n185.     left, top = leftTopCoordsOfBox(boxx, boxy) # get pixel coords from \nboard coords \n186.     # Draw the shapes \n187.     if shape == DONUT: \n188.         pygame.draw.circle(DISPLAYSURF, color, (left + half, top + half), \nhalf - 5) \n189.         pygame.draw.circle(DISPLAYSURF, BGCOLOR, (left + half, top + \nhalf), quarter - 5) \n190.     elif shape == SQUARE: \n191.         pygame.draw.rect(DISPLAYSURF, color, (left + quarter, top + \nquarter, BOXSIZE - half, BOXSIZE - half)) \n192.     elif shape == DIAMOND: \n193.         pygame.draw.polygon(DISPLAYSURF, color, ((left + half, top), (left \n+ BOXSIZE - 1, top + half), (left + half, top + BOXSIZE - 1), (left, top + \nhalf))) \n194.     elif shape == LINES: \n195.         for i in range(0, BOXSIZE, 4): \n196.             pygame.draw.line(DISPLAYSURF, color, (left, top + i), (left + \ni, top)) \n197.             pygame.draw.line(DISPLAYSURF, color, (left + i, top + BOXSIZE \n- 1), (left + BOXSIZE - 1, top + i)) \n198.     elif shape == OVAL: \n199.         pygame.draw.ellipse(DISPLAYSURF, color, (left, top + quarter, \nBOXSIZE, half)) \n200.  \n201.  \n202. def getShapeAndColor(board, boxx, boxy): \n203.     # shape value for x, y spot is stored in board[x][y][0] \n",
      "content_length": 1900,
      "extraction_method": "Direct"
    },
    {
      "page_number": 58,
      "chapter": null,
      "content": "40    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n204.     # color value for x, y spot is stored in board[x][y][1] \n205.     return board[boxx][boxy][0], board[boxx][boxy][1] \n206.  \n207.  \n208. def drawBoxCovers(board, boxes, coverage): \n209.     # Draws boxes being covered/revealed. \"boxes\" is a list \n210.     # of two-item lists, which have the x & y spot of the box. \n211.     for box in boxes: \n212.         left, top = leftTopCoordsOfBox(box[0], box[1]) \n213.         pygame.draw.rect(DISPLAYSURF, BGCOLOR, (left, top, BOXSIZE, \nBOXSIZE)) \n214.         shape, color = getShapeAndColor(board, box[0], box[1]) \n215.         drawIcon(shape, color, box[0], box[1]) \n216.         if coverage > 0: # only draw the cover if there is an coverage \n217.             pygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, coverage, \nBOXSIZE)) \n218.     pygame.display.update() \n219.     FPSCLOCK.tick(FPS) \n220.  \n221.  \n222. def revealBoxesAnimation(board, boxesToReveal): \n223.     # Do the \"box reveal\" animation. \n224.     for coverage in range(BOXSIZE, (-REVEALSPEED) - 1, - REVEALSPEED): \n225.         drawBoxCovers(board, boxesToReveal, coverage) \n226.  \n227.  \n228. def coverBoxesAnimation(board, boxesToCover): \n229.     # Do the \"box cover\" animation. \n230.     for coverage in range(0, BOXSIZE + REVEALSPEED, REVEALSPEED): \n231.         drawBoxCovers(board, boxesToCover, coverage) \n232.  \n233.  \n234. def drawBoard(board, revealed): \n235.     # Draws all of the boxes in their covered or revealed state. \n236.     for boxx in range(BOARDWIDTH): \n237.         for boxy in range(BOARDHEIGHT): \n238.             left, top = leftTopCoordsOfBox(boxx, boxy) \n239.             if not revealed[boxx][boxy]: \n240.                 # Draw a covered box. \n241.                 pygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, \nBOXSIZE, BOXSIZE)) \n242.             else: \n243.                 # Draw the (revealed) icon. \n244.                 shape, color = getShapeAndColor(board, boxx, boxy) \n245.                 drawIcon(shape, color, boxx, boxy) \n246.  \n",
      "content_length": 2107,
      "extraction_method": "Direct"
    },
    {
      "page_number": 59,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    41 \n \n247.  \n248. def drawHighlightBox(boxx, boxy): \n249.     left, top = leftTopCoordsOfBox(boxx, boxy) \n250.     pygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, (left - 5, top - 5, \nBOXSIZE + 10, BOXSIZE + 10), 4) \n251.  \n252.  \n253. def startGameAnimation(board): \n254.     # Randomly reveal the boxes 8 at a time. \n255.     coveredBoxes = generateRevealedBoxesData(False) \n256.     boxes = [] \n257.     for x in range(BOARDWIDTH): \n258.         for y in range(BOARDHEIGHT): \n259.             boxes.append( (x, y) ) \n260.     random.shuffle(boxes) \n261.     boxGroups = splitIntoGroupsOf(8, boxes) \n262.  \n263.     drawBoard(board, coveredBoxes) \n264.     for boxGroup in boxGroups: \n265.         revealBoxesAnimation(board, boxGroup) \n266.         coverBoxesAnimation(board, boxGroup) \n267.  \n268.  \n269. def gameWonAnimation(board): \n270.     # flash the background color when the player has won \n271.     coveredBoxes = generateRevealedBoxesData(True) \n272.     color1 = LIGHTBGCOLOR \n273.     color2 = BGCOLOR \n274.  \n275.     for i in range(13): \n276.         color1, color2 = color2, color1 # swap colors \n277.         DISPLAYSURF.fill(color1) \n278.         drawBoard(board, coveredBoxes) \n279.         pygame.display.update() \n280.         pygame.time.wait(300) \n281.  \n282.  \n283. def hasWon(revealedBoxes): \n284.     # Returns True if all the boxes have been revealed, otherwise False \n285.     for i in revealedBoxes: \n286.         if False in i: \n287.             return False # return False if any boxes are covered. \n288.     return True \n289.  \n290.  \n291. if __name__ == '__main__': \n",
      "content_length": 1629,
      "extraction_method": "Direct"
    },
    {
      "page_number": 60,
      "chapter": null,
      "content": "42    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n292.     main() \nCredits and Imports \n  1. # Memory Puzzle \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Released under a \"Simplified BSD\" license \n  5.  \n  6. import random, pygame, sys \n  7. from pygame.locals import * \nAt the top of the program are comments about what the game is, who made it, and where the user \ncould find more information. There’s also a note that the source code is freely copyable under a \n―Simplified BSD‖ license. The Simplified BSD license is more appropriate for software than the \nCreative Common license (which this book is released under), but they basically mean the same \nthing: People are free to copy and share this game. More info about licenses can be found at \nhttp://invpy.com/licenses. \nThis program makes use of many functions in other modules, so it imports those modules on line \n6. Line 7 is also an import statement in the from (module name) import * format, \nwhich means you do not have to type the module name in front of it. There are no functions in the \npygame.locals module, but there are several constant variables in it that we want to use such \nas MOUSEMOTION, KEYUP, or QUIT. Using this style of import statement, we only have to \ntype MOUSEMOTION rather than pygame.locals.MOUSEMOTION. \nMagic Numbers are Bad \n  9. FPS = 30 # frames per second, the general speed of the program \n 10. WINDOWWIDTH = 640 # size of window's width in pixels \n 11. WINDOWHEIGHT = 480 # size of windows' height in pixels \n 12. REVEALSPEED = 8 # speed boxes' sliding reveals and covers \n 13. BOXSIZE = 40 # size of box height & width in pixels \n 14. GAPSIZE = 10 # size of gap between boxes in pixels \nThe game programs in this book use a lot of constant variables. You might not realize why \nthey’re so handy. For example, instead of using the BOXSIZE variable in our code we could just \ntype the integer 40 directly in the code. But there are two reasons to use constant variables. \nFirst, if we ever wanted to change the size of each box later, we would have to go through the \nentire program and find and replace each time we typed 40. By just using the BOXSIZE \nconstant, we only have to change line 13 and the rest of the program is already up to date. This is \n",
      "content_length": 2356,
      "extraction_method": "Direct"
    },
    {
      "page_number": 61,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    43 \n \nmuch better, especially since we might use the integer value 40 for something else besides the \nsize of the white boxes, and changing that 40 accidentally would cause bugs in our program. \nSecond, it makes the code more readable. Go down to the next section and look at line 18. This \nsets up a calculation for the XMARGIN constant, which is how many pixels are on the side of the \nentire board. It is a complicated looking expression, but you can carefully piece out what it \nmeans. Line 18 looks like this: \nXMARGIN = int((WINDOWWIDTH - (BOARDWIDTH * (BOXSIZE + GAPSIZE))) / 2) \nBut if line 18 didn’t use constant variables, it would look like this: \nXMARGIN = int((640 – (10 * (40 + 10))) / 2) \nNow it becomes impossible to remember what exactly the programmer intended to mean. These \nunexplained numbers in the source code are often called magic numbers. Whenever you find \nyourself entering magic numbers, you should consider replacing them with a constant variable \ninstead. To the Python interpreter, both of the previous lines are the exact same. But to a human \nprogrammer who is reading the source code and trying to understand how it works, the second \nversion of line 18 doesn’t make much sense at all! Constants really help the readability of source \ncode. \nOf course, you can go too far replacing numbers with constant variables. Look at the following \ncode: \nZERO = 0 \nONE = 1 \nTWO = 99999999 \nTWOANDTHREEQUARTERS = 2.75 \nDon’t write code like that. That’s just silly. \nSanity Checks with assert Statements \n 15. BOARDWIDTH = 10 # number of columns of icons \n 16. BOARDHEIGHT = 7 # number of rows of icons \n 17. assert (BOARDWIDTH * BOARDHEIGHT) % 2 == 0, 'Board needs to have an even \nnumber of boxes for pairs of matches.' \n 18. XMARGIN = int((WINDOWWIDTH - (BOARDWIDTH * (BOXSIZE + GAPSIZE))) / 2) \n 19. YMARGIN = int((WINDOWHEIGHT - (BOARDHEIGHT * (BOXSIZE + GAPSIZE))) / 2) \n",
      "content_length": 1931,
      "extraction_method": "Direct"
    },
    {
      "page_number": 62,
      "chapter": null,
      "content": "44    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe assert statement on line 15 ensures that the board width and height we’ve selected will \nresult in an even number of boxes (since we will have pairs of icons in this game). There are three \nparts to an assert statement: the assert keyword, an expression which, if False, results in \ncrashing the program. The third part (after the comma after the expression) is a string that appears \nif the program crashes because of the assertion. \nThe assert statement with an expression basically says, ―The programmer asserts that this \nexpression must be True, otherwise crash the program.‖ This is a good way of adding a sanity \ncheck to your program to make sure that if the execution ever passes an assertion we can at least \nknow that that code is working as expected. \nTelling If a Number is Even or Odd \nIf the product of the board width and height is divided by two and has a remainder of 0 (the % \nmodulus operator evaluates what the remainder is) then the number is even. Even numbers \ndivided by two will always have a remainder of zero. Odd numbers divided by two will always \nhave a remainder of one. This is a good trick to remember if you need your code to tell if a \nnumber is even or odd: \n>>> isEven = someNumber % 2 == 0 \n>>> isOdd = someNumber % 2 != 0 \nIn the above case, if the integer in someNumber was even, then isEven will be True. If it was \nodd, then isOdd will be True. \nCrash Early and Crash Often! \nHaving your program crash is a bad thing. It happens when your program has some mistake in the \ncode and cannot continue. But there are some cases where crashing a program early can avoid \nworse bugs later. \nIf the values we chose for BOARDWIDTH and BOARDHEIGHT that we chose on line 15 and 16 \nresult in a board with an odd number of boxes (such as if the width were 3 and the height were 5), \nthen there would always be one left over icon that would not have a pair to be matched with. This \nwould cause a bug later on in the program, and it could take a lot of debugging work to figure out \nthat the real source of the bug is at the very beginning of the program. In fact, just for fun, try \ncommenting out the assertion so it doesn’t run, and then setting the BOARDWIDTH and \nBOARDHEIGHT constants both to odd numbers. When you run the program, it will immediately \nshow an error happening on a line 149 in memorypuzzle.py, which is in \ngetRandomizedBoard() function! \nTraceback (most recent call last): \n",
      "content_length": 2534,
      "extraction_method": "Direct"
    },
    {
      "page_number": 63,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    45 \n \n  File \"C:\\book2svn\\src\\memorypuzzle.py\", line 292, in <module> \n    main() \n  File \"C:\\book2svn\\src\\memorypuzzle.py\", line 58, in main \n    mainBoard = getRandomizedBoard() \n  File \"C:\\book2svn\\src\\memorypuzzle.py\", line 149, in getRandomizedBoard \n    columns.append(icons[0]) \nIndexError: list index out of range \nWe could spend a lot of time looking at getRandomizedBoard() trying to figure out what’s \nwrong with it before realizing that getRandomizedBoard() is perfectly fine: the real source \nof the bug was on line 15 and 16 where we set the BOARDWIDTH and BOARDHEIGHT constants. \nThe assertion makes sure that this never happens. If our code is going to crash, we want it to \ncrash as soon as it detects something is terribly wrong, because otherwise the bug may not \nbecome apparent until much later in the program. Crash early! \nYou want to add assert statements whenever there is some condition in your program that \nmust always, always, always be True. Crash often! You don’t have to go overboard and put \nassert statements everywhere, but crashing often with asserts goes a long way in detecting the \ntrue source of a bug. Crash early and crash often!  \n(In your code that is. Not, say, when riding a pony.) \nMaking the Source Code Look Pretty \n 21. #            R    G    B \n 22. GRAY     = (100, 100, 100) \n 23. NAVYBLUE = ( 60,  60, 100) \n 24. WHITE    = (255, 255, 255) \n 25. RED      = (255,   0,   0) \n 26. GREEN    = (  0, 255,   0) \n 27. BLUE     = (  0,   0, 255) \n 28. YELLOW   = (255, 255,   0) \n 29. ORANGE   = (255, 128,   0) \n 30. PURPLE   = (255,   0, 255) \n 31. CYAN     = (  0, 255, 255) \n 32.  \n 33. BGCOLOR = NAVYBLUE \n 34. LIGHTBGCOLOR = GRAY \n 35. BOXCOLOR = WHITE \n 36. HIGHLIGHTCOLOR = BLUE \nRemember that colors in Pygame are represented by a tuple of three integers from 0 to 255. \nThese three integers represent the amount of red, green, and blue in the color which is why these \n",
      "content_length": 1955,
      "extraction_method": "Direct"
    },
    {
      "page_number": 64,
      "chapter": null,
      "content": "46    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \ntuples are called RGB values. Notice the spacing of the tuples on lines 22 to 31 are such that the \nR, G, and B integers line up. In Python the indentation (that is, the space at the beginning of the \nline) is needs to be exact, but the spacing in the rest of the line is not so strict. By spacing the \nintegers in the tuple out, we can clearly see how the RGB values compare to each other. (More \ninfo on spacing and indentation is as http://invpy.com/whitespace.) \nIt is a nice thing to make your code more readable this way, but don’t bother spending too much \ntime doing it. Code doesn’t have to be pretty to work. At a certain point, you’ll just be spending \nmore time typing spaces than you would have saved by having readable tuple values. \nUsing Constant Variables Instead of Strings \n 38. DONUT = 'donut' \n 39. SQUARE = 'square' \n 40. DIAMOND = 'diamond' \n 41. LINES = 'lines' \n 42. OVAL = 'oval' \nThe program also sets up constant variables for some strings. These constants will be used in the \ndata structure for the board, tracking which spaces on the board have which icons. Using a \nconstant variable instead of the string value is a good idea. Look at the following code, which \ncomes from line 187: \n    if shape == DONUT: \nThe shape variable will be set to one of the strings 'donut', 'square', 'diamond', \n'lines', or 'oval' and then compared to the DONUT constant. If we made a typo when \nwriting line 187, for example, something like this: \n    if shape == DUNOT: \nThen Python would crash, giving an error message saying that there is no variable named DUNOT. \nThis is good. Since the program has crashed on line 187, when we check that line it will be easy \nto see that the bug was caused by a typo. However, if we were using strings instead of constant \nvariables and made the same typo, line 187 would look like this: \n    if shape == 'dunot': \nThis is perfectly acceptable Python code, so it won’t crash at first when you run it. However, this \nwill lead to weird bugs later on in our program. Because the code does not immediately crash \nwhere the problem is caused, it can be much harder to find it. \n",
      "content_length": 2230,
      "extraction_method": "Direct"
    },
    {
      "page_number": 65,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    47 \n \nMaking Sure We Have Enough Icons \n 44. ALLCOLORS = (RED, GREEN, BLUE, YELLOW, ORANGE, PURPLE, CYAN) \n 45. ALLSHAPES = (DONUT, SQUARE, DIAMOND, LINES, OVAL) \n 46. assert len(ALLCOLORS) * len(ALLSHAPES) * 2 >= BOARDWIDTH * BOARDHEIGHT, \n\"Board is too big for the number of shapes/colors defined.\" \nIn order for our game program to be able to create icons of every possible color and shape \ncombination, we need to make a tuple that holds all of these values. There is also another \nassertion on line 46 to make sure that there are enough color/shape combinations for the size of \nthe board we have. If there isn’t, then the program will crash on line 46 and we will know that we \neither have to add more colors and shapes, or make the board width and height smaller. With 7 \ncolors and 5 shapes, we can make 35 (that is, 7 x 5) different icons. And because we’ll have a pair \nof each icon, that means we can have a board with up to 70 (that is, 35 x 2, or 7 x 5 x 2) spaces. \nTuples vs. Lists, Immutable vs. Mutable \nYou might have noticed that the ALLCOLORS and ALLSHAPES variables are tuples instead of \nlists. When do we want to use tuples and when do we want to use lists? And what’s the difference \nbetween them anyway? \nTuples and lists are the same in every way except two: tuples use parentheses instead of square \nbrackets, and the items in tuples cannot be modified (but the items in lists can be modified). We \noften call lists mutable (meaning they can be changed) and tuples immutable (meaning they \ncannot be changed). \nFor an example of trying to change values in lists and tuples, look at the following code: \n>>> listVal = [1, 1, 2, 3, 5, 8] \n>>> tupleVal = (1, 1, 2, 3, 5, 8) \n>>> listVal[4] = 'hello!' \n>>> listVal \n[1, 1, 2, 3, 'hello!', 8] \n>>> tupleVal[4] = 'hello!' \nTraceback (most recent call last): \n  File \"<stdin>\", line 1, in <module> \nTypeError: 'tuple' object does not support item assignment \n>>> tupleVal \n(1, 1, 2, 3, 5, 8) \n>>> tupleVal[4] \n5 \nNotice that when we try to change the item at index 2 in the tuple, Python gives us an error \nmessage saying that tuple objects do not support ―item assignment‖. \n",
      "content_length": 2175,
      "extraction_method": "Direct"
    },
    {
      "page_number": 66,
      "chapter": null,
      "content": "48    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThere is a silly benefit and an important benefit to tuple’s immutability. The silly benefit is that \ncode that uses tuples is slightly faster than code that uses lists. (Python is able to make some \noptimizations knowing that the values in a tuple will never change.) But having your code run a \nfew nanoseconds faster is not important. \nThe important benefit to using tuples is similar to the benefit of using constant variables: it’s a \nsign that the value in the tuple will never change, so anyone reading the code later will be able to \nsay, ―I can expect that this tuple will always be the same. Otherwise the programmer would have \nused a list.‖ This also lets a future programmer reading your code say, ―If I see a list value, I \nknow that it could be modified at some point in this program. Otherwise, the programmer who \nwrote this code would have used a tuple.‖ \nYou can still assign a new tuple value to a variable: \n>>> tupleVal = (1, 2, 3) \n>>> tupleVal = (1, 2, 3, 4) \nThe reason this code works is because the code isn’t changing the (1, 2, 3) tuple on the \nsecond line. It is assigning an entirely new tuple (1, 2, 3, 4) to the tupleVal, and \noverwriting the old tuple value. You cannot however, use the square brackets to modify an item \nin the tuple. \nStrings are also an immutable data type. You can use the square brackets to read a single \ncharacter in a string, but you cannot change a single character in a string: \n>>> strVal = 'Hello' \n>>> strVal[1] \n'e' \n>>> strVal[1] = 'X' \nTraceback (most recent call last): \n  File \"<stdin>\", line 1, in <module> \nTypeError: 'str' object does not support item assignment \nOne Item Tuples Need a Trailing Comma \nAlso, one minor details about tuples: if you ever need to write code about a tuple that has one \nvalue in it, then it needs to have a trailing comma in it, such as this: \noneValueTuple = (42, ) \n",
      "content_length": 1972,
      "extraction_method": "Direct"
    },
    {
      "page_number": 67,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    49 \n \nIf you forget this comma (and it is very easy to forget), then Python won’t be able to tell the \ndifference between this and a set of parentheses that just change the order of operations. For \nexample, look at the following two lines of code: \nvariableA = (5 * 6) \nvariableB = (5 * 6, ) \nThe value that is stored in variableA is just the integer 30. However, the expression for \nvariableB’s assignment statement is the single-item tuple value (30, ). Blank tuple values \ndo not need a comma in them, they can just be a set of parentheses by themselves: (). \nConverting Between Lists and Tuples \nYou can convert between list and tuple values just like you can convert between string and \ninteger values. Just pass a tuple value to the list() function and it will return a list form of that \ntuple value. Or, pass a list value to the tuple() function and it will return a tuple form of that \nlist value. Try typing the following into the interactive shell: \n>>> spam = (1, 2, 3, 4) \n>>> spam = list(spam) \n>>> spam \n[1, 2, 3, 4] \n>>> spam = tuple(spam) \n>>> spam \n(1, 2, 3, 4) \n>>> \nThe global statement, and Why Global Variables are Evil \n 48. def main(): \n 49.     global FPSCLOCK, DISPLAYSURF \n 50.     pygame.init() \n 51.     FPSCLOCK = pygame.time.Clock() \n 52.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 53.  \n 54.     mousex = 0 # used to store x coordinate of mouse event \n 55.     mousey = 0 # used to store y coordinate of mouse event \n 56.     pygame.display.set_caption('Memory Game') \nThis is the start of the main() function, which is where (oddly enough) the main part of the \ngame code is. The functions called in the main() function will be explained later in this chapter. \nLine 49 is a global statement. The global statement is the global keyword followed by a \ncomma-delimited list of variable names. These variable names are then marked as global \n",
      "content_length": 1932,
      "extraction_method": "Direct"
    },
    {
      "page_number": 68,
      "chapter": null,
      "content": "50    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nvariables. Inside the main() function, those names are not for local variables that might just \nhappen to have the same name as global variables. They are the global variables. Any values \nassigned to them in the main() function will persist outside the main() function. We are \nmarking the FPSCLOCK and DISPLAYSURF variables as global because they are used in several \nother functions in the program. (More info is at http://invpy.com/scope.) \nThere are four simple rules to determine if a variable is local or global: \n1. If there is a global statement for a variable at the beginning of the function, then the \nvariable is global. \n2. If the name of a variable in a function has the same name as a global variable and the \nfunction never assigns the variable a value, then that variable is the global variable. \n3. If the name of a variable in a function has the same name as a global variable and the \nfunction does assign the variable a value, then that variable is a local variable. \n4. If there isn't a global variable with the same name as the variable in the function, then \nthat variable is obviously a local variable. \nYou generally want to avoid using global variables inside functions. A function is supposed to be \nlike a mini-program inside your program with specific inputs (the parameters) and an output (the \nreturn value). But a function that reads and writes to global variables has additional inputs and \noutput. Since the global variable could have been modified in many places before the function \nwas called, it can be tricky to track down a bug involving a bad value set in the global variable. \nHaving a function as a separate mini-program that doesn’t use global variables makes it easier to \nfind bugs in your code, since the parameters of the function are clearly known. It also makes \nchanging the code in a function easier, since if the new function works with the same parameters \nand gives the same return value, it will automatically work with the rest of the program just like \nthe old function. \nBasically, using global variables might make it easier to write your program but they generally \nmake it harder to debug. \nIn the games in this book, global variables are mostly used for variables that would be global \nconstants that never change, but need the pygame.init() function called first. Since this \nhappens in the main() function, they are set in the main() function and must be global for \nother functions to see them. But the global variables are used as constants and don’t change, so \nthey are less likely to cause confusing bugs. \nIf you don’t understand this, don’t worry. Just write your code so that you pass in values to \nfunctions rather than have the functions read global variables as a general rule. \n",
      "content_length": 2859,
      "extraction_method": "Direct"
    },
    {
      "page_number": 69,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    51 \n \nData Structures and 2D Lists \n 58.     mainBoard = getRandomizedBoard() \n 59.     revealedBoxes = generateRevealedBoxesData(False) \nThe getRandomizedBoard() function returns a data structure that represents the state of the \nboard. The generateRevealedBoxesData() function returns a data structure that \nrepresents which boxes are covered, respectively. The return values of these functions are two \ndimensional (2D) lists, or lists of lists. A list of lists of lists of values would be a 3D list. Another \nword for two or more dimensional lists is a multidimensional list. \nIf we have a list value stored in a variable named spam, we could access a value in that list with \nthe square brackets, such as spam[2] to retrieve the third value in the list. If the value at \nspam[2] is itself a list, then we could use another set of square brackets to retrieve a value in \nthat list. This would look like, for example, spam[2][4], which would retrieve the fifth value \nin the list that is the third value in spam. Using the this notation of lists of lists makes it easy to \nmap a 2D board to a 2D list value. Since the mainBoard variable will store icons in it, if we \nwanted to get the icon on the board at the position (4, 5) then we could just use the expression \nmainBoard[4][5]. Since the icons themselves are stored as two-item tuples with the shape \nand color, the complete data structure is a list of list of two-item tuples. Whew! \nHere’s an small example. Say the board looked like this: \n \nThe corresponding data structure would be: \nmainBoard = [[(DONUT, BLUE), (LINES, BLUE), (SQUARE, ORANGE)], [(SQUARE, \nGREEN), (DONUT, BLUE), (DIAMOND, YELLOW)], [(SQUARE, GREEN), (OVAL, YELLOW), \n(SQUARE, ORANGE)], [(DIAMOND, YELLOW), (LINES, BLUE), (OVAL, YELLOW)]] \n(If your book is in black and white, you can see a color version of the above picture at \nhttp://invpy.com/memoryboard.) You’ll notice that mainBoard[x][y] will correspond to the \nicon at the (x, y) coordinate on the board. \n",
      "content_length": 2025,
      "extraction_method": "Direct"
    },
    {
      "page_number": 70,
      "chapter": null,
      "content": "52    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nMeanwhile, the ―revealed boxes‖ data structure is also a 2D list, except instead of two-item tuples \nlike the board data structure, it has Boolean values: True if the box at that x, y coordinate is \nrevealed, and False if it is covered up. Passing False to the \ngenerateRevealedBoxesData() function sets all of the Boolean values to False. (This \nfunction is explained in detail later.) \nThese two data structures are used to keep track of the state of the game board. \nThe “Start Game” Animation \n 61.     firstSelection = None # stores the (x, y) of the first box clicked. \n 62.  \n 63.     DISPLAYSURF.fill(BGCOLOR) \n 64.     startGameAnimation(mainBoard) \nLine 61 sets up a variable called firstSelection with the value None. (None is the value \nthat represents a lack of a value. It is the only value of the data type, NoneType. More info at \nhttp://invpy.com/None) When the player clicks on an icon on the board, the program needs to \ntrack if this was the first icon of the pair that was clicked on or the second icon. If \nfirstSelection is None, the click was on the first icon and we store the XY coordinates in \nthe firstSelection variable as a tuple of two integers (one for the X value, the other for Y). \nOn the second click the value will be this tuple and not None, which is how the program tracks \nthat it is the second icon click. Line 63 fills the entire surface with the background color. This will \nalso paint over anything that used to be on the surface, which gives us a clean slate to start \ndrawing graphics on. \nIf you’ve played the Memory Puzzle game, you’ll notice that at the beginning of the game, all of \nthe boxes are quickly covered and uncovered randomly to give the player a sneak peek at which \nicons are under which boxes. This all happens in the startGameAnimation() function, \nwhich is explained later in this chapter. \nIt’s important to give the player this sneak peek (but not long enough of a peek to let the player \neasily memorize the icon locations), because otherwise they would have no clue where any icons \nare. Blindly clicking on the icons isn’t as much fun as having a little hint to go on. \nThe Game Loop \n 66.     while True: # main game loop \n 67.         mouseClicked = False \n 68.  \n 69.         DISPLAYSURF.fill(BGCOLOR) # drawing the window \n 70.         drawBoard(mainBoard, revealedBoxes) \n",
      "content_length": 2450,
      "extraction_method": "Direct"
    },
    {
      "page_number": 71,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    53 \n \nThe game loop is an infinite loop that starts on line 66 that keeps iterating for as long as the game \nis in progress. Remember that the game loop handles events, updates the game state, and draws \nthe game state to the screen. \nThe game state for the Memory Puzzle program is stored in the following variables: \n \nmainBoard \n \nrevealedBoxes \n \nfirstSelection \n \nmouseClicked \n \nmousex \n \nmousey \nOn each iteration of the game loop in the Memory Puzzle program, the mouseClicked variable \nstores a Boolean value that is True if the player has clicked the mouse during this iteration \nthrough the game loop. (This is part of keeping track of the game state.) \nOn line 69, the surface is painted over with the background color to erase anything that was \npreviously drawn on it. The program then calls drawBoard() to draw the current state of the \nboard based on the board and ―revealed boxes‖ data structures that we pass it. (These lines of \ncode are part of drawing and updating the screen.) \nRemember that our drawing functions only draw on the in-memory display Surface object. This \nSurface object will not actually appear on the screen until we call \npygame.display.update(), which is done at the end of the game loop on line 121. \nThe Event Handling Loop                                                                                                                \n 72.         for event in pygame.event.get(): # event handling loop \n 73.             if event.type == QUIT or (event.type == KEYUP and event.key == \nK_ESCAPE): \n 74.                 pygame.quit() \n 75.                 sys.exit() \n 76.             elif event.type == MOUSEMOTION: \n 77.                 mousex, mousey = event.pos \n 78.             elif event.type == MOUSEBUTTONUP: \n 79.                 mousex, mousey = event.pos \n 80.                 mouseClicked = True \nThe for loop on line 72 executes code for every event that has happened since the last iteration \nof the game loop. This loop is called the event handling loop (which is different from the game \nloop, although the event handling loop is inside of the game loop) and iterates over the list of \npygame.Event objects returned by the pygame.event.get() call. \n",
      "content_length": 2243,
      "extraction_method": "Direct"
    },
    {
      "page_number": 72,
      "chapter": null,
      "content": "54    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nIf the event object was a either a QUIT event or a KEYUP event for the Esc key, then the program \nshould terminate. Otherwise, in the event of a MOUSEMOTION event (that is, the mouse cursor \nhas moved) or MOUSEBUTTONUP event (that is, a mouse button was pressed earlier and now the \nbutton was let up), the position of the mouse cursor should be stored in the mousex and mousey \nvariables. If this was a MOUSEBUTTONUP event, mouseClicked should also be set to True. \nOnce we have handled all of the events, the values stored in mousex, mousey, and \nmouseClicked will tell us any input that player has given us. Now we should update the game \nstate and draw the results to the screen. \nChecking Which Box The Mouse Cursor is Over \n 82.         boxx, boxy = getBoxAtPixel(mousex, mousey) \n 83.         if boxx != None and boxy != None: \n 84.             # The mouse is currently over a box. \n 85.             if not revealedBoxes[boxx][boxy]: \n 86.                drawHighlightBox(boxx, boxy) \nThe getBoxAtPixel() function will return a tuple of two integers. The integers represent the \nXY board coordinates of the box that the mouse coordinates are over. How getBoxAtPixel() \ndoes this is explained later. All we have to know for now is that if the mousex and mousey \ncoordinates were over a box, a tuple of the XY board coordinates are returned by the function and \nstored in boxx and boxy. If the mouse cursor was not over any box (for example, if it was off to \nthe side of the board or in a gap in between boxes) then the tuple (None, None) is returned by \nthe function and boxx and boxy will both have None stored in them. \nWe are only interested in the case where boxx and boxy do not have None in them, so the next \nseveral lines of code are in the block following the if statement on line 83 that checks for this \ncase. If execution has come inside this block, we know the user has the mouse cursor over a box \n(and maybe has also clicked the mouse, depending on the value stored in mouseClicked). \nThe if statement on line 85 checks if the box is covered up or not by reading the value stored in \nrevealedBoxes[boxx][boxy]. If it is False, then we know the box is covered. \nWhenever the mouse is over a covered up box, we want to draw a blue highlight around the box \nto inform the player that they can click on it. This highlighting is not done for boxes that are \nalready uncovered. The highlight drawing is handled by our drawHighlightBox() function, \nwhich is explained later. \n 87.             if not revealedBoxes[boxx][boxy] and mouseClicked: \n 88.                 revealBoxesAnimation(mainBoard, [(boxx, boxy)]) \n",
      "content_length": 2732,
      "extraction_method": "Direct"
    },
    {
      "page_number": 73,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    55 \n \n 89.                 revealedBoxes[boxx][boxy] = True # set the box as \n\"revealed\" \nOn line 87, we check if the mouse cursor is not only over a covered up box but if the mouse has \nalso been clicked. In that case, we want to play the ―reveal‖ animation for that box by calling our \nrevealBoxesAnimation() function (which is, as with all the other functions main() calls, \nexplained later in this chapter). You should note that calling this function only draws the \nanimation of the box being uncovered. It isn’t until line 89 when we set \nrevealedBoxes[boxx][boxy] = True that the data structure that tracks the game state \nis updated. \nIf you comment out line 89 and then run the program, you’ll notice that after clicking on a box \nthe reveal animation is played, but then the box immediately appears covered up again. This is \nbecause revealedBoxes[boxx][boxy] is still set to False, so on the next iteration of the \ngame loop, the board is drawn with this box covered up. Not having line 89 would cause quite an \nodd bug in our program. \nHandling the First Clicked Box \n 90.                 if firstSelection == None: # the current box was the first \nbox clicked \n 91.                     firstSelection = (boxx, boxy) \n 92.                 else: # the current box was the second box clicked \n 93.                     # Check if there is a match between the two icons. \n 94.                     icon1shape, icon1color = getShapeAndColor(mainBoard, \nfirstSelection[0], firstSelection[1]) \n 95.                     icon2shape, icon2color = getShapeAndColor(mainBoard, \nboxx, boxy) \nBefore the execution entered the game loop, the firstSelection variable was set to None. \nOur program will interpret this to mean that no boxes have been clicked, so if line 90’s condition \nis True, that means this is the first of the two possibly matching boxes that was clicked. We \nwant to play the reveal animation for the box and then keep that box uncovered. We also set the \nfirstSelection variable to a tuple of the box coordinates for the box that was clicked. \nIf this is the second box the player has clicked on, we want to play the reveal animation for that \nbox but then check if the two icons under the boxes are matching. The getShapeAndColor() \nfunction (explained later) will retrieve the shape and color values of the icons. (These values will \nbe one of the values in the ALLCOLORS and ALLSHAPES tuples.) \n",
      "content_length": 2444,
      "extraction_method": "Direct"
    },
    {
      "page_number": 74,
      "chapter": null,
      "content": "56    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nHandling a Mismatched Pair of Icons \n 97.                     if icon1shape != icon2shape or icon1color != \nicon2color: \n 98.                         # Icons don't match. Re-cover up both selections. \n 99.                         pygame.time.wait(1000) # 1000 milliseconds = 1 sec \n100.                         coverBoxesAnimation(mainBoard, \n[(firstSelection[0], firstSelection[1]), (boxx, boxy)]) \n101.                         revealedBoxes[firstSelection[0]][firstSelection \n[1]] = False \n102.                         revealedBoxes[boxx][boxy] = False \nThe if statement on line 97 checks if either the shapes or colors of the two icons don’t match. If \nthis is the case, then we want to pause the game for 1000 milliseconds (which is the same as 1 \nsecond) by calling pygame.time.wait(1000) so that the player has a chance to see that the \ntwo icons don’t match. Then the ―cover up‖ animation plays for both boxes. We also want to \nupdate the game state to mark these boxes as not revealed (that is, covered up). \nHandling If the Player Won \n103.                     elif hasWon(revealedBoxes): # check if all pairs found \n104.                         gameWonAnimation(mainBoard) \n105.                         pygame.time.wait(2000) \n106.  \n107.                         # Reset the board \n108.                         mainBoard = getRandomizedBoard() \n109.                         revealedBoxes = generateRevealedBoxesData(False) \n110.  \n111.                         # Show the fully unrevealed board for a second. \n112.                         drawBoard(mainBoard, revealedBoxes) \n113.                         pygame.display.update() \n114.                         pygame.time.wait(1000) \n115.  \n116.                         # Replay the start game animation. \n117.                         startGameAnimation(mainBoard) \n \n118.                     firstSelection = None # reset firstSelection variable \nOtherwise, if line 97’s condition was False, then the two icons must be a match. The program \ndoesn’t really have to do anything else to the boxes at that point: it can just leave both boxes in \nthe revealed state. However, the program should check if this was the last pair of icons on the \nboard to be matched. This is done inside our hasWon() function, which returns True if the \nboard is in a winning state (that is, all of the boxes are revealed).  \n",
      "content_length": 2463,
      "extraction_method": "Direct"
    },
    {
      "page_number": 75,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    57 \n \nIf that is the case, we want to play the ―game won‖ animation by calling \ngameWonAnimation(), then pause slightly to let the player revel in their victory, and then \nreset the data structures in mainBoard and revealedBoxes to start a new game. \nLine 117 plays the ―start game‖ animation again. After that, the program execution will just loop \nthrough the game loop as usual, and the player can continue playing until they quit the program. \nNo matter if the two boxes were matching or not, after the second box was clicked line 118 will \nset the firstSelection variable back to None so that the next box the player clicks on will \nbe interpreted as the first clicked box of a pair of possibly matching icons. \nDrawing the Game State to the Screen \n120.         # Redraw the screen and wait a clock tick. \n121.         pygame.display.update() \n122.         FPSCLOCK.tick(FPS) \nAt this point, the game state has been updated depending on the player’s input, and the latest \ngame state has been drawn to the DISPLAYSURF display Surface object. We’ve reached the end \nof the game loop, so we call pygame.display.update() to draw the DISPLAYSURF \nSurface object to the computer screen. \nLine 9 set the FPS constant to the integer value 30, meaning we want the game to run (at most) at \n30 frames per second. If we want the program to run faster, we can increase this number. If we \nwant the program to run slower, we can decrease this number. It can even be set to a float value \nlike 0.5, which will run the program at half a frame per second, that is, one frame per two \nseconds. \nIn order to run at 30 frames per second, each frame must be drawn in 1/30th of a second. This \nmeans that pygame.display.update() and all the code in the game loop must execute in \nunder 33.3 milliseconds. Any modern computer can do this easily with plenty of time left over. \nTo prevent the program from running too fast, we call the tick() method of the \npygame.Clock object in FPSCLOCK to have to it pause the program for the rest of the 33.3 \nmilliseconds. \nSince this is done at the very end of the game loop, it ensures that each iteration of the game loop \ntakes (at least) 33.3 milliseconds. If for some reason the pygame.display.update() call \nand the code in the game loop takes longer than 33.3 milliseconds, then the tick() method will \nnot wait at all and immediately return. \n",
      "content_length": 2404,
      "extraction_method": "Direct"
    },
    {
      "page_number": 76,
      "chapter": null,
      "content": "58    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nI’ve kept saying that the other functions would be explained later in the chapter. Now that we’ve \ngone over the main() function and you have an idea for how the general program works, let’s \ngo into the details of all the other functions that are called from main(). \nCreating the “Revealed Boxes” Data Structure \n125. def generateRevealedBoxesData(val): \n126.     revealedBoxes = [] \n127.     for i in range(BOARDWIDTH): \n128.         revealedBoxes.append([val] * BOARDHEIGHT) \n129.     return revealedBoxes \nThe generateRevealedBoxesData() function needs to create a list of lists of Boolean \nvalues. The Boolean value will just be the one that is passed to the function as the val parameter. \nWe start the data structure as an empty list in the revealedBoxes variable. \nIn order to make the data structure have the revealedBoxes[x][y] structure, we need to \nmake sure that the inner lists represent the vertical columns of the board and not the horizontal \nrows. Otherwise, the data structure will have a revealedBoxes[y][x] structure. \nThe for loop will create the columns and then append them to revealedBoxes. The columns \nare created using list replication, so that the column list has as many val values as the \nBOARDHEIGHT dictates. \nCreating the Board Data Structure: Step 1 – Get All Possible Icons \n132. def getRandomizedBoard(): \n133.     # Get a list of every possible shape in every possible color. \n134.     icons = [] \n135.     for color in ALLCOLORS: \n136.         for shape in ALLSHAPES: \n137.             icons.append( (shape, color) ) \nThe board data structure is just a list of lists of tuples, where each tuple has a two values: one for \nthe icon’s shape and one for the icon’s color. But creating this data structure is a little \ncomplicated. We need to be sure to have exactly as many icons for the number of boxes on the \nboard and also be sure there are two and only two icons of each type. \nThe first step to do this is to create a list with every possible combination of shape and color. \nRecall that we have a list of each color and shape in ALLCOLORS and ALLSHAPES, so nested \nfor loops on lines 135 and 136 will go through every possible shape for every possible color. \nThese are each added to the list in the icons variable on line 137. \n",
      "content_length": 2375,
      "extraction_method": "Direct"
    },
    {
      "page_number": 77,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    59 \n \nStep 2 – Shuffling and Truncating the List of All Icons \n139.     random.shuffle(icons) # randomize the order of the icons list \n140.     numIconsUsed = int(BOARDWIDTH * BOARDHEIGHT / 2) # calculate how many \nicons are needed \n141.     icons = icons[:numIconsUsed] * 2 # make two of each \n142.     random.shuffle(icons) \nBut remember, there may be more possible combinations than spaces on the board. We need to \ncalculate the number of spaces on the board by multiplying BOARDWIDTH by BOARDHEIGHT. \nThen we divide that number by 2 because we will have pairs of icons. On a board with 70 spaces, \nwe’d only need 35 different icons, since there will be two of each icon. This number will be \nstored in numIconsUsed. \nLine 141 uses list slicing to grab the first numIconsUsed number of icons in the list. (If you’ve \nforgotten how list slicing works, check out http://invpy.com/slicing.) This list has been shuffled \non line 139, so it won’t always be the same icons each game. Then this list is replicated by using \nthe * operator so that there are two of each of the icons. This new doubled up list will overwrite \nthe old list in the icons variable. Since the first half of this new list is identical to the last half, \nwe call the shuffle() method again to randomly mix up the order of the icons. \nStep 3 – Placing the Icons on the Board \n144.     # Create the board data structure, with randomly placed icons. \n145.     board = [] \n146.     for x in range(BOARDWIDTH): \n147.         column = [] \n148.         for y in range(BOARDHEIGHT): \n149.             column.append(icons[0]) \n150.             del icons[0] # remove the icons as we assign them \n151.         board.append(column) \n152.     return board \nNow we need to create a list of lists data structure for the board. We can do this with nested for \nloops just like the generateRevealedBoxesData() function did. For each column on the \nboard, we will create a list of randomly selected icons. As we add icons to the column, on line \n149 we will then delete them from the front of the icons list on line 150. This way, as the \nicons list gets shorter and shorter, icons[0] will have a different icon to add to the columns. \nTo picture this better, type the following code into the interactive shell. Notice how the del \nstatement changes the myList list. \n>>> myList = ['cat', 'dog', 'mouse', 'lizard'] \n",
      "content_length": 2398,
      "extraction_method": "Direct"
    },
    {
      "page_number": 78,
      "chapter": null,
      "content": "60    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n>>> del myList[0] \n>>> myList \n['dog', 'mouse', 'lizard'] \n>>> del myList[0] \n>>> myList \n['mouse', 'lizard'] \n>>> del myList[0] \n>>> myList \n['lizard'] \n>>> del myList[0] \n>>> myList \n[] \n>>> \nBecause we are deleting the item at the front of the list, the other items shift forward so that the \nnext item in the list becomes the new ―first‖ item. This is the same way line 150 works. \nSplitting a List into a List of Lists \n155. def splitIntoGroupsOf(groupSize, theList): \n156.     # splits a list into a list of lists, where the inner lists have at \n157.     # most groupSize number of items. \n158.     result = [] \n159.     for i in range(0, len(theList), groupSize): \n160.         result.append(theList[i:i + groupSize]) \n161.     return result \nThe splitIntoGroupsOf() function (which will be called by the \nstartGameAnimation() function) splits a list into a list of lists, where the inner lists have \ngroupSize number of items in them. (The last list could have less if there are less than \ngroupSize items left over.) \nThe call to range() on line 159 uses the three-parameter form of range(). (If you are \nunfamiliar with this form, take a look at http://invpy.com/range.) Let’s use an example. If the \nlength of the list is 20 and the groupSize parameter is 8, then range(0, \nlen(theList), groupSize) evaluates to range(0, 20, 8). This will give the i \nvariable the values 0, 8, and 16 for the three iterations of the for loop. \nThe list slicing on line 160 with theList[i:i + groupSize] creates the lists that are \nadded to the result list. On each iteration where i is 0, 8, and 16 (and groupSize is 8), this \nlist slicing expression would be theList[0:8], then theList[8:16] on the second \niteration, and then theList[16:24] on the third iteration. \n",
      "content_length": 1864,
      "extraction_method": "Direct"
    },
    {
      "page_number": 79,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    61 \n \nNote that even though the largest index of theList would be 19 in our example, \ntheList[16:24] won’t raise an IndexError error even though 24 is larger than 19. It will \njust create a list slice with the remaining items in the list. List slicing doesn’t destroy or change \nthe original list stored in theList. It just copies a portion of it to evaluate to a new list value. \nThis new list value is the list that is appended to the list in the result variable on line 160. So \nwhen we return result at the end of this function, we are returning a list of lists. \nDifferent Coordinate Systems \n164. def leftTopCoordsOfBox(boxx, boxy): \n165.     # Convert board coordinates to pixel coordinates \n166.     left = boxx * (BOXSIZE + GAPSIZE) + XMARGIN \n167.     top = boxy * (BOXSIZE + GAPSIZE) + YMARGIN \n168.     return (left, top) \nYou should be familiar with Cartesian Coordinate systems. (If you’d like a refresher on this topic, \nread http://invpy.com/coordinates.) In most of our games we will be using multiple Cartesian \nCoordinate systems. One system of coordinates that is used in the Memory Puzzle game is for the \npixel or screen coordinates. But we will also be using another coordinate system for the boxes. \nThis is because it will be easier to use (3, 2) to refer to the 4th box from the left and 3rd from the \ntop (remember that the numbers start with 0, not 1) instead of using the pixel coordinate of the \nbox’s top left corner, (220, 165). However, we need a way to translate between these two \ncoordinate systems. \nHere’s a picture of the game and the two different coordinate systems. Remember that the \nwindow is 640 pixels wide and 480 pixels tall, so (639, 479) is the bottom right corner (because \nthe top left corner’s pixel is (0, 0), and not (1, 1)). \n",
      "content_length": 1811,
      "extraction_method": "Direct"
    },
    {
      "page_number": 80,
      "chapter": null,
      "content": "62    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nThe leftTopCoordsOfBox() function will take box coordinates and return pixel \ncoordinates. Because a box takes up multiple pixels on the screen, we will always return the \nsingle pixel at the top left corner of the box. This value will be returned as a two-integer tuple. \nThe leftTopCoordsOfBox() function will often be used when we need pixel coordinates for \ndrawing these boxes. \nConverting from Pixel Coordinates to Box Coordinates \n171. def getBoxAtPixel(x, y): \n172.     for boxx in range(BOARDWIDTH): \n173.         for boxy in range(BOARDHEIGHT): \n174.             left, top = leftTopCoordsOfBox(boxx, boxy) \n175.             boxRect = pygame.Rect(left, top, BOXSIZE, BOXSIZE) \n176.             if boxRect.collidepoint(x, y): \n177.                 return (boxx, boxy) \n178.     return (None, None) \nWe will also need a function to convert from pixel coordinates (which the mouse clicks and \nmouse movement events use) to box coordinates (so we can find out over which box the mouse \nevent happened). Rect objects have a collidepoint() method that you can pass X and Y \ncoordinates too and it will return True if the coordinates are inside (that is, collide with) the Rect \nobject’s area. \n",
      "content_length": 1301,
      "extraction_method": "Direct"
    },
    {
      "page_number": 81,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    63 \n \nIn order to find which box the mouse coordinates are over, we will go through each box’s \ncoordinates and call the collidepoint() method on a Rect object with those coordinates. \nWhen collidepoint() returns True, we know we have found the box that was clicked on or \nmoved over and will return the box coordinates. If none of them return True, then the \ngetBoxAtPixel() function will return the value (None, None). This tuple is returned \ninstead of simply returning None because the caller of getBoxAtPixel() is expecting a tuple \nof two values to be returned. \nDrawing the Icon, and Syntactic Sugar \n181. def drawIcon(shape, color, boxx, boxy): \n182.     quarter = int(BOXSIZE * 0.25) # syntactic sugar \n183.     half =    int(BOXSIZE * 0.5)  # syntactic sugar \n184.  \n185.     left, top = leftTopCoordsOfBox(boxx, boxy) # get pixel coords from \nboard coords \nThe drawIcon() function will draw an icon (with the specified shape and color) at the \nspace whose coordinates are given in the boxx and boxy parameters. Each possible shape has a \ndifferent set of Pygame drawing function calls for it, so we must have a large set of if and elif \nstatements to differentiate between them. (These statements are on lines 187 to 198.) \nThe X and Y coordinates of the left and top edge of the box can be obtained by calling the \nleftTopCoordsOfBox() function. The width and height of the box are both set in the \nBOXSIZE constant. However, many of the shape drawing function calls use the midpoint and \nquarter-point of the box as well. We can calculate this and store it in the variables quarter and \nhalf. We could just as easily have the code int(BOXSIZE * 0.25) instead of the variable \nquarter, but this way the code becomes easier to read since it is more obvious what quarter \nmeans rather than int(BOXSIZE * 0.25). \nSuch variables are an example of syntactic sugar. Syntactic sugar is when we add code that \ncould have been written in another way (probably with less actual code and variables), but does \nmake the source code easier to read. Constant variables are one form of syntactic sugar. Pre-\ncalculating a value and storing it in a variable is another type of syntactic sugar. (For example, in \nthe getRandomizedBoard() function, we could have easily made the code on lines 140 and \nline 141 into a single line of code. But it’s easier to read as two separate lines.) We don’t need to \nhave the extra quarter and half variables, but having them makes the code easier to read. \nCode that is easy to read is easy to debug and upgrade in the future. \n186.     # Draw the shapes \n187.     if shape == DONUT: \n",
      "content_length": 2647,
      "extraction_method": "Direct"
    },
    {
      "page_number": 82,
      "chapter": null,
      "content": "64    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n188.         pygame.draw.circle(DISPLAYSURF, color, (left + half, top + half), \nhalf - 5) \n189.         pygame.draw.circle(DISPLAYSURF, BGCOLOR, (left + half, top + \nhalf), quarter - 5) \n190.     elif shape == SQUARE: \n191.         pygame.draw.rect(DISPLAYSURF, color, (left + quarter, top + \nquarter, BOXSIZE - half, BOXSIZE - half)) \n192.     elif shape == DIAMOND: \n193.         pygame.draw.polygon(DISPLAYSURF, color, ((left + half, top), (left \n+ BOXSIZE - 1, top + half), (left + half, top + BOXSIZE - 1), (left, top + \nhalf))) \n194.     elif shape == LINES: \n195.         for i in range(0, BOXSIZE, 4): \n196.             pygame.draw.line(DISPLAYSURF, color, (left, top + i), (left + \ni, top)) \n197.             pygame.draw.line(DISPLAYSURF, color, (left + i, top + BOXSIZE \n- 1), (left + BOXSIZE - 1, top + i)) \n198.     elif shape == OVAL: \n199.         pygame.draw.ellipse(DISPLAYSURF, color, (left, top + quarter, \nBOXSIZE, half)) \nEach of the donut, square, diamond, lines, and oval functions require different drawing primitive \nfunction calls to make.  \nSyntactic Sugar with Getting a Board Space’s Icon’s Shape and Color \n202. def getShapeAndColor(board, boxx, boxy): \n203.     # shape value for x, y spot is stored in board[x][y][0] \n204.     # color value for x, y spot is stored in board[x][y][1] \n205.     return board[boxx][boxy][0], board[boxx][boxy][1] \nThe getShapeAndColor() function only has one line. You might wonder why we would \nwant a function instead of just typing in that one line of code whenever we need it. This is done \nfor the same reason we use constant variables: it improves the readability of the code. \nIt’s easy to figure out what a code like shape, color = getShapeAndColor() does. \nBut if you looked a code like shape, color = board[boxx][boxy][0], \nboard[boxx][boxy][1], it would be a bit more difficult to figure out. \nDrawing the Box Cover \n208. def drawBoxCovers(board, boxes, coverage): \n209.     # Draws boxes being covered/revealed. \"boxes\" is a list \n210.     # of two-item lists, which have the x & y spot of the box. \n211.     for box in boxes: \n",
      "content_length": 2203,
      "extraction_method": "Direct"
    },
    {
      "page_number": 83,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    65 \n \n212.         left, top = leftTopCoordsOfBox(box[0], box[1]) \n213.         pygame.draw.rect(DISPLAYSURF, BGCOLOR, (left, top, BOXSIZE, \nBOXSIZE)) \n214.         shape, color = getShapeAndColor(board, box[0], box[1]) \n215.         drawIcon(shape, color, box[0], box[1]) \n216.         if coverage > 0: # only draw the cover if there is an coverage \n217.             pygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, coverage, \nBOXSIZE)) \n218.     pygame.display.update() \n219.     FPSCLOCK.tick(FPS) \nThe drawBoxCovers() function has three parameters: the board data structure, a list of (X, Y) \ntuples for each box that should have the cover drawn, and then the amount of coverage to draw \nfor the boxes. \nSince we want to use the same drawing code for each box in the boxes parameter, we will use a \nfor loop on line 211 so we execute the same code on each box in the boxes list. Inside this \nfor loop, the code should do three things: draw the background color (to paint over anything that \nwas there before), draw the icon, then draw however much of the white box over the icon that is \nneeded. The leftTopCoordsOfBox() function will return the pixel coordinates of the top \nleft corner of the box. The if statement on line 216 makes sure that if the number in coverage \nhappens to be less than 0, we won’t call the pygame.draw.rect() function. \nWhen the coverage parameter is 0, there is no coverage at all. When the coverage is set to \n20, there is a 20 pixel wide white box covering the icon. The largest size we’ll want the \ncoverage set to is the number in BOXSIZE, where the entire icon is completely covered. \ndrawBoxCovers() is going to be called from a separate loop than the game loop. Because of \nthis, it needs to have its own calls to pygame.display.update() and \nFPSCLOCK.tick(FPS) to display the animation. (This does mean that while inside this loop, \nthere is no code being run to handle any events being generated. That’s fine, since the cover and \nreveal animations only take a second or so to play.) \nHandling the Revealing and Covering Animation \n222. def revealBoxesAnimation(board, boxesToReveal): \n223.     # Do the \"box reveal\" animation. \n224.     for coverage in range(BOXSIZE, (-REVEALSPEED) - 1, - REVEALSPEED): \n225.         drawBoxCovers(board, boxesToReveal, coverage) \n226.  \n227.  \n228. def coverBoxesAnimation(board, boxesToCover): \n229.     # Do the \"box cover\" animation. \n",
      "content_length": 2447,
      "extraction_method": "Direct"
    },
    {
      "page_number": 84,
      "chapter": null,
      "content": "66    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n230.     for coverage in range(0, BOXSIZE + REVEALSPEED, REVEALSPEED): \n231.         drawBoxCovers(board, boxesToCover, coverage) \nRemember that an animation is simply just displaying different images for brief moments of time, \nand together they make it seem like things are moving on the screen. The \nrevealBoxesAnimation() and coverBoxesAnimation() only need to draw an icon \nwith a varying amount of coverage by the white box. We can write a single function called \ndrawBoxCovers() which can do this, and then have our animation function call \ndrawBoxCovers() for each frame of animation. As we saw in the last section, \ndrawBoxCovers() makes a call to pygame.display.update() and \nFPSCLOCK.tick(FPS) itself. \nTo do this, we’ll set up a for loop to make decreasing (in the case of \nrevealBoxesAnimation()) or increasing (in the case of coverBoxesAnimation()) \nnumbers for the converage parameter. The amount that the coverage variable will \ndecrease/increase by is the number in the REVEALSPEED constant. On line 12 we set this \nconstant to 8, meaning that on each call to drawBoxCovers(), the white box will \ndecrease/increase by 8 pixels on each iteration. If we increase this number, then more pixels will \nbe drawn on each call, meaning that the white box will decrease/increase in size faster. If we set it \nto 1, then the white box will only appear to decrease or increase by 1 pixel on each iteration, \nmaking the entire reveal or cover animation take longer. \nThink of it like climbing stairs. If on each step you take, you climbed one stair, then it would take \na normal amount of time to climb the entire staircase. But if you climbed two stairs at a time on \neach step (and the steps took just as long as before), you could climb the entire staircase twice as \nfast. If you could climb the staircase 8 stairs at a time, then you would climb the entire staircase 8 \ntimes as fast. \nDrawing the Entire Board \n234. def drawBoard(board, revealed): \n235.     # Draws all of the boxes in their covered or revealed state. \n236.     for boxx in range(BOARDWIDTH): \n237.         for boxy in range(BOARDHEIGHT): \n238.             left, top = leftTopCoordsOfBox(boxx, boxy) \n239.             if not revealed[boxx][boxy]: \n240.                 # Draw a covered box. \n241.                 pygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, \nBOXSIZE, BOXSIZE)) \n242.             else: \n243.                 # Draw the (revealed) icon. \n244.                 shape, color = getShapeAndColor(board, boxx, boxy) \n",
      "content_length": 2613,
      "extraction_method": "Direct"
    },
    {
      "page_number": 85,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    67 \n \n245.                 drawIcon(shape, color, boxx, boxy) \nThe drawBoard() function makes a call to drawIcon() for each of the boxes on the board. \nThe nested for loops on lines 236 and 237 will loop through every possible X and Y coordinate \nfor the boxes, and will either draw the icon at that location or draw a white square instead (to \nrepresent a covered up box). \nDrawing the Highlight \n248. def drawHighlightBox(boxx, boxy): \n249.     left, top = leftTopCoordsOfBox(boxx, boxy) \n250.     pygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, (left - 5, top - 5, \nBOXSIZE + 10, BOXSIZE + 10), 4) \nTo help the player recognize that they can click on a covered box to reveal it, we will make a blue \noutline appear around a box to highlight it. This outline is drawn with a call to \npygame.draw.rect() to make a rectangle with a width of 4 pixels. \nThe “Start Game” Animation \n253. def startGameAnimation(board): \n254.     # Randomly reveal the boxes 8 at a time. \n255.     coveredBoxes = generateRevealedBoxesData(False) \n256.     boxes = [] \n257.     for x in range(BOARDWIDTH): \n258.         for y in range(BOARDHEIGHT): \n259.             boxes.append( (x, y) ) \n260.     random.shuffle(boxes) \n261.     boxGroups = splitIntoGroupsOf(8, boxes) \nThe animation that plays at the beginning of the game gives the player a quick hint as to where all \nthe icons are located. In order to make this animation, we have to reveal and cover up groups of \nboxes one group after another. To do this, first we’ll create a list of every possible space on the \nboard. The nested for loops on lines 257 and 258 will add (X, Y) tuples to a list in the boxes \nvariable. \nWe will reveal and cover up the first 8 boxes in this list, then the next 8, then the next 8 after that, \nand so on. However, since the order of the (X, Y) tuples in boxes would be the same each time, \nthen the same order of boxes would be displayed. (Try commenting out line 260 and then running \nto program a few times to see this effect.) \nTo change up the boxes each time a game starts, we will call the random.shuffle() function \nto randomly shuffle the order of the tuples in the boxes list. Then when we reveal and cover up \n",
      "content_length": 2217,
      "extraction_method": "Direct"
    },
    {
      "page_number": 86,
      "chapter": null,
      "content": "68    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nthe first 8 boxes in this list (and each group of 8 boxes afterwards), it will be random group of 8 \nboxes. \nTo get the lists of 8 boxes, we call our splitIntoGroupsOf() function, passing 8 and the \nlist in boxes. The list of lists that the function returns will be stored in a variable named \nboxGroups. \nRevealing and Covering the Groups of Boxes \n263.     drawBoard(board, coveredBoxes) \n264.     for boxGroup in boxGroups: \n265.         revealBoxesAnimation(board, boxGroup) \n266.         coverBoxesAnimation(board, boxGroup) \nFirst, we draw the board. Since every value in coveredBoxes is set to False, this call to \ndrawBoard() will end up drawing only covered up white boxes. The \nrevealBoxesAnimation() and coverBoxesAnimation() functions will draw over the \nspaces of these white boxes. \nThe for loop will go through each of the inner lists in the boxGroups lists. We pass these to \nrevealBoxesAnimation(), which will perform the animation of the white boxes being \npulled away to reveal the icon underneath. Then the call to coverBoxesAnimation() will \nanimate the white boxes expanding to cover up the icons. Then the for loop goes to the next \niteration to animate the next set of 8 boxes. \nThe “Game Won” Animation \n269. def gameWonAnimation(board): \n270.     # flash the background color when the player has won \n271.     coveredBoxes = generateRevealedBoxesData(True) \n272.     color1 = LIGHTBGCOLOR \n273.     color2 = BGCOLOR \n274.  \n275.     for i in range(13): \n276.         color1, color2 = color2, color1 # swap colors \n277.         DISPLAYSURF.fill(color1) \n278.         drawBoard(board, coveredBoxes) \n279.         pygame.display.update() \n280.         pygame.time.wait(300) \nWhen the player has uncovered all of the boxes by matching every pair on the board, we want to \ncongratulate them by flashing the background color. The for loop will draw the color in the \ncolor1 variable for the background color and then draw the board over it. However, on each \niteration of the for loop, the values in color1 and color2 will be swapped with each other \n",
      "content_length": 2173,
      "extraction_method": "Direct"
    },
    {
      "page_number": 87,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    69 \n \non line 276. This way the program will alternate between drawing two different background \ncolors. \nRemember that this function needs to call pygame.display.update() to actually make the \nDISPLAYSURF surface appear on the screen. \nTelling if the Player Has Won \n283. def hasWon(revealedBoxes): \n284.     # Returns True if all the boxes have been revealed, otherwise False \n285.     for i in revealedBoxes: \n286.         if False in i: \n287.             return False # return False if any boxes are covered. \n288.     return True \nThe player has won the game when all of the icon pairs have been matched. Since the ―revealed‖ \ndata structure gets values in it set to True as icons have been matched, we can simply loop \nthrough every space in revealedBoxes looking for a False value. If even one False value \nis in revealedBoxes, then we know there are still unmatched icons on the board. \nNote that because revealedBoxes is a list of lists, the for loop on line 285 will set the inner \nlist as the values of i. But we can use the in operator to search for a False value in the entire \ninner list. This way we don’t need to write an additional line of code and have two nested for \nloops like this: \nfor x in revealedBoxes: \n    for y in revealedBoxes[x]: \n        if False == revealedBoxes[x][y]: \n            return False \nWhy Bother Having a main() Function? \n291. if __name__ == '__main__': \n292.     main() \nIt may seem pointless to have a main() function, since you could just put that code in the global \nscope at the bottom of the program instead, and the code would run the exact same. However, \nthere are two good reasons to put them inside of a main() function. \nFirst, this lets you have local variables whereas otherwise the local variables in the main() \nfunction would have to become global variables. Limiting the number of global variables is a \ngood way to keep the code simple and easier to debug. (See the ―Why Global Variables are Evil‖ \nsection in this chapter.) \n",
      "content_length": 2020,
      "extraction_method": "Direct"
    },
    {
      "page_number": 88,
      "chapter": null,
      "content": "70    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nSecond, this also lets you import the program so that you can call and test individual functions. If \nthe memorypuzzle.py file is in the C:\\Python32 folder, then you can import it from the interactive \nshell. Type the following to test out the splitIntoGroupsOf() and getBoxAtPixel() \nfunctions to make sure they return the correct return values: \n>>> import memorypuzzle \n>>> memorypuzzle.splitIntoGroupsOf(3, [0,1,2,3,4,5,6,7,8,9]) \n[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]] \n>>> memorypuzzle.getBoxAtPixel(0, 0) \n(None, None) \n>>> memorypuzzle.getBoxAtPixel(150, 150) \n(1, 1) \nWhen a module is imported, all of the code in it is run. If we didn’t have the main() function, \nand had its code in the global scope, then the game would have automatically started as soon as \nwe imported it, which really wouldn’t let us call individual functions in it. \nThat’s why the code is in a separate function that we have named main(). Then we check the \nbuilt-in Python variable __name__ to see if we should call the main() function or not. This \nvariable is automatically set by the Python interpreter to the string '__main__' if the program \nitself is being run and 'memorypuzzle' if it is being imported. This is why the main() \nfunction is not run when we executed the import memorypuzzle statement in the interactive \nshell. \nThis is a handy technique for being able to import the program you are working on from the \ninteractive shell and make sure individual functions are returning the correct values by testing \nthem one call at a time. \nWhy Bother With Readability? \nA lot of the suggestions in this chapter haven’t been about how to write programs that computers \ncan run so much as how to write programs that programmers can read. You might not understand \nwhy this is important. After all, as long as the code works, who cares if it is hard or easy for \nhuman programmers to read? \nHowever, the important thing to realize about software is that it is rarely ever left alone. When \nyou are creating your own games, you will rarely be ―done‖ with the program. You will always \nget new ideas for game features you want add, or find new bugs with the program. Because of \nthis, it is important that your program is readable so that you can look at the code and understand \nit. And understanding the code is the first step to changing it to add more code or fix bugs. \nAs an example, here is an obfuscated version of the Memory Puzzle program that was made \nentirely unreadable. If you type it in (or download it from \n",
      "content_length": 2617,
      "extraction_method": "Direct"
    },
    {
      "page_number": 89,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    71 \n \nhttp://invpy.com/memorypuzzle_obfuscated.py) and run it you will find it runs exactly the same \nas the code at the beginning of this chapter. But if there was a bug with this code, it would be \nimpossible to read the code and understand what’s going on, much less fix the bug. \nThe computer doesn’t mind code as unreadable as this. It’s all the same to it. \nimport random, pygame, sys \nfrom pygame.locals import * \ndef hhh(): \n    global a, b \n    pygame.init() \n    a = pygame.time.Clock() \n    b = pygame.display.set_mode((640, 480)) \n    j = 0 \n    k = 0 \n    pygame.display.set_caption('Memory Game') \n    i = c() \n    hh = d(False) \n    h = None \n    b.fill((60, 60, 100)) \n    g(i) \n    while True: \n        e = False \n        b.fill((60, 60, 100)) \n        f(i, hh) \n        for eee in pygame.event.get(): \n            if eee.type == QUIT or (eee.type == KEYUP and eee.key == K_ESCAPE): \n                pygame.quit() \n                sys.exit() \n            elif eee.type == MOUSEMOTION: \n                j, k = eee.pos \n            elif eee.type == MOUSEBUTTONUP: \n                j, k = eee.pos \n                e = True \n        bb, ee = m(j, k) \n        if bb != None and ee != None: \n            if not hh[bb][ee]: \n                n(bb, ee) \n            if not hh[bb][ee] and e: \n                o(i, [(bb, ee)]) \n                hh[bb][ee] = True \n                if h == None: \n                    h = (bb, ee) \n                else: \n                    q, fff = s(i, h[0], h[1]) \n                    r, ggg = s(i, bb, ee) \n",
      "content_length": 1576,
      "extraction_method": "Direct"
    },
    {
      "page_number": 90,
      "chapter": null,
      "content": "72    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n                    if q != r or fff != ggg: \n                        pygame.time.wait(1000) \n                        p(i, [(h[0], h[1]), (bb, ee)]) \n                        hh[h[0]][h[1]] = False \n                        hh[bb][ee] = False \n                    elif ii(hh): \n                        jj(i) \n                        pygame.time.wait(2000) \n                        i = c() \n                        hh = d(False) \n                        f(i, hh) \n                        pygame.display.update() \n                        pygame.time.wait(1000) \n                        g(i) \n                    h = None \n        pygame.display.update() \n        a.tick(30) \ndef d(ccc): \n    hh = [] \n    for i in range(10): \n        hh.append([ccc] * 7) \n    return hh \ndef c(): \n    rr = [] \n    for tt in ((255, 0, 0), (0, 255, 0), (0, 0, 255), (255, 255, 0), (255, 128, \n0), (255, 0, 255), (0, 255, 255)): \n        for ss in ('a', 'b', 'c', 'd', 'e'): \n            rr.append( (ss, tt) ) \n    random.shuffle(rr) \n    rr = rr[:35] * 2 \n    random.shuffle(rr) \n    bbb = [] \n    for x in range(10): \n        v = [] \n        for y in range(7): \n            v.append(rr[0]) \n            del rr[0] \n        bbb.append(v) \n    return bbb \ndef t(vv, uu): \n    ww = [] \n    for i in range(0, len(uu), vv): \n        ww.append(uu[i:i + vv]) \n    return ww \ndef aa(bb, ee): \n    return (bb * 50 + 70, ee * 50 + 65) \ndef m(x, y): \n",
      "content_length": 1520,
      "extraction_method": "Direct"
    },
    {
      "page_number": 91,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    73 \n \n    for bb in range(10): \n        for ee in range(7): \n            oo, ddd = aa(bb, ee) \n            aaa = pygame.Rect(oo, ddd, 40, 40) \n            if aaa.collidepoint(x, y): \n                return (bb, ee) \n    return (None, None) \ndef w(ss, tt, bb, ee): \n    oo, ddd = aa(bb, ee) \n    if ss == 'a': \n        pygame.draw.circle(b, tt, (oo + 20, ddd + 20), 15) \n        pygame.draw.circle(b, (60, 60, 100), (oo + 20, ddd + 20), 5) \n    elif ss == 'b': \n        pygame.draw.rect(b, tt, (oo + 10, ddd + 10, 20, 20)) \n    elif ss == 'c': \n        pygame.draw.polygon(b, tt, ((oo + 20, ddd), (oo + 40 - 1, ddd + 20), \n(oo + 20, ddd + 40 - 1), (oo, ddd + 20))) \n    elif ss == 'd': \n        for i in range(0, 40, 4): \n            pygame.draw.line(b, tt, (oo, ddd + i), (oo + i, ddd)) \n            pygame.draw.line(b, tt, (oo + i, ddd + 39), (oo + 39, ddd + i)) \n    elif ss == 'e': \n        pygame.draw.ellipse(b, tt, (oo, ddd + 10, 40, 20)) \ndef s(bbb, bb, ee): \n    return bbb[bb][ee][0], bbb[bb][ee][1] \ndef dd(bbb, boxes, gg): \n    for box in boxes: \n        oo, ddd = aa(box[0], box[1]) \n        pygame.draw.rect(b, (60, 60, 100), (oo, ddd, 40, 40)) \n        ss, tt = s(bbb, box[0], box[1]) \n        w(ss, tt, box[0], box[1]) \n        if gg > 0: \n            pygame.draw.rect(b, (255, 255, 255), (oo, ddd, gg, 40)) \n    pygame.display.update() \n    a.tick(30) \ndef o(bbb, cc): \n    for gg in range(40, (-8) - 1, -8): \n        dd(bbb, cc, gg) \ndef p(bbb, ff): \n    for gg in range(0, 48, 8): \n        dd(bbb, ff, gg) \ndef f(bbb, pp): \n    for bb in range(10): \n        for ee in range(7): \n            oo, ddd = aa(bb, ee) \n            if not pp[bb][ee]: \n                pygame.draw.rect(b, (255, 255, 255), (oo, ddd, 40, 40)) \n",
      "content_length": 1765,
      "extraction_method": "Direct"
    },
    {
      "page_number": 92,
      "chapter": null,
      "content": "74    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n            else: \n                ss, tt = s(bbb, bb, ee) \n                w(ss, tt, bb, ee) \ndef n(bb, ee): \n    oo, ddd = aa(bb, ee) \n    pygame.draw.rect(b, (0, 0, 255), (oo - 5, ddd - 5, 50, 50), 4) \ndef g(bbb): \n    mm = d(False) \n    boxes = [] \n    for x in range(10): \n        for y in range(7): \n            boxes.append( (x, y) ) \n    random.shuffle(boxes) \n    kk = t(8, boxes) \n    f(bbb, mm) \n    for nn in kk: \n        o(bbb, nn) \n        p(bbb, nn) \ndef jj(bbb): \n    mm = d(True) \n    tt1 = (100, 100, 100) \n    tt2 = (60, 60, 100) \n    for i in range(13): \n        tt1, tt2 = tt2, tt1 \n        b.fill(tt1) \n        f(bbb, mm) \n        pygame.display.update() \n        pygame.time.wait(300) \ndef ii(hh): \n    for i in hh: \n        if False in i: \n            return False \n    return True \nif __name__ == '__main__': \n    hhh() \nNever write code like this. If you program like this while facing the mirror in a bathroom with the \nlights turned off, the ghost of Ada Lovelace will come out of the mirror and throw you into the \njaws of a Jacquard loom. \nSummary, and a Hacking Suggestion \nThis chapter covers the entire explanation of how the Memory Puzzle program works. Read over \nthe chapter and the source code again to understand it better. Many of the other game programs in \nthis book make use of the same programming concepts (like nested for loops, syntactic sugar, \n",
      "content_length": 1494,
      "extraction_method": "Direct"
    },
    {
      "page_number": 93,
      "chapter": null,
      "content": "Chapter 3 – Memory Puzzle    75 \n \nand different coordinate systems in the same program) so they won’t be explained again to keep \nthis book short. \nOne idea to try out to understand how the code works is to intentionally break it by commenting \nout random lines. Doing this to some of the lines will probably cause a syntactic error that will \nprevent the script from running at all. But commenting out other lines will result in weird bugs \nand other cool effects. Try doing this and then figure out why a program has the bugs it does. \nThis is also the first step in being able to add your own secret cheats or hacks to the program. By \nbreaking the program from what it normally does, you can learn how to change it to do something \nneat effect (like secretly giving you hints on how to solve the puzzle). Feel free to experiment. \nYou can always save a copy of the unchanged source code in a different file if you want to play \nthe regular game again. \nIn fact, if you’d like some practice fixing bugs, there are several versions of this game’s source \ncode that have small bugs in them. You can download these buggy versions from \nhttp://invpy.com/buggy/memorypuzzle. Try running the program to figure out what the bug is, \nand why the program is acting that way. \n \n",
      "content_length": 1273,
      "extraction_method": "Direct"
    },
    {
      "page_number": 94,
      "chapter": null,
      "content": "76    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n \n",
      "content_length": 106,
      "extraction_method": "Direct"
    },
    {
      "page_number": 95,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    77 \n \nCHAPTER 4 – SLIDE PUZZLE \n \nHow to Play Slide Puzzle \nThe board is a 4x4 grid with fifteen tiles (numbered 1 through 15 going left to right) and one \nblank space. The tiles start out in random positions, and the player must slide tiles around until \nthe tiles are back in their original order. \nSource Code to Slide Puzzle \nThis source code can be downloaded from http://invpy.com/slidepuzzle.py. If you get any error \nmessages, look at the line number that is mentioned in the error message and check your code for \nany typos. You can also copy and paste your code into the web form at \nhttp://invpy.com/diff/slidepuzzle to see if the differences between your code and the code in the \nbook. \n  1. # Slide Puzzle \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import pygame, sys, random \n  7. from pygame.locals import * \n  8.  \n  9. # Create the constants (go ahead and experiment with different values) \n 10. BOARDWIDTH = 4  # number of columns in the board \n 11. BOARDHEIGHT = 4 # number of rows in the board \n 12. TILESIZE = 80 \n",
      "content_length": 1165,
      "extraction_method": "Direct"
    },
    {
      "page_number": 96,
      "chapter": null,
      "content": "78    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 13. WINDOWWIDTH = 640 \n 14. WINDOWHEIGHT = 480 \n 15. FPS = 30 \n 16. BLANK = None \n 17.  \n 18. #                 R    G    B \n 19. BLACK =         (  0,   0,   0) \n 20. WHITE =         (255, 255, 255) \n 21. BRIGHTBLUE =    (  0,  50, 255) \n 22. DARKTURQUOISE = (  3,  54,  73) \n 23. GREEN =         (  0, 204,   0) \n 24.  \n 25. BGCOLOR = DARKTURQUOISE \n 26. TILECOLOR = GREEN \n 27. TEXTCOLOR = WHITE \n 28. BORDERCOLOR = BRIGHTBLUE \n 29. BASICFONTSIZE = 20 \n 30.  \n 31. BUTTONCOLOR = WHITE \n 32. BUTTONTEXTCOLOR = BLACK \n 33. MESSAGECOLOR = WHITE \n 34.  \n 35. XMARGIN = int((WINDOWWIDTH - (TILESIZE * BOARDWIDTH + (BOARDWIDTH - 1))) / \n2) \n 36. YMARGIN = int((WINDOWHEIGHT - (TILESIZE * BOARDHEIGHT + (BOARDHEIGHT - \n1))) / 2) \n 37.  \n 38. UP = 'up' \n 39. DOWN = 'down' \n 40. LEFT = 'left' \n 41. RIGHT = 'right' \n 42.  \n 43. def main(): \n 44.     global FPSCLOCK, DISPLAYSURF, BASICFONT, RESET_SURF, RESET_RECT, \nNEW_SURF, NEW_RECT, SOLVE_SURF, SOLVE_RECT \n 45.  \n 46.     pygame.init() \n 47.     FPSCLOCK = pygame.time.Clock() \n 48.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 49.     pygame.display.set_caption('Slide Puzzle') \n 50.     BASICFONT = pygame.font.Font('freesansbold.ttf', BASICFONTSIZE) \n 51.  \n 52.     # Store the option buttons and their rectangles in OPTIONS. \n 53.     RESET_SURF, RESET_RECT = makeText('Reset',    TEXTCOLOR, TILECOLOR, \nWINDOWWIDTH - 120, WINDOWHEIGHT - 90) \n",
      "content_length": 1528,
      "extraction_method": "Direct"
    },
    {
      "page_number": 97,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    79 \n \n 54.     NEW_SURF,   NEW_RECT   = makeText('New Game', TEXTCOLOR, TILECOLOR, \nWINDOWWIDTH - 120, WINDOWHEIGHT - 60) \n \n 55.     SOLVE_SURF, SOLVE_RECT = makeText('Solve',    TEXTCOLOR, TILECOLOR, \nWINDOWWIDTH - 120, WINDOWHEIGHT - 30) \n 56.  \n 57.     mainBoard, solutionSeq = generateNewPuzzle(80) \n 58.     SOLVEDBOARD = getStartingBoard() # a solved board is the same as the \nboard in a start state. \n 59.     allMoves = [] # list of moves made from the solved configuration \n 60.  \n 61.     while True: # main game loop \n 62.         slideTo = None # the direction, if any, a tile should slide \n 63.         msg = '' # contains the message to show in the upper left corner. \n 64.         if mainBoard == SOLVEDBOARD: \n 65.             msg = 'Solved!' \n 66.  \n 67.         drawBoard(mainBoard, msg) \n 68.  \n 69.         checkForQuit() \n 70.         for event in pygame.event.get(): # event handling loop \n 71.             if event.type == MOUSEBUTTONUP: \n 72.                 spotx, spoty = getSpotClicked(mainBoard, event.pos[0], \nevent.pos[1]) \n 73.  \n 74.                 if (spotx, spoty) == (None, None): \n 75.                     # check if the user clicked on an option button \n 76.                     if RESET_RECT.collidepoint(event.pos): \n 77.                         resetAnimation(mainBoard, allMoves) # clicked on \nReset button \n 78.                         allMoves = [] \n 79.                     elif NEW_RECT.collidepoint(event.pos): \n 80.                         mainBoard, solutionSeq = generateNewPuzzle(80) # \nclicked on New Game button \n 81.                         allMoves = [] \n 82.                     elif SOLVE_RECT.collidepoint(event.pos): \n 83.                         resetAnimation(mainBoard, solutionSeq + allMoves) \n# clicked on Solve button \n 84.                         allMoves = [] \n 85.                 else: \n 86.                     # check if the clicked tile was next to the blank spot \n 87.  \n 88.                     blankx, blanky = getBlankPosition(mainBoard) \n 89.                     if spotx == blankx + 1 and spoty == blanky: \n 90.                         slideTo = LEFT \n 91.                     elif spotx == blankx - 1 and spoty == blanky: \n",
      "content_length": 2232,
      "extraction_method": "Direct"
    },
    {
      "page_number": 98,
      "chapter": null,
      "content": "80    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 92.                         slideTo = RIGHT \n 93.                     elif spotx == blankx and spoty == blanky + 1: \n 94.                         slideTo = UP \n 95.                     elif spotx == blankx and spoty == blanky - 1: \n 96.                         slideTo = DOWN \n 97.  \n 98.             elif event.type == KEYUP: \n 99.                 # check if the user pressed a key to slide a tile \n100.                 if event.key in (K_LEFT, K_a) and isValidMove(mainBoard, \nLEFT): \n101.                     slideTo = LEFT \n102.                 elif event.key in (K_RIGHT, K_d) and \nisValidMove(mainBoard, RIGHT): \n103.                     slideTo = RIGHT \n104.                 elif event.key in (K_UP, K_w) and isValidMove(mainBoard, \nUP): \n105.                     slideTo = UP \n106.                 elif event.key in (K_DOWN, K_s) and isValidMove(mainBoard, \nDOWN): \n107.                     slideTo = DOWN \n108.  \n109.         if slideTo: \n110.             slideAnimation(mainBoard, slideTo, 'Click tile or press arrow \nkeys to slide.', 8) # show slide on screen \n111.             makeMove(mainBoard, slideTo) \n112.             allMoves.append(slideTo) # record the slide \n113.         pygame.display.update() \n114.         FPSCLOCK.tick(FPS) \n115.  \n116.  \n117. def terminate(): \n118.     pygame.quit() \n119.     sys.exit() \n120.  \n121.  \n122. def checkForQuit(): \n123.     for event in pygame.event.get(QUIT): # get all the QUIT events \n124.         terminate() # terminate if any QUIT events are present \n125.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n126.         if event.key == K_ESCAPE: \n127.             terminate() # terminate if the KEYUP event was for the Esc key \n128.         pygame.event.post(event) # put the other KEYUP event objects back \n129.  \n130.  \n131. def getStartingBoard(): \n132.     # Return a board data structure with tiles in the solved state. \n",
      "content_length": 2013,
      "extraction_method": "Direct"
    },
    {
      "page_number": 99,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    81 \n \n133.     # For example, if BOARDWIDTH and BOARDHEIGHT are both 3, this function \n134.     # returns [[1, 4, 7], [2, 5, 8], [3, 6, None]] \n135.     counter = 1 \n136.     board = [] \n137.     for x in range(BOARDWIDTH): \n138.         column = [] \n139.         for y in range(BOARDHEIGHT): \n140.             column.append(counter) \n141.             counter += BOARDWIDTH \n142.         board.append(column) \n143.         counter -= BOARDWIDTH * (BOARDHEIGHT - 1) + BOARDWIDTH - 1 \n144.  \n145.     board[BOARDWIDTH-1][BOARDHEIGHT-1] = None \n146.     return board \n147.  \n148.  \n149. def getBlankPosition(board): \n150.     # Return the x and y of board coordinates of the blank space. \n151.     for x in range(BOARDWIDTH)): \n152.         for y in range(BOARDHEIGHT): \n153.             if board[x][y] == None: \n154.                 return (x, y) \n155.  \n156.  \n157. def makeMove(board, move): \n158.     # This function does not check if the move is valid. \n159.     blankx, blanky = getBlankPosition(board) \n160.  \n161.     if move == UP: \n162.         board[blankx][blanky], board[blankx][blanky + 1] = \nboard[blankx][blanky + 1], board[blankx][blanky] \n163.     elif move == DOWN: \n164.         board[blankx][blanky], board[blankx][blanky - 1] = \nboard[blankx][blanky - 1], board[blankx][blanky] \n165.     elif move == LEFT: \n166.         board[blankx][blanky], board[blankx + 1][blanky] = board[blankx + \n1][blanky], board[blankx][blanky] \n167.     elif move == RIGHT: \n168.         board[blankx][blanky], board[blankx - 1][blanky] = board[blankx - \n1][blanky], board[blankx][blanky] \n169.  \n170.  \n171. def isValidMove(board, move): \n172.     blankx, blanky = getBlankPosition(board) \n173.     return (move == UP and blanky != len(board[0]) - 1) or \\ \n174.            (move == DOWN and blanky != 0) or \\ \n",
      "content_length": 1836,
      "extraction_method": "Direct"
    },
    {
      "page_number": 100,
      "chapter": null,
      "content": "82    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n175.            (move == LEFT and blankx != len(board) - 1) or \\ \n176.            (move == RIGHT and blankx != 0) \n177.  \n178.  \n179. def getRandomMove(board, lastMove=None): \n180.     # start with a full list of all four moves \n181.     validMoves = [UP, DOWN, LEFT, RIGHT] \n182.  \n183.     # remove moves from the list as they are disqualified \n184.     if lastMove == UP or not isValidMove(board, DOWN): \n185.         validMoves.remove(DOWN) \n186.     if lastMove == DOWN or not isValidMove(board, UP): \n187.         validMoves.remove(UP) \n188.     if lastMove == LEFT or not isValidMove(board, RIGHT): \n189.         validMoves.remove(RIGHT) \n190.     if lastMove == RIGHT or not isValidMove(board, LEFT): \n191.         validMoves.remove(LEFT) \n192.  \n193.     # return a random move from the list of remaining moves \n194.     return random.choice(validMoves) \n195.  \n196.  \n197. def getLeftTopOfTile(tileX, tileY): \n198.     left = XMARGIN + (tileX * TILESIZE) + (tileX - 1) \n199.     top = YMARGIN + (tileY * TILESIZE) + (tileY - 1) \n200.     return (left, top) \n201.  \n202.  \n203. def getSpotClicked(board, x, y): \n204.     # from the x & y pixel coordinates, get the x & y board coordinates \n205.     for tileX in range(len(board)): \n206.         for tileY in range(len(board[0])): \n207.             left, top = getLeftTopOfTile(tileX, tileY) \n208.             tileRect = pygame.Rect(left, top, TILESIZE, TILESIZE) \n209.             if tileRect.collidepoint(x, y): \n210.                 return (tileX, tileY) \n211.     return (None, None) \n212.  \n213.  \n214. def drawTile(tilex, tiley, number, adjx=0, adjy=0): \n215.     # draw a tile at board coordinates tilex and tiley, optionally a few \n216.     # pixels over (determined by adjx and adjy) \n217.     left, top = getLeftTopOfTile(tilex, tiley) \n218.     pygame.draw.rect(DISPLAYSURF, TILECOLOR, (left + adjx, top + adjy, \nTILESIZE, TILESIZE)) \n219.     textSurf = BASICFONT.render(str(number), True, TEXTCOLOR) \n",
      "content_length": 2074,
      "extraction_method": "Direct"
    },
    {
      "page_number": 101,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    83 \n \n220.     textRect = textSurf.get_rect() \n221.     textRect.center = left + int(TILESIZE / 2) + adjx, top + int(TILESIZE \n/ 2) + adjy \n222.     DISPLAYSURF.blit(textSurf, textRect) \n223.  \n224.  \n225. def makeText(text, color, bgcolor, top, left): \n226.     # create the Surface and Rect objects for some text. \n227.     textSurf = BASICFONT.render(text, True, color, bgcolor) \n228.     textRect = textSurf.get_rect() \n229.     textRect.topleft = (top, left) \n230.     return (textSurf, textRect) \n231.  \n232.  \n233. def drawBoard(board, message): \n234.     DISPLAYSURF.fill(BGCOLOR) \n235.     if message: \n236.         textSurf, textRect = makeText(message, MESSAGECOLOR, BGCOLOR, 5, \n5) \n237.         DISPLAYSURF.blit(textSurf, textRect) \n238.  \n239.     for tilex in range(len(board)): \n240.         for tiley in range(len(board[0])): \n241.             if board[tilex][tiley]: \n242.                 drawTile(tilex, tiley, board[tilex][tiley]) \n243.  \n244.     left, top = getLeftTopOfTile(0, 0) \n245.     width = BOARDWIDTH * TILESIZE \n246.     height = BOARDHEIGHT * TILESIZE \n247.     pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (left - 5, top - 5, width + \n11, height + 11), 4) \n248.  \n249.     DISPLAYSURF.blit(RESET_SURF, RESET_RECT) \n250.     DISPLAYSURF.blit(NEW_SURF, NEW_RECT) \n251.     DISPLAYSURF.blit(SOLVE_SURF, SOLVE_RECT) \n252.  \n253.  \n254. def slideAnimation(board, direction, message, animationSpeed): \n255.     # Note: This function does not check if the move is valid. \n256.  \n257.     blankx, blanky = getBlankPosition(board) \n258.     if direction == UP: \n259.         movex = blankx \n260.         movey = blanky + 1 \n261.     elif direction == DOWN: \n262.         movex = blankx \n",
      "content_length": 1738,
      "extraction_method": "Direct"
    },
    {
      "page_number": 102,
      "chapter": null,
      "content": "84    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n263.         movey = blanky - 1 \n264.     elif direction == LEFT: \n265.         movex = blankx + 1 \n266.         movey = blanky \n267.     elif direction == RIGHT: \n268.         movex = blankx - 1 \n269.         movey = blanky \n270.  \n271.     # prepare the base surface \n272.     drawBoard(board, message) \n273.     baseSurf = DISPLAYSURF.copy() \n274.     # draw a blank space over the moving tile on the baseSurf Surface. \n275.     moveLeft, moveTop = getLeftTopOfTile(movex, movey) \n276.     pygame.draw.rect(baseSurf, BGCOLOR, (moveLeft, moveTop, TILESIZE, \nTILESIZE)) \n277.  \n278.     for i in range(0, TILESIZE, animationSpeed): \n279.         # animate the tile sliding over \n280.         checkForQuit() \n281.         DISPLAYSURF.blit(baseSurf, (0, 0)) \n282.         if direction == UP: \n283.             drawTile(movex, movey, board[movex][movey], 0, -i) \n284.         if direction == DOWN: \n285.             drawTile(movex, movey, board[movex][movey], 0, i) \n286.         if direction == LEFT: \n287.             drawTile(movex, movey, board[movex][movey], -i, 0) \n288.         if direction == RIGHT: \n289.             drawTile(movex, movey, board[movex][movey], i, 0) \n290.  \n291.         pygame.display.update() \n292.         FPSCLOCK.tick(FPS) \n293.  \n294.  \n295. def generateNewPuzzle(numSlides): \n296.     # From a starting configuration, make numSlides number of moves (and \n297.     # animate these moves). \n298.     sequence = [] \n299.     board = getStartingBoard() \n300.     drawBoard(board, '') \n301.     pygame.display.update() \n302.     pygame.time.wait(500) # pause 500 milliseconds for effect \n303.     lastMove = None \n304.     for i in range(numSlides): \n305.         move = getRandomMove(board, lastMove) \n306.         slideAnimation(board, move, 'Generating new puzzle...', \nint(TILESIZE / 3)) \n",
      "content_length": 1921,
      "extraction_method": "Direct"
    },
    {
      "page_number": 103,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    85 \n \n307.         makeMove(board, move) \n308.         sequence.append(move) \n309.         lastMove = move \n310.     return (board, sequence) \n311.  \n312.  \n313. def resetAnimation(board, allMoves): \n314.     # make all of the moves in allMoves in reverse. \n315.     revAllMoves = allMoves[:] # gets a copy of the list \n316.     revAllMoves.reverse() \n317.  \n318.     for move in revAllMoves: \n319.         if move == UP: \n320.             oppositeMove = DOWN \n321.         elif move == DOWN: \n322.             oppositeMove = UP \n323.         elif move == RIGHT: \n324.             oppositeMove = LEFT \n325.         elif move == LEFT: \n326.             oppositeMove = RIGHT \n327.         slideAnimation(board, oppositeMove, '', int(TILESIZE / 2)) \n328.         makeMove(board, oppositeMove) \n329.  \n330.  \n331. if __name__ == '__main__': \n332.     main() \nSecond Verse, Same as the First \nMuch of the code in Wormy is similar to the previous games we’ve looked at, especially the \nconstants being set at the start of the code. \n  1. # Slide Puzzle \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import pygame, sys, random \n  7. from pygame.locals import * \n  8.  \n  9. # Create the constants (go ahead and experiment with different values) \n 10. BOARDWIDTH = 4  # number of columns in the board \n 11. BOARDHEIGHT = 4 # number of rows in the board \n 12. TILESIZE = 80 \n 13. WINDOWWIDTH = 640 \n",
      "content_length": 1516,
      "extraction_method": "Direct"
    },
    {
      "page_number": 104,
      "chapter": null,
      "content": "86    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 14. WINDOWHEIGHT = 480 \n 15. FPS = 30 \n 16. BLANK = None \n 17.  \n 18. #                 R    G    B \n 19. BLACK =         (  0,   0,   0) \n 20. WHITE =         (255, 255, 255) \n 21. BRIGHTBLUE =    (  0,  50, 255) \n 22. DARKTURQUOISE = (  3,  54,  73) \n 23. GREEN =         (  0, 204,   0) \n 24.  \n 25. BGCOLOR = DARKTURQUOISE \n 26. TILECOLOR = GREEN \n 27. TEXTCOLOR = WHITE \n 28. BORDERCOLOR = BRIGHTBLUE \n 29. BASICFONTSIZE = 20 \n 30.  \n 31. BUTTONCOLOR = WHITE \n 32. BUTTONTEXTCOLOR = BLACK \n 33. MESSAGECOLOR = WHITE \n 34.  \n 35. XMARGIN = int((WINDOWWIDTH - (TILESIZE * BOARDWIDTH + (BOARDWIDTH - 1))) / \n2) \n 36. YMARGIN = int((WINDOWHEIGHT - (TILESIZE * BOARDHEIGHT + (BOARDHEIGHT - \n1))) / 2) \n 37.  \n 38. UP = 'up' \n 39. DOWN = 'down' \n 40. LEFT = 'left' \n 41. RIGHT = 'right' \nThis code at the top of the program just handles all the basic importing of modules and creating \nconstants. This is just like the beginning of the Memory Puzzle game from the last chapter. \nSetting Up the Buttons \n 43. def main(): \n 44.     global FPSCLOCK, DISPLAYSURF, BASICFONT, RESET_SURF, RESET_RECT, \nNEW_SURF, NEW_RECT, SOLVE_SURF, SOLVE_RECT \n 45.  \n 46.     pygame.init() \n 47.     FPSCLOCK = pygame.time.Clock() \n 48.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 49.     pygame.display.set_caption('Slide Puzzle') \n 50.     BASICFONT = pygame.font.Font('freesansbold.ttf', BASICFONTSIZE) \n 51.  \n",
      "content_length": 1525,
      "extraction_method": "Direct"
    },
    {
      "page_number": 105,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    87 \n \n 52.     # Store the option buttons and their rectangles in OPTIONS. \n 53.     RESET_SURF, RESET_RECT = makeText('Reset',    TEXTCOLOR, TILECOLOR, \nWINDOWWIDTH - 120, WINDOWHEIGHT - 90) \n 54.     NEW_SURF,   NEW_RECT   = makeText('New Game', TEXTCOLOR, TILECOLOR, \nWINDOWWIDTH - 120, WINDOWHEIGHT - 60) \n 55.     SOLVE_SURF, SOLVE_RECT = makeText('Solve',    TEXTCOLOR, TILECOLOR, \nWINDOWWIDTH - 120, WINDOWHEIGHT - 30) \n 56.  \n 57.     mainBoard, solutionSeq = generateNewPuzzle(80) \n 58.     SOLVEDBOARD = getStartingBoard() # a solved board is the same as the \nboard in a start state. \nJust like in the last chapter, the functions called from the main() function calls will be \nexplained later in the chapter. For now, you just need to know what they do and what values they \nreturn. You don’t need to know how they work. \nThe first part of the main() function will handle creating the window, Clock object, and Font \nobject. The makeText() function is defined later in the program, but for now you just need to \nknow that it returns a pygame.Surface object and pygame.Rect object which can be used \nto make clickable buttons. The Slide Puzzle game will have three buttons: a ―Reset‖ button that \nwill undo any moves the player has made, a ―New‖ button that will create a new slide puzzle, and \na ―Solve‖ button that will solve the puzzle for the player. \nWe will need to have two board data structures for this program. One board will represent the \ncurrent game state. The other board will have its tiles in the ―solved‖ state, meaning that all the \ntiles are lined up in order. When the current game state’s board is exactly the same as the solved \nboard, then we know the player has won. (We won’t ever change this second one. It’ll just be \nthere to compare the current game state board to.) \nThe generateNewPuzzle() will create a board data structure that started off in the ordered, \nsolved state and then had 80 random slide moves performed on it (because we passed the integer \n80 to it. If we want the board to be even more jumbled, then we can pass a larger integer to it). \nThis will make the board into a randomly jumbled state that the player will have to solve (which \nwill be stored in a variable named mainBoard). The generateNewBoard() also returns a \nlist of all the random moves that were performed on it (which will be stored in a variable named \nsolutionSeq). \nBeing Smart By Using Stupid Code \n 59.     allMoves = [] # list of moves made from the solved configuration \n",
      "content_length": 2529,
      "extraction_method": "Direct"
    },
    {
      "page_number": 106,
      "chapter": null,
      "content": "88    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nSolving a slide puzzle can be really tricky. We could program the computer to do it, but that \nwould require us to figure out an algorithm that can solve the slide puzzle. That would be very \ndifficult and involve a lot of cleverness and effort to put into this program.  \nFortunately, there’s an easier way. We could just have the computer memorize all the random \nslides it made when it created the board data structure, and then the board can be solved just by \nperforming the opposite slide. Since the board originally started in the solved state, undoing all \nthe slides would return it to the solved state. \nFor example, below we perform a ―right‖ slide on the board on the left side of the page, which \nleaves the board in the state that is on the right side of the page: \n \nAfter the right slide, if we do the opposite slide (a left slide) then the board will be back in the \noriginal state. So to get back to the original state after several slides, we just have to do the \nopposite slides in reverse order. If we did a right slide, then another right slide, then a down slide, \nwe would have to do an up slide, left slide, and left slide to undo those first three slides. This is \nmuch easier than writing a function that can solve these puzzles simply by looking at the current \nstate of them. \nThe Main Game Loop \n 61.     while True: # main game loop \n 62.         slideTo = None # the direction, if any, a tile should slide \n 63.         msg = '' # contains the message to show in the upper left corner. \n 64.         if mainBoard == SOLVEDBOARD: \n 65.             msg = 'Solved!' \n 66.  \n 67.         drawBoard(mainBoard, msg) \nIn the main game loop, the slideTo variable will track which direction the player wants to slide \na tile (it starts off at the beginning of the game loop as None and is set later) and the msg \nvariable tracks what string to display at the top of the window. The program does a quick check \non line 64 to see if the board data structure has the same value as the solved board data structure \nstored in SOLVEDBOARD. If so, then the msg variable is changed to the string 'Solved!'. \n",
      "content_length": 2225,
      "extraction_method": "Direct"
    },
    {
      "page_number": 107,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    89 \n \nThis won’t appear on the screen until drawBoard() has been called to draw it to the \nDISPLAYSURF Surface object (which is done on line 67) and pygame.display.update() \nis called to draw the display Surface object on the actual computer screen (which is done on line \n291 at the end of the game loop). \nClicking on the Buttons \n 69.         checkForQuit() \n 70.         for event in pygame.event.get(): # event handling loop \n 71.             if event.type == MOUSEBUTTONUP: \n 72.                 spotx, spoty = getSpotClicked(mainBoard, event.pos[0], \nevent.pos[1]) \n 73.  \n 74.                 if (spotx, spoty) == (None, None): \n 75.                     # check if the user clicked on an option button \n 76.                     if RESET_RECT.collidepoint(event.pos): \n 77.                         resetAnimation(mainBoard, allMoves) # clicked on \nReset button \n 78.                         allMoves = [] \n 79.                     elif NEW_RECT.collidepoint(event.pos): \n 80.                         mainBoard, solutionSeq = generateNewPuzzle(80) # \nclicked on New Game button \n 81.                         allMoves = [] \n 82.                     elif SOLVE_RECT.collidepoint(event.pos): \n 83.                         resetAnimation(mainBoard, solutionSeq + allMoves) \n# clicked on Solve button \n 84.                         allMoves = [] \nBefore going into the event loop, the program calls checkForQuit() on line 69 to see if any \nQUIT events have been created (and terminates the program if there have). Why we have a \nseparate function (the checkForQuit() function) for handling the QUIT events will be \nexplained later. The for loop on line 70 executes the event handling code for any other event \ncreated since the last time pygame.event.get() was called (or since the program started, if \npygame.event.get() has never been called before). \nIf the type of event was a MOUSEBUTTONUP event (that is, the player had released a mouse \nbutton somewhere over the window), then we pass the mouse coordinates to our \ngetSpotClicked() function which will return the board coordinates of the spot on the board \nthe mouse release happened. The event.pos[0] is the X coordinate and event.pos[1] is \nthe Y coordinate. \nIf the mouse button release did not happen over one of the spaces on the board (but obviously still \nhappened somewhere on the window, since a MOUSEBUTTONUP event was created), then \ngetSpotClicked() will return None. If this is the case, we want to do an additional check to \n",
      "content_length": 2524,
      "extraction_method": "Direct"
    },
    {
      "page_number": 108,
      "chapter": null,
      "content": "90    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nsee if the player might have clicked on the Reset, New, or Solve buttons (which are not located on \nthe board).  \nThe coordinates of where these buttons are on the window are stored in the pygame.Rect \nobjects that are stored in the RESET_RECT, NEW_RECT, and SOLVE_RECT variables. We can \npass the mouse coordinates from the Event object to the collidepoint() method. This \nmethod will return True if the mouse coordinates are within the Rect object’s area and False \notherwise. \nSliding Tiles with the Mouse \n 85.                 else: \n 86.                     # check if the clicked tile was next to the blank spot \n 87.  \n 88.                     blankx, blanky = getBlankPosition(mainBoard) \n 89.                     if spotx == blankx + 1 and spoty == blanky: \n 90.                         slideTo = LEFT \n 91.                     elif spotx == blankx - 1 and spoty == blanky: \n 92.                         slideTo = RIGHT \n 93.                     elif spotx == blankx and spoty == blanky + 1: \n 94.                         slideTo = UP \n 95.                     elif spotx == blankx and spoty == blanky - 1: \n 96.                         slideTo = DOWN \nIf getSpotClicked() did not return (None, None), then it will have returned a tuple of \ntwo integer values that represent the X and Y coordinate of the spot on the board that was clicked. \nThen the if and elif statements on lines 89 to 96 check if the spot that was clicked is a tile that \nis next to the blank spot (otherwise the tile will have no place to slide). \nOur getBlankPosition() function will take the board data structure and return the X and Y \nboard coordinates of the blank spot, which we store in the variables blankx and blanky. If the \nspot the user clicked on was next to the blank space, we set the slideTo variable with the value \nthat the tile should slide. \nSliding Tiles with the Keyboard \n 98.             elif event.type == KEYUP: \n 99.                 # check if the user pressed a key to slide a tile \n100.                 if event.key in (K_LEFT, K_a) and isValidMove(mainBoard, \nLEFT): \n101.                     slideTo = LEFT \n102.                 elif event.key in (K_RIGHT, K_d) and \nisValidMove(mainBoard, RIGHT): \n103.                     slideTo = RIGHT \n",
      "content_length": 2355,
      "extraction_method": "Direct"
    },
    {
      "page_number": 109,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    91 \n \n104.                 elif event.key in (K_UP, K_w) and isValidMove(mainBoard, \nUP): \n105.                     slideTo = UP \n106.                 elif event.key in (K_DOWN, K_s) and isValidMove(mainBoard, \nDOWN): \n107.                     slideTo = DOWN \nWe can also let the user slide tiles by pressing keyboard keys. The if and elif statements on \nlines 100 to 107 let the user set the slideTo variable by either pressing the arrow keys or the \nWASD keys (explained later). Each if and elif statement also has a call to isValidMove() \nto make sure that the tile can slide in that direction. (We didn’t have to make this call with the \nmouse clicks because the checks for the neighboring blank space did the same thing.) \n“Equal To One Of” Trick with the in Operator \nThe expression event.key in (K_LEFT, K_a) is just a Python trick to make the code \nsimpler. It is a way of saying ―evaluate to True if event.key is equal to one of K_LEFT or \nK_a‖. The following two expressions will evaluate the exact same way: \nevent.key in (K_LEFT, K_a) \n \nevent.key == K_LEFT or event.key == K_a \nYou can really save on some space by using this trick when you have to check if a value is equal \nto one of multiple values. The following two expressions will evaluate the exact same way: \nspam == 'dog' or spam == 'cat' or spam == 'mouse' or spam == 'horse' or spam == \n42 or spam == 'dingo' \n \nspam in ('dog', 'cat', 'mouse', 'horse', 42, 'dingo') \nWASD and Arrow Keys \nThe W, A, S, and D keys (together called the WASD keys, pronounced ―waz-dee‖) are \ncommonly used in computer games to do the same thing as the arrow keys, except the player can \nuse their left hand instead (since the WASD keys are on the left side of the keyboard). W is for \nup, A is for left, S is for down, and D is for right. You can easily remember this because the \nWASD keys have the same layout as the arrow keys: \n",
      "content_length": 1914,
      "extraction_method": "Direct"
    },
    {
      "page_number": 110,
      "chapter": null,
      "content": "92    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nActually Performing the Tile Slide \n109.         if slideTo: \n110.             slideAnimation(mainBoard, slideTo, 'Click tile or press arrow \nkeys to slide.', 8) # show slide on screen \n111.             makeMove(mainBoard, slideTo) \n112.             allMoves.append(slideTo) # record the slide \n113.         pygame.display.update() \n114.         FPSCLOCK.tick(FPS) \nNow that the events have all been handled, we should update the variables of the game state and \ndisplay the new state on the screen. If slideTo has been set (either by the mouse event or \nkeyboard event handling code) then we can call slideAnimation() to perform the sliding \nanimation. The parameters are the board data structure, the direction of the slide, a message to \ndisplay while sliding the tile, and the speed of the sliding. \nAfter it returns, we need to update the actual board data structure (which is done by the \nmakeMove() function) and then add the slide to the allMoves list of all the slides made so \nfar. This is done so that if the player clicks on the ―Reset‖ button, we know how to undo all the \nplayer’s slides. \nIDLE and Terminating Pygame Programs \n117. def terminate(): \n118.     pygame.quit() \n119.     sys.exit() \nThis is a function that we can call that calls both the pygame.quit() and sys.exit() \nfunctions. This is a bit of syntactic sugar, so that instead of remembering to make both of these \ncalls, there is just a single function we can call instead. \nChecking for a Specific Event, and Posting Events to Pygame’s Event \nQueue \n122. def checkForQuit(): \n123.     for event in pygame.event.get(QUIT): # get all the QUIT events \n124.         terminate() # terminate if any QUIT events are present \n",
      "content_length": 1804,
      "extraction_method": "Direct"
    },
    {
      "page_number": 111,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    93 \n \n125.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n126.         if event.key == K_ESCAPE: \n127.             terminate() # terminate if the KEYUP event was for the Esc key \n128.         pygame.event.post(event) # put the other KEYUP event objects back \nThe checkForQuit() function will check for QUIT events (or if the user has pressed the Esc \nkey) and then call the terminate() function. But this is a bit tricky and requires some \nexplanation. \nPygame internally has its own list data structure that it creates and appends Event objects to as \nthey are made. This data structure is called the event queue. When the \npygame.event.get() function is called with no parameters, the entire list is returned. \nHowever, you can pass a constant like QUIT to pygame.event.get() so that it will only \nreturn the QUIT events (if any) that are in the internal event queue. The rest of the events will \nstay in the event queue for the next time pygame.event.get() is called. \nYou should note that Pygame’s event queue only stores up to 127 Event objects. If your program \ndoes not call pygame.event.get() frequently enough and the queue fills up, then any new \nevents that happen won’t be added to the event queue. \nLine 123 pulls out a list of QUIT events from Pygame’s event queue and returns them. If there \nare any QUIT events in the event queue, the program terminates. \nLine 125 pulls out all the KEYUP events from the event queue and checks if any of them are for \nthe Esc key. If one of the events is, then the program terminates. However, there could be KEYUP \nevents for keys other than the Esc key. In this case, we need to put the KEYUP event back into \nPygame’s event queue. We can do this with the pygame.event.post() function, which adds \nthe Event object passed to it to the end of the Pygame event queue. This way, when line 70 calls \npygame.event.get() the non-Esc key KEYUP events will still be there. Otherwise calls to \ncheckForQuit() would ―consume‖ all of the KEYUP events and those events would never be \nhandled. \nThe pygame.event.post() function is also handy if you ever want your program to add \nEvent objects to the Pygame event queue. \nCreating the Board Data Structure \n131. def getStartingBoard(): \n132.     # Return a board data structure with tiles in the solved state. \n133.     # For example, if BOARDWIDTH and BOARDHEIGHT are both 3, this function \n134.     # returns [[1, 4, 7], [2, 5, 8], [3, 6, None]] \n135.     counter = 1 \n",
      "content_length": 2512,
      "extraction_method": "Direct"
    },
    {
      "page_number": 112,
      "chapter": null,
      "content": "94    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n136.     board = [] \n137.     for x in range(BOARDWIDTH): \n138.         column = [] \n139.         for y in range(BOARDHEIGHT): \n140.             column.append(counter) \n141.             counter += BOARDWIDTH \n142.         board.append(column) \n143.         counter -= BOARDWIDTH * (BOARDHEIGHT - 1) + BOARDWIDTH - 1 \n144.  \n145.     board[BOARDWIDTH-1][BOARDHEIGHT-1] = None \n146.     return board \nThe getStartingBoard() data structure will create and return a data structure that \nrepresents a ―solved‖ board, where all the numbered tiles are in order and the blank tile is in the \nlower right corner. This is done with nested for loops, just like the board data structure in the \nMemory Puzzle game was made. \nHowever, notice that the first column isn’t going to be [1, 2, 3] but instead [1, 4, 7]. \nThis is because the numbers on the tiles increase by 1 going across the row, not down the column. \nGoing down the column, the numbers increase by the size of the board’s width (which is stored in \nthe BOARDWIDTH constant). We will use the counter variable to keep track of the number that \nshould go on the next tile. When the numbering of the tiles in the column is finished, then we \nneed to set counter to the number at the start of the next column.  \nNot Tracking the Blank Position \n149. def getBlankPosition(board): \n150.     # Return the x and y of board coordinates of the blank space. \n151.     for x in range(BOARDWIDTH)): \n152.         for y in range(BOARDHEIGHT): \n153.             if board[x][y] == None: \n154.                 return (x, y) \nWhenever our code needs to find the XY coordinates of the blank space, instead of keeping track \nof where the blank space is after each slide, we can just create a function that goes through the \nentire board and finds the blank space coordinates. The None value is used in the board data \nstructure to represent the blank space. The code in getBlankPosition() simply uses nested \nfor loops to find which space on the board is the blank space. \nMaking a Move by Updating the Board Data Structure \n157. def makeMove(board, move): \n158.     # This function does not check if the move is valid. \n",
      "content_length": 2253,
      "extraction_method": "Direct"
    },
    {
      "page_number": 113,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    95 \n \n159.     blankx, blanky = getBlankPosition(board) \n160.  \n161.     if move == UP: \n162.         board[blankx][blanky], board[blankx][blanky + 1] = \nboard[blankx][blanky + 1], board[blankx][blanky] \n163.     elif move == DOWN: \n164.         board[blankx][blanky], board[blankx][blanky - 1] = \nboard[blankx][blanky - 1], board[blankx][blanky] \n165.     elif move == LEFT: \n166.         board[blankx][blanky], board[blankx + 1][blanky] = board[blankx + \n1][blanky], board[blankx][blanky] \n167.     elif move == RIGHT: \n168.         board[blankx][blanky], board[blankx - 1][blanky] = board[blankx - \n1][blanky], board[blankx][blanky] \nThe data structure in the board parameter is a 2D list that represents where all the tiles are. \nWhenever the player makes a move, the program needs to update this data structure. What \nhappens is that the value for the tile is swapped with the value for the blank space. \nThe makeMove() function doesn’t have to return any values, because the board parameter has \na list reference passed for its argument. This means that any changes we make to board in this \nfunction will be made to the list value that was passed to makeMove(). (You can review the \nconcept of references at http://invpy.com/references.) \nWhen NOT to Use an Assertion \n171. def isValidMove(board, move): \n172.     blankx, blanky = getBlankPosition(board) \n173.     return (move == UP and blanky != len(board[0]) - 1) or \\ \n174.            (move == DOWN and blanky != 0) or \\ \n175.            (move == LEFT and blankx != len(board) - 1) or \\ \n176.            (move == RIGHT and blankx != 0) \nThe isValidMove() function is passed a board data structure and a move the player would \nwant to make. The return value is True if this move is possible and False if it is not. For \nexample, you cannot slide a tile to the left one hundred times in a row, because eventually the \nblank space will be at the edge and there are no more tiles to slide to the left. \nWhether a move is valid or not depends on where the blank space is. This function makes a call to \ngetBlankPosition() to find the X and Y coordinates of the blank spot. Lines 173 to 176 \nare a return statement with a single expression. The \\ slashes at the end of the first three lines \ntells the Python interpreter that that is not the end of the line of code (even though it is at the end \n",
      "content_length": 2380,
      "extraction_method": "Direct"
    },
    {
      "page_number": 114,
      "chapter": null,
      "content": "96    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nof the line). This will let us split up a ―line of code‖ across multiple lines to look pretty, rather \nthan just have one very long unreadable line. \nBecause the parts of this expression in parentheses are joined by or operators, only one of them \nneeds to be True for the entire expression to be True. Each of these parts checks what the \nintended move is and then sees if the coordinate of the blank space allows that move. \nGetting a Not-So-Random Move \n179. def getRandomMove(board, lastMove=None): \n180.     # start with a full list of all four moves \n181.     validMoves = [UP, DOWN, LEFT, RIGHT] \n182.  \n183.     # remove moves from the list as they are disqualified \n184.     if lastMove == UP or not isValidMove(board, DOWN): \n185.         validMoves.remove(DOWN) \n186.     if lastMove == DOWN or not isValidMove(board, UP): \n187.         validMoves.remove(UP) \n188.     if lastMove == LEFT or not isValidMove(board, RIGHT): \n189.         validMoves.remove(RIGHT) \n190.     if lastMove == RIGHT or not isValidMove(board, LEFT): \n191.         validMoves.remove(LEFT) \n192.  \n193.     # return a random move from the list of remaining moves \n194.     return random.choice(validMoves) \nAt the beginning of the game, we start with the board data structure in the solved, ordered state \nand create the puzzle by randomly sliding around tiles. To decide which of the four directions we \nshould slide, we’ll call our getRandomMove() function. Normally we could just use the \nrandom.choice() function and pass it a tuple (UP, DOWN, LEFT, RIGHT) to have \nPython simply randomly choose a direction value for us. But the Sliding Puzzle game has a small \nrestriction that prevents us from choosing a purely random number. \nIf you had a slide puzzle and slid a tile to left, and then slid a tile to the right, you would end up \nwith the exact same board you had at the start. It’s pointless to make a slide followed by the \nopposite slide. Also, if the blank space is in the lower right corner than it is impossible to slide a \ntile up or to the left. \nThe code in getRandomMove() will take these factors into account. To prevent the function \nfrom selecting the last move that was made, the caller of the function can pass a directional value \nfor the lastMove parameter. Line 181 starts with a list of all four directional values stored in \nthe validMoves variable. The lastMove value (if not set to None) is removed from \n",
      "content_length": 2523,
      "extraction_method": "Direct"
    },
    {
      "page_number": 115,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    97 \n \nvalidMoves. Depending on if the blank space is at the edge of the board, lines 184 to 191 will \nremove other directional values from the lastMove list. \nOf the values that are left in lastMove, one of them is randomly selected with a call to \nrandom.choice() and returned. \nConverting Tile Coordinates to Pixel Coordinates \n197. def getLeftTopOfTile(tileX, tileY): \n198.     left = XMARGIN + (tileX * TILESIZE) + (tileX - 1) \n199.     top = YMARGIN + (tileY * TILESIZE) + (tileY - 1) \n200.     return (left, top) \nThe getLeftTopOfTile() function converts board coordinates to pixel coordinates. For the \nboard XY coordinates that are passed in, the function calculates and returns the pixel XY \ncoordinates of the pixel at the top left of that board space. \nConverting from Pixel Coordinates to Board Coordinates \n203. def getSpotClicked(board, x, y): \n204.     # from the x & y pixel coordinates, get the x & y board coordinates \n205.     for tileX in range(len(board)): \n206.         for tileY in range(len(board[0])): \n207.             left, top = getLeftTopOfTile(tileX, tileY) \n208.             tileRect = pygame.Rect(left, top, TILESIZE, TILESIZE) \n209.             if tileRect.collidepoint(x, y): \n210.                 return (tileX, tileY) \n211.     return (None, None) \nThe getSpotClicked() function does the opposite of getLeftTopOfTile() and \nconverts from pixel coordinates to board coordinates. The nested loops on lines 205 and 206 go \nthrough every possible XY board coordinate, and if the pixel coordinates that were passed in are \nwithin that space on the board, it returns those board coordinates. Since all of the tiles have a \nwidth and height that is set in the TILESIZE constant, we can create a Rect object that \nrepresents the space on the board by getting the pixel coordinates of the top left corner of the \nboard space, and then use the collidepoint() Rect method to see if the pixel coordinates are \ninside that Rect object’s area. \nIf the pixel coordinates that were passed in were not over any board space, then the value \n(None, None) is returned. \nDrawing a Tile \n214. def drawTile(tilex, tiley, number, adjx=0, adjy=0): \n",
      "content_length": 2188,
      "extraction_method": "Direct"
    },
    {
      "page_number": 116,
      "chapter": null,
      "content": "98    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n215.     # draw a tile at board coordinates tilex and tiley, optionally a few \n216.     # pixels over (determined by adjx and adjy) \n217.     left, top = getLeftTopOfTile(tilex, tiley) \n218.     pygame.draw.rect(DISPLAYSURF, TILECOLOR, (left + adjx, top + adjy, \nTILESIZE, TILESIZE)) \n219.     textSurf = BASICFONT.render(str(number), True, TEXTCOLOR) \n220.     textRect = textSurf.get_rect() \n221.     textRect.center = left + int(TILESIZE / 2) + adjx, top + int(TILESIZE \n/ 2) + adjy \n222.     DISPLAYSURF.blit(textSurf, textRect) \nThe drawTile() function will draw a single numbered tile on the board. The tilex and \ntiley parameters are the board coordinates of the tile. The number parameter is a string of the \ntile’s number (like '3' or '12'). The adjx and adjy keyword parameters are for making \nminor adjustments to the position of the tile. For example, passing 5 for adjx would make the \ntile appear 5 pixels to the right of the tilex and tiley space on the board. Passing -10 for \nadjx would make the tile appear 10 pixels to the left of the space.  \nThese adjustment values will be handy when we need to draw the tile in the middle of sliding. If \nno values are passed for these arguments when drawTile() is called, then by default they are \nset to 0. This means they will be exactly on the board space given by tilex and tiley.  \nThe Pygame drawing functions only use pixel coordinates, so first line 217 converts the board \ncoordinates in tilex and tiley to pixel coordinates, which we will store in variables left \nand top (since getLeftTopOfTile() returns the top left corner’s coordinates). We draw the \nbackground square of the tile with a call to pygame.draw.rect() while adding the adjx \nand adjy values to left and top in case the code needs to adjust the position of the tile. \nLines 219 to 222 then create the Surface object that has the number text drawn on it. A Rect \nobject for the Surface object is positioned, and then used to blit the Surface object to the display \nSurface. The drawTile() function doesn’t call pygame.display.update() function, \nsince the caller of drawTile() probably will want to draw more tiles for the rest of the board \nbefore making them appear on the screen. \nThe Making Text Appear on the Screen \n225. def makeText(text, color, bgcolor, top, left): \n226.     # create the Surface and Rect objects for some text. \n227.     textSurf = BASICFONT.render(text, True, color, bgcolor) \n228.     textRect = textSurf.get_rect() \n229.     textRect.topleft = (top, left) \n230.     return (textSurf, textRect) \n",
      "content_length": 2658,
      "extraction_method": "Direct"
    },
    {
      "page_number": 117,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    99 \n \nThe makeText() function handles creating the Surface and Rect objects for positioning text on \nthe screen. Instead of doing all these calls each time we want to make text on the screen, we can \njust call makeText() instead. This saves us on the amount of typing we have to do for our \nprogram. (Though drawTile() makes the calls to render() and get_rect() itself \nbecause it positions the text Surface object by the center point rather than the topleft point and \nuses a transparent background color.) \nDrawing the Board \n233. def drawBoard(board, message): \n234.     DISPLAYSURF.fill(BGCOLOR) \n235.     if message: \n236.         textSurf, textRect = makeText(message, MESSAGECOLOR, BGCOLOR, 5, \n5) \n237.         DISPLAYSURF.blit(textSurf, textRect) \n238.  \n239.     for tilex in range(len(board)): \n240.         for tiley in range(len(board[0])): \n241.             if board[tilex][tiley]: \n242.                 drawTile(tilex, tiley, board[tilex][tiley]) \nThis function handles drawing the entire board and all of its tiles to the DISPLAYSURF display \nSurface object. The fill() method on line 234 completely paints over anything that used to be \ndrawn on the display Surface object before so that we start from scratch. \nLine 235 to 237 handles drawing the message at the top of the window. We use this for the \n―Generating new puzzle…‖ and other text we want to display at the top of the window. \nRemember that if statement conditions consider the blank string to be a False value, so if \nmessage is set to '' then the condition is False and lines 236 and 237 are skipped. \nNext, nested for loops are used to draw each tile to the display Surface object by calling the \ndrawTile() function. \nDrawing the Border of the Board \n244.     left, top = getLeftTopOfTile(0, 0) \n245.     width = BOARDWIDTH * TILESIZE \n246.     height = BOARDHEIGHT * TILESIZE \n247.     pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (left - 5, top - 5, width + \n11, height + 11), 4) \nLines 244 to 247 draw a border around the tiles. The top left corner of the boarder will be 5 pixels \nto the left and 5 pixels above the top left corner of the tile at board coordinates (0, 0). The width \nand height of the border are calculated from the number of tiles wide and high the board is (stored \n",
      "content_length": 2298,
      "extraction_method": "Direct"
    },
    {
      "page_number": 118,
      "chapter": null,
      "content": "100    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nin the BOARDWIDTH and BOARDHEIGHT constants) multiplied by the size of the tiles (stored in \nthe TILESIZE constant). \nThe rectangle we draw on line 247 will have a thickness of 4 pixels, so we will move the boarder \n5 pixels to the left and above where the top and left variables point so the thickness of the line \nwon’t overlap the tiles. We will also add 11 to the width and length (5 of those 11 pixels are to \ncompensate for moving the rectangle to the left and up). \nDrawing the Buttons \n249.     DISPLAYSURF.blit(RESET_SURF, RESET_RECT) \n250.     DISPLAYSURF.blit(NEW_SURF, NEW_RECT) \n251.     DISPLAYSURF.blit(SOLVE_SURF, SOLVE_RECT) \nFinally, we draw the buttons off to the slide of the screen. The text and position of these buttons \nnever changes, which is why they were stored in constant variables at the beginning of the \nmain() function. \nAnimating the Tile Slides \n254. def slideAnimation(board, direction, message, animationSpeed): \n255.     # Note: This function does not check if the move is valid. \n256.  \n257.     blankx, blanky = getBlankPosition(board) \n258.     if direction == UP: \n259.         movex = blankx \n260.         movey = blanky + 1 \n261.     elif direction == DOWN: \n262.         movex = blankx \n263.         movey = blanky - 1 \n264.     elif direction == LEFT: \n265.         movex = blankx + 1 \n266.         movey = blanky \n267.     elif direction == RIGHT: \n268.         movex = blankx - 1 \n269.         movey = blanky \nThe first thing our tile sliding animation code needs to calculate is where the blank space is and \nwhere the moving tile is. The comment on line 255 reminds us that the code that calls \nslideAnimation() should make sure that the slide it passes for the direction parameter is a \nvalid move to make. \n",
      "content_length": 1862,
      "extraction_method": "Direct"
    },
    {
      "page_number": 119,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    101 \n \nThe blank space’s coordinates come from a call to getBlankPosition(). From these \ncoordinates and the direction of the slide, we can figure out the XY board coordinates of the tile \nthat will slide. These coordinates will be stored in the movex and movey variables. \nThe copy() Surface Method \n271.     # prepare the base surface \n272.     drawBoard(board, message) \n273.     baseSurf = DISPLAYSURF.copy() \n274.     # draw a blank space over the moving tile on the baseSurf Surface. \n275.     moveLeft, moveTop = getLeftTopOfTile(movex, movey) \n276.     pygame.draw.rect(baseSurf, BGCOLOR, (moveLeft, moveTop, TILESIZE, \nTILESIZE)) \nThe copy() method of Surface objects will return a new Surface object that has the same image \ndrawn to it. But they are two separate Surface objects. After calling the copy() method, if we \ndraw on one Surface object using blit() or the Pygame drawing functions, it will not change \nthe image on the other Surface object. We store this copy in the baseSurf variable on line 273. \nNext, we paint another blank space over the tile that will slide. This is because when we draw \neach frame of the sliding animation, we will draw the sliding tile over different parts of the \nbaseSurf Surface object. If we didn’t blank out the moving tile on the baseSurf Surface, \nthen it would still be there as we draw the sliding tile. In that case, here is what the baseSurf \nSurface would look like: \n \nAnd then what it would look like when we draw the ―9‖ tile sliding upwards on top of it: \n",
      "content_length": 1548,
      "extraction_method": "Direct"
    },
    {
      "page_number": 120,
      "chapter": null,
      "content": "102    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nYou can see this for yourself by commenting out line 276 and running the program. \n278.     for i in range(0, TILESIZE, animationSpeed): \n279.         # animate the tile sliding over \n280.         checkForQuit() \n281.         DISPLAYSURF.blit(baseSurf, (0, 0)) \n282.         if direction == UP: \n283.             drawTile(movex, movey, board[movex][movey], 0, -i) \n284.         if direction == DOWN: \n285.             drawTile(movex, movey, board[movex][movey], 0, i) \n286.         if direction == LEFT: \n287.             drawTile(movex, movey, board[movex][movey], -i, 0) \n288.         if direction == RIGHT: \n289.             drawTile(movex, movey, board[movex][movey], i, 0) \n290.  \n291.         pygame.display.update() \n292.         FPSCLOCK.tick(FPS) \nIn order to draw the frames of the sliding animation, we must draw the baseSurf surface on the \ndisplay Surface, then on each frame of the animation draw the sliding tile closer and closer to its \nfinal position where the original blank space was. The space between two adjacent tiles is the \nsame size as a single tile, which we have stored in TILESIZE. The code uses a for loop to go \nfrom 0 to TILESIZE.  \nNormally this would mean that we would draw the tile 0 pixels over, then on the next frame draw \nthe tile 1 pixel over, then 2 pixels, then 3, and so on. Each of these frames would take 1/30th of a \nsecond. If you have TILESIZE set to 80 (as the program in this book does on line 12) then \nsliding a tile would take over two and a half seconds, which is actually kind of slow. \n",
      "content_length": 1649,
      "extraction_method": "Direct"
    },
    {
      "page_number": 121,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    103 \n \nSo instead we will have the for loop iterate from 0 to TILESIZE by several pixels each frame. \nThe number of pixels it jumps over is stored in animationSpeed, which is passed in when \nslideAnimation() is called. For example, if animationSpeed was set to 8 and the \nconstant TILESIZE was set to 80, then the for loop and range(0, TILESIZE, \nanimationSpeed) would set the i variable to the values 0, 8, 16, 24, 32, 40, 48, 56, 64, \n72. (It does not include 80 because the range() function goes up to, but not including, the \nsecond argument.) This means the entire sliding animation would be done in 10 frames, which \nwould mean it is done in 10/30th of a second (a third of a second) since the game runs at 30 FPS. \nLines 282 to 289 makes sure that we draw the tile sliding in the correct direction (based on what \nvalue the direction variable has). After the animation is done, then the function returns. \nNotice that while the animation is happening, any events being created by the user are not being \nhandled. Those events will be handled the next time execution reaches line 70 in the main() \nfunction or the code in the checkForQuit() function. \nCreating a New Puzzle \n295. def generateNewPuzzle(numSlides): \n296.     # From a starting configuration, make numSlides number of moves (and \n297.     # animate these moves). \n298.     sequence = [] \n299.     board = getStartingBoard() \n300.     drawBoard(board, '') \n301.     pygame.display.update() \n302.     pygame.time.wait(500) # pause 500 milliseconds for effect \nThe generateNewPuzzle() function will be called at the start of each new game. It will \ncreate a new board data structure by calling getStartingBoard() and then randomly \nscramble it. The first few lines of generateNewPuzzle() get the board and then draw it to \nthe screen (freezing for half a second to let the player see the fresh board for a moment). \n303.     lastMove = None \n304.     for i in range(numSlides): \n305.         move = getRandomMove(board, lastMove) \n306.         slideAnimation(board, move, 'Generating new puzzle...', \nint(TILESIZE / 3)) \n307.         makeMove(board, move) \n308.         sequence.append(move) \n309.         lastMove = move \n310.     return (board, sequence) \nThe numSlides parameter will show tell the function how many of these random moves to \nmake. The code for doing a random move is the getRandomMove() call on line 305 to get the \n",
      "content_length": 2431,
      "extraction_method": "Direct"
    },
    {
      "page_number": 122,
      "chapter": null,
      "content": "104    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nmove itself, then call slideAnimation() to perform the animation on the screen. Because \ndoing the slide animation does not actually update the board data structure, we update the board \nby calling makeMove() on line 307. \nWe need to keep track of each of the random moves that was made so that the player can click the \n―Solve‖ button later and have the program undo all these random moves. (The ―Being Smart By \nUsing Stupid Code‖ section talks about why and how we do this.) So the move is appended to the \nlist of moves in sequence on line 308. \nThen we store the random move in a variable called lastMove which will be passed to \ngetRandomMove() on the next iteration. This prevents the next random move from undoing \nthe random move we just performed. \nAll of this needs to happen numSlides number of times, so we put lines 305 to 309 inside a \nfor loop. When the board is done being scrambled, then we return the board data structure and \nalso the list of the random moves made on it. \nAnimating the Board Reset \n313. def resetAnimation(board, allMoves): \n314.     # make all of the moves in allMoves in reverse. \n315.     revAllMoves = allMoves[:] # gets a copy of the list \n316.     revAllMoves.reverse() \n317.  \n318.     for move in revAllMoves: \n319.         if move == UP: \n320.             oppositeMove = DOWN \n321.         elif move == DOWN: \n322.             oppositeMove = UP \n323.         elif move == RIGHT: \n324.             oppositeMove = LEFT \n325.         elif move == LEFT: \n326.             oppositeMove = RIGHT \n327.         slideAnimation(board, oppositeMove, '', int(TILESIZE / 2)) \n328.         makeMove(board, oppositeMove) \nWhen the player clicks on ―Reset‖ or ―Solve‖, the Slide Puzzle game program needs to undo all \nof the moves that were made to the board. The list of directional values for the slides will be \npassed as the argument for the allMoves parameter. \nLine 315 uses list slicing to create a duplicate of the allMoves list. Remember that if you don’t \nspecify a number before the :, then Python assumes the slice should start from the very \nbeginning of the list. And if you don’t specify a number after the :, then Python assumes the slice \nshould keep going to the very end of the list. So allMoves[:] creates a list slice of the entire \n",
      "content_length": 2388,
      "extraction_method": "Direct"
    },
    {
      "page_number": 123,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    105 \n \nallMoves list. This makes a copy of the actual list to store in revAllMoves, rather than just a \ncopy of the list reference. (See http://invpy.com/references for details.) \nTo undo all the moves in allMoves, we need to perform the opposite move of the moves in \nallMoves, and in reverse order. There is a list method called reverse() which will reverse \nthe order of the items in a list. We call this on the revAllMoves list on line 316. \nThe for loop on line 318 iterates over the list of directional values. Remember, we want the \nopposite move, so the if and elif statements from line 319 to 326 set the correct directional \nvalue in the oppositeMove variable. Then we call slideAnimation() to perform the \nanimation, and makeMove() to update the board data structure. \n331. if __name__ == '__main__': \n332.     main() \nJust like in the Memory Puzzle game, after all the def statements have been executed to create \nall the functions, we call the main() function to begin the meat of the program. \nThat’s all there is to the Slide Puzzle program! But let’s talk about some general programming \nconcepts that came up in this game. \nTime vs. Memory Tradeoffs \nOf course, there are a few different ways to write the Slide Puzzle game so that it looks and acts \nthe exact same way even though the code is different. There are many different ways the a \nprogram that does a task could be written. The most common differences are making tradeoffs \nbetween execution time and memory usage. \nUsually, the faster a program can run, the better it is. This is especially true with programs that \nneed to do a lot of calculations, whether they are scientific weather simulators or games with a \nlarge amount of detailed 3D graphics to draw. It’s also good to use the least amount of memory \npossible. The more variables and the larger the lists your program uses, the more memory it takes \nup. (You can find out how to measure your program’s memory usage and execution time at \nhttp://invpy.com/profiling.) \nRight now, the programs in this book aren’t big and complicated enough where you have to \nworry about conserving memory or optimizing the execution time. But it can be something to \nconsider as you become a more skilled programmer. \nFor example, consider the getBlankPosition() function. This function takes time to run, \nsince it goes through all the possible board coordinates to find where the blank space is. Instead, \nwe could just have a blankspacex and blankspacey variable which would have these XY \n",
      "content_length": 2542,
      "extraction_method": "Direct"
    },
    {
      "page_number": 124,
      "chapter": null,
      "content": "106    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \ncoordinates so we would not have to look through the entire board each time we want to know \nwhere it was. (We would also need code that updates the blankspacex and blankspacey \nvariables whenever a move is done. This code could go in makeMove().) Using these variables \nwould take up more memory, but they would save you on execution time so your program would \nrun faster. \nAnother example is that we keep a board data structure in the solved state in the SOLVEDBOARD \nvariable, so that we can compare the current board to SOLVEDBOARD to see if the player has \nsolved the puzzle. Each time we wanted to do this check, we could just call the \ngetStartingBoard() function and compare the returned value to the current board. Then \nwe would not need the SOLVEDBOARD variable. This would save us a little bit of memory, but \nthen our program would take longer to run because it is re-creating the solved-state board data \nstructure each time we do this check. \nThere is one thing you must remember though. Writing code that is readable is a very important \nskill. Code that is ―readable‖ is code that is easy to understand, especially by programmers who \ndid not write the code. If another programmer can look at your program’s source code and figure \nout what it does without much trouble, then that program is very readable. Readability is \nimportant because when you want to fix bugs or add new features to your program (and bugs and \nideas for new features always come up), then having a readable program makes those tasks much \neasier. \nNobody Cares About a Few Bytes \nAlso, there is one thing that might seem kind of silly to say in this book because it seem obvious, \nbut many people wonder about it. You should know that using short variable names like x or num \ninstead of longer, more descriptive variable names like blankx or numSlides does not save \nyou any memory when your program actually runs. Using these longer variable names is better \nbecause they’ll make your program more readable. \nYou might also come up with some clever tricks that do save a few bytes of memory here and \nthere. One trick is that when you no longer need a variable, you can reuse that variable name for a \ndifferent purpose instead of just using two differently named variables.  \nTry to avoid the temptation to do this. Usually, these tricks reduce code readability and make it \nharder to debug your programs. Modern computers have billions of bytes of memory, and saving \na few bytes here and there really isn’t worth making the code more confusing for human \nprogrammers. \n",
      "content_length": 2669,
      "extraction_method": "Direct"
    },
    {
      "page_number": 125,
      "chapter": null,
      "content": "Chapter 4 – Slide Puzzle    107 \n \nNobody Cares About a Few Million Nanoseconds \nSimilarly, there are times when you can rearrange your code in some way to make it slightly \nfaster by a few nanoseconds. These tricks also usually make the code harder to read. When you \nconsider that several billion nanoseconds have passed in the time it takes you to read this \nsentence, saving a few nanoseconds of execution time in your program won’t be noticed by the \nplayer. \nSummary \nThis chapter hasn’t introduced any new Pygame programming concepts that the Memory Puzzle \ngame didn’t use, aside from using the copy() method of Surface objects. Just knowing a few \ndifferent concepts will let you create completely different games. \nFor practice, you can download buggy versions of the Sliding Puzzle program from \nhttp://invpy.com/buggy/slidepuzzle.  \n \n",
      "content_length": 847,
      "extraction_method": "Direct"
    },
    {
      "page_number": 126,
      "chapter": null,
      "content": "108    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nCHAPTER 5 – SIMULATE \n \nHow to Play Simulate \nSimulate is a clone of the game Simon. There are four colored buttons on the screen. The buttons \nlight up in a certain random pattern, and then the player must repeat this pattern by pressing the \nbuttons in the correct order. Each time the player successfully simulates the pattern, the pattern \ngets longer. The player tries to match the pattern for as long as possible. \nSource Code to Simulate \nThis source code can be downloaded from http://invpy.com/simulate.py. If you get any error \nmessages, look at the line number that is mentioned in the error message and check your code for \nany typos. You can also copy and paste your code into the web form at \nhttp://invpy.com/diff/simulate to see if the differences between your code and the code in the \nbook. \nYou can download the four sound files that this program uses from: \n \nhttp://invpy.com/beep1.ogg \n \nhttp://invpy.com/beep2.ogg \n \nhttp://invpy.com/beep3.ogg \n \nhttp://invpy.com/beep4.ogg \n  1. # Simulate (a Simon clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n",
      "content_length": 1228,
      "extraction_method": "Direct"
    },
    {
      "page_number": 127,
      "chapter": null,
      "content": "Chapter 5 – Simulate    109 \n \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, sys, time, pygame \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 \n 10. WINDOWWIDTH = 640 \n 11. WINDOWHEIGHT = 480 \n 12. FLASHSPEED = 500 # in milliseconds \n 13. FLASHDELAY = 200 # in milliseconds \n 14. BUTTONSIZE = 200 \n 15. BUTTONGAPSIZE = 20 \n 16. TIMEOUT = 4 # seconds before game over if no button is pushed. \n 17.  \n 18. #                R    G    B \n 19. WHITE        = (255, 255, 255) \n 20. BLACK        = (  0,   0,   0) \n 21. BRIGHTRED    = (255,   0,   0) \n 22. RED          = (155,   0,   0) \n 23. BRIGHTGREEN  = (  0, 255,   0) \n 24. GREEN        = (  0, 155,   0) \n 25. BRIGHTBLUE   = (  0,   0, 255) \n 26. BLUE         = (  0,   0, 155) \n 27. BRIGHTYELLOW = (255, 255,   0) \n 28. YELLOW       = (155, 155,   0) \n 29. DARKGRAY     = ( 40,  40,  40) \n 30. bgColor = BLACK \n 31.  \n 32. XMARGIN = int((WINDOWWIDTH - (2 * BUTTONSIZE) - BUTTONGAPSIZE) / 2) \n 33. YMARGIN = int((WINDOWHEIGHT - (2 * BUTTONSIZE) - BUTTONGAPSIZE) / 2) \n 34.  \n 35. # Rect objects for each of the four buttons \n 36. YELLOWRECT = pygame.Rect(XMARGIN, YMARGIN, BUTTONSIZE, BUTTONSIZE) \n 37. BLUERECT   = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN, \nBUTTONSIZE, BUTTONSIZE) \n 38. REDRECT    = pygame.Rect(XMARGIN, YMARGIN + BUTTONSIZE + BUTTONGAPSIZE, \nBUTTONSIZE, BUTTONSIZE) \n 39. GREENRECT  = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN + \nBUTTONSIZE + BUTTONGAPSIZE, BUTTONSIZE, BUTTONSIZE) \n 40.  \n 41. def main(): \n 42.     global FPSCLOCK, DISPLAYSURF, BASICFONT, BEEP1, BEEP2, BEEP3, BEEP4 \n 43.  \n 44.     pygame.init() \n 45.     FPSCLOCK = pygame.time.Clock() \n 46.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n",
      "content_length": 1769,
      "extraction_method": "Direct"
    },
    {
      "page_number": 128,
      "chapter": null,
      "content": "110    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 47.     pygame.display.set_caption('Simulate') \n 48.  \n 49.     BASICFONT = pygame.font.Font('freesansbold.ttf', 16) \n 50. \n 51.     infoSurf = BASICFONT.render('Match the pattern by clicking on the \nbutton or using the Q, W, A, S keys.', 1, DARKGRAY) \n 52.     infoRect = infoSurf.get_rect() \n 53.     infoRect.topleft = (10, WINDOWHEIGHT - 25) \n 54.     # load the sound files \n 55.     BEEP1 = pygame.mixer.Sound('beep1.ogg') \n 56.     BEEP2 = pygame.mixer.Sound('beep2.ogg') \n 57.     BEEP3 = pygame.mixer.Sound('beep3.ogg') \n 58.     BEEP4 = pygame.mixer.Sound('beep4.ogg') \n 59.  \n 60.     # Initialize some variables for a new game \n 61.     pattern = [] # stores the pattern of colors \n 62.     currentStep = 0 # the color the player must push next \n 63.     lastClickTime = 0 # timestamp of the player's last button push \n 64.     score = 0 \n 65.     # when False, the pattern is playing. when True, waiting for the \nplayer to click a colored button: \n 66.     waitingForInput = False \n 67.  \n 68.     while True: # main game loop \n 69.         clickedButton = None # button that was clicked (set to YELLOW, \nRED, GREEN, or BLUE) \n 70.         DISPLAYSURF.fill(bgColor) \n 71.         drawButtons() \n 72.  \n 73.         scoreSurf = BASICFONT.render('Score: ' + str(score), 1, WHITE) \n 74.         scoreRect = scoreSurf.get_rect() \n 75.         scoreRect.topleft = (WINDOWWIDTH - 100, 10) \n 76.         DISPLAYSURF.blit(scoreSurf, scoreRect) \n 77.  \n 78.         DISPLAYSURF.blit(infoSurf, infoRect) \n 79.  \n 80.         checkForQuit() \n 81.         for event in pygame.event.get(): # event handling loop \n 82.             if event.type == MOUSEBUTTONUP: \n 83.                 mousex, mousey = event.pos \n 84.                 clickedButton = getButtonClicked(mousex, mousey) \n 85.             elif event.type == KEYDOWN: \n 86.                 if event.key == K_q: \n 87.                     clickedButton = YELLOW \n 88.                 elif event.key == K_w: \n 89.                     clickedButton = BLUE \n",
      "content_length": 2117,
      "extraction_method": "Direct"
    },
    {
      "page_number": 129,
      "chapter": null,
      "content": "Chapter 5 – Simulate    111 \n \n 90.                 elif event.key == K_a: \n 91.                     clickedButton = RED \n 92.                 elif event.key == K_s: \n 93.                     clickedButton = GREEN \n 94. \n 95. \n 96. \n 97.         if not waitingForInput: \n 98.             # play the pattern \n 99.             pygame.display.update() \n100.             pygame.time.wait(1000) \n101.             pattern.append(random.choice((YELLOW, BLUE, RED, GREEN))) \n102.             for button in pattern: \n103.                 flashButtonAnimation(button) \n104.                 pygame.time.wait(FLASHDELAY) \n105.             waitingForInput = True \n106.         else: \n107.             # wait for the player to enter buttons \n108.             if clickedButton and clickedButton == pattern[currentStep]: \n109.                 # pushed the correct button \n110.                 flashButtonAnimation(clickedButton) \n111.                 currentStep += 1 \n112.                 lastClickTime = time.time() \n113. \n114.                 if currentStep == len(pattern): \n115.                     # pushed the last button in the pattern \n116.                     changeBackgroundAnimation() \n117.                     score += 1 \n118.                     waitingForInput = False \n119.                     currentStep = 0 # reset back to first step \n120. \n121.             elif (clickedButton and clickedButton != pattern[currentStep]) \nor (currentStep != 0 and time.time() - TIMEOUT > lastClickTime): \n122.                 # pushed the incorrect button, or has timed out \n123.                 gameOverAnimation() \n124.                 # reset the variables for a new game: \n125.                 pattern = [] \n126.                 currentStep = 0 \n127.                 waitingForInput = False \n128.                 score = 0 \n129.                 pygame.time.wait(1000) \n130.                 changeBackgroundAnimation() \n131. \n132.         pygame.display.update() \n133.         FPSCLOCK.tick(FPS) \n134. \n",
      "content_length": 1993,
      "extraction_method": "Direct"
    },
    {
      "page_number": 130,
      "chapter": null,
      "content": "112    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n135. \n136. def terminate(): \n137.     pygame.quit() \n138.     sys.exit() \n139.  \n140.  \n141. def checkForQuit(): \n142.     for event in pygame.event.get(QUIT): # get all the QUIT events \n143.         terminate() # terminate if any QUIT events are present \n144.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n145.         if event.key == K_ESCAPE: \n146.             terminate() # terminate if the KEYUP event was for the Esc key \n147.         pygame.event.post(event) # put the other KEYUP event objects back \n148. \n149. \n150. def flashButtonAnimation(color, animationSpeed=50): \n151.     if color == YELLOW: \n152.         sound = BEEP1 \n153.         flashColor = BRIGHTYELLOW \n154.         rectangle = YELLOWRECT \n155.     elif color == BLUE: \n156.         sound = BEEP2 \n157.         flashColor = BRIGHTBLUE \n158.         rectangle = BLUERECT \n159.     elif color == RED: \n160.         sound = BEEP3 \n161.         flashColor = BRIGHTRED \n162.         rectangle = REDRECT \n163.     elif color == GREEN: \n164.         sound = BEEP4 \n165.         flashColor = BRIGHTGREEN \n166.         rectangle = GREENRECT \n167. \n168.     origSurf = DISPLAYSURF.copy() \n169.     flashSurf = pygame.Surface((BUTTONSIZE, BUTTONSIZE)) \n170.     flashSurf = flashSurf.convert_alpha() \n171.     r, g, b = flashColor \n172.     sound.play() \n173.     for start, end, step in ((0, 255, 1), (255, 0, -1)): # animation loop \n174.         for alpha in range(start, end, animationSpeed * step): \n175.             checkForQuit() \n176.             DISPLAYSURF.blit(origSurf, (0, 0)) \n177.             flashSurf.fill((r, g, b, alpha)) \n178.             DISPLAYSURF.blit(flashSurf, rectangle.topleft) \n179.             pygame.display.update() \n180.             FPSCLOCK.tick(FPS) \n",
      "content_length": 1874,
      "extraction_method": "Direct"
    },
    {
      "page_number": 131,
      "chapter": null,
      "content": "Chapter 5 – Simulate    113 \n \n181.     DISPLAYSURF.blit(origSurf, (0, 0)) \n182.  \n183.  \n184. def drawButtons(): \n185.     pygame.draw.rect(DISPLAYSURF, YELLOW, YELLOWRECT) \n186.     pygame.draw.rect(DISPLAYSURF, BLUE,   BLUERECT) \n187.     pygame.draw.rect(DISPLAYSURF, RED,    REDRECT) \n188.     pygame.draw.rect(DISPLAYSURF, GREEN,  GREENRECT) \n189. \n190. \n191. def changeBackgroundAnimation(animationSpeed=40): \n192.     global bgColor \n193.     newBgColor = (random.randint(0, 255), random.randint(0, 255), \nrandom.randint(0, 255)) \n194.  \n195.     newBgSurf = pygame.Surface((WINDOWWIDTH, WINDOWHEIGHT)) \n196.     newBgSurf = newBgSurf.convert_alpha() \n197.     r, g, b = newBgColor \n198.     for alpha in range(0, 255, animationSpeed): # animation loop \n199.         checkForQuit() \n200.         DISPLAYSURF.fill(bgColor) \n201.  \n202.         newBgSurf.fill((r, g, b, alpha)) \n203.         DISPLAYSURF.blit(newBgSurf, (0, 0)) \n204.  \n205.         drawButtons() # redraw the buttons on top of the tint \n206.  \n207.         pygame.display.update() \n208.         FPSCLOCK.tick(FPS) \n209.     bgColor = newBgColor \n210. \n211. \n212. def gameOverAnimation(color=WHITE, animationSpeed=50): \n213.     # play all beeps at once, then flash the background \n214.     origSurf = DISPLAYSURF.copy() \n215.     flashSurf = pygame.Surface(DISPLAYSURF.get_size()) \n216.     flashSurf = flashSurf.convert_alpha() \n217.     BEEP1.play() # play all four beeps at the same time, roughly. \n218.     BEEP2.play() \n219.     BEEP3.play() \n220.     BEEP4.play() \n221.     r, g, b = color \n222.     for i in range(3): # do the flash 3 times \n223.         for start, end, step in ((0, 255, 1), (255, 0, -1)): \n224.             # The first iteration in this loop sets the following for loop \n225.             # to go from 0 to 255, the second from 255 to 0. \n",
      "content_length": 1837,
      "extraction_method": "Direct"
    },
    {
      "page_number": 132,
      "chapter": null,
      "content": "114    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n226.             for alpha in range(start, end, animationSpeed * step): # \nanimation loop \n227.                 # alpha means transparency. 255 is opaque, 0 is invisible \n228.                 checkForQuit() \n229.                 flashSurf.fill((r, g, b, alpha)) \n230.                 DISPLAYSURF.blit(origSurf, (0, 0)) \n231.                 DISPLAYSURF.blit(flashSurf, (0, 0)) \n232.                 drawButtons() \n233.                 pygame.display.update() \n234.                 FPSCLOCK.tick(FPS) \n235.  \n236. \n237. \n238. def getButtonClicked(x, y): \n239.     if YELLOWRECT.collidepoint( (x, y) ): \n240.         return YELLOW \n241.     elif BLUERECT.collidepoint( (x, y) ): \n242.         return BLUE \n243.     elif REDRECT.collidepoint( (x, y) ): \n244.         return RED \n245.     elif GREENRECT.collidepoint( (x, y) ): \n246.         return GREEN \n247.     return None \n248.  \n249.  \n250. if __name__ == '__main__': \n251.     main() \nThe Usual Starting Stuff \n  1. # Simulate (a Simon clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, sys, time, pygame \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 \n 10. WINDOWWIDTH = 640 \n 11. WINDOWHEIGHT = 480 \n 12. FLASHSPEED = 500 # in milliseconds \n 13. FLASHDELAY = 200 # in milliseconds \n 14. BUTTONSIZE = 200 \n 15. BUTTONGAPSIZE = 20 \n 16. TIMEOUT = 4 # seconds before game over if no button is pushed. \n",
      "content_length": 1581,
      "extraction_method": "Direct"
    },
    {
      "page_number": 133,
      "chapter": null,
      "content": "Chapter 5 – Simulate    115 \n \n 17.  \n 18. #                R    G    B \n 19. WHITE        = (255, 255, 255) \n 20. BLACK        = (  0,   0,   0) \n 21. BRIGHTRED    = (255,   0,   0) \n 22. RED          = (155,   0,   0) \n 23. BRIGHTGREEN  = (  0, 255,   0) \n 24. GREEN        = (  0, 155,   0) \n 25. BRIGHTBLUE   = (  0,   0, 255) \n 26. BLUE         = (  0,   0, 155) \n 27. BRIGHTYELLOW = (255, 255,   0) \n 28. YELLOW       = (155, 155,   0) \n 29. DARKGRAY     = ( 40,  40,  40) \n 30. bgColor = BLACK \n 31.  \n 32. XMARGIN = int((WINDOWWIDTH - (2 * BUTTONSIZE) - BUTTONGAPSIZE) / 2) \n 33. YMARGIN = int((WINDOWHEIGHT - (2 * BUTTONSIZE) - BUTTONGAPSIZE) / 2) \nHere we set up the usual constants for things that we might want to modify later such as the size \nof the four buttons, the shades of color used for the buttons (the bright colors are used when the \nbuttons light up) and the amount of time the player has to push the next button in the sequence \nbefore the game times out. \nSetting Up the Buttons \n 35. # Rect objects for each of the four buttons \n 36. YELLOWRECT = pygame.Rect(XMARGIN, YMARGIN, BUTTONSIZE, BUTTONSIZE) \n 37. BLUERECT   = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN, \nBUTTONSIZE, BUTTONSIZE) \n 38. REDRECT    = pygame.Rect(XMARGIN, YMARGIN + BUTTONSIZE + BUTTONGAPSIZE, \nBUTTONSIZE, BUTTONSIZE) \n 39. GREENRECT  = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN + \nBUTTONSIZE + BUTTONGAPSIZE, BUTTONSIZE, BUTTONSIZE) \nJust like the buttons in the Sliding Puzzle games for ―Reset‖, ―Solve‖ and ―New Game‖, the \nSimulate game has four rectangular areas and code to handle when the player clicks inside of \nthose areas. The program will need Rect objects for the areas of the four buttons so it can call the \ncollidepoint() method on them. Lines 36 to 39 set up these Rect objects with the \nappropriate coordinates and sizes. \nThe main() Function \n 41. def main(): \n 42.     global FPSCLOCK, DISPLAYSURF, BASICFONT, BEEP1, BEEP2, BEEP3, BEEP4 \n",
      "content_length": 1990,
      "extraction_method": "Direct"
    },
    {
      "page_number": 134,
      "chapter": null,
      "content": "116    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 43.  \n 44.     pygame.init() \n 45.     FPSCLOCK = pygame.time.Clock() \n 46.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 47.     pygame.display.set_caption('Simulate') \n 48.  \n 49.     BASICFONT = pygame.font.Font('freesansbold.ttf', 16) \n 50. \n 51.     infoSurf = BASICFONT.render('Match the pattern by clicking on the \nbutton or using the Q, W, A, S keys.', 1, DARKGRAY) \n 52.     infoRect = infoSurf.get_rect() \n 53.     infoRect.topleft = (10, WINDOWHEIGHT - 25) \n 54.     # load the sound files \n 55.     BEEP1 = pygame.mixer.Sound('beep1.ogg') \n 56.     BEEP2 = pygame.mixer.Sound('beep2.ogg') \n 57.     BEEP3 = pygame.mixer.Sound('beep3.ogg') \n 58.     BEEP4 = pygame.mixer.Sound('beep4.ogg') \nThe main() function will implement the bulk of the program and call the other functions as they \nare needed. The usual Pygame setup functions are called to initialize the library, create a Clock \nobject, create a window, set the caption, and create a Font object that will be used to display the \nscore and the instructions on the window. The objects that are created by these function calls will \nbe stored in global variables so that they can be used in other functions. But they are basically \nconstants since the value in them is never changed. \nLines 55 to 58 will load sound files so that Simulate can play sound effects as the player clicks on \neach button. The pygame.mixer.Sound() constructor function will return a Sound object, \nwhich we store in the variables BEEP1 to BEEP4 which were made into global variables on line \n42. \nSome Local Variables Used in This Program \n 60.     # Initialize some variables for a new game \n 61.     pattern = [] # stores the pattern of colors \n 62.     currentStep = 0 # the color the player must push next \n 63.     lastClickTime = 0 # timestamp of the player's last button push \n 64.     score = 0 \n 65.     # when False, the pattern is playing. when True, waiting for the \nplayer to click a colored button: \n 66.     waitingForInput = False \nThe pattern variable will be a list of color values (either YELLOW, RED, BLUE, or GREEN) to \nkeep track of the pattern that the player must memorize. For example, if the value of pattern was \n[RED, RED, YELLOW, RED, BLUE, BLUE, RED, GREEN] then the player would \n",
      "content_length": 2386,
      "extraction_method": "Direct"
    },
    {
      "page_number": 135,
      "chapter": null,
      "content": "Chapter 5 – Simulate    117 \n \nhave to first click the red button twice, then the yellow button, then the red button, and so on until \nthe final green button. As the player finishes each round, a new random color is added to the end \nof the list. \nThe currentStep variable will keep track of which color in the pattern list the player has to \nclick next. If currentStep was 0 and pattern was [GREEN, RED, RED, YELLOW], \nthen the player would have to click the green button. If they clicked on any other button, the code \nwill cause a game over. \nThere is a TIMEOUT constant that makes the player click on next button in the pattern within a \nnumber of seconds, otherwise the code causes a game over. In order to check if enough time has \npassed since the last button click, the lastClickTime variable needs to keep track of the last \ntime the player clicked on a button. (Python has a module named time and a time.time() \nfunction to return the current time. This will be explained later.) \nIt may be hard to believe, but the score variable keeps track of the score. Inconceivable! \nThere are also two modes that our program will be in. Either the program is playing the pattern of \nbuttons for the player (in which case, waitingForInput is set to False), or the program has \nfinished playing the pattern and is waiting for the user to click the buttons in the correct order (in \nwhich case, waitingForInput is set to True). \nDrawing the Board and Handling Input \n 68.     while True: # main game loop \n 69.         clickedButton = None # button that was clicked (set to YELLOW, \nRED, GREEN, or BLUE) \n 70.         DISPLAYSURF.fill(bgColor) \n 71.         drawButtons() \n 72.  \n 73.         scoreSurf = BASICFONT.render('Score: ' + str(score), 1, WHITE) \n 74.         scoreRect = scoreSurf.get_rect() \n 75.         scoreRect.topleft = (WINDOWWIDTH - 100, 10) \n 76.         DISPLAYSURF.blit(scoreSurf, scoreRect) \n 77.  \n 78.         DISPLAYSURF.blit(infoSurf, infoRect) \nLine 68 is the start of the main game loop. The clickedButton will be reset to None at the \nbeginning of each iteration. If a button is clicked during this iteration, then clickedButton \nwill be set to one of the color values to match the button (YELLOW, RED, GREEN, or BLUE). \n",
      "content_length": 2248,
      "extraction_method": "Direct"
    },
    {
      "page_number": 136,
      "chapter": null,
      "content": "118    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe fill() method is called on line 70 to repaint the entire display Surface so that we can start \ndrawing from scratch. The four colored buttons are drawn with a call to the drawButtons() \n(explained later). Then the text for the score is created on lines 73 to 76. \nThere will also be text that tells the player what their current score is. Unlike the call to the \nrender() method on line 51 for the instruction text, the text for the score changes. It starts off \nas 'Score: 0' and then becomes 'Score: 1' and then 'Score: 2' and so on. This is \nwhy we create new Surface objects by calling the render() method on line 73 inside the game \nloop. Since the instruction text (―Match the pattern by…‖) never changes, we only need one call \nto render() outside the game loop on line 50. \nChecking for Mouse Clicks \n 80.         checkForQuit() \n 81.         for event in pygame.event.get(): # event handling loop \n 82.             if event.type == MOUSEBUTTONUP: \n 83.                 mousex, mousey = event.pos \n 84.                 clickedButton = getButtonClicked(mousex, mousey) \nLine 80 does a quick check for any QUIT events, and then line 81 is the start of the event \nhandling loop. The XY coordinates of any mouse clicks will be stored in the mousex and \nmousey variables. If the mouse click was over one of the four buttons, then our \ngetButtonClicked() function will return a Color object of the button clicked (otherwise it \nreturns None). \nChecking for Keyboard Presses \n 85.             elif event.type == KEYDOWN: \n 86.                 if event.key == K_q: \n 87.                     clickedButton = YELLOW \n 88.                 elif event.key == K_w: \n 89.                     clickedButton = BLUE \n 90.                 elif event.key == K_a: \n 91.                     clickedButton = RED \n 92.                 elif event.key == K_s: \n 93.                     clickedButton = GREEN \nLines 85 to 93 check for any KEYDOWN events (created when the user presses a key on the \nkeyboard). The Q, W, A, and S keys correspond to the buttons because they are arranged in a \nsquare shape on the keyboard. \nThe Q key is in the upper left of the four keyboard keys, just like the yellow button on the screen \nis in the upper left, so we will make pressing the Q key the same as clicking on the yellow button. \n",
      "content_length": 2413,
      "extraction_method": "Direct"
    },
    {
      "page_number": 137,
      "chapter": null,
      "content": "Chapter 5 – Simulate    119 \n \nWe can do this by setting the clickedButton variable to the value in the constant variable \nYELLOW. We can do the same for the three other keys. This way, the user can play Simulate with \neither the mouse or keyboard. \nThe Two States of the Game Loop \n 97.         if not waitingForInput: \n 98.             # play the pattern \n 99.             pygame.display.update() \n100.             pygame.time.wait(1000) \n101.             pattern.append(random.choice((YELLOW, BLUE, RED, GREEN))) \n102.             for button in pattern: \n103.                 flashButtonAnimation(button) \n104.                 pygame.time.wait(FLASHDELAY) \n105.             waitingForInput = True \nThere are two different ―modes‖ or ―states‖ that the program can be in. When \nwaitingForInput is False, the program will be displaying the animation for the pattern. \nWhen waitingForInput is True, the program will be waiting for the user to select buttons. \nLines 97 to 105 will cover the case where the program displays the pattern animation. Since this \nis done at the start of the game or when the player finishes a pattern, line 101 will add a random \ncolor to the pattern list to make the pattern one step longer. Then lines 102 to 104 loops through \neach of the values in the pattern list and calls flashButtonAnimation() which makes that \nbutton light up. After it is done lighting up all the buttons in the pattern list, the program sets the \nwaitingForInput variable to True. \nFiguring Out if the Player Pressed the Right Buttons \n106.         else: \n107.             # wait for the player to enter buttons \n108.             if clickedButton and clickedButton == pattern[currentStep]: \n109.                 # pushed the correct button \n110.                 flashButtonAnimation(clickedButton) \n111.                 currentStep += 1 \n112.                 lastClickTime = time.time() \nIf waitingForInput is True, then the code in line 106’s else statement will execute. Line \n108 checks if the player has clicked on a button during this iteration of the game loop and if that \nbutton was the correct one. The currentStep variable keeps track of the index in the pattern \nlist for the button that the player should click on next. \n",
      "content_length": 2238,
      "extraction_method": "Direct"
    },
    {
      "page_number": 138,
      "chapter": null,
      "content": "120    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nFor example, if pattern was set to [YELLOW, RED, RED] and the currentStep variable \nwas set to 0 (like it would be when the player first starts the game), then the correct button for the \nplayer to click would be pattern[0] (the yellow button). \nIf the player has clicked on the correct button, we want to flash the button the player clicked by \ncalling flashButtonAnimation() then, increase the currentStep to the next step, and \nthen update the lastClickTime variable to the current time. (The time.time() function \nreturns a float value of the number of seconds since January 1st, 1970, so we can use it to keep \ntrack of time.) \n114.                 if currentStep == len(pattern): \n115.                     # pushed the last button in the pattern \n116.                     changeBackgroundAnimation() \n117.                     score += 1 \n118.                     waitingForInput = False \n119.                     currentStep = 0 # reset back to first step \nLines 114 to 119 are inside the else statement that started on line 106. If the execution is inside \nthat else statement, we know the player clicked on a button and also it was the correct button. \nLine 114 checks if this was the last correct button in the pattern list by checking if the integer \nstored in currentStep is equal to the number of values inside the pattern list. \nIf this is True, then we want to change the background color by calling our \nchangeBackgroundAnimation(). This is a simple way to let the player know they have \nentered the entire pattern correctly. The score is incremented, currentStep is set back to 0, \nand the waitingForInput variable is set to False so that on the next iteration of the game \nloop the code will add a new Color value to the pattern list and then flash the buttons. \n121.             elif (clickedButton and clickedButton != pattern[currentStep]) \nor (currentStep != 0 and time.time() - TIMEOUT > lastClickTime): \nIf the player did not click on the correct button, the elif statement on line 121 handles the case \nwhere either the player clicked on the wrong button or the player has waited too long to click on a \nbutton. Either way, we need to show the ―game over‖ animation and start a new game. \nThe (clickedButton and clickedButton != pattern[currentStep]) part of \nthe elif statement’s condition checks if a button was clicked and was the wrong button to click. \nYou can compare this to line 108’s if statement’s condition clickedButton and \nclickedButton == pattern[currentStep] which evaluates to True if the player \nclicked a button and it was the correct button to click. \n",
      "content_length": 2699,
      "extraction_method": "Direct"
    },
    {
      "page_number": 139,
      "chapter": null,
      "content": "Chapter 5 – Simulate    121 \n \nThe other part of line 121’s elif condition is (currentStep != 0 and time.time() \n- TIMEOUT > lastClickTime). This handles making sure the player did not ―time out‖. \nNotice that this part of the condition has two expressions connected by an and keyword. That \nmeans both sides of the and keyword need to evaluate to True. \nIn order to ―time out‖, it must not be the player’s first button click. But once they’ve started to \nclick buttons, they must keep clicking the buttons quickly enough until they’ve entered the entire \npattern (or have clicked on the wrong pattern and gotten a ―game over‖). If currentStep != \n0 is True, then we know the player has begun clicking the buttons. \nEpoch Time \nAlso in order to ―time out‖, the current time (returned by time.time()) minus four seconds \n(because 4 is stored in TIMEOUT) must be greater than the last time clicked a button (stored in \nlastClickTime). The reason why time.time() - TIMEOUT > lastClickTime \nworks has to do with how epoch time works. Epoch time (also called Unix epoch time) is the \nnumber of seconds it has been since January 1st, 1970. This date is called the Unix epoch. \nFor example, when I run time.time() from the interactive shell (don’t forget to import the \ntime module first), it looks like this: \n>>> import time \n>>> time.time() \n1320460242.118 \nWhat this number means is that the moment the time.time() function was called was a little \nover 1,320,460,242 seconds since midnight of January 1st, 1970. (This translates to November 4th, \n2011 at 7:30:42pm. You can learn how to convert from Unix epoch time to regular English time \nat http://invpy.com/epochtime) \nIf I call time.time() from the interactive shell a few seconds later, it might look like this: \n>>> time.time() \n1320460261.315 \n1320460261.315 seconds after midnight of the Unix epoch is November 4th, 2011 at 7:31:01pm. \n(Actually, it’s 7:31 and 0.315 seconds if you want to be precise.) \nDealing with time would be difficult if we had to deal with strings. It’s hard to tell that 19 \nseconds have passed if we only had the string values '7:30:42 PM' and '7:31:01 PM' to \ncompare. But with epoch time, it’s just a matter of subtracting the integers 1320460261.315 \n- 1320460242.118, which evaluates to 19.197000026702881. This value is the number \n",
      "content_length": 2320,
      "extraction_method": "Direct"
    },
    {
      "page_number": 140,
      "chapter": null,
      "content": "122    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nof seconds between those two times. (The extra 0.000026702881 comes from very small \nrounding errors that happen when you do math with floating point numbers. They only happen \nsometimes and are usually too tiny to matter. You can learn more about floating point rounding \nerrors at http://invpy.com/roundingerrors.) \nGoing back to line 121, if time.time() - TIMEOUT > lastClickTime evaluates to \nTrue, then it has been longer than 4 seconds since time.time() was called and stored in \nlastClickTime. If it evaluates to False, then it has been less than 4 seconds. \n122.                 # pushed the incorrect button, or has timed out \n123.                 gameOverAnimation() \n124.                 # reset the variables for a new game: \n125.                 pattern = [] \n126.                 currentStep = 0 \n127.                 waitingForInput = False \n128.                 score = 0 \n129.                 pygame.time.wait(1000) \n130.                 changeBackgroundAnimation() \nIf either the player clicked on the wrong button or has timed out, the program should play the \n―game over‖ animation and then reset the variables for a new game. This involves setting the \npattern list to a blank list, currentStep to 0, waitingForInput to False, and then \nscore to 0. A small pause and a new background color will be set to indicate to the player the \nstart of a new game, which will begin on the next iteration of the game loop. \nDrawing the Board to the Screen \n132.         pygame.display.update() \n133.         FPSCLOCK.tick(FPS) \nJust like the other game programs, the last thing done in the game loop is drawing the display \nSurface object to the screen and calling the tick() method. \nSame Old terminate() Function \n136. def terminate(): \n137.     pygame.quit() \n138.     sys.exit() \n139.  \n140.  \n141. def checkForQuit(): \n142.     for event in pygame.event.get(QUIT): # get all the QUIT events \n143.         terminate() # terminate if any QUIT events are present \n144.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n",
      "content_length": 2153,
      "extraction_method": "Direct"
    },
    {
      "page_number": 141,
      "chapter": null,
      "content": "Chapter 5 – Simulate    123 \n \n145.         if event.key == K_ESCAPE: \n146.             terminate() # terminate if the KEYUP event was for the Esc key \n147.         pygame.event.post(event) # put the other KEYUP event objects back \nThe terminate() and checkForQuit() functions were used and explained in the Sliding \nPuzzle chapter, so we will skip describing them again. \nReusing The Constant Variables \n150. def flashButtonAnimation(color, animationSpeed=50): \n151.     if color == YELLOW: \n152.         sound = BEEP1 \n153.         flashColor = BRIGHTYELLOW \n154.         rectangle = YELLOWRECT \n155.     elif color == BLUE: \n156.         sound = BEEP2 \n157.         flashColor = BRIGHTBLUE \n158.         rectangle = BLUERECT \n159.     elif color == RED: \n160.         sound = BEEP3 \n161.         flashColor = BRIGHTRED \n162.         rectangle = REDRECT \n163.     elif color == GREEN: \n164.         sound = BEEP4 \n165.         flashColor = BRIGHTGREEN \n166.         rectangle = GREENRECT \nDepending on which Color value is passed as an argument for the color parameter, the sound, \ncolor of the bright flash, and rectangular area of the flash will be different. Line 151 to 166 sets \nthree local variables differently depending on the value in the color parameter: sound, \nflashColor, and rectangle. \nAnimating the Button Flash \n168.     origSurf = DISPLAYSURF.copy() \n169.     flashSurf = pygame.Surface((BUTTONSIZE, BUTTONSIZE)) \n170.     flashSurf = flashSurf.convert_alpha() \n171.     r, g, b = flashColor \n172.     sound.play() \nThe process of animating the button flash is simple: On each frame of the animation, the normal \nboard is drawn and then on top of that, the bright color version of the button that is flashing is \ndrawn over the button. The alpha value of the bright color starts off at 0 for the first frame of \nanimation, but then on each frame after the alpha value is slowly increased until it is fully opaque \n",
      "content_length": 1934,
      "extraction_method": "Direct"
    },
    {
      "page_number": 142,
      "chapter": null,
      "content": "124    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nand the bright color version completely paints over the normal button color. This will make it \nlook like the button is slowly brightening up. \nThe brightening up is the first half of the animation. The second half is the button dimming. This \nis done with the same code, except that instead of the alpha value increasing for each frame, it \nwill be decreasing. As the alpha value gets lower and lower, the bright color painted on top will \nbecome more and more invisible, until only the original board with the dull colors is visible. \nTo do this in code, line 168 creates a copy of the display Surface object and stores it in \norigSurf. Line 169 creates a new Surface object the size of a single button and stores it in \nflashSurf. The convert_alpha() method is called on flashSurf so that the Surface \nobject can have transparent colors drawn on it (otherwise, the alpha value in the Color objects we \nuse will be ignored and automatically assumed to be 255). In your own game programs, if you are \nhaving trouble getting color transparency to work, make sure that you have called the \nconvert_alpha() method on any Surface objects that have transparent colors painted on \nthem. \nLine 171 creates individual local variables named r, g, and b to store the individual RGB values \nof the tuple stored in flashColor. This is just some syntactic sugar that makes the rest of the \ncode in this function easier to read. Before we begin animating the button flash, line 172 will play \nthe sound effect for that button. The program execution keeps going after the sound effect has \nstarted to play, so the sound will be playing during the button flash animation. \n173.     for start, end, step in ((0, 255, 1), (255, 0, -1)): # animation loop \n174.         for alpha in range(start, end, animationSpeed * step): \n175.             checkForQuit() \n176.             DISPLAYSURF.blit(origSurf, (0, 0)) \n177.             flashSurf.fill((r, g, b, alpha)) \n178.             DISPLAYSURF.blit(flashSurf, rectangle.topleft) \n179.             pygame.display.update() \n180.             FPSCLOCK.tick(FPS) \n181.     DISPLAYSURF.blit(origSurf, (0, 0)) \nRemember that to do the animation, we want to first draw the flashSurf with color that has \nincreasing alpha values from 0 to 255 to do the brightening part of the animation. Then to do the \ndimming, we want the alpha value to go from 255 to 0. We could do that with code like this: \n    for alpha in range(0, 255, animationSpeed): # brightening \n        checkForQuit() \n        DISPLAYSURF.blit(origSurf, (0, 0)) \n        flashSurf.fill((r, g, b, alpha)) \n        DISPLAYSURF.blit(flashSurf, rectangle.topleft) \n",
      "content_length": 2749,
      "extraction_method": "Direct"
    },
    {
      "page_number": 143,
      "chapter": null,
      "content": "Chapter 5 – Simulate    125 \n \n        pygame.display.update() \n        FPSCLOCK.tick(FPS) \n    for alpha in range(255, 0, -animationSpeed): # dimming \n        checkForQuit() \n        DISPLAYSURF.blit(origSurf, (0, 0)) \n        flashSurf.fill((r, g, b, alpha)) \n        DISPLAYSURF.blit(flashSurf, rectangle.topleft) \n        pygame.display.update() \n        FPSCLOCK.tick(FPS) \nBut notice that the code inside the for loops handles drawing the frame and are identical to each \nother. If we wrote the code like the above, then the first for loop would handle the brightening \npart of the animation (where the alpha value goes from 0 to 255) and the second for loop would \nhandle the dimming part of the animation (where the alpha values goes from 255 to 0). Note that \nfor the second for loop, the third argument to the range() call is a negative number. \nWhenever we have identical code like this, we can probably shorten our code so we don’t have to \nrepeat it. This is what we do with the for loop on line 173, which supplies different values for \nthe range() call on line 174: \n173.     for start, end, step in ((0, 255, 1), (255, 0, -1)): # animation loop \n174.         for alpha in range(start, end, animationSpeed * step): \nOn the first iteration of line 173’s for loop, start is set to 0, end is set to 255, and step is \nset to 1. This way, when the for loop on line 174 is executed, it is calling range(0, 255, \nanimationSpeed). (Note that animationSpeed * 1 is the same as animationSpeed. \nMultiplying a number by 1 gives us the same number.) \nLine 174’s for loop then executes and performs the brightening animation. \nOn the second iteration of line 173’s for loop (there are always two and only two iterations of \nthis inner for loop), start is set to 255, end is set to 0, and step is set to -1. When the line \n174’s for loop is executed, it is calling range(255, 0, -animationSpeed). (Note that \nanimationSpeed * -1 evaluates to -animationSpeed, since multiplying any number \nby -1 returns the negative form of that same number.) \nThis way, we don’t have to have two separate for loops and repeat all the code that is inside of \nthem. Here’s the code again that is inside line 174’s for loop: \n175.             checkForQuit() \n176.             DISPLAYSURF.blit(origSurf, (0, 0)) \n177.             flashSurf.fill((r, g, b, alpha)) \n",
      "content_length": 2345,
      "extraction_method": "Direct"
    },
    {
      "page_number": 144,
      "chapter": null,
      "content": "126    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n178.             DISPLAYSURF.blit(flashSurf, rectangle.topleft) \n179.             pygame.display.update() \n180.             FPSCLOCK.tick(FPS) \n181.     DISPLAYSURF.blit(origSurf, (0, 0)) \nWe check for any QUIT events (in case the user tried to close the program during the animation), \nthen blit the origSurf Surface to the display Surface. Then we paint the flashSurf Surface \nby calling fill() (supplying the r, g, b values of the color we got on line 171 and the alpha \nvalue that the for loop sets in the alpha variable). Then the flashSurf Surface is blitted to \nthe display Surface.  \nThen, to make the display Surface appear on the screen, pygame.display.update() is \ncalled on line 179. To make sure the animation doesn’t play as fast as the computer can draw it, \nwe add short pauses with a call to the tick() method. (If you want to see the flashing animation \nplay very slowly, put a low number like 1 or 2 as the argument to tick() instead of FPS.) \nDrawing the Buttons \n184. def drawButtons(): \n185.     pygame.draw.rect(DISPLAYSURF, YELLOW, YELLOWRECT) \n186.     pygame.draw.rect(DISPLAYSURF, BLUE,   BLUERECT) \n187.     pygame.draw.rect(DISPLAYSURF, RED,    REDRECT) \n188.     pygame.draw.rect(DISPLAYSURF, GREEN,  GREENRECT) \nSince each of the buttons is just a rectangle of a certain color in a certain place, we just make four \ncalls to pygame.draw.rect() to draw the buttons on the display Surface. The Color object \nand the Rect object we use to position them never change, which is why we stored them in \nconstant variables like YELLOW and YELLOWRECT. \nAnimating the Background Change \n191. def changeBackgroundAnimation(animationSpeed=40): \n192.     global bgColor \n193.     newBgColor = (random.randint(0, 255), random.randint(0, 255), \nrandom.randint(0, 255)) \n194.  \n195.     newBgSurf = pygame.Surface((WINDOWWIDTH, WINDOWHEIGHT)) \n196.     newBgSurf = newBgSurf.convert_alpha() \n197.     r, g, b = newBgColor \n198.     for alpha in range(0, 255, animationSpeed): # animation loop \n199.         checkForQuit() \n200.         DISPLAYSURF.fill(bgColor) \n201.  \n202.         newBgSurf.fill((r, g, b, alpha)) \n",
      "content_length": 2235,
      "extraction_method": "Direct"
    },
    {
      "page_number": 145,
      "chapter": null,
      "content": "Chapter 5 – Simulate    127 \n \n203.         DISPLAYSURF.blit(newBgSurf, (0, 0)) \n204.  \n205.         drawButtons() # redraw the buttons on top of the tint \n206.  \n207.         pygame.display.update() \n208.         FPSCLOCK.tick(FPS) \n209.     bgColor = newBgColor \nThe background color change animation happens whenever the player finishes entering the entire \npattern correctly. On each iteration through the loop which starts on line 198 the entire display \nSurface has to be redrawn (blended with a less and less transparent new background color, until \nthe background is completely covered by the new color). The steps done on each iteration of the \nloop are: \n \nLine 200 fills in the entire display Surface (stored in DISPLAYSURF) with the old \nbackground color (which is stored in bgColor). \n \nLine 202 fills in a different Surface object (stored in newBgSurf) with the new \nbackground color’s RGB values (and the alpha transparency value changes on each \niteration since that is what the for loop on line 198 does). \n \nLine 203 then draws the newBgSurf Surface to the display Surface in DISPLAYSURF. \nThe reason we didn’t just paint our semitransparent new background color on \nDISPLAYSURF to begin with is because the fill() method will just replace the color \non the Surface, whereas the blit() method will blend the colors. \n \nNow that we have the background the way we want it, we’ll draw the buttons over it with \na call to drawButtons() on line 205.  \n \nLine 207 and 208 then just draws the display Surface to the screen and adds a pause. \nThe reason there is a global statement at the beginning of the \nchangeBackgroundAnimation() function is for the bgColor variable is because this \nfunction modifies the content of the variable with an assignment statement on line 209. Any \nfunction can read the value of a global variable without specifying the global statement.  \nIf that function assigns a value to a global variable without a global statement, then Python \nconsiders that variable to be a local variable that just happens to have the same name as a global \nvariable. The main() function uses the bgColor variable but doesn’t need a global statement \nfor it because it only reads the contents of the bgColor the main() function never assigns \nbgColor a new value. This concept is explained in more detail at http://invpy.com/global. \nThe Game Over Animation \n212. def gameOverAnimation(color=WHITE, animationSpeed=50): \n",
      "content_length": 2446,
      "extraction_method": "Direct"
    },
    {
      "page_number": 146,
      "chapter": null,
      "content": "128    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n213.     # play all beeps at once, then flash the background \n214.     origSurf = DISPLAYSURF.copy() \n215.     flashSurf = pygame.Surface(DISPLAYSURF.get_size()) \n216.     flashSurf = flashSurf.convert_alpha() \n217.     BEEP1.play() # play all four beeps at the same time, roughly. \n218.     BEEP2.play() \n219.     BEEP3.play() \n220.     BEEP4.play() \n221.     r, g, b = color \n222.     for i in range(3): # do the flash 3 times \nEach of the iterations of the for loop on the next line (line 223 below) will perform a flash. To \nhave three flashes done, we put all of that code in a for loop that has three iterations. If you want \nmore or fewer flashes, then change the integer that is passed to range() on line 222. \n223.         for start, end, step in ((0, 255, 1), (255, 0, -1)): \nThe for loop on line 223 is exactly the same as the one line 173. The start, end, and step \nvariables will be used on the next for loop (on line 224) to control how the alpha variable \nchanges. Reread the ―Animating the Button Flash‖ section if you need to refresh yourself on how \nthese loops work. \n224.             # The first iteration in this loop sets the following for loop \n225.             # to go from 0 to 255, the second from 255 to 0. \n226.             for alpha in range(start, end, animationSpeed * step): # \nanimation loop \n227.                 # alpha means transparency. 255 is opaque, 0 is invisible \n228.                 checkForQuit() \n229.                 flashSurf.fill((r, g, b, alpha)) \n230.                 DISPLAYSURF.blit(origSurf, (0, 0)) \n231.                 DISPLAYSURF.blit(flashSurf, (0, 0)) \n232.                 drawButtons() \n233.                 pygame.display.update() \n234.                 FPSCLOCK.tick(FPS) \nThis animation loop works the same as the previous flashing animation code in the ―Animating \nthe Background Change‖ section. The copy of the original Surface object stored in origSurf is \ndrawn on the display Surface, then flashSurf (which has the new flashing color painted on it) \nis blitted on top of the display Surface. After the background color is set up, the buttons are drawn \non top on line 232. Finally the display Surface is drawn to the screen with the call to \npygame.display.update(). \n",
      "content_length": 2341,
      "extraction_method": "Direct"
    },
    {
      "page_number": 147,
      "chapter": null,
      "content": "Chapter 5 – Simulate    129 \n \nThe for loop on line 226 adjusts the alpha value for the color used for each frame of animation \n(increasing at first, and then decreasing). \nConverting from Pixel Coordinates to Buttons \n238. def getButtonClicked(x, y): \n239.     if YELLOWRECT.collidepoint( (x, y) ): \n240.         return YELLOW \n241.     elif BLUERECT.collidepoint( (x, y) ): \n242.         return BLUE \n243.     elif REDRECT.collidepoint( (x, y) ): \n244.         return RED \n245.     elif GREENRECT.collidepoint( (x, y) ): \n246.         return GREEN \n247.     return None \n248.  \n249.  \n250. if __name__ == '__main__': \n251.     main() \nThe getButtonClicked() function simply takes XY pixel coordinates and returns either the \nvalues YELLOW, BLUE, RED, or GREEN if one of the buttons was clicked, or returns None if the \nXY pixel coordinates are not over any of the four buttons. \nExplicit is Better Than Implicit \nYou may have noticed that the code for getButtonClicked() ends with a return None \nstatement on line 247. This might seem like an odd thing to type out, since all functions return \nNone if they don’t have any return statement at all. We could have left line 47 out entirely and \nthe program would have worked the exact same way. So why bother writing it in? \nNormally when a function reaches the end and returns the None value implicitly (that is, there is \nno return statement outright saying that it is returning None) the code that calls it doesn’t care \nabout the return value. All function calls have to return a value (so that they can evaluate to \nsomething and be part of expressions), but our code doesn’t always make use of the return value. \nFor example, think about the print() function. Technically, this function returns the None \nvalue, but we never care about it: \n>>> spam = print('Hello') \nHello \n>>> spam == None \nTrue \n>>> \n",
      "content_length": 1859,
      "extraction_method": "Direct"
    },
    {
      "page_number": 148,
      "chapter": null,
      "content": "130    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nHowever, when getButtonClicked() returns None, it means that the coordinates that were \npassed to it were not over any of the four buttons. To make it clear that in this case the value \nNone is returned from getButtonClicked(), we have the return None line at the end of \nthe function. \nTo make your code more readable, it is better to have your code be explicit (that is, clearly state \nsomething even if it might be obvious) rather than implicit (that is, leaving it up to the person \nreading code to know how it works without outright telling them). In fact, ―explicit is better than \nimplicit‖ is one of the Python Koans.  \nThe koans are a group of little sayings about how to write good code. There’s an Easter egg (that \nis, a little hidden surprise) in the Python interactive shell where if you try to import a module \nnamed this, then it will display ―The Zen of Python‖ koans. Try it out in the interactive shell: \n>>> import this \nThe Zen of Python, by Tim Peters \n \nBeautiful is better than ugly. \nExplicit is better than implicit. \nSimple is better than complex. \nComplex is better than complicated. \nFlat is better than nested. \nSparse is better than dense. \nReadability counts. \nSpecial cases aren't special enough to break the rules. \nAlthough practicality beats purity. \nErrors should never pass silently. \nUnless explicitly silenced. \nIn the face of ambiguity, refuse the temptation to guess. \nThere should be one-- and preferably only one --obvious way to do it. \nAlthough that way may not be obvious at first unless you're Dutch. \nNow is better than never. \nAlthough never is often better than *right* now. \nIf the implementation is hard to explain, it's a bad idea. \nIf the implementation is easy to explain, it may be a good idea. \nNamespaces are one honking great idea -- let's do more of those! \nIf you’d like to know more about what these individual koans mean, visit http://invpy.com/zen. \n \n \n",
      "content_length": 2022,
      "extraction_method": "Direct"
    },
    {
      "page_number": 149,
      "chapter": null,
      "content": "Chapter 6 – Wormy    131 \n \nCHAPTER 6 – WORMY \n \n \nHow to Play Wormy \nWormy is a Nibbles clone. The player starts out controlling a short worm that is constantly \nmoving around the screen. The player cannot stop or slow down the worm, but they can control \nwhich direction it turns. A red apple appears randomly on the screen, and the player must move \nthe worm so that it eats the apple. Each time the worm eats an apple, the worm grows longer by \none segment and a new apply randomly appears on the screen. The game is over if the worm \ncrashes into itself or the edges of the screen. \nSource Code to Wormy \nThis source code can be downloaded from http://invpy.com/wormy.py. If you get any error \nmessages, look at the line number that is mentioned in the error message and check your code for \nany typos. You can also copy and paste your code into the web form at \nhttp://invpy.com/diff/wormy to see if the differences between your code and the code in the book. \n  1. # Wormy (a Nibbles clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, pygame, sys \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 15 \n 10. WINDOWWIDTH = 640 \n 11. WINDOWHEIGHT = 480 \n",
      "content_length": 1275,
      "extraction_method": "Direct"
    },
    {
      "page_number": 150,
      "chapter": null,
      "content": "132    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 12. CELLSIZE = 20 \n 13. assert WINDOWWIDTH % CELLSIZE == 0, \"Window width must be a multiple of \ncell size.\" \n 14. assert WINDOWHEIGHT % CELLSIZE == 0, \"Window height must be a multiple of \ncell size.\" \n 15. CELLWIDTH = int(WINDOWWIDTH / CELLSIZE) \n 16. CELLHEIGHT = int(WINDOWHEIGHT / CELLSIZE) \n 17.  \n 18. #             R    G    B \n 19. WHITE     = (255, 255, 255) \n 20. BLACK     = (  0,   0,   0) \n 21. RED       = (255,   0,   0) \n 22. GREEN     = (  0, 255,   0) \n 23. DARKGREEN = (  0, 155,   0) \n 24. DARKGRAY  = ( 40,  40,  40) \n 25. BGCOLOR = BLACK \n 26.  \n 27. UP = 'up' \n 28. DOWN = 'down' \n 29. LEFT = 'left' \n 30. RIGHT = 'right' \n 31.  \n 32. HEAD = 0 # syntactic sugar: index of the worm's head \n 33.  \n 34. def main(): \n 35.     global FPSCLOCK, DISPLAYSURF, BASICFONT \n 36.  \n 37.     pygame.init() \n 38.     FPSCLOCK = pygame.time.Clock() \n 39.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 40.     BASICFONT = pygame.font.Font('freesansbold.ttf', 18) \n 41.     pygame.display.set_caption('Wormy') \n 42.  \n 43.     showStartScreen() \n 44.     while True: \n 45.         runGame() \n 46.         showGameOverScreen() \n 47.  \n 48.  \n 49. def runGame(): \n 50.     # Set a random start point. \n 51.     startx = random.randint(5, CELLWIDTH - 6) \n 52.     starty = random.randint(5, CELLHEIGHT - 6) \n 53.     wormCoords = [{'x': startx,     'y': starty}, \n 54.                   {'x': startx - 1, 'y': starty}, \n 55.                   {'x': startx - 2, 'y': starty}] \n",
      "content_length": 1612,
      "extraction_method": "Direct"
    },
    {
      "page_number": 151,
      "chapter": null,
      "content": "Chapter 6 – Wormy    133 \n \n 56.     direction = RIGHT \n 57.  \n 58.     # Start the apple in a random place. \n 59.     apple = getRandomLocation() \n 60.  \n 61.     while True: # main game loop \n 62.         for event in pygame.event.get(): # event handling loop \n 63.             if event.type == QUIT: \n 64.                 terminate() \n 65.             elif event.type == KEYDOWN: \n 66.                 if (event.key == K_LEFT or event.key == K_a) and direction \n!= RIGHT: \n 67.                     direction = LEFT \n 68.                 elif (event.key == K_RIGHT or event.key == K_d) and \ndirection != LEFT: \n 69.                     direction = RIGHT \n 70.                 elif (event.key == K_UP or event.key == K_w) and direction \n!= DOWN: \n 71.                     direction = UP \n 72.                 elif (event.key == K_DOWN or event.key == K_s) and \ndirection != UP: \n 73.                     direction = DOWN \n 74.                 elif event.key == K_ESCAPE: \n 75.                     terminate() \n 76.  \n 77.         # check if the worm has hit itself or the edge \n 78.         if wormCoords[HEAD]['x'] == -1 or wormCoords[HEAD]['x'] == \nCELLWIDTH or wormCoords[HEAD]['y'] == -1 or wormCoords[HEAD]['y'] == \nCELLHEIGHT: \n 79.             return # game over \n 80.         for wormBody in wormCoords[1:]: \n 81.             if wormBody['x'] == wormCoords[HEAD]['x'] and wormBody['y'] == \nwormCoords[HEAD]['y']: \n 82.                 return # game over \n 83.  \n 84.         # check if worm has eaten an apply \n 85.         if wormCoords[HEAD]['x'] == apple['x'] and wormCoords[HEAD]['y'] \n== apple['y']: \n 86.             # don't remove worm's tail segment \n 87.             apple = getRandomLocation() # set a new apple somewhere \n 88.         else: \n 89.             del wormCoords[-1] # remove worm's tail segment \n 90.  \n 91.         # move the worm by adding a segment in the direction it is moving \n 92.         if direction == UP: \n",
      "content_length": 1949,
      "extraction_method": "Direct"
    },
    {
      "page_number": 152,
      "chapter": null,
      "content": "134    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 93.             newHead = {'x': wormCoords[HEAD]['x'], 'y': \nwormCoords[HEAD]['y'] - 1} \n 94.         elif direction == DOWN: \n 95.             newHead = {'x': wormCoords[HEAD]['x'], 'y': \nwormCoords[HEAD]['y'] + 1} \n 96.         elif direction == LEFT: \n 97.             newHead = {'x': wormCoords[HEAD]['x'] - 1, 'y': \nwormCoords[HEAD]['y']} \n 98.         elif direction == RIGHT: \n 99.             newHead = {'x': wormCoords[HEAD]['x'] + 1, 'y': \nwormCoords[HEAD]['y']} \n100.         wormCoords.insert(0, newHead) \n101.         DISPLAYSURF.fill(BGCOLOR) \n102.         drawGrid() \n103.         drawWorm(wormCoords) \n104.         drawApple(apple) \n105.         drawScore(len(wormCoords) - 3) \n106.         pygame.display.update() \n107.         FPSCLOCK.tick(FPS) \n108.  \n109. def drawPressKeyMsg(): \n110.     pressKeySurf = BASICFONT.render('Press a key to play.', True, \nDARKGRAY) \n111.     pressKeyRect = pressKeySurf.get_rect() \n112.     pressKeyRect.topleft = (WINDOWWIDTH - 200, WINDOWHEIGHT - 30) \n113.     DISPLAYSURF.blit(pressKeySurf, pressKeyRect) \n114.  \n115. \n116. def checkForKeyPress(): \n117.     if len(pygame.event.get(QUIT)) > 0: \n118.         terminate() \n119.  \n120.     keyUpEvents = pygame.event.get(KEYUP) \n121.     if len(keyUpEvents) == 0: \n122.         return None \n123.     if keyUpEvents[0].key == K_ESCAPE: \n124.         terminate() \n125.     return keyUpEvents[0].key \n126. \n127. \n128. def showStartScreen(): \n129.     titleFont = pygame.font.Font('freesansbold.ttf', 100) \n130.     titleSurf1 = titleFont.render('Wormy!', True, WHITE, DARKGREEN) \n131.     titleSurf2 = titleFont.render('Wormy!', True, GREEN) \n132.  \n133.     degrees1 = 0 \n",
      "content_length": 1775,
      "extraction_method": "Direct"
    },
    {
      "page_number": 153,
      "chapter": null,
      "content": "Chapter 6 – Wormy    135 \n \n134.     degrees2 = 0 \n135.     while True: \n136.         DISPLAYSURF.fill(BGCOLOR) \n137.         rotatedSurf1 = pygame.transform.rotate(titleSurf1, degrees1) \n138.         rotatedRect1 = rotatedSurf1.get_rect() \n139.         rotatedRect1.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2) \n140.         DISPLAYSURF.blit(rotatedSurf1, rotatedRect1) \n141.  \n142.         rotatedSurf2 = pygame.transform.rotate(titleSurf2, degrees2) \n143.         rotatedRect2 = rotatedSurf2.get_rect() \n144.         rotatedRect2.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2) \n145.         DISPLAYSURF.blit(rotatedSurf2, rotatedRect2) \n146.  \n147.         drawPressKeyMsg() \n148.  \n149.         if checkForKeyPress(): \n150.             pygame.event.get() # clear event queue \n151.             return \n152.         pygame.display.update() \n153.         FPSCLOCK.tick(FPS) \n154.         degrees1 += 3 # rotate by 3 degrees each frame \n155.         degrees2 += 7 # rotate by 7 degrees each frame \n156.  \n157.  \n158. def terminate(): \n159.     pygame.quit() \n160.     sys.exit() \n161.  \n162.  \n163. def getRandomLocation(): \n164.     return {'x': random.randint(0, CELLWIDTH - 1), 'y': random.randint(0, \nCELLHEIGHT - 1)} \n165.  \n166.  \n167. def showGameOverScreen(): \n168.     gameOverFont = pygame.font.Font('freesansbold.ttf', 150) \n169.     gameSurf = gameOverFont.render('Game', True, WHITE) \n170.     overSurf = gameOverFont.render('Over', True, WHITE) \n171.     gameRect = gameSurf.get_rect() \n172.     overRect = overSurf.get_rect() \n173.     gameRect.midtop = (WINDOWWIDTH / 2, 10) \n174.     overRect.midtop = (WINDOWWIDTH / 2, gameRect.height + 10 + 25) \n175.  \n176.     DISPLAYSURF.blit(gameSurf, gameRect) \n177.     DISPLAYSURF.blit(overSurf, overRect) \n178.     drawPressKeyMsg() \n",
      "content_length": 1792,
      "extraction_method": "Direct"
    },
    {
      "page_number": 154,
      "chapter": null,
      "content": "136    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n179.     pygame.display.update() \n180.     pygame.time.wait(500) \n181.     checkForKeyPress() # clear out any key presses in the event queue \n182.  \n183.     while True: \n184.         if checkForKeyPress(): \n185.             pygame.event.get() # clear event queue \n186.             return \n187.  \n188. def drawScore(score): \n189.     scoreSurf = BASICFONT.render('Score: %s' % (score), True, WHITE) \n190.     scoreRect = scoreSurf.get_rect() \n191.     scoreRect.topleft = (WINDOWWIDTH - 120, 10) \n192.     DISPLAYSURF.blit(scoreSurf, scoreRect) \n193.  \n194.  \n195. def drawWorm(wormCoords): \n196.     for coord in wormCoords: \n197.         x = coord['x'] * CELLSIZE \n198.         y = coord['y'] * CELLSIZE \n199.         wormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \n200.         pygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \n201.         wormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, \nCELLSIZE - 8) \n202.         pygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \n203.  \n204.  \n205. def drawApple(coord): \n206.     x = coord['x'] * CELLSIZE \n207.     y = coord['y'] * CELLSIZE \n208.     appleRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \n209.     pygame.draw.rect(DISPLAYSURF, RED, appleRect) \n210.  \n211.  \n212. def drawGrid(): \n213.     for x in range(0, WINDOWWIDTH, CELLSIZE): # draw vertical lines \n214.         pygame.draw.line(DISPLAYSURF, DARKGRAY, (x, 0), (x, WINDOWHEIGHT)) \n215.     for y in range(0, WINDOWHEIGHT, CELLSIZE): # draw horizontal lines \n216.         pygame.draw.line(DISPLAYSURF, DARKGRAY, (0, y), (WINDOWWIDTH, y)) \n217. \n218. \n219. if __name__ == '__main__': \n220.     main() \n",
      "content_length": 1757,
      "extraction_method": "Direct"
    },
    {
      "page_number": 155,
      "chapter": null,
      "content": "Chapter 6 – Wormy    137 \n \nThe Grid \n \nIf you play the game a little, you’ll notice that the apple and the segments of the worm’s body \nalways fit along a grid of lines. We will call each of the squares in this grid a cell (it’s not always \nwhat a space in a grid is called, it’s just a name I came up with). The cells have their own \nCartesian coordinate system, with (0, 0) being the top left cell and (31, 23) being the bottom right \ncell. \nThe Setup Code \n  1. # Wormy (a Nibbles clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, pygame, sys \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 15 \n 10. WINDOWWIDTH = 640 \n 11. WINDOWHEIGHT = 480 \n 12. CELLSIZE = 20 \n 13. assert WINDOWWIDTH % CELLSIZE == 0, \"Window width must be a multiple of \ncell size.\" \n 14. assert WINDOWHEIGHT % CELLSIZE == 0, \"Window height must be a multiple of \ncell size.\" \n 15. CELLWIDTH = int(WINDOWWIDTH / CELLSIZE) \n 16. CELLHEIGHT = int(WINDOWHEIGHT / CELLSIZE) \n",
      "content_length": 1067,
      "extraction_method": "Direct"
    },
    {
      "page_number": 156,
      "chapter": null,
      "content": "138    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe code at the start of the program just sets up some constant variables used in the game. The \nwidth and height of the cells are stored in CELLSIZE. The assert statements on lines 13 and \n14 ensure that the cells fit perfectly in the window. For example, if the CELLSIZE was 10 and \nthe WINDOWWIDTH or WINDOWHEIGHT constants were set to 15, then only 1.5 cells could fit. \nThe assert statements make sure that only a whole integer number of cells fits in the window. \n 18. #             R    G    B \n 19. WHITE     = (255, 255, 255) \n 20. BLACK     = (  0,   0,   0) \n 21. RED       = (255,   0,   0) \n 22. GREEN     = (  0, 255,   0) \n 23. DARKGREEN = (  0, 155,   0) \n 24. DARKGRAY  = ( 40,  40,  40) \n 25. BGCOLOR = BLACK \n 26.  \n 27. UP = 'up' \n 28. DOWN = 'down' \n 29. LEFT = 'left' \n 30. RIGHT = 'right' \n 31.  \n 32. HEAD = 0 # syntactic sugar: index of the worm's head \nSome more constants are set on lines 19 to 32. The HEAD constant will be explained later in this \nchapter. \nThe main() Function \n 34. def main(): \n 35.     global FPSCLOCK, DISPLAYSURF, BASICFONT \n 36.  \n 37.     pygame.init() \n 38.     FPSCLOCK = pygame.time.Clock() \n 39.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 40.     BASICFONT = pygame.font.Font('freesansbold.ttf', 18) \n 41.     pygame.display.set_caption('Wormy') \n 42.  \n 43.     showStartScreen() \n 44.     while True: \n 45.         runGame() \n 46.         showGameOverScreen() \nIn the Wormy game program, we’ve put the main part of the code in a function called \nrunGame(). This is because we only want to show the ―start screen‖ (the animation with the \nrotating ―Wormy‖ text) once when the program starts (by calling the showStartScreen() \n",
      "content_length": 1817,
      "extraction_method": "Direct"
    },
    {
      "page_number": 157,
      "chapter": null,
      "content": "Chapter 6 – Wormy    139 \n \nfunction). Then we want to call runGame(), which will start a game of Wormy. This function \nwill return when the player’s worm collides into a wall or into itself and causes a game over. \nAt that point we will show the game over screen by calling showGameOverScreen(). When \nthat function call returns, the loop goes back to the start and calls runGame() again. The \nwhile loop on line 44 will loop forever until the program terminates. \nA Separate runGame() Function \n 49. def runGame(): \n 50.     # Set a random start point. \n 51.     startx = random.randint(5, CELLWIDTH - 6) \n 52.     starty = random.randint(5, CELLHEIGHT - 6) \n 53.     wormCoords = [{'x': startx,     'y': starty}, \n 54.                   {'x': startx - 1, 'y': starty}, \n 55.                   {'x': startx - 2, 'y': starty}] \n 56.     direction = RIGHT \n 57.  \n 58.     # Start the apple in a random place. \n 59.     apple = getRandomLocation() \nAt the beginning of a game, we want the worm to start in a random position (but not too close to \nthe edges of the board) so we store a random coordinate in startx and starty. (Remember \nthat CELLWIDTH and CELLHEIGHT is the number of cells wide and high the window is, not the \nnumber of pixels wide and high). \nThe body of the worm will be stored in a list of dictionary values. There will be one dictionary \nvalue per body segment of the worm. The dictionary will have keys 'x' and 'y' for the XY \ncoordinates of that body segment. The head of the body to be at startx and starty. The other \ntwo body segments will be one and two cells to the left of the head. \nThe head of the worm will always be the body part at wormCoords[0]. To make this code \nmore readable, we’ve set the HEAD constant to 0 on line 32, so that we can use \nwormCoords[HEAD] instead of wormCoords[0]. \nThe Event Handling Loop \n 61.     while True: # main game loop \n 62.         for event in pygame.event.get(): # event handling loop \n 63.             if event.type == QUIT: \n 64.                 terminate() \n 65.             elif event.type == KEYDOWN: \n 66.                 if (event.key == K_LEFT or event.key == K_a) and direction \n!= RIGHT: \n",
      "content_length": 2170,
      "extraction_method": "Direct"
    },
    {
      "page_number": 158,
      "chapter": null,
      "content": "140    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 67.                     direction = LEFT \n 68.                 elif (event.key == K_RIGHT or event.key == K_d) and \ndirection != LEFT: \n 69.                     direction = RIGHT \n 70.                 elif (event.key == K_UP or event.key == K_w) and direction \n!= DOWN: \n 71.                     direction = UP \n 72.                 elif (event.key == K_DOWN or event.key == K_s) and \ndirection != UP: \n 73.                     direction = DOWN \n 74.                 elif event.key == K_ESCAPE: \n 75.                     terminate() \nLine 61 is the start of the main game loop and line 62 is the start of the event handling loop. If the \nevent is a QUIT event, then we call terminate() (which we’ve defined the same as the \nterminate() function in the previous game programs). \nOtherwise, if the event is a KEYDOWN event, then we check if the key that was pressed down is an \narrow key or a WASD key. We want an additional check so that the worm does not turn in on \nitself. For example, if the worm is moving left, then if the player accidentally presses the right \narrow key, the worm would immediate start going right and crash into itself. \nThat is why we have this check for the current value of the direction variable. That way, if \nthe player accidentally presses an arrow key that would cause them to immediately crash the \nworm, we just ignore that key press. \nCollision Detection \n77.         # check if the worm has hit itself or the edge \n78.         if wormCoords[HEAD]['x'] == -1 or wormCoords[HEAD]['x'] == \nCELLWIDTH or wormCoords[HEAD]['y'] == -1 or wormCoords[HEAD]['y'] == \nCELLHEIGHT: \n79.             return # game over \n80.         for wormBody in wormCoords[1:]: \n81.             if wormBody['x'] == wormCoords[HEAD]['x'] and wormBody['y'] == \nwormCoords[HEAD]['y']: \n82.                 return # game over \nThe worm has crashed when the head has moved off the edge of the grid or when the head moves \nonto a cell that is already occupied by another body segment. \nWe can check if the head has moved off the edge of the grid by seeing if either the X coordinate \nof the head (which is stored in wormCoords[HEAD]['x']) is -1 (which is past the left edge \n",
      "content_length": 2281,
      "extraction_method": "Direct"
    },
    {
      "page_number": 159,
      "chapter": null,
      "content": "Chapter 6 – Wormy    141 \n \nof the grid) or equal to CELLWIDTH (which is past the right edge, since the rightmost X cell \ncoordinate is one less than CELLWIDTH).  \nThe head has also moved off the grid if the Y coordinate of the head (which is stored in \nwormCoords[HEAD]['y']) is either -1 (which is past the top edge) or CELLHEIGHT \n(which is past the bottom edge). \nAll we have to do to end the current game is to return out of runGame(). When runGame() \nreturns to the function call in main(), the next line after the runGame() call (line 46) is the \ncall to showGameOverScreen() which makes the large ―Game Over‖ text appear. This is \nwhy we have the return statement on line 79. \nLine 80 loops through every body segment in wormCoords after the head (which is at index 0. \nThis is why the for loop iterates over wormCoords[1:] instead of just wormCoords). If \nboth the 'x' and 'y' values of the body segment are the same as the 'x' and 'y' of the head, \nthen we also end the game by returning out of the runGame() function. \nDetecting Collisions with the Apple \n 84.         # check if worm has eaten an apply \n 85.         if wormCoords[HEAD]['x'] == apple['x'] and wormCoords[HEAD]['y'] \n== apple['y']: \n 86.             # don't remove worm's tail segment \n 87.             apple = getRandomLocation() # set a new apple somewhere \n 88.         else: \n 89.             del wormCoords[-1] # remove worm's tail segment \nWe do a similar collision detection check between the head of the worm and the apple’s XY \ncoordinates. If they match, we set the coordinates of the apple to a random new location (which \nwe get from the return value of getRandomLocation()). \nIf the head has not collided with an apple, then we delete the last body segment in the \nwormCoords list. Remember that negative integers for indexes count from the end of the list. \nSo while 0 is the index of the first item in the list and 1 is for the second item, -1 is for the last \nitem in the list and -2 is for the second to last item. \nThe code on lines 91 to 100 (described next in the ―Moving the Worm‖ section) will add a new \nbody segment (for the head) in the direction that the worm is going. This will make the worm one \nsegment longer. By not deleting the last body segment when the worm eats an apple, the overall \nlength of the worm increases by one. But when line 89 deletes the last body segment, the size \nremains the same because a new head segment is added right afterwards. \n",
      "content_length": 2466,
      "extraction_method": "Direct"
    },
    {
      "page_number": 160,
      "chapter": null,
      "content": "142    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nMoving the Worm \n 91.         # move the worm by adding a segment in the direction it is moving \n 92.         if direction == UP: \n 93.             newHead = {'x': wormCoords[HEAD]['x'], 'y': \nwormCoords[HEAD]['y'] - 1} \n 94.         elif direction == DOWN: \n 95.             newHead = {'x': wormCoords[HEAD]['x'], 'y': \nwormCoords[HEAD]['y'] + 1} \n 96.         elif direction == LEFT: \n 97.             newHead = {'x': wormCoords[HEAD]['x'] - 1, 'y': \nwormCoords[HEAD]['y']} \n 98.         elif direction == RIGHT: \n 99.             newHead = {'x': wormCoords[HEAD]['x'] + 1, 'y': \nwormCoords[HEAD]['y']} \n100.         wormCoords.insert(0, newHead) \nTo move the worm, we add a new body segment to the beginning of the wormCoords list. \nBecause the body segment is being added to the beginning of the list, it will become the new \nhead. The coordinates of the new head will be right next to the old head’s coordinates. Whether 1 \nis added or subtracted from either the X or Y coordinate depends on the direction the worm was \ngoing. \nThis new head segment is added to wormCoords with the insert() list method on line 100. \nThe insert() List Method \nUnlike the append() list method that can only add items to the end of a list, the insert() list \nmethod can add items anywhere inside the list. The first parameter for insert() is the index \nwhere the item should go (all the items originally at this index and after have their indexes \nincrease by one). If the argument passed for the first parameter is larger than the length of the list, \nthe item is simply added to the end of the list (just like what append() does). The second \nparameter for insert() is the item value to be added. Type the following into the interactive \nshell to see how insert() works: \n>>> spam = ['cat', 'dog', 'bat'] \n>>> spam.insert(0, 'frog') \n>>> spam \n['frog', 'cat', 'dog', 'bat'] \n>>> spam.insert(10, 42) \n>>> spam \n['frog', 'cat', 'dog', 'bat', 42] \n>>> spam.insert(2, 'horse') \n>>> spam \n['frog', 'cat', 'horse', 'dog', 'bat', 42] \n",
      "content_length": 2119,
      "extraction_method": "Direct"
    },
    {
      "page_number": 161,
      "chapter": null,
      "content": "Chapter 6 – Wormy    143 \n \n>>> \nDrawing the Screen \n101.         DISPLAYSURF.fill(BGCOLOR) \n102.         drawGrid() \n103.         drawWorm(wormCoords) \n104.         drawApple(apple) \n105.         drawScore(len(wormCoords) - 3) \n106.         pygame.display.update() \n107.         FPSCLOCK.tick(FPS) \nThe code for drawing the screen in the runGame() function is fairly simple. Line 101 fills in \nthe entire display Surface with the background color. Lines 102 to 105 draw the grid, worm, \napple, and score to the display Surface. Then the call to pygame.display.update() draws \nthe display Surface to the actual computer screen. \nDrawing “Press a key” Text to the Screen \n109. def drawPressKeyMsg(): \n110.     pressKeySurf = BASICFONT.render('Press a key to play.', True, \nDARKGRAY) \n111.     pressKeyRect = pressKeySurf.get_rect() \n112.     pressKeyRect.topleft = (WINDOWWIDTH - 200, WINDOWHEIGHT - 30) \n113.     DISPLAYSURF.blit(pressKeySurf, pressKeyRect) \nWhile the start screen animation is playing or the game over screen is being shown, there will be \nsome small text in the bottom right corner that says ―Press a key to play.‖ Rather than have the \ncode typed out in both the showStartScreen() and the showGameOverScreen(), we \nput it in a this separate function and simply call the function from showStartScreen() and \nshowGameOverScreen(). \nThe checkForKeyPress() Function \n116. def checkForKeyPress(): \n117.     if len(pygame.event.get(QUIT)) > 0: \n118.         terminate() \n119.  \n120.     keyUpEvents = pygame.event.get(KEYUP) \n121.     if len(keyUpEvents) == 0: \n122.         return None \n123.     if keyUpEvents[0].key == K_ESCAPE: \n124.         terminate() \n125.     return keyUpEvents[0].key \n",
      "content_length": 1709,
      "extraction_method": "Direct"
    },
    {
      "page_number": 162,
      "chapter": null,
      "content": "144    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThis function first checks if there are any QUIT events in the event queue. The call to \npygame.event.get() on line 117 returns a list of all the QUIT events in the event queue \n(because we pass QUIT as an argument). If there are not QUIT events in the event queue, then \nthe list that pygame.event.get() returns will be the empty list: [] \nThe len() call on line 117 will return 0 if pygame.event.get() returned an empty list. If \nthere are more than zero items in the list returned by pygame.event.get() (and remember, \nany items in this list will only be QUIT events because we passed QUIT as the argument to \npygame.event.get()), then the terminate() function gets called on line 118 and the \nprogram terminates. \nAfter that, the call to pygame.event.get() gets a list of any KEYUP events in the event \nqueue. If the key event is for the Esc key, then the program terminates in that case as well. \nOtherwise, the first key event object in the list that was returned by pygame.event.get() is \nreturned from this checkForKeyPress() function. \nThe Start Screen \n128. def showStartScreen(): \n129.     titleFont = pygame.font.Font('freesansbold.ttf', 100) \n130.     titleSurf1 = titleFont.render('Wormy!', True, WHITE, DARKGREEN) \n131.     titleSurf2 = titleFont.render('Wormy!', True, GREEN) \n132.  \n133.     degrees1 = 0 \n134.     degrees2 = 0 \n135.     while True: \n136.         DISPLAYSURF.fill(BGCOLOR) \nWhen the Wormy game program first begins running, the player doesn’t automatically begin \nplaying the game. Instead, a start screen appears which tells the player what program they are \nrunning. A start screen also gives the player a chance to prepare for the game to begin (otherwise \nthe player might not be ready and crash on their first game). \nThe Wormy start screen requires two Surface objects with the ―Wormy!‖ text drawn on them. \nThese are what the render() method calls create on lines 130 and 131. The text will be large: \nthe Font() constructor function call on line 129 creates a Font object that is 100 points in size. \nThe first ―Wormy!‖ text will have white text with a dark green background, and the other will \nhave green text with a transparent background. \nLine 135 begins the animation loop for the start screen. During this animation, the two pieces of \ntext will be rotated and drawn to the display Surface object. \n",
      "content_length": 2451,
      "extraction_method": "Direct"
    },
    {
      "page_number": 163,
      "chapter": null,
      "content": "Chapter 6 – Wormy    145 \n \nRotating the Start Screen Text \n137.         rotatedSurf1 = pygame.transform.rotate(titleSurf1, degrees1) \n138.         rotatedRect1 = rotatedSurf1.get_rect() \n139.         rotatedRect1.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2) \n140.         DISPLAYSURF.blit(rotatedSurf1, rotatedRect1) \n141.  \n142.         rotatedSurf2 = pygame.transform.rotate(titleSurf2, degrees2) \n143.         rotatedRect2 = rotatedSurf2.get_rect() \n144.         rotatedRect2.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2) \n145.         DISPLAYSURF.blit(rotatedSurf2, rotatedRect2) \n146.  \n147.         drawPressKeyMsg() \n148.  \n149.         if checkForKeyPress(): \n150.             pygame.event.get() # clear event queue \n151.             return \n152.         pygame.display.update() \n153.         FPSCLOCK.tick(FPS) \nThe showStartScreen() function will rotate the images on the Surface objects that the \n―Wormy!‖ text is written on. The first parameter is the Surface object to make a rotated copy of. \nThe second parameter is the number of degrees to rotate the Surface. The \npygame.transform.rotate() function doesn’t change the Surface object you pass it, but \nrather returns a new Surface object with the rotated image drawn on it. \nNote that this new Surface object will probably be larger than the original one, since all Surface \nobjects represent rectangular areas and the corners of the rotated Surface will stick out past the \nwidth and height of original Surface. The picture below has a black rectangle along with a \nslightly rotated version of itself. In order to make a Surface object that can fit the rotated \nrectangle (which is colored gray in the picture below), it must be larger than the original black \nrectangle’s Surface object: \n \nThe amount you rotate it is given in degrees, which is a measure of rotation. There are 360 \ndegrees in a circle. Not rotated at all is 0 degrees. Rotating to one quarter counter-clockwise is 90 \ndegrees. To rotate clockwise, pass a negative integer. Rotating 360 degrees is rotating the image \nall the way around, which means you end up with the same image as if you rotated it 0 degrees. In \nfact, if the rotation argument you pass to pygame.transform.rotate() is 360 or larger, \n",
      "content_length": 2241,
      "extraction_method": "Direct"
    },
    {
      "page_number": 164,
      "chapter": null,
      "content": "146    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nthen Pygame automatically keeps subtracting 360 from it until it gets a number less than 360. \nThis image shows several examples of different rotation amounts: \n \nThe two rotated ―Wormy!‖ Surface objects are blitted to the display Surface on each frame of the \nanimation loop on lines 140 and 145. \nOn line 147 the drawPressKeyMsg() function call draws the ―Press a key to play.‖ text in the \nlower corner of the display Surface object. This animation loop will keep looping until \ncheckForKeyPress() returns a value that is not None, which happens if the player presses a \nkey. Before returning, pygame.event.get() is called simply to clear out any other events \nthat have accumulated in the event queue which the start screen was displayed. \nRotations Are Not Perfect \nYou may wonder why we store the rotated Surface in a separate variable, rather than just \noverwrite the titleSurf1 and titleSurf2 variables. There are two reasons. \nFirst, rotating a 2D image is never completely perfect. The rotated image is always approximate. \nIf you rotate an image by 10 degrees counterclockwise, and then rotate it back 10 degrees \nclockwise, the image you have will not be the exact same image you started with. Think of it as \nmaking a photocopy, and then a photocopy of the first photocopy, and the another photocopy of \nthat photocopy. If you keep doing this, the image gets worse and worse as the slight distortions \nadd up. \n(The only exception to this is if you rotate an image by a multiple of 90 degrees, such as 0, 90, \n180, 270, or 360 degrees. In that case, the pixels can be rotated without any distortion.) \nSecond, if you rotate a 2D image then the rotated image will be slightly larger than the original \nimage. If you rotate that rotated image, then the next rotated image will be slightly larger again. If \nyou keep doing this, eventually the image will become too large for Pygame to handle, and your \n",
      "content_length": 2017,
      "extraction_method": "Direct"
    },
    {
      "page_number": 165,
      "chapter": null,
      "content": "Chapter 6 – Wormy    147 \n \nprogram will crash with the error message, pygame.error: Width or height is too \nlarge. \n154.         degrees1 += 3 # rotate by 3 degrees each frame \n155.         degrees2 += 7 # rotate by 7 degrees each frame \nThe amount that we rotate the two ―Wormy!‖ text Surface objects is stored in degrees1 and \ndegrees2. On each iteration through the animation loop, we increase the number stored in \ndegrees1 by 3 and degrees2 by 7. This means on the next iteration of the animation loop \nthe white text ―Wormy!‖ Surface object will be rotated by another 3 degrees and the green text \n―Wormy!‖ Surface object will be rotated by another 7 degrees. This is why the one of the Surface \nobjects rotates slower than the other. \n158. def terminate(): \n159.     pygame.quit() \n160.     sys.exit() \nThe terminate() function calls pygame.quit() and sys.exit() so that the game \ncorrectly shuts down. It is identical to the terminate() functions in the previous game \nprograms. \nDeciding Where the Apple Appears \n163. def getRandomLocation(): \n164.     return {'x': random.randint(0, CELLWIDTH - 1), 'y': random.randint(0, \nCELLHEIGHT - 1)} \nThe getRandomLocation() function is called whenever new coordinates for the apple are \nneeded. This function returns a dictionary with keys 'x' and 'y', with the values set to random \nXY coordinates. \nGame Over Screens \n167. def showGameOverScreen(): \n168.     gameOverFont = pygame.font.Font('freesansbold.ttf', 150) \n169.     gameSurf = gameOverFont.render('Game', True, WHITE) \n170.     overSurf = gameOverFont.render('Over', True, WHITE) \n171.     gameRect = gameSurf.get_rect() \n172.     overRect = overSurf.get_rect() \n173.     gameRect.midtop = (WINDOWWIDTH / 2, 10) \n174.     overRect.midtop = (WINDOWWIDTH / 2, gameRect.height + 10 + 25) \n175.  \n176.     DISPLAYSURF.blit(gameSurf, gameRect) \n",
      "content_length": 1854,
      "extraction_method": "Direct"
    },
    {
      "page_number": 166,
      "chapter": null,
      "content": "148    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n177.     DISPLAYSURF.blit(overSurf, overRect) \n178.     drawPressKeyMsg() \n179.     pygame.display.update() \nThe game over screen is similar to the start screen, except it isn’t animated. The words ―Game‖ \nand ―Over‖ are rendered to two Surface objects which are then drawn on the screen. \n180.     pygame.time.wait(500) \n181.     checkForKeyPress() # clear out any key presses in the event queue \n182.  \n183.     while True: \n184.         if checkForKeyPress(): \n185.             pygame.event.get() # clear event queue \n186.             return \nThe Game Over text will stay on the screen until the player pushes a key. Just to make sure the \nplayer doesn’t accidentally press a key too soon, we will put a half second pause with the call to \npygame.time.wait() on line 180. (The 500 argument stands for a 500 millisecond pause, \nwhich is half of one second.)  \nThen, checkForKeyPress() is called so that any key events that were made since the \nshowGameOverScreen() function started are ignored. This pause and dropping of the key \nevents is to prevent the following situation: Say the player was trying to turn away from the edge \nof the screen at the last minute, but pressed the key too late and crashed into the edge of the \nboard. If this happens, then the key press would have happened after the \nshowGameOverScreen() was called, and that key press would cause the game over screen to \ndisappear almost instantly. The next game would start immediately after that, and might take the \nplayer by surprise. Adding this pause helps the make the game more ―user friendly‖. \nDrawing Functions \nThe code to draw the score, worm, apple, and grid are all put into separate functions. \n188. def drawScore(score): \n189.     scoreSurf = BASICFONT.render('Score: %s' % (score), True, WHITE) \n190.     scoreRect = scoreSurf.get_rect() \n191.     scoreRect.topleft = (WINDOWWIDTH - 120, 10) \n192.     DISPLAYSURF.blit(scoreSurf, scoreRect) \nThe drawScore() function simply renders and draws the text of the score that was passed in \nits score parameter on the display Surface object. \n",
      "content_length": 2179,
      "extraction_method": "Direct"
    },
    {
      "page_number": 167,
      "chapter": null,
      "content": "Chapter 6 – Wormy    149 \n \n195. def drawWorm(wormCoords): \n196.     for coord in wormCoords: \n197.         x = coord['x'] * CELLSIZE \n198.         y = coord['y'] * CELLSIZE \n199.         wormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \n200.         pygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \n201.         wormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, \nCELLSIZE - 8) \n202.         pygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nThe drawWorm() function will draw a green box for each of the segments of the worm’s body. \nThe segments are passed in the wormCoords parameter, which is a list of dictionaries each with \nan 'x' key and a 'y' key. The for loop on line 196 loops through each of the dictionary values \nin wormCoords. \nBecause the grid coordinates take up the entire window and also begin a 0, 0 pixel, it is fairly \neasy to convert from grid coordinates to pixel coordinates. Line 197 and 198 simply multiply the \ncoord['x'] and coord['y'] coordinate by the CELLSIZE. \nLine 199 creates a Rect object for the worm segment that will be passed to the \npygame.draw.rect() function on line 200. Remember that each cell in the grid is \nCELLSIZE in width and height, so that’s what the size of the segment’s Rect object should be. \nLine 200 draws a dark green rectangle for the segment. Then on top of this, a smaller bright green \nrectangle is drawn. This makes the worm look a little nicer.  \nThe inner bright green rectangle starts 4 pixels to the right and 4 pixels below the topleft corner of \nthe cell. The width and height of this rectangle are 8 pixels less than the cell size, so there will be \na 4 pixel margin on the right and bottom sides as well. \n205. def drawApple(coord): \n206.     x = coord['x'] * CELLSIZE \n207.     y = coord['y'] * CELLSIZE \n208.     appleRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \n209.     pygame.draw.rect(DISPLAYSURF, RED, appleRect) \nThe drawApple() function is very similar to drawWorm(), except since the red apple is just \na single rectangle that fills up the cell, all the function needs to do is convert to pixel coordinates \n(which is what lines 206 and 207 do), create the Rect object with the location and size of the \napple (line 208), and then pass this Rect object to the pygame.draw.rect() function. \n212. def drawGrid(): \n213.     for x in range(0, WINDOWWIDTH, CELLSIZE): # draw vertical lines \n",
      "content_length": 2409,
      "extraction_method": "Direct"
    },
    {
      "page_number": 168,
      "chapter": null,
      "content": "150    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n214.         pygame.draw.line(DISPLAYSURF, DARKGRAY, (x, 0), (x, WINDOWHEIGHT)) \n215.     for y in range(0, WINDOWHEIGHT, CELLSIZE): # draw horizontal lines \n216.         pygame.draw.line(DISPLAYSURF, DARKGRAY, (0, y), (WINDOWWIDTH, y)) \nJust to make it easier to visualize the grid of cells, we call pygame.draw.line() to draw out \neach of the vertical and horizontal lines of the grid. \nNormally, to draw the 32 vertical lines needed, we would need 32 calls to \npygame.draw.line() with the following coordinates: \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 0), (0, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (20, 0), (20, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (40, 0), (40, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (60, 0), (60, WINDOWHEIGHT)) \n...skipped for brevity... \npygame.draw.line(DISPLAYSURF, DARKGRAY, (560, 0), (560, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (580, 0), (580, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (600, 0), (600, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (620, 0), (620, WINDOWHEIGHT)) \nInstead of typing out all these lines of code, we can just have one line of code inside a for loop. \nNotice that the pattern for the vertical lines is that the X coordinate of the start and end point \nstarts at 0 and goes up to 620, increasing by 20 each time. The Y coordinate is always 0 for the \nstart point and WINDOWHEIGHT for the end point parameter. That means the for loop should \niterate over range(0, 640, 20). This is why the for loop on line 213 iterates over \nrange(0, WINDOWWIDTH, CELLSIZE). \nFor the horizontal lines, the coordinates would have to be: \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 0), (WINDOWWIDTH, 0)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 20), (WINDOWWIDTH, 20)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 40), (WINDOWWIDTH, 40)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 60), (WINDOWWIDTH, 60)) \n...skipped for brevity... \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 400), (WINDOWWIDTH, 400)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 420), (WINDOWWIDTH, 420)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 440), (WINDOWWIDTH, 440)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 460), (WINDOWWIDTH, 460)) \nThe Y coordinate ranges from 0 to 460, increasing by 20 each time. The X coordinate is always \n0 for the start point and WINDOWWIDTH for the end point parameter. We can also use a for loop \nhere so we don’t have to type out all those pygame.draw.line() calls. \n",
      "content_length": 2626,
      "extraction_method": "Direct"
    },
    {
      "page_number": 169,
      "chapter": null,
      "content": "Chapter 6 – Wormy    151 \n \nNoticing regular patterns needed by the calls and using loops is a clever programmer trick to save \nus from a lot of typing. We could have typed out all 56 pygame.draw.line() calls and the \nprogram would have worked the exact same. But by being a little bit clever, we can save \nourselves a lot of work. \n219. if __name__ == '__main__': \n220.     main() \nAfter all the functions and constants and global variables have been defined and created, the \nmain() function is called to start the game. \nDon’t Reuse Variable Names \nTake a look at a few lines of code from the drawWorm() function again: \n199.         wormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \n200.         pygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \n201.         wormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, \nCELLSIZE - 8) \n202.         pygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nNotice that two different Rect objects are created on lines 199 and 201. The Rect object created \non line 199 is stored in the wormSegmentRect local variable and is passed to the \npygame.draw.rect() function on line 200. The Rect object created on line 201 is stored in \nthe wormInnerSegmentRect local variable and is passed to the pygame.draw.rect() \nfunction on line 202. \nEvery time you create a variable, it takes up a small amount of the computer’s memory. You \nmight think it would be clever to reuse the wormSegmentRect variable for both Rect objects, \nlike this: \n199.         wormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \n200.         pygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \n201.         wormSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, CELLSIZE \n- 8) \n202.         pygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nBecause the Rect object returned by pygame.Rect() on line 199 won’t be needed after 200, \nwe can overwrite this value and reuse the variable to store the Rect object returned by \npygame.Rect() on line 201. Since we are now using fewer variables we are saving memory, \nright? \n",
      "content_length": 2081,
      "extraction_method": "Direct"
    },
    {
      "page_number": 170,
      "chapter": null,
      "content": "152    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nWhile this is technically true, you really are only saving a few bytes. Modern computers have \nmemory of several billion bytes. So the savings aren’t that great. Meanwhile, reusing variables \nreduces the code readability. If a programmer was reading through this code after it was written, \nthey would see that wormSegmentRect is passed to the pygame.draw.rect() calls on \nline 200 and 202. If they tried to find the first time the wormSegmentRect variable was \nassigned a value, they would see the pygame.Rect() call on line 199. They might not realize \nthat the Rect object returned by line 199’s pygame.Rect() call isn’t the same as the one that is \npassed to the pygame.draw.rect() call on line 202. \nLittle things like this make it harder to understand how exactly your program works. It won’t just \nbe other programmers looking at your code who will be confused. When you look at your own \ncode a couple weeks after writing it, you may have a hard time remembering how exactly it \nworks. Code readability is much more important than saving a few bytes of memory here and \nthere. \nFor additional programming practice, you can download buggy versions of Wormy from \nhttp://invpy.com/buggy/wormy and try to figure out how to fix the bugs. \n \n \n",
      "content_length": 1350,
      "extraction_method": "Direct"
    },
    {
      "page_number": 171,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    153 \n \nCHAPTER 7 - TETROMINO \n \nHow to Play Tetromino \nTetromino is a Tetris clone. Differently shaped blocks (each made up of four boxes) fall from the \ntop of the screen, and the player must guide them down to form complete rows that have no gaps \nin them. When a complete row is formed, the row disappears and each row above it moves down \none row. The player tries to keep forming complete lines until the screen fills up and a new \nfalling block cannot fit on the screen. \nSome Tetromino Nomenclature \nIn this chapter, I have come up with a set of terms for the different things in the game program. \n \nBoard – The board is made up of 10 x 20 spaces that the blocks fall and stack up in. \n \nBox – A box is a single filled-in square space on the board. \n \nPiece – The things that fall from the top of the board that the player can rotate and \nposition. Each piece has a shape and is made up of 4 boxes. \n \nShape – The shapes are the different types of pieces in the game. The names of the \nshapes are T, S, Z, J, L, I, and O. \n \n",
      "content_length": 1062,
      "extraction_method": "Direct"
    },
    {
      "page_number": 172,
      "chapter": null,
      "content": "154    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nTemplate – A list of shape data structures that represents all the possible rotations of a \nshape. These are store in variables with names like S_SHAPE_TEMPLATE or \nJ_SHAPE_TEMPLATE. \n \nLanded – When a piece has either reached the bottom of the board or is touching a box \non the board, we say that the piece has landed. At that point, the next piece should start \nfalling. \nSource Code to Tetromino \nThis source code can be downloaded from http://invpy.com/tetromino.py. If you get any error \nmessages, look at the line number that is mentioned in the error message and check your code for \nany typos. You can also copy and paste your code into the web form at \nhttp://invpy.com/diff/tetromino to see if the differences between your code and the code in the \nbook. \nYou will also need the background music files in the same folder of as the tetromino.py file. You \ncan download them from here: \n \nhttp://invpy.com/tetrisb.mid \n \nhttp://invpy.com/tetrisc.mid \n  1. # Tetromino (a Tetris clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, time, pygame, sys \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 25 \n 10. WINDOWWIDTH = 640 \n 11. WINDOWHEIGHT = 480 \n 12. BOXSIZE = 20 \n 13. BOARDWIDTH = 10 \n 14. BOARDHEIGHT = 20 \n 15. BLANK = '.' \n 16.  \n 17. MOVESIDEWAYSFREQ = 0.15 \n 18. MOVEDOWNFREQ = 0.1 \n 19.  \n 20. XMARGIN = int((WINDOWWIDTH - BOARDWIDTH * BOXSIZE) / 2) \n 21. TOPMARGIN = WINDOWHEIGHT - (BOARDHEIGHT * BOXSIZE) - 5 \n 22.  \n 23. #               R    G    B \n",
      "content_length": 1701,
      "extraction_method": "Direct"
    },
    {
      "page_number": 173,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    155 \n \n 24. WHITE       = (255, 255, 255) \n 25. GRAY        = (185, 185, 185) \n 26. BLACK       = (  0,   0,   0) \n 27. RED         = (155,   0,   0) \n 28. LIGHTRED    = (175,  20,  20) \n 29. GREEN       = (  0, 155,   0) \n 30. LIGHTGREEN  = ( 20, 175,  20) \n 31. BLUE        = (  0,   0, 155) \n 32. LIGHTBLUE   = ( 20,  20, 175) \n 33. YELLOW      = (155, 155,   0) \n 34. LIGHTYELLOW = (175, 175,  20) \n 35.  \n 36. BORDERCOLOR = BLUE \n 37. BGCOLOR = BLACK \n 38. TEXTCOLOR = WHITE \n 39. TEXTSHADOWCOLOR = GRAY \n 40. COLORS      = (     BLUE,      GREEN,      RED,      YELLOW) \n 41. LIGHTCOLORS = (LIGHTBLUE, LIGHTGREEN, LIGHTRED, LIGHTYELLOW) \n 42. assert len(COLORS) == len(LIGHTCOLORS) # each color must have light color \n 43.  \n 44. TEMPLATEWIDTH = 5 \n 45. TEMPLATEHEIGHT = 5 \n 46.  \n 47. S_SHAPE_TEMPLATE = [['.....', \n 48.                      '.....', \n 49.                      '..OO.', \n 50.                      '.OO..', \n 51.                      '.....'], \n 52.                     ['.....', \n 53.                      '..O..', \n 54.                      '..OO.', \n 55.                      '...O.', \n 56.                      '.....']] \n 57.  \n 58. Z_SHAPE_TEMPLATE = [['.....', \n 59.                      '.....', \n 60.                      '.OO..', \n 61.                      '..OO.', \n 62.                      '.....'], \n 63.                     ['.....', \n 64.                      '..O..', \n 65.                      '.OO..', \n 66.                      '.O...', \n 67.                      '.....']] \n 68.  \n 69. I_SHAPE_TEMPLATE = [['..O..', \n",
      "content_length": 1586,
      "extraction_method": "Direct"
    },
    {
      "page_number": 174,
      "chapter": null,
      "content": "156    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 70.                      '..O..', \n 71.                      '..O..', \n 72.                      '..O..', \n 73.                      '.....'], \n 74.                     ['.....', \n 75.                      '.....', \n 76.                      'OOOO.', \n 77.                      '.....', \n 78.                      '.....']] \n 79.  \n 80. O_SHAPE_TEMPLATE = [['.....', \n 81.                      '.....', \n 82.                      '.OO..', \n 83.                      '.OO..', \n 84.                      '.....']] \n 85.  \n 86. J_SHAPE_TEMPLATE = [['.....', \n 87.                      '.O...', \n 88.                      '.OOO.', \n 89.                      '.....', \n 90.                      '.....'], \n 91.                     ['.....', \n 92.                      '..OO.', \n 93.                      '..O..', \n 94.                      '..O..', \n 95.                      '.....'], \n 96.                     ['.....', \n 97.                      '.....', \n 98.                      '.OOO.', \n 99.                      '...O.', \n100.                      '.....'], \n101.                     ['.....', \n102.                      '..O..', \n103.                      '..O..', \n104.                      '.OO..', \n105.                      '.....']] \n106.  \n107. L_SHAPE_TEMPLATE = [['.....', \n108.                      '...O.', \n109.                      '.OOO.', \n110.                      '.....', \n111.                      '.....'], \n112.                     ['.....', \n113.                      '..O..', \n114.                      '..O..', \n115.                      '..OO.', \n",
      "content_length": 1680,
      "extraction_method": "Direct"
    },
    {
      "page_number": 175,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    157 \n \n116.                      '.....'], \n117.                     ['.....', \n118.                      '.....', \n119.                      '.OOO.', \n120.                      '.O...', \n121.                      '.....'], \n122.                     ['.....', \n123.                      '.OO..', \n124.                      '..O..', \n125.                      '..O..', \n126.                      '.....']] \n127.  \n128. T_SHAPE_TEMPLATE = [['.....', \n129.                      '..O..', \n130.                      '.OOO.', \n131.                      '.....', \n132.                      '.....'], \n133.                     ['.....', \n134.                      '..O..', \n135.                      '..OO.', \n136.                      '..O..', \n137.                      '.....'], \n138.                     ['.....', \n139.                      '.....', \n140.                      '.OOO.', \n141.                      '..O..', \n142.                      '.....'], \n143.                     ['.....', \n144.                      '..O..', \n145.                      '.OO..', \n146.                      '..O..', \n147.                      '.....']] \n148.  \n149. SHAPES = {'S': S_SHAPE_TEMPLATE, \n150.           'Z': Z_SHAPE_TEMPLATE, \n151.           'J': J_SHAPE_TEMPLATE, \n152.           'L': L_SHAPE_TEMPLATE, \n153.           'I': I_SHAPE_TEMPLATE, \n154.           'O': O_SHAPE_TEMPLATE, \n155.           'T': T_SHAPE_TEMPLATE} \n156.  \n157. \n158. def main(): \n159.     global FPSCLOCK, DISPLAYSURF, BASICFONT, BIGFONT \n160.     pygame.init() \n161.     FPSCLOCK = pygame.time.Clock() \n",
      "content_length": 1597,
      "extraction_method": "Direct"
    },
    {
      "page_number": 176,
      "chapter": null,
      "content": "158    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n162.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n163.     BASICFONT = pygame.font.Font('freesansbold.ttf', 18) \n164.     BIGFONT = pygame.font.Font('freesansbold.ttf', 100) \n165.     pygame.display.set_caption('Tetromino') \n166.  \n167.     showTextScreen('Tetromino') \n168.     while True: # game loop \n169.         if random.randint(0, 1) == 0: \n170.             pygame.mixer.music.load('tetrisb.mid') \n171.         else: \n172.             pygame.mixer.music.load('tetrisc.mid') \n173.         pygame.mixer.music.play(-1, 0.0) \n174.         runGame() \n175.         pygame.mixer.music.stop() \n176.         showTextScreen('Game Over') \n177.  \n178.  \n179. def runGame(): \n180.     # setup variables for the start of the game \n181.     board = getBlankBoard() \n182.     lastMoveDownTime = time.time() \n183.     lastMoveSidewaysTime = time.time() \n184.     lastFallTime = time.time() \n185.     movingDown = False # note: there is no movingUp variable \n186.     movingLeft = False \n187.     movingRight = False \n188.     score = 0 \n189.     level, fallFreq = calculateLevelAndFallFreq(score) \n190.  \n191.     fallingPiece = getNewPiece() \n192.     nextPiece = getNewPiece() \n193.  \n194.     while True: # main game loop \n195.         if fallingPiece == None: \n196.             # No falling piece in play, so start a new piece at the top \n197.             fallingPiece = nextPiece \n198.             nextPiece = getNewPiece() \n199.             lastFallTime = time.time() # reset lastFallTime \n200.  \n201.             if not isValidPosition(board, fallingPiece): \n202.                 return # can't fit a new piece on the board, so game over \n203.  \n204.         checkForQuit() \n205.         for event in pygame.event.get(): # event handling loop \n206.             if event.type == KEYUP: \n207.                 if (event.key == K_p): \n",
      "content_length": 1958,
      "extraction_method": "Direct"
    },
    {
      "page_number": 177,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    159 \n \n208.                     # Pausing the game \n209.                     DISPLAYSURF.fill(BGCOLOR) \n210.                     pygame.mixer.music.stop() \n211.                     showTextScreen('Paused') # pause until a key press \n212.                     pygame.mixer.music.play(-1, 0.0) \n213.                     lastFallTime = time.time() \n214.                     lastMoveDownTime = time.time() \n215.                     lastMoveSidewaysTime = time.time() \n216.                 elif (event.key == K_LEFT or event.key == K_a): \n217.                     movingLeft = False \n218.                 elif (event.key == K_RIGHT or event.key == K_d): \n219.                     movingRight = False \n220.                 elif (event.key == K_DOWN or event.key == K_s): \n221.                     movingDown = False \n222.  \n223.             elif event.type == KEYDOWN: \n224.                 # moving the block sideways \n225.                 if (event.key == K_LEFT or event.key == K_a) and \nisValidPosition(board, fallingPiece, adjX=-1): \n226.                     fallingPiece['x'] -= 1 \n227.                     movingLeft = True \n228.                     movingRight = False \n229.                     lastMoveSidewaysTime = time.time() \n230. \n231.                 elif (event.key == K_RIGHT or event.key == K_d) and \nisValidPosition(board, fallingPiece, adjX=1): \n232.                     fallingPiece['x'] += 1 \n233.                     movingRight = True \n234.                     movingLeft = False \n235.                     lastMoveSidewaysTime = time.time() \n236.  \n237.                 # rotating the block (if there is room to rotate) \n238.                 elif (event.key == K_UP or event.key == K_w): \n239.                     fallingPiece['rotation'] = (fallingPiece['rotation'] + \n1) % len(SHAPES[fallingPiece['shape']]) \n240.                     if not isValidPosition(board, fallingPiece): \n241.                         fallingPiece['rotation'] = \n(fallingPiece['rotation'] - 1) % len(SHAPES[fallingPiece['shape']]) \n242.                 elif (event.key == K_q): # rotate the other direction \n243.                     fallingPiece['rotation'] = (fallingPiece['rotation'] - \n1) % len(SHAPES[fallingPiece['shape']]) \n244.                     if not isValidPosition(board, fallingPiece): \n245.                         fallingPiece['rotation'] = \n(fallingPiece['rotation'] + 1) % len(SHAPES[fallingPiece['shape']]) \n246.  \n247.                 # making the block fall faster with the down key \n",
      "content_length": 2523,
      "extraction_method": "Direct"
    },
    {
      "page_number": 178,
      "chapter": null,
      "content": "160    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n248.                 elif (event.key == K_DOWN or event.key == K_s): \n249.                     movingDown = True \n250.                     if isValidPosition(board, fallingPiece, adjY=1): \n251.                         fallingPiece['y'] += 1 \n252.                     lastMoveDownTime = time.time() \n253.  \n254.                 # move the current block all the way down \n255.                 elif event.key == K_SPACE: \n256.                     movingDown = False \n257.                     movingLeft = False \n258.                     movingRight = False \n259.                     for i in range(1, BOARDHEIGHT): \n260.                         if not isValidPosition(board, fallingPiece, \nadjY=i): \n261.                             break \n262.                     fallingPiece['y'] += i - 1 \n263.  \n264.         # handle moving the block because of user input \n265.         if (movingLeft or movingRight) and time.time() - \nlastMoveSidewaysTime > MOVESIDEWAYSFREQ: \n266.             if movingLeft and isValidPosition(board, fallingPiece, adjX=-\n1): \n267.                 fallingPiece['x'] -= 1 \n268.             elif movingRight and isValidPosition(board, fallingPiece, \nadjX=1): \n269.                 fallingPiece['x'] += 1 \n270.             lastMoveSidewaysTime = time.time() \n271.  \n272.         if movingDown and time.time() - lastMoveDownTime > MOVEDOWNFREQ \nand isValidPosition(board, fallingPiece, adjY=1): \n273.             fallingPiece['y'] += 1 \n274.             lastMoveDownTime = time.time() \n275.  \n276.         # let the piece fall if it is time to fall \n277.         if time.time() - lastFallTime > fallFreq: \n278.             # see if the piece has landed \n279.             if not isValidPosition(board, fallingPiece, adjY=1): \n280.                 # falling piece has landed, set it on the board \n281.                 addToBoard(board, fallingPiece) \n282.                 score += removeCompleteLines(board) \n283.                 level, fallFreq = calculateLevelAndFallFreq(score) \n284.                 fallingPiece = None \n285.             else: \n286.                 # piece did not land, just move the block down \n287.                 fallingPiece['y'] += 1 \n288.                 lastFallTime = time.time() \n",
      "content_length": 2329,
      "extraction_method": "Direct"
    },
    {
      "page_number": 179,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    161 \n \n289.  \n290.         # drawing everything on the screen \n291.         DISPLAYSURF.fill(BGCOLOR) \n292.         drawBoard(board) \n293.         drawStatus(score, level) \n294.         drawNextPiece(nextPiece) \n295.         if fallingPiece != None: \n296.             drawPiece(fallingPiece) \n297.  \n298.         pygame.display.update() \n299.         FPSCLOCK.tick(FPS) \n300.  \n301.  \n302. def makeTextObjs(text, font, color): \n303.     surf = font.render(text, True, color) \n304.     return surf, surf.get_rect() \n305.  \n306.  \n307. def terminate(): \n308.     pygame.quit() \n309.     sys.exit() \n310.  \n311.  \n312. def checkForKeyPress(): \n313.     # Go through event queue looking for a KEYUP event. \n314.     # Grab KEYDOWN events to remove them from the event queue. \n315.     checkForQuit() \n316. \n317.     for event in pygame.event.get([KEYDOWN, KEYUP]): \n318.         if event.type == KEYDOWN: \n319.             continue \n320.         return event.key \n321.     return None \n322.  \n323.  \n324. def showTextScreen(text): \n325.     # This function displays large text in the \n326.     # center of the screen until a key is pressed. \n327.     # Draw the text drop shadow \n328.     titleSurf, titleRect = makeTextObjs(text, BIGFONT, TEXTSHADOWCOLOR) \n329.     titleRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2)) \n330.     DISPLAYSURF.blit(titleSurf, titleRect) \n331.  \n332.     # Draw the text \n333.     titleSurf, titleRect = makeTextObjs(text, BIGFONT, TEXTCOLOR) \n",
      "content_length": 1508,
      "extraction_method": "Direct"
    },
    {
      "page_number": 180,
      "chapter": null,
      "content": "162    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n334.     titleRect.center = (int(WINDOWWIDTH / 2) - 3, int(WINDOWHEIGHT / 2) - \n3) \n335.     DISPLAYSURF.blit(titleSurf, titleRect) \n336.  \n337.     # Draw the additional \"Press a key to play.\" text. \n338.     pressKeySurf, pressKeyRect = makeTextObjs('Press a key to play.', \nBASICFONT, TEXTCOLOR) \n339.     pressKeyRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2) + \n100) \n340.     DISPLAYSURF.blit(pressKeySurf, pressKeyRect) \n341.  \n342.     while checkForKeyPress() == None: \n343.         pygame.display.update() \n344.         FPSCLOCK.tick() \n345.  \n346.  \n347. def checkForQuit(): \n348.     for event in pygame.event.get(QUIT): # get all the QUIT events \n349.         terminate() # terminate if any QUIT events are present \n350.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n351.         if event.key == K_ESCAPE: \n352.             terminate() # terminate if the KEYUP event was for the Esc key \n353.         pygame.event.post(event) # put the other KEYUP event objects back \n354.  \n355. \n356. def calculateLevelAndFallFreq(score): \n357.     # Based on the score, return the level the player is on and \n358.     # how many seconds pass until a falling piece falls one space. \n359.     level = int(score / 10) + 1 \n360.     fallFreq = 0.27 - (level * 0.02) \n361.     return level, fallFreq \n362.  \n363. def getNewPiece(): \n364.     # return a random new piece in a random rotation and color \n365.     shape = random.choice(list(SHAPES.keys())) \n366.     newPiece = {'shape': shape, \n367.                 'rotation': random.randint(0, len(SHAPES[shape]) - 1), \n368.                 'x': int(BOARDWIDTH / 2) - int(TEMPLATEWIDTH / 2), \n369.                 'y': -2, # start it above the board (i.e. less than 0) \n370.                 'color': random.randint(0, len(COLORS)-1)} \n371.     return newPiece \n372.  \n373.  \n374. def addToBoard(board, piece): \n375.     # fill in the board based on piece's location, shape, and rotation \n376.     for x in range(TEMPLATEWIDTH): \n",
      "content_length": 2112,
      "extraction_method": "Direct"
    },
    {
      "page_number": 181,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    163 \n \n377.         for y in range(TEMPLATEHEIGHT): \n378.             if SHAPES[piece['shape']][piece['rotation']][y][x] != BLANK: \n379.                 board[x + piece['x']][y + piece['y']] = piece['color'] \n380.  \n381.  \n382. def getBlankBoard(): \n383.     # create and return a new blank board data structure \n384.     board = [] \n385.     for i in range(BOARDWIDTH): \n386.         board.append([BLANK] * BOARDHEIGHT) \n387.     return board \n388.  \n389.  \n390. def isOnBoard(x, y): \n391.     return x >= 0 and x < BOARDWIDTH and y < BOARDHEIGHT \n392.  \n393.  \n394. def isValidPosition(board, piece, adjX=0, adjY=0): \n395.     # Return True if the piece is within the board and not colliding \n396.     for x in range(TEMPLATEWIDTH): \n397.         for y in range(TEMPLATEHEIGHT): \n398.             isAboveBoard = y + piece['y'] + adjY < 0 \n399.             if isAboveBoard or \nSHAPES[piece['shape']][piece['rotation']][y][x] == BLANK: \n400.                 continue \n401.             if not isOnBoard(x + piece['x'] + adjX, y + piece['y'] + \nadjY): \n402.                 return False \n403.             if board[x + piece['x'] + adjX][y + piece['y'] + adjY] != \nBLANK: \n404.                 return False \n405.     return True \n406.  \n407. def isCompleteLine(board, y): \n408.     # Return True if the line filled with boxes with no gaps. \n409.     for x in range(BOARDWIDTH): \n410.         if board[x][y] == BLANK: \n411.             return False \n412.     return True \n413.  \n414.  \n415. def removeCompleteLines(board): \n416.     # Remove any completed lines on the board, move everything above them \ndown, and return the number of complete lines. \n417.     numLinesRemoved = 0 \n418.     y = BOARDHEIGHT - 1 # start y at the bottom of the board \n",
      "content_length": 1770,
      "extraction_method": "Direct"
    },
    {
      "page_number": 182,
      "chapter": null,
      "content": "164    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n419.     while y >= 0: \n420.         if isCompleteLine(board, y): \n421.             # Remove the line and pull boxes down by one line. \n422.             for pullDownY in range(y, 0, -1): \n423.                 for x in range(BOARDWIDTH): \n424.                     board[x][pullDownY] = board[x][pullDownY-1] \n425.             # Set very top line to blank. \n426.             for x in range(BOARDWIDTH): \n427.                 board[x][0] = BLANK \n428.             numLinesRemoved += 1 \n429.             # Note on the next iteration of the loop, y is the same. \n430.             # This is so that if the line that was pulled down is also \n431.             # complete, it will be removed. \n432.         else: \n433.             y -= 1 # move on to check next row up \n434.     return numLinesRemoved \n435.  \n436.  \n437. def convertToPixelCoords(boxx, boxy): \n438.     # Convert the given xy coordinates of the board to xy  \n439.     # coordinates of the location on the screen. \n440.     return (XMARGIN + (boxx * BOXSIZE)), (TOPMARGIN + (boxy * BOXSIZE)) \n441.  \n442.  \n443. def drawBox(boxx, boxy, color, pixelx=None, pixely=None): \n444.     # draw a single box (each tetromino piece has four boxes) \n445.     # at xy coordinates on the board. Or, if pixelx & pixely \n446.     # are specified, draw to the pixel coordinates stored in \n447.     # pixelx & pixely (this is used for the \"Next\" piece). \n448.     if color == BLANK: \n449.         return \n450.     if pixelx == None and pixely == None: \n451.         pixelx, pixely = convertToPixelCoords(boxx, boxy) \n452.     pygame.draw.rect(DISPLAYSURF, COLORS[color], (pixelx + 1, pixely + 1, \nBOXSIZE - 1, BOXSIZE - 1)) \n453.     pygame.draw.rect(DISPLAYSURF, LIGHTCOLORS[color], (pixelx + 1, pixely \n+ 1, BOXSIZE - 4, BOXSIZE - 4)) \n454.  \n455.  \n456. def drawBoard(board): \n457.     # draw the border around the board \n458.     pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (XMARGIN - 3, TOPMARGIN - \n7, (BOARDWIDTH * BOXSIZE) + 8, (BOARDHEIGHT * BOXSIZE) + 8), 5) \n459.  \n460.     # fill the background of the board \n",
      "content_length": 2164,
      "extraction_method": "Direct"
    },
    {
      "page_number": 183,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    165 \n \n461.     pygame.draw.rect(DISPLAYSURF, BGCOLOR, (XMARGIN, TOPMARGIN, BOXSIZE * \nBOARDWIDTH, BOXSIZE * BOARDHEIGHT)) \n462.     # draw the individual boxes on the board \n463.     for x in range(BOARDWIDTH): \n464.         for y in range(BOARDHEIGHT): \n465.             drawBox(x, y, board[x][y]) \n466.  \n467.  \n468. def drawStatus(score, level): \n469.     # draw the score text \n470.     scoreSurf = BASICFONT.render('Score: %s' % score, True, TEXTCOLOR) \n471.     scoreRect = scoreSurf.get_rect() \n472.     scoreRect.topleft = (WINDOWWIDTH - 150, 20) \n473.     DISPLAYSURF.blit(scoreSurf, scoreRect) \n474.  \n475.     # draw the level text \n476.     levelSurf = BASICFONT.render('Level: %s' % level, True, TEXTCOLOR) \n477.     levelRect = levelSurf.get_rect() \n478.     levelRect.topleft = (WINDOWWIDTH - 150, 50) \n479.     DISPLAYSURF.blit(levelSurf, levelRect) \n480.  \n481.  \n482. def drawPiece(piece, pixelx=None, pixely=None): \n483.     shapeToDraw = SHAPES[piece['shape']][piece['rotation']] \n484.     if pixelx == None and pixely == None: \n485.         # if pixelx & pixely hasn't been specified, use the location \nstored in the piece data structure \n486.         pixelx, pixely = convertToPixelCoords(piece['x'], piece['y']) \n487.  \n488.     # draw each of the blocks that make up the piece \n489.     for x in range(TEMPLATEWIDTH): \n490.         for y in range(TEMPLATEHEIGHT): \n491.             if shapeToDraw[y][x] != BLANK: \n492.                 drawBox(None, None, piece['color'], pixelx + (x * \nBOXSIZE), pixely + (y * BOXSIZE)) \n493. \n494. \n495. def drawNextPiece(piece): \n496.     # draw the \"next\" text \n497.     nextSurf = BASICFONT.render('Next:', True, TEXTCOLOR) \n498.     nextRect = nextSurf.get_rect() \n499.     nextRect.topleft = (WINDOWWIDTH - 120, 80) \n500.     DISPLAYSURF.blit(nextSurf, nextRect) \n501.     # draw the \"next\" piece \n502.     drawPiece(piece, pixelx=WINDOWWIDTH-120, pixely=100) \n503.  \n",
      "content_length": 1957,
      "extraction_method": "Direct"
    },
    {
      "page_number": 184,
      "chapter": null,
      "content": "166    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n504.  \n505. if __name__ == '__main__': \n506.     main() \nThe Usual Setup Code \n  1. # Tetromino (a Tetris clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, time, pygame, sys \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 25 \n 10. WINDOWWIDTH = 640 \n 11. WINDOWHEIGHT = 480 \n 12. BOXSIZE = 20 \n 13. BOARDWIDTH = 10 \n 14. BOARDHEIGHT = 20 \n 15. BLANK = '.' \nThese are the constants used by our Tetromino game. Each box is a square that is 20 pixels wide \nand high. The board itself is 10 boxes wide and 20 boxes tall. The BLANK constant will be used \nas a value to represent blank spaces in the board’s data structure. \nSetting up Timing Constants for Holding Down Keys \n 17. MOVESIDEWAYSFREQ = 0.15 \n 18. MOVEDOWNFREQ = 0.1 \nEvery time the player pushes the left or right arrow key down, the falling piece should move one \nbox over to the left or right, respectively. However, the player can also hold down the left or right \narrow key to keep moving the falling piece. The MOVESIDEWAYSFREQ constant will set it so \nthat every 0.15 seconds that passes with the left or right arrow key held down, the piece will \nmove another space over. \nThe MOVEDOWNFREQ constant is the same thing except it tells how frequently the piece drops by \none box while the player has the down arrow key held down. \nMore Setup Code \n 20. XMARGIN = int((WINDOWWIDTH - BOARDWIDTH * BOXSIZE) / 2) \n",
      "content_length": 1596,
      "extraction_method": "Direct"
    },
    {
      "page_number": 185,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    167 \n \n 21. TOPMARGIN = WINDOWHEIGHT - (BOARDHEIGHT * BOXSIZE) - 5 \nThe program needs to calculate how many pixels are to the left and right side of the board to use \nlater in the program. WINDOWWIDTH is the total number of pixels wide the entire window is. The \nboard is BOARDWIDTH boxes wide and each box is BOXSIZE pixels wide. If we subtract \nBOXSIZE pixels from this for each of the boxes wide in the board (which is BOARDWIDTH * \nBOXSIZE), we’ll have the size of the margin to the left and right of the board. If we divide this \nby 2, then we will have the size of just one margin. Since the margins are the same size, we can \nuse XMARGIN for either the left-side or right-side margin. \nWe can calculate the size of the space between the top of the board and the top of the window in a \nsimilar manner. The board will be drawn 5 pixels above the bottom of the window, so 5 is \nsubtracted from topmargin to account for this. \n \n 23. #               R    G    B \n 24. WHITE       = (255, 255, 255) \n 25. GRAY        = (185, 185, 185) \n 26. BLACK       = (  0,   0,   0) \n 27. RED         = (155,   0,   0) \n 28. LIGHTRED    = (175,  20,  20) \n 29. GREEN       = (  0, 155,   0) \n 30. LIGHTGREEN  = ( 20, 175,  20) \n 31. BLUE        = (  0,   0, 155) \n 32. LIGHTBLUE   = ( 20,  20, 175) \n 33. YELLOW      = (155, 155,   0) \n 34. LIGHTYELLOW = (175, 175,  20) \n",
      "content_length": 1388,
      "extraction_method": "Direct"
    },
    {
      "page_number": 186,
      "chapter": null,
      "content": "168    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 35.  \n 36. BORDERCOLOR = BLUE \n 37. BGCOLOR = BLACK \n 38. TEXTCOLOR = WHITE \n 39. TEXTSHADOWCOLOR = GRAY \n 40. COLORS      = (     BLUE,      GREEN,      RED,      YELLOW) \n 41. LIGHTCOLORS = (LIGHTBLUE, LIGHTGREEN, LIGHTRED, LIGHTYELLOW) \n 42. assert len(COLORS) == len(LIGHTCOLORS) # each color must have light color \nThe pieces will come in four colors: blue, green, red, and yellow. When we draw the boxes \nthough, there will be a thin highlight on the box in a lighter color. So this means we need to create \nlight blue, light green, light red, and light yellow colors as well. \nEach of these four colors will be stored in tuples named COLORS (for the normal colors) and \nLIGHTCOLORS (for the lighter colors). \nSetting Up the Piece Templates \n 44. TEMPLATEWIDTH = 5 \n 45. TEMPLATEHEIGHT = 5 \n 46.  \n 47. S_SHAPE_TEMPLATE = [['.....', \n 48.                      '.....', \n 49.                      '..OO.', \n 50.                      '.OO..', \n 51.                      '.....'], \n 52.                     ['.....', \n 53.                      '..O..', \n 54.                      '..OO.', \n 55.                      '...O.', \n 56.                      '.....']] \n 57.  \n 58. Z_SHAPE_TEMPLATE = [['.....', \n 59.                      '.....', \n 60.                      '.OO..', \n 61.                      '..OO.', \n 62.                      '.....'], \n 63.                     ['.....', \n 64.                      '..O..', \n 65.                      '.OO..', \n 66.                      '.O...', \n 67.                      '.....']] \n 68.  \n 69. I_SHAPE_TEMPLATE = [['..O..', \n 70.                      '..O..', \n",
      "content_length": 1718,
      "extraction_method": "Direct"
    },
    {
      "page_number": 187,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    169 \n \n 71.                      '..O..', \n 72.                      '..O..', \n 73.                      '.....'], \n 74.                     ['.....', \n 75.                      '.....', \n 76.                      'OOOO.', \n 77.                      '.....', \n 78.                      '.....']] \n 79.  \n 80. O_SHAPE_TEMPLATE = [['.....', \n 81.                      '.....', \n 82.                      '.OO..', \n 83.                      '.OO..', \n 84.                      '.....']] \n 85.  \n 86. J_SHAPE_TEMPLATE = [['.....', \n 87.                      '.O...', \n 88.                      '.OOO.', \n 89.                      '.....', \n 90.                      '.....'], \n 91.                     ['.....', \n 92.                      '..OO.', \n 93.                      '..O..', \n 94.                      '..O..', \n 95.                      '.....'], \n 96.                     ['.....', \n 97.                      '.....', \n 98.                      '.OOO.', \n 99.                      '...O.', \n100.                      '.....'], \n101.                     ['.....', \n102.                      '..O..', \n103.                      '..O..', \n104.                      '.OO..', \n105.                      '.....']] \n106.  \n107. L_SHAPE_TEMPLATE = [['.....', \n108.                      '...O.', \n109.                      '.OOO.', \n110.                      '.....', \n111.                      '.....'], \n112.                     ['.....', \n113.                      '..O..', \n114.                      '..O..', \n115.                      '..OO.', \n116.                      '.....'], \n",
      "content_length": 1610,
      "extraction_method": "Direct"
    },
    {
      "page_number": 188,
      "chapter": null,
      "content": "170    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n117.                     ['.....', \n118.                      '.....', \n119.                      '.OOO.', \n120.                      '.O...', \n121.                      '.....'], \n122.                     ['.....', \n123.                      '.OO..', \n124.                      '..O..', \n125.                      '..O..', \n126.                      '.....']] \n127.  \n128. T_SHAPE_TEMPLATE = [['.....', \n129.                      '..O..', \n130.                      '.OOO.', \n131.                      '.....', \n132.                      '.....'], \n133.                     ['.....', \n134.                      '..O..', \n135.                      '..OO.', \n136.                      '..O..', \n137.                      '.....'], \n138.                     ['.....', \n139.                      '.....', \n140.                      '.OOO.', \n141.                      '..O..', \n142.                      '.....'], \n143.                     ['.....', \n144.                      '..O..', \n145.                      '.OO..', \n146.                      '..O..', \n147.                      '.....']] \nOur game program needs to know how each of the shapes are shaped, including for all of their \npossible rotations. In order to do this, we will create lists of lists of strings. The inner list of \nstrings will represent a single rotation of a shape, like this: \n['.....', \n '.....', \n '..OO.', \n '.OO..', \n '.....'] \nWe will write the rest of our code so that it interprets a list of strings like the one above to \nrepresent a shape where the periods are empty spaces and the O’s are boxes, like this: \n",
      "content_length": 1698,
      "extraction_method": "Direct"
    },
    {
      "page_number": 189,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    171 \n \n \nSplitting a “Line of Code” Across Multiple Lines \nYou can see that this list is spread across many lines in the file editor. This is perfectly valid \nPython, because the Python interpreter realizes that until it sees the ] closing square bracket, the \nlist isn’t finished. The indentation doesn’t matter because Python knows you won’t have different \nindentation for a new block in the middle of a list. This code below works just fine: \nspam = ['hello', 3.14, 'world', 42, 10, 'fuzz'] \neggs = ['hello', 3.14, \n   'world' \n         , 42, \n       10, 'fuzz'] \nThough, of course, the code for the eggs list would be much more readable if we lined up all the \nitems in the list or put on a single line like spam. \nNormally, splitting a line of code across multiple lines in the file editor would require putting a \\ \ncharacter at the end of the line. The \\ tells Python, ―This code continues onto the next line.‖ (This \nslash was first used in the Sliding Puzzle game in the isValidMove() function.) \nWe will make ―template‖ data structures of the shapes by creating a list of these list of strings, \nand store them in variables such as S_SHAPE_TEMPLATE. This way, \nlen(S_SHAPE_TEMPLATE) will represent how many possible rotations there are for the S \nshape, and S_SHAPE_TEMPLATE[0] will represent the S shape’s first possible rotation. Lines \n47 to 147 will create ―template‖ data structures for each of the shapes. \nImagine that each possible piece in a tiny 5 x 5 board of empty space, with some of the spaces on \nthe board filled in with boxes. The following expressions that use S_SHAPE_TEMPLATE[0] \nare True: \nS_SHAPE_TEMPLATE[0][2][2] == 'O' \nS_SHAPE_TEMPLATE[0][2][3] == 'O' \nS_SHAPE_TEMPLATE[0][3][1] == 'O' \nS_SHAPE_TEMPLATE[0][3][2] == 'O' \nIf we represented this shape on paper, it would look something like this: \n",
      "content_length": 1858,
      "extraction_method": "Direct"
    },
    {
      "page_number": 190,
      "chapter": null,
      "content": "172    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nThis is how we can represent things like Tetromino pieces as Python values such as strings and \nlists. The TEMPLATEWIDTH and TEMPLATEHEIGHT constants simply set how large each row \nand column for each shape’s rotation should be. (The templates will always be 5x5.) \n149. SHAPES = {'S': S_SHAPE_TEMPLATE, \n150.           'Z': Z_SHAPE_TEMPLATE, \n151.           'J': J_SHAPE_TEMPLATE, \n152.           'L': L_SHAPE_TEMPLATE, \n153.           'I': I_SHAPE_TEMPLATE, \n154.           'O': O_SHAPE_TEMPLATE, \n155.           'T': T_SHAPE_TEMPLATE} \nThe SHAPES variable will be a dictionary that stores all of the different templates. Because each \ntemplate has all the possible rotations of a single shape, this means that the SHAPES variable \ncontains all possible rotations of every possible shape. This will be the data structure that contains \nall of the shape data in our game. \nThe main() Function \n158. def main(): \n159.     global FPSCLOCK, DISPLAYSURF, BASICFONT, BIGFONT \n160.     pygame.init() \n161.     FPSCLOCK = pygame.time.Clock() \n162.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n163.     BASICFONT = pygame.font.Font('freesansbold.ttf', 18) \n164.     BIGFONT = pygame.font.Font('freesansbold.ttf', 100) \n165.     pygame.display.set_caption('Tetromino') \n166.  \n167.     showTextScreen('Tetromino') \n",
      "content_length": 1439,
      "extraction_method": "Direct"
    },
    {
      "page_number": 191,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    173 \n \nThe main() function handles creating some more global constants and showing the start screen \nthat appears when the program is run.  \n168.     while True: # game loop \n169.         if random.randint(0, 1) == 0: \n170.             pygame.mixer.music.load('tetrisb.mid') \n171.         else: \n172.             pygame.mixer.music.load('tetrisc.mid') \n173.         pygame.mixer.music.play(-1, 0.0) \n174.         runGame() \n175.         pygame.mixer.music.stop() \n176.         showTextScreen('Game Over') \nThe code for the actual game is all in runGame(). The main() function here simply randomly \ndecides what background music to start playing (either the tetrisb.mid or tetrisc.mid MIDI music \nfile), then calls runGame() to begin the game. When the player loses, runGame() will return \nto main(), which then stops the background music and displays the game over screen. \nWhen the player presses a key, the showTextScreen() function that displays the game over \nscreen will return. The game loop will loop back to the beginning at line 169 and start another \ngame. \nThe Start of a New Game \n179. def runGame(): \n180.     # setup variables for the start of the game \n181.     board = getBlankBoard() \n182.     lastMoveDownTime = time.time() \n183.     lastMoveSidewaysTime = time.time() \n184.     lastFallTime = time.time() \n185.     movingDown = False # note: there is no movingUp variable \n186.     movingLeft = False \n187.     movingRight = False \n188.     score = 0 \n189.     level, fallFreq = calculateLevelAndFallFreq(score) \n190.  \n191.     fallingPiece = getNewPiece() \n192.     nextPiece = getNewPiece() \nBefore the game begins and pieces start falling, we need to initialize some variables to their start-\nof-game values. On line 191 the fallingPiece variable will be set to the currently falling \npiece that can be rotated by the player. On line 192 the nextPiece variable will be set to the \npiece that shows up in the ―Next‖ part of the screen so that player knows what piece is coming up \nafter setting the falling piece. \n",
      "content_length": 2062,
      "extraction_method": "Direct"
    },
    {
      "page_number": 192,
      "chapter": null,
      "content": "174    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe Game Loop \n194.     while True: # main game loop \n195.         if fallingPiece == None: \n196.             # No falling piece in play, so start a new piece at the top \n197.             fallingPiece = nextPiece \n198.             nextPiece = getNewPiece() \n199.             lastFallTime = time.time() # reset lastFallTime \n200.  \n201.             if not isValidPosition(board, fallingPiece): \n202.                 return # can't fit a new piece on the board, so game over \n203.  \n204.         checkForQuit() \nThe main game loop that starts on line 194 handles all of the code for the main part of the game \nwhen pieces are falling to the bottom. The fallingPiece variable is set to None after the \nfalling piece has landed. This means that the piece in nextPiece should be copied to the \nfallingPiece variable, and a random new piece should be put into the nextPiece variable. \nA new piece can be generated from the getNewPiece() function. The lastFallTime \nvariable is also reset to the current time so that the piece will fall in however many seconds is in \nfallFreq.  \nThe pieces that getNewPiece() are positioned a little bit above the board, usually with part of \nthe piece already on the board. But if this is an invalid position because the board is already filled \nup there (in which case the isValidPosition() call on line 201 will return False), then \nwe know that the board is full and the player should lose the game. When this happens, the \nrunGame() function returns. \nThe Event Handling Loop \n205.         for event in pygame.event.get(): # event handling loop \n206.             if event.type == KEYUP: \nThe event handling loop takes care of when the player rotates the falling piece, moves the falling \npiece, or pauses the game. \nPausing the Game \n207.                 if (event.key == K_p): \n208.                     # Pausing the game \n209.                     DISPLAYSURF.fill(BGCOLOR) \n210.                     pygame.mixer.music.stop() \n211.                     showTextScreen('Paused') # pause until a key press \n212.                     pygame.mixer.music.play(-1, 0.0) \n",
      "content_length": 2199,
      "extraction_method": "Direct"
    },
    {
      "page_number": 193,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    175 \n \n213.                     lastFallTime = time.time() \n214.                     lastMoveDownTime = time.time() \n215.                     lastMoveSidewaysTime = time.time() \nIf the player has pressed the P key, then the game should pause. We need to hide the board from \nthe player (otherwise the player could cheat by pausing the game and taking time to decide where \nto move the piece). \nThe code blanks out the display Surface with a call to DISPLAYSURF.fill(BGCOLOR) and \nstops the music. The showTextScreen() function is called to display the ―Paused‖ text and \nwait for the player to press a key to continue. \nOnce the player has pressed a key, showTextScreen() will return. Line 212 will restart the \nbackground music. Also, since a large amount of time could have passed since the player paused \nthe game, the lastFallTime, lastMoveDownTime, and lastMoveSidewaysTime \nvariables should all be reset to the current time (which is done on lines 213 to 215). \nUsing Movement Variables to Handle User Input \n216.                 elif (event.key == K_LEFT or event.key == K_a): \n217.                     movingLeft = False \n218.                 elif (event.key == K_RIGHT or event.key == K_d): \n219.                     movingRight = False \n220.                 elif (event.key == K_DOWN or event.key == K_s): \n221.                     movingDown = False \nLetting up on one of the arrow keys (or the WASD keys) will set the movingLeft, \nmovingRight, or movingDown variables back to False, indicating that the player no longer \nwants to move the piece in those directions. The code later will handle what to do based on the \nBoolean values inside these ―moving‖ variables. Note that the up arrow and W keys are used for \nrotating the piece, not moving the piece up. This is why there is no movingUp variable. \nChecking if a Slide or Rotation is Valid \n223.             elif event.type == KEYDOWN: \n224.                 # moving the block sideways \n225.                 if (event.key == K_LEFT or event.key == K_a) and \nisValidPosition(board, fallingPiece, adjX=-1): \n226.                     fallingPiece['x'] -= 1 \n227.                     movingLeft = True \n228.                     movingRight = False \n229.                     lastMoveSidewaysTime = time.time() \n",
      "content_length": 2297,
      "extraction_method": "Direct"
    },
    {
      "page_number": 194,
      "chapter": null,
      "content": "176    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nWhen the left arrow key is pressed down (and moving to the left is a valid move for the falling \npiece, as determined by the call to isValidPosition()), then we should change the position \nto one space to the left by subtracting the value of fallingPiece['x'] by 1. The \nisValidPosition() function has optional parameters called adjX and adjY. Normally the \nisValidPosition() function checks the position of the data provided by the piece object \nthat is passed for the second parameter. However, sometimes we don’t want to check where the \npiece is currently located, but rather a few spaces over from that position. \nIf we pass -1 for the adjX (a short name for ―adjusted X‖), then it doesn’t check the validity of \nthe position in the piece’s data structure, but rather if the position of where the piece would be if \nit was one space to the left. Passing 1 for adjX would check one space to the right. There is also \nan adjY optional parameter. Passing -1 for adjY checks one space above where the piece is \ncurrently positioned, and passing a value like 3 for adjY would check three spaces down from \nwhere the piece is. \nThe movingLeft variable is set to True, and just to make sure the falling piece won’t move \nboth left and right, the movingRight variable is set to False on line 228. The \nlastMoveSidewaysTime variable will be updated to the current time on line 229. \nThese variables are set so that the player can just hold down the arrow key to keep moving the \npiece over. If the movingLeft variable is set to True, the program can know that the left \narrow key (or A key) has been pressed and not yet let go. And if 0.15 seconds (the number stored \nin MOVESIDEWAYSFREQ) has passed since the time stored in lastMoveSidewaysTime, \nthen it is time for the program to move the falling piece to the left again. \nThe lastMoveSidewaysTime works just like how the lastClickTime variable did in the \nSimulate chapter. \n231.                 elif (event.key == K_RIGHT or event.key == K_d) and \nisValidPosition(board, fallingPiece, adjX=1): \n232.                     fallingPiece['x'] += 1 \n233.                     movingRight = True \n234.                     movingLeft = False \n235.                     lastMoveSidewaysTime = time.time() \nThe code on lines 231 to 235 is almost identical to lines 225 to 229, except that it handles moving \nthe falling piece to the right when the right arrow key (or D key) has been pressed. \n237.                 # rotating the block (if there is room to rotate) \n238.                 elif (event.key == K_UP or event.key == K_w): \n",
      "content_length": 2676,
      "extraction_method": "Direct"
    },
    {
      "page_number": 195,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    177 \n \n239.                     fallingPiece['rotation'] = (fallingPiece['rotation'] + \n1) % len(SHAPES[fallingPiece['shape']]) \nThe up arrow key (or W key) will rotate the falling piece to its next rotation. All the code has to \ndo is increment the 'rotation' key’s value in the fallingPiece dictionary by 1. \nHowever, if incrementing the 'rotation' key’s value makes it larger than the total number of \nrotations, then ―modding‖ by the total number of possible rotations for that shape (which is what \nlen(SHAPES[fallingPiece['shape']]) is) then it will ―roll over‖ to 0. \nHere’s an example of this modding with the J shape, which has 4 possible rotations: \n>>> 0 % 4 \n0 \n>>> 1 % 4 \n1 \n>>> 2 % 4 \n2 \n>>> 3 % 4 \n3 \n>>> 5 % 4 \n1 \n>>> 6 % 4 \n2 \n>>> 7 % 4 \n3 \n>>> 8 % 4 \n0 \n>>> \n240.                     if not isValidPosition(board, fallingPiece): \n241.                         fallingPiece['rotation'] = \n(fallingPiece['rotation'] - 1) % len(SHAPES[fallingPiece['shape']]) \nIf the new rotated position is not valid because it overlaps some boxes already on the board, then \nwe want to switch it back to the original rotation by subtracting 1 from \nfallingPiece['rotation']. We can also mod it by \nlen(SHAPES[fallingPiece['shape']]) so that if the new value is -1, the modding \nwill change it back to the last rotation in the list. Here’s an example of modding a negative \nnumber: \n>>> -1 % 4 \n3 \n",
      "content_length": 1421,
      "extraction_method": "Direct"
    },
    {
      "page_number": 196,
      "chapter": null,
      "content": "178    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n242.                 elif (event.key == K_q): # rotate the other direction \n243.                     fallingPiece['rotation'] = (fallingPiece['rotation'] - \n1) % len(SHAPES[fallingPiece['shape']]) \n244.                     if not isValidPosition(board, fallingPiece): \n245.                         fallingPiece['rotation'] = \n(fallingPiece['rotation'] + 1) % len(SHAPES[fallingPiece['shape']]) \nLines 242 to 245 do the same thing 238 to 241, except they handle the case where the player has \npressed the Q key which rotates the piece in the opposite direction. In this case, we subtract 1 \nfrom fallingPiece['rotation'] (which is done on line 243) instead of adding 1. \n247.                 # making the block fall faster with the down key \n248.                 elif (event.key == K_DOWN or event.key == K_s): \n249.                     movingDown = True \n250.                     if isValidPosition(board, fallingPiece, adjY=1): \n251.                         fallingPiece['y'] += 1 \n252.                     lastMoveDownTime = time.time() \nIf the down arrow or S key is pressed down, then the player wants the piece to fall faster than \nnormal. Line 251 moves the piece down one space on the board (but only if it is a valid space). \nThe movingDown variable is set to True and lastMoveDownTime is reset to the current \ntime. These variables will be checked later so that the piece keeps falling at the faster rate as long \nas the down arrow or S key is held down. \nFinding the Bottom \n254.                 # move the current block all the way down \n255.                 elif event.key == K_SPACE: \n256.                     movingDown = False \n257.                     movingLeft = False \n258.                     movingRight = False \n259.                     for i in range(1, BOARDHEIGHT): \n260.                         if not isValidPosition(board, fallingPiece, \nadjY=i): \n261.                             break \n262.                     fallingPiece['y'] += i - 1 \nWhen the player presses the space key the falling piece will immediately drop down as far as it \ncan go on the board and land. The program first needs to find out how many spaces the piece can \nmove until it lands. \nLines 256 to 258 will set all the moving variables to False (which makes the code in later parts \nof the programming think that the user has let up on any arrow keys that were held down). This is \n",
      "content_length": 2485,
      "extraction_method": "Direct"
    },
    {
      "page_number": 197,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    179 \n \ndone because this code will move the piece to the absolute bottom and begin falling the next \npiece, and we don’t want to surprise the player by having those pieces immediately start moving \njust because they were holding down an arrow key when they hit the space key. \nTo find the farthest that the piece can fall, we should first call isValidPosition() and pass \nthe integer 1 for the adjY parameter. If isValidPosition() returns False, we know that \nthe piece cannot fall any further and is already at the bottom. If isValidPosition() returns \nTrue, then we know that it can fall 1 space down. \nIn that case, we should call isValidPosition() with adjY set to 2. If it returns True \nagain, we will call isValidPosition() with adjY set to 3, and so on. This is what the for \nloop on line 259 handles: calling isValidPosition() with increasing integer values to pass \nfor adjY until the function call returns False. At that point, we know that the value in i is one \nspace more past the bottom. This is why line 262 increases fallingPiece['y'] by i - 1 \ninstead of i. \n(Also note that the second parameter to range() on line 259’s for statement is set to \nBOARDHEIGHT because this is the maximum amount that the piece could fall before it must hit \nthe bottom of the board.) \nMoving by Holding Down the Key \n264.         # handle moving the block because of user input \n265.         if (movingLeft or movingRight) and time.time() - \nlastMoveSidewaysTime > MOVESIDEWAYSFREQ: \n266.             if movingLeft and isValidPosition(board, fallingPiece, adjX=-\n1): \n267.                 fallingPiece['x'] -= 1 \n268.             elif movingRight and isValidPosition(board, fallingPiece, \nadjX=1): \n269.                 fallingPiece['x'] += 1 \n270.             lastMoveSidewaysTime = time.time() \nRemember that on line 227 the movingLeft variable was set to True if the player pressed \ndown on the left arrow key? (The same for line 233 where movingRight was set to True if \nthe player pressed down on the right arrow key.) The moving variables were set back to False if \nthe user let up on these keys also (see line 217 and 219). \nWhat also happened when the player pressed down on the left or right arrow key was that the \nlastMoveSidewaysTime variable was set to the current time (which was the return value of \ntime.time()). If the player continued to hold down the arrow key without letting up on it, \nthen the movingLeft or movingRight variable would still be set to True. \n",
      "content_length": 2503,
      "extraction_method": "Direct"
    },
    {
      "page_number": 198,
      "chapter": null,
      "content": "180    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nIf the user held down on the key for longer than 0.15 seconds (the value stored in \nMOVESIDEWAYSFREQ is the float 0.15) then the expression time.time() - \nlastMoveSidewaysTime > MOVESIDEWAYSFREQ would evaluate to True. Line 265’s \ncondition is True if the user has both held down the arrow key and 0.15 seconds has passed, and \nin that case we should move the falling piece to the left or right even though the user hasn’t \npressed the arrow key again. \nThis is very useful because it would become tiresome for the player to repeatedly hit the arrow \nkeys to get the falling piece to move over multiple spaces on the board. Instead, they can just hold \ndown an arrow key and the piece will keep moving over until they let up on the key. When that \nhappens, the code on lines 216 to 221 will set the moving variable to False and the condition on \nline 265 will be False. That is what stops the falling piece from sliding over more. \nTo demonstrate why the time.time() - lastMoveSidewaysTime > \nMOVESIDEWAYSFREQ returns True after the number of seconds in MOVESIDEWAYSFREQ has \npassed, run this short program: \nimport time \n \nWAITTIME = 4 \nbegin = time.time() \n \nwhile True: \n    now = time.time() \n    message = '%s, %s, %s' % (begin, now, (now - begin)) \n    if now - begin > WAITTIME: \n        print(message + ' PASSED WAIT TIME!') \n    else: \n        print(message + ' Not yet...') \n    time.sleep(0.2) \nThis program has an infinite loop, so in order to terminate it, press Ctrl-C. The output of this \nprogram will look something like this: \n1322106392.2, 1322106392.2, 0.0 Not yet... \n1322106392.2, 1322106392.42, 0.219000101089 Not yet... \n1322106392.2, 1322106392.65, 0.449000120163 Not yet... \n1322106392.2, 1322106392.88, 0.680999994278 Not yet... \n1322106392.2, 1322106393.11, 0.910000085831 Not yet... \n1322106392.2, 1322106393.34, 1.1400001049 Not yet... \n1322106392.2, 1322106393.57, 1.3710000515 Not yet... \n1322106392.2, 1322106393.83, 1.6360001564 Not yet... \n1322106392.2, 1322106394.05, 1.85199999809 Not yet... \n",
      "content_length": 2132,
      "extraction_method": "Direct"
    },
    {
      "page_number": 199,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    181 \n \n1322106392.2, 1322106394.28, 2.08000016212 Not yet... \n1322106392.2, 1322106394.51, 2.30900001526 Not yet... \n1322106392.2, 1322106394.74, 2.54100012779 Not yet... \n1322106392.2, 1322106394.97, 2.76999998093 Not yet... \n1322106392.2, 1322106395.2, 2.99800014496 Not yet... \n1322106392.2, 1322106395.42, 3.22699999809 Not yet... \n1322106392.2, 1322106395.65, 3.45600008965 Not yet... \n1322106392.2, 1322106395.89, 3.69200015068 Not yet... \n1322106392.2, 1322106396.12, 3.92100000381 Not yet... \n1322106392.2, 1322106396.35, 4.14899992943 PASSED WAIT TIME! \n1322106392.2, 1322106396.58, 4.3789999485 PASSED WAIT TIME! \n1322106392.2, 1322106396.81, 4.60700011253 PASSED WAIT TIME! \n1322106392.2, 1322106397.04, 4.83700013161 PASSED WAIT TIME! \n1322106392.2, 1322106397.26, 5.06500005722 PASSED WAIT TIME! \nTraceback (most recent call last): \n  File \"C:\\timetest.py\", line 13, in <module> \n    time.sleep(0.2) \nKeyboardInterrupt \nThe first number on each line of output is the return value of time.time() when the program \nfirst started (and this value never changes). The second number is the latest return value from \ntime.time() (this value keeps getting updated on each iteration of the loop). And the third \nnumber is the current time minus the start time. This third number is the number of seconds that \nhave elapsed since the begin = time.time() line of code was executed. \nIf this number is greater than 4, the code will start printing ―PASSED WAIT TIME!‖ instead of \n―Not yet...‖. This is how our game program can know if a certain amount of time has passed since \na line of code was run. \nIn our Tetromino program, the time.time() – lastMoveSidewaysTime expression will \nevaluate to the number of seconds that has elapsed since the last time \nlastMoveSidewaysTime was set to the current time. If this value is greater than the value in \nMOVESIDEWAYSFREQ, we know it is time for the code to move the falling piece over one more \nspace. \nDon’t forget to update lastMoveSidewaysTime to the current time again! This is what we \ndo on line 270. \n272.         if movingDown and time.time() - lastMoveDownTime > MOVEDOWNFREQ \nand isValidPosition(board, fallingPiece, adjY=1): \n273.             fallingPiece['y'] += 1 \n274.             lastMoveDownTime = time.time() \n",
      "content_length": 2299,
      "extraction_method": "Direct"
    },
    {
      "page_number": 200,
      "chapter": null,
      "content": "182    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nLines 272 to 274 do almost the same thing as lines 265 to 270 do except for moving the falling \npiece down. This has a separate move variable (movingDown) and ―last time‖ variable \n(lastMoveDownTime) as well as a different ―move frequency‖ variable (MOVEDOWNFREQ).  \nLetting the Piece “Naturally” Fall \n276.         # let the piece fall if it is time to fall \n277.         if time.time() - lastFallTime > fallFreq: \n278.             # see if the piece has landed \n279.             if not isValidPosition(board, fallingPiece, adjY=1): \n280.                 # falling piece has landed, set it on the board \n281.                 addToBoard(board, fallingPiece) \n282.                 score += removeCompleteLines(board) \n283.                 level, fallFreq = calculateLevelAndFallFreq(score) \n284.                 fallingPiece = None \n285.             else: \n286.                 # piece did not land, just move the block down \n287.                 fallingPiece['y'] += 1 \n288.                 lastFallTime = time.time() \nThe rate that the piece is naturally moving down (that is, falling) is tracked by the \nlastFallTime variable. If enough time has elapsed since the falling piece last fell down one \nspace, lines 279 to 288 will handle dropping the piece by one space. \nIf the condition on line 279 is True, then the piece has landed. The call to addToBoard() will \nmake the piece part of the board data structure (so that future pieces can land on it), and the \nremoveCompleteLines() call will handle erasing any complete lines on the board and \npulling the boxes down. The removeCompleteLines() function also returns an integer \nvalue of how many lines were removed, so we add this number to the score.  \nBecause the score may have changed, we call the calculateLevelAndFallFreq() \nfunction to update the current level and frequency that the pieces fall. And finally, we set the \nfallingPiece variable to None to indicate that the next piece should become the new falling \npiece, and a random new piece should be generated for the new next piece. (That is done on lines \n195 to 199 at the beginning of the game loop.) \nIf the piece has not landed, we simply set its Y position down one space (on line 287) and reset \nlastFallTime to the current time (on line 288). \nDrawing Everything on the Screen \n290.         # drawing everything on the screen \n291.         DISPLAYSURF.fill(BGCOLOR) \n292.         drawBoard(board) \n",
      "content_length": 2525,
      "extraction_method": "Direct"
    },
    {
      "page_number": 201,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    183 \n \n293.         drawStatus(score, level) \n294.         drawNextPiece(nextPiece) \n295.         if fallingPiece != None: \n296.             drawPiece(fallingPiece) \n297.  \n298.         pygame.display.update() \n299.         FPSCLOCK.tick(FPS) \nNow that the game loop has handled all events and updated the game state, the game loop just \nneeds to draw the game state to the screen. Most of the drawing is handled by other functions, so \nthe game loop code just needs to call those functions. Then the call to \npygame.display.update() makes the display Surface appear on the actual computer \nscreen, and the tick() method call adds a slight pause so the game doesn’t run too fast. \nmakeTextObjs(), A Shortcut Function for Making Text \n302. def makeTextObjs(text, font, color): \n303.     surf = font.render(text, True, color) \n304.     return surf, surf.get_rect() \nThe makeTextObjs() function just provides us with a shortcut. Given the text, Font object, \nand a Color object, it calls render() for us and returns the Surface and Rect object for this text. \nThis just saves us from typing out the code to create the Surface and Rect object each time we \nneed them. \nThe Same Old terminate() Function \n307. def terminate(): \n308.     pygame.quit() \n309.     sys.exit() \nThe terminate() function works the same as in the previous game programs. \nWaiting for a Key Press Event with the checkForKeyPress() \nFunction \n312. def checkForKeyPress(): \n313.     # Go through event queue looking for a KEYUP event. \n314.     # Grab KEYDOWN events to remove them from the event queue. \n315.     checkForQuit() \n316. \n317.     for event in pygame.event.get([KEYDOWN, KEYUP]): \n318.         if event.type == KEYDOWN: \n",
      "content_length": 1728,
      "extraction_method": "Direct"
    },
    {
      "page_number": 202,
      "chapter": null,
      "content": "184    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n319.             continue \n320.         return event.key \n321.     return None \nThe checkForKeyPress() function works almost the same as it did in the Wormy game. \nFirst it calls checkForQuit() to handle any QUIT events (or KEYUP events specifically for \nthe Esc key) and terminates the program if there are any. Then it pulls out all the KEYUP and \nKEYDOWN events from the event queue. It ignores any KEYDOWN events (KEYDOWN was \nspecified to pygame.event.get() only to clear those events out of the event queue). \nIf there were no KEYUP events in the event queue, then the function returns None. \nshowTextScreen(), A Generic Text Screen Function \n324. def showTextScreen(text): \n325.     # This function displays large text in the \n326.     # center of the screen until a key is pressed. \n327.     # Draw the text drop shadow \n328.     titleSurf, titleRect = makeTextObjs(text, BIGFONT, TEXTSHADOWCOLOR) \n329.     titleRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2)) \n330.     DISPLAYSURF.blit(titleSurf, titleRect) \n331.  \n332.     # Draw the text \n333.     titleSurf, titleRect = makeTextObjs(text, BIGFONT, TEXTCOLOR) \n334.     titleRect.center = (int(WINDOWWIDTH / 2) - 3, int(WINDOWHEIGHT / 2) - \n3) \n335.     DISPLAYSURF.blit(titleSurf, titleRect) \n336.  \n337.     # Draw the additional \"Press a key to play.\" text. \n338.     pressKeySurf, pressKeyRect = makeTextObjs('Press a key to play.', \nBASICFONT, TEXTCOLOR) \n339.     pressKeyRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2) + \n100) \n340.     DISPLAYSURF.blit(pressKeySurf, pressKeyRect) \nInstead of separate functions for the start screen and game over screens, we will create one \ngeneric function named showTextScreen(). The showTextScreen() function will draw \nwhatever text we pass for the text parameter. Also, the text ―Press a key to play.‖ will be \ndisplayed in addition. \nNotice that lines 328 to 330 draw the text in a darker shadow color first, and then lines 333 to 335 \ndraw the same text again, except offset by 3 pixels to the left and 3 pixels upward. This creates a \n―drop shadow‖ effect that makes the text look a bit prettier. You can compare the difference by \ncommenting out lines 328 to 330 to see the text without a drop shadow. \n",
      "content_length": 2344,
      "extraction_method": "Direct"
    },
    {
      "page_number": 203,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    185 \n \nThe showTextScreen() will be used for the start screen, the game over screen, and also for a \npause screen. (The pause screen is explained later in this chapter.) \n342.     while checkForKeyPress() == None: \n343.         pygame.display.update() \n344.         FPSCLOCK.tick() \nWe want the text to stay on the screen until the user presses a key. This small loop will constantly \ncall pygame.display.update() and FPSCLOCK.tick() until \ncheckForKeyPress() returns a value other than None. This happens when the user presses \na key. \nThe checkForQuit() Function \n347. def checkForQuit(): \n348.     for event in pygame.event.get(QUIT): # get all the QUIT events \n349.         terminate() # terminate if any QUIT events are present \n350.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n351.         if event.key == K_ESCAPE: \n352.             terminate() # terminate if the KEYUP event was for the Esc key \n353.         pygame.event.post(event) # put the other KEYUP event objects back \nThe checkForQuit() function can be called to handle any events that will cause the program \nto terminate. This happens if there are any QUIT events in the event queue (this is handle by lines \n348 and 349), or if there is a KEYUP event of the Esc key. The player should be able to press the \nEsc key at any time to quit the program. \nBecause the pygame.event.get() call on line 350 pulls out all of the KEYUP events \n(including events for keys other than the Esc key), if the event is not for the Esc key, we want to \nput it back into the event queue by calling the pygame.event.post() function. \nThe calculateLevelAndFallFreq() Function \n356. def calculateLevelAndFallFreq(score): \n357.     # Based on the score, return the level the player is on and \n358.     # how many seconds pass until a falling piece falls one space. \n359.     level = int(score / 10) + 1 \n360.     fallFreq = 0.27 - (level * 0.02) \n361.     return level, fallFreq \nEvery time the player completes a line, their score will increase by one point. Every ten points, \nthe game goes up a level and the pieces start falling down faster. Both the level and the falling \nfrequency can be calculated from the score that is passed to this function. \n",
      "content_length": 2250,
      "extraction_method": "Direct"
    },
    {
      "page_number": 204,
      "chapter": null,
      "content": "186    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nTo calculate the level, we use the int() function to round down the score divided by 10. So if \nthe score any number between 0 and 9, the int() call will round it down to 0. The + 1 part of \nthe code is there because we want the first level to be level 1, not level 0. When the score reaches \n10, then int(10 / 10) will evaluate to 1, and the + 1 will make the level 2. Here is a graph \nshowing the values of level for the scores 1 to 34: \n \nTo calculate the falling frequency, we start with a base time of 0.27 (meaning that the piece will \nnaturally fall once every 0.27 seconds). Then we multiply the level by 0.02, and subtract that \nfrom the 0.27 base time. So on level 1, we subtract 0.02 * 1 (that is, 0.02) from 0.27 to \nget 0.25. On level 2, we subtract 0.02 * 2 (that is, 0.04) to get 0.23. You can think of the \nlevel * 0.02 part of the equation as ―for every level, the piece will fall 0.02 seconds faster \nthan the previous level.‖ \nWe can also make a graph showing how fast the pieces will fall at each level of the game: \n0\n1\n2\n3\n4\n5\n1\n3\n5\n7\n9\n11\n13 15\n17 19\n21 23 25\n27 29\n31 33\nLevel \nScore \nlevel = int(score / 10) + 1 \n",
      "content_length": 1241,
      "extraction_method": "Direct"
    },
    {
      "page_number": 205,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    187 \n \n \nYou can see that at level 14, the falling frequency will be less than 0. This won’t cause any bugs \nwith our code, because line 277 just checks that the elapsed time since the falling piece last fell \none space is greater than the calculated falling frequency. So if the falling frequency is negative, \nthen the condition on line 277 will always be True and the piece will fall on every iteration of \nthe game loop. From level 14 and beyond, the piece cannot fall any faster. \nIf the FPS is set at 25, this means that at reaching level 14, the falling piece will fall 25 spaces a \nsecond. Considering that the board is only 20 spaces tall, that means the player will have less than \na second to set each piece! \nIf you want the pieces to start (if you can see what I mean) falling faster at a slower rate, you can \nchange the equation that the calculateLevelAndFallFreq() uses. For example, let’s say \nline 360 was this: \n360.     fallFreq = 0.27 - (level * 0.01) \nIn the above case, the pieces would only fall 0.01 seconds faster on each level rather than 0.02 \nseconds faster. The graph would look like this (the original line is also in the graph in light grey): \n-0.05\n0\n0.05\n0.1\n0.15\n0.2\n0.25\n0.3\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nFall Frequency (seconds) \nLevel \nfallFreq = 0.27 - (level * 0.02) \n",
      "content_length": 1339,
      "extraction_method": "Direct"
    },
    {
      "page_number": 206,
      "chapter": null,
      "content": "188    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nAs you can see, with this new equation, level 14 would only be as hard as the original level 7. \nYou can change the game to be as difficult or easy as you like by changing the equations in \ncalculateLevelAndFallFreq(). \nGenerating Pieces with the getNewPiece() Function \n363. def getNewPiece(): \n364.     # return a random new piece in a random rotation and color \n365.     shape = random.choice(list(SHAPES.keys())) \n366.     newPiece = {'shape': shape, \n367.                 'rotation': random.randint(0, len(SHAPES[shape]) - 1), \n368.                 'x': int(BOARDWIDTH / 2) - int(TEMPLATEWIDTH / 2), \n369.                 'y': -2, # start it above the board (i.e. less than 0) \n370.                 'color': random.randint(0, len(COLORS)-1)} \n371.     return newPiece \nThe getNewPiece() function generates a random piece that is positioned at the top of the \nboard. First, to randomly choose the shape of the piece, we create a list of all the possible shapes \nby calling list(SHAPES.keys()) on line 365. The keys() dictionary method returns a \nvalue of the data type ―dict_keys‖, which must be converted to a list value with the list() \nfunction before being passed to random.choice(). This is because the random.choice() \nfunction only accepts list values for its parameter. The random.choice() function then \nrandomly returns the value of an item from the list. \nThe piece data structures are simply a dictionary value with the keys 'shape', 'rotation', \n'x', 'y', and 'color'. \n-0.05\n0\n0.05\n0.1\n0.15\n0.2\n0.25\n0.3\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nFall Frequency (seconds) \nLevel \nfallFreq = 0.27 - (level * 0.01) \n",
      "content_length": 1730,
      "extraction_method": "Direct"
    },
    {
      "page_number": 207,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    189 \n \nThe value for the 'rotation' key is a random integer between 0 to one less than however \nmany possible rotations there are for that shape. The number of rotations for a shape can be found \nfrom the expression len(SHAPES[shape]). \nNotice that we don’t store the list of string values (like the ones store in the constants like \nS_SHAPE_TEMPLATE) in each piece data structure to represent the boxes of each piece. Instead, \nwe just store an index for the shape and rotation which refer to the PIECES constant. \nThe 'x' key’s value is always set to the middle of the board (also accounting for the width of the \npieces themselves, which is found from our TEMPLATEWIDTH constant). The 'y' key’s value is \nalways set to -2 to place it slightly above the board. (The top row of the board is row 0.) \nSince the COLORS constant is a tuple of the different colors, selecting a random number from 0 \nto the length of COLORS (subtracting one) will give us a random index value for the piece’s \ncolor. \nOnce all of the values in the newPiece dictionary are set, the getNewPiece() function \nreturns newPiece.  \nAdding Pieces to the Board Data Structure \n374. def addToBoard(board, piece): \n375.     # fill in the board based on piece's location, shape, and rotation \n376.     for x in range(TEMPLATEWIDTH): \n377.         for y in range(TEMPLATEHEIGHT): \n378.             if SHAPES[piece['shape']][piece['rotation']][y][x] != BLANK: \n379.                 board[x + piece['x']][y + piece['y']] = piece['color'] \nThe board data structure is a data representation for the rectangular space where pieces that have \npreviously landed are tracked. The currently falling piece is not marked on the board data \nstructure. What the addToBoard() function does is takes a piece data structure and adds its \nboxes to the board data structure. This happens after a piece has landed. \nThe nested for loops on lines 376 and 377 go through every space in the piece data structure, \nand if it finds a box in the space (line 378), it adds it to the board (line 379). \nCreating a New Board Data Structure \n382. def getBlankBoard(): \n383.     # create and return a new blank board data structure \n384.     board = [] \n385.     for i in range(BOARDWIDTH): \n386.         board.append([BLANK] * BOARDHEIGHT) \n",
      "content_length": 2304,
      "extraction_method": "Direct"
    },
    {
      "page_number": 208,
      "chapter": null,
      "content": "190    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n387.     return board \nThe data structure used for the board is fairly simple: it’s a list of lists of values. If the value is the \nsame as the value in BLANK, then it is an empty space. If the value is an integer, then it represents \na box that is the color that the integer indexes in the COLORS constant list. That is, 0 is blue, 1 is \ngreen, 2 is red, and 3 is yellow. \nIn order to create a blank board, list replication is used to create the lists of BLANK values which \nrepresents a column. This is done on line 386. One of these lists is created for each of the \ncolumns in the board (this is what the for loop on line 385 does). \nThe isOnBoard() and isValidPosition() Functions \n390. def isOnBoard(x, y): \n391.     return x >= 0 and x < BOARDWIDTH and y < BOARDHEIGHT \nThe isOnBoard() is a simple function which checks that the XY coordinates that are passed \nrepresent valid values that exist on the board. As long as both the XY coordinates are not less 0 \nor greater than or equal to the BOARDWIDTH and BOARDHEIGHT constants, then the function \nreturns True.  \n394. def isValidPosition(board, piece, adjX=0, adjY=0): \n395.     # Return True if the piece is within the board and not colliding \n396.     for x in range(TEMPLATEWIDTH): \n397.         for y in range(TEMPLATEHEIGHT): \n398.             isAboveBoard = y + piece['y'] + adjY < 0 \n399.             if isAboveBoard or \nSHAPES[piece['shape']][piece['rotation']][y][x] == BLANK: \n400.                 continue \nThe isValidPosition() function is given a board data structure and a piece data structure, \nand returns True if all the boxes in the piece are both on the board and not overlapping any \nboxes on the board. This is done by taking the piece’s XY coordinates (which is really the \ncoordinate of the upper right box on the 5x5 boxes for the piece) and adding the coordinate inside \nthe piece data structure. Here’s a couple pictures to help illustrate this: \n",
      "content_length": 2035,
      "extraction_method": "Direct"
    },
    {
      "page_number": 209,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    191 \n \n \n \nThe board with a falling piece in a valid \nposition. \nThe board with the falling piece in an invalid \nposition. \n \nOn the left board, the falling piece’s (that is, the top left corner of the falling piece’s) XY \ncoordinates are (2, 3) on the board. But the boxes inside the falling piece’s coordinate system \nhave their own coordinates. To find the ―board‖ coordinates of these pieces, we just have to add \nthe ―board‖ coordinates of the falling piece’s top left box and the ―piece‖ coordinates of the \nboxes. \nOn the left board, the falling piece’s boxes are at the following ―piece‖ coordinates: \n \n(2, 2) \n(3, 2) \n(1, 3) \n(2, 3) \nWhen we add the (2, 3) coordinate (the piece’s coordinates on the board) to these coordinates, it \nlooks like this: \n \n(2 + 2, 2 + 3) \n(3 + 2, 2 + 3) \n(1 + 2, 3 + 3) \n(2 + 2, 3 + 3) \nAfter adding the (2, 3) coordinate the boxes are at the following ―board‖ coordinates: \n \n(4, 5) \n(5, 5) \n(3, 6) \n(4, 6) \n",
      "content_length": 974,
      "extraction_method": "Direct"
    },
    {
      "page_number": 210,
      "chapter": null,
      "content": "192    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nAnd now that we can figure out where the falling piece’s boxes are as board coordinates, we can \nsee if they overlap with the landed boxes that are already on the board. The nested for loops on \nlines 396 and 397 go through each of the possible coordinates on the falling piece. \nWe want to check if a box of the falling piece is either off of the board or overlapping a box on \nthe board. (Although one exception is if the box is above the board, which is where it could be \nwhen the falling piece just begins falling.) Line 398 creates a variable named isAboveBoard \nthat is set to True if the box on the falling piece at the coordinates pointed to be x and y is above \nthe board. Otherwise it is set to False. \nThe if statement on line 399 checks if the space on the piece is above the board or is blank. If \neither of those is True, then the code executes a continue statement and goes to the next \niteration. (Note that the end of line 399 has [y][x] instead of [x][y]. This is because the \ncoordinates in the PIECES data structure are reversed. See the previous section, ―Setting Up the \nPiece Templates‖). \n401.             if not isOnBoard(x + piece['x'] + adjX, y + piece['y'] + \nadjY): \n402.                 return False \n403.             if board[x + piece['x'] + adjX][y + piece['y'] + adjY] != \nBLANK: \n404.                 return False \n405.     return True \nThe if statement on line 401 checks that the piece’s box is not located on the board. The if \nstatement on line 403 checks that the board space the piece’s box is located is not blank. If either \nof these conditions are True, then the isValidPosition() function will return False. \nNotice that these if statements also adjust the coordinates for the adjX and adjY parameters \nthat were passed in to the function. \nIf the code goes through the nested for loop and hasn’t found a reason to return False, then the \nposition of the piece must be valid and so the function returns True on line 405. \nChecking for, and Removing, Complete Lines \n407. def isCompleteLine(board, y): \n408.     # Return True if the line filled with boxes with no gaps. \n409.     for x in range(BOARDWIDTH): \n410.         if board[x][y] == BLANK: \n411.             return False \n412.     return True \n",
      "content_length": 2349,
      "extraction_method": "Direct"
    },
    {
      "page_number": 211,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    193 \n \nThe isCompleteLine does a simple check at the row specified by the y parameter. A row on \nthe board is considered to be ―complete‖ when every space is filled by a box. The for loop on \nline 409 goes through each space in the row. If a space is blank (which is caused by it having the \nsame value as the BLANK constant), then the function return False. \n415. def removeCompleteLines(board): \n416.     # Remove any completed lines on the board, move everything above them \ndown, and return the number of complete lines. \n417.     numLinesRemoved = 0 \n418.     y = BOARDHEIGHT - 1 # start y at the bottom of the board \n419.     while y >= 0: \nThe removeCompleteLines() function will find any complete lines in the passed board data \nstructure, remove the lines, and then shift all the boxes on the board above that line down one \nrow. The function will return the number of lines that were removed (which is tracked by the \nnumLinesRemoved variable) so that this can be added to the score. \nThe way this function works is by running in a loop starting on line 419 with the y variable \nstarting at the lowest row (which is BOARDHEIGHT - 1). Whenever the row specified by y is \nnot complete, y will be decremented to the next highest row. The loop finally stops once y \nreaches -1. \n420.         if isCompleteLine(board, y): \n421.             # Remove the line and pull boxes down by one line. \n422.             for pullDownY in range(y, 0, -1): \n423.                 for x in range(BOARDWIDTH): \n424.                     board[x][pullDownY] = board[x][pullDownY-1] \n425.             # Set very top line to blank. \n426.             for x in range(BOARDWIDTH): \n427.                 board[x][0] = BLANK \n428.             numLinesRemoved += 1 \n429.             # Note on the next iteration of the loop, y is the same. \n430.             # This is so that if the line that was pulled down is also \n431.             # complete, it will be removed. \n432.         else: \n433.             y -= 1 # move on to check next row up \n434.     return numLinesRemoved \nThe isCompleteLine() function will return True if the line that y is referring to is \ncomplete. In that case, the program needs to copy the values of each row above the removed line \nto the next lowest line. This is what the for loop on line 422 does (which is why its call to the \nrange() function begins at y, rather than 0. Also note that it uses the three argument form of \n",
      "content_length": 2458,
      "extraction_method": "Direct"
    },
    {
      "page_number": 212,
      "chapter": null,
      "content": "194    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nrange(), so that the list it returns starts at y, ends at 0, and after each iteration ―increases‖ by -\n1.) \nLet’s look at the following example. To save space, only the top five rows of the board are \nshown. Row 3 is a complete line, which means that all the rows above it (row 2, 1, and 0) must be \n―pulled down‖. First, row 2 is copied down to row 3. The board on the right shows what the board \nwill look like after this is done: \n \nThis ―pulling down‖ is really just copying the higher row’s values to the row below it on line 424. \nAfter row 2 is copied to row 3, then row 1 is copied to row 2 followed by row 0 copied to row 1: \n \n \nRow 0 (the row at the very top) doesn’t have a row above it to copy values down. But row 0 \ndoesn’t need a row copied to it, it just needs all the spaces set to BLANK. This is what lines 426 \nand 427 do. After that, the board will have changed from the board shown below on the left to the \nboard shown below on the right: \n \nAfter the complete line is removed, the execution reaches the end of the while loop that started \non line 419, so the execution jumps back to the beginning of the loop. Note that at no point when \n",
      "content_length": 1265,
      "extraction_method": "Direct"
    },
    {
      "page_number": 213,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    195 \n \nthe line was being removed and the rows being pulled down that the y variable changed at all. So \non the next iteration, the y variable is pointing to the same row as before. \nThis is needed because if there were two complete lines, then the second complete line would \nhave been pulled down and would also have to be removed. The code will then remove this \ncomplete line, and then go to the next iteration. It is only when there is not a completed line that \nthe y variable is decremented on line 433. Once the y variable has been decremented all the way \nto 0, the execution will exit the while loop. \nConvert from Board Coordinates to Pixel Coordinates  \n437. def convertToPixelCoords(boxx, boxy): \n438.     # Convert the given xy coordinates of the board to xy  \n439.     # coordinates of the location on the screen. \n440.     return (XMARGIN + (boxx * BOXSIZE)), (TOPMARGIN + (boxy * BOXSIZE)) \nThis helper function converts the board’s box coordinates to pixel coordinates. This function \nworks the same way to the other ―convert coordinates‖ functions used in the previous game \nprograms. \nDrawing a Box on the Board or Elsewhere on the Screen \n443. def drawBox(boxx, boxy, color, pixelx=None, pixely=None): \n444.     # draw a single box (each tetromino piece has four boxes) \n445.     # at xy coordinates on the board. Or, if pixelx & pixely \n446.     # are specified, draw to the pixel coordinates stored in \n447.     # pixelx & pixely (this is used for the \"Next\" piece). \n448.     if color == BLANK: \n449.         return \n450.     if pixelx == None and pixely == None: \n451.         pixelx, pixely = convertToPixelCoords(boxx, boxy) \n452.     pygame.draw.rect(DISPLAYSURF, COLORS[color], (pixelx + 1, pixely + 1, \nBOXSIZE - 1, BOXSIZE - 1)) \n453.     pygame.draw.rect(DISPLAYSURF, LIGHTCOLORS[color], (pixelx + 1, pixely \n+ 1, BOXSIZE - 4, BOXSIZE - 4)) \nThe drawBox() function draws a single box on the screen. The function can receive boxx and \nboxy parameters for board coordinates where the box should be drawn. However, if the pixelx \nand pixely parameters are specified, then these pixel coordinates will override the boxx and \nboxy parameters. The pixelx and pixely parameters are used to draw the boxes of the \n―Next‖ piece, which is not on the board. \nIf the pixelx and pixely parameters are not set, then they will be set to None by default \nwhen the function first begins. Then the if statement on line 450 will overwrite the None values \n",
      "content_length": 2494,
      "extraction_method": "Direct"
    },
    {
      "page_number": 214,
      "chapter": null,
      "content": "196    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nwith the return values from convertToPixelCoords(). This call gets the pixel coordinates \nof the board coordinates specified by boxx and boxy. \nThe code won’t fill the entire box’s space with color. To have a black outline in between the \nboxes of a piece, the left and top parameters in the pygame.draw.rect() call have + 1 \nadded to them and a - 1 is added to the width and height parameters. In order to draw the \nhighlighted box, first the box is drawn with the darker color on line 452. Then, a slightly smaller \nbox is drawn on top of the darker box on line 453. \nDrawing Everything to the Screen \n456. def drawBoard(board): \n457.     # draw the border around the board \n458.     pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (XMARGIN - 3, TOPMARGIN - \n7, (BOARDWIDTH * BOXSIZE) + 8, (BOARDHEIGHT * BOXSIZE) + 8), 5) \n459.  \n460.     # fill the background of the board \n461.     pygame.draw.rect(DISPLAYSURF, BGCOLOR, (XMARGIN, TOPMARGIN, BOXSIZE * \nBOARDWIDTH, BOXSIZE * BOARDHEIGHT)) \n462.     # draw the individual boxes on the board \n463.     for x in range(BOARDWIDTH): \n464.         for y in range(BOARDHEIGHT): \n465.             drawBox(x, y, board[x][y]) \nThe drawBoard() function is responsible for calling the drawing functions for the board’s \nborder and all the boxes on the board. First the board’s border is drawn on DISPLAYSURF, \nfollowed by the background color of the board. Then a call to drawBox() is made for each \nspace on the board. The drawBox() function is smart enough to leave out the box if \nboard[x][y] is set to BLANK. \nDrawing the Score and Level Text \n468. def drawStatus(score, level): \n469.     # draw the score text \n470.     scoreSurf = BASICFONT.render('Score: %s' % score, True, TEXTCOLOR) \n471.     scoreRect = scoreSurf.get_rect() \n472.     scoreRect.topleft = (WINDOWWIDTH - 150, 20) \n473.     DISPLAYSURF.blit(scoreSurf, scoreRect) \n474.  \n475.     # draw the level text \n476.     levelSurf = BASICFONT.render('Level: %s' % level, True, TEXTCOLOR) \n477.     levelRect = levelSurf.get_rect() \n478.     levelRect.topleft = (WINDOWWIDTH - 150, 50) \n479.     DISPLAYSURF.blit(levelSurf, levelRect) \n",
      "content_length": 2242,
      "extraction_method": "Direct"
    },
    {
      "page_number": 215,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    197 \n \nThe drawStatus() function is responsible for rendering the text for the ―Score:‖ and ―Level:‖ \ninformation that appears in the upper right of the corner of the screen. \nDrawing a Piece on the Board or Elsewhere on the Screen \n482. def drawPiece(piece, pixelx=None, pixely=None): \n483.     shapeToDraw = SHAPES[piece['shape']][piece['rotation']] \n484.     if pixelx == None and pixely == None: \n485.         # if pixelx & pixely hasn't been specified, use the location \nstored in the piece data structure \n486.         pixelx, pixely = convertToPixelCoords(piece['x'], piece['y']) \n487.  \n488.     # draw each of the blocks that make up the piece \n489.     for x in range(TEMPLATEWIDTH): \n490.         for y in range(TEMPLATEHEIGHT): \n491.             if shapeToDraw[y][x] != BLANK: \n492.                 drawBox(None, None, piece['color'], pixelx + (x * \nBOXSIZE), pixely + (y * BOXSIZE)) \nThe drawPiece() function will draw the boxes of a piece according to the piece data structure \nthat is passed to it. This function will be used to draw the falling piece and the ―Next‖ piece. \nSince the piece data structure will contain all of the shape, position, rotation, and color \ninformation, nothing else besides the piece data structure needs to be passed to the function. \nHowever, the ―Next‖ piece is not drawn on the board. In this case, we ignore the position \ninformation stored inside the piece data structure and instead let the caller of the drawPiece() \nfunction pass in arguments for the optional pixelx and pixely parameters to specify where \nexactly on the window the piece should be drawn. \nIf no pixelx and pixely arguments are passed in, then lines 484 and 486 will overwrite those \nvariables with the return values of convertToPixelCoords() call. \nThe nested for loops on line 489 and 490 will then call drawBox() for each box of the piece \nthat needs to be drawn. \nDrawing the “Next” Piece \n495. def drawNextPiece(piece): \n496.     # draw the \"next\" text \n497.     nextSurf = BASICFONT.render('Next:', True, TEXTCOLOR) \n498.     nextRect = nextSurf.get_rect() \n499.     nextRect.topleft = (WINDOWWIDTH - 120, 80) \n500.     DISPLAYSURF.blit(nextSurf, nextRect) \n501.     # draw the \"next\" piece \n502.     drawPiece(piece, pixelx=WINDOWWIDTH-120, pixely=100) \n",
      "content_length": 2305,
      "extraction_method": "Direct"
    },
    {
      "page_number": 216,
      "chapter": null,
      "content": "198    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n503.  \n504.  \n505. if __name__ == '__main__': \n506.     main() \nThe drawNextPiece() draws the ―Next‖ piece in the upper right corner of the screen. It does \nthis by calling the drawPiece() function and passing in arguments for drawPiece()’s \npixelx and pixely parameters. \nThat’s the last function. Line 505 and 506 are run after all the function definitions have been \nexecuted, and then the main() function is called to begin the main part of the program. \nSummary \nThe Tetromino game (which is a clone of the more popular game, ―Tetris‖) is pretty easy to \nexplain to someone in English: ―Blocks fall from the top of a board, and the player moves and \nrotates them so that they form complete lines. The complete lines disappear (giving the player \npoints) and the lines above them move down. The game keeps going until the blocks fill up the \nentire board and the player loses.‖ \nExplaining it in plain English is one thing, but when we have to tell a computer exactly what to \ndo there are many details we have to fill in. The original Tetris game was designed and \nprogrammed one person, Alex Pajitnov, in the Soviet Union in 1984. The game is simple, fun, \nand addictive. It is one of the most popular video games ever made, and has sold 100 million \ncopies with many people creating their own clones and variations of it. \nAnd it was all created by one person who knew how to program. \nWith the right idea and some programming knowledge you can create incredibly fun games. And \nwith some practice, you will be able to turn your game ideas into real programs that might \nbecome as popular as Tetris! \nFor additional programming practice, you can download buggy versions of Tetromino from \nhttp://invpy.com/buggy/tetromino and try to figure out how to fix the bugs. \nThere are also variations of the Tetromino game on the book’s website. ―Pentomino‖ is a version \nof this game with pieces made up of five boxes. There is also ―Tetromino for Idiots‖, where all of \nthe pieces are made up of just one box. \n",
      "content_length": 2114,
      "extraction_method": "Direct"
    },
    {
      "page_number": 217,
      "chapter": null,
      "content": "Chapter 7 - Tetromino    199 \n \n \nThese variations can be downloaded from: \n \nhttp://invpy.com/pentomino.py \n \nhttp://invpy.com/tetrominoforidiots.py \n  \n \n",
      "content_length": 158,
      "extraction_method": "Direct"
    },
    {
      "page_number": 218,
      "chapter": null,
      "content": "200    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nCHAPTER 8 – SQUIRREL EAT \nSQUIRREL \n \n \nHow to Play Squirrel Eat Squirrel \nSquirrel Eat Squirrel is loosely based on the game ―Katamari Damacy‖. The player controls a \nsmall squirrel that must hop around the screen eating smaller squirrels and avoiding larger \nsquirrels. Each time the player’s squirrel eats a squirrel that is smaller than it, it grows larger. If \nthe player’s squirrel gets hit by a larger squirrel larger than it, it loses a life point. The player wins \nwhen the squirrel becomes a monstrously large squirrel called the Omega Squirrel. The player \nloses if their squirrel gets hit three times. \nI’m not really sure where I got the idea for a video game where squirrels eat each other. I’m a \nlittle strange sometimes. \nThe Design of Squirrel Eat Squirrel \nThere are three types of data structures in this game, which are represented as dictionary values. \nThe types are player squirrels, enemy squirrels, and grass objects. There is only one player \nsquirrel object at a time in the game. \nNote: Technically, ―object‖ means something specific in Object-Oriented Programming. Python \ndoes have OOP features, but they aren’t covered in this book. Technically the Pygame objects \nsuch as ―Rect object‖ or ―Surface object‖ are objects. But I’m going to use the term ―object‖ in \nthis book to refer to ―things that exist in the game world‖. But really, the player squirrel, enemy \nsquirrels, and grass ―objects‖ are just dictionary values. \n",
      "content_length": 1559,
      "extraction_method": "Direct"
    },
    {
      "page_number": 219,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    201 \n \nAll the objects have the following keys in their dictionary value: 'x', 'y', and 'rect'. The \n'x' and 'y' key’s value give the coordinates of the top left of the object in game world \ncoordinates. These are different from pixel coordinates (which is what the 'rect' key’s value \ntracks). The difference between game world and pixel coordinates will be explained when you \nlearn about the concept of cameras. \nIn addition, the player squirrel, enemy squirrel, and grass objects have other keys which are \nexplained in a large comment at the start of the source code.  \nSource Code to Squirrel Eat Squirrel \nThis source code can be downloaded from http://invpy.com/squirrel.py. If you get any error \nmessages, look at the line number that is mentioned in the error message and check your code for \nany typos. You can also copy and paste your code into the web form at \nhttp://invpy.com/diff/squirrel to see if the differences between your code and the code in the \nbook. \nYou will also need to download the following image files: \n \nhttp://invpy.com/gameicon.png \n \nhttp://invpy.com/squirrel.png \n \nhttp://invpy.com/grass1.png \n \nhttp://invpy.com/grass2.png \n \nhttp://invpy.com/grass3.png \n \nhttp://invpy.com/grass4.png \n  1. # Squirrel Eat Squirrel (a 2D Katamari Damacy clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, sys, time, math, pygame \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 # frames per second to update the screen \n 10. WINWIDTH = 640 # width of the program's window, in pixels \n 11. WINHEIGHT = 480 # height in pixels \n 12. HALF_WINWIDTH = int(WINWIDTH / 2) \n 13. HALF_WINHEIGHT = int(WINHEIGHT / 2) \n 14.  \n 15. GRASSCOLOR = (24, 255, 0) \n 16. WHITE = (255, 255, 255) \n 17. RED = (255, 0, 0) \n 18.  \n",
      "content_length": 1895,
      "extraction_method": "Direct"
    },
    {
      "page_number": 220,
      "chapter": null,
      "content": "202    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 19. CAMERASLACK = 90     # how far from the center the squirrel moves before \nmoving the camera \n 20. MOVERATE = 9         # how fast the player moves \n 21. BOUNCERATE = 6       # how fast the player bounces (large is slower) \n 22. BOUNCEHEIGHT = 30    # how high the player bounces \n 23. STARTSIZE = 25       # how big the player starts off \n 24. WINSIZE = 300        # how big the player needs to be to win \n 25. INVULNTIME = 2       # how long the player is invulnerable after being hit \nin seconds \n 26. GAMEOVERTIME = 4     # how long the \"game over\" text stays on the screen \nin seconds \n 27. MAXHEALTH = 3        # how much health the player starts with \n 28.  \n 29. NUMGRASS = 80        # number of grass objects in the active area \n 30. NUMSQUIRRELS = 30    # number of squirrels in the active area \n 31. SQUIRRELMINSPEED = 3 # slowest squirrel speed \n 32. SQUIRRELMAXSPEED = 7 # fastest squirrel speed \n 33. DIRCHANGEFREQ = 2    # % chance of direction change per frame \n 34. LEFT = 'left' \n 35. RIGHT = 'right' \n 36.  \n 37. \"\"\" \n 38. This program has three data structures to represent the player, enemy \nsquirrels, and grass background objects. The data structures are dictionaries \nwith the following keys: \n 39.  \n 40. Keys used by all three data structures: \n 41.     'x' - the left edge coordinate of the object in the game world (not a \npixel coordinate on the screen) \n 42.     'y' - the top edge coordinate of the object in the game world (not a \npixel coordinate on the screen) \n 43.     'rect' - the pygame.Rect object representing where on the screen the \nobject is located. \n 44. Player data structure keys: \n 45.     'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen. \n 46.     'facing' - either set to LEFT or RIGHT, stores which direction the \nplayer is facing. \n 47.     'size' - the width and height of the player in pixels. (The width & \nheight are always the same.) \n 48.     'bounce' - represents at what point in a bounce the player is in. 0 \nmeans standing (no bounce), up to BOUNCERATE (the completion of the bounce) \n 49.     'health' - an integer showing how many more times the player can be \nhit by a larger squirrel before dying. \n 50. Enemy Squirrel data structure keys: \n",
      "content_length": 2377,
      "extraction_method": "Direct"
    },
    {
      "page_number": 221,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    203 \n \n 51.     'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen. \n 52.     'movex' - how many pixels per frame the squirrel moves horizontally. A \nnegative integer is moving to the left, a positive to the right. \n 53.     'movey' - how many pixels per frame the squirrel moves vertically. A \nnegative integer is moving up, a positive moving down. \n 54.     'width' - the width of the squirrel's image, in pixels \n 55.     'height' - the height of the squirrel's image, in pixels \n 56.     'bounce' - represents at what point in a bounce the player is in. 0 \nmeans standing (no bounce), up to BOUNCERATE (the completion of the bounce) \n 57.     'bouncerate' - how quickly the squirrel bounces. A lower number means \na quicker bounce. \n 58.     'bounceheight' - how high (in pixels) the squirrel bounces \n 59. Grass data structure keys: \n 60.     'grassImage' - an integer that refers to the index of the \npygame.Surface object in GRASSIMAGES used for this grass object \n 61. \"\"\" \n 62.  \n 63. def main(): \n 64.     global FPSCLOCK, DISPLAYSURF, BASICFONT, L_SQUIR_IMG, R_SQUIR_IMG, \nGRASSIMAGES \n 65.  \n 66.     pygame.init() \n 67.     FPSCLOCK = pygame.time.Clock() \n 68.     pygame.display.set_icon(pygame.image.load('gameicon.png')) \n 69.     DISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT)) \n 70.     pygame.display.set_caption('Squirrel Eat Squirrel') \n 71.     BASICFONT = pygame.font.Font('freesansbold.ttf', 32) \n 72.  \n 73.     # load the image files \n 74.     L_SQUIR_IMG = pygame.image.load('squirrel.png') \n 75.     R_SQUIR_IMG = pygame.transform.flip(L_SQUIR_IMG, True, False) \n 76.     GRASSIMAGES = [] \n 77.     for i in range(1, 5): \n 78.         GRASSIMAGES.append(pygame.image.load('grass%s.png' % i)) \n 79.  \n 80.     while True: \n 81.         runGame() \n 82.  \n 83.  \n 84. def runGame(): \n 85.     # set up variables for the start of a new game \n 86.     invulnerableMode = False  # if the player is invulnerable \n 87.     invulnerableStartTime = 0 # time the player became invulnerable \n 88.     gameOverMode = False      # if the player has lost \n 89.     gameOverStartTime = 0     # time the player lost \n",
      "content_length": 2238,
      "extraction_method": "Direct"
    },
    {
      "page_number": 222,
      "chapter": null,
      "content": "204    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 90.     winMode = False           # if the player has won \n 91.      \n 92.     # create the surfaces to hold game text \n 93.     gameOverSurf = BASICFONT.render('Game Over', True, WHITE) \n 94.     gameOverRect = gameOverSurf.get_rect() \n 95.     gameOverRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT) \n 96.  \n 97.     winSurf = BASICFONT.render('You have achieved OMEGA SQUIRREL!', True, \nWHITE) \n 98.     winRect = winSurf.get_rect() \n 99.     winRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT) \n100.  \n101.     winSurf2 = BASICFONT.render('(Press \"r\" to restart.)', True, WHITE) \n102.     winRect2 = winSurf2.get_rect() \n103.     winRect2.center = (HALF_WINWIDTH, HALF_WINHEIGHT + 30) \n104.  \n105.     # camerax and cameray are where the middle of the camera view is \n106.     camerax = 0 \n107.     cameray = 0 \n108.  \n109.     grassObjs = []    # stores all the grass objects in the game \n110.     squirrelObjs = [] # stores all the non-player squirrel objects \n111.     # stores the player object: \n112.     playerObj = {'surface': pygame.transform.scale(L_SQUIR_IMG, \n(STARTSIZE, STARTSIZE)), \n113.                  'facing': LEFT, \n114.                  'size': STARTSIZE, \n115.                  'x': HALF_WINWIDTH, \n116.                  'y': HALF_WINHEIGHT, \n117.                  'bounce':0, \n118.                  'health': MAXHEALTH} \n119.  \n120.     moveLeft  = False \n121.     moveRight = False \n122.     moveUp    = False \n123.     moveDown  = False \n124.  \n125.     # start off with some random grass images on the screen \n126.     for i in range(10): \n127.         grassObjs.append(makeNewGrass(camerax, cameray)) \n128.         grassObjs[i]['x'] = random.randint(0, WINWIDTH) \n129.         grassObjs[i]['y'] = random.randint(0, WINHEIGHT) \n130.  \n131.     while True: # main game loop \n132.         # Check if we should turn off invulnerability \n",
      "content_length": 1963,
      "extraction_method": "Direct"
    },
    {
      "page_number": 223,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    205 \n \n133.         if invulnerableMode and time.time() - invulnerableStartTime > \nINVULNTIME: \n134.             invulnerableMode = False \n135.  \n136.         # move all the squirrels \n137.         for sObj in squirrelObjs: \n138.             # move the squirrel, and adjust for their bounce \n139.             sObj['x'] += sObj['movex'] \n140.             sObj['y'] += sObj['movey'] \n141.             sObj['bounce'] += 1 \n142.             if sObj['bounce'] > sObj['bouncerate']: \n143.                 sObj['bounce'] = 0 # reset bounce amount \n144. \n145.             # random chance they change direction \n146.             if random.randint(0, 99) < DIRCHANGEFREQ: \n147.                 sObj['movex'] = getRandomVelocity() \n148.                 sObj['movey'] = getRandomVelocity() \n149.                 if sObj['movex'] > 0: # faces right \n150.                     sObj['surface'] = pygame.transform.scale(R_SQUIR_IMG, \n(sObj['width'], sObj['height'])) \n151.                 else: # faces left \n152.                     sObj['surface'] = pygame.transform.scale(L_SQUIR_IMG, \n(sObj['width'], sObj['height'])) \n153. \n154.  \n155.         # go through all the objects and see if any need to be deleted. \n156.         for i in range(len(grassObjs) - 1, -1, -1): \n157.             if isOutsideActiveArea(camerax, cameray, grassObjs[i]): \n158.                 del grassObjs[i] \n159.         for i in range(len(squirrelObjs) - 1, -1, -1): \n160.             if isOutsideActiveArea(camerax, cameray, squirrelObjs[i]): \n161.                 del squirrelObjs[i] \n162.  \n163.         # add more grass & squirrels if we don't have enough. \n164.         while len(grassObjs) < NUMGRASS: \n165.             grassObjs.append(makeNewGrass(camerax, cameray)) \n166.         while len(squirrelObjs) < NUMSQUIRRELS: \n167.             squirrelObjs.append(makeNewSquirrel(camerax, cameray)) \n168.  \n169.         # adjust camerax and cameray if beyond the \"camera slack\" \n170.         playerCenterx = playerObj['x'] + int(playerObj['size'] / 2) \n171.         playerCentery = playerObj['y'] + int(playerObj['size'] / 2) \n172.         if (camerax + HALF_WINWIDTH) - playerCenterx > CAMERASLACK: \n173.             camerax = playerCenterx + CAMERASLACK - HALF_WINWIDTH \n174.         elif playerCenterx – (camerax + HALF_WINWIDTH) > CAMERASLACK: \n175.             camerax = playerCenterx – CAMERASLACK - HALF_WINWIDTH \n",
      "content_length": 2422,
      "extraction_method": "Direct"
    },
    {
      "page_number": 224,
      "chapter": null,
      "content": "206    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n176.         if (cameray + HALF_WINHEIGHT) - playerCentery > CAMERASLACK: \n177.             cameray = playerCentery + CAMERASLACK - HALF_WINHEIGHT \n178.         elif playerCentery – (cameray + HALF_WINHEIGHT) > CAMERASLACK: \n179.             cameray = playerCentery – CAMERASLACK - HALF_WINHEIGHT \n180.  \n181.         # draw the green background \n182.         DISPLAYSURF.fill(GRASSCOLOR) \n183.  \n184.         # draw all the grass objects on the screen \n185.         for gObj in grassObjs: \n186.             gRect = pygame.Rect( (gObj['x'] - camerax, \n187.                                   gObj['y'] - cameray, \n188.                                   gObj['width'], \n189.                                   gObj['height']) ) \n190.             DISPLAYSURF.blit(GRASSIMAGES[gObj['grassImage']], gRect) \n191. \n192.  \n193.         # draw the other squirrels \n194.         for sObj in squirrelObjs: \n195.             sObj['rect'] = pygame.Rect( (sObj['x'] - camerax, \n196.                                          sObj['y'] - cameray - \ngetBounceAmount(sObj['bounce'], sObj['bouncerate'], sObj['bounceheight']), \n197.                                          sObj['width'], \n198.                                          sObj['height']) ) \n199.             DISPLAYSURF.blit(sObj['surface'], sObj['rect']) \n200. \n201.  \n202.         # draw the player squirrel \n203.         flashIsOn = round(time.time(), 1) * 10 % 2 == 1 \n204.         if not gameOverMode and not (invulnerableMode and flashIsOn): \n205.             playerObj['rect'] = pygame.Rect( (playerObj['x'] - camerax, \n206.                                               playerObj['y'] – cameray - \ngetBounceAmount(playerObj['bounce'], BOUNCERATE, BOUNCEHEIGHT), \n207.                                               playerObj['size'], \n208.                                               playerObj['size']) ) \n209.             DISPLAYSURF.blit(playerObj['surface'], playerObj['rect']) \n210. \n211.  \n212.         # draw the health meter \n213.         drawHealthMeter(playerObj['health']) \n214.  \n215.         for event in pygame.event.get(): # event handling loop \n216.             if event.type == QUIT: \n217.                 terminate() \n218. \n219.             elif event.type == KEYDOWN: \n",
      "content_length": 2343,
      "extraction_method": "Direct"
    },
    {
      "page_number": 225,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    207 \n \n220.                 if event.key in (K_UP, K_w): \n221.                     moveDown = False \n222.                     moveUp = True \n223.                 elif event.key in (K_DOWN, K_s): \n224.                     moveUp = False \n225.                     moveDown = True \n226.                 elif event.key in (K_LEFT, K_a): \n227.                     moveRight = False \n228.                     moveLeft = True \n229.                     if playerObj['facing'] == RIGHT: # change player image \n230.                         playerObj['surface'] = \npygame.transform.scale(L_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n231.                     playerObj['facing'] = LEFT \n232.                 elif event.key in (K_RIGHT, K_d): \n233.                     moveLeft = False \n234.                     moveRight = True \n235.                     if playerObj['facing'] == LEFT: # change player image \n236.                         playerObj['surface'] = \npygame.transform.scale(R_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n237.                     playerObj['facing'] = RIGHT \n238.                 elif winMode and event.key == K_r: \n239.                     return \n240. \n241.             elif event.type == KEYUP: \n242.                 # stop moving the player's squirrel \n243.                 if event.key in (K_LEFT, K_a): \n244.                     moveLeft = False \n245.                 elif event.key in (K_RIGHT, K_d): \n246.                     moveRight = False \n247.                 elif event.key in (K_UP, K_w): \n248.                     moveUp = False \n249.                 elif event.key in (K_DOWN, K_s): \n250.                     moveDown = False \n251. \n252.                 elif event.key == K_ESCAPE: \n253.                     terminate() \n254. \n255.         if not gameOverMode: \n256.             # actually move the player \n257.             if moveLeft: \n258.                 playerObj['x'] -= MOVERATE \n259.             if moveRight: \n260.                 playerObj['x'] += MOVERATE \n261.             if moveUp: \n262.                 playerObj['y'] -= MOVERATE \n263.             if moveDown: \n",
      "content_length": 2163,
      "extraction_method": "Direct"
    },
    {
      "page_number": 226,
      "chapter": null,
      "content": "208    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n264.                 playerObj['y'] += MOVERATE \n265. \n266.             if (moveLeft or moveRight or moveUp or moveDown) or \nplayerObj['bounce'] != 0: \n267.                 playerObj['bounce'] += 1 \n268.  \n269.             if playerObj['bounce'] > BOUNCERATE: \n270.                 playerObj['bounce'] = 0 # reset bounce amount \n271. \n272.             # check if the player has collided with any squirrels \n273.             for i in range(len(squirrelObjs)-1, -1, -1): \n274.                 sqObj = squirrelObjs[i] \n275.                 if 'rect' in sqObj and \nplayerObj['rect'].colliderect(sqObj['rect']): \n276.                     # a player/squirrel collision has occurred \n277. \n278.                     if sqObj['width'] * sqObj['height'] <= \nplayerObj['size']**2: \n279.                         # player is larger and eats the squirrel \n280.                         playerObj['size'] += int( (sqObj['width'] * \nsqObj['height'])**0.2 ) + 1 \n281.                         del squirrelObjs[i] \n282. \n283.                         if playerObj['facing'] == LEFT: \n284.                             playerObj['surface'] = \npygame.transform.scale(L_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n285.                         if playerObj['facing'] == RIGHT: \n286.                             playerObj['surface'] = \npygame.transform.scale(R_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n287. \n288.                         if playerObj['size'] > WINSIZE: \n289.                             winMode = True # turn on \"win mode\" \n290. \n291.                     elif not invulnerableMode: \n292.                         # player is smaller and takes damage \n293.                         invulnerableMode = True \n294.                         invulnerableStartTime = time.time() \n295.                         playerObj['health'] -= 1 \n296.                         if playerObj['health'] == 0: \n297.                             gameOverMode = True # turn on \"game over mode\" \n298.                             gameOverStartTime = time.time() \n299.         else: \n300.             # game is over, show \"game over\" text \n301.             DISPLAYSURF.blit(gameOverSurf, gameOverRect) \n302.             if time.time() - gameOverStartTime > GAMEOVERTIME: \n303.                 return # end the current game \n",
      "content_length": 2402,
      "extraction_method": "Direct"
    },
    {
      "page_number": 227,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    209 \n \n304.  \n305.         # check if the player has won. \n306.         if winMode: \n307.             DISPLAYSURF.blit(winSurf, winRect) \n308.             DISPLAYSURF.blit(winSurf2, winRect2) \n309.  \n310.         pygame.display.update() \n311.         FPSCLOCK.tick(FPS) \n312.  \n313.  \n314. \n315. \n316. def drawHealthMeter(currentHealth): \n317.     for i in range(currentHealth): # draw red health bars \n318.         pygame.draw.rect(DISPLAYSURF, RED,   (15, 5 + (10 * MAXHEALTH) - i \n* 10, 20, 10)) \n319.     for i in range(MAXHEALTH): # draw the white outlines \n320.         pygame.draw.rect(DISPLAYSURF, WHITE, (15, 5 + (10 * MAXHEALTH) - i \n* 10, 20, 10), 1) \n321.  \n322.  \n323. def terminate(): \n324.     pygame.quit() \n325.     sys.exit() \n326. \n327. \n328. def getBounceAmount(currentBounce, bounceRate, bounceHeight): \n329.     # Returns the number of pixels to offset based on the bounce. \n330.     # Larger bounceRate means a slower bounce. \n331.     # Larger bounceHeight means a higher bounce. \n332.     # currentBounce will always be less than bounceRate \n333.     return int(math.sin( (math.pi / float(bounceRate)) * currentBounce ) * \nbounceHeight) \n334. \n335. def getRandomVelocity(): \n336.     speed = random.randint(SQUIRRELMINSPEED, SQUIRRELMAXSPEED) \n337.     if random.randint(0, 1) == 0: \n338.         return speed \n339.     else: \n340.         return -speed \n341.  \n342.  \n343. def getRandomOffCameraPos(camerax, cameray, objWidth, objHeight): \n344.     # create a Rect of the camera view \n345.     cameraRect = pygame.Rect(camerax, cameray, WINWIDTH, WINHEIGHT) \n346.     while True: \n",
      "content_length": 1644,
      "extraction_method": "Direct"
    },
    {
      "page_number": 228,
      "chapter": null,
      "content": "210    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n347.         x = random.randint(camerax - WINWIDTH, camerax + (2 * WINWIDTH)) \n348.         y = random.randint(cameray - WINHEIGHT, cameray + (2 * WINHEIGHT)) \n349.         # create a Rect object with the random coordinates and use \ncolliderect() \n350.         # to make sure the right edge isn't in the camera view. \n351.         objRect = pygame.Rect(x, y, objWidth, objHeight) \n352.         if not objRect.colliderect(cameraRect): \n353.             return x, y \n354.  \n355.  \n356. def makeNewSquirrel(camerax, cameray): \n357.     sq = {} \n358.     generalSize = random.randint(5, 25) \n359.     multiplier = random.randint(1, 3) \n360.     sq['width']  = (generalSize + random.randint(0, 10)) * multiplier \n361.     sq['height'] = (generalSize + random.randint(0, 10)) * multiplier \n362.     sq['x'], sq['y'] = getRandomOffCameraPos(camerax, cameray, \nsq['width'], sq['height']) \n363.     sq['movex'] = getRandomVelocity() \n364.     sq['movey'] = getRandomVelocity() \n365.     if sq['movex'] < 0: # squirrel is facing left \n366.         sq['surface'] = pygame.transform.scale(L_SQUIR_IMG, (sq['width'], \nsq['height'])) \n367.     else: # squirrel is facing right \n368.         sq['surface'] = pygame.transform.scale(R_SQUIR_IMG, (sq['width'], \nsq['height'])) \n369.     sq['bounce'] = 0 \n370.     sq['bouncerate'] = random.randint(10, 18) \n371.     sq['bounceheight'] = random.randint(10, 50) \n372.     return sq \n373.  \n374.  \n375. def makeNewGrass(camerax, cameray): \n376.     gr = {} \n377.     gr['grassImage'] = random.randint(0, len(GRASSIMAGES) - 1) \n378.     gr['width']  = GRASSIMAGES[0].get_width() \n379.     gr['height'] = GRASSIMAGES[0].get_height() \n380.     gr['x'], gr['y'] = getRandomOffCameraPos(camerax, cameray, \ngr['width'], gr['height']) \n381.     gr['rect'] = pygame.Rect( (gr['x'], gr['y'], gr['width'], \ngr['height']) ) \n382.     return gr \n383. \n384. \n385. def isOutsideActiveArea(camerax, cameray, obj): \n386.     # Return False if camerax and cameray are more than \n",
      "content_length": 2094,
      "extraction_method": "Direct"
    },
    {
      "page_number": 229,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    211 \n \n387.     # a half-window length beyond the edge of the window. \n388.     boundsLeftEdge = camerax - WINWIDTH \n389.     boundsTopEdge = cameray - WINHEIGHT \n390.     boundsRect = pygame.Rect(boundsLeftEdge, boundsTopEdge, WINWIDTH * 3, \nWINHEIGHT * 3) \n391.     objRect = pygame.Rect(obj['x'], obj['y'], obj['width'], obj['height']) \n392.     return not boundsRect.colliderect(objRect) \n393.  \n394.  \n395. if __name__ == '__main__': \n396.     main() \nThe Usual Setup Code \n  1. # Squirrel Eat Squirrel (a 2D Katamari Damacy clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, sys, time, math, pygame \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 # frames per second to update the screen \n 10. WINWIDTH = 640 # width of the program's window, in pixels \n 11. WINHEIGHT = 480 # height in pixels \n 12. HALF_WINWIDTH = int(WINWIDTH / 2) \n 13. HALF_WINHEIGHT = int(WINHEIGHT / 2) \n 14.  \n 15. GRASSCOLOR = (24, 255, 0) \n 16. WHITE = (255, 255, 255) \n 17. RED = (255, 0, 0) \nThe start of the program assigns several constant variables. This program frequently makes use of \nthe half length of the width and height of the window so much that the HALF_WINWIDTH and \nHALF_WINHEIGHT variables store these numbers. \n 19. CAMERASLACK = 90     # how far from the center the squirrel moves before \nmoving the camera \nThe ―camera slack‖ is described later. Basically, it means that the camera will begin following the \nplayer squirrel when it moves 90 pixels away from the center of the window. \n 20. MOVERATE = 9         # how fast the player moves \n 21. BOUNCERATE = 6       # how fast the player bounces (large is slower) \n",
      "content_length": 1777,
      "extraction_method": "Direct"
    },
    {
      "page_number": 230,
      "chapter": null,
      "content": "212    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 22. BOUNCEHEIGHT = 30    # how high the player bounces \n 23. STARTSIZE = 25       # how big the player starts off \n 24. WINSIZE = 300        # how big the player needs to be to win \n 25. INVULNTIME = 2       # how long the player is invulnerable after being hit \nin seconds \n 26. GAMEOVERTIME = 4     # how long the \"game over\" text stays on the screen \nin seconds \n 27. MAXHEALTH = 3        # how much health the player starts with \n 28.  \n 29. NUMGRASS = 80        # number of grass objects in the active area \n 30. NUMSQUIRRELS = 30    # number of squirrels in the active area \n 31. SQUIRRELMINSPEED = 3 # slowest squirrel speed \n 32. SQUIRRELMAXSPEED = 7 # fastest squirrel speed \n 33. DIRCHANGEFREQ = 2    # % chance of direction change per frame \n 34. LEFT = 'left' \n 35. RIGHT = 'right' \nThe comments next to these constants explains what the constant variable is used for.  \nDescribing the Data Structures \n 37. \"\"\" \n 38. This program has three data structures to represent the player, enemy \nsquirrels, and grass background objects. The data structures are dictionaries \nwith the following keys: \n 39.  \n 40. Keys used by all three data structures: \n 41.     'x' - the left edge coordinate of the object in the game world (not a \npixel coordinate on the screen) \n 42.     'y' - the top edge coordinate of the object in the game world (not a \npixel coordinate on the screen) \n 43.     'rect' - the pygame.Rect object representing where on the screen the \nobject is located. \n 44. Player data structure keys: \n 45.     'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen. \n 46.     'facing' - either set to LEFT or RIGHT, stores which direction the \nplayer is facing. \n 47.     'size' - the width and height of the player in pixels. (The width & \nheight are always the same.) \n 48.     'bounce' - represents at what point in a bounce the player is in. 0 \nmeans standing (no bounce), up to BOUNCERATE (the completion of the bounce) \n 49.     'health' - an integer showing how many more times the player can be \nhit by a larger squirrel before dying. \n 50. Enemy Squirrel data structure keys: \n",
      "content_length": 2262,
      "extraction_method": "Direct"
    },
    {
      "page_number": 231,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    213 \n \n 51.     'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen. \n 52.     'movex' - how many pixels per frame the squirrel moves horizontally. A \nnegative integer is moving to the left, a positive to the right. \n 53.     'movey' - how many pixels per frame the squirrel moves vertically. A \nnegative integer is moving up, a positive moving down. \n 54.     'width' - the width of the squirrel's image, in pixels \n 55.     'height' - the height of the squirrel's image, in pixels \n 56.     'bounce' - represents at what point in a bounce the player is in. 0 \nmeans standing (no bounce), up to BOUNCERATE (the completion of the bounce) \n 57.     'bouncerate' - how quickly the squirrel bounces. A lower number means \na quicker bounce. \n 58.     'bounceheight' - how high (in pixels) the squirrel bounces \n 59. Grass data structure keys: \n 60.     'grassImage' - an integer that refers to the index of the \npygame.Surface object in GRASSIMAGES used for this grass object \n 61. \"\"\" \nThe comments from lines 37 to 61 are in one large, multi-line string. They describe the keys in \nthe player squirrel, enemy squirrel, and grass objects. In Python, a multi-line string value by itself \nworks as a multi-line comment. \nThe main() Function \n 63. def main(): \n 64.     global FPSCLOCK, DISPLAYSURF, BASICFONT, L_SQUIR_IMG, R_SQUIR_IMG, \nGRASSIMAGES \n 65.  \n 66.     pygame.init() \n 67.     FPSCLOCK = pygame.time.Clock() \n 68.     pygame.display.set_icon(pygame.image.load('gameicon.png')) \n 69.     DISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT)) \n 70.     pygame.display.set_caption('Squirrel Eat Squirrel') \n 71.     BASICFONT = pygame.font.Font('freesansbold.ttf', 32) \nThe first several lines of the main() function are the same setup code that we’ve seen in our \nprevious game programs. The pygame.display.set_icon() is a Pygame function that \nsets the icon in the window’s title bar (just like pygame.display.set_caption() sets the \ncaption text in the title bar). The single argument to pygame.display.set_icon() is a \nSurface object of a small image. The ideal image size is 32 x 32 pixels, although you can use \nother sized images. The image will just be compressed into a smaller size to be used as the \nwindow’s icon. \n",
      "content_length": 2335,
      "extraction_method": "Direct"
    },
    {
      "page_number": 232,
      "chapter": null,
      "content": "214    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe pygame.transform.flip() Function \n 73.     # load the image files \n 74.     L_SQUIR_IMG = pygame.image.load('squirrel.png') \n 75.     R_SQUIR_IMG = pygame.transform.flip(L_SQUIR_IMG, True, False) \n 76.     GRASSIMAGES = [] \n 77.     for i in range(1, 5): \n 78.         GRASSIMAGES.append(pygame.image.load('grass%s.png' % i)) \nThe image for the player and enemy squirrels is loaded from squirrel.png on line 74. Make sure \nthat this PNG file is in the same folder as squirrel.py, otherwise you will get the error \npygame.error: Couldn't open squirrel.png. \nThe image in squirrel.png (which you can download from http://invpy.com/squirrel.png) is of a \nsquirrel facing to the left. We also need a Surface object that contains a picture of the squirrel \nfacing to the right. Instead of creating a second PNG image file, we can call the \npygame.transform.flip() function. This function has three parameters: the Surface \nobject with the image to flip, a Boolean value to do a horizontal flip, and a Boolean value to do a \nvertical flip. By passing True for the second parameter and False for the third parameter, the \nSurface object that returns has the image of the squirrel facing to the right. The original Surface \nobject in L_SQUIR_IMG that we passed in is unchanged. \nHere are examples of images being horizontally and vertically flipped: \n \n \n \n \nOriginal \nHorizontal Flip \nVertical Flip \nHorizontal and \nVertical Flip \n \n 80.     while True: \n 81.         runGame() \nAfter the setup in main() is complete, the game begins with runGame() being called.  \nA More Detailed Game State than Usual \n 84. def runGame(): \n 85.     # set up variables for the start of a new game \n",
      "content_length": 1782,
      "extraction_method": "Direct"
    },
    {
      "page_number": 233,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    215 \n \n 86.     invulnerableMode = False  # if the player is invulnerable \n 87.     invulnerableStartTime = 0 # time the player became invulnerable \n 88.     gameOverMode = False      # if the player has lost \n 89.     gameOverStartTime = 0     # time the player lost \n 90.     winMode = False           # if the player has won \nThe Squirrel Eat Squirrel game has quite a few variables that track the game state. These \nvariables will be explained in more detail later when they are used in the code. \nThe Usual Text Creation Code \n 92.     # create the surfaces to hold game text \n 93.     gameOverSurf = BASICFONT.render('Game Over', True, WHITE) \n 94.     gameOverRect = gameOverSurf.get_rect() \n 95.     gameOverRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT) \n 96.  \n 97.     winSurf = BASICFONT.render('You have achieved OMEGA SQUIRREL!', True, \nWHITE) \n 98.     winRect = winSurf.get_rect() \n 99.     winRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT) \n100.  \n101.     winSurf2 = BASICFONT.render('(Press \"r\" to restart.)', True, WHITE) \n102.     winRect2 = winSurf2.get_rect() \n103.     winRect2.center = (HALF_WINWIDTH, HALF_WINHEIGHT + 30) \nThese variables contain Surface objects with the ―Game Over‖, ―You have achieved OMEGA \nSQUIRREL!‖, and ―(Press \"r\" to restart.)‖ text that appears on the screen after the game ends \n(with either the player losing or winning). \nCameras \n105.     # camerax and cameray are where the middle of the camera view is \n106.     camerax = 0 \n107.     cameray = 0 \nThe camerax and cameray variables track the game coordinates of the ―camera‖. Imagine the \ngame world as an infinite 2D space. This could, of course, never fit on any screen. We can only \ndraw a portion of the infinite 2D space on the screen. We call the area of this portion a camera, \nbecause it is as though our screen is just the area of the game world in front what a camera would \nsee. Here’s a picture of the game world (an infinite green field) and the area that the camera can \nview: \n",
      "content_length": 2034,
      "extraction_method": "Direct"
    },
    {
      "page_number": 234,
      "chapter": null,
      "content": "216    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nAs you can see, the game world XY coordinates keep getting bigger and smaller forever. The \ngame world origin is where the (0, 0) game world coordinates are. You can see that the three \nsquirrels are located (in game world coordinates) at (-384, -84), (384, 306), and (585, -234). \nBut we can only display 640 x 480 pixel area on the screen (though this can change if we pass \ndifferent numbers to the pygame.display.set_mode() function), so we need to track \nwhere the camera’s origin is located in game world coordinates. In the picture above, the camera \nis placed at (-486, -330) in game world coordinates. \nThe picture below shows the same field and squirrels, except everything is given in camera \ncoordinates: \n",
      "content_length": 823,
      "extraction_method": "Direct"
    },
    {
      "page_number": 235,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    217 \n \n \nThe area that the camera can see (called the camera view) has it’s center (that is, its origin) at the \ngame world coordinates (-486, -330). Since what the camera sees is displayed on the player’s \nscreen, the ―camera‖ coordinates are the same as the ―pixel‖ coordinates. To find out the pixel \ncoordinates of the squirrels (that is, where on the screen they appear), take the game coordinates \nof the squirrel and subtract the game coordinates of the camera’s origin. \nSo the squirrel on the left has game world coordinates of (-384, -84) but appears at (102, 246) on \nthe screen in pixel coordinates. (For the X coordinate, -384 - -486 = 102 and for the Y coordinate, \n-84 - -330 = 246.) \nWhen we do the same calculation to find the pixel coordinates of the other two squirrels, we find \nthat they exist outside of the range of the screen. This is why they don’t appear in the camera’s \nview. \nThe “Active Area” \nThe ―active area‖ is just a name I came up with to describe the area of the game world that the \ncamera views plus an area around it the size of the camera area: \n \n",
      "content_length": 1126,
      "extraction_method": "Direct"
    },
    {
      "page_number": 236,
      "chapter": null,
      "content": "218    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nCalculating if something is in the active area or not is explained in the \nisOutsideActiveArea() function’s explanation later in this chapter. When we create new \nenemy squirrel or grass objects, we don’t want them to be created inside the view of the camera, \nsince it’ll appear that they just pop out of nowhere. \nBut we also don’t want to create them too far away from the camera, because then they may \nnever wander into the camera’s view. Inside the active area but outside the camera is where \nsquirrel and grass objects can safely be created. \nAlso, when squirrel and grass objects are beyond the border of the active area then they are far \naway enough to delete so that they don’t take up memory any more. Objects that far away aren’t \nneeded since it is much less likely that they’ll come back into view of the camera. \nIf you have ever played Super Mario World on the Super Nintendo, there is a good YouTube \nvideo explaining how Super Mario World’s camera system works. You can find this video at \nhttp://invpy.com/mariocamera. \nKeeping Track of the Location of Things in the Game World \n109.     grassObjs = []    # stores all the grass objects in the game \n110.     squirrelObjs = [] # stores all the non-player squirrel objects \n111.     # stores the player object: \n112.     playerObj = {'surface': pygame.transform.scale(L_SQUIR_IMG, \n(STARTSIZE, STARTSIZE)), \n113.                  'facing': LEFT, \n114.                  'size': STARTSIZE, \n115.                  'x': HALF_WINWIDTH, \n116.                  'y': HALF_WINHEIGHT, \n117.                  'bounce':0, \n118.                  'health': MAXHEALTH} \n119.  \n120.     moveLeft  = False \n121.     moveRight = False \n122.     moveUp    = False \n123.     moveDown  = False \nThe grassObjs variable holds a list of all the grass objects in the game. As new grass objects \nare created, they are added to this list. As grass objects are deleted, they are removed from this \nlist. The same goes for the squirrelObjs variable and the enemy squirrel objects. \nThe playerObj variable is not a list, but just the dictionary value itself. \nThe move variables on lines 120 to 123 track which of arrow keys (or WASD keys) are being \nheld down, just like in a few of the previous game programs. \n",
      "content_length": 2356,
      "extraction_method": "Direct"
    },
    {
      "page_number": 237,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    219 \n \nStarting Off with Some Grass \n125.     # start off with some random grass images on the screen \n126.     for i in range(10): \n127.         grassObjs.append(makeNewGrass(camerax, cameray)) \n128.         grassObjs[i]['x'] = random.randint(0, WINWIDTH) \n129.         grassObjs[i]['y'] = random.randint(0, WINHEIGHT) \nThe active area should start off with a few grass objects visible on the screen. The \nmakeNewGrass() function will create and return a grass object that is randomly located \nsomewhere in the active area but outside the camera view. This is what we normally want when \nwe call makeNewGrass(), but since we want to make sure the first few grass objects are on the \nscreen, the X and Y coordinates are overwritten. \nThe Game Loop \n131.     while True: # main game loop \nThe game loop, like the game loops in the previous game programs, will do event handling, \nupdating the game state, and drawing everything to the screen. \nChecking to Disable Invulnerability \n132.         # Check if we should turn off invulnerability \n133.         if invulnerableMode and time.time() - invulnerableStartTime > \nINVULNTIME: \n134.             invulnerableMode = False \nWhen the player gets hit by an enemy squirrel and does not die, we make the player invulnerable \nfor a couple seconds (since the INVULNTIME constant is set to 2). During this time, the player’s \nsquirrel flashes and the won’t take any damage from other squirrels. If the ―invulnerability mode‖ \ntime is over, line 134 will set invulnerableMode to False. \nMoving the Enemy Squirrels \n136.         # move all the squirrels \n137.         for sObj in squirrelObjs: \n138.             # move the squirrel, and adjust for their bounce \n139.             sObj['x'] += sObj['movex'] \n140.             sObj['y'] += sObj['movey'] \nThe enemy squirrels all move according to the values in their 'movex' and 'movey' keys. If \nthese values are positive, the squirrels move right or down. If these values are negative, they \n",
      "content_length": 2017,
      "extraction_method": "Direct"
    },
    {
      "page_number": 238,
      "chapter": null,
      "content": "220    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nmove left or up. The larger the value, the farther they move on each iteration through the game \nloop (which means they move faster). \nThe for loop on line 137 will apply this moving code to each of the enemy squirrel objects in the \nsquirrelObjs list. First, line 139 and 140 will adjust their 'x' and 'y' keys’ values. \n141.             sObj['bounce'] += 1 \n142.             if sObj['bounce'] > sObj['bouncerate']: \n143.                 sObj['bounce'] = 0 # reset bounce amount \nThe value in sObj['bounce'] is incremented on each iteration of the game loop for each \nsquirrel. When this value is 0, the squirrel is at the very beginning of its bounce. When this value \nis equal to the value in sObj['bouncerate'] the value is at its end. (This is why a smaller \nsObj['bouncerate'] value makes for a faster bounce. If sObj['bouncerate'] is 3, \nthen it only takes three iterations through the game loop for the squirrel to do a full bounce. If \nsObj['bouncerate'] were 10, then it would take ten iterations.) \nWhen sObj['bounce'] gets larger than sObj['bouncerate'], then it needs to be reset \nto 0. This is what lines 142 and 143 do. \n145.             # random chance they change direction \n146.             if random.randint(0, 99) < DIRCHANGEFREQ: \n147.                 sObj['movex'] = getRandomVelocity() \n148.                 sObj['movey'] = getRandomVelocity() \n149.                 if sObj['movex'] > 0: # faces right \n150.                     sObj['surface'] = pygame.transform.scale(R_SQUIR_IMG, \n(sObj['width'], sObj['height'])) \n151.                 else: # faces left \n152.                     sObj['surface'] = pygame.transform.scale(L_SQUIR_IMG, \n(sObj['width'], sObj['height'])) \nThere is a 2% chance on each iteration through the game loop that the squirrel will randomly \nchange speed and direction. On line 146 the random.randint(0, 99) call randomly selects \nan integer out of 100 possible integers. If this number is less than DIRCHANGEFREQ (which we \nset to 2 on line 33) then a new value will be set for sObj['movex'] and sObj['movey'].  \nBecause this means the squirrel might have changed direction, the Surface object in \nsObj['surface'] should be replaced by a new one that is properly facing left or right and \nscaled to the squirrel’s size. This is what lines 149 to 152 determine. Note that line 150 gets a \nSurface object scaled from R_SQUIR_IMG and line 152 gets one scaled from L_SQUIR_IMG. \n",
      "content_length": 2526,
      "extraction_method": "Direct"
    },
    {
      "page_number": 239,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    221 \n \nRemoving the Far Away Grass and Squirrel Objects \n155.         # go through all the objects and see if any need to be deleted. \n156.         for i in range(len(grassObjs) - 1, -1, -1): \n157.             if isOutsideActiveArea(camerax, cameray, grassObjs[i]): \n158.                 del grassObjs[i] \n159.         for i in range(len(squirrelObjs) - 1, -1, -1): \n160.             if isOutsideActiveArea(camerax, cameray, squirrelObjs[i]): \n161.                 del squirrelObjs[i] \nDuring each iteration of the game loop, the code will check all of the grass and enemy squirrel \nobjects to see if they are outside the ―active area‖. The isOutsideActiveArea() function \ntakes the current coordinates of the camera (which are stored in camerax and cameray) and \nthe grass/enemy squirrel object, and returns True if the object is not located in the active area. \nIf this is the case, this object is deleted on line 158 (for grass objects) or line 161 (for squirrel \nobjects). This is how squirrel and grass objects get deleted when the player moves far enough \naway from them (or when the enemy squirrels move away far enough from the player). This \nensures that there is always a number of squirrels and grass objects near the player. \nWhen Deleting Items in a List, Iterate Over the List in Reverse \nDeleting squirrel and grass objects is done with the del operator. However, notice that the for \nloop on line 156 and 159 pass arguments to the range() function so that the numbering starts at \nthe index of the last item and then decrements by -1 (unlike incrementing by 1 as it normally \ndoes) until it reaches the number -1. We are iterating backwards over the list’s indexes compared \nto how it is normally done. This is done because we are iterating over the list that we are also \ndeleting items from. \nTo see why this reverse order is needed, say we had the following list value: \nanimals = ['cat', 'mouse', 'dog', 'horse'] \nSo we wanted to write code to delete any instances of the string 'dog' from this list. We might \nthink to write out code like this: \nfor i in range(len(animals)): \n    if animals[i] == 'dog': \n        del animals[i] \nBut if we ran this code, we would get an IndexError error that looks like this: \nTraceback (most recent call last): \n",
      "content_length": 2305,
      "extraction_method": "Direct"
    },
    {
      "page_number": 240,
      "chapter": null,
      "content": "222    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n  File \"<stdin>\", line 2, in <module> \nIndexError: list index out of range \nTo see why this error happens, let’s walk through the code. First, the animals list would be set \nto ['cat', 'mouse', 'dog', 'horse'] and len(animals) would return 4. This \nmeans that the call to range(4) would cause the for loop to iterate with the values 0, 1, 2, \nand 3. \nWhen the for loop iterates with i set to 2, the if statement’s condition will be True and the \ndel animals[i] statement will delete animals[2]. This means that afterwards the \nanimals list will be ['cat', 'mouse', 'horse']. The indexes of all the items after \n'dog' are all shifted down by one because the 'dog' value was removed. \nBut on the next iteration through the for loop, i is set to 3. But animals[3] is out of bounds \nbecause the valid indexes of the animals list is no longer 0 to 3 but 0 to 2. The original call to \nrange() was for a list with 4 items in it. The list changed in length, but the for loop is set up \nfor the original length. \nHowever, if we iterate from the last index of the list to 0, we don’t run into this problem. The \nfollowing program deletes the 'dog' string from the animals list without causing an \nIndexError error: \nanimals = ['cat', 'mouse', 'dog', 'horse'] \nfor i in range(len(animals) - 1, -1, -1): \n    if animals[i] == 'dog': \n        del animals[i] \nThe reason this code doesn’t cause an error is because the for loop iterates over 3, 2, 1, and 0. \nOn the first iteration, the code checks if animals[3] is equal to 'dog'. It isn’t \n(animals[3] is 'horse') so the code moves on to the next iteration. Then animals[2] is \nchecked if it equals 'dog'. It does, so animals[2] is deleted. \nAfter animals[2] is deleted, the animals list is set to ['cat', 'mouse', 'horse']. \nOn the next iteration, i is set to 1. There is a value at animals[1] (the 'mouse' value), so no \nerror is caused. It doesn’t matter that all the items in the list after 'dog' have shifted down by \none, because since we started at the end of the list and are going towards the front, all of those \nitems have already been checked. \nSimilarly, we can delete grass and squirrel objects from the grassObjs and squirrelObjs \nlists without error because the for loop on lines 156 and 159 iterate in reverse order. \n",
      "content_length": 2376,
      "extraction_method": "Direct"
    },
    {
      "page_number": 241,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    223 \n \nAdding New Grass and Squirrel Objects \n163.         # add more grass & squirrels if we don't have enough. \n164.         while len(grassObjs) < NUMGRASS: \n165.             grassObjs.append(makeNewGrass(camerax, cameray)) \n166.         while len(squirrelObjs) < NUMSQUIRRELS: \n167.             squirrelObjs.append(makeNewSquirrel(camerax, cameray)) \nRemember that the NUMGRASS constant was set to 80 and the NUMSQUIRRELS constant was set \nto 30 at the beginning of the program? These variables are set so that we can be sure there are \nalways plenty of grass and squirrel objects in the active area at all times. If the length of the \ngrassObjs or squirrelObjs drops below NUMGRASS or NUMSQUIRRELS respectively, \nthen new grass and squirrel objects are created. The makeNewGrass() and \nmakeNewSquirrel() functions that create these objects are explained later in this chapter. \nCamera Slack, and Moving the Camera View \n169.         # adjust camerax and cameray if beyond the \"camera slack\" \n170.         playerCenterx = playerObj['x'] + int(playerObj['size'] / 2) \n171.         playerCentery = playerObj['y'] + int(playerObj['size'] / 2) \n172.         if (camerax + HALF_WINWIDTH) - playerCenterx > CAMERASLACK: \n173.             camerax = playerCenterx + CAMERASLACK - HALF_WINWIDTH \n174.         elif playerCenterx – (camerax + HALF_WINWIDTH) > CAMERASLACK: \n175.             camerax = playerCenterx – CAMERASLACK - HALF_WINWIDTH \n176.         if (cameray + HALF_WINHEIGHT) - playerCentery > CAMERASLACK: \n177.             cameray = playerCentery + CAMERASLACK - HALF_WINHEIGHT \n178.         elif playerCentery – (cameray + HALF_WINHEIGHT) > CAMERASLACK: \n179.             cameray = playerCentery – CAMERASLACK - HALF_WINHEIGHT \nThe camera’s position (which is stored as integers in the camerax and cameray variables) \nneeds to be updated when the player moves over. I’ve called the number of pixels the player can \nmove before the camera gets updated the ―camera slack‖. Line 19 set the CAMERASLACK \nconstant to 90, which our program will take to mean that the player squirrel can move 90 pixels \nfrom the center before the camera position gets updated to follow the squirrel. \nIn order to understand the equations used in the if statements on lines 172, 174, 176, and 178, \nyou should note that (camerax + HALF_WINWIDTH) and (cameray + \nHALF_WINHEIGHT) are the XY game world coordinates currently at the center of the screen. \nThe playerCenterx and playerCentery is set to the middle of the player’s squirrel’s \nposition, also in game world coordinates. \nFor line 172, if the center X coordinate minus the player’s center X coordinate is greater than the \nCAMERASLACK value, that means the player is more pixels to the right of the center of the \n",
      "content_length": 2794,
      "extraction_method": "Direct"
    },
    {
      "page_number": 242,
      "chapter": null,
      "content": "224    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \ncamera than the camera slack should allow. The camerax value needs to be updated so that the \nplayer squirrel is just at the edge of the camera slack. This is why line 173 sets camerax to \nplayerCenterx + CAMERASLACK – HALF_WINWIDTH. Note that the camerax \nvariable is changed, not the playerObj['x'] value. We want to move the camera, not the \nplayer. \nThe other three if statements follow similar logic for the left, up and down sides. \nDrawing the Background, Grass, Squirrels, and Health Meter \n181.         # draw the green background \n182.         DISPLAYSURF.fill(GRASSCOLOR) \nLine 182 begins the code that starts drawing the contents of the display Surface object. First, line \n182 draws a green color for the background. This will paint over all of the previous contents of \nthe Surface so that we can start drawing the frame from scratch. \n184.         # draw all the grass objects on the screen \n185.         for gObj in grassObjs: \n186.             gRect = pygame.Rect( (gObj['x'] - camerax, \n187.                                   gObj['y'] - cameray, \n188.                                   gObj['width'], \n189.                                   gObj['height']) ) \n190.             DISPLAYSURF.blit(GRASSIMAGES[gObj['grassImage']], gRect) \nThe for loop on line 185 goes through all the grass objects in the grassObjs list and creates a \nRect object from the x, y, width, and height information stored in it. This Rect object is stored in \na variable named gRect. On line 190, gRect is used in the blit() method call to draw the \ngrass image on the display Surface. Note that gObj['grassImage'] only contains an integer \nthat is an index to GRASSIMAGES. GRASSIMAGES is a list of Surface objects that contain all \nthe grass images. Surface objects take up much more memory than just a single integer, and all \nthe grass objects with similar gObj['grassImage'] values look identical. So it makes sense \nto only have each grass image stored once in GRASSIMAGES and simply store integers in the \ngrass objects themselves. \n193.         # draw the other squirrels \n194.         for sObj in squirrelObjs: \n195.             sObj['rect'] = pygame.Rect( (sObj['x'] - camerax, \n196.                                          sObj['y'] - cameray - \ngetBounceAmount(sObj['bounce'], sObj['bouncerate'], sObj['bounceheight']), \n197.                                          sObj['width'], \n198.                                          sObj['height']) ) \n",
      "content_length": 2556,
      "extraction_method": "Direct"
    },
    {
      "page_number": 243,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    225 \n \n199.             DISPLAYSURF.blit(sObj['surface'], sObj['rect']) \nThe for loop that draws all the enemy squirrel game objects is similar to the previous for loop, \nexcept that the Rect object it creates is saved in the 'rect' key’s value of the squirrel \ndictionary. The reason the code does this is because we will use this Rect object later to check if \nthe enemy squirrels have collided with the player squirrel. \nNote that the top parameter for the Rect constructor is not just sObj['y'] - cameray but \nsObj['y'] - cameray - getBounceAmount(sObj['bounce'], \nsObj['bouncerate'], sObj['bounceheight']). The getBounceAmount() \nfunction will return the number of pixels that the top value should be raised. \nAlso, there is no common list of Surface objects of the squirrel images, like there was with grass \ngame objects and GRASSIMAGES. Each enemy squirrel game object has its own Surface object \nstored in the 'surface' key. This is because the squirrel images can be scaled to different \nsizes. \n202.         # draw the player squirrel \n203.         flashIsOn = round(time.time(), 1) * 10 % 2 == 1 \nAfter drawing the grass and enemy squirrels, the code will draw the player’s squirrel. However, \nthere is one case where we would skip drawing the player’s squirrel. When the player collides \nwith a larger enemy squirrel, the player takes damage and flashes for a little bit to indicate that \nthe player is temporarily invulnerable. This flashing effect is done by drawing the player squirrel \non some iterations through the game loop but not on others.  \nThe player squirrel will be drawn on game loop iterations for a tenth of a second, and then not \ndrawn on the game loop iterations for a tenth of second. This repeats over and over again as long \nas the player is invulnerable (which, in the code, means that the invulnerableMode variable \nis set to True). Our code will make the flashing last for two seconds, since 2 was stored in the \nINVULNTIME constant variable on line 25. \nTo determine if the flash is on or not, line 202 grabs the current time from time.time(). Let’s \nuse the example where this function call returns 1323926893.622. This value is passed to \nround(), which rounds it to one digit past the decimal point (since 1 is passed as round()’s \nsecond parameter). This means round() will return the value 1323926893.6. \nThis value is then multiplied by 10, to become 13239268936. Once we have it as an integer, \nwe can do the ―mod two‖ trick first discussed in the Memory Puzzle chapter to see if it is even or \nodd. 13239268936 % 2 evaluates to 0, which means that flashIsOn will be set to False, \nsince 0 == 1 is False. \n",
      "content_length": 2690,
      "extraction_method": "Direct"
    },
    {
      "page_number": 244,
      "chapter": null,
      "content": "226    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nIn fact, time.time() will keep returning values that will end up putting False into \nflashIsOn until 1323926893.700, which is the next tenth second. This is why the \nflashIsOn variable will constantly have False for one tenth of a second, and then True for \nthe next one tenth of a second (no matter how many iterations happen in that tenth of a second). \n204.         if not gameOverMode and not (invulnerableMode and flashIsOn): \n205.             playerObj['rect'] = pygame.Rect( (playerObj['x'] - camerax, \n206.                                               playerObj['y'] – cameray - \ngetBounceAmount(playerObj['bounce'], BOUNCERATE, BOUNCEHEIGHT), \n207.                                               playerObj['size'], \n208.                                               playerObj['size']) ) \n209.             DISPLAYSURF.blit(playerObj['surface'], playerObj['rect']) \nThere are three things that must be True before we draw the player’s squirrel. The game must \ncurrently be going on (which happens while gameOverMode is False) and the player is not \ninvulnerable and not flashing (which happens while invulnerableMode and flashIsOn \nare False). \nThe code for drawing the player’s squirrel is almost identical to the code for drawing the enemy \nsquirrels. \n212.         # draw the health meter \n213.         drawHealthMeter(playerObj['health']) \nThe drawHealthMeter() function draws the indicator at the top left corner of the screen that \ntells the player how many times the player squirrel can be hit before dying. This function will be \nexplained later in this chapter. \nThe Event Handling Loop \n215.         for event in pygame.event.get(): # event handling loop \n216.             if event.type == QUIT: \n217.                 terminate() \nThe first thing that is checked in the event handling loop is if the QUIT event has been generated. \nIf so, then the program should be terminated. \n219.             elif event.type == KEYDOWN: \n220.                 if event.key in (K_UP, K_w): \n221.                     moveDown = False \n222.                     moveUp = True \n223.                 elif event.key in (K_DOWN, K_s): \n",
      "content_length": 2235,
      "extraction_method": "Direct"
    },
    {
      "page_number": 245,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    227 \n \n224.                     moveUp = False \n225.                     moveDown = True \nIf the up or down arrow keys have been pressed (or their WASD equivalents), then the move \nvariable (moveRight, moveDown, etc.) for that direction should be set to True and the move \nvariable for the opposite direction should be set to False. \n226.                 elif event.key in (K_LEFT, K_a): \n227.                     moveRight = False \n228.                     moveLeft = True \n229.                     if playerObj['facing'] == RIGHT: # change player image \n230.                         playerObj['surface'] = \npygame.transform.scale(L_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n231.                     playerObj['facing'] = LEFT \n232.                 elif event.key in (K_RIGHT, K_d): \n233.                     moveLeft = False \n234.                     moveRight = True \n235.                     if playerObj['facing'] == LEFT: # change player image \n236.                         playerObj['surface'] = \npygame.transform.scale(R_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n237.                     playerObj['facing'] = RIGHT \nThe moveLeft and moveRight variables should also be set when the left or right arrow keys \nare pressed. Also, the value in playerObj['facing'] should be updated to either LEFT or \nRIGHT. If the player squirrel is now facing a new direction, the playerObj['surface'] \nvalue should be replaced with a correctly scaled image of the squirrel facing the new direction. \nLine 229 is run if the left arrow key was pressed and checks if the player squirrel was facing \nright. If that was so, then a new scaled Surface object of the player squirrel image is stored in \nplayerObj['surface']. The code in line 232’s elif statement handles the opposite case. \n238.                 elif winMode and event.key == K_r: \n239.                     return \nIf the player has won the game by growing large enough (in which case, winMode will be set to \nTrue) and the R key has been pressed, then runGame()should return. This will end the current \ngame, and a new game will start the next time that runGame() gets called. \n241.             elif event.type == KEYUP: \n242.                 # stop moving the player's squirrel \n243.                 if event.key in (K_LEFT, K_a): \n244.                     moveLeft = False \n",
      "content_length": 2382,
      "extraction_method": "Direct"
    },
    {
      "page_number": 246,
      "chapter": null,
      "content": "228    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n245.                 elif event.key in (K_RIGHT, K_d): \n246.                     moveRight = False \n247.                 elif event.key in (K_UP, K_w): \n248.                     moveUp = False \n249.                 elif event.key in (K_DOWN, K_s): \n250.                     moveDown = False \nIf the player lets up on any of the arrow or WASD keys, then the code should set the move \nvariable for that direction to False. This will stop the squirrel from moving in that direction any \nmore. \n252.                 elif event.key == K_ESCAPE: \n253.                     terminate() \nIf the key that was pressed was the Esc key, then terminate the program. \nMoving the Player, and Accounting for Bounce \n255.         if not gameOverMode: \n256.             # actually move the player \n257.             if moveLeft: \n258.                 playerObj['x'] -= MOVERATE \n259.             if moveRight: \n260.                 playerObj['x'] += MOVERATE \n261.             if moveUp: \n262.                 playerObj['y'] -= MOVERATE \n263.             if moveDown: \n264.                 playerObj['y'] += MOVERATE \nThe code inside the if statement on line 255 will move the player’s squirrel around only if the \ngame is not over. (This is why pressing on the arrow keys after the player’s squirrel dies will have \nno effect.) Depending on which of the move variables is set to True, the playerObj dictionary \nshould have its playerObj['x'] and playerObj['y'] values changed by MOVERATE. \n(This is why a larger value in MOVERATE makes the squirrel move faster.) \n266.             if (moveLeft or moveRight or moveUp or moveDown) or \nplayerObj['bounce'] != 0: \n267.                 playerObj['bounce'] += 1 \n268.  \n269.             if playerObj['bounce'] > BOUNCERATE: \n270.                 playerObj['bounce'] = 0 # reset bounce amount \n",
      "content_length": 1922,
      "extraction_method": "Direct"
    },
    {
      "page_number": 247,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    229 \n \nThe value in playerObj['bounce'] keeps track of at what point in bouncing the player is \nat. This variable stores an integer value from 0 to BOUNCERATE. Just like the bounce value for \nthe enemy squirrels, a playerObj['bounce'] value of 0 means the player squirrel is at the \nstart of a bounce and a value of BOUNCERATE means the player squirrel is at the end of the \nbounce. \nThe player squirrel will bounce whenever the player is moving, or if the player has stopped \nmoving but the squirrel hasn’t finished its current bounce. This condition is captured in the if \nstatement on line 266. If any of the move variables is set to True or the current \nplayerObj['bounce'] is not 0 (which means the player is currently in a bounce), then the \nvariable should be incremented on line 267. \nBecause the playerObj['bounce'] variable should only be in the range of 0 to \nBOUNCERATE, if incrementing it makes it larger than BOUNCERATE, it should be reset back to \n0. \nCollision Detection: Eat or Be Eaten \n272.             # check if the player has collided with any squirrels \n273.             for i in range(len(squirrelObjs)-1, -1, -1): \n274.                 sqObj = squirrelObjs[i] \nThe for loop on 273 will go run code on each of the enemy squirrel game objects in \nsquirrelObjs. Notice that the parameters to range() on line 273 start at the last index of \nsquirrelObjs and decrement. This is because the code inside this for loop may end up \ndeleting some of these enemy squirrel game objects (if the player’s squirrel ends up eating them), \nso it is important to iterate from the end down to the front. The reason why was explained \npreviously in the ―When Deleting Items in a List, Iterate Over the List in Reverse‖ section. \n275.                 if 'rect' in sqObj and \nplayerObj['rect'].colliderect(sqObj['rect']): \n276.                     # a player/squirrel collision has occurred \n277. \n278.                     if sqObj['width'] * sqObj['height'] <= \nplayerObj['size']**2: \n279.                         # player is larger and eats the squirrel \n280.                         playerObj['size'] += int( (sqObj['width'] * \nsqObj['height'])**0.2 ) + 1 \n281.                         del squirrelObjs[i] \nIf the player’s squirrel is equal or larger than the size of the enemy squirrel it has collided with, \nthen the player’s squirrel will eat that squirrel and grow. The number that is added to the 'size' \n",
      "content_length": 2453,
      "extraction_method": "Direct"
    },
    {
      "page_number": 248,
      "chapter": null,
      "content": "230    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nkey in the player object (that is, the growth) is calculated based on the enemy squirrel’s size on \nline 280. Here’s a graph showing the growth from different sized squirrels. Notice that larger \nsquirrels cause more growth: \n \nSo, according to the chart, eating a squirrel that has a width and height of 45 (that is, an area of \n1600 pixels) would cause the player to grow 5 pixels wider and taller. \nLine 281 deletes the eaten squirrel object from the squirrelObjs list so that it will no longer \nappear on the screen or have its position updated. \n283.                         if playerObj['facing'] == LEFT: \n284.                             playerObj['surface'] = \npygame.transform.scale(L_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \n285.                         if playerObj['facing'] == RIGHT: \n286.                             playerObj['surface'] = \npygame.transform.scale(R_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \nThe player’s squirrel image needs to be updated now that the squirrel is larger. This can be done \nby passing the original squirrel image in L_SQUIR_IMG or R_SQUIR_IMG to the \npygame.transform.scale() function, which will return an enlarged version of the image. \nDepending on whether playerObj['facing'] is equal to LEFT or RIGHT determines \nwhich original squirrel image we pass to the function. \n288.                         if playerObj['size'] > WINSIZE: \n289.                             winMode = True # turn on \"win mode\" \n0\n1\n2\n3\n4\n5\n6\n7\n8\n1\n5\n9\n13\n17\n21\n25\n29\n33\n37\n41\n45\n49\n53\n57\n61\n65\n69\n73\n77\n81\n85\n89\n93\n97\nGrowth \nSize of Eaten Squirrel (width & height) \nint( (sqObj['width'] * sqObj['height'])**0.2 ) + 1 \n",
      "content_length": 1769,
      "extraction_method": "Direct"
    },
    {
      "page_number": 249,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    231 \n \nThe way the player wins the game is by getting the squirrel to have a size larger than the integer \nstored in the WINSIZE constant variable. If this is true, then the winMode variable is set to \nTrue. Code in the other parts of this function will handle displaying the congratulations text and \nchecking for the player to press the R key to restart the game. \n291.                     elif not invulnerableMode: \n292.                         # player is smaller and takes damage \n293.                         invulnerableMode = True \n294.                         invulnerableStartTime = time.time() \n295.                         playerObj['health'] -= 1 \n296.                         if playerObj['health'] == 0: \n297.                             gameOverMode = True # turn on \"game over mode\" \n298.                             gameOverStartTime = time.time() \nIf the player’s area was not equal to or larger than the area of the enemy squirrel, and \ninvulnerableMode was not set to True, then the player will take damage from colliding \nwith this larger squirrel. \nTo prevent the player from being damaged several times by the same squirrel immediately, we \nwill briefly make the player invulnerable to further squirrel attacks by setting \ninvulnerableMode to True on line 293. Line 294 will set invulnerableStartTime to \nthe current time (which is returned by time.time()) so that lines 133 and 134 can know when \nto set invulnerableMode to False. \nLine 295 decrements the player’s health by 1. Because there is a chance that the player’s health is \nnow at 0, line 296 checks for this and, if so, sets gameOverMode to True and \ngameOverStartTime to the current time. \nThe Game Over Screen \n299.         else: \n300.             # game is over, show \"game over\" text \n301.             DISPLAYSURF.blit(gameOverSurf, gameOverRect) \n302.             if time.time() - gameOverStartTime > GAMEOVERTIME: \n303.                 return # end the current game \nWhen the player has died, the ―Game Over‖ text (which is on the Surface object in the \ngameOverSurf variable) will be shown on the screen for the number of seconds that is in the \nGAMEOVERTIME constant. Once this amount of time has elapsed, then the runGame() function \nwill return. \n",
      "content_length": 2280,
      "extraction_method": "Direct"
    },
    {
      "page_number": 250,
      "chapter": null,
      "content": "232    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThis lets the enemy squirrels continue to be animated and moving around for a few seconds after \nthe player dies and before the next game starts. The ―game over screen‖ in Squirrel Eat Squirrel \ndoes not wait until the player presses a key before a new game starts. \nWinning \n305.         # check if the player has won. \n306.         if winMode: \n307.             DISPLAYSURF.blit(winSurf, winRect) \n308.             DISPLAYSURF.blit(winSurf2, winRect2) \n309.  \n310.         pygame.display.update() \n311.         FPSCLOCK.tick(FPS) \nThe winMode variable is set to True on line 289 if the player has reached a certain size (which \nis dictated by the WINSIZE constant). All that happens when the player has won is that the ―You \nhave achieved OMEGA SQUIRREL!‖ text (which is on the Surface object stored in the \nwinSurf variable) and the ―(Press ―r‖ to restart.)‖ text (which is on the Surface object stored in \nthe winSurf2 variable) appears on the screen. The game continues until the user presses the R \nkey, at which point the program execution will return from runGame(). The event handling \ncode for the R key is done on lines 238 and 239. \nDrawing a Graphical Health Meter \n316. def drawHealthMeter(currentHealth): \n317.     for i in range(currentHealth): # draw red health bars \n318.         pygame.draw.rect(DISPLAYSURF, RED,   (15, 5 + (10 * MAXHEALTH) - i \n* 10, 20, 10)) \n319.     for i in range(MAXHEALTH): # draw the white outlines \n320.         pygame.draw.rect(DISPLAYSURF, WHITE, (15, 5 + (10 * MAXHEALTH) - i \n* 10, 20, 10), 1) \nTo draw the health meter, first the for loop on line 317 draws the filled-in red rectangle for the \namount of health the player has. Then the for loop on line 319 draws an unfilled white rectangle \nfor all of the possible health the player could have (which is the integer value stored in the \nMAXHEALTH constant). Note that the pygame.display.update() function is not called in \ndrawHealthMeter(). \nThe Same Old terminate() Function \n323. def terminate(): \n324.     pygame.quit() \n325.     sys.exit() \n",
      "content_length": 2151,
      "extraction_method": "Direct"
    },
    {
      "page_number": 251,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    233 \n \nThe terminate() function works the same as in the previous game programs. \nThe Mathematics of the Sine Function \n328. def getBounceAmount(currentBounce, bounceRate, bounceHeight): \n329.     # Returns the number of pixels to offset based on the bounce. \n330.     # Larger bounceRate means a slower bounce. \n331.     # Larger bounceHeight means a higher bounce. \n332.     # currentBounce will always be less than bounceRate \n333.     return int(math.sin( (math.pi / float(bounceRate)) * currentBounce ) * \nbounceHeight) \n334. \nThere is a mathematical function (which is similar to functions in programming in that they both \n―return‖ or ―evaluate‖ to a number based on their parameters) called sine (pronounced like ―sign‖ \nand often abbreviated as ―sin‖). You may have learned about it in math class, but if you haven’t it \nwill be explained here. Python has this mathematic function as a Python function in the math \nmodule. You can pass an int or float value to math.sin(), and it will return a float value that is \ncalled the ―sine value‖ \nIn the interactive shell, let’s see what math.sin() returns for some values: \n>>> import math \n>>> math.sin(1) \n0.8414709848078965 \n>>> math.sin(2) \n0.90929742682568171 \n>>> math.sin(3) \n0.14112000805986721 \n>>> math.sin(4) \n-0.7568024953079282 \n>>> math.sin(5) \n-0.95892427466313845 \nIt seems really hard to predict what value math.sin() is going to return based on what value \nwe pass it (which might make you wonder what math.sin() is useful for). But if we graph the \nsine values of the integers 1 through 10 on a graph, we would get this: \n",
      "content_length": 1631,
      "extraction_method": "Direct"
    },
    {
      "page_number": 252,
      "chapter": null,
      "content": "234    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \nYou can kind of see a wavy pattern in the values returned by math.sin(). If you figure out the \nsine values for more numbers besides integers (for example, 1.5 and 2.5 and so on) and then \nconnect the dots with lines, you can see this wavy pattern more easily: \n \nIn fact, if you kept adding more and more data points to this graph, you would see that the sine \nwave looks like this: \n \n-1.5\n-1\n-0.5\n0\n0.5\n1\n1.5\n0\n2\n4\n6\n8\n10\n12\nmath.sin(arg) \narg \nValues Returned by math.sin() \n-1.5\n-1\n-0.5\n0\n0.5\n1\n1.5\n0 0.5 1 1.5 2 2.5 3 3.5 4 4.5 5 5.5 6 6.5 7 7.5 8 8.5 9 9.5 10\nmath.sin(arg) \narg \nValues Returned by math.sin() \n",
      "content_length": 723,
      "extraction_method": "Direct"
    },
    {
      "page_number": 253,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    235 \n \nNotice that math.sin(0) returns 0, then gradually increases until math.sin(3.14 / 2) \nreturns 1, then it begins to decrease until math.sin(3.14) returns 0. The number 3.14 is a \nspecial number in mathematics called pi (pronounced the same as delicious ―pie‖). This value is \nalso stored in the constant variable pi in the math module (which is why line 333 uses the \nvariable, math.pi), which is technically the float value 3.1415926535897931. Since we \nwant a wavy-looking bounce for our squirrel, we’ll only pay attention to the return values of \nmath.sin() for the arguments 0 to 3.14: \n \nLet’s take a look at the return value of getBounceAmount() and figure out what it does \nexactly. \n333.     return int(math.sin( (math.pi / float(bounceRate)) * currentBounce ) * \nbounceHeight) \nRemember that on line 21 we set the BOUNCERATE constant to 6. This means that our code will \nonly increment playerObj['bounce'] from 0 to 6 and that we want to split up the range of \nfloating-point values from 0 to 3.14 into 6 parts, which we can do with simple division: 3.14 \n/ 6 = 0.5235. Each of the 6 equal parts of the 3.14 length on the graph for the ―sine wave \nbounce‖ is 0.5235. \nYou can see that when playerObj['bounce'] is at 3 (halfway between 0 and 6), the value \npassed to the math.sin() call is math.pi / 6 * 3, which is 1.5707 (halfway between 0 \nand 3.1415). Then math.sin(1.5707) will return 1.0, which is the highest part of the sine \nwave (and the highest part of the sine wave happens half way through the wave). \n0\n0.2\n0.4\n0.6\n0.8\n1\n1.2\n0\n0.12\n0.24\n0.36\n0.48\n0.6\n0.72\n0.84\n0.96\n1.08\n1.2\n1.32\n1.44\n1.56\n1.68\n1.8\n1.92\n2.04\n2.16\n2.28\n2.4\n2.52\n2.64\n2.76\n2.88\n3\n3.14\nmath.sin(arg) \narg \nValues Returned by math.sin() \n",
      "content_length": 1766,
      "extraction_method": "Direct"
    },
    {
      "page_number": 254,
      "chapter": null,
      "content": "236    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nAs playerObj['bounce'] gets its value incremented, the getBounceAmount() function \nwill return values that have the same bounce shape that the sine wave has from 0 to 3.14. If you \nwant to make the bounce higher, than increase the BOUNCEHEIGHT constant. If you want to \nmake the bounce slower, than increase the BOUNCERATE constant. \nThe sine function is a concept from trigonometry mathematics. If you’d like to learn more about \nthe sine wave, the Wikipedia page has detailed information: http://en.wikipedia.org/wiki/Sine \nBackwards Compatibility with Python Version 2 \nThe reason we call float() to convert bounceRate to a floating point number is simply so \nthat this program will work in Python version 2. In Python version 3, the division operator will \nevaluate to a floating point value even if both of the operands are integers, like this: \n>>> # Python version 3 \n... \n>>> 10 / 5 \n2.0 \n>>> 10 / 4 \n2.5 \n>>> \nHowever, in Python version 2, the / division operator will only evaluate to a floating point value \nif one of the operands is also a floating point value. If both operands are integers, then Python 2’s \ndivision operator will evaluate to an integer value (rounding down if needed), like this: \n>>> # Python version 2 \n... \n>>> 10 / 5 \n2 \n>>> 10 / 4 \n2 \n>>> 10 / 4.0 \n2.5 \n>>> 10.0 / 4 \n2.5 \n>>> 10.0 / 4.0 \n2.5 \nBut if we always convert one of the values to a floating point value with the float() function, \nthen the division operator will evaluate to a float value no matter which version of Python runs \nthis source code. Making these changes so that our code works with older versions of software is \ncalled backwards compatibility. It is important to maintain backwards compatibility, because \n",
      "content_length": 1821,
      "extraction_method": "Direct"
    },
    {
      "page_number": 255,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    237 \n \nnot everyone will always be running the latest version of software and you want to ensure that the \ncode you write works with as many computers as possible. \nYou can’t always make your Python 3 code backwards compatible with Python 2, but if it’s \npossible then you should do it. Otherwise, when people with Python 2 try to run your games will \nget error messages and think that your program is buggy. \nA list of some differences between Python 2 and Python 3 can be found at \nhttp://inventwithpython.com/appendixa.html. \nThe getRandomVelocity() Function \n335. def getRandomVelocity(): \n336.     speed = random.randint(SQUIRRELMINSPEED, SQUIRRELMAXSPEED) \n337.     if random.randint(0, 1) == 0: \n338.         return speed \n339.     else: \n340.         return -speed \nThe getRandomVelocity() function is used to randomly determine how fast an enemy \nsquirrel will move. The range of this velocity is set in the SQUIRRELMINSPEED and \nSQUIRRELMAXSPEED constants, but on top of that, the speed is either negative (indicating the \nsquirrel goes to the left or up) or positive (indicating the squirrel goes to the right or down). There \nis a fifty-fifty chance for the random speed to be positive or negative. \nFinding a Place to Add New Squirrels and Grass \n343. def getRandomOffCameraPos(camerax, cameray, objWidth, objHeight): \n344.     # create a Rect of the camera view \n345.     cameraRect = pygame.Rect(camerax, cameray, WINWIDTH, WINHEIGHT) \n346.     while True: \n347.         x = random.randint(camerax - WINWIDTH, camerax + (2 * WINWIDTH)) \n348.         y = random.randint(cameray - WINHEIGHT, cameray + (2 * WINHEIGHT)) \n349.         # create a Rect object with the random coordinates and use \ncolliderect() \n350.         # to make sure the right edge isn't in the camera view. \n351.         objRect = pygame.Rect(x, y, objWidth, objHeight) \n352.         if not objRect.colliderect(cameraRect): \n353.             return x, y \nWhen a new squirrel or grass object is created in the game world, we want it to be within the \nactive area (so that it is near the player’s squirrel) but not within the view of the camera (so that it \ndoesn’t just suddenly pop into existence on the screen). To do this, we create a Rect object that \n",
      "content_length": 2275,
      "extraction_method": "Direct"
    },
    {
      "page_number": 256,
      "chapter": null,
      "content": "238    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nrepresents the area of the camera (using camerax, cameray, WINWIDTH, and WINHEIGHT \nconstants). \nNext, we randomly generate numbers for the XY coordinates that would be within the active area. \nThe active area’s left and top edge are WINWIDTH and WINHEIGHT pixels to the left and up of \ncamerax and cameray. So the active area’s left and top edge are at camerax - WINWIDTH \nand cameray - WINHEIGHT. The active area’s width and height are also three times the size \nof the WINWIDTH and WINHEIGHT, as you can see in this image (where WINWIDTH is set to \n640 pixels and WINHEIGHT set to 480 pixels): \n \nThis means the right and bottom edges will be at camerax + (2 * WINWIDTH) and \ncameray + (2 * WINHEIGHT). Line 352 will check if the random XY coordinates would \ncollide with the camera view’s Rect object. If not, then those coordinates are returned. If so, then \nthe while loop on line 346 will keep generating new coordinates until it finds acceptable ones. \nCreating Enemy Squirrel Data Structures \n356. def makeNewSquirrel(camerax, cameray): \n357.     sq = {} \n358.     generalSize = random.randint(5, 25) \n359.     multiplier = random.randint(1, 3) \n360.     sq['width']  = (generalSize + random.randint(0, 10)) * multiplier \n361.     sq['height'] = (generalSize + random.randint(0, 10)) * multiplier \n362.     sq['x'], sq['y'] = getRandomOffCameraPos(camerax, cameray, \nsq['width'], sq['height']) \n363.     sq['movex'] = getRandomVelocity() \n364.     sq['movey'] = getRandomVelocity() \nCreating enemy squirrel game objects is similar to making the grass game objects. The data for \neach enemy squirrel is also stored in a dictionary. The width and height are set to random sizes on \nline 360 and 361. The generalSize variable is used so that the width and height of each \n",
      "content_length": 1881,
      "extraction_method": "Direct"
    },
    {
      "page_number": 257,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    239 \n \nsquirrel aren’t too different from each other. Otherwise, using completely random numbers for \nwidth and height could give us very tall and skinny squirrels or very short and wide squirrels. The \nwidth and height of the squirrel are this general size with a random number from 0 to 10 added to \nit (for slight variation), and then multiplied by the multiplier variable. \nThe original XY coordinate position of the squirrel will be a random location that the camera \ncannot see, to prevent the squirrels from just ―popping‖ into existence on the screen. \nThe speed and direction are also randomly selected by the getRandomVelocity() function. \nFlipping the Squirrel Image \n365.     if sq['movex'] < 0: # squirrel is facing left \n366.         sq['surface'] = pygame.transform.scale(L_SQUIR_IMG, (sq['width'], \nsq['height'])) \n367.     else: # squirrel is facing right \n368.         sq['surface'] = pygame.transform.scale(R_SQUIR_IMG, (sq['width'], \nsq['height'])) \n369.     sq['bounce'] = 0 \n370.     sq['bouncerate'] = random.randint(10, 18) \n371.     sq['bounceheight'] = random.randint(10, 50) \n372.     return sq \nThe L_SQUIR_IMG and R_SQUIR_IMG constants contain Surface objects with left-facing and \nright-facing squirrel images on them. New Surface objects will be made using the \npygame.transform.scale() function to match the squirrel’s  width and height (stored in \nsq['width'] and sq['height'] respectively). \nAfter that, the three bounce-related values are randomly generated (except for sq['bounce'] \nwhich is 0 because the squirrel always starts at the beginning of the bounce) and the dictionary is \nreturned on line 372. \nCreating Grass Data Structures \n375. def makeNewGrass(camerax, cameray): \n376.     gr = {} \n377.     gr['grassImage'] = random.randint(0, len(GRASSIMAGES) - 1) \n378.     gr['width']  = GRASSIMAGES[0].get_width() \n379.     gr['height'] = GRASSIMAGES[0].get_height() \n380.     gr['x'], gr['y'] = getRandomOffCameraPos(camerax, cameray, \ngr['width'], gr['height']) \n381.     gr['rect'] = pygame.Rect( (gr['x'], gr['y'], gr['width'], \ngr['height']) ) \n382.     return gr \n",
      "content_length": 2148,
      "extraction_method": "Direct"
    },
    {
      "page_number": 258,
      "chapter": null,
      "content": "240    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe grass game objects are dictionaries with the usual 'x', 'y', 'width', 'height', and \n'rect' keys but also a 'grassImage' key which is a number from 0 to one less than the \nlength of the GRASSIMAGES list. This number will determine what image the grass game object \nhas. For example, if the value of the grass object’s 'grassImage' key is 3, then it will use the \nSurface object stored at GRASSIMAGES[3] for its image. \nChecking if Outside the Active Area \n385. def isOutsideActiveArea(camerax, cameray, obj): \n386.     # Return False if camerax and cameray are more than \n387.     # a half-window length beyond the edge of the window. \n388.     boundsLeftEdge = camerax - WINWIDTH \n389.     boundsTopEdge = cameray - WINHEIGHT \n390.     boundsRect = pygame.Rect(boundsLeftEdge, boundsTopEdge, WINWIDTH * 3, \nWINHEIGHT * 3) \n391.     objRect = pygame.Rect(obj['x'], obj['y'], obj['width'], obj['height']) \n392.     return not boundsRect.colliderect(objRect) \nThe isOutsideActiveArea() will return True if the object you pass it is outside of the \n―active area‖ that is dictated by the camerax and cameray parameters. Remember that the \nactive area is an area around the camera view the size of the camera view (which has a width and \nheight set by WINWIDTH and WINHEIGHT), like this: \n \nWe can create a Rect object that represents the active area by passing camerax - WINWIDTH \nfor the left edge value and cameray - WINHEIGHT for the top edge value, and then \nWINWIDTH * 3 and WINHEIGHT * 3 for the width and height. Once we have the active area \nrepresented as a Rect object, we can use the colliderect() method to determine if the object \nin the obj parameter is collides with (that is, is inside of) the active area Rect object. \n",
      "content_length": 1839,
      "extraction_method": "Direct"
    },
    {
      "page_number": 259,
      "chapter": null,
      "content": "Chapter 8 – Squirrel Eat Squirrel    241 \n \nSince the player squirrel, enemy squirrel and grass objects all have 'x', 'y', 'width' and \n'height' keys, the isOutsideActiveArea() code can work with any type of those game \nobjects.  \n395. if __name__ == '__main__': \n396.     main() \nFinally, after all the functions have been defined, the program will run the main() function and \nstart the game. \nSummary \nSquirrel Eat Squirrel was our first game to have multiple enemies moving around the board at \nonce. The key to having several enemies was using a dictionary value with identical keys for each \nenemy squirrel, so that the same code could be run on each of them during an iteration through \nthe game loop. \nThe concept of the camera was also introduced. Cameras weren’t needed for our previous games \nbecause the entire game world fit onto one screen. However, when you make your own games \nthat involve a player moving around a large game world, you will need code to handle converting \nbetween the game world’s coordinate system and the screen’s pixel coordinate system. \nFinally, the mathematical sine function was introduced to give realistic squirrel hops (no matter \nhow tall or long each hop was). You don’t need to know a lot of math to do programming. In \nmost cases, just knowing addition, multiplication, and negative numbers is fine. However, if you \nstudy mathematics, you’ll often find several uses for math to make your games cooler. \nFor additional programming practice, you can download buggy versions of Squirrel Eat Squirrel \nfrom http://invpy.com/buggy/squirrel and try to figure out how to fix the bugs. \n \n",
      "content_length": 1631,
      "extraction_method": "Direct"
    },
    {
      "page_number": 260,
      "chapter": null,
      "content": "242    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nCHAPTER 9 – STAR PUSHER \n \n \nHow to Play Star Pusher \nStar Pusher is a Sokoban or ―Box Pusher‖ clone. The player is in a room with several stars. There \nare star marks on the grounds of some of the tile sprites in the room. The player must figure out \nhow to push the stars on top of the tiles with star marks. The player cannot push a star if there is a \nwall or another star behind it. The player cannot pull stars, so if a star gets pushed into a corner, \nthe player will have to restart the level. When all of the stars have been pushed onto star-marked \nfloor tiles, the level is complete and the next level starts. \nEach level is made up of a 2D grid of tile images. Tile sprites are images of the same size that \ncan be placed next to each other to form more complex images. With a few floor and wall tiles, \nwe can create levels of many interesting shapes and sizes. \nThe level files are not included in the source code. Instead, you can either create the level files \nyourself or download them. A level file with 201 levels can be downloaded from \nhttp://invpy.com/starPusherLevels.txt. When you run the Star Pusher program, make sure that this \nlevel file is in the same folder as the starpusher.py file. Otherwise you will get this error message: \nAssertionError: Cannot find the level file: starPusherLevels.txt \nThe level designs were originally made David W. Skinner. You can download more puzzles from \nhis website at http://users.bentonrea.com/~sasquatch/sokoban/. \nSource Code to Star Pusher \nThis source code can be downloaded from http://invpy.com/starpusher.py. If you get any error \nmessages, look at the line number that is mentioned in the error message and check your code for \nany typos. You can also copy and paste your code into the web form at \n",
      "content_length": 1876,
      "extraction_method": "Direct"
    },
    {
      "page_number": 261,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    243 \n \nhttp://invpy.com/diff/starpusher to see if the differences between your code and the code in the \nbook. \nThe level file can be downloaded from http://invpy.com/starPusherLevels.txt. The tiles can be \ndownloaded from http://invpy.com/starPusherImages.zip. \nAlso, just like the squirrel, grass, and enemy ―objects‖ in the Squirrel Eat Squirrel game, when I \nsay ―map objects‖, ―game state objects‖, or ―level objects‖ in this chapter, I do not mean objects \nin the Object-Oriented Programming sense. These ―objects‖ are really just dictionary values, but \nit is easier to refer to them as objects since they represent things in the game world. \n  1. # Star Pusher (a Sokoban clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, sys, copy, os, pygame \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 # frames per second to update the screen \n 10. WINWIDTH = 800 # width of the program's window, in pixels \n 11. WINHEIGHT = 600 # height in pixels \n 12. HALF_WINWIDTH = int(WINWIDTH / 2) \n 13. HALF_WINHEIGHT = int(WINHEIGHT / 2) \n 14.  \n 15. # The total width and height of each tile in pixels. \n 16. TILEWIDTH = 50 \n 17. TILEHEIGHT = 85 \n 18. TILEFLOORHEIGHT = 45 \n 19.  \n 20. CAM_MOVE_SPEED = 5 # how many pixels per frame the camera moves \n 21.  \n 22. # The percentage of outdoor tiles that have additional \n 23. # decoration on them, such as a tree or rock. \n 24. OUTSIDE_DECORATION_PCT = 20 \n 25.  \n 26. BRIGHTBLUE = (  0, 170, 255) \n 27. WHITE      = (255, 255, 255) \n 28. BGCOLOR = BRIGHTBLUE \n 29. TEXTCOLOR = WHITE \n 30.  \n 31. UP = 'up' \n 32. DOWN = 'down' \n 33. LEFT = 'left' \n 34. RIGHT = 'right' \n",
      "content_length": 1760,
      "extraction_method": "Direct"
    },
    {
      "page_number": 262,
      "chapter": null,
      "content": "244    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 35. \n 36. \n 37. def main(): \n 38.     global FPSCLOCK, DISPLAYSURF, IMAGESDICT, TILEMAPPING, \nOUTSIDEDECOMAPPING, BASICFONT, PLAYERIMAGES, currentImage \n 39.  \n 40.     # Pygame initialization and basic set up of the global variables. \n 41.     pygame.init() \n 42.     FPSCLOCK = pygame.time.Clock() \n 43.  \n 44.     # Because the Surface object stored in DISPLAYSURF was returned \n 45.     # from the pygame.display.set_mode() function, this is the \n 46.     # Surface object that is drawn to the actual computer screen \n 47.     # when pygame.display.update() is called. \n 48.     DISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT)) \n 49.  \n 50.     pygame.display.set_caption('Star Pusher') \n 51.     BASICFONT = pygame.font.Font('freesansbold.ttf', 18) \n 52. \n 53.     # A global dict value that will contain all the Pygame \n 54.     # Surface objects returned by pygame.image.load(). \n 55.     IMAGESDICT = {'uncovered goal': pygame.image.load('RedSelector.png'), \n 56.                   'covered goal': pygame.image.load('Selector.png'), \n 57.                   'star': pygame.image.load('Star.png'), \n 58.                   'corner': pygame.image.load('Wall Block Tall.png'), \n 59.                   'wall': pygame.image.load('Wood Block Tall.png'), \n 60.                   'inside floor': pygame.image.load('Plain Block.png'), \n 61.                   'outside floor': pygame.image.load('Grass Block.png'), \n 62.                   'title': pygame.image.load('star_title.png'), \n 63.                   'solved': pygame.image.load('star_solved.png'), \n 64.                   'princess': pygame.image.load('princess.png'), \n 65.                   'boy': pygame.image.load('boy.png'), \n 66.                   'catgirl': pygame.image.load('catgirl.png'), \n 67.                   'horngirl': pygame.image.load('horngirl.png'), \n 68.                   'pinkgirl': pygame.image.load('pinkgirl.png'), \n 69.                   'rock': pygame.image.load('Rock.png'), \n 70.                   'short tree': pygame.image.load('Tree_Short.png'), \n 71.                   'tall tree': pygame.image.load('Tree_Tall.png'), \n 72.                   'ugly tree': pygame.image.load('Tree_Ugly.png')} \n 73.  \n 74.     # These dict values are global, and map the character that appears \n 75.     # in the level file to the Surface object it represents. \n 76.     TILEMAPPING = {'x': IMAGESDICT['corner'], \n 77.                    '#': IMAGESDICT['wall'], \n 78.                    'o': IMAGESDICT['inside floor'], \n 79.                    ' ': IMAGESDICT['outside floor']} \n",
      "content_length": 2667,
      "extraction_method": "Direct"
    },
    {
      "page_number": 263,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    245 \n \n 80.     OUTSIDEDECOMAPPING = {'1': IMAGESDICT['rock'], \n 81.                           '2': IMAGESDICT['short tree'], \n 82.                           '3': IMAGESDICT['tall tree'], \n 83.                           '4': IMAGESDICT['ugly tree']} \n 84. \n 85.     # PLAYERIMAGES is a list of all possible characters the player can be. \n 86.     # currentImage is the index of the player's current player image. \n 87.     currentImage = 0 \n 88.     PLAYERIMAGES = [IMAGESDICT['princess'], \n 89.                     IMAGESDICT['boy'], \n 90.                     IMAGESDICT['catgirl'], \n 91.                     IMAGESDICT['horngirl'], \n 92.                     IMAGESDICT['pinkgirl']] \n 93. \n 94.     startScreen() # show the title screen until the user presses a key \n 95.  \n 96.     # Read in the levels from the text file. See the readLevelsFile() for \n 97.     # details on the format of this file and how to make your own levels. \n 98.     levels = readLevelsFile('starPusherLevels.txt') \n 99.     currentLevelIndex = 0 \n100. \n101.     # The main game loop. This loop runs a single level, when the user \n102.     # finishes that level, the next/previous level is loaded. \n103.     while True: # main game loop \n104.         # Run the level to actually start playing the game: \n105.         result = runLevel(levels, currentLevelIndex) \n106. \n107.         if result in ('solved', 'next'): \n108.             # Go to the next level. \n109.             currentLevelIndex += 1 \n110.             if currentLevelIndex >= len(levels): \n111.                 # If there are no more levels, go back to the first one. \n112.                 currentLevelIndex = 0 \n113.         elif result == 'back': \n114.             # Go to the previous level. \n115.             currentLevelIndex -= 1 \n116.             if currentLevelIndex < 0: \n117.                 # If there are no previous levels, go to the last one. \n118.                 currentLevelIndex = len(levels)-1 \n119.         elif result == 'reset': \n120.             pass # Do nothing. Loop re-calls runLevel() to reset the level \n121. \n122. \n123. def runLevel(levels, levelNum): \n124.     global currentImage \n125.     levelObj = levels[levelnum] \n",
      "content_length": 2219,
      "extraction_method": "Direct"
    },
    {
      "page_number": 264,
      "chapter": null,
      "content": "246    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n126.     mapObj = decorateMap(levelObj['mapObj'], \nlevelObj['startState']['player']) \n127.     gameStateObj = copy.deepcopy(levelObj['startState']) \n128.     mapNeedsRedraw = True # set to True to call drawMap() \n129.     levelSurf = BASICFONT.render('Level %s of %s' % (levelObj['levelNum'] \n+ 1, totalNumOfLevels), 1, TEXTCOLOR) \n130.     levelRect = levelSurf.get_rect() \n131.     levelRect.bottomleft = (20, WINHEIGHT - 35) \n132.     mapWidth = len(mapObj) * TILEWIDTH \n133.     mapHeight = (len(mapObj[0]) - 1) * (TILEHEIGHT - TILEFLOORHEIGHT) + \nTILEHEIGHT \n134.     MAX_CAM_X_PAN = abs(HALF_WINHEIGHT - int(mapHeight / 2)) + TILEWIDTH \n135.     MAX_CAM_Y_PAN = abs(HALF_WINWIDTH - int(mapWidth / 2)) + TILEHEIGHT \n136.  \n137.     levelIsComplete = False \n138.     # Track how much the camera has moved: \n139.     cameraOffsetX = 0 \n140.     cameraOffsetY = 0 \n141.     # Track if the keys to move the camera are being held down: \n142.     cameraUp = False \n143.     cameraDown = False \n144.     cameraLeft = False \n145.     cameraRight = False \n146.  \n147.     while True: # main game loop \n148.         # Reset these variables: \n149.         playerMoveTo = None \n150.         keyPressed = False \n151.  \n152.         for event in pygame.event.get(): # event handling loop \n153.             if event.type == QUIT: \n154.                 # Player clicked the \"X\" at the corner of the window. \n155.                 terminate() \n156.  \n157.             elif event.type == KEYDOWN: \n158.                 # Handle key presses \n159.                 keyPressed = True \n160.                 if event.key == K_LEFT: \n161.                     playerMoveTo = LEFT \n162.                 elif event.key == K_RIGHT: \n163.                     playerMoveTo = RIGHT \n164.                 elif event.key == K_UP: \n165.                     playerMoveTo = UP \n166.                 elif event.key == K_DOWN: \n167.                     playerMoveTo = DOWN \n168.  \n",
      "content_length": 2049,
      "extraction_method": "Direct"
    },
    {
      "page_number": 265,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    247 \n \n169.                 # Set the camera move mode. \n170.                 elif event.key == K_a: \n171.                     cameraLeft = True \n172.                 elif event.key == K_d: \n173.                     cameraRight = True \n174.                 elif event.key == K_w: \n175.                     cameraUp = True \n176.                 elif event.key == K_s: \n177.                     cameraDown = True \n178.  \n179.                 elif event.key == K_n: \n180.                     return 'next' \n181.                 elif event.key == K_b: \n182.                     return 'back' \n183.  \n184.                 elif event.key == K_ESCAPE: \n185.                     terminate() # Esc key quits. \n186.                 elif event.key == K_BACKSPACE: \n187.                     return 'reset' # Reset the level. \n188.                 elif event.key == K_p: \n189.                     # Change the player image to the next one. \n190.                     currentImage += 1 \n191.                     if currentImage >= len(PLAYERIMAGES): \n192.                         # After the last player image, use the first one. \n193.                         currentImage = 0 \n194.                     mapNeedsRedraw = True \n195.  \n196.             elif event.type == KEYUP: \n197.                 # Unset the camera move mode. \n198.                 if event.key == K_a: \n199.                     cameraLeft = False \n200.                 elif event.key == K_d: \n201.                     cameraRight = False \n202.                 elif event.key == K_w: \n203.                     cameraUp = False \n204.                 elif event.key == K_s: \n205.                     cameraDown = False \n206.  \n207.         if playerMoveTo != None and not levelIsComplete: \n208.             # If the player pushed a key to move, make the move \n209.             # (if possible) and push any stars that are pushable. \n210.             moved = makeMove(mapObj, gameStateObj, playerMoveTo) \n211.  \n212.             if moved: \n213.                 # increment the step counter. \n214.                 gameStateObj['stepCounter'] += 1 \n",
      "content_length": 2123,
      "extraction_method": "Direct"
    },
    {
      "page_number": 266,
      "chapter": null,
      "content": "248    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n215.                 mapNeedsRedraw = True \n216.  \n217.             if isLevelFinished(levelObj, gameStateObj): \n218.                 # level is solved, we should show the \"Solved!\" image. \n219.                 levelIsComplete = True \n220.                 keyPressed = False \n221.  \n222.         DISPLAYSURF.fill(BGCOLOR) \n223.  \n224.         if mapNeedsRedraw: \n225.             mapSurf = drawMap(mapObj, gameStateObj, levelObj['goals']) \n226.             mapNeedsRedraw = False \n227.  \n228.         if cameraUp and cameraOffsetY < MAX_CAM_X_PAN: \n229.             cameraOffsetY += CAM_MOVE_SPEED \n230.         elif cameraDown and cameraOffsetY > -MAX_CAM_X_PAN: \n231.             cameraOffsetY -= CAM_MOVE_SPEED \n232.         if cameraLeft and cameraOffsetX < MAX_CAM_Y_PAN: \n233.             cameraOffsetX += CAM_MOVE_SPEED \n234.         elif cameraRight and cameraOffsetX > -MAX_CAM_Y_PAN: \n235.             cameraOffsetX -= CAM_MOVE_SPEED \n236.  \n237.         # Adjust mapSurf's Rect object based on the camera offset. \n238.         mapSurfRect = mapSurf.get_rect() \n239.         mapSurfRect.center = (HALF_WINWIDTH + cameraOffsetX, \nHALF_WINHEIGHT + cameraOffsetY) \n240.  \n241.         # Draw mapSurf to the DISPLAYSURF Surface object. \n242.         DISPLAYSURF.blit(mapSurf, mapSurfRect) \n243.  \n244.         DISPLAYSURF.blit(levelSurf, levelRect) \n245.         stepSurf = BASICFONT.render('Steps: %s' % \n(gameStateObj['stepCounter']), 1, TEXTCOLOR) \n246.         stepRect = stepSurf.get_rect() \n247.         stepRect.bottomleft = (20, WINHEIGHT - 10) \n248.         DISPLAYSURF.blit(stepSurf, stepRect) \n249.  \n250.         if levelIsComplete: \n251.             # is solved, show the \"Solved!\" image until the player \n252.             # has pressed a key. \n253.             solvedRect = IMAGESDICT['solved'].get_rect() \n254.             solvedRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT) \n255.             DISPLAYSURF.blit(IMAGESDICT['solved'], solvedRect) \n256.  \n257.             if keyPressed: \n258.                 return 'solved' \n",
      "content_length": 2147,
      "extraction_method": "Direct"
    },
    {
      "page_number": 267,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    249 \n \n259.  \n260.         pygame.display.update() # draw DISPLAYSURF to the screen. \n261.         FPSCLOCK.tick() \n262. \n263. \n274. def decorateMap(mapObj, startxy): \n275.     \"\"\"Makes a copy of the given map object and modifies it. \n276.     Here is what is done to it: \n277.         * Walls that are corners are turned into corner pieces. \n278.         * The outside/inside floor tile distinction is made. \n279.         * Tree/rock decorations are randomly added to the outside tiles. \n280.  \n281.     Returns the decorated map object.\"\"\" \n282.  \n283.     startx, starty = startxy # Syntactic sugar \n284.  \n285.     # Copy the map object so we don't modify the original passed \n286.     mapObjCopy = copy.deepcopy(mapObj) \n287.  \n288.     # Remove the non-wall characters from the map data \n289.     for x in range(len(mapObjCopy)): \n290.         for y in range(len(mapObjCopy[0])): \n291.             if mapObjCopy[x][y] in ('$', '.', '@', '+', '*'): \n292.                 mapObjCopy[x][y] = ' ' \n293.  \n294.     # Flood fill to determine inside/outside floor tiles. \n295.     floodFill(mapObjCopy, startx, starty, ' ', 'o') \n296.  \n297.     # Convert the adjoined walls into corner tiles. \n298.     for x in range(len(mapObjCopy)): \n299.         for y in range(len(mapObjCopy[0])): \n300. \n301.             if mapObjCopy[x][y] == '#': \n302.                 if (isWall(mapObjCopy, x, y-1) and isWall(mapObjCopy, x+1, \ny)) or \\ \n303.                    (isWall(mapObjCopy, x+1, y) and isWall(mapObjCopy, x, \ny+1)) or \\ \n304.                    (isWall(mapObjCopy, x, y+1) and isWall(mapObjCopy, x-1, \ny)) or \\ \n305.                    (isWall(mapObjCopy, x-1, y) and isWall(mapObjCopy, x, \ny-1)): \n306.                     mapObjCopy[x][y] = 'x' \n307. \n308.             elif mapObjCopy[x][y] == ' ' and random.randint(0, 99) < \nOUTSIDE_DECORATION_PCT: \n",
      "content_length": 1881,
      "extraction_method": "Direct"
    },
    {
      "page_number": 268,
      "chapter": null,
      "content": "250    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n309.                 mapObjCopy[x][y] = \nrandom.choice(list(OUTSIDEDECOMAPPING.keys())) \n310.  \n311.     return mapObjCopy  \n312. \n313. \n314. def isBlocked(mapObj, gameStateObj, x, y): \n315.     \"\"\"Returns True if the (x, y) position on the map is \n316.     blocked by a wall or star, otherwise return False.\"\"\" \n317. \n318.     if isWall(mapObj, x, y): \n319.         return True \n320. \n321.     elif x < 0 or x >= len(mapObj) or y < 0 or y >= len(mapObj[x]): \n322.         return True # x and y aren't actually on the map. \n323. \n324.     elif (x, y) in gameStateObj['stars']: \n325.         return True # a star is blocking \n326.  \n327.     return False \n328. \n329. \n330. def makeMove(mapObj, gameStateObj, playerMoveTo): \n331.     \"\"\"Given a map and game state object, see if it is possible for the \n332.     player to make the given move. If it is, then change the player's \n333.     position (and the position of any pushed star). If not, do nothing. \n334.  \n335.     Returns True if the player moved, otherwise False.\"\"\" \n336.  \n337.     # Make sure the player can move in the direction they want. \n338.     playerx, playery = gameStateObj['player'] \n339.  \n340.     # This variable is \"syntactic sugar\". Typing \"stars\" is more \n341.     # readable than typing \"gameStateObj['stars']\" in our code. \n342.     stars = gameStateObj['stars'] \n343.  \n344.     # The code for handling each of the directions is so similar aside \n345.     # from adding or subtracting 1 to the x/y coordinates. We can \n346.     # simplify it by using the xOffset and yOffset variables. \n347.     if playerMoveTo == UP: \n348.         xOffset = 0 \n349.         yOffset = -1 \n350.     elif playerMoveTo == RIGHT: \n351.         xOffset = 1 \n352.         yOffset = 0 \n353.     elif playerMoveTo == DOWN: \n",
      "content_length": 1883,
      "extraction_method": "Direct"
    },
    {
      "page_number": 269,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    251 \n \n354.         xOffset = 0 \n355.         yOffset = 1 \n356.     elif playerMoveTo == LEFT: \n357.         xOffset = -1 \n358.         yOffset = 0 \n359.  \n360.     # See if the player can move in that direction. \n361.     if isWall(mapObj, playerx + xOffset, playery + yOffset): \n362.         return False \n363.     else: \n364.         if (playerx + xOffset, playery + yOffset) in stars: \n365.             # There is a star in the way, see if the player can push it. \n366.             if not isBlocked(mapObj, gameStateObj, playerx + (xOffset*2), \nplayery + (yOffset*2)): \n367.                 # Move the star. \n368.                 ind = stars.index((playerx + xOffset, playery + yOffset)) \n369.                 stars[ind] = (stars[ind][0] + xOffset, stars[ind][1] + \nyOffset) \n370.             else: \n371.                 return False \n372.         # Move the player upwards. \n373.         gameStateObj['player'] = (playerx + xOffset, playery + yOffset) \n374.         return True \n375. \n376. \n377. def startScreen(): \n378.     \"\"\"Display the start screen (which has the title and instructions) \n379.     until the player presses a key. Returns None.\"\"\" \n380.  \n381.     # Position the title image. \n382.     titleRect = IMAGESDICT['title'].get_rect() \n383.     topCoord = 50 # topCoord tracks where to position the top of the text \n384.     titleRect.top = topCoord \n385.     titleRect.centerx = HALF_WINWIDTH \n386.     topCoord += titleRect.height \n387.  \n388.     # Unfortunately, Pygame's font & text system only shows one line at \n389.     # a time, so we can't use strings with \\n newline characters in them. \n390.     # So we will use a list with each line in it. \n391.     instructionText = ['Push the stars over the marks.', \n392.                        'Arrow keys to move, WASD for camera control, P to \nchange character.', \n393.                        'Backspace to reset level, Esc to quit.', \n394.                        'N for next level, B to go back a level.'] \n395.  \n396.     # Start with drawing a blank color to the entire window: \n",
      "content_length": 2082,
      "extraction_method": "Direct"
    },
    {
      "page_number": 270,
      "chapter": null,
      "content": "252    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n397.     DISPLAYSURF.fill(BGCOLOR) \n398.  \n399.     # Draw the title image to the window: \n400.     DISPLAYSURF.blit(IMAGESDICT['title'], titleRect) \n401.  \n402.     # Position and draw the text. \n403.     for i in range(len(instructionText)): \n404.         instSurf = BASICFONT.render(instructionText[i], 1, TEXTCOLOR) \n405.         instRect = instSurf.get_rect() \n406.         topCoord += 10 # 10 pixels will go in between each line of text. \n407.         instRect.top = topCoord \n408.         instRect.centerx = HALF_WINWIDTH \n409.         topCoord += instRect.height # Adjust for the height of the line. \n410.         DISPLAYSURF.blit(instSurf, instRect) \n411.  \n412.     while True: # Main loop for the start screen. \n413.         for event in pygame.event.get(): \n414.             if event.type == QUIT: \n415.                 terminate() \n416.             elif event.type == KEYDOWN: \n417.                 if event.key == K_ESCAPE: \n418.                     terminate() \n419.                 return # user has pressed a key, so return. \n420.  \n421.         # Display the DISPLAYSURF contents to the actual screen. \n422.         pygame.display.update() \n423.         FPSCLOCK.tick() \n424. \n425. \n426. def readLevelsFile(filename): \n427.     assert os.path.exists(filename), 'Cannot find the level file: %s' % \n(filename) \n428.     mapFile = open(filename, 'r') \n429.     # Each level must end with a blank line \n430.     content = mapFile.readlines() + ['\\r\\n'] \n431.     mapFile.close() \n432. \n433.     levels = [] # Will contain a list of level objects. \n434.     levelNum = 0 \n435.     mapTextLines = [] # contains the lines for a single level's map. \n436.     mapObj = [] # the map object made from the data in mapTextLines \n437.     for lineNum in range(len(content)): \n438.         # Process each line that was in the level file. \n439.         line = content[lineNum].rstrip('\\r\\n') \n440.  \n441.         if ';' in line: \n",
      "content_length": 2035,
      "extraction_method": "Direct"
    },
    {
      "page_number": 271,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    253 \n \n442.             # Ignore the ; lines, they're comments in the level file. \n443.             line = line[:line.find(';')] \n444.  \n445.         if line != '': \n446.             # This line is part of the map. \n447.             mapTextLines.append(line) \n448.         elif line == '' and len(mapTextLines) > 0: \n449.             # A blank line indicates the end of a level's map in the file. \n450.             # Convert the text in mapTextLines into a level object. \n451.  \n452.             # Find the longest row in the map. \n453.             maxWidth = -1 \n454.             for i in range(len(mapTextLines)): \n455.                 if len(mapTextLines[i]) > maxWidth: \n456.                     maxWidth = len(mapTextLines[i]) \n457.             # Add spaces to the ends of the shorter rows. This \n458.             # ensures the map will be rectangular. \n459.             for i in range(len(mapTextLines)): \n460.                 mapTextLines[i] += ' ' * (maxWidth - len(mapTextLines[i])) \n461.  \n462.             # Convert mapTextLines to a map object. \n463.             for x in range(len(mapTextLines[0])): \n464.                 mapObj.append([]) \n465.             for y in range(len(mapTextLines)): \n466.                 for x in range(maxWidth): \n467.                     mapObj[x].append(mapTextLines[y][x]) \n468.  \n469.             # Loop through the spaces in the map and find the @, ., and $ \n470.             # characters for the starting game state. \n471.             startx = None # The x and y for the player's starting position \n472.             starty = None \n473.             goals = [] # list of (x, y) tuples for each goal. \n474.             stars = [] # list of (x, y) for each star's starting position. \n475.             for x in range(maxWidth): \n476.                 for y in range(len(mapObj[x])): \n477.                     if mapObj[x][y] in ('@', '+'): \n478.                         # '@' is player, '+' is player & goal \n479.                         startx = x \n480.                         starty = y \n481.                     if mapObj[x][y] in ('.', '+', '*'): \n482.                         # '.' is goal, '*' is star & goal \n483.                         goals.append((x, y)) \n484.                     if mapObj[x][y] in ('$', '*'): \n485.                         # '$' is star \n486.                         stars.append((x, y)) \n487.  \n",
      "content_length": 2395,
      "extraction_method": "Direct"
    },
    {
      "page_number": 272,
      "chapter": null,
      "content": "254    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n488.             # Basic level design sanity checks: \n489.             assert startx != None and starty != None, 'Level %s (around \nline %s) in %s is missing a \"@\" or \"+\" to mark the start point.' % (levelNum+1, \nlineNum, filename) \n490.             assert len(goals) > 0, 'Level %s (around line %s) in %s must \nhave at least one goal.' % (levelNum+1, lineNum, filename) \n \n491.             assert len(stars) >= len(goals), 'Level %s (around line %s) in \n%s is impossible to solve. It has %s goals but only %s stars.' % (levelNum+1, \nlineNum, filename, len(goals), len(stars)) \n492.  \n493.             # Create level object and starting game state object. \n494.             gameStateObj = {'player': (startx, starty), \n495.                             'stepCounter': 0, \n496.                             'stars': stars} \n497.             levelObj = {'width': maxWidth, \n498.                         'height': len(mapObj), \n499.                         'mapObj': mapObj, \n500.                         'goals': goals, \n501.                         'startState': gameStateObj} \n502. \n503.             levels.append(levelObj) \n504.  \n505.             # Reset the variables for reading the next map. \n506.             mapTextLines = [] \n507.             mapObj = [] \n508.             gameStateObj = {} \n509.             levelNum += 1 \n510.     return levels \n511. \n512. \n513. def floodFill(mapObj, x, y, oldCharacter, newCharacter): \n514.     \"\"\"Changes any values matching oldCharacter on the map object to \n515.     newCharacter at the (x, y) position, and does the same for the \n516.     positions to the left, right, down, and up of (x, y), recursively.\"\"\" \n517.  \n518.     # In this game, the flood fill algorithm creates the inside/outside \n519.     # floor distinction. This is a \"recursive\" function. \n520.     # For more info on the Flood Fill algorithm, see: \n521.     #   http://en.wikipedia.org/wiki/Flood_fill \n522.     if mapObj[x][y] == oldCharacter: \n523.         mapObj[x][y] = newCharacter \n524.  \n525.     if x < len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter: \n526.         floodFill(mapObj, x+1, y, oldCharacter, newCharacter) # call right \n527.     if x > 0 and mapObj[x-1][y] == oldCharacter: \n",
      "content_length": 2319,
      "extraction_method": "Direct"
    },
    {
      "page_number": 273,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    255 \n \n528.         floodFill(mapObj, x-1, y, oldCharacter, newCharacter) # call left \n529.     if y < len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter: \n530.         floodFill(mapObj, x, y+1, oldCharacter, newCharacter) # call down \n531.     if y > 0 and mapObj[x][y-1] == oldCharacter: \n532.         floodFill(mapObj, x, y-1, oldCharacter, newCharacter) # call up \n533. \n534. \n535. def drawMap(mapObj, gameStateObj, goals): \n536.     \"\"\"Draws the map to a Surface object, including the player and \n537.     stars. This function does not call pygame.display.update(), nor \n538.     does it draw the \"Level\" and \"Steps\" text in the corner.\"\"\" \n539.  \n540.     # mapSurf will be the single Surface object that the tiles are drawn \n541.     # on, so that it is easy to position the entire map on the DISPLAYSURF \n542.     # Surface object. First, the width and height must be calculated. \n543.     mapSurfWidth = len(mapObj) * TILEWIDTH \n544.     mapSurfHeight = (len(mapObj[0]) - 1) * (TILEHEIGHT - TILEFLOORHEIGHT) \n+ TILEHEIGHT \n545.     mapSurf = pygame.Surface((mapSurfWidth, mapSurfHeight)) \n546.     mapSurf.fill(BGCOLOR) # start with a blank color on the surface. \n547.  \n548.     # Draw the tile sprites onto this surface. \n549.     for x in range(len(mapObj)): \n550.         for y in range(len(mapObj[x])): \n551.             spaceRect = pygame.Rect((x * TILEWIDTH, y * (TILEHEIGHT - \nTILEFLOORHEIGHT), TILEWIDTH, TILEHEIGHT)) \n552.             if mapObj[x][y] in TILEMAPPING: \n553.                 baseTile = TILEMAPPING[mapObj[x][y]] \n554.             elif mapObj[x][y] in OUTSIDEDECOMAPPING: \n555.                 baseTile = TILEMAPPING[' '] \n556.  \n557.             # First draw the base ground/wall tile. \n558.             mapSurf.blit(baseTile, spaceRect) \n559.  \n560.             if mapObj[x][y] in OUTSIDEDECOMAPPING: \n561.                 # Draw any tree/rock decorations that are on this tile. \n562.                 mapSurf.blit(OUTSIDEDECOMAPPING[mapObj[x][y]], spaceRect) \n563.             elif (x, y) in gameStateObj['stars']: \n564.                 if (x, y) in goals: \n565.                     # A goal AND star are on this space, draw goal first. \n566.                     mapSurf.blit(IMAGESDICT['covered goal'], spaceRect) \n567.                 # Then draw the star sprite. \n568.                 mapSurf.blit(IMAGESDICT['star'], spaceRect) \n569.             elif (x, y) in goals: \n570.                 # Draw a goal without a star on it. \n571.                 mapSurf.blit(IMAGESDICT['uncovered goal'], spaceRect) \n",
      "content_length": 2571,
      "extraction_method": "Direct"
    },
    {
      "page_number": 274,
      "chapter": null,
      "content": "256    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n572.  \n573.             # Last draw the player on the board. \n574.             if (x, y) == gameStateObj['player']: \n575.                 # Note: The value \"currentImage\" refers \n576.                 # to a key in \"PLAYERIMAGES\" which has the \n577.                 # specific player image we want to show. \n578.                 mapSurf.blit(PLAYERIMAGES[currentImage], spaceRect) \n579.  \n580.     return mapSurf \n581. \n582. \n583. def isLevelFinished(levelObj, gameStateObj): \n584.     \"\"\"Returns True if all the goals have stars in them.\"\"\" \n585.     for goal in levelObj['goals']: \n586.         if goal not in gameStateObj['stars']: \n587.             # Found a space with a goal but no star on it. \n588.             return False \n589.     return True \n590. \n591. \n592. def terminate(): \n593.     pygame.quit() \n594.     sys.exit() \n595. \n596. \n597. if __name__ == '__main__': \n598.     main() \nThe Initial Setup \n  1. # Star Pusher (a Sokoban clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Creative Commons BY-NC-SA 3.0 US \n  5.  \n  6. import random, sys, copy, os, pygame \n  7. from pygame.locals import * \n  8.  \n  9. FPS = 30 # frames per second to update the screen \n 10. WINWIDTH = 800 # width of the program's window, in pixels \n 11. WINHEIGHT = 600 # height in pixels \n 12. HALF_WINWIDTH = int(WINWIDTH / 2) \n 13. HALF_WINHEIGHT = int(WINHEIGHT / 2) \n 14.  \n 15. # The total width and height of each tile in pixels. \n 16. TILEWIDTH = 50 \n",
      "content_length": 1607,
      "extraction_method": "Direct"
    },
    {
      "page_number": 275,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    257 \n \n 17. TILEHEIGHT = 85 \n 18. TILEFLOORHEIGHT = 45 \n 19.  \n 20. CAM_MOVE_SPEED = 5 # how many pixels per frame the camera moves \n 21.  \n 22. # The percentage of outdoor tiles that have additional \n 23. # decoration on them, such as a tree or rock. \n 24. OUTSIDE_DECORATION_PCT = 20 \n 25.  \n 26. BRIGHTBLUE = (  0, 170, 255) \n 27. WHITE      = (255, 255, 255) \n 28. BGCOLOR = BRIGHTBLUE \n 29. TEXTCOLOR = WHITE \n 30.  \n 31. UP = 'up' \n 32. DOWN = 'down' \n 33. LEFT = 'left' \n 34. RIGHT = 'right' \nThese constants are used in various parts of the program. The TILEWIDTH and TILEHEIGHT \nvariables show that each of the tile images are 50 pixels wide and 85 pixels tall. However, these \ntiles overlap with each other when drawn on the screen. (This is explained later.) The \nTILEFLOORHEIGHT refers to the fact that the part of the tile that represents the floor is 45 \npixels tall. Here is a diagram of the plain floor image: \n \nThe grassy tiles outside of the level’s room will sometimes have extra decorations added to them \n(such as trees or rocks). The OUTSIDE_DECORATION_PCT constant shows what percentage of \nthese tiles will randomly have these decorations. \n 37. def main(): \n 38.     global FPSCLOCK, DISPLAYSURF, IMAGESDICT, TILEMAPPING, \nOUTSIDEDECOMAPPING, BASICFONT, PLAYERIMAGES, currentImage \n 39.  \n 40.     # Pygame initialization and basic set up of the global variables. \n 41.     pygame.init() \n 42.     FPSCLOCK = pygame.time.Clock() \n 43.  \n 44.     # Because the Surface object stored in DISPLAYSURF was returned \n",
      "content_length": 1564,
      "extraction_method": "Direct"
    },
    {
      "page_number": 276,
      "chapter": null,
      "content": "258    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 45.     # from the pygame.display.set_mode() function, this is the \n 46.     # Surface object that is drawn to the actual computer screen \n 47.     # when pygame.display.update() is called. \n 48.     DISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT)) \n 49.  \n 50.     pygame.display.set_caption('Star Pusher') \n 51.     BASICFONT = pygame.font.Font('freesansbold.ttf', 18) \nThis is the usual Pygame setup that happens at the beginning of the program. \n 53.     # A global dict value that will contain all the Pygame \n 54.     # Surface objects returned by pygame.image.load(). \n 55.     IMAGESDICT = {'uncovered goal': pygame.image.load('RedSelector.png'), \n 56.                   'covered goal': pygame.image.load('Selector.png'), \n 57.                   'star': pygame.image.load('Star.png'), \n 58.                   'corner': pygame.image.load('Wall Block Tall.png'), \n 59.                   'wall': pygame.image.load('Wood Block Tall.png'), \n 60.                   'inside floor': pygame.image.load('Plain Block.png'), \n 61.                   'outside floor': pygame.image.load('Grass Block.png'), \n 62.                   'title': pygame.image.load('star_title.png'), \n 63.                   'solved': pygame.image.load('star_solved.png'), \n 64.                   'princess': pygame.image.load('princess.png'), \n 65.                   'boy': pygame.image.load('boy.png'), \n 66.                   'catgirl': pygame.image.load('catgirl.png'), \n 67.                   'horngirl': pygame.image.load('horngirl.png'), \n 68.                   'pinkgirl': pygame.image.load('pinkgirl.png'), \n 69.                   'rock': pygame.image.load('Rock.png'), \n 70.                   'short tree': pygame.image.load('Tree_Short.png'), \n 71.                   'tall tree': pygame.image.load('Tree_Tall.png'), \n 72.                   'ugly tree': pygame.image.load('Tree_Ugly.png')} \nThe IMAGESDICT is a dictionary where all of the loaded images are stored. This makes it easier \nto use in other functions, since only the IMAGESDICT variable needs to be made global. If we \nstored each of these images in separate variables, then all 18 variables (for the 18 images used in \nthis game) would need to be made global. A dictionary containing all of the Surface objects with \nthe images is easier to handle. \n 74.     # These dict values are global, and map the character that appears \n 75.     # in the level file to the Surface object it represents. \n 76.     TILEMAPPING = {'x': IMAGESDICT['corner'], \n 77.                    '#': IMAGESDICT['wall'], \n 78.                    'o': IMAGESDICT['inside floor'], \n 79.                    ' ': IMAGESDICT['outside floor']} \n",
      "content_length": 2771,
      "extraction_method": "Direct"
    },
    {
      "page_number": 277,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    259 \n \nThe data structure for the map is just a 2D list of single character strings. The TILEMAPPING \ndictionary links the characters used in this map data structure to the images that they represent. \n(This will become more clear in the drawMap() function’s explanation.) \n 80.     OUTSIDEDECOMAPPING = {'1': IMAGESDICT['rock'], \n 81.                           '2': IMAGESDICT['short tree'], \n 82.                           '3': IMAGESDICT['tall tree'], \n 83.                           '4': IMAGESDICT['ugly tree']} \nThe OUTSIDEDECOMAPPING is also a dictionary that links the characters used in the map data \nstructure to images that were loaded. The ―outside decoration‖ images are drawn on top of the \noutdoor grassy tile. \n 85.     # PLAYERIMAGES is a list of all possible characters the player can be. \n 86.     # currentImage is the index of the player's current player image. \n 87.     currentImage = 0 \n 88.     PLAYERIMAGES = [IMAGESDICT['princess'], \n 89.                     IMAGESDICT['boy'], \n 90.                     IMAGESDICT['catgirl'], \n 91.                     IMAGESDICT['horngirl'], \n 92.                     IMAGESDICT['pinkgirl']] \nThe PLAYERIMAGES list stores the images used for the player. The currentImage variable \ntracks the index of the currently selected player image. For example, when currentImage is \nset to 0 then PLAYERIMAGES[0], which is the ―princess‖ player image, is drawn to the screen. \n 94.     startScreen() # show the title screen until the user presses a key \n 95.  \n 96.     # Read in the levels from the text file. See the readLevelsFile() for \n 97.     # details on the format of this file and how to make your own levels. \n 98.     levels = readLevelsFile('starPusherLevels.txt') \n 99.     currentLevelIndex = 0 \nThe startScreen() function will keep displaying the initial start screen (which also has the \ninstructions for the game) until the player presses a key. When the player presses a key, the \nstartScreen() function returns and then reads in the levels from the level file. The player \nstarts off on the first level, which is the level object in the levels list at index 0. \n101.     # The main game loop. This loop runs a single level, when the user \n102.     # finishes that level, the next/previous level is loaded. \n103.     while True: # main game loop \n104.         # Run the level to actually start playing the game: \n",
      "content_length": 2411,
      "extraction_method": "Direct"
    },
    {
      "page_number": 278,
      "chapter": null,
      "content": "260    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n105.         result = runLevel(levels, currentLevelIndex) \nThe runLevel() function handles all the action for the game. It is passed a list of level objects, \nand the integer index of the level in that list to be played. When the player has finished playing \nthe level, runLevel() will return one of the following strings: 'solved' (because the player \nhas finished putting all the stars on the goals), 'next' (because the player wants to skip to the \nnext level), 'back' (because the player wants to go back to the previous level), and 'reset' \n(because the player wants to start playing the current level over again, maybe because they \npushed a star into a corner). \n107.         if result in ('solved', 'next'): \n108.             # Go to the next level. \n109.             currentLevelIndex += 1 \n110.             if currentLevelIndex >= len(levels): \n111.                 # If there are no more levels, go back to the first one. \n112.                 currentLevelIndex = 0 \n113.         elif result == 'back': \n114.             # Go to the previous level. \n115.             currentLevelIndex -= 1 \n116.             if currentLevelIndex < 0: \n117.                 # If there are no previous levels, go to the last one. \n118.                 currentLevelIndex = len(levels)-1 \nIf runLevel() has returned the strings 'solved' or 'next', then we need to increment \nlevelNum by 1. If this increments levelNum beyond the number of levels there are, then \nlevelNum is set back at 0. \nThe opposite is done if 'back' is returned, then levelNum is decremented by 1. If this makes \nit go below 0, then it is set to the last level (which is len(levels)-1). \n119.         elif result == 'reset': \n120.             pass # Do nothing. Loop re-calls runLevel() to reset the level \nIf the return value was 'reset', then the code does nothing. The pass statement does nothing \n(like a comment), but is needed because the Python interpreter expects an indented line of code \nafter an elif statement. \nWe could remove lines 119 and 120 from the source code entirely, and the program will still \nwork just the same. The reason we include it here is for program readability, so that if we make \nchanges to the code later, we won’t forget that runLevel() can also return the string \n'reset'. \n",
      "content_length": 2377,
      "extraction_method": "Direct"
    },
    {
      "page_number": 279,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    261 \n \n123. def runLevel(levels, levelNum): \n124.     global currentImage \n125.     levelObj = levels[levelnum] \n126.     mapObj = decorateMap(levelObj['mapObj'], \nlevelObj['startState']['player']) \n127.     gameStateObj = copy.deepcopy(levelObj['startState']) \nThe levels list contains all the level objects that were loaded from the level file. The level object \nfor the current level (which is what levelNum is set to) is stored in the levelObj variable. A \nmap object (which makes a distinction between indoor and outdoor tiles, and decorates the \noutdoor tiles with trees and rocks) is returned from the decorateMap() function. And to track \nthe state of the game while the player plays this level, a copy of the game state object that is \nstored in levelObj is made using the copy.deepcopy() function. \nThe game state object copy is made because the game state object stored in \nlevelObj['startState'] represents the game state at the very beginning of the level, and \nwe do not want to modify this. Otherwise, if the player restarts the level, the original game state \nfor that level will be lost. \nThe copy.deepcopy() function is used because the game state object is a dictionary of that \nhas tuples. But technically, the dictionary contains references to tuples. (References are explained \nin detail at http://invpy.com/references.) Using an assignment statement to make a copy of the \ndictionary will make a copy of the references but not the values they refer to, so that both the \ncopy and the original dictionary still refer to the same tuples. \nThe copy.deepcopy() function solves this problem by making copies of the actual tuples in \nthe dictionary. This way we can guarantee that changing one dictionary will not affect the other \ndictionary. \n128.     mapNeedsRedraw = True # set to True to call drawMap() \n129.     levelSurf = BASICFONT.render('Level %s of %s' % (levelObj['levelNum'] \n+ 1, totalNumOfLevels), 1, TEXTCOLOR) \n130.     levelRect = levelSurf.get_rect() \n131.     levelRect.bottomleft = (20, WINHEIGHT - 35) \n132.     mapWidth = len(mapObj) * TILEWIDTH \n133.     mapHeight = (len(mapObj[0]) - 1) * (TILEHEIGHT - TILEFLOORHEIGHT) + \nTILEHEIGHT \n134.     MAX_CAM_X_PAN = abs(HALF_WINHEIGHT - int(mapHeight / 2)) + TILEWIDTH \n135.     MAX_CAM_Y_PAN = abs(HALF_WINWIDTH - int(mapWidth / 2)) + TILEHEIGHT \n136.  \n137.     levelIsComplete = False \n138.     # Track how much the camera has moved: \n139.     cameraOffsetX = 0 \n",
      "content_length": 2479,
      "extraction_method": "Direct"
    },
    {
      "page_number": 280,
      "chapter": null,
      "content": "262    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n140.     cameraOffsetY = 0 \n141.     # Track if the keys to move the camera are being held down: \n142.     cameraUp = False \n143.     cameraDown = False \n144.     cameraLeft = False \n145.     cameraRight = False \nMore variables are set at the start of playing a level. The mapWidth and mapHeight variables \nare the size of the maps in pixels. The expression for calculating mapHeight is a bit \ncomplicated since the tiles overlap each other. Only the bottom row of tiles is the full height \n(which accounts for the + TILEHEIGHT part of the expression), all of the other rows of tiles \n(which number as (len(mapObj[0]) - 1)) are slightly overlapped. This means that they \nare effectively each only (TILEHEIGHT - TILEFLOORHEIGHT) pixels tall. \nThe camera in Star Pusher can be moved independently of the player moving around the map. \nThis is why the camera needs its own set of ―moving‖ variables: cameraUp, cameraDown, \ncameraLeft, and cameraRight. The cameraOffsetX and cameraOffsetY variables \ntrack the position of the camera. \n147.     while True: # main game loop \n148.         # Reset these variables: \n149.         playerMoveTo = None \n150.         keyPressed = False \n151.  \n152.         for event in pygame.event.get(): # event handling loop \n153.             if event.type == QUIT: \n154.                 # Player clicked the \"X\" at the corner of the window. \n155.                 terminate() \n156.  \nThe playerMoveTo variable will be set to the direction constant that the player intends to \nmove the player character on the map. The keyPressed variable tracks if any key has been \npressed during this iteration of the game loop. This variable is checked later when the player has \nsolved the level. \n157.             elif event.type == KEYDOWN: \n158.                 # Handle key presses \n159.                 keyPressed = True \n160.                 if event.key == K_LEFT: \n161.                     playerMoveTo = LEFT \n162.                 elif event.key == K_RIGHT: \n163.                     playerMoveTo = RIGHT \n164.                 elif event.key == K_UP: \n",
      "content_length": 2177,
      "extraction_method": "Direct"
    },
    {
      "page_number": 281,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    263 \n \n165.                     playerMoveTo = UP \n166.                 elif event.key == K_DOWN: \n167.                     playerMoveTo = DOWN \n168.  \n169.                 # Set the camera move mode. \n170.                 elif event.key == K_a: \n171.                     cameraLeft = True \n172.                 elif event.key == K_d: \n173.                     cameraRight = True \n174.                 elif event.key == K_w: \n175.                     cameraUp = True \n176.                 elif event.key == K_s: \n177.                     cameraDown = True \n178.  \n179.                 elif event.key == K_n: \n180.                     return 'next' \n181.                 elif event.key == K_b: \n182.                     return 'back' \n183.  \n184.                 elif event.key == K_ESCAPE: \n185.                     terminate() # Esc key quits. \n186.                 elif event.key == K_BACKSPACE: \n187.                     return 'reset' # Reset the level. \n188.                 elif event.key == K_p: \n189.                     # Change the player image to the next one. \n190.                     currentImage += 1 \n191.                     if currentImage >= len(PLAYERIMAGES): \n192.                         # After the last player image, use the first one. \n193.                         currentImage = 0 \n194.                     mapNeedsRedraw = True \n195.  \n196.             elif event.type == KEYUP: \n197.                 # Unset the camera move mode. \n198.                 if event.key == K_a: \n199.                     cameraLeft = False \n200.                 elif event.key == K_d: \n201.                     cameraRight = False \n202.                 elif event.key == K_w: \n203.                     cameraUp = False \n204.                 elif event.key == K_s: \n205.                     cameraDown = False \nThis code handles what to do when the various keys are pressed. \n207.         if playerMoveTo != None and not levelIsComplete: \n208.             # If the player pushed a key to move, make the move \n",
      "content_length": 2041,
      "extraction_method": "Direct"
    },
    {
      "page_number": 282,
      "chapter": null,
      "content": "264    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n209.             # (if possible) and push any stars that are pushable. \n210.             moved = makeMove(mapObj, gameStateObj, playerMoveTo) \n211.  \n212.             if moved: \n213.                 # increment the step counter. \n214.                 gameStateObj['stepCounter'] += 1 \n215.                 mapNeedsRedraw = True \n216.  \n217.             if isLevelFinished(levelObj, gameStateObj): \n218.                 # level is solved, we should show the \"Solved!\" image. \n219.                 levelIsComplete = True \n220.                 keyPressed = False \nIf the playerMoveTo variable is no longer set to None, then we know the player intended to \nmove. The call to makeMove() handles changing the XY coordinates of the player’s position in \nthe gameStateObj, as well as pushing any stars. The return value of makeMove() is stored \nin moved. If this value is True, then the player character was moved in that direction. If the \nvalue was False, then the player must have tried to move into a tile that was a wall, or push a \nstar that had something behind it. In this case, the player can’t move and nothing on the map \nchanges. \n222.         DISPLAYSURF.fill(BGCOLOR) \n223.  \n224.         if mapNeedsRedraw: \n225.             mapSurf = drawMap(mapObj, gameStateObj, levelObj['goals']) \n226.             mapNeedsRedraw = False \nThe map does not need to be redrawn on each iteration through the game loop. In fact, this game \nprogram is complicated enough that doing so would cause a slight (but noticeable) slowdown in \nthe game. And the map really only needs to be redrawn when something has changed (such as the \nplayer moving or a star being pushed). So the Surface object in the mapSurf variable is only \nupdated with a call to the drawMap() function when the mapNeedsRedraw variable is set to \nTrue. \nAfter the map has been drawn on line 225, the mapNeedsRedraw variable is set to False. If \nyou want to see how the program slows down by drawing on each iteration through the game \nloop, comment out line 226 and rerun the program. You will notice that moving the camera is \nsignificantly slower. \n228.         if cameraUp and cameraOffsetY < MAX_CAM_X_PAN: \n229.             cameraOffsetY += CAM_MOVE_SPEED \n230.         elif cameraDown and cameraOffsetY > -MAX_CAM_X_PAN: \n",
      "content_length": 2388,
      "extraction_method": "Direct"
    },
    {
      "page_number": 283,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    265 \n \n231.             cameraOffsetY -= CAM_MOVE_SPEED \n232.         if cameraLeft and cameraOffsetX < MAX_CAM_Y_PAN: \n233.             cameraOffsetX += CAM_MOVE_SPEED \n234.         elif cameraRight and cameraOffsetX > -MAX_CAM_Y_PAN: \n235.             cameraOffsetX -= CAM_MOVE_SPEED \nIf the camera movement variables are set to True and the camera has not gone past (i.e. panned \npassed) the boundaries set by the MAX_CAM_X_PAN and MAX_CAM_Y_PAN, then the camera \nlocation (stored in cameraOffsetX and cameraOffsetY) should move over by \nCAM_MOVE_SPEED pixels. \nNote that there is an if and elif statement on lines 228 and 230 for moving the camera up and \ndown, and then a separate if and elif statement on lines 232 and 234. This way, the user can \nmove the camera both vertically and horizontally at the same time. This wouldn’t be possible if \nline 232 were an elif statement. \n237.         # Adjust mapSurf's Rect object based on the camera offset. \n238.         mapSurfRect = mapSurf.get_rect() \n239.         mapSurfRect.center = (HALF_WINWIDTH + cameraOffsetX, \nHALF_WINHEIGHT + cameraOffsetY) \n240.  \n241.         # Draw mapSurf to the DISPLAYSURF Surface object. \n242.         DISPLAYSURF.blit(mapSurf, mapSurfRect) \n243.  \n244.         DISPLAYSURF.blit(levelSurf, levelRect) \n245.         stepSurf = BASICFONT.render('Steps: %s' % \n(gameStateObj['stepCounter']), 1, TEXTCOLOR) \n246.         stepRect = stepSurf.get_rect() \n247.         stepRect.bottomleft = (20, WINHEIGHT - 10) \n248.         DISPLAYSURF.blit(stepSurf, stepRect) \n249.  \n250.         if levelIsComplete: \n251.             # is solved, show the \"Solved!\" image until the player \n252.             # has pressed a key. \n253.             solvedRect = IMAGESDICT['solved'].get_rect() \n254.             solvedRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT) \n255.             DISPLAYSURF.blit(IMAGESDICT['solved'], solvedRect) \n256.  \n257.             if keyPressed: \n258.                 return 'solved' \n259.  \n260.         pygame.display.update() # draw DISPLAYSURF to the screen. \n261.         FPSCLOCK.tick() \n262. \n",
      "content_length": 2119,
      "extraction_method": "Direct"
    },
    {
      "page_number": 284,
      "chapter": null,
      "content": "266    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n263. \nLines 237 to 261 position the camera and draw the map and other graphics to the display Surface \nobject in DISPLAYSURF. If the level is solved, then the victory graphic is also drawn on top of \neverything else. The keyPressed variable will be set to True if the user pressed a key during \nthis iteration, at which point the runLevel() function returns. \n264. def isWall(mapObj, x, y): \n265.     \"\"\"Returns True if the (x, y) position on \n266.     the map is a wall, otherwise return False.\"\"\" \n267.     if x < 0 or x >= len(mapObj) or y < 0 or y >= len(mapObj[x]): \n268.         return False # x and y aren't actually on the map. \n269.     elif mapObj[x][y] in ('#', 'x'): \n270.         return True # wall is blocking \n271.     return False \nThe isWall() function returns True if there is a wall on the map object at the XY coordinates \npassed to the function. Wall objects are represented as either a 'x' or '#' string in the map \nobject. \n274. def decorateMap(mapObj, startxy): \n275.     \"\"\"Makes a copy of the given map object and modifies it. \n276.     Here is what is done to it: \n277.         * Walls that are corners are turned into corner pieces. \n278.         * The outside/inside floor tile distinction is made. \n279.         * Tree/rock decorations are randomly added to the outside tiles. \n280.  \n281.     Returns the decorated map object.\"\"\" \n282.  \n283.     startx, starty = startxy # Syntactic sugar \n284.  \n285.     # Copy the map object so we don't modify the original passed \n286.     mapObjCopy = copy.deepcopy(mapObj) \nThe decorateMap() function alters the data structure mapObj so that it isn’t as plain as it \nappears in the map file. The three things that decorateMap() changes are explained in the \ncomment at the top of the function. \n288.     # Remove the non-wall characters from the map data \n289.     for x in range(len(mapObjCopy)): \n290.         for y in range(len(mapObjCopy[0])): \n291.             if mapObjCopy[x][y] in ('$', '.', '@', '+', '*'): \n",
      "content_length": 2091,
      "extraction_method": "Direct"
    },
    {
      "page_number": 285,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    267 \n \n292.                 mapObjCopy[x][y] = ' ' \nThe map object has characters that represent the position of the player, goals, and stars. These are \nnecessary for the map object (they’re stored in other data structures after the map file is read) so \nthey are converted to blank spaces. \n294.     # Flood fill to determine inside/outside floor tiles. \n295.     floodFill(mapObjCopy, startx, starty, ' ', 'o') \nThe floodFill() function will change all of the tiles inside the walls from ' ' characters to \n'o' characters. It does this using a programming concept called recursion, which is explained in \n―Recursive Functions‖ section later in this chapter. \n297.     # Convert the adjoined walls into corner tiles. \n298.     for x in range(len(mapObjCopy)): \n299.         for y in range(len(mapObjCopy[0])): \n300. \n301.             if mapObjCopy[x][y] == '#': \n302.                 if (isWall(mapObjCopy, x, y-1) and isWall(mapObjCopy, x+1, \ny)) or \\ \n303.                    (isWall(mapObjCopy, x+1, y) and isWall(mapObjCopy, x, \ny+1)) or \\ \n304.                    (isWall(mapObjCopy, x, y+1) and isWall(mapObjCopy, x-1, \ny)) or \\ \n305.                    (isWall(mapObjCopy, x-1, y) and isWall(mapObjCopy, x, \ny-1)): \n306.                     mapObjCopy[x][y] = 'x' \n307. \n308.             elif mapObjCopy[x][y] == ' ' and random.randint(0, 99) < \nOUTSIDE_DECORATION_PCT: \n309.                 mapObjCopy[x][y] = \nrandom.choice(list(OUTSIDEDECOMAPPING.keys())) \n310.  \n311.     return mapObjCopy  \nThe large, multi-line if statement on line 301 checks if the wall tile at the current XY \ncoordinates are a corner wall tile by checking if there are wall tiles adjacent to it that form a \ncorner shape. If so, the '#' string in the map object that represents a normal wall is changed to a \n'x' string which represents a corner wall tile. \n314. def isBlocked(mapObj, gameStateObj, x, y): \n315.     \"\"\"Returns True if the (x, y) position on the map is \n316.     blocked by a wall or star, otherwise return False.\"\"\" \n",
      "content_length": 2047,
      "extraction_method": "Direct"
    },
    {
      "page_number": 286,
      "chapter": null,
      "content": "268    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n317. \n318.     if isWall(mapObj, x, y): \n319.         return True \n320. \n321.     elif x < 0 or x >= len(mapObj) or y < 0 or y >= len(mapObj[x]): \n322.         return True # x and y aren't actually on the map. \n323. \n324.     elif (x, y) in gameStateObj['stars']: \n325.         return True # a star is blocking \n326.  \n327.     return False \nThere are three cases where a space on the map would be blocked: if there is a star, a wall, or the \ncoordinates of the space are past the edges of the map. The isBlocked() function checks for \nthese three cases and returns True if the XY coordinates are blocked and False if not. \n330. def makeMove(mapObj, gameStateObj, playerMoveTo): \n331.     \"\"\"Given a map and game state object, see if it is possible for the \n332.     player to make the given move. If it is, then change the player's \n333.     position (and the position of any pushed star). If not, do nothing. \n334.  \n335.     Returns True if the player moved, otherwise False.\"\"\" \n336.  \n337.     # Make sure the player can move in the direction they want. \n338.     playerx, playery = gameStateObj['player'] \n339.  \n340.     # This variable is \"syntactic sugar\". Typing \"stars\" is more \n341.     # readable than typing \"gameStateObj['stars']\" in our code. \n342.     stars = gameStateObj['stars'] \n343.  \n344.     # The code for handling each of the directions is so similar aside \n345.     # from adding or subtracting 1 to the x/y coordinates. We can \n346.     # simplify it by using the xOffset and yOffset variables. \n347.     if playerMoveTo == UP: \n348.         xOffset = 0 \n349.         yOffset = -1 \n350.     elif playerMoveTo == RIGHT: \n351.         xOffset = 1 \n352.         yOffset = 0 \n353.     elif playerMoveTo == DOWN: \n354.         xOffset = 0 \n355.         yOffset = 1 \n356.     elif playerMoveTo == LEFT: \n357.         xOffset = -1 \n358.         yOffset = 0 \n",
      "content_length": 1982,
      "extraction_method": "Direct"
    },
    {
      "page_number": 287,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    269 \n \n359.  \n360.     # See if the player can move in that direction. \n361.     if isWall(mapObj, playerx + xOffset, playery + yOffset): \n362.         return False \n363.     else: \n364.         if (playerx + xOffset, playery + yOffset) in stars: \n365.             # There is a star in the way, see if the player can push it. \n366.             if not isBlocked(mapObj, gameStateObj, playerx + (xOffset*2), \nplayery + (yOffset*2)): \n367.                 # Move the star. \n368.                 ind = stars.index((playerx + xOffset, playery + yOffset)) \n369.                 stars[ind] = (stars[ind][0] + xOffset, stars[ind][1] + \nyOffset) \n370.             else: \n371.                 return False \n372.         # Move the player upwards. \n373.         gameStateObj['player'] = (playerx + xOffset, playery + yOffset) \n374.         return True \nThe makeMove() function checks to make sure if moving the player in a particular direction is \na valid move. As long as there isn’t a wall blocking the path, or a star that has a wall or star \nbehind it, the player will be able to move in that direction. The gameStateObj variable will be \nupdated to reflect this, and the True value will be returned to tell the function’s caller that the \nplayer was moved. \nIf there was a star in the space that the player wanted to move, that star’s position is also changed \nand this information is updated in the gameStateObj variable as well. This is how the ―star \npushing‖ is implemented. \nIf the player is blocked from moving in the desired direction, then the gameStateObj is not \nmodified and the function returns False. \n377. def startScreen(): \n378.     \"\"\"Display the start screen (which has the title and instructions) \n379.     until the player presses a key. Returns None.\"\"\" \n380.  \n381.     # Position the title image. \n382.     titleRect = IMAGESDICT['title'].get_rect() \n383.     topCoord = 50 # topCoord tracks where to position the top of the text \n384.     titleRect.top = topCoord \n385.     titleRect.centerx = HALF_WINWIDTH \n386.     topCoord += titleRect.height \n387.  \n388.     # Unfortunately, Pygame's font & text system only shows one line at \n",
      "content_length": 2178,
      "extraction_method": "Direct"
    },
    {
      "page_number": 288,
      "chapter": null,
      "content": "270    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n389.     # a time, so we can't use strings with \\n newline characters in them. \n390.     # So we will use a list with each line in it. \n391.     instructionText = ['Push the stars over the marks.', \n392.                        'Arrow keys to move, WASD for camera control, P to \nchange character.', \n393.                        'Backspace to reset level, Esc to quit.', \n394.                        'N for next level, B to go back a level.'] \nThe startScreen() function needs to display a few different pieces of text down the center \nof the window. We will store each line as a string in the instructionText list. The title \nimage (stored in IMAGESDICT['title'] as a Surface object (that was originally loaded from \nthe star_title.png file)) will be positioned 50 pixels from the top of the window. This is because \nthe integer 50 was stored in the topCoord variable on line 383. The topCoord variable will \ntrack the Y axis positioning of the title image and the instructional text. The X axis is always \ngoing to be set so that the images and text are centered, as it is on line 385 for the title image. \nOn line 386, the topCoord variable is increased by whatever the height of that image is. This \nway we can modify the image and the start screen code won’t have to be changed. \n396.     # Start with drawing a blank color to the entire window: \n397.     DISPLAYSURF.fill(BGCOLOR) \n398.  \n399.     # Draw the title image to the window: \n400.     DISPLAYSURF.blit(IMAGESDICT['title'], titleRect) \n401.  \n402.     # Position and draw the text. \n403.     for i in range(len(instructionText)): \n404.         instSurf = BASICFONT.render(instructionText[i], 1, TEXTCOLOR) \n405.         instRect = instSurf.get_rect() \n406.         topCoord += 10 # 10 pixels will go in between each line of text. \n407.         instRect.top = topCoord \n408.         instRect.centerx = HALF_WINWIDTH \n409.         topCoord += instRect.height # Adjust for the height of the line. \n410.         DISPLAYSURF.blit(instSurf, instRect) \nLine 400 is where the title image is blitted to the display Surface object. The for loop starting on \nline 403 will render, position, and blit each instructional string in the instructionText loop. \nThe topCoord variable will always be incremented by the size of the previously rendered text \n(line 409) and 10 additional pixels (on line 406, so that there will be a 10 pixel gap between the \nlines of text). \n412.     while True: # Main loop for the start screen. \n413.         for event in pygame.event.get(): \n",
      "content_length": 2627,
      "extraction_method": "Direct"
    },
    {
      "page_number": 289,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    271 \n \n414.             if event.type == QUIT: \n415.                 terminate() \n416.             elif event.type == KEYDOWN: \n417.                 if event.key == K_ESCAPE: \n418.                     terminate() \n419.                 return # user has pressed a key, so return. \n420.  \n421.         # Display the DISPLAYSURF contents to the actual screen. \n422.         pygame.display.update() \n423.         FPSCLOCK.tick() \nThere is a game loop in startScreen() that begins on line 412 and handles events that \nindicate if the program should terminate or return from the startScreen() function. Until the \nplayer does either, the loop will keep calling pygame.display.update() and \nFPSCLOCK.tick() to keep the start screen displayed on the screen. \nData Structures in Star Pusher \nStar Pusher has a specific format for the levels, maps, and game state data structures. \nThe “Game State” Data Structure \nThe game state object will be a dictionary with three keys: 'player', 'stepCounter', and \n'stars'. \n \nThe value at the 'player' key will be a tuple of two integers for the current XY \nposition of the player. \n \nThe value at the 'stepCounter' key will be an integer that tracks how many moves \nthe player has made in this level (so the player can try to solve the puzzle in the future \nwith fewer steps). \n \nThe value at the 'stars' key is a list of two-integer tuples of XY values for each of the \nstars on the current level. \nThe “Map” Data Structure \nThe map data structure is simply a 2D list of lists where the two indexes used represent the X and \nY coordinates of the map. The value at each index in the list of lists is a single-character string \nthat represents the title that is on that map at each space: \n \n'#' – A wooden wall. \n \n'x' – A corner wall. \n \n'@' – The starting space for the player on this level. \n \n'.' – A goal space. \n \n'$' – A space where a star is at the start of the level. \n",
      "content_length": 1945,
      "extraction_method": "Direct"
    },
    {
      "page_number": 290,
      "chapter": null,
      "content": "272    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n'+' – A space with a goal and the starting player’s space. \n \n'*' – A space with a goal and a star at the start of the level. \n \n' ' – A grassy outdoor space. \n \n'o' – An inside floor space. (This is a lowercase letter O, not a zero.) \n \n'1' – A rock on grass. \n \n'2' – A short tree on grass. \n \n'3' – A tall tree on grass. \n \n'4' – An ugly tree on grass. \nThe “Levels” Data Structure \nThe level object contains a game state object (which will be the state used when the level first \nstarts), a map object, and a few other values. The level object itself is a dictionary with the \nfollowing keys: \n \nThe value at the key 'width' is an integer of how many tiles wide the entire map is. \n \nThe value at the key 'height' is an integer of how many tiles tall the entire map is. \n \nThe value at the key 'mapObj' is the map object for this level. \n \nThe value at the key 'goals' is a list of two-integer tuples with the XY coordinates of \neach goal space on the map. \n \nThe value at the key 'startState' is a game state object used to show the starting \nposition of the stars and player at the start of the level. \nReading and Writing Text Files \nPython has functions for reading files off of the player’s hard drive. This will be useful for having \na separate file keep all of the data for each level. This is also a good idea because in order to get \nnew levels, the player doesn’t have to change the source code of the game but instead can just \ndownload new level files. \nText Files and Binary Files \nText files are files that contain simple text data. Text files are created in Windows by the Notepad \napplication, Gedit on Ubuntu, and TextEdit on Mac OS X. There are many other programs called \ntext editors that can create and modify text files. IDLE’s own file editor is a text editor. \nThe difference between text editors and word processors (like Microsoft Word, or OpenOffice \nWriter, or iWork Pages) is that text editors have text only. You can’t set the font, size, or color of \nthe text. (IDLE automatically sets the color of the text based on what kind of Python code it is, \nbut you can’t change this yourself, so it is still a text editor.) The difference between text and \nbinary files isn’t important for this game program, but you can read about it at \n",
      "content_length": 2385,
      "extraction_method": "Direct"
    },
    {
      "page_number": 291,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    273 \n \nhttp://invpy.com/textbinary. All you need to know is the this chapter and the Star Pusher program \nonly deal with text files. \nWriting to Files \nTo create a file, call the open() function pass it two arguments: a string for the name of the file, \nand the string 'w' to tell the open() function you want to open the file in ―write‖ mode. The \nopen() function returns a file object: \n>>> textFile = open('hello.txt', 'w') \n>>> \nIf you run this code from the interactive shell, the hello.txt file that this function creates will be \ncreated in the same folder that the python.exe program is in (on Windows, this will probably be \nC:\\Python32). If the open() function is called from a .py program, the file is created in the same \nfolder that the .py file is in. \nThe ―write‖ mode tells open() to create the file if it does not exist. If it does exist, then \nopen() will delete that file and create a new, blank file. This is just like how an assignment \nstatement can create a new variable, or overwrite the current value in an already existing variable. \nThis can be somewhat dangerous. If you accidentally send a filename of an important file to the \nopen() function with 'w' as the second parameter, it will be deleted. This could result in \nhaving to reinstall the operating system on your computer and/or the launching of nuclear \nmissiles. \nThe file object has a method called write() which can be used to write text to the file. Just pass \nit a string like you would pass a string to the print() function. The difference is that write() \ndoes not automatically add a newline character ('\\n') to the end of the string. If you want to add \na newline, you will have to include it in the string: \n>>> textFile = open('hello.txt', 'w') \n>>> textFile.write('This will be the content of the file.\\nHello world!\\n') \n>>> \nTo tell Python that you are done writing content to this file, you should call the close() \nmethod of the file object. (Although Python will automatically close any opened file objects when \nthe program ends.) \n>>> textFile.close() \n",
      "content_length": 2085,
      "extraction_method": "Direct"
    },
    {
      "page_number": 292,
      "chapter": null,
      "content": "274    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nReading from Files \nTo read the content of a file, pass the string 'r' instead of 'w' to the open() function. Then \ncall the readlines() method on the file object to read in the contents of the file. Last, close \nthe file by calling the close() method. \n>>> textFile = open('hello.txt', 'r') \n>>> content = textFile.readlines() \n>>> textFile.close() \nThe readlines() method returns a list of strings: one string for each line of text in the file: \n>>> content \n['This will be the content of the file.\\n', 'Hello world!\\n'] \n>>> \nIf you want to re-read the contents of that file, you will have to call close() on the file object \nand re-open it. \nAs an alternative to readlines(), you can also call the read() method, which will return \nthe entire contents of the file as a single string value: \n>>> textFile = open('hello.txt', 'r') \n>>> content = textFile.read() \n>>> content \n'This will be the content of the file.\\nHello world!\\n' \nOn a side note, if you leave out the second parameter to the open() function, Python will \nassume you mean to open the file in read mode. So open('foobar.txt', 'r') and \nopen('foobar.txt') do the exact same thing. \nAbout the Star Pusher Map File Format \nWe need the level text file to be in a specific format. Which characters represent walls, or stars, or \nthe player’s starting position? If we have the maps for multiple levels, how can we tell when one \nlevel’s map ends and the next one begins? \nFortunately, the map file format we will use is already defined for us. There are many Sokoban \ngames out there (you can find more at http://invpy.com/sokobanclones), and they all use the same \nmap file format. If you download the levels file from http://invpy.com/starPusherLevels.txt and \nopen it in a text editor, you’ll see something like this: \n; Star Pusher (Sokoban clone) \n",
      "content_length": 1919,
      "extraction_method": "Direct"
    },
    {
      "page_number": 293,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    275 \n \n; http://inventwithpython.com/blog \n; By Al Sweigart al@inventwithpython.com \n; \n; Everything after the ; is a comment and will be ignored by the game that \n; reads in this file. \n; \n; The format is described at: \n; http://sokobano.de/wiki/index.php?title=Level_format \n;   @ - The starting position of the player. \n;   $ - The starting position for a pushable star. \n;   . - A goal where a star needs to be pushed. \n;   + - Player & goal \n;   * - Star & goal \n;  (space) - an empty open space. \n;   # - A wall. \n; \n; Level maps are separated by a blank line (I like to use a ; at the start \n; of the line since it is more visible.) \n; \n; I tried to use the same format as other people use for their Sokoban games, \n; so that loading new levels is easy. Just place the levels in a text file \n; and name it \"starPusherLevels.txt\" (after renaming this file, of course). \n \n \n; Starting demo level: \n ######## \n##      # \n#   .   # \n#   $   # \n# .$@$. # \n####$   # \n   #.   # \n   #   ## \n   ##### \nThe comments at the top of the file explain the file’s format. When you load the first level, it \nlooks like this: \n",
      "content_length": 1145,
      "extraction_method": "Direct"
    },
    {
      "page_number": 294,
      "chapter": null,
      "content": "276    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n426. def readLevelsFile(filename): \n427.     assert os.path.exists(filename), 'Cannot find the level file: %s' % \n(filename) \nThe os.path.exists() function will return True if the file specified by the string passed to \nthe function exists. If it does not exist, os.path.exists() returns False. \n428.     mapFile = open(filename, 'r') \n429.     # Each level must end with a blank line \n430.     content = mapFile.readlines() + ['\\r\\n'] \n431.     mapFile.close() \n432. \n433.     levels = [] # Will contain a list of level objects. \n434.     levelNum = 0 \n435.     mapTextLines = [] # contains the lines for a single level's map. \n436.     mapObj = [] # the map object made from the data in mapTextLines \nThe file object for the level file that is opened for reading is stored in mapFile. All of the text \nfrom the level file is stored as a list of strings in the content variable, with a blank line added \nto the end. (The reason that this is done is explained later.) \nAfter the level objects are created, they will be stored in the levels list. The levelNum \nvariable will keep track of how many levels are found inside the level file. The mapTextLines \nlist will be a list of strings from the content list for a single map (as opposed to how content \nstores the strings of all maps in the level file). The mapObj variable will be a 2D list. \n437.     for lineNum in range(len(content)): \n438.         # Process each line that was in the level file. \n439.         line = content[lineNum].rstrip('\\r\\n') \n",
      "content_length": 1610,
      "extraction_method": "Direct"
    },
    {
      "page_number": 295,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    277 \n \nThe for loop on line 437 will go through each line that was read from the level file one line at a \ntime. The line number will be stored in lineNum and the string of text for the line will be stored \nin line. Any newline characters at the end of the string will be stripped off. \n441.         if ';' in line: \n442.             # Ignore the ; lines, they're comments in the level file. \n443.             line = line[:line.find(';')] \nAny text that exists after a semicolon in the map file is treated like a comment and is ignored. \nThis is just like the # sign for Python comments. To make sure that our code does not \naccidentally think the comment is part of the map, the line variable is modified so that it only \nconsists of the text up to (but not including) the semicolon character. (Remember that this is only \nchanging the string in the content list. It is not changing the level file on the hard drive.) \n445.         if line != '': \n446.             # This line is part of the map. \n447.             mapTextLines.append(line) \nThere can be maps for multiple levels in the map file. The mapTextLines list will contain the \nlines of text from the map file for the current level being loaded. As long as the current line is not \nblank, the line will be appended to the end of mapTextLines. \n448.         elif line == '' and len(mapTextLines) > 0: \n449.             # A blank line indicates the end of a level's map in the file. \n450.             # Convert the text in mapTextLines into a level object. \nWhen there is a blank line in the map file, that indicates that the map for the current level has \nended. And future lines of text will be for the later levels. Note however, that there must at least \nbe one line in mapTextLines so that multiple blank lines together are not counted as the start \nand stop to multiple levels. \n452.             # Find the longest row in the map. \n453.             maxWidth = -1 \n454.             for i in range(len(mapTextLines)): \n455.                 if len(mapTextLines[i]) > maxWidth: \n456.                     maxWidth = len(mapTextLines[i]) \nAll of the strings in mapTextLines need to be the same length (so that they form a rectangle), \nso they should be padded with extra blank spaces until they are all as long as the longest string. \nThe for loop goes through each of the strings in mapTextLines and updates maxWidth \n",
      "content_length": 2404,
      "extraction_method": "Direct"
    },
    {
      "page_number": 296,
      "chapter": null,
      "content": "278    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nwhen it finds a new longest string. After this loop finishes executing, the maxWidth variable \nwill be set to the length of the longest string in mapTextLines. \n457.             # Add spaces to the ends of the shorter rows. This \n458.             # ensures the map will be rectangular. \n459.             for i in range(len(mapTextLines)): \n460.                 mapTextLines[i] += ' ' * (maxWidth - len(mapTextLines[i])) \nThe for loop on line 459 goes through the strings in mapTextLines again, this time to add \nenough space characters to pad each to be as long as maxWidth. \n462.             # Convert mapTextLines to a map object. \n463.             for x in range(len(mapTextLines[0])): \n464.                 mapObj.append([]) \n465.             for y in range(len(mapTextLines)): \n466.                 for x in range(maxWidth): \n467.                     mapObj[x].append(mapTextLines[y][x]) \nThe mapTextLines variable just stores a list of strings. (Each string in the list represents a \nrow, and each character in the string represents a character at a different column. This is why line \n467 has the Y and X indexes reversed, just like the SHAPES data structure in the Tetromino \ngame.) But the map object will have to be a list of list of single-character strings such that \nmapObj[x][y] refers to the tile at the XY coordinates. The for loop on line 463 adds an \nempty list to mapObj for each column in mapTextLines. \nThe nested for loops on line 465 and 466 will fill these lists with single-character strings to \nrepresent each tile on the map. This creates the map object that Star Pusher uses. \n469.             # Loop through the spaces in the map and find the @, ., and $ \n470.             # characters for the starting game state. \n471.             startx = None # The x and y for the player's starting position \n472.             starty = None \n473.             goals = [] # list of (x, y) tuples for each goal. \n474.             stars = [] # list of (x, y) for each star's starting position. \n475.             for x in range(maxWidth): \n476.                 for y in range(len(mapObj[x])): \n477.                     if mapObj[x][y] in ('@', '+'): \n478.                         # '@' is player, '+' is player & goal \n479.                         startx = x \n480.                         starty = y \n481.                     if mapObj[x][y] in ('.', '+', '*'): \n482.                         # '.' is goal, '*' is star & goal \n483.                         goals.append((x, y)) \n",
      "content_length": 2592,
      "extraction_method": "Direct"
    },
    {
      "page_number": 297,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    279 \n \n484.                     if mapObj[x][y] in ('$', '*'): \n485.                         # '$' is star \n486.                         stars.append((x, y)) \nAfter creating the map object, the nested for loops on lines 475 and 476 will go through each \nspace to find the XY coordinates three things: \n1. The player’s starting position. This will be stored in the startx and starty variables, \nwhich will then be stored in the game state object later on line 494. \n2. The starting position of all the stars These will be stored in the stars list, which is later \nstored in the game state object on line 496. \n3. The position of all the goals. These will be stored in the goals list, which is later stored \nin the level object on line 500. \nRemember, the game state object contains all the things that can change. This is why the player’s \nposition is stored in it (because the player can move around) and why the stars are stored in it \n(because the stars can be pushed around by the player). But the goals are stored in the level \nobject, since they will never move around. \n488.             # Basic level design sanity checks: \n489.             assert startx != None and starty != None, 'Level %s (around \nline %s) in %s is missing a \"@\" or \"+\" to mark the start point.' % (levelNum+1, \nlineNum, filename) \n490.             assert len(goals) > 0, 'Level %s (around line %s) in %s must \nhave at least one goal.' % (levelNum+1, lineNum, filename) \n491.             assert len(stars) >= len(goals), 'Level %s (around line %s) in \n%s is impossible to solve. It has %s goals but only %s stars.' % (levelNum+1, \nlineNum, filename, len(goals), len(stars)) \nAt this point, the level has been read in and processed. To be sure that this level will work \nproperly, a few assertions must pass. If any of the conditions for these assertions are False, then \nPython will produce an error (using the string from the assert statement) saying what is wrong \nwith the level file. \nThe first assertion on line 489 checks to make sure that there is a player starting point listed \nsomewhere on the map. The second assertion on line 490 checks to make sure there is at least one \ngoal (or more) somewhere on the map. And the third assertion on line 491 checks to make sure \nthat there is at least one star for each goal (but having more stars than goals is allowed). \n493.             # Create level object and starting game state object. \n494.             gameStateObj = {'player': (startx, starty), \n495.                             'stepCounter': 0, \n",
      "content_length": 2563,
      "extraction_method": "Direct"
    },
    {
      "page_number": 298,
      "chapter": null,
      "content": "280    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n496.                             'stars': stars} \n497.             levelObj = {'width': maxWidth, \n498.                         'height': len(mapObj), \n499.                         'mapObj': mapObj, \n500.                         'goals': goals, \n501.                         'startState': gameStateObj} \n502. \n503.             levels.append(levelObj) \nFinally, these objects are stored in the game state object, which itself is stored in the level object. \nThe level object is added to a list of level objects on line 503. It is this levels list that will be \nreturned by the readLevelsFile() function when all of the maps have been processed. \n505.             # Reset the variables for reading the next map. \n506.             mapTextLines = [] \n507.             mapObj = [] \n508.             gameStateObj = {} \n509.             levelNum += 1 \n510.     return levels \nNow that this level is done processing, the variables for mapTextLines, mapObj, and \ngameStateObj should be reset to blank values for the next level that will be read in from the \nlevel file. The levelNum variable is also incremented by 1 for the next level’s level number. \nRecursive Functions \nBefore you can learn how the floodFill() function works, you need to learn about recursion. \nRecursion is a simple concept: A recursive function is just a function that calls itself, like the \none in the following program: (don’t type the letters at the beginning of each line though) \nA. def passFortyTwoWhenYouCallThisFunction(param): \nB.     print('Start of function.') \nC.     if param != 42: \nD.         print('You did not pass 42 when you called this function.') \nE.         print('Fine. I will do it myself.') \nF.         passFortyTwoWhenYouCallThisFunction(42) # this is the recursive call \nG.     if param == 42: \nH.         print('Thank you for passing 42 when you called this function.') \nI.     print('End of function.') \nJ.  \nK. passFortyTwoWhenYouCallThisFunction(41) \n(In your own programs, don’t make functions have names as long as \npassFortyTwoWhenYouCallThisFunction(). I’m just being stupid and silly. Stupilly.) \n",
      "content_length": 2202,
      "extraction_method": "Direct"
    },
    {
      "page_number": 299,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    281 \n \nWhen you run this program, the function gets defined when the def statement on line A \nexecutes. The next line of code that is executed is line K, which calls \npassFortyTwoWhenYouCallThisFunction() and passes (gasp!) 41. As a result, the \nfunction calls itself on line F and passes 42. We call this call the recursive call. \nThis is what our program outputs: \nStart of function. \nYou did not pass 42 when you called this function. \nFine. I will do it myself. \nStart of function. \nThank you for passing 42 when you called this function. \nEnd of function. \nEnd of function. \nNotice that the ―Start of function.‖ and ―End of function.‖ text appears twice. Let’s figure out \nwhat exactly happens and what order it happens in. \nOn line K, the function is called and 41 is passed for the param parameter. Line B prints out \n―Start of function.‖. The condition on line C will be True (since 41 != 42) so Line C and D \nwill print out their messages. Line F will then make a call, recursively, to the function and passes \n42 for the param parameter. So execution starts on line B again and prints out ―Start of \nfunction.‖. Line C’s condition this time is False, so it skips to line G and finds that condition to \nbe True. This causes line H to be called and displays ―Thank you…‖ on the screen. Then the last \nline of the function, line I, will execute to print out ―End of function.‖ and the function returns to \nthe line that called it. \nBut remember, the line of code that called the function was line F. And in this original call, param \nwas set to 41. The code goes down to line G and checks the condition, which is False (since 41 \n== 42 is False) so it skips the print() call on line H. Instead, it runs the print() call on \nline I which makes ―End of function.‖ display for a second time. \nSince it has reached the end of the function, it returns to the line of code that called this function \ncall, which was line K. There are no more lines of code after line K, so the program terminates.  \nNote that local variables are not just local to the function, but to a specific call of the function. \nStack Overflows \nEach time a function is called, the Python interpreter remembers which line of code made the call. \nThat way when the function returns Python knows where to resume the execution. Remembering \nthis takes up a tiny bit of memory. This isn’t normally a big deal, but take a look at this code: \n",
      "content_length": 2438,
      "extraction_method": "Direct"
    },
    {
      "page_number": 300,
      "chapter": null,
      "content": "282    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \ndef funky(): \n    funky() \n \nfunky() \nIf you run this program, you’ll get a large amount of output which looks like this: \n... \n  File \"C:\\test67.py\", line 2, in funky \n    funky() \n  File \"C:\\test67.py\", line 2, in funky \n    funky() \n  File \"C:\\test67.py\", line 2, in funky \n    funky() \n  File \"C:\\test67.py\", line 2, in funky \n    funky() \n  File \"C:\\test67.py\", line 2, in funky \n    funky() \nRuntimeError: maximum recursion depth exceeded \nThe funky() function does nothing but call itself. And then in that call, the function calls itself \nagain. Then it calls itself again, and again, and again. Each time it calls itself, Python has to \nremember what line of code made that call so that when the function returns it can resume the \nexecution there. But the funky() function never returns, it just keeps making calls to itself. \nThis is just like the infinite loop bug, where the program keeps going and never stops. To prevent \nitself from running out of memory, Python will cause an error after you are a 1000 calls deep and \ncrash the program. This type of bug is called a stack overflow. \nThis code also causes a stack overflow, even though there are no recursive functions: \ndef spam(): \n    eggs() \n \ndef eggs(): \n    spam() \n \nspam() \nWhen you run this program, it causes an error that looks like this: \n... \n  File \"C:\\test67.py\", line 2, in spam \n    eggs() \n",
      "content_length": 1479,
      "extraction_method": "Direct"
    },
    {
      "page_number": 301,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    283 \n \n  File \"C:\\test67.py\", line 5, in eggs \n    spam() \n  File \"C:\\test67.py\", line 2, in spam \n    eggs() \n  File \"C:\\test67.py\", line 5, in eggs \n    spam() \n  File \"C:\\test67.py\", line 2, in spam \n    eggs() \nRuntimeError: maximum recursion depth exceeded \nPreventing Stack Overflows with a Base Case \nIn order to prevent stack overflow bugs, you must have a base case where the function stops \nmake new recursive calls. If there is no base case then the function calls will never stop and \neventually a stack overflow will occur. Here is an example of a recursive function with a base \ncase. The base case is when the param parameter equals 2. \ndef fizz(param): \n    print(param) \n    if param == 2: \n        return \n    fizz(param - 1) \n \nfizz(5) \nWhen you run this program, the output will look like this: \n5 \n4 \n3 \n2 \nThis program does not have a stack overflow error because once the param parameter is set to 2, \nthe if statement’s condition will be True and the function will return, and then the rest of the \ncalls will also return in turn. \nThough if your code never reaches the base case, then this will cause a stack overflow. If we \nchanged the fizz(5) call to fizz(0), then the program’s output would look like this: \n  File \"C:\\rectest.py\", line 5, in fizz \n    fizz(param - 1) \n  File \"C:\\rectest.py\", line 5, in fizz \n    fizz(param - 1) \n  File \"C:\\rectest.py\", line 5, in fizz \n",
      "content_length": 1429,
      "extraction_method": "Direct"
    },
    {
      "page_number": 302,
      "chapter": null,
      "content": "284    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n    fizz(param - 1) \n  File \"C:\\rectest.py\", line 2, in fizz \n    print(param) \nRuntimeError: maximum recursion depth exceeded \nRecursive calls and base cases will be used to perform the flood fill algorithm, which is described \nnext. \nThe Flood Fill Algorithm \nThe flood fill algorithm is used in Star Pusher to change all of the floor tiles inside the walls of \nthe level to use the ―inside floor‖ tile image instead of the ―outside floor‖ tile (which all the tiles \non the map are by default). The original floodFill() call is on line 295. It will convert any \ntiles represented with the ' ' string (which represents an outdoor floor) to a 'o' string (which \nrepresents an indoor floor). \n513. def floodFill(mapObj, x, y, oldCharacter, newCharacter): \n514.     \"\"\"Changes any values matching oldCharacter on the map object to \n515.     newCharacter at the (x, y) position, and does the same for the \n516.     positions to the left, right, down, and up of (x, y), recursively.\"\"\" \n517.  \n518.     # In this game, the flood fill algorithm creates the inside/outside \n519.     # floor distinction. This is a \"recursive\" function. \n520.     # For more info on the Flood Fill algorithm, see: \n521.     #   http://en.wikipedia.org/wiki/Flood_fill \n522.     if mapObj[x][y] == oldCharacter: \n523.         mapObj[x][y] = newCharacter \nLine 522 and 523 converts the tile at the XY coordinate passed to floodFill() to the \nnewCharacter string if it originally was the same as the oldCharacter string. \n525.     if x < len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter: \n526.         floodFill(mapObj, x+1, y, oldCharacter, newCharacter) # call right \n527.     if x > 0 and mapObj[x-1][y] == oldCharacter: \n528.         floodFill(mapObj, x-1, y, oldCharacter, newCharacter) # call left \n529.     if y < len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter: \n530.         floodFill(mapObj, x, y+1, oldCharacter, newCharacter) # call down \n531.     if y > 0 and mapObj[x][y-1] == oldCharacter: \n532.         floodFill(mapObj, x, y-1, oldCharacter, newCharacter) # call up \nThese four if statements check if the tile to the right, left, down, and up of the XY coordinate are \nthe same as oldCharacter, and if so, a recursive call is made to floodFill() with those \ncoordinates. \n",
      "content_length": 2373,
      "extraction_method": "Direct"
    },
    {
      "page_number": 303,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    285 \n \nTo better understand how the floodFill() function works, here is a version that does not use \nrecursive calls, but instead uses a list of XY coordinates to keep track of which spaces on the map \nshould be checked and possibly changed to newCharacter. \ndef floodFill(mapObj, x, y, oldCharacter, newCharacter): \n    spacesToCheck = [] \n    if mapObj[x][y] == oldCharacter: \n        spacesToCheck.append((x, y)) \n    while spacesToCheck != []: \n        x, y = spacesToCheck.pop() \n        mapObj[x][y] = newCharacter \n \n        if x < len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter: \n            spacesToCheck.append((x+1, y)) # check right \n        if x > 0 and mapObj[x-1][y] == oldCharacter: \n            spacesToCheck.append((x-1, y)) # check left \n        if y < len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter: \n            spacesToCheck.append((x, y+1)) # check down \n        if y > 0 and mapObj[x][y-1] == oldCharacter: \n            spacesToCheck.append((x, y-1)) # check up \nIf you would like to read a more detailed tutorial on recursion that uses cats and zombies for an \nexample, go to http://invpy.com/recursivezombies. \nDrawing the Map \n535. def drawMap(mapObj, gameStateObj, goals): \n536.     \"\"\"Draws the map to a Surface object, including the player and \n537.     stars. This function does not call pygame.display.update(), nor \n538.     does it draw the \"Level\" and \"Steps\" text in the corner.\"\"\" \n539.  \n540.     # mapSurf will be the single Surface object that the tiles are drawn \n541.     # on, so that it is easy to position the entire map on the DISPLAYSURF \n542.     # Surface object. First, the width and height must be calculated. \n543.     mapSurfWidth = len(mapObj) * TILEWIDTH \n544.     mapSurfHeight = (len(mapObj[0]) - 1) * (TILEHEIGHT - TILEFLOORHEIGHT) \n+ TILEHEIGHT \n545.     mapSurf = pygame.Surface((mapSurfWidth, mapSurfHeight)) \n546.     mapSurf.fill(BGCOLOR) # start with a blank color on the surface. \nThe drawMap() function will return a Surface object with the entire map (and the player and \nstars) drawn on it. The width and height needed for this Surface have to be calculated from \nmapObj (which is done on line 543 and 544). The Surface object that everything will be drawn \n",
      "content_length": 2264,
      "extraction_method": "Direct"
    },
    {
      "page_number": 304,
      "chapter": null,
      "content": "286    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \non is created on line 545. To begin with, the entire Surface object is painted to the background \ncolor on line 546. \n548.     # Draw the tile sprites onto this surface. \n549.     for x in range(len(mapObj)): \n550.         for y in range(len(mapObj[x])): \n551.             spaceRect = pygame.Rect((x * TILEWIDTH, y * (TILEHEIGHT - \nTILEFLOORHEIGHT), TILEWIDTH, TILEHEIGHT)) \nThe set of nested for loops on line 549 and 550 will go through every possible XY coordinate \non the map and draw the appropriate tile image at that location. \n552.             if mapObj[x][y] in TILEMAPPING: \n553.                 baseTile = TILEMAPPING[mapObj[x][y]] \n554.             elif mapObj[x][y] in OUTSIDEDECOMAPPING: \n555.                 baseTile = TILEMAPPING[' '] \n556.  \n557.             # First draw the base ground/wall tile. \n558.             mapSurf.blit(baseTile, spaceRect) \n559.  \nThe baseTile variable is set to the Surface object of the tile image to be drawn at the \niteration’s current XY coordinate. If the single-character string is in the \nOUTSIDEDECOMAPPING dictionary, then TILEMAPPING[' '] (the single-character string \nfor the basic outdoor floor tile) will be used. \n560.             if mapObj[x][y] in OUTSIDEDECOMAPPING: \n561.                 # Draw any tree/rock decorations that are on this tile. \n562.                 mapSurf.blit(OUTSIDEDECOMAPPING[mapObj[x][y]], spaceRect) \nAdditionally, if the tile was listed in the OUTSIDEDECOMAPPING dictionary, the corresponding \ntree or rock image should be drawn on top of the tile that was just drawn at that XY coordinate. \n563.             elif (x, y) in gameStateObj['stars']: \n564.                 if (x, y) in goals: \n565.                     # A goal AND star are on this space, draw goal first. \n566.                     mapSurf.blit(IMAGESDICT['covered goal'], spaceRect) \n567.                 # Then draw the star sprite. \n568.                 mapSurf.blit(IMAGESDICT['star'], spaceRect) \nIf there is a star located at this XY coordinate on the map (which can be found out by checking \nfor (x, y) in the list at gameStateObj['stars']), then a star should be drawn at this XY \n",
      "content_length": 2245,
      "extraction_method": "Direct"
    },
    {
      "page_number": 305,
      "chapter": null,
      "content": "Chapter 9 – Star Pusher    287 \n \ncoordinate (which is done on line 568). Before the star is drawn, the code should first check if \nthere is also a goal at this location, in which case, the ―covered goal‖ tile should be drawn first. \n569.             elif (x, y) in goals: \n570.                 # Draw a goal without a star on it. \n571.                 mapSurf.blit(IMAGESDICT['uncovered goal'], spaceRect) \nIf there is a goal at this XY coordinate on the map, then the ―uncovered goal‖ should be drawn on \ntop of the tile. The uncovered goal is drawn because if execution has reached the elif statement \non line 569, we know that the elif statement’s condition on line 563 was False and there is no \nstar that is also at this XY coordinate. \n573.             # Last draw the player on the board. \n574.             if (x, y) == gameStateObj['player']: \n575.                 # Note: The value \"currentImage\" refers \n576.                 # to a key in \"PLAYERIMAGES\" which has the \n577.                 # specific player image we want to show. \n578.                 mapSurf.blit(PLAYERIMAGES[currentImage], spaceRect) \n579.  \n580.     return mapSurf \nFinally, the drawMap() function checks if the player is located at this XY coordinate, and if so, \nthe player’s image is drawn over the tile. Line 580 is outside of the nested for loops that began \non line 549 and 550, so by the time the Surface object is returned, the entire map has been drawn \non it. \nChecking if the Level is Finished \n583. def isLevelFinished(levelObj, gameStateObj): \n584.     \"\"\"Returns True if all the goals have stars in them.\"\"\" \n585.     for goal in levelObj['goals']: \n586.         if goal not in gameStateObj['stars']: \n587.             # Found a space with a goal but no star on it. \n588.             return False \n589.     return True \nThe isLevelFinished() function returns True if all the goals are covered stars. Some \nlevels could have more stars than goals, so it’s important to check that all the goals are covered \nby stars, rather than checking if all the stars are over goals. \nThe for loop on line 585 goes through the goals in levelObj['goals'] (which is a list of \ntuples of XY coordinates for each goal) and checks if there is a star in the \ngameStateObj['stars'] list that has those same XY coordinates (the not in operators \n",
      "content_length": 2321,
      "extraction_method": "Direct"
    },
    {
      "page_number": 306,
      "chapter": null,
      "content": "288    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nwork here because gameStateObj['stars'] is a list of those same tuples of XY \ncoordinates). The first time the code finds a goal with no star at the same position, the function \nreturns False. \nIf it gets through all of the goals and finds a star on each of them, isLevelFinished() \nreturns True. \n592. def terminate(): \n593.     pygame.quit() \n594.     sys.exit() \nThis terminate() function is the same as in all the previous programs. \n597. if __name__ == '__main__': \n598.     main() \nAfter all the functions have been defined, the main() function is called on line 602 to begin the \ngame. \nSummary \nIn the Squirrel Eat Squirrel game, the game world was pretty simple: just an infinite green plain \nwith grass images randomly scattered around it. The Star Pusher game introduced something \nnew: having uniquely designed levels with tile graphics. In order to store these levels in a format \nthat the computer can read, they are typed out into a text file and code in the program reads those \nfiles and creates the data structures for the level. \nReally, rather than just make a simple game with a single map, the Star Pusher program is more \nof a system for loading custom maps based on the level file. Just by modifying the level file, we \ncan change where walls, stars, and goals appear in the game world. The Star Pusher program can \nhandle any configuration that the level file is set to (as long as it passes the assert statements \nthat ensure the map makes sense). \nYou won’t even have to know how to program Python to make your own levels. A text editor \nprogram that modifies the starPusherLevels.txt file is all that anyone needs to have their own \nlevel editor for the Star Pusher game. \nFor additional programming practice, you can download buggy versions of Star Pusher from \nhttp://invpy.com/buggy/starpusher and try to figure out how to fix the bugs. \n \n",
      "content_length": 1974,
      "extraction_method": "Direct"
    },
    {
      "page_number": 307,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    289 \n \nCHAPTER 10 – FOUR EXTRA \nGAMES \nIncluded in this chapter is the source code for four extra games. Unfortunately, only the source \ncode (including comments) is in this chapter without any detailed explanation of the code. By \nnow, you can play these games and figure out how the code works by looking at the source code \nand comments. \nThe games are: \n \nFlippy – An ―Othello‖ clone where the player tries to flip the computer AI player’s tiles. \n \nInk Spill – A ―Flood It‖ clone that makes use of the flood fill algorithm. \n \nFour in a Row – A ―Connect Four‖ clone against the computer AI player. \n \nGemgem – A ―Bejeweled‖ clone where the player swaps gems to try to get three \nidentical gems in a row. \nIf you have any questions about the source code in this book, feel free to email the author at \nal@inventwithpython.com. \nBuggy versions of these programs are also available if you want to practice fixing bugs: \n \nhttp://invpy.com/buggy/flippy \n \nhttp://invpy.com/buggy/inkspill \n \nhttp://invpy.com/buggy/fourinarow \n \nhttp://invpy.com/buggy/gemgem \n \n \n",
      "content_length": 1105,
      "extraction_method": "Direct"
    },
    {
      "page_number": 308,
      "chapter": null,
      "content": "290    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nFlippy, an “Othello” Clone \n     \n \nOthello, also known by the generic name Reversi, has an 8 x 8 board with tiles that are black on \none side and white on the other. The starting board looks like Figure 10-1. Each player takes turn \nplacing down a new tile of their color. Any of the opponent's tiles that are between the new tile \nand the other tiles of that color is flipped. The goal of the game is to have as many of the tiles \nwith your color as possible. For example, Figure 10-2 is what it looks like if the white player \nplaces a new white tile on space 5, 6. \n \n \nThe starting Reversi board has two white tiles \nand two black tiles. \nWhite places a new tile. \n \n",
      "content_length": 775,
      "extraction_method": "Direct"
    },
    {
      "page_number": 309,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    291 \n \nThe black tile at 5, 5 is in between the new white tile and the existing white tile at 5, 4. That black \ntile is flipped over and becomes a new white tile, making the board look like Figure 10-3. Black \nmakes a similar move next, placing a black tile on 4, 6 which flips the white tile at 4, 5. This \nresults in a board that looks like Figure 10-4. \n \n \nWhite's move will flip over one of black's tiles. \nBlack places a new tile, which flips over one of \nwhite's tiles. \n \nTiles in all directions are flipped as long as they are in between the player's new tile and existing \ntile. In Figure 10-5, the white player places a tile at 3, 6 and flips black tiles in both directions \n(marked by the lines). The result is in Figure 10-6. \n",
      "content_length": 773,
      "extraction_method": "Direct"
    },
    {
      "page_number": 310,
      "chapter": null,
      "content": "292    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n \nWhite's second move at 3, 6 will flip two of \nblack's tiles. \nThe board after white's second move. \n \nAs you can see, each player can quickly grab a majority of the tiles on the board in just one or \ntwo moves. Players must always make a move that captures at least one tile. The game ends when \na player either cannot make a move, or the board is completely full. The player with the most tiles \nof their color wins. \nYou can learn more about Reversi from Wikipedia: http://en.wikipedia.org/wiki/Reversi \nA text version of this game that uses print() and input() instead of Pygame is featured in \nChapter 15 of ―Invent Your Own Computer Games with Python‖. You can read that chapter for \ndetails about how the computer AI’s algorithm was put together. \nhttp://inventwithpython.com/chapter15.html \nThe computer AI for this game is pretty good, because it is easy for a computer to simulate every \npossible move and take the one that flips over the most tiles. It usually beats me whenever I play \nit. \nSource Code for Flippy \nThis source code can be downloaded from http://invpy.com/flippy.py. \nThe image files that Flippy uses can be downloaded from http://invpy.com/flippyimages.zip. \n  1. # Flippy (an Othello or Reversi clone) \n",
      "content_length": 1339,
      "extraction_method": "Direct"
    },
    {
      "page_number": 311,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    293 \n \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Released under a \"Simplified BSD\" license \n  5.  \n  6. # Based on the \"reversi.py\" code that originally appeared in \"Invent \n  7. # Your Own Computer Games with Python\", chapter 15: \n  8. #   http://inventwithpython.com/chapter15.html \n  9.  \n 10. import random, sys, pygame, time, copy \n 11. from pygame.locals import * \n 12.  \n 13. FPS = 10 # frames per second to update the screen \n 14. WINDOWWIDTH = 640 # width of the program's window, in pixels \n 15. WINDOWHEIGHT = 480 # height in pixels \n 16. SPACESIZE = 50 # width & height of each space on the board, in pixels \n 17. BOARDWIDTH = 8 # how many columns of spaces on the game board \n 18. BOARDHEIGHT = 8 # how many rows of spaces on the game board \n 19. WHITE_TILE = 'WHITE_TILE' # an arbitrary but unique value \n 20. BLACK_TILE = 'BLACK_TILE' # an arbitrary but unique value \n 21. EMPTY_SPACE = 'EMPTY_SPACE' # an arbitrary but unique value \n 22. HINT_TILE = 'HINT_TILE' # an arbitrary but unique value \n 23. ANIMATIONSPEED = 25 # integer from 1 to 100, higher is faster animation \n 24.  \n 25. # Amount of space on the left & right side (XMARGIN) or above and below \n 26. # (YMARGIN) the game board, in pixels. \n 27. XMARGIN = int((WINDOWWIDTH - (BOARDWIDTH * SPACESIZE)) / 2) \n 28. YMARGIN = int((WINDOWHEIGHT - (BOARDHEIGHT * SPACESIZE)) / 2) \n 29.  \n 30. #              R    G    B \n 31. WHITE      = (255, 255, 255) \n 32. BLACK      = (  0,   0,   0) \n 33. GREEN      = (  0, 155,   0) \n 34. BRIGHTBLUE = (  0,  50, 255) \n 35. BROWN      = (174,  94,   0) \n 36.  \n 37. TEXTBGCOLOR1 = BRIGHTBLUE \n 38. TEXTBGCOLOR2 = GREEN \n 39. GRIDLINECOLOR = BLACK \n 40. TEXTCOLOR = WHITE \n 41. HINTCOLOR = BROWN \n 42.  \n 43.  \n 44. def main(): \n 45.     global MAINCLOCK, DISPLAYSURF, FONT, BIGFONT, BGIMAGE \n 46.  \n 47.     pygame.init() \n",
      "content_length": 1925,
      "extraction_method": "Direct"
    },
    {
      "page_number": 312,
      "chapter": null,
      "content": "294    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 48.     MAINCLOCK = pygame.time.Clock() \n 49.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 50.     pygame.display.set_caption('Flippy') \n 51.     FONT = pygame.font.Font('freesansbold.ttf', 16) \n 52.     BIGFONT = pygame.font.Font('freesansbold.ttf', 32) \n 53.  \n 54.     # Set up the background image. \n 55.     boardImage = pygame.image.load('flippyboard.png') \n 56.     # Use smoothscale() to stretch the board image to fit the entire \nboard: \n 57.     boardImage = pygame.transform.smoothscale(boardImage, (BOARDWIDTH * \nSPACESIZE, BOARDHEIGHT * SPACESIZE)) \n 58.     boardImageRect = boardImage.get_rect() \n 59.     boardImageRect.topleft = (XMARGIN, YMARGIN) \n 60.     BGIMAGE = pygame.image.load('flippybackground.png') \n 61.     # Use smoothscale() to stretch the background image to fit the entire \nwindow: \n 62.     BGIMAGE = pygame.transform.smoothscale(BGIMAGE, (WINDOWWIDTH, \nWINDOWHEIGHT)) \n 63.     BGIMAGE.blit(boardImage, boardImageRect) \n 64.  \n 65.     # Run the main game. \n 66.     while True: \n 67.         if runGame() == False: \n 68.             break \n 69.  \n 70.  \n 71. def runGame(): \n 72.     # Plays a single game of reversi each time this function is called. \n 73.  \n 74.     # Reset the board and game. \n 75.     mainBoard = getNewBoard() \n 76.     resetBoard(mainBoard) \n 77.     showHints = False \n 78.     turn = random.choice(['computer', 'player']) \n 79.  \n 80.     # Draw the starting board and ask the player what color they want. \n 81.     drawBoard(mainBoard) \n 82.     playerTile, computerTile = enterPlayerTile() \n 83.  \n 84.     # Make the Surface and Rect objects for the \"New Game\" and \"Hints\" \nbuttons \n 85.     newGameSurf = FONT.render('New Game', True, TEXTCOLOR, TEXTBGCOLOR2) \n 86.     newGameRect = newGameSurf.get_rect() \n 87.     newGameRect.topright = (WINDOWWIDTH - 8, 10) \n 88.     hintsSurf = FONT.render('Hints', True, TEXTCOLOR, TEXTBGCOLOR2) \n",
      "content_length": 2036,
      "extraction_method": "Direct"
    },
    {
      "page_number": 313,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    295 \n \n 89.     hintsRect = hintsSurf.get_rect() \n 90.     hintsRect.topright = (WINDOWWIDTH - 8, 40) \n 91.  \n 92.     while True: # main game loop \n 93.         # Keep looping for player and computer's turns. \n 94.         if turn == 'player': \n 95.             # Player's turn: \n 96.             if getValidMoves(mainBoard, playerTile) == []: \n 97.                 # If it's the player's turn but they \n 98.                 # can't move, then end the game. \n 99.                 break \n100.             movexy = None \n101.             while movexy == None: \n102.                 # Keep looping until the player clicks on a valid space. \n103.  \n104.                 # Determine which board data structure to use for display. \n105.                 if showHints: \n106.                     boardToDraw = getBoardWithValidMoves(mainBoard, \nplayerTile) \n107.                 else: \n108.                     boardToDraw = mainBoard \n109.  \n110.                 checkForQuit() \n111.                 for event in pygame.event.get(): # event handling loop \n112.                     if event.type == MOUSEBUTTONUP: \n113.                         # Handle mouse click events \n114.                         mousex, mousey = event.pos \n115.                         if newGameRect.collidepoint( (mousex, mousey) ): \n116.                             # Start a new game \n117.                             return True \n118.                         elif hintsRect.collidepoint( (mousex, mousey) ): \n119.                             # Toggle hints mode \n120.                             showHints = not showHints \n121.                         # movexy is set to a two-item tuple XY coordinate, \nor None value \n122.                         movexy = getSpaceClicked(mousex, mousey) \n123.                         if movexy != None and not isValidMove(mainBoard, \nplayerTile, movexy[0], movexy[1]): \n124.                             movexy = None \n125.  \n126.                 # Draw the game board. \n127.                 drawBoard(boardToDraw) \n128.                 drawInfo(boardToDraw, playerTile, computerTile, turn) \n129.  \n130.                 # Draw the \"New Game\" and \"Hints\" buttons. \n131.                 DISPLAYSURF.blit(newGameSurf, newGameRect) \n",
      "content_length": 2266,
      "extraction_method": "Direct"
    },
    {
      "page_number": 314,
      "chapter": null,
      "content": "296    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n132.                 DISPLAYSURF.blit(hintsSurf, hintsRect) \n133.  \n134.                 MAINCLOCK.tick(FPS) \n135.                 pygame.display.update() \n136.  \n137.             # Make the move and end the turn. \n138.             makeMove(mainBoard, playerTile, movexy[0], movexy[1], True) \n139.             if getValidMoves(mainBoard, computerTile) != []: \n140.                 # Only set for the computer's turn if it can make a move. \n141.                 turn = 'computer' \n142.  \n143.         else: \n144.             # Computer's turn: \n145.             if getValidMoves(mainBoard, computerTile) == []: \n146.                 # If it was set to be the computer's turn but \n147.                 # they can't move, then end the game. \n148.                 break \n149.  \n150.             # Draw the board. \n151.             drawBoard(mainBoard) \n152.             drawInfo(mainBoard, playerTile, computerTile, turn) \n153.  \n154.             # Draw the \"New Game\" and \"Hints\" buttons. \n155.             DISPLAYSURF.blit(newGameSurf, newGameRect) \n156.             DISPLAYSURF.blit(hintsSurf, hintsRect) \n157.  \n158.             # Make it look like the computer is thinking by pausing a bit. \n159.             pauseUntil = time.time() + random.randint(5, 15) * 0.1 \n160.             while time.time() < pauseUntil: \n161.                 pygame.display.update() \n162.  \n163.             # Make the move and end the turn. \n164.             x, y = getComputerMove(mainBoard, computerTile) \n165.             makeMove(mainBoard, computerTile, x, y, True) \n166.             if getValidMoves(mainBoard, playerTile) != []: \n167.                 # Only set for the player's turn if they can make a move. \n168.                 turn = 'player' \n169.  \n170.     # Display the final score. \n171.     drawBoard(mainBoard) \n172.     scores = getScoreOfBoard(mainBoard) \n173.  \n174.     # Determine the text of the message to display. \n175.     if scores[playerTile] > scores[computerTile]: \n176.         text = 'You beat the computer by %s points! Congratulations!' % \\ \n177.                (scores[playerTile] - scores[computerTile]) \n",
      "content_length": 2224,
      "extraction_method": "Direct"
    },
    {
      "page_number": 315,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    297 \n \n178.     elif scores[playerTile] < scores[computerTile]: \n179.         text = 'You lost. The computer beat you by %s points.' % \\ \n180.                (scores[computerTile] - scores[playerTile]) \n181.     else: \n182.         text = 'The game was a tie!' \n183.  \n184.     textSurf = FONT.render(text, True, TEXTCOLOR, TEXTBGCOLOR1) \n185.     textRect = textSurf.get_rect() \n186.     textRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2)) \n187.     DISPLAYSURF.blit(textSurf, textRect) \n188.  \n189.     # Display the \"Play again?\" text with Yes and No buttons. \n190.     text2Surf = BIGFONT.render('Play again?', True, TEXTCOLOR, \nTEXTBGCOLOR1) \n191.     text2Rect = text2Surf.get_rect() \n192.     text2Rect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2) + 50) \n193.  \n194.     # Make \"Yes\" button. \n195.     yesSurf = BIGFONT.render('Yes', True, TEXTCOLOR, TEXTBGCOLOR1) \n196.     yesRect = yesSurf.get_rect() \n197.     yesRect.center = (int(WINDOWWIDTH / 2) - 60, int(WINDOWHEIGHT / 2) + \n90) \n198.  \n199.     # Make \"No\" button. \n200.     noSurf = BIGFONT.render('No', True, TEXTCOLOR, TEXTBGCOLOR1) \n201.     noRect = noSurf.get_rect() \n202.     noRect.center = (int(WINDOWWIDTH / 2) + 60, int(WINDOWHEIGHT / 2) + \n90) \n203.  \n204.     while True: \n205.         # Process events until the user clicks on Yes or No. \n206.         checkForQuit() \n207.         for event in pygame.event.get(): # event handling loop \n208.             if event.type == MOUSEBUTTONUP: \n209.                 mousex, mousey = event.pos \n210.                 if yesRect.collidepoint( (mousex, mousey) ): \n211.                     return True \n212.                 elif noRect.collidepoint( (mousex, mousey) ): \n213.                     return False \n214.         DISPLAYSURF.blit(textSurf, textRect) \n215.         DISPLAYSURF.blit(text2Surf, text2Rect) \n216.         DISPLAYSURF.blit(yesSurf, yesRect) \n217.         DISPLAYSURF.blit(noSurf, noRect) \n218.         pygame.display.update() \n219.         MAINCLOCK.tick(FPS) \n220.  \n",
      "content_length": 2062,
      "extraction_method": "Direct"
    },
    {
      "page_number": 316,
      "chapter": null,
      "content": "298    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n221.  \n222. def translateBoardToPixelCoord(x, y): \n223.     return XMARGIN + x * SPACESIZE + int(SPACESIZE / 2), YMARGIN + y * \nSPACESIZE + int(SPACESIZE / 2) \n224.  \n225.  \n226. def animateTileChange(tilesToFlip, tileColor, additionalTile): \n227.     # Draw the additional tile that was just laid down. (Otherwise we'd \n228.     # have to completely redraw the board & the board info.) \n229.     if tileColor == WHITE_TILE: \n230.         additionalTileColor = WHITE \n231.     else: \n232.         additionalTileColor = BLACK \n233.     additionalTileX, additionalTileY = \ntranslateBoardToPixelCoord(additionalTile[0], additionalTile[1]) \n234.     pygame.draw.circle(DISPLAYSURF, additionalTileColor, (additionalTileX, \nadditionalTileY), int(SPACESIZE / 2) - 4) \n235.     pygame.display.update() \n236.  \n237.     for rgbValues in range(0, 255, int(ANIMATIONSPEED * 2.55)): \n238.         if rgbValues > 255: \n239.             rgbValues = 255 \n240.         elif rgbValues < 0: \n241.             rgbValues = 0 \n242.  \n243.         if tileColor == WHITE_TILE: \n244.             color = tuple([rgbValues] * 3) # rgbValues goes from 0 to 255 \n245.         elif tileColor == BLACK_TILE: \n246.             color = tuple([255 - rgbValues] * 3) # rgbValues goes from 255 \nto 0 \n247.  \n248.         for x, y in tilesToFlip: \n249.             centerx, centery = translateBoardToPixelCoord(x, y) \n250.             pygame.draw.circle(DISPLAYSURF, color, (centerx, centery), \nint(SPACESIZE / 2) - 4) \n251.         pygame.display.update() \n252.         MAINCLOCK.tick(FPS) \n253.         checkForQuit() \n254.  \n255.  \n256. def drawBoard(board): \n257.     # Draw background of board. \n258.     DISPLAYSURF.blit(BGIMAGE, BGIMAGE.get_rect()) \n259.  \n260.     # Draw grid lines of the board. \n261.     for x in range(BOARDWIDTH + 1): \n",
      "content_length": 1915,
      "extraction_method": "Direct"
    },
    {
      "page_number": 317,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    299 \n \n262.         # Draw the horizontal lines. \n263.         startx = (x * SPACESIZE) + XMARGIN \n264.         starty = YMARGIN \n265.         endx = (x * SPACESIZE) + XMARGIN \n266.         endy = YMARGIN + (BOARDHEIGHT * SPACESIZE) \n267.         pygame.draw.line(DISPLAYSURF, GRIDLINECOLOR, (startx, starty), \n(endx, endy)) \n268.     for y in range(BOARDHEIGHT + 1): \n269.         # Draw the vertical lines. \n270.         startx = XMARGIN \n271.         starty = (y * SPACESIZE) + YMARGIN \n272.         endx = XMARGIN + (BOARDWIDTH * SPACESIZE) \n273.         endy = (y * SPACESIZE) + YMARGIN \n274.         pygame.draw.line(DISPLAYSURF, GRIDLINECOLOR, (startx, starty), \n(endx, endy)) \n275.  \n276.     # Draw the black & white tiles or hint spots. \n277.     for x in range(BOARDWIDTH): \n278.         for y in range(BOARDHEIGHT): \n279.             centerx, centery = translateBoardToPixelCoord(x, y) \n280.             if board[x][y] == WHITE_TILE or board[x][y] == BLACK_TILE: \n281.                 if board[x][y] == WHITE_TILE: \n282.                     tileColor = WHITE \n283.                 else: \n284.                     tileColor = BLACK \n285.                 pygame.draw.circle(DISPLAYSURF, tileColor, (centerx, \ncentery), int(SPACESIZE / 2) - 4) \n286.             if board[x][y] == HINT_TILE: \n287.                 pygame.draw.rect(DISPLAYSURF, HINTCOLOR, (centerx - 4, \ncentery - 4, 8, 8)) \n288.  \n289.  \n290. def getSpaceClicked(mousex, mousey): \n291.     # Return a tuple of two integers of the board space coordinates where \n292.     # the mouse was clicked. (Or returns None not in any space.) \n293.     for x in range(BOARDWIDTH): \n294.         for y in range(BOARDHEIGHT): \n295.             if mousex > x * SPACESIZE + XMARGIN and \\ \n296.                mousex < (x + 1) * SPACESIZE + XMARGIN and \\ \n297.                mousey > y * SPACESIZE + YMARGIN and \\ \n298.                mousey < (y + 1) * SPACESIZE + YMARGIN: \n299.                 return (x, y) \n300.     return None \n301.  \n302.  \n303. def drawInfo(board, playerTile, computerTile, turn): \n",
      "content_length": 2099,
      "extraction_method": "Direct"
    },
    {
      "page_number": 318,
      "chapter": null,
      "content": "300    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n304.     # Draws scores and whose turn it is at the bottom of the screen. \n305.     scores = getScoreOfBoard(board) \n306.     scoreSurf = FONT.render(\"Player Score: %s    Computer Score: %s    \n%s's Turn\" % (str(scores[playerTile]), str(scores[computerTile]), \nturn.title()), True, TEXTCOLOR) \n307.     scoreRect = scoreSurf.get_rect() \n308.     scoreRect.bottomleft = (10, WINDOWHEIGHT - 5) \n309.     DISPLAYSURF.blit(scoreSurf, scoreRect) \n310.  \n311.  \n312. def resetBoard(board): \n313.     # Blanks out the board it is passed, and sets up starting tiles. \n314.     for x in range(BOARDWIDTH): \n315.         for y in range(BOARDHEIGHT): \n316.             board[x][y] = EMPTY_SPACE \n317.  \n318.     # Add starting pieces to the center \n319.     board[3][3] = WHITE_TILE \n320.     board[3][4] = BLACK_TILE \n321.     board[4][3] = BLACK_TILE \n322.     board[4][4] = WHITE_TILE \n323.  \n324.  \n325. def getNewBoard(): \n326.     # Creates a brand new, empty board data structure. \n327.     board = [] \n328.     for i in range(BOARDWIDTH): \n329.         board.append([EMPTY_SPACE] * BOARDHEIGHT) \n330.  \n331.     return board \n332.  \n333.  \n334. def isValidMove(board, tile, xstart, ystart): \n335.     # Returns False if the player's move is invalid. If it is a valid \n336.     # move, returns a list of spaces of the captured pieces. \n337.     if board[xstart][ystart] != EMPTY_SPACE or not isOnBoard(xstart, \nystart): \n338.         return False \n339.  \n340.     board[xstart][ystart] = tile # temporarily set the tile on the board. \n341.  \n342.     if tile == WHITE_TILE: \n343.         otherTile = BLACK_TILE \n344.     else: \n345.         otherTile = WHITE_TILE \n346.  \n",
      "content_length": 1771,
      "extraction_method": "Direct"
    },
    {
      "page_number": 319,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    301 \n \n347.     tilesToFlip = [] \n348.     # check each of the eight directions: \n349.     for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -\n1], [-1, -1], [-1, 0], [-1, 1]]: \n350.         x, y = xstart, ystart \n351.         x += xdirection \n352.         y += ydirection \n353.         if isOnBoard(x, y) and board[x][y] == otherTile: \n354.             # The piece belongs to the other player next to our piece. \n355.             x += xdirection \n356.             y += ydirection \n357.             if not isOnBoard(x, y): \n358.                 continue \n359.             while board[x][y] == otherTile: \n360.                 x += xdirection \n361.                 y += ydirection \n362.                 if not isOnBoard(x, y): \n363.                     break # break out of while loop, continue in for loop \n364.             if not isOnBoard(x, y): \n365.                 continue \n366.             if board[x][y] == tile: \n367.                 # There are pieces to flip over. Go in the reverse \n368.                 # direction until we reach the original space, noting all \n369.                 # the tiles along the way. \n370.                 while True: \n371.                     x -= xdirection \n372.                     y -= ydirection \n373.                     if x == xstart and y == ystart: \n374.                         break \n375.                     tilesToFlip.append([x, y]) \n376.  \n377.     board[xstart][ystart] = EMPTY_SPACE # make space empty \n378.     if len(tilesToFlip) == 0: # If no tiles flipped, this move is invalid \n379.         return False \n380.     return tilesToFlip \n381.  \n382.  \n383. def isOnBoard(x, y): \n384.     # Returns True if the coordinates are located on the board. \n385.     return x >= 0 and x < BOARDWIDTH and y >= 0 and y < BOARDHEIGHT \n386.  \n387.  \n388. def getBoardWithValidMoves(board, tile): \n389.     # Returns a new board with hint markings. \n390.     dupeBoard = copy.deepcopy(board) \n391.  \n",
      "content_length": 1995,
      "extraction_method": "Direct"
    },
    {
      "page_number": 320,
      "chapter": null,
      "content": "302    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n392.     for x, y in getValidMoves(dupeBoard, tile): \n393.         dupeBoard[x][y] = HINT_TILE \n394.     return dupeBoard \n395.  \n396.  \n397. def getValidMoves(board, tile): \n398.     # Returns a list of (x,y) tuples of all valid moves. \n399.     validMoves = [] \n400.  \n401.     for x in range(BOARDWIDTH): \n402.         for y in range(BOARDHEIGHT): \n403.             if isValidMove(board, tile, x, y) != False: \n404.                 validMoves.append((x, y)) \n405.     return validMoves \n406.  \n407.  \n408. def getScoreOfBoard(board): \n409.     # Determine the score by counting the tiles. \n410.     xscore = 0 \n411.     oscore = 0 \n412.     for x in range(BOARDWIDTH): \n413.         for y in range(BOARDHEIGHT): \n414.             if board[x][y] == WHITE_TILE: \n415.                 xscore += 1 \n416.             if board[x][y] == BLACK_TILE: \n417.                 oscore += 1 \n418.     return {WHITE_TILE:xscore, BLACK_TILE:oscore} \n419.  \n420.  \n421. def enterPlayerTile(): \n422.     # Draws the text and handles the mouse click events for letting \n423.     # the player choose which color they want to be.  Returns \n424.     # [WHITE_TILE, BLACK_TILE] if the player chooses to be White, \n425.     # [BLACK_TILE, WHITE_TILE] if Black. \n426.  \n427.     # Create the text. \n428.     textSurf = FONT.render('Do you want to be white or black?', True, \nTEXTCOLOR, TEXTBGCOLOR1) \n429.     textRect = textSurf.get_rect() \n430.     textRect.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2)) \n431.  \n432.     xSurf = BIGFONT.render('White', True, TEXTCOLOR, TEXTBGCOLOR1) \n433.     xRect = xSurf.get_rect() \n434.     xRect.center = (int(WINDOWWIDTH / 2) - 60, int(WINDOWHEIGHT / 2) + 40) \n435.  \n436.     oSurf = BIGFONT.render('Black', True, TEXTCOLOR, TEXTBGCOLOR1) \n",
      "content_length": 1872,
      "extraction_method": "Direct"
    },
    {
      "page_number": 321,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    303 \n \n437.     oRect = oSurf.get_rect() \n438.     oRect.center = (int(WINDOWWIDTH / 2) + 60, int(WINDOWHEIGHT / 2) + 40) \n439.  \n440.     while True: \n441.         # Keep looping until the player has clicked on a color. \n442.         checkForQuit() \n443.         for event in pygame.event.get(): # event handling loop \n444.             if event.type == MOUSEBUTTONUP: \n445.                 mousex, mousey = event.pos \n446.                 if xRect.collidepoint( (mousex, mousey) ): \n447.                     return [WHITE_TILE, BLACK_TILE] \n448.                 elif oRect.collidepoint( (mousex, mousey) ): \n449.                     return [BLACK_TILE, WHITE_TILE] \n450.  \n451.         # Draw the screen. \n452.         DISPLAYSURF.blit(textSurf, textRect) \n453.         DISPLAYSURF.blit(xSurf, xRect) \n454.         DISPLAYSURF.blit(oSurf, oRect) \n455.         pygame.display.update() \n456.         MAINCLOCK.tick(FPS) \n457.  \n458.  \n459. def makeMove(board, tile, xstart, ystart, realMove=False): \n460.     # Place the tile on the board at xstart, ystart, and flip tiles \n461.     # Returns False if this is an invalid move, True if it is valid. \n462.     tilesToFlip = isValidMove(board, tile, xstart, ystart) \n463.  \n464.     if tilesToFlip == False: \n465.         return False \n466.  \n467.     board[xstart][ystart] = tile \n468.  \n469.     if realMove: \n470.         animateTileChange(tilesToFlip, tile, (xstart, ystart)) \n471.  \n472.     for x, y in tilesToFlip: \n473.         board[x][y] = tile \n474.     return True \n475.  \n476.  \n477. def isOnCorner(x, y): \n478.     # Returns True if the position is in one of the four corners. \n479.     return (x == 0 and y == 0) or \\ \n480.            (x == BOARDWIDTH and y == 0) or \\ \n481.            (x == 0 and y == BOARDHEIGHT) or \\ \n482.            (x == BOARDWIDTH and y == BOARDHEIGHT) \n",
      "content_length": 1872,
      "extraction_method": "Direct"
    },
    {
      "page_number": 322,
      "chapter": null,
      "content": "304    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n483.  \n484.  \n485. def getComputerMove(board, computerTile): \n486.     # Given a board and the computer's tile, determine where to \n487.     # move and return that move as a [x, y] list. \n488.     possibleMoves = getValidMoves(board, computerTile) \n489.  \n490.     # randomize the order of the possible moves \n491.     random.shuffle(possibleMoves) \n492.  \n493.     # always go for a corner if available. \n494.     for x, y in possibleMoves: \n495.         if isOnCorner(x, y): \n496.             return [x, y] \n497.  \n498.     # Go through all possible moves and remember the best scoring move \n499.     bestScore = -1 \n500.     for x, y in possibleMoves: \n501.         dupeBoard = copy.deepcopy(board) \n502.         makeMove(dupeBoard, computerTile, x, y) \n503.         score = getScoreOfBoard(dupeBoard)[computerTile] \n504.         if score > bestScore: \n505.             bestMove = [x, y] \n506.             bestScore = score \n507.     return bestMove \n508.  \n509.  \n510. def checkForQuit(): \n511.     for event in pygame.event.get((QUIT, KEYUP)): # event handling loop \n512.         if event.type == QUIT or (event.type == KEYUP and event.key == \nK_ESCAPE): \n513.             pygame.quit() \n514.             sys.exit() \n515.  \n516.  \n517. if __name__ == '__main__': \n518.     main() \n \n",
      "content_length": 1391,
      "extraction_method": "Direct"
    },
    {
      "page_number": 323,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    305 \n \nInk Spill, a “Flood It” Clone \n      \n \nThe game ―Flood It‖ begins with a board filled with colored tiles. On each turn the player chooses \na new color to paint the top left tile and any tiles adjacent to it of that same color. This game \nmakes use of the flood fill algorithm (described in the Star Pusher chapter). The goal of the game \nis to turn the entire board into a single color before running out of turns. \nThis game also has a Settings screen where the player can change the size of the board and the \ndifficulty of the game. If the player gets board of the colors, there are a few other color schemes \nthey can switch to as well. \nSource Code for Ink Spill \nThis source code can be downloaded from http://invpy.com/inkspill.py. \nThe image files that Flippy uses can be downloaded from http://invpy.com/inkspillimages.zip. \n  1. # Ink Spill (a Flood It clone) \n  2. # http://inventwithpython.com/pygame \n  3. # By Al Sweigart al@inventwithpython.com \n  4. # Released under a \"Simplified BSD\" license \n  5.  \n  6. import random, sys, webbrowser, copy, pygame \n  7. from pygame.locals import * \n  8.  \n  9. # There are different box sizes, number of boxes, and \n 10. # life depending on the \"board size\" setting selected. \n 11. SMALLBOXSIZE  = 60 # size is in pixels \n 12. MEDIUMBOXSIZE = 20 \n 13. LARGEBOXSIZE  = 11 \n 14.  \n 15. SMALLBOARDSIZE  = 6 # size is in boxes \n",
      "content_length": 1419,
      "extraction_method": "Direct"
    },
    {
      "page_number": 324,
      "chapter": null,
      "content": "306    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 16. MEDIUMBOARDSIZE = 17 \n 17. LARGEBOARDSIZE  = 30 \n 18.  \n 19. SMALLMAXLIFE  = 10 # number of turns \n 20. MEDIUMMAXLIFE = 30 \n 21. LARGEMAXLIFE  = 64 \n 22.  \n 23. FPS = 30 \n 24. WINDOWWIDTH = 640 \n 25. WINDOWHEIGHT = 480 \n 26. boxSize = MEDIUMBOXSIZE \n 27. PALETTEGAPSIZE = 10 \n 28. PALETTESIZE = 45 \n 29. EASY = 0   # arbitrary but unique value \n 30. MEDIUM = 1 # arbitrary but unique value \n 31. HARD = 2   # arbitrary but unique value \n 32.  \n 33. difficulty = MEDIUM # game starts in \"medium\" mode \n 34. maxLife = MEDIUMMAXLIFE \n 35. boardWidth = MEDIUMBOARDSIZE \n 36. boardHeight = MEDIUMBOARDSIZE \n 37.  \n 38.  \n 39. #            R    G    B \n 40. WHITE    = (255, 255, 255) \n 41. DARKGRAY = ( 70,  70,  70) \n 42. BLACK    = (  0,   0,   0) \n 43. RED      = (255,   0,   0) \n 44. GREEN    = (  0, 255,   0) \n 45. BLUE     = (  0,   0, 255) \n 46. YELLOW   = (255, 255,   0) \n 47. ORANGE   = (255, 128,   0) \n 48. PURPLE   = (255,   0, 255) \n 49.  \n 50. # The first color in each scheme is the background color, the next six are \nthe palette colors. \n 51. COLORSCHEMES = (((150, 200, 255), RED, GREEN, BLUE, YELLOW, ORANGE, \nPURPLE), \n 52.                 ((0, 155, 104),  (97, 215, 164),  (228, 0, 69),  (0, 125, \n50),   (204, 246, 0),   (148, 0, 45),    (241, 109, 149)), \n 53.                 ((195, 179, 0),  (255, 239, 115), (255, 226, 0), (147, 3, \n167),  (24, 38, 176),   (166, 147, 0),   (197, 97, 211)), \n 54.                 ((85, 0, 0),     (155, 39, 102),  (0, 201, 13),  (255, \n118, 0),  (206, 0, 113),   (0, 130, 9),     (255, 180, 115)), \n 55.                 ((191, 159, 64), (183, 182, 208), (4, 31, 183),  (167, \n184, 45), (122, 128, 212), (37, 204, 7),    (88, 155, 213)), \n",
      "content_length": 1803,
      "extraction_method": "Direct"
    },
    {
      "page_number": 325,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    307 \n \n 56.                 ((200, 33, 205), (116, 252, 185), (68, 56, 56),  (52, 238, \n83),  (23, 149, 195),  (222, 157, 227), (212, 86, 185))) \n 57. for i in range(len(COLORSCHEMES)): \n 58.     assert len(COLORSCHEMES[i]) == 7, 'Color scheme %s does not have \nexactly 7 colors.' % (i) \n 59. bgColor = COLORSCHEMES[0][0] \n 60. paletteColors =  COLORSCHEMES[0][1:] \n 61.  \n 62. def main(): \n 63.     global FPSCLOCK, DISPLAYSURF, LOGOIMAGE, SPOTIMAGE, SETTINGSIMAGE, \nSETTINGSBUTTONIMAGE, RESETBUTTONIMAGE \n 64.  \n 65.     pygame.init() \n 66.     FPSCLOCK = pygame.time.Clock() \n 67.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 68.  \n 69.     # Load images \n 70.     LOGOIMAGE = pygame.image.load('inkspilllogo.png') \n 71.     SPOTIMAGE = pygame.image.load('inkspillspot.png') \n 72.     SETTINGSIMAGE = pygame.image.load('inkspillsettings.png') \n 73.     SETTINGSBUTTONIMAGE = pygame.image.load('inkspillsettingsbutton.png') \n 74.     RESETBUTTONIMAGE = pygame.image.load('inkspillresetbutton.png') \n 75.  \n 76.     pygame.display.set_caption('Ink Spill') \n 77.     mousex = 0 \n 78.     mousey = 0 \n 79.     mainBoard = generateRandomBoard(boardWidth, boardHeight, difficulty) \n 80.     life = maxLife \n 81.     lastPaletteClicked = None \n 82.  \n 83.     while True: # main game loop \n 84.         paletteClicked = None \n 85.         resetGame = False \n 86.  \n 87.         # Draw the screen. \n 88.         DISPLAYSURF.fill(bgColor) \n 89.         drawLogoAndButtons() \n 90.         drawBoard(mainBoard) \n 91.         drawLifeMeter(life) \n 92.         drawPalettes() \n 93.  \n 94.         checkForQuit() \n 95.         for event in pygame.event.get(): # event handling loop \n 96.             if event.type == MOUSEBUTTONUP: \n 97.                 mousex, mousey = event.pos \n",
      "content_length": 1832,
      "extraction_method": "Direct"
    },
    {
      "page_number": 326,
      "chapter": null,
      "content": "308    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 98.                 if pygame.Rect(WINDOWWIDTH - \nSETTINGSBUTTONIMAGE.get_width(), \n 99.                                WINDOWHEIGHT - \nSETTINGSBUTTONIMAGE.get_height(), \n100.                                SETTINGSBUTTONIMAGE.get_width(), \n101.                                \nSETTINGSBUTTONIMAGE.get_height()).collidepoint(mousex, mousey): \n102.                     resetGame = showSettingsScreen() # clicked on Settings \nbutton \n103.                 elif pygame.Rect(WINDOWWIDTH - \nRESETBUTTONIMAGE.get_width(), \n104.                                  WINDOWHEIGHT - \nSETTINGSBUTTONIMAGE.get_height() - RESETBUTTONIMAGE.get_height(), \n105.                                  RESETBUTTONIMAGE.get_width(), \n106.                                  \nRESETBUTTONIMAGE.get_height()).collidepoint(mousex, mousey): \n107.                     resetGame = True # clicked on Reset button \n108.                 else: \n109.                     # check if a palette button was clicked \n110.                     paletteClicked = getColorOfPaletteAt(mousex, mousey) \n111.  \n112.         if paletteClicked != None and paletteClicked != \nlastPaletteClicked: \n113.             # a palette button was clicked that is different from the \n114.             # last palette button clicked (this check prevents the player \n115.             # from accidentally clicking the same palette twice) \n116.             lastPaletteClicked = paletteClicked \n117.             floodAnimation(mainBoard, paletteClicked) \n118.             life -= 1 \n119.  \n120.             resetGame = False \n121.             if hasWon(mainBoard): \n122.                 for i in range(4): # flash border 4 times \n123.                     flashBorderAnimation(WHITE, mainBoard) \n124.                 resetGame = True \n125.                 pygame.time.wait(2000) # pause so the player can bask in \nvictory \n126.             elif life == 0: \n127.                 # life is zero, so player has lost \n128.                 drawLifeMeter(0) \n129.                 pygame.display.update() \n130.                 pygame.time.wait(400) \n131.                 for i in range(4): \n132.                     flashBorderAnimation(BLACK, mainBoard) \n133.                 resetGame = True \n",
      "content_length": 2316,
      "extraction_method": "Direct"
    },
    {
      "page_number": 327,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    309 \n \n134.                 pygame.time.wait(2000) # pause so the player can suffer in \ntheir defeat \n135.  \n136.         if resetGame: \n137.             # start a new game \n138.             mainBoard = generateRandomBoard(boardWidth, boardHeight, \ndifficulty) \n139.             life = maxLife \n140.             lastPaletteClicked = None \n141.  \n142.         pygame.display.update() \n143.         FPSCLOCK.tick(FPS) \n144.  \n145.  \n146. def checkForQuit(): \n147.     # Terminates the program if there are any QUIT or escape key events. \n148.     for event in pygame.event.get(QUIT): # get all the QUIT events \n149.         pygame.quit() # terminate if any QUIT events are present \n150.         sys.exit() \n151.     for event in pygame.event.get(KEYUP): # get all the KEYUP events \n152.         if event.key == K_ESCAPE: \n153.             pygame.quit() # terminate if the KEYUP event was for the Esc \nkey \n154.             sys.exit() \n155.         pygame.event.post(event) # put the other KEYUP event objects back \n156.  \n157.  \n158. def hasWon(board): \n159.     # if the entire board is the same color, player has won \n160.     for x in range(boardWidth): \n161.         for y in range(boardHeight): \n162.             if board[x][y] != board[0][0]: \n163.                 return False # found a different color, player has not won \n164.     return True \n165.  \n166.  \n167. def showSettingsScreen(): \n168.     global difficulty, boxSize, boardWidth, boardHeight, maxLife, \npaletteColors, bgColor \n169.  \n170.     # The pixel coordinates in this function were obtained by loading \n171.     # the inkspillsettings.png image into a graphics editor and reading \n172.     # the pixel coordinates from there. Handy trick. \n173.  \n174.     origDifficulty = difficulty \n175.     origBoxSize = boxSize \n",
      "content_length": 1823,
      "extraction_method": "Direct"
    },
    {
      "page_number": 328,
      "chapter": null,
      "content": "310    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n176.     screenNeedsRedraw = True \n177.  \n178.     while True: \n179.         if screenNeedsRedraw: \n180.             DISPLAYSURF.fill(bgColor) \n181.             DISPLAYSURF.blit(SETTINGSIMAGE, (0,0)) \n182.  \n183.             # place the ink spot marker next to the selected difficulty \n184.             if difficulty == EASY: \n185.                 DISPLAYSURF.blit(SPOTIMAGE, (30, 4)) \n186.             if difficulty == MEDIUM: \n187.                 DISPLAYSURF.blit(SPOTIMAGE, (8, 41)) \n188.             if difficulty == HARD: \n189.                 DISPLAYSURF.blit(SPOTIMAGE, (30, 76)) \n190.  \n191.             # place the ink spot marker next to the selected size \n192.             if boxSize == SMALLBOXSIZE: \n193.                 DISPLAYSURF.blit(SPOTIMAGE, (22, 150)) \n194.             if boxSize == MEDIUMBOXSIZE: \n195.                 DISPLAYSURF.blit(SPOTIMAGE, (11, 185)) \n196.             if boxSize == LARGEBOXSIZE: \n197.                 DISPLAYSURF.blit(SPOTIMAGE, (24, 220)) \n198.  \n199.             for i in range(len(COLORSCHEMES)): \n200.                 drawColorSchemeBoxes(500, i * 60 + 30, i) \n201.  \n202.             pygame.display.update() \n203.  \n204.         screenNeedsRedraw = False # by default, don't redraw the screen \n205.         for event in pygame.event.get(): # event handling loop \n206.             if event.type == QUIT: \n207.                 pygame.quit() \n208.                 sys.exit() \n209.             elif event.type == KEYUP: \n210.                 if event.key == K_ESCAPE: \n211.                     # Esc key on settings screen goes back to game \n212.                     return not (origDifficulty == difficulty and \norigBoxSize == boxSize) \n213.             elif event.type == MOUSEBUTTONUP: \n214.                 screenNeedsRedraw = True # screen should be redrawn \n215.                 mousex, mousey = event.pos # syntactic sugar \n216.  \n217.                 # check for clicks on the difficulty buttons \n218.                 if pygame.Rect(74, 16, 111, 30).collidepoint(mousex, \nmousey): \n219.                     difficulty = EASY \n",
      "content_length": 2187,
      "extraction_method": "Direct"
    },
    {
      "page_number": 329,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    311 \n \n220.                 elif pygame.Rect(53, 50, 104, 29).collidepoint(mousex, \nmousey): \n221.                     difficulty = MEDIUM \n222.                 elif pygame.Rect(72, 85, 65, 31).collidepoint(mousex, \nmousey): \n223.                     difficulty = HARD \n224.  \n225.                 # check for clicks on the size buttons \n226.                 elif pygame.Rect(63, 156, 84, 31).collidepoint(mousex, \nmousey): \n227.                     # small board size setting: \n228.                     boxSize = SMALLBOXSIZE \n229.                     boardWidth = SMALLBOARDSIZE \n230.                     boardHeight = SMALLBOARDSIZE \n231.                     maxLife = SMALLMAXLIFE \n232.                 elif pygame.Rect(52, 192, 106,32).collidepoint(mousex, \nmousey): \n233.                     # medium board size setting: \n234.                     boxSize = MEDIUMBOXSIZE \n235.                     boardWidth = MEDIUMBOARDSIZE \n236.                     boardHeight = MEDIUMBOARDSIZE \n237.                     maxLife = MEDIUMMAXLIFE \n238.                 elif pygame.Rect(67, 228, 58, 37).collidepoint(mousex, \nmousey): \n239.                     # large board size setting: \n240.                     boxSize = LARGEBOXSIZE \n241.                     boardWidth = LARGEBOARDSIZE \n242.                     boardHeight = LARGEBOARDSIZE \n243.                     maxLife = LARGEMAXLIFE \n244.                 elif pygame.Rect(14, 299, 371, 97).collidepoint(mousex, \nmousey): \n245.                     # clicked on the \"learn programming\" ad \n246.                     webbrowser.open('http://inventwithpython.com') # opens \na web browser \n247.                 elif pygame.Rect(178, 418, 215, 34).collidepoint(mousex, \nmousey): \n248.                     # clicked on the \"back to game\" button \n249.                     return not (origDifficulty == difficulty and \norigBoxSize == boxSize) \n250.  \n251.                 for i in range(len(COLORSCHEMES)): \n252.                     # clicked on a color scheme button \n253.                     if pygame.Rect(500, 30 + i * 60, MEDIUMBOXSIZE * 3, \nMEDIUMBOXSIZE * 2).collidepoint(mousex, mousey): \n254.                         bgColor = COLORSCHEMES[i][0] \n255.                         paletteColors  = COLORSCHEMES[i][1:] \n",
      "content_length": 2299,
      "extraction_method": "Direct"
    },
    {
      "page_number": 330,
      "chapter": null,
      "content": "312    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n256.  \n257.  \n258. def drawColorSchemeBoxes(x, y, schemeNum): \n259.     # Draws the color scheme boxes that appear on the \"Settings\" screen. \n260.     for boxy in range(2): \n261.         for boxx in range(3): \n262.             pygame.draw.rect(DISPLAYSURF, COLORSCHEMES[schemeNum][3 * boxy \n+ boxx + 1], (x + MEDIUMBOXSIZE * boxx, y + MEDIUMBOXSIZE * boxy, \nMEDIUMBOXSIZE, MEDIUMBOXSIZE)) \n263.             if paletteColors == COLORSCHEMES[schemeNum][1:]: \n264.                 # put the ink spot next to the selected color scheme \n265.                 DISPLAYSURF.blit(SPOTIMAGE, (x - 50, y)) \n266.  \n267.  \n268. def flashBorderAnimation(color, board, animationSpeed=30): \n269.     origSurf = DISPLAYSURF.copy() \n270.     flashSurf = pygame.Surface(DISPLAYSURF.get_size()) \n271.     flashSurf = flashSurf.convert_alpha() \n272.     for start, end, step in ((0, 256, 1), (255, 0, -1)): \n273.         # the first iteration on the outer loop will set the inner loop \n274.         # to have transparency go from 0 to 255, the second iteration will \n275.         # have it go from 255 to 0. This is the \"flash\". \n276.         for transparency in range(start, end, animationSpeed * step): \n277.             DISPLAYSURF.blit(origSurf, (0, 0)) \n278.             r, g, b = color \n279.             flashSurf.fill((r, g, b, transparency)) \n280.             DISPLAYSURF.blit(flashSurf, (0, 0)) \n281.             drawBoard(board) # draw board ON TOP OF the transparency layer \n282.             pygame.display.update() \n283.             FPSCLOCK.tick(FPS) \n284.     DISPLAYSURF.blit(origSurf, (0, 0)) # redraw the original surface \n285.  \n286.  \n287. def floodAnimation(board, paletteClicked, animationSpeed=25): \n288.     origBoard = copy.deepcopy(board) \n289.     floodFill(board, board[0][0], paletteClicked, 0, 0) \n290.  \n291.     for transparency in range(0, 255, animationSpeed): \n292.         # The \"new\" board slowly become opaque over the original board. \n293.         drawBoard(origBoard) \n294.         drawBoard(board, transparency) \n295.         pygame.display.update() \n296.         FPSCLOCK.tick(FPS) \n297.  \n298.  \n299. def generateRandomBoard(width, height, difficulty=MEDIUM): \n",
      "content_length": 2284,
      "extraction_method": "Direct"
    },
    {
      "page_number": 331,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    313 \n \n300.     # Creates a board data structure with random colors for each box. \n301.     board = [] \n302.     for x in range(width): \n303.         column = [] \n304.         for y in range(height): \n305.             column.append(random.randint(0, len(paletteColors) - 1)) \n306.         board.append(column) \n307.  \n308.     # Make board easier by setting some boxes to same color as a neighbor. \n309.  \n310.     # Determine how many boxes to change. \n311.     if difficulty == EASY: \n312.         if boxSize == SMALLBOXSIZE: \n313.             boxesToChange = 100 \n314.         else: \n315.             boxesToChange = 1500 \n316.     elif difficulty == MEDIUM: \n317.         if boxSize == SMALLBOXSIZE: \n318.             boxesToChange = 5 \n319.         else: \n320.             boxesToChange = 200 \n321.     else: \n322.         boxesToChange = 0 \n323.  \n324.     # Change neighbor's colors: \n325.     for i in range(boxesToChange): \n326.         # Randomly choose a box whose color to copy \n327.         x = random.randint(1, width-2) \n328.         y = random.randint(1, height-2) \n329.  \n330.         # Randomly choose neighbors to change. \n331.         direction = random.randint(0, 3) \n332.         if direction == 0: # change left and up neighbor \n333.             board[x-1][y] == board[x][y] \n334.             board[x][y-1] == board[x][y] \n335.         elif direction == 1: # change right and down neighbor \n336.             board[x+1][y] == board[x][y] \n337.             board[x][y+1] == board[x][y] \n338.         elif direction == 2: # change right and up neighbor \n339.             board[x][y-1] == board[x][y] \n340.             board[x+1][y] == board[x][y] \n341.         else: # change left and down neighbor \n342.             board[x][y+1] == board[x][y] \n343.             board[x-1][y] == board[x][y] \n344.     return board \n345.  \n",
      "content_length": 1877,
      "extraction_method": "Direct"
    },
    {
      "page_number": 332,
      "chapter": null,
      "content": "314    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n346.  \n347. def drawLogoAndButtons(): \n348.     # draw the Ink Spill logo and Settings and Reset buttons. \n349.     DISPLAYSURF.blit(LOGOIMAGE, (WINDOWWIDTH - LOGOIMAGE.get_width(), 0)) \n350.     DISPLAYSURF.blit(SETTINGSBUTTONIMAGE, (WINDOWWIDTH - \nSETTINGSBUTTONIMAGE.get_width(), WINDOWHEIGHT - \nSETTINGSBUTTONIMAGE.get_height())) \n351.     DISPLAYSURF.blit(RESETBUTTONIMAGE, (WINDOWWIDTH - \nRESETBUTTONIMAGE.get_width(), WINDOWHEIGHT - SETTINGSBUTTONIMAGE.get_height() - \nRESETBUTTONIMAGE.get_height())) \n352.  \n353.  \n354. def drawBoard(board, transparency=255): \n355.     # The colored squares are drawn to a temporary surface which is then \n356.     # drawn to the DISPLAYSURF surface. This is done so we can draw the \n357.     # squares with transparency on top of DISPLAYSURF as it currently is. \n358.     tempSurf = pygame.Surface(DISPLAYSURF.get_size()) \n359.     tempSurf = tempSurf.convert_alpha() \n360.     tempSurf.fill((0, 0, 0, 0)) \n361.  \n362.     for x in range(boardWidth): \n363.         for y in range(boardHeight): \n364.             left, top = leftTopPixelCoordOfBox(x, y) \n365.             r, g, b = paletteColors[board[x][y]] \n366.             pygame.draw.rect(tempSurf, (r, g, b, transparency), (left, \ntop, boxSize, boxSize)) \n367.     left, top = leftTopPixelCoordOfBox(0, 0) \n368.     pygame.draw.rect(tempSurf, BLACK, (left-1, top-1, boxSize * boardWidth \n+ 1, boxSize * boardHeight + 1), 1) \n369.     DISPLAYSURF.blit(tempSurf, (0, 0)) \n370.  \n371.  \n372. def drawPalettes(): \n373.     # Draws the six color palettes at the bottom of the screen. \n374.     numColors = len(paletteColors) \n375.     xmargin = int((WINDOWWIDTH - ((PALETTESIZE * numColors) + \n(PALETTEGAPSIZE * (numColors - 1)))) / 2) \n376.     for i in range(numColors): \n377.         left = xmargin + (i * PALETTESIZE) + (i * PALETTEGAPSIZE) \n378.         top = WINDOWHEIGHT - PALETTESIZE - 10 \n379.         pygame.draw.rect(DISPLAYSURF, paletteColors[i], (left, top, \nPALETTESIZE, PALETTESIZE)) \n380.         pygame.draw.rect(DISPLAYSURF, bgColor,   (left + 2, top + 2, \nPALETTESIZE - 4, PALETTESIZE - 4), 2) \n381.  \n382.  \n",
      "content_length": 2224,
      "extraction_method": "Direct"
    },
    {
      "page_number": 333,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    315 \n \n383. def drawLifeMeter(currentLife): \n384.     lifeBoxSize = int((WINDOWHEIGHT - 40) / maxLife) \n385.  \n386.     # Draw background color of life meter. \n387.     pygame.draw.rect(DISPLAYSURF, bgColor, (20, 20, 20, 20 + (maxLife * \nlifeBoxSize))) \n388.  \n389.     for i in range(maxLife): \n390.         if currentLife >= (maxLife - i): # draw a solid red box \n391.             pygame.draw.rect(DISPLAYSURF, RED, (20, 20 + (i * \nlifeBoxSize), 20, lifeBoxSize)) \n392.         pygame.draw.rect(DISPLAYSURF, WHITE, (20, 20 + (i * lifeBoxSize), \n20, lifeBoxSize), 1) # draw white outline \n393.  \n394.  \n395. def getColorOfPaletteAt(x, y): \n396.     # Returns the index of the color in paletteColors that the x and y \nparameters \n397.     # are over. Returns None if x and y are not over any palette. \n398.     numColors = len(paletteColors) \n399.     xmargin = int((WINDOWWIDTH - ((PALETTESIZE * numColors) + \n(PALETTEGAPSIZE * (numColors - 1)))) / 2) \n400.     top = WINDOWHEIGHT - PALETTESIZE - 10 \n401.     for i in range(numColors): \n402.         # Find out if the mouse click is inside any of the palettes. \n403.         left = xmargin + (i * PALETTESIZE) + (i * PALETTEGAPSIZE) \n404.         r = pygame.Rect(left, top, PALETTESIZE, PALETTESIZE) \n405.         if r.collidepoint(x, y): \n406.             return i \n407.     return None # no palette exists at these x, y coordinates \n408.  \n409.  \n410. def floodFill(board, oldColor, newColor, x, y): \n411.     # This is the flood fill algorithm. \n412.     if oldColor == newColor or board[x][y] != oldColor: \n413.         return \n414.  \n415.     board[x][y] = newColor # change the color of the current box \n416.  \n417.     # Make the recursive call for any neighboring boxes: \n418.     if x > 0: \n419.         floodFill(board, oldColor, newColor, x - 1, y) # on box to the \nleft \n420.     if x < boardWidth - 1: \n421.         floodFill(board, oldColor, newColor, x + 1, y) # on box to the \nright \n",
      "content_length": 1985,
      "extraction_method": "Direct"
    },
    {
      "page_number": 334,
      "chapter": null,
      "content": "316    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n422.     if y > 0: \n423.         floodFill(board, oldColor, newColor, x, y - 1) # on box to up \n424.     if y < boardHeight - 1: \n425.         floodFill(board, oldColor, newColor, x, y + 1) # on box to down \n426.  \n427.  \n428. def leftTopPixelCoordOfBox(boxx, boxy): \n429.     # Returns the x and y of the left-topmost pixel of the xth & yth box. \n430.     xmargin = int((WINDOWWIDTH - (boardWidth * boxSize)) / 2) \n431.     ymargin = int((WINDOWHEIGHT - (boardHeight * boxSize)) / 2) \n432.     return (boxx * boxSize + xmargin, boxy * boxSize + ymargin) \n433.  \n434.  \n435. if __name__ == '__main__': \n436.     main() \n \n",
      "content_length": 725,
      "extraction_method": "Direct"
    },
    {
      "page_number": 335,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    317 \n \nFour-In-A-Row, a “Connect Four” Clone \n      \n \nThe game ―Connect Four‖ has a 7 x 6 board where the players take turns dropping tokens from \nthe top of the board. The tokens will fall from the top of each column and come to rest on the \nbottom of the board or on top of the topmost token in that column. A player wins when four of \ntheir tokens line up in a row either horizontally, vertically, or diagonally. \nThe AI for this game is pretty good. It simulates every possible move it can make, then simulates \nevery possible move the human player can make in response to each of those moves, and then \nsimulates every possible move it can make in response to that, and then simulates every possible \nmove the human player could make in response to each of those moves! After all that thinking, \nthe computer determines which move is most likely to lead to it winning. \nSo the computer is kind of tough to beat. I usually lose to it. \nSince there are seven possible moves you can make on your turn (unless some columns are full), \nand seven possible moves the opponent could make, and seven moves in response to that, and \nseven moves in response to that, that means that on each turn the computer is considering 7 x 7 x \n7 x 7 = 2,401 possible moves. You can make the computer consider the game even further by \nsetting the DIFFICULTY constant to a higher number, but when I set to a value larger than 2, the \ncomputer takes a long time to calculate its turn. \nYou can also make the computer easier by setting DIFFICULTY to 1. Then the computer only \nconsiders each of its moves and the player’s possible responses to those moves. If you set the \nDIFFICULTY to 0, then the computer loses all intelligence and simply makes random moves. \nSource Code for Four-In-A-Row \nThis source code can be downloaded from http://invpy.com/fourinarow.py. \n",
      "content_length": 1881,
      "extraction_method": "Direct"
    },
    {
      "page_number": 336,
      "chapter": null,
      "content": "318    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nThe image files that Flippy uses can be downloaded from http://invpy.com/fourinarowimages.zip. \n  1. # Four-In-A-Row (a Connect Four clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Released under a \"Simplified BSD\" license \n  5.  \n  6. import random, copy, sys, pygame \n  7. from pygame.locals import * \n  8.  \n  9. BOARDWIDTH = 7  # how many spaces wide the board is \n 10. BOARDHEIGHT = 6 # how many spaces tall the board is \n 11. assert BOARDWIDTH >= 4 and BOARDHEIGHT >= 4, 'Board must be at least 4x4.' \n 12.  \n 13. DIFFICULTY = 2 # how many moves to look ahead. (>2 is usually too slow) \n 14.  \n 15. SPACESIZE = 50 # size of the tokens and individual board spaces in pixels \n 16.  \n 17. FPS = 30 # frames per second to update the screen \n 18. WINDOWWIDTH = 640 # width of the program's window, in pixels \n 19. WINDOWHEIGHT = 480 # height in pixels \n 20.  \n 21. XMARGIN = int((WINDOWWIDTH - BOARDWIDTH * SPACESIZE) / 2) \n 22. YMARGIN = int((WINDOWHEIGHT - BOARDHEIGHT * SPACESIZE) / 2) \n 23.  \n 24. BRIGHTBLUE = (0, 50, 255) \n 25. WHITE = (255, 255, 255) \n 26.  \n 27. BGCOLOR = BRIGHTBLUE \n 28. TEXTCOLOR = WHITE \n 29.  \n 30. RED = 'red' \n 31. BLACK = 'black' \n 32. EMPTY = None \n 33. HUMAN = 'human' \n 34. COMPUTER = 'computer' \n 35.  \n 36.  \n 37. def main(): \n 38.     global FPSCLOCK, DISPLAYSURF, REDPILERECT, BLACKPILERECT, REDTOKENIMG \n 39.     global BLACKTOKENIMG, BOARDIMG, ARROWIMG, ARROWRECT, HUMANWINNERIMG \n 40.     global COMPUTERWINNERIMG, WINNERRECT, TIEWINNERIMG \n 41.  \n 42.     pygame.init() \n 43.     FPSCLOCK = pygame.time.Clock() \n 44.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n",
      "content_length": 1794,
      "extraction_method": "Direct"
    },
    {
      "page_number": 337,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    319 \n \n 45.     pygame.display.set_caption('Four in a Row') \n 46.  \n 47.     REDPILERECT = pygame.Rect(int(SPACESIZE / 2), WINDOWHEIGHT - int(3 * \nSPACESIZE / 2), SPACESIZE, SPACESIZE) \n 48.     BLACKPILERECT = pygame.Rect(WINDOWWIDTH - int(3 * SPACESIZE / 2), \nWINDOWHEIGHT - int(3 * SPACESIZE / 2), SPACESIZE, SPACESIZE) \n 49.     REDTOKENIMG = pygame.image.load('4row_red.png') \n 50.     REDTOKENIMG = pygame.transform.smoothscale(REDTOKENIMG, (SPACESIZE, \nSPACESIZE)) \n 51.     BLACKTOKENIMG = pygame.image.load('4row_black.png') \n 52.     BLACKTOKENIMG = pygame.transform.smoothscale(BLACKTOKENIMG, \n(SPACESIZE, SPACESIZE)) \n 53.     BOARDIMG = pygame.image.load('4row_board.png') \n 54.     BOARDIMG = pygame.transform.smoothscale(BOARDIMG, (SPACESIZE, \nSPACESIZE)) \n 55.  \n 56.     HUMANWINNERIMG = pygame.image.load('4row_humanwinner.png') \n 57.     COMPUTERWINNERIMG = pygame.image.load('4row_computerwinner.png') \n 58.     TIEWINNERIMG = pygame.image.load('4row_tie.png') \n 59.     WINNERRECT = HUMANWINNERIMG.get_rect() \n 60.     WINNERRECT.center = (int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2)) \n 61.  \n 62.     ARROWIMG = pygame.image.load('4row_arrow.png') \n 63.     ARROWRECT = ARROWIMG.get_rect() \n 64.     ARROWRECT.left = REDPILERECT.right + 10 \n 65.     ARROWRECT.centery = REDPILERECT.centery \n 66.  \n 67.     isFirstGame = True \n 68.  \n 69.     while True: \n 70.         runGame(isFirstGame) \n 71.         isFirstGame = False \n 72.  \n 73.  \n 74. def runGame(isFirstGame): \n 75.     if isFirstGame: \n 76.         # Let the computer go first on the first game, so the player \n 77.         # can see how the tokens are dragged from the token piles. \n 78.         turn = COMPUTER \n 79.         showHelp = True \n 80.     else: \n 81.         # Randomly choose who goes first. \n 82.         if random.randint(0, 1) == 0: \n 83.             turn = COMPUTER \n 84.         else: \n 85.             turn = HUMAN \n",
      "content_length": 1953,
      "extraction_method": "Direct"
    },
    {
      "page_number": 338,
      "chapter": null,
      "content": "320    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 86.         showHelp = False \n 87.  \n 88.     # Set up a blank board data structure. \n 89.     mainBoard = getNewBoard() \n 90.  \n 91.     while True: # main game loop \n 92.         if turn == HUMAN: \n 93.             # Human player's turn. \n 94.             getHumanMove(mainBoard, showHelp) \n 95.             if showHelp: \n 96.                 # turn off help arrow after the first move \n 97.                 showHelp = False \n 98.             if isWinner(mainBoard, RED): \n 99.                 winnerImg = HUMANWINNERIMG \n100.                 break \n101.             turn = COMPUTER # switch to other player's turn \n102.         else: \n103.             # Computer player's turn. \n104.             column = getComputerMove(mainBoard) \n105.             animateComputerMoving(mainBoard, column) \n106.             makeMove(mainBoard, BLACK, column) \n107.             if isWinner(mainBoard, BLACK): \n108.                 winnerImg = COMPUTERWINNERIMG \n109.                 break \n110.             turn = HUMAN # switch to other player's turn \n111.  \n112.         if isBoardFull(mainBoard): \n113.             # A completely filled board means it's a tie. \n114.             winnerImg = TIEWINNERIMG \n115.             break \n116.  \n117.     while True: \n118.         # Keep looping until player clicks the mouse or quits. \n119.         drawBoard(mainBoard) \n120.         DISPLAYSURF.blit(winnerImg, WINNERRECT) \n121.         pygame.display.update() \n122.         FPSCLOCK.tick() \n123.         for event in pygame.event.get(): # event handling loop \n124.             if event.type == QUIT or (event.type == KEYUP and event.key == \nK_ESCAPE): \n125.                 pygame.quit() \n126.                 sys.exit() \n127.             elif event.type == MOUSEBUTTONUP: \n128.                 return \n129.  \n130.  \n",
      "content_length": 1904,
      "extraction_method": "Direct"
    },
    {
      "page_number": 339,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    321 \n \n131. def makeMove(board, player, column): \n132.     lowest = getLowestEmptySpace(board, column) \n133.     if lowest != -1: \n134.         board[column][lowest] = player \n135.  \n136.  \n137. def drawBoard(board, extraToken=None): \n138.     DISPLAYSURF.fill(BGCOLOR) \n139.  \n140.     # draw tokens \n141.     spaceRect = pygame.Rect(0, 0, SPACESIZE, SPACESIZE) \n142.     for x in range(BOARDWIDTH): \n143.         for y in range(BOARDHEIGHT): \n144.             spaceRect.topleft = (XMARGIN + (x * SPACESIZE), YMARGIN + (y * \nSPACESIZE)) \n145.             if board[x][y] == RED: \n146.                 DISPLAYSURF.blit(REDTOKENIMG, spaceRect) \n147.             elif board[x][y] == BLACK: \n148.                 DISPLAYSURF.blit(BLACKTOKENIMG, spaceRect) \n149.  \n150.     # draw the extra token \n151.     if extraToken != None: \n152.         if extraToken['color'] == RED: \n153.             DISPLAYSURF.blit(REDTOKENIMG, (extraToken['x'], \nextraToken['y'], SPACESIZE, SPACESIZE)) \n154.         elif extraToken['color'] == BLACK: \n155.             DISPLAYSURF.blit(BLACKTOKENIMG, (extraToken['x'], \nextraToken['y'], SPACESIZE, SPACESIZE)) \n156.  \n157.     # draw board over the tokens \n158.     for x in range(BOARDWIDTH): \n159.         for y in range(BOARDHEIGHT): \n160.             spaceRect.topleft = (XMARGIN + (x * SPACESIZE), YMARGIN + (y * \nSPACESIZE)) \n161.             DISPLAYSURF.blit(BOARDIMG, spaceRect) \n162.  \n163.     # draw the red and black tokens off to the side \n164.     DISPLAYSURF.blit(REDTOKENIMG, REDPILERECT) # red on the left \n165.     DISPLAYSURF.blit(BLACKTOKENIMG, BLACKPILERECT) # black on the right \n166.  \n167.  \n168. def getNewBoard(): \n169.     board = [] \n170.     for x in range(BOARDWIDTH): \n171.         board.append([EMPTY] * BOARDHEIGHT) \n172.     return board \n",
      "content_length": 1831,
      "extraction_method": "Direct"
    },
    {
      "page_number": 340,
      "chapter": null,
      "content": "322    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n173.  \n174.  \n175. def getHumanMove(board, isFirstMove): \n176.     draggingToken = False \n177.     tokenx, tokeny = None, None \n178.     while True: \n179.         for event in pygame.event.get(): # event handling loop \n180.             if event.type == QUIT: \n181.                 pygame.quit() \n182.                 sys.exit() \n183.             elif event.type == MOUSEBUTTONDOWN and not draggingToken and \nREDPILERECT.collidepoint(event.pos): \n184.                 # start of dragging on red token pile. \n185.                 draggingToken = True \n186.                 tokenx, tokeny = event.pos \n187.             elif event.type == MOUSEMOTION and draggingToken: \n188.                 # update the position of the red token being dragged \n189.                 tokenx, tokeny = event.pos \n190.             elif event.type == MOUSEBUTTONUP and draggingToken: \n191.                 # let go of the token being dragged \n192.                 if tokeny < YMARGIN and tokenx > XMARGIN and tokenx < \nWINDOWWIDTH - XMARGIN: \n193.                     # let go at the top of the screen. \n194.                     column = int((tokenx - XMARGIN) / SPACESIZE) \n195.                     if isValidMove(board, column): \n196.                         animateDroppingToken(board, column, RED) \n197.                         board[column][getLowestEmptySpace(board, column)] \n= RED \n198.                         drawBoard(board) \n199.                         pygame.display.update() \n200.                         return \n201.                 tokenx, tokeny = None, None \n202.                 draggingToken = False \n203.         if tokenx != None and tokeny != None: \n204.             drawBoard(board, {'x':tokenx - int(SPACESIZE / 2), 'y':tokeny \n- int(SPACESIZE / 2), 'color':RED}) \n205.         else: \n206.             drawBoard(board) \n207.  \n208.         if isFirstMove: \n209.             # Show the help arrow for the player's first move. \n210.             DISPLAYSURF.blit(ARROWIMG, ARROWRECT) \n211.  \n212.         pygame.display.update() \n213.         FPSCLOCK.tick() \n214.  \n",
      "content_length": 2169,
      "extraction_method": "Direct"
    },
    {
      "page_number": 341,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    323 \n \n215.  \n216. def animateDroppingToken(board, column, color): \n217.     x = XMARGIN + column * SPACESIZE \n218.     y = YMARGIN - SPACESIZE \n219.     dropSpeed = 1.0 \n220.  \n221.     lowestEmptySpace = getLowestEmptySpace(board, column) \n222.  \n223.     while True: \n224.         y += int(dropSpeed) \n225.         dropSpeed += 0.5 \n226.         if int((y - YMARGIN) / SPACESIZE) >= lowestEmptySpace: \n227.             return \n228.         drawBoard(board, {'x':x, 'y':y, 'color':color}) \n229.         pygame.display.update() \n230.         FPSCLOCK.tick() \n231.  \n232.  \n233. def animateComputerMoving(board, column): \n234.     x = BLACKPILERECT.left \n235.     y = BLACKPILERECT.top \n236.     speed = 1.0 \n237.     # moving the black tile up \n238.     while y > (YMARGIN - SPACESIZE): \n239.         y -= int(speed) \n240.         speed += 0.5 \n241.         drawBoard(board, {'x':x, 'y':y, 'color':BLACK}) \n242.         pygame.display.update() \n243.         FPSCLOCK.tick() \n244.     # moving the black tile over \n245.     y = YMARGIN - SPACESIZE \n246.     speed = 1.0 \n247.     while x > (XMARGIN + column * SPACESIZE): \n248.         x -= int(speed) \n249.         speed += 0.5 \n250.         drawBoard(board, {'x':x, 'y':y, 'color':BLACK}) \n251.         pygame.display.update() \n252.         FPSCLOCK.tick() \n253.     # dropping the black tile \n254.     animateDroppingToken(board, column, BLACK) \n255.  \n256.  \n257. def getComputerMove(board): \n258.     potentialMoves = getPotentialMoves(board, BLACK, DIFFICULTY) \n259.     # get the best fitness from the potential moves \n260.     bestMoveFitness = -1 \n",
      "content_length": 1640,
      "extraction_method": "Direct"
    },
    {
      "page_number": 342,
      "chapter": null,
      "content": "324    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n261.     for i in range(BOARDWIDTH): \n262.         if potentialMoves[i] > bestMoveFitness and isValidMove(board, i): \n263.             bestMoveFitness = potentialMoves[i] \n264.     # find all potential moves that have this best fitness \n265.     bestMoves = [] \n266.     for i in range(len(potentialMoves)): \n267.         if potentialMoves[i] == bestMoveFitness and isValidMove(board, i): \n268.             bestMoves.append(i) \n269.     return random.choice(bestMoves) \n270.  \n271.  \n272. def getPotentialMoves(board, tile, lookAhead): \n273.     if lookAhead == 0 or isBoardFull(board): \n274.         return [0] * BOARDWIDTH \n275.  \n276.     if tile == RED: \n277.         enemyTile = BLACK \n278.     else: \n279.         enemyTile = RED \n280.  \n281.     # Figure out the best move to make. \n282.     potentialMoves = [0] * BOARDWIDTH \n283.     for firstMove in range(BOARDWIDTH): \n284.         dupeBoard = copy.deepcopy(board) \n285.         if not isValidMove(dupeBoard, firstMove): \n286.             continue \n287.         makeMove(dupeBoard, tile, firstMove) \n288.         if isWinner(dupeBoard, tile): \n289.             # a winning move automatically gets a perfect fitness \n290.             potentialMoves[firstMove] = 1 \n291.             break # don't bother calculating other moves \n292.         else: \n293.             # do other player's counter moves and determine best one \n294.             if isBoardFull(dupeBoard): \n295.                 potentialMoves[firstMove] = 0 \n296.             else: \n297.                 for counterMove in range(BOARDWIDTH): \n298.                     dupeBoard2 = copy.deepcopy(dupeBoard) \n299.                     if not isValidMove(dupeBoard2, counterMove): \n300.                         continue \n301.                     makeMove(dupeBoard2, enemyTile, counterMove) \n302.                     if isWinner(dupeBoard2, enemyTile): \n303.                         # a losing move automatically gets the worst \nfitness \n304.                         potentialMoves[firstMove] = -1 \n305.                         break \n",
      "content_length": 2155,
      "extraction_method": "Direct"
    },
    {
      "page_number": 343,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    325 \n \n306.                     else: \n307.                         # do the recursive call to getPotentialMoves() \n308.                         results = getPotentialMoves(dupeBoard2, tile, \nlookAhead - 1) \n309.                         potentialMoves[firstMove] += (sum(results) / \nBOARDWIDTH) / BOARDWIDTH \n310.     return potentialMoves \n311.  \n312.  \n313. def getLowestEmptySpace(board, column): \n314.     # Return the row number of the lowest empty row in the given column. \n315.     for y in range(BOARDHEIGHT-1, -1, -1): \n316.         if board[column][y] == EMPTY: \n317.             return y \n318.     return -1 \n319.  \n320.  \n321. def isValidMove(board, column): \n322.     # Returns True if there is an empty space in the given column. \n323.     # Otherwise returns False. \n324.     if column < 0 or column >= (BOARDWIDTH) or board[column][0] != EMPTY: \n325.         return False \n326.     return True \n327.  \n328.  \n329. def isBoardFull(board): \n330.     # Returns True if there are no empty spaces anywhere on the board. \n331.     for x in range(BOARDWIDTH): \n332.         for y in range(BOARDHEIGHT): \n333.             if board[x][y] == EMPTY: \n334.                 return False \n335.     return True \n336.  \n337.  \n338. def isWinner(board, tile): \n339.     # check horizontal spaces \n340.     for x in range(BOARDWIDTH - 3): \n341.         for y in range(BOARDHEIGHT): \n342.             if board[x][y] == tile and board[x+1][y] == tile and \nboard[x+2][y] == tile and board[x+3][y] == tile: \n343.                 return True \n344.     # check vertical spaces \n345.     for x in range(BOARDWIDTH): \n346.         for y in range(BOARDHEIGHT - 3): \n347.             if board[x][y] == tile and board[x][y+1] == tile and \nboard[x][y+2] == tile and board[x][y+3] == tile: \n",
      "content_length": 1809,
      "extraction_method": "Direct"
    },
    {
      "page_number": 344,
      "chapter": null,
      "content": "326    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n348.                 return True \n349.     # check / diagonal spaces \n350.     for x in range(BOARDWIDTH - 3): \n351.         for y in range(3, BOARDHEIGHT): \n352.             if board[x][y] == tile and board[x+1][y-1] == tile and \nboard[x+2][y-2] == tile and board[x+3][y-3] == tile: \n353.                 return True \n354.     # check \\ diagonal spaces \n355.     for x in range(BOARDWIDTH - 3): \n356.         for y in range(BOARDHEIGHT - 3): \n357.             if board[x][y] == tile and board[x+1][y+1] == tile and \nboard[x+2][y+2] == tile and board[x+3][y+3] == tile: \n358.                 return True \n359.     return False \n360.  \n361.  \n362. if __name__ == '__main__': \n363.     main() \n \n \n \n \n",
      "content_length": 803,
      "extraction_method": "Direct"
    },
    {
      "page_number": 345,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    327 \n \nGemgem, a “Bejeweled” Clone \n    \n \n―Bejeweled‖ is a game where gems fall to fill up a board. The player can swap any two adjacent \ngems to try to match three gems in a row (vertically or horizontally, but not diagonally). The \nmatched gems then disappear, making way for new gems to fall from the top. Matching more \nthan three gems, or causing a chain reaction of gem matches will result in more points. The \nplayer’s score slowly drops over time, so the player must constantly be making new matches. The \ngame ends when no possible match can be made on the board. \nSource Code for Gemgem \nThis source code can be downloaded from http://invpy.com/gemgem.py. \nThe image files that Flippy uses can be downloaded from http://invpy.com/gemgemimages.zip. \n  1. # Gemgem (a Bejeweled clone) \n  2. # By Al Sweigart al@inventwithpython.com \n  3. # http://inventwithpython.com/pygame \n  4. # Released under a \"Simplified BSD\" license \n  5.  \n  6. \"\"\" \n  7. This program has \"gem data structures\", which are basically dictionaries \n  8. with the following keys: \n  9.   'x' and 'y' - The location of the gem on the board. 0,0 is the top left. \n 10.                 There is also a ROWABOVEBOARD row that 'y' can be set to, \n 11.                 to indicate that it is above the board. \n 12.   'direction' - one of the four constant variables UP, DOWN, LEFT, RIGHT. \n 13.                 This is the direction the gem is moving. \n 14.   'imageNum'  - The integer index into GEMIMAGES to denote which image \n 15.                 this gem uses. \n 16. \"\"\" \n 17.  \n",
      "content_length": 1592,
      "extraction_method": "Direct"
    },
    {
      "page_number": 346,
      "chapter": null,
      "content": "328    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n 18. import random, time, pygame, sys, copy \n 19. from pygame.locals import * \n 20.  \n 21. FPS = 30 # frames per second to update the screen \n 22. WINDOWWIDTH = 600  # width of the program's window, in pixels \n 23. WINDOWHEIGHT = 600 # height in pixels \n 24.  \n 25. BOARDWIDTH = 8 # how many columns in the board \n 26. BOARDHEIGHT = 8 # how many rows in the board \n 27. GEMIMAGESIZE = 64 # width & height of each space in pixels \n 28.  \n 29. # NUMGEMIMAGES is the number of gem types. You will need .png image \n 30. # files named gem0.png, gem1.png, etc. up to gem(N-1).png. \n 31. NUMGEMIMAGES = 7 \n 32. assert NUMGEMIMAGES >= 5 # game needs at least 5 types of gems to work \n 33.  \n 34. # NUMMATCHSOUNDS is the number of different sounds to choose from when \n 35. # a match is made. The .wav files are named match0.wav, match1.wav, etc. \n 36. NUMMATCHSOUNDS = 6 \n 37.  \n 38. MOVERATE = 25 # 1 to 100, larger num means faster animations \n 39. DEDUCTSPEED = 0.8 # reduces score by 1 point every DEDUCTSPEED seconds. \n 40.  \n 41. #             R    G    B \n 42. PURPLE    = (255,   0, 255) \n 43. LIGHTBLUE = (170, 190, 255) \n 44. BLUE      = (  0,   0, 255) \n 45. RED       = (255, 100, 100) \n 46. BLACK     = (  0,   0,   0) \n 47. BROWN     = ( 85,  65,   0) \n 48. HIGHLIGHTCOLOR = PURPLE # color of the selected gem's border \n 49. BGCOLOR = LIGHTBLUE # background color on the screen \n 50. GRIDCOLOR = BLUE # color of the game board \n 51. GAMEOVERCOLOR = RED # color of the \"Game over\" text. \n 52. GAMEOVERBGCOLOR = BLACK # background color of the \"Game over\" text. \n 53. SCORECOLOR = BROWN # color of the text for the player's score \n 54.  \n 55. # The amount of space to the sides of the board to the edge of the window \n 56. # is used several times, so calculate it once here and store in variables. \n 57. XMARGIN = int((WINDOWWIDTH - GEMIMAGESIZE * BOARDWIDTH) / 2) \n 58. YMARGIN = int((WINDOWHEIGHT - GEMIMAGESIZE * BOARDHEIGHT) / 2) \n 59.  \n 60. # constants for direction values \n 61. UP = 'up' \n 62. DOWN = 'down' \n 63. LEFT = 'left' \n",
      "content_length": 2144,
      "extraction_method": "Direct"
    },
    {
      "page_number": 347,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    329 \n \n 64. RIGHT = 'right' \n 65.  \n 66. EMPTY_SPACE = -1 # an arbitrary, nonpositive value \n 67. ROWABOVEBOARD = 'row above board' # an arbitrary, noninteger value \n 68.  \n 69. def main(): \n 70.     global FPSCLOCK, DISPLAYSURF, GEMIMAGES, GAMESOUNDS, BASICFONT, \nBOARDRECTS \n 71.  \n 72.     # Initial set up. \n 73.     pygame.init() \n 74.     FPSCLOCK = pygame.time.Clock() \n 75.     DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n 76.     pygame.display.set_caption('Gemgem') \n 77.     BASICFONT = pygame.font.Font('freesansbold.ttf', 36) \n 78.  \n 79.     # Load the images \n 80.     GEMIMAGES = [] \n 81.     for i in range(1, NUMGEMIMAGES+1): \n 82.         gemImage = pygame.image.load('gem%s.png' % i) \n 83.         if gemImage.get_size() != (GEMIMAGESIZE, GEMIMAGESIZE): \n 84.             gemImage = pygame.transform.smoothscale(gemImage, \n(GEMIMAGESIZE, GEMIMAGESIZE)) \n 85.         GEMIMAGES.append(gemImage) \n 86.  \n 87.     # Load the sounds. \n 88.     GAMESOUNDS = {} \n 89.     GAMESOUNDS['bad swap'] = pygame.mixer.Sound('badswap.wav') \n 90.     GAMESOUNDS['match'] = [] \n 91.     for i in range(NUMMATCHSOUNDS): \n 92.         GAMESOUNDS['match'].append(pygame.mixer.Sound('match%s.wav' % i)) \n 93.  \n 94.     # Create pygame.Rect objects for each board space to \n 95.     # do board-coordinate-to-pixel-coordinate conversions. \n 96.     BOARDRECTS = [] \n 97.     for x in range(BOARDWIDTH): \n 98.         BOARDRECTS.append([]) \n 99.         for y in range(BOARDHEIGHT): \n100.             r = pygame.Rect((XMARGIN + (x * GEMIMAGESIZE), \n101.                              YMARGIN + (y * GEMIMAGESIZE), \n102.                              GEMIMAGESIZE, \n103.                              GEMIMAGESIZE)) \n104.             BOARDRECTS[x].append(r) \n105.  \n106.     while True: \n107.         runGame() \n",
      "content_length": 1862,
      "extraction_method": "Direct"
    },
    {
      "page_number": 348,
      "chapter": null,
      "content": "330    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n108.  \n109.  \n110. def runGame(): \n111.     # Plays through a single game. When the game is over, this function \nreturns. \n112.  \n113.     # initialize the board \n114.     gameBoard = getBlankBoard() \n115.     score = 0 \n116.     fillBoardAndAnimate(gameBoard, [], score) # Drop the initial gems. \n117.  \n118.     # initialize variables for the start of a new game \n119.     firstSelectedGem = None \n120.     lastMouseDownX = None \n121.     lastMouseDownY = None \n122.     gameIsOver = False \n123.     lastScoreDeduction = time.time() \n124.     clickContinueTextSurf = None \n125.  \n126.     while True: # main game loop \n127.         clickedSpace = None \n128.         for event in pygame.event.get(): # event handling loop \n129.             if event.type == QUIT or (event.type == KEYUP and event.key == \nK_ESCAPE): \n130.                 pygame.quit() \n131.                 sys.exit() \n132.             elif event.type == KEYUP and event.key == K_BACKSPACE: \n133.                 return # start a new game \n134.  \n135.             elif event.type == MOUSEBUTTONUP: \n136.                 if gameIsOver: \n137.                     return # after games ends, click to start a new game \n138.  \n139.                 if event.pos == (lastMouseDownX, lastMouseDownY): \n140.                     # This event is a mouse click, not the end of a mouse \ndrag. \n141.                     clickedSpace = checkForGemClick(event.pos) \n142.                 else: \n143.                     # this is the end of a mouse drag \n144.                     firstSelectedGem = checkForGemClick((lastMouseDownX, \nlastMouseDownY)) \n145.                     clickedSpace = checkForGemClick(event.pos) \n146.                     if not firstSelectedGem or not clickedSpace: \n147.                         # if not part of a valid drag, deselect both \n148.                         firstSelectedGem = None \n149.                         clickedSpace = None \n",
      "content_length": 2024,
      "extraction_method": "Direct"
    },
    {
      "page_number": 349,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    331 \n \n150.             elif event.type == MOUSEBUTTONDOWN: \n151.                 # this is the start of a mouse click or mouse drag \n152.                 lastMouseDownX, lastMouseDownY = event.pos \n153.  \n154.         if clickedSpace and not firstSelectedGem: \n155.             # This was the first gem clicked on. \n156.             firstSelectedGem = clickedSpace \n157.         elif clickedSpace and firstSelectedGem: \n158.             # Two gems have been clicked on and selected. Swap the gems. \n159.             firstSwappingGem, secondSwappingGem = \ngetSwappingGems(gameBoard, firstSelectedGem, clickedSpace) \n160.             if firstSwappingGem == None and secondSwappingGem == None: \n161.                 # If both are None, then the gems were not adjacent \n162.                 firstSelectedGem = None # deselect the first gem \n163.                 continue \n164.  \n165.             # Show the swap animation on the screen. \n166.             boardCopy = getBoardCopyMinusGems(gameBoard, \n(firstSwappingGem, secondSwappingGem)) \n167.             animateMovingGems(boardCopy, [firstSwappingGem, \nsecondSwappingGem], [], score) \n168.  \n169.             # Swap the gems in the board data structure. \n170.             gameBoard[firstSwappingGem['x']][firstSwappingGem['y']] = \nsecondSwappingGem['imageNum'] \n171.             gameBoard[secondSwappingGem['x']][secondSwappingGem['y']] = \nfirstSwappingGem['imageNum'] \n172.  \n173.             # See if this is a matching move. \n174.             matchedGems = findMatchingGems(gameBoard) \n175.             if matchedGems == []: \n176.                 # Was not a matching move; swap the gems back \n177.                 GAMESOUNDS['bad swap'].play() \n178.                 animateMovingGems(boardCopy, [firstSwappingGem, \nsecondSwappingGem], [], score) \n179.                 gameBoard[firstSwappingGem['x']][firstSwappingGem['y']] = \nfirstSwappingGem['imageNum'] \n180.                 gameBoard[secondSwappingGem['x']][secondSwappingGem['y']] \n= secondSwappingGem['imageNum'] \n181.             else: \n182.                 # This was a matching move. \n183.                 scoreAdd = 0 \n184.                 while matchedGems != []: \n185.                     # Remove matched gems, then pull down the board. \n186.  \n",
      "content_length": 2296,
      "extraction_method": "Direct"
    },
    {
      "page_number": 350,
      "chapter": null,
      "content": "332    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n187.                     # points is a list of dicts that tells \nfillBoardAndAnimate() \n188.                     # where on the screen to display text to show how many  \n189.                     # points the player got. points is a list because if  \n190.                     # the player gets multiple matches, then multiple \npoints text should appear. \n191.                     points = [] \n192.                     for gemSet in matchedGems: \n193.                         scoreAdd += (10 + (len(gemSet) - 3) * 10) \n194.                         for gem in gemSet: \n195.                             gameBoard[gem[0]][gem[1]] = EMPTY_SPACE \n196.                         points.append({'points': scoreAdd, \n197.                                        'x': gem[0] * GEMIMAGESIZE + \nXMARGIN, \n198.                                        'y': gem[1] * GEMIMAGESIZE + \nYMARGIN}) \n199.                     random.choice(GAMESOUNDS['match']).play() \n200.                     score += scoreAdd \n201.  \n202.                     # Drop the new gems. \n203.                     fillBoardAndAnimate(gameBoard, points, score) \n204.  \n205.                     # Check if there are any new matches. \n206.                     matchedGems = findMatchingGems(gameBoard) \n207.             firstSelectedGem = None \n208.  \n209.             if not canMakeMove(gameBoard): \n210.                 gameIsOver = True \n211.  \n212.         # Draw the board. \n213.         DISPLAYSURF.fill(BGCOLOR) \n214.         drawBoard(gameBoard) \n215.         if firstSelectedGem != None: \n216.             highlightSpace(firstSelectedGem['x'], firstSelectedGem['y']) \n217.         if gameIsOver: \n218.             if clickContinueTextSurf == None: \n219.                 # Only render the text once. In future iterations, just \n220.                 # use the Surface object already in clickContinueTextSurf \n221.                 clickContinueTextSurf = BASICFONT.render('Final Score: %s \n(Click to continue)' % (score), 1, GAMEOVERCOLOR, GAMEOVERBGCOLOR) \n222.                 clickContinueTextRect = clickContinueTextSurf.get_rect() \n223.                 clickContinueTextRect.center = int(WINDOWWIDTH / 2), \nint(WINDOWHEIGHT / 2) \n224.             DISPLAYSURF.blit(clickContinueTextSurf, clickContinueTextRect) \n225.         elif score > 0 and time.time() - lastScoreDeduction > DEDUCTSPEED: \n226.             # score drops over time \n",
      "content_length": 2496,
      "extraction_method": "Direct"
    },
    {
      "page_number": 351,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    333 \n \n227.             score -= 1 \n228.             lastScoreDeduction = time.time() \n229.         drawScore(score) \n230.         pygame.display.update() \n231.         FPSCLOCK.tick(FPS) \n232.  \n233.  \n234. def getSwappingGems(board, firstXY, secondXY): \n235.     # If the gems at the (X, Y) coordinates of the two gems are adjacent, \n236.     # then their 'direction' keys are set to the appropriate direction \n237.     # value to be swapped with each other. \n238.     # Otherwise, (None, None) is returned. \n239.     firstGem = {'imageNum': board[firstXY['x']][firstXY['y']], \n240.                 'x': firstXY['x'], \n241.                 'y': firstXY['y']} \n242.     secondGem = {'imageNum': board[secondXY['x']][secondXY['y']], \n243.                  'x': secondXY['x'], \n244.                  'y': secondXY['y']} \n245.     highlightedGem = None \n246.     if firstGem['x'] == secondGem['x'] + 1 and firstGem['y'] == \nsecondGem['y']: \n247.         firstGem['direction'] = LEFT \n248.         secondGem['direction'] = RIGHT \n249.     elif firstGem['x'] == secondGem['x'] - 1 and firstGem['y'] == \nsecondGem['y']: \n250.         firstGem['direction'] = RIGHT \n251.         secondGem['direction'] = LEFT \n252.     elif firstGem['y'] == secondGem['y'] + 1 and firstGem['x'] == \nsecondGem['x']: \n253.         firstGem['direction'] = UP \n254.         secondGem['direction'] = DOWN \n255.     elif firstGem['y'] == secondGem['y'] - 1 and firstGem['x'] == \nsecondGem['x']: \n256.         firstGem['direction'] = DOWN \n257.         secondGem['direction'] = UP \n258.     else: \n259.         # These gems are not adjacent and can't be swapped. \n260.         return None, None \n261.     return firstGem, secondGem \n262.  \n263.  \n264. def getBlankBoard(): \n265.     # Create and return a blank board data structure. \n266.     board = [] \n267.     for x in range(BOARDWIDTH): \n268.         board.append([EMPTY_SPACE] * BOARDHEIGHT) \n",
      "content_length": 1952,
      "extraction_method": "Direct"
    },
    {
      "page_number": 352,
      "chapter": null,
      "content": "334    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n269.     return board \n270.  \n271.  \n272. def canMakeMove(board): \n273.     # Return True if the board is in a state where a matching \n274.     # move can be made on it. Otherwise return False. \n275.  \n276.     # The patterns in oneOffPatterns represent gems that are configured \n277.     # in a way where it only takes one move to make a triplet. \n278.     oneOffPatterns = (((0,1), (1,0), (2,0)), \n279.                       ((0,1), (1,1), (2,0)), \n280.                       ((0,0), (1,1), (2,0)), \n281.                       ((0,1), (1,0), (2,1)), \n282.                       ((0,0), (1,0), (2,1)), \n283.                       ((0,0), (1,1), (2,1)), \n284.                       ((0,0), (0,2), (0,3)), \n285.                       ((0,0), (0,1), (0,3))) \n286.  \n287.     # The x and y variables iterate over each space on the board. \n288.     # If we use + to represent the currently iterated space on the \n289.     # board, then this pattern: ((0,1), (1,0), (2,0))refers to identical \n290.     # gems being set up like this: \n291.     # \n292.     #     +A \n293.     #     B \n294.     #     C \n295.     # \n296.     # That is, gem A is offset from the + by (0,1), gem B is offset \n297.     # by (1,0), and gem C is offset by (2,0). In this case, gem A can \n298.     # be swapped to the left to form a vertical three-in-a-row triplet. \n299.     # \n300.     # There are eight possible ways for the gems to be one move \n301.     # away from forming a triple, hence oneOffPattern has 8 patterns. \n302.  \n303.     for x in range(BOARDWIDTH): \n304.         for y in range(BOARDHEIGHT): \n305.             for pat in oneOffPatterns: \n306.                 # check each possible pattern of \"match in next move\" to \n307.                 # see if a possible move can be made. \n308.                 if (getGemAt(board, x+pat[0][0], y+pat[0][1]) == \\ \n309.                     getGemAt(board, x+pat[1][0], y+pat[1][1]) == \\ \n310.                     getGemAt(board, x+pat[2][0], y+pat[2][1]) != None) or \n\\ \n311.                    (getGemAt(board, x+pat[0][1], y+pat[0][0]) == \\ \n312.                     getGemAt(board, x+pat[1][1], y+pat[1][0]) == \\ \n313.                     getGemAt(board, x+pat[2][1], y+pat[2][0]) != None): \n",
      "content_length": 2322,
      "extraction_method": "Direct"
    },
    {
      "page_number": 353,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    335 \n \n314.                     return True # return True the first time you find a \npattern \n315.     return False \n316.  \n317.  \n318. def drawMovingGem(gem, progress): \n319.     # Draw a gem sliding in the direction that its 'direction' key \n320.     # indicates. The progress parameter is a number from 0 (just \n321.     # starting) to 100 (slide complete). \n322.     movex = 0 \n323.     movey = 0 \n324.     progress *= 0.01 \n325.  \n326.     if gem['direction'] == UP: \n327.         movey = -int(progress * GEMIMAGESIZE) \n328.     elif gem['direction'] == DOWN: \n329.         movey = int(progress * GEMIMAGESIZE) \n330.     elif gem['direction'] == RIGHT: \n331.         movex = int(progress * GEMIMAGESIZE) \n332.     elif gem['direction'] == LEFT: \n333.         movex = -int(progress * GEMIMAGESIZE) \n334.  \n335.     basex = gem['x'] \n336.     basey = gem['y'] \n337.     if basey == ROWABOVEBOARD: \n338.         basey = -1 \n339.  \n340.     pixelx = XMARGIN + (basex * GEMIMAGESIZE) \n341.     pixely = YMARGIN + (basey * GEMIMAGESIZE) \n342.     r = pygame.Rect( (pixelx + movex, pixely + movey, GEMIMAGESIZE, \nGEMIMAGESIZE) ) \n343.     DISPLAYSURF.blit(GEMIMAGES[gem['imageNum']], r) \n344.  \n345.  \n346. def pullDownAllGems(board): \n347.     # pulls down gems on the board to the bottom to fill in any gaps \n348.     for x in range(BOARDWIDTH): \n349.         gemsInColumn = [] \n350.         for y in range(BOARDHEIGHT): \n351.             if board[x][y] != EMPTY_SPACE: \n352.                 gemsInColumn.append(board[x][y]) \n353.         board[x] = ([EMPTY_SPACE] * (BOARDHEIGHT - len(gemsInColumn))) + \ngemsInColumn \n354.  \n355.  \n356. def getGemAt(board, x, y): \n",
      "content_length": 1699,
      "extraction_method": "Direct"
    },
    {
      "page_number": 354,
      "chapter": null,
      "content": "336    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n357.     if x < 0 or y < 0 or x >= BOARDWIDTH or y >= BOARDHEIGHT: \n358.         return None \n359.     else: \n360.         return board[x][y] \n361.  \n362.  \n363. def getDropSlots(board): \n364.     # Creates a \"drop slot\" for each column and fills the slot with a \n365.     # number of gems that that column is lacking. This function assumes \n366.     # that the gems have been gravity dropped already. \n367.     boardCopy = copy.deepcopy(board) \n368.     pullDownAllGems(boardCopy) \n369.  \n370.     dropSlots = [] \n371.     for i in range(BOARDWIDTH): \n372.         dropSlots.append([]) \n373.  \n374.     # count the number of empty spaces in each column on the board \n375.     for x in range(BOARDWIDTH): \n376.         for y in range(BOARDHEIGHT-1, -1, -1): # start from bottom, going \nup \n377.             if boardCopy[x][y] == EMPTY_SPACE: \n378.                 possibleGems = list(range(len(GEMIMAGES))) \n379.                 for offsetX, offsetY in ((0, -1), (1, 0), (0, 1), (-1, \n0)): \n380.                     # Narrow down the possible gems we should put in the \n381.                     # blank space so we don't end up putting an two of \n382.                     # the same gems next to each other when they drop. \n383.                     neighborGem = getGemAt(boardCopy, x + offsetX, y + \noffsetY) \n384.                     if neighborGem != None and neighborGem in \npossibleGems: \n385.                         possibleGems.remove(neighborGem) \n386.  \n387.                 newGem = random.choice(possibleGems) \n388.                 boardCopy[x][y] = newGem \n389.                 dropSlots[x].append(newGem) \n390.     return dropSlots \n391.  \n392.  \n393. def findMatchingGems(board): \n394.     gemsToRemove = [] # a list of lists of gems in matching triplets that \nshould be removed \n395.     boardCopy = copy.deepcopy(board) \n396.  \n397.     # loop through each space, checking for 3 adjacent identical gems \n",
      "content_length": 2024,
      "extraction_method": "Direct"
    },
    {
      "page_number": 355,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    337 \n \n398.     for x in range(BOARDWIDTH): \n399.         for y in range(BOARDHEIGHT): \n400.             # look for horizontal matches \n401.             if getGemAt(boardCopy, x, y) == getGemAt(boardCopy, x + 1, y) \n== getGemAt(boardCopy, x + 2, y) and getGemAt(boardCopy, x, y) != EMPTY_SPACE: \n402.                 targetGem = boardCopy[x][y] \n403.                 offset = 0 \n404.                 removeSet = [] \n405.                 while getGemAt(boardCopy, x + offset, y) == targetGem: \n406.                     # keep checking, in case there's more than 3 gems in a \nrow \n407.                     removeSet.append((x + offset, y)) \n408.                     boardCopy[x + offset][y] = EMPTY_SPACE \n409.                     offset += 1 \n410.                 gemsToRemove.append(removeSet) \n411.  \n412.             # look for vertical matches \n413.             if getGemAt(boardCopy, x, y) == getGemAt(boardCopy, x, y + 1) \n== getGemAt(boardCopy, x, y + 2) and getGemAt(boardCopy, x, y) != EMPTY_SPACE: \n414.                 targetGem = boardCopy[x][y] \n415.                 offset = 0 \n416.                 removeSet = [] \n417.                 while getGemAt(boardCopy, x, y + offset) == targetGem: \n418.                     # keep checking if there's more than 3 gems in a row \n419.                     removeSet.append((x, y + offset)) \n420.                     boardCopy[x][y + offset] = EMPTY_SPACE \n421.                     offset += 1 \n422.                 gemsToRemove.append(removeSet) \n423.  \n424.     return gemsToRemove \n425.  \n426.  \n427. def highlightSpace(x, y): \n428.     pygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, BOARDRECTS[x][y], 4) \n429.  \n430.  \n431. def getDroppingGems(board): \n432.     # Find all the gems that have an empty space below them \n433.     boardCopy = copy.deepcopy(board) \n434.     droppingGems = [] \n435.     for x in range(BOARDWIDTH): \n436.         for y in range(BOARDHEIGHT - 2, -1, -1): \n437.             if boardCopy[x][y + 1] == EMPTY_SPACE and boardCopy[x][y] != \nEMPTY_SPACE: \n438.                 # This space drops if not empty but the space below it is \n",
      "content_length": 2144,
      "extraction_method": "Direct"
    },
    {
      "page_number": 356,
      "chapter": null,
      "content": "338    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n439.                 droppingGems.append( {'imageNum': boardCopy[x][y], 'x': x, \n'y': y, 'direction': DOWN} ) \n440.                 boardCopy[x][y] = EMPTY_SPACE \n441.     return droppingGems \n442.  \n443.  \n444. def animateMovingGems(board, gems, pointsText, score): \n445.     # pointsText is a dictionary with keys 'x', 'y', and 'points' \n446.     progress = 0 # progress at 0 represents beginning, 100 means finished. \n447.     while progress < 100: # animation loop \n448.         DISPLAYSURF.fill(BGCOLOR) \n449.         drawBoard(board) \n450.         for gem in gems: # Draw each gem. \n451.             drawMovingGem(gem, progress) \n452.         drawScore(score) \n453.         for pointText in pointsText: \n454.             pointsSurf = BASICFONT.render(str(pointText['points']), 1, \nSCORECOLOR) \n455.             pointsRect = pointsSurf.get_rect() \n456.             pointsRect.center = (pointText['x'], pointText['y']) \n457.             DISPLAYSURF.blit(pointsSurf, pointsRect) \n458.  \n459.         pygame.display.update() \n460.         FPSCLOCK.tick(FPS) \n461.         progress += MOVERATE # progress the animation a little bit more \nfor the next frame \n462.  \n463.  \n464. def moveGems(board, movingGems): \n465.     # movingGems is a list of dicts with keys x, y, direction, imageNum \n466.     for gem in movingGems: \n467.         if gem['y'] != ROWABOVEBOARD: \n468.             board[gem['x']][gem['y']] = EMPTY_SPACE \n469.             movex = 0 \n470.             movey = 0 \n471.             if gem['direction'] == LEFT: \n472.                 movex = -1 \n473.             elif gem['direction'] == RIGHT: \n474.                 movex = 1 \n475.             elif gem['direction'] == DOWN: \n476.                 movey = 1 \n477.             elif gem['direction'] == UP: \n478.                 movey = -1 \n479.             board[gem['x'] + movex][gem['y'] + movey] = gem['imageNum'] \n480.         else: \n481.             # gem is located above the board (where new gems come from) \n",
      "content_length": 2083,
      "extraction_method": "Direct"
    },
    {
      "page_number": 357,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    339 \n \n482.             board[gem['x']][0] = gem['imageNum'] # move to top row \n483.  \n484.  \n485. def fillBoardAndAnimate(board, points, score): \n486.     dropSlots = getDropSlots(board) \n487.     while dropSlots != [[]] * BOARDWIDTH: \n488.         # do the dropping animation as long as there are more gems to drop \n489.         movingGems = getDroppingGems(board) \n490.         for x in range(len(dropSlots)): \n491.             if len(dropSlots[x]) != 0: \n492.                 # cause the lowest gem in each slot to begin moving in the \nDOWN direction \n493.                 movingGems.append({'imageNum': dropSlots[x][0], 'x': x, \n'y': ROWABOVEBOARD, 'direction': DOWN}) \n494.  \n495.         boardCopy = getBoardCopyMinusGems(board, movingGems) \n496.         animateMovingGems(boardCopy, movingGems, points, score) \n497.         moveGems(board, movingGems) \n498.  \n499.         # Make the next row of gems from the drop slots \n500.         # the lowest by deleting the previous lowest gems. \n501.         for x in range(len(dropSlots)): \n502.             if len(dropSlots[x]) == 0: \n503.                 continue \n504.             board[x][0] = dropSlots[x][0] \n505.             del dropSlots[x][0] \n506.  \n507.  \n508. def checkForGemClick(pos): \n509.     # See if the mouse click was on the board \n510.     for x in range(BOARDWIDTH): \n511.         for y in range(BOARDHEIGHT): \n512.             if BOARDRECTS[x][y].collidepoint(pos[0], pos[1]): \n513.                 return {'x': x, 'y': y} \n514.     return None # Click was not on the board. \n515.  \n516.  \n517. def drawBoard(board): \n518.     for x in range(BOARDWIDTH): \n519.         for y in range(BOARDHEIGHT): \n520.             pygame.draw.rect(DISPLAYSURF, GRIDCOLOR, BOARDRECTS[x][y], 1) \n521.             gemToDraw = board[x][y] \n522.             if gemToDraw != EMPTY_SPACE: \n523.                 DISPLAYSURF.blit(GEMIMAGES[gemToDraw], BOARDRECTS[x][y]) \n524.  \n525.  \n",
      "content_length": 1967,
      "extraction_method": "Direct"
    },
    {
      "page_number": 358,
      "chapter": null,
      "content": "340    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n526. def getBoardCopyMinusGems(board, gems): \n527.     # Creates and returns a copy of the passed board data structure, \n528.     # with the gems in the \"gems\" list removed from it. \n529.     # \n530.     # Gems is a list of dicts, with keys x, y, direction, imageNum \n531.  \n532.     boardCopy = copy.deepcopy(board) \n533.  \n534.     # Remove some of the gems from this board data structure copy. \n535.     for gem in gems: \n536.         if gem['y'] != ROWABOVEBOARD: \n537.             boardCopy[gem['x']][gem['y']] = EMPTY_SPACE \n538.     return boardCopy \n539.  \n540.  \n541. def drawScore(score): \n542.     scoreImg = BASICFONT.render(str(score), 1, SCORECOLOR) \n543.     scoreRect = scoreImg.get_rect() \n544.     scoreRect.bottomleft = (10, WINDOWHEIGHT - 6) \n545.     DISPLAYSURF.blit(scoreImg, scoreRect) \n546.  \n547.  \n548. if __name__ == '__main__': \n549.     main() \nSummary \nI hope these game programs have given you your own ideas about what games you’d like to make \nand how you can write the code for them. Even if you don’t have any ideas of your own, it’s great \npractice to try to program clones of other games you’ve played. \nHere are several websites that can teach you more about programming Python: \n \nhttp://pygame.org – The official Pygame website has the source code to hundreds of \ngames that people have written that make use of the Pygame library. You can learn a lot \nby downloading and reading other people’s source code. \n \nhttp://python.org/doc/ - More Python tutorials and the documentation of all the Python \nmodules and functions. \n \nhttp://pygame.org/docs/ - Complete documentation on the modules and functions for \nPygame \n \nhttp://reddit.com/r/learnpython and http://reddit.com/r/learnprogramming have several \nusers that could help you with finding resources to learn programming. \n",
      "content_length": 1925,
      "extraction_method": "Direct"
    },
    {
      "page_number": 359,
      "chapter": null,
      "content": "Chapter 10 – Four Extra Games    341 \n \n \nhttp://inventwithpython.com/pygame - This book's website, which includes all the source \ncode for these programs and additional information. This site also has the image and \nsound files used in the Pygame programs.  \n \nhttp://inventwithpython.com - The website for the book ―Invent Your Own Computer \nGames with Python‖, which covers basic Python programming. \n \nhttp://invpy.com/wiki - A wiki that covers individual Python programming concepts that \nyou can look up if you need to learn about something specific. \n \nhttp://invpy.com/traces - A web application that helps you trace through the execution of \nthe programs in this book, step by step. \n \nhttp://invpy.com/videos - Videos that accompany the programs in this book. \n \nhttp://gamedevlessons.com - A helpful website about how to design and program video \ngames. \n \nal@inventwithpython.com - My email address. Feel free to email me your questions \nabout this book or about Python programming. \nOr you can find out more about Python by searching the World Wide Web. Go to the search \nwebsite http://google.com and search for ―Python programming‖ or ―Python tutorials‖ to find \nweb sites that can teach you more about Python programming. \nNow get going and invent your own games. And good luck! \n \n \n",
      "content_length": 1307,
      "extraction_method": "Direct"
    },
    {
      "page_number": 360,
      "chapter": null,
      "content": "342    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nGLOSSARY \nAlpha Value - The amount of transparency for a color. In Pygame, alpha values range from 0 \n(completely transparent) to 255 (completely opaque). \nAnti-Aliasing - A technique for making shapes look smoother and less blocky by adding fuzzy \ncolors to their edges. Anti-aliased drawings look smooth. Aliased drawings look blocky. \nAttributes - A variable that is part of an object. For example, Rect objects have members such as \ntop and left which hold integer values for the Rect object. \nBackwards Compatibility - Writing code that is compatible with older versions of software. \nPython version 3 has some backwards-incompatible features with Python version 2, but it is \npossible to write Python 3 programs that are backwards-compatible with Python 2. \nBase Case - In recursion, the base case is the condition that stops further recursive function calls. \nA base case is necessary to prevent stack overflow errors. \nBlitting - A word that means copying the image on one Surface object to another. In \nprogramming in general, it means to copy one image to another image. \nBounding Rectangle - The smallest rectangle that can be drawn around another shape. \nCamera - A view of a particular part of the game world. Cameras are used when the game world \nis too large to fit on the player's screen. \nCaption - In programming, the caption is the text on the title bar of the window. In Pygame, the \ncaption can be set with the pygame.display.set_caption() function. \nCLI - See, Command Line Interface \nCommand Line Interface - A program that the user can use by seeing text on the screen and \ntyping text through the keyboard. Old computers used to be able to only run CLI programs, but \nnew computers have Graphical User Interfaces. \nConstructor Function - The function that creates a new object. In Python, these functions have \nthe same name as the kind of objects they produce. For example, pygame.Rect() creates Rect \nobjects. \nDisplay Surface - The Surface object returned by the call to \npygame.display.set_mode(). This Surface object is special because anything drawn on it \n",
      "content_length": 2191,
      "extraction_method": "Direct"
    },
    {
      "page_number": 361,
      "chapter": null,
      "content": "Glossary    343 \n \nwith the Pygame drawing or blitting functions will appear on the screen when \npygame.display.update() is called. \nDrawing Primitives - The name for the basic shape-drawing functions in Pygame. Drawing \nprimitives include rectangles, lines, and ellipses. Drawing primitives do not include images like \nthe ones in .png or .jpg files. \nEvent Handling - The code that performs actions in response to Event objects that have been \ngenerated by the user, such as key presses or mouse clicks. \nEvent Handling Loop - The event handling code is usually inside a loop to handle each of the \nevents that have been generated since the last time the event handling loop was executed. \nEvent Queue - When events such as mouse clicks or key presses happen, Pygame stores them in \nan internal queue data structure. Events can be removed and retrieved from the event queue by \ncalling pygame.event.get(). \nFPS - See, Frames Per Second \nFrame - A single image that is displayed on the screen as part of an animation. Animated \ngraphics will be composed of many frames, each shown for a split second. \nFrame Rate - See, Refresh Rate \nFrames Per Second - The measure of how many frames of an animation are displayed per \nsecond. It is common for games to be run at 30 frames per second or more. \nGame Loop - The game loop contains code that performs event handling, updates the game \nworld's state, and draws the game world's state to the screen. This is done many times a second. \nGame State - The entire collection of values that make up the game world. This can include \ninformation about the player's character, which pieces are on a board, or the score and level \nnumber. \nGraphical User Interface - A program that displays graphics to the user for output and can \naccept keyboard presses and mouse clicks for input. \nGUI - See, Graphical User Interface \nImmutable - Not changeable or modifiable. In Python, list values are mutable and tuple values \nare immutable. \nInteractive Shell - A program (part of IDLE) that executes Python instructions one at a time. The \ninteractive shell is a good way to experiment with what a line of code does. \n",
      "content_length": 2148,
      "extraction_method": "Direct"
    },
    {
      "page_number": 362,
      "chapter": null,
      "content": "344    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \nInterpreter - The software that executes instructions written in the Python programming \nlanguage. On Windows, this is python.exe. When someone says, \"Python runs this program\", they \nmean \"the Python interpreter software runs this program.\" \nMagic Numbers - Integers or floating-point values used in a program without explanation. Magic \nnumbers should be replaced by constant variables with descriptive names to increase readability. \nMain Loop - See, Game Loop \nMember Variable - See, Attributes. \nModulus Operator - In Python, the modulus operator is the % sign. It performs \"remainder\" \narithmetic. For example, since 22 / 7 is ―3 remainder 1‖, then 22 % 7 is 1. \nMultidimensional - Having more than one dimension. In Python, this usually refers to when a \nlist contains another list, or a dictionary contains a tuple (which in turn could contain other lists, \ntuples, or dictionaries.) \nMutable - Changeable or modifiable. In Python, list values are mutable and tuple values are \nimmutable. \nPi - The number of diameter lengths of a circle that can fit along the outside circumference. Pi is \nthe same number no matter what the size of the circle is. This value is available in the math \nmodule as math.pi, which is the float value 3.1415926535897931. \nPixels - Stands for \"picture element\". A pixel is a single square of color on the computer screen. \nThe screen is made up of hundreds of thousands of pixels which can be set to different colors to \nform an image. \nPoints - A point in Python is usually represented as a tuple of two integers (or float values) to \nrepresent the X and Y coordinates of a position on a 2D surface. \nProperties - See, Attributes. \nReal-time - A program that runs continuously and does not wait for the player to do something is \nsaid to run in real-time. \nRecursive Call - The function call in a recursive function that calls that same function. \nRecursive Function - A function that calls itself. \nRefresh Rate - The frequency that the computer screen updates its image. A high or fast refresh \nrate will make animations appear smoothly, while a low or slow refresh rate will make animation \nlook choppy. Refresh rate is measured in FPS or hertz (which mean the same thing). \n",
      "content_length": 2318,
      "extraction_method": "Direct"
    },
    {
      "page_number": 363,
      "chapter": null,
      "content": "Glossary    345 \n \nRGB Values - An RGB value is an exact value of a particular color. RGB stands for red, green \nblue. In Pygame, an RGB value is a tuple of three integers (all between 0 and 255) which \nrepresent the amount of red, green, and blue are in the color. \nShell - See, Interactive Shell. \nSine - A mathematical function that produces a wavey line when drawn on a graph. Python has a \nsine function in the math module: math.sin(). \nSprites - A name given for a picture of something. Games commonly have a sprite for each kind \nof object in the game. \nStack Overflow - An error caused when a recursive function does not have a base case. \nSyntactic Sugar - A bit of code that is written to make the program more readable, even though \nit isn't necessary for the program to work. \nTile Sprites - Tiles are a kind of sprite designed to be drawn on a 2D grid. They are usually \nimages of the background, such as floors or walls. \nTitle Bar - The bar along the top of programs that usually contain the program's caption and \nclose button. The style of the title bar varies between operating systems. \nX-axis - The horizontal arrangement of numbers used in cartesian coordinate systems. The X \ncoordinates get smaller going to the left and larger going to the right. \nY-axis - The vertical arrangement of numbers used in cartesian coordinate systems. The Y \ncoordinates get smaller going up and larger going down. (This is the opposite of how the Y-axis \nworks in mathematics.) \n \n",
      "content_length": 1485,
      "extraction_method": "Direct"
    },
    {
      "page_number": 364,
      "chapter": null,
      "content": "346    http://inventwithpython.com/pygame \n \nEmail questions to the author: al@inventwithpython.com \n \n \n \n",
      "content_length": 107,
      "extraction_method": "Direct"
    },
    {
      "page_number": 365,
      "chapter": null,
      "content": "About the Author    347 \n \nABOUT THE AUTHOR \n \nAlbert Sweigart (but you can call him Al), is a software developer in San Francisco, California \nwho enjoys bicycling, volunteering, haunting coffee shops, and making useful software. ―Making \nGames with Python & Pygame‖ is his second book. \nHis first book, ―Invent Your Own Computer Games with Python‖ can be read online at \nhttp://inventwithpython.com. \nHe is originally from Houston, Texas. He finally put his University of Texas at Austin computer \nscience degree in a frame. He laughs out loud when watching park squirrels, which makes people \nthink he’s a simpleton. \n \nEmail: al@inventwithpython.com \n \nBlog: http://coffeeghost.net \n \nTwitter: @AlSweigart \n",
      "content_length": 714,
      "extraction_method": "Direct"
    }
  ],
  "enrichment": {
    "version": "1.0.0",
    "generated_by": "generate_chapter_metadata.py",
    "contains": [
      "keywords",
      "concepts",
      "summary"
    ]
  }
}