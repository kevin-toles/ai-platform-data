{
  "metadata": {
    "title": "Python Distilled",
    "author": "David M. Beazley",
    "publisher": "Addison-Wesley Professional",
    "edition": "1st Edition",
    "isbn": "978-0-134-17331-4",
    "total_pages": 355,
    "conversion_date": "2025-11-05T18:41:40.225817",
    "conversion_method": "PyMuPDF + OCR fallback"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "detection_method": "topic_boundary",
      "chapter_number": 1,
      "summary": "This chapter covers segment 1 (pages 1-8). Key topics include objects, operators, and operations. Beazley\n\nPp Author of Python Essential Reference Python Distilled This page intentionally left blank Python Distilled\nDavid M.",
      "keywords": [
        "Protocol",
        "Python",
        "Python Distilled",
        "Expressions",
        "Arguments",
        "Operators",
        "Distilled",
        "Control",
        "Operations",
        "Exceptions",
        "Final Words",
        "Pearson Education",
        "Object",
        "Data",
        "Keyword Arguments"
      ],
      "concepts": [
        "objects",
        "operators",
        "operations",
        "protocols",
        "sales",
        "python",
        "pythonic",
        "functions",
        "function",
        "exceptions"
      ],
      "similar_chapters": [
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 6,
          "title": "Segment 6 (pages 43-52)",
          "relevance_score": 0.69,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 0.67,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 40,
          "title": "Segment 40 (pages 420-428)",
          "relevance_score": 0.67,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.66,
          "method": "api"
        }
      ]
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 9-18)",
      "start_page": 9,
      "end_page": 18,
      "detection_method": "topic_boundary",
      "chapter_number": 2,
      "summary": "This chapter covers segment 2 (pages 9-18). Key topics include modules, python, and typing.",
      "keywords": [
        "Python",
        "Module",
        "Python Essential Reference",
        "world",
        "Functions",
        "Package",
        "Final Words",
        "Program",
        "Python programs",
        "Type",
        "Generators",
        "Python Essential",
        "book",
        "Reference",
        "Essential Reference"
      ],
      "concepts": [
        "modules",
        "python",
        "typing",
        "types",
        "programming",
        "program",
        "packages",
        "classes",
        "functions",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.85,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 40,
          "title": "Segment 40 (pages 420-428)",
          "relevance_score": 0.83,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 0.8,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 2,
          "title": "Segment 2 (pages 20-40)",
          "relevance_score": 0.77,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.75,
          "method": "api"
        }
      ]
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 19-26)",
      "start_page": 19,
      "end_page": 26,
      "detection_method": "topic_boundary",
      "chapter_number": 3,
      "summary": "This chapter covers segment 3 (pages 19-26). Key topics include operators, operation, and operations. Python doesn’t specify the amount of required\nindentation, as long as it’s consistent within a block.",
      "keywords": [
        "string",
        "Operators",
        "Strings",
        "World",
        "Python",
        "year",
        "Text Strings",
        "text",
        "Python Basics",
        "principal",
        "Arithmetic Operators",
        "format",
        "integers",
        "output",
        "Computer"
      ],
      "concepts": [
        "operators",
        "operation",
        "operations",
        "strings",
        "string",
        "prints",
        "uses",
        "useful",
        "formatting",
        "format"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 5,
          "title": "Segment 5 (pages 35-42)",
          "relevance_score": 0.74,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 4,
          "title": "Segment 4 (pages 27-34)",
          "relevance_score": 0.69,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 3,
          "title": "Segment 3 (pages 19-26)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 6,
          "title": "Segment 6 (pages 43-50)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 0.61,
          "method": "api"
        }
      ]
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 27-35)",
      "start_page": 27,
      "end_page": 35,
      "detection_method": "topic_boundary",
      "chapter_number": 4,
      "summary": "This chapter covers segment 4 (pages 27-35). Key topics include lists, file, and data. The for loop iterates line-by-line over the file until no more data is available.",
      "keywords": [
        "list",
        "IBM",
        "File",
        "shares",
        "dictionary",
        "items",
        "data",
        "row",
        "line",
        "empty list",
        "prices",
        "portfolio",
        "empty",
        "Tuples",
        "Python Basics"
      ],
      "concepts": [
        "lists",
        "file",
        "data",
        "names",
        "named",
        "object",
        "prices",
        "portfolio",
        "rows",
        "row"
      ],
      "similar_chapters": [
        {
          "book": "Learning Python Ed6",
          "chapter": 8,
          "title": "Lists and Dictionaries",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 2,
          "title": "Segment 2 (pages 20-40)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Designing Data-Intensive Applications",
          "chapter": 13,
          "title": "Segment 13 (pages 119-126)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 4,
          "title": "Segment 4 (pages 27-34)",
          "relevance_score": 0.55,
          "method": "api"
        }
      ]
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 36-45)",
      "start_page": 36,
      "end_page": 45,
      "detection_method": "topic_boundary",
      "chapter_number": 5,
      "summary": "Since looping over ranges of integers is quite common,\nthere is a shortcut:\nfor n in range(1, 10):\nprint(f'2 to the {n} power is {2**n}')\nThe range(i, j [,step]) function creates an object that represents a range of integers\nwith values from i up to, but not including, j Key topics include printed, function, and functions. Covers function, exception.",
      "keywords": [
        "stack",
        "function",
        "objects",
        "methods",
        "row",
        "file",
        "statement",
        "Python Basics",
        "items",
        "exception",
        "Python",
        "self.pop",
        "push",
        "program",
        "int"
      ],
      "concepts": [
        "printed",
        "function",
        "functions",
        "items",
        "method",
        "object",
        "classes",
        "connect",
        "connections",
        "connection"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 14,
          "title": "Segment 14 (pages 134-147)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 16,
          "title": "Segment 16 (pages 312-333)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 32,
          "title": "Segment 32 (pages 637-655)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 7,
          "title": "Segment 7 (pages 51-58)",
          "relevance_score": 0.49,
          "method": "api"
        }
      ]
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 46-53)",
      "start_page": 46,
      "end_page": 53,
      "detection_method": "topic_boundary",
      "chapter_number": 6,
      "summary": ">>>\nPython provides a large standard library of modules that simplify certain programming\ntasks Key topics include imported, python, and packages. If your file isn’t saved in one of those directories,\nPython won’t be able to find it.",
      "keywords": [
        "Python",
        "portfolio",
        "package",
        "import readport",
        "file",
        "filename",
        "import statement",
        "python readport.py",
        "code",
        "read",
        "module",
        "Python Basics",
        "readport.py",
        "main",
        "readport"
      ],
      "concepts": [
        "imported",
        "python",
        "packages",
        "files",
        "integer",
        "filename",
        "uses",
        "useful",
        "examples",
        "literals"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 40,
          "title": "Segment 40 (pages 420-428)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 25,
          "title": "Miscellaneous Library Modules",
          "relevance_score": 0.62,
          "method": "api"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 9,
          "title": "Tuples, Files, and Everything Else",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 39,
          "title": "Segment 39 (pages 411-419)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Python Microservices Development",
          "chapter": 9,
          "title": "Segment 9 (pages 65-73)",
          "relevance_score": 0.58,
          "method": "api"
        }
      ]
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 54-61)",
      "start_page": 54,
      "end_page": 61,
      "detection_method": "topic_boundary",
      "chapter_number": 7,
      "summary": "2.4 In-Place Assignment\n41\n2.4\nIn-Place Assignment\nPython provides the “in-place” or “augmented” assignment operations in Table 2.2 Key topics include operators, operation, and value.",
      "keywords": [
        "Operators",
        "items",
        "Expressions",
        "Boolean Expressions",
        "list",
        "assignment",
        "Comparison Operators",
        "Ordered Comparison Operators",
        "data",
        "Data Manipulation",
        "iterable",
        "Operations",
        "objects",
        "Standard Operators",
        "Fraction"
      ],
      "concepts": [
        "operators",
        "operation",
        "value",
        "iteration",
        "iterate",
        "iterations",
        "items",
        "object",
        "list",
        "equality"
      ],
      "similar_chapters": [
        {
          "book": "Fluent Python 2nd",
          "chapter": 30,
          "title": "Segment 30 (pages 596-614)",
          "relevance_score": 0.54,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 31,
          "title": "Segment 31 (pages 615-636)",
          "relevance_score": 0.53,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 7,
          "title": "Segment 7 (pages 51-58)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 5,
          "title": "Segment 5 (pages 84-106)",
          "relevance_score": 0.48,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 7,
          "title": "Segment 7 (pages 128-146)",
          "relevance_score": 0.47,
          "method": "api"
        }
      ]
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 62-70)",
      "start_page": 62,
      "end_page": 70,
      "detection_method": "topic_boundary",
      "chapter_number": 8,
      "summary": "This chapter covers segment 8 (pages 62-70). Key topics include operations, operators, and operation. Covers comprehension. This behavior of sequence multiplication is often not the intent of\nthe programmer.",
      "keywords": [
        "list",
        "sequence",
        "Operations",
        "list comprehension",
        "generator expression",
        "stride",
        "expression",
        "comprehension",
        "item",
        "Generator",
        "key",
        "Data",
        "IBM",
        "elements",
        "Operation"
      ],
      "concepts": [
        "operations",
        "operators",
        "operation",
        "list",
        "value",
        "key",
        "keys",
        "slicing",
        "slice",
        "data"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 14,
          "title": "Segment 14 (pages 134-147)",
          "relevance_score": 0.71,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 27,
          "title": "Segment 27 (pages 537-558)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 5,
          "title": "Segment 5 (pages 84-106)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "AI Agents and Applications",
          "chapter": 8,
          "title": "Segment 8 (pages 60-67)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.61,
          "method": "api"
        }
      ]
    },
    {
      "number": 9,
      "title": "Segment 9 (pages 71-78)",
      "start_page": 71,
      "end_page": 78,
      "detection_method": "topic_boundary",
      "chapter_number": 9,
      "summary": "This chapter covers segment 9 (pages 71-78). Key topics include looping, statements, and statement. Covers function. For\nexample, the following statements are equivalent:\nsum((x*x for x in values))\nsum(x*x for x in values)\n# Extra parens removed\nIn both cases, a generator (x*x for x in values) is created and passed to the sum()\nfunction.",
      "keywords": [
        "statements",
        "statement",
        "Operators",
        "loop",
        "Iteration",
        "function",
        "expression",
        "stripped",
        "variable",
        "line",
        "Python",
        "file",
        "Program Structure",
        "Data",
        "order"
      ],
      "concepts": [
        "looping",
        "statements",
        "statement",
        "operators",
        "operation",
        "operations",
        "expressions",
        "expression",
        "function",
        "functions"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 14,
          "title": "Segment 14 (pages 134-147)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 35,
          "title": "Segment 35 (pages 700-717)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 7,
          "title": "Program Structure and Control Flow",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.62,
          "method": "api"
        }
      ]
    },
    {
      "number": 10,
      "title": "Segment 10 (pages 79-89)",
      "start_page": 79,
      "end_page": 89,
      "detection_method": "topic_boundary",
      "chapter_number": 10,
      "summary": "This chapter covers segment 10 (pages 79-89). Key topics include exceptions, exception, and errors. Covers exception. As a matter of programming style, you should only catch exceptions from\nwhich your code can actually recover.",
      "keywords": [
        "exception",
        "Exceptions",
        "Control Flow",
        "errors",
        "raise",
        "code",
        "Control",
        "Exception Class",
        "exception type",
        "exception handling",
        "raised",
        "Program",
        "file",
        "built-in exceptions",
        "Flow"
      ],
      "concepts": [
        "exceptions",
        "exception",
        "errors",
        "raised",
        "raise",
        "program",
        "programming",
        "classes",
        "try",
        "file"
      ],
      "similar_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 11,
          "title": "Segment 11 (pages 88-95)",
          "relevance_score": 0.78,
          "method": "api"
        },
        {
          "book": "More Effective C++",
          "chapter": 9,
          "title": "Segment 9 (pages 76-97)",
          "relevance_score": 0.72,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 37,
          "title": "Segment 37 (pages 741-758)",
          "relevance_score": 0.69,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.67,
          "method": "api"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 12,
          "title": "Segment 12 (pages 96-104)",
          "relevance_score": 0.66,
          "method": "api"
        }
      ]
    },
    {
      "number": 11,
      "title": "Segment 11 (pages 90-99)",
      "start_page": 90,
      "end_page": 99,
      "detection_method": "topic_boundary",
      "chapter_number": 11,
      "summary": "This chapter covers segment 11 (pages 90-99). Key topics include object, type, and program. On the other hand, if\nthe program crashes with one of Python’s built-in exceptions (such as TypeError or\nValueError), that might indicate a more serious problem.",
      "keywords": [
        "object",
        "type",
        "reference count",
        "Reference",
        "Statement",
        "control flow",
        "list",
        "data",
        "program",
        "Context Managers",
        "statements",
        "count",
        "Context",
        "items",
        "Python"
      ],
      "concepts": [
        "object",
        "type",
        "program",
        "programming",
        "list",
        "statement",
        "statements",
        "data",
        "assertions",
        "assert"
      ],
      "similar_chapters": [
        {
          "book": "Fluent Python 2nd",
          "chapter": 36,
          "title": "Segment 36 (pages 718-737)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 7,
          "title": "Program Structure and Control Flow",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 38,
          "title": "Segment 38 (pages 403-410)",
          "relevance_score": 0.64,
          "method": "api"
        }
      ]
    },
    {
      "number": 12,
      "title": "Segment 12 (pages 100-107)",
      "start_page": 100,
      "end_page": 107,
      "detection_method": "topic_boundary",
      "chapter_number": 12,
      "summary": "This chapter covers segment 12 (pages 100-107). Key topics include method, objects, and operations. Covers function. For\nexample, in the output of the above code, there is no obvious way to know if the variable\nd is a date instance or a simple string containing the text '2012-12-21'.",
      "keywords": [
        "object",
        "methods",
        "Protocols",
        "Object Protocols",
        "function",
        "items",
        "instance",
        "repr",
        "Types",
        "special methods",
        "Add",
        "First-Class Objects",
        "lota",
        "Python",
        "special"
      ],
      "concepts": [
        "method",
        "objects",
        "operations",
        "operator",
        "operation",
        "functions",
        "instance",
        "math",
        "protocols",
        "way"
      ],
      "similar_chapters": [
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 3,
          "title": "Segment 3 (pages 17-26)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.62,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 46,
          "title": "Segment 46 (pages 930-951)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 49,
          "title": "Segment 49 (pages 993-1010)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.61,
          "method": "api"
        }
      ]
    },
    {
      "number": 13,
      "title": "Segment 13 (pages 108-115)",
      "start_page": 108,
      "end_page": 115,
      "detection_method": "topic_boundary",
      "chapter_number": 13,
      "summary": "This chapter covers segment 13 (pages 108-115). Key topics include methods, object, and functions. Covers function. If both __bool__()\nand __len__() are undefined, an object is simply considered to be True.",
      "keywords": [
        "Method",
        "object",
        "format",
        "Python",
        "slice",
        "Protocol",
        "Attribute",
        "type",
        "function",
        "bool",
        "implement",
        "Iteration Protocol",
        "Iteration",
        "Context",
        "Comparison"
      ],
      "concepts": [
        "methods",
        "object",
        "functions",
        "function",
        "functionality",
        "iteration",
        "iterating",
        "slicing",
        "slices",
        "value"
      ],
      "similar_chapters": [
        {
          "book": "Fluent Python 2nd",
          "chapter": 22,
          "title": "Segment 22 (pages 433-453)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 5,
          "title": "Table 3.11",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 13,
          "title": "Segment 13 (pages 250-271)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 16,
          "title": "Segment 16 (pages 312-333)",
          "relevance_score": 0.6,
          "method": "api"
        }
      ]
    },
    {
      "number": 14,
      "title": "Segment 14 (pages 116-123)",
      "start_page": 116,
      "end_page": 123,
      "detection_method": "topic_boundary",
      "chapter_number": 14,
      "summary": "This chapter\ndescribes function definitions, function application, scoping rules, closures, decorators,\nand other functional programming features Key topics include functions, function, and arguments. Covers function.",
      "keywords": [
        "function",
        "arguments",
        "Keyword Arguments",
        "Functions",
        "Keyword",
        "argument",
        "items",
        "result",
        "function definition",
        "parameter",
        "def func",
        "Hints",
        "Default",
        "args",
        "Positional arguments"
      ],
      "concepts": [
        "functions",
        "function",
        "arguments",
        "argument",
        "items",
        "values",
        "returns",
        "programs",
        "code",
        "parameters"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.84,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 14,
          "title": "Segment 14 (pages 272-289)",
          "relevance_score": 0.75,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 30,
          "title": "Segment 30 (pages 317-324)",
          "relevance_score": 0.72,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 49,
          "title": "Segment 49 (pages 993-1010)",
          "relevance_score": 0.71,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 12,
          "title": "Segment 12 (pages 115-125)",
          "relevance_score": 0.7,
          "method": "api"
        }
      ]
    },
    {
      "number": 15,
      "title": "Segment 15 (pages 124-132)",
      "start_page": 124,
      "end_page": 132,
      "detection_method": "topic_boundary",
      "chapter_number": 15,
      "summary": "This chapter covers segment 15 (pages 124-132). Key topics include function, functions, and values. Covers function, lambda. You can even\nuse * and ** more than once in the same function call.",
      "keywords": [
        "function",
        "Functions",
        "variable",
        "lambda",
        "prints",
        "greeting",
        "global",
        "Pass a sequence",
        "Pass a mapping",
        "result",
        "variables",
        "parts",
        "def func",
        "global variable",
        "local variable"
      ],
      "concepts": [
        "function",
        "functions",
        "values",
        "results",
        "variables",
        "variable",
        "returns",
        "prints",
        "scope",
        "examples"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.79,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 5,
          "title": "Segment 5 (pages 35-42)",
          "relevance_score": 0.67,
          "method": "api"
        },
        {
          "book": "makinggames",
          "chapter": 8,
          "title": "Segment 8 (pages 60-68)",
          "relevance_score": 0.67,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 35,
          "title": "Segment 35 (pages 700-717)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.65,
          "method": "api"
        }
      ]
    },
    {
      "number": 16,
      "title": "Segment 16 (pages 133-141)",
      "start_page": 133,
      "end_page": 141,
      "detection_method": "topic_boundary",
      "chapter_number": 16,
      "summary": "This chapter covers segment 16 (pages 133-141). Key topics include functions, function, and decorators. Covers decorator. If it makes code harder to read, perhaps it should be avoided.",
      "keywords": [
        "func",
        "args",
        "arguments",
        "result",
        "Functions",
        "callback function",
        "Callback",
        "def func",
        "add",
        "decorator",
        "partial",
        "trace",
        "call",
        "lambda",
        "return func"
      ],
      "concepts": [
        "functions",
        "function",
        "decorators",
        "decorate",
        "decoration",
        "decorated",
        "argument",
        "arguments",
        "returning",
        "results"
      ],
      "similar_chapters": [
        {
          "book": "Fluent Python 2nd",
          "chapter": 17,
          "title": "Segment 17 (pages 334-353)",
          "relevance_score": 0.77,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 47,
          "title": "Segment 47 (pages 952-973)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 24,
          "title": "Segment 24 (pages 241-248)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.63,
          "method": "api"
        }
      ]
    },
    {
      "number": 17,
      "title": "Segment 17 (pages 142-149)",
      "start_page": 142,
      "end_page": 149,
      "detection_method": "topic_boundary",
      "chapter_number": 17,
      "summary": "For example:\nsquares = (x*x for x in nums)\n# Creates a generator\nfor n in squares:\nprint(n)\nPython provides a built-in map() function that is the same as mapping a function with a\ngenerator expression Key topics include function, functional, and functions. Covers function.",
      "keywords": [
        "function",
        "code",
        "Functions",
        "locals",
        "Reduce",
        "Dictionary",
        "Attributes",
        "variables",
        "def func",
        "globals",
        "nums",
        "local variables",
        "signature",
        "exec"
      ],
      "concepts": [
        "function",
        "functional",
        "functions",
        "printing",
        "code",
        "reduce",
        "attributes",
        "local",
        "examples",
        "inspected"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 35,
          "title": "Segment 35 (pages 700-717)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 14,
          "title": "Segment 14 (pages 134-147)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 7,
          "title": "Segment 7 (pages 51-58)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 14,
          "title": "Segment 14 (pages 272-289)",
          "relevance_score": 0.5,
          "method": "api"
        }
      ]
    },
    {
      "number": 18,
      "title": "Segment 18 (pages 150-158)",
      "start_page": 150,
      "end_page": 158,
      "detection_method": "topic_boundary",
      "chapter_number": 18,
      "summary": "5.23 Asynchronous Functions and await\n135\n5.23\nAsynchronous Functions and await\nPython provides a number of language features related to the asynchronous execution of\ncode Key topics include generators, functions, and function. Covers function.",
      "keywords": [
        "function",
        "Generator",
        "Functions",
        "async",
        "generator function",
        "async functions",
        "yield",
        "async def",
        "Asynchronous Functions",
        "execute",
        "code",
        "generator function executes",
        "countdown",
        "Asynchronous",
        "await"
      ],
      "concepts": [
        "generators",
        "functions",
        "function",
        "functionality",
        "async",
        "iteration",
        "iterate",
        "yield",
        "uses",
        "useful"
      ],
      "similar_chapters": [
        {
          "book": "Fluent Python 2nd",
          "chapter": 42,
          "title": "Segment 42 (pages 842-862)",
          "relevance_score": 0.81,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 40,
          "title": "Segment 40 (pages 798-818)",
          "relevance_score": 0.7,
          "method": "api"
        },
        {
          "book": "Python Microservices Development",
          "chapter": 37,
          "title": "Segment 37 (pages 312-320)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Python Microservices Development",
          "chapter": 6,
          "title": "Segment 6 (pages 41-48)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 29,
          "title": "Segment 29 (pages 299-314)",
          "relevance_score": 0.58,
          "method": "api"
        }
      ]
    },
    {
      "number": 19,
      "title": "Segment 19 (pages 159-166)",
      "start_page": 159,
      "end_page": 166,
      "detection_method": "topic_boundary",
      "chapter_number": 19,
      "summary": "This chapter covers segment 19 (pages 159-166). Key topics include generators, yield, and line. Covers generator, function, exception. However, generators are particularly effective at\nstructuring various data handling problems related to pipelines and workflows.",
      "keywords": [
        "generator",
        "yield",
        "Enhanced Generators",
        "line",
        "function",
        "generator function",
        "Enhanced",
        "files",
        "r.send",
        "exception",
        "Python",
        "manager",
        "code",
        "paths",
        "val"
      ],
      "concepts": [
        "generators",
        "yield",
        "line",
        "functionality",
        "function",
        "functions",
        "files",
        "path",
        "data",
        "returned"
      ],
      "similar_chapters": [
        {
          "book": "Fluent Python 2nd",
          "chapter": 34,
          "title": "Segment 34 (pages 677-699)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 7,
          "title": "Program Structure and Control Flow",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 36,
          "title": "Segment 36 (pages 718-737)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 32,
          "title": "Segment 32 (pages 637-655)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "AI Engineering Building Applications",
          "chapter": 36,
          "title": "Segment 36 (pages 725-745)",
          "relevance_score": 0.55,
          "method": "api"
        }
      ]
    },
    {
      "number": 20,
      "title": "Segment 20 (pages 167-175)",
      "start_page": 167,
      "end_page": 175,
      "detection_method": "topic_boundary",
      "chapter_number": 20,
      "summary": "This chapter covers the details of\nclasses—but is not intended to be an in-depth reference on object-oriented programming\nand design Key topics include classes, accounts, and balance.",
      "keywords": [
        "Account",
        "Guido",
        "methods",
        "Python",
        "instance",
        "object",
        "self.balance",
        "class Account",
        "balance",
        "programming",
        "owner",
        "amount",
        "Classes",
        "attribute",
        "init"
      ],
      "concepts": [
        "classes",
        "accounts",
        "balance",
        "method",
        "object",
        "python",
        "pythonic",
        "programming",
        "iteration",
        "instance"
      ],
      "similar_chapters": [
        {
          "book": "Python Essential Reference 4th",
          "chapter": 2,
          "title": "Objects and Classes",
          "relevance_score": 0.62,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 7,
          "title": "Program Structure and Control Flow",
          "relevance_score": 0.62,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 20,
          "title": "Segment 20 (pages 392-414)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 18,
          "title": "Segment 18 (pages 175-187)",
          "relevance_score": 0.56,
          "method": "api"
        }
      ]
    },
    {
      "number": 21,
      "title": "Segment 21 (pages 176-183)",
      "start_page": 176,
      "end_page": 183,
      "detection_method": "topic_boundary",
      "chapter_number": 21,
      "summary": "This chapter covers segment 21 (pages 176-183). Key topics include classes, type, and typed. Covers method. Occasionally, a derived class would reimplement a method but also need to call the\noriginal implementation.",
      "keywords": [
        "Inheritance",
        "stack",
        "Account",
        "Calls Account.deposit",
        "self.",
        "row",
        "method",
        "inquiry",
        "make",
        "list",
        "super",
        "init",
        "Guido",
        "class Stack",
        "EvilAccount"
      ],
      "concepts": [
        "classes",
        "type",
        "typed",
        "typing",
        "method",
        "object",
        "list",
        "row",
        "inheritance",
        "inherit"
      ],
      "similar_chapters": [
        {
          "book": "Fluent Python 2nd",
          "chapter": 26,
          "title": "Segment 26 (pages 517-534)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "More Effective C++",
          "chapter": 14,
          "title": "Segment 14 (pages 133-140)",
          "relevance_score": 0.57,
          "method": "api"
        },
        {
          "book": "Python Cookbook 3rd",
          "chapter": 7,
          "title": "Functions",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 11,
          "title": "Segment 11 (pages 88-95)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.55,
          "method": "api"
        }
      ]
    },
    {
      "number": 22,
      "title": "Segment 22 (pages 184-191)",
      "start_page": 184,
      "end_page": 191,
      "detection_method": "topic_boundary",
      "chapter_number": 22,
      "summary": "This chapter covers segment 22 (pages 184-191). Key topics include classes, account, and instance. For example, when\nbuilding new containers, it is probably better to make a new class, as was shown for the\nStack class in Section 7.8.",
      "keywords": [
        "Account",
        "Methods",
        "amount",
        "class method",
        "Class Variables",
        "class Account",
        "Static Methods",
        "instance",
        "amount def",
        "owner",
        "self.balance",
        "def inquiry",
        "def deposit",
        "staticmethod def",
        "Python"
      ],
      "concepts": [
        "classes",
        "account",
        "instance",
        "methods",
        "data",
        "patterns",
        "implement",
        "implementation",
        "functions",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 24,
          "title": "Segment 24 (pages 241-248)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 47,
          "title": "Segment 47 (pages 952-973)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 20,
          "title": "Segment 20 (pages 198-208)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 2,
          "title": "Objects and Classes",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.57,
          "method": "api"
        }
      ]
    },
    {
      "number": 23,
      "title": "Segment 23 (pages 192-207)",
      "start_page": 192,
      "end_page": 207,
      "detection_method": "topic_boundary",
      "chapter_number": 23,
      "summary": "This chapter covers segment 23 (pages 192-207). Key topics include classes, attributes, and method. Covers inheritance. There’s nothing\nthat prevents a user from accessing it directly, but the leading underscore is a strong\nindicator that a user should look for a more public-facing interface—such as the\nAccount.inquiry() method.",
      "keywords": [
        "Classes",
        "attribute",
        "Multiple Inheritance",
        "inheritance",
        "Stream",
        "MRO",
        "Base",
        "base class",
        "Type",
        "balance",
        "method",
        "def noise",
        "self.",
        "class Stream",
        "Abstract Base"
      ],
      "concepts": [
        "classes",
        "attributes",
        "method",
        "type",
        "typing",
        "owner",
        "returning",
        "functions",
        "function",
        "functionality"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 22,
          "title": "Segment 22 (pages 218-231)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 24,
          "title": "Segment 24 (pages 241-248)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 26,
          "title": "Segment 26 (pages 517-534)",
          "relevance_score": 0.58,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 18,
          "title": "Segment 18 (pages 175-187)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 21,
          "title": "Segment 21 (pages 209-217)",
          "relevance_score": 0.55,
          "method": "api"
        }
      ]
    },
    {
      "number": 24,
      "title": "Segment 24 (pages 208-218)",
      "start_page": 208,
      "end_page": 218,
      "detection_method": "topic_boundary",
      "chapter_number": 24,
      "summary": "This chapter covers segment 24 (pages 208-218). Key topics include classes, examples, and methods. Covers method. # Example\ndispatcher = Dispatcher()\ndispatcher.handle(Duck())\n# -> handle_Duck()\ndispatcher.handle(Cyclist())\n# -> handle_Cyclist()\nThis last example of using getattr() to dispatch onto methods of a class is a fairly\ncommon programming pattern.",
      "keywords": [
        "init",
        "obj",
        "Account",
        "method",
        "object",
        "del",
        "Class Decorators",
        "Object Life Cycle",
        "Date",
        "create",
        "subclass",
        "class Point",
        "handle",
        "Guido",
        "repr"
      ],
      "concepts": [
        "classes",
        "examples",
        "methods",
        "date",
        "type",
        "object",
        "code",
        "performs",
        "performance",
        "returns"
      ],
      "similar_chapters": [
        {
          "book": "Fluent Python 2nd",
          "chapter": 47,
          "title": "Segment 47 (pages 952-973)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 24,
          "title": "Segment 24 (pages 241-248)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 18,
          "title": "Segment 18 (pages 175-187)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 5,
          "title": "Table 3.11",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "The Little Book Of Python-Anti-Patterns",
          "chapter": 3,
          "title": "Segment 3 (pages 17-26)",
          "relevance_score": 0.6,
          "method": "api"
        }
      ]
    },
    {
      "number": 25,
      "title": "Segment 25 (pages 219-229)",
      "start_page": 219,
      "end_page": 229,
      "detection_method": "topic_boundary",
      "chapter_number": 25,
      "summary": "This chapter covers segment 25 (pages 219-229). Key topics include classes, attribute, and object. Covers method. Second, the __del__() method should\navoid operations such as acquiring locks or other resources.",
      "keywords": [
        "attribute",
        "instance",
        "dict",
        "object",
        "method",
        "Account",
        "descriptor",
        "reference",
        "Classes",
        "weak reference",
        "slots",
        "instance dictionary",
        "dictionary",
        "self."
      ],
      "concepts": [
        "classes",
        "attribute",
        "object",
        "methods",
        "instances",
        "implementation",
        "implement",
        "account",
        "types",
        "slots"
      ],
      "similar_chapters": [
        {
          "book": "Fluent Python 2nd",
          "chapter": 13,
          "title": "Segment 13 (pages 250-271)",
          "relevance_score": 0.75,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 5,
          "title": "Table 3.11",
          "relevance_score": 0.74,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 24,
          "title": "Segment 24 (pages 241-248)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 22,
          "title": "Segment 22 (pages 218-231)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 13,
          "title": "Segment 13 (pages 134-141)",
          "relevance_score": 0.64,
          "method": "api"
        }
      ]
    },
    {
      "number": 26,
      "title": "Segment 26 (pages 230-237)",
      "start_page": 230,
      "end_page": 237,
      "detection_method": "topic_boundary",
      "chapter_number": 26,
      "summary": "This chapter covers segment 26 (pages 230-237). Key topics include classes, types, and typed. When you define a class using the class\nstatement, a new dictionary is created that serves as the local class namespace.",
      "keywords": [
        "Account",
        "Class Definition",
        "class namespace",
        "base",
        "amount",
        "type",
        "class Account",
        "namespace",
        "classes",
        "metaclass",
        "class Base",
        "self.balance",
        "create",
        "Definition",
        "class instance"
      ],
      "concepts": [
        "classes",
        "types",
        "typed",
        "base",
        "based",
        "methods",
        "definition",
        "definitions",
        "created",
        "create"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 31,
          "title": "Segment 31 (pages 312-319)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 24,
          "title": "Segment 24 (pages 241-248)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 50,
          "title": "Segment 50 (pages 1600-1629)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 11,
          "title": "Segment 11 (pages 210-230)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "Segment 32 (pages 320-329)",
          "relevance_score": 0.56,
          "method": "api"
        }
      ]
    },
    {
      "number": 27,
      "title": "Segment 27 (pages 238-246)",
      "start_page": 238,
      "end_page": 246,
      "detection_method": "topic_boundary",
      "chapter_number": 27,
      "summary": "7.33\nFinal Words: Keep It Simple\nThis chapter has presented a lot of information about classes and the ways to customize\nand control them Key topics include imported, important, and modules.",
      "keywords": [
        "module",
        "module import",
        "module import func",
        "func",
        "statement",
        "import statement",
        "code",
        "imports",
        "statement import module",
        "module object",
        "Python",
        "file",
        "import modb",
        "import func",
        "namespace"
      ],
      "concepts": [
        "imported",
        "important",
        "modules",
        "classes",
        "code",
        "statement",
        "statements",
        "object",
        "objection",
        "variable"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 40,
          "title": "Segment 40 (pages 420-428)",
          "relevance_score": 0.69,
          "method": "api"
        },
        {
          "book": "Python Cookbook 3rd",
          "chapter": 9,
          "title": "Metaprogramming",
          "relevance_score": 0.67,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 8,
          "title": "Modules, Packages, and Distribution",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 25,
          "title": "Miscellaneous Library Modules",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Python Architecture Patterns",
          "chapter": 11,
          "title": "[ 383 ]",
          "relevance_score": 0.63,
          "method": "api"
        }
      ]
    },
    {
      "number": 28,
      "title": "Segment 28 (pages 247-257)",
      "start_page": 247,
      "end_page": 257,
      "detection_method": "topic_boundary",
      "chapter_number": 28,
      "summary": "This chapter covers segment 28 (pages 247-257). Key topics include packages, packaging, and modules. This is because references to the cached module object still exist in other\nmodules that imported that module.",
      "keywords": [
        "package",
        "Module",
        "file",
        "Python",
        "init",
        "code",
        "directory",
        "Package Namespace",
        "imports",
        "Python files",
        "top-level package",
        "Main",
        "graphics",
        "import statement",
        "Python code"
      ],
      "concepts": [
        "packages",
        "packaging",
        "modules",
        "imported",
        "python",
        "file",
        "code",
        "directory",
        "directories",
        "classes"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 40,
          "title": "Segment 40 (pages 420-428)",
          "relevance_score": 0.74,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 39,
          "title": "Segment 39 (pages 411-419)",
          "relevance_score": 0.69,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 25,
          "title": "Miscellaneous Library Modules",
          "relevance_score": 0.69,
          "method": "api"
        },
        {
          "book": "Python Cookbook 3rd",
          "chapter": 10,
          "title": "Modules and Packages",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "Python Architecture Patterns",
          "chapter": 11,
          "title": "[ 383 ]",
          "relevance_score": 0.66,
          "method": "api"
        }
      ]
    },
    {
      "number": 29,
      "title": "Segment 29 (pages 258-268)",
      "start_page": 258,
      "end_page": 268,
      "detection_method": "topic_boundary",
      "chapter_number": 29,
      "summary": "This chapter covers segment 29 (pages 258-268). Key topics include python, bytes, and formatting. As with other type hints, module-level hints change no part of Python’s behavior, nor\ndo they actually define variables.",
      "keywords": [
        "format",
        "text",
        "Python",
        "Deploying Python Packages",
        "bytes",
        "package",
        "encoding",
        "Text Encoding",
        "code",
        "Character",
        "Python Packages",
        "data",
        "Output",
        "Deploying Python",
        "format codes"
      ],
      "concepts": [
        "python",
        "bytes",
        "formatting",
        "format",
        "characters",
        "packages",
        "encoding",
        "encode",
        "text",
        "module"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 4,
          "title": "Segment 4 (pages 27-34)",
          "relevance_score": 0.75,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 40,
          "title": "Segment 40 (pages 420-428)",
          "relevance_score": 0.74,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 3,
          "title": "Segment 3 (pages 19-26)",
          "relevance_score": 0.73,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 0.69,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.67,
          "method": "api"
        }
      ]
    },
    {
      "number": 30,
      "title": "Segment 30 (pages 269-279)",
      "start_page": 269,
      "end_page": 279,
      "detection_method": "topic_boundary",
      "chapter_number": 30,
      "summary": "For example, messages\nproduced by the logging module are formatted in this way:\nimport logging\nlog = logging.getLogger(__name__)\nlog.debug('%s got %d', name, value)\n# '%s got %d' % (name, value)\nThe logging module is briefly described later in this chapter in Section 9.15.12 Key topics include files, line, and buffering.",
      "keywords": [
        "File",
        "open",
        "file mode",
        "mode",
        "file object",
        "Output",
        "text",
        "line",
        "data",
        "Input",
        "binary mode file",
        "method",
        "buffer",
        "Binary mode",
        "encoding"
      ],
      "concepts": [
        "files",
        "line",
        "buffering",
        "buffers",
        "write",
        "writing",
        "reading",
        "open",
        "mode"
      ],
      "similar_chapters": [
        {
          "book": "Python Architecture Patterns",
          "chapter": 12,
          "title": "[ 427 ]",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 6,
          "title": "The Dynamic Typing Interlude",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Python Microservices Development",
          "chapter": 21,
          "title": "Segment 21 (pages 167-174)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 4,
          "title": "Segment 4 (pages 27-34)",
          "relevance_score": 0.55,
          "method": "api"
        },
        {
          "book": "Designing Machine Learning Systems An Iterative Process for Production-Ready Applications",
          "chapter": 10,
          "title": "Segment 10 (pages 80-87)",
          "relevance_score": 0.53,
          "method": "api"
        }
      ]
    },
    {
      "number": 31,
      "title": "Segment 31 (pages 280-288)",
      "start_page": 280,
      "end_page": 288,
      "detection_method": "topic_boundary",
      "chapter_number": 31,
      "summary": "Here is an example:\ndef countdown(n):\nwhile n > 0:\nyield f'T-minus {n}\\n'\nn -= 1\nyield 'Kaboom!\\n'\nProducing an output stream in this manner provides flexibility because it is decoupled\nfrom the code that actually directs the stream to its intended destination Key topics include data, sock, and file.",
      "keywords": [
        "data",
        "Output",
        "line",
        "object",
        "sock",
        "loop",
        "file",
        "EVENT",
        "operations",
        "Pickle",
        "operation",
        "module",
        "Input",
        "code",
        "Generating Output"
      ],
      "concepts": [
        "data",
        "sock",
        "file",
        "reader",
        "loop",
        "operations",
        "operating",
        "code",
        "programs",
        "programmed"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 16,
          "title": "Segment 16 (pages 157-164)",
          "relevance_score": 0.5,
          "method": "api"
        },
        {
          "book": "Python Cookbook 3rd",
          "chapter": 6,
          "title": "Data Encoding and Processing",
          "relevance_score": 0.49,
          "method": "api"
        },
        {
          "book": "makinggames",
          "chapter": 41,
          "title": "Segment 41 (pages 356-363)",
          "relevance_score": 0.48,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 34,
          "title": "Segment 34 (pages 677-699)",
          "relevance_score": 0.47,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 37,
          "title": "Segment 37 (pages 738-758)",
          "relevance_score": 0.47,
          "method": "api"
        }
      ]
    },
    {
      "number": 32,
      "title": "Segment 32 (pages 289-298)",
      "start_page": 289,
      "end_page": 298,
      "detection_method": "topic_boundary",
      "chapter_number": 32,
      "summary": "This chapter covers segment 32 (pages 289-298). Key topics include files, filename, and data. The code should echo back the text that you type.",
      "keywords": [
        "Module",
        "Standard Library Modules",
        "file",
        "Library Modules",
        "data",
        "csv Module",
        "csv",
        "filename",
        "Standard Library",
        "CSV file",
        "python",
        "Users",
        "functions",
        "module provides",
        "cgi Module"
      ],
      "concepts": [
        "files",
        "filename",
        "data",
        "logging",
        "log",
        "module",
        "path",
        "functions",
        "functionality",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Designing Machine Learning Systems An Iterative Process for Production-Ready Applications",
          "chapter": 10,
          "title": "Segment 10 (pages 80-87)",
          "relevance_score": 0.71,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 4,
          "title": "Segment 4 (pages 27-34)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 40,
          "title": "Segment 40 (pages 420-428)",
          "relevance_score": 0.61,
          "method": "api"
        },
        {
          "book": "AI Agents and Applications",
          "chapter": 13,
          "title": "Segment 13 (pages 104-111)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 3,
          "title": "Segment 3 (pages 19-26)",
          "relevance_score": 0.6,
          "method": "api"
        }
      ]
    },
    {
      "number": 33,
      "title": "Segment 33 (pages 299-307)",
      "start_page": 299,
      "end_page": 307,
      "detection_method": "topic_boundary",
      "chapter_number": 33,
      "summary": "This chapter covers segment 33 (pages 299-307). Key topics include data, module, and sock. In this example,\nthe \\d+ is interpreted to mean “one or more digits.” More information about the pattern\nsyntax can be found in the official documentation for the re module.",
      "keywords": [
        "module",
        "Standard Library Modules",
        "eyes",
        "Library Modules",
        "file",
        "data",
        "socket",
        "SOCK",
        "Output",
        "select Module",
        "INET",
        "shutil Module",
        "Standard Library",
        "address",
        "socket Module"
      ],
      "concepts": [
        "data",
        "module",
        "sock",
        "files",
        "client",
        "subprocess",
        "address",
        "text",
        "common",
        "server"
      ],
      "similar_chapters": [
        {
          "book": "Python Essential Reference 4th",
          "chapter": 21,
          "title": "Network Programming and Sockets",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 48,
          "title": "Segment 48 (pages 961-980)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 50,
          "title": "Segment 50 (pages 1000-1022)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 4,
          "title": "Segment 4 (pages 27-34)",
          "relevance_score": 0.51,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 54,
          "title": "Segment 54 (pages 522-529)",
          "relevance_score": 0.51,
          "method": "api"
        }
      ]
    },
    {
      "number": 34,
      "title": "Segment 34 (pages 308-315)",
      "start_page": 308,
      "end_page": 315,
      "detection_method": "topic_boundary",
      "chapter_number": 34,
      "summary": "gmtime([secs])\nThe same as localtime() except that the resulting structure represents the time in\nUTC (or Greenwich Mean Time) Key topics include character, python, and checks.",
      "keywords": [
        "string",
        "item",
        "Standard Library Modules",
        "characters",
        "Standard Library",
        "item num",
        "functions",
        "returns",
        "bytes",
        "Built-in Functions",
        "time",
        "Unicode",
        "num",
        "Python",
        "Module"
      ],
      "concepts": [
        "character",
        "python",
        "checks",
        "returns",
        "sep",
        "item",
        "bytes",
        "functions",
        "function",
        "strings"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 4,
          "title": "Segment 4 (pages 27-34)",
          "relevance_score": 0.52,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 17,
          "title": "Segment 17 (pages 326-347)",
          "relevance_score": 0.49,
          "method": "api"
        },
        {
          "book": "Python Microservices Development",
          "chapter": 22,
          "title": "Segment 22 (pages 175-182)",
          "relevance_score": 0.49,
          "method": "api"
        },
        {
          "book": "Designing Data-Intensive Applications",
          "chapter": 33,
          "title": "Segment 33 (pages 309-318)",
          "relevance_score": 0.45,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 32,
          "title": "Segment 32 (pages 336-344)",
          "relevance_score": 0.44,
          "method": "api"
        }
      ]
    },
    {
      "number": 35,
      "title": "Segment 35 (pages 316-323)",
      "start_page": 316,
      "end_page": 323,
      "detection_method": "topic_boundary",
      "chapter_number": 35,
      "summary": "This chapter covers segment 35 (pages 316-323). Key topics include value, object, and returns. Covers function. chr(x)\nConverts the integer x representing a Unicode code-point into a single-character\nstring.",
      "keywords": [
        "Returns",
        "object",
        "string",
        "function",
        "Built-in Functions",
        "Returns True",
        "integer",
        "items",
        "Attribute",
        "list",
        "number",
        "argument",
        "method",
        "complex",
        "dictionary"
      ],
      "concepts": [
        "value",
        "object",
        "returns",
        "string",
        "functions",
        "function",
        "methods",
        "integers",
        "key",
        "keys"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 12,
          "title": "Segment 12 (pages 116-123)",
          "relevance_score": 0.68,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 4,
          "title": "Segment 4 (pages 27-34)",
          "relevance_score": 0.64,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 49,
          "title": "Segment 49 (pages 993-1010)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 7,
          "title": "Segment 7 (pages 121-141)",
          "relevance_score": 0.62,
          "method": "api"
        }
      ]
    },
    {
      "number": 36,
      "title": "Segment 36 (pages 324-332)",
      "start_page": 324,
      "end_page": 332,
      "detection_method": "topic_boundary",
      "chapter_number": 36,
      "summary": "This chapter covers segment 36 (pages 324-332). Key topics include returned, exceptions, and exception. Table 10.8\nSet Operations and Methods\nOperation\nDescription\ns | t\nUnion\ns & t\nIntersection\ns - t\nDifference\ns ^ t\nSymmetric difference\nlen(s)\nReturns number of items in s.",
      "keywords": [
        "string",
        "items",
        "Built-in Functions",
        "Returns",
        "Exceptions",
        "Exception",
        "object",
        "Built-in Exceptions",
        "Built-in",
        "error",
        "characters",
        "function",
        "Checks",
        "Functions",
        "end"
      ],
      "concepts": [
        "returned",
        "exceptions",
        "exception",
        "errors",
        "checks",
        "string",
        "strings",
        "objects",
        "items",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 11,
          "title": "Segment 11 (pages 88-95)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "More Effective C++",
          "chapter": 9,
          "title": "Segment 9 (pages 76-97)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 27,
          "title": "Segment 27 (pages 537-558)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 37,
          "title": "Segment 37 (pages 741-758)",
          "relevance_score": 0.56,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 40,
          "title": "Segment 40 (pages 368-375)",
          "relevance_score": 0.55,
          "method": "api"
        }
      ]
    },
    {
      "number": 37,
      "title": "Segment 37 (pages 333-344)",
      "start_page": 333,
      "end_page": 344,
      "detection_method": "topic_boundary",
      "chapter_number": 37,
      "summary": "10.3.3\nitertools Module\nThe itertools module provides a variety of useful iteration patterns—chaining iterables\ntogether, iterating over product sets, permutations, grouping, and similar operations Key topics include methods, functions, and function. Covers method, function, exception.",
      "keywords": [
        "method",
        "function",
        "Module",
        "Functions",
        "operator",
        "exception",
        "attribute",
        "statement",
        "Standard Library",
        "Python",
        "Library",
        "functions related",
        "Standard",
        "file",
        "Built-in Functions"
      ],
      "concepts": [
        "methods",
        "functions",
        "function",
        "modules",
        "exception",
        "exceptions",
        "attributes",
        "classes",
        "operations",
        "operating"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 7,
          "title": "Segment 7 (pages 51-58)",
          "relevance_score": 0.63,
          "method": "api"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 7,
          "title": "Program Structure and Control Flow",
          "relevance_score": 0.62,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 31,
          "title": "Segment 31 (pages 615-636)",
          "relevance_score": 0.6,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 14,
          "title": "Segment 14 (pages 134-147)",
          "relevance_score": 0.59,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.58,
          "method": "api"
        }
      ]
    },
    {
      "number": 38,
      "title": "Segment 38 (pages 345-352)",
      "start_page": 345,
      "end_page": 352,
      "detection_method": "topic_boundary",
      "chapter_number": 38,
      "summary": "This chapter covers segment 38 (pages 345-352). Key topics include method, function, and functions. Covers method, function, exception.",
      "keywords": [
        "method",
        "function",
        "module",
        "exception",
        "attribute",
        "objects",
        "functions",
        "classes",
        "variable",
        "statement",
        "package",
        "types",
        "Index",
        "Method Resolution Order",
        "operator"
      ],
      "concepts": [
        "method",
        "function",
        "functions",
        "exception",
        "exceptions",
        "module",
        "attribute",
        "classes",
        "object",
        "packages"
      ],
      "similar_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 11,
          "title": "Segment 11 (pages 88-95)",
          "relevance_score": 0.78,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 49,
          "title": "Segment 49 (pages 993-1010)",
          "relevance_score": 0.75,
          "method": "api"
        },
        {
          "book": "More Effective C++",
          "chapter": 31,
          "title": "Segment 31 (pages 312-319)",
          "relevance_score": 0.75,
          "method": "api"
        },
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "Segment 32 (pages 320-329)",
          "relevance_score": 0.75,
          "method": "api"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 40,
          "title": "Segment 40 (pages 368-375)",
          "relevance_score": 0.74,
          "method": "api"
        }
      ]
    },
    {
      "number": 39,
      "title": "Segment 39 (pages 353-355)",
      "start_page": 353,
      "end_page": 355,
      "detection_method": "topic_boundary",
      "chapter_number": 39,
      "summary": "This chapter covers segment 39 (pages 353-355). Key topics include video, python, and learn. Visit informit.com/python to shop, preview sample chapters, and watch \nfree video lessons from our catalog.",
      "keywords": [
        "Python",
        "Press",
        "Video",
        "Adobe Press",
        "Cisco Press",
        "Microsoft Press",
        "Peachpit Press",
        "informit.com",
        "Python Programming",
        "Python Essential Reference",
        "Learn",
        "Discount code VIDBOB",
        "Discount",
        "video lessons",
        "Python LiveLessons"
      ],
      "concepts": [
        "video",
        "python",
        "learn",
        "press",
        "product",
        "technology",
        "title",
        "access",
        "free",
        "books"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 0.73,
          "method": "api"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.73,
          "method": "api"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 1,
          "title": "A Python Q&A Session",
          "relevance_score": 0.66,
          "method": "api"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 2,
          "title": "Segment 2 (pages 20-40)",
          "relevance_score": 0.65,
          "method": "api"
        },
        {
          "book": "Python Microservices Development",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.65,
          "method": "api"
        }
      ]
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "chapter": null,
      "content": "Python\nDistilled\n\nid M. Beazley\n\nPp Author of Python Essential Reference",
      "content_length": 72,
      "extraction_method": "OCR"
    },
    {
      "page_number": 2,
      "chapter": null,
      "content": "Python Distilled",
      "content_length": 16,
      "extraction_method": "OCR"
    },
    {
      "page_number": 3,
      "chapter": null,
      "content": "This page intentionally left blank",
      "content_length": 34,
      "extraction_method": "OCR"
    },
    {
      "page_number": 4,
      "chapter": null,
      "content": "Python Distilled\nDavid M. Beazley\nBoston • Columbus • New York • San Francisco • Amsterdam • Cape Town\nDubai • London • Madrid • Milan • Munich • Paris • Montreal • Toronto • Delhi • Mexico City\nSão Paulo • Sydney • Hong Kong • Seoul • Singapore • Taipei • Tokyo",
      "content_length": 262,
      "extraction_method": "Direct"
    },
    {
      "page_number": 5,
      "chapter": null,
      "content": "Many of the designations used by manufacturers and sellers to distinguish their products are claimed as\ntrademarks. Where those designations appear in this book, and the publisher was aware of a trademark\nclaim, the designations have been printed with initial capital letters or in all capitals.\nThe author and publisher have taken care in the preparation of this book, but make no expressed or\nimplied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumed\nfor incidental or consequential damages in connection with or arising out of the use of the information or\nprograms contained herein.\nFor information about buying this title in bulk quantities, or for special sales opportunities (which may\ninclude electronic versions; custom cover designs; and content particular to your business, training goals,\nmarketing focus, or branding interests), please contact our corporate sales department\nat corpsales@pearsoned.com or (800) 382-3419.\nFor government sales inquiries, please contact governmentsales@pearsoned.com.\nFor questions about sales outside the U.S., please contact intlcs@pearson.com.\nVisit us on the Web: informit.com/aw\nLibrary of Congress Control Number: 2021943288\nCopyright © 2022 Pearson Education, Inc.\nCover illustration by EHStockphoto/Shutterstock\nAll rights reserved. This publication is protected by copyright, and permission must be obtained from the\npublisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in any form or\nby any means, electronic, mechanical, photocopying, recording, or likewise. For information regarding\npermissions, request forms and the appropriate contacts within the Pearson Education Global Rights &\nPermissions Department, please visit www.pearson.com/permissions.\nISBN-13: 978-0-13-417327-6\nISBN-10: 0-13-417327-9\nScoutAutomatedPrintCode",
      "content_length": 1871,
      "extraction_method": "Direct"
    },
    {
      "page_number": 6,
      "chapter": null,
      "content": "Contents\nPreface\nxiii\n1\nPython Basics\n1\n1.1\nRunning Python\n1\n1.2\nPython Programs\n2\n1.3\nPrimitives, Variables, and\nExpressions\n3\n1.4\nArithmetic Operators\n5\n1.5\nConditionals and Control Flow\n7\n1.6\nText Strings\n9\n1.7\nFile Input and Output\n12\n1.8\nLists\n13\n1.9\nTuples\n15\n1.10\nSets\n17\n1.11\nDictionaries\n18\n1.12\nIteration and Looping\n21\n1.13\nFunctions\n22\n1.14\nExceptions\n24\n1.15\nProgram Termination\n26\n1.16\nObjects and Classes\n26\n1.17\nModules\n30\n1.18\nScript Writing\n32\n1.19\nPackages\n33\n1.20\nStructuring an Application\n34\n1.21\nManaging Third-Party Packages\n35\n1.22\nPython: It Fits Your Brain\n36\n2\nOperators, Expressions, and Data\nManipulation\n37\n2.1\nLiterals\n37\n2.2\nExpressions and Locations\n38\n2.3\nStandard Operators\n39\n2.4\nIn-Place Assignment\n41\n2.5\nObject Comparison\n42\n2.6\nOrdered Comparison Operators\n42",
      "content_length": 800,
      "extraction_method": "Direct"
    },
    {
      "page_number": 7,
      "chapter": null,
      "content": "vi\nContents\n2.7\nBoolean Expressions and Truth\nValues\n43\n2.8\nConditional Expressions\n44\n2.9\nOperations Involving Iterables\n45\n2.10\nOperations on Sequences\n47\n2.11\nOperations on Mutable\nSequences\n49\n2.12\nOperations on Sets\n50\n2.13\nOperations on Mappings\n51\n2.14\nList, Set, and Dictionary\nComprehensions\n52\n2.15\nGenerator Expressions\n54\n2.16\nThe Attribute (.) Operator\n56\n2.17\nThe Function Call () Operator\n56\n2.18\nOrder of Evaluation\n56\n2.19\nFinal Words: The Secret Life of\nData\n58\n3\nProgram Structure and Control\nFlow\n59\n3.1\nProgram Structure and\nExecution\n59\n3.2\nConditional Execution\n59\n3.3\nLoops and Iteration\n60\n3.4\nExceptions\n64\n3.4.1\nThe Exception\nHierarchy\n67\n3.4.2\nExceptions and Control\nFlow\n68\n3.4.3\nDefining New\nExceptions\n69\n3.4.4\nChained Exceptions\n70\n3.4.5\nException\nTracebacks\n73\n3.4.6\nException Handling\nAdvice\n73\n3.5\nContext Managers and the with\nStatement\n75\n3.6\nAssertions and __debug__\n77\n3.7\nFinal Words\n78",
      "content_length": 926,
      "extraction_method": "Direct"
    },
    {
      "page_number": 8,
      "chapter": null,
      "content": "Contents\nvii\n4\nObjects, Types, and Protocols\n79\n4.1\nEssential Concepts\n79\n4.2\nObject Identity and Type\n80\n4.3\nReference Counting and Garbage\nCollection\n81\n4.4\nReferences and Copies\n83\n4.5\nObject Representation and Printing\n84\n4.6\nFirst-Class Objects\n85\n4.7\nUsing None for Optional or Missing\nData\n87\n4.8\nObject Protocols and Data\nAbstraction\n87\n4.9\nObject Protocol\n89\n4.10\nNumber Protocol\n90\n4.11\nComparison Protocol\n92\n4.12\nConversion Protocols\n94\n4.13\nContainer Protocol\n95\n4.14\nIteration Protocol\n97\n4.15\nAttribute Protocol\n98\n4.16\nFunction Protocol\n98\n4.17\nContext Manager Protocol\n99\n4.18\nFinal Words: On Being Pythonic\n99\n5\nFunctions 101\n5.1\nFunction Definitions 101\n5.2\nDefault Arguments 101\n5.3\nVariadic Arguments 102\n5.4\nKeyword Arguments 103\n5.5\nVariadic Keyword Arguments 104\n5.6\nFunctions Accepting All Inputs 104\n5.7\nPositional-Only Arguments 105\n5.8\nNames, Documentation Strings, and Type\nHints 106\n5.9\nFunction Application and Parameter\nPassing 107\n5.10\nReturn Values 109\n5.11\nError Handling 110\n5.12\nScoping Rules 111\n5.13\nRecursion 114",
      "content_length": 1052,
      "extraction_method": "Direct"
    },
    {
      "page_number": 9,
      "chapter": null,
      "content": "viii\nContents\n5.14\nThe lambda Expression 114\n5.15\nHigher-Order Functions 115\n5.16\nArgument Passing in Callback\nFunctions 118\n5.17\nReturning Results from\nCallbacks 121\n5.18\nDecorators 124\n5.19\nMap, Filter, and Reduce 127\n5.20\nFunction Introspection, Attributes,\nand Signatures 129\n5.21\nEnvironment Inspection 131\n5.22\nDynamic Code Execution and\nCreation 133\n5.23\nAsynchronous Functions and\nawait 135\n5.24\nFinal Words: Thoughts on Functions\nand Composition 137\n6\nGenerators 139\n6.1\nGenerators and yield 139\n6.2\nRestartable Generators 142\n6.3\nGenerator Delegation 142\n6.4\nUsing Generators in Practice 144\n6.5\nEnhanced Generators and yield\nExpressions 146\n6.6\nApplications of Enhanced\nGenerators 148\n6.7\nGenerators and the Bridge to\nAwaiting 151\n6.8\nFinal Words: A Brief History of\nGenerators and Looking\nForward 152\n7\nClasses and Object-Oriented\nProgramming 153\n7.1\nObjects 153\n7.2\nThe class Statement 154\n7.3\nInstances 155\n7.4\nAttribute Access 156\n7.5\nScoping Rules 158",
      "content_length": 967,
      "extraction_method": "Direct"
    },
    {
      "page_number": 10,
      "chapter": null,
      "content": "Contents\nix\n7.6\nOperator Overloading and Protocols 159\n7.7\nInheritance 160\n7.8\nAvoiding Inheritance via Composition 163\n7.9\nAvoiding Inheritance via Functions 166\n7.10\nDynamic Binding and Duck Typing 167\n7.11\nThe Danger of Inheriting from Built-in\nTypes 167\n7.12\nClass Variables and Methods 169\n7.13\nStatic Methods 173\n7.14\nA Word about Design Patterns 176\n7.15\nData Encapsulation and Private\nAttributes 176\n7.16\nType Hinting 179\n7.17\nProperties 180\n7.18\nTypes, Interfaces, and Abstract Base\nClasses 183\n7.19\nMultiple Inheritance, Interfaces, and\nMixins 187\n7.20\nType-Based Dispatch 193\n7.21\nClass Decorators 194\n7.22\nSupervised Inheritance 197\n7.23\nThe Object Life Cycle and Memory\nManagement 199\n7.24\nWeak References 204\n7.25\nInternal Object Representation and\nAttribute Binding 206\n7.26\nProxies, Wrappers, and Delegation 208\n7.27\nReducing Memory Use with\n__slots__ 210\n7.28\nDescriptors 211\n7.29\nClass Definition Process 215\n7.30\nDynamic Class Creation 216\n7.31\nMetaclasses 217\n7.32\nBuilt-in Objects for Instances and\nClasses 222\n7.33\nFinal Words: Keep It Simple 223\n8\nModules and Packages 225\n8.1\nModules and the import Statement 225",
      "content_length": 1136,
      "extraction_method": "Direct"
    },
    {
      "page_number": 11,
      "chapter": null,
      "content": "x\nContents\n8.2\nModule Caching 227\n8.3\nImporting Selected Names from a\nModule 228\n8.4\nCircular Imports 230\n8.5\nModule Reloading and\nUnloading 232\n8.6\nModule Compilation 233\n8.7\nThe Module Search Path 234\n8.8\nExecution as the Main Program 234\n8.9\nPackages 235\n8.10\nImports Within a Package 237\n8.11\nRunning a Package Submodule as a\nScript 238\n8.12\nControlling the Package\nNamespace 239\n8.13\nControlling Package Exports 240\n8.14\nPackage Data 241\n8.15\nModule Objects 242\n8.16\nDeploying Python Packages 243\n8.17\nThe Penultimate Word: Start with a\nPackage 244\n8.18\nThe Final Word: Keep It Simple 245\n9\nInput and Output 247\n9.1\nData Representation 247\n9.2\nText Encoding and Decoding 248\n9.3\nText and Byte Formatting 250\n9.4\nReading Command-Line\nOptions 254\n9.5\nEnvironment Variables 256\n9.6\nFiles and File Objects 256\n9.6.1\nFilenames 257\n9.6.2\nFile Modes 258\n9.6.3\nI/O Buffering 258\n9.6.4\nText Mode Encoding 259\n9.6.5\nText-Mode Line\nHandling 260\n9.7\nI/O Abstraction Layers 260\n9.7.1\nFile Methods 261",
      "content_length": 992,
      "extraction_method": "Direct"
    },
    {
      "page_number": 12,
      "chapter": null,
      "content": "Contents\nxi\n9.8\nStandard Input, Output, and Error 263\n9.9\nDirectories 264\n9.10\nThe print() function 265\n9.11\nGenerating Output 265\n9.12\nConsuming Input 266\n9.13\nObject Serialization 268\n9.14\nBlocking Operations and\nConcurrency 269\n9.14.1\nNonblocking I/O 270\n9.14.2\nI/O Polling 271\n9.14.3\nThreads 271\n9.14.4\nConcurrent Execution with\nasyncio 272\n9.15\nStandard Library Modules 273\n9.15.1\nasyncio Module 273\n9.15.2\nbinascii Module 274\n9.15.3\ncgi Module 275\n9.15.4\nconfigparser Module 276\n9.15.5\ncsv Module 276\n9.15.6\nerrno Module 277\n9.15.7\nfcntl Module 278\n9.15.8\nhashlib Module 278\n9.15.9\nhttp Package 279\n9.15.10\nio Module 279\n9.15.11\njson Module 280\n9.15.12\nlogging Module 280\n9.15.13\nos Module 281\n9.15.14\nos.path Module 281\n9.15.15\npathlib Module 282\n9.15.16\nre Module 283\n9.15.17\nshutil Module 284\n9.15.18\nselect Module 284\n9.15.19\nsmtplib Module 285\n9.15.20\nsocket Module 286\n9.15.21\nstruct Module 288\n9.15.22\nsubprocess Module 288\n9.15.23\ntempfile Module 289\n9.15.24\ntextwrap Module 290",
      "content_length": 992,
      "extraction_method": "Direct"
    },
    {
      "page_number": 13,
      "chapter": null,
      "content": "xii\nContents\n9.15.25\nthreading Module 291\n9.15.26\ntime Module 293\n9.15.27\nurllib Package 293\n9.15.28\nunicodedata\nModule 294\n9.15.29\nxml Package 295\n9.16\nFinal Words 296\n10 Built-in Functions and Standard\nLibrary 297\n10.1\nBuilt-in Functions 297\n10.2\nBuilt-in Exceptions 314\n10.2.1\nException Base\nClasses 314\n10.2.2\nException Attributes 314\n10.2.3\nPredefined Exception\nClasses 315\n10.3\nStandard Library 318\n10.3.1\ncollections\nModule 318\n10.3.2\ndatetime Module 318\n10.3.3\nitertools Module 318\n10.3.4\ninspect Module 318\n10.3.5\nmath Module 318\n10.3.6\nos Module 319\n10.3.7\nrandom Module 319\n10.3.8\nre Module 319\n10.3.9\nshutil Module 319\n10.3.10\nstatistics\nModule 319\n10.3.11\nsys Module 319\n10.3.12\ntime Module 319\n10.3.13\nturtle Module 319\n10.3.14\nunittest Module 319\n10.4\nFinal Words: Use the Built-Ins 320\nIndex 321",
      "content_length": 811,
      "extraction_method": "Direct"
    },
    {
      "page_number": 14,
      "chapter": null,
      "content": "Preface\nMore than 20 years have passed since I authored the Python Essential Reference. At that time,\nPython was a much smaller language and it came with a useful set of batteries in its\nstandard library. It was something that could mostly fit in your brain. The Essential Reference\nreflected that era. It was a small book that you could take with you to write some Python\ncode on a desert island or inside a secret vault. Over the three subsequent revisions, the\nEssential Reference stuck with this vision of being a compact but complete language\nreference—because if you’re going to code in Python on vacation, why not use all of it?\nToday, more than a decade since the publication of the last edition, the Python world is\nmuch different. No longer a niche language, Python has become one of the most popular\nprogramming languages in the world. Python programmers also have a wealth of\ninformation at their fingertips in the form of advanced editors, IDEs, notebooks, web\npages, and more. In fact, there’s probably little need to consult a reference book when\nalmost any reference material you might want can be conjured to appear before your eyes\nwith the touch of a few keys.\nIf anything, the ease of information retrieval and the scale of the Python universe\npresents a different kind of challenge. If you’re just starting to learn or need to solve a new\nproblem, it can be overwhelming to know where to begin. It can also be difficult to\nseparate the features of various tools from the core language itself. These kinds of problems\nare the rationale for this book.\nPython Distilled is a book about programming in Python. It’s not trying to document\neverything that’s possible or has been done in Python. Its focus is on presenting a modern\nyet curated (or distilled) core of the language. It has been informed by my years of teaching\nPython to scientists, engineers, and software professionals. However, it’s also a product of\nwriting software libraries, pushing the edges of what makes Python tick, and finding out\nwhat’s most useful.\nFor the most part, the book focuses on Python programming itself. This includes\nabstraction techniques, program structure, data, functions, objects, modules, and so\nforth—topics that will well serve programmers working on Python projects of any size.\nPure reference material that can be easily obtained via an IDE (such as lists of functions,\nnames of commands, arguments, etc.) is generally omitted. I’ve also made a conscious\nchoice to not describe the fast-changing world of Python tooling—editors, IDEs,\ndeployment, and related matters.\nPerhaps controversially, I don’t generally focus on language features related to large-scale\nsoftware project management. Python is sometimes used for big and serious things—\ncomprised of millions upon millions of lines of code. Such applications require specialized\ntooling, design, and features. They also involve committees, and meetings, and decisions\nto be made about very important matters. All this is too much for this small book. But",
      "content_length": 3025,
      "extraction_method": "Direct"
    },
    {
      "page_number": 15,
      "chapter": null,
      "content": "xiv\nPreface\nperhaps the honest answer is that I don’t use Python to write such applications—and\nneither should you. At least not as a hobby.\nIn writing a book, there is always a cut-off for the ever-evolving language features. This\nbook was written during the era of Python 3.9. As such, it does not include some of the\nmajor additions planned for later releases—for example, structural pattern matching.\nThat’s a topic for a different time and place.\nLast, but not least, I think it’s important that programming remains fun. I hope that my\nbook will not only help you become a productive Python programmer but also capture\nsome of the magic that has inspired people to use Python for exploring the stars, flying\nhelicopters on Mars, and spraying squirrels with a water cannon in the backyard.\nAcknowledgments\nI’d like to thank the technical reviewers, Shawn Brown, Sophie Tabac, and Pete Fein, for\ntheir helpful comments. I’d also like to thank my long-time editor Debra Williams Cauley\nfor her work on this and past projects. The many students who have taken my classes have\nhad a major if indirect impact on the topics covered in this book. Last, but not least, I’d\nlike to thank Paula, Thomas, and Lewis for their support and love.\nAbout the Author\nDavid Beazley is the author of the Python Essential Reference, Fourth Edition\n(Addison-Wesley, 2010) and Python Cookbook, Third Edition (O’Reilly, 2013). He\ncurrently teaches advanced computer science courses through his company Dabeaz LLC\n( www.dabeaz.com ). He’s been using, writing, speaking, and teaching about Python\nsince 1996.",
      "content_length": 1586,
      "extraction_method": "Direct"
    },
    {
      "page_number": 16,
      "chapter": null,
      "content": "1\nPython Basics\nThis chapter gives an overview of the core of the Python language. It covers variables,\ndata types, expressions, control flow, functions, classes, and input/output. The chapter\nconcludes with a discussion of modules, script writing, packages, and a few tips on\norganizing larger programs. This chapter is not trying to provide comprehensive coverage\nof every feature, nor does it concern itself with all of the tooling that might surround a\nlarger Python project. However, experienced programmers should be able to extrapolate\nfrom the material here to write more advanced programs. Newcomers are encouraged to\ntry the examples in a simple environment, such as a terminal window and a basic text\neditor.\n1.1\nRunning Python\nPython programs are executed by an interpreter. There are many different environments\nin which the Python interpreter might run—an IDE, a browser, or a terminal window.\nHowever, underneath all that, the core of the interpreter is a text-based application that\ncan be started by typing python in a command shell such as bash. Since Python 2 and\nPython 3 might both be installed on the same machine, you might need to type python2\nor python3 to pick a version. This book assumes Python 3.8 or newer.\nWhen the interpreter starts, a prompt appears where you can type programs into a\nso-called “read-evaluation-print loop” (or REPL). For example, in the following output,\nthe interpreter displays its copyright message and presents the user with the >>> prompt, at\nwhich the user types a familiar “Hello World” program:\nPython 3.8.0 (default, Feb\n3 2019, 05:53:21)\n[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.38)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> print('Hello World')\nHello World\n>>>",
      "content_length": 1777,
      "extraction_method": "Direct"
    },
    {
      "page_number": 17,
      "chapter": null,
      "content": "2\nChapter 1\nPython Basics\nCertain environments may display a different prompt. The following output is from\nipython (an alternate shell for Python):\nPython 3.8.0 (default, Feb 4, 2019, 07:39:16)\nType 'copyright', 'credits' or 'license' for more information\nIPython 6.5.0 -- An enhanced Interactive Python. Type '?' for help.\nIn [1]: print('Hello World')\nHello World\nIn [2]:\nRegardless of the exact form of output you see, the underlying principle is the same.\nYou type a command, it runs, and you immediately see the output.\nPython’s interactive mode is one of its most useful features because you can type any\nvalid statement and immediately see the result. This is useful for debugging and\nexperimentation. Many people, including the author, use interactive Python as their\ndesktop calculator. For example:\n>>> 6000 + 4523.50 + 134.25\n10657.75\n>>> _ + 8192.75\n18850.5\n>>>\nWhen you use Python interactively, the variable _ holds the result of the last operation.\nThis is useful if you want to use that result in subsequent statements. This variable only\ngets defined when working interactively, so don’t use it in saved programs.\nYou can exit the interactive interpreter by typing quit() or the EOF (end of file)\ncharacter. On UNIX, EOF is Ctrl+D; on Windows, it’s Ctrl+Z.\n1.2\nPython Programs\nIf you want to create a program that you can run repeatedly, put statements in a text file.\nFor example:\n# hello.py\nprint('Hello World')\nPython source files are UTF-8-encoded text files that normally have a .py suffix. The\n# character denotes a comment that extends to the end of the line. International (Unicode)\ncharacters can be freely used in the source code as long as you use the UTF-8 encoding\n(this is the default in most editors, but it never hurts to check your editor settings if you’re\nunsure).",
      "content_length": 1800,
      "extraction_method": "Direct"
    },
    {
      "page_number": 18,
      "chapter": null,
      "content": "1.3 Primitives, Variables, and Expressions\n3\nTo execute the hello.py file, provide the filename to the interpreter as follows:\nshell % python3 hello.py\nHello World\nshell %\nIt is common to use #! to specify the interpreter on the first line of a program, like this:\n#!/usr/bin/env python3\nprint('Hello World')\nOn UNIX, if you give this file execute permissions (for example, by chmod +x\nhello.py), you can run the program by typing hello.py into your shell.\nOn Windows, you can double-click on a .py file or type the name of the program into\nthe Run command on the Windows Start menu to launch it. The #! line, if given, is used\nto pick the interpreter version (Python 2 versus 3). Execution of a program might take\nplace in a console window that disappears immediately after the program completes—\noften before you can read its output. For debugging, it’s better to run the program within\na Python development environment.\nThe interpreter runs statements in order until it reaches the end of the input file. At\nthat point, the program terminates and Python exits.\n1.3\nPrimitives, Variables, and Expressions\nPython provides a collection of primitive types such as integers, floats, and strings:\n42\n# int\n4.2\n# float\n'forty-two'\n# str\nTrue\n# bool\nA variable is a name that refers to a value. A value represents an object of some type:\nx = 42\nSometimes you might see a type explicitly attached to a name. For example:\nx: int = 42\nThe type is merely a hint to improve code readability. It can be used by third-party\ncode-checking tools. Otherwise, it is completely ignored. It does not prevent you from\nassigning a different kind of value later.\nAn expression is a combination of primitives, names, and operators that produces a\nvalue:\n2 + 3 * 4\n# -> 14",
      "content_length": 1749,
      "extraction_method": "Direct"
    },
    {
      "page_number": 19,
      "chapter": null,
      "content": "4\nChapter 1\nPython Basics\nThe following program uses variables and expressions to perform a compound-interest\ncalculation:\n# interest.py\nprincipal = 1000\n# Initial amount\nrate = 0.05\n# Interest rate\nnumyears = 5\n# Number of years\nyear = 1\nwhile year <= numyears:\nprincipal = principal * (1 + rate)\nprint(year, principal)\nyear += 1\nWhen executed, it produces the following output:\n1 1050.0\n2 1102.5\n3 1157.625\n4 1215.5062500000001\n5 1276.2815625000003\nThe while statement tests the conditional expression that immediately follows. If the\ntested condition is true, the body of the while statement executes. The condition is\nthen retested and the body executed again until the condition becomes false. The body\nof the loop is denoted by indentation. Thus, the three statements following while in\ninterest.py execute on each iteration. Python doesn’t specify the amount of required\nindentation, as long as it’s consistent within a block. It is most common to use four spaces\nper indentation level.\nOne problem with the interest.py program is that the output isn’t very pretty. To\nmake it better, you could right-align the columns and limit the precision of principal\nto two digits. Change the print() function to use a so-called f-string like this:\nprint(f'{year:>3d} {principal:0.2f}')\nIn the f-string, variable names and expressions can be evaluated by enclosing them in\ncurly braces. Optionally, each substitution can have a formatting specifier attached to it.\n'>3d' means a three-digit decimal number, right aligned. '0.2f' means a floating-point\nnumber with two decimal places of accuracy. More information about these formatting\ncodes can be found in Chapter 9.\nNow the output of the program looks like this:\n1 1050.00\n2 1102.50\n3 1157.62\n4 1215.51\n5 1276.28",
      "content_length": 1761,
      "extraction_method": "Direct"
    },
    {
      "page_number": 20,
      "chapter": null,
      "content": "1.4 Arithmetic Operators\n5\n1.4\nArithmetic Operators\nPython has a standard set of mathematical operators, shown in Table 1.1. These operators\nhave the same meaning they do in most other programming languages.\nTable 1.1\nArithmetic Operators\nOperation\nDescription\nx + y\nAddition\nx - y\nSubtraction\nx * y\nMultiplication\nx / y\nDivision\nx // y\nTruncating division\nx ** y\nPower (x to the y power)\nx % y\nModulo (x mod y). Remainder.\n–x\nUnary minus\n+x\nUnary plus\nThe division operator (/) produces a floating-point number when applied to integers.\nTherefore, 7/4 is 1.75. The truncating division operator //, also known as floor division,\ntruncates the result to an integer and works with both integers and floating-point\nnumbers. The modulo operator returns the remainder of the division x // y. For\nexample, 7 % 4 is 3. For floating-point numbers, the modulo operator returns the\nfloating-point remainder of x // y, which is x – (x // y) * y.\nIn addition, the built-in functions in Table 1.2 provide a few more commonly used\nnumerical operations.\nTable 1.2\nCommon Mathematic Functions\nFunction\nDescription\nabs(x)\nAbsolute value\ndivmod(x,y)\nReturns (x // y, x % y)\npow(x,y [,modulo])\nReturns (x ** y) % modulo\nround(x,[n])\nRounds to the nearest multiple of 10 to the nth power.\nThe round() function implements “banker’s rounding.” If the value being rounded is\nequally close to two multiples, it is rounded to the nearest even multiple (for example, 0.5\nis rounded to 0.0, and 1.5 is rounded to 2.0).\nIntegers provide a few additional operators to support bit manipulation, shown in\nTable 1.3.",
      "content_length": 1584,
      "extraction_method": "Direct"
    },
    {
      "page_number": 21,
      "chapter": null,
      "content": "6\nChapter 1\nPython Basics\nTable 1.3\nBit Manipulation Operators\nOperation\nDescription\nx << y\nLeft shift\nx >> y\nRight shift\nx & y\nBitwise and\nx | y\nBitwise or\nx ^ y\nBitwise xor (exclusive or)\n~x\nBitwise negation\nOne would commonly use these with binary integers. For example:\na = 0b11001001\nmask = 0b11110000\nx = (a & mask) >> 4\n# x = 0b1100 (12)\nIn this example, 0b11001001 is how you write an integer value in binary. You could\nhave written it as decimal 201 or hexadecimal 0xc9, but if you’re fiddling with bits, binary\nmakes it easier to visualize what you’re doing.\nThe semantics of the bitwise operators assumes that the integers use a two’s\ncomplement binary representation and that the sign bit is infinitely extended to the left.\nSome care is required if you are working with raw bit patterns that are intended to map to\nnative integers on the hardware. This is because Python does not truncate the bits or allow\nvalues to overflow—instead, the result will grow arbitrarily large in magnitude. It’s up to\nyou to make sure the result is properly sized or truncated if needed.\nTo compare numbers, use the comparison operators in Table 1.4.\nTable 1.4\nComparison Operators\nOperation\nDescription\nx == y\nEqual to\nx != y\nNot equal to\nx < y\nLess than\nx > y\nGreater than\nx >= y\nGreater than or equal to\nx <= y\nLess than or equal to\nThe result of a comparison is a Boolean value True or False.\nThe and, or, and not operators (not to be confused with the bit-manipulation\noperators above) can form more complex Boolean expressions. The behavior of these\noperators is as shown in Table 1.5.\nA value is considered false if it is literally False, None, numerically zero, or empty.\nOtherwise, it’s considered true.",
      "content_length": 1706,
      "extraction_method": "Direct"
    },
    {
      "page_number": 22,
      "chapter": null,
      "content": "1.5 Conditionals and Control Flow\n7\nTable 1.5\nLogical Operators\nOperator\nDescription\nx or y\nIf x is false, return y; otherwise, return x.\nx and y\nIf x is false, return x; otherwise, return y.\nnot x\nIf x is false, return True; otherwise, return False.\nIt is common to write an expression that updates a value. For example:\nx = x + 1\ny = y * n\nFor these, you can write the following shortened operation instead:\nx += 1\ny *= n\nThis shortened form of update can be used with any of the +, -, *, **, /, //, %, &, |, ^,\n<<, >> operators. Python does not have increment (++) or decrement (--) operators found\nin some other languages.\n1.5\nConditionals and Control Flow\nThe while, if and else statements are used for looping and conditional code execution.\nHere’s an example:\nif a < b:\nprint('Computer says Yes')\nelse:\nprint('Computer says No')\nThe bodies of the if and else clauses are denoted by indentation. The else clause is\noptional. To create an empty clause, use the pass statement, as follows:\nif a < b:\npass\n# Do nothing\nelse:\nprint('Computer says No')\nTo handle multiple-test cases, use the elif statement:\nif suffix == '.htm':\ncontent = 'text/html'\nelif suffix == '.jpg':\ncontent = 'image/jpeg'",
      "content_length": 1197,
      "extraction_method": "Direct"
    },
    {
      "page_number": 23,
      "chapter": null,
      "content": "8\nChapter 1\nPython Basics\nelif suffix == '.png':\ncontent = 'image/png'\nelse:\nraise RuntimeError(f'Unknown content type {suffix!r}')\nIf you are assigning a value in combination with a test, use a conditional expression:\nmaxval = a if a > b else b\nThis is the same as the longer:\nif a > b:\nmaxval = a\nelse:\nmaxval = b\nSometimes, you may see the assignment of a variable and a conditional combined\ntogether using the := operator. This is known as an assignment expression (or more\ncolloquially as the “walrus operator” because := looks like a walrus tipped over on its\nside—presumably playing dead). For example:\nx = 0\nwhile (x := x + 1) < 10:\n# Prints 1, 2, 3, ..., 9\nprint(x)\nThe parentheses used to surround an assignment expression are always required.\nThe break statement can be used to abort a loop early. It only applies to the innermost\nloop. For example:\nx = 0\nwhile x < 10:\nif x == 5:\nbreak\n# Stops the loop. Moves to Done below\nprint(x)\nx += 1\nprint('Done')\nThe continue statement skips the rest of the loop body and goes back to the top of the\nloop. For example:\nx = 0\nwhile x < 10:\nx += 1\nif x == 5:\ncontinue\n# Skips the print(x). Goes back to loop start.\nprint(x)\nprint('Done')",
      "content_length": 1188,
      "extraction_method": "Direct"
    },
    {
      "page_number": 24,
      "chapter": null,
      "content": "1.6 Text Strings\n9\n1.6\nText Strings\nTo define a string literal, enclose it in single, double, or triple quotes as follows:\na = 'Hello World'\nb = \"Python is groovy\"\nc = '''Computer says no.'''\nd = \"\"\"Computer still says no.\"\"\"\nThe same type of quote used to start a string must be used to terminate it. Triple-\nquoted strings capture all the text until the terminating triple quote—as opposed to single-\nand double-quoted strings which must be specified on one logical line. Triple-quoted\nstrings are useful when the contents of a string literal span multiple lines of text:\nprint('''Content-type: text/html\n<h1> Hello World </h1>\nClick <a href=\"http://www.python.org\">here</a>.\n''')\nImmediately adjacent string literals are concatenated into a single string. Thus, the\nabove example could also be written as:\nprint(\n'Content-type: text/html\\n'\n'\\n'\n'<h1> Hello World </h1>\\n'\n'Clock <a href=\"http://www.python.org\">here</a>\\n'\n)\nIf the opening quotation mark of a string is prefaced by an f, escaped expressions\nwithin a string are evaluated. For example, in earlier examples, the following statement was\nused to output values of a calculation:\nprint(f'{year:>3d} {principal:0.2f}')\nAlthough this is only using simple variable names, any valid expression can appear. For\nexample:\nbase_year = 2020\n...\nprint(f'{base_year + year:>4d} {principal:0.2f}')\nAs an alternative to f-strings, the format() method and % operator are also sometimes\nused to format strings. For example:\nprint('{0:>3d} {1:0.2f}'.format(year, principal))\nprint('%3d %0.2f' % (year, principal))",
      "content_length": 1562,
      "extraction_method": "Direct"
    },
    {
      "page_number": 25,
      "chapter": null,
      "content": "10\nChapter 1\nPython Basics\nMore information about string formatting is found in Chapter 9.\nStrings are stored as sequences of Unicode characters indexed by integers, starting at\nzero. Negative indices index from the end of the string. The length of a string s is\ncomputed using len(s). To extract a single character, use the indexing operator s[i]\nwhere i is the index.\na = 'Hello World'\nprint(len(a))\n# 11\nb = a[4]\n# b = 'o'\nc = a[-1]\n# c = 'd'\nTo extract a substring, use the slicing operator s[i:j]. It extracts all characters from s\nwhose index k is in the range i <= k < j. If either index is omitted, the beginning or end\nof the string is assumed, respectively:\nc = a[:5]\n# c = 'Hello'\nd = a[6:]\n# d = 'World'\ne = a[3:8]\n# e = 'lo Wo'\nf = a[-5:]\n# f = 'World'\nStrings have a variety of methods for manipulating their contents. For example, the\nreplace() method performs a simple text replacement:\ng = a.replace('Hello', 'Hello Cruel')\n# f = 'Hello Cruel World'\nTable 1.6 shows a few common string methods. Here and elsewhere, arguments\nenclosed in square brackets are optional.\nTable 1.6\nCommon String Methods\nMethod\nDescription\ns.endswith(prefix [,start [,end]])\nChecks whether a string ends with prefix.\ns.find(sub [, start [,end]])\nFinds the first occurrence of the specified\nsubstring sub or -1 if not found.\ns.lower()\nConverts to lowercase.\ns.replace(old, new [,maxreplace])\nReplaces a substring.\ns.split([sep [,maxsplit]])\nSplits a string using sep as a delimiter.\nmaxsplit is the maximum number of splits to\nperform.\ns.startswith(prefix [,start [,end]])\nChecks whether a string starts with prefix.\ns.strip([chrs])\nRemoves leading and trailing whitespace or\ncharacters supplied in chrs.\ns.upper()\nConverts a string to uppercase.\nStrings are concatenated with the plus (+) operator:\ng = a + 'ly'\n# g = 'Hello Worldly'",
      "content_length": 1828,
      "extraction_method": "Direct"
    },
    {
      "page_number": 26,
      "chapter": null,
      "content": "1.6 Text Strings\n11\nPython never implicitly interprets the contents of a string as numerical data. Thus, +\nalways concatenates strings:\nx = '37'\ny = '42'\nz = x + y\n# z = '3742' (String Concatenation)\nTo perform mathematical calculations, a string first has to be converted into a numeric\nvalue using a function such as int() or float(). For example:\nz = int(x) + int(y)\n# z = 79\n(Integer Addition)\nNon-string values can be converted into a string representation by using the str(),\nrepr(), or format() functions. Here’s an example:\ns = 'The value of x is ' + str(x)\ns = 'The value of x is ' + repr(x)\ns = 'The value of x is ' + format(x, '4d')\nAlthough str() and repr() both create strings, their output is often different. str()\nproduces the output that you get when you use the print() function, whereas repr()\ncreates a string that you type into a program to exactly represent the value of an object.\nFor example:\n>>> s = 'hello\\nworld'\n>>> print(str(s))\nhello\nworld\n>>> print(repr(s))\n'hello\\nworld'\n>>>\nWhen debugging, use repr(s) to produce output because it shows you more\ninformation about a value and its type.\nThe format() function is used to convert a single value to a string with a specific\nformatting applied. For example:\n>>> x = 12.34567\n>>> format(x, '0.2f')\n'12.35'\n>>>\nThe format code given to format() is the same code you would use with f-strings\nwhen producing formatted output. For example, the above code could be replaced by the\nfollowing:\n>>> f'{x:0.2f}'\n'12.35'\n>>>",
      "content_length": 1492,
      "extraction_method": "Direct"
    },
    {
      "page_number": 27,
      "chapter": null,
      "content": "12\nChapter 1\nPython Basics\n1.7\nFile Input and Output\nThe following program opens a file and reads its contents line by line as text strings:\nwith open('data.txt') as file:\nfor line in file:\nprint(line, end='')\n# end='' omits the extra newline\nThe open() function returns a new file object. The with statement that precedes it\ndeclares a block of statements (or context) where the file (file) is going to be used. Once\ncontrol leaves this block, the file is automatically closed. If you don’t use the with\nstatement, the code would need to look like this:\nfile = open('data.txt')\nfor line in file:\nprint(line, end='')\n# end='' omits the extra newline\nfile.close()\nIt’s easy to forget the extra step of calling close() so it’s better to use the with\nstatement and have the file closed for you.\nThe for loop iterates line-by-line over the file until no more data is available.\nIf you want to read the file in its entirety as a string, use the read() method like this:\nwith open('data.txt') as file:\ndata = file.read()\nIf you want to read a large file in chunks, give a size hint to the read() method as\nfollows:\nwith open('data.txt') as file:\nwhile (chunk := file.read(10000)):\nprint(chunk, end='')\nThe := operator used in this example assigns to a variable and returns its value so that it\ncan be tested by the while loop to break out. When the end of a file is reached, read()\nreturns an empty string. An alternate way to write the above function is using break:\nwith open('data.txt') as file:\nwhile True:\nchunk = file.read(10000)\nif not chunk:\nbreak\nprint(chunk, end='')\nTo make the output of a program go to a file, supply a file argument to the print()\nfunction:\nwith open('out.txt', 'wt') as out:\nwhile year <= numyears:",
      "content_length": 1723,
      "extraction_method": "Direct"
    },
    {
      "page_number": 28,
      "chapter": null,
      "content": "1.8 Lists\n13\nprincipal = principal * (1 + rate)\nprint(f'{year:>3d} {principal:0.2f}', file=out)\nyear += 1\nIn addition, file objects support a write() method that can be used to write string data.\nFor example, the print() function in the previous example could have been written\nthis way:\nout.write(f'{year:3d} {principal:0.2f}\\n')\nBy default, files contain text encoded as UTF-8. If you’re working with a different text\nencoding, use the extra encoding argument when opening the file. For example:\nwith open('data.txt', encoding='latin-1') as file:\ndata = file.read()\nSometimes you might want to read data typed interactively in the console. To do that,\nuse the input() function. For example:\nname = input('Enter your name : ')\nprint('Hello', name)\nThe input() function returns all of the typed text up to the terminating newline,\nwhich is not included.\n1.8\nLists\nLists are an ordered collection of arbitrary objects. Create a list by enclosing values in\nsquare brackets:\nnames = [ 'Dave', 'Paula', 'Thomas', 'Lewis' ]\nLists are indexed by integers, starting with zero. Use the indexing operator to access and\nmodify individual items of the list:\na = names[2]\n# Returns the third item of the list, 'Thomas'\nnames[2] = 'Tom'\n# Changes the third item to 'Tom'\nprint(names[-1])\n# Print the last item ('Lewis')\nTo append new items to the end of a list, use the append() method:\nnames.append('Alex')\nTo insert an item in the list at a specific position, use the insert() method:\nnames.insert(2, 'Aya')\nTo iterate over the items in a list, use a for loop:",
      "content_length": 1549,
      "extraction_method": "Direct"
    },
    {
      "page_number": 29,
      "chapter": null,
      "content": "14\nChapter 1\nPython Basics\nfor name in names:\nprint(name)\nYou can extract or reassign a portion of a list by using the slicing operator:\nb = names[0:2]\n# b -> ['Dave', 'Paula']\nc = names[2:]\n# c -> ['Aya', 'Tom', 'Lewis', 'Alex']\nnames[1] = 'Becky'\n# Replaces 'Paula' with 'Becky'\nnames[0:2] = ['Dave', 'Mark', 'Jeff'] # Replace the first two items\n# with ['Dave','Mark','Jeff']\nUse the plus (+) operator to concatenate lists:\na = ['x','y'] + ['z','z','y']\n# Result is ['x','y','z','z','y']\nAn empty list is created in one of two ways:\nnames = []\n# An empty list\nnames = list()\n# An empty list\nSpecifying [] for an empty list is more idiomatic. list is the name of the class\nassociated with the list type. It’s more common to see it used when performing\nconversions of data to a list. For example:\nletters = list('Dave')\n# letters = ['D', 'a', 'v', 'e']\nMost of the time, all of the items in a list are of the same type (for example, a list of\nnumbers or a list of strings). However, lists can contain any mix of Python objects,\nincluding other lists, as in the following example:\na = [1, 'Dave', 3.14, ['Mark', 7, 9, [100, 101]], 10]\nItems contained in nested lists are accessed by applying more than one indexing\noperation:\na[1]\n# Returns 'Dave'\na[3][2]\n# Returns 9\na[3][3][1]\n# Returns 101\nThe following program pcost.py illustrates how to read data into a list and perform a\nsimple calculation. In this example, lines are assumed to contain comma-separated values.\nThe program computes the sum of the product of two columns.\n# pcost.py\n#\n# Reads input lines of the form 'NAME,SHARES,PRICE'.\n# For example:\n#\n#\nSYM,123,456.78",
      "content_length": 1628,
      "extraction_method": "Direct"
    },
    {
      "page_number": 30,
      "chapter": null,
      "content": "1.9 Tuples\n15\nimport sys\nif len(sys.argv) != 2:\nraise SystemExit(f'Usage: {sys.argv[0]} filename')\nrows = []\nwith open(sys.argv[1], 'rt') as file:\nfor line in file:\nrows.append(line.split(','))\n# rows is a list of this form\n# [\n#\n['SYM', '123', '456.78']\n#\n...\n# ]\ntotal = sum([ int(row[1]) * float(row[2]) for row in rows ])\nprint(f'Total cost: {total:0.2f}')\nThe first line of this program uses the import statement to load the sys module from\nthe Python library. This module is used to obtain command-line arguments which are\nfound in the list sys.argv. The initial check makes sure that a filename has been provided.\nIf not, a SystemExit exception is raised with a helpful error message. In this message,\nsys.argv[0] inserts the name of the program that’s running.\nThe open() function uses the filename that was specified on the command line. The\nfor line in file loop is reading the file line by line. Each line is split into a small list\nusing the comma character as a delimiter. This list is appended to rows. The final result,\nrows, is a list of lists—remember that a list can contain anything including other lists.\nThe expression [ int(row[1]) * float(row[2]) for row in rows ] constructs a new\nlist by looping over all of the lists in rows and computing the product of the second and\nthird items. This useful technique for constructing a list is known as a list comprehension.\nThe same computation could have been expressed more verbosely as follows:\nvalues = []\nfor row in rows:\nvalues.append(int(row[1]) * float(row[2]))\ntotal = sum(values)\nAs a general rule, list comprehensions are a preferred technique for performing simple\ncalculations. The built-in sum() function computes the sum for all items in a sequence.\n1.9\nTuples\nTo create simple data structures, you can pack a collection of values into an immutable\nobject known as a tuple. You create a tuple by enclosing a group of values in parentheses:",
      "content_length": 1918,
      "extraction_method": "Direct"
    },
    {
      "page_number": 31,
      "chapter": null,
      "content": "16\nChapter 1\nPython Basics\nholding = ('GOOG', 100, 490.10)\naddress = ('www.python.org', 80)\nFor completeness, 0- and 1-element tuples can be defined, but have special syntax:\na = ()\n# 0-tuple (empty tuple)\nb = (item,)\n# 1-tuple (note the trailing comma)\nThe values in a tuple can be extracted by numerical index just like a list. However, it is\nmore common to unpack tuples into a set of variables, like this:\nname, shares, price = holding\nhost, port = address\nAlthough tuples support most of the same operations as lists (such as indexing, slicing,\nand concatenation), the elements of a tuple cannot be changed after creation—that is, you\ncannot replace, delete, or append new elements to an existing tuple. A tuple is best viewed\nas a single immutable object that consists of several parts, not as a collection of distinct\nobjects like a list.\nTuples and lists are often used together to represent data. For example, this program\nshows how you might read a file containing columns of data separated by commas:\n# File containing lines of the form ``name,shares,price\"\nfilename = 'portfolio.csv'\nportfolio = []\nwith open(filename) as file:\nfor line in file:\nrow = line.split(',')\nname = row[0]\nshares = int(row[1])\nprice = float(row[2])\nholding = (name, shares, price)\nportfolio.append(holding)\nThe resulting portfolio list created by this program looks like a two-dimensional array\nof rows and columns. Each row is represented by a tuple and can be accessed as follows:\n>>> portfolio[0]\n('AA', 100, 32.2)\n>>> portfolio[1]\n('IBM', 50, 91.1)\n>>>\nIndividual items of data can be accessed like this:\n>>> portfolio[1][1]\n50",
      "content_length": 1619,
      "extraction_method": "Direct"
    },
    {
      "page_number": 32,
      "chapter": null,
      "content": "1.10 Sets\n17\n>>> portfolio[1][2]\n91.1\n>>>\nHere’s how to loop over all of the records and unpack fields into a set of variables:\ntotal = 0.0\nfor name, shares, price in portfolio:\ntotal += shares * price\nAlternatively, you could use a list comprehension:\ntotal = sum([shares * price for _, shares, price in portfolio])\nWhen iterating over tuples, the variable _ can be used to indicate a discarded value. In\nthe above calculation, it means we’re ignoring the first item (the name).\n1.10\nSets\nA set is an unordered collection of unique objects. Sets are used to find distinct values or to\nmanage problems related to membership. To create a set, enclose a collection of values in\ncurly braces or give an existing collection of items to set(). For example:\nnames1 = { 'IBM', 'MSFT', 'AA' }\nnames2 = set(['IBM', 'MSFT', 'HPE', 'IBM', 'CAT'])\nThe elements of a set are typically restricted to immutable objects. For example, you can\nmake a set of numbers, strings, or tuples. However, you can’t make a set containing lists.\nMost common objects will probably work with a set, however—when in doubt, try it.\nUnlike lists and tuples, sets are unordered and cannot be indexed by numbers.\nMoreover, the elements of a set are never duplicated. For example, if you inspect the value\nof names2 from the preceding code, you get the following:\n>>> names2\n{'CAT', 'IBM', 'MSFT', 'HPE'}\n>>>\nNotice that 'IBM' only appears once. Also, the order of items can’t be predicted; the\noutput may vary from what’s shown. The order might even change between interpreter\nruns on the same computer.\nIf working with existing data, you can also create a set using a set comprehension. For\nexample, this statement turns all of the stock names from the data in the previous section\ninto a set:\nnames = { s[0] for s in portfolio }",
      "content_length": 1794,
      "extraction_method": "Direct"
    },
    {
      "page_number": 33,
      "chapter": null,
      "content": "18\nChapter 1\nPython Basics\nTo create an empty set, use set() with no arguments:\nr = set()\n# Initially empty set\nSets support a standard collection of operations including union, intersection,\ndifference, and symmetric difference. Here’s an example:\na = t | s\n# Union {'MSFT', 'CAT', 'HPE', 'AA', 'IBM'}\nb = t & s\n# Intersection {'IBM', 'MSFT'}\nc = t - s\n# Difference { 'CAT', 'HPE' }\nd = s - t\n# Difference { 'AA' }\ne = t ^ s\n# Symmetric difference { 'CAT', 'HPE', 'AA' }\nThe difference operation s - t gives items in s that aren’t in t. The symmetric\ndifference s ^ t gives items that are in either s or t but not in both.\nNew items can be added to a set using add() or update():\nt.add('DIS')\n# Add a single item\ns.update({'JJ', 'GE', 'ACME'}) # Adds multiple items to s\nAn item can be removed using remove() or discard():\nt.remove('IBM')\n# Remove 'IBM' or raise KeyError if absent.\ns.discard('SCOX')\n# Remove 'SCOX' if it exists.\nThe difference between remove() and discard() is that discard() doesn’t raise an\nexception if the item isn’t present.\n1.11\nDictionaries\nA dictionary is a mapping between keys and values. You create a dictionary by enclosing\nthe key-value pairs, each separated by a colon, in curly braces ({ }), like this:\ns = {\n'name' : 'GOOG',\n'shares' : 100,\n'price' : 490.10\n}\nTo access members of a dictionary, use the indexing operator as follows:\nname = s['name']\ncost = s['shares'] * s['price']\nInserting or modifying objects works like this:\ns['shares'] = 75\ns['date'] = '2007-06-07'",
      "content_length": 1507,
      "extraction_method": "Direct"
    },
    {
      "page_number": 34,
      "chapter": null,
      "content": "1.11 Dictionaries\n19\nA dictionary is a useful way to define an object that consists of named fields. However,\ndictionaries are also commonly used as a mapping for performing fast lookups on\nunordered data. For example, here’s a dictionary of stock prices:\nprices = {\n'GOOG' : 490.1,\n'AAPL' : 123.5,\n'IBM' : 91.5,\n'MSFT' : 52.13\n}\nGiven such a dictionary, you can look up a price:\np = prices['IBM']\nDictionary membership is tested with the in operator:\nif 'IBM' in prices:\np = prices['IBM']\nelse:\np = 0.0\nThis particular sequence of steps can also be performed more compactly using the\nget() method:\np = prices.get('IBM', 0.0)\n# prices['IBM'] if it exists, else 0.0\nUse the del statement to remove an element of a dictionary:\ndel prices['GOOG']\nAlthough strings are the most common type of key, you can use many other Python\nobjects, including numbers and tuples. For example, tuples are often used to construct\ncomposite or multipart keys:\nprices = { }\nprices[('IBM', '2015-02-03')] = 91.23\nprices['IBM', '2015-02-04'] = 91.42\n# Parens omitted\nAny kind of object can be placed into a dictionary, including other dictionaries.\nHowever, mutable data structures such as lists, sets, and dictionaries cannot be used as keys.\nDictionaries are often used as building blocks for various algorithms and data-handling\nproblems. One such problem is tabulation. For example, here’s how you could count the\ntotal number of shares for each stock name in earlier data:\nportfolio = [\n('ACME', 50, 92.34),\n('IBM', 75, 102.25),\n('PHP', 40, 74.50),",
      "content_length": 1530,
      "extraction_method": "Direct"
    },
    {
      "page_number": 35,
      "chapter": null,
      "content": "20\nChapter 1\nPython Basics\n('IBM', 50, 124.75)\n]\ntotal_shares = { s[0]: 0 for s in portfolio }\nfor name, shares, _ in portfolio:\ntotal_shares[name] += shares\n# total_shares = {'IBM': 125, 'ACME': 50, 'PHP': 40}\nIn this example, { s[0]: 0 for s in portfolio } is an example of a dictionary\ncomprehension. It creates a dictionary of key-value pairs from another collection of data.\nIn this case, it’s making an initial dictionary mapping stock names to 0. The for loop that\nfollows iterates over the dictionary and adds up all of the held shares for each stock symbol.\nMany common data processing tasks such as this one have already been implemented by\nlibrary modules. For example, the collections module has a Counter object that can be\nused for this task:\nfrom collections import Counter\ntotal_shares = Counter()\nfor name, shares, _ in portfolio:\ntotal_shares[name] += shares\n# total_shares = Counter({'IBM': 125, 'ACME': 50, 'PHP': 40})\nAn empty dictionary is created in one of two ways:\nprices = {}\n# An empty dict\nprices = dict()\n# An empty dict\nIt is more idiomatic to use {} for an empty dictionary—although caution is required\nsince it might look like you are trying to create an empty set (use set() instead). dict() is\ncommonly used to create dictionaries from key-value values. For example:\npairs = [('IBM', 125), ('ACME', 50), ('PHP', 40)]\nd = dict(pairs)\nTo obtain a list of dictionary keys, convert a dictionary to a list:\nsyms = list(prices)\n# syms = ['AAPL', 'MSFT', 'IBM', 'GOOG']\nAlternatively, you can obtain the keys using dict.keys():\nsyms = prices.keys()\nThe difference between these two methods is that keys() returns a special “keys view”\nthat is attached to the dictionary and actively reflects changes made to the dictionary. For\nexample:",
      "content_length": 1763,
      "extraction_method": "Direct"
    },
    {
      "page_number": 36,
      "chapter": null,
      "content": "1.12 Iteration and Looping\n21\n>>> d = { 'x': 2, 'y':3 }\n>>> k = d.keys()\n>>> k\ndict_keys(['x', 'y'])\n>>> d['z'] = 4\n>>> k\ndict_keys(['x', 'y', 'z'])\n>>>\nThe keys always appear in the same order as the items were initially inserted into the\ndictionary. The list conversion above will preserve this order. This can be useful when dicts\nare used to represent key-value data read from files and other data sources. The dictionary\nwill preserve the input order. This might help readability and debugging. It’s also nice if\nyou want to write the data back to a file. Prior to Python 3.6, however, this ordering was\nnot guaranteed, so you cannot rely upon it if compatibility with older versions of Python is\nrequired. Order is also not guaranteed if multiple deletions and insertions have taken place.\nTo obtain the values stored in a dictionary, use the dict.values() method. To obtain\nkey-value pairs, use dict.items(). For example, here’s how to iterate over the entire\ncontents of a dictionary as key-value pairs:\nfor sym, price in prices.items():\nprint(f'{sym} = {price}')\n1.12\nIteration and Looping\nThe most widely used looping construct is the for statement that iterates over a collection\nof items. One common form of iteration is to loop over all the members of a\nsequence—such as a string, list, or tuple. Here’s an example:\nfor n in [1, 2, 3, 4, 5, 6, 7, 8, 9]:\nprint(f'2 to the {n} power is {2**n}')\nIn this example, the variable n will be assigned successive items from the list [1, 2, 3,\n4, ..., 9] on each iteration. Since looping over ranges of integers is quite common,\nthere is a shortcut:\nfor n in range(1, 10):\nprint(f'2 to the {n} power is {2**n}')\nThe range(i, j [,step]) function creates an object that represents a range of integers\nwith values from i up to, but not including, j. If the starting value is omitted, it’s taken to\nbe zero. An optional stride can also be given as a third argument. Here are some examples:\na = range(5)\n# a = 0, 1, 2, 3, 4\nb = range(1, 8)\n# b = 1, 2, 3, 4, 5, 6, 7\nc = range(0, 14, 3)\n# c = 0, 3, 6, 9, 12\nd = range(8, 1, -1)\n# d = 8, 7, 6, 5, 4, 3, 2",
      "content_length": 2099,
      "extraction_method": "Direct"
    },
    {
      "page_number": 37,
      "chapter": null,
      "content": "22\nChapter 1\nPython Basics\nThe object created by range() computes the values it represents on demand when\nlookups are requested. Thus, it’s efficient to use even with a large range of numbers.\nThe for statement is not limited to sequences of integers. It can be used to iterate over\nmany kinds of objects including strings, lists, dictionaries, and files. Here’s an example:\nmessage = 'Hello World'\n# Print out the individual characters in message\nfor c in message:\nprint(c)\nnames = ['Dave', 'Mark', 'Ann', 'Phil']\n# Print out the members of a list\nfor name in names:\nprint(name)\nprices = { 'GOOG' : 490.10, 'IBM' : 91.50, 'AAPL' : 123.15 }\n# Print out all of the members of a dictionary\nfor key in prices:\nprint(key, '=', prices[key])\n# Print all of the lines in a file\nwith open('foo.txt') as file:\nfor line in file:\nprint(line, end='')\nThe for loop is one of Python’s most powerful language features because you can create\ncustom iterator objects and generator functions that supply it with sequences of values.\nMore details about iterators and generators can be found later in Chapter 6.\n1.13\nFunctions\nUse the def statement to define a function:\ndef remainder(a, b):\nq = a // b\n# // is truncating division.\nr = a - q * b\nreturn r\nTo invoke a function, use its name followed by its arguments in parentheses, for\nexample result = remainder(37, 15).\nIt is common practice for a function to include a documentation string as the first\nstatement. This string feeds the help() command and may be used by IDEs and other\ndevelopment tools to assist the programmer. For example:\ndef remainder(a, b):\n'''",
      "content_length": 1599,
      "extraction_method": "Direct"
    },
    {
      "page_number": 38,
      "chapter": null,
      "content": "1.13 Functions\n23\nComputes the remainder of dividing a by b\n'''\nq = a // b\nr = a - q * b\nreturn r\nIf the inputs and outputs of a function aren’t clear from their names, they might be\nannotated with types:\ndef remainder(a: int, b: int) -> int:\n'''\nComputes the remainder of dividing a by b\n'''\nq = a // b\nr = a - q * b\nreturn r\nSuch annotations are merely informational and are not actually enforced at runtime.\nSomeone could still call the above function with non-integer values, such as result =\nremainder(37.5, 3.2).\nUse a tuple to return multiple values from a function:\ndef divide(a, b):\nq = a // b\n# If a and b are integers, q is integer\nr = a - q * b\nreturn (q, r)\nWhen multiple values are returned in a tuple, they can be unpacked into separate\nvariables like this:\nquotient, remainder = divide(1456, 33)\nTo assign a default value to a function parameter, use assignment:\ndef connect(hostname, port, timeout=300):\n# Function body\n...\nWhen default values are given in a function definition, they can be omitted from\nsubsequent function calls. An omitted argument will take on the supplied default value.\nHere’s an example:\nconnect('www.python.org', 80)\nconnect('www.python.org', 80, 500)\nDefault arguments are often used for optional features. If there are many such\narguments, readability can suffer. It’s therefore recommended to specify such arguments\nusing keyword arguments. For example:",
      "content_length": 1398,
      "extraction_method": "Direct"
    },
    {
      "page_number": 39,
      "chapter": null,
      "content": "24\nChapter 1\nPython Basics\nconnect('www.python.org', 80, timeout=500)\nIf you know the names of the arguments, all of them can be named when calling a\nfunction. When named, the order in which they are listed doesn’t matter. For example,\nthis is fine:\nconnect(port=80, hostname='www.python.org')\nWhen variables are created or assigned inside a function, their scope is local. That is,\nthe variable is only defined inside the body of the function and is destroyed when the\nfunction returns. Functions can also access variables defined outside of a function as long as\nthey are defined in the same file. For example:\ndebug = True\n# Global variable\ndef read_data(filename):\nif debug:\nprint('Reading', filename)\n...\nScoping rules are described in more detail in Chapter 5.\n1.14\nExceptions\nIf an error occurs in your program, an exception is raised and a traceback message appears:\nTraceback (most recent call last):\nFile \"readport.py\", line 9, in <module>\nshares = int(row[1])\nValueError: invalid literal for int() with base 10: 'N/A'\nThe traceback message indicates the type of error that occurred, along with its location.\nNormally, errors cause a program to terminate. However, you can catch and handle\nexceptions using try and except statements, like this:\nportfolio = []\nwith open('portfolio.csv') as file:\nfor line in file:\nrow = line.split(',')\ntry:\nname = row[0]\nshares = int(row[1])\nprice = float(row[2])\nholding = (name, shares, price)\nportfolio.append(holding)\nexcept ValueError as err:",
      "content_length": 1491,
      "extraction_method": "Direct"
    },
    {
      "page_number": 40,
      "chapter": null,
      "content": "1.14 Exceptions\n25\nprint('Bad row:', row)\nprint('Reason:', err)\nIn this code, if a ValueError occurs, details concerning the cause of the error are placed\nin err and control passes to the code in the except block. If some other kind of exception\nis raised, the program crashes as usual. If no errors occur, the code in the except block is\nignored. When an exception is handled, program execution resumes with the statement\nthat immediately follows the last except block. The program does not return to the\nlocation where the exception occurred.\nThe raise statement is used to signal an exception. You need to give the name of an\nexception. For instance, here’s how to raise RuntimeError, a built-in exception:\nraise RuntimeError('Computer says no')\nProper management of system resources such as locks, files, and network connections is\noften tricky when combined with exception handling. Sometimes there are actions that\nmust be performed no matter what happens. For this, use try-finally. Here is an\nexample involving a lock that must be released to avoid deadlock:\nimport threading\nlock = threading.Lock()\n...\nlock.acquire()\n# If a lock has been acquired, it MUST be released\ntry:\n...\nstatements\n...\nfinally:\nlock.release()\n# Always runs\nTo simplify such programming, most objects that involve resource management also\nsupport the with statement. Here is a modified version of the above code:\nwith lock:\n...\nstatements\n...\nIn this example, the lock object is automatically acquired when the with statement\nexecutes. When execution leaves the context of the with block, the lock is automatically\nreleased. This is done regardless of what happens inside the with block. For example, if an\nexception occurs, the lock is released when control leaves the context of the block.\nThe with statement is normally only compatible with objects related to system\nresources or the execution environment—such as files, connections, and locks. However,\nuser-defined objects can have their own custom processing, as described further in\nChapter 3.",
      "content_length": 2032,
      "extraction_method": "Direct"
    },
    {
      "page_number": 41,
      "chapter": null,
      "content": "26\nChapter 1\nPython Basics\n1.15\nProgram Termination\nA program terminates when no more statements exist to execute in the input program or\nwhen an uncaught SystemExit exception is raised. If you want to force a program to quit,\nhere’s how to do it:\nraise SystemExit()\n# Exit with no error message\nraise SystemExit(\"Something is wrong\")\n# Exit with error\nOn exit, the interpreter makes a best effort to garbage-collect all active objects.\nHowever, if you need to perform a specific cleanup action (remove files, close a\nconnection), you can register it with the atexit module as follows:\nimport atexit\n# Example\nconnection = open_connection(\"deaddot.com\")\ndef cleanup():\nprint \"Going away...\"\nclose_connection(connection)\natexit.register(cleanup)\n1.16\nObjects and Classes\nAll values used in a program are objects. An object consists of internal data and methods\nthat perform various kinds of operations involving that data. You have already used objects\nand methods when working with the built-in types such as strings and lists. For example:\nitems = [37, 42]\n# Create a list object\nitems.append(73)\n# Call the append() method\nThe dir() function lists the methods available on an object. It is a useful tool for\ninteractive experimentation when no fancy IDE is available. For example:\n>>> items = [37, 42]\n>>> dir(items)\n['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',\n...\n'append', 'count', 'extend', 'index', 'insert', 'pop',\n'remove', 'reverse', 'sort']\n>>>\nWhen inspecting objects, you will see familiar methods such as append() and insert()\nlisted. However, you will also see special methods whose names begin and end with a",
      "content_length": 1650,
      "extraction_method": "Direct"
    },
    {
      "page_number": 42,
      "chapter": null,
      "content": "1.16 Objects and Classes\n27\ndouble underscore. These methods implement various operators. For example, the\n__add__() method is used to implement the + operator. These methods are explained in\nmore detail in later chapters.\n>>> items.__add__([73, 101])\n[37, 42, 73, 101]\n>>>\nThe class statement is used to define new types of objects and for object-oriented\nprogramming. For example, the following class defines a stack with push() and pop()\noperations:\nclass Stack:\ndef __init__(self):\n# Initialize the stack\nself._items = [ ]\ndef push(self, item):\nself._items.append(item)\ndef pop(self):\nreturn self._items.pop()\ndef __repr__(self):\nreturn f'<{type(self).__name__} at 0x{id(self):x}, size={len(self)}>'\ndef __len__(self):\nreturn len(self._items)\nInside the class definition, methods are defined using the def statement. The first\nargument in each method always refers to the object itself. By convention, self is the\nname used for this argument. All operations involving the attributes of an object must\nexplicitly refer to the self variable.\nMethods with leading and trailing double underscores are special methods. For\nexample, __init__ is used to initialize an object. In this case, __init__ creates an internal\nlist for storing the stack data.\nTo use a class, write code such as this:\ns = Stack()\n# Create a stack\ns.push('Dave')\n# Push some things onto it\ns.push(42)\ns.push([3, 4, 5])\nx = s.pop()\n# x gets [3,4,5]\ny = s.pop()\n# y gets 42\nWithin the class, you will notice that the methods use an internal _items variable.\nPython does not have any mechanism for hiding or protecting data. However, there is a\nprogramming convention wherein names preceded by a single underscore are taken to be",
      "content_length": 1697,
      "extraction_method": "Direct"
    },
    {
      "page_number": 43,
      "chapter": null,
      "content": "28\nChapter 1\nPython Basics\n“private.” In this example, _items should be treated (by you) as internal implementation\nand not used outside the Stack class itself. Be aware that there is no actual enforcement of\nthis convention—if you want to access _items, you can do so at any time. You’ll just have\nto answer to your coworkers when they review your code.\nThe __repr__() and __len__() methods are there to make the object play nicely with\nthe rest of the environment. Here, __len__() makes a Stack work with the built-in len()\nfunction and __repr__() changes the way that a Stack is displayed and printed. It’s a good\nidea to always define __repr__() as it can simplify debugging.\n>>> s = Stack()\n>>> s.push('Dave')\n>>> s.push(42)\n>>> len(s)\n2\n>>> s\n<Stack at 0x10108c1d0, size=2>\n>>>\nA major feature of objects is that you can add to or redefine the capabilities of existing\nclasses via inheritance.\nSuppose you wanted to add a method to swap the top two items on the stack. You\nmight write a class like this:\nclass MyStack(Stack):\ndef swap(self):\na = self.pop()\nb = self.pop()\nself.push(a)\nself.push(b)\nMyStack is identical to Stack except that it has a new method, swap().\n>>> s = MyStack()\n>>> s.push('Dave')\n>>> s.push(42)\n>>> s.swap()\n>>> s.pop()\n'Dave'\n>>> s.pop()\n42\n>>>\nInheritance can also be used to change the behavior of an existing method. Suppose\nyou want to restrict the stack to only hold numeric data. Write a class like this:\nclass NumericStack(Stack):\ndef push(self, item):",
      "content_length": 1492,
      "extraction_method": "Direct"
    },
    {
      "page_number": 44,
      "chapter": null,
      "content": "1.16 Objects and Classes\n29\nif not isinstance(item, (int, float)):\nraise TypeError('Expected an int or float')\nsuper().push(item)\nIn this example, the push() method has been redefined to add extra checking. The\nsuper() operation is a way to invoke the prior definition of push(). Here’s how this class\nwould work:\n>>> s = NumericStack()\n>>> s.push(42)\n>>> s.push('Dave')\nTraceback (most recent call last):\n...\nTypeError: Expected an int or float\n>>>\nOften, inheritance is not the best solution. Suppose you wanted to define a simple\nstack-based 4-function calculator that worked like this:\n>>> # Calculate 2 + 3 * 4\n>>> calc = Calculator()\n>>> calc.push(2)\n>>> calc.push(3)\n>>> calc.push(4)\n>>> calc.mul()\n>>> calc.add()\n>>> calc.pop()\n14\n>>>\nYou might look at this code, see the use of push() and pop(), and think that\nCalculator could be defined by inheriting from Stack. Although that would work, it is\nprobably better to define Calculator as a completely separate class:\nclass Calculator:\ndef __init__(self):\nself._stack = Stack()\ndef push(self, item):\nself._stack.push(item)\ndef pop(self):\nreturn self._stack.pop()\ndef add(self):\nself.push(self.pop() + self.pop())",
      "content_length": 1169,
      "extraction_method": "Direct"
    },
    {
      "page_number": 45,
      "chapter": null,
      "content": "30\nChapter 1\nPython Basics\ndef mul(self):\nself.push(self.pop() * self.pop())\ndef sub(self):\nright = self.pop()\nself.push(self.pop() - right)\ndef div(self):\nright = self.pop()\nself.push(self.pop() / right)\nIn this implementation, a Calculator contains a Stack as an internal implementation\ndetail. This is an example of composition. The push() and pop() methods delegate to the\ninternal Stack. The main reason for taking this approach is that you don’t really think of\nthe Calculator as a Stack. It’s a separate concept—a different kind of object. By analogy,\nyour phone contains a central processing unit (CPU) but you don’t usually think of your\nphone as a type of CPU.\n1.17\nModules\nAs your programs grow in size, you will want to break them into multiple files for easier\nmaintenance. To do this, use the import statement. To create a module, put the relevant\nstatements and definitions into a file with a .py suffix and the same name as the module.\nHere’s an example:\n# readport.py\n#\n# Reads a file of 'NAME,SHARES,PRICE' data\ndef read_portfolio(filename):\nportfolio = []\nwith open(filename) as file:\nfor line in file:\nrow = line.split(',')\ntry:\nname = row[0]\nshares = int(row[1])\nprice = float(row[2])\nholding = (name, shares, price)\nportfolio.append(holding)\nexcept ValueError as err:\nprint('Bad row:', row)\nprint('Reason:', err)\nreturn portfolio",
      "content_length": 1351,
      "extraction_method": "Direct"
    },
    {
      "page_number": 46,
      "chapter": null,
      "content": "1.17 Modules\n31\nTo use your module in other files, use the import statement. For example, here is a\nmodule pcost.py that uses the above read_portfolio() function:\n# pcost.py\nimport readport\ndef portfolio_cost(filename):\n'''\nCompute the total shares*price of a portfolio\n'''\nport = readport.read_portfolio(filename)\nreturn sum(shares * price for _, shares, price in port)\nThe import statement creates a new namespace (or environment) and executes\nall the statements in the associated .py file within that namespace. To access the\ncontents of the namespace after import, use the name of the module as a prefix, as in\nreadport.read_portfolio() in the preceding example.\nIf the import statement fails with an ImportError exception, you need to check a few\nthings in your environment. First, make sure you created a file called readport.py. Next,\ncheck the directories listed on sys.path. If your file isn’t saved in one of those directories,\nPython won’t be able to find it.\nIf you want to import a module under a different name, supply the import statement\nwith an optional as qualifier:\nimport readport as rp\nport = rp.read_portfolio('portfolio.dat')\nTo import specific definitions into the current namespace, use the from statement:\nfrom readport import read_portfolio\nport = read_portfolio('portfolio.dat')\nAs with objects, the dir() function lists the contents of a module. It is a useful tool for\ninteractive experimentation.\n>>> import readport\n>>> dir(readport)\n['__builtins__', '__cached__', '__doc__', '__file__', '__loader__',\n'__name__', '__package__', '__spec__', 'read_portfolio']\n...\n>>>\nPython provides a large standard library of modules that simplify certain programming\ntasks. For example, the csv module is a standard library for dealing with files of\ncomma-separated values. You could use it in your program as follows:",
      "content_length": 1836,
      "extraction_method": "Direct"
    },
    {
      "page_number": 47,
      "chapter": null,
      "content": "32\nChapter 1\nPython Basics\n# readport.py\n#\n# Reads a file of 'NAME,SHARES,PRICE' data\nimport csv\ndef read_portfolio(filename):\nportfolio = []\nwith open(filename) as file:\nrows = csv.reader(file)\nfor row in rows:\ntry:\nname = row[0]\nshares = int(row[1])\nprice = float(row[2])\nholding = (name, shares, price)\nportfolio.append(holding)\nexcept ValueError as err:\nprint('Bad row:', row)\nprint('Reason:', err)\nreturn portfolio\nPython also has a vast number of third-party modules that can be installed to solve\nalmost any imaginable task (including the reading of CSV files). See https://pypi.org.\n1.18\nScript Writing\nAny file can execute either as a script or as a library imported with import. To better\nsupport imports, script code is often enclosed with a conditional check against the\nmodule name:\n# readport.py\n#\n# Reads a file of 'NAME,SHARES,PRICE' data\nimport csv\ndef read_portfolio(filename):\n...\ndef main():\nportfolio = read_portfolio('portfolio.csv')\nfor name, shares, price in portfolio:\nprint(f'{name:>10s} {shares:10d} {price:10.2f}')",
      "content_length": 1042,
      "extraction_method": "Direct"
    },
    {
      "page_number": 48,
      "chapter": null,
      "content": "1.19 Packages\n33\nif __name__ == '__main__':\nmain()\n__name__ is a built-in variable that always contains the name of the enclosing module.\nIf a program is run as the main script with a command such as python readport.py,\nthe __name__ variable is set to '__main__'. Otherwise, if the code is imported using a\nstatement such as import readport, the __name__ variable is set to 'readport'.\nAs shown, the program is hardcoded to use a filename 'portfolio.csv'. Instead, you\nmay want to prompt the user for a filename or accept the filename as a command-line\nargument. To do this, use the built-in input() function or the sys.argv list. For example,\nhere is a modified version of the main() function:\ndef main(argv):\nif len(argv) == 1:\nfilename = input('Enter filename: ')\nelif len(argv) == 2:\nfilename = argv[1]\nelse:\nraise SystemExit(f'Usage: {argv[0]} [ filename ]')\nportfolio = read_portfolio(filename)\nfor name, shares, price in portfolio:\nprint(f'{name:>10s} {shares:10d} {price:10.2f}')\nif __name__ == '__main__':\nimport sys\nmain(sys.argv)\nThis program can be run in two different ways from the command line:\nbash % python readport.py\nEnter filename: portfolio.csv\n...\nbash % python readport.py portfolio.csv\n...\nbash % python readport.py a b c\nUsage: readport.py [ filename ]\nbash %\nFor very simple programs, it is often enough to process arguments in sys.argv as\nshown. For more advanced usage, the argparse standard library module can be used.\n1.19\nPackages\nIn large programs, it’s common to organize code into packages. A package is a hierarchical\ncollection of modules. On the filesystem, put your code as a collection of files in a\ndirectory like this:",
      "content_length": 1659,
      "extraction_method": "Direct"
    },
    {
      "page_number": 49,
      "chapter": null,
      "content": "34\nChapter 1\nPython Basics\ntutorial/\n__init__.py\nreadport.py\npcost.py\nstack.py\n...\nThe directory should have an __init__.py file, which may be empty. Once you’ve\ndone this, you should be able to make nested import statements. For example:\nimport tutorial.readport\nport = tutorial.readport.read_portfolio('portfolio.dat')\nIf you don’t like the long names, you can shorten things using an import like this:\nfrom tutorial.readport import read_portfolio\nport = read_portfolio('portfolio.dat')\nOne tricky issue with packages is imports between files within the same package. In an\nearlier example, a pcost.py module was shown that started with an import like this:\n# pcost.py\nimport readport\n...\nIf the pcost.py and readport.py files are moved into a package, this import statement\nbreaks. To fix it, you must use a fully qualified module import:\n# pcost.py\nfrom tutorial import readport\n...\nAlternatively, you can use a package-relative import like this:\n# pcost.py\nfrom . import readport\n...\nThe latter form has the benefit of not hardcoding the package name. This makes it\neasier to later rename a package or move it around within your project.\nOther subtle details concerning packages are covered later (see Chapter 8).\n1.20\nStructuring an Application\nAs you start to write more Python code, you may find yourself working on larger\napplications that include a mix of your own code as well as third-party dependencies.",
      "content_length": 1416,
      "extraction_method": "Direct"
    },
    {
      "page_number": 50,
      "chapter": null,
      "content": "1.21 Managing Third-Party Packages\n35\nManaging all of this is a complex topic that continues to evolve. There are also many\nconflicting opinions about what constitutes “best practice.” However, there are a few\nessential facets to it that you should know.\nFirst, it is standard practice to organize large code bases into packages (that is,\ndirectories of .py files that include the special __init__.py file). When doing this, pick\na unique package name for the top-level directory name. The primary purpose of the\npackage directory is to manage import statements and the namespaces of modules used\nwhile programming. You want your code isolated from everyone else’s code.\nIn addition to your main project source code, you might additionally have tests,\nexamples, scripts, and documentation. This additional material usually lives in a separate\nset of directories than the package containing your source code. Thus, it is common to\ncreate an enclosing top-level directory for your project and to put all of your work under\nthat. For example, a fairly typical project organization might look like this:\ntutorial-project/\ntutorial/\n__init__.py\nreadport.py\npcost.py\nstack.py\n...\ntests/\ntest_stack.py\ntest_pcost.py\n...\nexamples/\nsample.py\n...\ndoc/\ntutorial.txt\n...\nKeep in mind that there is more than one way to do it. The nature of the problem\nyou’re solving might dictate a different structure. Nevertheless, as long as your main set of\nsource code files lives in a proper package (again, the directory with the __init__.py file),\nyou should be fine.\n1.21\nManaging Third-Party Packages\nPython has a large library of contributed packages that can be found at the Python Package\nIndex (https://pypi.org). You may need to depend on some of these packages in your\nown code. To install a third-party package, use a command such as pip:\nbash % python3 -m pip install somepackage",
      "content_length": 1869,
      "extraction_method": "Direct"
    },
    {
      "page_number": 51,
      "chapter": null,
      "content": "36\nChapter 1\nPython Basics\nInstalled packages are placed into a special site-packages directory that you can find if\nyou inspect the value of sys.path. For example, on a UNIX machine, packages might be\nplaced in /usr/local/lib/python3.8/site-packages. If you are ever left wondering\nwhere a package is coming from, inspect the __file__ attribute of a package after\nimporting it in the interpreter:\n>>> import pandas\n>>> pandas.__file__\n'/usr/local/lib/python3.8/site-packages/pandas/__init__.py'\n>>>\nOne potential problem with installing a package is that you might not have permission\nto change the locally installed version of Python. Even if you had permission, it still might\nnot be a good idea. For example, many systems already have Python installed for use by\nvarious system utilities. Altering the installation of that version of Python is often a\nbad idea.\nTo make a sandbox where you can install packages and work without worrying about\nbreaking anything, create a virtual environment by a command like this:\nbash % python3 -m venv myproject\nThis will set up a dedicated Python installation for you in a directory called\nmyproject/. Within that directory, you’ll find an interpreter executable and library where\nyou can safely install packages. For example, if you run myproject/bin/python3, you’ll\nget an interpreter configured for your personal use. You can install packages into this\ninterpreter without worrying about breaking any part of the default Python installation.\nTo install a package, use pip as before but make sure to specify the correct interpreter:\nbash % ./myproject/bin/python3 -m pip install somepackage\nThere are various tools that aim to simplify the use of pip and venv. Such matters\nmight also be handled automagically by your IDE. As this is a fluid and ever-evolving part\nof Python, no further advice is given here.\n1.22\nPython: It Fits Your Brain\nIn the early days of Python, “it fits your brain” was a common motto. Even today, the core\nof Python is a small programming language along with a useful collection of built-in\nobjects—lists, sets, and dictionaries. A vast array of practical problems can be solved using\nnothing more than the basic features presented in this chapter. This is a good thing to\nkeep in mind as you begin your Python adventure—although there are always more\ncomplicated ways to solve a problem, there might also be a simple way to do it with the\nbasic features Python already provides. When in doubt, you’ll probably thank your past self\nfor doing just that.",
      "content_length": 2521,
      "extraction_method": "Direct"
    },
    {
      "page_number": 52,
      "chapter": null,
      "content": "2\nOperators, Expressions, and\nData Manipulation\nThis chapter describes Python’s expressions, operators, and evaluation rules related to data\nmanipulation. Expressions are at the heart of performing useful computations. Moreover,\nthird-party libraries can customize Python’s behavior to provide a better user experience.\nThis chapter describes expressions at a high level. Chapter 3 describes the underlying\nprotocols that can be used to customize the behavior of the interpreter.\n2.1\nLiterals\nA literal is a value typed directly into a program such as 42, 4.2, or 'forty-two'.\nInteger literals represent a signed integer value of arbitrary size. It’s possible to specify\nintegers in binary, octal, or hexadecimal:\n42\n# Decimal integer\n0b101010\n# Binary integer\n0o52\n# Octal integer\n0x2a\n# Hexadecimal integer\nThe base is not stored as part of the integer value. All of the above literals will display as\n42 if printed. You can use the built-in functions bin(x), oct(x), or hex(x) to convert an\ninteger to a string representing its value in different bases.\nFloating-point numbers can be written by adding a decimal point or by using scientific\nnotation where an e or E specifies an exponent. All of the following are floating-point\nnumbers:\n4.2\n42.\n.42\n4.2e+2\n4.2E2\n-4.2e-2",
      "content_length": 1273,
      "extraction_method": "Direct"
    },
    {
      "page_number": 53,
      "chapter": null,
      "content": "38\nChapter 2\nOperators, Expressions, and Data Manipulation\nInternally, floating-point numbers are stored as IEEE 754 double-precision (64-bit)\nvalues.\nIn numeric literals, a single underscore ( _ ) can be used as a visual separator between\ndigits. For example:\n123_456_789\n0x1234_5678\n0b111_00_101\n123.789_012\nThe digit separator is not stored as part of the number—it’s only used to make large\nnumeric literals easier to read in source code.\nBoolean literals are written as True and False.\nString literals are written by enclosing characters with single, double, or triple quotes.\nSingle- and double-quoted strings must appear on the same line. Triple-quoted strings can\nspan multiple lines. For example:\n'hello world'\n\"hello world\"\n'''hello world'''\n\"\"\"hello world\"\"\"\nTuple, liss, set, and dictionary literals are written as follows:\n(1, 2, 3)\n# tuple\n[1, 2, 3]\n# list\n{1, 2, 3}\n# set\n{'x':1, 'y':2, 'z':3}\n# dict\n2.2\nExpressions and Locations\nAn expression represents a computation that evaluates to a concrete value. It consists of a\ncombination of literals, names, operators, and function or method calls. An expression can\nalways appear on the right-hand side of an assignment statement, be used as an operand in\noperations in other expressions, or be passed as a function argument. For example:\nvalue = 2 + 3 * 5 + sqrt(6+7)\nOperators, such as + (addition) or * (multiplication), represent an operation performed\non objects provided as operands. sqrt() is a function that is applied to input arguments.\nThe left hand side of an assignment represents a location where a reference to an object\nis stored. That location, as shown in the previous example, might be a simple identifier\nsuch as value. It could also be an attribute of an object or an index within a container. For\nexample:",
      "content_length": 1790,
      "extraction_method": "Direct"
    },
    {
      "page_number": 54,
      "chapter": null,
      "content": "2.3 Standard Operators\n39\na = 4 + 2\nb[1] = 4 + 2\nc['key'] = 4 + 2\nd.value = 4 + 2\nReading a value back from a location is also an expression. For example:\nvalue = a + b[1] + c['key']\nThe assignment of a value and the evaluation of an expression are separate concepts. In\nparticular, you can’t include the assignment operator as part of an expression:\nwhile line=file.readline():\n# Syntax Error\nprint(line)\nHowever, an “assignment expression” operator (:=) can be used to perform this\ncombined action of expression evaluation and assignment. For example:\nwhile (line:=file.readline()):\nprint(line)\nThe := operator is usually used in combination with statements such as if and while.\nIn fact, using it as a normal assignment operator results in a syntax error unless you put\nparentheses around it.\n2.3\nStandard Operators\nPython objects can be made to work with any of the operators in Table 2.1.\nUsually these have a numeric interpretation. However, there are notable special cases.\nFor example, the + operator is also used to concatenate sequences, * operator replicates\nsequences, - is used for set differences, and % performs string formatting:\n[1,2,3] + [4,5]\n# [1,2,3,4,5]\n[1,2,3] * 4\n# [1,2,3,1,2,3,1,2,3,1,2,3]\n'%s has %d messages' % ('Dave', 37)\nChecking of operators is a dynamic process. Operations involving mixed data types will\noften “work” if there is an intuitive sense for the operation to work. For example, you can\nadd integers and fractions:\n>>> from fractions import Fraction\n>>> a = Fraction(2, 3)\n>>> b = 5\n>>> a + b\nFraction(17, 3)\n>>>",
      "content_length": 1556,
      "extraction_method": "Direct"
    },
    {
      "page_number": 55,
      "chapter": null,
      "content": "40\nChapter 2\nOperators, Expressions, and Data Manipulation\nTable 2.1\nStandard Operators\nOperation\nDescription\nx + y\nAddition\nx - y\nSubtraction\nx * y\nMultiplication\nx / y\nDivision\nx // y\nTruncating division\nx @ y\nMatrix multiplication\nx ** y\nPower (x to the y power)\nx % y\nModulo (x mod y). Remainder.\nx << y\nLeft shift\nx >> y\nRight shift\nx & y\nBitwise and\nx | y\nBitwise or\nx ^ y\nBitwise xor (exclusive or)\n~x\nBitwise negation\n–x\nUnary minus\n+x\nUnary plus\nabs(x)\nAbsolute value\ndivmod(x,y)\nReturns (x // y, x % y)\npow(x,y [,modulo])\nReturns (x ** y) % modulo\nround(x,[n])\nRounds to the nearest multiple of 10-n\nHowever, it’s not always foolproof. For example, it doesn’t work with decimals.\n>>> from decimal import Decimal\n>>> from fractions import Fraction\n>>> a = Fraction(2, 3)\n>>> b = Decimal('5')\n>>> a + b\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for +: 'Fraction' and 'decimal.Decimal'\n>>>\nFor most combinations of numbers, however, Python follows a standard numeric\nhierarchy of Booleans, integers, fractions, floats, and complex numbers. Mixed-type\noperations will simply work—you don’t have to worry about it.",
      "content_length": 1187,
      "extraction_method": "Direct"
    },
    {
      "page_number": 56,
      "chapter": null,
      "content": "2.4 In-Place Assignment\n41\n2.4\nIn-Place Assignment\nPython provides the “in-place” or “augmented” assignment operations in Table 2.2.\nTable 2.2\nAugmented Assignment Operators\nOperation\nDescription\nx += y\nx = x + y\nx -= y\nx = x - y\nx *= y\nx = x * y\nx /= y\nx = x / y\nx //= y\nx = x // y\nx **= y\nx = x ** y\nx %= y\nx = x % y\nx @= y\nx = x @ y\nx &= y\nx = x & y\nx |= y\nx = x | y\nx ^= y\nx = x ^ y\nx >>= y\nx = x >> y\nx <<= y\nx = x << y\nThese are not considered to be expressions. Instead, they are a syntactic convenience for\nupdating a value in place. For example:\na = 3\na = a + 1\n# a = 4\na += 1\n# a = 5\nMutable objects can use these operators to perform an in-place mutation of the data as\nan optimization. Consider this example:\n>>> a = [1, 2, 3]\n>>> b = a\n# Creates a new reference to a\n>>> a += [4, 5]\n# In-place update (doesn't create a new list)\n>>> a\n[1, 2, 3, 4, 5]\n>>> b\n[1, 2, 3, 4, 5]\n>>>\nIn this example, a and b are references to the same list. When a += [4, 5] is\nperformed, it updates the list object in place without creating a new list. Thus, b also sees\nthis update. This is often surprising.",
      "content_length": 1100,
      "extraction_method": "Direct"
    },
    {
      "page_number": 57,
      "chapter": null,
      "content": "42\nChapter 2\nOperators, Expressions, and Data Manipulation\n2.5\nObject Comparison\nThe equality operator (x == y) tests the values of x and y for equality. In the case of lists\nand tuples, they must be of equal size, have equal elements, and be in the same order. For\ndictionaries, True is returned only if x and y have the same set of keys and all the objects\nwith the same key have equal values. Two sets are equal if they have the same elements.\nAn equality comparison between objects of incompatible types, such as a file and a\nfloating-point number, does not trigger an error but returns False. However, sometimes a\ncomparison between objects of different types will produce True. For example, comparing\nan integer and a floating-point number of the same value:\n>>> 2 == 2.0\nTrue\n>>>\nThe identity operators (x is y and x is not y) test two values to see whether they\nrefer to literally the same object in memory (e.g., id(x) == id(y)). In general, it may be\nthe case that x == y, but x is not y. For example:\n>>> a = [1, 2, 3]\n>>> b = [1, 2, 3]\n>>> a is b\nFalse\n>>> a == b\nTrue\n>>>\nIn practice, comparing objects with the is operator is almost never what you want. Use\nthe == operator for all comparisons unless you have a good reason to expect the two\nobjects to have the same identity.\n2.6\nOrdered Comparison Operators\nThe ordered comparison operators in Table 2.3 have the standard mathematical\ninterpretation for numbers. They return a Boolean value.\nTable 2.3\nOrdered Comparison Operators\nOperation\nDescription\nx < y\nLess than\nx > y\nGreater than\nx >= y\nGreater than or equal to\nx <= y\nLess than or equal to",
      "content_length": 1614,
      "extraction_method": "Direct"
    },
    {
      "page_number": 58,
      "chapter": null,
      "content": "2.7 Boolean Expressions and Truth Values\n43\nFor sets, x < y tests if x is strict subset of y (i.e., has fewer elements, but is not equal\nto y).\nWhen comparing two sequences, the first elements of each sequence are compared. If\nthey differ, this determines the result. If they’re the same, the comparison moves to the\nsecond element of each sequence. This process continues until two different elements are\nfound or no more elements exist in either of the sequences. If the end of both sequences is\nreached, the sequences are considered equal. If a is a subsequence of b, then a < b.\nStrings and bytes are compared using lexicographical ordering. Each character is\nassigned a unique numerical index determined by the character set (such as ASCII or\nUnicode). A character is less than another character if its index is less.\nNot all types support the ordered comparisons. For example, trying to use < on\ndictionaries is undefined and results in a TypeError. Similarly, applying ordered\ncomparisons to incompatible types (such as a string and a number) will result in a\nTypeError.\n2.7\nBoolean Expressions and Truth Values\nThe and, or, and not operators can form complex Boolean expressions. The behavior of\nthese operators is shown in Table 2.4.\nTable 2.4\nLogical Operators\nOperator\nDescription\nx or y\nIf x is false, return y; otherwise, return x.\nx and y\nIf x is false, return x; otherwise, return y.\nnot x\nIf x is false, return True; otherwise, return False.\nWhen you use an expression to determine a true or false value, True, any nonzero\nnumber, a nonempty string, list, tuple, or dictionary is taken to be true. False, zero, None,\nand empty lists, tuples, and dictionaries evaluate as false.\nBoolean expressions are evaluated from left to right and consume the right operand\nonly if it’s needed to determine the final value. For example, a and b evaluates b only if a\nis true. This is known as short-circuit evaluation. It can be useful to simplify code\ninvolving a test and a subsequent operation. For example:\nif y != 0:\nresult = x / y\nelse:\nresult = 0\n# Alternative\nresult = y and x / y\nIn the second version, the x / y division is only performed if y is nonzero.",
      "content_length": 2168,
      "extraction_method": "Direct"
    },
    {
      "page_number": 59,
      "chapter": null,
      "content": "44\nChapter 2\nOperators, Expressions, and Data Manipulation\nRelying on implicit “truthiness” of objects may lead to difficult-to-find bugs. For\nexample, consider this function:\ndef f(x, items=None):\nif not items:\nitems = []\nitems.append(x)\nreturn items\nThis function has an optional argument that, if not given, causes a new list to be created\nand returned. For example,\n>>> foo(4)\n[4]\n>>>\nHowever, the function has really strange behavior if you give it an existing empty list as\nan argument:\n>>> a = []\n>>> foo(3, a)\n[3]\n>>> a\n# Notice how a did NOT update\n[]\n>>>\nThis is a truth-checking bug. Empty lists evaluate to False so the code created a new\nlist instead of using the one (a) that was passed in as an argument. To fix this, you need to\nbe more precise in your checking against None:\ndef f(x, items=None):\nif items is None:\nitems = []\nitems.append(x)\nreturn items\nIt’s always good practice to be precise when writing conditional checks.\n2.8\nConditional Expressions\nA common programming pattern is assigning a value conditionally based on the result of\nan expression. For example:\nif a <= b:\nminvalue = a\nelse:\nminvalue = b",
      "content_length": 1130,
      "extraction_method": "Direct"
    },
    {
      "page_number": 60,
      "chapter": null,
      "content": "2.9 Operations Involving Iterables\n45\nThis code can be shortened using a conditional expression. For example:\nminvalue = a if a <= b else b\nIn such expressions, the condition in the middle is evaluated first. The expression to the\nleft of the if is then evaluated if the result is True. Otherwise, the expression after the else\nis evaluated. The else clause is always required.\n2.9\nOperations Involving Iterables\nIteration is an important Python feature supported by all of Python’s containers (lists,\ntuples, dicts, and so on), files, as well as generator functions. The operations in Table 2.5\ncan be applied to any iterable object s.\nTable 2.5\nOperations on Iterables\nOperation\nDescription\nfor vars in s:\nIteration\nv1, v2, ... = s\nVariable unpacking\nx in s, x not in s\nMembership\n[a, *s, b], (a, *s, b), {a, *s, b}\nExpansion in list, tuple, or set literals\nThe most essential operation on an iterable is the for loop. This is how you iterate\nthrough the values one by one. All the other operations build upon this.\nThe x in s operator tests whether the object x appears as one of the items produced by\nthe iterable s and returns True or False. The x not in s operator is the same as not (x\nin s). For strings, the in and not in operators accept substrings. For example, 'hello'\nin 'hello world' produces True. Note that the in operator does not support wildcards\nor any kind of pattern matching.\nAny object supporting iteration can have its values unpacked into a series of locations.\nFor example:\nitems = [ 3, 4, 5 ]\nx, y, z = items\n# x = 3, y = 4, z = 5\nletters = \"abc\"\nx, y, z = letters\n# x = 'a', y = 'b', z = 'c'\nThe locations on the left don’t have to be simple variable names. Any valid location that\ncould appear on the left-hand side of an equal sign is acceptable. So, you could write code\nlike this:\nitems = [3, 4, 5]\nd = { }\nd['x'], d['y'], d['z'] = items",
      "content_length": 1870,
      "extraction_method": "Direct"
    },
    {
      "page_number": 61,
      "chapter": null,
      "content": "46\nChapter 2\nOperators, Expressions, and Data Manipulation\nWhen unpacking values into locations, the number of locations on the left must exactly\nmatch the number of items in the iterable on the right. For nested data structures, match\nlocations and data by following the same structural pattern. Consider this example of\nunpacking two nested 3-tuples:\ndatetime = ((5, 19, 2008), (10, 30, \"am\"))\n(month, day, year), (hour, minute, am_pm) = datetime\nSometimes, the _ variable is used to indicate a throw-away value when unpacking. For\nexample, if you only care about the day and the hour, you can use:\n(_, day, _), (hour, _, _) = datetime\nIf the number of items being unpacked isn’t known, you can use an extended form of\nunpacking by including a starred variable, such as *extra in the following example:\nitems = [1, 2, 3, 4, 5]\na, b, *extra = items\n# a = 1, b = 2, extra = [3,4,5]\n*extra, a, b\n# extra = [1,2,3], a = 4, b = 5\na, *extra, b\n# a = 1, extra = [2,3,4], b = 5\nIn this example, *extra receives all of the extra items. It is always a list. No more than\none starred variable can be used when unpacking a single iterable. However, multiple\nstarred variables could be used when unpacking more complex data structures involving\ndifferent iterables. For example:\ndatetime = ((5, 19, 2008), (10, 30, \"am\"))\n(month, *_), (hour, *_) = datetime\nAny iterable can be expanded when writing out list, tuple, and set literals. This is also\ndone using the star (*). For example:\nitems = [1, 2, 3]\na = [10, *items, 11]\n# a = [10, 1, 2, 3, 11]\n(list)\nb = (*items, 10, *items)\n# b = [1, 2, 3, 10, 1, 2, 3]\n(tuple)\nc = {10, 11, *items}\n# c = {1, 2, 3, 10, 11}\n(set)\nIn this example, the contents of items are simply pasted into the list, tuple, or set being\ncreated as if you typed it in place at that location. This expansion is known as “splatting.”\nYou can include as many * expansions as you like when defining a literal. However, many\niterable objects (such as files or generators) only support one-time iteration. If you use\n*-expansion, the contents will be consumed and the iterable won’t produce any more\nvalues on subsequent iterations.\nA variety of built-in functions accept any iterable as input. Table 2.6 shows some of\nthese operations.",
      "content_length": 2241,
      "extraction_method": "Direct"
    },
    {
      "page_number": 62,
      "chapter": null,
      "content": "2.10 Operations on Sequences\n47\nTable 2.6\nFunctions consuming iterables\nFunction\nDescription\nlist(s)\nCreate a list from s\ntuple(s)\nCreate a tuple from s\nset(s)\nCreate a set from s\nmin(s [,key])\nMinimum item in s\nmax(s [,key])\nMaximum item in s\nany(s)\nReturn True if any item in s is true\nall(s)\nReturn True if all items in s are true\nsum(s [, initial])\nSum of items with an optional initial value\nsorted(s [, key])\nCreate a sorted list\nThis applies to many other library functions as well—for example, functions in the\nstatistics module.\n2.10\nOperations on Sequences\nA sequence is an iterable container that has a size and allows items to be accessed by an\ninteger index starting at 0. Examples include strings, lists, and tuples. In addition to all of\nthe operations involving iteration, the operators in Table 2.7 can be applied to a sequence.\nTable 2.7\nOperations on Sequences\nOperation\nDescription\ns + r\nConcatenation\ns * n, n * s\nMakes n copies of s, where n is an integer\ns[i]\nIndexing\ns[i:j]\nSlicing\ns[i:j:stride]\nExtended slicing\nlen(s)\nLength\nThe + operator concatenates two sequences of the same type. For example:\n>>> a = [3, 4, 5]\n>>> b = [6, 7]\n>>> a + b\n[3, 4, 5, 6, 7]\n>>>\nThe s * n operator makes n copies of a sequence. However, these are shallow copies\nthat replicate elements by reference only. Consider the following code:",
      "content_length": 1342,
      "extraction_method": "Direct"
    },
    {
      "page_number": 63,
      "chapter": null,
      "content": "48\nChapter 2\nOperators, Expressions, and Data Manipulation\n>>> a = [3, 4, 5]\n>>> b = [a]\n>>> c = 4 * b\n>>> c\n[[3, 4, 5], [3, 4, 5], [3, 4, 5], [3, 4, 5]]\n>>> a[0] = -7\n>>> c\n[[-7, 4, 5], [-7, 4, 5], [-7, 4, 5], [-7, 4, 5]]\n>>>\nNotice how the change to a modifies every element of the list c. In this case,\na reference to the list a was placed in the list b. When b was replicated, four additional\nreferences to a were created. Finally, when a was modified, this change was propagated to\nall the other copies of a. This behavior of sequence multiplication is often not the intent of\nthe programmer. One way to work around the problem is to manually construct the\nreplicated sequence by duplicating the contents of a. Here’s an example:\na = [ 3, 4, 5 ]\nc = [list(a) for _ in range(4)]\n# list() makes a copy of a list\nThe indexing operator s[n] returns the nth object from a sequence; s[0] is the first\nobject. Negative indices can be used to fetch characters from the end of a sequence. For\nexample, s[-1] returns the last item. Otherwise, attempts to access elements that are out\nof range result in an IndexError exception.\nThe slicing operator s[i:j] extracts a subsequence from s consisting of the elements\nwith index k, where i <= k < j. Both i and j must be integers. If the starting or ending\nindex is omitted, the beginning or end of the sequence is assumed, respectively. Negative\nindices are allowed and assumed to be relative to the end of the sequence.\nThe slicing operator may be given an optional stride, s[i:j:stride], that causes the\nslice to skip elements. However, the behavior is somewhat more subtle. If a stride is\nsupplied, i is the starting index, j is the ending index, and the produced subsequence is the\nelements s[i], s[i+stride], s[i+2*stride], and so forth until index j is reached (which\nis not included). The stride may also be negative. If the starting index i is omitted, it is set\nto the beginning of the sequence if stride is positive or the end of the sequence if stride\nis negative. If the ending index j is omitted, it is set to the end of the sequence if stride is\npositive or the beginning of the sequence if stride is negative. Here are some examples:\na = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\na[2:5]\n# [2, 3, 4]\na[:3]\n# [0, 1, 2]\na[-3:]\n# [7, 8, 9]\na[::2]\n# [0, 2, 4, 6, 8 ]\na[::-2]\n# [9, 7, 5, 3, 1 ]\na[0:5:2]\n# [0, 2, 4]\na[5:0:-2]\n# [5, 3, 1]",
      "content_length": 2376,
      "extraction_method": "Direct"
    },
    {
      "page_number": 64,
      "chapter": null,
      "content": "2.11 Operations on Mutable Sequences\n49\na[:5:1]\n# [0, 1, 2, 3, 4]\na[:5:-1]\n# [9, 8, 7, 6]\na[5::1]\n# [5, 6, 7, 8, 9]\na[5::-1]\n# [5, 4, 3, 2, 1, 0]\na[5:0:-1]\n# [5, 4, 3, 2, 1]\nFancy slices may result in code that is hard to understand later. Thus, some judgment is\nprobably warranted. Slices can be named using slice(). For example:\nfirstfive = slice(0, 5)\ns = 'hello world'\nprint(s[firstfive])\n# Prints 'hello'\n2.11\nOperations on Mutable Sequences\nStrings and tuples are immutable and cannot be modified after creation. The contents of a\nlist or other mutable sequence can be modified in-place with the operators in Table 2.8.\nTable 2.8\nMutable Sequence Operations\nOperation\nDescription\ns[i] = x\nIndex assignment\ns[i:j] = r\nSlice assignment\ns[i:j:stride] = r\nExtended slice assignment\ndel s[i]\nDeletes an element\ndel s[i:j]\nDeletes a slice\ndel s[i:j:stride]\nDeletes an extended slice\nThe s[i] = x operator changes element i of a sequence to refer to object x, increasing\nthe reference count of x. Negative indices are relative to the end of the list and attempts\nto assign a value to an out-of-range index result in an IndexError exception. The slicing\nassignment operator s[i:j] = r replaces elements k, where i <= k < j, with elements\nfrom sequence r. Indices have the same meaning as for slicing. If necessary, the sequence s\nmay be expanded or reduced in size to accommodate all the elements in r. Here’s an\nexample:\na = [1, 2, 3, 4, 5]\na[1] = 6\n# a = [1, 6, 3, 4, 5]\na[2:4] = [10, 11]\n# a = [1, 6, 10, 11, 5]\na[3:4] = [-1, -2, -3]\n# a = [1, 6, 10, -1, -2, -3, 5]\na[2:] = [0]\n# a = [1, 6, 0]\nA slicing assignment may be supplied with an optional stride argument. However, the\nbehavior is then more restricted in that the argument on the right side must have exactly\nthe same number of elements as the slice that’s being replaced. Here’s an example:",
      "content_length": 1851,
      "extraction_method": "Direct"
    },
    {
      "page_number": 65,
      "chapter": null,
      "content": "50\nChapter 2\nOperators, Expressions, and Data Manipulation\na = [1, 2, 3, 4, 5]\na[1::2] = [10, 11]\n# a = [1, 10, 3, 11, 5]\na[1::2] = [30, 40, 50]\n# ValueError. Only two elements in slice on left.\nThe del s[i] operator removes element i from a sequence and decrements its\nreference count. del s[i:j] removes all the elements in a slice. A stride may also be\nsupplied, as in del s[i:j:stride].\nThe semantics described here apply to the built-in list type. Operations involving\nsequence slicing is a rich area for customization in third-party packages. You may find that\nslices on non-list objects have different rules concerning reassignment, deletion, and\nsharing of objects. For example, the popular numpy package has different slicing semantics\nthan Python lists.\n2.12\nOperations on Sets\nA set is an unordered collection of unique values. The operations in Table 2.9 can be\nperformed on sets.\nTable 2.9\nOperations on Sets\nOperation\nDescription\ns | t\nUnion of s and t\ns & t\nIntersection of s and t\ns – t\nSet difference (items in s, not in t)\ns ^ t\nSymmetric difference (items not in both s or t)\nlen(s)\nNumber of items in the set\nitem in s, item not in s\nMembership test\ns.add(item)\nAdd an item to set s\ns.remove(item)\nRemove an item from s if it exists (otherwise an error)\ns.discard(item)\nDiscard an item from s if it exists\nHere are some examples:\n>>> a = {'a', 'b', 'c' }\n>>> b = {'c', 'd'}\n>>> a | b\n{'a', 'b', 'c', 'd'}\n>>> a & b\n>>> {'c' }\n>>> a - b\n{'a', 'b'}\n>>> b - a\n{'d'}",
      "content_length": 1482,
      "extraction_method": "Direct"
    },
    {
      "page_number": 66,
      "chapter": null,
      "content": "2.13 Operations on Mappings\n51\n>>> a ^ b\n{'a', 'b', 'd'}\n>>>\nSet operations also work on the key-view and item-view objects of dictionaries. For\nexample, to find out which keys two dictionaries have in common, do this:\n>>> a = { 'x': 1, 'y': 2, 'z': 3 }\n>>> b = { 'z': 3, 'w': 4, 'q': 5 }\n>>> a.keys() & b.keys()\n{ 'z' }\n>>>\n2.13\nOperations on Mappings\nA mapping is an association between keys and values. The built-in dict type is an\nexample. The operations in Table 2.10 may be applied to mappings.\nTable 2.10\nOperations on Mappings\nOperation\nDescription\nx = m[k]\nIndexing by key\nm[k] = x\nAssignment by key\ndel m[k]\nDeletes an item by key\nk in m\nMembership testing\nlen(m)\nNumber of items in the mapping\nm.keys()\nReturn the keys\nm.values()\nReturn the values\nm.items()\nReturn (key, value) pairs\nKey values can be any immutable object, such as strings, numbers, and tuples. When\nusing a tuple as the key, you can omit the parentheses and write comma-separated values\nlike this:\nd = { }\nd[1,2,3] = \"foo\"\nd[1,0,3] = \"bar\"\nIn this case, the key values represent a tuple, making these assignments equivalent to the\nfollowing:\nd[(1,2,3)] = \"foo\"\nd[(1,0,3)] = \"bar\"",
      "content_length": 1158,
      "extraction_method": "Direct"
    },
    {
      "page_number": 67,
      "chapter": null,
      "content": "52\nChapter 2\nOperators, Expressions, and Data Manipulation\nUsing a tuple as a key is a common technique for creating composite keys in a\nmapping. For example, a key may consist of a “first name” and “last name.”\n2.14\nList, Set, and Dictionary\nComprehensions\nOne of the most common operations involving data is transforming a collection of data\ninto another data structure. For example, here we take all the items in a list, apply an\noperation, and create a new list:\nnums = [1, 2, 3, 4, 5]\nsquares = []\nfor n in nums:\nnums.append(n * n)\nSince this kind of operation is so common, it is available as an operator known as a list\ncomprehension. Here is a more compact version of this code:\nnums = [1, 2, 3, 4, 5]\nsquares = [n * n for n in nums]\nIt is also possible to apply a filter to the operation:\nsquares = [n * n for n in nums if n > 2]\n# [9, 16, 25]\nThe general syntax for a list comprehension is as follows:\n[expression for item1 in iterable1 if condition1\nfor item2 in iterable2 if condition2\n...\nfor itemN in iterableN if conditionN ]\nThis syntax is equivalent to the following code:\nresult = []\nfor item1 in iterable1:\nif condition1:\nfor item2 in iterable2:\nif condition2:\n...\nfor itemN in iterableN:\nif conditionN:\nresult.append(expression)\nList comprehensions are a very useful way to process list data of various forms. Here are\nsome practical examples:",
      "content_length": 1363,
      "extraction_method": "Direct"
    },
    {
      "page_number": 68,
      "chapter": null,
      "content": "2.14 List, Set, and Dictionary Comprehensions\n53\n# Some data (a list of dictionaries)\nportfolio = [\n{'name': 'IBM', 'shares': 100, 'price': 91.1 },\n{'name': 'MSFT', 'shares': 50, 'price': 45.67 },\n{'name': 'HPE', 'shares': 75, 'price': 34.51 },\n{'name': 'CAT', 'shares': 60, 'price': 67.89 },\n{'name': 'IBM', 'shares': 200, 'price': 95.25 }\n]\n# Collect all names ['IBM', 'MSFT', 'HPE', 'CAT', 'IBM' ]\nnames = [s['name'] for s in portfolio]\n# Find all entries with more than 100 shares ['IBM']\nmore100 = [s['name'] for s in portfolio if s['shares'] > 100 ]\n# Find the total shares*price\ncost = sum([s['shares']*s['price'] for s in portfolio])\n# Collect (name, shares) tuples\nname_shares = [ (s['name'], s['shares']) for s in portfolio ]\nAll of the variables used inside a list comprehension are private to the comprehension.\nYou don’t need to worry about such variables overwriting other variables with the same\nname. For example:\n>>> x = 42\n>>> squares = [x*x for x in [1,2,3]]\n>>> squares\n[1, 4, 9]\n>>> x\n42\n>>>\nInstead of creating a list, you can also create a set by changing the brackets into curly\nbraces. This is known as a set comprehension. A set comprehension will give you a set of\ndistinct values. For example:\n# Set comprehension\nnames = { s['name'] for s in portfolio }\n# names = { 'IBM', 'MSFT', 'HPE', 'CAT' }\nIf you specify key:value pairs, you’ll create a dictionary instead. This is known as a\ndictionary comprehension. For example:\nprices = { s['name']:s['price'] for s in portfolio }\n# prices = { 'IBM': 95.25, 'MSFT': 45.67, 'HPE': 34.51, 'CAT': 67.89 }",
      "content_length": 1574,
      "extraction_method": "Direct"
    },
    {
      "page_number": 69,
      "chapter": null,
      "content": "54\nChapter 2\nOperators, Expressions, and Data Manipulation\nWhen creating sets and dictionaries, be aware that later entries might overwrite earlier\nentries. For example, in the prices dictionary you get the last price for 'IBM'. The first\nprice is lost.\nWithin a comprehension, it’s not possible to include any sort of exception handling. If\nthis is a concern, consider wrapping exceptions with a function, as shown here:\ndef toint(x):\ntry:\nreturn int(x)\nexcept ValueError:\nreturn None\nvalues = [ '1', '2', '-4', 'n/a', '-3', '5' ]\ndata1 = [ toint(x) for x in values ]\n# data1 = [1, 2, -4, None, -3, 5]\ndata2 = [ toint(x) for x in values if toint(x) is not None ]\n# data2 = [1, 2, -4, -3, 5]\nThe double evaluation of toint(x) in the last example can be avoided by using the :=\noperator. For example:\ndata3 = [ v for x in values if (v:=toint(x)) is not None ]\n# data3 = [1, 2, -4, -3, 5]\ndata4 = [ v for x in values if (v:=toint(x)) is not None and v >= 0 ]\n# data4 = [1, 2, 5]\n2.15\nGenerator Expressions\nA generator expression is an object that carries out the same computation as a list\ncomprehension but produces the result iteratively. The syntax is the same as for a list\ncomprehension except that you use parentheses instead of square brackets. Here’s an\nexample:\nnums = [1,2,3,4]\nsquares = (x*x for x in nums)\nUnlike a list comprehension, a generator expression does not actually create a list or\nimmediately evaluate the expression inside the parentheses. Instead, it creates a generator\nobject that produces the values on demand via iteration. If you look at the result of the\nabove example, you’ll see the following:\n>>> squares\n<generator object at 0x590a8>\n>>> next(squares)",
      "content_length": 1685,
      "extraction_method": "Direct"
    },
    {
      "page_number": 70,
      "chapter": null,
      "content": "2.15 Generator Expressions\n55\n1\n>>> next(squares)\n4\n...\n>>> for n in squares:\n...\nprint(n)\n9\n16\n>>>\nA generator expression can only be used once. If you try to iterate a second time, you’ll\nget nothing:\n>>> for n in squares:\n...\nprint(n)\n...\n>>>\nThe difference between list comprehensions and generator expressions is important but\nsubtle. With a list comprehension, Python actually creates a list that contains the resulting\ndata. With a generator expression, Python creates a generator that merely knows how to\nproduce data on demand. In certain applications, this can greatly improve performance and\nmemory use. Here’s an example:\n# Read a file\nf = open('data.txt')\n# Open a file\nlines = (t.strip() for t in f)\n# Read lines, strip\n# trailing/leading whitespace\ncomments = (t for t in lines if t[0] == '#') # All comments\nfor c in comments:\nprint(c)\nIn this example, the generator expression that extracts lines and strips whitespace does\nnot actually read and hold the entire file in memory. The same is true of the expression\nthat extracts comments. Instead, the lines of the file are read one-by-one when the\nprogram starts iterating in the for loop that follows. During this iteration, the lines of the\nfile are produced upon demand and filtered accordingly. In fact, at no time will the entire\nfile be loaded into memory during this process. This is therefore a highly efficient way to\nextract comments from a gigabyte-sized Python source file.\nUnlike a list comprehension, a generator expression does not create an object that\nworks like a sequence. It can’t be indexed, and none of the usual list operations (such as\nappend()) will work. However, the items produced by a generator expression can be\nconverted into a list using list():\nclist = list(comments)",
      "content_length": 1766,
      "extraction_method": "Direct"
    },
    {
      "page_number": 71,
      "chapter": null,
      "content": "56\nChapter 2\nOperators, Expressions, and Data Manipulation\nWhen passed as a single function argument, one set of parentheses can be removed. For\nexample, the following statements are equivalent:\nsum((x*x for x in values))\nsum(x*x for x in values)\n# Extra parens removed\nIn both cases, a generator (x*x for x in values) is created and passed to the sum()\nfunction.\n2.16\nThe Attribute (.) Operator\nThe dot (.) operator is used to access the attributes of an object. Here’s an example:\nfoo.x = 3\nprint(foo.y)\na = foo.bar(3,4,5)\nMore than one dot operator can appear in a single expression, for example foo.y.a.b.\nThe dot operator can also be applied to the intermediate results of functions, as in a =\nfoo.bar(3,4,5).spam. Stylistically, however, it is not so common for programs to create\nlong chains of attribute lookups.\n2.17\nThe Function Call () Operator\nThe f(args) operator is used to make a function call on f. Each argument to a function\nis an expression. Prior to calling the function, all of the argument expressions are fully\nevaluated from left to right. This is known as applicative order evaluation. More\ninformation about functions can be found in Chapter 5.\n2.18\nOrder of Evaluation\nTable 2.11 lists the order of operation (precedence rules) for Python operators. All\noperators except the power (**) operator are evaluated from left to right and are listed in\nthe table from highest to lowest precedence. That is, operators listed first in the table are\nevaluated before operators listed later. Operators included together within subsections,\nsuch as x * y, x / y, x // y, x @ y, and x % y, have equal precedence.\nThe order of evaluation in Table 2.11 does not depend on the types of x and y. So, even\nthough user-defined objects can redefine individual operators, it is not possible to\ncustomize the underlying evaluation order, precedence, and associativity rules.",
      "content_length": 1879,
      "extraction_method": "Direct"
    },
    {
      "page_number": 72,
      "chapter": null,
      "content": "2.18 Order of Evaluation\n57\nTable 2.11\nOrder of Evaluation (Highest Precedence to Lowest)\nOperator\nName\n(...), [...], {...}\nTuple, list, and dictionary creation\ns[i], s[i:j]\nIndexing and slicing\ns.attr\nAttribute lookup\nf(...)\nFunction calls\n+x, -x, ~x\nUnary operators\nx ** y\nPower (right associative)\nx * y, x / y, x // y, x % y, x @ y\nMultiplication, division, floor division, modulo,\nmatrix multiplication\nx + y, x - y\nAddition, subtraction\nx << y, x >> y\nBit-shifting\nx & y\nBitwise and\nx ^ y\nBitwise exclusive or\nx | y\nBitwise or\nx < y, x <= y, x > y, x >= y, x == y, x !=y,\nx is y, x is not y, x in y, x not in y\nComparison, identity, and sequence\nmembership tests\nnot x\nLogical negation\nx and y\nLogical and\nx or y\nLogical or\nlambda args: expr\nAnonymous function\nexpr if expr else expr\nConditional expression\nname := expr\nAssignment expression\nA common confusion with precedence rules is when bitwise-and (&) and bitwise-or (|)\noperators are used to mean logical-and (and) and logical-or (or). For example:\n>>> a = 10\n>>> a <= 10 and 1 < a\nTrue\n>>> a <= 10 & 1 < a\nFalse\n>>>\nThe latter expression gets evaluated as a <= (10 & 1) < a or a <= 0 < a. You can fix\nit by adding parentheses:\n>>> (a <= 10) & (1 < a)\nTrue\n>>>",
      "content_length": 1222,
      "extraction_method": "Direct"
    },
    {
      "page_number": 73,
      "chapter": null,
      "content": "58\nChapter 2\nOperators, Expressions, and Data Manipulation\nThis might seem like an esoteric edge case, but it arises with some frequency in\ndata-oriented packages such as numpy and pandas. The logical operators and and or can’t\nbe customized so the bitwise operators are used instead—even though they have a higher\nprecedence level and evaluate differently when used in Boolean relations.\n2.19\nFinal Words: The Secret Life of Data\nOne of the most frequent uses of Python is in applications involving data manipulation and\nanalysis. Here, Python provides a kind of “domain language” for thinking about your\nproblem. The built-in operators and expressions are at the core of that language and\neverything else builds from it. Thus, once you build a kind of intuition around Python’s\nbuilt-in objects and operations, you will find that your intuition applies everywhere.\nAs an example, suppose you’re working with a database and you want to iterate over the\nrecords returned by a query. Chances are, you will use the for statement to do just that.\nOr, suppose you’re working with numeric arrays and want to perform element-by-element\nmathematics on arrays. You might think that the standard math operators would work—\nand your intuition would be correct. Or, suppose you’re using a library to fetch data over\nHTTP and you want to access the contents of the HTTP headers. There’s a good chance\nthat data will be presented in a way that looks like a dictionary.\nMore information about Python’s internal protocols and how to customize them is\ngiven in Chapter 4.",
      "content_length": 1555,
      "extraction_method": "Direct"
    },
    {
      "page_number": 74,
      "chapter": null,
      "content": "3\nProgram Structure and\nControl Flow\nThis chapter covers the details of program structure and control flow. Topics include\nconditionals, looping, exceptions, and context managers.\n3.1\nProgram Structure and Execution\nPython programs are structured as a sequence of statements. All language features,\nincluding variable assignment, expressions, function definitions, classes, and module\nimports, are statements that have equal status with all other statements—meaning that any\nstatement can be placed almost anywhere in a program (although certain statements such as\nreturn can only appear inside a function). For example, this code defines two different\nversions of a function inside a conditional:\nif debug:\ndef square(x):\nif not isinstance(x,float):\nraise TypeError('Expected a float')\nreturn x * x\nelse:\ndef square(x):\nreturn x * x\nWhen loading source files, the interpreter executes statements in the order they appear\nuntil there are no more statements to execute. This execution model applies both to files\nyou run as the main program and to library files that are loaded via import.\n3.2\nConditional Execution\nThe if, else, and elif statements control conditional code execution. The general\nformat of a conditional statement is",
      "content_length": 1233,
      "extraction_method": "Direct"
    },
    {
      "page_number": 75,
      "chapter": null,
      "content": "60\nChapter 3\nProgram Structure and Control Flow\nif expression:\nstatements\nelif expression:\nstatements\nelif expression:\nstatements\n...\nelse:\nstatements\nIf no action is to be taken, you can omit both the else and elif clauses of a\nconditional. Use the pass statement if no statements exist for a particular clause:\nif expression:\npass\n# To do: please implement\nelse:\nstatements\n3.3\nLoops and Iteration\nYou implement loops using the for and while statements. Here’s an example:\nwhile expression:\nstatements\nfor i in s:\nstatements\nThe while statement executes statements until the associated expression evaluates to\nfalse. The for statement iterates over all the elements of s until no more elements are\navailable. The for statement works with any object that supports iteration. This includes\nthe built-in sequence types such as lists, tuples, and strings, but also any object that\nimplements the iterator protocol.\nIn the statement for i in s, the variable i is known as the iteration variable. On each\niteration of the loop, it receives a new value from s. The scope of the iteration variable is\nnot private to the for statement. If a previously defined variable has the same name, that\nvalue will be overwritten. Moreover, the iteration variable retains the last value after the\nloop has completed.\nIf the elements produced by iteration are iterables of identical size, you can unpack their\nvalues into separate iteration variables using a statement such as this:\ns = [ (1, 2, 3), (4, 5, 6) ]\nfor x, y, z in s:\nstatements",
      "content_length": 1521,
      "extraction_method": "Direct"
    },
    {
      "page_number": 76,
      "chapter": null,
      "content": "3.3 Loops and Iteration\n61\nIn this example, s must contain or produce iterables, each with three elements. On\neach iteration, the contents of the variables x, y, and z are assigned the items of the\ncorresponding iterable. Although it is most common to see this used when s is a sequence\nof tuples, unpacking works when the items in s are any kind of iterable, including lists,\ngenerators, and strings.\nSometimes a throw-away variable such as _ is used while unpacking. For example:\nfor x, _, z in s:\nstatements\nIn this example, a value is still placed into the _ variable, but the variable’s name implies\nthat it’s not interesting or of use in the statements that follow.\nIf the items produced by an iterable have varying sizes, you can use wildcard unpacking\nto place multiple values into a variable. For example:\ns = [ (1, 2), (3, 4, 5), (6, 7, 8, 9) ]\nfor x, y, *extra in s:\nstatements\n# x = 1, y = 2, extra = []\n# x = 3, y = 4, extra = [5]\n# x = 6, y = 7, extra = [8, 9]\n# ...\nIn this example, at least two values x and y are required, but *extra receives any extra\nvalues that might also be present. These values are always placed in a list. At most, only one\nstarred variable can appear in a single unpacking, but it can appear in any position. So,\nboth of these variants are legal:\nfor *first, x, y in s:\n...\nfor x, *middle, y in s:\n...\nWhen looping, it is sometimes useful to keep track of a numerical index in addition to\nthe data values. Here’s an example:\ni = 0\nfor x in s:\nstatements\ni += 1\nPython provides a built-in function, enumerate(), that can be used to simplify\nthis code:\nfor i, x in enumerate(s):\nstatements",
      "content_length": 1629,
      "extraction_method": "Direct"
    },
    {
      "page_number": 77,
      "chapter": null,
      "content": "62\nChapter 3\nProgram Structure and Control Flow\nenumerate(s) creates an iterator that produces tuples (0, s[0]), (1, s[1]),\n(2, s[2]), and so on. A different starting value for the count can be provided with the\nstart keyword argument to enumerate():\nfor i, x in enumerate(s, start=100):\nstatements\nIn this case, tuples of the form (100, s[0]), (101, s[1]), and so on will be produced.\nAnother common looping problem is iterating in parallel over two or more iterables—\nfor example, writing a loop where you take items from different sequences on each\niteration:\n# s and t are two sequences\ni = 0\nwhile i < len(s) and i < len(t):\nx = s[i]\n# Take an item from s\ny = t[i]\n# Take an item from t\nstatements\ni += 1\nThis code can be simplified using the zip() function. For example:\n# s and t are two sequences\nfor x, y in zip(s, t):\nstatements\nzip(s, t) combines iterables s and t into an iterable of tuples (s[0], t[0]), (s[1],\nt[1]), (s[2], t[2]), and so forth, stopping with the shortest of s and t should they be of\nunequal length. The result of zip() is an iterator that produces the results when iterated. If\nyou want the result converted to a list, use list(zip(s, t)).\nTo break out of a loop, use the break statement. For example, this code reads lines of\ntext from a file until an empty line of text is encountered:\nwith open('foo.txt') as file:\nfor line in file:\nstripped = line.strip()\nif not stripped:\nbreak\n# A blank line, stop reading\n# process the stripped line\n...\nTo jump to the next iteration of a loop (skipping the remainder of the loop body), use\nthe continue statement. This statement is useful when reversing a test and indenting\nanother level would make the program too deeply nested or unnecessarily complicated.\nAs an example, the following loop skips all of the blank lines in a file:",
      "content_length": 1806,
      "extraction_method": "Direct"
    },
    {
      "page_number": 78,
      "chapter": null,
      "content": "3.3 Loops and Iteration\n63\nwith open('foo.txt') as file:\nfor line in file:\nstripped = line.strip()\nif not stripped:\ncontinue\n# Skip the blank line\n# process the stripped line\n...\nThe break and continue statements apply only to the innermost loop being executed.\nIf you need to break out of a deeply nested loop structure, you can use an exception.\nPython doesn’t provide a “goto” statement. You can also attach the else statement to loop\nconstructs, as in the following example:\n# for-else\nwith open('foo.txt') as file:\nfor line in file:\nstripped = line.strip()\nif not stripped:\nbreak\n# process the stripped line\n...\nelse:\nraise RuntimeError('Missing section separator')\nThe else clause of a loop executes only if the loop runs to completion. This either\noccurs immediately (if the loop wouldn’t execute at all) or after the last iteration. If the\nloop is terminated early using the break statement, the else clause is skipped.\nThe primary use case for the looping else clause is in code that iterates over data but\nneeds to set or check some kind of flag or condition if the loop breaks prematurely. For\nexample, if you didn’t use else, the previous code might have to be rewritten with a flag\nvariable as follows:\nfound_separator = False\nwith open('foo.txt') as file:\nfor line in file:\nstripped = line.strip()\nif not stripped:\nfound_separator = True\nbreak\n# process the stripped line\n...\nif not found_separator:\nraise RuntimeError('Missing section separator')",
      "content_length": 1461,
      "extraction_method": "Direct"
    },
    {
      "page_number": 79,
      "chapter": null,
      "content": "64\nChapter 3\nProgram Structure and Control Flow\n3.4\nExceptions\nExceptions indicate errors and break out of the normal control flow of a program. An\nexception is raised using the raise statement. The general format of the raise statement\nis raise Exception([value]), where Exception is the exception type and value is an\noptional value giving specific details about the exception. Here’s an example:\nraise RuntimeError('Unrecoverable Error')\nTo catch an exception, use the try and except statements, as shown here:\ntry:\nfile = open('foo.txt', 'rt')\nexcept FileNotFoundError as e:\nstatements\nWhen an exception occurs, the interpreter stops executing statements in the try block\nand looks for an except clause that matches the exception type that has occurred. If one\nis found, control is passed to the first statement in the except clause. After the except\nclause is executed, control continues with the first statement that appears after the entire\ntry-except block.\nIt is not necessary for a try statement to match all possible exceptions that might occur.\nIf no matching except clause can be found, an exception continues to propagate and\nmight be caught in a different try-except block that can actually handle the exception\nelsewhere. As a matter of programming style, you should only catch exceptions from\nwhich your code can actually recover. If recovery is not possible, it’s often better to let the\nexception propagate.\nIf an exception works its way up to the top level of a program without being caught,\nthe interpreter aborts with an error message.\nIf the raise statement is used by itself, the last exception generated is raised again. This\nworks only while handling a previously raised exception. For example:\ntry:\nfile = open('foo.txt', 'rt')\nexcept FileNotFoundError:\nprint(\"Well, that didn't work.\")\nraise\n# Reraises current exception\nEach except clause may be used with an as var modifier that gives the name of a\nvariable into which an instance of the exception type is placed if an exception occurs.\nException handlers can examine this value to find out more about the cause of\nthe exception. For example, you can use isinstance() to check the exception type.\nExceptions have a few standard attributes that might be useful in code that needs to\nperform further actions in response to an error:\ne.args\nThe tuple of arguments supplied when raising the exception. In most cases, this is a\none-item tuple with a string describing the error. For OSError exceptions, the value",
      "content_length": 2487,
      "extraction_method": "Direct"
    },
    {
      "page_number": 80,
      "chapter": null,
      "content": "3.4 Exceptions\n65\nis a 2-tuple or 3-tuple containing an integer error number, string error message, and\nan optional filename.\ne.__cause__\nPrevious exception if the exception was intentionally raised in response to handling\nanother exception. See the later section on chained exceptions.\ne.__context__\nPrevious exception if the exception was raised while handling another exception.\ne.__traceback__\nStack traceback object associated with the exception.\nThe variable used to hold an exception value is only accessible inside the associated\nexcept block. Once control leaves the block, the variable becomes undefined. For\nexample:\ntry:\nint('N/A')\n# Raises ValueError\nexcept ValueError as e:\nprint('Failed:', e)\nprint(e)\n# Fails -> NameError. 'e' not defined.\nMultiple exception-handling blocks can be specified using multiple except clauses:\ntry:\ndo something\nexcept TypeError as e:\n# Handle Type error\n...\nexcept ValueError as e:\n# Handle Value error\n...\nA single handler clause can catch multiple exception types like this:\ntry:\ndo something\nexcept (TypeError, ValueError) as e:\n# Handle Type or Value errors\n...\nTo ignore an exception, use the pass statement as follows:\ntry:\ndo something\nexcept ValueError:\npass\n# Do nothing (shrug)",
      "content_length": 1233,
      "extraction_method": "Direct"
    },
    {
      "page_number": 81,
      "chapter": null,
      "content": "66\nChapter 3\nProgram Structure and Control Flow\nSilently ignoring errors is often dangerous and a source of hard-to-find mistakes. Even\nif ignored, it is often wise to optionally report the error in a log or some other place where\nyou can inspect it later.\nTo catch all exceptions except those related to program exit, use Exception like this:\ntry:\ndo something\nexcept Exception as e:\nprint(f'An error occurred : {e!r}')\nWhen catching all exceptions, you should take great care to report accurate error\ninformation to the user. For example, in the previous code, an error message and the\nassociated exception value are being printed. If you don’t include any information about\nthe exception value, it can make it very difficult to debug code that is failing for reasons\nyou don’t expect.\nThe try statement also supports an else clause, which must follow the last except\nclause. This code is executed if the code in the try block doesn’t raise an exception. Here’s\nan example:\ntry:\nfile = open('foo.txt', 'rt')\nexcept FileNotFoundError as e:\nprint(f'Unable to open foo : {e}')\ndata = ''\nelse:\ndata = file.read()\nfile.close()\nThe finally statement defines a cleanup action that must execute regardless of what\nhappens in a try-except block. Here’s an example:\nfile = open('foo.txt', 'rt')\ntry:\n# Do some stuff\n...\nfinally:\nfile.close()\n# File closed regardless of what happened\nThe finally clause isn’t used to catch errors. Rather, it’s used for code that must always\nbe executed, regardless of whether an error occurs. If no exception is raised, the code in\nthe finally clause is executed immediately after the code in the try block. If an exception\noccurs, a matching except block (if any) is executed first and then control is passed to the\nfirst statement of the finally clause. If, after this code has executed, an exception is still\npending, that exception is reraised to be caught by another exception handler.",
      "content_length": 1916,
      "extraction_method": "Direct"
    },
    {
      "page_number": 82,
      "chapter": null,
      "content": "3.4 Exceptions\n67\n3.4.1\nThe Exception Hierarchy\nOne challenge of working with exceptions is managing the vast number of exceptions that\nmight potentially occur in your program. For example, there are more than 60 built-in\nexceptions alone. Factor in the rest of the standard library and it turns into hundreds of\npossible exceptions. Moreover, there is often no way to easily determine in advance what\nkind of exceptions any portion of code might raise. Exceptions aren’t recorded as part of a\nfunction’s calling signature nor is there any sort of compiler to verify correct exception\nhandling in your code. As a result, exception handling can sometimes feel haphazard and\ndisorganized.\nIt helps to realize that exceptions are organized into a hierarchy via inheritance. Instead\nof targeting specific errors, it might be easier to focus on more general categories of errors.\nFor example, consider the different errors that might arise when looking values up in a\ncontainer:\ntry:\nitem = items[index]\nexcept IndexError:\n# Raised if items is a sequence\n...\nexcept KeyError:\n# Raised if items is a mapping\n...\nInstead of writing code to handle two highly specific exceptions, it might be easier to\ndo this:\ntry:\nitem = items[index]\nexcept LookupError:\n...\nLookupError is a class that represents a higher-level grouping of exceptions. IndexError\nand KeyError both inherit from LookupError, so this except clause would catch either\none. Yet, LookupError isn’t so broad as to include errors unrelated to the lookup.\nTable 3.1 describes the most common categories of built-in exceptions.\nThe BaseException class is rarely used directly in exception handling because it\nmatches all possible exceptions whatsoever. This includes special exceptions that affect the\ncontrol flow such as SystemExit, KeyboardInterrupt, and StopIteration. Catching\nthese is rarely what you want. Instead, all normal program-related errors inherit from\nException. ArithmeticError is the base for all math-related errors such as\nZeroDivisionError, FloatingPointError, and OverflowError. ImportError is a base for\nall import-related errors. LookupError is a base for all container lookup-related errors.\nOSError is a base for all errors originating from the operating system and environment.\nOSError encompasses a wide range of exceptions related to files, network connections,\npermissions, pipes, timeouts, and more. The ValueError exception is commonly raised\nwhen a bad input value is given to an operation. UnicodeError is a subclass of ValueError\ngrouping all Unicode-related encoding and decoding errors.",
      "content_length": 2576,
      "extraction_method": "Direct"
    },
    {
      "page_number": 83,
      "chapter": null,
      "content": "68\nChapter 3\nProgram Structure and Control Flow\nTable 3.1\nException Categories\nException Class\nDescription\nBaseException\nThe root class for all exceptions\nException\nBase class for all program-related errors\nArithmeticError\nBase class for all math-related errors\nImportError\nBase class for import-related errors\nLookupError\nBase class for all container lookup errors\nOSError\nBase class for all system-related errors. IOError and\nEnvironmentError are aliases.\nValueError\nBase class for value-related errors, including Unicode\nUnicodeError\nBase class for a Unicode string encoding-related errors\nTable 3.2 shows some common built-in exceptions that inherit directly from Exception\nbut aren’t part of a larger exception group.\nTable 3.2\nOther Built-in Exceptions\nException Class\nDescription\nAssertionError\nFailed assert statement\nAttributeError\nBad attribute lookup on an object\nEOFError\nEnd of file\nMemoryError\nRecoverable out-of-memory error\nNameError\nName not found in the local or global namespace\nNotImplementedError\nUnimplemented feature\nRuntimeError\nA generic “something bad happened” error\nTypeError\nOperation applied to an object of the wrong type\nUnboundLocalError\nUsage of a local variable before a value is assigned\n3.4.2\nExceptions and Control Flow\nNormally, exceptions are reserved for the handling of errors. However, a few exceptions\nare used to alter the control flow. These exceptions, shown in Table 3.3, inherit from\nBaseException directly.\nTable 3.3\nExceptions Used for Control Flow\nException Class\nDescription\nSystemExit\nRaised to indicate program exit\nKeyboardInterrupt\nRaised when a program is interrupted via Control-C\nStopIteration\nRaised to signal the end of iteration",
      "content_length": 1691,
      "extraction_method": "Direct"
    },
    {
      "page_number": 84,
      "chapter": null,
      "content": "3.4 Exceptions\n69\nThe SystemExit exception is used to make a program terminate on purpose. As an\nargument, you can either provide an integer exit code or a string message. If a string is\ngiven, it is printed to sys.stderr and the program is terminated with an exit code of 1.\nHere is a typical example:\nimport sys\nif len(sys.argv) != 2:\nraise SystemExit(f'Usage: {sys.argv[0]} filename)\nfilename = sys.argv[1]\nThe KeyboardInterrupt exception is raised when the program receives a SIGINT signal\n(typically by pressing Control-C in a terminal). This exception is a bit unusual in that it is\nasynchronous—meaning that it could occur at almost any time and on any statement in\nyour program. The default behavior of Python is to simply terminate when this happens.\nIf you want to control the delivery of SIGINT, the signal library module can be used (see\nChapter 9).\nThe StopIteration exception is part of the iteration protocol and signals the end of\niteration.\n3.4.3\nDefining New Exceptions\nAll the built-in exceptions are defined in terms of classes. To create a new exception,\ncreate a new class definition that inherits from Exception, such as the following:\nclass NetworkError(Exception):\npass\nTo use your new exception, use the raise statement as follows:\nraise NetworkError('Cannot find host')\nWhen raising an exception, the optional values supplied with the raise statement are\nused as the arguments to the exception’s class constructor. Most of the time, this is a string\ncontaining some kind of error message. However, user-defined exceptions can be written\nto take one or more exception values, as shown in this example:\nclass DeviceError(Exception):\ndef __init__(self, errno, msg):\nself.args = (errno, msg)\nself.errno = errno\nself.errmsg = msg\n# Raises an exception (multiple arguments)\nraise DeviceError(1, 'Not Responding')",
      "content_length": 1833,
      "extraction_method": "Direct"
    },
    {
      "page_number": 85,
      "chapter": null,
      "content": "70\nChapter 3\nProgram Structure and Control Flow\nWhen you create a custom exception class that redefines __init__(), it is important to\nassign a tuple containing the arguments of __init__() to the attribute self.args as\nshown. This attribute is used when printing exception traceback messages. If you leave it\nundefined, users won’t be able to see any useful information about the exception when an\nerror occurs.\nExceptions can be organized into a hierarchy using inheritance. For instance, the\nNetworkError exception defined earlier could serve as a base class for a variety of more\nspecific errors. Here’s an example:\nclass HostnameError(NetworkError):\npass\nclass TimeoutError(NetworkError):\npass\ndef error1():\nraise HostnameError('Unknown host')\ndef error2():\nraise TimeoutError('Timed out')\ntry:\nerror1()\nexcept NetworkError as e:\nif type(e) is HostnameError:\n# Perform special actions for this kind of error\n...\nIn this case, the except NetworkError clause catches any exception derived from\nNetworkError. To find the specific type of error that was raised, examine the type of the\nexecution value with type().\n3.4.4\nChained Exceptions\nSometimes, in response to an exception, you might want to raise a different exception. To\ndo this, raise a chained exception:\nclass ApplicationError(Exception):\npass\ndef do_something():\nx = int('N/A')\n# raises ValueError\ndef spam():\ntry:\ndo_something()",
      "content_length": 1392,
      "extraction_method": "Direct"
    },
    {
      "page_number": 86,
      "chapter": null,
      "content": "3.4 Exceptions\n71\nexcept Exception as e:\nraise ApplicationError('It failed') from e\nIf an uncaught ApplicationError occurs, you will get a message that includes both\nexceptions. For example:\n>>> spam()\nTraceback (most recent call last):\nFile \"c.py\", line 9, in spam\ndo_something()\nFile \"c.py\", line 5, in do_something\nx = int('N/A')\nValueError: invalid literal for int() with base 10: 'N/A'\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"c.py\", line 11, in spam\nraise ApplicationError('It failed') from e\n__main__.ApplicationError: It failed\n>>>\nIf you catch an ApplicationError, the __cause__ attribute of the resulting exception\nwill contain the other exception. For example:\ntry:\nspam()\nexcept ApplicationError as e:\nprint('It failed. Reason:', e.__cause__)\nIf you want to raise a new exception without including the chain of other exceptions,\nraise an error from None like this:\ndef spam():\ntry:\ndo_something()\nexcept Exception as e:\nraise ApplicationError('It failed') from None\nA programming mistake that appears in an except block will also result in a chained\nexception, but that works in a slightly different way. For example, suppose you have some\nbuggy code like this:\ndef spam():\ntry:\ndo_something()",
      "content_length": 1310,
      "extraction_method": "Direct"
    },
    {
      "page_number": 87,
      "chapter": null,
      "content": "72\nChapter 3\nProgram Structure and Control Flow\nexcept Exception as e:\nprint('It failed:', err)\n# err undefined (typo)\nThe resulting exception traceback message is slightly different:\n>>> spam()\nTraceback (most recent call last):\nFile \"d.py\", line 9, in spam\ndo_something()\nFile \"d.py\", line 5, in do_something\nx = int('N/A')\nValueError: invalid literal for int() with base 10: 'N/A'\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"d.py\", line 11, in spam\nprint('It failed. Reason:', err)\nNameError: name 'err' is not defined\n>>>\nIf an unexpected exception is raised while handling another exception, the\n__context__ attribute (instead of __cause__) holds information about the exception\nthat was being handled when the error occurred. For example:\ntry:\nspam()\nexcept Exception as e:\nprint('It failed. Reason:', e)\nif e.__context__:\nprint('While handling:', e.__context__)\nThere is an important distinction between expected and unexpected exceptions in\nexception chains. In the first example, the code was written so that the possibility of\nan exception was anticipated. For example, code was explicitly wrapped in a try-except\nblock:\ntry:\ndo_something()\nexcept Exception as e:\nraise ApplicationError('It failed') from e\nIn the second case, there was a programming mistake in the except block:\ntry:\ndo_something()",
      "content_length": 1410,
      "extraction_method": "Direct"
    },
    {
      "page_number": 88,
      "chapter": null,
      "content": "3.4 Exceptions\n73\nexcept Exception as e:\nprint('It failed:', err)\n# err undefined\nThe difference between these two cases is subtle but important. That is why exception\nchaining information is placed into either the __cause__ or the __context__ attribute.\nThe __cause__ attribute is reserved for when you’re expecting the possibility of a failure.\nThe __context__ attribute is set in both cases, but would be the only source of\ninformation for an unexpected exception raised while handling another exception.\n3.4.5\nException Tracebacks\nExceptions have an associated stack traceback that provides information about where an\nerror occurred. The traceback is stored in the __traceback__ attribute of an exception.\nFor the purposes of reporting or debugging, you might want to produce the traceback\nmessage yourself. The traceback module can be used to do this. For example:\nimport traceback\ntry:\nspam()\nexcept Exception as e:\ntblines = traceback.format_exception(type(e), e, e.__traceback__)\ntbmsg = ''.join(tblines)\nprint('It failed:')\nprint(tbmsg)\nIn this code, format_exception() produces a list of strings containing the output\nPython would normally produce in a traceback message. As input, you provide the\nexception type, value, and traceback.\n3.4.6\nException Handling Advice\nException handling is one of the most difficult things to get right in larger programs.\nHowever, there are a few rules of thumb that make it easier.\nThe first rule is to not catch exceptions that can’t be handled at that specific location in\nthe code. Consider a function like this:\ndef read_data(filename):\nwith open(filename, 'rt') as file:\nrows = []\nfor line in file:\nrow = line.split()\nrows.append((row[0], int(row[1]), float(row[2]))\nreturn rows\nSuppose the open() function fails due to a bad filename. Is this an error that should be\ncaught with a try-except statement in this function? Probably not. If the caller gives a bad",
      "content_length": 1910,
      "extraction_method": "Direct"
    },
    {
      "page_number": 89,
      "chapter": null,
      "content": "74\nChapter 3\nProgram Structure and Control Flow\nfilename, there is no sensible way to recover. There is no file to open, no data to read, and\nnothing else that’s possible. It’s better to let the operation fail and report an exception back\nto the caller. Avoiding an error check in read_data() doesn’t mean that the exception\nwould never be handled anywhere—it just means that it’s not the role of read_data() to\ndo it. Perhaps the code that prompted a user for a filename would handle this exception.\nThis advice might seem contrary to the experience of programmers accustomed to\nlanguages that rely upon special error codes or wrapped result types. In those languages,\ngreat care is made to make sure you always check return codes for errors on all operations.\nYou don’t do this in Python. If an operation can fail and there’s nothing you can do to\nrecover, it’s better to just let it fail. The exception will propagate to upper levels of the\nprogram where it is usually the responsibility of some other code to handle it.\nOn the other hand, a function might be able to recover from bad data. For example:\ndef read_data(filename):\nwith open(filename, 'rt') as file:\nrows = []\nfor line in file:\nrow = line.split()\ntry:\nrows.append((row[0], int(row[1]), float(row[2]))\nexcept ValueError as e:\nprint('Bad row:', row)\nprint('Reason:', e)\nreturn rows\nWhen catching errors, try to make your except clauses as narrow as reasonable. The\nabove code could have been written to catch all errors by using except Exception.\nHowever, doing that would make the code catch legitimate programming errors that\nprobably shouldn’t be ignored. Don’t do that—it will make debugging difficult.\nFinally, if you’re explicitly raising an exception, consider making your own exception\ntypes. For example:\nclass ApplicationError(Exception):\npass\nclass UnauthorizedUserError(ApplicationError):\npass\ndef spam():\n...\nraise UnauthorizedUserError('Go away')\n...\nOne of the more challenging problems in large code bases is assigning blame for\nprogram failures. If you make your own exceptions, you’ll be better able to distinguish\nbetween intentionally raised errors and legitimate programming mistakes. If your program",
      "content_length": 2186,
      "extraction_method": "Direct"
    },
    {
      "page_number": 90,
      "chapter": null,
      "content": "3.5 Context Managers and the with Statement\n75\ncrashes with some kind of ApplicationError defined above, you’ll know immediately\nwhy that error got raised—because you wrote the code to do it. On the other hand, if\nthe program crashes with one of Python’s built-in exceptions (such as TypeError or\nValueError), that might indicate a more serious problem.\n3.5\nContext Managers and the with\nStatement\nProper management of system resources such as files, locks, and connections is often a\ntricky problem when combined with exceptions. For example, a raised exception can cause\ncontrol flow to bypass statements responsible for releasing critical resources, such as a lock.\nThe with statement allows a series of statements to execute inside a runtime context\nthat is controlled by an object serving as a context manager. Here is an example:\nwith open('debuglog', 'wt') as file:\nfile.write('Debugging\\n')\nstatements\nfile.write('Done\\n')\nimport threading\nlock = threading.Lock()\nwith lock:\n# Critical section\nstatements\n# End critical section\nIn the first example, the with statement automatically causes the opened file to be\nclosed when the control flow leaves the block of statements that follow. In the second\nexample, the with statement automatically acquires and releases a lock when control enters\nand leaves the block of statements that follow.\nThe with obj statement allows the object obj to manage what happens when the\ncontrol flow enters and exits the associated block of statements that follow. When the with\nobj statement executes, it calls the method obj.__enter__() to signal that a new context\nis being entered. When control flow leaves the context, the method obj.__exit__(type,\nvalue, traceback) executes. If no exception has been raised, the three arguments to\n__exit__() are all set to None. Otherwise, they contain the type, value, and traceback\nassociated with the exception that has caused the control flow to leave the context. If the\n__exit__() method returns True, it indicates that the raised exception was handled and\nshould no longer be propagated. Returning None or False will cause the exception to\npropagate.\nThe with obj statement accepts an optional as var specifier. If given, the value\nreturned by obj.__enter__() is placed into var. This value is commonly the same as obj\nbecause this allows an object to be constructed and used as a context manager in the same\nstep. For example, consider this class:",
      "content_length": 2432,
      "extraction_method": "Direct"
    },
    {
      "page_number": 91,
      "chapter": null,
      "content": "76\nChapter 3\nProgram Structure and Control Flow\nclass Manager:\ndef __init__(self, x):\nself.x = x\ndef yow(self):\npass\ndef __enter__(self):\nreturn self\ndef __exit__(self, ty, val, tb):\npass\nWith it, you can create and use an instance as a context manager in a single step:\nwith Manager(42) as m:\nm.yow()\nHere is a more interesting example involving list transactions:\nclass ListTransaction:\ndef __init__(self,thelist):\nself.thelist = thelist\ndef __enter__(self):\nself.workingcopy = list(self.thelist)\nreturn self.workingcopy\ndef __exit__(self, type, value, tb):\nif type is None:\nself.thelist[:] = self.workingcopy\nreturn False\nThis class allows you to make a sequence of modifications to an existing list. However,\nthe modifications only take effect if no exceptions occur. Otherwise, the original list is left\nunmodified. For example:\nitems = [1,2,3]\nwith ListTransaction(items) as working:\nworking.append(4)\nworking.append(5)\nprint(items)\n# Produces [1,2,3,4,5]\ntry:\nwith ListTransaction(items) as working:\nworking.append(6)",
      "content_length": 1024,
      "extraction_method": "Direct"
    },
    {
      "page_number": 92,
      "chapter": null,
      "content": "3.6 Assertions and __debug__\n77\nworking.append(7)\nraise RuntimeError(\"We're hosed!\")\nexcept RuntimeError:\npass\nprint(items)\n# Produces [1,2,3,4,5]\nThe contextlib standard library module contains functionality related to more\nadvanced uses of context managers. If you find yourself regularly creating context\nmanagers, it might be worth a look.\n3.6\nAssertions and __debug__\nThe assert statement can introduce debugging code into a program. The general form of\nassert is\nassert test [, msg]\nwhere test is an expression that should evaluate to True or False. If test evaluates to\nFalse, assert raises an AssertionError exception with the optional message msg supplied\nto the assert statement. Here’s an example:\ndef write_data(file, data):\nassert file, 'write_data: file not defined!'\n...\nThe assert statement should not be used for code that must be executed to make the\nprogram correct, because it won’t be executed if Python is run in optimized mode\n(specified with the -O option to the interpreter). In particular, it’s an error to use assert to\ncheck user input or the success of some important operation. Instead, assert statements\nare used to check invariants that should always be true; if one is violated, it represents a\nbug in the program, not an error by the user.\nFor example, if the function write_data(), shown previously, were intended for use by\nan end user, the assert statement should be replaced by a conventional if statement and\nthe desired error handling.\nA common use of assert is in testing. For example, you might use it to include a\nminimal test of a function:\ndef factorial(n):\nresult = 1\nwhile n > 1:\nresult *= n\nn -= 1\nreturn result\nassert factorial(5) == 120",
      "content_length": 1686,
      "extraction_method": "Direct"
    },
    {
      "page_number": 93,
      "chapter": null,
      "content": "78\nChapter 3\nProgram Structure and Control Flow\nThe purpose of such a test is not to be exhaustive, but to serve as a kind of “smoke\ntest.” If something obvious is broken in the function, the code will crash immediately with\na failed assertion upon import.\nAssertions can also be useful in specifying a kind of programming contract on expected\ninputs and outputs. For example:\ndef factorial(n):\nassert n > 0, \"must supply a positive value\"\nresult = 1\nwhile n > 1:\nresult *= n\nn -= 1\nreturn result\nAgain, this is not meant to check for user input. It’s more of a check for internal\nprogram consistency. If some other code tries to compute negative factorials, the assertion\nwill fail and point at the offending code so that you could debug it.\n3.7\nFinal Words\nAlthough Python supports a variety of different programming styles involving functions\nand objects, the fundamental model of program execution is that of imperative\nprogramming. That is, programs are made up of statements that execute one after the\nother in the order they appear within a source file. There are only three basic control flow\nconstructs: the if statement, the while loop, and the for loop. There are few mysteries\nwhen it comes to understanding how Python executes your program.\nBy far the most complicated and potentially error-prone feature is the exceptions. In\nfact, much of this chapter focused on how to properly think about exception handling.\nEven if you follow this advice, exceptions remain a delicate part of designing libraries,\nframeworks, and APIs. Exceptions can also play havoc with proper management of\nresources—this is a problem addressed via the use of context managers and the with\nstatement.\nNot covered in this chapter are the techniques that can be used to customize almost\nevery Python language feature—including the built-in operators and even aspects of the\ncontrol flow described in this chapter. Although Python programs often appear\nsuperficially simple in structure, a surprising amount of magic can often be at work behind\nthe scenes. Much of this is described in the next chapter.",
      "content_length": 2088,
      "extraction_method": "Direct"
    },
    {
      "page_number": 94,
      "chapter": null,
      "content": "4\nObjects, Types, and Protocols\nPython programs manipulate objects of various types. There are a variety of built-in types\nsuch as numbers, strings, lists, sets, and dictionaries. In addition, you can make your own\ntypes using classes. This chapter describes the underlying Python object model and\nmechanisms that make all objects work. Particular attention is given to the “protocols” that\ndefine the core behavior of various objects.\n4.1\nEssential Concepts\nEvery piece of data stored in a program is an object. Each object has an identity, a type\n(also known as its class), and a value. For example, when you write a = 42, an integer\nobject is created with the value of 42. The identity of the object is a number representing\nits location in memory; a is a label that refers to this specific location although the label is\nnot part of the object itself.\nThe type of an object, also known as the object’s class, defines the object’s internal data\nrepresentation as well as supported methods. When an object of a particular type is\ncreated, that object is called an instance of that type. After an instance is created, its identity\ndoes not change. If an object’s value can be modified, the object is said to be mutable. If\nthe value cannot be modified, the object is said to be immutable. An object that holds\nreferences to other objects is said to be a container.\nObjects are characterized by their attributes. An attribute is a value associated with an\nobject that is accessed using the dot operator (.). An attribute might be a simple data value\nsuch as a number. However, an attribute could also be a function that is invoked to carry\nout some operation. Such functions are called methods. The following example illustrates\naccess to attributes:\na = 34\n# Create an integer\nn = a.numerator\n# Get the numerator (an attribute)\nb = [1, 2, 3]\n# Create a list\nb.append(7)\n# Add a new element using the append method\nObjects may also implement various operators, such as the + operator. For example:",
      "content_length": 1997,
      "extraction_method": "Direct"
    },
    {
      "page_number": 95,
      "chapter": null,
      "content": "80\nChapter 4\nObjects, Types, and Protocols\nc = a + 10\n# c = 34 + 10\nd = b + [4, 5]\n# d = [1, 2, 3, 7, 4, 5]\nAlthough operators use a different syntax, they are ultimately mapped to methods. For\nexample, writing a + 10 executes a method a.__add__(10).\n4.2\nObject Identity and Type\nThe built-in function id() returns the identity of an object. The identity is an integer that\nusually corresponds to the object’s location in memory. The is and is not operators\ncompare the identities of two objects. type() returns the type of an object. Here’s an\nexample of different ways you might compare two objects:\n# Compare two objects\ndef compare(a, b):\nif a is b:\nprint('same object')\nif a == b:\nprint('same value')\nif type(a) is type(b):\nprint('same type')\nHere is how this function works:\n>>> a = [1, 2, 3]\n>>> b = [1, 2, 3]\n>>> compare(a, a)\nsame object\nsame value\nsame type\n>>> compare(a, b)\nsame value\nsame type\n>>> compare(a, [4,5,6])\nsame type\n>>>\nThe type of an object is itself an object, known as object’s class. This object is uniquely\ndefined and is always the same for all instances of a given type. Classes usually have names\n(list, int, dict, and so on) that can be used to create instances, perform type checking,\nand provide type hints. For example:\nitems = list()\nif isinstance(items, list):\nitems.append(item)",
      "content_length": 1318,
      "extraction_method": "Direct"
    },
    {
      "page_number": 96,
      "chapter": null,
      "content": "4.3 Reference Counting and Garbage Collection\n81\ndef removeall(items: list, item) -> list:\nreturn [i for i in items if i != item]\nA subtype is a type defined by inheritance. It carries all of the features of the original\ntype plus additional and/or redefined methods. Inheritance is discussed in more detail in\nChapter 7, but here is an example of defining a subtype of list with a new method added\nto it:\nclass mylist(list):\ndef removeall(self, val):\nreturn [i for i in self if i != val]\n# Example\nitems = mylist([5, 8, 2, 7, 2, 13, 9])\nx = items.removeall(2)\nprint(x)\n# [5, 8, 7, 13, 9]\nThe isinstance(instance, type) function is the preferred way to check a value\nagainst a type because it is aware of subtypes. It can also check against many possible types.\nFor example:\nif isinstance(items, (list, tuple)):\nmaxval = max(items)\nAlthough type checks can be added to a program, this is often not as useful as you\nmight imagine. For one, excessive checking impacts performance. Second, programs don’t\nalways define objects that neatly fit into a nice type hierarchy. For instance, if the purpose\nof the isinstance(items, list) statement above is to test whether items is “list-like,” it\nwon’t work with objects that have the same programming interface as a list but don’t\ndirectly inherit from the built-in list type (one example is deque from the collections\nmodule).\n4.3\nReference Counting and Garbage\nCollection\nPython manages objects through automatic garbage collection. All objects are reference-\ncounted. An object’s reference count is increased whenever it’s assigned to a new name or\nplaced in a container such as a list, tuple, or dictionary:\na = 37\n# Creates an object with value 37\nb = a\n# Increases reference count on 37\nc = []\nc.append(b)\n# Increases reference count on 37\nThis example creates a single object containing the value 37. a is a name that initially\nrefers to the newly created object. When b is assigned a, b becomes a new name for the",
      "content_length": 1963,
      "extraction_method": "Direct"
    },
    {
      "page_number": 97,
      "chapter": null,
      "content": "82\nChapter 4\nObjects, Types, and Protocols\nsame object, and the object’s reference count increases. When you place b into a list, the\nobject’s reference count increases again. Throughout the example, only one object\ncorresponds to 37. All other operations are creating references to that object.\nAn object’s reference count is decreased by the del statement or whenever a reference\ngoes out of scope or is reassigned. Here’s an example:\ndel a\n# Decrease reference count of 37\nb = 42\n# Decrease reference count of 37\nc[0] = 2.0 # Decrease reference count of 37\nThe current reference count of an object can be obtained using the\nsys.getrefcount() function. For example:\n>>> a = 37\n>>> import sys\n>>> sys.getrefcount(a)\n7\n>>>\nThe reference count is often much higher than you might expect. For immutable data\nsuch as numbers and strings, the interpreter aggressively shares objects between different\nparts of the program in order to conserve memory. You just don’t notice that because the\nobjects are immutable.\nWhen an object’s reference count reaches zero, it is garbage-collected. However, in\nsome cases a circular dependency may exist in a collection of objects that are no longer in\nuse. Here’s an example:\na = { }\nb = { }\na['b'] = b\n# a contains reference to b\nb['a'] = a\n# b contains reference to a\ndel a\ndel b\nIn this example, the del statements decrease the reference count of a and b and destroy\nthe names used to refer to the underlying objects. However, since each object contains a\nreference to the other, the reference count doesn’t drop to zero and the objects remain\nallocated. The interpreter won’t leak memory, but the destruction of the objects will be\ndelayed until a cycle detector executes to find and delete the inaccessible objects. The\ncycle-detection algorithm runs periodically as the interpreter allocates more and more\nmemory during execution. The exact behavior can be fine-tuned and controlled using\nfunctions in the gc standard library module. The gc.collect() function can be used to\nimmediately invoke the cyclic garbage collector.\nIn most programs, garbage collection is something that simply happens without you\nhaving to think much about it. However, there are certain situations where manually\ndeleting objects might make sense. One such scenario arises when working with gigantic\ndata structures. For example, consider this code:",
      "content_length": 2365,
      "extraction_method": "Direct"
    },
    {
      "page_number": 98,
      "chapter": null,
      "content": "4.4 References and Copies\n83\ndef some_calculation():\ndata = create_giant_data_structure()\n# Use data for some part of a calculation\n...\n# Release the data\ndel data\n# Calculation continues\n...\nIn this code, the use of the del data statement indicates that the data variable is no\nlonger needed. If this causes the reference count to reach 0, the object is garbage-collected\nat that point. Without the del statement, the object persists for some indeterminate\namount of time until the data variable goes out of scope at the end of the function. You\nmight only notice this when trying to figure out why your program is using more memory\nthan it ought to.\n4.4\nReferences and Copies\nWhen a program makes an assignment such as b = a, a new reference to a is created. For\nimmutable objects such as numbers and strings, this assignment appears to create a copy\nof a (even though this is not the case). However, the behavior appears quite different for\nmutable objects such as lists and dictionaries. Here’s an example:\n>>> a = [1,2,3,4]\n>>> b = a\n# b is a reference to a\n>>> b is a\nTrue\n>>> b[2] = -100\n# Change an element in b\n>>> a\n# Notice how a also changed\n[1, 2, -100, 4]\n>>>\nSince a and b refer to the same object in this example, a change made to one of the\nvariables is reflected in the other. To avoid this, you have to create a copy of an object\nrather than a new reference.\nTwo types of copy operations are applied to container objects such as lists and\ndictionaries: a shallow copy and a deep copy. A shallow copy creates a new object, but\npopulates it with references to the items contained in the original object. Here’s an\nexample:\n>>> a = [ 1, 2, [3,4] ]\n>>> b = list(a)\n# Create a shallow copy of a\n>>> b is a\nFalse",
      "content_length": 1725,
      "extraction_method": "Direct"
    },
    {
      "page_number": 99,
      "chapter": null,
      "content": "84\nChapter 4\nObjects, Types, and Protocols\n>>> b.append(100)\n# Append element to b\n>>> b\n[1, 2, [3, 4], 100]\n>>> a\n# Notice that a is unchanged\n[1, 2, [3, 4]]\n>>> b[2][0] = -100\n# Modify an element inside b\n>>> b\n[1, 2, [-100, 4], 100]\n>>> a\n# Notice the change inside a\n[1, 2, [-100, 4]]\n>>>\nIn this case, a and b are separate list objects, but the elements they contain are shared.\nTherefore, a modification to one of the elements of a also modifies an element of b, as\nshown.\nA deep copy creates a new object and recursively copies all the objects it contains.\nThere is no built-in operator to create deep copies of objects, but you can use the\ncopy.deepcopy() function in the standard library:\n>>> import copy\n>>> a = [1, 2, [3, 4]]\n>>> b = copy.deepcopy(a)\n>>> b[2][0] = -100\n>>> b\n[1, 2, [-100, 4]]\n>>> a\n# Notice that a is unchanged\n[1, 2, [3, 4]]\n>>>\nUse of deepcopy() is actively discouraged in most programs. Copying of an object is\nslow and often unnecessary. Reserve deepcopy() for situations where you actually need a\ncopy because you’re about to mutate data and you don’t want your changes to affect the\noriginal object. Also, be aware that deepcopy() will fail with objects that involve system or\nruntime state (such as open files, network connections, threads, generators, and so on).\n4.5\nObject Representation and Printing\nPrograms often need to display objects—for example, to show data to the user or print it\nfor the purposes of debugging. If you supply an object x to the print(x) function or\nconvert it to a string using str(x), you will generally get a “nice” human-readable\nrepresentation of the object’s value. For example, consider an example involving dates:\n>>> from datetime import date\n>>> d = date(2012, 12, 21)\n>>> print(d)",
      "content_length": 1755,
      "extraction_method": "Direct"
    },
    {
      "page_number": 100,
      "chapter": null,
      "content": "4.6 First-Class Objects\n85\n2012-12-21\n>>> str(d)\n'2012-12-21'\n>>>\nThis “nice” representation of an object may not be sufficient for debugging. For\nexample, in the output of the above code, there is no obvious way to know if the variable\nd is a date instance or a simple string containing the text '2012-12-21'. To get more\ninformation, use the repr(x) function that creates a string with a representation of the\nobject that you would have to type out in source code to create it. For example:\n>>> d = date(2012, 12, 21)\n>>> repr(d)\n'datetime.date(2012, 12, 21)'\n>>> print(repr(d))\ndatetime.date(2012, 12, 21)\n>>> print(f'The date is: {d!r}')\nThe date is: datetime.date(2012, 12, 21)\n>>>\nIn string formatting, the !r suffix can be added to a value to produce its repr() value\ninstead of the normal string conversion.\n4.6\nFirst-Class Objects\nAll objects in Python are said to be first-class. This means that all objects that can be\nassigned to a name can also be treated as data. As data, objects can be stored as variables,\npassed as arguments, returned from functions, compared against other objects, and more.\nFor example, here is a simple dictionary containing two values:\nitems = {\n'number' : 42\n'text' : \"Hello World\"\n}\nThe first-class nature of objects can be seen by adding some more unusual items to this\ndictionary:\nitems['func']\n= abs\n# Add the abs() function\nimport math\nitems['mod']\n= math\n# Add a module\nitems['error'] = ValueError\n# Add an exception type\nnums = [1,2,3,4]\nitems['append'] = nums.append\n# Add a method of another object",
      "content_length": 1547,
      "extraction_method": "Direct"
    },
    {
      "page_number": 101,
      "chapter": null,
      "content": "86\nChapter 4\nObjects, Types, and Protocols\nIn this example, the items dictionary now contains a function, a module, an exception,\nand a method of another object. If you want, you can use dictionary lookups on items in\nplace of the original names and the code will still work. For example:\n>>> items['func'](-45)\n# Executes abs(-45)\n45\n>>> items['mod'].sqrt(4)\n# Executes math.sqrt(4)\n2.0\n>>> try:\n...\nx = int('a lot')\n... except items['error'] as e:\n# Same as: except ValueError as e\n...\nprint(\"Couldn't convert\")\n...\nCouldn't convert\n>>> items['append'](100)\n# Executes nums.append(100)\n>>> nums\n[1, 2, 3, 4, 100]\n>>>\nThe fact that everything in Python is first-class is often not fully appreciated by\nnewcomers. However, it can be used to write very compact and flexible code.\nFor example, suppose you have a line of text such as “ACME,100,490.10” and you\nwant to convert it into a list of values with appropriate type conversions. Here’s a clever\nway to do it by creating a list of types (which are first-class objects) and executing a few\ncommon list-processing operations:\n>>> line = 'ACME,100,490.10'\n>>> column_types = [str, int, float]\n>>> parts = line.split(',')\n>>> row = [ty(val) for ty, val in zip(column_types, parts)]\n>>> row\n['ACME', 100, 490.1]\n>>>\nPlacing functions or classes in a dictionary is a common technique for eliminating\ncomplex if-elif-else statements. For example, if you have code like this:\nif format == 'text':\nformatter = TextFormatter()\nelif format == 'csv':\nformatter = CSVFormatter()\nelif format == 'html':\nformatter = HTMLFormatter()\nelse:\nraise RuntimeError('Bad format')\nyou could rewrite it using a dictionary:",
      "content_length": 1650,
      "extraction_method": "Direct"
    },
    {
      "page_number": 102,
      "chapter": null,
      "content": "4.8 Object Protocols and Data Abstraction\n87\n_formats = {\n'text': TextFormatter,\n'csv': CSVFormatter,\n'html': HTMLFormatter\n}\nif format in _formats:\nformatter = _formats[format]()\nelse:\nraise RuntimeError('Bad format')\nThis latter form is also more flexible as new cases can be added by inserting more entries\ninto the dictionary without having to modify a large if-elif-else statement block.\n4.7\nUsing None for Optional or\nMissing Data\nSometimes programs need to represent an optional or missing value. None is a special\ninstance reserved for this purpose. None is returned by functions that don’t explicitly return\na value. None is also frequently used as the default value of optional arguments, so that the\nfunction can detect whether the caller has actually passed a value for that argument. None\nhas no attributes and evaluates to False in Boolean expressions.\nInternally, None is stored as a singleton—that is, there is only one None value in the\ninterpreter. Therefore, a common way to test a value against None is to use the is operator\nlike this:\nif value is None:\nstatements\n...\nTesting for None using the == operator also works, but it’s not recommended and might\nbe flagged as a style error by code-checking tools.\n4.8\nObject Protocols and Data Abstraction\nMost Python language features are defined by protocols. Consider the following function:\ndef compute_cost(unit_price, num_units):\nreturn unit_price * num_units\nNow, ask yourself the question: What inputs are allowed? The answer is deceptively\nsimple—everything is allowed! At first glance, this function looks like it might apply to\nnumbers:",
      "content_length": 1611,
      "extraction_method": "Direct"
    },
    {
      "page_number": 103,
      "chapter": null,
      "content": "88\nChapter 4\nObjects, Types, and Protocols\n>>> compute_cost(1.25, 50)\n62.5\n>>>\nIndeed, it works as expected. However, the function works with much more. You can\nuse specialized numbers such as fractions or decimals:\n>>> from fractions import Fraction\n>>> compute_cost(Fraction(5, 4), 50)\nFraction(125, 2)\n>>> from decimal import Decimal\n>>> compute_cost(Decimal('1.25'), Decimal('50'))\nDecimal('62.50')\n>>>\nNot only that—the function works with arrays and other complex structures from\npackages such as numpy. For example:\n>>> import numpy as np\n>>> prices = np.array([1.25, 2.10, 3.05])\n>>> units = np.array([50, 20, 25])\n>>> compute_cost(prices, quantities)\narray([62.5 , 42.\n, 76.25])\n>>>\nThe function might even work in unexpected ways:\n>>> compute_cost('a lot', 10)\n'a lota lota lota lota lota lota lota lota lota lot'\n>>>\nAnd yet, certain combinations of types fail:\n>>> compute_cost(Fraction(5, 4), Decimal('50'))\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 2, in compute_cost\nTypeError: unsupported operand type(s) for *: 'Fraction' and 'decimal.Decimal'\n>>>\nUnlike a compiler for a static language, Python does not verify correct program\nbehavior in advance. Instead, the behavior of an object is determined by a dynamic process\nthat involves the dispatch of so-called “special” or “magic” methods. The names of these\nspecial methods are always preceded and followed by double underscores (__). The\nmethods are automatically triggered by the interpreter as a program executes. For example,\nthe operation x * y is carried out by a method x.__mul__(y). The names of these\nmethods and their corresponding operators are hard-wired. The behavior of any given\nobject depends entirely on the set of special methods that it implements.",
      "content_length": 1784,
      "extraction_method": "Direct"
    },
    {
      "page_number": 104,
      "chapter": null,
      "content": "4.9 Object Protocol\n89\nThe next few sections describe the special methods associated with different categories\nof core interpreter features. These categories are sometimes called “protocols.” An object,\nincluding a user-defined class, may define any combination of these features to make the\nobject behave in different ways.\n4.9\nObject Protocol\nThe methods in Table 4.1 are related to the overall management of objects. This includes\nobject creation, initialization, destruction, and representation.\nTable 4.1\nMethods for Object Management\nMethod\nDescription\n__new__(cls [,*args [,**kwargs]])\nA static method called to create a new instance.\n__init__(self [,*args [,**kwargs]])\nCalled to initialize a new instance after it’s been\ncreated.\n__del__(self)\nCalled when an instance is being destroyed.\n__repr__(self)\nCreate a string representation.\nThe __new__() and __init__() methods are used together to create and initialize\ninstances. When an object is created by calling SomeClass(args), it is translated into the\nfollowing steps:\nx = SomeClass.__new__(SomeClass, args)\nif isinstance(x, SomeClass):\nx.__init__(args)\nNormally, these steps are handled behind the scenes and you don’t need to worry about\nit. The most common method implemented in a class is __init__(). Use of __new__()\nalmost always indicates the presence of advanced magic related to instance creation (for\nexample, it is used in class methods that want to bypass __init__() or in certain creational\ndesign patterns such as singletons or caching). The implementation of __new__() doesn’t\nnecessarily need to return an instance of the class in question—if not, the subsequent call\nto __init__() on creation is skipped.\nThe __del__() method is invoked when an instance is about to be garbage-collected.\nThis method is invoked only when an instance is no longer in use. Note that the statement\ndel x only decrements the instance reference count and doesn’t necessarily result in a call\nto this function. __del__() is almost never defined unless an instance needs to perform\nadditional resource management steps upon destruction.\nThe __repr__() method, called by the built-in repr() function, creates a string\nrepresentation of an object that can be useful for debugging and printing. This is also the\nmethod responsible for creating the output of values you see when inspecting variables in\nthe interactive interpreter. The convention is for __repr__() to return an expression string\nthat can be evaluated to re-create the object using eval(). For example:",
      "content_length": 2520,
      "extraction_method": "Direct"
    },
    {
      "page_number": 105,
      "chapter": null,
      "content": "90\nChapter 4\nObjects, Types, and Protocols\na = [2, 3, 4, 5]\n# Create a list\ns = repr(a)\n# s = '[2, 3, 4, 5]'\nb = eval(s)\n# Turns s back into a list\nIf a string expression cannot be created, the convention is for __repr__() to return a\nstring of the form <...message...>, as shown here:\nf = open('foo.txt')\na = repr(f)\n# a = \"<_io.TextIOWrapper name='foo.txt' mode='r' encoding='UTF-8'>\n4.10\nNumber Protocol\nTable 4.2 lists special methods that objects must implement to provide mathematical\noperations.\nTable 4.2\nMethods for Mathematical Operations\nMethod\nOperation\n__add__(self, other)\nself + other\n__sub__(self, other)\nself - other\n__mul__(self, other)\nself * other\n__truediv__(self, other)\nself / other\n__floordiv__(self, other)\nself // other\n__mod__(self, other)\nself % other\n__matmul__(self, other)\nself @ other\n__divmod__(self, other)\ndivmod(self, other)\n__pow__(self, other [, modulo])\nself ** other, pow(self, other, modulo)\n__lshift__(self, other)\nself << other\n__rshift__(self, other)\nself >> other\n__and__(self, other)\nself & other\n__or__(self, other)\nself | other\n__xor__(self, other)\nself ^ other\n__radd__(self, other)\nother + self\n__rsub__(self, other)\nother - self\n__rmul__(self, other)\nother * self\n__rtruediv__(self, other)\nother / self\n__rfloordiv__(self, other)\nother // self\n__rmod__(self, other)\nother % self\n__rmatmul__(self, other)\nother @ self\n__rdivmod__(self, other)\ndivmod(other, self)",
      "content_length": 1412,
      "extraction_method": "Direct"
    },
    {
      "page_number": 106,
      "chapter": null,
      "content": "4.10 Number Protocol\n91\nMethod\nOperation\n__rpow__(self, other)\nother ** self\n__rlshift__(self, other)\nother << self\n__rrshift__(self, other)\nother >> self\n__rand__(self, other)\nother & self\n__ror__(self, other)\nother | self\n__rxor__(self, other)\nother ^ self\n__iadd__(self, other)\nself += other\n__isub__(self, other)\nself -= other\n__imul__(self, other)\nself *= other\n__itruediv__(self, other)\nself /= other\n__ifloordiv__(self, other)\nself //= other\n__imod__(self, other)\nself %= other\n__imatmul__(self, other)\nself @= other\n__ipow__(self, other)\nself **= other\n__iand__(self, other)\nself &= other\n__ior__(self, other)\nself |= other\n__ixor__(self, other)\nself ^= other\n__ilshift__(self, other)\nself <<= other\n__irshift__(self, other)\nself >>= other\n__neg__(self)\n–self\n__pos__(self)\n+self\n__invert__(self)\n~self\n__abs__(self)\nabs(self)\n__round__(self, n)\nround(self, n)\n__floor__(self)\nmath.floor(self)\n__ceil__(self)\nmath.ceil(self)\n__trunc__(self)\nmath.trunc(self)\nWhen presented with an expression such as x + y, the interpreter invokes a\ncombination of the methods x.__add__(y) or y.__radd__(x) to carry out the operation.\nThe initial choice is to try x.__add__(y) in all cases except for the special case where y\nhappens to be a subtype of x; in that case, y.__radd__(x) executes first. If the initial\nmethod fails by returning NotImplemented, an attempt is made to invoke the operation\nwith reversed operands such as y.__radd__(x). If this second attempt fails, the entire\noperation fails. Here is an example:\n>>> a = 42\n# int\n>>> b = 3.7\n# float\n>>> a.__add__(b)\nNotImplemented",
      "content_length": 1583,
      "extraction_method": "Direct"
    },
    {
      "page_number": 107,
      "chapter": null,
      "content": "92\nChapter 4\nObjects, Types, and Protocols\n>>> b.__radd__(a)\n45.7\n>>>\nThis example might seem surprising but it reflects the fact that integers don’t actually\nknow anything about floating-point numbers. However, floating-point numbers do know\nabout integers—as integers are, mathematically, a special kind of floating-point numbers.\nThus, the reversed operand produces the correct answer.\nThe methods __iadd__(), __isub__(), and so forth are used to support in-place\narithmetic operators such as a += b and a -= b (also known as augmented assignment).\nA distinction is made between these operators and the standard arithmetic methods\nbecause the implementation of the in-place operators might be able to provide certain\ncustomizations or performance optimizations. For instance, if the object is not shared, the\nvalue of an object could be modified in place without allocating a newly created object\nfor the result. If the in-place operators are left undefined, an operation such as a += b is\nevaluated using a = a + b instead.\nThere are no methods that can be used to define the behavior of the logical and, or,\nor not operators. The and and or operators implement short-circuit evaluation where\nevaluation stops if the final result can already be determined. For example:\n>>> True or 1/0\n# Does not evaluate 1/0\nTrue\n>>>\nThis behavior involving unevaluated subexpressions can’t be expressed using the\nevaluation rules of a normal function or method. Thus, there is no protocol or set of\nmethods for redefining it. Instead, it is handled as a special case deep inside the\nimplementation of Python itself.\n4.11\nComparison Protocol\nObjects can be compared in various ways. The most basic check is an identity check with\nthe is operator. For example, a is b. Identity does not consider the values stored inside\nof an object, even if they happen to be the same. For example:\n>>> a = [1, 2, 3]\n>>> b = a\n>>> a is b\nTrue\n>>> c = [1, 2, 3]\n>>> a is c\nFalse\n>>>\nThe is operator is an internal part of Python that can’t be redefined. All other\ncomparisons on objects are implemented by the methods in Table 4.3.",
      "content_length": 2103,
      "extraction_method": "Direct"
    },
    {
      "page_number": 108,
      "chapter": null,
      "content": "4.11 Comparison Protocol\n93\nTable 4.3\nMethods for Instance Comparison and Hashing\nMethod\nDescription\n__bool__(self)\nReturns False or True for truth-value testing\n__eq__(self, other)\nself == other\n__ne__(self, other)\nself != other\n__lt__(self, other)\nself < other\n__le__(self, other)\nself <= other\n__gt__(self, other)\nself > other\n__ge__(self, other)\nself >= other\n__hash__(self)\nComputes an integer hash index\nThe __bool__() method, if present, is used to determine the truth value when an\nobject is tested as part of a condition or conditional expression. For example:\nif a:\n# Executes a.__bool__()\n...\nelse:\n...\nIf __bool__() is undefined, then __len__() is used as a fallback. If both __bool__()\nand __len__() are undefined, an object is simply considered to be True.\nThe __eq__() method is used to determine basic equality for use with the == and !=\noperators. The default implementation of __eq__() compares objects by identity using\nthe is operator. The __ne__() method, if present, can be used to implement special\nprocessing for !=, but is usually not required as long as __eq__() is defined.\nOrdering is determined by the relational operators (<, >, <=, and >=) using methods\nsuch as __lt__() and __gt__(). As with other mathematical operations, the evaluation\nrules are subtle. To evaluate a < b, the interpreter will first try to execute a.__lt__(b)\nexcept where b is a subtype of a. In that one specific case, b.__gt__(a) executes instead.\nIf this initial method is not defined or returns NotImplemented, the interpreter tries a\nreversed comparison, calling b.__gt__(a). Similar rules apply to operators such as <= and\n>=. For example, evaluating <= first tries to evaluate a.__le__(b). If not implemented,\nb.__ge__(a) is tried.\nEach of the comparison methods takes two arguments and is allowed to return any\nkind of value, including a Boolean value, a list, or any other Python type. For instance,\na numerical package might use this to perform an element-wise comparison of two\nmatrices, returning a matrix with the results. If comparison is not possible, the methods\nshould return the built-in object NotImplemented. This is not the same as the\nNotImplementedError exception. For example:\n>>> a = 42\n# int\n>>> b = 52.3\n# float\n>>> a.__lt__(b)\nNotImplemented",
      "content_length": 2271,
      "extraction_method": "Direct"
    },
    {
      "page_number": 109,
      "chapter": null,
      "content": "94\nChapter 4\nObjects, Types, and Protocols\n>>> b.__gt__(a)\nTrue\n>>>\nIt is not necessary for an ordered object to implement all of the comparison operations\nin Table 4.3. If you want to be able to sort objects or use functions such as min() or max(),\nthen __lt__() must be minimally defined. If you are adding comparison operators to a\nuser-defined class, the @total_ordering class decorator in the functools module may be\nof some use. It can generate all of the methods as long as you minimally implement\n__eq__() and one of the other comparisons.\nThe __hash__() method is defined on instances that are to be placed into a set or be\nused as keys in a mapping (dictionary). The value returned is an integer that should be the\nsame for two instances that compare as equal. Moreover, __eq__() should always be\ndefined together with __hash__() because the two methods work together. The value\nreturned by __hash__() is typically used as an internal implementation detail of various\ndata structures. However, it’s possible for two different objects to have the same hash value.\nTherefore, __eq__() is necessary to resolve potential collisions.\n4.12\nConversion Protocols\nSometimes, you must convert an object to a built-in type such as a string or a number.\nThe methods in Table 4.4 can be defined for this purpose.\nTable 4.4\nMethods for Conversions\nMethod\nDescription\n__str__(self)\nConversion to a string\n__bytes__(self)\nConversion to bytes\n__format__(self, format_spec)\nCreates a formatted representation\n__bool__(self)\nbool(self)\n__int__(self)\nint(self)\n__float__(self)\nfloat(self)\n__complex__(self)\ncomplex(self)\n__index__(self)\nConversion to a integer index [self]\nThe __str__() method is called by the built-in str() function and by functions related\nto printing. The __format__() method is called by the format() function or the\nformat() method of strings. The format_spec argument is a string containing the format\nspecification. This string is the same as the format_spec argument to format(). For\nexample:\nf'{x:spec}'\n# Calls x.__format__('spec')\nformat(x, 'spec')\n# Calls x.__format__('spec')\n'x is {0:spec}'.format(x)\n# Calls x.__format__('spec')",
      "content_length": 2152,
      "extraction_method": "Direct"
    },
    {
      "page_number": 110,
      "chapter": null,
      "content": "4.13 Container Protocol\n95\nThe syntax of the format specification is arbitrary and can be customized on an object-\nby-object basis. However, there is a standard set of conventions used for the built-in types.\nMore information about string formatting, including the general format of the specifier,\ncan be found in Chapter 9.\nThe __bytes__() method is used to create a byte representation if an instance is passed\nto bytes(). Not all types support byte conversion.\nThe numeric conversions __bool__(), __int__(), __float__(), and __complex__()\nare expected to produce a value of the corresponding built-in type.\nPython never performs implicit type conversions using these methods. Thus, even if an\nobject x implements an __int__() method, the expression 3 + x will still produce a\nTypeError. The only way to execute __int__() is through an explicit use of the int()\nfunction.\nThe __index__() method performs an integer conversion of an object when it’s used\nin an operation that requires an integer value. This includes indexing in sequence\noperations. For example, if items is a list, performing an operation such as items[x] will\nattempt to execute items[x.__index__()] if x is not an integer. __index__() is also used\nin various base conversions such as oct(x) and hex(x).\n4.13\nContainer Protocol\nThe methods in Table 4.5 are used by objects that want to implement containers of various\nkinds—lists, dicts, sets, and so on.\nTable 4.5\nMethods for Containers\nMethod\nDescription\n__len__(self)\nReturns the length of self\n__getitem__(self, key)\nReturns self[key]\n__setitem__(self, key, value)\nSets self[key] = value\n__delitem__(self, key)\nDeletes self[key]\n__contains__(self, obj)\nobj in self\nHere’s an example:\na = [1, 2, 3, 4, 5, 6]\nlen(a)\n# a.__len__()\nx = a[2]\n# x = a.__getitem__(2)\na[1] = 7\n# a.__setitem__(1,7)\ndel a[2]\n# a.__delitem__(2)\n5 in a\n# a.__contains__(5)\nThe __len__() method is called by the built-in len() function to return a non-\nnegative length. This function also determines truth values unless the __bool__() method\nhas also been defined.",
      "content_length": 2059,
      "extraction_method": "Direct"
    },
    {
      "page_number": 111,
      "chapter": null,
      "content": "96\nChapter 4\nObjects, Types, and Protocols\nFor accessing individual items, the __getitem__() method can return an item by key\nvalue. The key can be any Python object, but it is expected to be an integer for ordered\nsequences such as lists and arrays. The __setitem__() method assigns a value to an\nelement. The __delitem__() method is invoked whenever the del operation is applied to\na single element. The __contains__() method is used to implement the in operator.\nSlicing operations such as x = s[i:j] are also implemented using __getitem__(),\n__setitem__(), and __delitem__(). For slices, a special slice instance is passed as the\nkey. This instance has attributes that describe the range of the slice being requested. For\nexample:\na = [1,2,3,4,5,6]\nx = a[1:5]\n# x = a.__getitem__(slice(1, 5, None))\na[1:3] = [10,11,12]\n# a.__setitem__(slice(1, 3, None), [10, 11, 12])\ndel a[1:4]\n# a.__delitem__(slice(1, 4, None))\nThe slicing features of Python are more powerful than many programmers realize. For\nexample, the following variations of extended slicing are all supported and may be useful\nfor working with multidimensional data structures such as matrices and arrays:\na = m[0:100:10]\n# Strided slice (stride=10)\nb = m[1:10, 3:20]\n# Multidimensional slice\nc = m[0:100:10, 50:75:5]\n# Multiple dimensions with strides\nm[0:5, 5:10] = n\n# extended slice assignment\ndel m[:10, 15:]\n# extended slice deletion\nThe general format for each dimension of an extended slice is i:j[:stride], where\nstride is optional. As with ordinary slices, you can omit the starting or ending values for\neach part of a slice.\nIn addition, the Ellipsis (written as ...) is available to denote any number of trailing\nor leading dimensions in an extended slice:\na = m[..., 10:20]\n# extended slice access with Ellipsis\nm[10:20, ...] = n\nWhen using extended slices, the __getitem__(), __setitem__(), and __delitem__()\nmethods implement access, modification, and deletion, respectively. However, instead of\nan integer, the value passed to these methods is a tuple containing a combination of slice\nor Ellipsis objects. For example,\na = m[0:10, 0:100:5, ...]\ninvokes __getitem__() as follows:\na = m.__getitem__((slice(0,10,None), slice(0,100,5), Ellipsis))\nPython strings, tuples, and lists currently provide some support for extended slices. No\npart of Python or its standard library make use of multidimensional slicing or the\nEllipsis. Those features are reserved purely for third-party libraries and frameworks.\nPerhaps the most common place you would see them used is in a library such as numpy.",
      "content_length": 2568,
      "extraction_method": "Direct"
    },
    {
      "page_number": 112,
      "chapter": null,
      "content": "4.14 Iteration Protocol\n97\n4.14\nIteration Protocol\nIf an instance, obj, supports iteration, it provides a method, obj.__iter__(), that returns\nan iterator. An iterator iter, in turn, implements a single method, iter.__next__(), that\nreturns the next object or raises StopIteration to signal the end of iteration. These\nmethods are used by the implementation of the for statement as well as other operations\nthat implicitly perform iteration. For example, the statement for x in s is carried out by\nperforming these steps:\n_iter = s.__iter__()\nwhile True:\ntry:\nx = _iter.__next__()\nexcept StopIteration:\nbreak\n# Do statements in body of for loop\n...\nAn object may optionally provide a reversed iterator if it implements the\n__reversed__() special method. This method should return an iterator object with\nthe same interface as a normal iterator (that is, a __next__() method that raises\nStopIteration at the end of iteration). This method is used by the built-in reversed()\nfunction. For example:\n>>> for x in reversed([1,2,3]):\n...\nprint(x)\n3\n2\n1\n>>>\nA common implementation technique for iteration is to use a generator function\ninvolving yield. For example:\nclass FRange:\ndef __init__(self, start, stop, step):\nself.start = start\nself.stop = stop\nself.step = step\ndef __iter__(self):\nx = self.start\nwhile x < self.stop:\nyield x\nx += self.step\n# Example use:",
      "content_length": 1359,
      "extraction_method": "Direct"
    },
    {
      "page_number": 113,
      "chapter": null,
      "content": "98\nChapter 4\nObjects, Types, and Protocols\nnums = FRange(0.0, 1.0, 0.1)\nfor x in nums:\nprint(x)\n# 0.0, 0.1, 0.2, 0.3, ...\nThis works because generator functions conform to the iteration protocol themselves.\nIt’s a bit easier to implement an iterator in this way since you only have to worry about\nthe __iter__() method. The rest of the iteration machinery is already provided by the\ngenerator.\n4.15\nAttribute Protocol\nThe methods in Table 4.6 read, write, and delete the attributes of an object using the dot\n(.) operator and the del operator, respectively.\nTable 4.6\nMethods for Attribute Access\nMethod\nDescription\n__getattribute__(self, name)\nReturns the attribute self.name\n__getattr__(self, name)\nReturns the attribute self.name if it’s not\nfound through __getattribute__()\n__setattr__(self, name, value)\nSets the attribute self.name = value\n__delattr__(self, name)\nDeletes the attribute del self.name\nWhenever an attribute is accessed, the __getattribute__() method is invoked. If the\nattribute is located, its value is returned. Otherwise, the __getattr__() method is\ninvoked. The default behavior of __getattr__() is to raise an AttributeError exception.\nThe __setattr__() method is always invoked when setting an attribute, and the\n__delattr__() method is always invoked when deleting an attribute.\nThese methods are fairly blunt—in that they allow a type to completely redefine\nattribute access for all attributes. User-defined classes can define properties and descriptors\nwhich allow for more fine-grained control of attribute access. This is discussed further in\nChapter 7.\n4.16\nFunction Protocol\nAn object can emulate a function by providing the __call__() method. If an object, x,\nprovides this method, it can be invoked like a function. That is, x(arg1, arg2, ...)\ninvokes x.__call__(arg1, arg2, ...).\nThere are many built-in types that support function calls. For example, types\nimplement __call__() to create new instances. Bound methods implement\n__call__() to pass the self argument to instance methods. Library functions such as\nfunctools.partial() also create objects that emulate functions.",
      "content_length": 2112,
      "extraction_method": "Direct"
    },
    {
      "page_number": 114,
      "chapter": null,
      "content": "4.18 Final Words: On Being Pythonic\n99\n4.17\nContext Manager Protocol\nThe with statement allows a sequence of statements to execute under the control of an\ninstance known as a context manager. The general syntax is as follows:\nwith context [ as var]:\nstatements\nA context object shown here is expected to implement the methods listed in Table 4.7.\nTable 4.7\nMethods for Context Managers\nMethod\nDescription\n__enter__(self)\nCalled when entering a new context. The return value\nis placed in the variable listed with the as specifier to\nthe with statement.\n__exit__(self, type, value, tb)\nCalled when leaving a context. If an exception\noccurred, type, value, and tb have the exception\ntype, value, and traceback information.\nThe __enter__() method is invoked when the with statement executes. The value\nreturned by this method is placed into the variable specified with the optional as var\nspecifier. The __exit__() method is called as soon as control flow leaves the block of\nstatements associated with the with statement. As arguments, __exit__() receives the\ncurrent exception type, value, and a traceback if an exception has been raised. If no errors\nare being handled, all three values are set to None. The __exit__() method should return\nTrue or False to indicate if a raised exception was handled or not. If True is returned, any\npending exception is cleared and program execution continues normally with the first\nstatement after the with block.\nThe primary use of the context management interface is to allow for simplified\nresource control on objects involving system state such as open files, network connections,\nand locks. By implementing this interface, an object can safely clean up resources when\nexecution leaves a context in which an object is being used. Further details are found in\nChapter 3.\n4.18\nFinal Words: On Being Pythonic\nA commonly cited design goal is to write code that is “Pythonic.” That can mean many\nthings, but basically it encourages you to follow established idioms used by the rest of\nPython. That means knowing Python’s protocols for containers, iterables, resource\nmanagement, and so forth. Many of Python’s most popular frameworks use these protocols\nto provide good user experience. You should strive for that as well.\nOf the different protocols, three deserve special attention because of their widespread\nuse. One is creating a proper object representation using the __repr__() method. Python",
      "content_length": 2432,
      "extraction_method": "Direct"
    },
    {
      "page_number": 115,
      "chapter": null,
      "content": "100\nChapter 4\nObjects, Types, and Protocols\nprograms are often debugged and experimented with at the interactive REPL. It is also\ncommon to output objects using print() or a logging library. If you make it easy to\nobserve the state of your objects, it will make all of these things easier.\nSecond, iterating over data is one of the most common programming tasks. If you’re\ngoing to do it, you should make your code work with Python’s for statement. Many core\nparts of Python and the standard library are designed to work with iterable objects. By\nsupporting iteration in the usual way, you’ll automatically get a significant amount of extra\nfunctionality and your code will be intuitive to other programmers.\nFinally, use context managers and the with statement for the common programming\npattern where statements get sandwiched between some kind of startup and teardown\nsteps—for example, opening and closing resources, acquiring and releasing locks,\nsubscribing and unsubscribing, and so on.",
      "content_length": 993,
      "extraction_method": "Direct"
    },
    {
      "page_number": 116,
      "chapter": null,
      "content": "5\nFunctions\nFunctions are a fundamental building block of most Python programs. This chapter\ndescribes function definitions, function application, scoping rules, closures, decorators,\nand other functional programming features. Particular attention is given to different\nprogramming idioms, evaluation models, and patterns associated with functions.\n5.1\nFunction Definitions\nFunctions are defined with the def statement:\ndef add(x, y):\nreturn x + y\nThe first part of a function definition specifies the function name and parameter names\nthat represent input values. The body of a function is a sequence of statements that execute\nwhen the function is called or applied. You apply a function to arguments by writing\nthe function name followed by the arguments enclosed in parentheses: a = add(3, 4).\nArguments are fully evaluated left-to-right before executing the function body. For\nexample, add(1+1, 2+2) is first reduced to add(2, 4) before calling the function. This is\nknown as applicative evaluation order. The order and number of arguments must match the\nparameters given in the function definition. If a mismatch exists, a TypeError exception\nis raised. The structure of calling a function (such as the number of required arguments) is\nknown as the function’s call signature.\n5.2\nDefault Arguments\nYou can attach default values to function parameters by assigning values in the function\ndefinition. For example:\ndef split(line, delimiter=','):\nstatements",
      "content_length": 1460,
      "extraction_method": "Direct"
    },
    {
      "page_number": 117,
      "chapter": null,
      "content": "102\nChapter 5\nFunctions\nWhen a function defines a parameter with a default value, that parameter and all the\nparameters that follow it are optional. It is not possible to specify a parameter with no\ndefault value after any parameter with a default value.\nDefault parameter values are evaluated once when the function is first defined, not each\ntime the function is called. This often leads to surprising behavior if mutable objects are\nused as a default:\ndef func(x, items=[]):\nitems.append(x)\nreturn items\nfunc(1)\n# returns [1]\nfunc(2)\n# returns [1, 2]\nfunc(3)\n# returns [1, 2, 3]\nNotice how the default argument retains the modifications made from previous\ninvocations. To prevent this, it is better to use None and add a check as follows:\ndef func(x, items=None):\nif items is None:\nitems = []\nitems.append(x)\nreturn items\nAs a general practice, to avoid such surprises, only use immutable objects for default\nargument values—numbers, strings, Booleans, None, and so on.\n5.3\nVariadic Arguments\nA function can accept a variable number of arguments if an asterisk (*) is used as a prefix\non the last parameter name. For example:\ndef product(first, *args):\nresult = first\nfor x in args:\nresult = result * x\nreturn result\nproduct(10, 20)\n# -> 200\nproduct(2, 3, 4, 5)\n# -> 120\nIn this case, all of the extra arguments are placed into the args variable as a tuple. You\ncan then work with the arguments using the standard sequence operations—iteration,\nslicing, unpacking, and so on.",
      "content_length": 1478,
      "extraction_method": "Direct"
    },
    {
      "page_number": 118,
      "chapter": null,
      "content": "5.4 Keyword Arguments\n103\n5.4\nKeyword Arguments\nFunction arguments can be supplied by explicitly naming each parameter and specifying a\nvalue. These are known as keyword arguments. Here is an example:\ndef func(w, x, y, z):\nstatements\n# Keyword argument invocation\nfunc(x=3, y=22, w='hello', z=[1, 2])\nWith keyword arguments, the order of the arguments doesn’t matter as long as each\nrequired parameter gets a single value. If you omit any of the required arguments or if the\nname of a keyword doesn’t match any of the parameter names in the function definition, a\nTypeError exception is raised. Keyword arguments are evaluated in the same order as they\nare specified in the function call.\nPositional arguments and keyword arguments can appear in the same function call,\nprovided that all the positional arguments appear first, values are provided for all\nnonoptional arguments, and no argument receives more than one value. Here’s an example:\nfunc('hello', 3, z=[1, 2], y=22)\nfunc(3, 22, w='hello', z=[1, 2])\n# TypeError. Multiple values for w\nIf desired, it is possible to force the use of keyword arguments. This is done by listing\nparameters after a * argument or just by including a single * in the definition. For example:\ndef read_data(filename, *, debug=False):\n...\ndef product(first, *values, scale=1):\nresult = first * scale\nfor val in values:\nresult = result * val\nreturn result\nIn this example, the debug argument to read_data() can only be specified by keyword.\nThis restriction often improves code readability:\ndata = read_data('Data.csv', True)\n# NO. TypeError\ndata = read_data('Data.csv', debug=True)\n# Yes.\nThe product() function takes any number of positional arguments and an optional\nkeyword-only argument. For example:\nresult = product(2,3,4)\n# Result = 24\nresult = product(2,3,4, scale=10)\n# Result = 240",
      "content_length": 1825,
      "extraction_method": "Direct"
    },
    {
      "page_number": 119,
      "chapter": null,
      "content": "104\nChapter 5\nFunctions\n5.5\nVariadic Keyword Arguments\nIf the last argument of a function definition is prefixed with **, all the additional keyword\narguments (those that don’t match any of the other parameter names) are placed in a\ndictionary and passed to the function. The order of items in this dictionary is guaranteed\nto match the order in which keyword arguments were provided.\nArbitrary keyword arguments might be useful for defining functions that accept a large\nnumber of potentially open-ended configuration options that would be too unwieldy to\nlist as parameters. Here’s an example:\ndef make_table(data, **parms):\n# Get configuration parameters from parms (a dict)\nfgcolor = parms.pop('fgcolor', 'black')\nbgcolor = parms.pop('bgcolor', 'white')\nwidth = parms.pop('width', None)\n...\n# No more options\nif parms:\nraise TypeError(f'Unsupported configuration options {list(parms)}')\nmake_table(items, fgcolor='black', bgcolor='white', border=1,\nborderstyle='grooved', cellpadding=10,\nwidth=400)\nThe pop() method of a dictionary removes an item from a dictionary, returning a\npossible default value if it’s not defined. The parms.pop('fgcolor', 'black') expression\nused in this code mimics the behavior of a keyword argument specified with a default\nvalue.\n5.6\nFunctions Accepting All Inputs\nBy using both * and **, you can write a function that accepts any combination of\narguments. The positional arguments are passed as a tuple and the keyword arguments are\npassed as a dictionary. For example:\n# Accept variable number of positional or keyword arguments\ndef func(*args, **kwargs):\n# args is a tuple of positional args\n# kwargs is dictionary of keyword args\n...\nThis combined use of *args and **kwargs is commonly used to write wrappers,\ndecorators, proxies, and similar functions. For example, suppose you have a function to\nparse lines of text taken from an iterable:",
      "content_length": 1879,
      "extraction_method": "Direct"
    },
    {
      "page_number": 120,
      "chapter": null,
      "content": "5.7 Positional-Only Arguments\n105\ndef parse_lines(lines, separator=',', types=(), debug=False):\nfor line in lines:\n...\nstatements\n...\nNow, suppose you want to make a special-case function that parses data from a file\nspecified by filename instead. To do that, you could write:\ndef parse_file(filename, *args, **kwargs):\nwith open(filename, 'rt') as file:\nreturn parse_lines(file, *args, **kwargs)\nThe benefit of this approach is that the parse_file() function doesn’t need to know\nanything about the arguments of parse_lines(). It accepts any extra arguments the caller\nprovides and passes them along. This also simplifies the maintenance of the parse_file()\nfunction. For example, if new arguments are added to parse_lines(), those arguments\nwill magically work with the parse_file() function too.\n5.7\nPositional-Only Arguments\nMany of Python’s built-in functions only accept arguments by position. You’ll see this\nindicated by the presence of a slash (/) in the calling signature of a function shown by\nvarious help utilities and IDEs. For example, you might see something like func(x, y, /).\nThis means that all arguments appearing before the slash can only be specified by position.\nThus, you could call the function as func(2, 3) but not as func(x=2, y=3). For\ncompleteness, this syntax may also be used when defining functions. For example, you can\nwrite the following:\ndef func(x, y, /):\npass\nfunc(1, 2)\n# Ok\nfunc(1, y=2)\n# Error\nThis definition form is rarely found in code since it was first supported only in\nPython 3.8. However, it can be a useful way to avoid potential name clashes between\nargument names. For example, consider the following code:\nimport time\ndef after(seconds, func, /, *args, **kwargs):\ntime.sleep(seconds)\nreturn func(*args, **kwargs)",
      "content_length": 1767,
      "extraction_method": "Direct"
    },
    {
      "page_number": 121,
      "chapter": null,
      "content": "106\nChapter 5\nFunctions\ndef duration(*, seconds, minutes, hours):\nreturn seconds + 60 * minutes + 3600 * hours\nafter(5, duration, seconds=20, minutes=3, hours=2)\nIn this code, seconds is being passed as a keyword argument, but it’s intended to be\nused with the duration function that’s passed to after(). The use of positional-only\narguments in after() prevents a name clash with the seconds argument that appears first.\n5.8\nNames, Documentation Strings, and\nType Hints\nThe standard naming convention for functions is to use lowercase letters with an\nunderscore ( _ ) used as a word separator—for example, read_data() and not readData().\nIf a function is not meant to be used directly because it’s a helper or some kind of internal\nimplementation detail, its name usually has a single underscore prepended to it—for\nexample, _helper(). These are only conventions, however. You are free to name a\nfunction whatever you want as long as the name is a valid identifier.\nThe name of a function can be obtained via the __name__ attribute. This is sometimes\nuseful for debugging.\n>>> def square(x):\n...\nreturn x * x\n...\n>>> square.__name__\n'square'\n>>>\nIt is common for the first statement of a function to be a documentation string\ndescribing its usage. For example:\ndef factorial(n):\n'''\nComputes n factorial. For example:\n>>> factorial(6)\n120\n>>>\n'''\nif n <= 1:\nreturn 1\nelse:\nreturn n*factorial(n-1)",
      "content_length": 1396,
      "extraction_method": "Direct"
    },
    {
      "page_number": 122,
      "chapter": null,
      "content": "5.9 Function Application and Parameter Passing\n107\nThe documentation string is stored in the __doc__ attribute of the function. It’s often\naccessed by IDEs to provide interactive help.\nFunctions can also be annotated with type hints. For example:\ndef factorial(n: int) -> int:\nif n <= 1:\nreturn 1\nelse:\nreturn n * factorial(n - 1)\nThe type hints don’t change anything about how the function evaluates. That is, the\npresence of hints provides no performance benefits or extra runtime error checking. The\nhints are merely stored in the __annotations__ attribute of the function which is a\ndictionary mapping argument names to the supplied hints. Third-party tools such as IDEs\nand code checkers might use the hints for various purposes.\nSometimes you will see type hints attached to local variables within a function. For\nexample:\ndef factorial(n:int) -> int:\nresult: int = 1\n# Type-hinted local variable\nwhile n > 1:\nresult *= n\nn -= 1\nreturn result\nSuch hints are completely ignored by the interpreter. They’re not checked, stored, or\neven evaluated. Again, the purpose of the hints is to help third-party code-checking tools.\nAdding type hints to functions is not advised unless you are actively using code-checking\ntools that make use of them. It is easy to specify type hints incorrectly—and, unless you’re\nusing a tool that checks them, errors will go undiscovered until someone else decides to\nrun a type-checking tool on your code.\n5.9\nFunction Application and Parameter\nPassing\nWhen a function is called, the function parameters are local names that get bound to the\npassed input objects. Python passes the supplied objects to the function “as is” without any\nextra copying. Care is required if mutable objects, such as lists or dictionaries, are passed. If\nchanges are made, those changes are reflected in the original object. Here’s an example:\ndef square(items):\nfor i, x in enumerate(items):\nitems[i] = x * x\n# Modify items in-place",
      "content_length": 1943,
      "extraction_method": "Direct"
    },
    {
      "page_number": 123,
      "chapter": null,
      "content": "108\nChapter 5\nFunctions\na = [1, 2, 3, 4, 5]\nsquare(a)\n# Changes a to [1, 4, 9, 16, 25]\nFunctions that mutate their input values, or change the state of other parts of the\nprogram behind the scenes, are said to have “side effects.” As a general rule, side effects are\nbest avoided. They can become a source of subtle programming errors as programs grow in\nsize and complexity—it may not be obvious from reading a function call if a function has\nside effects or not. Such functions also interact poorly with programs involving threads and\nconcurrency since side effects typically need to be protected by locks.\nIt’s important to make a distinction between modifying an object and reassigning a\nvariable name. Consider this function:\ndef sum_squares(items):\nitems = [x*x for x in items]\n# Reassign \"items\" name\nreturn sum(items)\na = [1, 2, 3, 4, 5]\nresult = sum_squares(a)\nprint(a)\n# [1, 2, 3, 4, 5]\n(Unchanged)\nIn this example, it appears as if the sum_squares() function might be overwriting\nthe passed items variable. Yes, the local items label is reassigned to a new value. But the\noriginal input value (a) is not changed by that operation. Instead, the local variable\nname items is bound to a completely different object—the result of the internal list\ncomprehension. There is a difference between assigning a variable name and modifying an\nobject. When you assign a value to a name, you’re not overwriting the object that was\nalready there—you’re just reassigning the name to a different object.\nStylistically, it is common for functions with side effects to return None as a result. As an\nexample, consider the sort() method of a list:\n>>> items = [10, 3, 2, 9, 5]\n>>> items.sort()\n# Observe: no return value\n>>> items\n[2, 3, 5, 9, 10]\n>>>\nThe sort() method performs an in-place sort of list items. It returns no result. The\nlack of a result is a strong indicator of a side effect—in this case, the elements of the list got\nrearranged.\nSometimes you already have data in a sequence or a mapping that you’d like to pass to a\nfunction. To do this, you can use * and ** in function invocations. For example:\ndef func(x, y, z):\n...\ns = (1, 2, 3)",
      "content_length": 2145,
      "extraction_method": "Direct"
    },
    {
      "page_number": 124,
      "chapter": null,
      "content": "5.10 Return Values\n109\n# Pass a sequence as arguments\nresult = func(*s)\n# Pass a mapping as keyword arguments\nd = { 'x':1, 'y':2, 'z':3 }\nresult = func(**d)\nYou may be taking data from multiple sources or even supplying some of the arguments\nexplicitly, and it will all work as long as the function gets all of its required arguments,\nthere is no duplication, and everything in its calling signature aligns properly. You can even\nuse * and ** more than once in the same function call. If you’re missing an argument or\nspecify duplicate values for an argument, you’ll get an error. Python will never let you call\na function with arguments that don’t satisfy its signature.\n5.10\nReturn Values\nThe return statement returns a value from a function. If no value is specified or you omit\nthe return statement, None is returned. To return multiple values, place them in a tuple:\ndef parse_value(text):\n'''\nSplit text of the form name=val into (name, val)\n'''\nparts = text.split('=', 1)\nreturn (parts[0].strip(), parts[1].strip())\nValues returned in a tuple can be unpacked to individual variables:\nname, value = parse_value('url=http://www.python.org')\nSometimes named tuples are used as an alternative:\nfrom typing import NamedTuple\nclass ParseResult(NamedTuple):\nname: str\nvalue: str\ndef parse_value(text):\n'''\nSplit text of the form name=val into (name, val)\n'''\nparts = text.split('=', 1)\nreturn ParseResult(parts[0].strip(), parts[1].strip())",
      "content_length": 1440,
      "extraction_method": "Direct"
    },
    {
      "page_number": 125,
      "chapter": null,
      "content": "110\nChapter 5\nFunctions\nA named tuple works the same way as a normal tuple (you can perform all the same\noperations and unpacking), but you can also reference the returned values using named\nattributes:\nr = parse_value('url=http://www.python.org')\nprint(r.name, r.value)\n5.11\nError Handling\nOne problem with the parse_value() function in the previous section is error handling.\nWhat course of action should be taken if the input text is malformed and no correct result\ncan be returned?\nOne approach is to treat the result as optional—that is, the function either works by\nreturning an answer or returns None which is commonly used to indicate a missing value.\nFor example, the function could be modified like this:\ndef parse_value(text):\nparts = text.split('=', 1)\nif len(parts) == 2:\nreturn ParseResult(parts[0].strip(), parts[1].strip())\nelse:\nreturn None\nWith this design, the burden of checking for the optional result is placed on the caller:\nresult = parse_value(text)\nif result:\nname, value = result\nOr, in Python 3.8+, more compactly as follows:\nif result := parse_value(text):\nname, value = result\nInstead of returning None, you could treat malformed text as an error by raising an\nexception. For example:\ndef parse_value(text):\nparts = text.split('=', 1)\nif len(parts) == 2:\nreturn ParseResult(parts[0].strip(), parts[1].strip())\nelse:\nraise ValueError('Bad value')\nIn this case, the caller is given the option of handling bad values with try-except. For\nexample:",
      "content_length": 1473,
      "extraction_method": "Direct"
    },
    {
      "page_number": 126,
      "chapter": null,
      "content": "5.12 Scoping Rules\n111\ntry:\nname, value = parse_value(text)\n...\nexcept ValueError:\n...\nThe choice of whether or not to use an exception is not always clear-cut. As a general\nrule, exceptions are the more common way to handle an abnormal result. However,\nexceptions are also expensive if they frequently occur. If you’re writing code where\nperformance matters, returning None, False, -1, or some other special value to indicate\nfailure might be better.\n5.12\nScoping Rules\nEach time a function executes, a local namespace is created. This namespace is an\nenvironment that contains the names and values of the function parameters as well as all\nvariables that are assigned inside the function body. The binding of names is known in\nadvance when a function is defined and all names assigned within the function body are\nbound to the local environment. All other names that are used but not assigned in the\nfunction body (the free variables) are dynamically found in the global namespace which is\nalways the enclosing module where a function was defined.\nThere are two types of name-related errors that can occur during function execution.\nLooking up an undefined name of a free variable in the global environment results in a\nNameError exception. Looking up a local variable that hasn’t been assigned a value yet\nresults in an UnboundLocalError exception. This latter error is often a result of control\nflow bugs. For example:\ndef func(x):\nif x > 0:\ny = 42\nreturn x + y\n# y not assigned if conditional is false\nfunc(10)\n# Returns 52\nfunc(-10)\n# UnboundLocalError: y referenced before assignment\nUnboundLocalError is also sometimes caused by a careless use of in-place assignment\noperators. A statement such as n += 1 is handled as n = n + 1. If used before n is assigned\nan initial value, it will fail.\ndef func():\nn += 1\n# Error: UnboundLocalError\nIt’s important to emphasize that variable names never change their scope—they are\neither global variables or local variables, and this is determined at function definition time.\nHere is an example that illustrates this:",
      "content_length": 2064,
      "extraction_method": "Direct"
    },
    {
      "page_number": 127,
      "chapter": null,
      "content": "112\nChapter 5\nFunctions\nx = 42\ndef func():\nprint(x)\n# Fails. UnboundLocalError\nx = 13\nfunc()\nIn this example, it might look as though the print() function would output the value\nof the global variable x. However, the assignment of x that appears later marks x as a local\nvariable. The error is a result of accessing a local variable that hasn’t yet been assigned a\nvalue.\nIf you remove the print() function, you get code that looks like it might be\nreassigning the value of a global variable. For example, consider this:\nx = 42\ndef func():\nx = 13\nfunc()\n# x is still 42\nWhen this code executes, x retains its value of 42, despite the appearance that it might\nbe modifying the global variable x from inside the function func. When variables are\nassigned inside a function, they’re always bound as local variables; as a result, the variable\nx in the function body refers to an entirely new object containing the value 13, not the\nouter variable. To alter this behavior, use the global statement. global declares names as\nbelonging to the global namespace, and it’s necessary when a global variable needs to be\nmodified. Here’s an example:\nx = 42\ny = 37\ndef func():\nglobal x\n# 'x' is in global namespace\nx = 13\ny = 0\nfunc()\n# x is now 13. y is still 37.\nIt should be noted that use of the global statement is usually considered poor Python\nstyle. If you’re writing code where a function needs to mutate state behind the scenes,\nconsider using a class definition and modify state by mutating an instance or class variable\ninstead. For example:\nclass Config:\nx = 42\ndef func():\nConfig.x = 13",
      "content_length": 1586,
      "extraction_method": "Direct"
    },
    {
      "page_number": 128,
      "chapter": null,
      "content": "5.12 Scoping Rules\n113\nPython allows nested function definitions. Here’s an example:\ndef countdown(start):\nn = start\ndef display():\n# Nested function definition\nprint('T-minus', n)\nwhile n > 0:\ndisplay()\nn -= 1\nVariables in nested functions are bound using lexical scoping. That is, names are\nresolved first in the local scope and then in successive enclosing scopes from the innermost\nscope to the outermost scope. Again, this is not a dynamic process—the binding of names\nis determined once at function definition time based on syntax. As with global variables,\ninner functions can’t reassign the value of a local variable defined in an outer function. For\nexample, this code does not work:\ndef countdown(start):\nn = start\ndef display():\nprint('T-minus', n)\ndef decrement():\nn -= 1\n# Fails: UnboundLocalError\nwhile n > 0:\ndisplay()\ndecrement()\nTo fix this, you can declare n as nonlocal like this:\ndef countdown(start):\nn = start\ndef display():\nprint('T-minus', n)\ndef decrement():\nnonlocal n\nn -= 1\n# Modifies the outer n\nwhile n > 0:\ndisplay()\ndecrement()\nnonlocal cannot be used to refer to a global variable—it must reference a local variable\nin an outer scope. Thus, if a function is assigning to a global, you should still use the\nglobal declaration as previously described.\nUse of nested functions and nonlocal declarations is not a common programming style.\nFor example, inner functions have no outside visibility, which can complicate testing and\ndebugging. Nevertheless, nested functions are sometimes useful for breaking complex\ncalculations into smaller parts and hiding internal implementation details.",
      "content_length": 1617,
      "extraction_method": "Direct"
    },
    {
      "page_number": 129,
      "chapter": null,
      "content": "114\nChapter 5\nFunctions\n5.13\nRecursion\nPython supports recursive functions. For example:\ndef sumn(n):\nif n == 0:\nreturn 0\nelse:\nreturn n + sumn(n-1)\nHowever, there is a limit on the depth of recursive function calls. The function\nsys.getrecursionlimit() returns the current maximum recursion depth, and the\nfunction sys.setrecursionlimit() can be used to change the value. The default value is\n1000. Although it is possible to increase the value, programs are still limited by the stack\nsize enforced by the host operating system. When the recursion depth limit is exceeded, a\nRuntimeError exception is raised. If the limit is increased too much, Python might crash\nwith a segmentation fault or another operating system error.\nIn practice, issues with the recursion limit only arise when you work with deeply\nnested recursive data structures such as trees and graphs. Many algorithms involving trees\nnaturally lend themselves to recursive solutions—and, if your data structure is too large,\nyou might blow the stack limit. However, there are some clever workarounds; see\nChapter 6 on generators for an example.\n5.14\nThe lambda Expression\nAn anonymous—unnamed—function can be defined with a lambda expression:\nlambda args: expression\nargs is a comma-separated list of arguments, and expression is an expression involving\nthose arguments. Here’s an example:\na = lambda x, y: x + y\nr = a(2, 3)\n# r gets 5\nThe code defined with lambda must be a valid expression. Multiple statements, or\nnonexpression statements such as try and while, cannot appear in a lambda expression.\nlambda expressions follow the same scoping rules as functions.\nOne of the main uses of lambda is to define small callback functions. For example, you\nmay see it used with built-in operations such as sorted(). For example:\n# Sort a list of words by the number of unique letters\nresult = sorted(words, key=lambda word: len(set(word)))\nCaution is required when a lambda expression contains free variables (not specified as\nparameters). Consider this example:",
      "content_length": 2024,
      "extraction_method": "Direct"
    },
    {
      "page_number": 130,
      "chapter": null,
      "content": "5.15 Higher-Order Functions\n115\nx = 2\nf = lambda y: x * y\nx = 3\ng = lambda y: x * y\nprint(f(10))\n# --> prints 30\nprint(g(10))\n# --> prints 30\nIn this example, you might expect the call f(10) to print 20, reflecting the fact that\nx was 2 at the time of definition. However, this is not the case. As a free variable, the\nevaluation of f(10) uses whatever value x happens to have at the time of evaluation.\nIt could be different from the value it had when the lambda function was defined.\nSometimes this behavior is referred to as late binding.\nIf it’s important to capture the value of a variable at the time of definition, use a default\nargument:\nx = 2\nf = lambda y, x=x: x * y\nx = 3\ng = lambda y, x=x: x * y\nprint(f(10))\n# --> prints 20\nprint(g(10))\n# --> prints 30\nThis works because default argument values are only evaluated at the time of function\ndefinition and thus would capture the current value of x.\n5.15\nHigher-Order Functions\nPython supports the concept of higher-order functions. This means that functions can be\npassed as arguments to other functions, placed in data structures, and returned by a\nfunction as a result. Functions are said to be first-class objects, meaning there is no difference\nbetween how you might handle a function and any other kind of data. Here is an example\nof a function that accepts another function as input and calls it after a time delay—for\nexample, to emulate the performance of a microservice in the cloud:\nimport time\ndef after(seconds, func):\ntime.sleep(seconds)\nfunc()\n# Example usage\ndef greeting():\nprint('Hello World')\nafter(10, greeting)\n# Prints 'Hello World' after 10 seconds",
      "content_length": 1631,
      "extraction_method": "Direct"
    },
    {
      "page_number": 131,
      "chapter": null,
      "content": "116\nChapter 5\nFunctions\nHere, the func argument to after() is an example of what’s known as a callback\nfunction. This refers to the fact that the after() function “calls back” to the function\nsupplied as an argument.\nWhen a function is passed as data, it implicitly carries information related to the\nenvironment in which the function was defined. For example, suppose the greeting()\nfunction makes use of a variable like this:\ndef main():\nname = 'Guido'\ndef greeting():\nprint('Hello', name)\nafter(10, greeting)\n# Produces: 'Hello Guido'\nmain()\nIn this example, the variable name is used by greeting(), but it’s a local variable of the\nouter main() function. When greeting is passed to after(), the function remembers its\nenvironment and uses the value of the required name variable. This relies on a feature\nknown as a closure. A closure is a function along with an environment containing all of the\nvariables needed to execute the function body.\nClosures and nested functions are useful when you write code based on the concept of\nlazy or delayed evaluation. The after() function, shown above, is an illustration of this\nconcept. It receives a function that is not evaluated right away—that only happens at some\nlater point in time. This is a common programming pattern that arises in other contexts.\nFor example, a program might have functions that only execute in response to events—\nkey presses, mouse movement, arrival of network packets, and so on. In all of these cases,\nfunction evaluation is deferred until something interesting happens. When the function\nfinally executes, a closure ensures that the function gets everything that it needs.\nYou can also write functions that create and return other functions. For example:\ndef make_greeting(name):\ndef greeting():\nprint('Hello', name)\nreturn greeting\nf = make_greeting('Guido')\ng = make_greeting('Ada')\nf()\n# Produces: 'Hello Guido'\ng()\n# Produces: 'Hello Ada'\nIn this example, the make_greeting() function doesn’t carry out any interesting\ncomputations. Instead, it creates and returns a function greeting() that does the actual\nwork. That only happens when that function gets evaluated later.\nIn this example, the two variables f and g hold two different versions of the greeting()\nfunction. Even though the make_greeting() function that created those functions is no",
      "content_length": 2329,
      "extraction_method": "Direct"
    },
    {
      "page_number": 132,
      "chapter": null,
      "content": "5.15 Higher-Order Functions\n117\nlonger executing, the greeting() functions still remember the name variable that was\ndefined—it’s part of each function’s closure.\nOne caution about closures is that binding to variable names is not a “snapshot” but a\ndynamic process—meaning the closure points to the name variable and the value that it\nwas most recently assigned. This is subtle, but here’s an example that illustrates where\ntrouble can arise:\ndef make_greetings(names):\nfuncs = []\nfor name in names:\nfuncs.append(lambda: print('Hello', name))\nreturn funcs\n# Try it\na, b, c = make_greetings(['Guido', 'Ada', 'Margaret'])\na()\n# Prints 'Hello Margaret'\nb()\n# Prints 'Hello Margaret'\nc()\n# Prints 'Hello Margaret'\nIn this example, a list of different functions is made (using lambda). It may appear as if\nthey are all using a unique value of name, as it changes on each iteration of a for loop. This\nis not the case. All functions end up using the same value of name—the value it has when\nthe outer make_greetings() function returns.\nThis is probably unexpected and not what you want. If you want to capture a copy of a\nvariable, capture it as a default argument, as previously described:\ndef make_greetings(names):\nfuncs = []\nfor name in names:\nfuncs.append(lambda name=name: print('Hello', name))\nreturn funcs\n# Try it\na, b, c = make_greetings(['Guido', 'Ada', 'Margaret'])\na()\n# Prints 'Hello Guido'\nb()\n# Prints 'Hello Ada'\nc()\n# Prints 'Hello Margaret'\nIn the last two examples, functions have been defined using lambda. This is often used\nas a shortcut for creating small callback functions. However, it’s not a strict requirement.\nYou could have rewritten it like this:\ndef make_greetings(names):\nfuncs = []\nfor name in names:\ndef greeting(name=name):\nprint('Hello', name)",
      "content_length": 1776,
      "extraction_method": "Direct"
    },
    {
      "page_number": 133,
      "chapter": null,
      "content": "118\nChapter 5\nFunctions\nfuncs.append(greeting)\nreturn funcs\nThe choice of when and where to use lambda is one of personal preference and a\nmatter of code clarity. If it makes code harder to read, perhaps it should be avoided.\n5.16\nArgument Passing in Callback\nFunctions\nOne challenging problem with callback functions is that of passing arguments to the\nsupplied function. Consider the after() function written earlier:\nimport time\ndef after(seconds, func):\ntime.sleep(seconds)\nfunc()\nIn this code, func() is hardwired to be called with no arguments. If you want to pass\nextra arguments, you’re out of luck. For example, you might try this:\ndef add(x, y):\nprint(f'{x} + {y} -> {x+y}')\nreturn x + y\nafter(10, add(2, 3))\n# Fails: add() called immediately\nIn this example, the add(2, 3) function runs immediately, returning 5. The after()\nfunction then crashes 10 seconds later as it tries to execute 5(). That is definitely not what\nyou intended. Yet there seems to be no obvious way to make it work if add() is called\nwith its desired arguments.\nThis problem hints towards a greater design issue concerning the use of functions and\nfunctional programming in general—function composition. When functions are mixed\ntogether in various ways, you need to think about how function inputs and outputs\nconnect together. It is not always simple.\nIn this case, one solution is to package up computation into a zero-argument function\nusing lambda. For example:\nafter(10, lambda: add(2, 3))\nA small zero-argument function like this is sometimes known as a thunk. Basically, it’s an\nexpression that will be evaluated later when it’s eventually called as a zero-argument\nfunction. This can be a general-purpose way to delay the evaluation of any expression to a\nlater point in time: put the expression in a lambda and call the function when you actually\nneed the value.",
      "content_length": 1855,
      "extraction_method": "Direct"
    },
    {
      "page_number": 134,
      "chapter": null,
      "content": "5.16 Argument Passing in Callback Functions\n119\nAs an alternative to using lambda, you could use functools.partial() to create a\npartially evaluated function like this:\nfrom functools import partial\nafter(10, partial(add, 2, 3))\npartial() creates a callable where one or more of the arguments have already been\nspecified and are cached. It can be a useful way to make nonconforming functions match\nexpected calling signatures in callbacks and other applications. Here are a few more\nexamples of using partial():\ndef func(a, b, c, d):\nprint(a, b, c, d)\nf = partial(func, 1, 2)\n# Fix a=1, b=2\nf(3, 4)\n# func(1, 2, 3, 4)\nf(10, 20)\n# func(1, 2, 10, 20)\ng = partial(func, 1, 2, d=4)\n# Fix a=1, b=2, d=4\ng(3)\n# func(1, 2, 3, 4)\ng(10)\n# func(1, 2, 10, 4)\npartial() and lambda can be used for similar purposes, but there is an important\nsemantic distinction between the two techniques. With partial(), the arguments are\nevaluated and bound at the time the partial function is first defined. With a zero-argument\nlambda, the arguments are evaluated and bound when the lambda function actually\nexecutes later (the evaluation of everything is delayed). To illustrate:\n>>> def func(x, y):\n...\nreturn x + y\n...\n>>> a = 2\n>>> b = 3\n>>> f = lambda: func(a, b)\n>>> g = partial(func, a, b)\n>>> a = 10\n>>> b = 20\n>>> f()\n# Uses current values of a, b\n30\n>>> g()\n# Uses initial values of a, b\n5\n>>>\nSince partials are fully evaluated, the callables created by partial() are objects that can\nbe serialized into bytes, saved in files, and even transmitted across network connections (for\nexample, using the pickle standard library module). This is not possible with a lambda",
      "content_length": 1653,
      "extraction_method": "Direct"
    },
    {
      "page_number": 135,
      "chapter": null,
      "content": "120\nChapter 5\nFunctions\nfunction. Thus, in applications where functions are passed around, possibly to Python\ninterpreters running in different processes or on different machines, you’ll find partial()\nto be a bit more adaptable.\nAs an aside, partial function application is closely related to a concept known as currying.\nCurrying is a functional programming technique where a multiple-argument function is\nexpressed as a chain of nested single-argument functions. Here is an example:\n# Three-argument function\ndef f(x, y, z):\nreturn x + y + z\n# Curried version\ndef fc(x):\nreturn lambda y: (lambda z: x + y + z)\n# Example use\na = f(2, 3, 4)\n# Three-argument function\nb = fc(2)(3)(4)\n# Curried version\nThis is not a common Python programming style and there are few practical reasons\nfor doing it. However, sometimes you’ll hear the word “currying” thrown about in\nconversations with coders who’ve spent too much time warping their brains with things\nlike lambda calculus. This technique of handling multiple arguments is named in honor\nof the famous logician Haskell Curry. Knowing what it is might be useful—should you\nstumble into a group of functional programmers having a heated flamewar at a social event.\nGetting back to the original problem of argument passing, another option for passing\narguments to a callback function is to accept them separately as arguments to the outer\ncalling function. Consider this version of the after() function:\ndef after(seconds, func, *args):\ntime.sleep(seconds)\nfunc(*args)\nafter(10, add, 2, 3)\n# Calls add(2, 3) after 10 seconds\nYou will notice that passing keyword arguments to func() is not supported. This is\nby design. One issue with keyword arguments is that the argument names of the given\nfunction might clash with argument names already in use (that is, seconds and func).\nKeyword arguments might also be reserved for specifying options to the after() function\nitself. For example:\ndef after(seconds, func, *args, debug=False):\ntime.sleep(seconds)\nif debug:\nprint('About to call', func, args)\nfunc(*args)",
      "content_length": 2054,
      "extraction_method": "Direct"
    },
    {
      "page_number": 136,
      "chapter": null,
      "content": "5.17 Returning Results from Callbacks\n121\nAll is not lost, however. If you need to specify keyword arguments to func(), you can\nstill do it using partial(). For example:\nafter(10, partial(add, y=3), 2)\nIf you wanted the after() function to accept keyword arguments, a safe way to do it\nmight be to use positional-only arguments. For example:\ndef after(seconds, func, debug=False, /, *args, **kwargs):\ntime.sleep(seconds)\nif debug:\nprint('About to call', func, args, kwargs)\nfunc(*args, **kwargs)\nafter(10, add, 2, y=3)\nAnother possibly unsettling insight is that after() actually represents two different\nfunction calls merged together. Perhaps the problem of passing arguments can be\ndecomposed into two functions like this:\ndef after(seconds, func, debug=False):\ndef call(*args, **kwargs):\ntime.sleep(seconds)\nif debug:\nprint('About to call', func, args, kwargs)\nfunc(*args, **kwargs)\nreturn call\nafter(10, add)(2, y=3)\nNow, there are no conflicts whatsoever between the arguments to after() and the\narguments to func. However, there is a chance that doing this will introduce a conflict\nbetween you and your coworkers.\n5.17\nReturning Results from Callbacks\nAnother problem not addressed in the previous section is that of returning the results of\nthe calculation. Consider this modified after() function:\ndef after(seconds, func, *args):\ntime.sleep(seconds)\nreturn func(*args)\nThis works, but there are some subtle corner cases that arise from the fact that two\nseparate functions are involved—the after() function itself and the supplied\ncallback func.\nOne issue concerns exception handling. For example, try these two examples:",
      "content_length": 1632,
      "extraction_method": "Direct"
    },
    {
      "page_number": 137,
      "chapter": null,
      "content": "122\nChapter 5\nFunctions\nafter(\"1\", add, 2, 3)\n# Fails: TypeError (integer is expected)\nafter(1, add, \"2\", 3)\n# Fails: TypeError (can't concatenate int to str)\nA TypeError is raised in both cases, but it’s for very different reasons and in different\nfunctions. The first error is due to a problem in the after() function itself: A bad\nargument is being given to time.sleep(). The second error is due to a problem with the\nexecution of the callback function func(*args).\nIf it’s important to distinguish between these two cases, there are a few options for that.\nOne option is to rely on chained exceptions. The idea is to package errors from the\ncallback in a different way that allows them to be handled separately from other kinds of\nerrors. For example:\nclass CallbackError(Exception):\npass\ndef after(seconds, func, *args):\ntime.sleep(seconds)\ntry:\nreturn func(*args)\nexcept Exception as err:\nraise CallbackError('Callback function failed') from err\nThis modified code isolates errors from the supplied callback into its own exception\ncategory. Use it like this:\ntry:\nr = after(delay, add, x, y)\nexcept CallbackError as err:\nprint(\"It failed. Reason\", err.__cause__)\nIf there was a problem with the execution of after() itself, that exception would\npropagate out, uncaught. On the other hand, problems related to the execution of the\nsupplied callback function would be caught and reported as a CallbackError. All of this is\nquite subtle, but in practice, managing errors is hard. This approach makes the attribution\nof blame more precise and the behavior of after() easier to document. Specifically, if\nthere is a problem in the callback, it’s always reported as a CallbackError.\nAnother option is to package the result of the callback function into some kind of result\ninstance that holds both a value and an error. For example, define a class like this:\nclass Result:\ndef __init__(self, value=None, exc=None):\nself._value = value\nself._exc = exc\ndef result(self):\nif self._exc:\nraise self._exc",
      "content_length": 1998,
      "extraction_method": "Direct"
    },
    {
      "page_number": 138,
      "chapter": null,
      "content": "5.17 Returning Results from Callbacks\n123\nelse:\nreturn self._value\nThen, use this class to return results from the after() function:\ndef after(seconds, func, *args):\ntime.sleep(seconds)\ntry:\nreturn Result(value=func(*args))\nexcept Exception as err:\nreturn Result(exc=err)\n# Example use:\nr = after(1, add, 2, 3)\nprint(r.result())\n# Prints 5\ns = after(\"1\", add, 2, 3)\n# Immediately raises TypeError. Bad sleep() arg.\nt = after(1, add, \"2\", 3)\n# Returns a \"Result\"\nprint(t.result())\n# Raises TypeError\nThis second approach works by deferring the result reporting of the callback function\nto a separate step. If there is a problem with after(), it gets reported immediately. If there\nis a problem with the callback func(), that gets reported when a user tries to obtain the\nresult by calling the result() method.\nThis style of boxing a result into a special instance to be unwrapped later is an\nincreasingly common pattern found in modern programming languages. One reason for\nits use is that it facilitates type checking. For example, if you were to put a type hint on\nafter(), its behavior is fully defined—it always returns a Result and nothing else:\ndef after(seconds, func, *args) -> Result:\n...\nAlthough it’s not so common to see this kind of pattern in Python code, it does arise\nwith some regularity when working with concurrency primitives such as threads and\nprocesses. For example, instances of a so-called Future behave like this when working with\nthread pools. For example:\nfrom concurrent.futures import ThreadPoolExecutor\npool = ThreadPoolExecutor(16)\nr = pool.submit(add, 2, 3)\n# Returns a Future\nprint(r.result())\n# Unwrap the Future result",
      "content_length": 1653,
      "extraction_method": "Direct"
    },
    {
      "page_number": 139,
      "chapter": null,
      "content": "124\nChapter 5\nFunctions\n5.18\nDecorators\nA decorator is a function that creates a wrapper around another function. The primary\npurpose of this wrapping is to alter or enhance the behavior of the object being wrapped.\nSyntactically, decorators are denoted using the special @ symbol as follows:\n@decorate\ndef func(x):\n...\nThe preceding code is shorthand for the following:\ndef func(x):\n...\nfunc = decorate(func)\nIn the example, a function func() is defined. However, immediately after its definition,\nthe function object itself is passed to the function decorate(), which returns an object\nthat replaces the original func.\nAs an example of a concrete implementation, here is a decorator @trace that adds\ndebugging messages to a function:\ndef trace(func):\ndef call(*args, **kwargs):\nprint('Calling', func.__name__)\nreturn func(*args, **kwargs)\nreturn call\n# Example use\n@trace\ndef square(x):\nreturn x * x\nIn this code, trace() creates a wrapper function that writes some debugging output\nand then calls the original function object. Thus, if you call square(), you will see the\noutput of the print() function in the wrapper.\nIf only it were so easy! In practice, functions also contain metadata such as the function\nname, doc string, and type hints. If you put a wrapper around a function, this information\ngets hidden. When writing a decorator, it’s considered best practice to use the @wraps()\ndecorator as shown in this example:\nfrom functools import wraps\ndef trace(func):\n@wraps(func)\ndef call(*args, **kwargs):\nprint('Calling', func.__name__)",
      "content_length": 1545,
      "extraction_method": "Direct"
    },
    {
      "page_number": 140,
      "chapter": null,
      "content": "5.18 Decorators\n125\nreturn func(*args, **kwargs)\nreturn call\nThe @wraps() decorator copies various function metadata to the replacement function.\nIn this case, metadata from the given function func() is copied to the returned wrapper\nfunction call().\nWhen decorators are applied, they must appear on their own line immediately prior to\nthe function. More than one decorator can be applied. Here’s an example:\n@decorator1\n@decorator2\ndef func(x):\npass\nIn this case, the decorators are applied as follows:\ndef func(x):\npass\nfunc = decorator1(decorator2(func))\nThe order in which decorators appear might matter. For example, in class definitions,\ndecorators such as @classmethod and @staticmethod often have to be placed at the\noutermost level. For example:\nclass SomeClass(object):\n@classmethod\n# Yes\n@trace\ndef a(cls):\npass\n@trace\n# No. Fails.\n@classmethod\ndef b(cls):\npass\nThe reason for this placement restriction has to do with the values returned by\n@classmethod. Sometimes a decorator returns an object that’s different than a normal\nfunction. If the outermost decorator isn’t expecting this, things can break. In this case,\n@classmethod creates a classmethod descriptor object (see Chapter 7). Unless the @trace\ndecorator was written to account for this, it will fail if decorators are listed in the wrong\norder.\nA decorator can also accept arguments. Suppose you want to change the @trace\ndecorator to allow for a custom message like this:\n@trace(\"You called {func.__name__}\")\ndef func():\npass",
      "content_length": 1499,
      "extraction_method": "Direct"
    },
    {
      "page_number": 141,
      "chapter": null,
      "content": "126\nChapter 5\nFunctions\nIf arguments are supplied, the semantics of the decoration process is as follows:\ndef func():\npass\n# Create the decoration function\ntemp = trace(\"You called {func.__name__}\")\n# Apply it to func\nfunc = temp(func)\nIn this case, the outermost function that accepts the arguments is responsible for creating\na decoration function. That function is then called with the function to be decorated to\nobtain the final result. Here’s what the decorator implementation might look like:\nfrom functools import wraps\ndef trace(message):\ndef decorate(func):\n@wraps(func)\ndef wrapper(*args, **kwargs):\nprint(message.format(func=func))\nreturn func(*args, **kwargs)\nreturn wrapper\nreturn decorate\nOne interesting feature of this implementation is that the outer function is actually a\nkind of a “decorator factory.” Suppose you found yourself writing code like this:\n@trace('You called {func.__name__}')\ndef func1():\npass\n@trace('You called {func.__name__}')\ndef func2():\npass\nThat would quickly get tedious. You could simplify it by calling the outer decorator\nfunction once and reusing the result like this:\nlogged = trace('You called {func.__name__}')\n@logged\ndef func1():\npass",
      "content_length": 1187,
      "extraction_method": "Direct"
    },
    {
      "page_number": 142,
      "chapter": null,
      "content": "5.19 Map, Filter, and Reduce\n127\n@logged\ndef func2():\npass\nDecorators don’t necessarily have to replace the original function. Sometimes a\ndecorator merely performs an action such as registration. For example, if you are building\na registry of event handlers, you could define a decorator that works like this:\n@eventhandler('BUTTON')\ndef handle_button(msg):\n...\n@eventhandler('RESET')\ndef handle_reset(msg):\n...\nHere’s a decorator that manages it:\n# Event handler decorator\n_event_handlers = { }\ndef eventhandler(event):\ndef register_function(func):\n_event_handlers[event] = func\nreturn func\nreturn register_function\n5.19\nMap, Filter, and Reduce\nProgrammers familiar with functional languages often inquire about common list\noperations such as map, filter, and reduce. Much of this functionality is provided by list\ncomprehensions and generator expressions. For example:\ndef square(x):\nreturn x * x\nnums = [1, 2, 3, 4, 5]\nsquares = [ square(x) for x in nums ]\n# [1, 4, 9, 16, 25]\nTechnically, you don’t even need the short one-line function. You could write:\nsquares = [ x * x for x in nums ]\nFiltering can also be performed with a list comprehension:\na = [ x for x in nums if x > 2 ]\n# [3, 4, 5]",
      "content_length": 1197,
      "extraction_method": "Direct"
    },
    {
      "page_number": 143,
      "chapter": null,
      "content": "128\nChapter 5\nFunctions\nIf you use a generator expression, you’ll get a generator that produces the results\nincrementally through iteration. For example:\nsquares = (x*x for x in nums)\n# Creates a generator\nfor n in squares:\nprint(n)\nPython provides a built-in map() function that is the same as mapping a function with a\ngenerator expression. For example, the above example could be written:\nsquares = map(lambda x: x*x, nums)\nfor n in squares:\nprint(n)\nThe built-in filter() function creates a generator that filters values:\nfor n in filter(lambda x: x > 2, nums):\nprint(n)\nIf you want to accumulate or reduce values, you can use functools.reduce(). For\nexample:\nfrom functools import reduce\ntotal = reduce(lambda x, y: x + y, nums)\nIn its general form, reduce() accepts a two-argument function, an iterable, and an\ninitial value. Here are a few examples:\nnums = [1, 2, 3, 4, 5]\ntotal = reduce(lambda x, y: x + y, nums)\n# 15\nproduct = reduce(lambda x, y: x * y, nums, 1)\n# 120\npairs = reduce(lambda x, y: (x, y), nums, None)\n# (((((None, 1), 2), 3), 4), 5)\nreduce() accumulates values left-to-right on the supplied iterable. This is known as a\nleft-fold operation. Here is pseudocode for reduce(func, items, initial):\ndef reduce(func, items, initial):\nresult = initial\nfor item in items:\nresult = func(result, item)\nreturn result\nUsing reduce() in practice may be confusing. Moreover, common reduction\noperations such as sum(), min(), and max() are already built-in. Your code will be easier\nto follow (and likely run faster) if you use one of those instead of trying to implement\ncommon operations with reduce().",
      "content_length": 1614,
      "extraction_method": "Direct"
    },
    {
      "page_number": 144,
      "chapter": null,
      "content": "5.20 Function Introspection, Attributes, and Signatures\n129\n5.20\nFunction Introspection, Attributes,\nand Signatures\nAs you have seen, functions are objects—which means they can be assigned to variables,\nplaced in data structures, and used in the same way as any other kind of data in a program.\nThey can also be inspected in various ways. Table 5.1 shows some common attributes of\nfunctions. Many of these attributes are useful in debugging, logging, and other operations\ninvolving functions.\nTable 5.1\nFunction Attributes\nAttribute\nDescription\nf.__name__\nFunction name\nf.__qualname__\nFully qualified name (if nested)\nf.__module__\nName of module in which defined\nf.__doc__\nDocumentation string\nf.__annotations__\nType hints\nf.__globals__\nDictionary that is the global namespace\nf.__closure__\nClosure variables (if any)\nf.__code__\nUnderlying code object\nThe f.__name__ attribute contains the name that was used when defining a function.\nf.__qualname__ is a longer name that includes additional information about the\nsurrounding definition environment.\nThe f.__module__ attribute is a string that holds the module name in which the\nfunction was defined. The f.__globals__ attribute is a dictionary that serves as the global\nnamespace for the function. It is normally the same dictionary that’s attached to the\nassociated module object.\nf.__doc__ holds the function documentation string. The f.__annotations__ attribute\nis a dictionary that holds type hints, if any.\nf.__closure__ holds references to the values of closure variables for nested functions.\nThese are a bit buried, but the following example shows how to view them:\ndef add(x, y):\ndef do_add():\nreturn x + y\nreturn do_add\n>>> a = add(2, 3)\n>>> a.__closure__\n(<cell at 0x10edf1e20: int object at 0x10ecc1950>,\n<cell at 0x10edf1d90: int object at 0x10ecc1970>)\n>>> a.__closure__[0].cell_contents",
      "content_length": 1852,
      "extraction_method": "Direct"
    },
    {
      "page_number": 145,
      "chapter": null,
      "content": "130\nChapter 5\nFunctions\n2\n>>>\nThe f.__code__ object represents the compiled interpreter bytecode for the\nfunction body.\nFunctions can have arbitrary attributes attached to them. Here’s an example:\ndef func():\nstatements\nfunc.secure = 1\nfunc.private = 1\nAttributes are not visible within the function body—they are not local variables and do\nnot appear as names in the execution environment. The main use of function attributes is\nto store extra metadata. Sometimes frameworks or various metaprogramming techniques\nutilize function tagging—that is, attaching attributes to functions. One example is the\n@abstractmethod decorator that’s used on methods within abstract base classes. All that\ndecorator does is attach an attribute:\ndef abstractmethod(func):\nfunc.__isabstractmethod__ = True\nreturn func\nSome other bit of code (in this case, a metaclass) looks for this attribute and uses it to\nadd extra checks to instance creation.\nIf you want to know more about a function’s parameters, you can obtain its signature\nusing the inspect.signature() function:\nimport inspect\ndef func(x: int, y:float, debug=False) -> float:\npass\nsig = inspect.signature(func)\nSignature objects provide many convenient features for printing and obtaining detailed\ninformation about the parameters. For example:\n# Print out the signature in a nice form\nprint(sig)\n# Produces (x: int, y: float, debug=False) -> float\n# Get a list of argument names\nprint(list(sig.parameters))\n# Produces [ 'x', 'y', 'debug']\n# Iterate over the parameters and print various metadata\nfor p in sig.parameters.values():\nprint('name', p.name)",
      "content_length": 1595,
      "extraction_method": "Direct"
    },
    {
      "page_number": 146,
      "chapter": null,
      "content": "5.21 Environment Inspection\n131\nprint('annotation', p.annotation)\nprint('kind', p.kind)\nprint('default', p.default)\nA signature is metadata that describes the nature of a function—how you would call it,\ntype hints, and so on. There are various things that you might do with a signature. One\nuseful operation on signatures is comparison. For example, here’s how you check to see if\ntwo functions have the same signature:\ndef func1(x, y):\npass\ndef func2(x, y):\npass\nassert inspect.signature(func1) == inspect.signature(func2)\nThis kind of comparison might be useful in frameworks. For example, a framework\ncould use signature comparison to see if you’re writing functions or methods that conform\nto an expected prototype.\nIf stored in the __signature__ attribute of a function, a signature will be shown in help\nmessages and returned on further uses of inspect.signature(). For example:\ndef func(x, y, z=None):\n...\nfunc.__signature__ = inspect.signature(lambda x,y: None)\nIn this example, the optional argument z would be hidden in further inspection of\nfunc. Instead, the attached signature would be returned by inspect.signature().\n5.21\nEnvironment Inspection\nFunctions can inspect their execution environment using the built-in functions globals()\nand locals(). globals() returns the dictionary that’s serving as the global namespace.\nThis is the same as the func.__globals__ attribute. This is usually the same dictionary\nthat’s holding the contents of the enclosing module. locals() returns a dictionary\ncontaining the values of all local and closure variables. This dictionary is not the actual data\nstructure used to hold these variables. Local variables can come from outer functions (via a\nclosure) or be defined internally. locals() collects all of these variables and puts them into\na dictionary for you. Changing an item in the locals() dictionary has no effect on the\nunderlying variable. For example:\ndef func():\ny = 20\nlocs = locals()",
      "content_length": 1947,
      "extraction_method": "Direct"
    },
    {
      "page_number": 147,
      "chapter": null,
      "content": "132\nChapter 5\nFunctions\nlocs['y'] = 30\n# Try to change y\nprint(locs['y'])\n# Prints 30\nprint(y)\n# Prints 20\nIf you wanted a change to take effect, you’d have to copy it back into the local variable\nusing normal assignment.\ndef func():\ny = 20\nlocs = locals()\nlocs['y'] = 30\ny = locs['y']\nA function can obtain its own stack frame using inspect.currentframe(). A function\ncan obtain the stack frame of its caller by following the stack trace through f.f_back\nattributes on the frame. Here is an example:\nimport inspect\ndef spam(x, y):\nz = x + y\ngrok(z)\ndef grok(a):\nb = a * 10\n# outputs: {'a':5, 'b':50 }\nprint(inspect.currentframe().f_locals)\n# outputs: {'x':2, 'y':3, 'z':5 }\nprint(inspect.currentframe().f_back.f_locals)\nspam(2, 3)\nSometimes you will see stack frames obtained using the sys._getframe() function\ninstead. For example:\nimport sys\ndef grok(a):\nb = a * 10\nprint(sys._getframe(0).f_locals)\n# myself\nprint(sys._getframe(1).f_locals)\n# my caller\nThe attributes in Table 5.2 can be useful for inspecting frames.",
      "content_length": 1020,
      "extraction_method": "Direct"
    },
    {
      "page_number": 148,
      "chapter": null,
      "content": "5.22 Dynamic Code Execution and Creation\n133\nTable 5.2\nFrame Attributes\nAttribute\nDescription\nf.f_back\nPrevious stack frame (toward the caller)\nf.f_code\nCode object being executed\nf.f_locals\nDictionary of local variables (locals())\nf.f_globals\nDictionary used for global variables (globals())\nf.f_builtins\nDictionary used for built-in names\nf.f_lineno\nLine number\nf.f_lasti\nCurrent instruction. This is an index into the bytecode string of f_code.\nf.f_trace\nFunction called at start of each source code line\nLooking at stack frames is useful for debugging and code inspection. For example,\nhere’s an interesting debug function that lets you view the values of the selected variables\nof the caller:\nimport inspect\nfrom collections import ChainMap\ndef debug(*varnames):\nf = inspect.currentframe().f_back\nvars = ChainMap(f.f_locals, f.f_globals)\nprint(f'{f.f_code.co_filename}:{f.f_lineno}')\nfor name in varnames:\nprint(f'\n{name} = {vars[name]!r}')\n# Example use\ndef func(x, y):\nz = x + y\ndebug('x','y')\n# Shows x and y along with file/line\nreturn z\n5.22\nDynamic Code Execution and\nCreation\nThe exec(str [, globals [, locals]]) function executes a string containing arbitrary\nPython code. The code supplied to exec() is executed as if the code actually appeared in\nplace of the exec operation. Here’s an example:\na = [3, 5, 10, 13]\nexec('for i in a: print(i)')",
      "content_length": 1357,
      "extraction_method": "Direct"
    },
    {
      "page_number": 149,
      "chapter": null,
      "content": "134\nChapter 5\nFunctions\nThe code given to exec() executes within the local and global namespace of the caller.\nHowever, be aware that changes to local variables have no effect. For example:\ndef func():\nx = 10\nexec(\"x = 20\")\nprint(x)\n# Prints 10\nThe reasons for this have to do with the locals being a dictionary of collected local\nvariables, not the actual local variables (see the previous section for more detail).\nOptionally, exec() can accept one or two dictionary objects that serve as the global and\nlocal namespaces for the code to be executed, respectively. Here’s an example:\nglobs = {'x': 7,\n'y': 10,\n'birds': ['Parrot', 'Swallow', 'Albatross']\n}\nlocs = { }\n# Execute using the above dictionaries as the global and local namespace\nexec('z = 3 * x + 4 * y', globs, locs)\nexec('for b in birds: print(b)', globs, locs)\nIf you omit one or both namespaces, the current values of the global and local\nnamespaces are used. If you only provide a dictionary for globals, it’s used for both the\nglobals and locals.\nA common use of dynamic code execution is for creating functions and methods. For\nexample, here’s a function that creates an __init__() method for a class given a list of\nnames:\ndef make_init(*names):\nparms = ','.join(names)\ncode = f'def __init__(self, {parms}):\\n'\nfor name in names:\ncode += f'\nself.{name} = {name}\\n'\nd = { }\nexec(code, d)\nreturn d['__init__']\n# Example use\nclass Vector:\n__init__ = make_init('x','y','z')\nThis technique is used in various parts of the standard library. For example,\nnamedtuple(), @dataclass, and similar features all rely on dynamic code creation with\nexec().",
      "content_length": 1611,
      "extraction_method": "Direct"
    },
    {
      "page_number": 150,
      "chapter": null,
      "content": "5.23 Asynchronous Functions and await\n135\n5.23\nAsynchronous Functions and await\nPython provides a number of language features related to the asynchronous execution of\ncode. These include so-called async functions (or coroutines) and awaitables. They are mostly\nused by programs involving concurrency and the asyncio module. However, other\nlibraries may also build upon these.\nAn asynchronous function, or coroutine function, is defined by prefacing a normal\nfunction definition with the extra keyword async. For example:\nasync def greeting(name):\nprint(f'Hello {name}')\nIf you call such a function, you’ll find that it doesn’t execute in the usual way—in fact,\nit doesn’t execute at all. Instead, you get an instance of a coroutine object in return. For\nexample:\n>>> greeting('Guido')\n<coroutine object greeting at 0x104176dc8>\n>>>\nTo make the function run, it must execute under the supervision of other code. A\ncommon option is asyncio. For example:\n>>> import asyncio\n>>> asyncio.run(greeting('Guido'))\nHello Guido\n>>>\nThis example brings up the most important feature of asynchronous functions—that\nthey never execute on their own. Some kind of manager or library code is always required\nfor their execution. It’s not necessarily asyncio as shown, but something is always involved\nin making async functions run.\nAside from being managed, an asynchronous function evaluates in the same manner\nas any other Python function. Statements run in order and all of the usual control-flow\nfeatures work. If you want to return a result, use the usual return statement. For example:\nasync def make_greeting(name):\nreturn f'Hello {name}'\nThe value given to return is returned by the outer run() function used to execute the\nasync function. For example:\n>>> import asyncio\n>>> a = asyncio.run(make_greeting('Paula'))\n>>> a\n'Hello Paula'\n>>>\nAsync functions can call other async functions using an await expression like this:",
      "content_length": 1915,
      "extraction_method": "Direct"
    },
    {
      "page_number": 151,
      "chapter": null,
      "content": "136\nChapter 5\nFunctions\nasync def make_greeting(name):\nreturn f'Hello {name}'\nasync def main():\nfor name in ['Paula', 'Thomas', 'Lewis']:\na = await make_greeting(name)\nprint(a)\n# Run it.\nWill see greetings for Paula, Thomas, and Lewis\nasyncio.run(main())\nUse of await is only valid within an enclosing async function definition. It’s also a\nrequired part of making async functions execute. If you leave off the await, you’ll find that\nthe code breaks.\nThe requirement of using await hints at a general usage issue with asynchronous\nfunctions. Namely, their different evaluation model prevents them from being used in\ncombination with other parts of Python. Specifically, it is never possible to write code that\ncalls an async function from a non-async function:\nasync def twice(x):\nreturn 2 * x\ndef main():\nprint(twice(2))\n# Error. Doesn't execute the function.\nprint(await twice(2))\n# Error. Can't use await here.\nCombining async and non-async functionality in the same application is a complex\ntopic, especially if you consider some of the programming techniques involving\nhigher-order functions, callbacks, and decorators. In most cases, support for asynchronous\nfunctions has to be built as a special case.\nPython does precisely this for the iterator and context manager protocols. For example,\nan asynchronous context manager can be defined using __aenter__() and __aexit__()\nmethods on a class like this:\nclass AsyncManager(object):\ndef __init__(self, x):\nself.x = x\nasync def yow(self):\npass\nasync def __aenter__(self):\nreturn self\nasync def __aexit__(self, ty, val, tb):\npass",
      "content_length": 1583,
      "extraction_method": "Direct"
    },
    {
      "page_number": 152,
      "chapter": null,
      "content": "5.24 Final Words: Thoughts on Functions and Composition\n137\nNote that these methods are async functions and can thus execute other async functions\nusing await. To use such a manager, you must use the special async with syntax that is\nonly legal within an async function:\n# Example use\nasync def main():\nasync with AsyncManager(42) as m:\nawait m.yow()\nasyncio.run(main())\nA class can similarly define an async iterator by defining methods __aiter__() and\n__anext__(). These are used by the async for statement which also may only appear\ninside an async function.\nFrom a practical point of view, an async function behaves exactly the same as a normal\nfunction—it’s just that it has to execute within a managed environment such as asyncio.\nUnless you’ve made a conscious decision to work in such an environment, you should\nmove along and ignore async functions. You’ll be a lot happier.\n5.24\nFinal Words: Thoughts on Functions\nand Composition\nAny system is built as a composition of components. In Python, these components include\nvarious sorts of libraries and objects. However, underlying everything are functions.\nFunctions are the glue by which a system is put together and the basic mechanism of\nmoving data around.\nMuch of the discussion in this chapter focused on the nature of functions and their\ninterfaces. How are the inputs presented to a function? How are the outputs handled?\nHow are errors reported? How can all of these things be more tightly controlled and better\nunderstood?\nThe interaction of functions as a potential source of complexity is worth thinking about\nwhen working on larger projects. It can often mean the difference between an intuitive\neasy-to-use API and a mess.",
      "content_length": 1693,
      "extraction_method": "Direct"
    },
    {
      "page_number": 153,
      "chapter": null,
      "content": "This page intentionally left blank",
      "content_length": 34,
      "extraction_method": "OCR"
    },
    {
      "page_number": 154,
      "chapter": null,
      "content": "6\nGenerators\nGenerator functions are one of Python’s most interesting and powerful features. Generators\nare often presented as a convenient way to define new kinds of iteration patterns.\nHowever, there is much more to them: Generators can also fundamentally change the\nwhole execution model of functions. This chapter discusses generators, generator\ndelegation, generator-based coroutines, and common applications of generators.\n6.1\nGenerators and yield\nIf a function uses the yield keyword, it defines an object known as a generator. The\nprimary use of a generator is to produce values for use in iteration. Here’s an example:\ndef countdown(n):\nprint('Counting down from', n)\nwhile n > 0:\nyield n\nn -= 1\n# Example use\nfor x in countdown(10):\nprint('T-minus', x)\nIf you call this function, you will find that none of its code starts executing. For\nexample:\n>>> c = countdown(10)\n>>> c\n<generator object countdown at 0x105f73740>\n>>>\nInstead, a generator object is created. The generator object, in turn, only executes the\nfunction when you start iterating on it. One way to do that is to call next() on it:\n>>> next(c)\nCounting down from 10",
      "content_length": 1140,
      "extraction_method": "Direct"
    },
    {
      "page_number": 155,
      "chapter": null,
      "content": "140\nChapter 6\nGenerators\n10\n>>> next(c)\n9\nWhen next() is called, the generator function executes statements until it reaches a\nyield statement. The yield statement returns a result, at which point execution of the\nfunction is suspended until next() is invoked again. While it’s suspended, the function\nretains all of its local variables and execution environment. When resumed, execution\ncontinues with the statement following the yield.\nnext() is a shorthand for invoking the __next__() method on a generator. For\nexample, you could also do this:\n>>> c.__next__()\n8\n>>> c.__next__()\n7\n>>>\nYou normally don’t call next() on a generator directly, but use the for statement or\nsome other operation that consumes the items. For example:\nfor n in countdown(10):\nstatements\na = sum(countdown(10))\nA generator function produces items until it returns—by reaching the end of the\nfunction or by using a return statement. This raises a StopIteration exception that\nterminates a for loop. If a generator function returns a non-None value, it is attached to\nthe StopIteration exception. For example, this generator function uses both yield and\nreturn:\ndef func():\nyield 37\nreturn 42\nHere’s how the code would execute:\n>>> f = func()\n>>> f\n<generator object func at 0x10b7cd480>\n>>> next(f)\n37\n>>> next(f)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nStopIteration: 42\n>>>",
      "content_length": 1386,
      "extraction_method": "Direct"
    },
    {
      "page_number": 156,
      "chapter": null,
      "content": "6.1 Generators and yield\n141\nObserve that the return value is attached to StopIteration. To collect this value, you\nneed to explicitly catch StopIteration and extract the value:\ntry:\nnext(f)\nexcept StopIteration as e:\nvalue = e.value\nNormally, generator functions don’t return a value. Generators are almost always\nconsumed by a for loop where there is no way to obtain the exception value. This means\nthe only practical way to get the value is to drive the generator manually with explicit\nnext() calls. Most code involving generators just doesn’t do that.\nA subtle issue with generators is where a generator function is only partially consumed.\nFor example, consider this code that abandons a loop early:\nfor n in countdown(10):\nif n == 2:\nbreak\nstatements\nIn this example, the for loop aborts by calling break and the associated generator never\nruns to full completion. If it’s important for your generator function to perform some kind\nof cleanup action, make sure you use try-finally or a context manager. For example:\ndef countdown(n):\nprint('Counting down from', n)\ntry:\nwhile n > 0:\nyield n\nn = n - 1\nfinally:\nprint('Only made it to', n)\nGenerators are guaranteed to execute the finally block code even if the generator is\nnot fully consumed—it will execute when the abandoned generator is garbage-collected.\nSimilarly, any cleanup code involving a context manager is also guaranteed to execute\nwhen a generator terminates:\ndef func(filename):\nwith open(filename) as file:\n...\nyield data\n...\n# file closed here even if generator is abandoned\nProper cleanup of resources is a tricky problem. As long as you use constructs such as\ntry-finally or context managers, generators are guaranteed to do the right thing even if\nthey are terminated early.",
      "content_length": 1752,
      "extraction_method": "Direct"
    },
    {
      "page_number": 157,
      "chapter": null,
      "content": "142\nChapter 6\nGenerators\n6.2\nRestartable Generators\nNormally a generator function executes only once. For example:\n>>> c = countdown(3)\n>>> for n in c:\n...\nprint('T-minus', n)\n...\nT-minus 3\nT-minus 2\nT-minus 1\n>>> for n in c:\n...\nprint('T-minus', n)\n...\n>>>\nIf you want an object that allows repeated iteration, define it as a class and make the\n__iter__() method a generator:\nclass countdown:\ndef __init__(self, start):\nself.start = start\ndef __iter__(self):\nn = self.start\nwhile n > 0:\nyield n\nn -= 1\nThis works because each time you iterate, a fresh generator is created by __iter__().\n6.3\nGenerator Delegation\nAn essential feature of generators is that a function involving yield never executes by\nitself—it always has to be driven by some other code using a for loop or explicit next()\ncalls. This makes it somewhat difficult to write library functions involving yield because\ncalling a generator function is not enough to make it execute. To address this, the yield\nfrom statement can be used. For example:\ndef countup(stop):\nn = 1\nwhile n <= stop:\nyield n\nn += 1",
      "content_length": 1069,
      "extraction_method": "Direct"
    },
    {
      "page_number": 158,
      "chapter": null,
      "content": "6.3 Generator Delegation\n143\ndef countdown(start):\nn = start\nwhile n > 0:\nyield n\nn -= 1\ndef up_and_down(n):\nyield from countup(n)\nyield from countdown(n)\nyield from effectively delegates the iteration process to an outer iteration. For\nexample, you would write code like this to drive the iteration:\n>>> for x in up_and_down(5):\n...\nprint(x, end=' ')\n1 2 3 4 5 5 4 3 2 1\n>>>\nyield from mainly saves you from having to drive iteration yourself. Without this\nfeature, you would have to write up_and_down(n) as follows:\ndef up_and_down(n):\nfor x in countup(n):\nyield x\nfor x in countdown(n):\nyield x\nyield from is especially useful when writing code that must recursively iterate through\nnested iterables. For example, this code flattens nested lists:\ndef flatten(items):\nfor i in items:\nif isinstance(i, list):\nyield from flatten(i)\nelse:\nyield i\nHere is an example of how this works:\n>>> a = [1, 2, [3, [4, 5], 6, 7], 8]\n>>> for x in flatten(a):\n...\nprint(x, end=' ')\n...\n1 2 3 4 5 6 7 8\n>>>",
      "content_length": 991,
      "extraction_method": "Direct"
    },
    {
      "page_number": 159,
      "chapter": null,
      "content": "144\nChapter 6\nGenerators\nOne limitation of this implementation is that it is still subject to Python’s recursion\nlimit, so it would not be able to handle deeply nested structures. This will be addressed in\nthe next section.\n6.4\nUsing Generators in Practice\nAt first glance, it might not be obvious how to use generators for practical problems\nbeyond defining simple iterators. However, generators are particularly effective at\nstructuring various data handling problems related to pipelines and workflows.\nOne useful application of generators is as a tool for restructuring code that consists of\ndeeply nested for loops and conditionals. Consider this script that searches a directory\nof Python files for all comments containing the word “spam”:\nimport pathlib\nimport re\nfor path in pathlib.Path('.').rglob('*.py'):\nif path.exists():\nwith path.open('rt', encoding='latin-1') as file:\nfor line in file:\nm = re.match('.*(#.*)$', line)\nif m:\ncomment = m.group(1)\nif 'spam' in comment:\nprint(comment)\nNotice the number of levels of nested control flow. Your eyes are already starting to\nhurt as you look at the code. Now, consider this version using generators:\nimport pathlib\nimport re\ndef get_paths(topdir, pattern):\nfor path in pathlib.Path(topdir).rglob(pattern)\nif path.exists():\nyield path\ndef get_files(paths):\nfor path in paths:\nwith path.open('rt', encoding='latin-1') as file:\nyield file\ndef get_lines(files):\nfor file in files:\nyield from file",
      "content_length": 1450,
      "extraction_method": "Direct"
    },
    {
      "page_number": 160,
      "chapter": null,
      "content": "6.4 Using Generators in Practice\n145\ndef get_comments(lines):\nfor line in lines:\nm = re.match('.*(#.*)$', line)\nif m:\nyield m.group(1)\ndef print_matching(lines, substring):\nfor line in lines:\nif substring in lines:\nprint(substring)\npaths = get_paths('.', '*.py')\nfiles = get_files(paths)\nlines = get_lines(files)\ncomments = get_comments(lines)\nprint_matching(comments, 'spam')\nIn this section, the problem is broken down into smaller self-contained components.\nEach component only concerns itself with a specific task. For example, the get_paths()\ngenerator is only concerned with path names, the get_files() generator is only\nconcerned with opening files, and so forth. It is only at the end that these generators are\nhooked together into a workflow to solve a problem.\nMaking each component small and isolated is a good abstraction technique. For\nexample, consider the get_comments() generator. As input, it takes any iterable producing\nlines of text. This text could come from almost anywhere—a file, a list, a generator, and so\non. As a result, this functionality is much more powerful and adaptable than it was when it\nwas embedded into a deeply nested for loop involving files. Generators thus encourage\ncode reuse by breaking problems into small well-defined computational tasks. Smaller tasks\nare also easier to reason about, debug, and test.\nGenerators are also useful for altering the normal evaluation rules of function\napplication. Normally, when you apply a function, it executes immediately, producing\na result. Generators don’t do that. When a generator function is applied, its execution\nis delayed until some other bit of code invokes next() on it (either explicitly or by a\nfor loop).\nAs an example, consider again the generator function for flattening nested lists:\ndef flatten(items):\nfor i in items:\nif isinstance(i, list):\nyield from flatten(i)\nelse:\nyield i\nOne problem with this implementation is that, due to Python’s recursion limit, it won’t\nwork with deeply nested structures. This can be fixed by driving iteration in a different\nway using a stack. Consider this version:",
      "content_length": 2100,
      "extraction_method": "Direct"
    },
    {
      "page_number": 161,
      "chapter": null,
      "content": "146\nChapter 6\nGenerators\ndef flatten(items):\nstack = [ iter(items) ]\nwhile stack:\ntry:\nitem = next(stack[-1])\nif isinstance(item, list):\nstack.append(iter(item))\nelse:\nyield item\nexcept StopIteration:\nstack.pop()\nThis implementation builds an internal stack of iterators. It is not subject to Python’s\nrecursion limit because it’s putting data on an internal list as opposed to building frames on\nthe internal interpreter stack. Thus, if you find yourself in need of flattening a few million\nlayers of some uncommonly deep data structure, you’ll find that this version works fine.\nDo these examples mean that you should rewrite all of your code using wild generator\npatterns? No. The main point is that the delayed evaluation of generators allows you to\nalter the spacetime dimensions of normal function evaluation. There are various real-world\nscenarios where these techniques can be useful and applied in unexpected ways.\n6.5\nEnhanced Generators and yield\nExpressions\nInside a generator function, the yield statement can also be used as an expression that\nappears on the right-hand side of an assignment operator. For example:\ndef receiver():\nprint('Ready to receive')\nwhile True:\nn = yield\nprint('Got', n)\nA function that uses yield in this manner is sometimes known as an “enhanced\ngenerator” or “generator-based coroutine.” Sadly, this terminology is a bit imprecise and\nmade even more confusing since “coroutines” are more recently associated with async\nfunctions. To avoid this confusion, we’ll use the term “enhanced generator” to make it\nclear that we’re still talking about standard functions that use yield.\nA function that uses yield as an expression is still a generator, but its usage is different.\nInstead of producing values, it executes in response to values sent to it. For example:\n>>> r = receiver()\n>>> r.send(None)\n# Advances to the first yield\nReady to receive",
      "content_length": 1883,
      "extraction_method": "Direct"
    },
    {
      "page_number": 162,
      "chapter": null,
      "content": "6.5 Enhanced Generators and yield Expressions\n147\n>>> r.send(1)\nGot 1\n>>> r.send(2)\nGot 2\n>>> r.send('Hello')\nGot Hello\n>>>\nIn this example, the initial call to r.send(None) is necessary so that the generator\nexecutes statements leading to the first yield expression. At this point, the generator\nsuspends, waiting for a value to be sent to it using the send() method of the associated\ngenerator object r. The value passed to send() is returned by the yield expression in the\ngenerator. Upon receiving a value, a generator executes statements until the next yield is\nencountered.\nAs written, the function runs indefinitely. The close() method can be used to shut\ndown the generator as follows:\n>>> r.close()\n>>> r.send(4)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nStopIteration\n>>>\nThe close() operation raises a GeneratorExit exception inside the generator at the\ncurrent yield. Normally, this causes the generator to terminate silently; if you’re so\ninclined, you can catch it to perform cleanup actions. Once closed, a StopIteration\nexception will be raised if further values are sent to a generator.\nExceptions can be raised inside a generator using the throw(ty [,val [,tb]]) method\nwhere ty is the exception type, val is the exception argument (or tuple of arguments), and\ntb is an optional traceback. For example:\n>>> r = receiver()\nReady to receive\n>>> r.throw(RuntimeError, \"Dead\")\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"receiver.py\", line 14, in receiver\nn = yield\nRuntimeError: Dead\n>>>\nExceptions raised in either manner will propagate from the currently executing yield\nstatement in the generator. A generator can elect to catch the exception and handle it as is\nappropriate. If a generator doesn’t handle the exception, it propagates out of the generator\nto be handled at a higher level.",
      "content_length": 1868,
      "extraction_method": "Direct"
    },
    {
      "page_number": 163,
      "chapter": null,
      "content": "148\nChapter 6\nGenerators\n6.6\nApplications of Enhanced Generators\nEnhanced generators are an odd programming construct. Unlike a simple generator which\nnaturally feeds a for loop, there is no core language feature that drives an enhanced\ngenerator. Why, then, would you ever want a function that needs values to be sent to it? Is\nit purely academic?\nHistorically, enhanced generators have been used in the context of concurrency\nlibraries—especially those based on asynchronous I/O. In that context, they’re usually\nreferred to as “coroutines” or “generator-based coroutines.” However, much of that\nfunctionality has been folded into the async and await features of Python. There is little\npractical reason to use yield for that specific use case. That said, there are still some\npractical applications.\nLike generators, an enhanced generator can be used to implement different kinds of\nevaluation and control flow. One example is the @contextmanager decorator found in the\ncontextlib module. For example:\nfrom contextlib import contextmanager\n@contextmanager\ndef manager():\nprint(\"Entering\")\ntry:\nyield 'somevalue'\nexcept Exception as e:\nprint(\"An error occurred\", e)\nfinally:\nprint(\"Leaving\")\nHere, a generator is being used to glue together the two halves of a context manager.\nRecall that context managers are defined by objects implementing the following protocol:\nclass Manager:\ndef __enter__(self):\nreturn somevalue\ndef __exit__(self, ty, val, tb):\nif ty:\n# An exception occurred.\n...\n# Return True if handled, False otherwise\nWith the @contextmanager generator, everything prior to the yield statement executes\nwhen the manager enters (via the __enter__() method). Everything after the yield\nexecutes when the manager exits (via the __exit__() method). If an error took place, it is\nreported as an exception on the yield statement. Here is an example:",
      "content_length": 1858,
      "extraction_method": "Direct"
    },
    {
      "page_number": 164,
      "chapter": null,
      "content": "6.6 Applications of Enhanced Generators\n149\n>>> with manager() as val:\n...\nprint(val)\n...\nEntering\nsomevalue\nLeaving\n>>> with manager() as val:\n...\nprint(int(val))\n...\nEntering\nAn error occurred invalid literal for int() with base 10: 'somevalue'\nLeaving\n>>>\nTo implement this, a wrapper class is used. This is a simplified implementation that\nillustrates the basic idea:\nclass Manager:\ndef __init__(self, gen):\nself.gen = gen\ndef __enter__(self):\n# Run to the yield\nreturn self.gen.send(None)\ndef __exit__(self, ty, val, tb):\n# Propagate an exception (if any)\ntry:\nif ty:\ntry:\nself.gen.throw(ty, val, tb)\nexcept ty:\nreturn False\nelse:\nself.gen.send(None)\nexcept StopIteration:\nreturn True\nAnother application of extended generators is using functions to encapsulate a\n“worker” task. One of the central features of a function call is that it sets up an\nenvironment of local variables. Access to those variables is highly optimized—it’s much\nfaster than accessing attributes of classes and instances. Since generators stay alive until\nexplicitly closed or destroyed, one might use a generator to set up a long-lived task. Here is\nan example of a generator that receives byte fragments and assembles them into lines:",
      "content_length": 1214,
      "extraction_method": "Direct"
    },
    {
      "page_number": 165,
      "chapter": null,
      "content": "150\nChapter 6\nGenerators\ndef line_receiver():\ndata = bytearray()\nline = None\nlinecount = 0\nwhile True:\npart = yield line\nlinecount += part.count(b'\\n')\ndata.extend(part)\nif linecount > 0:\nindex = data.index(b'\\n')\nline = bytes(data[:index+1])\ndata = data[index+1:]\nlinecount -= 1\nelse:\nline = None\nIn this example, a generator receives byte fragments that are collected into a byte array.\nIf the array contains a newline, a line is extracted and returned. Otherwise, None is\nreturned. Here’s an example illustrating how it works:\n>>> r = line_receiver()\n>>> r.send(None)\n# Prime the generator\n>>> r.send(b'hello')\n>>> r.send(b'world\\nit ')\nb'hello world\\n'\n>>> r.send(b'works!')\n>>> r.send(b'\\n')\nb'it works!\\n''\n>>>\nSimilar code could be written as a class such as this:\nclass LineReceiver:\ndef __init__(self):\nself.data = bytearray()\nself.linecount = 0\ndef send(self, part):\nself.linecount += part.count(b'\\n')\nself.data.extend(part)\nif self.linecount > 0:\nindex = self.data.index(b'\\n')\nline = bytes(self.data[:index+1])\nself.data = self.data[index+1:]\nself.linecount -= 1\nreturn line",
      "content_length": 1087,
      "extraction_method": "Direct"
    },
    {
      "page_number": 166,
      "chapter": null,
      "content": "6.7 Generators and the Bridge to Awaiting\n151\nelse:\nreturn None\nAlthough writing a class might be more familiar, the code is more complex and runs\nslower. Tested on the author’s machine, feeding a large collection of chunks into a receiver\nis about 40–50% faster with a generator than with this class code. Most of those savings are\ndue to the elimination of instance attribute lookup—local variables are faster.\nAlthough there are many other potential applications, the important thing to keep in\nmind is that if you see yield being used in a context that is not involving iteration, it is\nprobably using the enhanced features such as send() or throw().\n6.7\nGenerators and the Bridge to Awaiting\nA classic use of generator functions is in libraries related to asynchronous I/O such as in\nthe standard asyncio module. However, since Python 3.5 much of this functionality has\nbeen moved into a different language feature related to async functions and the await\nstatement (see the last part of Chapter 5).\nThe await statement involves interacting with a generator in disguise. Here is an\nexample that illustrates the underlying protocol used by await:\nclass Awaitable:\ndef __await__(self):\nprint('About to await')\nyield\n# Must be a generator\nprint('Resuming')\n# Function compatible with \"await\". Returns an \"awaitable\".\ndef function():\nreturn Awaitable()\nasync def main():\nawait function()\nHere is how you might try the code using asyncio:\n>>> import asyncio\n>>> asyncio.run(main())\nAbout to await\nResuming\n>>>\nIs it absolutely essential to know how this works? Probably not. All of this machinery is\nnormally hidden from view. However, if you ever find yourself using async functions, just\nknow that there is a generator function buried somewhere inside. You’ll eventually find it\nif you just keep on digging the hole of technical debt deep enough.",
      "content_length": 1848,
      "extraction_method": "Direct"
    },
    {
      "page_number": 167,
      "chapter": null,
      "content": "152\nChapter 6\nGenerators\n6.8\nFinal Words: A Brief History of\nGenerators and Looking Forward\nGenerators are one of Python’s more interesting success stories. They are also part of a\ngreater story concerning iteration. Iteration is one of the most common programming\ntasks of all. In early versions of Python, iteration was implemented via sequence indexing\nand the __getitem__() method. This later evolved into the current iteration protocol\nbased on __iter__() and __next__() methods. Generators appeared shortly thereafter as\na more convenient way to implement an iterator. In modern Python, there is almost no\nreason to ever implement an iterator using anything other than a generator. Even on\niterable objects that you might define yourself, the __iter__() method itself is\nconveniently implemented in this way.\nIn later versions of Python, generators took on a new role as they evolved enhanced\nfeatures related to coroutines—the send() and throw() methods. These were no longer\nlimited to iteration but opened up possibilities for using generators in other contexts. Most\nnotably, this formed the basis of many so-called “async” frameworks used for network\nprogramming and concurrency. However, as asynchronous programming has evolved, most\nof this has transformed into later features that use the async/await syntax. Thus, it’s not so\ncommon to see generator functions used outside of the context of iteration—their\noriginal purpose. In fact, if you find yourself defining a generator function and you’re not\nperforming iteration, you should probably reconsider your approach. There may be a\nbetter or more modern way to accomplish what you’re doing.",
      "content_length": 1656,
      "extraction_method": "Direct"
    },
    {
      "page_number": 168,
      "chapter": null,
      "content": "7\nClasses and Object-Oriented\nProgramming\nClasses are used to create new kinds of objects. This chapter covers the details of\nclasses—but is not intended to be an in-depth reference on object-oriented programming\nand design. Some programming patterns common in Python are discussed, as well as ways\nthat you can customize classes to behave in interesting ways. The overall structure of this\nchapter is top-down. High-level concepts and techniques for using classes are described\nfirst. In later parts of the chapter, the material gets more technical and focused on internal\nimplementation.\n7.1\nObjects\nAlmost all code in Python involves creating and performing actions on objects. For\nexample, you might make a string object and manipulate it as follows:\n>>> s = \"Hello World\"\n>>> s.upper()\n'HELLO WORLD'\n>>> s.replace('Hello', 'Hello Cruel')\n'Hello Cruel World'\n>>> s.split()\n['Hello', 'World']\n>>>\nor a list object:\n>>> names = ['Paula', 'Thomas']\n>>> names.append('Lewis')\n>>> names\n['Paula', 'Thomas', 'Lewis']\n>>> names[1] = 'Tom'\n>>>",
      "content_length": 1039,
      "extraction_method": "Direct"
    },
    {
      "page_number": 169,
      "chapter": null,
      "content": "154\nChapter 7\nClasses and Object-Oriented Programming\nAn essential feature of each object is that it usually has some kind of state—the\ncharacters of a string, the elements of a list, and so on, as well as methods that operate on\nthat state. The methods are invoked through the object itself—as if they are functions\nattached to the object via the dot (.) operator.\nObjects always have an associated type. You can view it using type():\n>>> type(names)\n<class 'list'>\n>>>\nAn object is said to be an instance of its type. For example, names is an instance of list.\n7.2\nThe class Statement\nNew objects are defined using the class statement. A class typically consists of a collection\nof functions that make up the methods. Here’s an example:\nclass Account:\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\ndef __repr__(self):\nreturn f'Account({self.owner!r}, {self.balance!r})'\ndef deposit(self, amount):\nself.balance += amount\ndef withdraw(self, amount):\nself.balance -= amount\ndef inquiry(self):\nreturn self.balance\nIt’s important to note that a class statement by itself doesn’t create any instances of the\nclass. For example, no accounts are actually created in the preceding example. Rather, a\nclass merely holds the methods that will be available on the instances created later. You\nmight think of it as a blueprint.\nThe functions defined inside a class are known as methods. An instance method is a\nfunction that operates on an instance of the class, which is passed as the first argument.\nBy convention, this argument is called self. In the preceding example, deposit(),\nwithdraw(), and inquiry() are examples of instance methods.\nThe __init__() and __repr__() methods of the class are examples of so-called special\nor magic methods. These methods have special meaning to the interpreter runtime.\nThe __init__() method is used to initialize state when a new instance is created. The",
      "content_length": 1916,
      "extraction_method": "Direct"
    },
    {
      "page_number": 170,
      "chapter": null,
      "content": "7.3 Instances\n155\n__repr__() method returns a string for viewing an object. Defining this method is\noptional, but doing so simplifies debugging and makes it easier to view objects from the\ninteractive prompt.\nA class definition may optionally include a documentation string and type hints. For\nexample:\nclass Account:\n'''\nA simple bank account\n'''\nowner: str\nbalance: float\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\ndef __repr__(self):\nreturn f'Account({self.owner!r}, {self.balance!r})'\ndef deposit(self, amount):\nself.balance += amount\ndef withdraw(self, amount):\nself.balance -= amount\ndef inquiry(self):\nreturn self.balance\nType hints do not change any aspect of how a class works—that is, they do not\nintroduce any extra checking or validation. It is purely metadata that might be useful for\nthird-party tools or IDEs, or used by certain advanced programming techniques. They are\nnot used in most examples that follow.\n7.3\nInstances\nInstances of a class are created by calling a class object as a function. This creates a new\ninstance that is then passed to the __init__() method. The arguments to __init__()\nconsist of the newly created instance self along with the arguments supplied in calling the\nclass object. For example:\n# Create a few accounts\na = Account('Guido', 1000.0)\n# Calls Account.__init__(a, 'Guido', 1000.0)",
      "content_length": 1366,
      "extraction_method": "Direct"
    },
    {
      "page_number": 171,
      "chapter": null,
      "content": "156\nChapter 7\nClasses and Object-Oriented Programming\nb = Account('Eva', 10.0)\n# Calls Account.__init__(b, 'Eva', 10.0)\nInside __init__(), attributes are saved on the instance by assigning to self. For\nexample, self.owner = owner is saving an attribute on the instance. Once the newly\ncreated instance has been returned, these attributes, as well as methods of the class, are\naccessed using the dot (.) operator:\na.deposit(100.0)\n# Calls Account.deposit(a, 100.0)\nb.withdraw(50.00\n# Calls Account.withdraw(b, 50.0)\nowner = a.owner\n# Get account owner\nIt’s important to emphasize that each instance has its own state. You can view instance\nvariables using the vars() function. For example:\n>>> a = Account('Guido', 1000.0)\n>>> b = Account('Eva', 10.0)\n>>> vars(a)\n{'owner': 'Guido', 'balance': 1000.0}\n>>> vars(b)\n{'owner': 'Eva', 'balance': 10.0}\n>>>\nNotice that the methods do not appear here. The methods are found on the class\ninstead. Every instance keeps a link to its class via its associated type. For example:\n>>> type(a)\n<class 'Account'>\n>>> type(b)\n<class 'Account'>\n>>> type(a).deposit\n<function Account.deposit at 0x10a032158>\n>>> type(a).inquiry\n<function Account.inquiry at 0x10a032268>\n>>>\nA later section discusses the implementation details of attribute binding and the\nrelationship between instances and classes.\n7.4\nAttribute Access\nThere are only three basic operations that can be performed on an instance: getting,\nsetting, and deleting an attribute. For example:\n>>> a = Account('Guido', 1000.0)\n>>> a.owner\n# get",
      "content_length": 1537,
      "extraction_method": "Direct"
    },
    {
      "page_number": 172,
      "chapter": null,
      "content": "7.4 Attribute Access\n157\n'Guido'\n>>> a.balance = 750.0\n# set\n>>> del a.balance\n# delete\n>>> a.balance\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nAttributeError: 'Account' object has no attribute 'balance'\n>>>\nEverything in Python is a dynamic process with very few restrictions. If you want to\nadd a new attribute to an object after it’s been created, you’re free to do that. For example:\n>>> a = Account('Guido', 1000.0)\n>>> a.creation_date = '2019-02-14'\n>>> a.nickname = 'Former BDFL'\n>>> a.creation_date\n'2019-02-14'\n>>>\nInstead of using dot (.) to perform these operations, you can supply an attribute name\nas a string to the getattr(), setattr(), and delattr() functions. The hasattr()\nfunction tests for the existence of an attribute. For example:\n>>> a = Account('Guido', 1000.0)\n>>> getattr(a, 'owner')\n'Guido'\n>>> setattr(a, 'balance', 750.0)\n>>> delattr(a, 'balance')\n>>> hasattr(a, 'balance')\nFalse\n>>> getattr(a, 'withdraw')(100)\n# Method call\n>>> a\nAccount('Guido', 650.0)\n>>>\na.attr and getattr(a, 'attr') are interchangeable, so getattr(a,\n'withdraw')(100) is the same as a.withdraw(100). It matters not that withdraw() is a\nmethod.\nThe getattr() function is notable for taking an optional default value. If you wanted\nto look up an attribute that may or may not exist, you could do this:\n>>> a = Account('Guido', 1000.0)\n>>> getattr(s, 'balance', 'unknown')\n1000.0\n>>> getattr(s, 'creation_date', 'unknown')\n'unknown'\n>>>",
      "content_length": 1466,
      "extraction_method": "Direct"
    },
    {
      "page_number": 173,
      "chapter": null,
      "content": "158\nChapter 7\nClasses and Object-Oriented Programming\nWhen you access a method as an attribute, you get an object known as a bound method.\nFor example:\n>>> a = Account('Guido', 1000.0)\n>>> w = a.withdraw\n>>> w\n<bound method Account.withdraw of Account('Guido', 1000.0)>\n>>> w(100)\n>>> a\nAccount('Guido', 900.0)\n>>>\nA bound method is an object that contains both an instance (the self) and the function\nthat implements the method. When you call a bound method by adding parentheses and\narguments, it executes the method, passing the attached instance as the first argument. For\nexample, calling w(100) above turns into a call to Account.withdraw(a, 100).\n7.5\nScoping Rules\nAlthough classes define an isolated namespace for the methods, that namespace does\nnot serve as a scope for resolving names used inside methods. Therefore, when you’re\nimplementing a class, references to attributes and methods must be fully qualified. For\nexample, in methods you always reference attributes of the instance through self. Thus,\nyou use self.balance, not balance. This also applies if you want to call a method from\nanother method. For example, suppose you want to implement withdraw() in terms of\ndepositing a negative amount:\nclass Account:\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\ndef __repr__(self):\nreturn f'Account({self.owner!r}, {self.balance!r})'\ndef deposit(self, amount):\nself.balance += amount\ndef withdraw(self, amount):\nself.deposit(-amount)\n# Must use self.deposit()\ndef inquiry(self):\nreturn self.balance",
      "content_length": 1544,
      "extraction_method": "Direct"
    },
    {
      "page_number": 174,
      "chapter": null,
      "content": "7.6 Operator Overloading and Protocols\n159\nThe lack of a class-level scope is one area where Python differs from C++ or Java. If\nyou have used those languages, the self parameter in Python is the same as the so-called\n“this” pointer, except that in Python you always have to use it explicitly.\n7.6\nOperator Overloading and Protocols\nIn Chapter 4, we discussed Python’s data model. Particular attention was given to the\nso-called special methods that implement Python operators and protocols. For example,\nthe len(obj) function calls obj.__len__() and obj[n] calls obj.__getitem__(n).\nWhen defining new classes, it is common to define some of these methods. The\n__repr__() method in the Account class was one such method for improving debugging\noutput. You might define more of these methods if you’re creating something more\ncomplicated, such as a custom container. For example, suppose you wanted to make a\nportfolio of accounts:\nclass AccountPortfolio:\ndef __init__(self):\nself.accounts = []\ndef add_account(self, account):\nself.accounts.append(account)\ndef total_funds(self):\nreturn sum(account.inquiry() for account in self)\ndef __len__(self):\nreturn len(self.accounts)\ndef __getitem__(self, index):\nreturn self.accounts[index]\ndef __iter__(self):\nreturn iter(self.accounts)\n# Example\nport = AccountPortfolio()\nport.add_account(Account('Guido', 1000.0))\nport.add_account(Account('Eva', 50.0))\nprint(port.total_funds())\n# -> 1050.0\nlen(port)\n# -> 2\n# Print the accounts",
      "content_length": 1472,
      "extraction_method": "Direct"
    },
    {
      "page_number": 175,
      "chapter": null,
      "content": "160\nChapter 7\nClasses and Object-Oriented Programming\nfor account in port:\nprint(account)\n# Access an individual account by index\nport[1].inquiry()\n# -> 50.0\nThe special methods that appear at the end, such as __len__(), __getitem__(), and\n__iter__(), make an AccountPortfolio work with Python operators such as indexing\nand iteration.\nSometimes you’ll hear the word “Pythonic,” as in “this code is Pythonic.” The term is\ninformal, but it usually refers to whether or not an object plays nicely with the rest of the\nPython environment. This implies supporting—to the extent that it makes sense—core\nPython features such as iteration, indexing, and other operations. You almost always do\nthis by having your class implement predefined special methods as described in Chapter 4.\n7.7\nInheritance\nInheritance is a mechanism for creating a new class that specializes or modifies the\nbehavior of an existing class. The original class is called a base class, superclass, or parent\nclass. The new class is called a derived class, child class, subclass, or subtype. When a class\nis created via inheritance, it inherits the attributes defined by its base classes. However, a\nderived class may redefine any of these attributes and add new attributes of its own.\nInheritance is specified with a comma-separated list of base-class names in the class\nstatement. If there is no specified base class, a class implicitly inherits from object. object\nis a class that is the root of all Python objects; it provides the default implementation of\nsome common methods such as __str__() and __repr__().\nOne use of inheritance is to extend an existing class with new methods. For example,\nsuppose you want to add a panic() method to Account that would withdraw all funds.\nHere’s how:\nclass MyAcount(Account):\ndef panic(self):\nself.withdraw(self.balance)\n# Example\na = MyAcount('Guido', 1000.0)\na.withdraw(23.0)\n# a.balance = 977.0\na.panic()\n# a.balance = 0\nInheritance can also be used to redefine the already existing methods. For example,\nhere’s a specialized version of Account that redefines the inquiry() method to periodically\noverstate the balance with the hope that someone not paying close attention will overdraw\ntheir account and incur a big penalty when making a payment on their subprime\nmortgage:",
      "content_length": 2286,
      "extraction_method": "Direct"
    },
    {
      "page_number": 176,
      "chapter": null,
      "content": "7.7 Inheritance\n161\nimport random\nclass EvilAccount(Account):\ndef inquiry(self):\nif random.randint(0,4) == 1:\nreturn self.balance * 1.10\nelse:\nreturn self.balance\na = EvilAccount('Guido', 1000.0)\na.deposit(10.0)\n# Calls Account.deposit(a, 10.0)\navailable = a.inquiry()\n# Calls EvilAccount.inquiry(a)\nIn this example, instances of EvilAccount are identical to instances of Account except\nfor the redefined inquiry() method.\nOccasionally, a derived class would reimplement a method but also need to call the\noriginal implementation. A method can explicitly call the original method using super():\nclass EvilAccount(Account):\ndef inquiry(self):\nif random.randint(0,4) == 1:\nreturn 1.10 * super().inquiry()\nelse:\nreturn super().inquiry()\nIn this example, super() allows you to access a method as it was previously defined.\nThe super().inquiry() call is using the original definition of inquiry() before it got\nredefined by EvilAccount.\nIt’s less common, but inheritance might also be used to add additional attributes to\ninstances. Here’s how you could make the 1.10 factor in the above example an\ninstance-level attribute that could be adjusted:\nclass EvilAccount(Account):\ndef __init__(self, owner, balance, factor):\nsuper().__init__(owner, balance)\nself.factor = factor\ndef inquiry(self):\nif random.randint(0,4) == 1:\nreturn self.factor * super().inquiry()\nelse:\nreturn super().inquiry()\nA tricky issue with adding attributes is dealing with the existing __init__() method.\nIn this example, we define a new version of __init__() that includes our additional\ninstance variable factor. However, when __init__() is redefined, it is the responsibility\nof the child to initialize its parent using super().__init__() as shown. If you forget to do",
      "content_length": 1739,
      "extraction_method": "Direct"
    },
    {
      "page_number": 177,
      "chapter": null,
      "content": "162\nChapter 7\nClasses and Object-Oriented Programming\nthis, you’ll end up with a half-initialized object and everything will break. Since\ninitialization of the parent requires additional arguments, those still must be passed to the\nchild __init__() method.\nInheritance can break code in subtle ways. Consider the __repr__() method of the\nAccount class:\nclass Account:\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\ndef __repr__(self):\nreturn f'Account({self.owner!r}, {self.balance!r})'\nThe purpose of this method is to assist in debugging by making nice output. However,\nthe method is hardcoded to use the name Account. If you start using inheritance, you’ll\nfind that the output is wrong:\n>>> class EvilAccount(Account):\n...\npass\n...\n>>> a = EvilAccount('Eva', 10.0)\n>>> a\nAccount('Eva', 10.0)\n# Notice misleading output\n>>> type(a)\n<class 'EvilAccount'>\n>>>\nTo fix this, you need to modify the __repr__() method to use the proper type name.\nFor example:\nclass Account:\n...\ndef __repr__(self):\nreturn f'{type(self).__name__}({self.owner!r}, {self.balance!r})'\nNow you’ll see more accurate output. Inheritance is not used with every class, but if it’s\nan anticipated use case of the class you’re writing, you need to pay attention to details like\nthis. As a general rule, avoid the hardcoding of class names.\nInheritance establishes a relationship in the type system where any child class will\ntype-check as the parent class. For example:\n>>> a = EvilAccount('Eva', 10)\n>>> type(a)\n<class 'EvilAccount'>\n>>> isinstance(a, Account)",
      "content_length": 1562,
      "extraction_method": "Direct"
    },
    {
      "page_number": 178,
      "chapter": null,
      "content": "7.8 Avoiding Inheritance via Composition\n163\nTrue\n>>>\nThis is the so-called “is a” relationship: EvilAccount is an Account. Sometimes, the “is\na” inheritance relationship is used to define object type ontologies or taxonomies. For\nexample:\nclass Food:\npass\nclass Sandwich(Food):\npass\nclass RoastBeef(Sandwich):\npass\nclass GrilledCheese(Sandwich):\npass\nclass Taco(Food):\npass\nIn practice, organizing objects in this manner can be quite difficult and fraught with\nperil. Suppose you wanted to add a HotDog class to the above hierarchy. Where does it go?\nGiven that a hot dog has a bun, you might be inclined to make it a subclass of Sandwich.\nHowever, based on the overall curved shape of the bun with a tasty filling inside, perhaps a\nhot dog is really more like a Taco. Maybe you decide to make it a subclass of both:\nclass HotDog(Sandwich, Taco):\npass\nAt this point, everyone’s head is exploding and the office is embroiled in a heated\nargument. This might as well be a good time to mention that Python supports multiple\ninheritance. To do that, list more than one class as a parent. The resulting child class will\ninherit all of the combined features of the parents. See Section 7.19 for more about\nmultiple inheritance.\n7.8\nAvoiding Inheritance via Composition\nOne concern with inheritance is what’s known as implementation inheritance. To\nillustrate, suppose you wanted to make a stack data structure with push and pop operations.\nA quick way to do that would be to inherit from a list and add a new method to it:\nclass Stack(list):\ndef push(self, item):\nself.append(item)",
      "content_length": 1576,
      "extraction_method": "Direct"
    },
    {
      "page_number": 179,
      "chapter": null,
      "content": "164\nChapter 7\nClasses and Object-Oriented Programming\n# Example\ns = Stack()\ns.push(1)\ns.push(2)\ns.push(3)\ns.pop()\n# -> 3\ns.pop()\n# -> 2\nSure enough, this data structure works like a stack, but it also has every other feature\nof lists—insertion, sorting, slice reassignment, and so forth. This is implementation\ninheritance—you used inheritance to reuse some code upon which you built something\nelse, but you also got a lot of features that aren’t pertinent to the problem actually being\nsolved. Users will probably find the object strange. Why does a stack have methods for\nsorting?\nA better approach is composition. Instead of building a stack by inheriting from a list,\nyou should build a stack as an independent class that happens to have a list contained in it.\nThe fact that there’s a list inside is an implementation detail. For example:\nclass Stack:\ndef __init__(self):\nself._items = list()\ndef push(self, item):\nself._items.append(item)\ndef pop(self):\nreturn self._items.pop()\ndef __len__(self):\nreturn len(self._items)\n# Example use\ns = Stack()\ns.push(1)\ns.push(2)\ns.push(3)\ns.pop()\n# -> 3\ns.pop()\n# -> 2\nThis object works exactly the same as before, but it’s focused exclusively on just being\na stack. There are no extraneous list methods or nonstack features. There is much more\nclarity of purpose.\nA slight extension of this implementation might accept the internal list class as an\noptional argument:",
      "content_length": 1413,
      "extraction_method": "Direct"
    },
    {
      "page_number": 180,
      "chapter": null,
      "content": "7.8 Avoiding Inheritance via Composition\n165\nclass Stack:\ndef __init__(self, *, container=None):\nif container is None:\ncontainer = list()\nself._items = container\ndef push(self, item):\nself._items.append(item)\ndef pop(self):\nreturn self._items.pop()\ndef __len__(self):\nreturn len(self._items)\nOne benefit of this approach is that it promotes loose coupling of components. For\nexample, you might want to make a stack that stores its elements in a typed array instead of\na list. Here’s how you could do it:\nimport array\ns = Stack(container=array.array('i'))\ns.push(42)\ns.push(23)\ns.push('a lot')\n# TypeError\nThis is also an example of what’s known as dependency injection. Instead of hardwiring\nStack to depend on list, you can make it depend on any container a user decides to pass\nin, provided it implements the required interface.\nMore broadly, making the internal list a hidden implementation detail is related to the\nproblem of data abstraction. Perhaps you later decide that you don’t even want to use\na list. The above design makes that easy to change. For example, if you change the\nimplementation to use linked tuples as follows, the users of Stack won’t even notice:\nclass Stack:\ndef __init__(self):\nself._items = None\nself._size = 0\ndef push(self, item):\nself._items = (item, self._items)\nself._size += 1\ndef pop(self):\n(item, self._items) = self._items\nself._size -= 1",
      "content_length": 1377,
      "extraction_method": "Direct"
    },
    {
      "page_number": 181,
      "chapter": null,
      "content": "166\nChapter 7\nClasses and Object-Oriented Programming\nreturn item\ndef __len__(self):\nreturn self._size\nTo decide whether to use inheritance or not, you should step back and ask yourself if\nthe object you’re building is a specialized version of the parent class or if you are merely\nusing it as a component in building something else. If it’s the latter, don’t use inheritance.\n7.9\nAvoiding Inheritance via Functions\nSometimes you might find yourself writing classes with just a single method that needs to\nbe customized. For example, maybe you wrote a data parsing class like this:\nclass DataParser:\ndef parse(self, lines):\nrecords = []\nfor line in lines:\nrow = line.split(',')\nrecord = self.make_record(row)\nrecords.append(row)\nreturn records\ndef make_record(self, row):\nraise NotImplementedError()\nclass PortfolioDataParser(DataParser):\ndef make_record(self, row):\nreturn {\n'name': row[0],\n'shares': int(row[1]),\n'price': float(row[2])\n}\nparser = PortfolioDataParser()\ndata = parser.parse(open('portfolio.csv'))\nThere is too much plumbing going on here. If you’re writing a lot of single-method\nclasses, consider using functions instead. For example:\ndef parse_data(lines, make_record):\nrecords = []\nfor line in lines:\nrow = line.split(',')\nrecord = make_record(row)",
      "content_length": 1268,
      "extraction_method": "Direct"
    },
    {
      "page_number": 182,
      "chapter": null,
      "content": "7.11 The Danger of Inheriting from Built-in Types\n167\nrecords.append(row)\nreturn records\ndef make_dict(row):\nreturn {\n'name': row[0],\n'shares': int(row[1]),\n'price': float(row[2])\n}\ndata = parse_data(open('portfolio.csv'), make_dict)\nThis code is much simpler and just as flexible, plus simple functions are easier to test. If\nthere’s a need to expand it into classes, you can always do it later. Premature abstraction is\noften not a good thing.\n7.10\nDynamic Binding and Duck Typing\nDynamic binding is the runtime mechanism that Python uses to find the attributes of\nobjects. This is what allows Python to work with instances without regard for their type.\nIn Python, variable names do not have an associated type. Thus, the attribute binding\nprocess is independent of what kind of object obj is. If you make a lookup, such as\nobj.name, it will work on any obj whatsoever that happens to have a name attribute. This\nbehavior is sometimes referred to as duck typing—in reference to the adage “if it looks\nlike a duck, quacks like a duck, and walks like a duck, then it’s a duck.”\nPython programmers often write programs that rely on this behavior. For example, if\nyou want to make a customized version of an existing object, you can either inherit from\nit, or you can create a completely new object that looks and acts like it but is otherwise\nunrelated. This latter approach is often used to maintain loose coupling of program\ncomponents. For example, code may be written to work with any kind of object\nwhatsoever as long as it has a certain set of methods. One of the most common examples is\nwith various iterable objects defined in the standard library. There are all sorts of objects\nthat work with the for loop to produce values—lists, files, generators, strings, and so on.\nHowever, none of these inherit from any kind of special Iterable base class. They merely\nimplement the methods required to perform iteration—and it all works.\n7.11\nThe Danger of Inheriting from\nBuilt-in Types\nPython allows inheritance from built-in types. However, doing so invites danger. As an\nexample, if you decide to subclass dict in order to force all keys to be uppercase, you\nmight redefine the __setitem__() method like this:",
      "content_length": 2214,
      "extraction_method": "Direct"
    },
    {
      "page_number": 183,
      "chapter": null,
      "content": "168\nChapter 7\nClasses and Object-Oriented Programming\nclass udict(dict):\ndef __setitem__(self, key, value):\nsuper().__setitem__(key.upper(), value)\nIndeed, it initially even seems to work:\n>>> u = udict()\n>>> u['name'] = 'Guido'\n>>> u['number'] = 37\n>>> u\n{ 'NAME': 'Guido', 'NUMBER': 37 }\n>>>\nFurther use, however, reveals that it only seems to work. In fact, it doesn’t really seem\nto work at all:\n>>> u = udict(name='Guido', number=37)\n>>> u\n{ 'name': 'Guido', 'number': 37 }\n>>> u.update(color='blue')\n>>> u\n{ 'name': 'Guido', 'number': 37, 'color': 'blue' }\n>>>\nAt issue here is the fact that Python’s built-in types aren’t implemented like normal\nPython classes—they’re implemented in C. Most of the methods operate in the world of\nC. For example, the dict.update() method directly manipulates the dictionary data\nwithout ever routing through the redefined __setitem__() method in your custom udict\nclass above.\nThe collections module has special classes UserDict, UserList, and UserString that\ncan be used to make safe subclasses of dict, list, and str types. For example, you’ll find\nthat this solution works a lot better:\nfrom collections import UserDict\nclass udict(UserDict):\ndef __setitem__(self, key, value):\nsuper().__setitem__(key.upper(), value)\nHere’s an example of this new version in action:\n>>> u = udict(name='Guido', num=37)\n>>> u.update(color='Blue')\n>>> u\n{'NAME': 'Guido', 'NUM': 37, 'COLOR': 'Blue'}\n>>> v = udict(u)\n>>> v['title'] = 'BDFL'\n>>> v",
      "content_length": 1472,
      "extraction_method": "Direct"
    },
    {
      "page_number": 184,
      "chapter": null,
      "content": "7.12 Class Variables and Methods\n169\n{'NAME': 'Guido', 'NUM': 37, 'COLOR': 'Blue', 'TITLE': 'BDFL'}\n>>>\nMost of the time, subclassing a built-in type can be avoided. For example, when\nbuilding new containers, it is probably better to make a new class, as was shown for the\nStack class in Section 7.8. If you really do need to subclass a built-in, it might be a lot\nmore work than you think.\n7.12\nClass Variables and Methods\nIn a class definition, all functions are assumed to operate on an instance, which is always\npassed as the first parameter self. However, the class itself is also an object that can carry\nstate and be manipulated as well. As an example, you could track how many instances have\nbeen created using a class variable num_accounts:\nclass Account:\nnum_accounts = 0\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\nAccount.num_accounts += 1\ndef __repr__(self):\nreturn f'{type(self).__name__}({self.owner!r}, {self.balance!r})'\ndef deposit(self, amount):\nself.balance += amount\ndef withdraw(self, amount):\nself.deposit(-amount)\n# Must use self.deposit()\ndef inquiry(self):\nreturn self.balance\nClass variables are defined outside the normal __init__() method. To modify them,\nuse the class, not self. For example:\n>>> a = Account('Guido', 1000.0)\n>>> b = Account('Eva', 10.0)\n>>> Account.num_accounts\n2\n>>>\nIt’s a bit unusual, but class variables can also be accessed via instances. For example:",
      "content_length": 1438,
      "extraction_method": "Direct"
    },
    {
      "page_number": 185,
      "chapter": null,
      "content": "170\nChapter 7\nClasses and Object-Oriented Programming\n>>> a.num_accounts\n2\n>>> c = Account('Ben', 50.0)\n>>> Account.num_accounts\n3\n>>> a.num_accounts\n3\n>>>\nThis works because attribute lookup on instances checks the associated class if there’s no\nmatching attribute on the instance itself. This is the same mechanism by which Python\nnormally finds methods.\nIt is also possible to define what’s known as a class method. A class method is a method\napplied to the class itself, not to instances. A common use of class methods is to define\nalternate instance constructors. For example, suppose there was a requirement to create\nAccount instances from a legacy enterprise-grade input format:\ndata = '''\n<account>\n<owner>Guido</owner>\n<amount>1000.0</amount>\n</account>\n'''\nTo do that, you can write a @classmethod like this:\nclass Account:\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\n@classmethod\ndef from_xml(cls, data):\nfrom xml.etree.ElementTree import XML\ndoc = XML(data)\nreturn cls(doc.findtext('owner'), float(doc.findtext('amount')))\n# Example use\ndata = '''\n<account>\n<owner>Guido</owner>\n<amount>1000.0</amount>\n</account>\n'''\na = Account.from_xml(data)",
      "content_length": 1191,
      "extraction_method": "Direct"
    },
    {
      "page_number": 186,
      "chapter": null,
      "content": "7.12 Class Variables and Methods\n171\nThe first argument of a class method is always the class itself. By convention, this\nargument is often named cls. In this example, cls is set to Account. If the purpose of a\nclass method is to create a new instance, explicit steps must be taken to do so. In the final\nline of the example, the call cls(..., ...) is the same as calling Account(..., ...) on\nthe two arguments.\nThe fact that the class is passed as argument solves an important problem related to\ninheritance. Suppose you define a subclass of Account and now want to create an instance\nof that class. You’ll find that it still works:\nclass EvilAccount(Account):\npass\ne = EvilAccount.from_xml(data)\n# Creates an 'EvilAccount'\nThe reason this code works is that EvilAccount is now passed as cls. Thus, the last\nstatement of the from_xml() classmethod now creates an EvilAccount instance.\nClass variables and class methods are sometimes used together to configure and control\nhow instances operate. As another example, consider the following Date class:\nimport time\nclass Date:\ndatefmt = '{year}-{month:02d}-{day:02d}'\ndef __init__(self, year, month, day):\nself.year = year\nself.month = month\nself.day = day\ndef __str__(self):\nreturn self.datefmt.format(year=self.year,\nmonth=self.month,\nday=self.day)\n@classmethod\ndef from_timestamp(cls, ts):\ntm = time.localtime(ts)\nreturn cls(tm.tm_year, tm.tm_mon, tm.tm_mday)\n@classmethod\ndef today(cls):\nreturn cls.from_timestamp(time.time())\nThis class features a class variable datefmt that adjusts output from the __str__()\nmethod. This is something that can be customized via inheritance:",
      "content_length": 1628,
      "extraction_method": "Direct"
    },
    {
      "page_number": 187,
      "chapter": null,
      "content": "172\nChapter 7\nClasses and Object-Oriented Programming\nclass MDYDate(Date):\ndatefmt = '{month}/{day}/{year}'\nclass DMYDate(Date):\ndatefmt = '{day}/{month}/{year}'\n# Example\na = Date(1967, 4, 9)\nprint(a)\n# 1967-04-09\nb = MDYDate(1967, 4, 9)\nprint(b)\n# 4/9/1967\nc = DMYDate(1967, 4, 9)\nprint(c)\n# 9/4/1967\nConfiguration via class variables and inheritance like this is a common tool for adjusting\nthe behavior of instances. The use of class methods is critical to making it work since they\nensure that the proper kind of object gets created. For example:\na = MDYDate.today()\nb = DMYDate.today()\nprint(a)\n# 2/13/2019\nprint(b)\n# 13/2/2019\nAlternate construction of instances is, by far, the most common use of class methods. A\ncommon naming convention for such methods is to include the word from_ as a prefix,\nsuch as from_timestamp(). You will see this naming convention used in class methods\nthroughout the standard library and in third-party packages. For example, dictionaries have\na class method for creating a preinitialized dictionary from a set of keys:\n>>> dict.from_keys(['a','b','c'], 0)\n{'a': 0, 'b': 0, 'c': 0}\n>>>\nOne caution about class methods is that Python does not manage them in a namespace\nseparate from the instance methods. As a result, they can still be invoked on an instance.\nFor example:\nd = Date(1967,4,9)\nb = d.today()\n# Calls Date.now(Date)\nThis is potentially quite confusing because a call to d.today() doesn’t really have\nanything to do with the instance d. Yet, you might see today() listed as a valid method on\nDate instances in your IDE and in documentation.",
      "content_length": 1590,
      "extraction_method": "Direct"
    },
    {
      "page_number": 188,
      "chapter": null,
      "content": "7.13 Static Methods\n173\n7.13\nStatic Methods\nSometimes a class is merely used as a namespace for functions declared as static methods\nusing @staticmethod. Unlike a normal method or class method, a static method does not\ntake an extra self or cls argument. A static method is just a ordinary function that\nhappens to be defined inside a class. For example:\nclass Ops:\n@staticmethod\ndef add(x, y):\nreturn x + y\n@staticmethod\ndef sub(x, y):\nreturn x - y\nYou don’t normally create instances of such a class. Instead, call the functions directly\nthrough the class:\na = Ops.add(2, 3)\n# a = 5\nb = Ops.sub(4, 5)\n# a = -1\nSometimes other classes will use a collection of static methods like this to implement\n“swappable” or “configurable” behavior, or as something that loosely mimics the behavior\nof an import module. Consider the use of inheritance in the earlier Account example:\nclass Account:\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\ndef __repr__(self):\nreturn f'{type(self).__name__}({self.owner!r}, {self.balance!r})'\ndef deposit(self, amount):\nself.balance += amount\ndef withdraw(self, amount):\nself.balance -= amount\ndef inquiry(self):\nreturn self.balance\n# A special \"Evil\" account\nclass EvilAccount(Account):\ndef deposit(self, amount):\nself.balance += 0.95 * amount",
      "content_length": 1303,
      "extraction_method": "Direct"
    },
    {
      "page_number": 189,
      "chapter": null,
      "content": "174\nChapter 7\nClasses and Object-Oriented Programming\ndef inquiry(self):\nif random.randint(0,4) == 1:\nreturn 1.10 * self.balance\nelse:\nreturn self.balance\nThe use of inheritance here is a little strange. It introduces two different kinds of\nobjects, Account and EvilAccount. There is also no obvious way to change an existing\nAccount instance into an EvilAccount or back, because this involves changing the instance\ntype. Perhaps it’s better to have evil manifest as a kind of an account policy instead. Here is\nan alternate formulation of Account that does that with static methods:\nclass StandardPolicy:\n@staticmethod\ndef deposit(account, amount):\naccount.balance += amount\n@staticmethod\ndef withdraw(account, amount):\naccount.balance -= amount\n@staticmethod\ndef inquiry(account):\nreturn account.balance\nclass EvilPolicy(StandardPolicy):\n@staticmethod\ndef deposit(account, amount):\naccount.balance += 0.95*amount\n@staticmethod\ndef inquiry(account):\nif random.randint(0,4) == 1:\nreturn 1.10 * account.balance\nelse:\nreturn account.balance\nclass Account:\ndef __init__(self, owner, balance, *, policy=StandardPolicy):\nself.owner = owner\nself.balance = balance\nself.policy = policy\ndef __repr__(self):\nreturn f'Account({self.policy}, {self.owner!r}, {self.balance!r})'",
      "content_length": 1265,
      "extraction_method": "Direct"
    },
    {
      "page_number": 190,
      "chapter": null,
      "content": "7.13 Static Methods\n175\ndef deposit(self, amount):\nself.policy.deposit(self, amount)\ndef withdraw(self, amount):\nself.policy.withdraw(self, amount)\ndef inquiry(self):\nreturn self.policy.inquiry(self)\nIn this reformulation, there is only one type of instance that gets created, Account.\nHowever, it has a special policy attribute that provides the implementation of various\nmethods. If needed, the policy can be dynamically changed on an existing Account\ninstance:\n>>> a = Account('Guido', 1000.0)\n>>> a.policy\n<class 'StandardPolicy'>\n>>> a.deposit(500)\n>>> a.inquiry()\n1500.0\n>>> a.policy = EvilPolicy\n>>> a.deposit(500)\n>>> a.inquiry()\n# Could randomly be 1.10x more\n1975.0\n>>>\nOne reason why @staticmethod makes sense here is that there is no need to create\ninstances of StandardPolicy or EvilPolicy. The main purpose of these classes is to\norganize a bundle of methods, not to store additional instance data that’s related to\nAccount. Still, the loosely coupled nature of Python could certainly allow a policy to be\nupgraded to hold its own data. Change the static methods to normal instance methods\nlike this:\nclass EvilPolicy(StandardPolicy):\ndef __init__(self, deposit_factor, inquiry_factor):\nself.deposit_factor = deposit_factor\nself.inquiry_factor = inquiry_factor\ndef deposit(self, account, amount):\naccount.balance += self.deposit_factor * amount\ndef inquiry(self, account):\nif random.randint(0,4) == 1:\nreturn self.inquiry_factor * account.balance\nelse:\nreturn account.balance",
      "content_length": 1489,
      "extraction_method": "Direct"
    },
    {
      "page_number": 191,
      "chapter": null,
      "content": "176\nChapter 7\nClasses and Object-Oriented Programming\n# Example use\na = Account('Guido', 1000.0, policy=EvilPolicy(0.95, 1.10))\nThis approach of delegating methods to supporting classes is a common\nimplementation strategy for state machines and similar objects. Each operational state\ncan be encapsulated into its own class of methods (often static). A mutable instance\nvariable, such as the policy attribute in this example, can then be used to hold\nimplementation-specific details related to the current operational state.\n7.14\nA Word about Design Patterns\nIn writing object-oriented programs, programmers sometimes get fixated on\nimplementing named design patterns—such as the “strategy pattern,” the “flyweight\npattern,” the “singleton pattern,” and so forth. Many of these originate from the famous\nDesign Patterns book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.\nIf you are familiar with such patterns, the general design principles used in other\nlanguages can certainly be applied to Python. However, many of these documented\npatterns are aimed at working around specific issues that arise from the strict static type\nsystem of C++ or Java. The dynamic nature of Python renders a lot of these patterns\nobsolete, an overkill, or simply unnecessary.\nThat said, there are a few overarching principles of writing good software—such as\nstriving to write code that is debuggable, testable, and extensible. Basic strategies such as\nwriting classes with useful __repr__() methods, preferring composition over inheritance,\nand allowing dependency injection can go a long way towards these goals. Python\nprogrammers also like to work with code that can be said to be “Pythonic.” Usually, that\nmeans that objects obey various built-in protocols, such as iteration, containers, or context\nmanagement. For example, instead of trying to implement some exotic data traversal\npattern from a Java programming book, a Python programmer would probably implement\nit with a generator function feeding a for loop, or just replace the entire pattern with a\nfew dictionary lookups.\n7.15\nData Encapsulation and Private\nAttributes\nIn Python, all attributes and methods of a class are public, that is, accessible without any\nrestrictions. This is often undesirable in object-oriented applications that have reasons to\nhide or encapsulate internal implementation details.\nTo address this problem, Python relies on naming conventions as a means of signaling\nintended usage. One such convention is that names starting with a single leading\nunderscore (_) indicate internal implementation. For example, here’s a version of the\nAccount class where the balance has been turned into a “private” attribute:",
      "content_length": 2699,
      "extraction_method": "Direct"
    },
    {
      "page_number": 192,
      "chapter": null,
      "content": "7.15 Data Encapsulation and Private Attributes\n177\nclass Account:\ndef __init__(self, owner, balance):\nself.owner = owner\nself._balance = balance\ndef __repr__(self):\nreturn f'Account({self.owner!r}, {self._balance!r})'\ndef deposit(self, amount):\nself._balance += amount\ndef withdraw(self, amount):\nself._balance -= amount\ndef inquiry(self):\nreturn self._balance\nIn this code, the _balance attribute is meant to be an internal detail. There’s nothing\nthat prevents a user from accessing it directly, but the leading underscore is a strong\nindicator that a user should look for a more public-facing interface—such as the\nAccount.inquiry() method.\nA grey area is whether or not internal attributes are available for use in a subclass. For\nexample, is the previous inheritance example allowed to directly access the _balance\nattribute of its parent?\nclass EvilAccount(Account):\ndef inquiry(self):\nif random.randint(0,4) == 1:\nreturn 1.10 * self._balance\nelse:\nreturn self._balance\nAs a general rule, this is considered acceptable in Python. IDEs and other tools are\nlikely to expose such attributes. If you come from C++, Java, or another similar\nobject-oriented language, consider _balance similar to a “protected” attribute.\nIf you wish to have an even more private attribute, prefix the name with two leading\nunderscores ( __ ). All names such as __name are automatically renamed into a new name of\nthe form _Classname__name. This ensures that private names used in a superclass won’t be\noverwritten by identical names in a child class. Here’s an example that illustrates this\nbehavior:\nclass A:\ndef __init__(self):\nself.__x = 3\n# Mangled to self._A__x\ndef __spam(self):\n# Mangled to _A__spam()",
      "content_length": 1692,
      "extraction_method": "Direct"
    },
    {
      "page_number": 193,
      "chapter": null,
      "content": "178\nChapter 7\nClasses and Object-Oriented Programming\nprint('A.__spam', self.__x)\ndef bar(self):\nself.__spam()\n# Only calls A.__spam()\nclass B(A):\ndef __init__(self):\nA.__init__(self)\nself.__x = 37\n# Mangled to self._B__x\ndef __spam(self):\n# Mangled to _B__spam()\nprint('B.__spam', self.__x)\ndef grok(self):\nself.__spam()\n# Calls B.__spam()\nIn this example, there are two different assignments to an __x attribute. In addition, it\nappears that class B is trying to override the __spam() method via inheritance. Yet this is\nnot the case. Name mangling causes unique names to be used for each definition. Try the\nfollowing example:\n>>> b = B()\n>>> b.bar()\nA.__spam 3\n>>> b.grok()\nB.__spam 37\n>>>\nYou can see the mangled names more directly if you look at the underlying instance\nvariables:\n>>> vars(b)\n{ '_A__x': 3, '_B__x': 37 }\n>>> b._A__spam()\nA.__spam 3\n>>> b._B__spam\nB.__spam 37\n>>>\nAlthough this scheme provides the illusion of data hiding, there’s no mechanism in\nplace to actually prevent access to the “private” attributes of a class. In particular, if the\nnames of the class and the corresponding private attribute are known, they can still be\naccessed using the mangled name. If such access to private attributes is still a concern, you\nmight consider a more painful code review process.\nAt first glance, name mangling might look like an extra processing step. However, the\nmangling process actually only occurs once when the class is defined. It does not occur\nduring execution of the methods, nor does it add extra overhead to program execution.",
      "content_length": 1557,
      "extraction_method": "Direct"
    },
    {
      "page_number": 194,
      "chapter": null,
      "content": "7.16 Type Hinting\n179\nBe aware that name mangling does not occur in functions such as getattr(),\nhasattr(), setattr(), or delattr() where the attribute name is specified as a string.\nFor these functions, you would need to explicitly use the mangled name such as\n'_Classname__name' to access the attribute.\nIn practice, it’s probably best to not overthink the privacy of names. The single-\nunderscore names are quite common; double-underscore names less so. Although you can\ntake further steps to try and truly hide attributes, the extra effort and added complexity is\nhardly worth the benefits gained. Perhaps the most useful thing is to remember that if you\nsee leading underscores on a name, it’s almost certainly some kind of internal detail best\nleft alone.\n7.16\nType Hinting\nAttributes of user-defined classes have no constraints on their type or value. In fact, you\ncan set an attribute to anything that you want. For example:\n>>> a = Account('Guido', 1000.0)\n>>> a.owner\n'Guido'\n>>> a.owner = 37\n>>> a.owner\n37\n>>> b = Account('Eva', 'a lot')\n>>> b.deposit(' more')\n>>> b.inquiry()\n'a lot more'\n>>>\nIf this is a practical concern, there are a few possible solutions. One is easy—don’t do\nthat! Another is to rely upon external tooling such as linters and type checkers. For this,\nclasses allow optional type hints to be specified for selected attributes. For example:\nclass Account:\nowner: str\n# Type hint\n_balance: float\n# Type hint\ndef __init__(self, owner, balance):\nself.owner = owner\nself._balance = balance\n...\nThe inclusion of type hints changes nothing about the actual runtime behavior of a\nclass—that is, no extra checking takes place and nothing prevents a user from setting bad\nvalues in their code. However, the hints might give users more useful information in their\neditor, thus preventing careless usage errors before they happen.",
      "content_length": 1853,
      "extraction_method": "Direct"
    },
    {
      "page_number": 195,
      "chapter": null,
      "content": "180\nChapter 7\nClasses and Object-Oriented Programming\nIn practice, accurate type hinting can be difficult. For example, does the Account class\nallow someone to use an int instead of a float? Or what about a Decimal? You’ll find\nthat all of these work even though the hint might seem to suggest otherwise.\nfrom decimal import Decimal\na = Account('Guido', Decimal('1000.0'))\na.withdraw(Decimal('50.0'))\nprint(a.inquiry())\n# -> 950.0\nKnowing how to properly organize types in such situations is beyond the scope of this\nbook. When in doubt, it’s probably better not to guess unless you are actively using tools\nthat type-check your code.\n7.17\nProperties\nAs noted in the previous section, Python places no runtime restrictions on attribute\nvalues or types. However, such enforcement is possible if you put an attribute under the\nmanagement of a so-called property. A property is a special kind of attribute that intercepts\nattribute access and handles it via user-defined methods. These methods have complete\nfreedom to manage the attribute as they see fit. Here is an example:\nimport string\nclass Account:\ndef __init__(self, owner, balance):\nself.owner = owner\nself._balance = balance\n@property\ndef owner(self):\nreturn self._owner\n@owner.setter\ndef owner(self, value):\nif not isinstance(value, str):\nraise TypeError('Expected str')\nif not all(c in string.ascii_uppercase for c in value):\nraise ValueError('Must be uppercase ASCII')\nif len(value) > 10:\nraise ValueError('Must be 10 characters or less')\nself._owner = value\nHere, the owner attribute is being constrained to a very enterprise-grade 10-character\nuppercase ASCII string. Here is how it works when you try to use the class:",
      "content_length": 1681,
      "extraction_method": "Direct"
    },
    {
      "page_number": 196,
      "chapter": null,
      "content": "7.17 Properties\n181\n>>> a = Account('GUIDO', 1000.0)\n>>> a.owner = 'EVA'\n>>> a.owner = 42\nTraceback (most recent call last):\n...\nTypeError: Expected str\n>>> a.owner = 'Carol'\nTraceback (most recent call last):\n...\nValueError: Must be uppercase ASCII\n>>> a.owner = 'RENÉE'\nTraceback (most recent call last):\n...\nValueError: Must be uppercase ASCII\n>>> a.owner = 'RAMAKRISHNAN'\nTraceback (most recent call last):\n...\nValueError: Must be 10 characters or less\n>>>\nThe @property decorator is used to establish an attribute as a property. In this example,\nit’s being applied to the owner attribute. This decorator is always first applied to a method\nthat gets the attribute value. In this case, the method is returning the actual value which is\nbeing stored in the private attribute _owner. The @owner.setter decorator that follows\nis used to optionally implement a method for setting the attribute value. This method\nperforms the various type and value checks before storing the value in the private _owner\nattribute.\nA critical feature of properties is that the associated name, such as owner in the example,\nbecomes “magical.” That is, any use of that attribute automatically routes through\nthe getter/setter methods that you implemented. You don’t have to change any\npreexisting code to make this work. For example, no changes need to be made to the\nAccount.__init__() method. This may surprise you because __init__() makes the\nassignment self.owner = owner instead of using the private attribute self._owner. This\nis by design—the whole point of the owner property was to validate attribute values.\nYou’d definitely want to do that when instances are created. You’ll find that it works\nexactly as intended:\n>>> a = Account('Guido', 1000.0)\nTraceback (most recent call last):\nFile \"account.py\", line 5, in __init__\nself.owner = owner\nFile \"account.py\", line 15, in owner\nraise ValueError('Must be uppercase ASCII')\nValueError: Must be uppercase ASCII\n>>>",
      "content_length": 1953,
      "extraction_method": "Direct"
    },
    {
      "page_number": 197,
      "chapter": null,
      "content": "182\nChapter 7\nClasses and Object-Oriented Programming\nSince each access to a property attribute automatically invokes a method, the actual\nvalue needs to be stored under a different name. This is why _owner is used inside the\ngetter and setter methods. You can’t use owner as the storage location because doing so\nwould cause infinite recursion.\nIn general, properties allow for the interception of any specific attribute name. You can\nimplement methods for getting, setting, or deleting the attribute value. For example:\nclass SomeClass:\n@property\ndef attr(self):\nprint('Getting')\n@attr.setter\ndef attr(self, value):\nprint('Setting', value)\n@attr.deleter\ndef attr(self):\nprint('Deleting')\n# Example\ns = SomeClass()\ns.attr\n# Getting\ns.attr = 13\n# Setting\ndel s.attr\n# Deleting\nIt is not necessary to implement all parts of a property. In fact, it’s common to use\nproperties for implementing read-only computed data attributes. For example:\nclass Box(object):\ndef __init__(self, width, height):\nself.width = width\nself.height = height\n@property\ndef area(self):\nreturn self.width * self.height\n@property\ndef perimeter(self):\nreturn 2*self.width + 2*self.height\n# Example use\nb = Box(4, 5)",
      "content_length": 1186,
      "extraction_method": "Direct"
    },
    {
      "page_number": 198,
      "chapter": null,
      "content": "7.18 Types, Interfaces, and Abstract Base Classes\n183\nprint(b.area)\n# -> 20\nprint(b.perimeter)\n# -> 18\nb.area = 5\n# Error: can't set attribute\nOne thing to think about when defining a class is making the programming interface to\nit as uniform as possible. Without properties, some values would be accessed as simple\nattributes such as b.width or b.height whereas other values would be accessed as methods\nsuch as b.area() and b.perimeter(). Keeping track of when to add the extra () creates\nunnecessary confusion. A property can help fix this.\nPython programmers don’t often realize that methods themselves are implicitly handled\nas a kind of property. Consider this class:\nclass SomeClass:\ndef yow(self):\nprint('Yow!')\nWhen a user creates an instance such as s = SomeClass() and then accesses s.yow, the\noriginal function object yow is not returned. Instead, you get a bound method like this:\n>>> s = SomeClass()\n>>> s.yow\n<bound method SomeClass.yow of <__main__.SomeClass object at 0x10e2572b0>>\n>>>\nHow did this happen? It turns out that functions behave a lot like properties when\nthey’re placed in a class. Specifically, functions magically intercept attribute access and\ncreate the bound method behind the scenes. When you define static and class methods\nusing @staticmethod and @classmethod, you are actually altering this process.\n@staticmethod returns the method function back “as is” without any special wrapping or\nprocessing. More information about this process is covered later in Section 7.28.\n7.18\nTypes, Interfaces, and Abstract Base\nClasses\nWhen you create an instance of a class, the type of that instance is the class itself. To test\nfor membership in a class, use the built-in function isinstance(obj, cls). This function\nreturns True if an object, obj, belongs to the class cls or any class derived from cls.\nHere’s an example:\nclass A:\npass\nclass B(A):\npass",
      "content_length": 1880,
      "extraction_method": "Direct"
    },
    {
      "page_number": 199,
      "chapter": null,
      "content": "184\nChapter 7\nClasses and Object-Oriented Programming\nclass C:\npass\na = A()\n# Instance of 'A'\nb = B()\n# Instance of 'B'\nc = C()\n# Instance of 'C'\ntype(a)\n# Returns the class object A\nisinstance(a, A)\n# Returns True\nisinstance(b, A)\n# Returns True, B derives from A\nisinstance(b, C)\n# Returns False, B not derived from C\nSimilarly, the built-in function issubclass(A, B) returns True if the class A is a subclass\nof class B. Here’s an example:\nissubclass(B, A)\n# Returns True\nissubclass(C, A)\n# Returns False\nA common use of class typing relations is the specification of programming interfaces.\nAs an example, a top-level base class might be implemented to specify the requirements\nof a programming interface. That base class might then be used for type hinting or for\ndefensive type enforcement via isinstance():\nclass Stream:\ndef receive(self):\nraise NotImplementedError()\ndef send(self, msg):\nraise NotImplementedError()\ndef close(self):\nraise NotImplementedError()\n# Example.\ndef send_request(stream, request):\nif not isinstance(stream, Stream):\nraise TypeError('Expected a Stream')\nstream.send(request)\nreturn stream.receive()\nThe anticipation with such code is not that Stream be used directly. Instead, different\nclasses would inherit from Stream and implement the required functionality. A user would\ninstantiate one of those classes instead. For example:\nclass SocketStream(Stream):\ndef receive(self):\n...",
      "content_length": 1414,
      "extraction_method": "Direct"
    },
    {
      "page_number": 200,
      "chapter": null,
      "content": "7.18 Types, Interfaces, and Abstract Base Classes\n185\ndef send(self, msg):\n...\ndef close(self):\n...\nclass PipeStream(Stream):\ndef receive(self):\n...\ndef send(self, msg):\n...\ndef close(self):\n...\n# Example\ns = SocketStream()\nsend_request(s, request)\nWorth discussing in this example is the runtime enforcement of the interface in\nsend_request(). Should one use a type hint instead?\n# Specifying an interface as a type hint\ndef send_request(stream:Stream, request):\nstream.send(request)\nreturn stream.receive()\nGiven that type hints aren’t enforced, the decision of how to validate an argument\nagainst an interface really depends on when you want it to happen—at runtime, as a code\nchecking step, or not at all.\nThis use of interface classes is more common in the organization of large frameworks\nand applications. However, with this approach you need to make sure that subclasses\nactually implement the required interface. For example, if a subclass chose not to\nimplement one of the required methods or had a simple misspelling, the effects might go\nunnoticed at first as the code might still work in the common case. However, later on, the\nprogram will crash if the unimplemented method is invoked. Naturally, this would only\ntake place at 3:30 AM in production.\nTo prevent this problem, it is common for interfaces to be defined as abstract base classes\nusing the abc module. This module defines a base class (ABC) and a decorator\n(@abstractmethod) that are used together to describe an interface. Here is an example:\nfrom abc import ABC, abstractmethod\nclass Stream(ABC):\n@abstractmethod",
      "content_length": 1590,
      "extraction_method": "Direct"
    },
    {
      "page_number": 201,
      "chapter": null,
      "content": "186\nChapter 7\nClasses and Object-Oriented Programming\ndef receive(self):\npass\n@abstractmethod\ndef send(self, msg):\npass\n@abstractmethod\ndef close(self):\npass\nAn abstract class is not meant to be instantiated directly. In fact, if you try to create a\nStream instance, you’ll get an error:\n>>> s = Stream()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: Can't instantiate abstract class Stream with abstract methods\nclose, receive, send\n>>>\nThe error message tells you exactly what methods need to be implemented by a\nStream. This serves as a guide for writing subclasses. Suppose you write a subclass but\nmake a mistake:\nclass SocketStream(Stream):\ndef read(self):\n# Misnamed\n...\ndef send(self, msg):\n...\ndef close(self):\n...\nAn abstract base class will catch the mistake upon instantiation. This is useful because\nerrors are caught early.\n>>> s = SocketStream()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: Can't instantiate abstract class SocketStream with abstract\nmethods receive\n>>>",
      "content_length": 1058,
      "extraction_method": "Direct"
    },
    {
      "page_number": 202,
      "chapter": null,
      "content": "7.19 Multiple Inheritance, Interfaces, and Mixins\n187\nAlthough an abstract class cannot be instantiated, it can define methods and properties\nfor use in subclasses. Moreover, an abstract method in the base can still be called from a\nsubclass. For example, calling super().receive() from a subclass is allowed.\n7.19\nMultiple Inheritance, Interfaces, and\nMixins\nPython supports multiple inheritance. If a child class lists more than one parent, the child\ninherits all of the features of the parents. For example:\nclass Duck:\ndef walk(self):\nprint('Waddle')\nclass Trombonist:\ndef noise(self):\nprint('Blat!')\nclass DuckBonist(Duck, Trombonist):\npass\nd = DuckBonist()\nd.walk()\n# -> Waddle\nd.noise()\n# -> Blat!\nConceptually, it’s a neat idea, but then practical realities start to set in. For example,\nwhat happens if Duck and Trombonist each define an __init__() method? Or if they both\ndefine a noise() method? Suddenly, you start to realize that multiple inheritance is fraught\nwith peril.\nTo better understand the actual usage of multiple inheritance, step back and view it\nas a highly specialized tool for organization and code reuse—as opposed to a general-\npurpose programming technique. Specifically, taking a collection of arbitrary unrelated\nclasses and combining them together with multiple inheritance to create weird mutant\nduck-musicians isn’t standard practice. Don’t ever do that.\nA more common use of multiple inheritance is organizing type and interface relations.\nFor example, the last section introduced the concept of an abstract base class. The purpose\nof an abstract base is to specify a programming interface. For example, you might have\nvarious abstract classes like this:\nfrom abc import ABC, abstractmethod\nclass Stream(ABC):\n@abstractmethod",
      "content_length": 1762,
      "extraction_method": "Direct"
    },
    {
      "page_number": 203,
      "chapter": null,
      "content": "188\nChapter 7\nClasses and Object-Oriented Programming\ndef receive(self):\npass\n@abstractmethod\ndef send(self, msg):\npass\n@abstractmethod\ndef close(self):\npass\nclass Iterable(ABC):\n@abstractmethod\ndef __iter__(self):\npass\nWith these classes, multiple inheritance might be used to specify which interfaces have\nbeen implemented by a child class:\nclass MessageStream(Stream, Iterable):\ndef receive(self):\n...\ndef send(self):\n...\ndef close(self):\n...\ndef __iter__(self):\n...\nAgain, this use of multiple inheritance is not about implementation, but type relations.\nFor example, none of the inherited methods even do anything in this example. There is no\ncode reuse. Mainly, the inheritance relationship allows you to perform type checks like this:\nm = MessageStream()\nisinstance(m, Stream)\n# -> True\nisinstance(m, Iterable)\n# -> True\nThe other use of multiple inheritance is to define mixin classes. A mixin class is a class\nthat modifies or extends the functionality of other classes. Consider the following class\ndefinitions:\nclass Duck:\ndef noise(self):\nreturn 'Quack'\ndef waddle(self):",
      "content_length": 1083,
      "extraction_method": "Direct"
    },
    {
      "page_number": 204,
      "chapter": null,
      "content": "7.19 Multiple Inheritance, Interfaces, and Mixins\n189\nreturn 'Waddle'\nclass Trombonist:\ndef noise(self):\nreturn 'Blat!'\ndef march(self):\nreturn 'Clomp'\nclass Cyclist:\ndef noise(self):\nreturn 'On your left!'\ndef pedal(self):\nreturn 'Pedaling'\nThese classes are completely unrelated to each other. There is no inheritance\nrelationship and they implement different methods. However, there is a shared\ncommonality in that they each define a noise() method. Using that as a guide, you could\ndefine the following classes:\nclass LoudMixin:\ndef noise(self):\nreturn super().noise().upper()\nclass AnnoyingMixin:\ndef noise(self):\nreturn 3*super().noise()\nAt first glance, these classes look wrong. There’s just a single isolated method and it uses\nsuper() to delegate to a nonexistent parent class. The classes don’t even work:\n>>> a = AnnoyingMixin()\n>>> a.noise()\nTraceback (most recent call last):\n...\nAttributeError: 'super' object has no attribute 'noise'\n>>>\nThese are mixin classes. The only way that they work is in combination with other\nclasses that implement the missing functionality. For example:\nclass LoudDuck(LoudMixin, Duck):\npass\nclass AnnoyingTrombonist(AnnoyingMixin, Trombonist):\npass",
      "content_length": 1194,
      "extraction_method": "Direct"
    },
    {
      "page_number": 205,
      "chapter": null,
      "content": "190\nChapter 7\nClasses and Object-Oriented Programming\nclass AnnoyingLoudCyclist(AnnoyingMixin, LoudMixin, Cyclist):\npass\nd = LoudDuck()\nd.noise() # -> 'QUACK'\nt = AnnoyingTrombonist()\nt.noise() # -> 'Blat!Blat!Blat!'\nc = AnnoyingLoudCyclist()\nc.noise() # -> 'ON YOUR LEFT!ON YOUR LEFT!ON YOUR LEFT!'\nSince mixin classes are defined in the same way as normal classes, it is best to include\nthe word “Mixin” as part of the class name. This naming convention provides a greater\nclarity of purpose.\nTo fully understand mixins, you need to know a bit more about how inheritance and\nthe super() function work.\nFirst, whenever you use inheritance, Python builds a linear chain of classes known as\nthe Method Resolution Order, or MRO for short. This is available as the __mro__ attribute\non a class. Here are some examples for single inheritance:\nclass Base:\npass\nclass A(Base):\npass\nclass B(A):\npass\nBase.__mro__ # -> (<class 'Base'>, <class 'object'>)\nA.__mro__\n# -> (<class 'A'>, <class 'Base'>, <class 'object'>)\nB.__mro__\n# -> (<class 'B'>, <class 'A'>, <class 'Base'>, <class 'object'>)\nThe MRO specifies the search order for attribute lookup. Specifically, whenever you\nsearch for an attribute on an instance or class, each class on the MRO is checked in the\norder listed. The search stops when the first match is made. The object class is listed in\nthe MRO because all classes inherit from object, whether or not it’s listed as a parent.\nTo support multiple inheritance, Python implements what’s known as “cooperative\nmultiple inheritance.” With cooperative inheritance, all of the classes are placed on the\nMRO list according to two primary ordering rules. The first rule states that a child class\nmust always be checked before any of its parents. The second rule states that if a class has\nmultiple parents, those parents must be checked in the same order as they’re written in the\ninheritance list of the child. For the most part, these rules produce an MRO that makes\nsense. However, the precise algorithm that orders the classes is actually quite complex and\nnot based on any simple approach such as depth-first or breadth-first search. Instead, the",
      "content_length": 2154,
      "extraction_method": "Direct"
    },
    {
      "page_number": 206,
      "chapter": null,
      "content": "7.19 Multiple Inheritance, Interfaces, and Mixins\n191\nordering is determined according to the C3 linearization algorithm, which is described in\nthe paper “A Monotonic Superclass Linearization for Dylan” (K. Barrett, et al., presented\nat OOPSLA’96). A subtle aspect of this algorithm is that certain class hierarchies will be\nrejected by Python with a TypeError. Here’s an example:\nclass X: pass\nclass Y(X): pass\nclass Z(X,Y): pass\n# TypeError.\n# Can't create consistent MRO\nIn this case, the method resolution algorithm rejects class Z because it can’t determine\nan ordering of the base classes that makes sense. Here, the class X appears before class Y in\nthe inheritance list, so it must be checked first. However, class Y inherits from X, so if X is\nchecked first, it violates the rule about children being checked first. In practice, these issues\nrarely arise—and if they do, it usually indicates a more serious design problem.\nAs an example of an MRO in practice, here’s the MRO for the AnnoyingLoudCyclist\nclass shown earlier:\nclass AnnoyingLoudCyclist(AnnoyingMixin, LoudMixin, Cyclist):\npass\nAnnoyingLoudCyclist.__mro__\n# (<class 'AnnoyingLoudCyclist'>, <class 'AnnoyingMixin'>,\n#\n<class 'LoudMixin'>, <class 'Cyclist'>, <class 'object'>)\nIn this MRO, you see how both rules are satisfied. Specifically, any child class is always\nlisted before its parents. The object class is listed last because it is the parent of all other\nclasses. The multiple parents are listed in the order they appeared in the code.\nThe behavior of the super() function is tied to the underlying MRO. Specifically, its\nrole is to delegate attributes to the next class on the MRO. This is based upon the class\nwhere super() is used. For example, when the AnnoyingMixin class uses super(), it looks\nat the MRO of the instance to find its own position. From there, it delegates attribute\nlookup to the next class. In this example, using super().noise() in the AnnoyingMixin\nclass invokes LoudMixin.noise(). This is because LoudMixin is the next class listed on the\nMRO for AnnoyingLoudCyclist. The super().noise() operation in the LoudMixin class\nthen delegates to the Cyclist class. For any use of super(), the choice of the next class\nvaries according to the type of the instance. For example, if you make an instance of\nAnnoyingTrombonist, then super().noise() will invoke Trombonist.noise() instead.\nDesigning for cooperative multiple inheritance and mixins is a challenge. Here are\nsome design guidelines. First, child classes are always checked before any base class in the\nMRO. Thus, it is common for mixins to share a common parent, and for that parent to\nprovide an empty implementation of methods. If multiple mixin classes are used at the\nsame time, they’ll line up after each other. The common parent will appear last where it\ncan provide a default implementation or an error check. For example:\nclass NoiseMixin:\ndef noise(self):",
      "content_length": 2922,
      "extraction_method": "Direct"
    },
    {
      "page_number": 207,
      "chapter": null,
      "content": "192\nChapter 7\nClasses and Object-Oriented Programming\nraise NotImplementedError('noise() not implemented')\nclass LoudMixin(NoiseMixin):\ndef noise(self):\nreturn super().noise().upper()\nclass AnnoyingMixin(NoiseMixin):\ndef noise(self):\nreturn 3 * super().noise()\nThe second guideline is that all implementations of a mixin method should have an\nidentical function signature. One issue with mixins is that they are optional and often\nmixed together in unpredictable order. For this to work, you must guarantee that\noperations involving super() succeed regardless of what class comes next. To do that,\nall methods in the call chain need to have a compatible calling signature.\nFinally, you need to make sure that you use super() everywhere. Sometimes you’ll\nencounter a class that makes a direct call to its parent:\nclass Base:\ndef yow(self):\nprint('Base.yow')\nclass A(Base):\ndef yow(self):\nprint('A.yow')\nBase.yow(self)\n# Direct call to parent\nclass B(Base):\ndef yow(self):\nprint('B.yow')\nsuper().yow(self)\nclass C(A, B):\npass\nc = C()\nc.yow()\n# Outputs:\n#\nA.yow\n#\nBase.yow\nSuch classes are not safe to use with multiple inheritance. Doing so breaks the proper\nchain of method calls and causes confusion. For instance, in the above example, no output\never appears from B.yow() even though it’s part of the inheritance hierarchy. If you’re\ndoing anything with multiple inheritance, you should be using super() instead of making\ndirect calls to methods in superclasses.",
      "content_length": 1463,
      "extraction_method": "Direct"
    },
    {
      "page_number": 208,
      "chapter": null,
      "content": "7.20 Type-Based Dispatch\n193\n7.20\nType-Based Dispatch\nSometimes you need to write code that dispatches based on a specific type. For example:\nif isinstance(obj, Duck):\nhandle_duck(obj)\nelif isinstance(obj, Trombonist):\nhandle_trombonist(obj)\nelif isinstance(obj, Cyclist):\nhandle_cyclist(obj)\nelse:\nraise RuntimeError('Unknown object')\nSuch a large if-elif-else block is inelegant and fragile. An often used solution is to\ndispatch through a dictionary:\nhandlers = {\nDuck: handle_duck,\nTrombonist: handle_trombonist,\nCyclist: handle_cyclist\n}\n# Dispatch\ndef dispatch(obj):\nfunc = handlers.get(type(obj))\nif func:\nreturn func(obj)\nelse:\nraise RuntimeError(f'No handler for {obj}')\nThis solution assumes an exact type match. If inheritance is also to be supported in such\ndispatch, you would need to walk the MRO:\ndef dispatch(obj):\nfor ty in type(obj).__mro__:\nfunc = handlers.get(ty)\nif func:\nreturn func(obj)\nraise RuntimeError(f'No handler for {obj}')\nSometimes dispatching is implemented through a class-based interface using getattr()\nlike this:\nclass Dispatcher:\ndef handle(self, obj):\nfor ty in type(obj).__mro__:\nmeth = getattr(self, f'handle_{ty.__name__}', None)",
      "content_length": 1171,
      "extraction_method": "Direct"
    },
    {
      "page_number": 209,
      "chapter": null,
      "content": "194\nChapter 7\nClasses and Object-Oriented Programming\nif meth:\nreturn meth(obj)\nraise RuntimeError(f'No handler for {obj}')\ndef handle_Duck(self, obj):\n...\ndef handle_Trombonist(self, obj):\n...\ndef handle_Cyclist(self, obj):\n...\n# Example\ndispatcher = Dispatcher()\ndispatcher.handle(Duck())\n# -> handle_Duck()\ndispatcher.handle(Cyclist())\n# -> handle_Cyclist()\nThis last example of using getattr() to dispatch onto methods of a class is a fairly\ncommon programming pattern.\n7.21\nClass Decorators\nSometimes you want to perform extra processing steps after a class has been defined—such\nas adding the class to a registry or generating extra support code. One approach is to use a\nclass decorator. A class decorator is a function that takes a class as input and returns a class\nas output. For example, here’s how you can maintain a registry:\n_registry = { }\ndef register_decoder(cls):\nfor mt in cls.mimetypes:\n_registry[mt.mimetype] = cls\nreturn cls\n# Factory function that uses the registry\ndef create_decoder(mimetype):\nreturn _registry[mimetype]()\nIn this example, the register_decoder() function looks inside a class for a mimetypes\nattribute. If found, it’s used to add the class to a dictionary mapping MIME types to class\nobjects. To use this function, you apply it as a decorator right before the class definition:\n@register_decoder\nclass TextDecoder:\nmimetypes = [ 'text/plain' ]",
      "content_length": 1385,
      "extraction_method": "Direct"
    },
    {
      "page_number": 210,
      "chapter": null,
      "content": "7.21 Class Decorators\n195\ndef decode(self, data):\n...\n@register_decoder\nclass HTMLDecoder:\nmimetypes = [ 'text/html' ]\ndef decode(self, data):\n...\n@register_decoder\nclass ImageDecoder:\nmimetypes = [ 'image/png', 'image/jpg', 'image/gif' ]\ndef decode(self, data):\n...\n# Example usage\ndecoder = create_decoder('image/jpg')\nA class decorator is free to modify the contents of the class it’s given. For example, it\nmight even rewrite existing methods. This is a common alternative to mixin classes or\nmultiple inheritance. For example, consider these decorators:\ndef loud(cls):\norig_noise = cls.noise\ndef noise(self):\nreturn orig_noise(self).upper()\ncls.noise = noise\nreturn cls\ndef annoying(cls):\norig_noise = cls.noise\ndef noise(self):\nreturn 3 * orig_noise(self)\ncls.noise = noise\nreturn cls\n@annoying\n@loud\nclass Cyclist(object):\ndef noise(self):\nreturn 'On your left!'\ndef pedal(self):\nreturn 'Pedaling'",
      "content_length": 904,
      "extraction_method": "Direct"
    },
    {
      "page_number": 211,
      "chapter": null,
      "content": "196\nChapter 7\nClasses and Object-Oriented Programming\nThis example produces the same result as the mixin example from the previous section.\nHowever, there is no multiple inheritance and no use of super(). Within each decorator,\nthe lookup of cls.noise performs the same action as super(). But, since this only\nhappens once when the decorator is applied (at definition time), the resulting calls to\nnoise() will run a bit faster.\nClass decorators can also be used to create entirely new code. For example, a common\ntask when writing a class is to write a useful __repr__() method for improved debugging:\nclass Point:\ndef __init__(self, x, y):\nself.x = x\nself.y = y\ndef __repr__(self):\nreturn f'{type(self).__name__}({self.x!r}, {self.y!r})'\nWriting such methods is often annoying. Perhaps a class decorator could create the\nmethod for you?\nimport inspect\ndef with_repr(cls):\nargs = list(inspect.signature(cls).parameters)\nargvals = ', '.join('{self.%s!r}' % arg for arg in args)\ncode = 'def __repr__(self):\\n'\ncode += f'\nreturn f\"{cls.__name__}({argvals})\"\\n'\nlocs = { }\nexec(code, locs)\ncls.__repr__ = locs['__repr__']\nreturn cls\n# Example\n@with_repr\nclass Point:\ndef __init__(self, x, y):\nself.x = x\nself.y = y\nIn this example, a __repr__() method is generated from the calling signature of the\n__init__() method. The method is created as a text string and passed to exec() to create\na function. That function is attached to the class.\nSimilar code generation techniques are used in parts of the standard library. For\nexample, a convenient way to define data structures is to use a dataclass:\nfrom dataclasses import dataclass\n@dataclass\nclass Point:",
      "content_length": 1651,
      "extraction_method": "Direct"
    },
    {
      "page_number": 212,
      "chapter": null,
      "content": "7.22 Supervised Inheritance\n197\nx: int\ny: int\nA dataclass automatically creates methods such as __init__() and __repr__() from\nclass type hints. The methods are created using exec(), similarly to the prior example.\nHere’s how the resulting Point class works:\n>>> p = Point(2, 3)\n>>> p\nPoint(x=2, y=3)\n>>>\nOne downside of such an approach is poor startup performance. Dynamically creating\ncode with exec() bypasses the compilation optimizations that Python normally applies to\nmodules. Defining a large number of classes in this way may therefore significantly slow\ndown the importing of your code.\nThe examples shown in this section illustrate common uses of class decorators—\nregistration, code rewriting, code generation, validation, and so on. One issue with class\ndecorators is that they must be explicitly applied to each class where they are used. This\nis not always desired. The next section describes a feature that allows for implicit\nmanipulation of classes.\n7.22\nSupervised Inheritance\nAs you saw in the previous section, sometimes you want to define a class and perform\nadditional actions. A class decorator is one mechanism for doing this. However, a parent\nclass can also perform extra actions on behalf of its subclasses. This is accomplished by\nimplementing an __init_subclass__(cls) class method. For example:\nclass Base:\n@classmethod\ndef __init_subclass__(cls):\nprint('Initializing', cls)\n# Example (should see 'Initializing' message for each class)\nclass A(Base):\npass\nclass B(A):\npass\nIf an __init_subclass__() method is present, it is triggered automatically upon the\ndefinition of any child class. This happens even if the child is buried deeply in an\ninheritance hierarchy.\nMany of the tasks commonly performed with class decorators can be performed with\n__init_subclass__() instead. For example, class registration:",
      "content_length": 1839,
      "extraction_method": "Direct"
    },
    {
      "page_number": 213,
      "chapter": null,
      "content": "198\nChapter 7\nClasses and Object-Oriented Programming\nclass DecoderBase:\n_registry = { }\n@classmethod\ndef __init_subclass__(cls):\nfor mt in cls.mimetypes:\nDecoderBase._registry[mt.mimetype] = cls\n# Factory function that uses the registry\ndef create_decoder(mimetype):\nreturn DecoderBase._registry[mimetype]()\nclass TextDecoder(DecoderBase):\nmimetypes = [ 'text/plain' ]\ndef decode(self, data):\n...\nclass HTMLDecoder(DecoderBase):\nmimetypes = [ 'text/html' ]\ndef decode(self, data):\n...\nclass ImageDecoder(DecoderBase):\nmimetypes = [ 'image/png', 'image/jpg', 'image/gif' ]\ndef decode(self, data):\n...\n# Example usage\ndecoder = create_decoder('image/jpg')\nHere is an example of a class that automatically creates a __repr__() method from the\nsignature of the class __init__() method:\nimport inspect\nclass Base:\n@classmethod\ndef __init_subclass__(cls):\n# Create a __repr__ method\nargs = list(inspect.signature(cls).parameters)\nargvals = ', '.join('{self.%s!r}' % arg for arg in args)\ncode = 'def __repr__(self):\\n'\ncode += f'\nreturn f\"{cls.__name__}({argvals})\"\\n'\nlocs = { }\nexec(code, locs)\ncls.__repr__ = locs['__repr__']",
      "content_length": 1122,
      "extraction_method": "Direct"
    },
    {
      "page_number": 214,
      "chapter": null,
      "content": "7.23 The Object Life Cycle and Memory Management\n199\nclass Point(Base):\ndef __init__(self, x, y):\nself.x = x\nself.y = y\nIf multiple inheritance is being used, you should use super() to make sure all classes\nthat implement __init_subclass__() get called. For example:\nclass A:\n@classmethod\ndef __init_subclass__(cls):\nprint('A.init_subclass')\nsuper().__init_subclass__()\nclass B:\n@classmethod\ndef __init_subclass__(cls):\nprint('B.init_subclass')\nsuper().__init_subclass__()\n# Should see output from both classes here\nclass C(A, B):\npass\nSupervising inheritance with __init_subclass__() is one of Python’s most powerful\ncustomization features. Much of its power comes from its implicit nature. A top-level base\nclass can use this to quietly supervise an entire hierarchy of child classes. Such supervision\ncan register classes, rewrite methods, perform validation, and more.\n7.23\nThe Object Life Cycle and Memory\nManagement\nWhen a class is defined, the resulting class is a factory for creating new instances. For\nexample:\nclass Account:\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\n# Create some Account instances\na = Account('Guido', 1000.0)\nb = Account('Eva', 25.0)",
      "content_length": 1199,
      "extraction_method": "Direct"
    },
    {
      "page_number": 215,
      "chapter": null,
      "content": "200\nChapter 7\nClasses and Object-Oriented Programming\nThe creation of an instance is carried out in two steps using the special method\n__new__() that creates a new instance and __init__() that initializes it. For example, the\noperation a = Account('Guido', 1000.0) performs these steps:\na = Account.__new__(Account, 'Guido', 1000.0)\nif isinstance(a, Account):\nAccount.__init__('Guido', 1000.0)\nExcept for the first argument which is the class instead of an instance, __new__()\nnormally receives the same arguments as __init__(). However, the default\nimplementation of __new__() just ignores them. You’ll sometimes see __new__() invoked\nwith just a single argument. For example, this code also works:\na = Account.__new__(Account)\nAccount.__init__('Guido', 1000.0)\nDirect use of the __new__() method is uncommon, but sometimes it’s used to create\ninstances while bypassing the invocation of the __init__() method. One such use is in\nclass methods. For example:\nimport time\nclass Date:\ndef __init__(self, year, month, day):\nself.year = year\nself.month = month\nself.day = day\n@classmethod\ndef today(cls):\nt = time.localtime()\nself = cls.__new__(cls)\n# Make instance\nself.year = t.tm_year\nself.month = t.tm_month\nself.day = t.tm_day\nreturn self\nModules that perform object serialization such as pickle also utilize __new__() to\nrecreate instances when objects are deserialized. This is done without ever invoking\n__init__().\nSometimes a class will define __new__() if it wants to alter some aspect of instance\ncreation. Typical applications include instance caching, singletons, and immutability. As an\nexample, you might want Date class to perform date interning—that is, caching and\nreusing Date instances that have an identical year, month, and day. Here is one way that\nmight be implemented:",
      "content_length": 1790,
      "extraction_method": "Direct"
    },
    {
      "page_number": 216,
      "chapter": null,
      "content": "7.23 The Object Life Cycle and Memory Management\n201\nclass Date:\n_cache = { }\n@staticmethod\ndef __new__(cls, year, month, day):\nself = Date._cache.get((year,month,day))\nif not self:\nself = super().__new__(cls)\nself.year = year\nself.month = month\nself.day = day\nDate._cache[year,month,day] = self\nreturn self\ndef __init__(self, year, month, day):\npass\n# Example\nd = Date(2012, 12, 21)\ne = Date(2012, 12, 21)\nassert d is e\n# Same object\nIn this example, the class keeps an internal dictionary of previously created Date\ninstances. When creating a new Date, the cache is consulted first. If a match is found, that\ninstance is returned. Otherwise, a new instance is created and initialized.\nA subtle detail of this solution is the empty __init__() method. Even though instances\nare cached, every call to Date() still invokes __init__(). To avoid duplicated effort, the\nmethod simply does nothing—instance creation actually takes place in __new__() when\nan instance is created the first time.\nThere are ways to avoid the extra call to __init__() but it requires sneaky tricks. One\nway to avoid it is to have __new__() return an entirely different type instance—for\nexample, one belonging to a different class. Another solution, described later, is to use a\nmetaclass.\nOnce created, instances are managed by reference counting. If the reference count\nreaches zero, the instance is immediately destroyed. When the instance is about to be\ndestroyed, the interpreter first looks for a __del__() method associated with the object\nand calls it. For example:\nclass Account(object):\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\ndef __del__(self):\nprint('Deleting Account')",
      "content_length": 1692,
      "extraction_method": "Direct"
    },
    {
      "page_number": 217,
      "chapter": null,
      "content": "202\nChapter 7\nClasses and Object-Oriented Programming\n>>> a = Account('Guido', 1000.0)\n>>> del a\nDeleting Account\n>>>\nOccasionally, a program will use the del statement to delete a reference to an object\nas shown. If this causes the reference count of the object to reach zero, the __del__()\nmethod is called. However, in general, the del statement doesn’t directly call __del__()\nbecause there may be other object references living elsewhere. There are many other ways\nthat an object might be deleted—for example, reassignment of a variable name or a\nvariable going out of scope in a function:\n>>> a = Account('Guido', 1000.0)\n>>> a = 42\nDeleting Account\n>>> def func():\n...\na = Account('Guido', 1000.0)\n...\n>>> func()\nDeleting Account\n>>>\nIn practice, it’s rarely necessary for a class to define a __del__() method. The only\nexception is when the destruction of an object requires an extra cleanup action—such as\nclosing a file, shutting down a network connection, or releasing other system resources.\nEven in these cases, it’s dangerous to rely on __del__() for a proper shutdown because\nthere’s no guarantee that this method will be called when you think it would. For clean\nshutdown of resources, you should give the object an explicit close() method. You\nshould also make your class support the context manager protocol so it can be used with\nthe with statement. Here is an example that covers all of the cases:\nclass SomeClass:\ndef __init__(self):\nself.resource = open_resource()\ndef __del__(self):\nself.close()\ndef close(self):\nself.resource.close()\ndef __enter__(self):\nreturn self\ndef __exit__(self, ty, val, tb):\nself.close()",
      "content_length": 1636,
      "extraction_method": "Direct"
    },
    {
      "page_number": 218,
      "chapter": null,
      "content": "7.23 The Object Life Cycle and Memory Management\n203\n# Closed via __del__()\ns = SomeClass()\ndel s\n# Explicit close\ns = SomeClass()\ns.close()\n# Closed at the end of a context block\nwith SomeClass() as s:\n...\nAgain, it should be emphasized that writing a __del__() in a class is almost never\nnecessary. Python already has garbage collection and there is simply no need to do it unless\nthere is some extra action that needs to take place upon object destruction. Even then, you\nstill might not need __del__() as it’s possible that the object is already programmed to\nclean itself up properly even if you do nothing.\nAs if there weren’t enough dangers with reference counting and object destruction,\nthere are certain kinds of programming patterns—especially those involving parent-child\nrelationships, graphs, or caching—where objects can create a so-called reference cycle. Here\nis an example:\nclass SomeClass:\ndef __del__(self):\nprint('Deleting')\nparent = SomeClass()\nchild = SomeClass()\n# Create a child-parent reference cycle\nparent.child = child\nchild.parent = parent\n# Try deletion (no output from __del__ appears)\ndel parent\ndel child\nIn this example, the variable names are destroyed but you never see execution of the\n__del__() method. The two objects each hold internal references to each other, so there’s\nno way for the reference count to ever drop to 0. To handle this, a special cycle-detecting\ngarbage collector runs every so often. Eventually the objects will be reclaimed, but it’s hard\nto predict when this might happen. If you want to force garbage collection, you can call\ngc.collect(). The gc module has a variety of other functions related to the cyclic\ngarbage collector and monitoring memory.\nBecause of the unpredictable timing of garbage collection, the __del__() method has\na few restrictions placed on it. First, any exception that propagates out of __del__() is",
      "content_length": 1887,
      "extraction_method": "Direct"
    },
    {
      "page_number": 219,
      "chapter": null,
      "content": "204\nChapter 7\nClasses and Object-Oriented Programming\nprinted to sys.stderr, but otherwise ignored. Second, the __del__() method should\navoid operations such as acquiring locks or other resources. Doing so could result in a\ndeadlock when __del__() is unexpectedly fired in the middle of executing an unrelated\nfunction within the seventh inner callback circle of signal handling and threads. If you\nmust define __del__(), keep it simple.\n7.24\nWeak References\nSometimes objects are kept alive when you’d much rather see them die. In an earlier\nexample, a Date class was shown with internal caching of instances. One problem with this\nimplementation is that there is no way for an instance to ever be removed from the cache.\nAs such, the cache will grow larger and larger over time.\nOne way to fix this problem is to create a weak reference using the weakref module. A\nweak reference is a way of creating a reference to an object without increasing its reference\ncount. To work with a weak reference, you have to add an extra bit of code to check if the\nobject being referred to still exists. Here’s an example of how you create a weakref:\n>>> a = Account('Guido', 1000.0)\n>>> import weakref\n>>> a_ref = weakref.ref(a)\n>>> a_ref\n<weakref at 0x104617188; to 'Account' at 0x1046105c0>\n>>>\nUnlike a normal reference, a weak reference allows the original object to die. For\nexample:\n>>> del a\n>>> a_ref\n<weakref at 0x104617188; dead>\n>>>\nA weak reference contains an optional reference to an object. To get the actual object,\nyou need to call the weak reference as a function with no arguments. This will either\nreturn the object being pointed at or None. For example:\nacct = a_ref()\nif acct is not None:\nacct.withdraw(10)\n# Alternative\nif acct := a_ref():\nacct.withdraw(10)",
      "content_length": 1768,
      "extraction_method": "Direct"
    },
    {
      "page_number": 220,
      "chapter": null,
      "content": "7.24 Weak References\n205\nWeak references are commonly used in conjunction with caching and other advanced\nmemory management. Here is a modified version of the Date class that automatically\nremoves objects from the cache when no more references exist:\nimport weakref\nclass Date:\n_cache = { }\n@staticmethod\ndef __new__(cls, year, month, day):\nselfref = Date._cache.get((year,month,day))\nif not selfref:\nself = super().__new__(cls)\nself.year = year\nself.month = month\nself.day = day\nDate._cache[year,month,day] = weakref.ref(self)\nelse:\nself = selfref()\nreturn self\ndef __init__(self, year, month, day):\npass\ndef __del__(self):\ndel Date._cache[self.year,self.month,self.day]\nThis might require a bit of study, but here is an interactive session that shows how it\nworks. Notice how an entry is removed from the cache once no more references to it exist:\n>>> Date._cache\n{}\n>>> a = Date(2012, 12, 21)\n>>> Date._cache\n{(2012, 12, 21): <weakref at 0x10c7ee2c8; to 'Date' at 0x10c805518>}\n>>> b = Date(2012, 12, 21)\n>>> a is b\nTrue\n>>> del a\n>>> Date._cache\n{(2012, 12, 21): <weakref at 0x10c7ee2c8; to 'Date' at 0x10c805518>}\n>>> del b\n>>> Date._cache\n{}\n>>>",
      "content_length": 1151,
      "extraction_method": "Direct"
    },
    {
      "page_number": 221,
      "chapter": null,
      "content": "206\nChapter 7\nClasses and Object-Oriented Programming\nAs previously noted, the __del__() method of a class is only invoked when the\nreference count of an object reaches zero. In this example, the first del a statement\ndecreases the reference count. However, since there’s still another reference to the same\nobject, the object remains in Date._cache. When the second object is deleted, __del__()\nis invoked and the cache is cleared.\nSupport for weak references requires instances to have a mutable __weakref__ attribute.\nInstances of user-defined classes normally have such an attribute by default. However,\nbuilt-in types and certain kinds of special data structures—named tuples, classes with\nslots—do not. If you want to construct weak references to these types, you can do it by\ndefining variants with a __weakref__ attribute added:\nclass wdict(dict):\n__slots__ = ('__weakref__',)\nw = wdict()\nw_ref = weakref.ref(w)\n# Now works\nThe use of slots here is to avoid unnecessary memory overhead, as explained shortly.\n7.25\nInternal Object Representation and\nAttribute Binding\nThe state associated with an instance is stored in a dictionary that’s accessible as the\ninstance’s __dict__ attribute. This dictionary contains the data that’s unique to each\ninstance. Here’s an example:\n>>> a = Account('Guido', 1100.0)\n>>> a.__dict__\n{'owner': 'Guido', 'balance': 1100.0}\nNew attributes can be added to an instance at any time:\na.number = 123456\n# Add attribute 'number' to a.__dict__\na.__dict__['number'] = 654321\nModifications to an instance are always reflected in the local __dict__ attribute unless\nthe attribute is being managed by a property. Likewise, if you make modifications to\n__dict__ directly, those modifications are reflected in the attributes.\nInstances are linked back to their class by a special attribute __class__. The class itself is\nalso just a thin layer over a dictionary that can be found in its own __dict__ attribute. The\nclass dictionary is where you find the methods. For example:\n>>> a.__class__\n<class '__main__.Account'>\n>>> Account.__dict__.keys()",
      "content_length": 2075,
      "extraction_method": "Direct"
    },
    {
      "page_number": 222,
      "chapter": null,
      "content": "7.25 Internal Object Representation and Attribute Binding\n207\ndict_keys(['__module__', '__init__', '__repr__', 'deposit', 'withdraw',\n'inquiry', '__dict__', '__weakref__', '__doc__'])\n>>> Account.__dict__['withdraw']\n<function Account.withdraw at 0x108204158>\n>>>\nClasses are linked to their base classes by a special attribute __bases__, which is a tuple\nof the base classes. The __bases__ attribute is only informational. The actual runtime\nimplementation of inheritance uses the __mro__ attribute which is a tuple of all parent\nclasses listed in search order. This underlying structure is the basis for all operations that\nget, set, or delete the attributes of instances.\nWhenever an attribute is set using obj.name = value, the special method\nobj.__setattr__('name', value) is invoked. If an attribute is deleted using del\nobj.name, the special method obj.__delattr__('name') is invoked. The default behavior\nof these methods is to modify or remove values from the local __dict__ of obj unless the\nrequested attribute happens to correspond to a property or descriptor. In that case, the set\nand delete operations will be carried out by the set and delete functions associated with the\nproperty.\nFor attribute lookup such as obj.name, the special method\nobj.__getattribute__('name') is invoked. This method carries out the search for the\nattribute, which normally includes checking the properties, looking in the local __dict__,\nchecking the class dictionary, and searching the MRO. If this search fails, a final attempt to\nfind the attribute is made by invoking the obj.__getattr__('name') method of the class\n(if defined). If this fails, an AttributeError exception is raised.\nUser-defined classes can implement their own versions of the attribute access functions,\nif desired. For example, here’s a class that restricts the attribute names that can be set:\nclass Account:\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\ndef __setattr__(self, name, value):\nif name not in {'owner', 'balance'}:\nraise AttributeError(f'No attribute {name}')\nsuper().__setattr__(name, value)\n# Example\na = Account('Guido', 1000.0)\na.balance = 940.25\n# Ok\na.amount = 540.2\n# AttributeError. No attribute amount\nA class that reimplements these methods should rely upon the default implementation\nprovided by super() to carry out the actual work of manipulating an attribute. This is\nbecause the default implementation takes care of the more advanced features of classes such",
      "content_length": 2487,
      "extraction_method": "Direct"
    },
    {
      "page_number": 223,
      "chapter": null,
      "content": "208\nChapter 7\nClasses and Object-Oriented Programming\nas descriptors and properties. If you don’t use super(), you will have to take care of these\ndetails yourself.\n7.26\nProxies, Wrappers, and Delegation\nSometimes classes implement a wrapper layer around another object to create a kind of\nproxy object. A proxy is an object exposes the same interface as another object but, for\nsome reason, isn’t related to the original object via inheritance. This is different from\ncomposition where an entirely new object is created from other objects but with its own\nunique set of methods and attributes.\nThere are many real-world scenarios where this might arise. For example, in distributed\ncomputing, the actual implementation of an object might live on a remote server in the\ncloud. Clients that interact with that server might use a proxy that looks like the object on\nthe server but, behind the scenes, delegates all of its method calls via network messages.\nA common implementation technique for proxies involves the __getattr__() method.\nHere is a simple example:\nclass A:\ndef spam(self):\nprint('A.spam')\ndef grok(self):\nprint('A.grok')\ndef yow(self):\nprint('A.yow')\nclass LoggedA:\ndef __init__(self):\nself._a = A()\ndef __getattr__(self, name):\nprint(\"Accessing\", name)\n# Delegate to internal A instance\nreturn getattr(self._a, name)\n# Example use\na = LoggedA()\na.spam()\n# prints \"Accessing spam\" and \"A.spam\"\na.yow()\n# prints \"Accessing yow\" and \"A.yow\"\nDelegation is sometimes used as an alternative to inheritance. Here is an example:\nclass A:\ndef spam(self):",
      "content_length": 1560,
      "extraction_method": "Direct"
    },
    {
      "page_number": 224,
      "chapter": null,
      "content": "7.26 Proxies, Wrappers, and Delegation\n209\nprint('A.spam')\ndef grok(self):\nprint('A.grok')\ndef yow(self):\nprint('A.yow')\nclass B:\ndef __init__(self):\nself._a = A()\ndef grok(self):\nprint('B.grok')\ndef __getattr__(self, name):\nreturn getattr(self._a, name)\n# Example use\nb = B()\nb.spam()\n# -> A.spam\nb.grok()\n# -> B.grok\n(redefined method)\nb.yow()\n# -> A.yow\nIn this example, it appears as if class B might be inheriting from class A and redefining a\nsingle method. This is the observed behavior—but inheritance is not being used. Instead,\nB holds an internal reference to an A inside. Certain methods of A can be redefined.\nHowever, all of the other methods are delegated via the __getattr__() method.\nThe technique of forwarding attribute lookup via __getattr__() is a common\ntechnique. However, be aware that it does not apply to operations mapped to special\nmethods. For example, consider this class:\nclass ListLike:\ndef __init__(self):\nself._items = list()\ndef __getattr__(self, name):\nreturn getattr(self._items, name)\n# Example\na = ListLike()\na.append(1)\n# Works\na.insert(0, 2)\n# Works\na.sort()\n# Works",
      "content_length": 1107,
      "extraction_method": "Direct"
    },
    {
      "page_number": 225,
      "chapter": null,
      "content": "210\nChapter 7\nClasses and Object-Oriented Programming\nlen(a)\n# Fails. No __len__() method\na[0]\n# Fails. No __getitem__() method\nHere, the class successfully forwards all of the standard list methods (list.sort(),\nlist.append(), and so on) to an inner list. However, none of Python’s standard operators\nwork. To make those work, you would have to explicitly implement the required special\nmethods. For example:\nclass ListLike:\ndef __init__(self):\nself._items = list()\ndef __getattr__(self, name):\nreturn getattr(self._items, name)\ndef __len__(self):\nreturn len(self._items)\ndef __getitem__(self, index):\nreturn self._items[index]\ndef __setitem__(self, index, value):\nself._items[index] = value\n7.27\nReducing Memory Use with\n__slots__\nAs we’ve seen, an instance stores its data in a dictionary. If you are creating a large number\nof instances, this can introduce a lot of memory overhead. If you know that the attribute\nnames are fixed, you can specify the names in a special class variable called __slots__.\nHere’s an example:\nclass Account(object):\n__slots__ = ('owner', 'balance')\n...\nSlots is a definition hint that allows Python to make performance optimizations for\nboth memory use and execution speed. Instances of a class with __slots__ no longer use\na dictionary for storing instance data. Instead, a much more compact data structure based\non an array is used. In programs that create a large number of objects, using __slots__\ncan result in a substantial reduction in memory use and a modest improvement in\nexecution time.\nThe only entries in __slots__ are instance attributes. You do not list methods,\nproperties, class variables, or any other class-level attributes. Basically, it’s the same names\nthat would ordinarily appear as dictionary keys in the instance’s __dict__.",
      "content_length": 1783,
      "extraction_method": "Direct"
    },
    {
      "page_number": 226,
      "chapter": null,
      "content": "7.28 Descriptors\n211\nBe aware that __slots__ has a tricky interaction with inheritance. If a class inherits\nfrom a base class that uses __slots__, it also needs to define __slots__ for storing its own\nattributes (even if it doesn’t add any) to take advantage of the benefits __slots__ provides.\nIf you forget this, the derived class will run slower—and use even more memory than if\n__slots__ had not been used on any of the classes!\n__slots__ is incompatible with multiple inheritance. If multiple base classes are\nspecified, each with nonempty slots, you will get a TypeError.\nThe use of __slots__ can also break code that expects instances to have an underlying\n__dict__ attribute. Although this often does not apply to user code, utility libraries and\nother tools for supporting objects may be programmed to look at __dict__ for debugging,\nserializing objects, and other operations.\nThe presence of __slots__ has no effect on the invocation of methods such as\n__getattribute__(), __getattr__(), and __setattr__() should they be redefined in a\nclass. However, if you’re implementing such methods, be aware that there is no longer any\ninstance __dict__ attribute. Your implementation will need to take that into account.\n7.28\nDescriptors\nNormally, attribute access corresponds to dictionary operations. If more control is needed,\nattribute access can be routed through user-defined get, set, and delete functions. The\nuse of properties was already described. However, a property is actually implemented using\na lower-level construct known as a descriptor. A descriptor is a class-level object that\nmanages access to an attribute. By implementing one or more of the special methods\n__get__(), __set__(), and __delete__(), you can hook directly into the attribute access\nmechanism and customize those operations. Here is an example:\nclass Typed:\nexpected_type = object\ndef __set_name__(self, cls, name):\nself.key = name\ndef __get__(self, instance, cls):\nif instance:\nreturn instance.__dict__[self.key]\nelse:\nreturn self\ndef __set__(self, instance, value):\nif not isinstance(value, self.expected_type):\nraise TypeError(f'Expected {self.expected_type}')\ninstance.__dict__[self.key] = value",
      "content_length": 2186,
      "extraction_method": "Direct"
    },
    {
      "page_number": 227,
      "chapter": null,
      "content": "212\nChapter 7\nClasses and Object-Oriented Programming\ndef __delete__(self,instance):\nraise AttributeError(\"Can't delete attribute\")\nclass Integer(Typed):\nexpected_type = int\nclass Float(Typed):\nexpected_type = float\nclass String(Typed):\nexpected_type = str\n# Example use:\nclass Account:\nowner = String()\nbalance = Float()\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\nIn this example, the class Typed defines a descriptor where type checking is performed\nwhen an attribute is assigned and an error is produced if an attempt is made to delete the\nattribute. The Integer, Float, and String subclasses specialize Type to match a specific\ntype. The use of these classes in another class (such as Account) makes those attributes\nautomatically call the appropriate __get__(), __set__(), or __delete__() methods on\naccess. For example:\na = Account('Guido', 1000.0)\nb = a.owner\n# Calls Account.owner.__get__(a, Account)\na.owner = 'Eva'\n# Calls Account.owner.__set__(a, 'Eva')\ndel f.owner\n# Calls Account.owner.__delete__(a)\nDescriptors can only be instantiated at the class level. It is not legal to create descriptors\non a per-instance basis by creating descriptor objects inside __init__() and other\nmethods. The __set_name__() method of a descriptor is invoked after a class has been\ndefined, but before any instances have been created, to inform a descriptor about the name\nthat has been used within the class. For instance, the balance = Float() definition calls\nFloat.__set_name__(Account, 'balance') to inform the descriptor of the class and\nname being used.\nDescriptors with a __set__() method always take precedence over items in the instance\ndictionary. For example, if a descriptor happens to have the same name as a key in the\ninstance dictionary, the descriptor takes priority. In the above Account example, you’ll see\nthe descriptor applying type checking even though the instance dictionary has a matching\nentry:",
      "content_length": 1951,
      "extraction_method": "Direct"
    },
    {
      "page_number": 228,
      "chapter": null,
      "content": "7.28 Descriptors\n213\n>>> a = Account('Guido', 1000.0)\n>>> a.__dict__\n{'owner': 'Guido', 'balance': 1000.0 }\n>>> a.balance = 'a lot'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"descrip.py\", line 63, in __set__\nraise TypeError(f'Expected {self.expected_type}')\nTypeError: Expected <class 'float'>\n>>>\nThe __get__(instance, cls) method of a descriptor takes arguments for both the\ninstance and the class. It’s possible that __get__() is invoked at the class level, in which\ncase the instance argument is None. In most cases, the __get__() returns the descriptor\nback if no instance is provided. For example:\n>>> Account.balance\n<__main__.Float object at 0x110606710>\n>>>\nA descriptor that only implements __get__() is known as a method descriptor. It has a\nweaker binding than a descriptor with both get/set capabilities. Specifically, the __get__()\nmethod of a method descriptor only gets invoked if there is no matching entry in the\ninstance dictionary. The reason it’s called a method descriptor is that this kind of descriptor\nis mainly used to implement Python’s various types of methods—including instance\nmethods, class methods, and static methods.\nFor example, here’s a skeleton implementation that shows how @classmethod and\n@staticmethod could be implemented from scratch (the real implementation is more\nefficient):\nimport types\nclass classmethod:\ndef __init__(self, func):\nself.__func__ = func\n# Return a bound method with cls as first argument\ndef __get__(self, instance, cls):\nreturn types.MethodType(self.__func__, cls)\nclass staticmethod:\ndef __init__(self, func):\nself.__func__ = func\n# Return the bare function\ndef __get__(self, instance, cls):\nreturn self.__func__",
      "content_length": 1713,
      "extraction_method": "Direct"
    },
    {
      "page_number": 229,
      "chapter": null,
      "content": "214\nChapter 7\nClasses and Object-Oriented Programming\nSince method descriptors only act if there is no matching entry in the instance\ndictionary, they can also be used to implement various forms of lazy evaluation of\nattributes. For example:\nclass Lazy:\ndef __init__(self, func):\nself.func = func\ndef __set_name__(self, cls, name):\nself.key = name\ndef __get__(self, instance, cls):\nif instance:\nvalue = self.func(instance)\ninstance.__dict__[self.key] = value\nreturn value\nelse:\nreturn self\nclass Rectangle:\ndef __init__(self, width, height):\nself.width = width\nself.height = height\narea = Lazy(lambda self: self.width * self.height)\nperimeter = Lazy(lambda self: 2*self.width + 2*self.height)\nIn this example, area and perimeter are attributes that are computed on demand and\nstored in the instance dictionary. Once computed, values are just returned directly from\nthe instance dictionary.\n>>> r = Rectangle(3, 4)\n>>> r.__dict__\n{'width': 3, 'height': 4 }\n>>> r.area\n12\n>>> r.perimeter\n14\n>>> r.__dict__\n{'width': 3, 'height': 4, 'area': 12, 'perimeter': 14 }\n>>>",
      "content_length": 1063,
      "extraction_method": "Direct"
    },
    {
      "page_number": 230,
      "chapter": null,
      "content": "7.29 Class Definition Process\n215\n7.29\nClass Definition Process\nThe definition of a class is a dynamic process. When you define a class using the class\nstatement, a new dictionary is created that serves as the local class namespace. The body\nof the class then executes as a script within this namespace. Eventually, the namespace\nbecomes the __dict__ attribute of the resulting class object.\nAny legal Python statement is allowed in the body of a class. Normally, you just define\nfunctions and variables, but control flow, imports, nested classes, and everything else is\nallowed. For example, here is a class that conditionally defines methods:\ndebug = True\nclass Account:\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\nif debug:\nimport logging\nlog = logging.getLogger(f'{__module__}.{__qualname__}')\ndef deposit(self, amount):\nAccount.log.debug('Depositing %f', amount)\nself.balance += amount\ndef withdraw(self, amount):\nAccount.log.debug('Withdrawing %f', amount)\nself.balance -= amount\nelse:\ndef deposit(self, amount):\nself.balance += amount\ndef withdraw(self, amount):\nself.balance -= amount\nIn this example, a global variable debug is being used to conditionally define methods.\nThe __qualname__ and __module__ variables are predefined strings that hold information\nabout the class name and enclosing module. These can be used by statements in the class\nbody. In this example, they’re being used to configure the logging system. There are\nprobably cleaner ways of organizing the above code, but the key point is that you can put\nanything you want in a class.\nOne critical point about class definition is that the namespace used to hold the contents\nof the class body is not a scope of variables. Any name that gets used within a method\n(such as Account.log in the above example) needs to be fully qualified.\nIf a function like locals() is used in a class body (but not inside a method), it returns\nthe dictionary being used for the class namespace.",
      "content_length": 1984,
      "extraction_method": "Direct"
    },
    {
      "page_number": 231,
      "chapter": null,
      "content": "216\nChapter 7\nClasses and Object-Oriented Programming\n7.30\nDynamic Class Creation\nNormally, classes are created using the class statement, but this is not a requirement. As\nnoted in the previous section, classes are defined by executing the body of a class to\npopulate a namespace. If you’re able to populate a dictionary with your own definitions,\nyou can make a class without ever using the class statement. To do that, use\ntypes.new_class():\nimport types\n# Some methods (not in a class)\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\ndef deposit(self, amount):\nself.balance -= amount\ndef withdraw(self, amount):\nself.balance += amount\nmethods = {\n'__init__': __init__,\n'deposit': deposit,\n'withdraw': withdraw,\n}\nAccount = types.new_class('Account', (),\nexec_body=lambda ns: ns.update(methods))\n# You now have a class\na = Account('Guido', 1000.0)\na.deposit(50)\na.withdraw(25)\nThe new_class() function requires a class name, a tuple of base classes, and a callback\nfunction responsible for populating the class namespace. This callback receives the class\nnamespace dictionary as an argument. It should update this dictionary in place. The return\nvalue of the callback is ignored.\nDynamic class creation may be useful if you want to create classes from data structures.\nFor example, in the section on descriptors, the following classes were defined:\nclass Integer(Typed):\nexpected_type = int",
      "content_length": 1423,
      "extraction_method": "Direct"
    },
    {
      "page_number": 232,
      "chapter": null,
      "content": "7.31 Metaclasses\n217\nclass Float(Typed):\nexpected_type = float\nclass String(Typed):\nexpected_type = str\nThis code is highly repetitive. Perhaps a data-driven approach would be better:\ntyped_classes = [\n('Integer', int),\n('Float', float),\n('String', str),\n('Bool', bool),\n('Tuple', tuple),\n]\nglobals().update(\n(name, types.new_class(name, (Typed,),\nexec_body=lambda ns: ns.update(expected_type=ty)))\nfor name, ty in typed_classes)\nIn this example, the global module namespace is being updated with dynamically\ncreated classes using types.new_class(). If you want to make more classes, put an\nappropriate entry in the typed_classes list.\nSometimes you will see type() being used to dynamically create a class instead. For\nexample:\nAccount = type('Account', (), methods)\nThis works, but it doesn’t take into account some of the more advanced class\nmachinery such as metaclasses (to be discussed shortly). In modern code, try to use\ntypes.new_class() instead.\n7.31\nMetaclasses\nWhen you define a class in Python, the class definition itself becomes an object. Here’s an\nexample:\nclass Account:\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\ndef deposit(self, amount):\nself.balance += amount",
      "content_length": 1216,
      "extraction_method": "Direct"
    },
    {
      "page_number": 233,
      "chapter": null,
      "content": "218\nChapter 7\nClasses and Object-Oriented Programming\ndef withdraw(self, amount):\nself.balance -= amount\nisinstance(Account, object)\n# -> True\nIf you think about this long enough, you will realize that if Account is an object, then\nsomething had to create it. This creation of the class object is controlled by a special kind\nof class called a metaclass. Simply put, a metaclass is a class that creates instances of classes.\nIn the preceding example, the metaclass that created Account is a built-in class called\ntype. In fact, if you check the type of Account, you will see that it is an instance of type:\n>>> Account.__class__\n<type 'type'>\n>>>\nIt’s a bit brain-bending, but it’s similar to integers. For example, if you write x = 42 and\nthen look at x.__class__, you’ll get int, which is the class that creates integers. Similarly,\ntype makes instances of types or classes.\nWhen a new class is defined with the class statement, a number of things happen.\nFirst, a new namespace for the class is created. Next, the body of the class is executed in\nthis namespace. Finally, the class name, base classes, and populated namespace are used to\ncreate the class instance. The following code illustrates the low-level steps that take place:\n# Step 1: Create the class namespace\nnamespace = type.__prepare__('Account', ())\n# Step 2: Execute the class body\nexec('''\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\ndef deposit(self, amount):\nself.balance += amount\ndef withdraw(self, amount):\nself.balance -= amount\n''', globals(), namespace)\n# Step 3: Create the final class object\nAccount = type('Account', (), namespace)\nIn the definition process, there is interaction with the type class to create the class\nnamespace and to create the final class object. The choice of using type can be\ncustomized—a class can choose to be processed by a different type class by specifying a\ndifferent metaclass. This is done by using the metaclass keyword argument in inheritance:",
      "content_length": 1991,
      "extraction_method": "Direct"
    },
    {
      "page_number": 234,
      "chapter": null,
      "content": "7.31 Metaclasses\n219\nclass Account(metaclass=type):\n...\nIf no metaclass is given, the class statement examines the type of the first entry in the\ntuple of base classes (if any) and uses that as the metaclass. Therefore, if you write class\nAccount(object), the resulting Account class will have the same type as object (which is\ntype). Note that classes that don’t specify any parent at all always inherit from object, so\nthis still applies.\nTo create a new metaclass, define a class that inherits from type. Within this class, you\ncan redefine one or more methods that are used during the class creation process.\nTypically, this includes the __prepare__() method used to create the class namespace, the\n__new__() method used to create the class instance, the __init__() method called after a\nclass has already been created, and the __call__() method used to create new instances.\nThe following example implements a metaclass that merely prints the input arguments to\neach method so you can experiment:\nclass mytype(type):\n# Creates the class namespace\n@classmethod\ndef __prepare__(meta, clsname, bases):\nprint(\"Preparing:\", clsname, bases)\nreturn super().__prepare__(clsname, bases)\n# Creates the class instance after body has executed\n@staticmethod\ndef __new__(meta, clsname, bases, namespace):\nprint(\"Creating:\", clsname, bases, namespace)\nreturn super().__new__(meta, clsname, bases, namespace)\n# Initializes the class instance\ndef __init__(cls, clsname, bases, namespace):\nprint(\"Initializing:\", clsname, bases, namespace)\nsuper().__init__(clsname, bases, namespace)\n# Creates new instances of the class\ndef __call__(cls, *args, **kwargs):\nprint(\"Creating instance:\", args, kwargs)\nreturn super().__call__(*args, **kwargs)\n# Example\nclass Base(metaclass=mytype):\npass\n# Definition of the Base produces the following output",
      "content_length": 1826,
      "extraction_method": "Direct"
    },
    {
      "page_number": 235,
      "chapter": null,
      "content": "220\nChapter 7\nClasses and Object-Oriented Programming\n# Preparing: Base ()\n# Creating: Base () {'__module__': '__main__', '__qualname__': 'Base'}\n# Initializing: Base () {'__module__': '__main__', '__qualname__': 'Base'}\nb = Base()\n# Creating instance: () {}\nOne tricky facet of working with metaclasses is the naming of variables and keeping\ntrack of the various entities involved. In the above code, the meta name refers to the\nmetaclass itself. The cls name refers to a class instance created by the metaclass. Although\nnot used here, the self name refers to a normal instance created by a class.\nMetaclasses propagate via inheritance. So, if you’ve defined a base class to use a different\nmetaclass, all child classes will also use that metaclass. Try this example to see your custom\nmetaclass at work:\nclass Account(Base):\ndef __init__(self, owner, balance):\nself.owner = owner\nself.balance = balance\ndef deposit(self, amount):\nself.balance += amount\ndef withdraw(self, amount):\nself.balance -= amount\nprint(type(Account))\n# -> <class 'mytype'>\nThe primary use of metaclasses is in situations where you want to exert extreme\nlow-level control over the class definition environment and creation process. Before\nproceeding, however, remember that Python already provides a lot of functionality for\nmonitoring and altering class definitions (such as the __init_subclass__() method, class\ndecorators, descriptors, mixins, and so on). Most of the time, you probably don’t need a\nmetaclass. That said, the next few examples show situations where a metaclass provides the\nonly sensible solution.\nOne use of a metaclass is in rewriting the contents of the class namespace prior to the\ncreation of the class object. Certain features of classes are established at definition time and\ncan’t be modified later. One such feature is __slots__. As noted earlier, __slots__ is a\nperformance optimization related to the memory layout of instances. Here’s a metaclass\nthat automatically sets the __slots__ attribute based on the calling signature of the\n__init__() method.\nimport inspect\nclass SlotMeta(type):\n@staticmethod",
      "content_length": 2110,
      "extraction_method": "Direct"
    },
    {
      "page_number": 236,
      "chapter": null,
      "content": "7.31 Metaclasses\n221\ndef __new__(meta, clsname, bases, methods):\nif '__init__' in methods:\nsig = inspect.signature(methods['__init__'])\n__slots__ = tuple(sig.parameters)[1:]\nelse:\n__slots__ = ()\nmethods['__slots__'] = __slots__\nreturn super().__new__(meta, clsname, bases, methods)\nclass Base(metaclass=SlotMeta):\npass\n# Example\nclass Point(Base):\ndef __init__(self, x, y):\nself.x = x\nself.y = y\nIn this example, the Point class that’s created is automatically created with __slots__ of\n('x', 'y'). The resulting instances of Point now get memory savings without knowing\nthat slots are being used. It doesn’t have to be specified directly. This kind of trick is not\npossible with class decorators or with __init_subclass__() because those features only\noperate on a class after it’s been created. By then, it’s too late to apply the __slots__\noptimization.\nAnother use of metaclasses is for altering the class definition environment. For example,\nduplicate definitions of a name during class definition normally result in a silent error—the\nsecond definition overwrites the first. Suppose you wanted to catch that. Here’s a metaclass\nthat does that by defining a different kind of dictionary for the class namespace:\nclass NoDupeDict(dict):\ndef __setitem__(self, key, value):\nif key in self:\nraise AttributeError(f'{key} already defined')\nsuper().__setitem__(key, value)\nclass NoDupeMeta(type):\n@classmethod\ndef __prepare__(meta, clsname, bases):\nreturn NoDupeDict()\nclass Base(metaclass=NoDupeMeta):\npass\n# Example\nclass SomeClass(Base):",
      "content_length": 1538,
      "extraction_method": "Direct"
    },
    {
      "page_number": 237,
      "chapter": null,
      "content": "222\nChapter 7\nClasses and Object-Oriented Programming\ndef yow(self):\nprint('Yow!')\ndef yow(self, x):\n# Fails. Already defined\nprint('Different Yow!')\nThis is only a small sample of what’s possible. For framework builders, metaclasses offer\nan opportunity to tightly control what happens during class definition—allowing classes to\nserve as a kind of domain-specific language.\nHistorically, metaclasses have been used to accomplish a variety of tasks that are now\npossible through other means. The __init_subclass__() method, in particular, can be\nused to address a wide variety of use cases where metaclasses were once applied. This\nincludes registration of classes with a central registry, automatic decoration of methods,\nand code generation.\n7.32\nBuilt-in Objects for Instances and\nClasses\nThis section gives some details about the low-level objects used to represent types and\ninstances. This information may be useful in low-level metaprogramming and code that\nneeds to directly manipulate types.\nTable 7.1 shows commonly used attributes of a type object cls.\nTable 7.1\nAttributes of Types\nAttribute\nDescription\ncls.__name__\nClass name\ncls.__module__\nModule name in which the class is defined\ncls.__qualname__\nFully qualified class name\ncls.__bases__\nTuple of base classes\ncls.__mro__\nMethod Resolution Order tuple\ncls.__dict__\nDictionary holding class methods and variables\ncls.__doc__\nDocumentation string\ncls.__annotations__\nDictionary of class type hints\ncls.__abstractmethods__\nSet of abstract method names (may be undefined if there\naren’t any).\nThe cls.__name__ attribute contains a short class name. The cls.__qualname__\nattribute contains a fully qualified name with additional information about the\nsurrounding context (this may be useful if a class is defined inside a function or if you\ncreate a nested class definition). The cls.__annotations__ dictionary contains class-level\ntype hints (if any).",
      "content_length": 1915,
      "extraction_method": "Direct"
    },
    {
      "page_number": 238,
      "chapter": null,
      "content": "7.33 Final Words: Keep It Simple\n223\nTable 7.2 shows special attributes of an instance i.\nTable 7.2\nInstance Attributes\nAttribute\nDescription\ni.__class__\nClass to which the instance belongs\ni.__dict__\nDictionary holding instance data (if defined)\nThe __dict__ attribute is normally where all of the data associated with an instance\nis stored. However, if a user-defined class uses __slots__, a more efficient internal\nrepresentation is used and instances will not have a __dict__ attribute.\n7.33\nFinal Words: Keep It Simple\nThis chapter has presented a lot of information about classes and the ways to customize\nand control them. However, when writing classes, keeping it simple is often the best\nstrategy. Yes, you could use abstract based classes, metaclasses, descriptors, class decorators,\nproperties, multiple inheritance, mixins, patterns, and type hints. However, you could also\njust write a plain class. There’s a pretty good chance that this class is good enough and that\neveryone will understand what it’s doing.\nIn the big picture, it’s useful to step back and consider a few generally desirable code\nqualities. First and foremost, readability counts for a lot—and it often suffers if you pile on\ntoo many layers of abstraction. Second, you should try to make code that is easy to observe\nand debug, and don’t forget about using the REPL. Finally, making code testable is often a\ngood driver for good design. If your code can’t be tested or testing is too awkward, there\nmay be a better way to organize your solution.",
      "content_length": 1528,
      "extraction_method": "Direct"
    },
    {
      "page_number": 239,
      "chapter": null,
      "content": "This page intentionally left blank",
      "content_length": 34,
      "extraction_method": "OCR"
    },
    {
      "page_number": 240,
      "chapter": null,
      "content": "8\nModules and Packages\nPython programs are organized into modules and packages that are loaded with the import\nstatement. This chapter describes the module and package system in more detail. The\nprimary focus is on programming with modules and packages, not the process of bundling\ncode for deployment to others. For the latter, consult the latest documentation at\nhttps://packaging.python.org/tutorials/packaging-projects/.\n8.1\nModules and the import Statement\nAny Python source file can be imported as a module. For example:\n# module.py\na = 37\ndef func():\nprint(f'func says that a is {a}')\nclass SomeClass:\ndef method(self):\nprint('method says hi')\nprint('loaded module')\nThis file contains common programming elements—including a global variable, a\nfunction, a class definition, and an isolated statement. This example illustrates some\nimportant (and sometimes subtle) features of module loading.\nTo load a module, use the statement import module. For example:\n>>> import module\nloaded module\n>>> module.a\n37",
      "content_length": 1011,
      "extraction_method": "Direct"
    },
    {
      "page_number": 241,
      "chapter": null,
      "content": "226\nChapter 8\nModules and Packages\n>>> module.func()\nfunc says that a is 37\n>>> s = module.SomeClass()\n>>> s.method()\nmethod says hi\n>>>\nIn executing an import, several things happen:\n1. The module source code is located. If it can’t be found, an ImportError exception is\nraised.\n2. A new module object is created. This object serves as a container for all of the global\ndefinitions contained within the module. It’s sometimes referred to as a namespace.\n3. The module source code is executed within the newly created module namespace.\n4. If no errors occur, a name is created within the caller that refers to the new module\nobject. This name matches the name of the module, but without any kind of\nfilename suffix. For example, if the code is found in a file module.py, the name of\nthe module is module.\nOf these steps, the first one (locating modules) is the most complicated. A common\nsource of failure for newcomers is using a bad filename or putting code in an unknown\nlocation. A module filename must use the same rules as variable names (letters, digits, and\nunderscore) and have a .py suffix—for example, module.py. When using import, you\nspecify the name without the suffix: import module, not import module.py (the latter\nproduces a rather confusing error message). The file needs to be placed in one of the\ndirectories found in sys.path.\nThe remaining steps are all related to a module defining an isolated environment for the\ncode. All definitions that appear in a module remain isolated to that module. Thus, there is\nno risk of the names of variables, functions, and classes clashing with identical names in\nother modules. When accessing definitions in a module, use a fully qualified name such as\nmodule.func().\nimport executes all of the statements in the loaded source file. If a module carries out\na computation or produces output in addition to defining objects, you will see the\nresult—such as the “loaded module” message printed in the example above. A common\nconfusion with modules concerns accessing classes. A module always defines a namespace,\nso if a file module.py defines a class SomeClass, use the name module.SomeClass to refer\nto the class.\nTo import multiple modules using a single import, use a comma-separated list of names:\nimport socket, os, re\nSometimes the local name used to refer to a module is changed using the as qualifier to\nimport. For example:\nimport module as mo\nmo.func()",
      "content_length": 2419,
      "extraction_method": "Direct"
    },
    {
      "page_number": 242,
      "chapter": null,
      "content": "8.2 Module Caching\n227\nThis latter style of import is standard practice in the data analysis world. For example,\nyou often see this:\nimport numpy as np\nimport pandas as pd\nimport matplotlib as plt\n...\nWhen a module is renamed, the new name only applies to the context where the\nimport statement appeared. Other unrelated program modules can still load the module\nusing its original name.\nAssigning a different name to an imported module can be a useful tool for managing\ndifferent implementations of common functionality or for writing extensible programs.\nFor example, if you have two modules unixmodule.py and winmodule.py that both define\na function func() but involve platform-dependent implementation details, you could\nwrite code to selectively import the module:\nif platform == 'unix':\nimport unixmodule as module\nelif platform == 'windows':\nimport winmodule as module\n...\nr = module.func()\nModules are first-class objects in Python. This means they can be assigned to variables,\nplaced in data structures, and passed around in a program as data. For instance, the module\nname in the above example is a variable that refers to the corresponding module object.\n8.2\nModule Caching\nThe source code for a module is loaded and executed only once, regardless of how often\nyou use the import statement. Subsequent import statements bind the module name to\nthe module object already created by the previous import.\nA common confusion for newcomers arises when a module is imported into an\ninteractive session, then its source code is modified (for example, to fix a bug) but a new\nimport fails to load the modified code. The module cache is to blame for this. Python will\nnever reload a previously imported module even if the underlying source code has been\nupdated.\nYou can find the cache of all currently loaded modules in sys.modules, which is a\ndictionary that maps module names to module objects. The contents of this dictionary are\nused to determine whether import loads a fresh copy of a module or not. Deleting a\nmodule from the cache will force it to load again on the next import statement. However,\nthis is rarely safe for reasons explained in Section 8.5 on module reloading.",
      "content_length": 2186,
      "extraction_method": "Direct"
    },
    {
      "page_number": 243,
      "chapter": null,
      "content": "228\nChapter 8\nModules and Packages\nSometimes you will see import used inside a function like this:\ndef f(x):\nimport math\nreturn math.sin(x) + math.cos(x)\nAt first glance, it seems like such an implementation would be horribly slow—loading\na module on each invocation. In reality, the cost of the import is minimal—it’s just a\nsingle dictionary lookup, as Python immediately finds the module in the cache. The main\nobjection to having the import inside a function is one of style—it’s more common to\nhave all module imports listed at the top of a file where they’re easy to see. On the other\nhand, if you have a specialized function that’s rarely invoked, putting the function’s import\ndependencies inside the function body can speed up program loading. In this case, you’d\nonly load the required modules if they are actually needed.\n8.3\nImporting Selected Names from a\nModule\nYou can load specific definitions from a module into the current namespace using the from\nmodule import name statement. It’s identical to import except that, instead of creating a\nname referring to the newly created module namespace, it places references to one or\nmore of the objects defined in the module into the current namespace:\nfrom module import func\n# Imports module and puts func in current namespace\nfunc()\n# Calls func() defined in module\nmodule.func()\n# Fails. NameError: module\nThe from statement accepts comma-separated names if you want multiple definitions.\nFor example:\nfrom module import func, SomeClass\nSemantically, the statement from module import name performs a name copy from the\nmodule cache to the local namespace. That is, Python first executes import module\nbehind the scenes. Afterwards, it makes an assignment from the cache to a local name, such\nas name = sys.modules['module'].name.\nA common misconception is that the from module import name statement is more\nefficient—possibly only loading part of a module. This is not the case. Either way, the\nentire module is loaded and stored in the cache.\nImporting functions using the from syntax does not change their scoping rules. When\nfunctions look for variables, they only look within the file where the function was defined,\nnot the namespace into which a function is imported and called. For example:\n>>> from module import func\n>>> a = 42",
      "content_length": 2298,
      "extraction_method": "Direct"
    },
    {
      "page_number": 244,
      "chapter": null,
      "content": "8.3 Importing Selected Names from a Module\n229\n>>> func()\nfunc says that a is 37\n>>> func.__module__\n'module'\n>>> func.__globals__['a']\n37\n>>>\nA related confusion concerns the behavior of global variables. For example, consider\nthis code that imports both func and a global variable a that it uses:\nfrom module import a, func\na = 42\n# Modify the variable\nfunc()\n# Prints \"func says a is 37\"\nprint(a)\n# Prints \"42\"\nVariable assignment in Python is not a storage operation. That is, the name a in this\nexample does not represent some kind of box where a value gets stored. The initial import\nassociates the local name a with the original object module.a. However, the later\nreassignment a = 42 moves the local name a to a completely different object. At this\npoint, a is no longer bound to the value in the imported module. Because of this, it is not\npossible to use the from statement in a way that makes variables behave like global variables\nin a language such as C. If you want to have mutable global parameters in your program,\nput them in a module and use the module name explicitly using the import statement—\nfor example, module.a.\nThe asterisk (*) wildcard character is sometimes used to load all the definitions in a\nmodule, except those that start with an underscore. Here’s an example:\n# Load all definitions into the current namespace\nfrom module import *\nThe from module import * statement may only be used at the top-level scope of a\nmodule. In particular, it is illegal to use this form of import inside a function body.\nModules can precisely control the set of names imported by from module import * by\ndefining the list __all__. Here’s an example:\n# module: module.py\n__all__ = [ 'func', 'SomeClass' ]\na = 37\n# Not exported\ndef func():\n# Exported\n...\nclass SomeClass:\n# Exported\n...",
      "content_length": 1798,
      "extraction_method": "Direct"
    },
    {
      "page_number": 245,
      "chapter": null,
      "content": "230\nChapter 8\nModules and Packages\nWhen at the interactive Python prompt, using from module import * can be a\nconvenient way to work with a module. However, using this style of import in a program\nis frowned upon. Overuse can pollute the local namespace and lead to confusion. For\nexample:\nfrom math import *\nfrom random import *\nfrom statistics import *\na = gauss(1.0, 0.25)\n# From which module?\nIt’s usually better to be explicit about names:\nfrom math import sin, cos, sqrt\nfrom random import gauss\nfrom statistics import mean\na = gauss(1.0, 0.25)\n8.4\nCircular Imports\nA peculiar problem arises if two modules mutually import each other. For example,\nsuppose you had two files:\n# ----------------------------\n# moda.py\nimport modb\ndef func_a():\nmodb.func_b()\nclass Base:\npass\n# ----------------------------\n# modb.py\nimport moda\ndef func_b():\nprint('B')\nclass Child(moda.Base):\npass",
      "content_length": 885,
      "extraction_method": "Direct"
    },
    {
      "page_number": 246,
      "chapter": null,
      "content": "8.4 Circular Imports\n231\nThere is a strange import order dependency in this code. Using import modb first\nworks fine, but if you put import moda first, it blows up with an error about moda.Base\nbeing undefined.\nTo understand what is happening, you have to follow the control flow. import moda\nstarts executing the file moda.py. The first statement it encounters is import modb. Thus,\ncontrol switches over to modb.py. The first statement in that file is import moda. Instead\nof entering a recursive cycle, that import is satisfied by the module cache and control\ncontinues on to the next statement in modb.py. This is good—circular imports don’t cause\nPython to deadlock or enter a new spacetime dimension. However, at this point in\nexecution, module moda has only been partially evaluated. When control reaches the class\nChild(moda.Base) statement, it blows up. The required Base class hasn’t been defined yet.\nOne way to fix this problem is to move the import modb statement someplace else. For\nexample, you could move the import into func_a() where the definition is actually\nneeded:\n# moda.py\ndef func_a():\nimport modb\nmodb.func_b()\nclass Base:\npass\nYou could also move the import to a later position in the file:\n# moda.py\ndef func_a():\nmodb.func_b()\nclass Base:\npass\nimport modb\n# Must be after Base is defined\nBoth of these solutions are likely to raise eyebrows in a code review. Most of the time,\nyou don’t see module imports appearing at the end of a file. The presence of circular\nimports almost always suggests a problem in code organization. A better way to handle this\nmight be to move the definition of Base to a separate file base.py and rewrite modb.py as\nfollows:\n# modb.py\nimport base",
      "content_length": 1703,
      "extraction_method": "Direct"
    },
    {
      "page_number": 247,
      "chapter": null,
      "content": "232\nChapter 8\nModules and Packages\ndef func_b():\nprint('B')\nclass Child(base.Base):\npass\n8.5\nModule Reloading and Unloading\nThere is no reliable support for reloading or unloading of previously imported modules.\nAlthough you can remove a module from sys.modules, this does not unload a module\nfrom memory. This is because references to the cached module object still exist in other\nmodules that imported that module. Moreover, if there are instances of classes defined in\nthe module, those instances contain references back to their class objects, which in turn\nhold references to the module in which they were defined.\nThe fact that module references exist in many places makes it generally impractical to\nreload a module after making changes to its implementation. For example, if you remove a\nmodule from sys.modules and use import to reload it, this will not retroactively change\nall of the previous references to the module used in a program. Instead, you’ll have one\nreference to the new module created by the most recent import statement, and a set of\nreferences to the old module created by imports in other parts of the code. This is rarely\nwhat you want. Module reloading is never safe to use in any kind of sane production code\nunless you are able to carefully control the entire execution environment.\nThere is a reload() function for reloading a module that can be found in the\nimportlib library. As an argument, you pass it the already loaded module. For example:\n>>> import module\n>>> import importlib\n>>> importlib.reload(module)\nloaded module\n<module 'module' from 'module.py'>\n>>>\nreload() works by loading a new version of the module source code and then\nexecuting it on top of the already existing module namespace. This is done without\nclearing the previous namespace. It’s literally the same as you typing new source code on\ntop of the old code without restarting the interpreter.\nIf other modules had previously imported the reloaded module using a standard import\nstatement, such as import module, reloading will make them see the updated code as if by\nmagic. However, there’s still a lot of peril. First, reloading doesn’t reload any of the\nmodules that might be imported by the reloaded file. It’s not recursive—it only applies to\nthe single module given to reload(). Second, if any module has used the from module\nimport name form of import, those imports fail to see the effect of the reload. Finally, if",
      "content_length": 2432,
      "extraction_method": "Direct"
    },
    {
      "page_number": 248,
      "chapter": null,
      "content": "8.6 Module Compilation\n233\ninstances of classes have been created, reloading does not update their underlying class\ndefinition. In fact, you’ll now have two different definitions of the same class in the same\nprogram—the old one that remains in use for all existing instances at the time of reloading,\nand the new one that gets used for new instances. This is almost always confusing.\nFinally, it should be noted that C/C++ extensions to Python cannot be safely unloaded\nor reloaded in any way. No support is provided for this, and the underlying operating\nsystem may prohibit it anyways. Your best recourse for that scenario is to restart the\nPython interpreter process.\n8.6\nModule Compilation\nWhen modules are first imported, they are compiled into an interpreter bytecode. This\ncode is written to a .pyc file within a special __pycache__ directory. This directory is\nusually found in the same directory as the original .py file. When the same import occurs\nagain on a different run of the program, the compiled bytecode is loaded instead. This\nsignificantly speeds up the import process.\nThe caching of bytecode is an automatic process that you almost never need to worry\nabout. Files are automatically regenerated if the original source code changes. It just works.\nThat said, there are still reasons to know about this caching and compilation process.\nFirst, sometimes Python files get installed (often accidentally) in an environment where\nusers don’t have operating system permissions to create the required __pycache__\ndirectory. Python will still work, but every import now loads the original source code and\ncompiles it to bytecode. Program loading will be a lot slower than it needs to be. Similarly,\nin deploying or packaging a Python application, it may be advantageous to include the\ncompiled bytecode, as that may significantly speed up program startup.\nThe other good reason to know about module caching is that some programming\ntechniques interfere with it. Advanced metaprogramming techniques involving dynamic\ncode generation and the exec() function defeat the benefits of bytecode caching. A\nnotable example is the use of dataclasses:\nfrom dataclasses import dataclass\n@dataclass\nclass Point:\nx: float\ny: float\nDataclasses work by generating method functions as text fragments and executing\nthem using exec(). None of this generated code is cached by the import system. For a\nsingle class definition, you won’t notice. However, if you have a module consisting of\n100 dataclasses, you might find that it imports nearly 20 times slower than a comparable\nmodule where you just wrote out the classes in the normal, if less compact, way.",
      "content_length": 2652,
      "extraction_method": "Direct"
    },
    {
      "page_number": 249,
      "chapter": null,
      "content": "234\nChapter 8\nModules and Packages\n8.7\nThe Module Search Path\nWhen importing modules, the interpreter searches the list of directories in sys.path. The\nfirst entry in sys.path is often an empty string '', which refers to the current working\ndirectory. Alternatively, if you run a script, the first entry in sys.path is the directory in\nwhich the script is located. The other entries in sys.path usually consist of a mix of\ndirectory names and .zip archive files. The order in which entries are listed in sys.path\ndetermines the search order used when importing modules. To add new entries to the\nsearch path, add them to this list. This can be done directly or by setting the PYTHONPATH\nenvironment variable. For example, on UNIX:\nbash $ env PYTHONPATH=/some/path python3 script.py\nZIP archive files are a convenient way to bundle a collection of modules into a single\nfile. For example, suppose you created two modules, foo.py and bar.py, and placed them\nin a file mymodules.zip. The file could be added to the Python search path as follows:\nimport sys\nsys.path.append('mymodules.zip')\nimport foo, bar\nSpecific locations within the directory structure of a .zip file can also be used for the\npath. In addition, .zip files can be mixed with regular pathname components. Here’s an\nexample:\nsys.path.append('/tmp/modules.zip/lib/python')\nIt is not necessary for a ZIP file to have a .zip file suffix to be used. Historically, it has\nbeen common to encounter .egg files on the path as well. .egg files originate from an\nearly Python package management tool called setuptools. However, an .egg file is\nnothing more than a normal .zip file or directory with some extra metadata added to it\n(version number, dependencies, and so on).\n8.8\nExecution as the Main Program\nAlthough this section is about the import statement, Python files are often executed as a\nmain script. For example:\n% python3 module.py\nEach module contains a variable, __name__, that holds the module name. Code can\nexamine this variable to determine the module in which they’re executing. The top-level\nmodule of the interpreter is named __main__. Programs specified on the command line\nor entered interactively run inside the __main__ module. Sometimes a program may alter\nits behavior, depending on whether it has been imported as a module or is running in\n__main__. For example, a module may include code that is executed if the module is used",
      "content_length": 2409,
      "extraction_method": "Direct"
    },
    {
      "page_number": 250,
      "chapter": null,
      "content": "8.9 Packages\n235\nas the main program but not executed if the module is simply imported by another\nmodule.\n# Check if running as a program\nif __name__ == '__main__':\n# Yes. Running as the main script\nstatements\nelse:\n# No, I must have been imported as a module\nstatements\nSource files intended for use as libraries can use this technique to include optional\ntesting or example code. When developing a module, you can put debugging code for\ntesting the features of your library inside an if statement as shown, and run Python on\nyour module as the main program. That code won’t run for users who import your library.\nIf you’ve made a directory of Python code, you can execute the directory if it contains a\nspecial __main__.py file. For example, if you make a directory like this:\nmyapp/\nfoo.py\nbar.py\n__main__.py\nYou can run Python on it by typing python3 myapp. Execution will start in the\n__main__.py file. This also works if you turn the myapp directory into a ZIP archive.\nTyping python3 myapp.zip will look for a top-level __main__.py file and execute it if\nfound.\n8.9\nPackages\nFor anything but the simplest programs, Python code is organized into packages. A package\nis a collection of modules that are grouped under a common top-level name. This\ngrouping helps resolve conflicts between the module names used in different applications\nand keeps your code separate from everyone else’s code. A package is defined by creating\na directory with a distinctive name and placing an initially empty __init__.py file in that\ndirectory. You then place additional Python files and subpackages in this directory as\nneeded. For example, a package might be organized as follows:\ngraphics/\n__init__.py\nprimitive/\n__init__.py\nlines.py\nfill.py\ntext.py",
      "content_length": 1740,
      "extraction_method": "Direct"
    },
    {
      "page_number": 251,
      "chapter": null,
      "content": "236\nChapter 8\nModules and Packages\n...\ngraph2d/\n__init__.py\nplot2d.py\n...\ngraph3d/\n__init__.py\nplot3d.py\n...\nformats/\n__init__.py\ngif.py\npng.py\ntiff.py\njpeg.py\nThe import statement is used to load modules from a package the same way as it’s used\nfor simple modules, except that you now have longer names. For example:\n# Full path\nimport graphics.primitive.fill\n...\ngraphics.primitive.fill.floodfill(img, x, y, color)\n# Load a specific submodule\nfrom graphics.primitive import fill\n...\nfill.floodfill(img, x, y, color)\n# Load a specific function from a submodule\nfrom graphics.primitive.fill import floodfill\n...\nfloodfill(img, x, y, color)\nWhenever any part of a package is first imported, code in the __init__.py file executes\nfirst (if it exists). As noted, this file may be empty, but it can also contain code to perform\npackage-specific initializations. If importing a deeply nested submodule, all __init__.py\nfiles encountered in traversal of the directory structure are executed. Thus, the statement\nimport graphics.primitive.fill would first execute the __init__.py file in the\ngraphics/ directory followed by the __init__.py file in the primitive/ directory.\nAstute Python users might observe that a package still seems to work if __init__.py\nfiles are omitted. This is true—you can use a directory of Python code as a package even if\nit contains no __init__.py. However, what’s not obvious is that a directory with a missing\n__init__.py file actually defines a different kind of package known as namespace package.\nThis is an advanced feature sometimes used by very large libraries and frameworks to",
      "content_length": 1608,
      "extraction_method": "Direct"
    },
    {
      "page_number": 252,
      "chapter": null,
      "content": "8.10 Imports Within a Package\n237\nimplement broken plugin systems. In the opinion of the author, this is rarely what you\nwant—you should always create proper __init__.py files when creating a package.\n8.10\nImports Within a Package\nA critical feature of the import statement is that all module imports require an absolute or\nfully qualified package path. This includes import statements used within a package itself.\nFor example, suppose the graphics.primitive.fill module wants to import the\ngraphics.primitive.lines module. A simple statement such as import lines won’t\nwork—you’ll get an ImportError exception. Instead, you need to fully qualify the import\nlike this:\n# graphics/primitives/fill.py\n# Fully qualified submodule import\nfrom graphics.primitives import lines\nSadly, writing out a full package name like that is both annoying and fragile. For\nexample, sometimes it makes sense to rename a package—maybe you want to rename it so\nthat you can use different versions. If the package name is hardwired into the code, you\ncan’t do that. A better choice is to use a package-relative import like this:\n# graphics/primitives/fill.py\n# Package-relative import\nfrom . import lines\nHere, the . used in the statement from . import lines refers to the same directory\nas the importing module. Thus, this statement looks for a module lines in the same\ndirectory as the file fill.py.\nRelative imports can also specify submodules contained in different directories of the\nsame package. For example, if the module graphics.graph2d.plot2d wants to import\ngraphics.primitive.lines, it may use a statement like this:\n# graphics/graph2d/plot2d.py\nfrom ..primitive import lines\nHere, the .. moves up one directory level and primitive drops down into a different\nsubpackage directory.\nRelative imports can only be specified using the from module import symbol form of\nthe import statement. Thus, statements such as import ..primitive.lines or import\n.lines are a syntax error. Also, symbol has to be a simple identifier, so a statement such as\nfrom .. import primitive.lines is also illegal. Finally, relative imports can only be used\nfrom within a package; it is illegal to use a relative import to refer to modules that are\nsimply located in a different directory on the filesystem.",
      "content_length": 2273,
      "extraction_method": "Direct"
    },
    {
      "page_number": 253,
      "chapter": null,
      "content": "238\nChapter 8\nModules and Packages\n8.11\nRunning a Package Submodule as a\nScript\nCode that’s organized into a package has a different runtime environment than a simple\nscript. There is an enclosing package name, submodules, and the use of relative imports\n(which only work inside a package). One feature that no longer works is the ability to run\nPython directly on a package source file. For example, suppose you are working on the\ngraphics/graph2d/plot2d.py file and add some testing code at the bottom:\n# graphics/graph2d/plot2d.py\nfrom ..primitive import lines, text\nclass Plot2D:\n...\nif __name__ == '__main__':\nprint('Testing Plot2D')\np = Plot2D()\n...\nIf you try to run it directly, you get a crash complaining about relative import\nstatements:\nbash $ python3 graphics/graph2d/plot2d.py\nTraceback (most recent call last):\nFile \"graphics/graph2d/plot2d.py\", line 1, in <module>\nfrom ..primitive import line, text\nValueError: attempted relative import beyond top-level package\nbash $\nYou can’t move into the package directory and run it there either:\nbash $ cd graphics/graph2d/\nbash $ python3 plot2d.py\nTraceback (most recent call last):\nFile \"plot2d.py\", line 1, in <module>\nfrom ..primitive import line, text\nValueError: attempted relative import beyond top-level package\nbash $\nTo run a submodule as a main script, you need to use the -m option to the interpreter.\nFor example:\nbash $ python3 -m graphics.graph2d.plot2d\nTesting Plot2D\nbash $",
      "content_length": 1447,
      "extraction_method": "Direct"
    },
    {
      "page_number": 254,
      "chapter": null,
      "content": "8.12 Controlling the Package Namespace\n239\n-m specifies a module or package as the main program. Python will run the module\nwith the proper environment to make sure that imports work. Many of Python’s built-in\npackages have “secret” features that can be used via -m. One of the most well-known is\nusing python3 -m http.server to run a web server from the current directory.\nYou can provide similar functionality with your own packages. If the name supplied to\npython -m name corresponds to a package directory, Python looks for the presence of a\n__main__.py in that directory and runs that as the script.\n8.12\nControlling the Package Namespace\nThe primary purpose of a package is to serve as a top-level container for code. Sometimes\nusers will import the top-level name and nothing else. For example:\nimport graphics\nThis import doesn’t specify any particular submodule. Nor does it make any other part\nof the package accessible. For example, you’ll find that code like this fails:\nimport graphics\ngraphics.primitive.fill.floodfill(img,x,y,color)\n# Fails!\nWhen only a top-level package import is given, the only file that imports is the\nassociated __init__.py file. In this example, it’s the file graphics/__init__.py file.\nThe primary purpose of an __init__.py file is to build and/or manage the contents of\nthe top-level package namespace. Often, this involves importing selected functions, classes,\nand other objects from lower-level submodules. For example, if the graphics package\nin this example consists of hundreds of low-level functions but most of those details are\nencapsulated into a handful of high-level classes, then the __init__.py file might choose\nto expose just those classes:\n# graphics/__init__.py\nfrom .graph2d.plot2d import Plot2D\nfrom .graph3d.plot3d import Plot3D\nWith this __init__.py file, the names Plot2D and Plot3D would appear at the top level\nof the package. A user could then use those names as if graphics were a simple module:\nfrom graphics import Plot2D\nplt = Plot2D(100, 100)\nplt.clear()\n...\nThis is often much more convenient for the user because they don’t have to know how\nyou’ve actually organized your code. In some sense, you’re putting a higher layer of",
      "content_length": 2198,
      "extraction_method": "Direct"
    },
    {
      "page_number": 255,
      "chapter": null,
      "content": "240\nChapter 8\nModules and Packages\nabstraction on top of your code structure. Many of the modules in the Python standard\nlibrary are constructed in this manner. For example, the popular collections module is\nactually a package. The collections/__init__.py file consolidates definitions from a few\ndifferent places and presents them to the user as a single consolidated namespace.\n8.13\nControlling Package Exports\nOne issue concerns the interaction between an __init__.py file and low-level\nsubmodules. For example, the user of a package might only want to concern themselves\nwith objects and functions that live in the top-level package namespace. However, the\nimplementor of a package might be concerned with the problem of organizing code into\nmaintainable submodules.\nTo better manage this organizational complexity, package submodules often declare an\nexplicit list of exports by defining an __all__ variable. This is a list of names that should\nbe pushed up one level in the package namespace. For example:\n# graphics/graph2d/plot2d.py\n__all__ = ['Plot2D']\nclass Plot2D:\n...\nThe associated __init__.py file then imports its submodules using an * import like\nthis:\n# graphics/graph2d/__init__.py\n# Only loads names explicitly listed in __all__ variables\nfrom .plot2d import *\n# Propagate the __all__ up to next level (if desired)\n__all__ = plot2d.__all__\nThis lifting process then continues all the way to the top-level package __init__.py.\nFor example:\n# graphics/__init__.py\nfrom .graph2d import *\nfrom .graph3d import *\n# Consolidate exports\n__all__ = [\n*graph2d.__all__,",
      "content_length": 1578,
      "extraction_method": "Direct"
    },
    {
      "page_number": 256,
      "chapter": null,
      "content": "8.14 Package Data\n241\n*graph3d.__all__\n]\nThe gist is that every component of a package explicitly states its exports using the\n__all__ variable. The __init__.py files then propagate the exports upwards. In practice,\nit can get complicated, but this approach avoids the problem of hard-wiring specific export\nnames into the __init__.py file. Instead, if a submodule wants to export something, its\nname gets listed in just one place—the __all__ variable. Then, by magic, it propagates up\nto its proper place in the package namespace.\nIt is worth noting that although using * imports in user code is frowned upon, it is\nwidespread practice in package __init__.py files. The reason it works in packages is that\nit is usually much more controlled and contained—being driven by the contents of the\n__all__ variables and not a free-wheeling attitude of “let’s just import everything.”\n8.14\nPackage Data\nSometimes a package includes data files that need to be loaded (as opposed to source\ncode). Within a package, the __file__ variable will give you location information about a\nspecific source file. However, packages are complicated. They might be bundled within\nZIP archive files or loaded from unusual environments. The __file__ variable itself might\nbe unreliable or even undefined. As a result, loading a data file is often not a simple matter\nof passing a filename to the built-in open() function and reading some data.\nTo read package data, use pkgutil.get_data(package, resource). For example, is\nyour package looks like this:\nmycode/\nresources/\ndata.json\n__init__.py\nspam.py\nyow.py\nTo load the file data.json from the file spam.py, do this:\n# mycode/spam.py\nimport pkgutil\nimport json\ndef func():\nrawdata = pkgutil.get_data(__package__,\n'resources/data.json')\ntextdata = rawdata.decode('utf-8')\ndata = json.loads(textdata)\nprint(data)",
      "content_length": 1836,
      "extraction_method": "Direct"
    },
    {
      "page_number": 257,
      "chapter": null,
      "content": "242\nChapter 8\nModules and Packages\nThe get_data() function attempts to find the specified resource and returns its\ncontents as a raw byte string. The __package__ variable shown in the example is a string\nholding the name of the enclosing package. Any further decoding (such as converting\nbytes to text) and interpretation is up to you. In the example, the data is decoded and\nparsed from JSON into a Python dictionary.\nA package is not a good place to store giant data files. Reserve package resources for\nconfiguration data and other assorted bits of stuff needed to make your package work.\n8.15\nModule Objects\nModules are first-class objects. Table 8.1 lists attributes commonly found on modules.\nTable 8.1\nModule Attributes\nAttribute\nDescription\n__name__\nFull module name\n__doc__\nDocumentation string\n__dict__\nModule dictionary\n__file__\nFilename where defined\n__package__\nName of enclosing package (if any)\n__path__\nList of subdirectories to search for submodules of a package.\n__annotations__\nModule-level type hints\nThe __dict__ attribute is a dictionary that represents the module namespace.\nEverything that’s defined in the module is placed here.\nThe __name__ attribute is often used in scripts. A check such as if __name__ ==\n'__main__' is often done to see if a file is running as a standalone program.\nThe __package__ attribute contains the name of the enclosing package if any. If set,\nthe __path__ attribute is a list of directories that will be searched to locate package\nsubmodules. Normally, it contains a single entry with the directory in which a package is\nlocated. Sometimes large frameworks will manipulate __path__ to incorporate additional\ndirectories for the purpose of supporting plugins and other advanced features.\nNot all attributes are available on all modules. For example, built-in modules may not\nhave a __file__ attribute set. Similarly, package-related attributes are not set for top-level\nmodules (not contained in a package).\nThe __doc__ attribute is the module doc string (if any). This is a string that appears as\nthe first statement in a file. The __annotations__ attribute is a dictionary of module-level\ntype hints. These look something like this:\n# mymodule.py\n'''",
      "content_length": 2205,
      "extraction_method": "Direct"
    },
    {
      "page_number": 258,
      "chapter": null,
      "content": "8.16 Deploying Python Packages\n243\nThe doc string\n'''\n# Type hints\n(placed into __annotations__)\nx: int\ny: float\n...\nAs with other type hints, module-level hints change no part of Python’s behavior, nor\ndo they actually define variables. They are purely metadata that other tools can choose to\nlook at if they want.\n8.16\nDeploying Python Packages\nThe final frontier of modules and packages is the problem of giving your code to\nothers. This is a large topic that has been the focus of active ongoing development\nover many years. I won’t try to document a process that’s bound to be out-of-date by\nthe time you read this. Instead, direct your attention to the documentation at\nhttps://packaging.python.org/tutorials/packaging-projects.\nFor the purposes of day-to-day development, the most important thing is to keep your\ncode isolated as a self-contained project. All of your code should live in a proper package.\nTry to give your package a unique name so that it doesn’t conflict with other possible\ndependencies. Consult the Python package index at https://pypi.org to pick a name. In\nstructuring your code, try to keep things simple. As you’ve seen, there are many highly\nsophisticated things that can be done with the module and package system. There is a time\nand place for that, but it should not be your starting point.\nWith absolute simplicity in mind, the most minimalistic way to distribute pure Python\ncode is to use the setuptools module or the built-in distutils module. Suppose you\nhave written some code and it’s in a project that looks like this:\nspam-project/\nREADME.txt\nDocumentation.txt\nspam/\n# A package of code\n__init__.py\nfoo.py\nbar.py\nrunspam.py\n# A script to run as: python runspam.py\nTo create a distribution, create a file setup.py in the topmost directory\n(spam-project/ in this example). In this file, put the following code:\n# setup.py\nfrom setuptools import setup\nsetup(name=\"spam\",",
      "content_length": 1911,
      "extraction_method": "Direct"
    },
    {
      "page_number": 259,
      "chapter": null,
      "content": "244\nChapter 8\nModules and Packages\nversion=\"0.0\"\npackages=['spam'],\nscripts=['runspam.py'],\n)\nIn the setup() call, packages is a list of all package directories, and scripts is a\nlist of script files. Any of these arguments may be omitted if your software does not\nhave them (for example, if there are no scripts). name is the name of your package, and\nversion is the version number as a string. The call to setup() supports a variety of\nother parameters that supply various metadata about your package. See the full list at\nhttps://docs.python.org/3/distutils/apiref.html.\nCreating a setup.py file is enough to create a source distribution of your software.\nType the following shell command to make a source distribution:\nbash $ python setup.py sdist\n...\nbash $\nThis creates an archive file, such as spam-1.0.tar.gz or spam-1.0.zip, in the directory\nspam/dist. This is the file you would give to others to install your software. To install, a\nuser can use a command such as pip. For example:\nshell $ python3 -m pip install spam-1.0.tar.gz\nThis installs the software into the local Python distribution and makes it available for\ngeneral use. The code will normally be installed into a directory called site-packages\nin the Python library. To find the exact location of this directory, inspect the value of\nsys.path. Scripts are normally installed into the same directory as the Python interpreter\nitself.\nIf the first line of a script starts with #! and contains the text python, the installer will\nrewrite the line to point to the local installation of Python. Thus, if your scripts have been\nhardcoded to a specific Python location, such as /usr/local/bin/python, they should still\nwork when installed on other systems where Python is in a different location.\nIt must be stressed that the use of setuptools as described here is absolutely minimal.\nLarger projects may involve C/C++ extensions, complicated package structures, examples,\nand more. Covering all of the tools and possible ways to deploy such code is beyond the\nscope of this book. You should consult various resources on https://python.org and\nhttps://pypi.org for the most up-to-date advice.\n8.17\nThe Penultimate Word: Start with a\nPackage\nWhen first starting a new program, it is easy to start with a simple single Python file. For\nexample, you might write a script called program.py and start with that. Although this\nwill work fine for throwaway programs and short tasks, your “script” may start growing",
      "content_length": 2472,
      "extraction_method": "Direct"
    },
    {
      "page_number": 260,
      "chapter": null,
      "content": "8.18 The Final Word: Keep It Simple\n245\nand adding features. Eventually, you might want to split it into multiple files. It’s at that\npoint that problems often arise.\nIn light of this, it makes sense to get in the habit of starting all programs as a package\nfrom the onset. For example, instead of making a file called program.py, you should make\na program package directory called program:\nprogram/\n__init__.py\n__main__.py\nPut your starting code in __main__.py and run your program using a command such\nas python -m program. As you need more code, add new files to your package and use\npackage-relative imports. An advantage of using a package is that all of your code remains\nisolated. You can name the files whatever you want and not worry about collisions with\nother packages, standard library modules, or code written by your coworkers. Although\nsetting up a package requires a bit more work at the start, it will likely save you a lot of\nheadaches later.\n8.18\nThe Final Word: Keep It Simple\nThere is a lot of more advanced wizardry associated with the module and package system\nthan what has been shown here. Consult the tutorial “Modules and Packages: Live and\nLet Die!” at https://dabeaz.com/modulepackage/index.html to get an idea of what’s\npossible.\nAll things considered, however, you’re probably better off not doing any advanced\nmodule hacking. Managing modules, packages, and software distribution has always been\na source of pain in the Python community. Much of the pain is a direct consequence of\npeople applying hacks to the module system. Don’t do that. Keep it simple and find the\npower to just say “no” when your coworkers propose to modify import to work with\nthe blockchain.",
      "content_length": 1697,
      "extraction_method": "Direct"
    },
    {
      "page_number": 261,
      "chapter": null,
      "content": "This page intentionally left blank",
      "content_length": 34,
      "extraction_method": "OCR"
    },
    {
      "page_number": 262,
      "chapter": null,
      "content": "9\nInput and Output\nInput and output (I/O) is part of all programs. This chapter describes the essentials of\nPython I/O including data encoding, command-line options, environment variables, file\nI/O, and data serialization. Particular attention is given to programming techniques and\nabstractions that encourage proper I/O handling. The end of this chapter gives an\noverview of common standard library modules related to I/O.\n9.1\nData Representation\nThe main problem of I/O is the outside world. To communicate with it, data must be\nproperly represented, so that it can be manipulated. At the lowest level, Python works with\ntwo fundamental datatypes: bytes that represent raw uninterpreted data of any kind and text\nthat represents Unicode characters.\nTo represent bytes, two built-in types are used, bytes and bytearray. bytes is an\nimmutable string of integer byte values. bytearray is a mutable byte array that behaves as\na combination of a byte string and a list. Its mutability makes it suitable for building up\ngroups of bytes in a more incremental manner, as when assembling data from fragments.\nThe following example illustrates a few features of bytes and bytearray:\n# Specify a bytes literal (note the b' prefix)\na = b'hello'\n# Specify bytes from a list of integers\nb = bytes([0x68, 0x65, 0x6c, 0x6c, 0x6f])\n# Create and populate a bytearray from parts\nc = bytearray()\nc.extend(b'world')\n# c = bytearray(b'world')\nc.append(0x21)\n# c = bytearray(b'world!')\n# Access byte values\nprint(a[0])\n# --> prints 104",
      "content_length": 1515,
      "extraction_method": "Direct"
    },
    {
      "page_number": 263,
      "chapter": null,
      "content": "248\nChapter 9\nInput and Output\nfor x in b:\n# Outputs 104 101 108 108 111\nprint(x)\nAccessing individual elements of byte and bytearray objects produces integer byte\nvalues, not single-character byte strings. This is different from text strings, so it is a\ncommon usage error.\nText is represented by the str datatype and stored as an array of Unicode code points.\nFor example:\nd = 'hello'\n# Text (Unicode)\nlen(d)\n# --> 5\nprint(d[0])\n# prints 'h'\nPython maintains a strict separation between bytes and text. There is never automatic\nconversion between the two types, comparisons between these types evaluate as False,\nand any operation that mixes bytes and text together results in an error. For example:\na = b'hello'\n# bytes\nb = 'hello'\n# text\nc = 'world'\n# text\nprint(a == b)\n# -> False\nd = a + c\n# TypeError: can't concat str to bytes\ne = b + c\n# -> 'helloworld' (both are strings)\nWhen performing I/O, make sure you’re working with the right kind of data\nrepresentation. If you are manipulating text, use text strings. If you are manipulating binary\ndata, use bytes.\n9.2\nText Encoding and Decoding\nIf you work with text, all data read from input must be decoded and all data written to\noutput must be encoded. For explicit conversion between text and bytes, there are\nencode(text [,errors]) and decode(bytes [,errors]) methods on text and bytes\nobjects, respectively. For example:\na = 'hello'\n# Text\nb = a.encode('utf-8')\n# Encode to bytes\nc = b'world'\n# Bytes\nd = c.decode('utf-8')\n# Decode to text\nBoth encode() and decode() require the name of an encoding such as 'utf-8' or\n'latin-1'. The encodings in Table 9.1 are common.",
      "content_length": 1628,
      "extraction_method": "Direct"
    },
    {
      "page_number": 264,
      "chapter": null,
      "content": "9.2 Text Encoding and Decoding\n249\nTable 9.1\nCommon Encodings\nEncoding Name\nDescription\n'ascii'\nCharacter values in the range [0x00, 0x7f].\n'latin1'\nCharacter values in the range [0x00, 0xff]. Also known as\n'iso-8859-1'.\n'utf-8'\nVariable-length encoding that allows all Unicode characters to be\nrepresented.\n'cp1252'\nA common text encoding on Windows.\n'macroman'\nA common text encoding on Macintosh.\nAdditionally, the encoding methods accept an optional errors argument that specifies\nbehavior in the presence of encoding errors. It is one of the values in Table 9.2.\nTable 9.2\nError-Handling Options\nValue\nDescription\n'strict'\nRaises a UnicodeError exception for encoding and decoding\nerrors (the default).\n'ignore'\nIgnores invalid characters.\n'replace'\nReplaces invalid characters with a replacement character (U+FFFD\nin Unicode, b'?' in bytes).\n'backslashreplace'\nReplaces each invalid character with a Python character escape\nsequence. For example, the character U+1234 is replaced by\n'\\u1234' (encoding only).\n'xmlcharrefreplace'\nReplaces each invalid character with an XML character reference.\nFor example, the character U+1234 is replaced by '&#4660;'\n(encoding only).\n'surrogateescape'\nReplaces any invalid byte '\\xhh' with U+DChh on decoding,\nreplaces U+DChh with byte '\\xhh' on encoding.\nThe 'backslashreplace' and 'xmlcharrefreplace' error policies represent\nunrepresentable characters in a form that allows them to be viewed as simple ASCII text or\nas XML character references. This can be useful for debugging.\nThe 'surrogateescape' error handling policy allows degenerate byte data—data that\ndoes not follow the expected encoding rules—to survive a roundtrip decoding/encoding\ncycle intact regardless of the text encoding being used. Specifically, s.decode(enc,\n'surrogateescape').encode(enc, 'surrogateescape') == s. This round-trip\npreservation of data is useful for certain kinds of system interfaces where a text encoding is\nexpected but can’t be guaranteed due to issues outside of Python’s control. Instead of\ndestroying data with a bad encoding, Python embeds it “as is” using surrogate encoding.\nHere’s an example of this behavior with a improperly encoded UTF-8 string:",
      "content_length": 2192,
      "extraction_method": "Direct"
    },
    {
      "page_number": 265,
      "chapter": null,
      "content": "250\nChapter 9\nInput and Output\n>>> a = b'Spicy Jalape\\xf1o'\n# Invalid UTF-8\n>>> a.decode('utf-8')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1\nin position 12: invalid continuation byte\n>>> a.decode('utf-8', 'surrogateescape')\n'Spicy Jalape\\udcf1o'\n>>> # Encode the resulting string back into bytes\n>>> _.encode('utf-8', 'surrogateescape')\nb'Spicy Jalape\\xf1o'\n>>>\n9.3\nText and Byte Formatting\nA common problem when working with text and byte strings is string conversions and\nformatting—for example, converting a floating-point number to a string with a given\nwidth and precision. To format a single value, use the format() function:\nx = 123.456\nformat(x, '0.2f')\n# '123.46'\nformat(x, '10.4f')\n# '\n123.4560'\nformat(x, '<*10.2f')\n# '123.46****'\nThe second argument to format() is a format specifier. The general format of the\nspecifier is [[fill[align]][sign][0][width][,][.precision][type] where each part\nenclosed in [] is optional. The width specifies the minimum field width to use, and the\nalign specifier is one of <, >, or ^ for left, right, and centered alignment within the field.\nAn optional fill character fill is used to pad the space. For example:\nname = 'Elwood'\nr = format(name, '<10')\n# r = 'Elwood\n'\nr = format(name, '>10')\n# r = '\nElwood'\nr = format(name, '^10')\n# r = '\nElwood\n'\nr = format(name, '*^10')\n# r = '**Elwood**'\nThe type specifier indicates the type of data. Table 9.3 lists the supported format codes.\nIf not supplied, the default format code is s for strings, d for integers, and f for floats.\nThe sign part of a format specifier is one of +, -, or a space. A + indicates that a leading\nsign should be used on all numbers. A - is the default and only adds a sign character for\nnegative numbers. A space adds a leading space to positive numbers.\nAn optional comma (,) may appear between the width and the precision. This adds a\nthousands separator character. For example:",
      "content_length": 1984,
      "extraction_method": "Direct"
    },
    {
      "page_number": 266,
      "chapter": null,
      "content": "9.3 Text and Byte Formatting\n251\nTable 9.3\nFormat Codes\nCharacter\nOutput Format\nd\nDecimal integer or long integer.\nb\nBinary integer or long integer.\no\nOctal integer or long integer.\nx\nHexadecimal integer or long integer.\nX\nHexadecimal integer (uppercase letters).\nf, F\nFloating point as [-]m.dddddd.\ne\nFloating point as [-]m.dddddde±xx.\nE\nFloating point as [-]m.ddddddE±xx.\ng, G\nUse e or E for exponents less than [nd]4 or greater than the precision; otherwise\nuse f.\nn\nSame as g except that the current locale setting determines the decimal point\ncharacter.\n%\nMultiplies a number by 100 and displays it using f format followed by a % sign.\ns\nString or any object. The formatting code uses str() to generate strings.\nc\nSingle character.\nx = 123456.78\nformat(x, '16,.2f')\n# '\n123,456.78'\nThe precision part of the specifier supplies the number of digits of accuracy to use for\ndecimals. If a leading 0 is added to the field width for numbers, numeric values are padded\nwith leading 0s to fill the space. Here are some examples of formatting different kinds of\nnumbers:\nx = 42\nr = format(x, '10d')\n# r = '\n42'\nr = format(x, '10x')\n# r = '\n2a'\nr = format(x, '10b')\n# r = '\n101010'\nr = format(x, '010b')\n# r = '0000101010'\ny = 3.1415926\nr = format(y, '10.2f')\n# r = '\n3.14'\nr = format(y, '10.2e')\n# r = '\n3.14e+00'\nr = format(y, '+10.2f')\n# r = '\n+3.14'\nr = format(y, '+010.2f')\n# r = '+000003.14'\nr = format(y, '+10.2%')\n# r = '\n+314.16%'\nFor more complex string formatting, you can use f-strings:\nx = 123.456",
      "content_length": 1506,
      "extraction_method": "Direct"
    },
    {
      "page_number": 267,
      "chapter": null,
      "content": "252\nChapter 9\nInput and Output\nf'Value is {x:0.2f}'\n#\n'Value is 123.46'\nf'Value is {x:10.4f}'\n#\n'Value is\n123.4560'\nf'Value is {2*x:*<10.2f}'\n#\n'Value is 246.91****'\nWithin an f-string, text of the form {expr:spec} is replaced by the value of\nformat(expr, spec). expr can be an arbitrary expression as long as it doesn’t include {, },\nor \\ characters. Parts of the format specifier itself can optionally be supplied by other\nexpressions. For example:\ny = 3.1415926\nwidth = 8\nprecision=3\nr = f'{y:{width}.{precision}f}'\n# r = '\n3.142'\nIf you end expr by =, then the literal text of expr is also included in the result. For\nexample:\nx = 123.456\nf'{x=:0.2f}'\n# 'x=123.46'\nf'{2*x=:0.2f}'\n# '2*x=246.91'\nIf you append !r to a value, formatting is applied to the output of repr(). If you use\n!s, formatting is applied to the output of str(). For example:\nf'{x!r:spec}'\n# Calls (repr(x).__format__('spec'))\nf'{x!s:spec}'\n# Calls (str(x).__format__('spec'))\nAs an alternative to f-strings, you can use the .format() method of strings:\nx = 123.456\n'Value is {:0.2f}'.format(x)\n# 'Value is 123.46'\n'Value is {0:10.2f}'.format(x)\n# 'Value is\n123.4560'\n'Value is {val:<*10.2f}'.format(val=x)\n# 'Value is 123.46****'\nWith a string formatted by .format(), text of the form {arg:spec} is replaced by the\nvalue of format(arg, spec). In this case, arg refers to one of the arguments given to\nthe format() method. If omitted entirely, the arguments are taken in order. For example:\nname = 'IBM'\nshares = 50\nprice = 490.1\nr = '{:>10s} {:10d} {:10.2f}'.format(name, shares, price)\n# r = '\nIBM\n50\n490.10'\narg can also refer to a specific argument number or name. For example:",
      "content_length": 1654,
      "extraction_method": "Direct"
    },
    {
      "page_number": 268,
      "chapter": null,
      "content": "9.3 Text and Byte Formatting\n253\ntag = 'p'\ntext = 'hello world'\nr = '<{0}>{1}</{0}>'.format(tag, text)\n# r = '<p>hello world</p>'\nr = '<{tag}>{text}</{tag}>'.format(tag='p', text='hello world')\nUnlike f-strings, the arg value of a specifier cannot be an arbitrary expression, so it’s not\nquite as expressive. However, the format() method can perform limited attribute lookup,\nindexing, and nested substitutions. For example:\ny = 3.1415926\nwidth = 8\nprecision=3\nr = 'Value is {0:{1}.{2}f}'.format(y, width, precision)\nd = {\n'name': 'IBM',\n'shares': 50,\n'price': 490.1\n}\nr = '{0[shares]:d} shares of {0[name]} at {0[price]:0.2f}'.format(d)\n# r = '50 shares of IBM at 490.10'\nbytes and bytearray instances can be formatted using the % operator. The semantics of\nthis operator are modeled after the sprintf() function from C. Here are some examples:\nname = b'ACME'\nx = 123.456\nb'Value is %0.2f' % x\n# b'The value is 123.46'\nbytearray(b'Value is %0.2f') % x\n# b'Value is 123.46'\nb'%s = %0.2f' % (name, x)\n# b'ACME = 123.46'\nWith this formatting, sequences of the form %spec are replaced in order with values\nfrom a tuple provided as the second operand to the % operator. The basic format codes (d,\nf, s, etc.) are the same as those used for the format() function. However, more advanced\nfeatures are either missing or changed slightly. For example, to adjust alignment, you use a\n- character like this:\nx = 123.456\nb'%10.2f' % x\n# b'\n123.46'\nb'%-10.2f' % x\n# b'123.46\n'\nUsing a format code of %r produces the output of ascii() which can be useful in\ndebugging and logging.",
      "content_length": 1567,
      "extraction_method": "Direct"
    },
    {
      "page_number": 269,
      "chapter": null,
      "content": "254\nChapter 9\nInput and Output\nWhen working with bytes, be aware that text strings are not supported. They need to\nbe explicitly encoded.\nname = 'Dave'\nb'Hello %s' % name\n# TypeError!\nb'Hello %s' % name.encode('utf-8')\n# Ok\nThis form of formatting can also be used with text strings, but it’s considered to be an\nolder programming style. However, it still arises in certain libraries. For example, messages\nproduced by the logging module are formatted in this way:\nimport logging\nlog = logging.getLogger(__name__)\nlog.debug('%s got %d', name, value)\n# '%s got %d' % (name, value)\nThe logging module is briefly described later in this chapter in Section 9.15.12.\n9.4\nReading Command-Line Options\nWhen Python starts, command-line options are placed in the list sys.argv as text strings.\nThe first item is the name of the program. Subsequent items are the options added on the\ncommand line after the program name. The following program is a minimal prototype of\nmanually processing command-line arguments:\ndef main(argv):\nif len(argv) != 3:\nraise SystemExit(\nf'Usage : python {argv[0]} inputfile outputfile\\n')\ninputfile\n= argv[1]\noutputfile = argv[2]\n...\nif __name__ == '__main__':\nimport sys\nmain(sys.argv)\nFor better code organization, testing, and similar reasons, it’s a good idea to write a\ndedicated main() function that accepts the command-line options (if any) as a list, as\nopposed to directly reading sys.argv. Include a small fragment of code at the end of your\nprogram to pass the command-line options to your main() function.",
      "content_length": 1536,
      "extraction_method": "Direct"
    },
    {
      "page_number": 270,
      "chapter": null,
      "content": "9.4 Reading Command-Line Options\n255\nsys.argv[0] contains the name of the script being executed. Writing a descriptive help\nmessage and raising SystemExit is standard practice for command-line scripts that want to\nreport an error.\nAlthough in simple scripts, you can manually process command options, consider using\nthe argparse module for more complicated command-line handling. Here is an example:\nimport argparse\ndef main(argv):\np = argparse.ArgumentParser(description=\"This is some program\")\n# A positional argument\np.add_argument(\"infile\")\n# An option taking an argument\np.add_argument(\"-o\",\"--output\", action=\"store\")\n# An option that sets a Boolean flag\np.add_argument(\"-d\",\"--debug\", action=\"store_true\", default=False)\n# Parse the command line\nargs = p.parse_args(args=argv)\n# Retrieve the option settings\ninfile\n= args.infile\noutput\n= args.output\ndebugmode = args.debug\nprint(infile, output, debugmode)\nif __name__ == '__main__':\nimport sys\nmain(sys.argv[1:])\nThis example only shows the most simple use of the argparse module. The standard\nlibrary documentation provides more advanced usage. There are also third-party modules\nsuch as click and docopt that can simplify writing of more complex command-line\nparsers.\nFinally, command-line options might be provided to Python in an invalid text encoding.\nSuch arguments are still accepted but they will be encoded using 'surrogateescape'\nerror handling as described in Section 9.2. You need to be aware of this if such arguments\nare later included in any kind of text output and it’s critical to avoid crashing. It might not\nbe critical, though—don’t overcomplicate your code for edge cases that don’t matter.",
      "content_length": 1668,
      "extraction_method": "Direct"
    },
    {
      "page_number": 271,
      "chapter": null,
      "content": "256\nChapter 9\nInput and Output\n9.5\nEnvironment Variables\nSometimes data is passed to a program via environment variables set in the command shell.\nFor example, a Python program might be launched using a shell command such as env:\nbash $ env SOMEVAR=somevalue python3 somescript.py\nEnvironment variables are accessed as text strings in the mapping os.environ. Here’s an\nexample:\nimport os\npath = os.environ['PATH']\nuser = os.environ['USER']\neditor = os.environ['EDITOR']\nval = os.environ['SOMEVAR']\n... etc. ...\nTo modify environment variables, set the os.environ variable. For example:\nos.environ['NAME'] = 'VALUE'\nModifications to os.environ affect both the running program and any subprocesses\ncreated later—for example, those created by the subprocess module.\nAs with command-line options, badly encoded environment variables may produce\nstrings that use the 'surrogateescape' error handling policy.\n9.6\nFiles and File Objects\nTo open a file, use the built-in open() function. Usually, open() is given a filename and a\nfile mode. It is also often used in combination with the with statement as a context\nmanager. Here are some common usage patterns of working with files:\n# Read a text file all at once as a string\nwith open('filename.txt', 'rt') as file:\ndata = file.read()\n# Read a file line-by-line\nwith open('filename.txt', 'rt') as file:\nfor line in file:\n...\n# Write to a text file\nwith open('out.txt', 'wt') as file:\nfile.write('Some output\\n')\nprint('More output', file=file)",
      "content_length": 1486,
      "extraction_method": "Direct"
    },
    {
      "page_number": 272,
      "chapter": null,
      "content": "9.6 Files and File Objects\n257\nIn most cases, using open() is a straightforward affair. You give it the name of the file\nyou want to open along with a file mode. For example:\nopen('name.txt')\n# Opens \"name.txt\" for reading\nopen('name.txt', 'rt')\n# Opens \"name.txt\" for reading (same)\nopen('name.txt', 'wt')\n# Opens \"name.txt\" for writing\nopen('data.bin', 'rb')\n# Binary mode read\nopen('data.bin', 'wb')\n# Binary mode write\nFor most programs, you will never need to know more than these simple examples to\nwork with files. However, there are a number of special cases and more esoteric features of\nopen() worth knowing. The next few sections discuss open() and file I/O in more detail.\n9.6.1\nFilenames\nTo open a file, you need to give open() the name of the file. The name can either be a\nfully specified absolute pathname such as '/Users/guido/Desktop/files/old/data.csv'\nor a relative pathname such as 'data.csv' or '..\\old\\data.csv'. For relative filenames,\nthe file location is determined relative to the current working directory as returned by\nos.getcwd(). The current working directory can be changed with os.chdir(newdir).\nThe name itself can be encoded in a number of forms. If it’s a text string, the name is\ninterpreted according to the text encoding returned by sys.getfilesystemencoding()\nbefore being passed to the host operating system. If the filename is a byte string, it is left\nunencoded and is passed as is. This latter option may be useful if you’re writing programs\nthat must handle the possibility of degenerate or miscoded filenames—instead of passing\nthe filename as text, you can pass the raw binary representation of the name. This might\nseem like an obscure edge case, but Python is commonly used to write system-level scripts\nthat manipulate the filesystem. Abuse of the filesystem is a common technique used by\nhackers to either hide their tracks or to break system tools.\nIn addition to text and bytes, any object that implements the special method\n__fspath__() can be used as a name. The __fspath__() method must return a text or\nbytes object corresponding to the actual name. This is the mechanism that makes standard\nlibrary modules such as pathlib work. For example:\n>>> from pathlib import Path\n>>> p = Path('Data/portfolio.csv')\n>>> p.__fspath__()\n'Data/portfolio.csv'\n>>>\nPotentially, you could make your own custom Path object that worked with open() as\nlong as it implements __fspath__() in a way that resolves to a proper filename on the\nsystem.\nFinally, filenames can be given as low-level integer file descriptors. This requires that\nthe “file” is already open on the system in some way. Perhaps it corresponds to a network\nsocket, a pipe, or some other system resource that exposes a file descriptor. Here is an",
      "content_length": 2754,
      "extraction_method": "Direct"
    },
    {
      "page_number": 273,
      "chapter": null,
      "content": "258\nChapter 9\nInput and Output\nexample of opening a file directly with the os module and then turning it into a proper\nfile object:\n>>> import os\n>>> fd = os.open('/etc/passwd', os.O_RDONLY)\n# Integer fd\n>>> fd\n3\n>>> file = open(fd, 'rt')\n# Proper file object\n>>> file\n<_io.TextIOWrapper name=3 mode='rt' encoding='UTF-8'>\n>>> data = file.read()\n>>>\nWhen opening an existing file descriptor like this, the close() method of the returned\nfile will also close the underlying descriptor. This can be disabled by passing\nclosefd=False to open(). For example:\nfile = open(fd, 'rt', closefd=False)\n9.6.2\nFile Modes\nWhen opening a file, you need to specify a file mode. The core file modes are 'r' for\nreading, 'w' for writing, and 'a' for appending. 'w' mode replaces any existing file with\nnew content. 'a' opens a file for writing and positions the file pointer to the end of the\nfile so that new data can be appended.\nA special file mode of 'x' can be used to write to a file, but only if it doesn’t exist\nalready. This is a useful way to prevent accidental overwriting of existing data. For this\nmode, a FileExistsError exception is raised if the file already exists.\nPython makes a strict distinction between text and binary data. To specify the kind of\ndata, you append a 't' or a 'b' to the file mode. For example, a file mode of 'rt' opens a\nfile for reading in text mode and 'rb' opens a file for reading in binary mode. The mode\ndetermines the kind of data returned by file-related methods such as f.read(). In text\nmode, strings are returned. In binary mode, bytes are returned.\nBinary files can be opened for in-place updates by supplying a plus (+) character, such as\n'rb+' or 'wb+'. When a file is opened for update, you can perform both input and\noutput, as long as all output operations flush their data before any subsequent input\noperations. If a file is opened using 'wb+' mode, its length is first truncated to zero. A\ncommon use of the update mode is to provide random read/write access to file contents in\ncombination with seek operations.\n9.6.3\nI/O Buffering\nBy default, files are opened with I/O buffering enabled. With I/O buffering, I/O\noperations are performed in larger chunks to avoid excessive system calls. For example,",
      "content_length": 2244,
      "extraction_method": "Direct"
    },
    {
      "page_number": 274,
      "chapter": null,
      "content": "9.6 Files and File Objects\n259\nwrite operations would start filling an internal memory buffer and output would only\nactually occur when the buffer is filled up. This behavior can be changed by giving a\nbuffering argument to open(). For example:\n# Open a binary-mode file with no I/O buffering\nwith open('data.bin', 'wb', buffering=0) as file:\nfile.write(data)\n...\nA value of 0 specifies unbuffered I/O and is only valid for binary mode files. A value\nof 1 specifies line-buffering and is usually only meaningful for text-mode files. Any other\npositive value indicates the buffer size to use (in bytes). If no buffering value is specified,\nthe default behavior depends on the kind of file. If it’s a normal file on disk, buffering is\nmanaged in blocks and the buffer size is set to io.DEFAULT_BUFFER_SIZE. Typically this\nis some small multiple of 4096 bytes. It might vary by system. If the file represents an\ninteractive terminal, line buffering is used.\nFor normal programs, I/O buffering is not typically a major concern. However,\nbuffering can have an impact on applications involving active communication between\nprocesses. For example, a problem that sometimes arises is two communicating\nsubprocesses that deadlock due to an internal buffering issue—for instance, one process\nwrites into a buffer, but a receiver never sees that data because the buffer didn’t get flushed.\nSuch problems can be fixed by either specifying unbuffered I/O or by an explicit flush()\ncall on the associated file. For example:\nfile.write(data)\nfile.write(data)\n...\nfile.flush()\n# Make sure all data is written from buffers\n9.6.4\nText Mode Encoding\nFor files opened in text mode, an optional encoding and an error-handling policy can be\nspecified using the encoding and errors arguments. For example:\nwith open('file.txt', 'rt',\nencoding='utf-8', errors='replace') as file:\ndata = file.read()\nThe values given to the encoding and errors argument have the same meaning as for\nthe encode() and decode() methods of strings and bytes respectively.\nThe default text encoding is determined by the value of sys.getdefaultencoding()\nand may vary by system. If you know the encoding in advance, it’s often better to\nexplicitly provide it even if it happens to match the default encoding on your system.",
      "content_length": 2275,
      "extraction_method": "Direct"
    },
    {
      "page_number": 275,
      "chapter": null,
      "content": "260\nChapter 9\nInput and Output\n9.6.5\nText-Mode Line Handling\nWith text files, one complication is the encoding of newline characters. Newlines are\nencoded as '\\n', '\\r\\n', or '\\r' depending on the host operating system—for example,\n'\\n' on UNIX and '\\r\\n' on Windows. By default, Python translates all of these line\nendings to a standard '\\n' character when reading. On writing, newline characters are\ntranslated back to the default line ending used on the system. The behavior is sometimes\nreferred to as “universal newline mode” in Python documentation.\nYou can change the newline behavior by giving a newline argument to open(). For\nexample:\n# Exactly require '\\r\\n' and leave intact\nfile = open('somefile.txt', 'rt', newline='\\r\\n')\nSpecifying newline=None enables the default line handling behavior where all line\nendings are translated to a standard '\\n' character. Giving newline='' makes Python\nrecognize all line endings, but disables the translation step—if lines were terminated by\n'\\r\\n', the '\\r\\n' combination would be left in the input intact. Specifying a value of\n'\\n', '\\r', or '\\r\\n' makes that the expected line ending.\n9.7\nI/O Abstraction Layers\nThe open() function serves as a kind of high-level factory function for creating instances\nof different I/O classes. These classes embody the different file modes, encodings, and\nbuffering behaviors. They are also composed together in layers. The following classes are\ndefined in the io module:\nFileIO(filename, mode='r', closefd=True, opener=None)\nOpens a file for raw unbuffered binary I/O. filename is any valid filename accepted\nby the open() function. Other arguments have the same meaning as for open().\nBufferedReader(file [, buffer_size])\nBufferedWriter(file [, buffer_size])\nBufferedRandom(file [, buffer_size])\nImplements a buffered binary I/O layer for a file. file is an instance of FileIO.\nbuffer_size specifies the internal buffer size to use. The choice of class depends\non whether or not the file is reading, writing, or updating data. The optional\nbuffer_size argument specifies the internal buffer size used.\nTextIOWrapper(buffered, [encoding, [errors [, newline [, line_buffering [,\nwrite_through]]]]])\nImplements text mode I/O. buffered is a buffered binary mode file, such as\nBufferedReader or BufferedWriter. The encoding, errors, and newline\narguments have the same meaning as for open(). line_buffering is a Boolean\nflag that forces I/O to be flushed on newline characters (False by default).\nwrite_through is a Boolean flag that forces all writes to be flushed (False by\ndefault).",
      "content_length": 2572,
      "extraction_method": "Direct"
    },
    {
      "page_number": 276,
      "chapter": null,
      "content": "9.7 I/O Abstraction Layers\n261\nHere is an example that shows how a text-mode file is constructed, layer-by-layer:\n>>> raw = io.FileIO('filename.txt', 'r')\n# Raw-binary mode\n>>> buffer = io.BufferedReader(raw)\n# Binary buffered reader\n>>> file = io.TextIOWrapper(buffer, encoding='utf-8') # Text mode\n>>>\nNormally you don’t need to manually construct layers like this—the built-in open()\nfunction takes care of all of the work. However, if you already have an existing file object\nand want to change its handling in some way, you might manipulate the layers as shown.\nTo strip layers away, use the detach() method of a file. For example, here is how you\ncan convert an already text-mode file into a binary-mode file:\nf = open('something.txt', 'rt')\n# Text-mode file\nfb = f.detach()\n# Detach underlying binary mode file\ndata = fb.read()\n# Returns bytes\n9.7.1\nFile Methods\nThe exact type of object returned by open() depends on the combination of file mode\nand buffering options provided. However, the resulting file object supports the methods in\nTable 9.4.\nTable 9.4\nFile Methods\nMethod\nDescription\nf.readable()\nReturns True if file can be read.\nf.read([n])\nReads at most n bytes.\nf.readline([n])\nReads a single line of input up to n characters. If n is omitted,\nthis method reads the entire line.\nf.readlines([size])\nReads all the lines and returns a list. size optionally specifies\nthe approximate number of characters to read on the file\nbefore stopping.\nf.readinto(buffer)\nReads data into a memory buffer.\nf.writable()\nReturns True if file can be written.\nf.write(s)\nWrites string s.\nf.writelines(lines)\nWrites all strings in iterable lines.\nf.close()\nCloses the file.\nf.seekable()\nReturns True if file supports random-access seeking.\nf.tell()\nReturns the current file pointer.\nf.seek(offset [, where])\nSeeks to a new file position.\nf.isatty()\nReturns True if f is an interactive terminal.\nf.flush()\nFlushes the output buffers.\nf.truncate([size])\nTruncates the file to at most size bytes.\nf.fileno()\nReturns an integer file descriptor.",
      "content_length": 2038,
      "extraction_method": "Direct"
    },
    {
      "page_number": 277,
      "chapter": null,
      "content": "262\nChapter 9\nInput and Output\nThe readable(), writable(), and seekable() methods test for supported file\ncapabilities and modes. The read() method returns the entire file as a string unless an\noptional length parameter specifies the maximum number of characters. The readline()\nmethod returns the next line of input, including the terminating newline; the readlines()\nmethod returns all the input file as a list of strings. The readline() method optionally\naccepts a maximum line length, n. If a line longer than n characters is read, the first n\ncharacters are returned. The remaining line data is not discarded and will be returned on\nsubsequent read operations. The readlines() method accepts a size parameter that\nspecifies the approximate number of characters to read before stopping. The actual number\nof characters read may be larger than this depending on how much data has been buffered\nalready. The readinto() method is used to avoid memory copies and is discussed later.\nread() and readline() indicate end-of-file (EOF) by returning an empty string. Thus,\nthe following code shows how you can detect an EOF condition:\nwhile True:\nline = file.readline()\nif not line:\n# EOF\nbreak\nstatements\n...\nYou could also write this code as follows:\nwhile (line:=file.readline()):\nstatements\n...\nA convenient way to read all lines in a file is to use iteration with a for loop:\nfor line in file:\n# Iterate over all lines in the file\n# Do something with line\n...\nThe write() method writes data to the file, and the writelines() method writes an\niterable of strings to the file. write() and writelines() do not add newline characters to\nthe output, so all output that you produce should already include all necessary formatting.\nInternally, each open file object keeps a file pointer that stores the byte offset at which\nthe next read or write operation will occur. The tell() method returns the current value\nof the file pointer. The seek(offset [,whence]) method is used to randomly access parts\nof a file given an integer offset and a placement rule in whence. If whence is os.SEEK_SET\n(the default), seek() assumes that offset is relative to the start of the file; if whence\nis os.SEEK_CUR, the position is moved relative to the current position; and if whence is\nos.SEEK_END, the offset is taken from the end of the file.\nThe fileno() method returns the integer file descriptor for a file and is sometimes used\nin low-level I/O operations in certain library modules. For example, the fcntl module\nuses the file descriptor to provide low-level file control operations on UNIX systems.",
      "content_length": 2584,
      "extraction_method": "Direct"
    },
    {
      "page_number": 278,
      "chapter": null,
      "content": "9.8 Standard Input, Output, and Error\n263\nThe readinto() method is used to perform zero-copy I/O into contiguous memory\nbuffers. It is most commonly used in combination with specialized libraries such as\nnumpy—for example, to read data directly into the memory allocated for a numeric array .\nFile objects also have the read-only data attributes shown in Table 9.5.\nTable 9.5\nFile Attributes\nAttribute\nDescription\nf.closed\nBoolean value indicates the file state: False if the file is open, True if\nclosed.\nf.mode\nThe I/O mode for the file.\nf.name\nName of the file if created using open(). Otherwise, it will be a string\nindicating the source of the file.\nf.newlines\nThe newline representation actually found in the file. The value is either\nNone if no newlines have been encountered, a string containing '\\n',\n'\\r', or '\\r\\n', or a tuple containing all the different newline\nencodings seen.\nf.encoding\nA string that indicates file encoding, if any (for example, 'latin-1' or\n'utf-8'). The value is None if no encoding is being used.\nf.errors\nThe error handling policy.\nf.write_through\nBoolean value indicating if writes on a text file pass data directly to the\nunderlying binary level file without buffering.\n9.8\nStandard Input, Output, and Error\nThe interpreter provides three standard file-like objects, known as standard input, standard\noutput, and standard error, available as sys.stdin, sys.stdout, and sys.stderr,\nrespectively. stdin is a file object corresponding to the stream of input characters supplied\nto the interpreter, stdout is the file object that receives output produced by print(), and\nstderr is a file that receives error messages. More often than not, stdin is mapped to the\nuser’s keyboard, whereas stdout and stderr produce text on screen.\nThe methods described in the preceding section can be used to perform I/O with the\nuser. For example, the following code writes to standard output and reads a line of input\nfrom standard input:\nimport sys\nsys.stdout.write(\"Enter your name: \")\nname = sys.stdin.readline()\nAlternatively, the built-in function input(prompt) can read a line of text from stdin\nand optionally print a prompt:",
      "content_length": 2151,
      "extraction_method": "Direct"
    },
    {
      "page_number": 279,
      "chapter": null,
      "content": "264\nChapter 9\nInput and Output\nname = input(\"Enter your name: \")\nLines read by input() do not include the trailing newline. This is different than reading\ndirectly from sys.stdin where newlines are included in the input text.\nIf necessary, the values of sys.stdout, sys.stdin, and sys.stderr can be replaced\nwith other file objects, in which case the print() and input() functions will use the new\nvalues. Should it ever be necessary to restore the original value of sys.stdout, it should be\nsaved first. The original values of sys.stdout, sys.stdin, and sys.stderr at interpreter\nstartup are also available in sys.__stdout__, sys.__stdin__, and sys.__stderr__,\nrespectively.\n9.9\nDirectories\nTo get a directory listing, use the os.listdir(pathname) function. For example, here is\nhow to print out a list of filenames in a directory:\nimport os\nnames = os.listdir('dirname')\nfor name in names:\nprint(name)\nNames returned by listdir() are normally decoded according to the encoding\nreturned by sys.getfilesystemencoding(). If you specify the initial path as bytes, the\nfilenames are returned as undecoded byte strings. For example:\nimport os\n# Return raw undecoded names\nnames = os.listdir(b'dirname')\nA useful operation related to directory listing is matching filenames according to a\npattern, known as globbing. The pathlib modules can be used for this purpose. For\nexample, here is an example of matching all *.txt files in a specific directory:\nimport pathlib\nfor filename in path.Path('dirname').glob('*.txt'):\nprint(filename)\nIf you use rglob() instead of glob(), it will recursively search all subdirectories for\nfilenames that match the pattern. Both the glob() and rglob() functions return a\ngenerator that produces the filenames via iteration.",
      "content_length": 1751,
      "extraction_method": "Direct"
    },
    {
      "page_number": 280,
      "chapter": null,
      "content": "9.11 Generating Output\n265\n9.10\nThe print() function\nTo print a series of values separated by spaces, supply them all to print() like this:\nprint('The values are', x, y, z)\nTo suppress or change the line ending, use the end keyword argument:\n# Suppress the newline\nprint('The values are', x, y, z, end='')\nTo redirect the output to a file, use the file keyword argument:\n# Redirect to file object f\nprint('The values are', x, y, z, file=f)\nTo change the separator character between items, use the sep keyword argument:\n# Put commas between the values\nprint('The values are', x, y, z, sep=',')\n9.11\nGenerating Output\nWorking directly with files is most familiar to programmers. However, generator functions\ncan also be used to emit an I/O stream as a sequence of data fragments. To do this, use the\nyield statement as you would use a write() or print() function. Here is an example:\ndef countdown(n):\nwhile n > 0:\nyield f'T-minus {n}\\n'\nn -= 1\nyield 'Kaboom!\\n'\nProducing an output stream in this manner provides flexibility because it is decoupled\nfrom the code that actually directs the stream to its intended destination. For example, if\nyou want to route the above output to a file f, you can do this:\nlines = countdown(5)\nf.writelines(lines)\nIf, instead, you want to redirect the output across a socket s, you can do this:\nfor chunk in lines:\ns.sendall(chunk.encode('utf-8'))\nOr, if you simply want to capture all of the output in a single string, you can do this:\nout = ''.join(lines)",
      "content_length": 1489,
      "extraction_method": "Direct"
    },
    {
      "page_number": 281,
      "chapter": null,
      "content": "266\nChapter 9\nInput and Output\nMore advanced applications can use this approach to implement their own I/O\nbuffering. For example, a generator could be emitting small text fragments, but another\nfunction would then collect the fragments into larger buffers to create a more efficient\nsingle I/O operation.\nchunks = []\nbuffered_size = 0\nfor chunk in count:\nchunks.append(chunk)\nbuffered_size += len(chunk)\nif buffered_size >= MAXBUFFERSIZE:\noutf.write(''.join(chunks))\nchunks.clear()\nbuffered_size = 0\noutf.write(''.join(chunks))\nFor programs that are routing output to files or network connections, a generator\napproach can also result in a significant reduction in memory use because the entire output\nstream can often be generated and processed in small fragments, as opposed to being first\ncollected into one large output string or list of strings.\n9.12\nConsuming Input\nFor programs that consume fragmentary input, enhanced generators can be useful for\ndecoding protocols and other facets of I/O. Here is an example of an enhanced generator\nthat receives byte fragments and assembles them into lines:\ndef line_receiver():\ndata = bytearray()\nline = None\nlinecount = 0\nwhile True:\npart = yield line\nlinecount += part.count(b'\\n')\ndata.extend(part)\nif linecount > 0:\nindex = data.index(b'\\n')\nline = bytes(data[:index+1])\ndata = data[index+1:]\nlinecount -= 1\nelse:\nline = None\nIn this example, a generator has been programmed to receive byte fragments that are\ncollected into a byte array. If the array contains a newline, a line is extracted and returned.\nOtherwise, None is returned. Here’s an example illustrating how it works:",
      "content_length": 1630,
      "extraction_method": "Direct"
    },
    {
      "page_number": 282,
      "chapter": null,
      "content": "9.12 Consuming Input\n267\n>>> r = line_receiver()\n>>> r.send(None)\n# Necessary first step\n>>> r.send(b'hello')\n>>> r.send(b'world\\nit ')\nb'hello world\\n'\n>>> r.send(b'works!')\n>>> r.send(b'\\n')\nb'it works!\\n''\n>>>\nAn interesting side effect of this approach is that it externalizes the actual I/O\noperations that must be performed to get the input data. Specifically, the implementation\nof line_receiver() contains no I/O operations at all! This means that it could be used in\ndifferent contexts. For example, with sockets:\nr = line_receiver()\ndata = None\nwhile True:\nwhile not (line:=r.send(data)):\ndata = sock.recv(8192)\n# Process the line\n...\nor with files:\nr = line_receiver()\ndata = None\nwhile True:\nwhile not (line:=r.send(data)):\ndata = file.read(10000)\n# Process the line\n...\nor even in asynchronous code:\nasync def reader(ch):\nr = line_receiver()\ndata = None\nwhile True:\nwhile not (line:=r.send(data)):\ndata = await ch.receive(8192)\n# Process the line\n...",
      "content_length": 963,
      "extraction_method": "Direct"
    },
    {
      "page_number": 283,
      "chapter": null,
      "content": "268\nChapter 9\nInput and Output\n9.13\nObject Serialization\nSometimes it’s necessary to serialize the representation of an object so it can be transmitted\nover the network, saved to a file, or stored in a database. One way to do this is to convert\ndata into a standard encoding such as JSON or XML. There is also a common\nPython-specific data serialization format called Pickle.\nThe pickle module serializes an object into a stream of bytes that can be used to\nreconstruct the object at a later point in time. The interface to pickle is simple, consisting\nof two operations, dump() and load(). For example, the following code writes an object\nto a file:\nimport pickle\nobj = SomeObject()\nwith open(filename, 'wb') as file:\npickle.dump(obj, file)\n# Save object on f\nTo restore the object, use:\nwith open(filename, 'rb') as file:\nobj = pickle.load(file)\n# Restore the object\nThe data format used by pickle has its own framing of records. Thus, a sequence of\nobjects can be saved by issuing a series of dump() operations one after the other. To restore\nthese objects, simply use a similar sequence of load() operations.\nFor network programming, it is common to use pickle to create byte-encoded\nmessages. To do that, use dumps() and loads(). Instead of reading/writing data to a file,\nthese functions work with byte strings.\nobj = SomeObject()\n# Turn an object into bytes\ndata = pickle.dumps(obj)\n...\n# Turn bytes back into an object\nobj = pickle.loads(data)\nIt is not normally necessary for user-defined objects to do anything extra to work\nwith pickle. However, certain kinds of objects can’t be pickled. These tend to be objects\nthat incorporate runtime state—open files, threads, closures, generators, and so on. To\nhandle these tricky cases, a class can define the special methods __getstate__() and\n__setstate__().\nThe __getstate__() method, if defined, will be called to create a value representing\nthe state of an object. The value returned by __getstate__() is typically a string, tuple,\nlist, or dictionary. The __setstate__() method receives this value during unpickling and\nshould restore the state of an object from it.",
      "content_length": 2125,
      "extraction_method": "Direct"
    },
    {
      "page_number": 284,
      "chapter": null,
      "content": "9.14 Blocking Operations and Concurrency\n269\nWhen encoding an object, pickle does not include the underlying source code itself.\nInstead, it encodes a name reference to the defining class. When unpickling, this name\nis used to perform a source-code lookup on the system. For unpickling to work, the\nrecipient of a pickle must have the proper source code already installed. It is also important\nto emphasize that pickle is inherently insecure—unpickling untrusted data is a known\nvector for remote code execution. Thus, pickle should only be used if you can\ncompletely secure the runtime environment.\n9.14\nBlocking Operations and Concurrency\nA fundamental aspect of I/O is the concept of blocking. By its very nature, I/O is\nconnected to the real world. It often involves waiting for input or devices to be ready. For\nexample, code that reads data on the network might perform a receive operation on a\nsocket like this:\ndata = sock.recv(8192)\nWhen this statement executes, it might return immediately if data is available. However,\nif that’s not the case, it will stop—waiting for data to arrive. This is blocking. While the\nprogram is blocked, nothing else happens.\nFor a data analysis script or a simple program, blocking is not something that you worry\nabout. However, if you want your program to do something else while an operation is\nblocked, you will need to take a different approach. This is the fundamental problem of\nconcurrency—having a program work on more than one thing at a time. One common\nproblem is having a program read on two or more different network sockets at the\nsame time:\ndef reader1(sock):\nwhile (data := sock.recv(8192)):\nprint('reader1 got:', data)\ndef reader2(sock):\nwhile (data := sock.recv(8192)):\nprint('reader2 got:', data)\n# Problem: How to make reader1() and reader2()\n# run at the same time?\nThe rest of this section outlines a few different approaches to solving this problem.\nHowever, it is not meant to be a full tutorial on concurrency. For that, you will need to\nconsult other resources.",
      "content_length": 2029,
      "extraction_method": "Direct"
    },
    {
      "page_number": 285,
      "chapter": null,
      "content": "270\nChapter 9\nInput and Output\n9.14.1\nNonblocking I/O\nOne approach to avoiding blocking is to use so-called nonblocking I/O. This is a special\nmode that has to be enabled—for example, on a socket:\nsock.setblocking(False)\nOnce enabled, an exception will now be raised if an operation would have blocked. For\nexample:\ntry:\ndata = sock.recv(8192)\nexcept BlockingIOError as e:\n# No data is available\n...\nIn response to a BlockingIOError, the program could elect to work on something else.\nIt could retry the I/O operation later to see if any data has arrived. For example, here’s\nhow you might read on two sockets at once:\ndef reader1(sock):\ntry:\ndata = sock.recv(8192)\nprint('reader1 got:', data)\nexcept BlockingIOError:\npass\ndef reader2(sock):\ntry:\ndata = sock.recv(8192)\nprint('reader2 got:', data)\nexcept BlockingIOError:\npass\ndef run(sock1, sock2):\nsock1.setblocking(False)\nsock2.setblocking(False)\nwhile True:\nreader1(sock1)\nreader2(sock2)\nIn practice, relying only on nonblocking I/O is clumsy and inefficient. For example,\nthe core of this program is the run() function at the end. It will run in a inefficient busy\nloop as it constantly tries to read on the sockets. This works, but it is not a good design.",
      "content_length": 1212,
      "extraction_method": "Direct"
    },
    {
      "page_number": 286,
      "chapter": null,
      "content": "9.14 Blocking Operations and Concurrency\n271\n9.14.2\nI/O Polling\nInstead of relying upon exceptions and spinning, it is possible to poll I/O channels to see\nif data is available. The select or selectors module can be used for this purpose. For\nexample, here’s a slightly modified version of the run() function:\nfrom selectors import DefaultSelector, EVENT_READ, EVENT_WRITE\ndef run(sock1, sock2):\nselector = DefaultSelector()\nselector.register(sock1, EVENT_READ, data=reader1)\nselector.register(sock2, EVENT_READ, data=reader2)\n# Wait for something to happen\nwhile True:\nfor key, evt in selector.select():\nfunc = key.data\nfunc(key.fileobj)\nIn this code, the loop dispatches either reader1() or reader2() function as a callback\nwhenever I/O is detected on the appropriate socket. The selector.select() operation\nitself blocks, waiting for I/O to occur. Thus, unlike the previous example, it won’t make\nthe CPU furiously spin.\nThis approach to I/O is the foundation of many so-called “async” frameworks such as\nasyncio, although you usually don’t see the inner workings of the event loop.\n9.14.3\nThreads\nIn the last two examples, concurrency required the use of a special run() function to drive\nthe calculation. As an alternative, you can use thread programming and the threading\nmodule. Think of a thread as an independent task that runs inside your program. Here is\nan example of code that reads data on two sockets at once:\nimport threading\ndef reader1(sock):\nwhile (data := sock.recv(8192)):\nprint('reader1 got:', data)\ndef reader2(sock):\nwhile (data := sock.recv(8192)):\nprint('reader2 got:', data)\nt1 = threading.Thread(target=reader1, args=[sock1])\nt2 = threading.Thread(target=reader2, args=[sock2])\n# Start the threads",
      "content_length": 1725,
      "extraction_method": "Direct"
    },
    {
      "page_number": 287,
      "chapter": null,
      "content": "272\nChapter 9\nInput and Output\nt1.start()\nt2.start()\n# Wait for the threads to finish\nt1.join()\nt2.join()\nIn this program, the reader1() and reader2() functions execute concurrently. This is\nmanaged by the host operating system, so you don’t need to know much about how it\nworks. If a blocking operation occurs in one thread, it does not affect the other thread.\nThe subject of thread programming is, in its entirety, beyond the scope of this book.\nHowever, a few additional examples are provided in the threading module section later in\nthis chapter.\n9.14.4\nConcurrent Execution with asyncio\nThe asyncio module provides a concurrency implementation alternative to threads.\nInternally, it’s based on an event loop that uses I/O polling. However, the high-level\nprogramming model looks very similar to threads through the use of special async\nfunctions. Here is an example:\nimport asyncio\nasync def reader1(sock):\nloop = asyncio.get_event_loop()\nwhile (data := await loop.sock_recv(sock, 8192)):\nprint('reader1 got:', data)\nasync def reader2(sock):\nloop = asyncio.get_event_loop()\nwhile (data := await loop.sock_recv(sock, 8192)):\nprint('reader2 got:', data)\nasync def main(sock1, sock2):\nloop = asyncio.get_event_loop()\nt1 = loop.create_task(reader1(sock1))\nt2 = loop.create_task(reader2(sock2))\n# Wait for the tasks to finish\nawait t1\nawait t2\n...\n# Run it\nasyncio.run(main(sock1, sock2))",
      "content_length": 1389,
      "extraction_method": "Direct"
    },
    {
      "page_number": 288,
      "chapter": null,
      "content": "9.15 Standard Library Modules\n273\nFull details of using asyncio would require its own dedicated book. What you should\nknow is that many libraries and frameworks advertise support for asynchronous operation.\nUsually that means that concurrent execution is supported through asyncio or a similar\nmodule. Much of the code is likely to involve async functions and related features.\n9.15\nStandard Library Modules\nA large number of standard library modules are used for various I/O related tasks. This\nsection provides a brief overview of the commonly used modules, along with a few\nexamples. Complete reference material can be found online or in an IDE and is not\nrepeated here. The main purpose of this section is to point you in the right direction by\ngiving you the names of the modules that you should be using along with a few examples\nof very common programming tasks involving each module.\nMany of the examples are shown as interactive Python sessions. These are experiments\nthat you are encouraged to try yourself.\n9.15.1\nasyncio Module\nThe asyncio module provides support for concurrent I/O operations using I/O polling\nand an underlying event loop. Its primary use is in code involving networks and\ndistributed systems. Here is an example of a TCP echo server using low-level sockets:\nimport asyncio\nfrom socket import *\nasync def echo_server(address):\nloop = asyncio.get_event_loop()\nsock = socket(AF_INET, SOCK_STREAM)\nsock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)\nsock.bind(address)\nsock.listen(5)\nsock.setblocking(False)\nprint('Server listening at', address)\nwith sock:\nwhile True:\nclient, addr = await loop.sock_accept(sock)\nprint('Connection from', addr)\nloop.create_task(echo_client(loop, client))\nasync def echo_client(loop, client):\nwith client:\nwhile True:\ndata = await loop.sock_recv(client, 10000)",
      "content_length": 1813,
      "extraction_method": "Direct"
    },
    {
      "page_number": 289,
      "chapter": null,
      "content": "274\nChapter 9\nInput and Output\nif not data:\nbreak\nawait loop.sock_sendall(client, b'Got:' + data)\nprint('Connection closed')\nif __name__ == '__main__':\nloop = asyncio.get_event_loop()\nloop.create_task(echo_server(('', 25000)))\nloop.run_forever()\nTo test this code, use a program such as nc or telnet to connect to port 25000 on your\nmachine. The code should echo back the text that you type. If you connect more than\nonce using multiple terminal windows, you’ll find that the code can handle all of the\nconnections concurrently.\nMost applications using asyncio will probably operate at a higher level than sockets.\nHowever, in such applications, you will still have to make use of special async functions\nand interact with the underlying event loop in some manner.\n9.15.2\nbinascii Module\nThe binascii module has functions for converting binary data into various text-based\nrepresentations such as hexadecimal and base64. For example:\n>>> binascii.b2a_hex(b'hello')\nb'68656c6c6f'\n>>> binascii.a2b_hex(_)\nb'hello'\n>>> binascii.b2a_base64(b'hello')\nb'aGVsbG8=\\n'\n>>> binascii.a2b_base64(_)\nb'hello'\n>>>\nSimilar functionality can be found in the base64 module as well as with the hex() and\nfromhex() methods of bytes. For example:\n>>> a = b'hello'\n>>> a.hex()\n'68656c6c6f'\n>>> bytes.fromhex(_)\nb'hello'\n>>> import base64\n>>> base64.b64encode(a)\nb'aGVsbG8='\n>>>",
      "content_length": 1356,
      "extraction_method": "Direct"
    },
    {
      "page_number": 290,
      "chapter": null,
      "content": "9.15 Standard Library Modules\n275\n9.15.3\ncgi Module\nSo, let’s say you just want to put a basic form on your website. Perhaps it’s a sign-up form\nfor your weekly “Cats and Categories” newsletter. Sure, you could install the latest web\nframework and spend all of your time fiddling with it. Or, you could also just write a basic\nCGI script—old-school style. The cgi module is for doing just that.\nSuppose you have the following form fragment on a webpage:\n<form method=\"POST\" action=\"cgi-bin/register.py\">\n<p>\nTo register, please provide a contact name and email address.\n</p>\n<div>\n<input name=\"name\" type=\"text\">Your name:</input>\n</div>\n<div>\n<input name=\"email\" type=\"email\">Your email:</input>\n</div>\n<div class=\"modal-footer justify-content-center\">\n<input type=\"submit\" name=\"submit\" value=\"Register\"></input>\n</div>\n</form>\nHere’s a CGI script that receives the form data on the other end:\n#!/usr/bin/env python\nimport cgi\ntry:\nform = cgi.FieldStorage()\nname = form.getvalue('name')\nemail = form.getvalue('email')\n# Validate the responses and do whatever\n...\n# Produce an HTML result (or redirect)\nprint(\"Status: 302 Moved\\r\")\nprint(\"Location: https://www.mywebsite.com/thanks.html\\r\")\nprint(\"\\r\")\nexcept Exception as e:\nprint(\"Status: 501 Error\\r\")\nprint(\"Content-type: text/plain\\r\")\nprint(\"\\r\")\nprint(\"Some kind of error occurred.\\r\")\nWill writing such a CGI script get you a job at an Internet startup? Probably not. Will\nit solve your actual problem? Likely.",
      "content_length": 1469,
      "extraction_method": "Direct"
    },
    {
      "page_number": 291,
      "chapter": null,
      "content": "276\nChapter 9\nInput and Output\n9.15.4\nconfigparser Module\nINI files are a common format for encoding program configuration information in a\nhuman-readable form. Here is an example:\n# config.ini\n; A comment\n[section1]\nname1 = value1\nname2 = value2\n[section2]\n; Alternative syntax\nname1: value1\nname2: value2\nThe configparser module is used to read .ini files and extract values. Here’s a basic\nexample:\nimport configparser\n# Create a config parser and read a file\ncfg = configparser.ConfigParser()\ncfg.read('config.ini')\n# Extract values\na = cfg.get('section1', 'name1')\nb = cfg.get('section2', 'name2')\n...\nMore advanced functionality is also available, including string interpolation features, the\nability to merge multiple .ini files, provide default values, and more. Consult the official\ndocumentation for more examples.\n9.15.5\ncsv Module\nThe csv module is used to read/write files of comma-separated values (CSV) produced by\nprograms such as Microsoft Excel or exported from a database. To use it, open a file and\nthen wrap an extra layer of CSV encoding/decoding around it. For example:\nimport csv\n# Read a CSV file into a list of tuples\ndef read_csv_data(filename):\nwith open(filename, newline='') as file:\nrows = csv.reader(file)",
      "content_length": 1237,
      "extraction_method": "Direct"
    },
    {
      "page_number": 292,
      "chapter": null,
      "content": "9.15 Standard Library Modules\n277\n# First line is often a header. This reads it\nheaders = next(rows)\n# Now read the rest of the data\nfor row in rows:\n# Do something with row\n...\n# Write Python data to a CSV file\ndef write_csv_data(filename, headers, rows):\nwith open(filename, 'w', newline='') as file:\nout = csv.writer(file)\nout.writerow(headers)\nout.writerows(rows)\nAn often used convenience is to use a DictReader() instead. This interprets the first\nline of a CSV file as headers and returns each row as dictionary instead of a tuple.\nimport csv\ndef find_nearby(filename):\nwith open(filename, newline='') as file:\nrows = csv.DictReader(file)\nfor row in rows:\nlat = float(rows['latitude'])\nlon = float(rows['longitude'])\nif close_enough(lat, lon):\nprint(row)\nThe csv module doesn’t do much with CSV data other than reading or writing it. The\nmain benefit provided is that the module knows how to properly encode/decode the data\nand handles a lot of edge cases involving quotation, special characters, and other details.\nThis is a module you might use to write simple scripts for cleaning or preparing data to be\nused with other programs. If you want to perform data analysis tasks with CSV data,\nconsider using a third-party package such as the popular pandas library.\n9.15.6\nerrno Module\nWhenever a system-level error occurs, Python reports it with an exception that’s a subclass\nof OSError. Some of the more common kinds of system errors are represented by separate\nsubclasses of OSError such as PermissionError or FileNotFoundError. However, there\nare hundreds of other errors that could occur in practice. For these, any OSError exception\ncarries a numeric errno attribute that can be inspected. The errno module provides\nsymbolic constants corresponding to these error codes. They are often used when writing\nspecialized exception handlers. For example, here is an exception handler that checks for\nno space remaining on a device:",
      "content_length": 1938,
      "extraction_method": "Direct"
    },
    {
      "page_number": 293,
      "chapter": null,
      "content": "278\nChapter 9\nInput and Output\nimport errno\ndef write_data(file, data):\ntry:\nfile.write(data)\nexcept OSError as e:\nif e.errno == errno.ENOSPC:\nprint(\"You're out of disk space!\")\nelse:\nraise\n# Some other error. Propagate\n9.15.7\nfcntl Module\nThe fcntl module is used to perform low-level I/O control operations on UNIX using\nthe fcntl() and ioctl() system calls. This is also the module to use if you want to\nperform any kind of file locking—a problem that sometimes arises in the context of\nconcurrency and distributed systems. Here is an example of opening a file in combination\nwith mutual exclusion locking across all processes using fcntl.flock():\nimport fcntl\nwith open(\"somefile\", \"r\") as file:\ntry:\nfcntl.flock(file.fileno(), fcntl.LOCK_EX)\n# Use the file\n...\nfinally:\nfcntl.flock(file.fileno(), fcntl.LOCK_UN)\n9.15.8\nhashlib Module\nThe hashlib module provides functions for computing cryptographic hash values such as\nMD5 and SHA-1. The following example illustrates how to use the module:\n>>> h = hashlib.new('sha256')\n>>> h.update(b'Hello')\n# Feed data\n>>> h.update(b'World')\n>>> h.digest()\nb'\\xa5\\x91\\xa6\\xd4\\x0b\\xf4 @J\\x01\\x173\\xcf\\xb7\\xb1\\x90\\xd6,e\\xbf\\x0b\\xcd\n\\xa3+W\\xb2w\\xd9\\xad\\x9f\\x14n'\n>>> h.hexdigest()\n'a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e'\n>>> h.digest_size\n32\n>>>",
      "content_length": 1312,
      "extraction_method": "Direct"
    },
    {
      "page_number": 294,
      "chapter": null,
      "content": "9.15 Standard Library Modules\n279\n9.15.9\nhttp Package\nThe http package contains a large amount of code related to the low-level\nimplementation of the HTTP internet protocol. It can be used to implement both servers\nand clients. However, most of this package is considered legacy and too low-level for\nday-to-day work. Serious programmers working with HTTP are more likely to use\nthird-party libraries such as requests, httpx, Django, flask, and others.\nNevertheless, one useful easter egg of the http package is the ability for Python to run\na standalone web server. Go a directory with a collection of files and type the following:\nbash $ python -m http.server\nServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...\nNow, Python will serve the files to your browser if you point it at the right port. You\nwouldn’t use this to run a website, but it can be useful for testing and debugging programs\nrelated to the web. For example, the author has used this to locally test programs involving\na mix of HTML, Javascript, and WebAssembly.\n9.15.10\nio Module\nThe io module primarily contains the definitions of classes used to implement the file\nobjects as returned by the open() function. It is not so common to access those classes\ndirectly. However, the module also contains a pair of classes that are useful for “faking” a\nfile in the form of strings and bytes. This can be useful for testing and other applications\nwhere you need to provide a “file” but have obtained data in a different way.\nThe StringIO() class provides a file-like interface on top of strings. For example, here\nis how you can write output to a string:\n# Function that expects a file\ndef greeting(file):\nfile.write('Hello\\n')\nfile.write('World\\n')\n# Call the function using a real file\nwith open('out.txt', 'w') as file:\ngreeting(file)\n# Call the function with a \"fake\" file\nimport io\nfile = io.StringIO()\ngreeting(file)\n# Get the resulting output\noutput = file.getvalue()\nSimilarly, you can create a StringIO object and use it for reading:",
      "content_length": 2014,
      "extraction_method": "Direct"
    },
    {
      "page_number": 295,
      "chapter": null,
      "content": "280\nChapter 9\nInput and Output\nfile = io.StringIO('hello\\nworld\\n')\nwhile (line := file.readline()):\nprint(line, end='')\nThe BytesIO() class serves a similar purpose but is used for emulating binary I/O with\nbytes.\n9.15.11\njson Module\nThe json module can be used to encode and decode data in the JSON format, commonly\nused in the APIs of microservices and web applications. There are two basic functions for\nconverting data, dumps() and loads(). dumps() takes a Python dictionary and encodes it\nas a JSON Unicode string:\n>>> import json\n>>> data = { 'name': 'Mary A. Python', 'email': 'mary123@python.org' }\n>>> s = json.dumps(data)\n>>> s\n'{\"name\": \"Mary A. Python\", \"email\": \"mary123@python.org\"}'\n>>>\nThe loads() function goes in the other direction:\n>>> d = json.loads(s)\n>>> d == data\nTrue\n>>>\nBoth the dumps() and loads() functions have many options for controlling aspects of\nthe conversion as well as interfacing with Python class instances. That’s beyond the scope of\nthis section but copious amounts of information is available in the official documentation.\n9.15.12\nlogging Module\nThe logging module is the de facto standard module used for reporting program\ndiagnostics and for print-style debugging. It can be used to route output to a log file and\nprovides a large number of configuration options. A common practice is to write code that\ncreates a Logger instance and issues messages on it like this:\nimport logging\nlog = logging.getLogger(__name__)\n# Function that uses logging\ndef func(args):\nlog.debug(\"A debugging message\")\nlog.info(\"An informational message\")",
      "content_length": 1577,
      "extraction_method": "Direct"
    },
    {
      "page_number": 296,
      "chapter": null,
      "content": "9.15 Standard Library Modules\n281\nlog.warning(\"A warning message\")\nlog.error(\"An error message\")\nlog.critical(\"A critical message\")\n# Configuration of logging (occurs one at program startup)\nif __name__ == '__main__':\nlogging.basicConfig(\nlevel=logging.WARNING,\nfilename=\"output.log\"\n)\nThere are five built-in levels of logging ordered by increasing severity. When\nconfiguring the logging system, you specify a level that acts as a filter. Only messages at\nthat level or greater severity are reported. Logging provides a large number of\nconfiguration options, mostly related to the back-end handling of the log messages.\nUsually you don’t need to know about that when writing application code—you use\ndebug(), info(), warning(), and similar methods on some given Logger instance. Any\nspecial configuration takes place during program startup in a special location (such as a\nmain() function or the main code block).\n9.15.13\nos Module\nThe os module provides a portable interface to common operating-system functions,\ntypically associated with the process environment, files, directories, permissions, and so\nforth. The programming interface closely follows C programming and standards such as\nPOSIX.\nPractically speaking, most of this module is probably too low-level to be directly used in\na typical application. However, if you’re ever faced with the problem of executing some\nobscure low-level system operation (such as opening a TTY), there’s a good chance you’ll\nfind the functionality for it here.\n9.15.14\nos.path Module\nThe os.path module is a legacy module for manipulating pathnames and performing\ncommon operations on the filesystem. Its functionality has been largely replaced by the\nnewer pathlib module, but since its use is still so widespread, you’ll continue to see it in a\nlot of code.\nOne fundamental problem solved by this module is portable handling of path separators\non UNIX (forward-slash /) and Windows (backslash \\). Functions such as os.path.join()\nand os.path.split() are often used to pull apart filepaths and put them back together:\n>>> filename = '/Users/beazley/Desktop/old/data.csv'\n>>> os.path.split()\n('/Users/beazley/Desktop/old', 'data.csv')\n>>> os.path.join('/Users/beazley/Desktop', 'out.txt')",
      "content_length": 2229,
      "extraction_method": "Direct"
    },
    {
      "page_number": 297,
      "chapter": null,
      "content": "282\nChapter 9\nInput and Output\n'/Users/beazley/Desktop/out.txt'\n>>>\nHere is an example of code that uses these functions:\nimport os.path\ndef clean_line(line):\n# Line up a line (whatever)\nreturn line.strip().upper() + '\\n'\ndef clean_data(filename):\ndirname, basename = os.path.split()\nnewname = os.path.join(dirname, basename+'.clean')\nwith open(newname, 'w') as out_f:\nwith open(filename, 'r') as in_f:\nfor line in in_f:\nout_f.write(clean_line(line))\nThe os.path module also has a number of functions, such as isfile(), isdir(), and\ngetsize(), for performing tests on the filesystem and getting file metadata. For example,\nthis function returns the total size in bytes of a simple file or of all of files in a directory:\nimport os.path\ndef compute_usage(filename):\nif os.path.isfile(filename):\nreturn os.path.getsize(filename)\nelif os.path.isdir(filename):\nreturn sum(compute_usage(os.path.join(filename, name))\nfor name in os.listdir(filename))\nelse:\nraise RuntimeError('Unsupported file kind')\n9.15.15\npathlib Module\nThe pathlib module is the modern way of manipulating pathnames in a portable and\nhigh-level manner. It combines a lot of the file-oriented functionality in one place and\nuses an object-oriented interface. The core object is the Path class. For example:\nfrom pathlib import Path\nfilename = Path('/Users/beazley/old/data.csv')\nOnce you have an instance filename of Path, you can perform various operations on it\nto manipulate the filename. For example:",
      "content_length": 1469,
      "extraction_method": "Direct"
    },
    {
      "page_number": 298,
      "chapter": null,
      "content": "9.15 Standard Library Modules\n283\n>>> filename.name\n'data.csv'\n>>> filename.parent\nPath('/Users/beazley/old')\n>>> filename.parent / 'newfile.csv'\nPath('/Users/beazley/old/newfile.csv')\n>>> filename.parts\n('/', 'Users', 'beazley', 'old', 'data.csv')\n>>> filename.with_suffix('.csv.clean')\nPath('/Users/beazley/old/data.csv.clean')\n>>>\nPath instances also have functions for obtaining file metadata, getting directory listings,\nand other similar functions. Here is a reimplementation of the compute_usage() function\nfrom the previous section:\nimport pathlib\ndef compute_usage(filename):\npathname = pathlib.Path(filename)\nif pathname.is_file():\nreturn pathname.stat().st_size\nelif pathname.is_dir():\nreturn sum(path.stat().st_size\nfor path in pathname.rglob('*')\nif path.is_file())\nreturn pathname.stat().st_size\nelse:\nraise RuntimeError('Unsupported file kind')\n9.15.16\nre Module\nThe re module is used to perform text matching, searching, and replacement operations\nusing regular expressions. Here is a simple example:\n>>> text = 'Today is 3/27/2018. Tomorrow is 3/28/2018.'\n>>> # Find all occurrences of a date\n>>> import re\n>>> re.findall(r'\\d+/\\d+/\\d+', text)\n['3/27/2018', '3/28/2018']\n>>> # Replace all occurrences of a date with replacement text\n>>> re.sub(r'(\\d+)/(\\d+)/(\\d+)', r'\\3-\\1-\\2', text)\n'Today is 2018-3-27. Tomorrow is 2018-3-28.'\n>>>",
      "content_length": 1350,
      "extraction_method": "Direct"
    },
    {
      "page_number": 299,
      "chapter": null,
      "content": "284\nChapter 9\nInput and Output\nRegular expressions are often notorious for their inscrutable syntax. In this example,\nthe \\d+ is interpreted to mean “one or more digits.” More information about the pattern\nsyntax can be found in the official documentation for the re module.\n9.15.17\nshutil Module\nThe shutil module is used to carry out some common tasks that you might otherwise\nperform in the shell. These include copying and removing files, working with archives,\nand so forth. For example, to copy a file:\nimport shutil\nshutil.copy(srcfile, dstfile)\nTo move a file:\nshutil.move(srcfile, dstfile)\nTo copy a directory tree:\nshutil.copytree(srcdir, dstdir)\nTo remove a directory tree:\nshutil.rmtree(pathname)\nThe shutil module is often used as a safer and more portable alternative to directly\nexecuting shell commands with the os.system() function.\n9.15.18\nselect Module\nThe select module is used for simple polling of multiple I/O streams. That is, it can be\nused to watch a collection of file descriptors for incoming data or for the ability to receive\noutgoing data. The following example shows typical usage:\nimport select\n# Collections of objects representing file descriptors.\nMust be\n# integers or objects with a fileno() method.\nwant_to_read = [ ... ]\nwant_to_write = [ ... ]\ncheck_exceptions = [ ... ]\n# Timeout (or None)\ntimeout = None\n# Poll for I/O",
      "content_length": 1361,
      "extraction_method": "Direct"
    },
    {
      "page_number": 300,
      "chapter": null,
      "content": "9.15 Standard Library Modules\n285\ncan_read, can_write, have_exceptions = \\\nselect.select(want_to_read, want_to_write, check_exceptions, timeout)\n# Perform I/O operations\nfor file in can_read:\ndo_read(file)\nfor file in can_write:\ndo_write(file)\n# Handle exceptions\nfor file in have_exceptions:\nhandle_exception(file)\nIn this code, three sets of file descriptors are constructed. These sets correspond to\nreading, writing, and exceptions. These are passed to select() along with an optional\ntimeout. select() returns three subsets of the passed arguments. These subsets represent\nthe files on which the requested operation can be performed. For example, a file returned\nin can_read() has incoming data pending.\nThe select() function is a standard low-level system call that’s commonly used to\nwatch for system events and to implement asynchronous I/O frameworks such as the\nbuilt-in asyncio module.\nIn addition to select(), the select module also exposes poll(), epoll(), kqueue(),\nand similar variant functions that provide similar functionality. The availability of these\nfunctions varies by operating system.\nThe selectors module provides a higher-level interface to select that might be useful\nin certain contexts. An example was given earlier in Section 9.14.2.\n9.15.19\nsmtplib Module\nThe smtplib module implements the client side of SMTP, commonly used to send email\nmessages. A common use of the module is in a script that does just that—sends an email\nto someone. Here is an example:\nimport smtplib\nfromaddr = \"someone@some.com\"\ntoaddrs = [\"recipient@other.com\" ]\namount = 123.45\nmsg = f\"\"\"From: {fromaddr}\nPay {amount} bitcoin or else.\nWe're watching.\n\"\"\"\nserver = smtplib.SMTP('localhost')\nserv.sendmail(fromaddr, toaddrs, msg)\nserv.quit()",
      "content_length": 1747,
      "extraction_method": "Direct"
    },
    {
      "page_number": 301,
      "chapter": null,
      "content": "286\nChapter 9\nInput and Output\nThere are additional features to handle passwords, authentication, and other matters.\nHowever, if you’re running a script on a machine and that machine is configured to\nsupport email, the above example will usually do the job.\n9.15.20\nsocket Module\nThe socket module provides low-level access to network programming functions. The\ninterface is modeled after the standard BSD socket interface commonly associated with\nsystem programming in C.\nThe following example shows how to make an outgoing connection and receive a\nresponse:\nfrom socket import socket, AF_INET, SOCK_STREAM\nsock = socket(AF_INET, SOCK_STREAM)\nsock.connect(('python.org', 80))\nsock.send(b'GET /index.html HTTP/1.0\\r\\n\\r\\n')\nparts = []\nwhile True:\npart = sock.recv(10000)\nif not part:\nbreak\nparts.append(part)\nparts = b''.join(parts)\nprint(parts)\nThe following example shows a basic echo server that accepts client connections and\nechoes back any received data. To test this server, run it and then connect to it using a\ncommand such as telnet localhost 25000 or nc localhost 25000 in a separate\nterminal session.\nfrom socket import socket, AF_INET, SOCK_STREAM\ndef echo_server(address):\nsock = socket(AF_INET, SOCK_STREAM)\nsock.bind(address)\nsock.listen(1)\nwhile True:\nclient, addr = sock.accept()\necho_handler(client, addr)\ndef echo_handler(client, addr):\nprint('Connection from:', addr)\nwith client:\nwhile True:\ndata = client.recv(10000)",
      "content_length": 1439,
      "extraction_method": "Direct"
    },
    {
      "page_number": 302,
      "chapter": null,
      "content": "9.15 Standard Library Modules\n287\nif not data:\nbreak\nclient.sendall(data)\nprint('Connection closed')\nif __name__ == '__main__':\necho_server(('', 25000))\nFor UDP servers, there is no connection process. However, a server must still bind the\nsocket to a known address. Here is a typical example of what a UDP server and client\nlook like:\n# udp.py\nfrom socket import socket, AF_INET, SOCK_DGRAM\ndef run_server(address):\nsock = socket(AF_INET, SOCK_DGRAM)\n# 1. Create a UDP socket\nsock.bind(address)\n# 2. Bind to address/port\nwhile True:\nmsg, addr = sock.recvfrom(2000)\n# 3. Get a message\n# ... do something\nresponse = b'world'\nsock.sendto(response, addr)\n# 4. Send a response back\ndef run_client(address):\nsock = socket(AF_INET, SOCK_DGRAM)\n# 1. Create a UDP socket\nsock.sendto(b'hello', address)\n# 2. Send a message\nresponse, addr = sock.recvfrom(2000)\n# 3. Get response\nprint(\"Received:\", response)\nsock.close()\nif __name__ == '__main__':\nimport sys\nif len(sys.argv) != 4:\nraise SystemExit('Usage: udp.py [-client|-server] hostname port')\naddress = (sys.argv[2], int(sys.argv[3]))\nif sys.argv[1] == '-server':\nrun_server(address)\nelif sys.argv[1] == '-client':\nrun_client(address)",
      "content_length": 1179,
      "extraction_method": "Direct"
    },
    {
      "page_number": 303,
      "chapter": null,
      "content": "288\nChapter 9\nInput and Output\n9.15.21\nstruct Module\nThe struct module is used to convert data between Python and binary data structures,\nrepresented as Python byte strings. These data structures are often used when interacting\nwith functions written in C, binary file formats, network protocols, or binary\ncommunication over serial ports.\nAs an example, suppose you need to construct a binary message with its format\ndescribed by a C data structure:\n# Message format: All values are \"big endian\"\nstruct Message {\nunsigned short msgid;\n// 16 bit unsigned integer\nunsigned int sequence;\n// 32 bit sequence number\nfloat x;\n// 32 bit float\nfloat y;\n// 32 bit float\n}\nHere’s how you do this using the struct module:\n>>> import struct\n>>> data = struct.pack('>HIff', 123, 456, 1.23, 4.56)\n>>> data\nb'\\x00{\\x00\\x00\\x00-?\\x9dp\\xa4@\\x91\\xeb\\x85'\n>>>\nTo decode binary data, use struct.unpack:\n>>> struct.unpack('>HIff', data)\n(123, 456, 1.2300000190734863, 4.559999942779541)\n>>>\nThe differences in the floating-point values are due to the loss of accuracy incurred by\ntheir conversion to 32-bit values. Python represents floating-point values as 64-bit double\nprecision values.\n9.15.22\nsubprocess Module\nThe subprocess module is used to execute a separate program as a subprocess, but with\ncontrol over the execution environment including I/O handling, termination, and so\nforth. There are two common uses of the module.\nIf you want to run a separate program and collect all of its output at once, use\ncheck_output(). For example:\nimport subprocess\n# Run the 'netstat -a' command and collect its output\ntry:\nout = subprocess.check_output(['netstat', '-a'])",
      "content_length": 1648,
      "extraction_method": "Direct"
    },
    {
      "page_number": 304,
      "chapter": null,
      "content": "9.15 Standard Library Modules\n289\nexcept subprocess.CalledProcessError as e:\nprint(\"It failed:\", e)\nThe data returned by check_output() is presented as bytes. If you want to convert it to\ntext, make sure you apply a proper decoding:\ntext = out.decode('utf-8')\nIt is also possible to set up a pipe and to interact with a subprocess in a more detailed\nmanner. To do that, use the Popen class like this:\nimport subprocess\n# wc is a program that returns line, word, and byte counts\np = subprocess.Popen(['wc'],\nstdin=subprocess.PIPE,\nstdout=subprocess.PIPE)\n# Send data to the subprocess\np.stdin.write(b'hello world\\nthis is a test\\n')\np.stdin.close()\n# Read data back\nout = p.stdout.read()\nprint(out)\nAn instance p of Popen has attributes stdin and stdout that can be used to\ncommunicate with the subprocess.\n9.15.23\ntempfile Module\nThe tempfile module provides support for creating temporary files and directories. Here\nis an example of creating a temporary file:\nimport tempfile\nwith tempfile.TemporaryFile() as f:\nf.write(b'Hello World')\nf.seek(0)\ndata = f.read()\nprint('Got:', data)\nBy default, temporary files are open in binary mode and allow both reading and\nwriting. The with statement is also commonly used to define a scope for when the file\nwill be used. The file is deleted at the end of the with block.\nIf you would like to create a temporary directory, use this:",
      "content_length": 1373,
      "extraction_method": "Direct"
    },
    {
      "page_number": 305,
      "chapter": null,
      "content": "290\nChapter 9\nInput and Output\nwith tempfile.TemporaryDirectory() as dirname:\n# Use the directory dirname\n...\nAs with a file, the directory and all of its contents will be deleted at the end of the with\nblock.\n9.15.24\ntextwrap Module\nThe textwrap module can be used to format text to fit a specific terminal width. Perhaps\nit’s a bit special-purpose but it can sometimes be useful in cleaning up text for output\nwhen making reports. There are two functions of interest.\nwrap() takes text and wraps it to fit a specified column width. The function returns a\nlist of strings. For example:\nimport textwrap\ntext = \"\"\"look into my eyes\nlook into my eyes\nthe eyes the eyes the eyes\nnot around the eyes\ndon't look around the eyes\nlook into my eyes you're under\n\"\"\"\nwrapped = textwrap.wrap(text, width=81)\nprint('\\n'.join(wrapped))\n# Produces:\n# look into my eyes look into my eyes the\n# eyes the eyes the eyes not around the\n# eyes don't look around the eyes look\n# into my eyes you're under\nThe indent() function can be used to indent a block of text. For example:\nprint(textwrap.indent(text, '\n'))\n# Produces:\n#\nlook into my eyes\n#\nlook into my eyes\n#\nthe eyes the eyes the eyes\n#\nnot around the eyes\n#\ndon't look around the eyes\n#\nlook into my eyes you're under",
      "content_length": 1257,
      "extraction_method": "Direct"
    },
    {
      "page_number": 306,
      "chapter": null,
      "content": "9.15 Standard Library Modules\n291\n9.15.25\nthreading Module\nThe threading module is used to execute code concurrently. This problem commonly\narises with I/O handling in network programs. Thread programming is a large topic, but\nthe following examples illustrate solutions to common problems.\nHere’s an example of launching a thread and waiting for it:\nimport threading\nimport time\ndef countdown(n):\nwhile n > 0:\nprint('T-minus', n)\nn -= 1\ntime.sleep(1)\nt = threading.Thread(target=countdown, args=[10])\nt.start()\nt.join()\n# Wait for the thread to finish\nIf you’re never going to wait for the thread to finish, make it daemonic by supplying an\nextra daemon flag like this:\nt = threading.Thread(target=countdown, args=[10], daemon=True)\nIf you want to make a thread terminate, you’ll need to do so explicitly with a flag or\nsome dedicated variable for that purpose. The thread will have to be programmed to check\nfor it.\nimport threading\nimport time\nmust_stop = False\ndef countdown(n):\nwhile n > 0 and not must_stop:\nprint('T-minus', n)\nn -= 1\ntime.sleep(1)\nIf threads are going to mutate shared data, protect it with a Lock.\nimport threading\nclass Counter:\ndef __init__(self):\nself.value = 0\nself.lock = threading.Lock()",
      "content_length": 1218,
      "extraction_method": "Direct"
    },
    {
      "page_number": 307,
      "chapter": null,
      "content": "292\nChapter 9\nInput and Output\ndef increment(self):\nwith self.lock:\nself.value += 1\ndef decrement(self):\nwith self.lock:\nself.value -= 1\nIf one thread must wait for another thread to do something, use an Event.\nimport threading\nimport time\ndef step1(evt):\nprint('Step 1')\ntime.sleep(5)\nevt.set()\ndef step2(evt):\nevt.wait()\nprint('Step 2')\nevt = threading.Event()\nthreading.Thread(target=step1, args=[evt]).start()\nthreading.Thread(target=step2, args=[evt]).start()\nIf threads are going to communicate, use a Queue:\nimport threading\nimport queue\nimport time\ndef producer(q):\nfor i in range(10):\nprint('Producing:', i)\nq.put(i)\nprint('Done')\nq.put(None)\ndef consumer(q):\nwhile True:\nitem = q.get()\nif item is None:\nbreak\nprint('Consuming:', item)\nprint('Goodbye')",
      "content_length": 761,
      "extraction_method": "Direct"
    },
    {
      "page_number": 308,
      "chapter": null,
      "content": "9.15 Standard Library Modules\n293\nq = queue.Queue()\nthreading.Thread(target=producer, args=[q]).start()\nthreading.Thread(target=consumer, args=[q]).start()\n9.15.26\ntime Module\nThe time module is used to access system time-related functions. The following selected\nfunctions are the most useful:\nsleep(seconds)\nMake Python sleep for a given number of seconds, given as a floating point.\ntime()\nReturn the current system time in UTC as a floating-point number. This is the\nnumber of seconds since the epoch (usually January 1, 1970 for UNIX systems). Use\nlocaltime() to convert it into a data structure suitable for extracting useful\ninformation.\nlocaltime([secs])\nReturn a struct_time object representing the local time on the system or the time\nrepresented by the floating-point value secs passed as an argument. The resulting\nstruct has attributes tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec, tm_wday,\ntm_yday, and tm_isdst.\ngmtime([secs])\nThe same as localtime() except that the resulting structure represents the time in\nUTC (or Greenwich Mean Time).\nctime([secs])\nConvert a time represented as seconds to a text string suitable for printing. Useful for\ndebugging and logging.\nasctime(tm)\nConvert a time structure as represented by localtime() into a text string suitable for\nprinting.\nThe datetime module is more generally used for representing dates and times for the\npurpose of performing date-related computations and dealing with timezones.\n9.15.27\nurllib Package\nThe urllib package is used to make client-side HTTP requests. Perhaps the most useful\nfunction is urllib.request.urlopen() which can be used to fetch simple webpages. For\nexample:\n>>> from urllib.request import urlopen\n>>> u = urlopen('http://www.python.org')",
      "content_length": 1737,
      "extraction_method": "Direct"
    },
    {
      "page_number": 309,
      "chapter": null,
      "content": "294\nChapter 9\nInput and Output\n>>> data = u.read()\n>>>\nIf you want to encode form parameters, you can use urllib.parse.urlencode() as\nshown here:\nfrom urllib.parse import urlencode\nfrom urllib.request import urlopen\nform = {\n'name': 'Mary A. Python',\n'email': 'mary123@python.org'\n}\ndata = urlencode(form)\nu = urlopen('http://httpbin.org/post', data.encode('utf-8'))\nresponse = u.read()\nThe urlopen() function works fine for basic webpages and APIs involving HTTP or\nHTTPS. However, it becomes quite awkward to use if access also involves cookies,\nadvanced authentication schemes, and other layers. Frankly, most Python programmers\nwould use a third-party library such as requests or httpx to handle these situations. You\nshould too.\nThe urllib.parse subpackage has additional functions for manipulating URLs\nthemselves. For example, the urlparse() function can be used to pull apart a URL:\n>>> url = 'http://httpbin.org/get?name=Dave&n=42'\n>>> from urllib.parse import urlparse\n>>> urlparse(url)\nParseResult(scheme='http', netloc='httpbin.org', path='/get', params='',\nquery='name=Dave&n=42', fragment='')\n>>>\n9.15.28\nunicodedata Module\nThe unicodedata module is used for more advanced operations involving Unicode text\nstrings. There are often multiple representations of the same Unicode text. For example,\nthe character U+00F1 (ñ) might be fully composed as a single character U+00F1 or\ndecomposed into a multicharacter sequence U+006e U+0303 (n, ~). This can cause\nstrange problems in programs that are expecting text strings that visually render the same\nto actually be the same in representation. Consider the following example involving\ndictionary keys:\n>>> d = {}\n>>> d['Jalape\\xf1o'] = 'spicy'\n>>> d['Jalapen\\u0303o'] = 'mild'",
      "content_length": 1736,
      "extraction_method": "Direct"
    },
    {
      "page_number": 310,
      "chapter": null,
      "content": "9.15 Standard Library Modules\n295\n>>> d\n{'jalapeño': 'spicy', 'jalapeño': 'mild' }\n>>>\nAt first glance, this looks like it should be an operational error—how could a\ndictionary have two identical, yet separate, keys like that? The answer is found in the fact\nthat the keys consist of different Unicode character sequences.\nIf consistent processing of identically rendered Unicode strings is an issue, they should\nbe normalized. The unicodedata.normalize() function can be used to ensure a\nconsistent character representation. For example, unicodedata.normalize('NFC', s) will\nmake sure that all characters in s are fully composed and not represented as a sequence of\ncombining characters. Using unicodedata.normalize('NFD', s) will make sure that all\ncharacters in s are fully decomposed.\nThe unicodedata module also has functions for testing character properties such as\ncapitalization, numbers, and whitespace. General character properties can be obtained with\nthe unicodedata.category(c) function. For example, unicodedata.category('A')\nreturns 'Lu', signifying that the character is an uppercase letter. More information\nabout these values can be found in the official Unicode character database at\nhttps://www.unicode.org/ucd.\n9.15.29\nxml Package\nThe xml package is a large collection of modules for processing XML data in various ways.\nHowever, if your primary goal is to read an XML document and extract information from\nit, the easiest way to do it is to use the xml.etree subpackage. Suppose you had an XML\ndocument in a file recipe.xml like this:\n<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<recipe>\n<title>Famous Guacamole</title>\n<description>A southwest favorite!</description>\n<ingredients>\n<item num=\"4\"> Large avocados, chopped </item>\n<item num=\"1\"> Tomato, chopped </item>\n<item num=\"1/2\" units=\"C\"> White onion, chopped </item>\n<item num=\"2\" units=\"tbl\"> Fresh squeezed lemon juice </item>\n<item num=\"1\"> Jalapeno pepper, diced </item>\n<item num=\"1\" units=\"tbl\"> Fresh cilantro, minced </item>\n<item num=\"1\" units=\"tbl\"> Garlic, minced </item>\n<item num=\"3\" units=\"tsp\"> Salt </item>\n<item num=\"12\" units=\"bottles\"> Ice-cold beer </item>\n</ingredients>\n<directions>\nCombine all ingredients and hand whisk to desired consistency.\nServe and enjoy with ice-cold beers.",
      "content_length": 2284,
      "extraction_method": "Direct"
    },
    {
      "page_number": 311,
      "chapter": null,
      "content": "296\nChapter 9\nInput and Output\n</directions>\n</recipe>\nHere’s how to extract specific elements from it:\nfrom xml.etree.ElementTree import ElementTree\ndoc = ElementTree(file=\"recipe.xml\")\ntitle = doc.find('title')\nprint(title.text)\n# Alternative (just get element text)\nprint(doc.findtext('description'))\n# Iterate over multiple elements\nfor item in doc.findall('ingredients/item'):\nnum = item.get('num')\nunits = item.get('units', '')\ntext = item.text.strip()\nprint(f'{num} {units} {text}')\n9.16\nFinal Words\nI/O is a fundamental part of writing any useful program. Given its popularity, Python\nis able to work with literally any data format, encoding, or document structure that’s in\nuse. Although the standard library might not support it, you will almost certainly find a\nthird-party module to solve your problem.\nIn the big picture, it may be more useful to think about the edges of your application.\nAt the outer boundary between your program and reality, it’s common to encounter issues\nrelated to data encoding. This is especially true for textual data and Unicode. Much of the\ncomplexity in Python’s I/O handling—supporting different encoding, error handling\npolicies, and so on—is aimed at this specific problem. It’s also critical to keep in mind that\ntextual data and binary data are strictly separated. Knowing what you’re working with\nhelps in understanding the big picture.\nA secondary consideration in I/O is the overall evaluation model. Python code is\ncurrently separated into two worlds—normal synchronous code and asynchronous code\nusually associated with the asyncio module (characterized by the use of async functions\nand the async/await syntax). Asynchronous code almost always requires using dedicated\nlibraries that are capable of operating in that environment. This, in turn, forces your hand\non writing your application code in the “async” style as well. Honestly, you should\nprobably avoid asynchronous coding unless you absolutely know that you need it—and\nif you’re not really sure, then you almost certainly don’t. Most of the well-adjusted\nPython-speaking universe codes in a normal synchronous style that is far easier to reason\nabout, debug, and test. You should choose that.",
      "content_length": 2206,
      "extraction_method": "Direct"
    },
    {
      "page_number": 312,
      "chapter": null,
      "content": "10\nBuilt-in Functions and\nStandard Library\nThis chapter is a compact reference to Python built-in functions. These functions are\nalways available without any import statement. The chapter concludes with a brief\noverview of some useful standard library modules.\n10.1\nBuilt-in Functions\nabs(x)\nReturns the absolute value of x.\nall(s)\nReturns True if all of the values in the iterable s evaluate as True. Returns True if s\nis empty.\nany(s)\nReturns True if any of the values in the iterable s evaluate as True. Returns False if\ns is empty.\nascii(x)\nCreates a printable representation of the object x just like the repr(), but only uses\nASCII characters in the result. Non-ASCII characters are turned into appropriate\nescape sequences. This can be used to view Unicode strings in a terminal or shell\nthat doesn’t support Unicode.\nbin(x)\nReturns a string with the binary representation of the integer x.\nbool([x])\nType representing Boolean values True and False. If used to convert x, it returns\nTrue if x evaluates to true using the usual truth-testing semantics—that is, nonzero\nnumber, nonempty list, and so on. Otherwise, False is returned. False is also the\ndefault value returned if bool() is called without any arguments. The bool class",
      "content_length": 1237,
      "extraction_method": "Direct"
    },
    {
      "page_number": 313,
      "chapter": null,
      "content": "298\nChapter 10\nBuilt-in Functions and Standard Library\ninherits from int so the Boolean values True and False can be used as integers with\nvalues 1 and 0 in mathematical calculations.\nbreakpoint()\nSets a manual debugger breakpoint. When encountered, control will transfer to pdb,\nthe Python debugger.\nbytearray([x])\nA type representing a mutable array of bytes. When creating an instance, x may\neither be an iterable sequence of integers in the range 0 to 255, an 8-bit string or\nbytes literal, or an integer that specifies the size of the byte array (in which case every\nentry will be initialized to 0).\nbytearray(s, encoding)\nAn alternative calling convention for creating a bytearray instance from characters\nin a string s where encoding specifies the character encoding to use in the\nconversion.\nbytes([x])\nA type representing an immutable array of bytes.\nbytes(s, encoding)\nAn alternate calling convention for creating bytes from a string s where encoding\nspecifies the encoding to use in conversion.\nTable 10.1 shows operations supported by both bytes and byte arrays.\nTable 10.1\nOperations on Bytes and Bytearrays\nOperation\nDescription\ns + t\nConcatenates if t is bytes.\ns * n\nReplicates if n is an integer.\ns % x\nFormats bytes. x is tuple.\ns[i]\nReturns element i as an integer.\ns[i:j]\nReturns a slice.\ns[i:j:stride]\nReturns an extended slice.\nlen(s)\nNumber of bytes in s.\ns.capitalize()\nCapitalizes the first character.\ns.center(width [, pad])\nCenters the string in a field of length width.\npad is a padding character.\ns.count(sub [, start [, end]])\nCounts occurrences of the specified\nsubstring sub.\ns.decode([encoding [, errors]])\nDecodes a byte string into text (bytes\ntype only).\ns.endswith(suffix [, start [, end]])\nChecks the end of the string for a suffix.\ns.expandtabs([tabsize])\nReplaces tabs with spaces.",
      "content_length": 1821,
      "extraction_method": "Direct"
    },
    {
      "page_number": 314,
      "chapter": null,
      "content": "10.1 Built-in Functions\n299\nOperation\nDescription\ns.find(sub [, start [, end]])\nFinds the first occurrence of the specified\nsubstring sub.\ns.hex()\nConverts to a hexadecimal string.\ns.index(sub [, start [, end]])\nFinds the first occurrence or error in the\nspecified substring sub.\ns.isalnum()\nChecks whether all characters are\nalphanumeric.\ns.isalpha()\nChecks whether all characters are alphabetic.\ns.isascii()\nChecks whether all characters are ASCII.\ns.isdigit()\nChecks whether all characters are digits.\ns.islower()\nChecks whether all characters are lowercase.\ns.isspace()\nChecks whether all characters are whitespace.\ns.istitle()\nChecks whether the string is a title-cased\nstring (first letter of each word capitalized).\ns.isupper()\nChecks whether all characters are uppercase.\ns.join(t)\nJoins a sequence of strings t using a\ndelimiter s.\ns.ljust(width [, fill])\nLeft-aligns s in a string of size width.\ns.lower()\nConverts to lowercase.\ns.lstrip([chrs])\nRemoves leading whitespace or characters\nsupplied in chrs.\ns.maketrans(x [, y [, z]])\nMakes a translation table for\ns.translate().\ns.partition(sep)\nPartitions a string based on a separator string\nsep. Returns a tuple (head, sep, tail) or\n(s, '', '') if sep isn’t found.\ns.removeprefix(prefix)\nReturns s with a given prefix removed if\npresent.\ns.removesuffix(suffix)\nReturns s with a given suffix removed if\npresent.\ns.replace(old, new [, maxreplace])\nReplaces a substring.\ns.rfind(sub [, start [, end]])\nFinds the last occurrence of a substring.\ns.rindex(sub [, start [, end]])\nFinds the last occurrence or raises an error.\ns.rjust(width [, fill])\nRight-aligns s in a string of length width.\ns.rpartition(sep)\nPartitions s based on a separator sep, but\nsearches from the end of the string.\ns.rsplit([sep [, maxsplit]])\nSplits a string from the end of the string using\nsep as a delimiter. maxsplit is the maximum\nnumber of splits to perform. If maxsplit is\nomitted, the result is identical to the split()\nmethod.",
      "content_length": 1967,
      "extraction_method": "Direct"
    },
    {
      "page_number": 315,
      "chapter": null,
      "content": "300\nChapter 10\nBuilt-in Functions and Standard Library\nOperation\nDescription\ns.rstrip([chrs])\nRemoves trailing whitespace or characters\nsupplied in chrs.\ns.split([sep [, maxsplit]])\nSplits a string using sep as a delimiter.\nmaxsplit is the maximum number of splits to\nperform.\ns.splitlines([keepends])\nSplits a string into a list of lines. If keepends\nis 1, trailing newlines are preserved.\ns.startswith(prefix [, start [, end]])\nChecks whether a string starts with prefix.\ns.strip([chrs])\nRemoves leading and trailing whitespace or\ncharacters supplied in chrs.\ns.swapcase()\nConverts uppercase to lowercase, and vice\nversa.\ns.title()\nReturns a title-cased version of the string.\ns.translate(table [, deletechars])\nTranslates a string using a character\ntranslation table table, removing characters\nin deletechars.\ns.upper()\nConverts a string to uppercase.\ns.zfill(width)\nPads a string with zeros on the left up to the\nspecified width.\nByte arrays additionally support the methods in Table 10.2.\nTable 10.2\nAdditional Operations on Byte Arrays\nOperation\nDescription\ns[i] = v\nItem assignment\ns[i:j] = t\nSlice assignment\ns[i:j:stride] = t\nExtended slice assignment\ndel s[i]\nItem deletion\ndel s[i:j]\nSlice deletion\ndel s[i:j:stride]\nExtended slice deletion\ns.append(x)\nAppends a new byte to the end.\ns.clear()\nClears the byte array.\ns.copy()\nMakes a copy.\ns.extend(t)\nExtends s with bytes from t.\ns.insert(n, x)\nInserts byte x at index n.\ns.pop([n])\nRemoves and returns byte at index n.\ns.remove(x)\nRemoves first occurrence of byte x.\ns.reverse()\nReverses the byte array in-place.",
      "content_length": 1575,
      "extraction_method": "Direct"
    },
    {
      "page_number": 316,
      "chapter": null,
      "content": "10.1 Built-in Functions\n301\ncallable(obj)\nReturns True if obj is callable as a function.\nchr(x)\nConverts the integer x representing a Unicode code-point into a single-character\nstring.\nclassmethod(func)\nThis decorator creates a class method for the function func. It is typically only used\ninside class definitions where it is implicitly invoked using @classmethod. Unlike a\nnormal method, a class method receives the class as the first argument, not an\ninstance.\ncompile(string, filename, kind)\nCompiles string into a code object for use with exec() or eval(). string is a\nstring containing valid Python code. If this code spans multiple lines, the lines must\nbe terminated by a single newline ('\\n') and not platform-specific variants (for\nexample, '\\r\\n' on Windows). filename is a string containing the name of the file\nin which the string was defined (if any). kind is 'exec' for a sequence of statements,\n'eval' for a single expression, or 'single' for a single executable statement. The\nresulting code object that is returned can be directly passed to exec() or eval() in\nplace of a string.\ncomplex([real [, imag]])\nType representing a complex number with real and imaginary components, real and\nimag, which can be supplied as any numeric type. If imag is omitted, the imaginary\ncomponent is set to zero. If real is passed as a string, the string is parsed and\nconverted to a complex number. In this case, imag should be omitted. If real is any\nother kind of object, the value of real.__complex__() is returned. If no arguments\nare given, 0j is returned.\nTable 10.3 shows methods and attributes of complex.\nTable 10.3\nAttributes of complex\nAttribute/Method\nDescription\nz.real\nReal component\nz.imag\nImaginary component\nz.conjugate()\nConjugates as a complex number.\ndelattr(object, attr)\nDeletes an attribute of an object. attr is a string. Same as del object.attr.\ndict([m]) or dict(key1=value1, key2=value2, ...)\nType representing a dictionary. If no argument is given, an empty dictionary is\nreturned. If m is a mapping object (such as another dictionary), a new dictionary",
      "content_length": 2081,
      "extraction_method": "Direct"
    },
    {
      "page_number": 317,
      "chapter": null,
      "content": "302\nChapter 10\nBuilt-in Functions and Standard Library\nhaving the same keys and same values as m is returned. For example, if m is a\ndictionary, dict(m) makes a shallow copy of it. If m is not a mapping, it must support\niteration in which a sequence of (key, value) pairs is produced. These pairs are\nused to populate the dictionary. dict() can also be called with keyword arguments.\nFor example, dict(foo=3, bar=7) creates the dictionary {'foo': 3, 'bar': 7 }.\nTable 10.4 shows operations supported by dictionaries.\nTable 10.4\nOperations on Dictionaries\nOperation\nDescription\nm | n\nMerges m and n into a single dictionary.\nlen(m)\nReturns the number of items in m.\nm[k]\nReturns the item of m with key k.\nm[k]=x\nSets m[k] to x.\ndel m[k]\nRemoves m[k] from m.\nk in m\nReturns True if k is a key in m.\nm.clear()\nRemoves all items from m.\nm.copy()\nMakes a shallow copy of m.\nm.fromkeys(s [, value])\nCreates a new dictionary with keys from sequence s and values\nall set to value.\nm.get(k [, v])\nReturns m[k] if found; otherwise, returns v.\nm.items()\nReturns (key, value) pairs.\nm.keys()\nReturns the keys.\nm.pop(k [, default])\nReturns m[k] if found and removes it from m; otherwise, returns\ndefault if supplied or raises KeyError if not.\nm.popitem()\nRemoves a random (key, value) pair from m and returns it as\na tuple.\nm.setdefault(k [, v])\nReturns m[k] if found; otherwise, returns v and sets m[k] = v.\nm.update(b)\nAdds all objects from b to m.\nm.values()\nReturns the values.\ndir([object])\nReturns a sorted list of attribute names. If object is a module, it contains the list of\nsymbols defined in that module. If object is a type or class object, it returns a list\nof attribute names. The names are typically obtained from the object’s __dict__\nattribute if defined, but other sources may be used. If no argument is given, the\nnames in the current local symbol table are returned. It should be noted that this\nfunction is primarily used for informational purposes (for example, used interactively\nat the command line). It should not be used for formal program analysis because the\ninformation obtained may be incomplete. Also, user-defined classes can define a\nspecial method __dir__() that alters the result of this function.",
      "content_length": 2220,
      "extraction_method": "Direct"
    },
    {
      "page_number": 318,
      "chapter": null,
      "content": "10.1 Built-in Functions\n303\ndivmod(a, b)\nReturns the quotient and remainder of long division as a tuple. For integers, the\nvalue (a // b, a % b) is returned. For floats, (math.floor(a / b), a % b) is\nreturned. This function may not be called with complex numbers.\nenumerate(iter, start=0)\nGiven an iterable object, iter, returns a new iterator (of type enumerate) that\nproduces tuples containing a count and the value produced from iter. For example,\nif iter produces a, b, c, then enumerate(iter) produces (0,a), (1,b), (2,c). The\noptional start changes the initial value of the count.\neval(expr [, globals [, locals]])\nEvaluates an expression. expr is a string or a code object created by compile().\nglobals and locals are mapping objects that define the global and local\nnamespaces, respectively, for the operation. If omitted, the expression is evaluated\nusing the values of globals() and locals() as executed in the caller’s environment.\nIt is most common for globals and locals to be specified as dictionaries, but advanced\napplications can supply custom mapping objects.\nexec(code [, globals [, locals]])\nExecutes Python statements. code is a string, bytes, or a code object created by\ncompile(). globals and locals define the global and local namespaces, respectively,\nfor the operation. If omitted, the code is executed using the values of globals() and\nlocals() as executed in the caller’s environment.\nfilter(function, iterable)\nCreates an iterator that returns the items in iterable for which function(item)\nevaluates as True.\nfloat([x])\nType representing a floating-point number. If x is a number, it is converted to a float.\nIf x is a string, it is parsed into a float. For all other objects, x.__float__() is\ninvoked. If no argument is supplied, 0.0 is returned.\nTable 10.5 shows methods and attributes of floats.\nTable 10.5\nMethods and Attributes of Floats\nAttribute/Method\nDescription\nx.real\nReal component when used as a complex.\nx.imag\nImaginary component when used as a complex.\nx.conjugate()\nConjugates as a complex number.\nx.as_integer_ratio()\nConverts to numerator/denominator pair.\nx.hex()\nCreates a hexadecimal representation\nx.is_integer()\nTests if an exact integer value.\nfloat.fromhex(s)\nCreates from a hexadecimal string. A class method.",
      "content_length": 2266,
      "extraction_method": "Direct"
    },
    {
      "page_number": 319,
      "chapter": null,
      "content": "304\nChapter 10\nBuilt-in Functions and Standard Library\nformat(value [, format_spec])\nConverts value to a formatted string according to the format specification string\nin format_spec. This operation invokes value.__format__(), which is free to\ninterpret the format specification as it sees fit. For simple types of data, the format\nspecifier typically includes an alignment character of '<', '>', or '^', a number\n(which indicates the field width), and a character code of 'd', 'f', or 's' for\ninteger, floating point, or string values, respectively. For example, a format\nspecification of 'd' formats an integer, a specification of '8d' right-aligns an integer\nin an 8-character field, and '<8d' left-aligns an integer in an 8-character field. More\ndetails on format() and format specifiers can be found in Chapter 9.\nfrozenset([items])\nType representing an immutable set object populated with values taken from items\nwhich must be an iterable. The values must also be immutable. If no argument is\ngiven, an empty set is returned. A frozenset supports all of the operations found on\nsets except for any operations that mutate a set in-place.\ngetattr(object, name [, default])\nReturns the value of a named attribute of an object. name is a string containing the\nattribute name. default is an optional value to return if no such attribute exists;\notherwise, AttributeError is raised. Same as accessing object.name.\nglobals()\nReturns the dictionary of the current module that represents the global namespace.\nWhen called inside another function or method, it returns the global namespace of\nthe module in which the function or method was defined.\nhasattr(object, name)\nReturns True if name is the name of an attribute of object. name is a string.\nhash(object)\nReturns an integer hash value for an object (if possible). The hash value is primarily\nused in the implementation of dictionaries, sets, and other mapping objects. The\nhash value is always the same for any objects that compare as equal. Mutable objects\nusually don’t define a hash value, although user-defined classes can define a method\n__hash__() to support this operation.\nhex(x)\nCreates a hexadecimal string from an integer x.\nid(object)\nReturns the unique integer identity of object. You should not interpret the return\nvalue in any way (for example, it’s not a memory location).\ninput([prompt])\nPrints a prompt to standard output and reads a single line of input from standard\ninput. The returned line is not modified in any way. It does not include a line\nending (e.g., '\\n').",
      "content_length": 2540,
      "extraction_method": "Direct"
    },
    {
      "page_number": 320,
      "chapter": null,
      "content": "10.1 Built-in Functions\n305\nint(x [, base])\nType representing an integer. If x is a number, it is converted to an integer by\ntruncating towards 0. If it is a string, it is parsed into an integer value. base\noptionally specifies a base when converting from a string.\nIn addition to their support for common math operations, integers also have a number\nof attributes and methods listed in Table 10.6.\nTable 10.6\nMethods and Attributes of Integers\nOperation\nDescription\nx.numerator\nNumerator when used as a\nfraction.\nx.denominator\nDenominator when used as a\nfraction.\nx.real\nReal component when used as\na complex.\nx.imag\nImaginary component when\nused as a complex.\nx.conjugate()\nConjugates as a complex\nnumber.\nx.bit_length()\nNumber of bits needed to\nrepresent the value in binary.\nx.to_bytes(length, byteorder, *, signed=False)\nConverts to bytes.\nint.from_bytes(bytes, byteorder, *, signed=False)\nConverts from bytes. A class\nmethod.\nisinstance(object, classobj)\nReturns True if object is an instance of classobj or a subclass of classobj. The\nclassobj parameter can also be a tuple of possible types or classes. For example,\nisinstance(s, (list, tuple)) returns True if s is a tuple or a list.\nissubclass(class1, class2)\nReturns True if class1 is a subclass of (derived from) class2. class2 can also be a\ntuple of possible classes, in which case each class will be checked. Note that\nissubclass(A, A) is True.\niter(object [, sentinel])\nReturns an iterator for producing items in object. If the sentinel parameter is\nomitted, the object must either provide the method __iter__(), which creates an\niterator, or the object must implement __getitem__(), which accepts integer\narguments starting at 0. If sentinel is specified, object is interpreted differently.\nInstead, object should be a callable object that takes no parameters. The returned\niterator object will call this function repeatedly until the returned value is equal to\nsentinel, at which point iteration will stop. A TypeError will be generated if\nobject does not support iteration.",
      "content_length": 2041,
      "extraction_method": "Direct"
    },
    {
      "page_number": 321,
      "chapter": null,
      "content": "306\nChapter 10\nBuilt-in Functions and Standard Library\nlen(s)\nReturns the number of items contained in s which should be some kind of\ncontainer such as a list, tuple, string, set, or dictionary.\nlist([items])\nType representing a list. items may be any iterable object, the values of which are\nused to populate the list. If items is already a list, a shallow copy is made. If no\nargument is given, an empty list is returned.\nTable 10.7 shows operations defined on lists.\nTable 10.7\nList Operators and Methods\nOperation\nDescription\ns + t\nConcatenation if t is a list.\ns * n\nReplication if n is an integer.\ns[i]\nReturns element i of s.\ns[i:j]\nReturns a slice.\ns[i:j:stride]\nReturns an extended slice.\ns[i] = v\nItem assignment.\ns[i:j] = t\nSlice assignment.\ns[i:j:stride] = t\nExtended slice assignment.\ndel s[i]\nItem deletion.\ndel s[i:j]\nSlice deletion.\ndel s[i:j:stride]\nExtended slice deletion.\nlen(s)\nNumber of elements in s.\ns.append(x)\nAppends a new element, x, to the end of s.\ns.extend(t)\nAppends a new list, t, to the end of s.\ns.count(x)\nCounts occurrences of x in s.\ns.index(x [, start [, stop]])\nReturns the smallest i where s[i] == x. start and\nstop optionally specify the starting and ending index for\nthe search.\ns.insert(i, x)\nInserts x at index i.\ns.pop([i])\nReturns the element i and removes it from the list. If i is\nomitted, the last element is returned.\ns.remove(x)\nSearches for x and removes it from s.\ns.reverse()\nReverses items of s in place.\ns.sort([key [, reverse]])\nSorts items of s in place. key is a key function. reverse\nis a flag that sorts the list in reverse order. key and\nreverse should always be specified as keyword\narguments.",
      "content_length": 1657,
      "extraction_method": "Direct"
    },
    {
      "page_number": 322,
      "chapter": null,
      "content": "10.1 Built-in Functions\n307\nlocals()\nReturns a dictionary corresponding to the local namespace of the caller. This\ndictionary should only be used to inspect the execution environment—changes\nmade to the dictionary don’t have any effect on the corresponding local variables.\nmap(function, items, ...)\nCreates an iterator that produces the results of applying function to the items in\nitems. If multiple input sequences are supplied, function is assumed to take that\nmany arguments, with each argument taken from a different sequence. In this case,\nthe result is only as long as the shortest input sequence.\nmax(s [, args, ...], *, default=obj, key=func)\nFor a single argument, s, this function returns the maximum value of the items in s,\nwhich may be any iterable object. For multiple arguments, it returns the largest of\nthe arguments. If the keyword-only argument default is given, it supplies the value\nto return if s is empty. If the keyword-only argument key is given, then the value v\nfor which key(v) returns the maximum value is returned.\nmin(s [, args, ...], *, default=obj, key=func)\nThe same as max(s) except that the minimum value is returned.\nnext(s [, default])\nReturns the next item from the iterator s. If the iterator has no more items, a\nStopIteration exception is raised unless a value is supplied to the default argument.\nIn that case, default is returned instead.\nobject()\nThe base class for all objects in Python. You can call it to create an instance, but the\nresult isn’t especially interesting.\noct(x)\nConverts an integer, x, to an octal string.\nopen(filename [, mode [, bufsize [, encoding [, errors [, newline\n[, closefd]]]]]])\nOpens the file filename and returns a file object. The arguments are described in\ndetail in Chapter 9.\nord(c)\nReturns the integer ordinal value of a single character, c. This value usually\ncorresponds to the character’s Unicode code-point value.\npow(x, y [, z])\nReturns x ** y. If z is supplied, this function returns (x ** y) % z. If all three\narguments are given, they must be integers and y must be non-negative.",
      "content_length": 2070,
      "extraction_method": "Direct"
    },
    {
      "page_number": 323,
      "chapter": null,
      "content": "308\nChapter 10\nBuilt-in Functions and Standard Library\nprint(value, ... , *, sep=separator, end=ending, file=outfile)\nPrint a collection of values. As input, you can supply any number of values, all of\nwhich are printed on the same line. The sep keyword argument is used to specify\na different separator character (a space by default). The end keyword argument\nspecifies a different line ending ('\\n' by default). The file keyword argument\nredirects the output to a file object.\nproperty([fget [, fset [, fdel [, doc]]]])\nCreates a property attribute for classes. fget is a function that returns the attribute\nvalue, fset sets the attribute value, and fdel deletes an attribute. doc provides a\ndocumentation string. Properties are often specified as a decorator:\nclass SomeClass:\nx = property(doc='This is property x')\n@x.getter\ndef x(self):\nprint('getting x')\n@x.setter\ndef x(self, value):\nprint('setting x to', value)\n@x.deleter\ndef x(self):\nprint('deleting x')\nrange([start,] stop [, step])\nCreates a range object that represents a range of integer values from start to stop.\nstep indicates a stride and is set to 1 if omitted. If start is omitted (when range() is\ncalled with one argument), it defaults to 0. A negative step creates a list of numbers\nin descending order.\nrepr(object)\nReturns a string representation of object. In most cases, the returned string is an\nexpression that can be passed to eval() to recreate the object.\nreversed(s)\nCreates a reverse iterator for sequence s. This function only works if s defines the\n__reversed__() method or it implements the sequence methods __len__() and\n__getitem__(). It does not work with generators.\nround(x [, n])\nRounds the result of rounding the floating-point number x to the closest multiple of\n10 to the power minus n. If n is omitted, it defaults to 0. If two multiples are equally\nclose, it rounds towards 0 if the previous digit is even and away from 0 otherwise (for\nexample, 0.5 is rounded to 0.0 and 1.5 is rounded to 2).",
      "content_length": 1990,
      "extraction_method": "Direct"
    },
    {
      "page_number": 324,
      "chapter": null,
      "content": "10.1 Built-in Functions\n309\nset([items])\nCreates a set populated with items taken from the iterable object items. The items\nmust be immutable. If items contains other sets, those sets must be of type\nfrozenset. If items is omitted, an empty set is returned.\nTable 10.8 shows operations on sets.\nTable 10.8\nSet Operations and Methods\nOperation\nDescription\ns | t\nUnion\ns & t\nIntersection\ns - t\nDifference\ns ^ t\nSymmetric difference\nlen(s)\nReturns number of items in s.\ns.add(item)\nAdds item to s. Has no effect if item is already in s.\ns.clear()\nRemoves all items from s.\ns.copy()\nMakes a copy of s.\ns.difference(t)\nSet difference. Returns all the items in s, but not\nin t.\ns.difference_update(t)\nRemoves all the items from s that are also in t.\ns.discard(item)\nRemoves item from s. If item is not a member of s,\nnothing happens.\ns.intersection(t)\nIntersection. Returns all the items that are both in s\nand in t.\ns.intersection_update(t)\nComputes the intersection of s and t and leaves the\nresult in s.\ns.isdisjoint(t)\nReturns True if s and t have no items in common.\ns.issubset(t)\nReturns True if s is a subset of t.\ns.issuperset(t)\nReturns True if s is a superset of t.\ns.pop()\nReturns an arbitrary set element and removes it\nfrom s.\ns.remove(item)\nRemoves item from s. If item is not a member,\nKeyError is raised.\ns.symmetric_difference(t)\nSymmetric difference. Returns all the items that are\nin s or t, but not in both sets.\ns.symmetric_difference_update(t)\nComputes the symmetric difference of s and t and\nleaves the result in s.\ns.union(t)\nUnion. Returns all items in s or t.\ns.update(t)\nAdds all the items in t to s. t may be another set, a\nsequence, or any object that supports iteration.",
      "content_length": 1694,
      "extraction_method": "Direct"
    },
    {
      "page_number": 325,
      "chapter": null,
      "content": "310\nChapter 10\nBuilt-in Functions and Standard Library\nsetattr(object, name, value)\nSets an attribute of an object. name is a string. Same as object.name = value.\nslice([start,] stop [, step])\nReturns a slice object representing integers in the specified range. Slice objects are\nalso generated by the extended slice syntax a[i:i:k].\nsorted(iterable, *, key=keyfunc, reverse=reverseflag)\nCreates a sorted list from items in iterable. The keyword argument key is a\nsingle-argument function that transforms values before they are compared. The\nkeyword argument reverse is a Boolean flag that specifies whether or not the\nresulting list is sorted in reverse order. The key and reverse arguments must be\nspecified using keywords—for example, sorted(a, key=get_name).\nstaticmethod(func)\nCreates a static method for use in classes. This function is usually used as a\n@staticmethod decorator.\nstr([object])\nType representing a string. If object is supplied, a string representation of its value is\ncreated by calling its __str__() method. This is the same string that you see when\nyou print the object. If no argument is given, an empty string is created.\nTable 10.9 shows methods defined on strings.\nTable 10.9\nString Operators and Methods\nOperation\nDescription\ns + t\nConcatenates strings if t is a string.\ns * n\nReplicates a string if n is an integer.\ns % x\nFormats a string. x is tuple.\ns[i]\nReturns element i of a string.\ns[i:j]\nReturns a slice.\ns[i:j:stride]\nReturns an extended slice.\nlen(s)\nNumber of elements in s.\ns.capitalize()\nCapitalizes the first character.\ns.casefold()\nConverts s to a string usable for a caseless\ncomparison.\ns.center(width [, pad])\nCenters the string in a field of length width.\npad is a padding character.\ns.count(sub [, start [, end]])\nCounts occurrences of the specified\nsubstring sub.\ns.decode([encoding [, errors]])\nDecodes a byte string into text (bytes\ntype only).\ns.encode([encoding [, errors]])\nReturns an encoded version of the string (str\ntype only).",
      "content_length": 1987,
      "extraction_method": "Direct"
    },
    {
      "page_number": 326,
      "chapter": null,
      "content": "10.1 Built-in Functions\n311\nOperation\nDescription\ns.endswith(suffix [, start [, end]])\nChecks the end of the string for a suffix.\ns.expandtabs([tabsize])\nReplaces tabs with spaces.\ns.find(sub [, start [, end]])\nFinds the first occurrence of the specified\nsubstring sub.\ns.format(*args, **kwargs)\nFormats s (str type only).\ns.format_map(m)\nFormats s with substitutions taking from the\nmapping m (str type only).\ns.index(sub [, start [, end]])\nFinds the first occurrence or error in the\nspecified substring sub.\ns.isalnum()\nChecks whether all characters are\nalphanumeric.\ns.isalpha()\nChecks whether all characters are alphabetic.\ns.isascii()\nChecks whether all characters are ASCII.\ns.isdecimal()\nChecks whether all characters are decimal\ncharacters. Does not match superscript,\nsubscripts, or other special digits.\ns.isdigit()\nChecks whether all characters are digits.\nMatches superscripts and superscripts, but\nnot vulgar fractions.\ns.isidentifier()\nChecks whether s is a valid Python identifier.\ns.islower()\nChecks whether all characters are lowercase.\ns.isnumeric()\nChecks whether all characters are numeric.\nMatches all forms of numeric characters such\nas vulgar fractions, Roman numerals, etc.\ns.isprintable()\nChecks whether all characters are printable.\ns.isspace()\nChecks whether all characters are whitespace.\ns.istitle()\nChecks whether the string is a title-cased\nstring (first letter of each word capitalized).\ns.isupper()\nChecks whether all characters are uppercase.\ns.join(t)\nJoins a sequence of strings t using a\ndelimiter s.\ns.ljust(width [, fill])\nLeft-aligns s in a string of size width.\ns.lower()\nConverts to lowercase.\ns.lstrip([chrs])\nRemoves leading whitespace or characters\nsupplied in chrs.\ns.maketrans(x [, y [, z]])\nMakes a translation table for\ns.translate().\ns.partition(sep)\nPartitions a string based on a separator string\nsep. Returns a tuple (head, sep, tail) or\n(s, '', '') if sep isn’t found.",
      "content_length": 1922,
      "extraction_method": "Direct"
    },
    {
      "page_number": 327,
      "chapter": null,
      "content": "312\nChapter 10\nBuilt-in Functions and Standard Library\nOperation\nDescription\ns.removeprefix(prefix)\nReturns s with a given prefix removed if\npresent.\ns.removesuffix(suffix)\nReturns s with a given suffix removed if\npresent.\ns.replace(old, new [, maxreplace])\nReplaces a substring.\ns.rfind(sub [, start [, end]])\nFinds the last occurrence of a substring.\ns.rindex(sub [, start [, end]])\nFinds the last occurrence or raises an error.\ns.rjust(width [, fill])\nRight-aligns s in a string of length width.\ns.rpartition(sep)\nPartitions s based on a separator sep, but\nsearches from the end of the string.\ns.rsplit([sep [, maxsplit]])\nSplits a string from the end of the string using\nsep as a delimiter. maxsplit is the maximum\nnumber of splits to perform. If maxsplit is\nomitted, the result is identical to the split()\nmethod.\ns.rstrip([chrs])\nRemoves trailing whitespace or characters\nsupplied in chrs.\ns.split([sep [, maxsplit]])\nSplits a string using sep as a delimiter.\nmaxsplit is the maximum number of splits to\nperform.\ns.splitlines([keepends])\nSplits a string into a list of lines. If keepends\nis 1, trailing newlines are preserved.\ns.startswith(prefix [, start [, end]])\nChecks whether a string starts with a prefix.\ns.strip([chrs])\nRemoves leading and trailing whitespace or\ncharacters supplied in chrs.\ns.swapcase()\nConverts uppercase to lowercase, and vice\nversa.\ns.title()\nReturns a title-cased version of the string.\ns.translate(table [, deletechars])\nTranslates a string using a character\ntranslation table table, removing characters\nin deletechars.\ns.upper()\nConverts a string to uppercase.\ns.zfill(width)\nPads a string with zeros on the left up to the\nspecified width.\nsum(items [, initial])\nComputes the sum of a sequence of items taken from the iterable object items.\ninitial provides the starting value and defaults to 0. This function usually only\nworks with numbers.",
      "content_length": 1880,
      "extraction_method": "Direct"
    },
    {
      "page_number": 328,
      "chapter": null,
      "content": "10.1 Built-in Functions\n313\nsuper()\nReturns an object that represents the collective superclasses of the class in which its\nused. The primary purpose of this object is to invoke methods in base classes. Here’s\nan example:\nclass B(A):\ndef foo(self):\nsuper().foo()\n# Invoke foo() defined by superclasses.\ntuple([items])\nType representing a tuple. If supplied, items is an iterable object that is used to\npopulate the tuple. However, if items is already a tuple, it’s returned unmodified. If\nno argument is given, an empty tuple is returned.\nTable 10.10 shows methods defined on tuples.\nTable 10.10\nTuple Operators and Methods\nOperation\nDescription\ns + t\nConcatenation if t is a list.\ns * n\nReplication if n is an integer.\ns[i]\nReturns element i of a s.\ns[i:j]\nReturns a slice.\ns[i:j:stride]\nReturns an extended slice.\nlen(s)\nNumber of elements in s.\ns.append(x)\nAppends a new element, x, to the end of s.\ns.count(x)\nCounts occurrences of x in s.\ns.index(x [, start [, stop]])\nReturns the smallest i where s[i] == x. start and\nstop optionally specify the starting and ending index for\nthe search.\ntype(object)\nThe base class of all types in Python. When called as a function, returns the type of\nobject. This type is the same as the object’s class. For common types such as\nintegers, floats, and lists, the type will refer to one of the other built-in classes such as\nint, float, list, and so forth. For user-defined objects, the type is the associated\nclass. For objects related to Python’s internals, you will typically get a reference to\none of the classes defined in the types module.\nvars([object])\nReturns the symbol table of object (usually found in its __dict__ attribute). If no\nargument is given, a dictionary corresponding to the local namespace is returned.\nThe dictionary returned by this function should be assumed to be read-only. It’s not\nsafe to modify its contents.",
      "content_length": 1880,
      "extraction_method": "Direct"
    },
    {
      "page_number": 329,
      "chapter": null,
      "content": "314\nChapter 10\nBuilt-in Functions and Standard Library\nzip([s1 [, s2 [, ... ]]])\nCreates an iterator that produces tuples containing one item each from s1, s2, and so\non. The nth tuple is (s1[n], s2[n], ... ). The resulting iterator stops when the\nshortest input is exhausted. If no arguments are given, the iterator produces no\nvalues.\n10.2\nBuilt-in Exceptions\nThis section describes the built-in exceptions used to report different kinds of errors.\n10.2.1\nException Base Classes\nThe following exceptions serve as base classes for all the other exceptions:\nBaseException\nThe root class for all exceptions. All built-in exceptions are derived from this class.\nException\nThe base class for all program-related exceptions. That includes all built-in\nexceptions except for SystemExit, GeneratorExit, and KeyboardInterrupt.\nUser-defined exceptions should inherit from Exception.\nArithmeticError\nThe base class for arithmetic exceptions, including OverflowError,\nZeroDivisionError, and FloatingPointError.\nLookupError\nThe base class for indexing and key errors, including IndexError and KeyError.\nEnvironmentError\nThe base class for errors that occur outside Python. Is a synonym for OSError.\nThe preceding exceptions are never raised explicitly. However, they can be used to\ncatch certain classes of errors. For instance, the following code would catch any sort of\nnumerical error:\ntry:\n# Some operation\n...\nexcept ArithmeticError as e:\n# Math error\n10.2.2\nException Attributes\nInstances of an exception e have a few standard attributes that can be useful to inspect\nand/or manipulate it in certain applications.",
      "content_length": 1608,
      "extraction_method": "Direct"
    },
    {
      "page_number": 330,
      "chapter": null,
      "content": "10.2 Built-in Exceptions\n315\ne.args\nThe tuple of arguments supplied when raising the exception. In most cases, this is a\none-item tuple with a string describing the error. For EnvironmentError\nexceptions, the value is a 2-tuple or 3-tuple containing an integer error number,\nstring error message, and an optional filename. The contents of this tuple might be\nuseful if you need to recreate the exception in a different context—for example, to\nraise an exception in a different Python interpreter process.\ne.__cause__\nPrevious exception when using explicit chained exceptions.\ne.__context__\nPrevious exception for implicitly chained exceptions.\ne.__traceback__\nTraceback object associated with the exception.\n10.2.3\nPredefined Exception Classes\nThe following exceptions are raised by programs:\nAssertionError\nFailed assert statement.\nAttributeError\nFailed attribute reference or assignment.\nBufferError\nMemory buffer expected.\nEOFError\nEnd of file. Generated by the built-in functions input() and raw_input(). It should\nbe noted that most other I/O operations such as the read() and readline()\nmethods of files return an empty string to signal EOF instead of raising an\nexception.\nFloatingPointError\nFailed floating-point operation. It should be noted that floating-point exception\nhandling is a tricky problem and this exception only gets raised if Python has been\nconfigured and built in a way that enables it. It is more common for floating-point\nerrors to silently produce results such as float('nan') or float('inf'). A subclass\nof ArithmeticError.\nGeneratorExit\nRaised inside a generator function to signal termination. This happens when a\ngenerator is destroyed prematurely (before all generator values are consumed) or the\nclose() method of a generator is called. If a generator ignores this exception, the\ngenerator is terminated, and the exception is silently ignored.",
      "content_length": 1877,
      "extraction_method": "Direct"
    },
    {
      "page_number": 331,
      "chapter": null,
      "content": "316\nChapter 10\nBuilt-in Functions and Standard Library\nIOError\nFailed I/O operation. The value is an IOError instance with the attributes errno,\nstrerror, and filename. errno is an integer error number, strerror is a string error\nmessage, and filename is an optional filename. A subclass of EnvironmentError.\nImportError\nRaised when an import statement can’t find a module or when from can’t find a\nname in a module.\nIndentationError\nIndentation error. A subclass of SyntaxError.\nIndexError\nSequence subscript out of range. A subclass of LookupError.\nKeyError\nKey not found in a mapping. A subclass of LookupError.\nKeyboardInterrupt\nRaised when the user hits the interrupt key (usually Ctrl+C).\nMemoryError\nRecoverable out-of-memory error.\nModuleNotFoundError\nModule can’t be found by the import statement.\nNameError\nName not found in local or global namespaces.\nNotImplementedError\nUnimplemented feature. Can be raised by base classes that require derived classes to\nimplement certain methods. A subclass of RuntimeError.\nOSError\nOperating system error. Primarily raised by functions in the os module. The\nfollowing exceptions are subclasses: BlockingIOError, BrokenPipeError,\nChildProcessError, ConnectionAbortedError, ConnectionError,\nConnectionRefusedError, ConnectionResetError, FileExistsError,\nFileNotFoundError, InterruptedError, IsADirectoryError,\nNotADirectoryError, PermissionError, ProcessLookupError, TimeoutError.\nOverflowError\nResult of an integer value being too large to be represented. This exception usually\nonly arises if large integer values are passed to objects that internally rely upon\nfixed-precision machine integers in their implementation. For example, this error\ncan arise with range or xrange objects if you specify starting or ending values that\nexceed 32 bits in size. A subclass of ArithmeticError.",
      "content_length": 1832,
      "extraction_method": "Direct"
    },
    {
      "page_number": 332,
      "chapter": null,
      "content": "10.2 Built-in Exceptions\n317\nRecursionError\nRecursion limit exceeded.\nReferenceError\nResult of accessing a weak reference after the underlying object has been destroyed\n(see the weakref module).\nRuntimeError\nA generic error not covered by any of the other categories.\nStopIteration\nRaised to signal the end of iteration. This normally happens in the next() method\nof an object or in a generator function.\nStopAsyncIteration\nRaised to signal the end of asynchronous iteration. Only applicable in the context of\nasync functions and generators.\nSyntaxError\nParser syntax error. Instances have the attributes filename, lineno, offset, and\ntext, which can be used to gather more information.\nSystemError\nInternal error in the interpreter. The value is a string indicating the problem.\nSystemExit\nRaised by the sys.exit() function. The value is an integer indicating the return\ncode. If it’s necessary to exit immediately, os._exit() can be used.\nTabError\nInconsistent tab usage. Generated when Python is run with the -tt option. A\nsubclass of SyntaxError.\nTypeError\nOccurs when an operation or function is applied to an object of an inappropriate\ntype.\nUnboundLocalError\nUnbound local variable referenced. This error occurs if a variable is referenced\nbefore it’s defined in a function. A subclass of NameError.\nUnicodeError\nUnicode encoding or decoding error. A subclass of ValueError. The following\nexceptions are subclasses: UnicodeEncodeError, UnicodeDecodeError,\nUnicodeTranslateError.\nValueError\nGenerated when the argument to a function or operation is the right type but an\ninappropriate value.",
      "content_length": 1597,
      "extraction_method": "Direct"
    },
    {
      "page_number": 333,
      "chapter": null,
      "content": "318\nChapter 10\nBuilt-in Functions and Standard Library\nWindowsError\nGenerated by failed system calls on Windows. A subclass of OSError.\nZeroDivisionError\nDividing by zero. A subclass of ArithmeticError.\n10.3\nStandard Library\nPython comes with a sizable standard library. Many of these modules have been\npreviously described in the book. Reference material can be found at\nhttps://docs.python.org/library. That material is not repeated here.\nThe modules listed below are notable because they are generally useful for a wide\nvariety of applications and for Python programming in general.\n10.3.1\ncollections Module\nThe collections module supplements Python with a variety of additional container\nobjects that can be quite useful for working with data—such as a double-ended queue\n(deque), dictionaries that automatically initialize missing items (defaultdict), and\ncounters for tabulation (Counter).\n10.3.2\ndatetime Module\nThe datetime module is where you find functions related to dates, times, and\ncomputations involving those things.\n10.3.3\nitertools Module\nThe itertools module provides a variety of useful iteration patterns—chaining iterables\ntogether, iterating over product sets, permutations, grouping, and similar operations.\n10.3.4\ninspect Module\nThe inspect module provides functions for inspecting the internals of code-related\nelements such as functions, classes, generators, and coroutines. It’s commonly used in\nmetaprogramming by functions that define decorators and similar features.\n10.3.5\nmath Module\nThe math module provides common mathematical functions such as sqrt(), cos(),\nand sin().",
      "content_length": 1606,
      "extraction_method": "Direct"
    },
    {
      "page_number": 334,
      "chapter": null,
      "content": "10.3 Standard Library\n319\n10.3.6\nos Module\nThe os module is where you find low-level functions related to the host operating\nsystem—processes, files, pipes, permissions, and similar features.\n10.3.7\nrandom Module\nThe random module provides various functions related to random number generation.\n10.3.8\nre Module\nThe re module provides support for working with text via regular expression pattern\nmatching.\n10.3.9\nshutil Module\nThe shutil module has functions for performing common tasks related to the shell, such\nas copying files and directories.\n10.3.10\nstatistics Module\nThe statistics module provides functions for computing common statistical values such\nas means, medians, and standard deviation.\n10.3.11\nsys Module\nThe sys module contains a variety of attributes and methods related to the runtime\nenvironment of Python itself. This includes command-line options, standard I/O streams,\nthe import path, and similar features.\n10.3.12\ntime Module\nThe time module is where you find various functions related to system time, such as\ngetting the value of the system clock, sleeping, and the number of elapsed CPU seconds.\n10.3.13\nturtle Module\nTurtle graphics. You know, for kids.\n10.3.14\nunittest Module\nThe unittest module provides built-in support for writing unit tests. Python itself is\ntested using unittest. However, many programmers prefer using third-party libraries such\nas pytest for testing. This author concurs.",
      "content_length": 1426,
      "extraction_method": "Direct"
    },
    {
      "page_number": 335,
      "chapter": null,
      "content": "320\nChapter 10\nBuilt-in Functions and Standard Library\n10.4\nFinal Words: Use the Built-Ins\nIn the modern world where there are hundreds of thousands of Python packages, it is easy\nfor programmers to seek solutions to small problems in the form of third-party package\ndependencies. However, Python has long had an extremely useful set of built-in functions\nand datatypes. Combined with modules from the standard library, a wide range of\ncommon programming problems can often be solved using nothing beyond what Python\nalready provides. Given a choice, prefer that.",
      "content_length": 563,
      "extraction_method": "Direct"
    },
    {
      "page_number": 336,
      "chapter": null,
      "content": "Index\n( ) (parentheses)\nfor functions, 22, 56, 101\nfor tuples, 15\n* (star)\nin function arguments, 102–104, 108–109\nin module imports, 229–230, 240–241\nin variable names, 46\noperator, 5, 38–40, 47, 57, 298, 307, 310, 313\n** (double star)\nin function arguments, 104, 108–109\noperator, 5, 40, 56, 57\n*=, **= operators, 7, 41\n+ (plus sign)\nin file modes, 258\nin numbers converted to text strings, 250–251\noperator, 5, 10–11, 14, 38–40, 47, 57, 91, 298,\n307, 310, 313\n+= operator, 7, 41, 92, 111\n, (comma)\nin numbers converted to text strings, 250–251\nseparating values, 276\n- (minus sign)\nin byte formatting, 253\nin numbers converted to text strings, 250–251\noperator, 5, 18, 39–40, 50, 57, 309\n-= operator, 7, 41, 92\n. (dot) operator, 56, 79, 154\n.. (double dots), in relative imports, 237\n... (ellipsis), in extended slices, 96\n/ (slash)\nas path separator, 281\nin function signature, 105\noperator, 5, 40, 57\n// operator, 5, 40, 57\n/=, //= operators, 7, 41\n: (colon)\nfor dictionaries, 18\nfor slicing operator, 10, 47–49\n:= operator, 8, 12, 39, 54, 57\n= operator, 3, 51\n== operator, 6, 42, 57, 93\ntesting for None with, 87\n[] (square brackets), 13\n# comments, 2\n% (percent sign)\nin byte formatting, 253\nin numbers converted to text strings, 251\noperator, 5, 9, 39–40, 57, 298, 310\n%=, &=, ^= operators, 7, 41\n&, ^ operators, 6, 18, 40, 50, 57, 309\n_ (undescore)\nas variable, 2, 17, 46, 61\nin function names, 106\nin names of internal variables, 27\nin numeric literals, 38\nin private attribute and method names, 176\n__ (double undescore)\nin attribute names, 177–179\nin method names, 27, 88\n~ operator, 6, 40, 57\n\\ (backslash), as path separator, 281\n| operator, 6, 18, 40, 50, 57, 302, 309\n|= operator, 7, 41\n>, < operators, 6, 42, 57\n>=, <= operators, 6, 42, 57, 93\n>>, << operators, 6, 40, 57\n>>=, <<= operators, 7, 41\n>>> prompt, 1\n{ } (curly braces), 20\nfor dictionaries, 18\nin f-strings, 252\nABC base class, 185\nabc module, 185",
      "content_length": 1926,
      "extraction_method": "Direct"
    },
    {
      "page_number": 337,
      "chapter": null,
      "content": "322\nIndex\nabs() function, 5, 40, 297\n__abs__() method, 91\n@abstractmethod decorator, 130, 185\n__abstractmethods__ attribute, 222\nadd() method, 18, 50, 309\n__add__() method, 27, 80, 90–91\naddition, 5\n__aenter__(), __aexit__() methods, 136\n__aiter__(), __anext__() methods, 137 \nall() function, 47, 297\n__all__ variable, 229, 240–241\nand operator, 6–7, 43, 57, 92\n__and__() method, 90\nannotations, 23\n__annotations__ attribute, 107, 129, 222, 242 \nany() function, 47, 297\nappend() method, 13, 26, 300, 307, 313 \napplicative evaluation order, 101\narchives, working with, 284\nargparse module, 33, 255\nargs attribute, 64–65, 70–315\narguments, see functions, arguments of \narithmetic operators, 5, 40\nArithmeticError exception, 67–68, 314–318 \nas qualifier, 31, 64, 75, 99, 226\nas_integer_ratio() method, 303\nascii() function, 253, 297\nasctime() function, 293\nassert statement, 77–78\nAssertionError exception, 68, 77, 315 \nassignment expression operator, see := operator \nassignments, 38–39, 41, 83\naugmented, 7, 41, 47, 92, 111\nasync for, async with statements, 137\nasync keyword, 135, 136\nasyncio module, 135, 137, 151, 271–274, 285 \natexit module, 26\nAttributeError exception, 68, 98, 207, 304, 315 \nattributes, 79, 98\nbinding, 167, 207–208\ndeleting, 301\nfully qualified, 158\ninternal, 177–179\nlazy evaluation of, 214\nno type contraints on, 179\nof classes, 308\nof functions, 129–130\nof objects, 157–158, 304, 310\npublic, 176\nawait statement, 135–137, 151\nawaitables, 135\nbanker’s rounding, 5\nbase classes, 160\nabstract, 185–188\ninvoking menthods of, 313\nlinking to, 207\n__slots__ variable and, 210\ntuple of, 222\nused for type hinting, 184–185\nbase64 module, 274\nBaseException exception, 67–68, 314\n__bases__ attribute, 207, 222\nbash shell, 1\nbin() function, 37, 297\nbinary data structures, 288\nbinary integers, 6\nbinascii module, 274\nbit manipulation, 6\nbit_length() method, 305\nbitwise operators, 6, 40, 57\nblocking, 269–273\nBlockingIOError exception, 270, 316\nbool class, 297\nbool type, 298\n__bool__() method, 93–95\nBoolean values, 6–7, 38, 43–44, 297\nbound methods, 158, 183\nbreak statement, 8, 12, 62–63, 141\nbreakpoint() function, 298\nBrokenPipeError exception, 316\nBSD socket interface, 286\nBufferedXXX classes, 260\nBufferError exception, 315\nbyte arrays, 247, 266, 298–300\nbytearray type, 247, 298\nbytes, 247–248\ncomparing, 43\nconverting to text, 274\nformatting, 253–254\noperations on, 298–300\nserializing objects into, 268",
      "content_length": 2427,
      "extraction_method": "Direct"
    },
    {
      "page_number": 338,
      "chapter": null,
      "content": "Index\n323\nbytes module, 274\nbytes type, 247–248, 298\n__bytes__() method, 94–95\nBytesIO class, 280\nC programming language, 281, 286, 288\n__call__() method, 98, 219\ncallable() function, 301\ncallback functions, 114, 116\npassing arguments to, 118–121\nreturning results from, 121–123\nCallbackError exception, 122\ncapitalize() method, 298, 310\ncasefold() method, 310\ncategory() function, 295\n__cause__ attribute, 65, 71–73, 315\n__ceil__() method, 91\ncenter() method, 298, 310\ncgi module, 275\ncharacters\nend of file (EOF), 2, 68, 315\nline-feed, see newline characters\nordinal values of, 307\ncheck_output() function, 288–289\nchild classes, see subclasses\nChildProcessError exception, 316\nchr() function, 301\ncircular dependency, 82\nclass methods, 89, 170–172, 222, 301\nclass statement, 27, 154–155, 215–218\nbase-class names in, 160\nclass variables, 169–172, 222\nmutating, 112\n__class__ attribute, 206, 223\nclasses, 80, 153–223\nadding methods to, 28\nbody of, 215\nbuilt-in, 313\ncreating, 160, 215–218\nduplicating definitions of, 221\nextending, 160\ninspecting, 318\ninternal variables in, 27\nlinking instances to, 206, 223\nmembership testing for, 183\nnames of, 222\nnamespace of, 215, 218\nstatic methods in, 173\ntype-checking, 162\nuniformity of, 183\nuser-defined, 179, 206–207\nwith a single method, 166\nclassmethod object, 125\n@classmethod decorator, 125, 170–171, 183, 197,\n213, 301\nclassobj type, 305\ncleanup, 66, 141\nclear() method, 300, 302, 309\nclick module, 255\nclose() method, 12, 147, 202, 258, 262, 315\nclosed attribute, 263\n__closure__ attribute, 129\nclosures, 116–117, 129\ncls object, 125, 171, 220, 222\ncode, see also programs\ngenerating, 222, 233\nPythonic, 99–100, 160, 176\nreadability of, 103, 223\ntesting, 223\ncode-checking tools, 87, 107\n__code__ attribute, 129–130\ncollect() function, 82\ncollections module, 20, 81, 168, 240, 318\ncomma-separated values (CSVs), 276\ncommand-line options, 15, 33, 254–255, 317, 319\ncomments, 2\nextracting, 55\ncomparisons, 6, 42, 93\nbetween bytes and text, 248\ncompile() function, 301\ncomplex() function, 301\n__complex__() method, 94–95, 301\ncompound-interest calculation, 4\ncompute_usage() function, 282–283\nconcatenation, 47\nof tuples, 16\nconcurrency, 148, 269, 273, 291–293\nconditionals, 4, 7–9, 44–45, 59–60\nconfigparser module, 276\nconjugate() method, 303, 305\nConnectionXXXError exceptions, 316\ncontainers, 95–96\n__contains__() method, 95–96",
      "content_length": 2381,
      "extraction_method": "Direct"
    },
    {
      "page_number": 339,
      "chapter": null,
      "content": "324\nIndex\ncontext managers, 75–77, 99\nasynchronous, 136–137\ncleaning up with, 141\n__context__ attribute, 65, 72–73, 315\ncontextlib module, 77, 148\n@contextmanager decorator, 148\ncontinue statement, 8, 62–63\ncontrol flow\nwith conditionals, 7–9, 59–60\nwith exceptions, 64–69, 77\nwith loops, 60–63\ncopy() method, 300, 302, 309\ncopying, of sequences, 47–48\ncoroutines, 135\ngenerator-based, 146\ninspecting, 318\ncos() function, 318\ncount() method, 298, 307, 310, 313\nCounter class, 318\ncryptographic hash values, 278\ncsv module, 31, 276\nctime() function, 293\ncurrentframe() function, 132\ndaemon flag, 291\ndata encapsulation, 176\ndata hiding, 178\n@dataclass decorator, 134\ndataclasses, 196, 233\ndatetime module, 293, 318\ndeadlocks, 25, 204\ndebug variable, 215\ndebug() function, 133, 281\ndebugging\nbreakpoint for, 298\nerror messages for, 66, 124\nexception handling and, 74\nin Python development environment, 3\nintroducing code for, 77–78\nlogging for, 280\nmaking output for, 162\nmodules individually, 235\nsmaller tasks, 145\nstack frames and, 133\nwhen using dictionaries, 21\nwith __dict__ attribute, 211\nwith repr(), 11\nwith __repr__(), 28, 196\ndecode() method, 248, 259, 298, 310\ndecorators, 104, 124–127, 194–197, 220\ndeep copies, 83\ndeepcopy() function, 84\ndef statement, 22, 27, 101\nDEFAULT_BUFFER_SIZE value, 259\ndefaultdict class, 318\ndel statement, 19, 50–51, 82–83, 89, 202, 207,\n300–302, 307\n__del__() method, 89, 201–206\ndelattr() function, 157, 179, 301\n__delattr__() method, 98, 207\ndelegation, 208–210\n__delete__() method, 211\n__delitem__() method, 95–96\ndependency injection, 165, 176\ndeque class, 81, 318\ndescriptors, 211–214, 220, 285\nDesign Patterns book, 176\ndetach() method, 261\ndict type, 80, 301–302\ndict() function, 20, 51, 168\n__dict__ attribute, 206–207, 211, 215, 222–223,\n242, 302, 313\ndictionaries, 18–21\naccessing members of, 18\nadding unusual items to, 85–87\nas literals, 38\nassignments on, 83\nconverting to lists, 20\ncreating, 18, 20, 53–54\ndeep vs. shallow copies of, 83\ndispatching through, 193\nempty, 20, 43\ninitializing missing items automatically, 318\ninserting objects into, 18\niterating over, 21\nkeys of, 20–21, 294–295\nmodifying objects of, 18\nnested, 19\nno ordered comparisons on, 43\nnumber of items in, 306\noperations on, 51, 301–302\npassed as function parameters, 107\nremoving elements from, 19, 104",
      "content_length": 2330,
      "extraction_method": "Direct"
    },
    {
      "page_number": 340,
      "chapter": null,
      "content": "Index\n325\nusing tuples in, 19\nvalues of, 21\ndictionary comprehension, 20, 53–54\ndictionary lookups, 176\nDictReader class, 277\ndifference operation, 18, 50, 309\ndifference() method, 309\ndifference_update() method, 309\ndir() function, 26, 31, 302\n__dir__() method, 302\ndirectories, 264\ncurrent working, 234\ntemporary, 289\ndiscard() method, 18, 50, 309\ndistutils module, 243\ndivision, 5, 303\ndivmod() function, 5, 40, 303\n__divmod__() method, 90\nDjango library, 279\n__doc__ attribute, 106, 129, 222, 242\ndocopt module, 255\ndocumentation strings, 106, 129, 155, 222, 242\ndot operator, see . operator\ndouble-ended queues, 318\nduck typing, 167\ndump() function, 268\ndumps() function, 280\ndynamic binding, 167\ne, E, in numbers, 37\necho servers, 286\n.egg suffix, 234\nelif statement, 7–8, 59–60, 193\nEllipsis object, 96\nelse statement, 7–9, 44–45, 57, 59–60, 63, 66,\n193\nemails, sending, 285\nencode() method, 248, 259, 310\nencoding attribute, 13, 259–260, 263\nencodings, 248–249, 263\nend keyword, 265, 308\nendswith() method, 10, 298, 311\n__enter__() method, 75, 99, 148\nenumerate() function, 61, 303\nenv command, 256\nenvironment variables, 256\nEnvironmentError exception, 314–316\nEOF (end of file) character, 2, 68, 315\nEOFError exception, 68, 315\nepoll() function, 285\n__eq__() method, 93–94\nerrno attribute, 316\nerrno module, 277–278\nerrors\nhandling, 110–111\nlogging, 66\nerrors attribute, 259–260, 263\neval() function, 89, 301, 303, 308\nEvent class, 292\nexcept statement, 24–25, 64–66, 70, 110\nnarrowness of, 74\nException exception, 66–69, 314\nexceptions, 24–25, 64–75\naltering control flow, 67–69\nasynchronous, 69\nbuilt-in, 67–68, 75, 314–318\ncatching, 64, 66, 70, 73–74\nchained, 70–73, 315\ndefining new, 69–70, 74\nexpected vs. unexpected, 72–73\nextracting values attached to, 141\nhandling, 24–25, 73–75, 110–111, 121–122,\n277–278\nhierarchy of, 67–68, 70\nignoring, 65–66\npredefined, 315–318\npropagating, 64\nraising, 64, 69, 110, 147, 315\nstandard attributes of, 64–65\ntraceback messages of, 70, 73\nuser-defined, 69, 314\nwrapping with a function, 54\nexec() function, 133–134, 233, 301, 303\n__exit__() method, 75, 99, 148\nexpandtabs() method, 298, 311\nexpressions, 3, 38–39\nevaluating, 43, 303\nextend() method, 300, 307\nExtensible Markup Language (XML), 295\nf-strings, 4, 9, 11, 251–252\nFalse value, 6–7, 38, 43–45, 297–298",
      "content_length": 2314,
      "extraction_method": "Direct"
    },
    {
      "page_number": 341,
      "chapter": null,
      "content": "326\nIndex\nfast lookups, 19\nfcntl module, 262, 278 \nfcntl() function, 278 \nfile descriptors, 257, 262 \nfile keyword, 265, 308 \nfile modes, 258, 263\nfile objects, 258, 262, 307\nattributes of, 263\nimplementing, 279\nmanipulating, 261\nmethods supported by, 261\nstandard, 263\nfile pointers, 262\n__file__ attribute, 36, 242\n__file__ variable, 241\nFileExistsError exception, 258, 316\nFileIO class, 260\nfilename attribute, 316–317\nfileno() method, 262\nFileNotFoundError exception, 277, 316\nfiles\nconverting between binary and text, 261\ncopying, 284, 319\nencoding of, 13, 263\nlocking, 278\nmetadata of, 282\nnames of, 257–258, 263\nnewline characters in, 260, 263\nopening, 12, 256–258\noverwritting, 258\nparsing, 105\npaths to, 281–283\nreading, 12–13, 262\nremoving, 284, 319\nstate of, 263\ntemporary, 289\nwriting to, 262, 268\nfilter() function, 128, 303\nfiltering, 127–128\nfinally statement, 25, 66, 141\nfind() method, 10, 299, 311\nfirst-class objects, 85–87, 115, 242\nflag variables, 63\nflask library, 279\nfloat() function, 11, 303, 315\n__float__() method, 94–95, 303\nFloatingPointError exception, 67, 314–315\nfloats, 3, 5, 37–38, 303, 315\nconverting to text, 250–251\nprecision of, 288\nrounding, 5, 308\nflock() function, 278\n__floor__() method, 91\n__floordiv__() method, 90\nflush() method, 259, 262\nflyweight pattern, 176\nfor statement, 12–13, 21–22, 45, 60–63, 140, 176\nfor reading lines in a file, 262\nimplementing, 97\nnested, 144–145\non lists, 52\nformat() function, 11, 94, 250, 304\nformat() method, 9, 252–253, 311\n__format__() method, 94, 304\nformat_map() method, 311\nfrom statement, 31, 228–230, 237, 316\nfrom_ prefix, in method names, 172\nfrom_bytes() method, 305\nfromhex() method, 274, 303\nfromkeys() method, 302\nfrozenset() function, 304, 309\n__fspath__() method, 257\nfunction call operator, 56\nfunctions, 22–24, 101–131, 137\naccepting iterables, 47\narguments of\ndefault, 23, 101–102, 115\ndefault values for, 87, 157\nevaluated left-to-right, 101\nkeyword, 103–104\nnumber of, 101–102\norder of, 101\npositional, 105–106\nasynchronous, 135–137, 272, 317\nattribute access, 207\nattributes of, 129–130\nbuilt-in, 297–314\ncallback, 114, 116, 118–123\ncomparing, 131\ndebugging messages in, 124\ndefining, 22, 101\ndelayed execution of, 145",
      "content_length": 2218,
      "extraction_method": "Direct"
    },
    {
      "page_number": 342,
      "chapter": null,
      "content": "Index\n327\ndocumenting, 106, 129, 155\nemulating, 98\nevaluating, 116\nhelper, 106\nhigher-order, 115–118\ninspecting, 131–133, 318\ninvoking, 22, 101, 111\nlocal variables in, 24, 107, 111–113, 149–151\nmetadata of, 124–125, 130\nnaming, 106, 129\nnested, 113, 116–117, 129\nrecursive, 114\nreturn values of, 23, 109–110\nside effects in, 108\nsignature of, 130–131\ntype hints in, 107, 129, 155\nwrappers around, 124\nfunctools module, 94\nfutures, 123\ngarbage collection, 26, 81–83, 89, 141, 203–204\ngc module, 82\n__ge__() method, 93\ngenerator expressions, 54–56, 128\nGeneratorExit exception, 147, 314–315\ngenerators, 97, 139–152\nasynchronous, 317\ncreating, 54\ndelegating, 142–144\nemitting I/O streams, 265–266\nenhanced, 146–151, 266–267\nfor repeated iterations, 142\ninspecting, 318\nterminating, 315\nget() method, 19, 302\n__get__() method, 211–213\nget_data() function, 242\ngetattr() function, 157, 179, 193–194, 304\n__getattr__() method, 98, 207–211\n__getattribute__() method, 98, 207, 211\n__getitem__() method, 95–96, 159–308\ngetsize() function, 282\n__getstate__() method, 268\nglob() function, 264\nglobal statement, 112\nglobals() function, 131, 303–304\n__globals__ attribute, 129, 131\nglobbing, 264\ngmtime() function, 293\n__gt__() method, 93\nhasattr() function, 157, 179, 304\nhash() function, 304\n__hash__() method, 93–94\nhashlib module, 278\nhelp() command, 22\nhex() function, 37, 95, 304\nhex() method, 274, 299, 303\nhigher-order functions, 115–118\nhttp package, 279\nhttpx library, 279, 294\nHyperText Markup Language (HTML), 279\nHypertext Transfer Protocol (HTTP), 279,\n293–294\n__iadd__(), __iand__() methods, 91–92\nid() function, 80, 304\nidentifiers, 38\nidentity checks, 92\n__idivmod__() method, 91–92\nif statement, 7–9, 39, 44–45, 52, 57, 59–60, 193\n__ifloordiv__(), __ilshift__(),\n__imatmul__(), __imod__() methods, 91–92\nimport statement, 15, 30–35, 59, 225–237, 241,\n245, 316\ninside a function, 228, 231\nImportError exception, 31, 67–68, 226, 237, 316\nimportlib library, 232\n__imul__() method, 91–92\nin operator, 19, 45, 50–52, 57, 96, 302\nin-place assignment, see assignments, augmented\nindent() function, 290\nindentation, 4, 316\nIndentationError exception, 316\nindex() method, 299, 307, 311, 313\n__index__() method, 94–95\nIndexError exception, 48, 49, 67, 314, 316\nindexing operator, 13\non dictionaries, 18\non tuples, 16\ninfo() function, 281",
      "content_length": 2333,
      "extraction_method": "Direct"
    },
    {
      "page_number": 343,
      "chapter": null,
      "content": "328\nIndex\ninheritance, 28–30, 160–163\nbreaking code with, 162\nfrom built-in types, 167–169\nmultiple, 163, 187–192, 211\ncooperative, 190–192\npropagating metaclasses via, 220\n__slots__ variable and, 210\nsupervised, 197–199\nvia composition, 164–166\nvia functions, 166–167\nvia implementation, 163–164\nINI files, 276\n__init__() method, 27, 70, 89, 134, 154–155,\n161, 181–201, 219–220\n__init__.py file, 34–35, 235–237, 239–241\n__init_subclass__() method, 197–199, 220–222\ninput() function, 13, 33, 304, 315\ninput/output (I/O), 247–296\nbuffering, 258–260\nconsuming input, 266–267\nerror handling, 249, 256, 259, 316\ngenerating output, 265–266\nhandling, 288, 291\nin binary mode, 257–259\nin text mode, 258–260\nnonblocking, 270\npolling channels of, 271, 273, 284\ninsert() method, 13, 26, 300, 307\ninspect module, 318\ninstances, 79, 154–156\nadding attributes to, 161, 206\nalternate constructors of, 170–172\ncaching, 200–201, 204–206\ncreating, 89, 199\ndeleting an attribute of, 156\ndestroying, 89, 201\ngetting, 156\ninitializing, 89\nlinking to classes, 206, 223\nsetting, 156\nstate associated with, 206, 223\nstoring data of, 210–211\nint class, 80\nint() function, 11, 95, 305\n__int__() method, 94–95\nintegers, 3, 305\nas literals, 37\nbase of, 37\nbinary, 6\nconverting\nto text, 251\nto/from bytes, 305\ncreating strings from\nbinary, 37, 297\nhexadecimal, 37, 299, 303–304\noctal, 37, 307\niterating over, 21\nprecision of, 316\nranges of, 21–22, 308\ntesting values of, 303\ninterfaces, 184–188\ninterpreter, 1, 3\nInterruptedError exception, 316\nintersection operation, 18, 50, 309\nintersection() method, 309\n__invert__() method, 91\nio module, 260–261, 279–280\nioctl() function, 278\nIOError exception, 316\n__ior__(), __ipow__() methods, 91–92\nipython shell, 2\n__irshift__() method, 91–92\n“is a” relationship, 163\nis not operator, 42, 57, 80\nis operator, 42, 57, 80, 92\nis_integer() method, 303\nIsADirectoryError exception, 316\nisalnum(), isalpha() methods, 299, 311\nisascii() method, 311\nisatty() method, 262\nisdecimal() method, 311\nisdigit() method, 299, 311\nisdir() function, 282\nisdisjoint() method, 309\nisfile() function, 282\nisidentifier() method, 311\nisinstance() function, 64, 81, 183, 305\nislower() method, 299, 311\nisnumeric(), isprintable() methods, 311\nisspace() method, 299, 311\nissubclass() function, 184, 305\nissubset(), issuperset() methods, 309\nistitle() method, 299, 311",
      "content_length": 2358,
      "extraction_method": "Direct"
    },
    {
      "page_number": 344,
      "chapter": null,
      "content": "Index\n329\n__isub__() method, 91–92\nisupper() method, 299, 311\nitems() method, 21, 51, 302\niter() function, 305\n__iter__() method, 97–98, 142, 152, 160, 305\niterations, 21–22, 45–47, 60–62, 97–98, 305\nending, 69\nhandling, 307, 318\nnested, 143\nproducing values for, 139\nrepeated, 142\nreversed, 308\niterator objects\nasynchronous, 136–137\ncreating, 22, 61\nimplementing, 98, 152\ninternal stack of, 146\nreversed, 97\nitertools module, 318\n__itruediv__() method, 91–92\n__ixor__() method, 91–92\njoin() function, 281\njoin() method, 299, 311\nJSON format, 280\njson module, 280\nKeyboardInterrupt exception, 67, 69, 314, 316\nKeyError exception, 67, 314, 316\nkeys() method, 20, 51, 302\nkqueue() function, 285\nlambda expression, 114–115, 117–118\nlate binding, 115\nlazy evaluation, 116, 214\n__le__() method, 93\nleft-fold operations, 128\nlen() function, 10, 47, 50, 51, 159, 298, 302, 306,\n309–310, 313\n__len__() method, 28, 93, 95, 159–160, 308\nlibraries, 235\nline endings, see newline characters\nlineno attribute, 317\nlist class, 14, 80\nlist comprehension, 17, 52, 55\nfiltering with, 127\nlist() function, 20, 47, 55, 81, 168, 306\nlistdir() function, 264\nlists, 13–15\nadding items to, 13, 307\nas literals, 38, 46\nas sequences, 47\nassignments on, 83\ncomparing, 42\nconcatenating, 14\nconverting to, from data, 14\ncreating, 13\ndeep vs. shallow copies of, 83, 306\ndefining subtypes of, 81\nempty, 14, 43–44, 306\niterating over, 13, 21\nmodifying, 49–50\nnested, 14, 145–146\nnumber of items in, 306–307\npassed as function parameters, 107\nprocessing, 52–53, 307\nremoving items from, 307\nslicing, 14\nsorting, 307, 310\nliterals, 37–38\nljust() method, 299, 311\nload() function, 268\nloads() function, 280\nlocals() function, 131, 303, 307\nlocaltime() function, 293\nLock class, 291\nlocks, 25\nLogger instance, 280–281\nlogging module, 254, 280–281\nlogical operators, 6–7, 43, 57, 92\nLookupError exception, 67–68, 314, 316\nloops, 4, 7–9, 21–22, 60–63\naborting, 141\nflag variables in, 63\nnumerical indices in, 61\nskipping the reminder of, 8, 62\ntaking items from different sequences, 62\nloose coupling, 167\nlower() method, 10, 299, 311\n__lshift__() method, 90",
      "content_length": 2122,
      "extraction_method": "Direct"
    },
    {
      "page_number": 345,
      "chapter": null,
      "content": "330\nIndex\nlstrip() method, 299, 311\n__lt__() method, 93–94\nmain() function, 33, 281\n__main__ module, 234\n__main__.py file, 235, 239, 245\nmaketrans() method, 299, 311\nmap() function, 128, 307\nmappings, 18–19, 128, 307\nopeations on, 51–52\nmath module, 318\nmathematical operations, 5, 40, 90–92\n__matmul__() method, 90\nmax() function, 47, 94, 128, 307\nMD5 algorithm, 278\nmemory\nallocating, 82\nreducing usage of, 55, 210–211 \nMemoryError exception, 68, 316\nmetaclass keyword, 218–219\nmetaclasses, 217–222\nMethod Resolution Order (MRO, 190–192, 222 \nmethods, 79, 154\nabstract, 185, 222\navailable on an object, 26\nbound, 158, 183\ndecorating automatically, 222\ndefining, 215\nfully qualified, 158\nimplementing, 213\ninternal, 176\ninternal variables in, 27\ninvoking, 154\nmagic (special), 154, 210\nnaming, 172, 176\npublic, 176\nredefining, 28, 160\nrewriting, 195\nstatic, 173–176, 310\nuser-defined, 180\nMicrosoft Excel, 276\nmin() function, 47, 94, 128, 307\nmixin classes, 188–192, 220\n__mod__() method, 90\nmode attribute, 263\nmodule objects, 226\n__module__ attribute, 129, 222\n__module__ variable, 215\nModuleNotFoundError exception, 316\nmodules, 30–32, 225–235\nas first-class objects, 242–243\ncaching, 227–228, 231–233\ncompiling, 233\ndebugging, 235\nimporting, 31, 225–227, 232–234\ncircular, 230–232\nspecific definitions from, 228–230\nlisting contents of, 31\nlocating, 226\nnames of, 222, 226, 234, 242\nnamespaces of, 242, 304\norganizing, 33\nreloading and unloading, 232–233\nrenaming, 227\nstandard library, 31, 273–296, 318–319\nthird-party, 32\nmodulo, 5, 307\nmonads, 123\n__mro__ attribute, 190, 207, 222\n__mul__() method, 88, 90\nmultiplication, 5\nname attribute, 263\nname mangling, 177–179\n__name__ attribute, 106, 129, 222, 242\n__name__ variable, 33, 234\nnamed fields, 19\nnamedtuple() function, 134\nNameError exception, 68, 111, 316–317\nnamespace packages, 237\nnamespaces, 31, 158, 226, 242\nglobal, 112\nlocal, 111\nof classes, 215, 218\nof packages, 239–240\nnc program, 274, 286\n__ne__() method, 93\n__neg__() method, 91\nnetwork programs, 286, 288, 291\n__new__() method, 89, 199–201, 219\nnew_class() function, 216–217\nnewline attribute, 260",
      "content_length": 2123,
      "extraction_method": "Direct"
    },
    {
      "page_number": 346,
      "chapter": null,
      "content": "Index\n331\nnewline characters, 260, 263, 301, 304\ncontrolling, in output, 265\nin input, 266\nnewlines attribute, 263\nnext() function, 139–141, 307\nnext() method, 317\n__next__() method, 97, 140, 152\nNone value, 6, 43–44, 87, 102, 108–110\nnormalize() function, 295\nnot in operator, 45, 57\nnot operator, 6–7, 43, 57, 92\nNotADirectoryError exception, 316\nNotImplemented object, 91, 93\nNotImplementedError exception, 68, 93, 316\nnumbers\ncomparing, 42\ncomplex, 301, 303, 305\nconverting\nfrom objects, 94–95\nfrom strings, 11\nto text, 250–251\nfloating-point, 5, 37–38, 250–251, 288, 303,\n308, 315\nnonempty, 43\nprecision of, 251\nrandom, 319\nsum of, 312\nnumpy package, 50, 88, 96, 263\nobject class, 190, 307\ninheriting from, 160, 191\nobjects, 26–30, 79–99, 153\nattributes of, 56\nbuilt-in, 222–223\nchecking against classes, 183\ncomparing, 42, 80, 92–94\nconverting to built-in types, 94–95\ncoroutine, 135\ndeep vs. shallow copies of, 83\nfirst-class, 85–87, 115\nhash values of, 93–94, 304\nidentity of, 80, 304\nimmutable, 102\nimplementing operators for, 79\ninitializing, 27\ninvoked likes functions, 98\niterable, 45\nlisting available methods of, 26\nlocation of, 38–39\nmanagement of, 89–90\nmethods available on, 26\nmutable, 41, 83–84, 107–108\nreference count of, 81–83\nreferences to, 83–84\nrepresentations of, 84–85, 297, 308\nserialization of, 268–269\nsorting, 94\nstate of, 154\ntypes of, 79, 154\nunpacking values of, 45–46, 60\nvalues of, 79, 84–85\noct() function, 37, 95, 307\noffset attribute, 317\nopen() function, 12, 15, 241, 256–261, 279, 307\noperating-system functions, 281, 316, 319\noperators, 39–40\narithmetic, 5, 40\naugmented, 7, 41, 47, 92, 111\nbitwise, 6, 40, 57\ncomparison, 6, 42–43, 93\nimplementing, 79\nlogical, 6–7, 43, 57, 92\nprecedence rules for, 56–58\nor operator, 6–7, 43, 57, 92\n__or__() method, 90\nord() function, 307\nos module, 258, 281, 319\nos._exit() method, 317\nos.chdir(), os.getcwd() methods, 257\nos.environ variable, 256\nos.path module, 281–282\nos.system() function, 284\nOSError exception, 64–65, 67–68, 277, 314,\n316–318\noutput, see input/output (I/O)\nOverflowError exception, 67, 314, 316\n__package__ attribute, 242\npackages, 33–34, 235–242\ndata files of, 241–242\ndeploying, 243–244\nexporting, 240–241",
      "content_length": 2208,
      "extraction_method": "Direct"
    },
    {
      "page_number": 347,
      "chapter": null,
      "content": "332\nIndex\nimporting files within, 34\nimports within, 237\ninstalling, 36, 244\nlocating, 36\nnamespaces of, 239–240\nnaming, 243\nsubmodules of, running as scripts, 238–239\nthird-party, 50\npandas library, 277\nparameters, see functions, arguments of\nparent classes, see base classes\npartial() function, 98\npartition() method, 299, 311\npass statement, 7, 60, 65\nPath class, 282\npath separators, 281\n__path__ attribute, 242\npathlib module, 257, 264, 281–283\npatterns, 176\nperformance, 55\nexception handling and, 111\nlocal variables and, 149–151\noptimizing, 210, 220–221\ntype checks and, 81\nPermissionError exception, 277, 316\npickle module, 268–269\npip command, 35–36, 244\npoll() function, 285\npop() method, 27, 104, 300, 302, 307, 309\nPopen class, 289\npopitem() method, 302\n__pos__() method, 91\nPOSIX standard, 281\npow() function, 5, 40, 307\n__pow__() method, 90\npower, in math, 5, 307\n__prepare__() method, 219\nprimitive types, 3\nprint() function, 4, 11–13, 84, 265, 308\nProcessLookupError exception, 316\nprograms, see also code\ncreating, 2–3\nexecuting, 1, 3, 234–235\nloading, 228, 233\nside effects in, 108\nspecifying interpreter in, 3\nstarting from packages, 244\nstructuring, 34–35, 59, 235\nterminating, 26, 69\nproperties, 180–183\nfunctions associated with, 207, 211\nimplementing, 211\n@property decorator, 180–182, 308\nprotocols, 87–99\nproxies, 104, 208\npush() method, 27\n.py suffix, 2, 3, 30, 226, 233\n__pycache__ directory, 233\npytest library, 319\nPython\napplying design patterns to, 176\nflexibility of, 86\nindentation in, 4, 316\ninteractive mode of, 1–2\nno internal variables in, 27\noptimized mode of, 77\npackage index of, 243\nruntime environment of, 254, 319\npython shell, 1\nPYTHONPATH environment variable, 234\n__qualname__ attribute, 129, 222\n__qualname__ variable, 215\nQueue class, 292\nquit(), in REPL, 2\n__radd__() method, 90–91\nraise statement, 25, 64, 69\n__rand__() method, 91\nrandom module, 319\nrange() function, 21–22, 308\nraw_input() function, 315\n__rdivmod__() method, 90\nre module, 283–284, 319\nread() function, 258\nread() method, 12, 262, 315\nread-evaluation-print loop (REPL), 1\nreadable() method, 262\nreadinto() method, 262–263\nreadline() method, 262, 315\nreadlines() method, 262",
      "content_length": 2192,
      "extraction_method": "Direct"
    },
    {
      "page_number": 348,
      "chapter": null,
      "content": "Index\n333\nrecursion, 114\nlimit of, 114, 143, 317\nRecursionError exception, 317\nreduce() function, 128\nreference counting, 81–83, 201\nreference cycle, 203\nReferenceError exception, 317\nregistries, 194, 197, 222\nregular expressions, 283–284, 319\nreload() function, 232\nremote servers, 208\nremove() method, 18, 50, 300, 307, 309\nremoveprefix() method, 299, 312\nremovesuffix() method, 299, 312\nreplace() method, 10, 299, 312\nrepr() function, 11, 85, 89, 252, 308\n__repr__() method, 28, 89–90, 154–155,\n159–199\ndefault implementation of, 160\nrequests library, 279, 294\nresources, controlling, 99\nreturn statement, 59, 109, 135, 140\nreverse() method, 300, 307\nreversed() function, 97, 308\n__reversed__() method, 97, 308\nrfind() method, 299, 312\n__rfloordiv__() method, 90\nrglob() function, 264\nrindex(), rjust() methods, 299, 312\n__rlshift__() method, 91\n__rmatmul__(), __rmod__(), __rmul__()\nmethods, 90\n__ror__(), __round__() methods, 91\nround() function, 5, 40, 308\nrpartition(), rsplit() methods, 299, 312\n__rpow__() method, 90\n__rrshift__() method, 91\n__rshift__() method, 90\nrstrip() method, 300, 312\n__rsub__(), __rtruediv__() methods, 90\nrun() function, 135, 270–271\nRuntimeError exception, 68, 114, 316–317\n__rxor__() method, 91\nsandbox, 36\nscripts, 32–33\nseek(), seekable() methods, 262\nselect module, 271, 284–285\nselect() function, 285\nselectors module, 271, 285\nself object, 27, 154, 158, 169, 220\nsend() method, 152\nsep keyword, 265, 308\nsequences\ncomparing, 43\nmutable, 49–50\noperations on, 47–50\nset comprehension, 17, 53\nset() function, 17–18, 20, 47, 309\n__set__() method, 211\n__set_name__() method, 212\nsetattr() function, 157, 179, 310\n__setattr__() method, 98, 207, 211\nsetdefault() method, 302\n__setitem__() method, 95–96, 167\nsets, 17–18\nadding/removing items to/from, 50, 309\nas literals, 38, 46\ncreating, 17, 309\nempty, 18\nimmutable, 304\nnumber of items in, 50, 306, 309\norder of elements in, 17\nprocessing, 50–51, 53–54, 309\n__setstate__() method, 268\nsetup() function, 244\nsetup.py file, 244\nsetuptools module, 234, 243–244\nSHA-1 algorithm, 278\nshallow copies, 83\nshell, 1, 284, 319\nshort-circuit evaluation, 43\nshutil module, 284, 319\nside effects, 108\nSIGINT signal, 69\nsignal module, 69\nsignature() function, 130–131\n__signature__ attribute, 131\nSimple Mail Transfer Protocol (SMTP), 285\nsin() function, 318\nsingletons, 176, 200\nsite-packages directory, 35, 244",
      "content_length": 2385,
      "extraction_method": "Direct"
    },
    {
      "page_number": 349,
      "chapter": null,
      "content": "334\nIndex\nsleep() function, 293\nslice instance, 96\nslice() function, 310\nslicing operator, 10, 47–49, 298, 307, 310, 313\nimplementing, 96\non lists, 14\non tuples, 16\n__slots__ variable, 210–211, 220–221, 223\nsmtplib module, 285–286\nsocket module, 286–287\nsort() method, 108, 307\nsorted() function, 47, 114, 310\nsplatting, 46\nsplit() function, 281\nsplit() method, 10, 300, 312\nsplitlines() method, 300, 312\nsprintf() function (C), 253\nsqrt() function, 38, 318\nstack frames, 132–133\nstack traceback objects, 65, 73\nstandard error, 263\nstandard input/output, 263, 304\nstart keyword, 62\nstartswith() method, 10, 300, 312\nstate machines, 176\nstatements, 59\nexecuting, 303\n@staticmethod decorator, 125, 173, 183, 213, 310\nstatistics module, 47, 319\nstdin, stdout attributes, 289\nStopAsyncIteration exception, 317\nStopIteration exception, 67, 69, 97, 140–141,\n147, 307, 317\nstr() function, 11, 84, 94, 168, 248, 251–252,\n310\n__str__() method, 94, 171, 310\ndefault implementation of, 160\nstrategy pattern, 176\nstrerror attribute, 316\nstride argument, 48, 49, 96\nStringIO class, 279\nstrings, 3, 9–12\nas literals, 38\nas sequences, 47\nchecking characters of, 311\ncomparing, 43\nconcatenating, 10–11, 310\nconverting\nfrom non-string values, 11, 304\nfrom objects, 94\nto numbers, 11\nconverting to upper/lowercase, 310–312\ncreating, 11, 310\nencoding/decoding, 310\nformatting, 9, 11, 250–253, 310–311\niterating over, 21\nmethods for, 10\nnonempty, 43\nnumber of items in, 10, 306, 310\nprocessing, 310–312\nrepresentations of, 89–90\nsubstrings of, 10, 310–312\ntriple-quoted, 9, 38\nwhitespace in, 312\nstrip() method, 10, 300, 312\nstruct module, 288\nstruct_time object, 293\n__sub__() method, 90\nsubclasses, 81, 160\nchecking classes against, 184, 305\nimplementing interfaces, 185\nsubprocess module, 256, 288–289\nsubtraction, 5\nsubtypes, see subclasses\nsum() function, 15, 47, 128, 312\nsuper() function, 161, 189–192, 199, 207, 313\nsuperclasses, see base classes\nswapcase() method, 300, 312\nsymmetric difference operation, 18, 50, 309\nsymmetric_difference() method, 309\nsymmetric_difference_update() method, 309\nSyntaxError exception, 316, 317\nsys module, 15, 319\nsys.argv list, 33, 254–255\nsys.exit() function, 317\nsys.getdefaultencoding() method, 259\nsys.getfilesystemencoding() function, 257,\n264\nsys._getframe() function, 132\nsys.getrecursionlimit() function, 114\nsys.getrefcount() function, 82\nsys.modules variable, 227, 232\nsys.path variable, 31, 35, 226, 234, 244\nsys.setrecursionlimit() function, 114",
      "content_length": 2480,
      "extraction_method": "Direct"
    },
    {
      "page_number": 350,
      "chapter": null,
      "content": "Index\n335\nsys.stderr object, 69, 263–264\nsys.stdin, sys.stdout objects, 263–264\nSystemError exception, 317\nSystemExit exception, 15, 26, 67, 69, 314,\n317\nTabError exception, 317\ntabulation, 19, 311, 318\nteletypewriter (TTY), 281\ntell() method, 262\ntelnet program, 274, 286\ntempfile module, 289–290\ntesting\nsmaller tasks, 145\nusing file objects for, 279\ntext, 247–248\nconverting from binary data, 274\nencoding/decoding, 13, 248–250, 255,\n259\nfitting to terminal width, 290\nhandling lines of, 260, 263\ntext attribute, 317\nTextIOWrapper class, 260\ntextwrap module, 290\nthreading module, 271, 291–293\nthreads, 271–272\nthrow() method, 147, 152\ntime module, 293, 319\ntime() function, 293\ntime, handling, 293, 318–319\nTimeoutError exception, 316\ntitle() method, 300, 312\nto_bytes() method, 305\n@trace decorator, 125–126\ntraceback messages, 24, 315\ntraceback module, 73\n__traceback__ attribute, 65, 73, 315\ntranslate() method, 299–300, 312\nTrue value, 6–7, 38, 43–45, 297–298\n__truediv__() method, 90\n__trunc__() method, 91\ntruncate() method, 262\ntruncating division, 5\ntry statement, 24–25, 64, 66, 110, 141\ntuple type, 313\ntuple() function, 47\ntuples, 15–17\nas keys, 52\nas literals, 38, 46\nas sequences, 47\ncomparing, 42\nconcatenating, 16\ncreating, 15\nempty, 43, 313\nindexing, 16\niterating over, 17, 21\nnamed, 109–110\nnumber of items in, 306, 313\nreturning values from functions with, 23, 109\nslicing, 16\nunpacking, 16\nusing in dictionaries, 19\nturtle module, 319\ntype class, 218–220, 313\ntype hints, 107, 129, 155, 179–180, 222\ncreating methods from, 197\nmodule-level, 242\nwith base classes, 184–185\ntype() function, 70, 80, 154, 217, 313\ntype-based dispatch, 193–194\nTypeError exception, 43, 68, 95, 101, 103, 122,\n191, 211, 305, 317\ntypes, 79, 313\nbuilt-in, 167–169\nchecking values against, 81, 305\nconversions between, 94–95\ntypes module, 313\nUDP servers, 287\nunary minus/plus, 5\nUnboundLocalError exception, 68, 111, 317\nUnicode encoding\ncode-point values in, 307\nin source code, 2\noperations on text strings in, 294–295\nunicodedata module, 294–295\nUnicodeError exception, 67–68, 249, 317\nUnicodeXXXError exceptions, 317\nunion operation, 18, 50, 309\nunion() method, 309\nunittest module, 319\nuniversal newline mode, 260",
      "content_length": 2217,
      "extraction_method": "Direct"
    },
    {
      "page_number": 351,
      "chapter": null,
      "content": "336\nIndex\nUNIX\nEOF character on, 2\nexecuting files on, 3\nlow-level I/O control operations on, 278\nnewline characters on, 260\npath separators on, 281\nunpack() function, 288\nupdate() method, 18, 168, 302\nupper() method, 10, 300, 312\nurlencode(), urlopen(), urlparse() functions,\n293–294\nurllib package, 293–294\nurllib.parse package, 294\nUserDict, UserList, UserString classes, 168\nUTF-8 encoding, 2, 13, 249–250\nValueError exception, 25, 67–68, 317\nvalues, 3, 79\nchecking against types, 81, 305\nminimum/maximum, 307\nprinting, 265, 308\nreducing, 128\nrepresenting, 84–85\nupdating in place, 41\nvalues() method, 21, 51, 302\nvariables, 3\nassociated types of, 3, 167\nfree, 114–115\nglobal, 111–113\nlocal, 24, 111–113, 134, 149–151\nnames of, 3\nreassigning, 108\nstarred, 46\ntype hints for, 107\nunbound, 317\nvars() function, 313\nvenv command, 36\nvirtual environment, 36\nwalrus operator, see := operator\nwarning() function, 281\nweak references, 204–206, 317\nweakref module, 204, 317\n__weakref__ attribute, 206\nweb servers, 279\nwebsites, 275, 294\nwhile statement, 4, 7–9, 12, 39, 60–62\nWindows\nEOF character on, 2\nexecuting files on, 3\nfailed system calls on, 318\nnewline characters on, 260\npath separators on, 281\nWindowsError exception, 318\nwith statement, 12, 25, 75–77, 99, 202, 256,\n289–290\nwrap() function, 290\nwrappers, 104, 208\n@wraps decorator, 124–125\nwritable() method, 262\nwrite() function, 265\nwrite() method, 13, 262\nwrite_through attribute, 263\nwritelines() method, 262\nxml package, 295–296\nxml.etree package, 295\n__xor__() method, 90\nyield from statement, 142–143\nyield statement, 97, 139–142, 265\nused as an expression, 146–147\nZeroDivisionError exception, 67, 314, 318\nzfill() method, 300, 312\nzip() function, 62, 314",
      "content_length": 1721,
      "extraction_method": "Direct"
    },
    {
      "page_number": 352,
      "chapter": null,
      "content": "Video Course Companion to \nPython Distilled\nSAVE\n60%*\nCODE: BEAZLEYVID\nSave 60%*—Use coupon code BEAZLEYVID\ninformit.com/beazley/video \n*Discount code VIDEOBOB confers a 60% discount oﬀ  the list price of featured video \nwhen purchased on InformIT. Oﬀ er is subject to change.\nPython Programming Language LiveLessons provides developers with a guided \ntour of the Python programming language, including demonstrations of many of \nthe advanced techniques used in libraries and frameworks.\nWatch and learn how to\n•\nRead and write data from ﬁ les\n•\nEﬀ ectively manipulate data using tuples, lists, sets, and dictionaries\n•\nDeﬁ ne new functions\n•\nHandle exceptions and errors\n•\nCreate new objects with classes\n•\nUtilize object-oriented programming techniques\n•\nCustomize objects with special methods, properties, and descriptors\n•\nUse metaprogramming features including decorators, class decorators, and\nmetaclasses\n•\nPlace code into modules and packages",
      "content_length": 950,
      "extraction_method": "Direct"
    },
    {
      "page_number": 353,
      "chapter": null,
      "content": "Addison-Wesley • Adobe Press • Cisco Press • Microsoft Press • Pearson IT Certification • Que • Sams • Peachpit Press\nPython Programming\nBooks, eBooks & Video\nInformIT, the website for Pearson technical imprints, including Addison-\nWesley, has Python programming tutorials, references, and pragmatic \nguides for all levels of experience. Most of our eBooks are DRM-free and \nare delivered in three formats: PDF, EPUB, and MOBI.\nVisit informit.com/python to shop, preview sample chapters, and watch \nfree video lessons from our catalog.\nPython Essential Reference - David Beazley\nEffective Python - Brett Slatkin\nLearn More Python 3 the Hard Way - Zed Shaw\nModern Python LiveLessons - Raymond Hettinger\nSupercharged Python - Brian Overland\nRefactoring in Python LiveLessons - Bryan Beecham\nMachine Learning with Python for Everyone - Mark E. Fenner\nThe Python 3 Standard Library by Example - Doug Hellman",
      "content_length": 903,
      "extraction_method": "Direct"
    },
    {
      "page_number": 354,
      "chapter": null,
      "content": "V I D E O  T R A I N I N G  F O R  T H E  I T  P R O F E S S I O N A L\n*Discount code VIDBOB confers a 50% discount oﬀ the list price of eligible titles purchased on informit.com. Eligible titles include most full-course video titles. Book + eBook bundles, \nbook/eBook + video bundles, individual video lessons, Rough Cuts, Safari Books Online, non-discountable titles, titles on promotion with our retail partners, and any title featured \nas eBook Deal of the Day or Video Deal of the Week is not eligible for discount. Discount may not be combined with any other oﬀer and is not redeemable for cash. Oﬀer subject to change.\nLearn more, browse our store, and watch free, sample lessons at  \ninformit.com/video \nSave 50%* off the list price of video courses with discount code VIDBOB\nLEARN QUICKLY \nLearn a new technology in just hours. Video training can teach more in \nless time, and material is generally easier to absorb and remember.\nWATCH AND LEARN \nInstructors demonstrate concepts so you see technology in action.\nTEST YOURSELF \nOur Complete Video Courses oﬀer self-assessment quizzes throughout.\nCONVENIENT \nMost videos are streaming with an option to download lessons for oﬄine viewing.\nPhoto by Marvent/Shutterstock",
      "content_length": 1226,
      "extraction_method": "Direct"
    },
    {
      "page_number": 355,
      "chapter": null,
      "content": "Addison-Wesley • Adobe Press • Cisco Press • Microsoft Press • Pearson IT Certification • Que • Sams • Peachpit Press\nRegister Your Product at informit.com/register  \nAccess additional benefits and save 35% on your next purchase\n• \n Automatically receive a coupon for 35% off your next purchase, valid \nfor 30 days. Look for your code in your InformIT cart or the Manage \nCodes section of your account page.\n• \nDownload available product updates.\n• \nAccess bonus material if available.* \n• \n Check the box to hear from us and receive exclusive offers on new  \neditions and related products.  \n*Registration benefits vary by product. Benefits will be listed on your account page under \nRegistered Products.\nInformIT.com—The Trusted Technology Learning Source\nInformIT is the online home of information technology brands at Pearson, the world’s         \nforemost education company. At InformIT.com, you can: \n• \nShop our books, eBooks, software, and video training\n• \nTake advantage of our special offers and promotions (informit.com/promotions)\n• \nSign up for special offers and content newsletter (informit.com/newsletters)\n• \nAccess thousands of free chapters and video lessons\nConnect with InformIT—Visit informit.com/community\nPhoto by izusek/gettyimages",
      "content_length": 1257,
      "extraction_method": "Direct"
    }
  ],
  "enrichment": {
    "version": "1.0.0",
    "generated_by": "generate_chapter_metadata.py",
    "contains": [
      "keywords",
      "concepts",
      "summary"
    ]
  }
}