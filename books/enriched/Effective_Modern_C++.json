{
  "metadata": {
    "title": "Effective_Modern_C++",
    "source_file": "Effective_Modern_C++_metadata.json"
  },
  "chapters": [
    {
      "chapter_number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "summary": "Modern C++\n42 SPECIFIC WAYS TO IMPROVE YOUR USE OF C++11 AND C++14\nPROGRAMMING/C++\nEffective Modern C++\nhow to use C++ in \nEffective C++ books.\nEffective Modern C++ \nmodern C++ effectively \nusing C++11 and C++14—i.e., using modern C++.\nrequire revision for software development in modern C++\nEffective Modern C++ follows the proven guideline-based, example-driven \nessential reading for every modern C++ software developer.\nFor more than 20 years, Scott Meyers' Effective C++ books (Effective C++, More \nSo, still interested in C++?\nModern C++ (i.e., C++11/C++14)\nConcerning C++, Scott Meyers was\nEffective Modern C++ is a towering achievement from a consummate technical writer.\ntechnical mistake, a dull moment, or a lazy sentence in Effective Modern C++.\nPh.D., Research Scientist, Facebook, and author of Modern C++ Design\nEffective Modern C++ makes us share this same feeling by clearly explaining\nof C++11 and C++14.\nPraise for Effective Modern C++\nHis Effective C++ books helped to raise the coding style of a previous generation of C++\nprogrammers; the new book seems positioned to do the same for those using modern C++.\nEffective Modern C++ is a great tool to improve your modern C++ skills.\nteach you how, when and where to use modern C++ and be effective, it also explains why.\nScott’s Effective C++ books are the definitive answer to this question.\nGreat read for transitioning to modern C++—new C++11/14\nlanguage features are described alongside C++98, subject items are\nclear information Scott provides in Effective Modern C++.\nC++11 code, you’ll probably discover issues with the new features through Scott’s\nEffective Modern C++\nEffective Modern C++\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Effective Modern C++, the cover image",
      "keywords": [
        "Effective Modern",
        "Modern",
        "Effective",
        "Scott Meyers",
        "Scott",
        "Scott Meyers' Effective",
        "Scott Meyers book",
        "Meyers",
        "Software",
        "features",
        "great Scott Meyers",
        "book",
        "Meyers' Effective",
        "O’Reilly Media",
        "Development Engineer"
      ],
      "concepts": [
        "effective",
        "scott",
        "books",
        "technical",
        "software",
        "useful",
        "great",
        "clear",
        "write",
        "writing"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 3,
          "title": "",
          "score": 0.477,
          "base_score": 0.477,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 4,
          "title": "",
          "score": 0.355,
          "base_score": 0.355,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 2,
          "title": "",
          "score": 0.312,
          "base_score": 0.312,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 11,
          "title": "",
          "score": 0.31,
          "base_score": 0.31,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 10,
          "title": "",
          "score": 0.308,
          "base_score": 0.308,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "effective",
          "modern",
          "effective modern",
          "scott",
          "meyers"
        ],
        "semantic": [],
        "merged": [
          "effective",
          "modern",
          "effective modern",
          "scott",
          "meyers"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.26508010112231084,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:02:16.725035+00:00"
      }
    },
    {
      "chapter_number": 2,
      "title": "Segment 2 (pages 9-16)",
      "start_page": 9,
      "end_page": 16,
      "summary": "Item 1: Understand template type deduction.\nItem 2: Understand auto type deduction.\nItem 3: Understand decltype.\nItem 4: Know how to view deduced types.\nItem 5: Prefer auto to explicit type declarations.\nItem 6: Use the explicitly typed initializer idiom when auto deduces\nItem 11: Prefer deleted functions to private undefined ones.\nItem 12: Declare overriding functions override.\nItem 15: Use constexpr whenever possible.\nItem 16: Make const member functions thread safe.\nItem 17: Understand special member function generation.\nItem 18: Use std::unique_ptr for exclusive-ownership resource\nItem 19: Use std::shared_ptr for shared-ownership resource\nItem 20: Use std::weak_ptr for std::shared_ptr-like pointers that can\nItem 21: Prefer std::make_unique and std::make_shared to direct use of\nItem 22: When using the Pimpl Idiom, define special member functions in\nItem 23: Understand std::move and std::forward.\nItem 25: Use std::move on rvalue references, std::forward on universal\nItem 26: Avoid overloading on universal references.\nItem 28: Understand reference collapsing.\nItem 32: Use init capture to move objects into closures.\nItem 33: Use decltype on auto&& parameters to std::forward them.\nItem 34: Prefer lambdas to std::bind.\nItem 35: Prefer task-based programming to thread-based.\nItem 37: Make std::threads unjoinable on all paths.\nItem 40: Use std::atomic for concurrency, volatile for special memory.\nbook does not require permission.\nfrom O’Reilly books does require permission.\nbook and quoting example code does not require permission.\ntive professionals use Safari Books Online as their primary resource for research,\nbook,” and Andrei Alexandrescu (author of Modern C++ Design, Addison-Wesley,\nItem 4’s use of an undefined template to coax type\nIn Item 5, the unsigned-\nthe same Item is from Stephan T.\n&& Secrets.” Item 6 was inspired by Herb Sutter’s 12 August 2013 article, “GotW #94\nSolution: AAA Style (Almost Always Auto).” Item 9 was motivated by Martinho Fer‐\nnandes’ blog post of 27 May 2012, “Handling dependent names.” The Item 12 exam‐\nMy Item 15 treatment of\nItem 16 is based on Herb Sutter’s C++ and Beyond\n2012 presentation, “You don’t know const and mutable.” Item 18’s advice to have\narticle, “GotW# 90 Solution: Factories.” In Item 19, fastLoadWidget is derived from\nment of std::unique_ptr and incomplete types in Item 22 draws on Herb Sutter’s\nexample in Item 25 is based on writings by David Abrahams.\nlambda move capture,” was the source of Item 32’s std::bind-based approach to\nobjects.” Item 41 was originally motivated by discussions of David Abrahams’ 15\nIn Item 42,",
      "keywords": [
        "Item",
        "std",
        "Safari Books Online",
        "Books Online",
        "book",
        "Herb Sutter",
        "Prefer",
        "Safari Books",
        "Stephan T. Lavavej",
        "functions",
        "Online",
        "Understand",
        "Sutter",
        "Press",
        "Modern"
      ],
      "concepts": [
        "item",
        "std",
        "types",
        "functions",
        "function",
        "press",
        "uses",
        "prefer",
        "examples",
        "professionals"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 14,
          "title": "",
          "score": 0.684,
          "base_score": 0.684,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "",
          "score": 0.596,
          "base_score": 0.596,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 13,
          "title": "",
          "score": 0.577,
          "base_score": 0.577,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 4,
          "title": "",
          "score": 0.547,
          "base_score": 0.547,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 9,
          "title": "",
          "score": 0.535,
          "base_score": 0.535,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "item",
          "sutter",
          "std",
          "books",
          "understand"
        ],
        "semantic": [],
        "merged": [
          "item",
          "sutter",
          "std",
          "books",
          "understand"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4638652610452407,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:02:16.725127+00:00"
      }
    },
    {
      "chapter_number": 3,
      "title": "Segment 3 (pages 17-24)",
      "start_page": 17,
      "end_page": 24,
      "summary": "It’s C++, only more so.” But as you\nC++, to say nothing of the new concurrency features.\nIf you need basic information about “modern” C++ features, resources abound,\nIt’s devoted not to describing the features of C++11\nC++.\nC++98 and C++03 differ only in technical\ndetails, so in this book, I refer to both as C++98.\nWhen I refer to C++11, I mean both\nC++14, I mean specifically C++14.\nC++\nC++98\nC++98 and C++03\nC++11\nC++11 and C++14\nC++14\nC++14\nthat C++11 supports lambda expressions (true for C++11 and C++14), and that\nC++14 offers generalized function return type deduction (true for C++14 only).\nThat’s because rvalues indicate objects eligible for move operations, while lvalues\ntemporary objects returned from functions, while lvalues correspond to objects you\nA useful heuristic to determine whether an expression is an lvalue is to ask if you can\nT, you can have lvalues of type T as well as rvalues of type T.\nto remember this when dealing with a parameter of rvalue reference type, because the\n…                        // an rvalue reference type\nso rhs is an lvalue, even though its type is an rvalue reference.\nI use Widget whenever I want to refer to an arbitrary\nUnless I need to show specific details of the class, I use Widget\nfrom the wide ellipsis (“...”) that’s used in the source code for C++11’s variadic\nTs>                // these are C++\nThe declaration of processVals shows that I use typename when declaring type\nfrom a C++ Standard, I declare type parameters using class, because that’s what\nRegrettably, there’s no terminology in C++ that distinguishes between\nCopies of rvalues are generally move constructed, while copies of lvalues are usually\nanother object, it’s not possible to say how expensive it was to construct the copy.\nparameter w without knowing whether rvalues or lvalues are passed to someFunc.\nIn a function call, the expressions passed at the call site are the function’s arguments.\nThe arguments are used to initialize the function’s parameters.\nfunction is passed to a second function such that the original argument’s rvalueness\nWell-designed functions are exception safe, meaning they offer at least the basic\nWhen I refer to a function object, I usually mean an object of a type supporting an\nator(), but also functions and C-like function pointers.\ncomes from C++98, the broader one from C++11.) Generalizing further by adding\nmember function pointers yields what are known as callable objects.\nobjects as things in C++ that can be invoked using some kind of function-calling syn‐\nFunction objects created through lambda expressions are known as closures.\n(i.e., the functions generated from function templates).\nMany things in C++ can be both declared and defined.\nclass Widget;                       // class declaration\nbool func(const Widget& w);         // function declaration\nclass Widget {                      // class definition\n{ return w.size() < 10; }           // function definition\nA definition also qualifies as a declaration, so unless it’s really important that some‐\nthing is a definition, I tend to refer to declarations.\nI define a function’s signature to be the part of its declaration that specifies parameter\nFunction and parameter names are not part of the signature.\ndeclaration other than its parameter and return types (e.g., noexcept or constexpr,\nbook, my definition is more useful.\nNew C++ Standards generally preserve the validity of code written under older ones,\ndeprecated in C++11, because std::unique_ptr does the same job, only better.",
      "keywords": [
        "Widget",
        "function",
        "type",
        "object",
        "code",
        "move",
        "copy",
        "functions",
        "parameter",
        "class Widget",
        "book",
        "definition",
        "const Widget",
        "declaration",
        "lvalues"
      ],
      "concepts": [
        "objects",
        "definition",
        "definitions",
        "code",
        "standards",
        "declarations",
        "declaring",
        "declare",
        "widget",
        "useful"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 4,
          "title": "",
          "score": 0.723,
          "base_score": 0.573,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 10,
          "title": "",
          "score": 0.492,
          "base_score": 0.492,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 1,
          "title": "",
          "score": 0.477,
          "base_score": 0.477,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 24,
          "title": "",
          "score": 0.47,
          "base_score": 0.47,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 2,
          "title": "",
          "score": 0.432,
          "base_score": 0.432,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "function",
          "lvalues",
          "14",
          "declaration",
          "definition"
        ],
        "semantic": [],
        "merged": [
          "function",
          "lvalues",
          "14",
          "declaration",
          "definition"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.41040413499703765,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725261+00:00"
      }
    },
    {
      "chapter_number": 4,
      "title": "Segment 4 (pages 25-35)",
      "start_page": 25,
      "end_page": 35,
      "summary": "Deducing Types\nC++98 had a single set of rules for type deduction: the one for function templates.\ntype deduction takes place: in calls to function templates, in most situations where\nIt explains how template type deduction works, how auto builds on\nthat compilers are deducing the types you want them to.\nItem 1: Understand template type deduction.\ndescription of how the types used by those functions were deduced.\ntype deduction for templates is the basis for one of modern C++’s most compelling\nIf you were happy with how C++98 deduced types for templates,\nyou’re set up to be happy with how C++11 deduces types for auto.\nthat when the template type deduction rules are applied in the context of auto, they\nvoid f(const T& param);     // ParamType is const T&\n• ParamType is a pointer or reference type, but not a universal reference.\nThe simplest situation is when ParamType is a reference type or a pointer type, but\nIn that case, type deduction works like this:\n1. If expr’s type is a reference, ignore the reference part.\nthe deduced types for param and T in various calls are as follows:\nf(x);                   // T is int, param's type is int&\nf(cx);                  // T is const int,\n// param's type is const int&\nf(rx);                  // T is const int,\n// param's type is const int&\nis deduced to be const int, thus yielding a parameter type of const int&.\nWhen they pass a const object to a reference parameter, they\nThat’s why passing a const object to a template taking a T& parameter is safe:\nthe constness of the object becomes part of the type deduced for T.\nIn the third example, note that even though rx’s type is a reference, T is deduced to\nThat’s because rx’s reference-ness is ignored during type deduc‐\nThese examples all show lvalue reference parameters, but type deduction works\nto do with type deduction.\nIf we change the type of f’s parameter from T& to const T&, things change a little, but\nf(x);                    // T is int, param's type is const int&\nf(cx);                   // T is int, param's type is const int&\nf(rx);                   // T is int, param's type is const int&\nAs before, rx’s reference-ness is ignored during type deduction.\nIf param were a pointer (or a pointer to const) instead of a reference, things would\nf(&x);                   // T is int, param's type is int*\n// param's type is const int*\nin a type deduction system.\nparameters are declared like rvalue references (i.e., in a function template taking a\ntype parameter T, a universal reference’s declared type is T&&), but they behave differ‐\nFirst, it’s the only situation in template type deduction\nusing the syntax for an rvalue reference, its deduced type is an lvalue reference.\n// param's type is also int&\n// param's type is also const int&\n// param's type is also const int&\n// param's type is therefore int&&\nhere is that the type deduction rules for universal reference parameters are different\nlar, when universal references are in use, type deduction distinguishes between lvalue\n1. As before, if expr’s type is a reference, ignore the reference part.\nf(x);                // T's and param's types are both int\nf(cx);               // T's and param's types are again both int\nf(rx);               // T's and param's types are still both int\nwhen deducing a type for param: just because expr can’t be modified doesn’t mean\nconst, the constness of expr is preserved during type deduction.\nf(ptr);                  // pass arg of type const char * const\nwith the type deduction rule for by-value parameters, the constness of ptr will be\nignored, and the type deduced for param will be const char*, i.e., a modifiable\nduring type deduction, but the constness of ptr itself is ignored when copying it to\nIt’s that array types are different from pointer\nThese types (const char* and const char[13]) are not the same,\nvoid f(T param);      // template with by-value parameter\nf(name);              // what types are deduced for T and param?\nC roots at the base of C++, and it fosters the illusion that array and pointer types are\nthe type of an array that’s passed to a template function by value is deduced to be a\npointer type.\nThat means that in the call to the template f, its type parameter T is\nf(name);          // name is array, but T deduced as const char*\nvoid f(T& param);      // template with by-reference parameter\nthe type deduced for T is the actual type of the array!\nthe array, so in this example, T is deduced to be const char [13], and the type of f’s\nparameter (a reference to this array) is const char (&)[13].\ntion for arrays applies to type deduction for functions and their decay into function",
      "keywords": [
        "type",
        "const int",
        "const",
        "type deduction",
        "int",
        "param",
        "param type",
        "reference",
        "template type deduction",
        "template",
        "const char",
        "deduction",
        "pointer",
        "template type",
        "Item"
      ],
      "concepts": [
        "reference",
        "templates",
        "types",
        "array",
        "declared",
        "declarations",
        "declares",
        "deduction",
        "deductions",
        "pointer"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 5,
          "title": "",
          "score": 0.838,
          "base_score": 0.838,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 3,
          "title": "",
          "score": 0.723,
          "base_score": 0.573,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 20,
          "title": "",
          "score": 0.64,
          "base_score": 0.64,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 8,
          "title": "",
          "score": 0.627,
          "base_score": 0.627,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 2,
          "title": "",
          "score": 0.547,
          "base_score": 0.547,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "type",
          "param",
          "const",
          "deduction",
          "type deduction"
        ],
        "semantic": [],
        "merged": [
          "type",
          "param",
          "const",
          "deduction",
          "type deduction"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4422154989422893,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725330+00:00"
      }
    },
    {
      "chapter_number": 5,
      "title": "Segment 5 (pages 36-48)",
      "start_page": 36,
      "end_page": 48,
      "summary": "So there you have it: the auto-related rules for template type deduction.\n• During template type deduction, arguments that are references are treated as\n• During template type deduction, arguments that are array or function names\nItem 2: Understand auto type deduction.\nIf you’ve read Item 1 on template type deduction, you already know almost every‐\nthing you need to know about auto type deduction, because, with only one curious\nexception, auto type deduction is template type deduction.\nTemplate type deduction involves templates and functions and parameters, but auto\ndeduction and auto type deduction.\nIn Item 1, template type deduction is explained using this general function template\nHere, the type specifier for x is simply auto by itself.\nthe type specifier is const auto.\nthe type specifier is const auto&.\n// deduced type is x's type\nAs I said, deducing types for auto is, with only one exception (which we’ll discuss\nsoon), the same as deducing types for templates.\nItem 1 divides template type deduction into three cases, based on the characteristics\nof ParamType, the type specifier for param in the general function template.\nable declaration using auto, the type specifier takes the place of ParamType, so there\n// so uref2's type is const int&\nThat happens in auto type deduction, too:\nauto arr1 = name;              // arr1's type is const char*\nauto& arr2 = name;             // arr2's type is\nAs you can see, auto type deduction works like template type deduction.\nof fixed types, so it’d be nice to replace int with auto in the above variable declara‐\nThe first two statements do, indeed, declare a variable of type int with\nThe second two, however, declare a variable of type std::initial\nauto x1 = 27;             // type is int, value is 27\nauto x3 = { 27 };         // type is std::initializer_list<int>,\nThis is due to a special type deduction rule for auto.\nauto-declared variable is enclosed in braces, the deduced type is a std::initial\nstems from the use of auto: x5’s type has to be deduced.\nThe treatment of braced initializers is the only way in which auto type deduction and\ntemplate type deduction differ.\nbraced initializer, the deduced type is an instantiation of std::initializer_list.\nBut if the corresponding template is passed the same initializer, type deduction fails,\nauto x = { 11, 23, 9 };   // x's type is\ncan't deduce type for T\nfor some unknown T, template type deduction will deduce what T is:\n// type is std::initializer_list<int>\nSo the only real difference between auto and template type deduction is that auto\nYou might wonder why auto type deduction has a special rule for braced initializers,\nbut template type deduction does not.\ninitializer, the deduced type will always be std::initializer_list.\nauto to indicate that a function’s return type should be deduced (see Item 3), and\nauto employ template type deduction, not auto type deduction.\nauto return type that returns a braced initializer won’t compile:\nreturn { 1, 2, 3 };         // error: can't deduce type\nThe same is true when auto is used in a parameter type specification in a C++14\ncan't deduce type\n• auto type deduction is usually the same as template type deduction, but auto\ntype deduction assumes that a braced initializer represents a std::initial\nizer_list, and template type deduction doesn’t.\n• auto in a function return type or a lambda parameter implies template type\ndeduction, not auto type deduction.\nwhat happens during type deduction for templates and auto (see Items 1 and 2),\ndecltype typically parrots back the exact type of the name or expression you give it:\nThe return type of the function should\nbe the same as the type returned by the indexing operation.\noperator[] on a container of objects of type T typically returns a T&.\nItem 6, but what’s important here is that the type returned by a container’s opera\nwrite, showing the use of decltype to compute the return type.\nThe use of auto before the function name has nothing to do with type deduction.\nfunction’s return type will be declared following the parameter list (after the “->”).\nreturn type using c and i.\nIf we were to have the return type precede the function\nWith this declaration, authAndAccess returns whatever type operator[] returns\nC++11 permits return types for single-statement lambdas to be deduced, and C++14\ntrailing return type, leaving just the leading auto.\nauto does mean that type deduction will take place.\npilers will deduce the function’s return type from the function’s implementation:\nreturn c[i];                  // return type deduced from c[i]\nItem 2 explains that for functions with an auto return type specification, compilers\nemploy template type deduction.\ntemplate type deduction, the reference-ness of an initializing expression is ignored.\nHere, d[5] returns an int&, but auto return type deduction for authAndAccess will\nstrip off the reference, thus yielding a return type of int.\nTo get authAndAccess to work as we’d like, we need to use decltype type deduction\nfor its return type, i.e., to specify that authAndAccess should return exactly the same\ntype that the expression c[i] returns.\nuse decltype type deduction rules in some cases where types are inferred, make this\nthe type is to be deduced, and decltype says that decltype rules should be used\nThe use of decltype(auto) is not limited to function return types.\nconvenient for declaring variables when you want to apply the decltype type deduc‐\nauto myWidget1 = cw;             // auto type deduction:\ndecltype(auto) myWidget2 = cw;   // decltype type deduction:\ndecltype(auto) authAndAccess(Container& c, Index i);\ndecltype(auto) authAndAccess(Container&& c,     // universal\nIn this template, we don’t know what type of container we’re operating on, and that\nC++14 counterpart, except that you have to specify the return type yourself:\nApplying decltype to a name yields the declared type for that name.\nT, decltype reports that type as T&.\nthe type that decltype reports for it!\nwrite a return statement can affect the deduced type for a function:\naffect the type that decltype(auto) reports.\nand in conjunction with auto) may occasionally yield type-deduction surprises, but\ndecltype does just what it sounds like: it reports that name’s declared type.\n• decltype almost always yields the type of a variable or expression without\n• For lvalue expressions of type T other than names, decltype always reports a\ntype of T&.\n• C++14 supports decltype(auto), which, like auto, deduces a type from its\ninitializer, but it performs the type deduction using the decltype rules.\nan IDE editor would likely show that x’s deduced type was int and y’s was const\nwhat types it deduced.",
      "keywords": [
        "type",
        "template type deduction",
        "type deduction",
        "auto type deduction",
        "template type",
        "auto",
        "return type",
        "auto type",
        "deduction",
        "template",
        "int",
        "Item",
        "decltype",
        "container",
        "auto return type"
      ],
      "concepts": [
        "returns",
        "item",
        "templates",
        "deduction",
        "references",
        "refer",
        "std",
        "cases",
        "initialize",
        "initializing"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 4,
          "title": "",
          "score": 0.838,
          "base_score": 0.838,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 8,
          "title": "",
          "score": 0.687,
          "base_score": 0.537,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 19,
          "title": "",
          "score": 0.596,
          "base_score": 0.446,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 6,
          "title": "",
          "score": 0.59,
          "base_score": 0.44,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 20,
          "title": "",
          "score": 0.542,
          "base_score": 0.542,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "type",
          "deduction",
          "type deduction",
          "auto",
          "template type"
        ],
        "semantic": [],
        "merged": [
          "type",
          "deduction",
          "type deduction",
          "auto",
          "template type"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.343655792905226,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725363+00:00"
      }
    },
    {
      "chapter_number": 6,
      "title": "Segment 6 (pages 49-59)",
      "start_page": 49,
      "end_page": 59,
      "summary": "An effective way to get a compiler to show a type it has deduced is to use that type in\nSuppose, for example, we’d like to see the types that were deduced for x and y in the\nTo see the types for x and y, just try to instantiate\nTD with their types:\nerror: aggregate 'TD<const int *> yType' has incomplete type\ntypeid and std::type_info::name to the rescue.” In our continuing quest to see\nstd::cout << typeid(x).name() << '\\n';    // display types for\nyields a std::type_info object, and std::type_info has a member function, name,\ntype.\nCalls to std::type_info::name are not guaranteed to return anything sensible, but\nClang compilers report that the type of x is “i”, and the type of y is “PKi”, for exam‐\nThis code, which involves a user-defined type (Widget), an STL container (std::vec\nmight want some visibility into the types your compilers are deducing.\nthe types you’d like to see: \n}                                                     // type\nSo these compilers tell us that both T and param are of type\ntype is const T&.\nsame type?\nIf T were int, for example, param’s type should be const int&—not the\nsame type at all.\nSadly, the results of std::type_info::name are not reliable.\nple, the type that all three compilers report for param are incorrect.\nFirst the type’s reference-ness is removed, and then the constness of the resulting\ntype as (I am not making this up):\nstd::_Simple_types<std::_Wrap_alloc<std::_Vec_base_types<Widget,\nstd::allocator<Widget> >::_Alloc>::value_type>::value_type *\nThe same IDE editor shows param’s type as:\nconst std::_Simple_types<...>::value_type *const &\nwhere std::type_info::name and IDEs may fail, the Boost TypeIndex library\nHere’s how our function f can produce accurate type information using Boost.Type‐\n// show param's type\nThe result is a boost::typeindex::type_index\nto help you figure out what types your compilers are deducing.\n• Deduced types can often be seen using IDE editors, compiler error messages,\nFurthermore, some of auto’s type deduc‐\nknow how to guide auto to the right answer, because falling back on manual type\nItem 5: Prefer auto to explicit type declarations.\ntypename std::iterator_traits<It>::value_type\n“typename std::iterator_traits<It>::value_type” to express the type of\nThe type of a closure is known only to the compiler,\nauto variables have their type deduced from their initializer, so they must be initial‐\nAnd because auto uses type deduction (see Item 2), it can represent types known\n[](const std::unique_ptr<Widget>& p1,   // for Widgets\nconst std::unique_ptr<Widget>& p2)   // pointed to by\n[](const auto& p1,                      // function for\ndeclare a variable that holds a closure, because we can use a std::function object.\nJust as you must specify the type of function to point to\npoint to), you must specify the type of function to refer to when you create a\nstd::function object.\nFor example, to declare a std::function object named func that could refer to any\nbool(const std::unique_ptr<Widget>&,  // C++11 signature for\nstd::function<bool(const std::unique_ptr<Widget>&,\nstd::function objects.\nstd::function<bool(const std::unique_ptr<Widget>&,\nconst std::unique_ptr<Widget>&)>\nderefUPLess = [](const std::unique_ptr<Widget>& p1,\nconst std::unique_ptr<Widget>& p2)\nrepeat the parameter types, using std::function is not the same as using auto.\nauto-declared variable holding a closure has the same type as the closure, and as such\nThe type of a std::function-\ndeclared variable holding a closure is an instantiation of the std::function tem‐\nstd::function object typically uses more memory than the auto-declared object.\nwriting “auto” is a whole lot less work than writing the type of the std::function\nIn the competition between auto and std::function for holding a\nmade for auto over std::function for holding the result of calls to std::bind, but\nThe official return type of v.size() is std::vector<int>::size_type, but few\nstd::vector<int>::size_type is specified to be an\n32-bit Windows, for example, both unsigned and std::vector<int>::size_type\ntor<int>::size_type is 64 bits.\nauto sz = v.size();  // sz's type is std::vector<int>::size_type\nfor (const std::pair<std::string, int>& p : m)\ndered_map is const, so the type of std::pair in the hash table (which is what a\n<const std::string, int>.\nBut that’s not the type declared for the variable p in the\nstd::pair<const std::string, int> objects (i.e., what’s in the hash table) to\nstd::pair<std::string, int> objects (the declared type for p).\nSuch unintentional type mismatches can be autoed away:\ntor<int>::size_type and writing std::pair<std::string, int> when you\nIf you use auto as the type of the target variable, you need not worry about\nThere are thus several reasons to prefer auto over explicit type declarations.\nThe type for each auto variable is deduced from its initializing expres‐\ntional type declarations: the readability of the resulting source code.",
      "keywords": [
        "type",
        "std",
        "const std",
        "Widget",
        "const",
        "Widget const",
        "class Widget const",
        "auto",
        "Widgets const std",
        "function",
        "type const Widget",
        "int",
        "param",
        "Item",
        "class Widget"
      ],
      "concepts": [
        "type",
        "typing",
        "std",
        "compiler",
        "widget",
        "function",
        "functions",
        "error",
        "variable",
        "variables"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 8,
          "title": "",
          "score": 0.767,
          "base_score": 0.617,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 19,
          "title": "",
          "score": 0.703,
          "base_score": 0.553,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 10,
          "title": "",
          "score": 0.598,
          "base_score": 0.598,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 5,
          "title": "",
          "score": 0.59,
          "base_score": 0.44,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 7,
          "title": "",
          "score": 0.564,
          "base_score": 0.564,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "std",
          "type",
          "std function",
          "const",
          "const std"
        ],
        "semantic": [],
        "merged": [
          "std",
          "type",
          "std function",
          "const",
          "const std"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.41397147237595894,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725417+00:00"
      }
    },
    {
      "chapter_number": 7,
      "title": "Segment 7 (pages 60-80)",
      "start_page": 60,
      "end_page": 80,
      "summary": "thermore, auto types automatically change if the type of their initializing expression\n• auto variables must be initialized, are generally immune to type mismatches\nItem 6: Use the explicitly typed initializer idiom when\nand returns a std::vector<bool>, where each bool indicates whether the Widget\nstd::vector<bool> features(const Widget& w);\nIn the code using auto, the type of\nThough std::vector<bool> conceptually holds\nbools, operator[] for std::vector<bool> doesn’t return a reference to an element\nof the container (which is what std::vector::operator[] returns for every type\nInstead, it returns an object of type std::vector<bool>::reference\n(a class nested inside std::vector<bool>).\nstd::vector<bool>::reference exists because std::vector<bool> is specified to\nstd::vector<bool>’s operator[], because operator[] for std::vector<T> is\nbool&, operator[] for std::vector<bool> returns an object that acts like a bool&.\nFor this act to succeed, std::vector<bool>::reference objects must be usable in\nHere, features returns a std::vector<bool> object, on which operator[] is\noperator[] returns a std::vector<bool>::reference object, which is\nthen implicitly converted to the bool that is needed to initialize highPriority.\nPriority thus ends up with the value of bit 5 in the std::vector<bool> returned\n// type\nAgain, features returns a std::vector<bool> object, and, again, operator[] is\noperator[] continues to return a std::vector<bool>::reference\nobject, but now there’s a change, because auto deduces that as the type of highPrior\nhighPriority doesn’t have the value of bit 5 of the std::vector<bool>\nThe value it does have depends on how std::vector<bool>::reference is imple‐\nstd::vector<bool>::reference implementation is in place.\nThe call to features returns a temporary std::vector<bool> object.\ninvoked on temp, and the std::vector<bool>::reference it returns contains a\nstd::vector<bool>::reference object, so highPriority, too, contains a pointer\nstd::vector<bool>::reference is an example of a proxy class: a class that exists\nstd::vector<bool>::reference\nexists to offer the illusion that operator[] for std::vector<bool> returns a refer‐\nence to a bit, for example, and the Standard Library’s smart pointer types (see Chap‐\nstd::vector<bool>::reference is an exam‐\nAs was the case with std::vector<bool>::reference and\nthe case with std::vector<bool>::reference, and we’ve seen that violating that\nauto someVar = expression of \"invisible\" proxy class type;\nHere’s the spec for std::vector<bool>::operator[], for example:\nAssuming you know that operator[] for std::vector<T> normally returns a T&,\nThe way you do that is what I call the explicitly typed initializer idiom.\nThe explicitly typed initializer idiom involves declaring a variable with auto, but\ncasting the initialization expression to the type you want auto to deduce.\nauto highPriority = static_cast<bool>(features(w)[5]);\nHere, features(w)[5] continues to return a std::vector<bool>::reference\nobject, just as it always has, but the cast changes the type of the expression to bool,\nwhich auto then deduces as the type for highPriority.\ntor<bool>::reference object returned from std::vector<bool>::operator[]\nstill-valid pointer to the std::vector<bool> returned from features is derefer‐\nFor the Matrix example, the explicitly typed initializer idiom would look like this:\nApplications of the idiom aren’t limited to initializers yielding proxy class types.\nreturned by the function.” A declaration using the explicitly typed initializer idiom,\nThe explicitly typed initializer idiom makes things transparent:\n• The explicitly typed initializer idiom forces auto to deduce the type you want\ninitialization values may be specified with parentheses, an equals sign, or braces:\nint x(0);             // initializer is in parentheses\nint y = 0;            // initializer follows \"=\"\nint z{ 0 };           // initializer is in braces\nint z = { 0 };        // initializer uses \"=\" and braces\ndefined types, it’s important to distinguish initialization from assignment, because\nBraced initialization lets you express the formerly inexpressible.\nstd::vector<int> v{ 1, 3, 5 }; // v's initial content is 1, 3, 5\nBraces can also be used to specify default initialization values for non-static data\nOn the other hand, uncopyable objects (e.g., std::atomics—see Item 40) may be\ninitialized using braces or parentheses, but not using “=”: \nIt’s thus easy to understand why braced initialization is called “uniform.” Of C++’s\nthree ways to designate an initializing expression, only braces can be used every‐\nIf the value of an expression in a braced initializer isn’t\nguaranteed to be expressible by the type of the object being initialized, the code won’t\nAnother noteworthy characteristic of braced initialization is its immunity to C++’s\nbraced initializers, std::initializer_lists, and constructor overload resolution.\nbraced initializer, the type deduced is std::initializer_list, even though other\ntype.\nbraced initialization.\nstd::initializer_list parameters are not involved:\nWidget(int i, bool b);      // ctors not declaring\nWidget(int i, double d);    // std::initializer_list params\nIf, however, one or more constructors declare a parameter of type std::initial\nizer_list, calls using the braced initialization syntax strongly prefer the overloads\ntaking std::initializer_lists.\nstrue a call using a braced initializer to be to a constructor taking a std::initial\naugmented with a constructor taking a std::initializer_list<long double>, for\nWidget(std::initializer_list<long double> il);   // added\ntype of the std::initializer_list elements (long double) is, compared to the\nnon-std::initializer_list constructors, a worse match for both arguments!\nWidget w2{10, true};     // uses braces, but now calls\n// std::initializer_list ctor\nWidget w4{10, 5.0};      // uses braces, but now calls\n// std::initializer_list ctor\nstd::initializer_list constructors:\nWidget(std::initializer_list<long double> il);   // as before\nWidget w6{w4};               // uses braces, calls\n// std::initializer_list ctor\nWidget w7(std::move(w4));    // uses parens, calls move ctor\nWidget w8{std::move(w4)};    // uses braces, calls\n// std::initializer_list ctor\nCompilers’ determination to match braced initializers with constructors taking\nstd::initializer_lists is so strong, it prevails even if the best-match std::ini\nWidget(std::initializer_list<bool> il);  // element type is\nstd::initializer_list<bool>.\ninside braced initializers, so the call is invalid, and the code is rejected.\nOnly if there’s no way to convert the types of the arguments in a braced initializer to\nthe type in a std::initializer_list do compilers fall back on normal overload\nFor example, if we replace the std::initializer_list<bool> construc‐\ntor with one taking a std::initializer_list<std::string>, the non-\nstd::initializer_list constructors become candidates again, because there is no\nway to convert ints and bools to std::strings:\n// std::initializer_list element type is now std::string\nWidget(std::initializer_list<std::string> il);\nWidget w1(10, true);     // uses parens, still calls first ctor\nWidget w2{10, true};     // uses braces, now calls first ctor\nWidget w3(10, 5.0);      // uses parens, still calls second ctor\nWidget w4{10, 5.0};      // uses braces, now calls second ctor\ntion and also supports std::initializer_list construction.\nmean “empty std::initializer_list,” you get construction from a std::ini\nan empty std::initializer_list:\nWidget(std::initializer_list<int> il);   // std::initializer\nIf you want to call a std::initializer_list constructor with an empty std::ini\nWidget w4({});        // calls std::initializer_list ctor\nAt this point, with seemingly arcane rules about braced initializers, std::initial\nstd::vector has a non-std::initializer_list constructor that allows you to\nhave, but it also has a constructor taking a std::initializer_list that permits\nIf you create a std::vector of a\nnumeric type (e.g., a std::vector<int>) and you pass two arguments to the con‐\nstd::vector<int> v1(10, 20);  // use non-std::initializer_list\n// std::vector, all elements have\nstd::vector<int> v2{10, 20};  // use std::initializer_list ctor:\n// create 2-element std::vector,\nBut let’s step back from std::vector and also from the details of parentheses,\nset of overloaded constructors includes one or more functions taking a std::ini\ntializer_list, client code using braced initialization may see only the std::ini\nthe overload called isn’t affected by whether clients use parentheses or braces.\nAn implication is that if you have a class with no std::initializer_list construc‐\ntor, and you add one, client code using braced initialization may find that calls that\nused to resolve to non-std::initializer_list constructors now resolve to the\nThe difference with std::initializer_list constructor\noverloads is that a std::initializer_list overload doesn’t just compete with\nof the auto-deduced-a-std::initializer_list problem, and the knowledge that\ntheir object creation calls won’t be inadvertently waylaid by std::initial\ntemplate<typename T,                // type of object to create\nstd::vector<int> v;\ndoSomeWork<std::vector<int>>(10, 20);\nstd::vector with 10 elements.\nIf doSomeWork uses braces, the result is a std::vec\n• During constructor overload resolution, braced initializers are matched to\nstd::initializer_list parameters if at all possible, even if other construc‐\nsignificant difference is creating a std::vector<numeric type> with two\nthe issue here isn’t the exact type of NULL, it’s that neither 0 nor NULL has a pointer\ntype.\nactual type is std::nullptr_t, and, in a wonderfully circular definition,\nstd::nullptr_t is defined to be the type of nullptr.\nThe type std::nullptr_t\nimplicitly converts to all raw pointer types, and that’s what makes nullptr act as if it\nwere a pointer of all types.\nint    f1(std::shared_ptr<Widget> spw);  // call these only when\ndouble f2(std::unique_ptr<Widget> upw);  // the appropriate\nCalling code that wants to pass null pointers could look like this:\nauto result = f3(nullptr);  // pass nullptr as null ptr to f3\nIf the return type of this function (auto … -> decltype(func(ptr)) has you scratch‐\nThe type of 0 is, was,\nand always will be int, so that’s the type of the parameter ptr inside the instantiation\nstd::shared_ptr<Widget> parameter that f1 expects.\nTrying to pass this int to f1 as a std::shared_ptr\n<Widget> is a type error.\ntemplate, an int is being passed to a function that requires a std::\nstd::unique_ptr<Widget>.\nlockAndCall, the type for ptr is deduced to be std::nullptr_t.\npassed to f3, there’s an implicit conversion from std::nullptr_t to Widget*,\nbecause std::nullptr_t implicitly converts to all pointer types.\n• Avoid overloading on integral and pointer types.",
      "keywords": [
        "std",
        "Widget",
        "type",
        "bool",
        "initializer",
        "NULL",
        "Item",
        "int",
        "vector",
        "list",
        "auto",
        "calls",
        "object",
        "braces",
        "pointer"
      ],
      "concepts": [
        "type",
        "typed",
        "typing",
        "std",
        "auto",
        "initializing",
        "initialized",
        "initialize",
        "item",
        "widget"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 10,
          "title": "",
          "score": 0.84,
          "base_score": 0.69,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 31,
          "title": "",
          "score": 0.61,
          "base_score": 0.46,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 20,
          "title": "",
          "score": 0.593,
          "base_score": 0.593,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 6,
          "title": "",
          "score": 0.564,
          "base_score": 0.564,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 29,
          "title": "",
          "score": 0.544,
          "base_score": 0.544,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "std",
          "vector bool",
          "std initializer_list",
          "initializer_list",
          "bool"
        ],
        "semantic": [],
        "merged": [
          "std",
          "vector bool",
          "std initializer_list",
          "initializer_list",
          "bool"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.42462785233430483,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725455+00:00"
      }
    },
    {
      "chapter_number": 8,
      "title": "Segment 8 (pages 81-89)",
      "start_page": 81,
      "end_page": 89,
      "summary": "that in C++98 had to be hacked together with typedefs nested inside templatized\ntemplate<typename T>                     // MyAllocList<T>::type\ntypedef std::list<T, MyAlloc<T>> type; // std::list<T,\nMyAllocList<Widget>::type lw;            // client code\nating a linked list holding objects of a type specified by a template parameter, you\ntypename MyAllocList<T>::type list;  // as a data member\nHere, MyAllocList<T>::type refers to a type that’s dependent on a template type\nMyAllocList<T>::type is thus a dependent type, and one of C++’s\nTo you, MyAllocList<T> (i.e., use of the alias template) may look just as dependent\non the template parameter T as MyAllocList<T>::type (i.e., use of the nested type\nMyAllocList<T> is the name of a type, because MyAllocList is an alias template: it\nmust name a type.\nMyAllocList<T> is thus a non-dependent type, and a typename\nWhen compilers see MyAllocList<T>::type (i.e., use of the nested typedef) in the\nWidget template, on the other hand, they can’t know for sure that it names a type,\nwhere MyAllocList<T>::type refers to something other than a type.\nAs you can see, MyAllocList<Wine>::type doesn’t refer to a type.\nbe instantiated with Wine, MyAllocList<T>::type inside the Widget template\nMyAllocList<T>::type refers to a type is honestly dependent on what T is, and\nped up against the need to take template type parameters and create revised types\nlike to apply a transformation, the resulting type is std::transformation\n<T>::type.\nstd::remove_const<T>::type           // yields T from const T\nstd::remove_reference<T>::type       // yields T from T& and T&&\nstd::add_lvalue_reference<T>::type   // yields T& from T\nIf you apply them to a type parameter inside a template (which is virtually always\nThe reason for both of these syntactic speed bumps is that the C++11 type\nter way to go, and they included such templates in C++14 for all the C++11 type\nstd::transformation<T>::type, there’s a corresponding C++14 alias template\nstd::remove_const<T>::type           // C++11: const T → T\nstd::remove_reference<T>::type       // C++11: T&/T&& → T\nstd::remove_reference_t<T>           // C++14 equivalent\nstd::add_lvalue_reference<T>::type   // C++11: T → T&\nstd::add_lvalue_reference_t<T>       // C++14 equivalent\nEven if you don’t have access to C++14, writing the alias templates yourself\ntypename add_lvalue_reference<T>::type;\n• C++14 offers alias templates for all the C++11 type traits transformations.\nC++98-style enums.\nthe enum, and that means that nothing else in that scope may have the same name:\nBecause scoped enums are declared via “enum class”, they’re sometimes referred to as\nenum classes.\nped enums implicitly convert to integral types (and, from there, to floating-point\ntypes).\nfrom enumerators in a scoped enum to any other type:\nenum class Color { black, white, red };  // enum is now scoped\nprimeFactors(static_cast<std::size_t>(c));  // it compiles\nscoped enums may be forward-declared, i.e., their names may be declared without\nenum class Color;         // fine\nIn C++11, unscoped enums may also be forward-declared, but\nC++ has an integral underlying type that is determined by compilers.\nenum Color { black, white, red };\nlying type for an enum that’s sufficient to represent its range of enumerator values.\ntions (where all enumerators are listed); enum declarations are not allowed.\nmakes it possible for compilers to select an underlying type for each enum prior to the\nenum being used.\nenums in C++11 eliminates.\nenum class Status;                   // forward declaration\nvoid continueProcessing(Status s);   // use of fwd-declared enum\nBut if compilers need to know the size of an enum before it’s used, how can C++11’s\nenums get away with forward declarations when C++98’s enums can’t?\nsimple: the underlying type for a scoped enum is always known, and for unscoped\nBy default, the underlying type for scoped enums is int:\nenum class Status;                 // underlying type is int\nenum class Status: std::uint32_t;  // underlying type for\nEither way, compilers know the size of the enumerators in a scoped enum.\nTo specify the underlying type for an unscoped enum, you do the same thing as for a\nscoped enum, and the result may be forward-declared:\nenum Color: std::uint8_t;       // fwd decl for unscoped enum;\n// underlying type is\nUnderlying type specifications can also go on an enum’s definition:\nenum class Status: std::uint32_t { good = 0,\nusing UserInfo =                 // type alias; see Item 9",
      "keywords": [
        "type",
        "std",
        "enum",
        "Color",
        "template",
        "MyAllocList",
        "enum Color",
        "enum class Status",
        "enum class Color",
        "Widget",
        "alias",
        "Status",
        "Item",
        "enum class",
        "underlying type"
      ],
      "concepts": [
        "types",
        "typed",
        "std",
        "templates",
        "compiler",
        "compiles",
        "color",
        "declaration",
        "classes",
        "item"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 6,
          "title": "",
          "score": 0.767,
          "base_score": 0.617,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 5,
          "title": "",
          "score": 0.687,
          "base_score": 0.537,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 19,
          "title": "",
          "score": 0.644,
          "base_score": 0.494,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 4,
          "title": "",
          "score": 0.627,
          "base_score": 0.627,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 20,
          "title": "",
          "score": 0.618,
          "base_score": 0.618,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "enum",
          "type",
          "myalloclist",
          "underlying type",
          "myalloclist type"
        ],
        "semantic": [],
        "merged": [
          "enum",
          "type",
          "myalloclist",
          "underlying type",
          "myalloclist type"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.43600024364246703,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725491+00:00"
      }
    },
    {
      "chapter_number": 9,
      "title": "Segment 9 (pages 90-101)",
      "start_page": 90,
      "end_page": 101,
      "summary": "means it must be a constexpr function.\nIn fact, it should really be a constexpr function template, because it should work\nThe result is a function template\nreturn static_cast<std::underlying_type_t<E>>(enumerator);\nreturn static_cast<std::underlying_type_t<E>>(enumerator);\nItem 11: Prefer deleted functions to private undefined\ncalling a particular function, you generally just don’t declare the function.\ntion declaration, no function to call.\ntions for you, and if you want to prevent clients from calling those functions, the\nThe situation arises only for the “special member functions,” i.e., the member func‐\nwant to suppress use of a member function, it’s almost always the copy constructor,\nThe C++98 approach to preventing use of these functions is to declare them private\nC++ Standard Library is the class template basic_ios.\nDeclaring these functions private prevents clients from calling them.\nfunctions or friends of the class) uses them, linking will fail due to missing function\nmark the copy constructor and the copy assignment operator as deleted functions.\nThe difference between deleting these functions and declaring them private may\nDeleted functions may not be used in any way, so even code\nthat’s in member and friend functions will fail to compile if it tries to copy\nBy convention, deleted functions are declared public, not private.\nWhen client code tries to use a member function, C++ checks accessibility\nWhen client code tries to use a deleted private function, some\ncompilers complain only about the function being private, even though the func‐\nfunctions with deleted ones, because making the new functions public will generally\nwhile only member functions may be private.\nmember function that takes an integer and returns whether it’s a lucky number:\nbool isLucky(int number);            // original function\nAlthough deleted functions can’t be used, they are part of your program.\nfunction declarations above, the undesirable calls to isLucky will be rejected:\ncall to deleted function\nAnother trick that deleted functions can perform (and that private member func‐\nInterestingly, if you have a function template inside a class, and you’d like to disable\ncan’t, because it’s not possible to give a member function template specialization a\nmember function template inside Widget, for example, and you wanted to disable\nThis issue doesn’t arise for deleted functions, because they don’t need a\nThe truth is that the C++98 practice of declaring functions private and not defining\nthem was really an attempt to achieve what C++11’s deleted functions actually\nSo stick to deleted functions.\n• Prefer deleted functions to private undefined ones.\n• Any function may be deleted, including non-member functions and template\nItem 12: Declare overriding functions override.\ntance, and virtual functions.\nvirtual function implementations in derived classes override the implementations of\nfunction overriding can go wrong.\nme make clear that virtual function overriding is what makes it possible to invoke a\nderived class function through a base class interface:\nvirtual void doWork();         // base class virtual function\nclass Derived: public Base {\nvirtual void doWork();         // overrides Base::doWork\nstd::make_unique<Derived>();   // to derived class object;\n• The base class function must be virtual.\n• The base and derived function names must be identical (except in the case of\n• The parameter types of the base and derived functions must be identical.\n• The constness of the base and derived functions must be identical.\n• The return types and exception specifications of the base and derived functions\n• The functions’ reference qualifiers must be identical.\nMember function reference\nMember functions need not be virtual to\nI’ll say more about member functions with reference qualifiers later, but for now,\nsimply note that if a virtual function in a base class has a reference qualifier,\nderived class overrides of that function must have exactly the same reference\nIf they don’t, the declared functions will still exist in the derived class,\nbut they won’t override anything in the base class.\nlooks reasonable, but it contains no virtual function overrides—not a single derived\nclass function that is tied to a base class function.\neach case, i.e., why each derived class function doesn’t override the base class func‐\nclass Derived: public Base {\n• mf1 is declared const in Base, but not in Derived.\nBecause declaring derived class overrides is important to get right, but easy to get\nwrong, C++11 gives you a way to make explicit that a derived class function is\nsupposed to override a base class version: declare it override.\nclass Derived: public Base {\nvirtual void mf4() const override;\nyou should declare all your overriding functions override.\nis for all functions in Derived to override virtuals in Base):\nclass Derived: public Base {\nvirtual void mf1() const override;\nvirtual void mf2(int x) override;\nvoid mf4() const override;          // adding \"virtual\" is OK,\nMost overriding-related errors occur in derived classes, but it’s possible\nture of a virtual function in a base class.\nIf derived classes use override everywhere,\n2 Applying final to a virtual function prevents the function from being overridden in derived classes.\nthat are supposed to override base class functions, but don’t, need not elicit compiler\nwhen it occurs at the end of a member function declaration.\nfunction reference qualifiers.\nIf we want to write a function that accepts only lvalue arguments, we declare a non-\nIf we want to write a function that accepts only rvalue arguments, we declare an\nMember function reference qualifiers simply make it possible to draw the same dis‐\ntinction for the object on which a member function is invoked, i.e., *this.\ncisely analogous to the const at the end of a member function declaration, which\nindicates that the object on which the member function is invoked (i.e., *this) is\nThe need for reference-qualified member functions is not common, but it can arise.\nFor example, suppose our Widget class has a std::vector data member, and we",
      "keywords": [
        "function",
        "base",
        "void",
        "base class",
        "virtual void",
        "functions",
        "derived class function",
        "derived class",
        "derived",
        "Item",
        "member function",
        "virtual",
        "std",
        "base class function",
        "deleted functions"
      ],
      "concepts": [
        "classes",
        "function",
        "template",
        "std",
        "overriding",
        "override",
        "delete",
        "deleting",
        "declare",
        "declaration"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 8,
          "title": "",
          "score": 0.546,
          "base_score": 0.546,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 11,
          "title": "",
          "score": 0.542,
          "base_score": 0.542,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 2,
          "title": "",
          "score": 0.535,
          "base_score": 0.535,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 4,
          "title": "",
          "score": 0.528,
          "base_score": 0.528,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 12,
          "title": "",
          "score": 0.509,
          "base_score": 0.509,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "derived",
          "virtual",
          "class",
          "function",
          "base"
        ],
        "semantic": [],
        "merged": [
          "derived",
          "virtual",
          "class",
          "function",
          "base"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4236401535015097,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:02:16.725526+00:00"
      }
    },
    {
      "chapter_number": 10,
      "title": "Segment 10 (pages 102-112)",
      "start_page": 102,
      "end_page": 112,
      "summary": "The return type of Widget::data is an lvalue reference (a std::vector<double>&,\nand we want to initialize a variable with the std::vector inside the Widget returned\nmakeWidget (i.e., an rvalue), so copying the std::vector inside it is a waste of time.\nrules of C++ require that compilers generate code for a copy.\n• Member function reference qualifiers make it possible to treat lvalue and\nThat’s as true for C++98 as for C++11, but in C++98, const_iterators had only\nstd::vector<int>::iterator it =\nRevising the code to use const_iterators should be\ntypedef std::vector<int>::iterator IterT;             // type-\ntypedef std::vector<int>::const_iterator ConstIterT;  // defs\nadvice of Item 9 to use alias declarations, it’s because this example shows C++98\ncode, and alias declarations are a feature new to C++11.)\nThe casts in the call to std::find are present because values is a non-const con‐\ntainer and in C++98, there was no simple way to get a const_iterator from a non-\nconst_iterators in other ways (e.g., you could bind values to a reference-to-const\nOnce you had the const_iterators, matters often got worse, because in C++98,\nconst_iterator (that I was so careful to get from std::find) into an iterator:\nconst_iterators\nconst_iterators were so much trouble in C++98, they were rarely worth the\nit whenever practical, and in C++98, const_iterators just weren’t very practical.\nThe container member functions cbegin and cend produce const_iterators,\neven for non-const containers, and STL member functions that use iterators to iden‐\ntify positions (e.g., insert and erase) actually use const_iterators.\noriginal C++98 code that uses iterators to use const_iterators in C++11 is truly\nNow that’s code using const_iterators that’s practical!\nAbout the only situation in which C++11’s support for const_iterators comes up a\nend (plus cbegin, cend, rbegin, etc.) as non-member functions, rather than mem‐\ngeneric code thus uses non-member functions rather than assuming the existence of\nauto it = std::find(cbegin(container),  // non-member cbegin\nstandardization, C++11 added the non-member functions begin and end, but it\nIf you’re using C++11, you want to write maximally generic code, and none of the\nauto cbegin(const C& container)->decltype(std::begin(container))\ntainer type (e.g., a std::vector<int>), container will be a reference to a const\nversion of that container (e.g., a const std::vector<int>&).\nmember begin function (provided by C++11) on a const container yields a\nconst_iterator, and that iterator is what this template returns.\nmember function (which, for containers, is what C++11’s non-member begin calls),\nconst array are const, so the pointer that non-member begin returns for a const\nItem 14: Declare functions noexcept if they won’t emit\nIn C++98, exception specifications were rather temperamental beasts.\nsummarize the exception types a function might emit, so if the function’s implemen‐\ning an exception specification could break client code, because callers might be\nhelp in maintaining consistency among function implementations, exception specifi‐\nabout a function’s exception-emitting behavior was whether it had any.\nwhite, either a function might emit an exception or it guaranteed that it wouldn’t.\nThis maybe-or-never dichotomy forms the basis of C++11’s exception specifications,\n(C++98-style exception specifications remain\nvalid, but they’re deprecated.) In C++11, unconditional noexcept is for functions\nexception-emitting behavior of a function is of key interest to clients.\nAs such, whether a function is\nnoexcept is as important a piece of information as whether a member function is\nFailure to declare a function noexcept when you know that it won’t emit an\nBut there’s an additional incentive to apply noexcept to functions that won’t pro‐\nthat a function won’t emit exceptions.\nint f(int x) noexcept;    // no exceptions from f: C++11 style\nC++98 exception specification, the call stack is unwound to f’s caller, and, after some\nIn a noexcept function, optimizers need\nout of the function, nor must they ensure that objects in a noexcept function are\ndestroyed in the inverse order of construction should an exception leave the function.\nFunctions with “throw()” exception specifications lack such optimization flexibility,\nas do functions with no exception specification at all.\nRetType function(params) noexcept;     // most optimizable\nThis alone is sufficient reason to declare functions noexcept whenever you know\nSuppose you have a C++98 code base making use of a std::vec\nFunctions \nstd::move_if_noexcept, a variation of std::move that conditionally casts to an rvalue (see Item 23),\nexception was thrown during the copying of the elements, the state of the std::vec\nIn C++11, a natural optimization would be to replace the copying of std::vector\nfunctions sporting the strong exception safety guarantee in C++98 (e.g., std::vec\nAll these functions\nswap functions comprise another case where noexcept is particularly desirable.\nThese functions are conditionally noexcept: whether they are noexcept depends on\nments in the arrays is noexcept, i.e., if swap for Widget is noexcept.\nWidget’s swap thus determines whether swapping arrays of Widget is noexcept.\nWidget, are noexcept.\nnoexcept swap functions whenever you can.\npart of a function’s interface, so you should declare a function noexcept only if you\ndeclare a function noexcept and later regret that decision, your options are bleak.\nYou can remove noexcept from the function’s declaration (i.e., change its interface),\nThe fact of the matter is that most functions are exception-neutral.\nSuch functions\nthrow no exceptions themselves, but functions they call might emit one.\n4 The interface specifications for move operations on containers in the Standard Library lack noexcept.\never, implementers are permitted to strengthen exception specifications for Standard Library functions, and,\nin practice, it is common for at least some container move operations to be declared noexcept.\nexceptions aren’t thrown, implementers often declare the operations noexcept, even though the Standard\nhappens, the exception-neutral function allows the emitted exception to pass through\nException-neutral functions are\nnever noexcept, because they may emit such “just passing through” exceptions.\nfunctions, therefore, quite properly lack the noexcept designation.\nSome functions, however, have natural implementations that emit no exceptions, and\nPlease note that I said some functions have natural noexcept implementations.\nTwisting a function’s implementation to permit a noexcept declaration is the tail\ntion might yield exceptions (e.g., by invoking a function that might throw), the hoops\nfunction’s implementation, it will typically complicate code at call sites, too.\nFor some functions, being noexcept is so important, they’re that way by default.\nC++98, it was considered bad style to permit the memory deallocation functions (i.e.,",
      "keywords": [
        "noexcept",
        "std",
        "function",
        "const",
        "Widget",
        "functions",
        "exception",
        "Item",
        "iterators",
        "code",
        "n’t",
        "vector",
        "exceptions",
        "move",
        "data"
      ],
      "concepts": [
        "function",
        "functions",
        "std",
        "exceptions",
        "container",
        "code",
        "values",
        "item",
        "implementations",
        "implementation"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 7,
          "title": "",
          "score": 0.84,
          "base_score": 0.69,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 31,
          "title": "",
          "score": 0.701,
          "base_score": 0.551,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 29,
          "title": "",
          "score": 0.663,
          "base_score": 0.663,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 20,
          "title": "",
          "score": 0.641,
          "base_score": 0.641,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 8,
          "title": "",
          "score": 0.61,
          "base_score": 0.61,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "noexcept",
          "exception",
          "const_iterators",
          "functions",
          "function"
        ],
        "semantic": [],
        "merged": [
          "noexcept",
          "exception",
          "const_iterators",
          "functions",
          "function"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.48405561989231705,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725562+00:00"
      }
    },
    {
      "chapter_number": 11,
      "title": "Segment 11 (pages 113-123)",
      "start_page": 113,
      "end_page": 123,
      "summary": "writing a function f taking a std::string parameter, and suppose f’s natural imple‐\nvoid f(const std::string& s) noexcept;    // precondition:\nnoexcept for functions with wide contracts.\nHere, doWork is declared noexcept, even though it calls the non-noexcept functions\n(Even functions from the\nBecause there are legitimate reasons for noexcept functions to rely on code lacking\nthe noexcept guarantee, C++ permits such code, and compilers generally don’t issue\n• noexcept is part of a function’s interface, and that means that callers may\n• Most functions are exception-neutral rather than noexcept.\nItem 15: Use constexpr whenever possible.\nConceptually, constexpr indicates a value that’s not only constant, it’s known dur‐\nconstexpr functions are const, nor can you take for granted that their values are\ngood that constexpr functions need not produce results that are const or known\nin fact, have values that are known at compile time.\neffect on you, so you can blithely program as if the values of constexpr objects were\nValues known during compilation are privileged.\npilers will ensure that it has a compile-time value:\n// is constexpr\nobjects need not be initialized with values known during compilation:\nSimply put, all constexpr objects are const, but not all const objects are con\nSuch functions produce compile-time constants when they\n• constexpr functions can be used in contexts that demand compile-time con‐\nIf the values of the arguments you pass to a constexpr function in such a\ncontext are known during compilation, the result will be computed during\nIf any of the arguments’ values is not known during compilation,\n• When a constexpr function is called with one or more values that are not\nknown during compilation, it acts like a normal function, computing its result at\ntion, one for compile-time constants and one for all other values.\nThe constexpr\nfunction does it all.\nneed a way to compute 3n during compilation.\nstd::pow, which is the mathematical functionality we need, but, for our purposes,\nSecond, std::pow isn’t constexpr (i.e., isn’t guaranteed to\nreturn a compile-time result when called with compile-time values), so we can’t use it\nRecall that the constexpr in front of pow doesn’t say that pow returns a const value,\nit says that if base and exp are compile-time constants, pow’s result may be used as a\nthings like compile-time-compute the size of a std::array, it can also be called in\nBecause constexpr functions must be able to return compile-time results when\ncalled with compile-time values, restrictions are imposed on their implementations.\nIn C++11, constexpr functions may contain no more than a single executable state‐\nto extend the expressiveness of constexpr functions beyond what you might think.\nconstexpr int pow(int base, int exp) noexcept\nIn C++14, the restrictions on constexpr func‐\nconstexpr int pow(int base, int exp) noexcept       // C++14\nconstexpr functions are limited to taking and returning literal types, which essen‐\nconstructors and other member functions may be constexpr:\nconstexpr Point(double xVal = 0, double yVal = 0) noexcept\nconstexpr double xValue() const noexcept { return x; }\nconstexpr double yValue() const noexcept { return y; }\nHere, the Point constructor can be declared constexpr, because if the arguments\npassed to it are known during compilation, the value of the data members of the con‐\nthus be constexpr:\nconstexpr Point p1(9.4, 27.7);      // fine, \"runs\" constexpr\nconstexpr Point p2(28.8, 5.3);      // also fine\ninvoked on a Point object with a value known during compilation (e.g., a constexpr\nPoint object), the values of the data members x and y can be known during compila‐\nThat makes it possible to write constexpr functions that call Point’s getters\nand to initialize constexpr objects with the results of such functions:\nconstexpr\n// constexpr function\nIn C++11, two restrictions prevent Point’s member functions setX and setY from\nbeing declared constexpr.\nC++11, constexpr member functions are implicitly const.\nin C++14, so in C++14, even Point’s setters can be constexpr:\nconstexpr void setX(double newX) noexcept     // C++14\nconstexpr void setY(double newY) noexcept     // C++14\nconstexpr Point reflection(const Point& p) noexcept\nconstexpr Point p1(9.4, 27.7);        // as above\nconstexpr Point p2(28.8, 5.3);\nconstexpr auto reflectedMid =         // reflectedMid's value is\nThe advice of this Item is to use constexpr whenever possible, and by now I hope it’s\nclear why: both constexpr objects and constexpr functions can be employed in a\nwider range of contexts than non-constexpr objects and functions.\nobjects and functions may be used.\nIt’s important to note that constexpr is part of an object’s or function’s interface.\nconstexpr proclaims “I can be used in a context where C++ requires a constant\nexpression.” If you declare an object or function constexpr, clients may use it in\nconstexpr functions.) Part of “whenever possible” in “Use constexpr whenever\n• constexpr objects are const and are initialized with values known during\n• constexpr functions can produce compile-time results when called with\narguments whose values are known during compilation.\n• constexpr objects and functions may be used in a wider range of contexts\nthan non-constexpr objects and functions.\n• constexpr is part of an object’s or function’s interface.\nItem 16: Make const member functions thread safe.\na function to compute the root(s) of a polynomial, i.e., values where the polynomial\nroots is a const member function, and that\nThe problem is that roots is declared const, but it’s not thread safe.\nconst member functions, and within roots (a const member function), m would\nhow many times a member function is called, a std::atomic counter (i.e, one where",
      "keywords": [
        "constexpr",
        "functions",
        "constexpr functions",
        "point",
        "constexpr Point",
        "function",
        "const",
        "compilation",
        "noexcept",
        "Item",
        "std",
        "constexpr objects",
        "n’t",
        "polynomial",
        "objects"
      ],
      "concepts": [
        "functions",
        "function",
        "functionality",
        "compilers",
        "compile",
        "value",
        "std",
        "point",
        "result",
        "returns"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 9,
          "title": "",
          "score": 0.542,
          "base_score": 0.542,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 4,
          "title": "",
          "score": 0.487,
          "base_score": 0.487,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 19,
          "title": "",
          "score": 0.47,
          "base_score": 0.47,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 2,
          "title": "",
          "score": 0.465,
          "base_score": 0.465,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 6,
          "title": "",
          "score": 0.446,
          "base_score": 0.446,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "constexpr",
          "noexcept",
          "compile time",
          "constexpr functions",
          "constexpr objects"
        ],
        "semantic": [],
        "merged": [
          "constexpr",
          "noexcept",
          "compile time",
          "constexpr functions",
          "constexpr objects"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.40200286266035906,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:02:16.725597+00:00"
      }
    },
    {
      "chapter_number": 12,
      "title": "Segment 12 (pages 124-133)",
      "start_page": 124,
      "end_page": 133,
      "summary": "Because operations on std::atomic variables are often less expensive than mutex\ndestructor, the copy constructor, and the copy assignment operator.\nstructor is generated only if the class declares no constructors at all.\nconstructor arguments are required.) Generated special member functions are\nIn that case, the compiler-generated destructor for the derived class is also virtual.\nknowing when compilers silently insert member functions into your classes.\nconstructor and the move assignment operator.\nare any), and the move assignment operator move-assigns its base class parts.\ne.g., most C++98 legacy classes) will be “moved” via their copy operations.\ntions on data members and base classes that support move operations, but a copy\nAs is the case with the copy operations, the move operations aren’t generated if you\nated differ a bit from those for the copy operations.\nThe two copy operations are independent: declaring one doesn’t prevent compilers\nSo if you declare a copy constructor, but no copy assign‐\nment operator, then write code that requires copy assignment, compilers will gener‐\nate the copy assignment operator for you.\nSimilarly, if you declare a copy assignment\noperator, but no copy constructor, yet your code requires copy construction, compil‐\ners will generate the copy constructor for you.\noperator from being generated, and declaring a move assignment operator prevents\nFurthermore, move operations won’t be generated for any class that explicitly\ndeclares a copy operation.\nThe justification is that declaring a copy operation (con‐\n(memberwise copy) isn’t appropriate for the class, and compilers figure that if mem‐\nberwise copy isn’t appropriate for the copy operations, memberwise move probably\nDeclaring a move operation (construction or\nassignment) in a class causes compilers to disable the copy operations.\ncode, because the conditions under which the copy operations are enabled are more\nmove operations, because there was no such thing as “moving” objects in C++98.\nonly way a legacy class can have user-declared move operations is if they were added\nplay by the C++11 rules for special member function generation.\nstates that if you declare any of a copy constructor, copy assignment operator, or\nto take over the meaning of a copy operation almost always stemmed from the class\n(1) whatever resource management was being done in one copy operation probably\nneeded to be done in the other copy operation and (2) the class destructor would also\nment) all declare “the big three”: both copy operations and a destructor.\noperations in the class.\ncopy operations probably shouldn’t be automatically generated, because they\ndeclared destructor had no impact on compilers’ willingness to generate copy opera‐\nconditions under which the copy operations are generated would break too much\nwith the observation that declaration of a copy operation precludes the implicit gen‐\neration of the move operations, motivates the fact that C++11 does not generate\nmove operations for a class with a user-declared destructor.\nSo move operations are generated for classes (when needed) only if these three things\n• No copy operations are declared in the class.\n• No move operations are declared in the class.\n• No destructor is declared in the class.\nAt some point, analogous rules may be extended to the copy operations, because\nC++11 deprecates the automatic generation of copy operations for classes declaring\ncopy operations or a destructor.\nthe generation of copy operations in classes declaring a destructor or one of the copy\noperations, you should consider upgrading these classes to eliminate the dependence.\nwise copying of the class’s non-static data members is what you want), your job is\nWidget&                                // default copy assign\nDeclaring the move operations disables the copy operations, so if\nIn fact, even if you have a class where compilers are willing to generate the copy and\nmove operations and where the generated functions would behave as you want, you\nAssuming that the class declares no copy operations, no move operations, and no\nthe class’s copy operations is unaffected.\nAnd copying a std\nHad the copy and move operations been explicitly\nother special member functions, the default constructor and the destructor.\n• Copy constructor: Same runtime behavior as C++98: memberwise copy con‐\ndeclared copy constructor.\nDeleted if the class declares a move operation.\nGeneration of this function in a class with a user-declared copy assignment oper‐\n• Copy assignment operator: Same runtime behavior as C++98: memberwise\nuser-declared copy assignment operator.\noperation.\nGeneration of this function in a class with a user-declared copy con‐\n• Move constructor and move assignment operator: Each performs memberwise\ndeclared copy operations, move operations, or destructor.\ncompilers will still generate copy and move operations for Widget (assuming the\ncopy assignment operator.\n• The special member functions are those compilers may generate on their own:\ndefault constructor, destructor, copy operations, and move operations.\n• Move operations are generated only for classes lacking explicitly declared\nmove operations, copy operations, and a destructor.\n• The copy constructor is generated only for classes lacking an explicitly\ndeclared copy constructor, and it’s deleted if a move operation is declared.\nThe copy assignment operator is generated only for classes lacking an explic‐\nitly declared copy assignment operator, and it’s deleted if a move operation is\nGeneration of the copy operations in classes with an explicitly",
      "keywords": [
        "copy operations",
        "move operations",
        "copy",
        "move",
        "operations",
        "copy assignment operator",
        "Widget",
        "copy assignment",
        "move assignment operator",
        "class Widget",
        "copy constructor",
        "member functions",
        "member",
        "destructor",
        "move assignment"
      ],
      "concepts": [
        "classes",
        "copy",
        "copies",
        "operations",
        "operator",
        "operation",
        "widget",
        "thread",
        "declared",
        "declares"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 29,
          "title": "",
          "score": 0.555,
          "base_score": 0.555,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "",
          "score": 0.549,
          "base_score": 0.549,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 26,
          "title": "",
          "score": 0.545,
          "base_score": 0.545,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 28,
          "title": "",
          "score": 0.544,
          "base_score": 0.544,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 17,
          "title": "",
          "score": 0.538,
          "base_score": 0.538,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "copy",
          "operations",
          "copy operations",
          "assignment",
          "assignment operator"
        ],
        "semantic": [],
        "merged": [
          "copy",
          "operations",
          "copy operations",
          "assignment",
          "assignment operator"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.44216847411369953,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:02:16.725633+00:00"
      }
    },
    {
      "chapter_number": 13,
      "title": "Segment 13 (pages 134-141)",
      "start_page": 134,
      "end_page": 141,
      "summary": "anism (e.g., a dedicated destruction function the pointer should be passed to)?\nno longer holds the object the pointer is supposed to point to.\narise when objects are destroyed while pointers still point to them.\nThere are four smart pointers in C++11: std::auto_ptr, std::unique_ptr,\nstd::auto_ptr is a deprecated leftover from C++98.\nize what later became C++11’s std::unique_ptr.\nAs a workaround, std::auto_ptr co-opted\nThis led to surprising code (copying a std::auto_ptr\nstd::unique_ptr does everything std::auto_ptr does, plus more.\nthan std::auto_ptr in every way.\nThe only legitimate use case for std::auto_ptr\nyou should replace std::auto_ptr with std::unique_ptr and never look back.\nItem 18: Use std::unique_ptr for exclusive-ownership\nWhen you reach for a smart pointer, std::unique_ptr should generally be the one\nIt’s reasonable to assume that, by default, std::unique_ptrs are the\nenough for you, a std::unique_ptr almost certainly is, too.\nstd::unique_ptr embodies exclusive ownership semantics.\nunique_ptr always owns what it points to.\nMoving a std::unique_ptr transfers\nset to null.) Copying a std::unique_ptr isn’t allowed, because if you could copy a\nstd::unique_ptr, you’d end up with two std::unique_ptrs to the same resource,\nstd::unique_ptr is thus a move-only type.\nstd::unique_ptr destroys its resource.\nplished by applying delete to the raw pointer inside the std::unique_ptr.\nA common use for std::unique_ptr is as a factory function return type for objects\nreturns a pointer to it, with the caller being responsible for deleting the object when\nThat’s a perfect match for std::unique_ptr, because the\nownership of it), and the std::unique_ptr automatically deletes what it points to\nwhen the std::unique_ptr is destroyed.\nTs>              // return std::unique_ptr\nstd::unique_ptr<Investment>           // to an object created\nCallers could use the returned std::unique_ptr in a single scope as follows,\ncation is violated (see Item 14), local objects may not be destroyed, and if std::abort or an exit function\nmakeInvestment( arguments );  // std::unique_ptr<Investment>\nstd::unique_ptr returned from the factory is moved into a container, the container\nWhen that happens, the object’s std::unique_ptr data member\nthe std::unique_ptr owning the managed resource would eventually have its\nstd::unique_ptr objects can be configured to use custom deleters: arbitrary func‐\nstd::unique_ptr<Investment, decltype(delInvmt)>   // return type\nstd::unique_ptr<Investment, decltype(delInvmt)> // ptr to be\npInv.reset(new Bond(std::forward<Ts>(params)...));\nof std::unique_ptr means you need not concern yourself with when the resource\nstd::unique_ptr takes care of all those\n• delInvmt is the custom deleter for the object returned from makeInvestment.\nAll custom deletion functions accept a raw pointer to the object to be destroyed,\nargument to std::unique_ptr.\nthat’s why the return type of makeInvestment is std::unique_ptr<Invest\n• The basic strategy of makeInvestment is to create a null std::unique_ptr,\n• Attempting to assign a raw pointer (e.g., from new) to a std::unique_ptr won’t\nactual type of object created inside makeInvestment (i.e., Stock, Bond, or Real\ndelete pInvestment;          // Investment\nstd::unique_ptr<Investment, decltype(delInvmt)>   // as\npInv.reset(new Bond(std::forward<Ts>(params)...));\nably assume that std::unique_ptr objects are the same size as raw pointers.\nfunction pointers generally cause the size of a std::unique_ptr to grow from one\nFor deleters that are function objects, the change in size depends on\nstd::unique_ptr<Investment, decltype(delInvmt1)>  // has size of\nstd::unique_ptr<Investment,              // size of Investment*\nparams);          // of function pointer!\nFunction object deleters with extensive state can yield std::unique_ptr objects of\nIf you find that a custom deleter makes your std::unique_ptrs",
      "keywords": [
        "std",
        "unique",
        "ptr",
        "Investment",
        "pointer",
        "object",
        "Raw pointers",
        "Smart Pointers",
        "function",
        "Item",
        "makeInvestment",
        "raw",
        "auto",
        "type",
        "resource"
      ],
      "concepts": [
        "std",
        "pointers",
        "delete",
        "deleting",
        "deletion",
        "investment",
        "investments",
        "invest",
        "object",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 14,
          "title": "",
          "score": 0.853,
          "base_score": 0.703,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "",
          "score": 0.796,
          "base_score": 0.646,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 26,
          "title": "",
          "score": 0.704,
          "base_score": 0.554,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 15,
          "title": "",
          "score": 0.686,
          "base_score": 0.536,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 23,
          "title": "",
          "score": 0.671,
          "base_score": 0.521,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "unique_ptr",
          "std unique_ptr",
          "std",
          "investment",
          "unique_ptr investment"
        ],
        "semantic": [],
        "merged": [
          "unique_ptr",
          "std unique_ptr",
          "std",
          "investment",
          "unique_ptr investment"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.41231115324707035,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725667+00:00"
      }
    },
    {
      "chapter_number": 14,
      "title": "Segment 14 (pages 142-153)",
      "start_page": 142,
      "end_page": 153,
      "summary": "makeInvestment( arguments );      // to std::shared_ptr\nstd::shared_ptr) would be more appropriate.\nstd::shared_ptr, proceed to Item 19.)\nsize of std::unique_ptr objects.\n• Converting a std::unique_ptr to a std::shared_ptr is easy.\nItem 19: Use std::shared_ptr for shared-ownership\nstd::shared_ptr is the C++11 way of binding these worlds together.\naccessed via std::shared_ptrs has its lifetime managed by those pointers through\nNo specific std::shared_ptr owns the object.\nWhen the last std::shared_ptr pointing to an object\nstops pointing there (e.g., because the std::shared_ptr is destroyed or made to\npoint to a different object), that std::shared_ptr destroys the object it points to.\nA std::shared_ptr can tell whether it’s the last one pointing to a resource by con‐\ntrack of how many std::shared_ptrs point to it.\nstd::shared_ptr constructors\nincrement this count (usually—see below), std::shared_ptr destructors decrement\npointed to by sp2 is incremented.) If a std::shared_ptr sees a reference count of\nresource, so the std::shared_ptr destroys it.\ndynamic allocation is avoided when the std::shared_ptr is created by\na std::shared_ptr pointing to a resource in one thread could be executing its\nwhile, in a different thread, a std::shared_ptr to the same object could be\nDid I pique your curiosity when I wrote that std::shared_ptr constructors only\nstd::shared_ptr pointing to an object always yields one more std::shared_ptr\nMove-constructing a std::shared_ptr from\nthat the old std::shared_ptr stops pointing to the resource at the moment the new\nstd::shared_ptr starts.\nLike std::unique_ptr (see Item 18), std::shared_ptr uses delete as its default\nstd::unique_ptr, the type of the deleter is part of the type of the smart pointer.\nstd::shared_ptr, it’s not:\nstd::shared_ptr<Widget>                 // deleter type is not\nThe std::shared_ptr design is more flexible.\nConsider two std::shared_ptr\nstd::shared_ptr<Widget> pw1(new Widget, customDeleter1);\nstd::shared_ptr<Widget> pw2(new Widget, customDeleter2);\nstd::vector<std::shared_ptr<Widget>> vpw{ pw1, pw2 };\ntion taking a parameter of type std::shared_ptr<Widget>.\nchange the size of a std::shared_ptr object.\nstd::shared_ptr object is two pointers in size.\nHow can a std::shared_ptr refer to a deleter of arbitrary size without using\nstd::shared_ptr object.\nIt’s on the heap or, if the creator of the std::shared_ptr\ntook advantage of std::shared_ptr support for custom allocators, it’s wherever the\nstd::shared_ptr object contains a pointer to the reference count for the object it\nobject managed by std::shared_ptrs.\ncan envision the memory associated with a std::shared_ptr<T> object as looking\nstd::shared_ptr<T>\nstd::shared_ptr to the object.\neral, it’s impossible for a function creating a std::shared_ptr to an object to know\nwhether some other std::shared_ptr already points to that object, so the following\n• std::make_shared (see Item 21) always creates a control block.\nobject at the time std::make_shared is called.\n• A control block is created when a std::shared_ptr is constructed from a\nstd::shared_ptr assumes ownership of the pointed-to object, so the unique-\n• When a std::shared_ptr constructor is called with a raw pointer, it creates a\nIf you wanted to create a std::shared_ptr from an object that\nalready had a control block, you’d presumably pass a std::shared_ptr or a\nstd::weak_ptr (see Item 20) as a constructor argument, not a raw pointer.\nstd::shared_ptr constructors taking std::shared_ptrs or std::weak_ptrs\nA consequence of these rules is that constructing more than one std::shared_ptr\nstd::shared_ptr<Widget> spw1(pw, loggingDel);  // create control\nstd::shared_ptr<Widget> spw2(pw, loggingDel);  // create 2nd\nThere are at least two lessons regarding std::shared_ptr use here.\navoid passing raw pointers to a std::shared_ptr constructor.\npass a raw pointer to a std::shared_ptr constructor, pass the result of new directly\nstd::shared_ptr<Widget> spw1(new Widget,    // direct use of new\nit’d be a lot less tempting to create a second std::shared_ptr from the same raw\ninitialization argument (i.e., would call the std::shared_ptr copy constructor), and\nstd::shared_ptr<Widget> spw2(spw1);     // spw2 uses same\nAn especially surprising way that using raw pointer variables as std::shared_ptr\nSuppose our program uses std::shared_ptrs to manage Widget objects, and we\nstd::vector<std::shared_ptr<Widget>> processedWidgets;\npointer (this) to a container of std::shared_ptrs.\nThe std::shared_ptr thus\nThe std::shared_ptr API includes a facility for just this kind of situation.\nstd::shared_ptr from a this pointer.\nstd::shared_ptr to the current object, but it does it without duplicating control\ntions whenever you want a std::shared_ptr that points to the same object as the\n// add std::shared_ptr to current object to processedWidgets\nit creates a new std::shared_ptr that refers to that control block.\nmust be an existing std::shared_ptr (e.g., one outside the member function calling\nIf no such std::shared_ptr\nbefore a std::shared_ptr points to the object, classes inheriting from\nstatic std::shared_ptr<Widget> create(Ts&&...\nthe std::shared_ptr is created by std::make_shared, the control block is only\nDereferencing a std::shared_ptr is no more expensive than dereferencing a raw\nally used only once per object managed by std::shared_ptrs: when the object is\nMost of the time, using std::shared_ptr is vastly\nIf you find yourself doubting whether you can afford use of std::shared_ptr,\nshared_ptr is easy, because a std::shared_ptr can be created from a std::\nto a std::shared_ptr, there’s no changing your mind.\nference from std::unique_ptr, std::shared_ptr has an API that’s designed only\nThere’s no std::shared_ptr<T[]>.\ntime, “clever” programmers stumble on the idea of using a std::shared_ptr<T> to\nstd::shared_ptr offers no operator[], so indexing into the array requires awk‐\nFor another, std::shared_ptr sup‐\n• Compared to std::unique_ptr, std::shared_ptr objects are typically\nThe type of the deleter has no effect on the type of the std::shared_ptr.\n• Avoid creating std::shared_ptrs from variables of raw pointer type.\nItem 20: Use std::weak_ptr for std::shared_ptr-\nstd::shared_ptr (see Item 19), but that doesn’t participate in the shared ownership\nIn other words, a pointer like std::shared_ptr that\nof std::shared_ptr.\nstd::make_shared<Widget>();    // the pointed-to Widget's\nstd::weak_ptr<Widget> wpw(spw);  // wpw points to same Widget\nanother thread might reassign or destroy the last std::shared_ptr pointing to the\na std::shared_ptr from the std::weak_ptr.\nwhen you try to create a std::shared_ptr from it.\nweak_ptr::lock, which returns a std::shared_ptr.\nThe std::shared_ptr is null\nstd::shared_ptr<Widget> spw1 = wpw.lock();  // if wpw's expired,\nThe other form is the std::shared_ptr constructor taking a std::weak_ptr as an\nstd::shared_ptr<Widget> spw3(wpw);    // if wpw's expired,",
      "keywords": [
        "std",
        "ptr",
        "shared",
        "Widget",
        "object",
        "control block",
        "Item",
        "reference count",
        "ptrs",
        "control",
        "count",
        "pointer",
        "block",
        "reference",
        "unique"
      ],
      "concepts": [
        "std",
        "objects",
        "widget",
        "item",
        "pointer",
        "created",
        "creates",
        "uses",
        "useful",
        "block"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "",
          "score": 0.925,
          "base_score": 0.775,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 13,
          "title": "",
          "score": 0.853,
          "base_score": 0.703,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 15,
          "title": "",
          "score": 0.811,
          "base_score": 0.661,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 26,
          "title": "",
          "score": 0.727,
          "base_score": 0.577,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 2,
          "title": "",
          "score": 0.684,
          "base_score": 0.684,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "shared_ptr",
          "std shared_ptr",
          "std",
          "shared_ptr std",
          "shared_ptr widget"
        ],
        "semantic": [],
        "merged": [
          "shared_ptr",
          "std shared_ptr",
          "std",
          "shared_ptr std",
          "shared_ptr widget"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4135496488678213,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725701+00:00"
      }
    },
    {
      "chapter_number": 15,
      "title": "Segment 15 (pages 154-161)",
      "start_page": 154,
      "end_page": 161,
      "summary": "std::unique_ptr<const Widget> loadWidget(WidgetID id);\nFor this caching factory function, a std::unique_ptr return type is not a good fit.\nThat means that the factory’s return type should be a std::shared_ptr, because\nstd::shared_ptr<const Widget> fastLoadWidget(WidgetID id)\nstd::weak_ptr<const Widget>> cache;\nauto objPtr = cache[id].lock();   // objPtr is std::shared_ptr\nstd::shared_ptrs to it:\nstd::shared_ptr\nstd::shared_ptr\nstd::shared_ptr\nstd::shared_ptr\n• A std::shared_ptr.\nIn this design, A and B contain std::shared_ptrs to each\nThe resulting std::shared_ptr cycle (A points to B and B points to A) will\ncount, hence can’t keep A from being destroyed when std::shared_ptrs no\nthat for std::shared_ptr.\nshared_ptr objects, they make use of the same control blocks as std::\nthat std::weak_ptrs don’t participate in the shared ownership of objects and hence\n• Use std::weak_ptr for std::shared_ptr-like pointers that can dangle.\n• Potential use cases for std::weak_ptr include caching, observer lists, and the\nprevention of std::shared_ptr cycles.\nItem 21: Prefer std::make_unique and\nstd::make_shared to direct use of new.\nstd::make_shared is part of C++11, but, sadly, std::make_\nstd::unique_ptr<T> make_unique(Ts&&...\nreturn std::unique_ptr<T>(new T(std::forward<Ts>(params)...));\nof the object being created, constructs a std::unique_ptr from the raw pointer new\nstd::make_unique and std::make_shared are two of the three make functions:\nstd::allocate_shared.\nstd::make_shared, except its first argument is an allocator object to be used for the\nauto upw1(std::make_unique<Widget>());      // with make func\nstd::unique_ptr<Widget> upw2(new Widget);   // without make func\nauto spw1(std::make_shared<Widget>());      // with make func\nstd::shared_ptr<Widget> spw2(new Widget);   // without make func\nvoid processWidget(std::shared_ptr<Widget> spw, int priority);\nPassing the std::shared_ptr by value may look suspicious, but Item 41 explains\nthat if processWidget always makes a copy of the std::shared_ptr (e.g., by storing\nstd::make_shared:\nprocessWidget(std::shared_ptr<Widget>(new Widget),  // potential\nBoth the calling code and the called function are using std::shared_ptrs, and\ndestroy what they point to when the last std::shared_ptr pointing there goes away.\nIf everybody is using std::shared_ptrs everywhere, how can this code leak?\n• The constructor for the std::shared_ptr<Widget> responsible for managing\nWidget” must be executed before the std::shared_ptr constructor may be called,\n3. Run std::shared_ptr constructor.\nUsing std::make_shared avoids this problem.\nprocessWidget(std::make_shared<Widget>(),   // no potential\nAt runtime, either std::make_shared or computePriority will be called first.\nstd::make_shared, the raw pointer to the dynamically allocated Widget is safely\nstored in the returned std::shared_ptr before computePriority is called.\ntePriority then yields an exception, the std::shared_ptr destructor will see to it\nyields an exception, std::make_shared will not be invoked, and there will hence be\nIf we replace std::shared_ptr and std::make_shared with std::unique_ptr and\nUsing std::make_unique\nstd::make_shared.\nA special feature of std::make_shared (compared to direct use of new) is improved\nUsing std::make_shared allows compilers to generate smaller, faster\nstd::shared_ptr<Widget> spw(new Widget);\nItem 19 explains that every std::shared_ptr points to a control block containing,\ncontrol block is allocated in the std::shared_ptr constructor.\nIf std::make_shared is used instead,\nauto spw = std::make_shared<Widget>();\nThat’s because std::make_shared allocates a single chunk of\nFurthermore, using std::make_shared obviates the need for\ncate_shared, so the performance advantages of std::make_shared extend to that\n(see Items 18 and 19), but both std::unique_ptr and std::shared_ptr have con‐\nstd::shared_ptr<Widget> spw(new Widget, widgetDeleter);\nauto spv = std::make_shared<std::vector<int>>(10, 20);\nauto spv = std::make_shared<std::vector<int>>(initList);\nFor std::shared_ptr",
      "keywords": [
        "std",
        "Widget",
        "ptr",
        "make",
        "shared",
        "Item",
        "ptrs",
        "make functions",
        "unique",
        "object",
        "weak",
        "code",
        "function",
        "pointer",
        "functions"
      ],
      "concepts": [
        "std",
        "widget",
        "code",
        "auto",
        "pointers",
        "caches",
        "cached",
        "objects",
        "useful",
        "uses"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "",
          "score": 0.818,
          "base_score": 0.668,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 14,
          "title": "",
          "score": 0.811,
          "base_score": 0.661,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 23,
          "title": "",
          "score": 0.732,
          "base_score": 0.582,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 13,
          "title": "",
          "score": 0.686,
          "base_score": 0.536,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 26,
          "title": "",
          "score": 0.665,
          "base_score": 0.515,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "std",
          "shared_ptr",
          "std shared_ptr",
          "make_shared",
          "std make_shared"
        ],
        "semantic": [],
        "merged": [
          "std",
          "shared_ptr",
          "std shared_ptr",
          "make_shared",
          "std make_shared"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.38670425711554784,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725733+00:00"
      }
    },
    {
      "chapter_number": 16,
      "title": "Segment 16 (pages 162-174)",
      "start_page": 162,
      "end_page": 174,
      "summary": "size of objects of the class, e.g., operator new and operator delete for class Widget\nSuch routines are a poor fit for std::shared_ptr’s\ncustom deleters), because the amount of memory that std::allocate_shared\nfrom std::shared_ptr’s control block being placed in the same chunk of memory\npointed-to object has no std::shared_ptrs referring to it and has thus been\nAs long as std::weak_ptrs refer to a control block (i.e., the weak count is greater\nstd::shared_ptr make function, then, can’t be deallocated until the last\nstd::shared_ptr and the last std::weak_ptr referring to it have been destroyed.\nstd::make_shared<ReallyBigType>();    // object via\n// std::make_shared\n…            // final std::shared_ptr to object destroyed here,\n…            // final std::weak_ptr to object destroyed here;\nas soon as the last std::shared_ptr to it is destroyed:\nstd::shared_ptr<ReallyBigType> pBigObj(new ReallyBigType);\n// std::weak_ptrs to object, use them with it\n…            // final std::shared_ptr to object destroyed here,\n…            // final std::weak_ptr to object destroyed here;\nvoid processWidget(std::shared_ptr<Widget> spw,  // as before\nstd::shared_ptr<Widget>(new Widget, cusDel),   // potential\nstd::shared_ptr constructor, and if computePriority yields an exception, the\nHere the use of a custom deleter precludes use of std::make_shared, so the way to\nstd::shared_ptr into their own statement, then call processWidget with the\nresulting std::shared_ptr.\nstd::shared_ptr<Widget> spw(new Widget, cusDel);\nThis works, because a std::shared_ptr assumes ownership of the raw pointer\nstd::shared_ptr<Widget>(new Widget, cusDel),  // arg is rvalue\nBecause processWidget’s std::shared_ptr parameter is passed by value, construc‐\nFor std::shared_ptr, the difference can be significant, because copying a\nstd::shared_ptr requires an atomic increment of its reference count, while moving\na std::shared_ptr requires no reference count manipulation at all.\n• For std::shared_ptrs, additional situations where make functions may be\nWidget();\nBecause Widget’s data members are of types std::string, std::vector, and\nGadget, headers for those types must be present for Widget to compile, and that\nmeans that Widget clients must #include <string>, <vector>, and gadget.h. Those headers increase the compilation time for Widget clients, plus they make those\nApplying the Pimpl Idiom in C++98 could have Widget replace its data members\nWidget();\nBecause Widget no longer mentions the types std::string, std::vector, and\nGadget, Widget clients no longer need to #include the headers for these types.\nWidget::Impl is such a type.\nlocation code goes in the implementation file, e.g., for Widget, in widget.cpp:\n#include \"widget.h\"            // in impl.\nstd::vector<double> data;    // in Widget\n: pImpl(new Impl)              // this Widget object\nThe need to deallocate this object when a Widget is destroyed\nto dynamically allocate a Widget::Impl object inside the Widget constructor and\nhave it destroyed at the same time the Widget is, std::unique_ptr (see Item 18) is\nReplacing the raw pImpl pointer with a std::unique_ptr\nWidget();\nstd::unique_ptr<Impl> pImpl;      // use smart pointer\n: pImpl(std::make_unique<Impl>())   // std::unique_ptr\nstd::unique_ptr automatically deletes what it points to when\nit (the std::unique_ptr) is destroyed, so we need not delete anything ourselves.\nbecause (1) std::unique_ptr is advertised as supporting incomplete types, and (2)\nthe Pimpl Idiom is one of std::unique_ptrs most common use cases.\nstd::unique_ptr, we didn’t declare a destructor, because we didn’t have any code to\ndestructor, the compiler inserts code to call the destructor for Widget’s data member\npImpl is a std::unique_ptr<Widget::Impl>, i.e., a std::unique_ptr\npointer inside the std::unique_ptr.\ndestroy the std::unique_ptr<Widget::Impl> is generated, Widget::Impl is a\nthe compiler will generate code to destroy the std::unique_ptr data member) only\nWidget();\n~Widget();                       // declaration only\nstd::unique_ptr<Impl> pImpl;\nstd::string name;                // Widget::Impl\n: pImpl(std::make_unique<Impl>())\ndeclared it was to cause its definition to be generated in Widget’s implementation\ntor in Widget prevents compilers from generating the move operations, so if you\nclass Widget {                                 // still in\nWidget();\n~Widget();\nstd::unique_ptr<Impl> pImpl;\ning it, but in the Widget header file, pImpl points to an incomplete type.\nWidget();\n~Widget();\nstd::unique_ptr<Impl> pImpl;\n: pImpl(std::make_unique<Impl>())\nThe original Widget class contained std::string,\nstd::strings and std::vectors, can be copied, it would make sense for Widget to\nstd::unique_ptr and (2) even if they did, the generated functions would copy only\nthe std::unique_ptr (i.e., perform a shallow copy), and we want to copy what the\nstd::unique_ptr<Impl> pImpl;\n: pImpl(std::make_unique<Impl>(*rhs.pImpl))\nWe thus implement Widget’s copy operations by calling\nWidget::Impl’s compiler-generated copy operations.\nFor purposes of implementing the Pimpl Idiom, std::unique_ptr is the smart\npointer to use, because the pImpl pointer inside an object (e.g., inside a Widget) has\nWidget::Impl object).\nstd::shared_ptr instead of std::unique_ptr for pImpl, we’d find that the advice\nWidget();\nstd::shared_ptr<Impl> pImpl;     // std::shared_ptr\n};                                 // instead of std::unique_ptr\nand this client code that #includes widget.h,\nThe difference in behavior between std::unique_ptr and std::shared_ptr for\nFor std::unique_ptr, the type of the deleter is part of the type of the smart\nFor std::shared_ptr, the type of the\nstd::unique_ptr and std::shared_ptr, because the relationship between classes\nlike Widget and classes like Widget::Impl is exclusive ownership, and that makes\nthe function-definition hoops that use of std::unique_ptr entails.\n• For std::unique_ptr pImpl pointers, declare special member functions in\n• The above advice applies to std::unique_ptr, but not to std::shared_ptr.",
      "keywords": [
        "Widget",
        "std",
        "Impl",
        "ptr",
        "class Widget",
        "Pimpl Idiom",
        "Pimpl",
        "shared",
        "Item",
        "Widget clients",
        "unique",
        "struct Widget",
        "object",
        "struct Impl",
        "Impl std"
      ],
      "concepts": [
        "widget",
        "std",
        "code",
        "objects",
        "compilers",
        "compile",
        "uses",
        "include",
        "item",
        "generation"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 14,
          "title": "",
          "score": 0.925,
          "base_score": 0.775,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 15,
          "title": "",
          "score": 0.818,
          "base_score": 0.668,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 13,
          "title": "",
          "score": 0.796,
          "base_score": 0.646,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 26,
          "title": "",
          "score": 0.758,
          "base_score": 0.608,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 23,
          "title": "",
          "score": 0.716,
          "base_score": 0.566,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "impl",
          "std",
          "widget",
          "pimpl",
          "shared_ptr"
        ],
        "semantic": [],
        "merged": [
          "impl",
          "std",
          "widget",
          "pimpl",
          "shared_ptr"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.45242438934068907,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725767+00:00"
      }
    },
    {
      "chapter_number": 17,
      "title": "Segment 17 (pages 175-189)",
      "start_page": 175,
      "end_page": 189,
      "summary": "Rvalue References, Move Semantics,\nworld of move semantics, perfect forwarding, and rvalue references is more nuanced\nreference.\nsemantics, perfect forwarding, and rvalue references will once again seem pretty\nis always an lvalue, even if its type is an rvalue reference.\nthe parameter w is an lvalue, even though its type is rvalue-reference-to-Widget.\nItem 23: Understand std::move and std::forward.\nstd::move and std::forward are merely functions (actually function templates)\nstd::move unconditionally casts its argument to an rvalue, while\ntypename remove_reference<T>::type&&;  // see Item 9\nAs you can see, std::move takes a reference to an object (a universal reference, to be\nThe “&&” part of the function’s return type implies that std::move returns an rvalue\nreference, but, as Item 28 explains, if the type T happens to be an lvalue reference, T&&\nItem 9) std::remove_reference is applied to T, thus ensuring that “&&” is applied\nrvalue reference, and that’s important, because rvalue references returned from func‐\nThus, std::move casts its argument to an rvalue, and that’s all it\nstd::remove_reference_t (see Item 9), std::move can be written this way:\nBecause std::move does nothing but cast its argument to an rvalue, there have been\nOf course, rvalues are candidates for moving, so applying std::move to an object\nThat’s why std::move\nexplicit Annotation(std::string text);  // param to be copied,\nexplicit Annotation(const std::string text)\nan rvalue:\nexplicit Annotation(const std::string text)\nstd::string value;\ncast to an rvalue by std::move, but text is declared to be a const std::string, so\nbefore the cast, text is an lvalue const std::string, and the result of the cast is an\nrvalue const std::string, but throughout it all, the constness remains.\nstd::move(text) is an rvalue of type const std::string.\nrvalue reference to a non-const std::string.\nthe copy constructor, because an lvalue-reference-to-const is permitted to bind to a\nstd::string, even though text has been cast to an rvalue!\nstd::move to an object is that it’s an rvalue.\nstd::move unconditionally casts its argument to an rvalue, std::forward does it\nstd::forward is a conditional cast.\nwhen it casts and when it doesn’t, recall how std::forward is typically used.\nmost common scenario is a function template taking a universal reference parameter\nprocess(std::forward<T>(param));\nlogAndProcess(std::move(w));       // call with rvalue\nwas an rvalue.\nThis is precisely what std::forward does.\nThat’s why std::forward\nrvalue.\nwith an rvalue.\nIn the code above, for example, how can std::forward tell whether\nence being that std::move always casts, while std::forward only sometimes does,\nstd::string s;\nTo implement the same behavior with std::forward, the code would look like this:\n: s(std::forward<std::string>(rhs.s))     // undesirable\nstd::forward requires both a function argument (rhs.s) and a template type argu‐\nThen note that the type we pass to std::forward should be a\ntyping than std::forward, and it spares us the trouble of passing a type argument\nbility of our passing an incorrect type (e.g., std::string&, which would result in the\nMore importantly, the use of std::move conveys an unconditional cast to an rvalue,\nwhile the use of std::forward indicates a cast to an rvalue only for references to\n• std::move performs an unconditional cast to an rvalue.\n• std::forward casts its argument to an rvalue only if that argument is bound\nto an rvalue.\n1 Item 25 explains that universal references should almost always have std::forward applied to them, and as\nas forwarding references.\nItem 24: Distinguish universal references from rvalue\nreferences.\nTo declare an rvalue reference to some type T, you write T&&.\nvoid f(Widget&& param);             // rvalue reference\nWidget&& var1 = Widget();           // rvalue reference\nauto&& var2 = var1;                 // not rvalue reference\nvoid f(std::vector<T>&& param);     // rvalue reference\nvoid f(T&& param);                  // not rvalue reference\nOne is rvalue reference, of course.\nreferences behave exactly the way you expect: they bind only to rvalues, and their pri‐\nThe other meaning for “T&&” is either rvalue reference or lvalue reference.\nences look like rvalue references in the source code (i.e., “T&&”), but they can behave\nrvalues (like rvalue references) as well as lvalues (like lvalue references).\nthem universal references.1\nvoid f(T&& param);             // param is a universal reference\ndeduction, you’re looking at an rvalue reference:\n// param is an rvalue reference\n// var1 is an rvalue reference\nfor a universal reference determines whether it represents an rvalue reference or an\nIf the initializer is an rvalue, the universal reference corresponds to\nan rvalue reference.\nFor universal references that are function parameters, the ini‐\nf(std::move(w));       // rvalue passed to f; param's type is\n// Widget&& (i.e., an rvalue reference)\nFor a reference to be universal, type deduction is necessary, but it’s not sufficient.\nvoid f(std::vector<T>&& param);  // param is an rvalue reference\na universal reference.\nparam is therefore an rvalue reference, something that your\n// rvalue reference\nvoid f(const T&& param);         // param is an rvalue reference\nIf you’re in a template and you see a function parameter of type “T&&”, you might\npush_back member function in std::vector:\nvoid push_back(Widget&& x);               // rvalue reference\nter of type rvalue-reference-to-T.\nthe following template takes a universal reference, because the form (“type&&”) is\nprecise, variables declared with the type auto&& are universal references, because type\nences are not as common as universal references used for function template parame‐\nstd::forward<decltype(params)>(params)...\nDistinguishing between rvalue references and universal references will help you read\ngues (“I’m using a universal reference here, not an rvalue reference…”).\ndoes not occur, type&& denotes an rvalue reference.\n• Universal references correspond to rvalue references if they’re initialized with\nrvalues.\nItem 25: Use std::move on rvalue references,\nstd::forward on universal references.\nRvalue references bind only to objects that are candidates for moving.\nrvalue reference parameter, you know that the object it’s bound to may be moved:\nthat is to cast parameters bound to such objects to rvalues.\nWidget(Widget&& rhs)               // rhs is rvalue reference\nstd::string name;\nA universal reference, on the other hand (see Item 24), might be bound to an object\nUniversal references should be cast to rvalues only if they\n{ name = std::forward<T>(newName); }    // universal reference\nIn short, rvalue references should be unconditionally cast to rvalues (via std::move)\nwhen forwarding them to other functions, because they’re always bound to rvalues,\nand universal references should be conditionally cast to rvalues (via std::forward)\nItem 23 explains that using std::forward on rvalue references can be made to\nmatic, so you should avoid using std::forward with rvalue references.\nthe idea of using std::move with universal references, because that can have the\nvoid setName(T&& newName)         // universal reference\nstd::string name;\nstd::move to unconditionally cast its reference parameter to an rvalue, n’s value will\nSuch references can’t be const (see Item 24), yet setName surely\nvoid setName(const std::string& newName)      // set from\nvoid setName(std::string&& newName)           // set from\n{ name = std::move(newName); }                // rvalue\nthe overloaded versions of setName, however, a temporary std::string object\nstd::string would then be moved into w’s data member.\ning a template taking a universal reference with a pair of functions overloaded on\nlvalue references and rvalue references is likely to incur a runtime cost in some cases.\ntype (rather than knowing that it’s std::string), the performance gap can widen\nconsiderably, because not all types are as cheap to move as std::string (see",
      "keywords": [
        "rvalue reference",
        "std",
        "Rvalue",
        "reference",
        "Move",
        "Item",
        "universal reference",
        "Widget",
        "type",
        "universal",
        "string",
        "forward",
        "param",
        "lvalue",
        "template"
      ],
      "concepts": [
        "std",
        "references",
        "referring",
        "refer",
        "items",
        "types",
        "typing",
        "template",
        "functions",
        "forwarding"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 18,
          "title": "",
          "score": 0.93,
          "base_score": 0.78,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 21,
          "title": "",
          "score": 0.799,
          "base_score": 0.649,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 29,
          "title": "",
          "score": 0.767,
          "base_score": 0.617,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 28,
          "title": "",
          "score": 0.759,
          "base_score": 0.609,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 20,
          "title": "",
          "score": 0.69,
          "base_score": 0.69,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "rvalue",
          "std",
          "reference",
          "references",
          "rvalue reference"
        ],
        "semantic": [],
        "merged": [
          "rvalue",
          "std",
          "reference",
          "references",
          "rvalue reference"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.46472765585159975,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725914+00:00"
      }
    },
    {
      "chapter_number": 18,
      "title": "Segment 18 (pages 190-203)",
      "start_page": 190,
      "end_page": 203,
      "summary": "For functions like these, overloading on lvalues and rvalues is not an option: univer‐\nstd::forward is applied to the universal reference parameters when they’re passed\nuse the object bound to an rvalue reference or a universal reference more than once\nIn that case, you’ll want to apply std::move (for rvalue\nreferences) or std::forward (for universal references) to only the final use of the\nstd::forward on only the final use of the universal reference.\nIf you’re in a function that returns by value, and you’re returning an object bound to\nan rvalue reference or a universal reference, you’ll want to apply std::move or\nstd::forward when you return the reference.\nreturn std::move(lhs);                      // move lhs into\n}                                             // return value\nBy casting lhs to an rvalue in the return statement (via std::move), lhs will be\nmoved into the function’s return value location.\nreturn lhs;                                 // copy lhs into\n}                                             // return value\nthe fact that lhs is an lvalue would force compilers to instead copy it into the return\nmore efficient than copy construction, using std::move in the return statement\nrvalue will simply be copied by Matrix’s copy constructor (see Item 23).\ngained) by applying std::move to rvalue references being returned from functions\nthat return by value.\nThe situation is similar for universal references and std::forward.\nreduces it, and then returns a copy of the reduced value.\nreturn std::forward<T>(frac);    // move rvalue into return\n}                                  // value, copy lvalue\nIf the call to std::forward were omitted, frac would be unconditionally copied into\n“If using std::move on an rvalue reference parameter being\nRVO to unnamed objects and calling its application to named objects the named return value optimization\ncopied into a return value turns a copy construction into a move construction,” they\nIn other words, they figure that given a function returning a local variable by value,\nreturn w;                // \"copy\" w into return value\nreturn std::move(w);     // move w into return value\n“copying” version of makeWidget can avoid the need to copy the local variable w by\nconstructing it in the memory alloted for the function’s return value.\nas the return value optimization (RVO), and it’s been expressly blessed by the C++\nblessing says that compilers may elide the copying (or moving) of a local object2 in a\nfunction that returns by value if (1) the type of the local object is the same as that\nreturned by the function and (2) the local object is what’s being returned.\nreturn w;                // \"copy\" w into return value\ncode, every decent C++ compiler will employ the RVO to avoid copying w.\nagain constructing w in the memory alloted for the function’s return value?\nreturn std::move(w);\nWhat’s being returned here isn’t the local object w, it’s a reference to w—the result of\nReturning a reference to a local object doesn’t satisfy the conditions\nrequired for the RVO, so compilers must move w into the function’s return value\nthe appropriate local variable in the memory allotted for the function’s return value,\nIn that case, applying std::move to a local object would still be a bad idea.\nare met, but compilers choose not to perform copy elision, the object being returned\npermitted, either copy elision takes place or std::move is implicitly applied to local\ncompilers must either elide the copying of w or they must treat the function as if it\nreturn std::move(w);     // treat w as rvalue, because\ncopy elision with respect to their function’s return value, but compilers must treat\n{                                 // type as function's return\nreturn std::move(w);            // treat w as rvalue\nThis means that if you use std::move on a local object being returned from a func‐\ntion that’s returning by value, you can’t help your compilers (they have to treat the\nlocal object as an rvalue if they don’t perform copy elision), but you can certainly hin‐\n• Apply std::move to rvalue references and std::forward to universal refer‐\nreturned from functions that return by value.\n• Never apply std::move or std::forward to local objects if they would other‐\nItem 26: Avoid overloading on universal references.\nvoid logAndAdd(const std::string& name)\nlogAndAdd(petName);                   // pass lvalue std::string\nlogAndAdd(std::string(\"Persephone\")); // pass rvalue std::string\ncopied into names, but we recognize that, in principle, its value could be moved into\nInstead, emplace would have used the string literal to create the std::string object\nstd::string, yet there’s really no reason to pay even for a move, much less a copy.\nlogAndAdd to take a universal reference (see Item 24) and, in accord with Item 25,\nstd::forwarding this reference to emplace.\nnames.emplace(std::forward<T>(name));\nlogAndAdd(std::string(\"Persephone\"));  // move rvalue instead\nlogAndAdd(\"Patty Dog\");                // create std::string\n// std::string\nstd::string nameFromIdx(int idx);      // return name\nlogAndAdd(std::string(\"Persephone\"));  // calls all invoke\nlogAndAdd(22);                         // calls int overload\nname is then std::forwarded to the emplace member function on names (a\nstd::string constructor.\nThere is no constructor for std::string that takes a\nshort, so the std::string constructor call inside the call to multiset::emplace\nAll because the universal reference overload was a\nwriting a free function that can take either a std::string or an index that can be\nused to look up a std::string, imagine a class Person with constructors that do the\nstd::string name;\nstd::size_t, short, long, etc.) will call the universal reference constructor over‐\nIf the copy and move constructors for Person\nPerson(const Person& rhs);        // copy ctor\noperation.) But this code won’t call the copy constructor.\nstd::string data member with a Person object (p).\ninstead of the copy constructor?\n: name(std::forward<Person&>(n)) {}    // perfect-forwarding\nPerson(const Person& rhs);             // copy ctor\np could be passed to either the copy constructor or the instantiated template.\nthe copy constructor would require adding const to p to match the copy construc‐\nBecause the object to be copied is now const, it’s an exact match for the parameter\nPerson(const Person& rhs);             // copy ctor\nThe copy constructor (a normal function) thereby trumps an instantiated\n(If you’re wondering why compilers generate a copy constructor when they could\ninstantiate a templatized constructor to get the signature that the copy constructor\n: Person(std::move(rhs))                 // base class\nstd::string constructor taking a SpecialPerson.\ntypically better matches than copy constructors for non-const lvalues, and\noverloading on universal references.\nItem 26 explains that overloading on universal references can lead to a variety of\neither through designs that avoid overloading on universal references or by employ‐\nThe first example in Item 26, logAndAdd, is representative of the many functions that\nvalue when you know you’ll copy them, so I’ll defer to that Item for a detailed discus‐\nexplicit Person(std::string n) // replaces T&& ctor; see\n: name(std::move(n)) {}        // Item 41 for use of std::move\nstd::string name;\nBecause there’s no std::string constructor taking only an integer, all int and int-\nlike arguments to a Person constructor (e.g., std::size_t, short, long) get fun‐\nSimilarly, all arguments of type std::string (and things\nthe constructor taking a std::string.\nNeither pass by lvalue-reference-to-const nor pass by value offers support for perfect\npoor matches on the non-universal reference parameters can knock an overload with",
      "keywords": [
        "std",
        "Person",
        "copy",
        "Item",
        "move",
        "universal reference",
        "return std",
        "class Person",
        "copy constructor",
        "string",
        "universal",
        "function",
        "explicit Person",
        "constructor",
        "reference"
      ],
      "concepts": [
        "copy",
        "copied",
        "item",
        "overloading",
        "std",
        "functions",
        "function",
        "person",
        "compilers",
        "compile"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 17,
          "title": "",
          "score": 0.93,
          "base_score": 0.78,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 21,
          "title": "",
          "score": 0.783,
          "base_score": 0.633,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 28,
          "title": "",
          "score": 0.757,
          "base_score": 0.607,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 29,
          "title": "",
          "score": 0.722,
          "base_score": 0.572,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 30,
          "title": "",
          "score": 0.607,
          "base_score": 0.457,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "std",
          "return value",
          "person",
          "string",
          "return"
        ],
        "semantic": [],
        "merged": [
          "std",
          "return value",
          "person",
          "string",
          "return"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.43306839387410284,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.725958+00:00"
      }
    },
    {
      "chapter_number": 19,
      "title": "Segment 19 (pages 204-214)",
      "start_page": 204,
      "end_page": 214,
      "summary": "logAndAdd itself will accept all argument types, both\nlogAndAddImpl(std::forward<T>(name),\nstd::is_integral<T>());     // not quite correct\nThis function forwards its parameter to logAndAddImpl, but it also passes an argu‐\nItem 28 explains, if an lvalue argument is passed to the universal reference name, the\nThat means that std::is_integral<T> will be false for\ndard C++ Library has a type trait (see Item 9), std::remove_reference, that does\nstd::forward<T>(name),\nstd::is_integral<typename std::remove_reference<T>::type>()\nintegral types (i.e., to types where std::is_integral<typename std::remove_ref\nvoid logAndAddImpl(T&& name, std::false_type)    // argument:\nindicating whether an integral type was passed to logAndAdd, but true and false\nnames std::true_type and std::false_type.\ndImpl by logAndAdd is an object of a type that inherits from std::true_type if T is\nintegral and from std::false_type if T is not integral.\nstd::string nameFromIdx(int idx);             // as in Item 26\nvoid logAndAddImpl(int idx, std::true_type)   // integral\nto logAndAdd (from where it will be std::forwarded to the other logAndAddImpl\nIn this design, the types std::true_type and std::false_type are “tags” whose\nstrained universal reference parameter, but this function is not overloaded.\ntype, but, as Item 26 demonstrates, providing a constructor taking a universal refer‐\nFor situations like these, where an overloaded function taking a universal reference is\nstd::enable_if.\nenabled, but a template using std::enable_if is enabled only if the condition speci‐\nperfect-forwarding constructor only if the type being passed isn’t Person.\nbeing passed is Person, we want to disable the perfect-forwarding constructor (i.e.,\nwith another Person.\nHere’s the declaration for the perfect-forwarding constructor in Person, showing\nonly the declaration for this constructor, because the use of std::enable_if has no\ntypename = typename std::enable_if<condition>::type>\nstd::enable_if work.) Here, I want to focus on expression of the condition that\nstructor should be enabled only if T is a type other than Person.\ntrait that determines whether two types are the same (std::is_same), it would seem\nthat the condition we want is !std::is_same<Person, T>::value.\nthe type deduced for a universal reference initialized with an lvalue is always an\nthe type T in the universal constructor will be deduced to be Person&.\nson and Person& are not the same, and the result of std::is_same will reflect that:\nstd::is_same<Person, Person&>::value is false.\nconstructor in Person should be enabled only if T isn’t Person, we’ll realize that\nreference constructor should be enabled, the types Person, Person&, and Per\nbefore checking to see if that type is the same as Person.\nstd::decay<T>::type is the same as T, except that references and cv-qualifiers (i.e.,\nstd::decay, as its name suggests, also turns array and function types into pointers\n!std::is_same<Person, typename std::decay<T>::type>::value\ni.e., Person is not the same type as T, ignoring any references or cv-qualifiers.\nItem 9 explains, the “typename” in front of std::decay is required, because the type\nstd::decay<T>::type depends on the template parameter T.)\nfor Person’s perfect-forwarding constructor:\ntypename = typename std::enable_if<\n!std::is_same<Person,\ntypename std::decay<T>::type\n: Person(std::move(rhs))                 // base class\nclass’s constructors, and because SpecialPerson isn’t the same as Person (not even\nafter application of std::decay), the universal reference constructor in the base class\nPerson’s copy and move constructors, so with the code we have now, copying and\nmoving SpecialPerson objects would use the Person perfect-forwarding construc‐\nparticular, in the condition that controls whether Person’s universal reference con‐\nstructor for any argument type other than Person, we want to enable it for any\nargument type other than Person or a type derived from Person.\nIt’s called std::is_base_of.\nforwarding constructor such that the constructor is enabled only if the type T, after\nstripping it of references and cv-qualifiers, is neither Person nor a class derived from\nPerson.\ntypename = typename std::enable_if<\n!std::is_base_of<Person,\ntypename std::decay<T>::type\ntypename = std::enable_if_t<               // less code here\n!std::is_base_of<Person,\nWe’ve seen how to use std::enable_if to selectively disable Person’s universal ref‐\nerence constructor for argument types we want to have handled by the class’s copy\ntypename = std::enable_if_t<\n!std::is_base_of<Person, std::decay_t<T>>::value\n!std::is_integral<std::remove_reference_t<T>>::value\nexplicit Person(T&& n)        // ctor for std::strings and\nstd::string name;\nWell, okay, the beauty is perhaps most pronounced for\neligibility—use perfect forwarding, hence don’t specify types for the parameters.\nIn the case of the Person constructor, perfect forwarding permits a string\nliteral such as \"Nancy\" to be forwarded to the constructor for the std::string\ntion for the Person constructor.\nperfect-forwarded, even though they can be passed to functions taking specific types.\navailable constructors take either int or std::string, and they’ll produce a more or\nit’s forwarded to the constructor of Person’s std::string data member, and it’s\nchar16_t array) and what’s required (any type acceptable to the std::string con‐\nIn this example, the universal reference is forwarded only once (from the Person\nconstructor to the std::string constructor), but the more complex the system, the\nmore likely that a universal reference is forwarded through several layers of function\nIn the case of Person, we know that the forwarding function’s universal reference\nparameter is supposed to be an initializer for a std::string, so we can use a\ntypename = std::enable_if_t<\n!std::is_base_of<Person, std::decay_t<T>>::value\n!std::is_integral<std::remove_reference_t<T>>::value\n: name(std::forward<T>(n))\n// assert that a std::string can be created from a T object\n\"Parameter n can't be used to construct a std::string\"\nPerson from a type that can’t be used to construct a std::string.",
      "keywords": [
        "Person",
        "std",
        "type",
        "Item",
        "class Person",
        "Person constructor",
        "constructor",
        "universal reference",
        "explicit Person",
        "typename std",
        "reference",
        "integral",
        "universal",
        "typename",
        "n’t Person"
      ],
      "concepts": [
        "std",
        "types",
        "item",
        "functions",
        "functional",
        "constructor",
        "overload",
        "template",
        "argument",
        "arguments"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 6,
          "title": "",
          "score": 0.703,
          "base_score": 0.553,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 8,
          "title": "",
          "score": 0.644,
          "base_score": 0.494,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 5,
          "title": "",
          "score": 0.596,
          "base_score": 0.446,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 20,
          "title": "",
          "score": 0.545,
          "base_score": 0.545,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 4,
          "title": "",
          "score": 0.533,
          "base_score": 0.533,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "person",
          "std",
          "typename std",
          "typename",
          "constructor"
        ],
        "semantic": [],
        "merged": [
          "person",
          "std",
          "typename std",
          "typename",
          "constructor"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3873770356735449,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.726079+00:00"
      }
    },
    {
      "chapter_number": 20,
      "title": "Segment 20 (pages 215-222)",
      "start_page": 215,
      "end_page": 222,
      "summary": "compilers may use the universal reference overloads.\nItem 28: Understand reference collapsing.\nvations about universal references and lvalue/rvalue encoding mean that for this tem‐\ndeduced to be an lvalue reference.\nrvalues are encoded as non-references.) Hence:\nis an rvalue, different types are deduced for the template parameter T.\nshall soon see, is what determines whether universal references become rvalue refer‐\nences or lvalue references, and it’s also the underlying mechanism through which\nBefore we can look more closely at std::forward and universal references, we must\nuniversal reference:\nIf we take the type deduced for T (i.e., Widget&) and use it to instantiate the template,\nItem 24 that because the universal reference param is being initialized with an lvalue,\nparam’s type is supposed to be an lvalue reference, but how does the compiler get\nto references, but compilers may produce them in particular contexts, template\nThere are two kinds of references (lvalue and rvalue), so there are four possible\nreference-reference combinations (lvalue to lvalue, lvalue to rvalue, rvalue to lvalue,\nmitted (e.g., during template instantiation), the references collapse to a single refer‐\nIf either reference is an lvalue reference, the result is an lvalue reference.\nOtherwise (i.e., if both are rvalue references) the result is an rvalue refer‐\nIn our example above, substitution of the deduced type Widget& into the template\nfunc yields an rvalue reference to an lvalue reference, and the reference-collapsing\nrule tells us that the result is an lvalue reference.\nReference collapsing is a key part of what makes std::forward work.\nin Item 25, std::forward is applied to universal reference parameters, so a common\nBecause fParam is a universal reference, we know that the type parameter T will\nif T is a non-reference type.\nremove_reference<T>::type& param)     // std\nSuppose that the argument passed to f is an lvalue of type Widget.\nPlugging Widget& into the std::forward implementation yields this:\nremove_reference<Widget&>::type& param)\nThe type trait std::remove_reference<Widget&>::type yields Widget (see\nReference collapsing is also applied to the return type and the cast, and the result is\nstd::forward is instantiated to take and return an lvalue reference.\nstd::forward does nothing, because param’s type is already Widget&, so casting it to\nAn lvalue argument passed to std::forward will thus return\nan lvalue reference.\nBy definition, lvalue references are lvalues, so passing an lvalue to\nstd::forward causes an lvalue to be returned, just like it’s supposed to.\nNow suppose that the argument passed to f is an rvalue of type Widget.\nremove_reference<Widget>::type& param)\nApplying std::remove_reference to the non-reference type Widget yields the\nsame type it started with (Widget), so std::forward becomes this:\nRvalue references returned from functions are defined to be rvalues, so in this case,\nstd::forward will turn f’s parameter fParam (an lvalue) into an rvalue.\nIn C++14, the existence of std::remove_reference_t makes it possible to imple‐\nT&& forward(remove_reference_t<T>& param)    // namespace std\nReference collapsing occurs in four contexts.\ninitializes w1 with an lvalue, thus deducing the type Widget& for auto.\nWidget& in for auto in the declaration for w1 yields this reference-to-reference code,\nwhich, after reference collapsing, becomes\nAs a result, w1 is an lvalue reference.\ninitializes w2 with an rvalue, causing the non-reference type Widget to be deduced for\nognize the existence of reference collapsing contexts, to mentally deduce different\ntypes for lvalues and rvalues, and to apply the reference collapsing rule after mentally\nrvalue reference type,\nand suppose we instantiate Widget with an lvalue reference type:\ntive as we’d hoped: RvalueRefToT is a typedef for an lvalue reference when Widget\nis instantiated with an lvalue reference type.\nThe final context in which reference collapsing takes place is uses of decltype.\nduring analysis of a type involving decltype, a reference to a reference arises, refer‐\n• Reference collapsing occurs in four contexts: template instantiation, auto type\n• When compilers generate a reference to a reference in a reference collapsing\nences is an lvalue reference, the result is an lvalue reference.\nrvalue reference.\n• Universal references are rvalue references in contexts where type deduction\ndistinguishes lvalues from rvalues and where reference collapsing occurs.",
      "keywords": [
        "Widget",
        "reference",
        "lvalue reference",
        "lvalue",
        "reference collapsing",
        "std",
        "type",
        "type Widget",
        "Item",
        "forward",
        "rvalue",
        "universal references",
        "lvalue reference type",
        "template",
        "universal"
      ],
      "concepts": [
        "reference",
        "refer",
        "std",
        "item",
        "widget",
        "templates",
        "type",
        "collapsing",
        "collapse",
        "auto"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 17,
          "title": "",
          "score": 0.69,
          "base_score": 0.69,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 10,
          "title": "",
          "score": 0.641,
          "base_score": 0.641,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 4,
          "title": "",
          "score": 0.64,
          "base_score": 0.64,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 8,
          "title": "",
          "score": 0.618,
          "base_score": 0.618,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 7,
          "title": "",
          "score": 0.593,
          "base_score": 0.593,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "reference",
          "lvalue",
          "reference collapsing",
          "lvalue reference",
          "collapsing"
        ],
        "semantic": [],
        "merged": [
          "reference",
          "lvalue",
          "reference collapsing",
          "lvalue reference",
          "collapsing"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4865177348530411,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:02:16.726175+00:00"
      }
    },
    {
      "chapter_number": 21,
      "title": "Segment 21 (pages 223-230)",
      "start_page": 223,
      "end_page": 230,
      "summary": "where moving is faster than copying, moving a std::array of Widget will be faster\nYet both moving and copying a std::array have linear-time computational com‐\nOn the other hand, std::string offers constant-time moves and linear-time copies.\nThat makes it sound like moving is faster than copying, but that may not be the case.\n• In code with known types or support for move semantics, there is no need for\nbeing forwarded to) to receive the same objects that the first function (the one doing\nLet’s assume we have some function f, and we’d like to write a function (in truth, a\nfunction template) that forwards to it.\nf(std::forward<T>(param));         // forward it to f\naccepts any type of argument, and it forwards whatever it gets.\nthis genericity is for forwarding functions to be not just templates, but variadic tem‐\nf(std::forward<Ts>(params)...);    // forward them to f\nGiven our target function f and our forwarding function fwd, perfect forwarding fails\nif calling f with a particular argument does one thing, but calling fwd with the same\n// to perfectly forward expression to f\nSuppose f is declared like this:\nvoid f(const std::vector<int>& v);\nIn that case, calling f with a braced initializer compiles,\nbut passing the same braced initializer to fwd doesn’t compile:\nThat’s because the use of a braced initializer is a perfect forwarding failure case.\n3 })), compilers see the arguments passed at the call site, and they see the types of the\nparameters declared by f.\nrary std::vector<int> object from { 1, 2, 3 } so that f’s parameter v has a\nWhen calling f indirectly through the forwarding function template fwd, compilers\nno longer compare the arguments passed at fwd’s call site to the parameter declara‐\nInstead, they deduce the types of the arguments being passed to fwd, and\nthey compare the deduced types to f’s parameter declarations.\n• Compilers are unable to deduce a type for one or more of fwd’s parameters.\nthis case, the code fails to compile.\n• Compilers deduce the “wrong” type for one or more of fwd’s parameters.\n“wrong” could mean that fwd’s instantiation won’t compile with the types that\nwere deduced, but it could also mean that the call to f using fwd’s deduced types\nbehaves differently from a direct call to f with the arguments that were passed to\nfunction name, and, due to “incorrect” type deduction, the overload of f called\ninside fwd were different from the overload that would be invoked if f were\nto a function template parameter that’s not declared to be a std::initial\nexpression { 1, 2, 3 } in the call to fwd, because fwd’s parameter isn’t declared to be\nBeing prevented from deducing a type for fwd’s parame‐\nforwarding function should deduce is a std::initializer_list—declare a local\nvariable using auto, then pass the local variable to the forwarding function:\nfwd(il);                   // fine, perfect-forwards il to f\nItem 8 explains that when you try to pass 0 or NULL as a null pointer to a template,\npointer type for the argument you pass.\nperfect-forwarded as a null pointer.\nstatic const std::size_t MinVals = 28; // MinVals' declaration\nWith that in mind, imagine that f (the function fwd forwards its argument to) is\nCalling f with MinVals is fine, because compilers will just replace MinVals with its\nf(Widget::MinVals);         // fine, treated as \"f(28)\"\nAlas, things may not go so smoothly if we try to call f through fwd:\nfwd(Widget::MinVals);       // error!\nAlthough nothing in the source code takes MinVals’ address, fwd’s parameter is a\nPassing integral static const data members by reference, then, generally requires\nthat they be defined, and that requirement can cause code using perfect forwarding to\nfail where the equivalent code without perfect forwarding succeeds.\ndepending on your compilers and linkers, you may find that you can perfect-forward\nSuppose our function f (the one we keep wanting to forward arguments to via fwd)\nAssuming this function takes and returns ints, f could be declared like this:\nvoid f(int (*pf)(int));         // pf = \"processing function\"\nIt’s worth noting that f could also be declared using a simpler non-pointer syntax.\nWe can pass processVal to f,\nf(processVal);                  // fine\nf demands a pointer to a function as its\nargument, but processVal isn’t a function pointer or even a function, it’s the name\nthe one matching f’s parameter type.\nint, and they pass that function’s address to f.\nWhat makes this work is that f’s declaration lets compilers figure out which version\nfwd, however, being a function template, doesn’t have any\ninformation about what type it needs, and that makes it impossible for compilers to\nwithout type deduction, we’re left with another perfect forwarding failure case.\nThe way to get a perfect-forwarding function like fwd to accept an overloaded func‐\nsame type as f’s parameter, initialize that pointer with processVal or workOnVal\ntiation of workOnVal to be generated), and pass the pointer to fwd:",
      "keywords": [
        "move",
        "fwd",
        "move operations",
        "function",
        "Item",
        "std",
        "type",
        "perfect forwarding",
        "forwarding",
        "n’t",
        "MinVals",
        "operations",
        "int",
        "code",
        "compilers"
      ],
      "concepts": [
        "forwarded",
        "item",
        "function",
        "functions",
        "pointers",
        "std",
        "type",
        "compilers",
        "compiles",
        "copying"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 17,
          "title": "",
          "score": 0.799,
          "base_score": 0.649,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 18,
          "title": "",
          "score": 0.783,
          "base_score": 0.633,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 29,
          "title": "",
          "score": 0.749,
          "base_score": 0.599,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 28,
          "title": "",
          "score": 0.737,
          "base_score": 0.587,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 30,
          "title": "",
          "score": 0.56,
          "base_score": 0.41,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "fwd",
          "forwarding",
          "minvals",
          "perfect",
          "function"
        ],
        "semantic": [],
        "merged": [
          "fwd",
          "forwarding",
          "minvals",
          "perfect",
          "function"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4314507708246544,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.726216+00:00"
      }
    },
    {
      "chapter_number": 22,
      "title": "Segment 22 (pages 231-241)",
      "start_page": 231,
      "end_page": 241,
      "summary": "the bitfield’s value.\nfunction obviously receives a copy of the value in the bitfield, and it turns out that in\nactually bind to a copy of the bitfield’s value that’s stored in an object of some stan‐\nto “normal” objects into which the values of the bitfields have been copied.\nbitfield’s value.\n// copy bitfield value; see Item 6 for info on init.\nBut lambdas are such a convenient way to create function objects, the impact on day-\n• A closure is the runtime object created by a lambda.\nmode, closures hold copies of or references to the captured data.\nA lambda is often used to create a closure that’s used only as an argument to a func‐\n// by the lambda\nc1, c2, and c3 are all copies of the closure produced by the lambda.\nInformally, it’s perfectly acceptable to blur the lines between lambdas, closures, and\nexists during compilation (lambdas and closure classes), what exists at runtime (clo‐\nItem 31: Avoid default capture modes.\nThere are two default capture modes in C++11: by-reference and by-value.\nDefault by-value capture lures\nreference capture.\nA by-reference capture causes a closure to contain a reference to a local variable or to\nof a closure created from that lambda exceeds the lifetime of the local variable or\ncontainer of filtering functions, each of which takes an int and returns a bool indi‐\nstd::vector<std::function<bool(int)>>;    // \"using\", Item 2\n[&](int value) { return value % divisor == 0; }  // ref to\nThe lambda refers to the local variable\nimmediately after filters.emplace_back returns, so the function that’s added to\nNow, the same problem would exist if divisor’s by-reference capture were explicit,\n[&divisor](int value)                // danger!\n{ return value % divisor == 0; }     // divisor will\nbut with an explicit capture, it’s easier to see that the viability of the lambda is depen‐\nensure that divisor lives at least as long as the lambda’s closures.\nthe local variables and parameters in the environment where its lambda is created.\navoid a default by-reference capture mode.\nFor example, our filtering lambda might\nif (std::all_of(                              // if all values\n{ return value % divisor == 0; })       // of divisor...\nIf the lambda were found\nBy the way, the ability to use auto in C++14 lambda parameter specifications means\n[&](const auto& value)                // C++14\n{ return value % divisor == 0; }))\nOne way to solve our problem with divisor would be a default by-value capture\nThat is, we could add the lambda to filters as follows:\n[=](int value) { return value % divisor == 0; }     // divisor\nThis suffices for this example, but, in general, default by-value capture isn’t the anti-\nvalue, you copy the pointer into the closures arising from the lambda, but you don’t\nprevent code outside the lambda from deleteing the pointer and causing your\nint divisor;                       // used in Widget's filter\n[=](int value) { return value % divisor == 0; }\ndivisor, but the default by-value capture mode ensures that divisor is copied into\nif the default capture mode is eliminated, the code won’t compile:\n[](int value) { return value % divisor == 0; }  // divisor\nFurthermore, if an attempt is made to explicitly capture divisor (either by value or\n[divisor](int value)                // error!\n{ return value % divisor == 0; }    // divisor to capture\nSo if the default by-value capture clause isn’t capturing divisor, yet without the\ndefault by-value capture clause, the code won’t compile, what’s going on?\nWidget::addFilter with a default by-value capture,\n[=](int value) { return value % divisor == 0; }\nwhat’s being captured is the Widget’s this pointer, not divisor.\n{ return value % currentObjectPtr->divisor == 0; }\narising from this lambda is tied to the lifetime of the Widget whose this pointer they\nobject produced by std::make_unique, i.e., a filter that contains a copy of a pointer\nauto divisorCopy = divisor;                // copy data member\n[divisorCopy](int value)                 // capture the copy\n{ return value % divisorCopy == 0; }     // use the copy\nTo be honest, if you take this approach, default by-value capture will work, too,\nauto divisorCopy = divisor;                // copy data member\n[=](int value)                           // capture the copy\n{ return value % divisorCopy == 0; }     // use the copy\nIn C++14, a better way to capture a data member is to use generalized lambda cap‐\n[divisor = divisor](int value)    // copy divisor to closure\n{ return value % divisor == 0; }  // use the copy\nThere’s no such thing as a default capture mode for a generalized lambda capture,\nAn additional drawback to default by-value captures is that they can suggest that the\non local variables and parameters (which may be captured), but also on objects with\nlambdas, but they can’t be captured.\nYet specification of a default by-value capture\n[=](int value)                     // captures nothing!\n{ return value % divisor == 0; }   // refers to above static\nthe lambda makes a copy of all the objects it uses and is therefore self-contained.” But\nThis lambda doesn’t use any non-static local variables, so\nRather, the code for the lambda refers to the static variable\nincremented, any lambdas that have been added to filters via this function will\ning, this lambda captures divisor by reference, a direct contradiction to what the\ndefault by-value capture clause seems to imply.\nvalue capture clauses, you eliminate the risk of your code being misread in this way.\n• Default by-reference capture can lead to dangling references.\n• Default by-value capture is susceptible to dangling pointers (especially this),",
      "keywords": [
        "divisor",
        "Default by-value capture",
        "Widget",
        "Lambda",
        "capture",
        "Item",
        "std",
        "void Widget",
        "copy",
        "function",
        "default",
        "by-value capture",
        "Default by-value",
        "closure",
        "int"
      ],
      "concepts": [
        "functions",
        "lambda",
        "divisor",
        "std",
        "capture",
        "captured",
        "value",
        "auto",
        "void",
        "filtering"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 23,
          "title": "",
          "score": 0.619,
          "base_score": 0.619,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 24,
          "title": "",
          "score": 0.604,
          "base_score": 0.454,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 28,
          "title": "",
          "score": 0.513,
          "base_score": 0.513,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 12,
          "title": "",
          "score": 0.475,
          "base_score": 0.475,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 29,
          "title": "",
          "score": 0.47,
          "base_score": 0.47,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "divisor",
          "value",
          "capture",
          "value capture",
          "default value"
        ],
        "semantic": [],
        "merged": [
          "divisor",
          "value",
          "capture",
          "value capture",
          "default value"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3872988035111675,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.726252+00:00"
      }
    },
    {
      "chapter_number": 23,
      "title": "Segment 23 (pages 242-249)",
      "start_page": 242,
      "end_page": 249,
      "summary": "Item 32: Use init capture to move objects into closures.\n1. the name of a data member in the closure class generated from the lambda and\nHere’s how you can use init capture to move a std::unique_ptr into a closure:\nauto pw = std::make_unique<Widget>();   // create Widget; see\nauto func = [pw = std::move(pw)]               // init data mbr\nname pw on the left of the “=” refers to a data member in the closure class, while the\nname pw on the right refers to the object declared above the lambda, i.e., the variable\nAs usual, code in the body of the lambda is in the scope of the closure class, so uses of\npw there refer to the closure class data member.\ncaptured by the lambda, the local variable pw is unnecessary, because the closure\nclass’s data member can be directly initialized by std::make_unique:\nauto func = [pw = std::make_unique<Widget>()]  // init data mbr\nauto func = IsValAndArch(std::make_unique<Widget>());\nstd::bind and\nstd::vector<double> data;                 // object to be moved\nauto func = [data = std::move(data)]      // C++14 init capture\n(std::vector<double>), the name of that object (data), and the initializing expres‐\nsion for the init capture (std::move(data)).\nstd::bind(                              // C++11 emulation\n[](const std::vector<double>& data)   // of init capture\nstd::move(data)\nLike lambda expressions, std::bind produces function objects.\nobjects returned by std::bind bind objects.\nThe first argument to std::bind is a\nA bind object contains copies of all the arguments passed to std::bind.\n(the result of std::move—see Item 23), so data is move constructed into the bind\nrvalue into a C++11 closure.\nments it stores are passed to the callable object originally passed to std::bind.\nconstructed copy of data inside func is passed as an argument to the lambda that\nwas passed to std::bind.\nThis lambda is the same as the lambda we’d use in C++14, except a parameter, data,\nis an lvalue reference to the copy of data in the bind object.\nstd::bind(                               // C++11 emulation\n[](std::vector<double>& data) mutable  // of init capture\nstd::move(data)\nBecause a bind object stores copies of all the arguments passed to std::bind, the\nbind object in our example contains a copy of the closure produced by the lambda\n• It’s not possible to move-construct an object into a C++11 closure, but it is possi‐\n• Emulating move-capture in C++11 consists of move-constructing an object into\na bind object, then passing the move-constructed object to the lambda by refer‐\nAs a second example of using std::bind to emulate move capture, here’s the C++14\nauto func = [pw = std::make_unique<Widget>()]    // as before,\nauto func = std::bind(\n[](const std::unique_ptr<Widget>& pw)\nC++11 lambdas, because in Item 34, I advocate the use of lambdas over std::bind.\nHowever, that Item explains that there are some cases in C++11 where std::bind\n• Use C++14’s init capture to move objects into closures.\n• In C++11, emulate init capture via hand-written classes or std::bind.\nstd::forward them.\nforward: operator() in the lambda’s closure class is a template.\nIn this example, the only thing the lambda does with its parameter x is forward it to\nence (see Item 24), and second, it has to be passed to normalize via std::forward\n{ return func(normalize(std::forward<???>(x))); };\na type parameter T, so you just write std::forward<T>.\nwas passed in, decltype(x) will produce a type that’s an lvalue reference.\nBut look at the sample C++14 implementation for std::forward from Item 28:\nT&& forward(remove_reference_t<T>& param)    // std\nates std::forward with the type Widget (i.e, a non-reference type), and the\n{                                          // std::forward when\ncollapsing (once again, see Item 28), std::forward would look like this:\n{                                          // std::forward when\n{                                          // std::forward when\nating std::forward with an rvalue reference type yields the same result as instantiat‐\nan rvalue is passed as an argument to our lambda’s parameter x.\nary type to pass to std::forward, and now we realize that for rvalues, decltype(x)\nyields a type to pass to std::forward that’s not conventional, but that nevertheless\npassing decltype(x) to std::forward gives us the result we want.\nfunc(normalize(std::forward<decltype(param)>(param)));",
      "keywords": [
        "std",
        "Widget",
        "bind object",
        "lambda",
        "object",
        "bind",
        "data",
        "Item",
        "closure",
        "capture",
        "move",
        "init capture",
        "closure class",
        "rvalue",
        "forward"
      ],
      "concepts": [
        "std",
        "captures",
        "captured",
        "objects",
        "item",
        "refers",
        "reference",
        "data",
        "widget",
        "uses"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 15,
          "title": "",
          "score": 0.732,
          "base_score": 0.582,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "",
          "score": 0.716,
          "base_score": 0.566,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 26,
          "title": "",
          "score": 0.671,
          "base_score": 0.521,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 13,
          "title": "",
          "score": 0.671,
          "base_score": 0.521,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 14,
          "title": "",
          "score": 0.661,
          "base_score": 0.511,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "bind",
          "std",
          "std bind",
          "forward",
          "closure"
        ],
        "semantic": [],
        "merged": [
          "bind",
          "std",
          "std bind",
          "forward",
          "closure"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.44532485465852917,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.726300+00:00"
      }
    },
    {
      "chapter_number": 24,
      "title": "Segment 24 (pages 250-258)",
      "start_page": 250,
      "end_page": 258,
      "summary": "Item 34: Prefer lambdas to std::bind.\nstd::bind is the C++11 successor to C++98’s std::bind1st and std::bind2nd,\nstd::tr1::bind, not std::bind, and a few interface details were different.) This\nstd::bind.\nC++11, lambdas are almost always a better choice than std::bind.\nThis Item assumes that you’re familiar with std::bind.\nstd::bind in a code base you have to read or maintain.\nAs in Item 32, I refer to the function objects returned from std::bind as bind\nThe most important reason to prefer lambdas over std::bind is that lambdas are\nOur first attempt to write the corresponding std::bind call is below.\nstd::bind(setAlarm,\ninvokes setAlarm with the time and duration specified in the call to std::bind.\nstd::bind parameter list in order to understand that the first argument in a call to\nis not identified in the call to std::bind, so readers have to consult the setAlarm\nIn the std::bind call, however, “steady_clock::now() + 1h”\nis passed as an argument to std::bind, not to setAlarm.\nexpression will be evaluated when std::bind is called, and the time resulting from\nalarm will be set to go off an hour after the call to std::bind, not an hour after the\nFixing the problem requires telling std::bind to defer evaluation of the expression\nuntil setAlarm is called, and the way to do that is to nest a second call to std::bind\nstd::bind(setAlarm,\nstd::bind(std::plus<>(), steady_clock::now(), 1h),\nC++11 offers no such feature, so the C++11 std::bind\nstd::bind(setAlarm,\nstd::bind(std::plus<steady_clock::time_point>(),\nThe std::bind call, on the other hand, now fails to compile:\nstd::bind(setAlarm,                          // setAlarm?\nstd::bind(std::plus<>(),\nfunctions they should pass to std::bind.\nTo get the std::bind call to compile, setAlarm must be cast to the proper function\nstd::bind(static_cast<SetAlarm3ParamType>(setAlarm),  // okay\nstd::bind(std::plus<>(),\nBut this brings up another difference between lambdas and std::bind.\nThe call to std::bind, however, passes a function pointer to setAlarm, and that\noperator for the bind object), the call to setAlarm takes place through a function\nIt’s thus possible that using lambdas generates faster code than using std::bind.\nstd::bind can express the same thing, but the construct is an example of job secu‐\nstd::bind(std::logical_and<>(),            // C++14\nstd::bind(std::less_equal<>(), lowVal, _1),\nstd::bind(std::less_equal<>(), _1, highVal));\nIn C++11, we’d have to specify the types we wanted to compare, and the std::bind\nstd::bind(std::logical_and<bool>(),\nstd::bind(std::less_equal<int>(), lowVal, _1),\nstd::bind(std::less_equal<int>(), _1, highVal));\nEarlier, I remarked that for those with little std::bind experience, its placeholders\nThis use of std::bind will create such an object:\n1 std::bind always copies its arguments, but callers can achieve the effect of having an argument stored by\nauto compressRateB = std::bind(compress, std::ref(w), _1);\nauto compressRateB = std::bind(compress, w, _1);\nNow, when we pass w to std::bind, it has to be stored for the later call to compress.\nIt makes a difference, because if w is modified between the call to std::bind\nhow std::bind works; there’s no sign of it in the call to std::bind.\nBut in the call to the object resulting from std::bind, how is the argument passed?\nAgain, the only way to know is to memorize how std::bind works.\nCompared to lambdas, then, code using std::bind is less readable, less expressive,\nstd::bind.\nIn C++11, however, std::bind can be justified in two constrained situa‐\nthrough a combination of a lambda and std::bind.\nyou want to bind an object with a templatized function call operator.\nstd::bind can bind a PolyWidget as follows:\nauto boundPW = std::bind(pw, _1);\nThe addition of lambda support to C++11 rendered std::bind\nusing std::bind.\n• In C++11 only, std::bind may be useful for implementing move capture or\nfor binding objects with templatized function call operators.",
      "keywords": [
        "std",
        "bind",
        "call",
        "setAlarm",
        "namespace std",
        "Item",
        "auto",
        "function call",
        "lambda",
        "function",
        "Sound",
        "function call operator",
        "bind call",
        "call operator",
        "time"
      ],
      "concepts": [
        "std",
        "auto",
        "bind",
        "lambdas",
        "functions",
        "item",
        "code",
        "compressed",
        "compression",
        "uses"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 22,
          "title": "",
          "score": 0.604,
          "base_score": 0.454,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 3,
          "title": "",
          "score": 0.47,
          "base_score": 0.47,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 10,
          "title": "",
          "score": 0.403,
          "base_score": 0.403,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 18,
          "title": "",
          "score": 0.397,
          "base_score": 0.397,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 21,
          "title": "",
          "score": 0.382,
          "base_score": 0.382,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "std bind",
          "bind",
          "std",
          "bind std",
          "setalarm"
        ],
        "semantic": [],
        "merged": [
          "std bind",
          "bind",
          "std",
          "bind std",
          "setalarm"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3240253089049851,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.726331+00:00"
      }
    },
    {
      "chapter_number": 25,
      "title": "Segment 25 (pages 259-270)",
      "start_page": 259,
      "end_page": 270,
      "summary": "dard Library (tasks, futures, threads, mutexes, condition variables, atomic objects,\nItem 35: Prefer task-based programming to thread-\nYou can create a std::thread and run doAsyncWork on it, thus employing\nstd::thread t(doAsyncWork);\nOr you can pass doAsyncWork to std::async, a strategy known as task-based:\nauto fut = std::async(doAsyncWork);        // \"fut\" for \"future\"\nIn such calls, the function object passed to std::async (e.g., doAsyncWork) is con‐\nbecause the future returned from std::async offers the get function.\nWith the thread-based approach, if doAsyncWork throws, the\nA more fundamental difference between thread-based and task-based programming\ntion on hardware threads.\nIt’s typically possible to create more software threads\n• std::threads are objects in a C++ process that act as handles to underlying\nsoftware threads.\nSome std::thread objects represent “null” handles, i.e., corre‐\nstd::thread then acts as the handle to the underlying software thread), have\nstd::thread t(doAsyncWork);          // throws if no more\noption is to wait for some existing software threads to complete and then try to create\na new std::thread again, but it’s possible that the existing threads are waiting for an\nEven if you don’t run out of threads, you can have trouble with oversubscription.\nThat’s when there are more ready-to-run (i.e., unblocked) software threads than\nhardware threads.\nauto fut = std::async(doAsyncWork);   // onus of thread mgmt is\nprovide, why does it matter whether I do it by creating std::threads or by calling\nsoftware thread.\n(in this example, doAsyncWork) to be run on the thread requesting doAsyncWork’s\nresult (i.e., on the thread calling get or wait on fut), and reasonable schedulers take\nWith std::async, responsiveness on a GUI thread can still be problematic, because\nThe C++ Standard does not require the use of thread pools or\non the other hand, you program directly with std::threads, you assume the burden\nimplementation, std::thread objects typically offer the native_handle mem‐\nfor what std::async returns).\n• You need to implement threading technology beyond the C++ concurrency\nAPI, e.g., thread pools on platforms where your C++ implementations don’t\n• The std::thread API offers no direct way to get return values from asyn‐\n• Task-based programming via std::async with the default launch policy han‐\nItem 36: Specify std::launch::async if\nWhen you call std::async to execute a function (or other callable object), you’re\nrun in accord with a std::async launch policy.\nstd::async to which f was passed is likely to be different from the one returned by std::async.\nfuture returned from std::async.\ninformation on scoped enums.) Assuming a function f is passed to std::async for\n• The std::launch::async launch policy means that f must be run asynchro‐\n• The std::launch::deferred launch policy means that f may run only when\nget or wait is called on the future returned by std::async.2 That is, f’s execu‐\nauto fut1 = std::async(f);                     // run f using\nauto fut2 = std::async(std::launch::async |    // run f either\nstd::launch::deferred,  // async or\nAs Item 35 points out, this flexibility permits std::async and the thread-\namong the things that make concurrent programming with std::async so conve‐\nauto fut = std::async(f);   // run f using default launch policy\n• It’s not possible to predict whether f runs on a thread different from the\nthread invoking get or wait on fut.\nit’s not possible to predict whether f runs on a thread different from t.\nauto fut = std::async(f);        // TLS for f possibly for\n// possibly for thread\nstd::this_thread::sleep_for(1s);\nauto fut = std::async(f);             // run f asynchronously\nIf f runs concurrently with the thread calling std::async (i.e., if the launch policy\nchosen for f is std::launch::async), there’s no problem here (assuming f\neventually finishes), but if f is deferred, fut.wait_for will always return std::\nmachine towards oversubscription or thread exhaustion, and that’s when a task may\nauto fut = std::async(f);                  // as above\n• The task need not run concurrently with the thread calling get or wait.\nby std::async or it’s acceptable that the task may never execute.\nstd::async will schedule the task for truly asynchronous execution.\nauto fut = std::async(std::launch::async, f);  // launch f\nIn fact, having a function that acts like std::async, but that automatically uses\nreturn std::async(std::launch::async,  // call to f(params...)\nLike std::async, it returns a std::future for the result of\nreturn std::async(std::launch::async,\n• The default launch policy for std::async permits both asynchronous and\n• Specify std::launch::async if asynchronous task execution is essential.\nItem 37: Make std::threads unjoinable on all paths.\nEvery std::thread object is in one of two states: joinable or unjoinable.\nstd::thread corresponds to an underlying asynchronous thread of execution that is\nA std::thread corresponding to an underlying thread that’s\nstd::thread objects cor‐\nAn unjoinable std::thread is what you’d expect: a std::thread that’s not joinable.\nUnjoinable std::thread objects include:\n• Default-constructed std::threads.\nSuch std::threads have no function to\n• std::thread objects that have been moved from.\nthe underlying thread of execution a std::thread used to correspond to (if any)\nnow corresponds to a different std::thread.\n• std::threads that have been joined.\nAfter a join, the std::thread object no\n• std::threads that have been detached.\nbetween a std::thread object and the underlying thread of execution it corre‐\nOne reason a std::thread’s joinability is important is that if the destructor for a\njoinable thread is invoked, execution of the program is terminated.\nthrough the std::thread API; the task-based API (i.e., futures) doesn’t provide it.\nOur approach will therefore be based on threads, not tasks.\nstd::thread t([&filter, maxVal, &goodVals]  // populate\nreturns false or throws an exception, the std::thread object t will be joinable\nYou might wonder why the std::thread destructor behaves this way.\nIn this case, a std::thread’s destructor would wait for its\nIn this case, a std::thread’s destructor would sever the\nconnection between the std::thread object and its underlying thread of execu‐\nThe underlying thread would continue to run.",
      "keywords": [
        "std",
        "thread",
        "async",
        "Item",
        "Software threads",
        "launch",
        "run",
        "software",
        "launch policy",
        "Hardware threads",
        "underlying thread",
        "function",
        "wait",
        "future",
        "doAsyncWork"
      ],
      "concepts": [
        "threading",
        "std",
        "items",
        "based",
        "function",
        "functionality",
        "run",
        "running",
        "runs",
        "auto"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 26,
          "title": "",
          "score": 0.726,
          "base_score": 0.576,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 27,
          "title": "",
          "score": 0.717,
          "base_score": 0.567,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 23,
          "title": "",
          "score": 0.507,
          "base_score": 0.357,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "",
          "score": 0.502,
          "base_score": 0.352,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 15,
          "title": "",
          "score": 0.501,
          "base_score": 0.351,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "async",
          "thread",
          "std async",
          "std",
          "std thread"
        ],
        "semantic": [],
        "merged": [
          "async",
          "thread",
          "std async",
          "std",
          "std thread"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.33709748376597387,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.726363+00:00"
      }
    },
    {
      "chapter_number": 26,
      "title": "Segment 26 (pages 271-286)",
      "start_page": 271,
      "end_page": 286,
      "summary": "This puts the onus on you to ensure that if you use a std::thread object, it’s made\nthe object it points to, and the destructors in std::shared_ptr and std::weak_ptr\ndecrement reference counts), std::fstream objects (their destructors close the files\nstd::thread objects, perhaps because the Standardization Committee, having rejec‐\ndRAII object (an RAII object for a std::thread) is destroyed:\nThreadRAII(std::thread&& t, DtorAction a)  // in dtor, take\nstd::thread& get() { return t; }           // see below\nstd::thread t;\n• The constructor accepts only std::thread rvalues, because we want to move the\npassed-in std::thread into the ThreadRAII object.\n(Recall that std::thread\n(specifying the std::thread first and the destructor action second makes more\nThat order puts the std::thread object\nstd::thread objects may start running a function immediately after they are\nnously running thread that corresponds to the std::thread data member.\nstd::thread object.\nviding get avoids the need for ThreadRAII to replicate the full std::thread\nwhere std::thread objects are required.\nstd::thread object t, it checks to make sure that t is joinable.\nIt’s possible that a client constructed a std::thread, created a\nA std::thread object can change\ninvoked, no other thread should be making member function calls on that object.\nstd::thread([&filter, maxVal, &goodVals]\nIn this case, we’ve chosen to do a join on the asynchronously running thread in the\ntermination (which use of a raw std::thread would yield), or performance anoma‐\nstd::thread destruction can sometimes lead not just to a performance anomaly, but\nThreadRAII(std::thread&& t, DtorAction a)         // as before\n: action(a), t(std::move(t)) {}\nstd::thread& get() { return t; }                  // as before\nstd::thread t;\n• Make std::threads unjoinable on all paths.\n• Declare std::thread objects last in lists of data members.\nItem 37 explains that a joinable std::thread corresponds to an underlying system\nA future for a non-deferred task (see Item 36) has a similar rela‐\nAs such, both std::thread objects and future objects\nFrom this perspective, it’s interesting that std::threads and futures have such dif‐\nstd::thread terminates your program, because the two obvious alternatives—an\nnel (typically via a std::promise object), and the caller reads that result using a\na std::future may be used to create a std::shared_future (thus transferring\nownership of the callee’s result from the std::future to the std::shared_future),\nwhich may then be copied many times after the original std::future is destroyed.\n• The destructor for the last future referring to a shared state for a non-\ndeferred task launched via std::async blocks until the task completes.\nessence, the destructor for such a future does an implicit join on the thread on\n• The destructor for all other futures simply destroys the future object.\nFor deferred tasks for which this is the final future, it means that the\na future’s destructor destroys the future object.\nto it and the callee’s std::promise.\n• It refers to a shared state that was created due to a call to std::async.\n• The task’s launch policy is std::launch::async (see Item 36), either because\nFor std::futures,\nFor std::shared_futures, if other std::shared_\ncial behavior, and that behavior is to block until the asynchronously running task\nrunning the std::async-created task.\ncial rule for shared states for non-deferred tasks that are launched by std::async”\nstate arising from a call to std::async, so given an arbitrary future object, it’s not\n// deferred task launched via std::async\nstd::vector<std::future<void>> futs;   // see Item 39 for info\n// on std::future<void>\nstd::shared_future<double> fut;\nOne is the use of std::packaged_task.\nstd::packaged_task object prepares a function (or other callable object) for asyn‐\nfuture referring to that shared state can then be obtained via std::packaged_task’s\nstd::packaged_task<int()>             // wrap calcValue so it\nAt this point, we know that the future fut doesn’t refer to a shared state created by a\nOnce created, the std::packaged_task pt can be run on a thread.\nvia a call to std::async, too, but if you want to run a task using std::async, there’s\nlittle reason to create a std::packaged_task, because std::async does everything\nstd::packaged_task does before it schedules the task for execution.)\nstd::packaged_tasks aren’t copyable, so when pt is passed to the std::thread\nstd::thread t(std::move(pt));         // run pt on t\nstd::packaged_task<int()>\nstd::thread t(std::move(pt));\nThe most interesting code here is the “…” that follows creation of the std::thread\ndue to a std::packaged_task, there’s usually no need to adopt a special destruction\nthe code that manipulates the std::thread on which the std::packaged_task is\n• Future destructors normally just destroy the future’s data members.\n• The final future referring to a shared state for a non-deferred task launched\nvia std::async blocks until the task completes.\nSometimes it’s useful for a task to tell a second, asynchronously running task that a\nIf we call the task that\ndetects the condition the detecting task and the task reacting to the condition the\nreacting task, the strategy is simple: the reacting task waits on a condition variable,\nstd::condition_variable cv;             // condvar for event\ntask.\nThe code for the reacting task is a bit more complicated, because before calling wait\non the condvar, it must lock a mutex through a std::unique_lock object.\nneed to lock the mutex through a std::unique_lock object is simply part of the\nentirely possible that the detecting and reacting tasks have no need for such media‐\ndata structure, then turning it over to the reacting task for use.\nnever accesses the data structure after initializing it, and if the reacting task never\n• If the detecting task notifies the condvar before the reacting task waits, the\npens to execute the notification before the reacting task executes the wait, the\nreacting task will miss the notification, and it will wait forever.\nThe reacting thread may have\nWhen the detecting thread recognizes the event it’s looking for, it sets\nstd::atomic<bool> flag(false);      // shared flag; see\nflag = true;                        // tell reacting task\nThere’s no need for a mutex, no problem if the detecting task sets the flag before the\ning for the flag to be set, the task is essentially blocked, yet it’s still running.\nit occupies a hardware thread that another task might be able to make use of, it incurs\nbased approach, because a task in a wait call is truly blocked.\nflag = true;                        // tell reacting task\nAnd here’s the reacting task:\nthe reacting task waits before the detecting task notifies, it works in the presence of\ndetecting task communicates with the reacting task in a very curious fashion.\ning the condition variable tells the reacting task that the event it’s been waiting for\nhas probably occurred, but the reacting task must check the flag to be sure.\nthe flag tells the reacting task that the event has definitely occurred, but the detecting\ntask still has to notify the condition variable so that the reacting task will awaken and\ning task wait on a future that’s set by the detecting task.\nthere’s no callee-caller relationship between the detecting and reacting tasks.\nstd::promise and whose receiving end is a future can be used for more than just\nthe reacting task, and the information we’ll convey will be that the event of interest\nThe detecting task has a std::promise object (i.e., the writing\nend of the communications channel), and the reacting task has a corresponding\nWhen the detecting task sees that the event it’s looking for has occurred, it sets\nreacting task waits on its future.\nThat wait blocks the reacting task until the\nNow, both std::promise and futures (i.e., std::future and std::shared_future)\nThe only thing of interest to the reacting task is that its future\nWhat we need for the std::promise and future templates is a type that\nThe detecting task will thus use a std::promise<void>, and the react‐\ning task a std::future<void> or std::shared_future<void>.\nwill set its std::promise<void> when the event of interest occurs, and the reacting\ntask will wait on its future.\nfrom the detecting task, the communications channel will permit the reacting task to\nknow when the detecting task has “written” its void data by calling set_value on its\np.set_value();                      // tell reacting task\nand the reacting task’s code is equally simple:\nwhether the detecting task sets its std::promise before the reacting task waits, and\nproblem.) Like the condvar-based approach, the reacting task is truly blocked after\nFor example, Item 38 explains that between a std::promise\ntions channel between a std::promise and a future is a one-shot mechanism: it can’t\nThe C++ concurrency API offers no way to do those things, but std::thread\nning its thread function), a design using a void future is a reasonable choice.\nstd::thread t([]                   // create thread",
      "keywords": [
        "std",
        "reacting task",
        "task",
        "future",
        "Item",
        "thread",
        "detecting task",
        "reacting",
        "shared state",
        "reacting task waits",
        "shared",
        "object",
        "thread objects",
        "detecting",
        "destructor"
      ],
      "concepts": [
        "std",
        "thread",
        "future",
        "items",
        "task",
        "object",
        "reacting",
        "approach",
        "running",
        "run"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "",
          "score": 0.758,
          "base_score": 0.608,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 14,
          "title": "",
          "score": 0.727,
          "base_score": 0.577,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 25,
          "title": "",
          "score": 0.726,
          "base_score": 0.576,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 13,
          "title": "",
          "score": 0.704,
          "base_score": 0.554,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 27,
          "title": "",
          "score": 0.676,
          "base_score": 0.526,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "task",
          "reacting",
          "reacting task",
          "thread",
          "std"
        ],
        "semantic": [],
        "merged": [
          "task",
          "reacting",
          "reacting task",
          "thread",
          "std"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4145405243512141,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.726396+00:00"
      }
    },
    {
      "chapter_number": 27,
      "title": "Segment 27 (pages 287-297)",
      "start_page": 287,
      "end_page": 297,
      "summary": "std::thread([]\nstd::shared_futures instead of a std::future in the react code.\nstate to the std::shared_future object produced by share, the code nearly writes\nItem 40: Use std::atomic for concurrency, volatile\nthat definitely does belong in this chapter—is the std::atomic template.\nstd::atomic<int>, \nstd::atomic<bool>,\nstd::atomic<Widget*>, etc.) offer operations that are guaranteed to be seen as\natomic by other threads.\nOnce a std::atomic object has been constructed, opera‐\nConsider this code using std::atomic:\nstd::atomic<int> ai(0);    // initialize ai to 0\nstd::cout << ai;           // atomically read ai's value\nDuring execution of these statements, other threads reading ai may see only values\nment, the fact that ai is a std::atomic guarantees only that the read of ai is atomic.\ntime ai’s value is read and operator<< is invoked to write it to the standard output,\ntics of the std::atomic types: once a std::atomic object has been constructed, all\nstd::cout << vi;           // read vi's value\nDuring execution of this code, if other threads are reading the value of vi, they may\nstd::atomic nor protected by a mutex, and that’s the definition of a data race.\nAs a concrete example of how the behavior of std::atomics and volatiles can dif‐\nstd::atomic<int> ac(0);    // \"atomic counter\"\nWhen both threads have finished, ac’s value (i.e., the value of the std::atomic)\n1. Thread 1 reads vc’s value, which is 0.\n2. Thread 2 reads vc’s value, which is still 0.\n3. Thread 1 increments the 0 it read to 1, then writes that value into vc.\n4. Thread 2 increments the 0 it read to 1, then writes that value into vc.\nThe use of RMW operations isn’t the only situation where std::atomics comprise a\ntency model for std::atomic objects that use the syntax shown in this book.\nby using a std::atomic<bool>.\nCode in the task computing the value would look\nstd::atomic<bool> valAvailable(false);\nAs humans reading this code, we know it’s crucial that the assignment to imptValue\nHowever, the use of std::atomics imposes restrictions on how code can be reor‐\nwrite of a std::atomic variable may take place (or appear to other cores to take\nAs a result, declaring valAvailable as std::atomic ensures that our crit‐\nauto y = x;           // read x\ny = x;                // read x again\nthe compiler can optimize the generated code by eliminating the assignment to y,\nauto y = x;           // read x\ny = x;                // read x again\nauto y = x;           // read x\nLest you wonder who’d write code that performs these kinds of redundant reads and\nafter compilers take reasonable-looking source code and perform template instantia‐\nauto y = x;           // read x\nIf x corresponds to, say, the value reported by a temperature sensor, the second read\nThis means that redundant reads of and writes to y can be eliminated.\nexample, compilers must perform both the initialization of and the assignment to y, because x is volatile,\nso the second read of x might yield a different value from the first one.\nauto y = x;           // read x\ny = x;                // read x again (can't be optimized away)\nIn that last piece of code, what is y’s type: int or volatile int?7\ndealing with special memory explains, by the way, why std::atomics are unsuitable\ntions on std::atomics.\nstd::atomic<int> x;\nauto y = x;           // conceptually read x (see below)\nauto y = x;           // conceptually read x (see below)\nstd::atomic:\nThat’s because the copy operations for std::atomic are deleted (see Item 11).\nBecause x is std::atomic, y’s type would be deduced to be std::atomic, too\nI remarked earlier that one of the best things about std::atomics is\nthat all their operations are atomic, but in order for the copy construction of y from x\nto be atomic, compilers would have to generate code to read x and write y in a single\nported for std::atomic types.\nwhich is why the assignment from x to y won’t compile.\nexplicitly declared in std::atomic, so, per the rules for compiler-generated special\nfunctions described in Item 17, std::atomic offers neither move construction nor\nIt’s possible to get the value of x into y, but it requires use of std::atomic’s member\nThe load member function reads a std::atomic’s value\nx, followed by putting x’s value in y, the code must be written like this:\nstd::atomic<int> y(x.load());     // read x\ny.store(x.load());                // read x again\nThis compiles, but the fact that reading x (via x.load()) is a separate function call\nGiven that code, compilers could “optimize” it by storing x’s value in a register\nstd::atomic<int> y(register);     // init y with register value\n• std::atomic is useful for concurrent programming, but not for accessing spe‐\nBecause std::atomic and volatile serve different purposes, they can even be used\nvolatile std::atomic<int> vai;    // operations on vai are\n// atomic and can't be\nAs a final note, some developers prefer to use std::atomic’s load and store mem‐\nstd::atomic, and we’ve already seen that the use of std::atomics prevents\nCalling out loads and stores of std::atomics can therefore help iden‐\nstd::atomic when it should have been.\nbetween std::atomic and volatile.\n• std::atomic is for data accessed from multiple threads without using\n• volatile is for memory where reads and writes should not be optimized",
      "keywords": [
        "std",
        "View From Aris",
        "atomic",
        "Code",
        "Item",
        "read",
        "memory",
        "volatile",
        "Thread",
        "write",
        "compilers",
        "n’t",
        "Thread Suspension",
        "special memory",
        "int"
      ],
      "concepts": [
        "atomic",
        "volatiles",
        "code",
        "value",
        "std",
        "thread",
        "compiled",
        "compile",
        "memory",
        "item"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 25,
          "title": "",
          "score": 0.717,
          "base_score": 0.567,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 26,
          "title": "",
          "score": 0.676,
          "base_score": 0.526,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 14,
          "title": "",
          "score": 0.634,
          "base_score": 0.484,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "",
          "score": 0.619,
          "base_score": 0.469,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 15,
          "title": "",
          "score": 0.568,
          "base_score": 0.418,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "atomic",
          "std atomic",
          "read",
          "std",
          "value"
        ],
        "semantic": [],
        "merged": [
          "atomic",
          "std atomic",
          "read",
          "std",
          "value"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3396922071305465,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.726426+00:00"
      }
    },
    {
      "chapter_number": 28,
      "title": "Segment 28 (pages 298-307)",
      "start_page": 298,
      "end_page": 307,
      "summary": "1 In this Item, to “copy” a parameter generally means to use it as the source of a copy or move operation.\nItem 41: Consider pass by value for copyable parameters\nSome function parameters are intended to be copied.1 For example, a member func‐\ntion addName might copy its parameter into a private container.\nfunction should copy lvalue arguments, but move rvalue arguments:\nvoid addName(const std::string& newName)    // take lvalue;\n{ names.push_back(newName); }               // copy it\nvoid addName(std::string&& newName)         // take rvalue;\n{ names.push_back(std::move(newName)); }    // move it; see\nvoid addName(T&& newName)                     // and rvalues;\n{                                             // copy lvalues,\nnames.push_back(std::forward<T>(newName));  // move rvalues;\nues were copied, rvalues were moved, there was only one function to deal with (in\nFor parameters like newName in functions like addName,\nBefore we discuss why pass-by-value may be a good fit for newName and addName,\nvoid addName(std::string newName)           // take lvalue or\n{ names.push_back(std::move(newName)); }    // rvalue; move it\nTypically, std::move is used with rvalue references, but in this case,\ncaller passed in, so changing newName won’t affect callers and (2) this is the final use\nparameter newName would be created by copy construction.\nName will be copy constructed only for lvalues.\nIn the first call to addName (when name is passed), the parameter newName is initial‐\nnewName is thus copy constructed, just like it would be in C++98.\nIn the second call, newName is initialized with the std::string object resulting from\nrvalue, and newName is therefore move constructed.\nLvalues are thus copied, and rvalues are moved, just like we want.\nvoid addName(const std::string& newName)      // lvalues and\nvoid addName(std::string&& newName)\n{ names.push_back(std::move(newName)); }\n{ names.push_back(std::forward<T>(newName)); }\nvoid addName(std::string newName)\n{ names.push_back(std::move(newName)); }\nw.addName(name);                       // pass lvalue\nw.addName(name + \"Jenne\");             // pass rvalue\n• Overloading: Regardless of whether an lvalue or an rvalue is passed, the caller’s\nIn the lvalue overload, newName is copied into\nstd::forward, lvalue std::string arguments are copied into Widget::names,\nwhile rvalue std::string arguments are moved.\nstd::string arguments is the same as with overloading: one copy for lvalues,\ncause as few as zero std::string copy or move operations to be performed.\ning that callers always pass std::string arguments.\n• Passing by value: Regardless of whether an lvalue or an rvalue is passed, the\nIf an lvalue is passed, this costs a copy\nIf an rvalue is passed, it costs a move construction.\nthe function, newName is unconditionally moved into Widget::names.\nsummary is thus one copy plus one move for lvalues, and two moves for rvalues.\nConsider pass by value for copyable parameters that are cheap to move\n2. Consider pass by value only for copyable parameters.\nstd::make_unique (see Item 21) is passed by rvalue reference to setPtr, where\n3. Pass by value is worth considering only for parameters that are cheap to move.\nis what led to the C++98 rule about avoiding pass by value in the first place!\n4. You should consider pass by value only for parameters that are always copied.\nvoid addName(std::string newName)\nnames.push_back(std::move(newName));\nThis function incurs the cost of constructing and destroying newName, even if\nThat’s because a function can copy a parameter in two ways: via con‐\naddName uses construction: its parameter newName\nis passed to vector::push_back, and inside that function, newName is copy con‐\nusing pass by value incurs the cost of an extra move for both lvalue and rvalue argu‐\ncan be changed, we provide a setter function, changeTo. Using a pass-by-value strat‐\nexplicit Password(std::string pwd)     // pass by value\nvoid changeTo(std::string newPwd)      // pass by value\nstd::string text;                      // text of password\npass by value in the constructor incurs the cost of a std::string move construction\nOurs is that changeTo’s use of assignment to copy the parameter newPwd\nprobably causes that function’s pass-by-value strategy to explode in cost.\nter newPwd is constructed, it’s the std::string copy constructor that’s called.\nvoid changeTo(const std::string& newPwd)      // the overload",
      "keywords": [
        "std",
        "move",
        "string",
        "newName",
        "Item",
        "copy",
        "Widget",
        "class Widget",
        "addName",
        "function",
        "rvalue",
        "lvalue",
        "functions",
        "Password",
        "parameter"
      ],
      "concepts": [
        "std",
        "function",
        "functions",
        "passed",
        "passes",
        "copy",
        "copied",
        "copies",
        "passwords",
        "item"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 29,
          "title": "",
          "score": 0.783,
          "base_score": 0.633,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 17,
          "title": "",
          "score": 0.759,
          "base_score": 0.609,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 18,
          "title": "",
          "score": 0.757,
          "base_score": 0.607,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 21,
          "title": "",
          "score": 0.737,
          "base_score": 0.587,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 30,
          "title": "",
          "score": 0.599,
          "base_score": 0.449,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "newname",
          "addname",
          "pass value",
          "string",
          "std string"
        ],
        "semantic": [],
        "merged": [
          "newname",
          "addname",
          "pass value",
          "string",
          "std string"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4293099822600001,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.726461+00:00"
      }
    },
    {
      "chapter_number": 29,
      "title": "Segment 29 (pages 308-316)",
      "start_page": 308,
      "end_page": 316,
      "summary": "The upshot is that the extra cost of pass by value for functions that copy a parameter\nName called Widget::validateName, and this function also passed by value.\nvalue, unlike pass by reference, is susceptible to the slicing problem.\ndeclare a pass-by-value parameter of that type, because you’ll “slice off” the derived-\nclass characteristics of any derived type object that may be passed in:\nslicing problem is another reason (on top of the efficiency hit) why pass by value has\ncheap-to-move types passed to functions that always copy them and where slicing is\n• For copyable, cheap-to-move parameters that are always copied, pass by value\nIf you have a container holding, say, std::strings, it seems logical that when you\nadd a new element via an insertion function (i.e., insert, push_front, push_back,\nor, for std::forward_list, insert_after), the type of element you’ll pass to the\nfunction will be std::string.\nstd::vector<std::string> vs;         // container of std::string\nHere, the container holds std::strings, but what you have in hand—what you’re\nyou’re passing to push_back is not of the type held by the container.\npush_back for std::vector is overloaded for lvalues and rvalues as follows:\ntype of the parameter taken by push_back (a reference to a std::string).\naddress the mismatch by generating code to create a temporary std::string object\nfrom the string literal, and they pass that temporary object to push_back.\nvs.push_back(std::string(\"xyzzy\"));  // create temp.\nstd::string\nTo create a new element in a container of std::strings, they understand, a\nstd::string constructor is going to have to be called, but the code above doesn’t\nAnd it calls the std::string destruc‐\n1. A temporary std::string object is created from the string literal \"xyzzy\".\nstd::string construction.\n2. temp is passed to the rvalue overload for push_back, where it’s bound to the\nnew object inside the std::vector.\nthe std::vector is the move constructor, because x, being an rvalue reference,\nstring literal and pass it directly to the code in step 2 that constructs the std::string\nobject inside the std::vector, we could avoid constructing and destroying temp.\nemplace_back does exactly what we desire: it uses whatever arguments are passed to\nit to construct a std::string directly inside the std::vector.\nvs.emplace_back(\"xyzzy\");   // construct std::string inside\ncreate a std::string in vs via the std::string constructor taking a character and\nvs.emplace_back(50, 'x');   // insert std::string consisting\nemplace_back is available for every standard container that supports push_back.\nbut std::forward_list and std::array) supports emplace.\niterator, and std::forward_list has emplace_after to match its insert_after.\nWhat makes it possible for emplacement functions to outperform insertion functions\nemplacement functions take constructor arguments for objects to be inserted.\nBecause an argument of the type held by the container can be passed to an emplace‐\nstruction), emplacement can be used even when an insertion function would require\nEmplacement functions can thus do everything insertion functions can.\ntion or emplacement is requested, the exception safety of the contained types’ con‐\nstructors, and, for containers where duplicate values are prohibited (i.e., std::set,\n• The value being added is constructed into the container, not assigned.\nexample that opened this Item (adding a std::string with the value \"xyzzy\" to\na std::vector vs) showed the value being added to the end of vs—to a place\nIf we revise the example such that the new std::string goes\nstd::vector<std::string> vs;         // as before\nFor this code, few implementations will construct the added std::string into\nthe primary advantage of emplacement over insertion is that temporary objects\nNode-based containers virtually always use construction to add new values, and\nnon-node-based containers, you can rely on emplace_back to use construction\ninstead of assignment to get a new value into place, and for std::deque, the\n• The argument type(s) being passed differ from the type held by the container.\nthe argument(s) passed are of a type other than that held by the container.\nan object of type T is to be added to a container<T>, there’s no reason to expect\nis already in the container, emplacement implementations typically create a node\nSuch nodes are created for emplacement functions more often than for\nvs.emplace_back(\"xyzzy\");   // construct new value at end of\n// container; don't pass the type in\ntainer of std::shared_ptr<Widget>s,\nstd::list<std::shared_ptr<Widget>> ptrs;\nItem 21 explains that you should use std::make_shared to create\nptrs.push_back(std::shared_ptr<Widget>(new Widget, killWidget));\nEither way, a temporary std::shared_ptr would be constructed before calling\npush_back’s parameter is a reference to a std::shared_ptr, so there\nhas to be a std::shared_ptr for this parameter to refer to.\nThe creation of the temporary std::shared_ptr is what emplace_back would\n1. In either call above, a temporary std::shared_ptr<Widget> object is construc‐\nstd::shared_ptr referring to the Widget it’s managing, it automatically relea‐\nstd::shared_ptr that was created to manage it (temp).\nThe fact that functions like std::make_shared and std::make_unique\nIn calls to the insertion functions of containers holding resource-managing objects\n(e.g., std::list<std::shared_ptr<Widget>>), the functions’ parameter types gen‐\nIn the emplacement functions,\nstd::shared_ptr<Widget> spw(new Widget,    // create Widget and\nptrs.push_back(std::move(spw));            // add spw as rvalue\nstd::shared_ptr<Widget> spw(new Widget, killWidget);\nptrs.emplace_back(std::move(spw));",
      "keywords": [
        "std",
        "Widget",
        "back",
        "string",
        "Item",
        "push",
        "container",
        "emplacement",
        "functions",
        "object",
        "type",
        "emplacement functions",
        "temporary std",
        "insertion",
        "function"
      ],
      "concepts": [
        "std",
        "emplacement",
        "emplace",
        "passed",
        "string",
        "type",
        "item",
        "widget",
        "classes",
        "insertion"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 28,
          "title": "",
          "score": 0.783,
          "base_score": 0.633,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 17,
          "title": "",
          "score": 0.767,
          "base_score": 0.617,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 21,
          "title": "",
          "score": 0.749,
          "base_score": 0.599,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 18,
          "title": "",
          "score": 0.722,
          "base_score": 0.572,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 10,
          "title": "",
          "score": 0.663,
          "base_score": 0.663,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "std",
          "string",
          "std string",
          "emplacement",
          "push_back"
        ],
        "semantic": [],
        "merged": [
          "std",
          "string",
          "std string",
          "emplacement",
          "push_back"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4642052330583195,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.726496+00:00"
      }
    },
    {
      "chapter_number": 30,
      "title": "Segment 30 (pages 317-324)",
      "start_page": 317,
      "end_page": 324,
      "summary": "porary object of the type held by the container, yet that’s conceptually what spw is,\nemplacement functions are unlikely to outperform insertion functions when you’re\nYou don’t notice the error as you type it, and your compilers accept the code without\nstd::regex r = nullptr;           // error!\nThe curious behavior you’re experiencing stems from the fact that std::regex\nstd::regex upperCaseWord(\"[A-Z]+\");\nunintentionally, the std::regex constructor taking a const char* pointer is\nstd::regex r = nullptr;           // error!\nstd::regex, and the explicitness of that constructor prevents such conversions.\nIn the call to emplace_back, however, we’re not claiming to pass a std::regex\nInstead, we’re passing a constructor argument for a std::regex object.\nthis code:\nstd::regex r(nullptr);           // compiles\nthis code, though it will compile, has undefined behavior.\nThe std::regex construc‐\nstd::regex r1 = nullptr;         // error!\nstd::regex r2(nullptr);          // compiles\nCopy initialization is not permitted\ntions versus the emplacement functions.\nEmplacement functions use direct initializa‐\ncopy initialization, so they can’t.\nregexes.emplace_back(nullptr);  // compiles.\n// use of explicit std::regex\nThe lesson to take away is that when you use an emplacement function, be especially\n• In principle, emplacement functions should sometimes be more efficient than\nconstructed into the container, not assigned; (2) the argument type(s) passed\n• Emplacement functions may perform type conversions that would be rejected\nby insertion functions.\ntemplates and, 60\ntype of, 58\n=delete (see deleted functions)\n\"Adventure\", allusion to, 295\ndefinition of, 63\ndecay, definition of, 15\nstd::initializer_list and, 21\nstd::function for function objects, 39\ndefinition of, 50\nreturn type deduction and, 23\nstd::initializer_lists and, 52-54\nby-reference captures, 217-219\nstd::move and, 283\nby-value parameters, std::move and, 283\nC++03, definition of, 2\nC++11, definition of, 2\nC++14, definition of, 2\ndefinition of, 2\ncallable objects, definition of, 5\nstd::move vs.\nstd::forward, 158\nclass templates, definition of, 5\nclosure class, definition of, 216\ncopies of, 216\ndefinition of, 5, 216\ncode examples (see example classes/templates;\nexample functions/templates)\nconst member functions and thread safety,\nconst propagation, definition of, 210\npointers and type deduction, 14\nconstexpr functions, 98-102\ndefinition of, 128\nstd::shared_ptr and, 129\ncopy elision, definition of, 174\ncopy of an object, definition of, 4\ndefinition of, 3\nfor classes declaring copy operations or\ncustom deleters, definition of, 120\ndangling pointer, definition of, 134\ndeclarations, definition of, 5\ndeep copy, definition of, 154\ndefaulted member functions, 112\nclass template, 5\ncopy of an object, 4\ndefinition, 5\ndeleted function, 75\ndependent type, 64\nfunction argument, 4\nfunction objects, 5\nfunction parameter, 4\njoinable std::thread, 250\nmake function, 139\nmove-only type, 105, 119\ntemplate class, 5\ntemplate function, 5\nunjoinable std::thread, 250\ndeleted functions, 74-79\ndefinition of, 75\nstd::unique_ptr vs.\nstd::shared_ptr, 126, 155\ndependent type, definition of, 64\ndefinition of, 6\nstd::auto_ptr, 118\ndisabled templates, definition of, 189\nemplacement functions, 293-300\nenabled templates, definition of, 189\nstd::get and, 71-73",
      "keywords": [
        "std",
        "definition",
        "functions",
        "regex",
        "type",
        "copy",
        "emplacement functions",
        "function",
        "templates",
        "back",
        "code",
        "Curiously Recurring Template",
        "container",
        "nullptr",
        "adding resource-managing objects"
      ],
      "concepts": [
        "function",
        "std",
        "definition",
        "definitions",
        "type",
        "pointer",
        "templates",
        "object",
        "thread",
        "xiv"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 17,
          "title": "",
          "score": 0.61,
          "base_score": 0.46,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 18,
          "title": "",
          "score": 0.607,
          "base_score": 0.457,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 28,
          "title": "",
          "score": 0.599,
          "base_score": 0.449,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 29,
          "title": "",
          "score": 0.572,
          "base_score": 0.422,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 21,
          "title": "",
          "score": 0.56,
          "base_score": 0.41,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "definition",
          "regex",
          "std regex",
          "std",
          "emplacement"
        ],
        "semantic": [],
        "merged": [
          "definition",
          "regex",
          "std regex",
          "std",
          "emplacement"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.36818623717067794,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.726539+00:00"
      }
    },
    {
      "chapter_number": 31,
      "title": "Segment 31 (pages 325-333)",
      "start_page": 325,
      "end_page": 333,
      "summary": "(see also std::)\nMyAllocList<Wine>, 65\nPoint, 24, 100, 101, 106\nstd::add_lvalue_reference, 66\nstd::get, 257\nstd::pair, 93\nstd::remove_const, 66\nstd::remove_reference, 66\nstd::string, 160\nstd::vector, 24, 166, 292\nstd::vector<bool>, 46\nWidget, 3, 5, 50, 52, 64, 78, 80, 83, 106-108,\n(see also std::)\nstd::add_lvalue_reference, 66\nstd::basic_ios::operator=, 75, 160\nstd::forward, 199-201, 230\nstd::get, 257\nstd::make_shared, 139-147, 171\nstd::move, 158\nstd::remove_const, 66\nstd::remove_reference, 66\nstd::swap, 93\nstd::vector::emplace_back, 167\nstd::vector::operator[], 24, 24\nstd::vector<bool>::operator[], 46\nWidget::operator=, 109, 112, 115, 152-154\nalternatives to std::make_shared, 145-147,\ndefinition of, 4\nexpired std::weak_ptr, 135\nfeminine manifestation of the divine (see\nfunction\narguments, definition of, 4\nobjects, definition of, 5\nparameters, definition of, 4\ngeneralized lambda capture, definition of, 225\ndefinition of, 229\nhardware threads, definition of, 242\nincomplete type, definition of, 148\ndefinition of, 224\norder with std::thread data members, 254\nstd::bind, 236\ninterruptible threads, definition of, 256\njoinability, testing std::threads for, 255\njoinable std::threads\ndefinition of, 250\ndefinition of, 5, 215\nstd::bind, 232-240\nliteral types, definition of, 100\ndefinition of, 139\ndefinition of, 3\nstd::array and, 204\nstd::shared_ptr and, 126\nstd::string and, 205\nmove-only type, definition of, 105, 119\nnon-dependent type, definition of, 64\ntype of, 59\noperator templates, type arguments and, 235\noperator[], return type of, 24, 46\nOS threads, definition of, 242\nforwarding, definition of, 207\nof rvalue reference type, 2\ndefinition of, 4, 157, 207\noverloaded function/template names,\nstd::bind and, 238\ndefinition of, 147\nstd::shared_ptr and, 155-156\nstd::unique_ptr and, 149\nfunctions, 74\nraces, testing for std::thread joinability and, 255\ndefinition of, 253\nfor std::thread objects, 269\nRAII objects, definition of, 253\ndefinition of, 6\nstd::atomic and, 272\nreference count, definition of, 125\ndefinition of, 80\non member functions, 83-85\nRule of Three, definition of, 111\ndefinition of, 2\npassing to std::forward, 231-232\ndefinition of, 67\ndefinition of, 259\ndefinition of, 6, 118\nsoftware threads, definition of, 242\ndefinition of, 109\nmember function templates and, 115\nstd::add_lvalue_reference, 66\nstd::add_lvalue_reference_t, 66\nstd::allocate_shared\nstd::all_of, 218\nstd::array, move operations and, 204\nstd::async, 243\nstd::atomic\nstd::auto_ptr, 118\nstd::basic_ios::operator=, 75\nstd::bind\nstd::cbegin, 88\nstd::cend, 88\nstd::crbegin, 88\nstd::crend, 88\nstd::decay, 190\nstd::enable_if, 189-194\nstd::enable_shared_from_this, 131-132\nstd::false_type, 187\nstd::forward, 161-162, 199-201\nreplacing std::move with, 162\nstd::function, 39-40\nstd::future<void>, 267\nstd::initializer_lists, braced initializers and, 52\nstd::is_base_of, 192\nstd::is_constructible, 195\nstd::is_nothrow_move_constructible, 92\nstd::is_same, 190-191\nstd::launch::async, 246\nstd::launch::deferred, 246\nstd::literals, 233\nstd::make_shared, 139-147, 171\nstd::move, 158-161\nreplacing with std::forward, 162-163\nstd::move_if_noexcept, 92\nstd::nullptr_t, 59\nstd::operator, 160\nstd::operator=, 75\nstd::operator[], 24, 46\nstd::async and, 261\nstd::pair, 93\nstd::plus, 235\nstd::promise, 258\nstd::promise<void>, 267\nstd::rbegin, 88\nstd::ref, 238\nstd::remove_const, 66\nstd::remove_const_t, 66\nstd::remove_reference, 66\nstd::remove_reference_t, 66\nstd::rend, 88\nstd::result_of, 249\nstd::shared_future<void>, 267\nstd::shared_ptr, 125-134\ncreating from std::weak_ptr, 135\nstd::unique_ptr deleters, 155\nstd::weak_ptr, 134\nstd::string, move operations and, 205\nstd::swap, 93\nstd::system_error, 242\nstd::threads\nstd::true_type, 187\nstd::unique_ptr, 118-124\nconversion to std::shared_ptr, 124\nstd::shared_ptr deleters, 155\nstd::vector, 24, 166, 292\nstd::vector constructors, 56\nstd::vector::emplace_back, 167\nstd::vector<bool>, 43-46\nstd::vector<bool>::operator[], 46\nstd::vector<bool>::reference, 43-45\nstd::weak_ptr, 134-139\nconstruction of std::shared_ptr with, 135\nstd::shared_ptr, 134\ndefinition of, 4\nclasses, definition of, 5\nfunctions, definition of, 5\nfor pointer and reference types, 11-14\ntesting std::threads for joinability, 255\nthread-based programming, definition of, 241\ntype arguments, operator templates and, 235\nstd::move and, 169\nunjoinable std::threads, definition of, 250\ndefinition of, 67\nuse with std::atomic, 279\nstd::atomic, 271-279\nWidget, definition of, 3\nZolman, Leor, xiii, xiv",
      "keywords": [
        "std",
        "definition",
        "Widget",
        "xiv",
        "type",
        "reference",
        "move",
        "move operations",
        "functions",
        "operations",
        "operator",
        "universal references",
        "ptr",
        "shared",
        "Base"
      ],
      "concepts": [
        "std",
        "xiv",
        "definition",
        "functions",
        "operator",
        "operations",
        "type",
        "widget",
        "reference",
        "threads"
      ],
      "similar_chapters": [
        {
          "book": "Effective_Modern_C++",
          "chapter": 10,
          "title": "",
          "score": 0.701,
          "base_score": 0.551,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 7,
          "title": "",
          "score": 0.61,
          "base_score": 0.46,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 16,
          "title": "",
          "score": 0.49,
          "base_score": 0.49,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 2,
          "title": "",
          "score": 0.481,
          "base_score": 0.481,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Effective_Modern_C++",
          "chapter": 17,
          "title": "",
          "score": 0.471,
          "base_score": 0.471,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "std",
          "definition",
          "66 std",
          "66",
          "operator"
        ],
        "semantic": [],
        "merged": [
          "std",
          "definition",
          "66 std",
          "66",
          "operator"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.39864684012569385,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:02:16.726573+00:00"
      }
    },
    {
      "chapter_number": 32,
      "title": "Segment 32 (pages 334-334)",
      "start_page": 334,
      "end_page": 334,
      "summary": "The animal on the cover of Effective Modern C++ is a Rose-crowned fruit dove (Ptili‐\nThis species of dove also goes by the names pink-capped fruit dove or\nSwainson’s fruit dove.\ncrowned fruit dove’s diet consists of various fruits like figs (which it swallows whole),\nthe fruit dove.\nThe fruit dove is considered vulnerable in New South Wales due to rainforest clear‐\nthe heading font is Adobe Myriad Condensed; and the code font is Dalton Maag’s",
      "keywords": [
        "fruit dove",
        "Effective",
        "dove",
        "fruit",
        "Effective STL",
        "Author",
        "Rose-crowned fruit dove",
        "Effective Modern",
        "Scott Meyers",
        "Lesser Sunda Islands",
        "Brown University",
        "Adobe Minion Pro",
        "Adobe Myriad Condensed",
        "pink-capped fruit dove",
        "crowned fruit dove"
      ],
      "concepts": [
        "fonts",
        "orange",
        "rainforests",
        "rainforest",
        "effective",
        "cover",
        "scott",
        "evergreen",
        "south",
        "logging"
      ],
      "similar_chapters": [],
      "enriched_keywords": {
        "tfidf": [
          "dove",
          "fruit",
          "fruit dove",
          "crowned fruit",
          "crowned"
        ],
        "semantic": [],
        "merged": [
          "dove",
          "fruit",
          "fruit dove",
          "crowned fruit",
          "crowned"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.14048555786368447,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:02:16.726597+00:00"
      }
    }
  ],
  "total_chapters": 32,
  "enrichment_provenance": {
    "taxonomy_id": "none",
    "taxonomy_version": "none",
    "taxonomy_path": "none",
    "taxonomy_checksum": "sha256:none",
    "source_metadata_file": "Effective_Modern_C++_metadata.json",
    "enrichment_date": "2025-12-17T23:02:16.736455+00:00",
    "enrichment_method": "msep",
    "model_version": "ai-agents-msep-v1",
    "processing_time_ms": 3947.9155850003735,
    "total_similar_chapters": 155
  }
}